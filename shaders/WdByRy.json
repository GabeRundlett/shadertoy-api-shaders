{
    "Shader": {
        "info": {
            "date": "1586821573",
            "description": "Sierpinski triangle",
            "flags": 0,
            "hasliked": 0,
            "id": "WdByRy",
            "likes": 3,
            "name": "Sierpinski_pieces",
            "published": 3,
            "tags": [
                "fractal",
                "sierpinski"
            ],
            "usePreview": 0,
            "username": "elle",
            "viewed": 301
        },
        "renderpass": [
            {
                "code": "float sierpinski(vec3 p)\n{\n    const int iter_cnt = 20;\n    float scale = clamp(sin((iTime - 7.0) * 0.2) + 2.02, 1.0, 2.0);\n    float offset = 1.0;\n    for (int n = 0; n < iter_cnt; n++)\n    {\n       if(p.x + p.y < 0.0) p.xy = -p.yx; // fold 1\n       if(p.x + p.z < 0.0) p.xz = -p.zx; // fold 2\n       if(p.y + p.z < 0.0) p.zy = -p.yz; // fold 3\t\n       p = p * scale - offset * (scale - 1.0);\n    }\n    return (length(p)) * pow(scale, -float(iter_cnt));\n}\n\nvec3 rotate(vec3 p, float angleX, float angleY)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\treturn (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0, 0.0, 1.0);\n\treturn (c.z * mix(vec3(1.0), rgb, c.y));\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn (length(p) - r);\n}\n\nfloat distPlane(vec3 p, vec4 n)\n{\n\treturn (dot(p, n.xyz) + n.w);\n}\n\nbool bgS = false;\nbool bgP = false;\nfloat distanceEstimate(vec3 p)\n{\n\tfloat dSphere = -distSphere(p, 30.0);\t\n\tfloat dFractal = sierpinski(p);\n    float dPlane = distPlane(p, normalize(vec4(-10.0, -10.0, 10.0, 10.1)));\n    bgP = dPlane < dFractal ? true : false;\n    bgS = dSphere < dPlane ? true : false;\n\treturn (min(min(dFractal, dPlane), dSphere));\n}\n\nvec3 getNormal(vec3 pos, float dist)\n{\n    vec2 eps = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n           distanceEstimate(pos + eps.xyy),\n           distanceEstimate(pos + eps.yxy),\n           distanceEstimate(pos + eps.yyx)) - dist);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        float d = distanceEstimate(ro + rd * t);\n        res = min(res, k * d/t);\n        if(res < 0.001)\n            break;\n        t += clamp(d, 0.01, 0.2);\n    }\n    return (clamp(res, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 4.0 * (iMouse.xy / iResolution.xy - 0.5);\n    mouse.x += 2.7;\n    mouse.y -= 0.4;\n    vec3 ro = rotate(vec3(0.0, -0.1, sin((iTime - 7.0) * 0.2) + 2.5), mouse.x, mouse.y);\n    vec3 rd = -rotate(vec3(uv, 1.0), mouse.x, mouse.y);  \n    vec3 light = rotate(vec3(0.7, -0.22, 0.5), mouse.x, mouse.y);\n    vec3 lightColor = vec3(0.9, 1.0, 1.0);\n    vec3 material;\n    vec3 color;\n    float eps = 0.002;\n\tfloat dist;\n\tfor(float n = 0.0; n < 200.0; n++)\n    {\n\t\tdist = distanceEstimate(ro);\n\t\tif(dist < eps)\n\t\t\tbreak;\n\t\tro += rd * dist * 0.5;\n\t}\n\tif(bgS == true)\n\t{ \n        color = vec3(1.0, 1.0, 0.5) * (1.0 + 0.9 * uv.y);\n\t\tfragColor = vec4(color, 1.0);\n\t\treturn;\n\t}\n    if(bgP == true) \n        material = hsv2rgb(vec3(dot(ro, ro) * 0.0001 + 0.52, ro.y, 0.4));\n    else\n        material = hsv2rgb(vec3(dot(ro, ro) * 0.11 + 0.62, 0.98, 1.2));\n\tvec3 norm = getNormal(ro, dist);\n\tvec3 lightDir = normalize(light - rd);   \n\tfloat shadow = softShadow(ro + 0.001 * norm, light, 20.0);\n    float ambient = 0.5;\n\tfloat diff = clamp(dot(light, norm), 0.0, 1.0) * shadow * 2.5;\n\tfloat spec = pow(clamp(dot(norm, lightDir), 0.0, 1.0), 32.0) * shadow * 2.0;\n \tcolor = (lightColor * (ambient + diff + spec) * material);   \n    color = pow(color, 0.9 * lightColor);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}