{
    "Shader": {
        "info": {
            "date": "1598405426",
            "description": "Atmospheric scattering based on Sebastian Lague's tutorial\nhttps://www.youtube.com/watch?v=DxfEbulyFcY",
            "flags": 0,
            "hasliked": 0,
            "id": "WlBfzD",
            "likes": 38,
            "name": "Atmospheric Scattering",
            "published": 3,
            "tags": [
                "planet",
                "scattering",
                "atmospheric",
                "gas"
            ],
            "usePreview": 0,
            "username": "CobaltXII",
            "viewed": 1314
        },
        "renderpass": [
            {
                "code": "// Sun settings.\nconst float sunIntensity = 1.0;\n\n// Planet settings.\nconst vec3 planetPosition = vec3(0.0, 0.0, 3.0);\nconst float planetRadius = 1.5;\nconst vec3 planetColor = vec3(0.8);\n\n// Atmosphere settings.\nconst float atmosphereSize = 0.2;\nconst float densityFalloff = 3.0;\nconst vec3 wavelengths = vec3(750.0, 530.0, 400.0);\nconst float scatteringStrength = 15.0;\n\n// Atmosphere calculations.\nconst float atmosphereRadius = planetRadius + atmosphereSize;\nconst vec3 scatteringCoefficients = pow(400.0 / wavelengths, vec3(4.0)) * scatteringStrength;\n\n// Quality settings.\nconst int inScatterPoints = 20;\nconst int outScatterPoints = 20;\n\n// Globals.\nvec3 sunDirection;\n\n// Intersection of a ray with a sphere. Returns both intersection times as a\n// vector where x is the nearest intersection and y is the farthest\n// intersection.\nvec2 rayIntersectSphere(in vec3 ro, in vec3 rd, in vec3 ce, float ra) {\n\tvec3 oc = ro - ce;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - ra * ra;\n\tfloat h = b * b - c;\n\tif (h < 0.0) {\n\t\treturn vec2(-1.0);\n\t}\n\th = sqrt(h);\n\treturn vec2(-b - h, -b + h);\n}\n\n// The density at a position above the surface but below the atmosphere's edge.\nfloat densityAtPoint(in vec3 p) {\n\t// Get the elevation of the point above the surface of the planet.\n\tfloat elevation = length(p - planetPosition) - planetRadius;\n\n\t// Scale the elevation so that a point directly on the surface of the\n\t// planet would have a value of 0, and a point directly on the edge of the\n\t// atmosphere would have a value of 1.\n\tfloat elevationScalar = elevation / atmosphereSize;\n\n\t// Use some math to determine the density.\n\treturn exp(-elevationScalar * densityFalloff) * (1.0 - elevationScalar);\n}\n\n// Calculate the average density of the atmosphere along a given finite ray\n// multiplied by the ray's length. This is referred to as the optical depth of\n// the ray.\nfloat opticalDepth(in vec3 ro, in vec3 rd, float rl) {\n\tvec3 p = ro;\n\tfloat dt = rl / float(outScatterPoints - 1);\n\tfloat accumulatedDensity = 0.0;\n\tfor (int i = 0; i < outScatterPoints; i++) {\n\t\taccumulatedDensity += densityAtPoint(p) * dt;\n\t\tp += rd * dt;\n\t}\n\treturn accumulatedDensity;\n}\n\n// Accumulated light along a given finite ray (referred to as the light-ray).\nvec3 accumulateLight(in vec3 ro, in vec3 rd, float rl) {\n\tvec3 p = ro;\n\tfloat dt = rl / float(inScatterPoints - 1);\n\tvec3 accumulatedLight = vec3(0.0);\n\tfor (int i = 0; i < inScatterPoints; i++) {\n\t\t// Cast a ray from the current point to the sun. Store the length of\n\t\t// this ray.\n\t\tfloat sunRayLength = rayIntersectSphere(p, sunDirection, planetPosition, atmosphereRadius).y;\n\n\t\t// Calculate the optical depth of the sun-ray.\n\t\tfloat sunRayOpticalDepth = opticalDepth(p, sunDirection, sunRayLength);\n\n\t\t// Calculate the optical depth of the ray from the current point to the\n\t\t// origin of the light-ray.\n\t\tfloat viewRayOpticalDepth = opticalDepth(p, -rd, dt * float(i));\n\n\t\t// Use some math to calculate the transmission.\n\t\tvec3 transmission = exp(-(sunRayOpticalDepth + viewRayOpticalDepth) * scatteringCoefficients);\n\n\t\t// Get the density at the current point.\n\t\tfloat density = densityAtPoint(p);\n\t\t\n\t\t// Accumulate light.\n\t\taccumulatedLight += density * transmission * scatteringCoefficients * dt;\n\t\tp += rd * dt;\n\t}\n\t\n\treturn accumulatedLight;\n}\n\n// // Convert from polar coordinates to Cartesian coordinates.\n// vec3 polarToCartesian(vec2 polar) {\n// \treturn vec3(cos(p.x) * cos(p.y), sin(p.x) * cos(p.y), sin(p.y));\n// }\n\n// Main image.\nvoid mainImage(out vec4 rgba, in vec2 fragCoord) {\n    // Use the mouse to determine the sun's position.\n\tsunDirection = normalize(vec3((2.0 * iMouse.xy - iResolution.xy) / iResolution.y * 5.0, 1.0));\n\n    // Set up the camera.\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(uv, 2.0));\n\t\n    // The color of this fragment.\n\tvec3 rgb;\n\t\n\t// Raycast to the planet.\n\tvec2 planetIntersection = rayIntersectSphere(ro, rd, planetPosition, planetRadius);\n\tif (planetIntersection.x > 0.0) {\n\t\t// The planet was hit by the ray. Calculate the normal.\n\t\tvec3 p = ro + rd * planetIntersection.x;\n\t\tvec3 n = normalize(p - planetPosition);\n\t\t\n\t\t// Diffuse lighting.\n\t\tfloat diffuse = max(0., dot(n, sunDirection)) * sunIntensity;\n\t\t\n        // Coloring.\n\t\trgb = vec3(planetColor * diffuse);\t \n\t} else {\n\t\t// The planet was not hit by the ray. Do sun lighting.\n        float angle = max(0.0, dot(sunDirection, rd));\n        float sun = pow(angle, 150.0);\n        float aura = pow(angle, 800.0);\n\t\trgb = vec3(sun + aura);\n\t}\n\t\n    // Raycast to the atmosphere.\n\tvec2 atmosphereIntersection = rayIntersectSphere(ro, rd, planetPosition, atmosphereRadius);\n\tif (atmosphereIntersection.x > 0.) {\n\t  \t// Calculate the distance passed through the atmosphere by the ray,\n\t\t// taking into account the planet (which may obstruct the ray).\n\t\tfloat distanceThroughAtmosphere;\n\t\tif (planetIntersection.x > 0.0) {\n\t\t\t// Hits the planet.\n\t\t\tdistanceThroughAtmosphere = planetIntersection.x - atmosphereIntersection.x;\n\t\t} else {\n\t\t\t// Does not hit the planet.\n\t\t\tdistanceThroughAtmosphere = atmosphereIntersection.y - atmosphereIntersection.x;\n\t\t}\n\t\t\n        // Accumulate light along the finite ray starting where the ray first\n        // interescted with the atmosphere and ending where the ray either\n        // intersected the planet or exited the atmosphere.\n\t\tvec3 p = ro + rd * atmosphereIntersection.x;\n\t\tvec3 light = accumulateLight(p, rd, distanceThroughAtmosphere) * 1.2;\n\t\t\n        // Mix the lighting with the color.\n\t\trgb = rgb * (1.0 - light) + light;\n\t}\n\t\n    // Output the color.\n\trgba = vec4(rgb, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}