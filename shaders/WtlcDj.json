{
    "Shader": {
        "info": {
            "date": "1593116919",
            "description": "License CC0: Generation ship design\nI have been working on SciFi related shaders lately\nCode \"borrowed\" from the usual suspects\nLots and lots of cheating",
            "flags": 0,
            "hasliked": 0,
            "id": "WtlcDj",
            "likes": 14,
            "name": "Generation ship design",
            "published": 3,
            "tags": [
                "scifiraymarching"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 440
        },
        "renderpass": [
            {
                "code": "// License CC0: Generation ship design\n//  I have been working on SciFi related shaders lately\n//  Code \"borrowed\" from the usual suspects\n//  Lots and lots of cheating\n\n// If you have a better graphics card than me uncomment for anti aliasing\n// #define AA\n#define TOLERANCE           0.001\n#define NORM_OFF            0.001\n#define MAX_RAY_LENGTH      100.0\n\n#define MAX_RAY_MARCHES     60\n\n#define PI                  3.141592654\n#define TAU                 (2.0*PI)\n\n#define TIME                iTime\n#define PERIOD              20.0\n#define PERIODS             3.0\n#define FADETIME            2.0\n#define TPERIOD             (mod(TIME, PERIOD))\n#define NPERIOD             (int(mod(TIME/PERIOD, PERIODS)))\n\nconst vec3  sunDirection        = normalize(vec3(-2.5, 3.5, -10.0));\nconst vec3  sunColor1           = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2           = vec3(1.0, 0.8, 0.9);\nconst vec3  smallSunDirection   = normalize(vec3(0.5, 0, -10.0));\nconst vec3  smallSunColor1      = vec3(1.0, 0.6, 0.6);\nconst vec3  smallSunColor2      = vec3(1.0, 0.3, 0.6);\n\nconst vec3  ringColor           = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet              = vec4(80.0, 20.0, -100.0, 50.0)*1000.0;\nconst vec3  planetCol           = sqrt(vec3(0.8, 0.7, 0.9))*1.3;\nconst vec3  ringsNormal         = normalize(vec3(1.0, 02.25, 0.0));\nconst vec4  rings               = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\nconst vec3  mountainColor       = sqrt(vec3(0.95, 0.65, 0.45));\n\nconst float refractRatio = 0.95;\n\nconst vec3  seaCol1     = vec3(0.15, 0.45, 0.55);\nconst vec3  seaCol2     = seaCol1*seaCol1*seaCol1*3.0;\n\nconst float innerLength = 4.0;\nconst float outerLength = 6.25;\nconst vec3  sunPos      = vec3(0.0, 0.0, innerLength);\n\nconst float radius      = 1.0;\nconst vec3  start      = vec3(0.0);\n  \nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nconst vec3 engineCol1 = vec3(8.0/8.0,6.0/8.0,6.0/8.0);\nconst vec3 engineCol2 = vec3(8.0/8.0,5.0/8.0,6.0/8.0);\n\nvoid rot(inout vec2 v, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  v.xy = vec2(v.x*c + v.y*s, -v.x*s + v.y*c);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// Not an exact distance field\nfloat softBox(vec3 p, float r) {\n  p *= p;\n  p *= p;\n  p *= p;\n  return pow(p.x + p.y + p.z, 1.0/8.0) - r;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat l2(vec2 p) {\n  return dot(p, p);\n}\n\nfloat l2(vec3 p) {\n  return dot(p, p);\n}\n\nfloat capsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0.0, h);\n  return length(p) - r;\n}\n\nfloat cylinder(vec3 p, vec3 c) {\n  return length(p.xy-c.xy)-c.z;\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat chamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat roundIntersection(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat roundDiff (float a, float b, float r) {\n    return roundIntersection(a, -b, r);\n}\n\nfloat mod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {\n  vec3  oc = ro - cb;\n  float card = dot(ca,rd);\n  float caoc = dot(ca,oc);\n  float a = 1.0 - card*card;\n  float b = dot(oc, rd) - caoc*card;\n  float c = dot(oc, oc) - caoc*caoc - cr*cr;\n  float h = b*b - a*c;\n  if (h<0.0) return vec2(-1.0); //no intersection\n  h = sqrt(h);\n  return vec2(-b-h,-b+h)/a;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 ce, float ra) {\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra*ra;\n  float h = b*b - c;\n  if (h<0.0) return vec2(-1.0); // no intersection\n  h = sqrt(h);\n  return vec2( -b-h, -b+h );\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nvec2 cylinderCoord(vec3 p) {\n  return vec2(p.z, atan(p.x, -p.y));\n}\n\nvec4 voronoi(vec2 x) {\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n\n  vec4 m = vec4(8.0);\n  for(int j=-1; j<=1; j++)\n  for(int i=-1; i<=1; i++)\n  {\n    vec2  g = vec2(float(i), float(j));\n    vec2  o = hash2(n + g);\n    vec2  r = g - f + o;\n    float d = dot(r, r);\n    if(d<m.x)\n    {\n      m = vec4(d, o.x + o.y, r);\n    }\n  }\n\n  return vec4(sqrt(m.x), m.yzw);\n}\n\nfloat noise2(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat fbm(vec2 p, int mx) {\n  const float aa = 0.45;\n  const float pp = 2.08;\n  const float rr = 1.0;\n  \n  float a = 1.0;\n  float s = 0.0;\n  float d = 0.0;\n  \n  for (int i = 0; i < mx; ++i) {\n    s += a*noise2(p);\n    d += abs(a);\n    a *= aa;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return 1.0*s/d;\n}\n\nvec3 normal(vec2 p, int mx) {\n  vec2 eps = -vec2(0.0001, 0.0);\n  \n  vec3 nor;\n  \n  nor.x = fbm(p + eps.xy, mx) - fbm(p - eps.xy, mx);\n  nor.y = 2.0*eps.x;\n  nor.z = fbm(p + eps.yx, mx) - fbm(p - eps.yx, mx);\n  \n  return normalize(nor);\n}\n\nvec3 gasGiant(vec3 ro, vec3 rd, vec3 sunDir) {\n  vec2 si = raySphere(ro, rd, planet.xyz, planet.w);\n  float pi = rayPlane(ro, rd, rings);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  return final;\n}\n\nvec3 sunColor(vec3 ro, vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n  vec3 col = vec3(0.0);\n\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2;\n\n  col += pow(smallDiff, 8000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.5;\n  col += pow(smallDiff, 150.0)*smallSunColor2*0.5;\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 scol = sunColor(ro, rd);\n  vec3 gcol = gasGiant(ro+vec3(0.0, 0.0, 200000.0), rd, sunDirection);\n  \n  return scol+gcol;\n}\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 refColor(vec3 ro, vec3 rd) {\n  vec3 scol = sunColor(ro, rd);\n\n  vec3 final = vec3(0.0);\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) final = vec3(2.0)*rd.y;\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n  final *= 0.5;\n  final += scol;\n  \n  return final;\n}\n\nvec3 domeColor(vec3 ro, vec3 rd) {\n  vec3 scol = sunColor(ro, rd);\n\n  vec3 final = mix(vec3(0.125, 0.25, 0.5), vec3(0.25), 0.5 + 0.5*rd.y)*0.5;\n  final += scol;\n  \n  return final;\n}\n\nvec4 backplane(vec3 ro, vec3 rd, inout vec3 scol) {\n  float ed = (innerLength - ro.z)/rd.z;\n  vec3 ep = ro + rd*ed;\n  vec3 en = vec3(0.0, 0.0, 1.0);\n\n  float lr = 0.5;\n  float er = (lr*lr-dot(ep.xy, ep.xy))/(lr*lr);\n  float eradius = length(ep.xy);\n  float emradius = eradius;\n  float eangle = atan(ep.y, ep.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.1);\n  mod1(emangle, TAU/60.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n  \n  float efadeout = 1.0 - smoothstep(0.0, 0.9, eradius);\n\n  scol = vec3(0.0);  \n  scol += 8.0*lightCol1*pow(clamp(er, 0.0, 1.0), 8.0);\n  scol += lightCol1*pow(clamp(er, 0.0, 1.0), 1.0);\n  scol += lightCol2*efadeout*efadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += scol;\n  ecol += elinec*smoothstep(0.01, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.015, 0.0, abs(emangle))*efadeout;\n \n  return vec4(ecol, eradius < 1.0);\n}\n\nvec3 islands(vec3 col, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.7;\n  float beachLevel = level + 0.025;\n\n  vec3 sunDir = normalize(sunPos - p);\n\n  sp *= 2.0;\n  float hih = fbm(sp, 6);\n  float loh = fbm(sp+vec2(0.075-0.075*sp.x/innerLength, 0.0), 3);\n  vec3 hn = normal(sp, 6);\n\n  vec3 nn = normalize(hn + n);\n\n  const vec3 sandCol = vec3(1.0, 0.95, 0.9);\n\n  float fdiff = pow(max(dot(sunDir, nn), 0.0), 0.5);\n  \n  vec4 treePattern = voronoi(sp*40.0);\n  vec3 islandCol  = mix(vec3(0.5, 0.75, 0.0), vec3(0.1, 0.45, 0.0), treePattern.y*fdiff*2.0);\n  islandCol *= 1.0 - treePattern.x * 0.75;\n\n  col = mix(0.0, 1.0, hih < level)*mix(sandCol, col , 1.0 - exp(8.0*vec3(2.0, 1.0, 1.0)*(hih-level)));\n  col = mix(col, sandCol, vec3((beachLevel >  hih) && (hih > level)));\n  col = mix(col, islandCol, vec3(hih > beachLevel));\n  // Really REALLY fake lighting+shadows\n  const float hh = 0.125;\n  vec3 scol = vec3(1.0)*(smoothstep(level, level+hh, hih) - smoothstep(level, level+hh, loh));\n  col = col+scol*0.5;\n\n  return col;\n}\n\nvec3 clouds(vec3 col, vec3 ro, vec3 rd, vec3 p, vec3 n, vec2 sp, float level) {\n  level += 0.5;\n\n  vec3 ref = reflect(rd, n);\n\n  vec3 sunDir = normalize(sunPos - p);\n  float sunL2 = l2(sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe1 = 0.5*pow(max(dot(sunDir, ref), 0.0), 10.0);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  sp *= 2.0;\n  sp += 100.0;\n  float hih = max(fbm(sp, 6) - level, 0.0);\n  float loh = max(fbm(sp, 3) - level, 0.0);;\n\n  // More fake stuff\n  float m = clamp(1.0- exp(-15.0*(hih-0.5*loh)), 0.0, 1.0);\n\n  col = mix(col, vec3(1.25)*lightCol1*(sunIll + spe1 + spe2), m*m*m);\n\n  return col;\n}\n\nvec3 cloudShadows(vec3 col, vec3 p, float level) {\n  level += 0.5;\n\n  vec3 sunDir = normalize(sunPos - p);\n\n  vec2 ci = rayCylinder(p, sunDir, start, vec3(0.0, 0.0, 1.0), 0.8*radius);\n\n  vec3 pp = p + ci.x*sunDir;\n  vec2 pp2 = cylinderCoord(pp);\n\n  pp2 *= 2.0;\n  pp2 += 100.0;\n  float loh = max(fbm(pp2, 3) - level, 0.0);\n\n  return col*mix(0.3, 1.0, exp(-3.0\n  *loh));\n}\n\nvec3 sea(vec3 ro, vec3 rd, vec3 n, vec3 p, vec2 sp) {\n\n  vec3 ref = reflect(rd, n);\n  ref = normalize(ref + 0.025*psin(mix(110.0, 220.0, psin(2.0*p.z+0.2*p.x))*p.z));\n\n  vec3 sunDir = normalize(sunPos - p);\n  float sunL2 = l2(sunPos - p);\n  float sunDiff = max(dot(sunDir, n), 0.0);\n  float sunIll = 20.0/(10.0+sunL2);\n  float spe2 = pow(max(dot(sunDir, ref), 0.0), 100.0);\n\n  vec3 seaCol = vec3(0.0);    \n  seaCol += 1.0*seaCol2*pow(1.0-max(dot(n, ref), 0.0), 0.45);\n  seaCol += seaCol1*0.5*sunIll;\n  seaCol += seaCol1*lightCol1*sunDiff*sunIll;\n  seaCol += lightCol1*spe2;\n  \n  return seaCol;  \n}\n\nvec3 shipInterior(vec3 ro, vec3 rd) {\n  ro += rd*0.05;\n  \n  float fd = (0.0 - ro.z)/rd.z;\n  vec2 di = raySphere(ro, rd, start, 1.0);\n  vec2 ci = rayCylinder(ro, rd, start, vec3(0.0, 0.0, 1.0), 0.8*radius);\n  vec2 gi = rayCylinder(ro, rd, start, vec3(0.0, 0.0, 1.0), 0.9*radius);\n\n  vec3 dp = ro + rd*di.y;\n  vec3 dn = -normalize(dp  -start);\n  vec3 drefr = refract(dp, dn, 1.0/refractRatio);\n  vec3 dcol = 0.9*domeColor(dp, drefr);\n\n  vec3 gp = ro + rd*gi.y;\n  vec3 gpy = ro + rd*gi.x;\n  vec3 gn = -normalize(vec3(gp.xy-start.xy, 0.0));\n  vec2 gp2 = cylinderCoord(gp);\n\n  vec3 cp = ro + rd*ci.y;\n  vec3 cn = -normalize(vec3(cp.xy-start.xy, 0.0));\n\n  vec3 fpcol = vec3(0.0);\n  \n  vec3 scol;\n  vec4 bpcol = backplane(ro, rd, scol);\n  vec3 bpn = vec3(0.0, 0.0, 1.0);\n  float bpdiff = max(dot(rd, bpn), 0.0);\n\n  vec3 col = vec3(0.0);\n\n  col = mix(col, fpcol, vec3(fd > gi.y));\n  col = mix(col, dcol, vec3(dp.z < 0.0));\n  col = mix(col, bpcol.xyz, bpcol.w);\n\n  if (gp.z > 0.0 && gpy.z < 0.0 && gp.z < innerLength) {\n    float level = 0.0;\n    level += 1.0-smoothstep(0.0, 0.1*innerLength, gp2.x);\n    level += 1.0-smoothstep(0.0, 0.1*innerLength, innerLength-gp2.x);\n\n    /*\n    // Too fix discontinuity. Alternative approach, place the camera correctly ;)\n    level += 1.0-smoothstep(-PI, -PI+0.5, gp2.y);\n    level += 1.0-smoothstep(PI, PI-0.5, gp2.y);\n    */\n    \n    level *= 0.125;\n    vec3 gcol = sea(ro, rd, gn, gp, gp2);\n    gcol = islands(gcol, gp, gn, gp2, level);\n    gcol = cloudShadows(gcol, gp, level);\n    gcol = clouds(gcol, ro, rd, cp, cn, cylinderCoord(cp), level);\n    col = gcol;\n  }\n  \n  float id = max(gi.y-max(gi.x, 0.0), 0.0);\n  col = mix(col, lightCol1, 1.0-exp(-0.05*id*id));\n  col = mix(col, 0.75*scol + 1.25*lightCol1, pow(bpdiff, 35.0));\n\n  return col;\n}\n\nfloat theShip(vec3 p, out float nx, out float ny, out int m) {\n  const float rep = 5.0;\n  const float tradius = 1.2;\n  const float sstep = TAU*1.125/rep;\n  const float sradius = 0.45*TAU*1.125/rep;\n  rot(p.xy, TIME*TAU/60.0);\n  float dcapsule = capsule(p, outerLength, 1.0);\n  dcapsule = pmin(dcapsule, softBox(p, 0.75), 0.25);\n  float dglobe = max(dcapsule, p.z);\n  \n  vec3 pc = p;\n  pc.z -= 0.5*sstep;\n  float n = mod1(pc.z, sstep);\n  float dtorus = torus(pc.xzy, vec2(tradius*1.55, 0.025));\n  float nm = modPolar(pc.xy, rep);\n  float dspoke = cylinder(pc, vec3(tradius*1.55, 0.0, 0.025));\n  dtorus = min(dtorus, dspoke);\n  dtorus = max(dtorus, -p.z + sstep*0.5-0.025);\n  dtorus = max(dtorus, p.z-sstep*5.0 + sstep*0.5-0.025);\n  float dbattery = sphere(pc - vec3(tradius, 0.0, 0.0), sradius);\n  float dbox = softBox(pc - vec3(tradius, 0.0, 0.0), sradius*0.9);\n  dbox = roundDiff(dbox, dbattery, 0.125);\n  dbattery = min(dbattery, dbox);\n  dbattery = max(dbattery, -p.z + sstep*0.05);\n  dbattery = max(dbattery, p.z-sstep*5.0);\n  float dengine1 = sphere((p-vec3(0.0, 0.0, outerLength+1.0)), 0.9);\n  float dengine2 = sphere((p-vec3(0.0, 0.0, outerLength+2.0)), 0.9);\n  float dengine3 = sphere((p-vec3(0.0, 0.0, outerLength+1.0)), 0.25);\n  float dengine = dengine1;\n  dengine = max(dengine, -dengine2);\n  dengine = min(dengine, dengine3);\n  vec3 pe = p;\n  pe -= vec3(0.0, 0.0, outerLength+1.8);\n  mod1(pe.x, 0.5);\n  mod1(pe.y, 0.5);\n  float d = dcapsule;\n  d = min(d, dengine);\n  d = chamfer(d, dbattery, 0.035);\n  d = min(d, dtorus);\n  \n \n  m = 1;\n\n  if (d == dglobe) m = 3;\n  if (d == dbattery) m = 4;\n  if (d == dtorus) m = 1;\n  if (d == dbox) m = 2;\n  if (d == dengine1) m = 2;\n  if (d == -dengine2) m = 5;\n  if (d == dengine3) m = 5;\n\n  nx = n;\n  ny = nm;\n  \n  return d;\n}\n\nfloat map(vec3 p, out float nx, out float ny, out int m) {\n  return theShip(p, nx, ny, m);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, out float nx, out float ny, out int mat, out int iter) {\n  float t = 0.0;\n  float d;\n  int i;\n  for (i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    d = map(ro + rd*t, nx, ny, mat);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d; // 0.9\n  }\n  iter = i;\n  \n  if (abs(d) > 10.0*TOLERANCE) return MAX_RAY_LENGTH;\n  \n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec3  eps = vec3(NORM_OFF,0.0,0.0);\n  vec3 nor;\n  float nx;\n  float ny;\n  int mat;\n  nor.x = map(pos+eps.xyy, nx, ny, mat) - map(pos-eps.xyy, nx, ny, mat);\n  nor.y = map(pos+eps.yxy, nx, ny, mat) - map(pos-eps.yxy, nx, ny, mat);\n  nor.z = map(pos+eps.yyx, nx, ny, mat) - map(pos-eps.yyx, nx, ny, mat);\n  return normalize(nor);\n}\n\nvec3 innerColor(vec3 ro, vec3 rd, vec3 nor, float nx, float ny) {\n  vec2 f = hash2(137.0*vec2(nx, ny)+27.0);\n  vec3 refr = refract(rd, nor, 3.0); \n  float dim = smoothstep(0.6, 0.7, f.x);\n  dim *= mix(0.5, 1.0, psin(2.0*TIME+f.y*TAU));\n  float s1 = mix(0.3, 2.0, dim);\n  float s2 = mix(1.0, 1.25, dim);\n  float m = max(dot(nor, -refr), 0.0);\n  return 1.5*s1*pow(vec3(1.2, 1.1, s2)*m, 1.25*vec3(2.5, 2.5, 5.5));\n}\n\nvec3 engineColor(vec3 ro, vec3 rd, vec3 nor) {\n  float eradius = length(ro.xy);\n  float emradius = eradius;\n  float eangle = atan(ro.y, ro.x);\n  float emangle = eangle;\n\n  mod1(emradius, 0.2);\n  mod1(emangle, TAU/20.0);\n\n  vec3 elinec = vec3(1.0)*1.25;\n  \n  float efadeout = 1.0 - smoothstep(0.0, 0.75, eradius);\n  float ifadeout = smoothstep(0.2, 0.225, eradius);\n\n  vec3 refr = refract(rd, nor, 1.25); \n  float m = max(dot(nor, -refr), 0.0);\n \n \n  vec3 scol = vec3(0.0);  \n  scol += 4.0*engineCol1*pow(m, 4.0);\n  scol += engineCol2*2.0;\n  scol *= 1.0- ifadeout;\n\n  vec3 ecol = vec3(0.0);\n  ecol += elinec*smoothstep(0.02, 0.0, abs(emradius))*efadeout;\n  ecol += elinec*smoothstep(0.05, 0.0, abs(emangle))*efadeout;\n  ecol += engineCol2*2.0*efadeout*efadeout;\n  ecol *= ifadeout;\n \n  return ecol + scol;\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n  // background color\n  vec3 color  = vec3(0.5, 0.8, 1.0);\n\n  int mat = 0;\n  int iter = 0;\n  float nx;\n  float ny;\n  float t = rayMarch(ro, rd, nx, ny, mat, iter);\n\n//  vec3 icol = 1.0*vec3(1.0, 0.0, 0.9)*smoothstep(0.5, 1.0, float(iter)/MAX_RAY_MARCHES);\n  const  vec3 icol = vec3(0.0);\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = normal(pos);\n\n  float ndif = 1.0;\n  float nref = 0.8;\n\n  vec3 ref  = reflect(rd, nor);\n  vec3 rcol = refColor(pos, ref);\n  vec3 refr = refract(rd, nor, refractRatio);\n    \n  if (t < MAX_RAY_LENGTH) {\n    // Ray intersected object\n    \n    switch(mat) {\n    case 0:\n      color = mix(vec3(1.0), nor*nor, 0.5);\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 1:\n      color = vec3(0.9) + abs(nor.zxy)*0.1;\n      ndif = 0.75;\n      nref = 0.7;\n      break;\n    case 2:\n      color = vec3(0.25) + abs(nor.zxy)*0.05;\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 3:\n      vec3 sicol = shipInterior(pos, refr);\n      color = mix(sicol, rcol, vec3(refr == vec3(0.0)));\n      ndif = 0.5;\n      nref = 0.9;\n      break;\n    case 4:\n      color = innerColor(pos, rd, nor, nx, ny);\n      ndif = 0.75;\n      nref = 0.9;\n      break;\n    case 5:\n      color = engineColor(pos, rd, nor);\n      ndif = 0.5;\n      nref = 0.75;\n      break;\n    default:\n      color = nor*nor;\n      break;\n    }\n      \n  }\n  else {\n    // Ray intersected sky\n    return skyColor(ro, rd) + icol;\n  }\n\n  vec3 ld0  = vec3(0.0, 1.0, 0.0);\n\n  vec3 lv1  = sunDirection;\n  float ll1 = length(lv1);\n  vec3 ld1  = lv1 / ll1;\n\n  vec3 lv2  = smallSunDirection;\n  float ll2 = length(lv2);\n  vec3 ld2  = lv2 / ll2;\n\n  int rmat = 0;\n  int riter = 0;\n  float st  = rayMarch(pos + ref*10.0*TOLERANCE, ref, nx ,ny, rmat, riter);\n  float sha2 = st < MAX_RAY_LENGTH ? 0.0 : 1.0;\n\n  float dif0 = pow(max(dot(nor,ld0),0.0), ndif);\n  float dif1 = pow(max(dot(nor,ld1),0.0), ndif);\n  float dif2 = pow(max(dot(nor,ld2),0.0), ndif);\n\n  vec3 col0 = mix(vec3(1.0), dif0*vec3(1.0), 0.8);\n  vec3 col1 = mix(vec3(1.0), dif1*lightCol1, 0.8);\n  vec3 col2 = mix(vec3(1.0), dif2*lightCol2, 0.8);\n\n  vec3 col = mix(rcol*sha2, color*(col0 + col1 + col2)/2.0, nref);\n\n  return col + icol;\n}\n\nvec3 fragment(vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  float tperiod = TPERIOD;\n  int nperiod = NPERIOD;\n  vec3 ro  =vec3(1.0, 0.0, -3.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n \n  switch(nperiod) {\n  case 0:\n    ro = 3.0*vec3(0.5-tperiod/10., 1.0+tperiod/5.0, 15.0-tperiod);\n    break;\n  case 1:\n    ro = vec3(-10.0+tperiod, 0.5, -3.0);\n    break;\n  case 2:\n    ro = -3.0*vec3(-0.5+tperiod/10., 1.0-tperiod/5.0, 10.0-tperiod);\n    break;\n  default:\n    break;\n  }\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n\n  float s = 2.0/iResolution.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/  \n  col += fragment(ro, uu, vv, ww, p+o1);\n\n#ifdef AA\n  // Adaptive AA? Is that a good idea?  \n  vec3 dcolx = dFdx(col);\n  vec3 dcoly = dFdy(col);\n  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly)/(col+1.0/256.0);\n//  vec3 dcol = sqrt(dcolx*dcolx+dcoly*dcoly);\n\n  float de = max(dcol.x, max(dcol.y, dcol.z));\n  if (de > 0.1) {\n    col += fragment(ro, uu, vv, ww, p-o1);\n    col += fragment(ro, uu, vv, ww, p+o2);\n    col += fragment(ro, uu, vv, ww, p-o2);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n#endif\n\n  col = clamp(col, 0.0, 1.0);\n  float fadeIn = smoothstep(0.0, FADETIME, tperiod);\n  float fadeOut = 1.0 - smoothstep(PERIOD - FADETIME, PERIOD, tperiod);\n  col *= fadeIn;\n  col *= fadeOut;\n  \n  fragColor = vec4(col ,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}