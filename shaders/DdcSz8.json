{
    "Shader": {
        "info": {
            "date": "1679349863",
            "description": "This shader is based of https://www.shadertoy.com/view/XdlGzn (from iq)\nPress space to toggle anaglyph 3d (you will need 3d red/cyan googles)\nYou can also change the eye spacing by editing the first line inside common",
            "flags": 48,
            "hasliked": 0,
            "id": "DdcSz8",
            "likes": 8,
            "name": "Space Ship with Anaglyph 3D",
            "published": 3,
            "tags": [
                "3d",
                "rasterizer",
                "anaglyph",
                "spaceship"
            ],
            "usePreview": 0,
            "username": "GetItemFromBlock",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "// Fork of \"Rasterizer - Cube\" by iq. https://shadertoy.com/view/XdlGzn\n// GetItemFromBlock - 2023-03-20\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Update - 2023-04-07\n// Changed Triangle struct to use indexed vectors\n// This helped to reduce code size quite a lot\n\n// Update - 2023-05-30\n// Added metallic-like reflection on the glass part of the ship\n\nvec3 rasterize(in vec2 fragCoord, int delta, int dtB)\n{\n    vec2 px = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0.478,0.478,0.478);\n    // clear zbuffer\n    float mindist = -1000000.0;\n    \n    for (int i = 0; i < TRIANGLE_COUNT; i++)\n    {\n        vec4 bounds = texelFetch(iChannel0, ivec2(i, delta + 3), 0);\n        if (px.x < bounds.x || px.x > bounds.y || px.y < bounds.z || px.y > bounds.w)\n        {\n            continue;\n        }\n        vec4 frb = texelFetch(iChannel0, ivec2(i, delta + 1), 0);\n        vec4 frc = texelFetch(iChannel0, ivec2(i, delta + 2), 0);\n        vec2 cp0 = frb.xy;\n        vec2 cp1 = frb.zw;\n        vec2 cp2 = frc.xy;\n\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n                        \n        if( all(greaterThan(di,vec3(0.0))) )\n        {\n            vec4 fra = texelFetch(iChannel0, ivec2(i, delta), 0);\n            float w0 = fra.x;\n            float w1 = fra.y;\n            float w2 = fra.z;\n            \n            vec3 p0 = vectors[triangles[i].a] * w0;\n            vec3 p1 = vectors[triangles[i].b] * w1;\n            vec3 p2 = vectors[triangles[i].c] * w2;\n            \n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n            \n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n\n\t\t\t// depth (-1/z) buffer test\n\t\t\tif( z>mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n                \n\t\t\t\t// perform lighting/shading \n                vec3 cameraPos = texelFetch(iChannel1, ivec2(0,dtB), 0).rgb;\n                vec3 worldPos = p0 * ba.x + p1 * ba.y + p2 * ba.z;\n                worldPos *= z;\n                vec3 viewdir = normalize(cameraPos-worldPos);\n\t\t\t\tcolor = shader(-viewdir, vectors[triangles[i].n], vectors[triangles[i].col]);\n                if (vectors[triangles[i].col].r < .1) color = mix(texture(iChannel3, reflect(viewdir, vectors[triangles[i].n])).rgb, color, .8);\n\t\t\t}\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (texelFetch(iChannel2, ivec2(32,2), 0).r > 0.)\n    {\n        vec3 a = rasterize(fragCoord, 0, 4);\n        vec3 b = rasterize(fragCoord, 4, 9);\n        float r = (a.x + a.y + a.z) / 3.;\n        float gb = (b.x + b.y + b.z) / 3.;\n        fragColor = vec4(r, gb, gb, 1);\n    }\n    else\n    {\n        fragColor = vec4(rasterize(fragCoord, 0, 4), 1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.x < 1)\n    {\n        float rx = iMouse.z <= 0. ? .3 + .3 * sin(iTime * .55) : (iMouse.y/iResolution.y-.5)*-3.1415;\n        float ry = iMouse.z <= 0. ? .3*iTime : iMouse.x/iResolution.x*10.;\n        if (coord.y < 5)\n        {\n            if (coord.y == 4)\n            {\n                fragColor = vec4( ANAGLYPH_DELTA,0,-8,0) * setRotation( rx, 0.,  0. ) * setRotation( 0., ry, 0. );\n            }\n            else\n            {\n                mat4 mvp = setTranslation( ANAGLYPH_DELTA, 0., -8. ) * \n                   setRotation( rx, 0.,  0. ) * \n                   setRotation( 0., ry, 0. );\n                fragColor = mvp[coord.y];\n            }\n        }\n        else if (coord.y < 10)\n        {\n            if (coord.y == 9)\n            {\n                fragColor = vec4(-ANAGLYPH_DELTA,0,-8,0) * setRotation( rx, 0.,  0. ) * setRotation( 0., ry, 0. );\n            }\n            else\n            {\n                mat4 mvp = setTranslation(-ANAGLYPH_DELTA, 0., -8. ) * \n                   setRotation( rx, 0.,  0. ) * \n                   setRotation( 0., ry, 0. );\n                fragColor = mvp[coord.y-5];\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ANAGLYPH_DELTA 0.2\n#define TRIANGLE_COUNT 29\n\nstruct Triangle\n{\n    int a;\n    int b;\n    int c;\n    int n;\n    int col;\n};\n\nconst Triangle triangles[TRIANGLE_COUNT] = Triangle[TRIANGLE_COUNT](\n    Triangle( 0,  1,  2,  3, 4 ),\n    Triangle( 5,  6,  7,  8, 9 ),\n    Triangle(10,  5, 11, 12, 9 ),\n    Triangle( 5,  7, 11, 13, 9 ),\n    Triangle( 5, 10,  6, 14, 9 ),\n    Triangle(15, 16, 17, 18, 19),\n    Triangle(20, 17, 16, 21, 19),\n    Triangle(17, 20, 15, 22, 19),\n    Triangle(23, 24, 25, 26, 19),\n    Triangle(27, 28, 29, 30, 19),\n    Triangle(31, 29, 28, 32, 19),\n    Triangle(33, 25, 24, 34, 19),\n    Triangle(25, 33, 23, 35, 19),\n    Triangle(24, 23, 33, 36, 19),\n    Triangle(29, 31, 27, 37, 19),\n    Triangle(28, 27, 31, 38, 19),\n    Triangle(39, 40, 41, 42, 19),\n    Triangle(40, 43, 41, 44, 19),\n    Triangle(39, 41, 43, 45, 19),\n    Triangle(46, 47, 48, 49, 19),\n    Triangle(50, 46, 48, 51, 19),\n    Triangle(47, 50, 48, 52, 19),\n    Triangle(15, 20, 16, 53, 19),\n    Triangle( 1, 54,  2, 55, 19),\n    Triangle( 1, 56, 54, 57, 19),\n    Triangle(58,  1,  0, 59, 19),\n    Triangle(58, 56,  1, 60, 19),\n    Triangle(54,  0,  2, 61, 19),\n    Triangle(54, 58,  0, 61, 19)\n);\n\nconst vec3 vectors[] = vec3[](\n    vec3(-1.740639, 0.263649,-0.447956),\n    vec3(-1.676231,-0.328994,-0.      ),\n    vec3(-1.740639, 0.263649, 0.447957),\n    vec3(-0.9939  ,-0.1104  ,-0.      ),\n    vec3( 1.      , 0.032634, 0.      ),\n    vec3(-0.303772, 0.664045, 0.      ),\n    vec3( 1.266395, 0.070252, 0.      ),\n    vec3(-0.760758, 0.270009,-0.3     ),\n    vec3( 0.173   , 0.4561  ,-0.8729  ),\n    vec3( 0.047274, 0.296477, 0.8     ),\n    vec3(-0.760758, 0.27001 , 0.3     ),\n    vec3(-1.275573, 0.482339, 0.      ),\n    vec3(-0.1261  , 0.6935  , 0.7093  ),\n    vec3(-0.1261  , 0.6935  ,-0.7093  ),\n    vec3( 0.173   , 0.4561  , 0.8729  ),\n    vec3( 3.168733,-0.3     ,-0.      ),\n    vec3(-1.924065, 0.798304, 0.      ),\n    vec3(-1.      ,-0.3     , 1.      ),\n    vec3( 0.1576  , 0.7328  , 0.6619  ),\n    vec3( 0.49499 , 0.618285, 0.8     ),\n    vec3(-1.      ,-0.3     ,-1.      ),\n    vec3(-0.7637  ,-0.6456  ,-0.      ),\n    vec3(-0.      ,-1.      ,-0.      ),\n    vec3(-0.743818,-0.3     ,-0.772652),\n    vec3(-0.990441,-0.3     ,-1.150883),\n    vec3(-1.237182, 1.188035,-1.491767),\n    vec3( 0.838   , 0.0156  ,-0.5455  ),\n    vec3(-0.743818,-0.3     , 0.772652),\n    vec3(-1.237182, 1.188036, 1.491767),\n    vec3(-0.990441,-0.3     , 1.150883),\n    vec3( 0.838   , 0.0157  , 0.5455  ),\n    vec3(-1.346018,-0.43934 , 1.086163),\n    vec3(-0.0865  ,-0.2361  , 0.9679  ),\n    vec3(-1.346019,-0.43934 ,-1.086163),\n    vec3(-0.0865  ,-0.2361  ,-0.9679  ),\n    vec3(-0.4895  , 0.2448  , 0.8369  ),\n    vec3( 0.3231  ,-0.9221  ,-0.2128  ),\n    vec3( 0.3231  ,-0.9221  , 0.2128  ),\n    vec3(-0.4895  , 0.2448  ,-0.8369  ),\n    vec3(-0.582366,-0.288396,-0.530632),\n    vec3(-0.748945,-0.149185,-0.530632),\n    vec3(-0.582367,-0.815582,-3.234085),\n    vec3(-0.6376  ,-0.7557  , 0.1496  ),\n    vec3( 0.522291,-0.23427 ,-0.530632),\n    vec3( 0.0632  , 0.9696  ,-0.2365  ),\n    vec3( 0.0471  ,-0.981   , 0.1883  ),\n    vec3( 0.522291,-0.234269, 0.530632),\n    vec3(-0.748945,-0.149185, 0.530632),\n    vec3(-0.582366,-0.815582, 3.234085),\n    vec3( 0.0631  , 0.9696  , 0.2365  ),\n    vec3(-0.582366,-0.288396, 0.530632),\n    vec3( 0.0471  ,-0.981   ,-0.1883  ),\n    vec3(-0.6376  ,-0.7557  ,-0.1496  ),\n    vec3( 0.1576  , 0.7328  ,-0.6619  ),\n    vec3(-1.315454, 0.185521, 0.279947),\n    vec3( 0.2055  ,-0.577   , 0.7905  ),\n    vec3(-1.079661,-0.172737,-0.      ),\n    vec3( 0.1412  ,-0.5491  , 0.8237  ),\n    vec3(-1.315454, 0.185521,-0.279947),\n    vec3( 0.2055  ,-0.5771  ,-0.7904  ),\n    vec3( 0.1412  ,-0.5491  ,-0.8237  ),\n    vec3( 0.1807  , 0.9835  ,-0.      )\n);\n\nfloat cross2d( in vec2 a, in vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nconst vec3 lightDir = normalize(vec3(.5, 1, -1));\nconst vec3 lightCol = vec3(.3, .3, .3);\nconst float smoothness = 256.;\n\nvec3 shader(vec3 view, vec3 normal, vec3 color)\n{\n    float deltaA = dot(lightDir,normal);\n    if (deltaA < 0.) deltaA = 0.;\n    vec3 halfV = normalize(lightDir + view);\n    float deltaB = pow(max(dot(normal,halfV), 0.0), smoothness);\n    return color + lightCol * deltaA + deltaB;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 processTriangle(ivec2 coord, int delta, int dtIn)\n{\n\tmat4 mvp = mat4(\n        texelFetch(iChannel0,ivec2(0,dtIn    ),0),\n        texelFetch(iChannel0,ivec2(0,dtIn + 1),0),\n        texelFetch(iChannel0,ivec2(0,dtIn + 2),0),\n        texelFetch(iChannel0,ivec2(0,dtIn + 3),0)\n    );\n    vec3 ep0 = (mvp * vec4(vectors[triangles[coord.x].a],1.0)).xyz;\n    vec3 ep1 = (mvp * vec4(vectors[triangles[coord.x].b],1.0)).xyz;\n    vec3 ep2 = (mvp * vec4(vectors[triangles[coord.x].c],1.0)).xyz;\n\n    // transform to clip space\n    float w0 = 1.0/ep0.z;\n    float w1 = 1.0/ep1.z;\n    float w2 = 1.0/ep2.z;\n\n    if (coord.y == delta)\n    {\n        return vec4(w0,w1,w2,0);\n    }\n\n    vec2 cp0 = 2.0*ep0.xy * -w0;\n    vec2 cp1 = 2.0*ep1.xy * -w1;\n    vec2 cp2 = 2.0*ep2.xy * -w2;\n    if (coord.y == delta + 1)\n    {\n        return vec4(cp0, cp1);\n    }\n    else if (coord.y == delta + 2)\n    {\n        return vec4(cp2, 0, 0);\n    }\n    float minY = min(min(cp0.y, cp1.y), cp2.y);\n    float maxY = max(max(cp0.y, cp1.y), cp2.y);\n    float minX = min(min(cp0.x, cp1.x), cp2.x);\n    float maxX = max(max(cp0.x, cp1.x), cp2.x);\n    return vec4(minX, maxX, minY, maxY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.x < TRIANGLE_COUNT)\n    {\n        if (coord.y < 4)\n        {\n            fragColor = processTriangle(coord, 0, 0);\n        }\n        else if (coord.y < 8)\n        {\n            fragColor = processTriangle(coord, 4, 5);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}