{
    "Shader": {
        "info": {
            "date": "1630708033",
            "description": "asdas",
            "flags": 32,
            "hasliked": 0,
            "id": "NssXD7",
            "likes": 10,
            "name": "Clouds fractals 3",
            "published": 3,
            "tags": [
                "asdas"
            ],
            "usePreview": 0,
            "username": "MinimilisticBits",
            "viewed": 429
        },
        "renderpass": [
            {
                "code": "\nvec3 blur(vec2 uv, float r){\nvec3 c = texture(iChannel0, uv).xyz;\nuv *= iResolution.xy;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     x*=r;\n     y*=r;\n     //float bok = texture(iChannel1, vec2(0.5)+((vec2(x,y)*6.)/iResolution.xy)).y;\n     vec3 col = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyz;\n     //if(length(col) > 0.6)col*=1.2;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n} \nvec3 bokeh2(vec2 uv, float r){\n//float dist = texture(iChannel0, uv).w;\n//dist = (sqrt(dist)/8.)*dist*0.8;\nvec3 c;\nuv *= iResolution.xy;\n//float r = clamp(dist*.9,0., 20.);\n//r = clamp(1.0-exp(-(dist-1.6)*3.),0.,12.);\n//r = 1.;\nfloat iter;\nvec3 bk;\nfor(int i = 0; i < 150; i++){\nvec2 dir = vec2(float(i+1)*0.01*cos((float(i+1)*1.61803)*2.0*3.14159), \nfloat(i+1)*0.01*sin((float(i+1)*1.61803)*2.0*3.14159));\n//dir += offset;\ndir *= r*8.;\n//if(offset < 0.01){\n   vec3 col = texture(iChannel0, (uv+dir)/iResolution.xy).xyz;\n   //if(luminance(col)>0.6)col *= 4.;\n  // col = col * col * 3.3;\n   vec3 bkk = pow(col, vec3(4));\n   \n   c += col*bkk;\n   bk+=bkk;\n   iter+=1.;\n//}\n}\nreturn c/bk;\n}\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 c = texture(iChannel0, uv);\n    vec3 col = c.xyz;\n    float dist = length(vec2(-0.,-0.)-(uv*2.0-1.0));\n   // vec3 col = blur(uv, (exp(.3*(dist-3.))*dist*dist*dist)*3.);\n    //vec3 col = bokeh2(uv, (exp(.9*(dist-3.))*dist)*5.);\n       // if(dist < 0.1)col+=1.;\n\n    /*for(int i = 0; i < 20; i++){\n    float dist = ds(p);\n    if(dist < 0.01){\n    vec3 n = normal(p);\n    col = vec3(0.4,0.3,0.1)*max(dot(n, lig),0.3)+max(clouds(vec3(0.), reflect(d,n), lig),0.2)*0.2\n    +rough(0.1, dot(reflect(d,n), -lig))*0.1;\n    break;\n    }\n    p+=d*dist;\n    }*/\n    //col = ACESFilm(col);\n    //col = pow(col, vec3(1.0/2.2));\n    float ds = c.w;\n    //vec3 col = blur(uv, min((sqrt(ds)/8.0)*ds*2., 10.), 0.4);\n     //col+=vec3(0.7,0.7,0.7)* (sqrt(ds)/8.0)*ds*0.5;\n       // col = max(col,0.);\n       vec3 a = vec3(0.6,0.7,0.7)-0.4;\n       //col = mix(col, smoothstep(0.,1.,col),a);\n       col = vec3(1.)-exp(-2.6*col);\n      // col = col/(col+1./2.);\n       //col = ACESFilm(col);\n       col = pow(col, vec3(1.0/2.2));\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": " const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc *= pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y<0.0)?2.*pi-acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\n\nfloat noise(vec3 uv){\nreturn fract(sin(uv.x*23. + uv.y*345.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\nfloat noise2(vec3 uv){\nvec3 f = floor(uv);\nvec3 i = fract(uv);\ni = smoothstep(0.,1.,i);\nfloat a = noise(f);\nfloat b = noise(f+vec3(1.,0.,0.));\nfloat c = noise(f+vec3(0.,1.,0.));\nfloat d = noise(f+vec3(1.,1.,0.));\nfloat e = noise(f+vec3(0.,0.,1.));\nfloat f2 = noise(f+vec3(1.,0.,1.));\nfloat g = noise(f+vec3(0.,1.,1.));\nfloat h = noise(f+vec3(1.,1.,1.));\n\nfloat m1 =  mix(mix(a,b,i.x),mix(c,d,i.x),i.y);\nfloat m2 =  mix(mix(e,f2,i.x),mix(g,h,i.x),i.y);\nreturn mix(m1,m2,i.z);\n}\n\nfloat fbm(vec3 uv){\nreturn noise2(uv)*0.5+noise2(uv*2.0)*0.25+noise2(uv*4.)*0.125+noise2(uv*8.)*0.0625;\n}\n\n\nfloat Tr(float densityMultiplier, float collectedDensity){\nreturn exp(-collectedDensity*densityMultiplier);\n}\n\nfloat Powder(float densityMultiplier, float collectedDensity){\nreturn 1.0 - exp(-collectedDensity*densityMultiplier*2.0);\n}\n\n//r = particle radius\n//wave = light wavelength\n// x<<1 Rayleigh scattering\n// x==1 Mie scattering (x < 1.01 && x > 0.997)\n// x>>1 Geometric scattering\nfloat phase(float r, float wave){\nreturn (2.0*3.14159*r)/wave;\n}\n\n//theta = dot between light and view vector(i think)\nfloat RayleighPhase(float theta){\nfloat a = 0.0596831036595;\nfloat b = (1.+theta*theta);\nreturn a*b;\n}\n\n//g = [0,1]\nfloat HenyeyGreensteinPhase(float g, float theta){\nfloat a = 1.0 - g*g;\nfloat b = 12.5663706144*pow(1.0+g*g-2.*g*theta,1.5);\nreturn a/b;\n}\n\n//Maybe -(a/b) is needed as it seems to be inverted\nfloat SchlickApproximationPhase(float g, float theta){\nfloat k = 1.55*g-0.55*g*g*g;\nfloat a = 1.0 - k*k;\nfloat sub = 1.0 + k*theta;\nfloat b = 12.5663706144*sub*sub;\nreturn -(a/b);\n}\n\n\n\n \n        #define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\nvec3 cc = vec3(1.);\n\n// simply scale the dual vectors\n\nvoid sphereFold(inout vec3 z) {\n\tfloat minRadius2 = 0.25;\n    float fixedRadius2 = 2.;\n    float r2 = dot(z,z);\n\tif (r2 < minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t} else if (r2 < fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z) {\nfloat foldingLimit = 2.;\n\tz = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\nfloat escape;\nvec4 orb; \nfloat DE2( vec3 p )\n{ \n    float s = 1.7;\n\tfloat scale = 1.0;\n    escape = 0.;\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\t//p = -1.0 + 2.0*fract(0.5*p+0.5);\n        p = mod(p*0.5 + 0.5, 1.)*2.0-1.0;\n\t\tfloat r2 = dot(p,p);\n\t\tescape += exp(-0.2*r2);\n        orb = min( orb, vec4(abs(p.xyz),r2) );\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\tfloat m = 0.25*length(p.xz)/scale;\n    return (m < 0.001)?0.5:0.05;\n}\n\nfloat DE3(vec3 p0){\n   vec4 p = vec4(p0, 1.);\n       escape = 0.;\n\n   for(int i = 0; i < 8; i++){\n       \n        \n       // p*=4.2;\n        p.xyz = mod(p.xyz - 1., 2.)-1.;\n       //p.xyz = mod(p.xyz*0.5 + 0.5, 1.)*2.-1.;\n        float m = length(p.xyz);\nfloat r2 = dot(p.xyz,p.xyz);\n\t\tescape += exp(-0.2*r2);\np*=(1.7/r2);\n   }\n   p/=p.w;\n   float d  = 0.25*length(p.xz)/1.0;\n   return (d < 0.001)?0.5:0.08;\n}\n\nfloat escape2;\nfloat DEmine2(vec3 p){   \n    float d = 10e5;\n   // p.xz = rot2(p.xz,(-1.2 +0.3)*360./3.14159);\n    vec4 q = vec4(p,1);\n    escape = 0.;\n    escape2 = 9999999.;\n    for(float i = 0.; i < 12.; i++){\n         \n        //q = abs(q);\n        float as = dot(q.xyz, q.xyz);\n        escape2 = min(escape2, as);\n        escape += exp(-.2*as);\n        if( i == 4.)q.xyz = pmod(q.xyz,5.);\n        if( i == 7.)q.xyz = pmod(q.xyz, 5.);\n        if(i == 10.)q.xz=q.zx;\n        //if( i == 5.)q =abs(q)/dot(q.xyz,q.xyz);\n        q = abs(q);\n        if(q.x < q.z) q.xz = q.zx;\n        if(q.z > q.y) q.zy = q.yz;\n        boxFold(q.xyz);\n        sphereFold(q.xyz);\n        //q.xz *= rot2(q.xz,(1.5*pi)*360./3.14159);\n          q.y -= 0.2*sin(i*4.)+0.25;\n          q.x -= sin(i)*8.;\n          q *= 1.34;\n\n    }\n    q.xyz /= q.w;\n    float ds = max(abs(q.x),abs(q.z));\n    ds = min(ds, length(q.yz)-0.);\n    ds -= 0.02;\n    return (ds<0.01)?0.5:0.05;\n}\n\nfloat len(vec3 p){\nreturn length(vec3(0.,-6.,0.)-p)-4.3;\n}\n\nvec3 orbitTrap;\n\n\nfloat DE(vec3 p){\n\tvec3 w = p;\n\tfloat m = dot(w, w);\n    orbitTrap = vec3(1.);\n\n    for(int i = 0; i < 8; i++){\n\t\tif(m > 1.2) break;\n\n\t\tfloat m2 = m*m;\n\t\tfloat m4 = m2*m2;\n\t\tfloat x = w.x; float x2 = x*x; float x4 = x2*x2;\n\t\tfloat y = w.y; float y2 = y*y; float y4 = y2*y2;\n\t\tfloat z = w.z; float z2 = z*z; float z4 = z2*z2;\n\t\tfloat k3 = x2 + z2;\n\t\tfloat k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n\t\tfloat k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n\t\tfloat k4 = x2 - y2 + z2;\n\t\tw.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n\t\tw.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n\t\tw.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n\t\tm = dot(w, w);\n        orbitTrap = min(abs(w*1.2), orbitTrap);\n\n\t}\n    //orbitTrap = 1.0-exp(-orbitTrap*2.);\n\treturn m > 1.2 ? 0.08 : 0.3 ;\n}\n\nvec3 color(vec3 p) {\n    float a = DE(p);\n    return 1.-orbitTrap;\n}\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat box(vec3 p, float s){\nvec3 a = abs(p)-s;\nreturn max(max(a.x,a.y),a.z);\n}\n\nvec4 clouds(vec3 p, vec3 d, vec3 lig, inout float dd){\nvec3 col = vec3(0.);\n    const int iter = 283;\n    float shadow_dist = 183.;\n    float ss = 1.0/float(shadow_dist);\n    float trans = 1.;\n   \n    float transmittance = 1.;\n    vec3 tryTr = vec3(0.);\n    //float shadowstepsize = 1. / float(iter);\n\n    float density = 1.0;\n    //density *= ss;\n    vec3 lightenergy = vec3(0.);\n    vec3 lightpowder = vec3(0.);\n    float ShadowDensity = 4.;\n    float PowderDensity = 3.0;\n   \n    float t1;\n    float t2;\n    \n         float minus = 0.04;\n         float mult = 1.;\n         float rep = 6.;\n         \n   p = vec3(0.);\n   bool hit_obj = false;\n   for(int i = 0; i < 60; i++){\n     // float a = DEmine((mod(vec3(0., 0.,0.)-p.xyz,12.)-6.)/2.)*5.;\n     // float dist = max(a, length(vec3(0.,-6.,0.)-p)-4.3);\n     float dist = length(mod(vec3(0.,-2.,0.)-p,rep)-rep*0.5)-3.3;\n      if(dist < 0.001){hit_obj = true; break;}\n      p+=d*dist;\n   }\n   //return vec3(0.,1.,0.);\n   \n   // vec2 i = intersect2(p, d, vec3(0.), 2.3);\n   if(hit_obj){\n         //vec3 end = p+d*i.y;\n         //p = vec3(0.);\n         //p.zx = rot(p.zx, iTime*4.);\n         //p.yz = rot(p.yz, iTime*4.);\n        // p.y-=iTime*0.1;\n         bool hit_volume = false;\n         for(int i = 0; i < iter; i++){\n             float nos = DE3((mod(vec3(0.,1.4,0.)+p*mult,rep)-rep*0.5))-minus+fbm(p*2.3)-0.6;\n             if(nos > 0.01){\n             \n               vec3 lpos = p;\n               float shadowdist = 0.;\n               vec3 lm;\n               for (int s = 0; s < 20; s++)\n               {\n                 // if(DE(mod(lpos,12.)-6.) < 0.01){\n                    float lsample = DE3((mod(vec3(0.,1.4,0.)+lpos*mult,rep)-rep*0.5))-minus+fbm(lpos*2.3)-0.6;\n                    //if(nos < 0.05 && lsample > 0.1)lsample*=8.;\n                    shadowdist += clamp(lsample, 0., 1.);\n                    lpos += lig*ss;\n                    if(length(mod(vec3(0.,-2.,0.)-lpos,rep)-rep*0.5)-3.3 > 0.01)break;\n                    if(s == 10)lm = lpos;\n                    \n               }\n               \n               transmittance += clamp(nos,0.,1.);\n               trans *= 1.0 - (clamp(nos,0.,1.));\n               lightenergy += vec3(Tr(0.5*ShadowDensity, shadowdist)\n               ,Tr(1.*ShadowDensity, shadowdist),\n               Tr(2.*ShadowDensity, shadowdist))*trans*clamp(nos,0.,1.)\n               *(palette(escape*2.2, vec3(0.5), vec3(0.5), vec3(1.,1.,1.), vec3(0.0,.1,0.2))+0.1)*0.5;\n               //*color((mod(vec3(0.,1.4,0.)+lm*mult,2.)-2.*0.5));\n               lightpowder += vec3(Powder(0.5*PowderDensity, shadowdist)\n               ,Powder(1.*PowderDensity, shadowdist),\n               Powder(2.*PowderDensity, shadowdist))*trans*max(nos,0.);\n             }\n             p+=d*ss;\n             if(length(mod(vec3(0.,-2.,0.)-p,rep)-rep*0.5)-3.3 > 0.01)break;\n         }\n         \n         if(transmittance != 1.){\n         col = col*trans + lightenergy*lightpowder*2.;\n         }\n    }\n    return vec4(col,trans);\n}\n\nfloat ds(vec3 p){\n    vec3 a = vec3(0.,12.,0.)-p;\n    a.yz = rot(a.yz, iTime*20.);\n    a.xy = rot(a.xy, iTime*20.);\n    a = abs(a)-2.3;\n    return max(max(a.x,a.y),a.z);\n}\n\nvec3 normal(vec3 p){\nreturn normalize(\nvec3(\nds(vec3(p.x+0.01, p.yz))-ds(vec3(p.x-0.01, p.yz)),\nds(vec3(p.x, p.y+0.01,p.z))-ds(vec3(p.x, p.y+0.01,p.z)),\nds(vec3(p.xy,p.z+0.01))-ds(vec3(p.xy,p.z-0.01))\n)\n);\n}\n\nfloat luminance(vec3 v)\n{\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0)-a,2.0))/(3.14159*a);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\nvec3 sky(vec3 d, vec3 ld){\nfloat thetas = dot(ld, vec3(0.,0.,1.));\nfloat theta = dot(d, vec3(0.,0.,1.));\n//if(theta < 0.0)return vec3(0.);\nfloat thetay = dot(d,ld);\nfloat y = acos(thetay);\nfloat taa = dot(-d, vec3(0.,0.,1.));\nfloat tay = dot(-d,ld);\nfloat Fred = (1.0 -1.32004*exp(0.14318/taa))*(1.0+5.30694*exp(-2.48062*y)+0.3167*tay*tay);\nfloat F2 = 1.0-(-0.523242)*(1.0+5.30694*exp(-2.48062*y)+0.3167*thetas*thetas);\nfloat Fblue = (1.0 + -0.27416*exp(-0.0668/taa))*(1.0+0.20388*exp(-1.68898*y)+0.04418*tay*tay);\nif(theta<0.03)return F2*F2*vec3(0.05,0.02,(thetas)*0.1);\n\nreturn 0.2*vec3((1.0 - thetas)*Fred, Fblue*0.4*max(ld.z,0.), Fblue) + F2*F2*vec3(0.1,0.07,(thetas)*0.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv*=0.6;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //uv *= 0.6;\n    // if(iFrame < 20)discard;\n     //float tiles=10.;\n    int tiles = 3;\n    int samples = 3;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n    if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n\n    //int jk = iFrame%200;\n    \n    //uv*=2.;\n    //vec3 lig = normalize(vec3(0.,-1.,0.));\n    vec3 lig = normalize(vec3(0., -1.2, 0.));\n    vec3 d = normalize(vec3(uv.x, -1.0, uv.y));\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    //-0.8,0.4\n    d.xz = rot(d.xz, 90.);\n    d.yz = rot(d.yz,-50.);\n    d.xy = rot(d.xy,60.);\n   \n    vec3 p = vec3(0.,0.,0.);\n    //vec3 col = sky(d, lig);\n    vec3 col = vec3(0.);\n    float dd;\n   vec4 c = clouds(p,d,lig,dd);\n\n    col = col*c.w + c.xyz;\n    p = vec3(0.);\n    /*for(int i = 0; i < 20; i++){\n    float dist = ds(p);\n    if(dist < 0.01){\n    vec3 n = normal(p);\n    col = vec3(0.4,0.3,0.1)*max(dot(n, lig),0.3)+max(clouds(vec3(0.), reflect(d,n), lig),0.2)*0.2\n    +rough(0.1, dot(reflect(d,n), -lig))*0.1;\n    break;\n    }\n    p+=d*dist;\n    }*/\n    //col = ACESFilm(col);\n    //col = pow(col, vec3(1.0/2.2));\n\n   \n    // Output to screen\n    fragColor = vec4(col,dd);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float pis = 3.14159265358;\n\nvec2 rot2(vec2 a, float c){\nfloat g = c*pis/180.0;\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y,a.x)+g; \nreturn vec2(l*cos(ang),l*sin(ang));\n}\nfloat c_twopi = 3.14159*2.0;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}