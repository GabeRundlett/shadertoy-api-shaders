{
    "Shader": {
        "info": {
            "date": "1501051378",
            "description": "Using mirror symmetry to get this shape, without atan(y,x)  and with as few sqrt() as possible.\nDistance field lacks polar symmetry for not being polar-modulo.\n\nI expected to need sqrt(3) more here, but ;\nfloat a=3.73;// is VERY precise and rational.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dBBzK",
            "likes": 2,
            "name": "equilateral triangle incircle",
            "published": 3,
            "tags": [
                "symmetry",
                "triforce",
                "equilateral"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 606
        },
        "renderpass": [
            {
                "code": "/*\nMade an equilateral triangle, with just one sqrt(3.).\nmin(max())'ed incircle and circumcircle (radius 1 and radius 2) to ckeck intersections.\n\nusually you need sqrt(3) multiple times, for angle AND offsets.\nbut this utilizes one mirror symmetry and an efficient \"distance to line\" sdf_line6\n\nusing mirror symmetry instead of polar_modulo_atan(y,x) skews the distance field.\n*/\n\n//show distance field, illustrates the mirror symmetry\n//#define showdist\n\n//rotate over time\n#define spin\n\n//return signed distance of point [p] to line [a]\n//where [a] is the differential of 2 points that the line goes trough;\n//... you have a line trough [c]and [d] then a=c-d OR a=d-c;\n//which one you chose to define [a] sets the sign of the distance == line direction.\nfloat sdf_line6(vec2 p,vec2 a){a.x=-a.x;return dot(a.yx,p);}\n//for the above, a must be normalized, which is done by wrapper below.\nfloat sdf_line6n(vec2 p,vec2 a){return sdf_line6(p,normalize(a));}\n//https://www.shadertoy.com/view/4dBfzG\n\n//#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvec2 frame(vec2 u){u/=iResolution.xy;u-=.5;\nif(iResolution.x>iResolution.y)u.x*=iResolution.x/iResolution.y;\nelse u.y*=iResolution.y/iResolution.x;return u*5.;}\n\n#define rm(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n\n#define ss(a) a=smoothstep(.003,-.003,a);\n\n//return distance to equilateral triangle, minus incircle\nfloat tri(vec2 u){\n //vec2 m=frame(iMouse.xy);\n //float l=sdf_line6(u,m);\n //l=abs(l);\n float a=3.73;//somehow this is VERY precise, but i expect something with sqrt(3)\n float t=sdf_line6(vec2(1.+abs(u.x),a+u.y),vec2(1.,sqrt(3.)));//mirror symmetry, rotated by sixth rotation.\n t=max(t,u.y-1.);//substract bloor side\n float f=length(u)-1.;//incircle\n t=max(t,-f);//substract incircle\n return t;\n}\n//note that the mirror symmetry is not polar-modulo, \n//therefore the distance field is skewed\n//here a skewed distance field is worth it, not using atan(y,x);\n\nvoid mainImage( out vec4 O, in vec2 U ){\n vec2 u=frame(U);\n #ifdef spin\n  u*=rm(iTime);\n #endif\n float t=tri(u);\n //u.y=-u.y;\n //u*=rm(floor(iTime*9.)*acos(0.)/1.5);\n //if (floor(iTime*9.)>=0.) u.y=-u.y;\n //float l=tri(u);\n //l=abs(l);\n\n t=min(t,2.-length(u));//outer circle, radius 2.\n t=-t;//invert\n #ifdef showdist\n t=fract(t);//show distance field\n #else\n t=ss(t);//smooth borders\n #endif\n O=vec4(vec3(t,t,t),0);}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}