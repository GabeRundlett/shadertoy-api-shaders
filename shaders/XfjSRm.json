{
    "Shader": {
        "info": {
            "date": "1706156243",
            "description": "-tmm reduced loop iterations ~18fps -> 48fps on my machine\n  ifdef'ed out unused functions\nTrying to compute modular forms and especially: https://en.wikipedia.org/wiki/J-invariant with only FP32 precision.\nUndefine DISC to see the half-plane model",
            "flags": 0,
            "hasliked": 0,
            "id": "XfjSRm",
            "likes": 18,
            "name": "Modular forms Faster w/MouseZoom",
            "published": 3,
            "tags": [
                "modularforms",
                "jinvariant"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "// Fork of \"Modular forms Faster\" by timmaffett. https://shadertoy.com/view/4cjXzw\n// 2024-01-25 04:16:46\n\n// Fork of \"Modular forms\" by nimitz. https://shadertoy.com/view/sdcyW8\n// 2024-01-25 03:50:51\n\n// -tmm All I did here is reduce the loop iterations with little or no visible effect but\n//  sped it up from 18fps to 48fps on my machine.\n// also if'def out unused functions for faster compile\n//\n//   Oh and I added mouse rotate/zoom\n\n//Modular forms by nimitz (nmz) 2024\n\n/*\n    See vec3 f(vec2 z) for more functions! (line ~200)\n*/\n\n#define DISC\n#define ALT_PALETTE\n\n#define pi 3.1415926535\nvec2 qn(vec2 z, float n){ return cexp(2.*n*pi*cmuli(z)); }\nvec2 qinv(vec2 z){ return cdiv(cmuli(-z) + vec2(1,0), z - vec2(0,1)); }\nmat2 rot2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n#ifdef USED\n//Eisenstein series\nvec2 e4(vec2 z)\n{\n    vec2 rz = vec2(0.,0.);\n    for(float n = 1.; n<50.; n++)\n    {\n        vec2 q = qn(z, n);\n        rz += cdiv(n*n*n*q, vec2(1., 0.) - q);\n    }\n    return vec2(1.0, 0.) + 240.*rz;\n}\n\nvec2 e6(vec2 z)\n{\n    vec2 rz = vec2(0);\n    for(float n = 1.; n<50.; n++)\n    {\n        float n2 = n*n;\n        vec2 q = qn(z, n);\n        rz += cdiv(n2*n2*n*q, vec2(1., 0.) - q);\n    }\n    return vec2(1.0, 0.0) - 504.*rz;\n}\n\nvec2 e8(vec2 z)\n{\n    vec2 rz = vec2(0);\n    for(float n = 1.; n<50.; n++)\n    {\n        float n3 = n*n*n;\n        vec2 q = qn(z, n);\n        rz += cdiv(n3*n3*n*q, vec2(1., 0.) - q);\n    }\n    return vec2(1.0, 0.0) + 480.*rz;\n}\n#endif\n\n// Dedekind eta function (Euler function with final scaling factor)\nvec2 eta(vec2 z)\n{\n    vec2 prod = vec2(1.,0.);\n    for(float n = 1.; n<5.0 /*50.*/; n++)\n    {\n        vec2 q = qn(z, n);\n        prod = cmul(prod, vec2(1.,.0)-q);\n    }\n    vec2 ml = cexp(pi*cmuli(z)/12.);\n    return cmul(ml, prod);\n}\n\n// eta squared\nvec2 eta2(vec2 z)\n{\n    vec2 prod = vec2(1.,.0);\n    for(float n = 1.; n<5.0 /*50.0*/ /*150.*/; n++)\n    {\n        vec2 q = qn(z, n);\n        prod = cmul(prod, csqr(vec2(1.,.0)-q));\n    }\n    vec2 ml = cexp(pi*cmuli(z)/6.);\n    return cmul(ml, prod);\n}\n\n// eta cubed\nvec2 eta3(vec2 z)\n{\n    vec2 prod = vec2(1.,.0);\n    for(float n = 1.; n<5.; n++)\n    {\n        vec2 q = qn(z, n);\n        prod = cmul(prod, cpow(vec2(1.,.0)-q, 3.));\n    }\n    vec2 ml = cexp(pi*cmuli(z)/4.);\n    return cmul(ml, prod);\n}\n#ifdef USED\nvec2 eta8(vec2 z)\n{\n    vec2 prod = vec2(1.,.0);\n    for(float n = 1.; n<20.; n++)\n    {\n        vec2 q = qn(z, n);\n        prod = cmul(prod, cpow(vec2(1.,.0)-q, 8.));\n    }\n    vec2 ml = cexp(pi*cmuli(z)/1.5);\n    return cmul(ml, prod);\n}\n\n// modular discriminant\nvec2 delta(vec2 z)\n{\n    if (z.y < 0.0) return vec2(0);\n    vec2 prod = vec2(1.,0.);\n    for(float n = 1.; n<50.; n++)\n    {\n        vec2 q = qn(z, n);\n        prod = cmul(prod, cpow(vec2(1.,.0)-q, 24.));\n    }\n    vec2 ml = cexp(2.*pi*cmuli(z));\n    return cmul(ml, prod)*pow(6.2831853,12.);\n}\n\n// Jacobi theta function\nvec2 theta(vec2 z, vec2 tau)\n{\n    vec2 rez = vec2(0);\n    for(float n = -30.; n<15.; n++)\n    {\n        rez += cexp(pi*cmuli(n*n*tau + 2.*n*z));\n    }\n    return rez;\n}\n\n// Z = 0,1/5\nvec2 theta0(vec2 tau)\n{\n    vec2 z = vec2(0,.5);\n    vec2 rz = vec2(0);\n    for(float n = -12.; n<12.; n++)\n    {\n        rz += cexp(pi*n*n*cmuli(tau) + 2.*pi*n*cmuli(z));\n    } \n    return rz;\n}\n#endif\n\n// j-function / j-invariant\nvec3 jfunc(vec2 z)\n{\n    if (z.y < -.0) return vec3(0);\n    // using auxilliary theta functions\n    vec2 et = eta(z);\n    vec2 a = cdiv(2.*eta2(2.*z), et); // ϑ_10 (θ_2)\n    vec2 b = cdiv(eta2(0.5*(z+vec2(1,0))), eta(z + vec2(1,0))); // ϑ_00 (θ_3)\n    vec2 c = cdiv(eta2(.5*z), et); // ϑ_01 (θ_3) \n    vec2 num = cpow(cpow(a,8.) + cpow(b,8.) + cpow(c,8.), 3.);\n    vec2 den = cmul(cmul(a,b),c);    \n    vec2 rz = 32.*cdiv(num, cpow(cmul(cmul(a,b),c),8.));\n    float of = 1.;\n    #if 1\n    // Hack to get higher precision\n    if (length(rz) > 1e20)\n    {\n        of = 7.;\n        a *= of;b *= of;c *= of;\n        rz = cdiv(num, cpow(cmul(cmul(a,b),c),8.));\n    }\n    #endif\n    \n    return vec3(rz,of);\n}\n\n#ifdef USED\n// Modular lambda function\nvec2 lambda(vec2 z)\n{\n    vec2 nm = 1.414*cmul(eta(z*0.5), eta2(2.*z));\n    return cpow(cdiv(nm, eta3(z)), 8.);\n}\n\n// Lambert series\nvec2 lambert(vec2 z)\n{\n    vec2 rz = vec2(0);\n    for(float n = 1.; n<75.; n++)\n    {\n        vec2 q = qn(z, n);\n        rz += 10.*n*cdiv(q, vec2(1.,0.) - q);\n    }\n    return rz;\n}\n\n// e4 as a series of coefficients\nint[100] coeffs = int[100](1, 240, 2160, 6720, 17520, 30240, 60480, 82560, 140400, 181680, 272160, 319680, 490560, 527520, 743040, 846720, 1123440, 1179360, 1635120, 1646400, 2207520, 2311680, 2877120, 2920320, 3931200, 3780240, 4747680, 4905600, 6026880, 5853600, 7620480, 7150080, 8987760, 8951040, 10614240, 10402560, 13262640, 12156960, 14817600, 14770560, 17690400, 16541280, 20805120, 19081920, 23336640, 22891680, 26282880, 24917760, 31456320, 28318320, 34022160, 33022080, 38508960, 35730720, 44150400, 40279680, 48297600, 46099200, 52682400, 49291200, 61810560, 54475680, 64350720, 62497920, 71902320, 66467520, 80559360, 72183360, 86093280, 81768960, 93623040, 85898880, 106282800, 93364320, 109412640, 105846720, 120187200, 109969920, 132935040, 118329600, 141553440, 132451440, 148871520, 137229120, 168752640, 148599360, 171737280, 163900800, 187012800, 169192800, 206025120, 181466880, 213183360, 200202240, 224259840, 207446400, 251657280, 219041760, 254864880, 241997760);\nvec2 e4Series(vec2 z)\n{\n    vec2 rz = vec2(1,0);\n    for(int i = 1; i < 100; i++)\n    {\n        rz += float(coeffs[i]) * cpow(qn(z, 1.), float(i));\n    }\n    return rz;\n}\n#endif\n\nvec3 f(vec2 z)\n{   \n    vec3 v = vec3(0);\n    z = abs(z);\n    \n    v = jfunc(z); v.xy*=1e-16; //coloring scale\n    //v.xy = eta8(z);\n    //v.xy = e4(z);\n    //v.xy = e4Series(z);\n    //v.xz = lambert(z);\n    //v.xz = lambda(z);\n    //v.xz = theta0(z);\n    \n    return v;\n}\n\nvec3 render(vec2 p)\n{\n\n#ifdef DISC\n        float t = iTime;\n        float lz = length(p);\n        p *= rot(-t*.15);\n        p = qinv(p);\n        p *= rot(-t*0.07 + 1.57);\n        p.x += iTime*.22;\n        \n#else\n        p.y += 1.;\n        p *= 0.74;\n#endif\n    \n    //numerical derivatives for coloring\n    vec2 e = vec2(0.0001,0.);\n    vec3 col = vec3(0);\n    \n    vec3 z0 = f(p);\n    vec3 bz0 = z0;\n    vec3 zrg = f(p + e);\n    vec3 zup = f(p + e.yx);\n    float z0tt = atan(bz0.y,bz0.x);\n    \n    float frq = .3;\n    float z0t = sin(frq*atan(z0.y,z0.x));\n    float zrgt = sin(frq*atan(zrg.y,zrg.x));\n    float zupt = sin(frq*atan(zup.y,zup.x));\n    \n    float z = log(length(z0.xy));\n    float z2 = log(dot(z0.xy,z0.xy));\n    float zrg2 = log(dot(zrg.xy,zrg.xy));\n    float zup2 = log(dot(zup.xy,zup.xy));\n    \n    \n    vec3 nor = normalize(vec3(zrg2 - z2, .0007, zup2 - z2));\n    nor.xz *= rot2(iTime*.7);\n    \n    float dif = clamp(dot(nor, normalize(vec3(0.5,1.,0.5)))+.5,0.,1.);\n    vec3 norPhase = normalize(vec3(zrgt - z0t, 0.001, zupt - z0t));\n    float difPhase = dot(norPhase, normalize(vec3(0.5,.5,0.5)))*.5+0.5;\n    \n#ifdef ALT_PALETTE\nfloat off = 0.;\n    if (z0.z == 7.) off = -5. - sin(iTime*0.5);\n    col = pal(sin(z0t + 1.5708)*2.5 + -z2*(0.05 + sin(iTime*0.5)*0.01) - 4. + off);\n    col /= abs(sin(z*1.5 + 0.1))*0.25+.9;\n    col /= abs(sin(z0tt*1. + iTime*.4))*0.5 + .45;\n    col /= difPhase*.4+.7;\n    col /= dif*1. + .9;\n#else\n    float off = 0.;\n    if (z0.z == 7.) off = -5. - sin(iTime*0.5);\n    col = pal((abs(z0tt+1.)+.5)*0.2 - z2*(0.05 + sin(iTime*0.5)*0.01) + off - 1.3 - (sin(z0tt*2.+1.5708)*2.)*.0);\n    col /= difPhase*.4+.8;\n    col /= dif*0.55 + .8;\n#endif\n    \n    return col;\n}\n\n\n// simple mouse rotate and zoom for shader\n//#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n    return uv;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n    if(iMouse.xy!=vec2(0.)) {\n        p = mouseRotZoom(p);\n    }\n    vec3 col = render(p);\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float cabs (const vec2 c) { return dot(c,c); }\nvec2 cmuli(vec2 z) { return vec2(-z.y, z.x);}\nvec2 cadd(vec2 a, float s) { return vec2( a.x+s, a.y ); }\nvec2 cmul(vec2 a, vec2 b)  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv(vec2 a, vec2 b)  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cinv(vec2 z)  { float d = dot(z,z); return vec2( z.x, -z.y ) / d; }\nvec2 csqr(vec2 a) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt(vec2 z) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj(vec2 z) { return vec2(z.x,-z.y); }\nvec2 cpow(vec2 z, float n) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 cexp(vec2 z) {  return exp( z.x )*vec2( cos(z.y), sin(z.y) ); }\nvec2 cexp2(vec2 z) {  return exp2( z.x )*vec2( cos(z.y), sin(z.y) ); }\nvec2 clog(vec2 z) {  float d = dot(z,z);return vec2( 0.5*log(d), atan(z.y,z.x)); }\nvec2 csin(vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*sin(z.x),(r-1.0/r)*cos(z.x));}\nvec2 ccos(vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*cos(z.x),-(r-1.0/r)*sin(z.x));}\nfloat det(vec2 a, vec2 b) { return a.x*b.y-a.y*b.x;}\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\n// slightly higher precison\nvec2 ccos2(vec2 z) { return vec2(cos(z.x)*cosh(z.y), - sin(z.x)*sinh(z.y));}\n\n\nint imod(int a, int b){return a - (b * int(a/b));}\n\n//cheap viridis approx\nvec3 pal(float x)\n{\n    vec3 col = sin(x + vec3(4.1, -1., .6) - 1.1)*vec3(0.4, 0.37, 0.11) + vec3(0.6, 0.45, 0.33);\n    col.r *= col.r;\n    return col;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}