{
    "Shader": {
        "info": {
            "date": "1468803871",
            "description": "A variation of [url]https://www.shadertoy.com/view/MsdGzl[/url], which is pretty much a distorted Manger fractal: [url]https://www.shadertoy.com/view/4sX3Rn[/url]. Most of the lighting is indirect, so it takes a while to converge.",
            "flags": 32,
            "hasliked": 0,
            "id": "Xtt3Wn",
            "likes": 137,
            "name": "Fractal Cave",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "menger",
                "pathtracing",
                "montecarlo"
            ],
            "usePreview": 1,
            "username": "iq",
            "viewed": 25334
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n//\n// More info in this tutorial:\n// https://iquilezles.org/articles/simplepathtracing\n//\n// You can buy a metal print of this shader here:\n// https://www.redbubble.com/i/canvas-print/Cave-by-InigoQuilez/39845435.5Y5V7\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get color\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    col /= float(1+iFrame);\n    col = pow( col, vec3(0.4545) );\n    \n    // color grading\n    col = pow( col, vec3(0.8) ); col *= 1.6; col -= vec3(0.03,0.02,0.0);\n    \n    // vigneting\n\tvec2 p = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by inigo quilez - iq/2015\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n//\n// More info in this tutorial:\n// https://iquilezles.org/articles/simplepathtracing\n\n//------------------------------------------------------------------\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    // compute basis from normal\n    // see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nvec3 uniformVector( in float seed)\n{\n    float a = 3.141593*hash( 78.233 + seed);\n    float b = 6.283185*hash( 10.873 + seed);\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\n// https://iquilezles.org/articles/biplanar\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x+m.y+m.z);\n}\n\n//------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = max(di.x,max(di.y,di.z));\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat map( vec3 p )\n{\n    vec3 w = p;\n    vec3 q = p;\n\n    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;\n\n    float d = sdBox(q,vec3(1.0));\n    float s = 1.0;\n    for( int m=0; m<7; m++ )\n    {\n        float h = float(m)/6.0;\n\n        p =  q.yzx - 0.5*sin( 1.5*p.x + 6.0 + p.y*3.0 + float(m)*5.0 + vec3(1.0,0.0,0.0));\n\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n        d = max( c, d );\n   }\n    \n   return d*0.5;\n}\n\n//------------------------------------------------------------------\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0001;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float tmax = 16.0;\n    float t = 0.01;\n    for(int i=0; i<128; i++ )\n    {\n        float h = map(ro+rd*t);\n        if( h<0.0001 || t>tmax ) break;\n        t +=  h;\n    }\n    return (t<tmax) ? t : -1.0;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    const float tmax = 12.0;\n    float t = 0.001;\n    for(int i=0; i<80; i++ )\n    {\n        float h = map(ro+rd*t);\n        if( h<0.0001 || t>tmax ) break;\n        t += h;\n    }\n    return (t<tmax)?0.0:1.0;\n}\n\nconst vec3 sunDir = normalize(vec3(0.2,1.0,-0.5));\nconst vec3 sunCol =  10.0*vec3(1.2,0.9,0.7); \nconst vec3 skyCol =  3.0*vec3(0.3,0.5,0.7);\n\n// https://iquilezles.org/articles/simplepathtracing\nvec3 calculateColor(vec3 ro, vec3 rd, float sa )\n{\n    const float epsilon = 0.0001;\n\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 oro = ro;\n    vec3 ord = rd;\n\n    float fdis = 0.0;\n    for( int bounce = 0; bounce<4; bounce++ ) // bounces of GI\n    {\n        rd = normalize(rd);\n       \n        //-----------------------\n        // trace\n        //-----------------------\n        float t = intersect( ro, rd );\n        if( t < 0.0 )\n        {\n            if( bounce==0 ) { fdis=16.0; accumulatedColor = mix( 0.05*vec3(0.9,1.0,1.0), skyCol, smoothstep(0.1,0.25,rd.y) ); break; }\n            break;\n        }\n\n        if( bounce==0 ) fdis = t;\n\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal( pos );\n\n        vec3 surfaceColor = vec3(0.65,0.66,0.65);\n        surfaceColor *= texcube( iChannel1, pos*0.5, nor ).xyz*1.2;\n        surfaceColor.x += 0.09;        \n        \n        //-----------------------\n        // add direct lighitng\n        //-----------------------\n        colorMask *= surfaceColor;\n\n        vec3 iColor = vec3(0.0);\n\n        // light 1        \n        float sunDif =  max(0.0, dot(sunDir, nor));\n        float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = shadow( pos + nor*epsilon, sunDir);\n        iColor += sunCol * sunDif * sunSha;\n        // todo - add back direct specular\n\n        // light 2\n        vec3 skyPoint = cosineDirection( sa + 7.1*float(iFrame) + 5681.123 + float(bounce)*92.13, nor);\n        float skySha = shadow( pos + nor*epsilon, skyPoint);\n        iColor += skyCol * skySha;\n\n\n        accumulatedColor += colorMask * iColor;\n\n        //-----------------------\n        // calculate new ray\n        //-----------------------\n        float isDif = 0.5;\n        if( hash(sa + 1.123 + 7.7*float(bounce)) < isDif )\n        {\n           rd = cosineDirection(76.2 + 73.1*float(bounce) + sa + 17.7*float(iFrame), nor);\n        }\n        else\n        {\n            float glossiness = 0.2;\n            rd = normalize(reflect(rd, nor)) + uniformVector(sa + 111.123 + 65.2*float(bounce)) * glossiness;\n        }\n\n        ro = pos;\n   }\n\n   // extintion\n   accumulatedColor *= exp(-0.1*fdis);\n\n   // volumetrics\n   float acc = 0.0;\n   for( int i=0; i<5; i++ )\n   {\n       float t = fdis*hash(sa+1.31+13.731*float(i)+float(iFrame)*7.773);\n       vec3 pos = oro + ord*t;\n       acc += 0.2*shadow( pos, sunDir );\n   }\n   accumulatedColor += vec3(0.1)*pow(acc,2.0)*sunCol*0.4;\n    \n   return accumulatedColor;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame) );\n    \n    vec2 of = vec2( hash(sa+13.271), hash(sa+63.216) )-0.5;\n    vec2 pi = (2.0*(fragCoord+of)-iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(-0.2,0.0,0.00);\n    vec3 ta = vec3( 1.5,0.8,2.45);\n\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(pi,-1.3) );\n\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    if( iFrame==0 ) col = vec3(0.0);\n    \n    col += calculateColor( ro, rd, sa );\n \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}