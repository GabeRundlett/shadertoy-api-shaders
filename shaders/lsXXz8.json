{
    "Shader": {
        "info": {
            "date": "1396527232",
            "description": "Just a little test...",
            "flags": 0,
            "hasliked": 0,
            "id": "lsXXz8",
            "likes": 6,
            "name": "Little test",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 493
        },
        "renderpass": [
            {
                "code": "#define DELTA\t\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t50.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\t\tvec3 (0.5, 0.75, 1.0)\n#define BACK_COLOR\t\t\tvec3 (0.25, 0.5, 1.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t4.0\n#define SPECULAR_INTENSITY\t0.5\n#define REFLECT_COUNT\t\t2\n#define FADE_POWER\t\t\t2.0\n#define GAMMA\t\t\t\t(1.0 / 2.2)\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n#define SHADOW\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\nfloat sphere (in vec3 p, in float r) {\n\treturn length (p) - r;\n}\n\nfloat box (in vec3 p, in vec3 b, in float r) {\n\treturn length (max (abs (p) - b + r, 0.0)) - r;\n}\n\nfloat plane (in vec3 p, in vec3 n, in float d) {\n\treturn dot (p, normalize (n)) + d;\n}\n\nfloat torusZ (in vec3 p, in float r1, in float r2) {\n\tvec2 q = vec2 (length (p.xy) - r1, p.z);\n\treturn length (q) - r2;\n}\n\nfloat cylinderX (in vec3 p, in float r) {\n \treturn length (p.yz) - r;\n}\n\nfloat cylinderY (in vec3 p, in float r) {\n \treturn length (p.xz) - r;\n}\n\nvec3 twistY (in vec3 p, in float k, in float angle) {\n\treturn vRotateY (p, angle + k * p.y);\n}\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat getDistance (in vec3 p, out vec4 q) {\n\n\t// Ground\n\tvec3 q_ = p;\n\tq_.z += 0.8 * (sin (iTime + p.x * 0.5) + sin (p.y * 0.5));\n\tfloat dist = fixDistance (plane (q_, vec3 (-0.2, 0.0, 1.0), 5.0), 0.6, 0.8); // need to fix the distance because of the sine deformation\n\tq = vec4 (q_, 0.0);\n\n\t// Twisted box\n\tq_ = p;\n\tq_.x -= 5.0;\n\tq_ = twistY (q_, cos (iTime), iTime);\n\tfloat dist_ = fixDistance (box (q_, vec3 (1.0, 1.0, 1.0), 0.1), 0.2, 0.8); // need to fix the distance because of the twist\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 1.0);\n\t\tdist = dist_;\n\t}\n\n\t// Simple box\n\tq_ = p;\n\tq_.y -= 3.0;\n\tq_ = mRotate (vec3 (0.7, 0.0, -0.2)) * q_;\n\tdist_ = box (q_, vec3 (1.0, 0.5, 1.0), 0.3);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 2.0);\n\t\tdist = dist_;\n\t}\n\n\t// Sphere\n\tq_ = p + vec3 (3.0, -1.0, sin (iTime * 2.0) - 1.0);\n\tdist_ = sphere (q_, 1.0);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 3.0);\n\t\tdist = dist_;\n\t}\n\n\t// Twisted torus\n\tq_ = p;\n\tq_.y += 4.0;\n\tq_ = twistY (q_, 2.0, 0.0);\n\tdist_ = fixDistance (torusZ (q_, 1.0, 0.3), 0.8, 0.5); // need to fix the distance because of the twist\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 4.0);\n\t\tdist = dist_;\n\t}\n\n\t// Cylinders\n\tq_ = p;\n\tq_.z += 2.0;\n\tq_.y = mod (q_.y, 5.0) - 0.5 * 5.0;\n\tdist_ = cylinderX (q_, 0.2);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 5.0);\n\t\tdist = dist_;\n\t}\n\tq_ = p;\n\tq_.z += 2.0;\n\tq_.x = mod (q_.x, 5.0) - 0.5 * 5.0;\n\tdist_ = cylinderY (q_, 0.2);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 6.0);\n\t\tdist = dist_;\n\t}\n\n\t// Smallest distance\n\treturn dist;\n}\n\nvec3 getObjectColor (in vec4 q, out float reflection) {\n\tfloat tint = 0.6 + 0.4 * sin (q.x * 10.0) * sin (q.y * 10.0) * sin (q.z * 10.0);\n\tif (q.w < 0.5) {\n\t\treflection = 0.0;\n\t\treturn (0.6 + 0.4 * tint) * vec3 (0.2, 1.0, 1.0);\n\t}\n\tif (q.w < 1.5) {\n\t\treflection = 0.2;\n\t\treturn tint * vec3 (1.0, 0.0, 0.0);\n\t}\n\tif (q.w < 2.5) {\n\t\treflection = 0.0;\n\t\treturn tint * vec3 (0.0, 0.0, 1.0);\n\t}\n\tif (q.w < 3.5) {\n\t\treflection = 0.5;\n\t\treturn tint * vec3 (1.0, 1.0, 0.0);\n\t}\n\tif (q.w < 4.5) {\n\t\treflection = 0.0;\n\t\treturn tint * vec3 (1.0, 0.2, 0.5);\n\t}\n\treflection = 0.0;\n\treturn tint * vec3 (0.5, 0.5, 0.6);\n}\n\nvec3 getNormal (in vec3 p) {\n\tvec4 q;\n\tvec2 h = vec2 (DELTA, 0.0);\n\treturn normalize (vec3 (\n\t\tgetDistance (p + h.xyy, q) - getDistance (p - h.xyy, q),\n\t\tgetDistance (p + h.yxy, q) - getDistance (p - h.yxy, q),\n\t\tgetDistance (p + h.yyx, q) - getDistance (p - h.yyx, q)\n\t));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Old monitor effect\n\tvec2 frag = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tfloat round = pow (length (frag * frag), 6.0);\n\tfrag.y *= 1.0 + round * 0.2;\n\tvec3 colorMonitor = vec3 (1.0 - round);\n\tcolorMonitor *= vec3 (0.8, 1.0 + abs (mod (frag.y, 0.04) / 0.04 - 0.5), 0.8);\n\n\t// Define the ray corresponding to this fragment\n\tfrag.x *= iResolution.x / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tfloat angle = M_PI * sin (0.1 * iTime);\n\tvec3 origin = vec3 (10.0 * cos (angle), 10.0 * sin (angle), 2.5);\n\tdirection = mRotate (vec3 (M_PI / 2.0 + 0.45, 0.0, angle - M_PI / 2.0)) * direction;\n\n\t// Compute the fragment color\n\tvec3 lightDirection = normalize (LIGHT);\n\tfloat moveAway = DELTA * 10.0;\n\n\tvec3 color = vec3 (0.0, 0.0, 0.0);\n\tfloat absorb = 1.0;\n\tfloat fade = 0.0;\n\tfor (int reflectionIndex = 0; reflectionIndex < REFLECT_COUNT; ++reflectionIndex) {\n\n\t\t// Ray marching\n\t\tvec4 objectInfo;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = getDistance (origin, objectInfo);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += dist * direction;\n\t\t}\n\n\t\t// Combine colors\n\t\tif (reflectionIndex == 0) {\n\t\t\tfade = pow (max (0.0, 1.0 - rayLength / RAY_LENGTH_MAX), FADE_POWER);\n\t\t} else {\n\t\t\tcolor *= 1.0 - absorb;\n\t\t}\n\t\tif (rayLength > RAY_LENGTH_MAX) {\n\t\t\tcolor += BACK_COLOR * absorb;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the object color\n\t\tfloat reflection;\n\t\tvec3 objectColor = getObjectColor (objectInfo, reflection);\n\n\t\t// Lighting\n\t\tvec3 normal = getNormal (origin);\n\t\tdirection = reflect (direction, normal);\n\n\t\t#ifdef SHADOW\n\t\tvec3 p = origin + moveAway * lightDirection;\n\t\trayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = getDistance (p, objectInfo);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp += dist * lightDirection;\n\t\t}\t\t\n\t\tif (rayLength < RAY_LENGTH_MAX) {\n\t\t\tobjectColor *= AMBIENT;\n\t\t}\n\t\telse\n\t\t#endif\n\t\t{\n\t\t\tfloat diffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat specular = pow (max (0.0, dot (direction, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tobjectColor = (AMBIENT + diffuse) * objectColor + specular;\n\t\t}\n\t\tcolor += objectColor * absorb;\n\n\t\t// Next ray...\n\t\tif (reflection < DELTA) {\n\t\t\tbreak;\n\t\t}\n\t\tabsorb *= reflection;\n\t\torigin += moveAway * direction;\n\t}\n\n\t// Fading\n\tcolor = mix (BACK_COLOR, color, fade);\n\n\t// Gamma correction\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Set the fragment color\n\tfragColor = vec4 (color * colorMonitor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}