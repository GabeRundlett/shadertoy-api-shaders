{
    "Shader": {
        "info": {
            "date": "1603132720",
            "description": "Minimalistic recreation of the solar system using squares",
            "flags": 0,
            "hasliked": 0,
            "id": "WdVyzG",
            "likes": 4,
            "name": "Solar System Screensaver",
            "published": 3,
            "tags": [
                "space"
            ],
            "usePreview": 0,
            "username": "Manaz",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "/*\nby Manas Khadka 18 October 2020.\n\nThis is my first ever shader. Just me messing around.\nDistance between planets and sun is not perfect.\nAll planets and their orbits are to scale unless specified.\nThe sun's radius is 1/4 what it should be.\n\nA lot of reference is taken from Uğur Güney's GLSL 2D Tutorials.\n*/\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.0005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = vec2(fragCoord.xy - 0.5*iResolution.xy);\n\tr = 2.0 * r.xy / iResolution.y;\n\t// r.y will be in [-1.0, 1.0]\n\t// r.x will be in [-1.7778, 1.7778] (16:9 resolution) \n    \n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    // p.x and p.y will be in [0.0, 1.0]\n    \n    float xMax = iResolution.x/iResolution.y;\n    // in case the maximum x value is needed for reference in r.xy\n    \n\tvec3 ret;\n\n//START OF CHANGEABLE VARIABLES\n   \n   \tvec3 col =  0.5*sin(iTime*.05*vec3(8,6,4));\n    // time changing color - if you don't like it just comment this line out and remove the // from below\n    // vec3 col = vec3(.2);\n  \n    float mercRev = 7.5;\n    // change this variable to change the speed of all orbits\n    \n     float mercOrbit = .025;\n    // change this variable to change the distance of orbits\n    // make it bigger to zoom in on the orbit; smaller to zoom out (the size of planets/sun don't change)\n    \n    float sunRadius = 0.1;\n    // change this variable to change the size of all objects\n\n    vec3 colSun = vec3(1);\n    vec3 colMerc = vec3(1);\n    vec3 colVen = vec3(1);\n    vec3 colEarth = vec3(1);\n    vec3 colMars = vec3(1);\n    vec3 colJup = vec3(1);\n    vec3 colSat = vec3(1);\n    vec3 colUran = vec3(1);\n    vec3 colNept = vec3(1);\n    // if you want to color the planets, do so here!\n    \n//END OF CHANGEABLE VARIABLES\n   \n    float mercRadius = sunRadius / 66.0 * 2.0;\n    // modelled at 1/2 scale (double what it should be)\n    float venRadius = sunRadius / 26.6 * 2.0;\n    // modelled at 1/2 scale \n    float earthRadius = sunRadius / 25.0 * 2.0;\n    // modelled at 1/2 scale \n    float marsRadius = sunRadius / 47.6 * 2.0;\n    // modelled at 1/2 scale\n    float jupRadius = (sunRadius / 2.3);\n    float satRadius = (sunRadius / 2.76);\n    float uranRadius = sunRadius / 6.35;\n    float neptRadius = sunRadius / 6.54;\n    \n    float venRev = mercRev/2.55;\n    float earthRev = mercRev/ 5.15;\n    float marsRev = mercRev/7.8;\n    float jupRev = mercRev/45.6;\n    float satRev = mercRev/122.36;\n    float uranRev = mercRev/369.6;\n    float neptRev = mercRev/732.2;\n   \n    float venOrbit = mercOrbit * 1.82;\n    float earthOrbit = mercOrbit * 2.95;\n    float marsOrbit = mercOrbit * 4.25;\n    float jupOrbit = mercOrbit * 13.14;\n    float satOrbit = mercOrbit * 18.12;\n    float uranOrbit = mercOrbit * 30.24;\n    float neptOrbit = mercOrbit * 47.7;\n        \n    float xMerc = (0.14 + mercOrbit)*cos(iTime*mercRev);\n    float yMerc = (0.14 + mercOrbit)*cos(iTime*mercRev + PI/2.0);\n    \n    float xVen = (0.15 + venOrbit)*cos(iTime*venRev);\n    float yVen = (0.15 + venOrbit)*cos(iTime*venRev + PI/2.0);\n    \n    float xEarth = (0.15 + earthOrbit)*cos(iTime*earthRev);\n    float yEarth = (0.15 + earthOrbit)*cos(iTime*earthRev + PI/2.0);\n    \n    float xMars = (0.15 + marsOrbit)*cos(iTime*marsRev);\n    float yMars = (0.15 + marsOrbit)*cos(iTime*marsRev + PI/2.0);\n    \n    float xJup = (0.15 + jupOrbit)*cos(iTime*jupRev);\n    float yJup = (0.15 + jupOrbit)*cos(iTime*jupRev + PI/2.0);\n    \n    float xSat = (0.15 + satOrbit)*cos(iTime*satRev);\n    float ySat = (0.15 + satOrbit)*cos(iTime*satRev + PI/2.0);\n    \n    float xUran = (0.15 + uranOrbit)*cos(iTime*uranRev);\n    float yUran = (0.15 + uranOrbit)*cos(iTime*uranRev + PI/2.0);\n    \n    float xNept = (0.15 + neptOrbit)*cos(iTime*neptRev);\n    float yNept = (0.15 + neptOrbit)*cos(iTime*neptRev + PI/2.0);\n    \n    float sunx = 0.001*cos(iTime*1.0);\n    float suny = 0.001*cos(iTime*1.0 + PI/2.0);\n\n    ret = col;\n    // background color\n    \n    float radius = 0.2 + 0.1*sin(iTime*2.0);;\n    ret = mix(ret, colSun, rect(r, vec2(sunx-sunRadius, suny-sunRadius), vec2(sunx+sunRadius, suny+sunRadius)));\n    ret = mix(ret, colMerc, rect(r, vec2(xMerc-mercRadius, yMerc-mercRadius), vec2(xMerc+mercRadius, yMerc+mercRadius)));\n    ret = mix(ret, colVen, rect(r, vec2(xVen-venRadius, yVen-venRadius), vec2(xVen+venRadius, yVen+venRadius)));\n    ret = mix(ret, colEarth, rect(r, vec2(xEarth-earthRadius, yEarth-earthRadius), vec2(xEarth+earthRadius, yEarth+earthRadius)));\n    ret = mix(ret, colMars, rect(r, vec2(xMars-marsRadius, yMars-marsRadius), vec2(xMars+marsRadius, yMars+marsRadius)));\n    ret = mix(ret, colJup, rect(r, vec2(xJup-jupRadius, yJup-jupRadius), vec2(xJup+jupRadius, yJup+jupRadius)));\n    ret = mix(ret, colSat, rect(r, vec2(xSat-satRadius, ySat-satRadius), vec2(xSat+satRadius, ySat+satRadius)));\n    ret = mix(ret, colUran, rect(r, vec2(xUran-uranRadius, yUran-uranRadius), vec2(xUran+uranRadius, yUran+uranRadius)));\n    ret = mix(ret, colNept, rect(r, vec2(xNept-neptRadius, yNept-neptRadius), vec2(xNept+neptRadius, yNept+neptRadius)));\n\n    vec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}