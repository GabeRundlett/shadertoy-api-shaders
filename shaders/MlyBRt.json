{
    "Shader": {
        "info": {
            "date": "1544067479",
            "description": "aircraft",
            "flags": 0,
            "hasliked": 0,
            "id": "MlyBRt",
            "likes": 2,
            "name": "aircraft3",
            "published": 3,
            "tags": [
                "aircraft"
            ],
            "usePreview": 0,
            "username": "lise",
            "viewed": 462
        },
        "renderpass": [
            {
                "code": "const float MATH_PI = float( 3.14159265359 );\nconst vec3 SKY_COLOR = vec3(0.05, 0.2, 0.5);\nconst vec3 LIGHT = normalize( vec3(  0.1, 0.8,  0.9 ) );\nconst vec3 LIGHT_BACK = LIGHT * - 1.0;\nconst float AIRPLANE_SIZE = 20.0; // AIRPLANE描画範囲直径\nconst float AIRPLANE_SCALE = 1.0; // AIRPLANEスケール\nconst float TIME_SCALE = 1.0;\nconst float EP = 0.0001;\nconst int AIRPLANE_COUNT = 5;\nconst float PI = 3.141592;\nconst float PI2 = PI * 2.0;\n\nmat3 airplanes[AIRPLANE_COUNT];\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\nvec3 foldXZ(vec3 p)\n{\n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    return p;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a),c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec4 dElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat dSphere(vec3 pos, float size)\n{\n    return length(pos) - size;\n}\n\nfloat dEllipsoid(vec3 pos, vec3 size)\n{\n    return dSphere(pos / size, 1.0);\n}\n\nfloat dRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat dBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat dTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat dTree(vec3 po, inout vec4 hitColor)\n{\n    vec3 p = po;\n    // p = vec3(floor(p.x),floor(p.y),floor(p.z));\n    p.x = mod(p.x, 20.) - 10.0;\n    p.z = mod(p.z, 20.) - 10.0;\n\n    vec3 size = vec3(0.4, 4.0, 0.4);\n    float branch = dBox(p, size);\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 q = foldXZ(p);\n        q.y -= size.y;\n        q.xy *= rotate(-0.4);\n        q.zy *= rotate(-0.4);\n        branch = min(branch, dBox(q, size));\n        p = q;\n    }\n\n    p.y -= size.y;\n    float leaf = dEllipsoid(p, vec3(3,2,3));\n\n    if (branch < leaf)\n    {\n        hitColor = vec4(0.44, 0.29, 0.22, 1.0);\n    }\n    else\n    {\n        float hoge = step(fract(po.x) + fract(po.y) + fract(po.z), 0.9) * 0.5;\n        hitColor = vec4(0.44 - hoge, 0.99 - hoge, 0.22 - hoge, 1.0);\n    }\n\n    return min(branch, leaf);\n}\n\nvec3 rotateX(vec3 position, float rotate)\n{\n    return vec3(position.x, position.z * -sin(rotate) + position.y * cos(rotate), position.z * cos(rotate) + position.y * sin(rotate));\n}\n\nfloat dAircraft(vec3 ray, inout vec4 hitColor)\n{\n    vec3 body1 = vec3(0.5, 0.6, 2.0) * AIRPLANE_SCALE;\n    vec3 body1Pos = vec3(0, 0.2, -1.) * AIRPLANE_SCALE;\n    float body1Rot = 3.14 * -0.03;\n    vec3 body2 = vec3(1, 1, 5) * AIRPLANE_SCALE;\n    vec3 body2Pos = vec3(0, 1, 0) * AIRPLANE_SCALE;\n    float body2Rot = 3.14 * 0.0;\n    vec3 body3 = vec3(0.5, 0.9, 7) * AIRPLANE_SCALE;\n    vec3 body3Pos = vec3(1, -1, 1.1) * AIRPLANE_SCALE;\n    float body3Rot = 3.14 * 0.5;\n    vec2 body4 = vec2(0.3, 0.1) * AIRPLANE_SCALE;\n    vec3 body4Pos = vec3(-1.5, 1.5, 1) * AIRPLANE_SCALE;\n    float body4Distortion = 3.14 * 0.0;\n    vec2 body5 = vec2(8.0, -6.0) * AIRPLANE_SCALE;\n    vec3 body5Pos = vec3(0, -1, 0) * AIRPLANE_SCALE;\n    vec2 body6 = vec2(4.0, -3.0) * AIRPLANE_SCALE;\n    vec3 body6Pos = vec3(0, -1.1, -5) * AIRPLANE_SCALE;\n    vec3 body7 = vec3(2.4, 0.5, 2.0) * AIRPLANE_SCALE;\n    vec3 body7Pos = vec3(0, 1.5, 5) * AIRPLANE_SCALE;\n    vec3 body8_1 = vec3(1.2, 0, -4.0) * AIRPLANE_SCALE;\n    vec3 body8_2 = vec3(2.4, 2.5, -7.5) * AIRPLANE_SCALE;\n    vec3 body8_3 = vec3(1.4, -1., -7.5) * AIRPLANE_SCALE;\n    vec3 body8Pos = vec3(0, -1, 0) * AIRPLANE_SCALE;\n\n    float body1Depth = dEllipsoid(rotateX(ray, body1Rot) + body1Pos, body1);\n    float body2Depth = dEllipsoid(rotateX(ray, body2Rot) + body2Pos, body2);\n    float body3Depth = dRoundCone(rotateX(vec3(ray.x, ray.y, ray.z), body3Rot) + body3Pos, body3.x, body3.y, body3.z);\n    // absしたい\n    float body3_1Depth = dRoundCone(rotateX(vec3(-ray.x, ray.y, ray.z), body3Rot) + body3Pos, body3.x, body3.y, body3.z);\n    vec4 body4_ = dElongate(vec3(abs(ray.x), ray.y, ray.z) + body4Pos + vec3(0, 0, ray.y * -0.5), vec3(0.6, 0.1, 2.0));\n    float body4Depth = body4_.w + dTorus(rotateX(body4_.xzy + vec3(0, 0, 0), body4Distortion), body4);\n    float body5Depth = dTriangle(ray, vec3(body5.x, 0.0, body5.y) + body5Pos, vec3(-body5.x, 0.0, body5.y) + body5Pos, body5Pos) - 0.3;\n    float body6Depth = dTriangle(ray, vec3(body6.x, 0.0, body6.y) + body6Pos, vec3(-body6.x, 0.0, body6.y) + body6Pos, body6Pos) - 0.2;\n    float body7Depth = dBox(ray + body7Pos + vec3(0, 0, ray.y * -0.5), body7);\n    float body8Depth = dTriangle(vec3(abs(ray.x), ray.y, ray.z), body8_1 + body8Pos, body8_2 + body8Pos, body8_3 + body8Pos) - 0.1;\n\n    hitColor = vec4(1.0, 1.0, 1.0, 1.0);\n    float depth = min(min(min(min(min(min(min(min(body1Depth, body2Depth), body3Depth), body3_1Depth), body4Depth), body5Depth), body6Depth), body7Depth), body8Depth);\n\n    if (EP > abs(depth - body1Depth))\n    {\n        hitColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n\n    return depth;\n}\n\nvec3 dAircraftNormal(vec3 pos)\n{\n    vec4 _tmp;\n    return normalize(vec3(\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x - EP, pos.y, pos.z), _tmp),\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x, pos.y - EP, pos.z), _tmp),\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x, pos.y, pos.z - EP), _tmp)\n        ));\n}\n\nmat4 getWorldMat(mat3 transform)\n{\n    // trans world\n    vec3 axisX = cross(transform[1], transform[2]) * -1.0;\n\n    return mat4(\n        axisX.x, axisX.y, axisX.z, 0,\n        transform[1].x, transform[1].y, transform[1].z, 0,\n        transform[2].x, transform[2].y, transform[2].z, 0,\n        0, 0, 0, 1 \n        );\n}\n\nbool needRender(vec3 cameraPos, vec3 rayDirection, vec3 position, float size)\n{\n    // レンダリングが必要かどうか\n    return size > length(cameraPos + rayDirection * length(cameraPos - position) - position);\n}\n\nvoid airplaneRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    for (int i = 0; i < AIRPLANE_COUNT; i++)\n    {\n        if (!needRender(cameraPos, rayDirection, airplanes[i][0], AIRPLANE_SIZE))\n        {\n            // fixme\n            //return;\n        }\n\n        mat4 worldMat = getWorldMat(airplanes[i]);\n\n        vec3 localCameraPosition = (worldMat * vec4(cameraPos - airplanes[i][0], 1.0)).xyz;\n        vec3 localRayDirection = (worldMat * vec4(rayDirection, 1.0)).xyz;\n\n        float airplaneDepth = length(localCameraPosition) - AIRPLANE_SIZE * 0.5;\n        vec4 hitColor = color;\n\n        for (float marchDepth = 0.0; marchDepth < airplaneDepth + AIRPLANE_SIZE; marchDepth += AIRPLANE_SIZE * 0.001)\n        {\n            vec3 ray = localCameraPosition + localRayDirection * marchDepth;\n            float diff = dAircraft(ray, hitColor);\n\n            if (diff < EP)\n            {\n                if (depth > marchDepth + diff)\n                {\n                    depth = marchDepth + diff;\n                    vec3 normal = dAircraftNormal(ray);\n                    color = vec4(vec3(clamp(dot(normal, LIGHT) * hitColor, 0.0, 1.0)) + 0.2, 1.0);\n                }\n            }\n            else\n            {\n                // 細かい所に精度をよせる\n                marchDepth += diff;\n            }\n        }\n    }\n}\n\nvoid skyRender(inout vec4 color, float time, vec3 rayDirection)\n{\n    float sundot = clamp(dot(rayDirection, LIGHT), 0.0, 1.0);\n    float t = pow(1.0 - 0.7 * rayDirection.y, 15.0);\n    \n    vec3 col = 0.8 * SKY_COLOR;\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0 );\n    color = vec4(col, 1.0);\n}\n\nvoid groundRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{        \n    // 地平線が汚いので EP\n    if (-EP > rayDirection.y)\n    {\n        float groundDepth = abs((cameraPos.y) / rayDirection.y);\n        vec3 groundPoint = cameraPos + rayDirection * groundDepth;\n\n        depth = groundDepth;\n        float normal = clamp((dot(LIGHT, rayDirection) + 5.0) * 0.08, 0.2, 0.5);\n        color = vec4(normal, normal, normal, 1.0);\n\n        float line = step(mod(groundPoint.x, 10.0), 0.1) + step(mod(groundPoint.z, 10.0), 0.1);\n        color = color + vec4(line, line, line, 0);\n    }\n\n    // 木\n    float groundForestDepth = abs((cameraPos.y - 13.0) / rayDirection.y);\n    vec3 groundPoint = cameraPos + rayDirection * groundForestDepth;\n\n    vec4 hitColor = vec4(1,1,1,1);\n    for (float marchDepth = 0.0; marchDepth < 50.0; marchDepth += 0.1)\n    {\n        vec3 ray = groundPoint + rayDirection * marchDepth;\n        float diff = dTree(ray, hitColor);\n\n        if (diff < EP)\n        {\n            if (depth > groundForestDepth + marchDepth + diff)\n            {\n                depth = groundForestDepth + marchDepth + diff;\n                color = hitColor;\n                return;\n            }\n        }\n        else\n        {\n            // 細かい所に精度をよせる\n            marchDepth += diff;\n        }\n    }\n}\n\nvoid objectRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    airplaneRender(color, depth, time, cameraPos, rayDirection);\n}\n\nvec3 getAirplanePosition(float time)\n{\n    vec3 outline = vec3(cos(time * 0.2) * 1000.0, 40.0 + abs(sin(time * 0.1) * 100.0), sin(time * 0.2) * 1000.0);\n    return outline + vec3(cos(time) * 10.0, sin(time), sin(time) * 10.0);\n}\n\nvoid objectUpdate(float time)\n{\n    vec3 position = getAirplanePosition(time);\n    vec3 prevPosition = getAirplanePosition(time - EP);\n    vec3 nextPosition = getAirplanePosition(time + EP);\n    vec3 dir = normalize(nextPosition - position);\n    vec3 top = vec3(0, 1, 0);\n\n    airplanes[0] = mat3(position, top, dir);\n\n    mat4 leaderWorld = inverse(getWorldMat(airplanes[0]));\n\n    for(int index = 1; index < AIRPLANE_COUNT; index++)\n    {\n        int temp =index - 1;\n        airplanes[index] = mat3(position + (leaderWorld * vec4((float(temp) - 1.5) * 4.0, 0, step(1.0, abs(float(temp) - 1.5)) * 2.0 - 3.0, 1.0)).xyz * 10.0, top, dir);\n    }\n}\n\nvoid cameraUpdate(vec2 fragCoord, float time, out vec3 cameraPosition, out vec3 rayDirection)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    cameraPosition = vec3(800.0, 44.0 + clamp(airplanes[0][0].x * 0.1, 28.0, 200.), 400.0 + airplanes[0][0].z * 0.4);\n\n    vec3 cameraDirection = normalize(airplanes[0][0] - cameraPosition);\n    vec3 cameraTop = normalize(cameraDirection + vec3(0, 1, 0));\n    vec3 right = normalize(cross(cameraDirection, cameraTop));\n    cameraTop = cross(cameraDirection, right) * -1.0;\n\n    rayDirection = normalize(uv.x * right + uv.y * cameraTop + cameraDirection);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    float time = iTime * TIME_SCALE;\n    vec3 cameraPos;\n    vec3 rayDirection;\n    vec4 color;\n    float depth = 10000.0;\n\n    objectUpdate(time);\n    cameraUpdate(fragCoord, time, cameraPos, rayDirection);\n\n    skyRender(color, time, rayDirection);\n    groundRender(color, depth, time, cameraPos, rayDirection);\n    objectRender(color, depth, time, cameraPos, rayDirection);\n\n\tfragColor = color;\n\n    float debugcolor = depth * 0.01;\n    //fragColor = vec4(debugcolor, debugcolor, debugcolor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}