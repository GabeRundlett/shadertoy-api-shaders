{
    "Shader": {
        "info": {
            "date": "1616386013",
            "description": "first shader I've made without any tutorial.\nIf you watch it for a long time it produces some interesting color palettes. ",
            "flags": 0,
            "hasliked": 0,
            "id": "fdsGRf",
            "likes": 5,
            "name": "Endless Rainbow Well",
            "published": 3,
            "tags": [
                "2d",
                "rainbow"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 264
        },
        "renderpass": [
            {
                "code": "mat2 Rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c,-s,s,c);\n}\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur ,d);\n    return c;\n}\nvec3 endlessRGB(float offset, float iTime){\n    //color intensity\n    float colori = 0.4+0.25*(1.0+sin(iTime));\n    //magic\n    return vec3(\n    colori*(1.0+sin(mod(iTime/100.0,5.0)*mod(floor(offset),1000.0))),\n    colori*(1.0+sin(mod(iTime/100.0,5.0)*mod(floor(10.0+offset),1000.0))),\n    colori*(1.0+sin(mod(iTime/100.0,5.0)*mod(floor(20.0+offset),1000.0))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 cuv=uv; //Untoched uv for center stuff\n    \n    //manipulating UV to setup side walls\n    uv*=1.3;\n    clamp(uv.x,-1.0,1.0);\n    uv.x=1.0-mod(uv.x,2.0);\n    \n    //Speed\n    float t=iTime*2.0;\n    \n    //Wobbly Jerk Time\n    t= floor(t*0.25)+pow(fract(t*0.25),0.6);\n    t*=4.0;\n    //Rotation\n    uv*=Rot(0.05*sin(iTime));\n    vec3 col = vec3(0.0);\n    vec2 ruv = uv;\n    \n    //Downward Movement and initial offset\n    ruv.y+=t*0.1+10.0;\n    \n    //Wavey Y\n    ruv.y-=0.04*abs(sin(ruv.x*6.0+sin(ruv.y*3.0)));\n    \n    //Scaling Y for to make space for Layers\n    ruv.y *= 25.0;\n    \n    //Row on/off\n    float rid = floor(mod(ruv.y,2.0));\n\n    //Inner Edge\n    float edge1 = smoothstep(abs(ruv.x)-0.002,abs(ruv.x),0.2);\n    \n    //Moving Edge\n    float edge2;\n    float waves=3.0;\n    \n    if(ruv.x>0.0){\n        edge2 = smoothstep(ruv.x-0.005,ruv.x,0.5+0.2*sin(t+floor(ruv.y*waves))); //I think this might be backwards\n    }\n    else{\n        edge2 = smoothstep(-ruv.x-0.00,-ruv.x,0.5+0.2*sin(-t-floor(ruv.y*waves)));\n    }    \n    edge2+=(1.0-rid);\n    \n    //coloring edges\n    float l1 = rid*edge2;\n    float l2 = (1.0-rid)*edge1;\n    \n    col.rgb+=l1*endlessRGB(ruv.y,iTime);\n    col.rbg+=vec3(l2);\n    \n    //duplicating the circle and moving it\n    float rotDir = 1.0-2.0*mod(floor((cuv.y-t*0.05)*2.0),2.0);\n    cuv.y=0.25-mod(cuv.y-t*0.05,.5);\n    cuv*=Rot(rotDir*t*0.4);\n    \n    //adding circles\n    col+= endlessRGB(cuv.y*30.0+10.0,iTime)*Circle(cuv, vec2(0.0), .2, .2);\n    \n    fragColor = vec4(col,1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}