{
    "Shader": {
        "info": {
            "date": "1691677289",
            "description": "// CC0: B/W logarithmic circles II\n// Tweaking on an old shader on the bus.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "mljcWR",
            "likes": 25,
            "name": "B/W logarithmic circles II",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 350
        },
        "renderpass": [
            {
                "code": "// CC0: B/W logarithmic circles II\n// Tweaking on an old shader on the bus.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// Carefully fine tuned. No thinking involved.\nconst float ExpBy   = log2(4.1);\nconst float Radius  = 0.3175;\n  \nfloat forward(float l) {\n  return exp2(ExpBy*l);\n}\n\nfloat reverse(float l) {\n  return log2(l)/ExpBy;\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nvec3 effect(vec2 p) {\n  float aa = 4.0/RESOLUTION.y;\n  vec3 col = vec3(0.2*smoothstep(-sqrt(0.5), sqrt(0.5), sin(0.5*TAU*p.y/aa)));\n  \n  float tm = 0.5*TIME;\n  mat2 rot0 = ROT(-0.5*tm); \n  for (float i = 0.0; i < 2.0; ++i) {\n    float ltm = tm+0.5*i;\n    mat2 rot1 = ROT(i*0.5*TAU/8.0);\n    float mtm = fract(ltm);\n    float ntm = floor(ltm);\n    float zz = forward(mtm);\n  \n    vec2 p0 = p;\n    p0 *= rot0;\n    p0 *= rot1;\n    p0 /= zz;\n  \n    float l0 = length(p0);\n    \n    float n0 = ceil(reverse(l0));\n    float r0 = forward(n0);\n    float r1 = forward(n0-1.0);\n    float r = (r0+r1)/2.0;\n    float w = r0-r1;\n    float nn = n0;\n    n0 -= ntm;\n    vec2 p1 = p0;\n    float n1 = modPolar(p1, 8.0);\n    p1.x -= r;\n  \n    float a = 0.5*ltm+n1/8.0;\n    a = fract(a);\n    float d1 = length(p1)-Radius*w;\n    float d2 = length(p1)-Radius*w*smoothstep(0.0, 0.45, mod(a, 0.5));\n    d1 *= zz;\n    d2 *= zz;\n    vec3 ccol = vec3(1.0)*smoothstep(0.0, -aa, d2);\n    if (a >= 0.5) ccol = 1.0-ccol;\n    col = mix(col, ccol, smoothstep(0.0, -aa, d1));\n  }\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}