{
    "Shader": {
        "info": {
            "date": "1611365154",
            "description": "fork with (swiveled and physics disabled) [url=https://www.shadertoy.com/view/ttdyDl]quaternion camera[/url] \n\nmove= ESDF             +TG (=up down)   \nrotate= arrows/mouse +WR(roll)",
            "flags": 48,
            "hasliked": 0,
            "id": "wtKczV",
            "likes": 10,
            "name": "Atmospheric Nebula cam",
            "published": 3,
            "tags": [
                "volumetric",
                "nebula",
                "atmosphericscatteringquatenrioncamera"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 653
        },
        "renderpass": [
            {
                "code": "//commontab and BufferB are from\n//https://www.shadertoy.com/view/ttdyDl\n//imagetab modified to get Ro and rd from bufferB\n//but (once again) i had to swivel eYPR2q() inouts of Ca0() to get correct mouseRotation\n//but (once again) i had to swivel the keyboard inputs to match the mouse\n\n\n#define noiseResInverse      1.0 / 32.0\n\n#define PI                   radians(180.0)\n\n#define rayleighCoefficient  vec3(4.847e-6, 1.149e-5, 2.87e-5 )\n#define mieCoefficient       3e-6\n#define nebulaCoeff          rayleighCoefficient\n\n\n\n\n\n#define FieldOfView 2.5\nv22 getRay(vec2 u//uU is not normalized\n){u=(u-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(tf(camA0),tf(camP0).xyz)\n ;mat3 m=m42Rot(ct) //;mat3 m=q2m(tf(camA0))\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                   +(m*vec3(1,0,0)*u.x//right+forward...\n                   +m*vec3(0,1,0)*u.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd);}\n\nmat2 rotate(float r){return mat2(vec2(cos(r),-sin(r)),vec2(sin(r),cos(r)));}\n\nfloat bayer2(vec2 a){a=floor(a);return fract(dot(a,vec2(0.5,a.y*.75)));}\nfloat bayer4(vec2 a)  {return bayer2( 0.5  *a)*.25    +bayer2(a);}\nfloat bayer8(vec2 a)  {return bayer4( 0.5  *a)*.25    +bayer2(a);}\nfloat bayer16(vec2 a) {return bayer4( 0.25 *a)*.0625  +bayer4(a);}\nfloat bayer32(vec2 a) {return bayer8( 0.25 *a)*.0625  +bayer4(a);}\nfloat bayer64(vec2 a) {return bayer8( 0.125*a)*.015625+bayer8(a);}\nfloat bayer128(vec2 a){return bayer16(0.125*a)*.015625+bayer8(a);}\n\nfloat Get3DNoise(vec3 u){return texture(iChannel0,u*noiseResInverse).x;}\n\nbool raySphereIntersect(vec3 rd, vec3 sphere, float radius, out vec2 hit\n){hit=vec2(0)\n ;float b=dot(sphere, rd)\n ;float c=dot(sphere, sphere) - radius * radius\n ;float d=b*b-c\n ;//if (dot(rd, normalize(sphere)) > 1.0) return false\n ;if (d < 0.0)return false\n ;d=sqrt(d)\n ;hit=vec2(-b-d,d-b);return true;}\n\nfloat hgPhase(float r,float g){return(1./(4.*PI))*((1.-g*g)/pow(1.+g*g-2.*g*r,1.5));}\n\nfloat nebulaFBM(vec3 u\n){u+=6.\n ;float coverage=.22\n ;float noise=0.\n ;float a=1.\n ;mat2 rotMat = rotate(0.8)\n ;for(int i=0;i<4;i++\n ){noise+= texture(iChannel0, u * noiseResInverse).x*a\n  ;u.xy *= rotMat\n  ;u.yz *= rotMat\n  ;u*=3.5\n  ;a*=.4;}\n ;noise *= 0.25\n ;noise  = max(noise - coverage, 0.0) * 200000000.0 + 50000.0\n ;return noise;}\n\nfloat getNebulaVolume(vec3 r,float d){return nebulaFBM(r)*smoothstep(1.,0.,d/Nebula_Radius);}\n\nvec3 calculateStarlightVisibility(vec3 ray, const vec4 nebula, float startingOpticalDepth, float distFromCenter\n){const int samples  = 15\n ;float stepSize = (nebula.a * 2.0) / float(samples)\n ;float dirSwitch = -1.0\n ;if (ray.y > nebula.y) dirSwitch = 1.0\n ;vec3 centralRay   = ray - nebula.xyz //centralize ray on star\n ;vec3 rayDirection = -normalize(centralRay) * stepSize\n ;        ray         += rayDirection * 0.5\n ;float opticalDepth = -startingOpticalDepth\n ;//ray.xy =(ray.xy - vec2(0.0, 1.0)) * rotate(iTime * 0.1) + vec2(0.0, 1.0)\n ;for (int i = 0; i < samples; i++, ray += rayDirection\n ){opticalDepth -= nebulaFBM(ray)*smoothstep(1.,0.,distFromCenter/Nebula_Radius);;}\n ;return exp(nebulaCoeff * stepSize * opticalDepth);}\n\n//fucking hell, it couldnt just make a normal ramera\n//it had tro be a lazy orbit cam\n//main issue here is that rd input value is only set by uv\n\nvoid renderNebula(vec2 u,inout vec3 color,float dither\n){vec3 starColor =vec3(.5,.7,1)\n ;vec3 rd=normalize(vec3((u.xy*2.-iR.xy)/iR.y,1).xzy)\n ;vec3 ro=vec3(0)//rd*max(1.0 - Nebula_Radius, 0.0)\n ;v22 r=getRay(u)\n ;ro=r.a\n ;rd=r.b \n ;float starRadius=.015\n ;vec3 a=-nebulaCoeff/log(2.)\n ;vec3 b=-1./nebulaCoeff\n ;vec3 center=normalize(vec3(0,1,0))///center of nebular\n ;vec2 d\n ;raySphereIntersect(rd,ro-center,Nebula_Radius,d)//not sure about the ro-center\n ;//if(!raySphereIntersect(rd,ro,Nebula_Radius,d))return\n ;float l =(d.y-d.x) / float(Nebula_Quality)//stepSize\n ;//vec3 ro=tf(camP0).xyz//+* max(1. - Nebula_Radius, 0.0)\n ;//rd=qv2v(tf(camA0),vec3(1,0,0)) \n ;vec3  L =rd*l \n ;ro=ro+L*dither\n ;float phase        =hgPhase(dot(center, rd), 0.85) * PI\n ;vec3  scatter      =vec3(0.0)\n ;vec3  transmission =vec3(1.0)\n ;//RO.xy=(RO.xy-vec2(0.0, 1.0))*rotate(iTime * 0.1) + vec2(0.0, 1.0)\n ;for (int i = 0; i < Nebula_Quality; i++,ro+=L\n ){float distFromCenter = distance(ro,center)\n  ;if (distFromCenter > Nebula_Radius) continue\n  ;if (distFromCenter < starRadius){color = starColor;break;}\n  ;float lightFalloff   = inversesqrt(0.1 + distFromCenter)\n  ;float opticalDepth   = getNebulaVolume(ro, distFromCenter) * l\n  ;if (opticalDepth <= 0.0) continue\n  ;vec3  nebulaLighting = calculateStarlightVisibility(ro, vec4(center, Nebula_Radius), opticalDepth, distFromCenter) * lightFalloff * starColor * phase * nebulaCoeff\n  ;scatter      +=nebulaLighting *(exp2(a*opticalDepth)*b-b)*transmission\n  ;transmission *=exp(-nebulaCoeff * opticalDepth);}\n ;color = color * transmission + scatter;}\n\nvoid reinhardTonemap(inout vec3 color\n){color *= 8.0\n ;//color  = max0(color - 0.005)\n ;color  = color / (1.0 + color) * 1.08\n ;float luminance = dot(color, vec3(0.2125, 0.7154, 0.0721))\n ;color = mix(vec3(luminance), color, 1.0);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y\n ;float dither = bayer128(gl_FragCoord.xy)\n ;fragColor = vec4(vec3(0.0),1.0)\n ;renderNebula(fragCoord,fragColor.xyz, dither)\n ;reinhardTonemap(fragColor.xyz);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define noiseResInverse      1.0 / 32.0\n\n\n#define iR iResolution\n\n#define PI                   radians(180.0)\n\n#define rayleighCoefficient  vec3(4.847e-6, 1.149e-5, 2.87e-5 )\n#define mieCoefficient       3e-6\n#define nebulaCoeff          rayleighCoefficient\n\n\n#define Nebula_Quality 40\n#define Nebula_Radius  1.2\n\n\n#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n\n#define camType 1\n\n//its not just broken during rotation\n//, there are just-as-broken ghost-images during straving\n\n\nconst vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\nconst float\n //set to -100. to skip collisions\n //=.01 is reasonable for the mandelbulb distanceField\n PHYSICS_RADIUS=-100.\n,LIN_ACCE=.5//linear accelleration\n,ANG_ACCE=2.//angular accelleration\n,LIN_DRAG=1.//linear drag\n,ANG_DRAG=2.//angular drag\n;\n\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n\n//specific buffereB Addresses\nconst float \n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera angle    (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera angle    (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera position of previous frame\n,camA0p=7.//camera angle    of previous frame\n,li2P0 =8.//light0 position\n,li3P0 =9.//light1 position\n,NBuffB=8.//max address count\n;\n#define tf(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n\nconst float tau=acos(-1.)*2.// 1/1 rotation in radians\n,pi=acos(-1.)               // 1/2 rotation in radians\n,pi2=acos(0.)               // 1/4 rotation in radians\n//,pi4=acos(0.)*.5            // 1/8 rotation in radians\n;\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec1 mav(vec2 a){return max(a.x,a.y);}\nvec1 mav(vec3 a){return max(mav(a.xy),a.z);}\nvec3 ma0(vec3 a){return max(a,0.);}\nvec1 mu(vec2 a){return a.x*a.y;}\nvec1 mu(vec3 a){return a.x*a.y*a.z;}\nvec1 su(vec2 a){return a.x-a.y;}\nvec1 su(vec3 a){return a.x+a.y-a.z;}\nvec1 ad(vec2 a){return a.x+a.y;}\nvec1 ad(vec3 a){return a.x+a.y+a.z;}\n\n//internal RNG state \nuvec4 s0,s1;\nivec2 pixel;\n\nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\n\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n\nfloat rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\nvec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\n\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\n\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec2 c=cos(r),s=sin(r)\n ;return vec3(c.x*s.y,s.x*s.y,c.y);}\n\nfloat HenyeyGreenstein(float g,float c//g,costh\n){return (4.*pi*pow(1.0+g*g-2.0*g*c,3./2.))/(1.-g*g);}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b;return length(ma0(q))+min(mav(q),0.);}\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n \n//from https://www.shadertoy.com/view/XsSXDy\nvec4 pwS(float x){return vec4(x*x*x,x*x,x,1.0);}\n\n/*\nvec3 pq(vec2 a){return vec3(a.x*a.x,a.x*a.y,a.y*a.y);}\nfloat pow7(float a){float b=a*a;float c=b*b;return a*b*c;}\n//mandelbulb.core \n//o.x=distance , o.yzw=orbittrap\n//w.xyz=uv     ,w.w=dd(uv)\nvoid mandelCore(inout vec4 o,inout vec4 w,vec3 u\n){o.x=8.*sqrt(pow7(w.w))*o.x+1.\n ;vec3 w2=w.xyz*w.xyz,w4=w2*w2\n ,e=vec3(ad(w2.xz)\n        ,ad(w4)-6.*dot(w2.zx,w2.yy)+2.*mu(w2.xy)\n        ,su(w2.zxy))\n ;w.xyz=u+vec3( 64.*mu(w.xyz)*su(w2.xz)*ad(pq(w2.xz)*vec3(1,-6,1))\n              ,-16.*w2.y*mu(e.xzz)+e.y*e.y\n              ,-8.*w.y*(dd(w4.xz)+mu(w2.xz)*(-28.*w4.x+70.*mu(w2.xz)-28.*w4.z)))\n              *(vec3(0,1,0)+vec3(1,0,1)*e.z*e.y*inversesqrt(pow7(e.x)))\n ;w.w=dd(w.xyz);o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n\nvec4 mandelBulbO(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break;mandelCore(o,w,u);}\n ;o.x=.25*log(w.w)*sqrt(w.w)/o.x;return o;}\n\nvec1 mandelBulb(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break;mandelCore(o,w,u);}\n ;return .25*log(w.w)*sqrt(w.w)/o.x;}\n*/\n\n//subroutines of   https://www.shadertoy.com/view/XlVyDK\n#define le(a) sqrt(dd(a))\n#define co(a) cos(a)\n#define si(a) sin(a)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\n/*\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}*/\n\n/*\nvec3 repeat(vec3 u){//return u;\n ;vec3 v=pmod(u,vec3(2.8));return u\n ;}*/\n\n\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/length(a)/length(b));}\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q){return q/dd(q);}//return normalize(q);}\n//\n// quaternion & vectors\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b// http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\n//vec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\n//vec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\n//vec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of [q]uaternion (rotation matrix without translation)\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,1);mat3 m=mat3(.5)+mat3(0,q.zyz*a,0,q.xyx*a.xxy,0)*q.w\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n//---end__ quaternion\n\n\n//https://www.shadertoy.com/view/ldjyRK\nconst float s2=sqrt(2.);\nvec2 scm(float a){return sin(vec2(a,a+pi2));}//NOT a rotation, but a reflection at a halfRotated axis.\nvec2 sc(float a){return scm(a);//lazy override\n return vec2(sin(a),cos(a)); ;}//actual reflection\n//Hammer.transform:\nvec2 tHammer(vec2 p){\n vec2 s=sc(p.y),o=sc(p.y*.5);\n return s2*vec2(2.*s.y*o.x,s.x)/sqrt(1.+s.y*o.y);}\n//Hammer.transform.Inverse\nvec2 tHammerI(vec2 p){float z=1.-(p.x*p.x/16.)-(p.y*p.y/4.);\n if(z<0.)discard;float s=sqrt(z);\n return vec2(2.*atan((s*p.x),(2.*(2.*z-1.))),asin(s*p.y));}\n \n//scale: (-0.5.-0.5) x (0.5..0.5) -> (l[0]..l[1]) x (l[2]..l[3])\nvec2 scale(vec2 p, vec4 l){\n return (p+vec2(.5))*vec2(l[1]-l[0],l[3]-l[2])+vec2(l[0],l[2]);}\n//scale.inverse p=scale1(scale_forward(p));\nvec2 scale1(vec2 p, vec4 l){\n return (p-vec2(l[0],l[2]))/vec2(l[1]-l[0], l[3]-l[2])-vec2(.5);}\n\nvec2 hammerScale(vec2 u,vec2 r\n){u=u.xy/r.xy-.5\n ;u*=sqrt(2.)\n ;//u*=1.; //fieldOfView\n ;vec4 CarLim=vec4(-2,2,-1,1);//carthesian limits\n ;return scale(u,CarLim);}\n \n ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Controller\n\n//Keyboard constants\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\n  \n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyT,keyE ,keyF).zxy//right ,up  ,front      ==+linear\n           ,kln=ivec3(keyG,keyD ,keyS  ).zxy//left  ,down,back       ==-linear\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular\n\n//constant code:\nfloat kg(int key_code){return texelFetch(iChannel3, ivec2(key_code,0), 0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n  \nvec4 cp0(//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return vec4(0,0,0,1);\n ;vec3 r=tf(camP0).xyz\n /*\n ;if(PHYSICS_RADIUS>-99.){//optional collision\n  ;float d=PHYSICS_RADIUS-df(r.xyz)\n  ;if (d>0.)r.xyz+=normal(r)*d ;} */ //no physics in this one\n ;return vec4(r+(q2m(tf(camA0),vec3(0))\n               *vec4(tf(camP1).xyz,0)).xyz*iTimeDelta,0);}\n\nvec4 cp1(//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(tf(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n \nconst vec4 rotStart=vec4(-.27,.5,0,0)*pi;\nvec4 ca0(//return camera angular Position.xyz (quaternion)\n){if (iFrame <1)return aa2q(vec3(1,0,0),-5.5)\n ;return normalize(qq2q(eYPR2q(iTimeDelta*tf(camA1).yzx),tf(camA0)));}\n\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;return vec4(drag(tf(camA1).xyz,a.yzx*ANG_ACCE,ANG_DRAG),0.);}\n\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=tf(q)\n ;if(key(k))c.xyz=tf(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n \nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}\n ;         if(u==camP1)return cp1();return ca1();}\n\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return tf(camP0)//memorize previous pos\n ;if(u==camA0p)return tf(camA0)//memorize previous angle\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))\n ;if(u==li2P0)return lightPos(u,keyO,vec4(-.1,.5,.5,0))\n ;if(u==li3P0)return lightPos(u,keyK,vec4(1.2,-1.,0,0))\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}