{
    "Shader": {
        "info": {
            "date": "1532704853",
            "description": "Partially incremental ray marching water shader.",
            "flags": 32,
            "hasliked": 0,
            "id": "ltcyDN",
            "likes": 4,
            "name": "Freaky Ice Bergs",
            "published": 3,
            "tags": [
                "terrain",
                "multipass",
                "incremental"
            ],
            "usePreview": 0,
            "username": "emh",
            "viewed": 785
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //fragColor.b = texelFetch(iChannel1, ivec2(fragCoord), 0).x * 100.0;\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// default is freaky ice berg mode. uncomment below to have normal water.\n// #define NORMAL_WATER 1\n\nconst float waterDepth = 1.0;\n//#define waterDepth (1.0 + 0.5 * sinc(iTime))\nconst float waveHeight = 0.5;\n//#define waveHeight (0.1 + 0.5 * sinc(iTime))\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\n\n// its from here https://github.com/achlubek/venginenative/blob/master/shaders/include/WaterHeight.glsl \nfloat wave(vec2 uv, vec2 emitter, float speed, float phase){\n\tfloat dst = distance(uv, emitter);\n\treturn pow((0.5 + 0.5 * sin(dst * phase - iTime * speed)), 5.0);\n}\n\n#define GOLDEN_ANGLE_RADIAN 2.39996\nfloat getwaves(vec2 uv){\n\tfloat w = 0.0;\n\tfloat sw = 0.0;\n\tfloat iter = 0.0;\n\tfloat ww = 1.0;\n    uv += mod(iTime, 60.0) * 0.5;\n\t// it seems its absolutely fastest way for water height function that looks real\n\tfor(int i=0;i<6;i++){\n\t\tw += ww * wave(uv * 0.06 , vec2(sin(iter), cos(iter)) * 10.0, 2.0 + iter * 0.08, 2.0 + iter * 3.0);\n\t\tsw += ww;\n\t\tww = mix(ww, 0.0115, 0.4);\n\t\titer += GOLDEN_ANGLE_RADIAN;\n\t}\n\t\n\treturn w / sw;\n}\n\n\nfloat minabs(float x, float y) {\n    return abs(x) < abs(y) ? x : y;\n}\n\nfloat sinc(float x) {\n    return (sin(x) + 1.0) / 2.0;\n}\n\nfloat terrain(vec3 p) {\n    float h = sinc(iTime * 10.0) * 0.125 + 0.1;\n    h = 0.125;\n    float l = length(p) * 0.5;\n    float terra = -1.0 + 0.5 + h * (sinc(10.0 * p.x) + sinc(10.0 * p.z));\n    float fbmh = -1.0 + 0.5 * fbm(p.xz + p.xz * sinc(iTime));\n    \n    /*\n    vec2 coord = (p.xz + vec2(2.0, 5.0)) * 0.1;\n    coord = fract(coord);\n\t*/\n    \n    vec2 coord = fract(abs(p.xz * 0.25 + vec2(0.5, 0.9)));\n    \n    // coord = sin(coord);\n    vec4 water = texture(iChannel1, coord);\n    //float h2 = water.z > 0.0 ? 0.4 * water.z : 0.8 * water.x;\n    float h2 = water.x * 1.0;\n    //h2 = clamp(h2, -0.2, 0.2);\n    //vec4 terrain = texture(iChannel2, coord);\n    //float h3 = 0.5 * terrain.x;\n    float h4 = getwaves(p.xz * 10.0);\n    //h4 = water.z <= 0.0 ? 0.5 * h4 : h2;\n    //float h2 = water.x;\n    terra = -1.0 + 0.5 + h2;\n    // float h5 = fbm(p.xz);\n#ifdef NORMAL_WATER\n    terra = -0.5 + waveHeight * h4;\n#endif\n    return terra;\n}\n\nfloat map2(vec3 p) {\n    return p.y - terrain(p);\n}\n\nfloat bob1 = 0.0;\nfloat bob2 = 0.0;\nfloat bob3 = 0.0;\n\nfloat map3(vec3 p) {\n    float cubeSize = 10.0;\n    vec3 b = vec3(cubeSize);\n    float d = length(max(abs(p)-b,0.0));\n    return d;\n}\n\nfloat map(vec3 p) {\n    //float bob = 0.1 * sin(iTime);\n    float d = distance(p, vec3(-1, bob1, -5)) - 1.;     // sphere at (-1,0,5) with radius 1\n    d = min(d, distance(p, vec3(2, bob2, -3)) - 1.);    // second sphere\n    d = min(d, distance(p, vec3(-2, bob3, -2)) - 1.);   // and another\n    /*\n    vec2 coord = (p.xz + vec2(2.0, 5.0)) * 0.1;\n    vec4 water = texture(iChannel1, coord);\n    float h2 = water.z > 0.0 ? 0.2 * water.z : 0.1 * water.x;\n    d -= h2;\n\t*/\n    //float x = texture(iChannel3, p.xz).g;\n    \n    // horizontal plane at y = -1\n    d = min(d, p.y + waterDepth);\n    \n    /*\n    d = min(d, p.x + cubeSize);\n    d = min(d, p.x - cubeSize);\n    d = min(d, p.y + cubeSize);\n    d = min(d, p.y - cubeSize);\n    d = min(d, p.z + cubeSize);\n    d = min(d, p.z - cubeSize);\n\t*/\n    //d = min(d, 1.0 + map2(p));\n    // d = min(d, p.y - terrain(p));\n    return d;\n}\n\n//\n// Calculate the normal by taking the central differences on the distance field.\n//\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvec3 calcNormal2(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * map2(p + e.xyy) +\n        e.yyx * map2(p + e.yyx) +\n        e.yxy * map2(p + e.yxy) +\n        e.xxx * map2(p + e.xxx));\n}\n\nfloat castRay3(const vec3 ro, const vec3 rd, out float resT) {\n    \n    float t2 = 0.0;\n    float ret2 = 0.0;\n    \n    for (int i = 0; i < 256; i++) {\n        vec3 p2 = ro + rd*t2;\n        float h2 = map3(p2);\n        \n        //h = min(h, h2);\n        if (h2 > 0.0 && h2 < 0.01) {\n            resT = t2;\n            ret2 = 1.0;\n        }\n        \n        t2 += h2;\n    }\n    \n    return ret2;\n}\n\n\nfloat castRay2(const vec3 ro, const vec3 rd, const float ret, out float resT) {\n    \n    float t2 = 0.0;\n    float ret2 = ret;\n    \n    for (int i = 0; i < 256; i++) {\n        vec3 p2 = ro + rd*t2;\n        float h2 = map(p2);\n        \n        //h = min(h, h2);\n        if (h2 > 0.0 && h2 < 0.01 && (ret == 0.0 || t2 < resT)) {\n            resT = t2;\n            ret2 = 1.0;\n        }\n        if (t2 >= 10.0) {\n            break;\n        }\n        \n        t2 += h2;\n    }\n    \n    return ret2;\n}\n\n\n\nfloat castRay(const vec3 ro, const vec3 rd, out float resT) {\n    const float odelt = 0.01f;\n    float delt = odelt;\n    float dt = delt;\n    const float mint = 0.001f;\n    const float maxt = 10.0f;\n    float lh = 0.0f;\n    float ly = 0.0f;\n    \n    float t = iFrame == 0 ? mint : resT; //max(mint, resT);\n    vec3 p = ro + rd*t;\n    float h = terrain(p);\n    if (p.y < h) {\n        t = (mint + t) / 2.0;\n        //t = mint;\n    }\n    \n    float ret = 0.0;\n    for (int i = 0; i < 1000; i++) {\n        \n        vec3 p = ro + rd*t;\n        float h = terrain(p);\n        \n        //h = min(h, h2);\n        resT = t;\n        if (p.y < h) {\n            // interpolate the intersection distance\n            resT = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n            ret = 2.0;\n            break;\n        }\n        \n        t += delt;\n        if (t > maxt) break;\n        \n        // allow the error to be proportional to the distance\n        delt = odelt * t;\n        dt = delt;\n        lh = h;\n        ly = p.y;\n    }\n    \n    /*if (ret == 0.0) {\n    \tret = castRay2(ro, rd, resT);\n    }*/\n    ret = castRay2(ro, rd, ret, resT);\n    \n    return ret;\n}\n\nvec3 getLight(vec3 p, vec3 normal) {\n    vec3 light = vec3(0.0, 1.0, -3.0);\n    vec3 light2 = vec3(0.0, -1.0, -3.0);\n    vec3 dirlight = vec3(0.0, 1.0, 0.0);\n    //light = vec3(q.x, 0.0, q.y);\n\n    // Calculate diffuse lighting by taking the dot product of \n    // the light direction (light-p) and the normal.\n    float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n    float dif2 = clamp(dot(normal, normalize(light2 - p)), 0., 1.);\n    float dif3 = clamp(dot(normal, normalize(dirlight)), 0., 1.);\n\n    // Multiply by light intensity (5) and divide by the square\n    // of the distance to the light.\n    dif *= 5. / dot(light - p, light - p);\n    dif2 *= 5. / dot(light2 - p, light2 - p);\n    // dif3 *= 5. / dot(dirlight, dirlight);\n\n    float dif4 = (dif + dif2 + dif3) / 3.0;\n\n    dif = pow(dif, 0.4545);\n    dif2 = pow(dif2, 0.4545);\n    dif3 = pow(dif3, 0.4545);\n\n    vec3 color = vec3(dif2 * 0.5, dif * 0.25, dif3);\n    return color;\n}\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nfloat caustics(in vec2 uv) {\n\t// float time = iTime * .5+23.0;\n    float time = iTime * .5+23.0;\n    // uv should be the 0-1 uv of texture...\n\t// vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = mod(uv*TAU, TAU)-250.0;\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n    c = pow(abs(c), 8.0);\n    return c;\n    /*\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);    \n\tfragColor = vec4(colour, 1.0);\n\t*/\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0.0, 0.5, 1);                           // ray origin\n    \n    // ro *= sinc(iTime) + 0.5;\n    \n    //ro.y = sinc(iTime);\n    \n    vec4 old = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    bob1 = terrain(vec3(-1, 0, -5));\n    bob2 = terrain(vec3(2, 0, -3));\n    bob3 = terrain(vec3(-2, 0, -2));\n    /*\n    if (iFrame > 10) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n\t*/\n\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    //ro = vec3(q.x, 0.0, q.y);\n    vec3 rd = normalize(vec3(q, 0.) - ro);             // ray direction for fragCoord.xy\n\n    // March the distance field until a surface is hit.  \n    float t = old.a;\n    float res = castRay(ro, rd, t);\n    float h = res > 0.0 ? 0.0 : 1.0;\n    \n    if (h < 0.01) {\n        //t += sin(iTime);\n        //t = res == 2.0 ? t * 10.1 : t;\n        vec3 p = ro + rd * t;\n        vec3 op = p;\n        vec3 normal = res == 2.0 ? calcNormal2(p) : calcNormal(p);\n        vec3 onormal = normal;\n        \n        vec3 refractionDir = refract(normalize(rd), normal, 1.0 / 1.333);\n        float wt = 0.0;\n        float res2 = castRay2(p, refractionDir, 0.0, wt);\n        \n        vec3 tex = vec3(0.0);\n        //tex = texture(iChannel3, p.xz).rgb * (1.0 - 0.0);\n        if (res2 > 0.0) {\n            p = p + refractionDir * wt;\n            normal = calcNormal(p);\n            \n            float depth = distance(op, p);\n            depth /= waterDepth;\n            depth = pow(depth * 2.0, 3.2);\n            depth *= 0.02;\n            depth = clamp(depth, 0.0, 0.8);\n            \n            if (p.y <= -waterDepth + 0.1) {\n            \ttex = texture(iChannel3, p.xz).rgb * (1.0 - depth);\n            } else {\n                tex = getLight(p, normal);\n            }\n        }\n        float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-normal, rd)), 5.0)));\n        \n        vec3 color = getLight(p, normal);\n        \n        if (res == 2.0) {\n            float wt2 = 0.0;\n            vec3 reflectionDir = reflect(normalize(rd), normal);\n            float res3 = castRay2(p, reflectionDir, 0.0, wt2);\n            vec3 p2 = vec3(0.0);\n            if (res3 > 0.0) {\n                vec3 p2 = p + reflectionDir * wt2;\n                vec3 normal2 = calcNormal(p2);\n                color = 0.5 * (color + 5.0 * getLight(p2, normal2));\n            }\n            \n            /*\n            float wt3 = 0.0;\n            vec3 reflectionDir2 = reflect(normalize(rd), normal);\n            res3 = castRay3(p, reflectionDir2, wt3);\n            vec3 p3 = p + reflectionDir2 * wt3;\n            //vec3 normal3 = calcNormal(p2);\n            //color = 0.5 * (color + 5.0 * getLight(p3, normal3));\n            tex = 1.0 * tex + tex * 1.0 * texture(iChannel2, p3).rgb;\n\t\t\t*/\n        }\n        \n        if (res == 2.0) {\n            //color *= fresnel * 10.0;\n            //if (useTex) {\n        \t\tcolor = 1.0 * color * tex + 1.0 * tex;\n            //}\n            //color = tex;\n            color += color * vec3(fresnel);\n        }\n        \n        if (res == 2.0) {\n            float caustic = caustics(fract(p.xz * 1.0));\n            //color = color + 0.5 * pow(caustic, 1.0);\n            float l = length(color);            \n            color *= 0.8 + 1.0 * pow(caustic, 1.0) * l;\n            \n            //color -= pow(caustic.b, 2.0);\n        }\n        \n        if (res == 1.0 && (p.y <= -waterDepth + 0.1)) {\n            tex = texture(iChannel3, p.xz).rgb;\n            color = tex;\n        }\n        \n        // color = vec3(0.0, 0.0, dif3);\n        \n        //fragColor = vec4(color * vec3(pow(dif, 0.4545)), 1);     // Gamma correction\n        fragColor = vec4(color, 1.0);     // Gamma correction\n        //fragColor = vec4((vec3(p.x, p.y, p.z) + 1.0) / 2.0, 1.0);\n        //fragColor = vec4(1.0 - length(p) / 10.0);\n    } else {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n    fragColor.a = t;\n    \n    /*\n    if (res > 0.0) {\n    \t\n    } else {\n        fragColor.a = 0.0;\n    }\n\t*/\n    //fragColor = vec4(1.0 - (sin(iTime) + 1.0) / 2.0 * t / 10.0, 0, 0, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define HEIGHT 2.4\n//#define HEIGHT 0.0\n#define TERRAMUL 1.0\n\n// its from here https://github.com/achlubek/venginenative/blob/master/shaders/include/WaterHeight.glsl \nfloat wave(vec2 uv, vec2 emitter, float speed, float phase){\n\tfloat dst = distance(uv, emitter);\n\treturn pow((0.5 + 0.5 * sin(dst * phase - iTime * speed)), 5.0);\n}\n\n#define GOLDEN_ANGLE_RADIAN 2.39996\nfloat getwaves(vec2 uv){\n\tfloat w = 0.0;\n\tfloat sw = 0.0;\n\tfloat iter = 0.0;\n\tfloat ww = 1.0;\n    uv += mod(iTime, 1.0) * 0.5;\n\t// it seems its absolutely fastest way for water height function that looks real\n\tfor(int i=0;i<6;i++){\n\t\tw += ww * wave(uv * 0.06 , vec2(sin(iter), cos(iter)) * 10.0, 2.0 + iter * 0.08, 2.0 + iter * 3.0);\n\t\tsw += ww;\n\t\tww = mix(ww, 0.0115, 0.4);\n\t\titer += GOLDEN_ANGLE_RADIAN;\n\t}\n\t\n\treturn w / sw;\n}\n\nbool hitTest(vec2 uvn) {\n    /*float d = distance(uvn, vec2(0.5, 0.5));\n    if (d < 0.2) {\n        return self;\n    }*/\n    /*\n    if ((uvn.x > 0.4 && uvn.x < 0.6) &&\n        (uvn.y > 0.4 && uvn.y < 0.6)) {\n        return true;\n    }*/\n    float h = texture(iChannel1, uvn).x;\n    //if (h > nb || h > HEIGHT) {\n    if (h > HEIGHT) {\n        return true;\n    }\n    return false;\n}\n\nbool checkSink(vec2 uv) {\n    return distance(uv, vec2(0.5, 0.5)) <= 0.1;\n}\n\nfloat getContribution(vec2 uv, float u) {\n    float terrainHeight = texture(iChannel1, uv).x * TERRAMUL;\n    float waterHeight = texture(iChannel0, uv).x;\n    \n    /*\n    bool ht = hitTest(uv);\n    if (ht) {\n    \t//ux = 0.0;\n    }\n\t*/\n    float ux = waterHeight;\n    if (uv.x < 0.0 || uv.x >= 1.0 || uv.y < 0.0 || uv.y >= 1.0) {\n        ux = 0.0;\n    }\n    return ux;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dx = 1.0/iResolution.x;\n    float dy = 1.0/iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 udu = texture(iChannel0, uv).xy;\n\t// old elevation\n    float u = udu.x;\n    float terrainHeight = texture(iChannel1, uv).x * TERRAMUL;\n    //float uTotal = u + terrainHeight;\n    // old velociy\n    float v = udu.y;\n    \n    \n    \n    //float self = 0.0;\n    \n    // Finite differences\n    vec2 uv1 = vec2(uv.x+dx, uv.y);\n    float ux = getContribution(uv1, u);\n    \n    vec2 uv2 = vec2(uv.x-dx, uv.y);\n    float umx = getContribution(uv2, u);\n    \n    vec2 uv3 = vec2(uv.x, uv.y+dy);\n    float uy = getContribution(uv3, u);\n    \n    vec2 uv4 = vec2(uv.x, uv.y-dy);\n    float umy = getContribution(uv4, u);\n\n    float avg = (umx+ux+umy+uy) * 0.25;\n    \n    v += 2.0 * (avg - u);\n    \n    // new elevation\n    float nu = u + 1.0 * v;\n    \n    // wave decay\n    //nu = 0.9999*nu;\n    // nu *= 0.999;\n    \n    nu += terrainHeight / 200.0;\n    float mul = 500.0;\n    //nu += (sin(uv.x * mul) + sin(uv.y * mul) + 2.0 * sin(iTime)) / 1000.0;\n    //nu += getwaves(uv * mul) / 100.0;\n    nu += getwaves(uv * mul) / iResolution.y;\n    \n    float d = distance(uv, vec2(0.5, 0.5));\n    /*\n    if (d > 0.08 && d < 0.1) {\n        //float scale = mix(0.99, 0.999999, d * 2.0);\n        //nu = scale;\n        nu = (1.0 - d / 0.1) * (sin(10.0 * iTime) + 1.0) / 2.0;\n    }*/\n    \n    float z = terrainHeight / TERRAMUL;\n    float w = (terrainHeight + nu) / TERRAMUL;\n    \n    fragColor = vec4(nu,v,z,w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise2(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat snoise(vec3 v) {\n    return snoise2(v); // - 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = 3.0;\n    float ns = 0.0;\n    float fac = 1.0;\n    //float time = iTime / 40.0;\n    float time = iTime / 10.0;\n    // time = 0.0;\n    ns += fac * snoise(vec3(uv.x * scale, uv.y * scale, time));\n    fac /= 2.0;\n    scale *= 2.0;\n    ns += fac * snoise(vec3(uv.x * scale, uv.y * scale, time));\n    fac /= 2.0;\n    scale *= 2.0;\n    ns += fac * snoise(vec3(uv.x * scale, uv.y * scale, time));\n    fac /= 2.0;\n    scale *= 2.0;\n    ns += fac * snoise(vec3(uv.x * scale, uv.y * scale, time));\n    fragColor = vec4(ns);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}