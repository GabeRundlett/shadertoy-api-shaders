{
    "Shader": {
        "info": {
            "date": "1633962893",
            "description": "Create watery landscapes; if control panel not visible click on ring; see source for details. ",
            "flags": 32,
            "hasliked": 0,
            "id": "7scXW2",
            "likes": 17,
            "name": "Terrain Explorer 2",
            "published": 3,
            "tags": [
                "fractal",
                "interactive",
                "water",
                "landscape"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 379
        },
        "renderpass": [
            {
                "code": "// \"Terrain Explorer 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Updated to include water and reflection.\n\n  Control panel appears when yellow ring (or a hidden control) clicked; panel fades\n  automatically; use mouse to look around.\n\n  Height functions based on the following (1-3 have additional spatial modulation):\n    1) Basic fBm.\n    2) Modified fBm in 'Elevated' by iq.\n    3) Inverted waves simplified from 'Seascape' by TDM.\n    4) Weird forms from 'Sirenian Dawn' by nimitz.\n\n  Sliders (from top):\n    Overall height scale.\n    Lacunarity - rate of fBm length scale change per iteration.\n    Persistence - rate of fBm amplitude change per iteration.\n    Variable spatial modulation (height functions 1 & 2), or feature sharpness (3 & 4).\n    Water height.\n    Flight speed.\n\n  Buttons (from left):\n    Height function choice (= 1-4).\n    Distance marching accuracy and range (may affect update rate) (= 1-3).\n    Shadows (= 1 off) and sun elevation (= 2-3).\n    Terrain reflection (= 1 off, = 2 on).\n\n  There is no end to the functionality that can be added...\n\n  (Based on \"Terrain Explorer\", with water from \"Scrolling Terrain\", and other mods)\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Noisefv2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst float pi = 3.14159;\n\nvec3 sunDir;\nfloat tCur, dstFar, htWat, hFac, fWav, aWav, smFac, stepFac;\nint grType, qType, shType, refType, stepLim;\n\nfloat GrndHt1 (vec2 p)\n{\n  vec2 q;\n  float f, wAmp;\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.1 * p;\n  f = 0.;\n  wAmp = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= aWav;\n    q *= fWav * qRot;\n  }\n  return min (5. * Noisefv2 (0.033 * smFac * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt2 (vec2 p)\n{\n  vec3 v;\n  vec2 q, t;\n  float wAmp, f;\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.1 * p;\n  wAmp = 1.;\n  t = vec2 (0.);\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    v = Noisev3v2 (q);\n    t += v.yz;\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= aWav;\n    q *= fWav * qRot;\n  }\n  return min (5. * Noisefv2 (0.033 * smFac * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt3 (vec2 p)\n{\n  vec2 q, t, ta, v;\n  float wAmp, pRough, f;\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.1 * p;\n  wAmp = 0.3;\n  pRough = 1.;\n  f = 0.;\n  for (int j = 0; j < 3; j ++) {\n    t = q + 2. * Noisefv2 (q) - 1.;\n    ta = abs (sin (t));\n    v = (1. - ta) * (ta + sqrt (1. - ta * ta));\n    v = pow (1. - v, vec2 (pRough));\n    f += (v.x + v.y) * wAmp;\n    q *= fWav * qRot;\n    wAmp *= aWav;\n    pRough = smFac * pRough + 0.2;\n  }\n  return min (7. * Noisefv2 (0.033 * p) + 0.5, 5.) * f;\n}\n\nfloat GrndHt4 (vec2 p)\n{\n  vec3 v;\n  vec2 q, t;\n  float wAmp, b, f, waFac;\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.1 * p;\n  wAmp = 1.;\n  t = vec2 (0.);\n  f = 0.;\n  waFac = 1.;\n  for (int j = 0; j < 4; j ++) {\n    v = Noisev3v2 (q);\n    t += pow (abs (v.yz), vec2 (5. - 0.5 * float (j))) - smoothstep (0., 1., v.yz);\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= - aWav * waFac;\n    q *= fWav * qRot;\n    waFac *= smFac;\n  }\n  b = 0.5 * (0.5 + clamp (f, -0.5, 1.5));\n  return 3. * f / (b * b * (3. - 2. * b) + 0.5) + 2.;\n}\n\nfloat GrndHt (vec2 p)\n{\n  float ht;\n  if      (grType == 1) ht = GrndHt1 (p);\n  else if (grType == 2) ht = GrndHt2 (p);\n  else if (grType == 3) ht = GrndHt3 (p);\n  else if (grType == 4) ht = GrndHt4 (p);\n  return hFac * ht;\n}\n\nfloat GrndDf (vec3 p)\n{\n  return p.y - GrndHt (p.xz);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 300; j ++) {\n    h = GrndDf (ro + s * rd);\n    if (h < 0.) break;\n    sLo = s;\n    s += stepFac * (max (0.4, 0.6 * h) + 0.008 * s);\n    if (s > dstFar || j == stepLim) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (GrndDf (ro + s * rd) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat GrndDfN (vec3 p)\n{\n  return GrndDf (p) - 0.8 * Fbm2 (0.5 * p.xz);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.01, -0.01);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDfN (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GrndSShadow (vec3 p, vec3 vs)\n{\n  vec3 q;\n  float sh, d;\n  sh = 1.;\n  d = 0.4;\n  for (int j = VAR_ZERO; j < 25; j ++) {\n    q = p + vs * d;\n    sh = min (sh, smoothstep (0., 0.02 * d, GrndDf (q)));\n    d += max (0.4, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.2, 0.3, 0.55) + 0.25 * pow (1. - max (rd.y, 0.), 8.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float f;\n  ro.xz += 1.5 * tCur;\n  f = Fbm2 (0.1 * (ro + rd * (50. - ro.y) / rd.y).xz);\n  return mix (SkyBg (rd) + 0.35 * pow (max (dot (rd, sunDir), 0.), 16.),\n     vec3 (0.85), clamp (1.6 * f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colW, vn, vnw, rdo;\n  float dstGrnd, dstWat, f, spec, sh;\n  bool isRefl;\n  dstGrnd = GrndRay (ro, rd);\n  isRefl = false;\n  rdo = rd;\n  dstWat = (rd.y < 0.) ? - (ro.y - htWat) / rd.y : dstFar;\n  if (dstWat < min (dstGrnd, dstFar)) {\n    ro += dstWat * rd;\n    vnw = vec3 (0., 1., 0.);\n    vnw = VaryNf (2. * ro + vec3 (0.1, 0., 0.05) * tCur, vnw, 0.1 * (1. -\n       smoothstep (0.1, 0.4, dstWat / dstFar)));\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstGrnd = (refType > 1) ? GrndRay (ro, rd) : dstFar;\n    isRefl = true;\n    col = mix (vec3 (0.1, 0.3, 0.4), vec3 (0.1, 0.25, 0.5),\n       smoothstep (0.4, 0.6, Fbm2 (0.25 * ro.xz))) *\n       (0.3 + 0.7 * (max (vnw.y, 0.) + 0.1 * pow (max (dot (sunDir, rd), 0.), 32.)));\n    col = mix (col, SkyCol (ro, rd), 0.2 + 0.8 * pow (1. - abs (dot (rdo, vnw)), 2.));\n    colW = col;\n  }\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro);\n    f = 0.2 + 0.8 * smoothstep (0.35, 0.551, Fbm2 (1.7 * ro.xz));\n    col = mix (mix (vec3 (0.2, 0.35, 0.1), vec3 (0.1, 0.3, 0.15), f),\n       mix (vec3 (0.3, 0.25, 0.2), vec3 (0.35, 0.3, 0.3), f),\n       smoothstep (1., 3., ro.y));\n    col = mix (vec3 (0.4, 0.3, 0.2), col, smoothstep (0.2, 0.6, abs (vn.y)));\n    col = mix (col, vec3 (0.75, 0.7, 0.7), smoothstep (5., 8., ro.y - 0.5 * htWat));\n    col = mix (col, vec3 (0.9), smoothstep (7., 9., ro.y - 0.5 * htWat) *\n       smoothstep (0., 0.5, abs (vn.y)));\n    spec = mix (0.1, 0.5, smoothstep (8., 9., ro.y - 0.5 * htWat));\n    sh = (shType > 1) ? GrndSShadow (ro, sunDir) : 1.;\n    col *= 0.2 + 0.1 * vn.y + 0.8 * sh * max (0., max (dot (vn, sunDir), 0.)) +\n       spec * step (0.95, sh) * sh * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    f = dstGrnd / dstFar;\n    f *= f;\n    col = mix (col, SkyBg (rd), clamp (f * f, 0., 1.));\n    if (isRefl) col = mix (col, colW, pow (1. - abs (dot (rdo, vnw)), 5.));\n  } else if (! isRefl) col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec4 ShowWg (vec2 uv, vec2 canvas, vec4 parmV1, vec4 parmV2, vec4 parmV3)\n{\n  vec4 wgBx[10];\n  vec3 col, cc;\n  vec2 ut, ust;\n  float vW[10], asp, s;\n  cc = vec3 (1., 0., 0.);\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k < 6; k ++)\n     wgBx[k] = vec4 (0.36 * asp, 0.25 - 0.06 * float (k), 0.12 * asp, 0.018);\n  for (int k = 6; k < 10; k ++)\n     wgBx[k] = vec4 ((0.29 + 0.05 * float (k - 6)) * asp, -0.25, 0.024, 0.024);\n  vW[0] = parmV1.x;  vW[1] = parmV1.y;  vW[2] = parmV1.z;  vW[3] = parmV1.w;\n  vW[4] = parmV2.x;  vW[5] = parmV2.y;\n  vW[6] = parmV3.x;  vW[7] = parmV3.y;  vW[8] = parmV3.z;  vW[9] = parmV3.w;\n  col = vec3 (0.);\n  for (int k = 0; k < 6; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw;\n    if (Maxv2 (ust) < 0.) col = cc.xxx * ((Minv2 (abs (ust)) * canvas.y < 2.) ? 0.3 :\n       ((0.6 + 0.4 * smoothstep (0., 5., abs (mod (10. * ut.x / (2. * wgBx[k].z) + 0.5, 1.) -\n       0.5) * canvas.y - 20.)) * 0.6));\n    if (Maxv2 (ust) * canvas.y < 25.) {\n      ut.x -= (vW[k] - 0.5) * 2. * wgBx[k].z;\n      s = ShowInt (ut - vec2 (0.018, -0.01), 0.022 * vec2 (asp, 1.), 2.,\n         clamp (floor (100. * vW[k]), 0., 99.));\n      if (s > 0.) col = (k < 4) ? cc.yxy : ((k == 4) ? cc.yxx : cc.xyx);\n      ut = abs (ut) * vec2 (1., 1.2);\n      if (Maxv2 (abs (ut)) < 0.025 && Maxv2 (ut) > 0.02) col = cc.xxy;\n    }\n  }\n  for (int k = 6; k < 10; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw;\n    if (Maxv2 (ust) < 0.) {\n      col = cc.xxx * ((Minv2 (abs (ust)) * canvas.y < 2.) ? 0.3 : 0.6);\n      s = ShowInt (ut - vec2 (0.01, -0.01), 0.022 * vec2 (asp, 1.), 2., vW[k]);\n      if (s > 0.) col = (k == 6) ? cc.yxy : ((k == 7) ? cc : ((k == 8) ? cc.yyx : cc.xxy));\n    }\n  }\n  return vec4 (col, step (0.001, length (col)));\n}\n\nvec3 TrkPos (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid FlyerPM (float t, out vec3 flPos, out mat3 flMat)\n{\n  vec3 vel, acc, va, flVd, fpF, fpB;\n  vec2 cs;\n  float oRl, dt, vm;\n  dt = 0.5;\n  flPos = TrkPos (t);\n  fpF = TrkPos (t + dt);\n  fpB = TrkPos (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  vm = length (vel);\n  va = cross (acc, vel) / max (vm, 0.001);\n  flVd = (vm > 0.) ? vel / vm : vec3 (0.);\n  oRl = 2. * length (va) * sign (va.y);\n  oRl = smoothstep (0.02, 0.05, abs (oRl)) * oRl;\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 stDat, mPtr, wgBxC, parmV1, parmV2, parmV3, c4;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, hSum;\n  float el, az, asp, zmFac, sr, dt, tCur, tCurM, mvTot, h;\n  int wgSel, noInt;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  asp = canvas.x / canvas.y;\n  parmV1 = Loadv4 (0);\n  hFac = 1. + parmV1.x;\n  fWav = 1.5 + 0.7 * parmV1.y;\n  aWav = 0.1 + 0.5 * parmV1.z;\n  smFac = 0.3 + 0.7 * parmV1.w;\n  parmV2 = Loadv4 (1);\n  htWat = 8. * parmV2.x;\n  parmV3 = Loadv4 (2);\n  grType = int (parmV3.x);\n  qType = int (parmV3.y);\n  shType = int (parmV3.z);\n  refType = int (parmV3.w);\n  stDat = Loadv4 (3);\n  el = stDat.x;\n  az = stDat.y;\n  tCur = stDat.z;\n  tCurM = stDat.w;\n  stDat = Loadv4 (4);\n  mvTot = stDat.x;\n  noInt = int (stDat.y);\n  stDat = Loadv4 (5);\n  mPtr = vec4 (stDat.xyz, 0.);\n  wgSel = int (stDat.w);\n  if (qType == 1) {\n    dstFar = 170.;\n    stepLim = 100;\n    stepFac = 1.;\n  } else if (qType == 2) {\n    dstFar = 220.;\n    stepLim = 200;\n    stepFac = 0.5;\n  } else if (qType >= 3) {\n    dstFar = 300.;\n    stepLim = 300;\n    stepFac = 0.33;\n  }\n  if (shType == 1) sunDir = normalize (vec3 (1., 2., -1.));\n  else if (shType == 2) sunDir = normalize (vec3 (1., 1.5, -1.));\n  else if (shType == 3) sunDir = normalize (vec3 (1., 1., -1.));\n  FlyerPM (mvTot, ro, flMat);\n  dt = 0.3;\n  hSum = vec2 (0.);\n  for (float k = -2.; k < 8.; k ++)\n     hSum += vec2 (GrndHt (TrkPos (mvTot + k * dt).xz), 1);\n  ro.y = max (4. * hFac + hSum.x / hSum.y, htWat + 6.);\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.5;\n  if (abs (uv.y) < 0.9) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif\n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      uvv /= zmFac;\n      rd = normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n      rd = (vuMat * rd) * flMat;\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = vec3 (0.05);\n  if (noInt > 0 || tCur - tCurM < 6.) {\n    c4 = ShowWg (uv, canvas, parmV1, parmV2, parmV3);\n    c4 = vec4 (mix (col, c4.rgb, c4.a),\n       ((noInt > 0) ? 0.3 : 0.2 + 0.8 * smoothstep (5., 6., tCur - tCurM)));\n  } else {\n    wgBxC = vec4 (0.47 * asp, -0.4, 0.022, 0.);\n    c4 = vec4 (0.7, 0.7, 0., 0.3 + 0.7 * smoothstep (1., 2.,\n       abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y));\n  }\n  col = mix (c4.rgb, col, c4.a);\n  if (mPtr.z > 0. && wgSel < 0) {\n    if (Maxv2 (abs (uv)) < 0.05 && Minv2 (abs (uv)) < 0.005)\n       col = mix (col, vec3 (1., 1., 0.1), 0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, vec2 (1., 57.)));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Terrain Explorer 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.1415927;\nconst float txRow = 32.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[10], wgBxC, mPtr, mPtrP, stDat, parmV1, parmV2, parmV3;\n  vec2 iFrag, canvas, ust;\n  float tCur, tCurP, tCurM, vW, asp, el, az, flyVel, mvTot;\n  int pxId, wgSel, wgReg, kSel, grType, qType, shType, refType, noInt;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 6) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  wgSel = -1;\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  if (iFrame <= 2) {\n    parmV1 = vec4 (0.6, 0.6, 0.8, 0.6);\n    parmV2 = vec4 (0.2, 0.3, 0., 0.);\n    parmV3 = vec4 (1., 2., 2., 1.);\n    el = -0.05 * pi;\n    az = 0.;\n    mvTot = 0.;\n    mPtrP = mPtr;\n    tCurP = tCur;\n    tCurM = tCur;\n    noInt = 1;\n  } else {\n    parmV1 = Loadv4 (0);\n    parmV2 = Loadv4 (1);\n    flyVel = parmV2.y;\n    parmV3 = Loadv4 (2);\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    tCurP = stDat.z;\n    tCurM = stDat.w;\n    stDat = Loadv4 (4);\n    mvTot = stDat.x;\n    noInt = int (stDat.y);\n    mvTot += 8. * flyVel * (tCur - tCurP);\n    if (mvTot > 4000.) mvTot = 0.;\n    stDat = Loadv4 (5);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 6; k ++)\n       wgBx[k] = vec4 (0.36 * asp, 0.25 - 0.06 * float (k), 0.12 * asp, 0.018);\n    for (int k = 6; k < 10; k ++)\n       wgBx[k] = vec4 ((0.29 + 0.05 * float (k - 6)) * asp, -0.25, 0.024, 0.024);\n    wgBxC = vec4 (0.47 * asp, -0.4, 0.022, 0.);\n    for (int k = 0; k < 10; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    ust = mPtr.xy * vec2 (asp, 1.) - wgBxC.xy;\n    if (length (ust) < wgBxC.z) wgReg = 10;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    if (wgSel >= 0 || noInt > 0) tCurM = tCur;\n    noInt = 0;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = 2. * pi * mPtr.x;\n      el = -0.05 * pi + 0.8 * pi * mPtr.y;\n    } else {\n      el = mix (el, -0.05 * pi, 0.02);\n      az = mix (az, 0., 0.02);\n    }\n  } else {\n    if (wgSel < 6) {\n      for (int k = 0; k < 6; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.x * asp - wgBx[k].x) / wgBx[k].z, 0., 0.99);\n          break;\n        }\n      }\n      if      (kSel == 0) parmV1.x = vW;\n      else if (kSel == 1) parmV1.y = vW;\n      else if (kSel == 2) parmV1.z = vW;\n      else if (kSel == 3) parmV1.w = vW;\n      else if (kSel == 4) parmV2.x = vW;\n      else if (kSel == 5) parmV2.y = vW;\n    } else if (mPtrP.z <= 0.) {\n      if (wgSel == 6) {\n        grType = int (parmV3.x);\n        if (++ grType > 4) grType = 1;\n        parmV3.x = float (grType);\n      } else if (wgSel == 7) {\n        qType = int (parmV3.y);\n        if (++ qType > 3) qType = 1;\n        parmV3.y = float (qType);\n      } else if (wgSel == 8) {\n        shType = int (parmV3.z);\n        if (++ shType > 3) shType = 1;\n        parmV3.z = float (shType);\n      } else if (wgSel == 9) {\n        refType = int (parmV3.w);\n        if (++ refType > 2) refType = 1;\n        parmV3.w = float (refType);\n      }\n    }\n  }\n  if      (pxId == 0) stDat = parmV1;\n  else if (pxId == 1) stDat = parmV2;\n  else if (pxId == 2) stDat = parmV3;\n  else if (pxId == 3) stDat = vec4 (el, az, tCur, tCurM);\n  else if (pxId == 4) stDat = vec4 (mvTot, float (noInt), 0., 0.);\n  else if (pxId == 5) stDat = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}