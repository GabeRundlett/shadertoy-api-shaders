{
    "Shader": {
        "info": {
            "date": "1492961507",
            "description": "an implement from https://www.shadertoy.com/view/MdlcWH",
            "flags": 32,
            "hasliked": 0,
            "id": "Md2cRV",
            "likes": 9,
            "name": "GLSL smallpt old-fashioned displ",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "reflection",
                "refraction",
                "globalillumination",
                "pathtracing",
                "montecarlo"
            ],
            "usePreview": 0,
            "username": "0xAA55",
            "viewed": 1415
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GAUSSIAN_BLUR_V 5\n#define GAUSSIAN_BLUR_DIFF .2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0);\n    float diffusion = length(texture(iChannel0, fragCoord / iResolution.xy)) * GAUSSIAN_BLUR_DIFF;\n    for(int i = -GAUSSIAN_BLUR_V; i <= GAUSSIAN_BLUR_V; i++)\n    {\n        color += texture(iChannel0, (fragCoord + vec2(0, i) * diffusion) / iResolution.xy);\n    }\n    fragColor = color / vec4(GAUSSIAN_BLUR_V * 2 + 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GAUSSIAN_BLUR_H 5\n#define GAUSSIAN_BLUR_DIFF .2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0);\n    float diffusion = length(texture(iChannel0, fragCoord / iResolution.xy)) * GAUSSIAN_BLUR_DIFF;\n    for(int i = -GAUSSIAN_BLUR_H; i <= GAUSSIAN_BLUR_H; i++)\n    {\n        color += texture(iChannel0, (fragCoord + vec2(i, 0) * diffusion) / iResolution.xy);\n    }\n    fragColor = color / vec4(GAUSSIAN_BLUR_H * 2 + 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nThis shader is an attempt at porting smallpt to GLSL.\n\nSee what it's all about here:\nhttp://www.kevinbeason.com/smallpt/\n\nThe code is based in particular on the slides by David Cline.\n\nSome differences:\n\n- For optimization purposes, the code considers there is\n  only one light source (see the commented loop)\n- Russian roulette and tent filter are not implemented\n\nI spent quite some time pulling my hair over inconsistent\nbehavior between Chrome and Firefox, Angle and native. I\nexpect many GLSL related bugs to be lurking, on top of\nimplementation errors. Please Let me know if you find any.\n\n--\nZavie\n\n*/\n\n// Play with the two following values to change quality.\n// You want as many samples as your GPU can bear. :)\n#define SAMPLES 16\n#define MAXDEPTH 8\n#define ENABLE_NEXT_EVENT_PREDICTION\n\n// Uncomment to see how many samples never reach a light source\n// #define DEBUG\n\n// Not used for now\n#define DEPTH_RUSSIAN 2\n\n#define PI 3.1415926535897932384626\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define NUM_SPHERES 9\n\n#define POV (1. / 10.)\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n};\n\nSphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), DIFF);\n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF);\n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(.0), DIFF);\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC);\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR);\n\tspheres[8] = Sphere(600., vec3(50., 681.33, 81.6),\tvec3(12.), vec3(0.), DIFF);\n    \n    float angle = iTime * PI * 2.;\n    vec3 pos = vec3(sin(angle), 0, cos(angle)) * 10.;\n    spheres[7].p += pos;\n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id = intersect(r, t, obj, id)) < 0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d));\n\n        float E = 1.;\n\t\t// vec3 f = obj.c;\n\t\t// float p = dot(f, vec3(1.2126, 0.7152, 0.0722));\n\t\t// if (depth > DEPTH_RUSSIAN || p == 0.) if (rand() < p) f /= p; else { acc += mask * obj.e * E; break; }\n\n\t\tif (obj.refl == DIFF) {\n\t\t\tfloat r2 = rand();\n\t\t\tvec3 d = jitter(nl, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = vec3(0.);\n#ifdef ENABLE_NEXT_EVENT_PREDICTION\n\t\t\t// for (int i = 0; i < NUM_SPHERES; ++i)\n\t\t\t{\n\t\t\t\t// Sphere s = spheres[i];\n\t\t\t\t// if (dot(s.e, vec3(1.)) == 0.) continue;\n\n\t\t\t\t// Normally we would loop over the light sources and\n\t\t\t\t// cast rays toward them, but since there is only one\n\t\t\t\t// light source, that is mostly occluded, here goes\n\t\t\t\t// the ad hoc optimization:\n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 8;\n\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n\n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\te += (s.e * clamp(dot(l, n),0.,1.) * omega) / PI;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t//float(depth==0);\n\t\t\tacc += mask * obj.e * E + mask * obj.c * e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, d);\n\t\t} else if (obj.refl == SPEC) {\n\t\t\tacc += mask * obj.e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t} else {\n\t\t\tfloat a=dot(n,r.d), ddn=abs(a);\n\t\t\tfloat nc=1., nt=1.5, nnt=mix(nc/nt, nt/nc, float(a>0.));\n\t\t\tfloat cos2t=1.-nnt*nnt*(1.-ddn*ddn);\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t\tif (cos2t>0.) {\n\t\t\t\tvec3 tdir = normalize(r.d*nnt + sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n\t\t\t\tfloat R0=(nt-nc)*(nt-nc)/((nt+nc)*(nt+nc)),\n\t\t\t\t\tc = 1.-mix(ddn,dot(tdir, n),float(a>0.));\n\t\t\t\tfloat Re=R0+(1.-R0)*c*c*c*c*c,P=.25+.5*Re,RP=Re/P,TP=(1.-Re)/(1.-P);\n\t\t\t\tif (rand()<P) { mask *= RP; }\n\t\t\t\telse { mask *= obj.c*TP; r = Ray(x, tdir); }\n\t\t\t}\n\t\t}\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tseed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\tinitSpheres();\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec3 camPos = vec3((2. * (iMouse.xy==vec2(0.)?.5*iResolution.xy:iMouse.xy) / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), 169.);\n\tvec3 cz = normalize(vec3(50., 40., 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n\tvec3 color = vec3(0.);\n\tfor (int i = 0; i < SAMPLES; ++i)\n    {\n#ifdef DEBUG\n        vec3 test = radiance(Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n        if (dot(test, test) > 0.) color += vec3(1.); else color += vec3(0.5,0.,0.1);\n#else\n\t\tcolor += radiance(Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n#endif\n    }\n    \n    // 0xAA55:\n    // Here was modified by me, I added \"vision stay\" feature here.\n    vec4 newcolor = vec4(pow(clamp(color/float(SAMPLES), 0., 1.), vec3(1./2.2)), 1.);\n    vec4 oldcolor = texture(iChannel0, fragCoord / iResolution.xy);\n    if(iTimeDelta <= POV)\n    {\n        float ratio = iTimeDelta / POV;\n\t\tfragColor = newcolor * ratio + oldcolor * (1. - ratio);\n    }\n    else\n        fragColor = newcolor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}