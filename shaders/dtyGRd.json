{
    "Shader": {
        "info": {
            "date": "1684450643",
            "description": "Just some experiments/learning. This AA is crazy expensive so turn off if slow. Was trying to get a \"glow\" effect which is achieved by accumulating color at every marching step, but this way of doing it seems to be brittle and leaves artifacts elswehere.",
            "flags": 0,
            "hasliked": 0,
            "id": "dtyGRd",
            "likes": 21,
            "name": "Radioactive dreamy puddle",
            "published": 3,
            "tags": [
                "raymarching",
                "glow",
                "aa",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "Mermersk",
            "viewed": 617
        },
        "renderpass": [
            {
                "code": "/*\n    Author: Mermersk (ic4ruz39@gmail.com)\n*/\n\n#define PI 3.141592653589793\n#define MAX_STEPS 300\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.001\n\nconst bool AA = false;\n\n//A struct that hold both the sdf value and the color\nstruct Surface {\n\tfloat distVal;\n\tvec4 color;\n\tint id; //0 = waves, 1 = skyDome\n};\n\n\nfloat singleWave(vec3 p, float wavelength, float amplitude, float speed, vec2 direction) {\n\t\n\tfloat frequency = 2.0/wavelength;\n\tfloat phaseConstant = speed * (2.0/wavelength);\n\t\n\treturn amplitude * sin(dot(direction, p.xz)*frequency + iTime*phaseConstant);\n\n\n}\n\nfloat singleWave2(vec3 p, float wavelength, float amplitude, float speed, vec2 direction) {\n\t\n\tfloat frequency = 2.0/wavelength;\n\tfloat phaseConstant = speed * (2.0/wavelength);\n\t\n\tconst float kkk = 2.5;\n\t\n\treturn 2.0*amplitude * pow((sin(dot(normalize(p.xz), p.xz)*frequency + iTime*phaseConstant)+1.0)/2.0, kkk);\n\n\n}\n\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise1d(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\t\n\treturn mix(hashwithoutsine11(i), hashwithoutsine11(i+1.0), smoothstep(0.0, 1.0, f));\n}\n\nSurface wavyPlane(vec3 p, vec4 col, int id) {\n\t\n\t\n\tfloat wave = singleWave(p, 3.0, 2.0, 2.0, vec2(1.0, 0.0));//a * sin(dot(d, p.xz)*f + iTime*pc);\n\t\n\tfloat w = 0.0;\n\t\n\tfloat waveLength = 5.0;\n\tfloat amplitude = 1.0;\n\tfloat speed = 0.9;\n\tvec2 dir = vec2(1.0, 0.0);\n\t\n\t//Coordinates from origin and increase equally in all directions from origin\n\tfloat fromMiddle = dot(normalize(p.xz), p.xz)*0.2;\n\t\n\tfor (int i = 0; i < 5; i++) {\n\t\tw += singleWave2(p, waveLength, amplitude, speed, dir);// + noise(p.xz*fromMiddle*waveLength*max(0.0, noise1d(fromMiddle)))*0.15;;\n\t\twaveLength *= 0.5;\n\t\tamplitude *= 0.55;\n\t\tspeed *= 0.5;\n\t\tdir = vec2(1.0, float(i)/1.0);\n\t}\n\t\n\tw += noise(p.xz*5.0+0.5*fromMiddle*9.0*max(0.0, sin(noise1d(fromMiddle))*0.8))*0.25;\n\t\n\t//vec4 bottom = vec4(0.6, 0.0, 0.5, 0.1);\n\t//vec4 top = vec4(0.17, 0.35, 0.95, 0.1);\n\t\n\tvec4 bottom = vec4(53.0/255.0, 92.0/255.0, 125.0/255.0, 0.1);\n\tvec4 top = vec4(192.0/255.0, 108.0/255.0, 132.0/255.0, 0.1);\n\t\n\tcol = mix(bottom, top, w-1.3);\n\t\n\treturn Surface((p.y + w)*0.33, col, id);\n\n}\n\n\n//@Shane - path function\nvec2 path(in float z){\n    vec2 p1 =vec2(2.38*sin(z * .15)+5.38*cos(z * .15), 3.4*cos(z * .0945));\n    vec2 p2 =vec2(3.2*sin(z * .179),4.31*sin(z * .127));\n    return (p1 - p2)*0.33;\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n\n\tif (obj1.distVal < obj2.distVal) {\n\t\treturn obj1;\n\t}\n\t\n\treturn obj2;\n}\n\nSurface getDist(vec3 p) {\n\t\n\tp.xy += path(p.z*2.0+iTime);\n\t//p.xz += path(p.x*1.0+iTime);\n\t\n\tSurface wavyPlanez = wavyPlane(p*1.0, vec4(1.0), 0);\n\t\n\treturn wavyPlanez;\n\n}\n\nSurface rayMarch(vec3 rayOrigin, vec3 rayDirection) {\n\t\n\tSurface closestObject = Surface(0.0, vec4(1.0, 0.0, 0.0, 1.0), 0);\n\t\n\tvec4 glow = vec4(0.0);\n\t\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n\t\t//The current stop (blue point from video). Will in first iteration just be the rayOrigin\n\t\tvec3 currentStop = rayOrigin + (closestObject.distVal * rayDirection);\n\t\t//Distance to the closes \"thing\" in our scene\n\t\tSurface distToScene = getDist(currentStop);\n\t\tclosestObject.distVal += distToScene.distVal;\n\t\tclosestObject.color = distToScene.color;\n\t\tclosestObject.id = distToScene.id;\n\t\t\n\t\t\n\t\tglow += distToScene.color*(1.0/float(MAX_STEPS))*7.0;\n\t\t\n\t\tclosestObject.color = clamp(glow, 0.0, 1.0);\n\t\t\n\t\t// we have a hit || The distance is too large, this ray hit nothing. we marched past everything, dont want to march to infinity \n\t\tif (closestObject.distVal > MAX_DIST || distToScene.distVal < SURFACE_DIST) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\t\n\treturn closestObject;\n\n}\n\n/* ChatGPT solutuon for crating a view matrix */\nmat3 getViewMatrix(vec3 cameraPos, vec3 cameraTarget, vec3 cameraUp)\n{\n    // Calculate the view direction vector\n    vec3 viewDir = normalize(cameraTarget - cameraPos);\n\n    // Calculate the right and up direction vectors\n    vec3 rightDir = normalize(cross(cameraUp, viewDir));\n    vec3 upDir = cross(viewDir, rightDir);\n\n    // Create the view matrix\n    mat3 viewMatrix = mat3(rightDir, upDir, viewDir);\n\n    return viewMatrix;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 ogUV = uv;\n    uv = (uv * 2.0) - 1.0;\n    \n    //uv *= 1.0;\n    \n    float ar = iResolution.x / iResolution.y;\n    uv.x = uv.x * ar;\n    \n    //Init raymarch\n    vec3 rayOrigin = vec3(0.0, 6.0, -12.0);\n    \n    //vec3 lookAtPoint = vec3(sin(iTime*0.1)*10.0, cos(iTime*0.1)*13.0, 1.0);\n    vec3 lookAtPoint = vec3(sin(iTime*0.1)*10.0, cos(iTime*0.5)*3.0, 0.0);\n    \n    mat3 viewM = getViewMatrix(rayOrigin, lookAtPoint, vec3(0.0, 1.0, 0.0));\n    \n    vec3 col = vec3(0.0); \n    \n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.0));\n    rayDirection = viewM * rayDirection;\n    //rayOrigin = viewM * rayOrigin;\n    //rayDirection = rayDirRes;\n    \n    Surface objects = rayMarch(rayOrigin, rayDirection);\n    float d = objects.distVal;\n    vec3 surfacePoints = rayOrigin + (rayDirection * d);\n    \n    if (AA) {\n        //AA\n        vec3 acc = vec3(0.0);\n        float offAmount = 0.001;\n        //Taking 3 samples up(y-axis) from current pixel and 1 down seems the best?\n        vec3[4] offs = vec3[](\n            vec3(0.0, offAmount*3.0, 0.0),\n            vec3(0.0, offAmount*2.0, 0.0),\n            vec3(0.0, offAmount, 0.0),\n            vec3(0.0, -offAmount, 0.0)\n        );\n\n        //Really expensive AA\n        for (int i = 0; i < offs.length(); i++) {\n            vec3 off = offs[i];\n            vec3 rayDirNeighb = rayDirection + off;\n            Surface neighbObjects = rayMarch(rayOrigin, rayDirNeighb);\n            acc += neighbObjects.color.rgb;\n        }\n        \n        col = col + ((objects.color.rgb + acc)/5.0);\n    } else {\n        col = col + objects.color.rgb;\n    }\n    \n     \n  \t\n  \t//col = col + objects.color.rgb;\n    //col = col + ((objects.color.rgb + acc)/5.0);\n    \n    //------ PostProcess experiments--------\n    //Contrast\n    float contrastVal = 1.0;\n    col = clamp(contrastVal * (col - 0.5) + 0.5, 0.0, 1.0);\n    //brightness\n    float brightness = 0.0;\n    col = clamp(col + brightness, 0.0, 1.0);\n    //Saturation\n    float grayscale = dot(col, vec3(0.299, 0.587, 0.114));\n    float saturation = 1.15;\n    col = clamp(mix(vec3(grayscale), col, saturation), 0.0, 1.0);\n    \n    //col = vec3(grayscale);\n    \n    //Gamma correction\n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}