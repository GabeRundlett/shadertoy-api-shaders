{
    "Shader": {
        "info": {
            "date": "1630714190",
            "description": "Newton fractal of the nth mandelbrot polynomial. Controls: WASD to move, up/down arrows to zoom, and left/right arrows to change the number of iterations.",
            "flags": 48,
            "hasliked": 0,
            "id": "Ndc3Wf",
            "likes": 4,
            "name": "mandelbrot newton fractal",
            "published": 3,
            "tags": [
                "fractal",
                "interactive",
                "zoomable"
            ],
            "usePreview": 0,
            "username": "peabrainiac",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "/*\n * Newton fractal of the nth mandelbrot polynomial or whatever... you\n * know, c^2+c for n=2, (c^2+c)^2+c for n=3 and so on. What makes this\n * interesting to me is that this fractal naturally but almost secretly\n * arises in the background when trying to find minibrots by applying\n * newton's method, in the form of the pattern of where the algorithm is\n * able to find a minibrot of the given period and where not.\n *\n * Controls:\n *  - left/right arrow keys: number of iterations/which polynomial is used\n *  - up/down arrow keys: zoom\n *  - WASD: moving around\n * \n * If you want to dig into the code, Buffer A contains the actual fractal-\n * related code, while Buffer B contains all of the controls, together\n * with a bunch of code that is currently unused and has just been copied\n * over from one of my previous shaders.\n * This whole piece of code is licensed under the unlicense (see below),\n * so feel free to fork and edit it as you like.\n * \n *  - - - - -\n * \n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org/>.\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float BAILOUT = 4096.0;\nconst int STEPS = 50;\nconst float A = 1.0;\n\nfloat color(vec2 c);\n\nfloat fractal(in vec2 startC, in int iter);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if (false&&texelFetch(iChannel0,ivec2(0),0).x==0.0){\n        // if the update flag in buffer B is not set, simply keep the old value\n        fragColor = texelFetch(iChannel1,ivec2(fragCoord),0);\n    }else{\n        vec4 cameraPosition = texelFetch(iChannel0,ivec2(2,0),0);\n        vec2 dc = vec2(10.0/(length(iResolution)*cameraPosition.z),0.0);\n        vec2 c = cameraPosition.xy+dc.x*vec2(1.,-1.)*(fragCoord-iResolution.xy*0.5);\n        fragColor = vec4(vec3(color(c)),1.0);\n    }\n}\n\n// computes the brightness the pixel at a given fractal coordinate should have\nfloat color(vec2 c){\n    vec3 config = texelFetch(iChannel0,ivec2(1,0),0).xyz;\n    int iter = int(config.z);\n    return fractal(c,iter);\n}\n\nfloat fractal(in vec2 startC, in int iter){\n    vec2 c = startC;\n    for (int step=0;step<STEPS;step++){\n        vec2 z = c;\n        vec2 dz = vec2(1.0,0.0);\n        int i;\n        for (i=0;i<iter;i++){\n            dz = 2.0*cmul(z,dz)+vec2(1.0,0.0);\n            z = cmul(z,z)+c;\n            if (dot(z,z)>1e12){\n                i++;\n                break;\n            }\n        }\n        vec2 temp = A*cdiv(z,dz)*pow(0.5,float(iter-i));\n        c -= temp;\n        if (dot(temp,temp)<1e-11&&i==iter){\n            return float(step)/float(STEPS);\n        }\n    }\n    return 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n * Control buffer. Don't ask, I've written this months ago and only forked and tweaked this again and again since then.\n *\n * Stored values in the first row of pixels, in order:\n *  - refresh flag, animation flag, reset flag (unused)\n *  - formula id (unused), formula param (unused), iterations\n *  - X, Y, zoom, minibrot index\n */\n\nvec3 defaultAnimation(float t);\nfloat keysDown();\nint keyState(int key);\nivec4 keyStates(int key1, int key2, int key3, int key4);\nint keyPressed(int key);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 p = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    if (!(p.y==0&&p.x<=2)){\n        return;\n    }\n    // set up default values in the first frame\n    if (iFrame==0){\n        if (p==ivec2(0,0)){\n            // flags\n            fragColor = vec4(1.0,1.0,0.0,0.0);\n        }else if(p==ivec2(1,0)){\n            // iterations\n            fragColor = vec4(0.0,0.0,16.0,0.0);\n        }else if(p==ivec2(2,0)){\n            // position\n            fragColor = vec4(defaultAnimation(iTime),0.0);\n        }\n        return;\n    }\n    fragColor = texelFetch(iChannel0,p,0);\n    if (p==ivec2(0,0)){\n        // flag updates\n        float keys = keysDown();\n        if (fragColor.y==1.0){\n            if (keys>0.0){\n                // animation end because of user input\n                fragColor.xyz = vec3(1.0,0.0,1.0);\n            }\n        }else{\n            //refresh flag update\n            fragColor.x = min(1.0,keys+step(mod(float(iFrame),30.0),0.0));\n            fragColor.z = 0.0;\n        }\n    }else if(p==ivec2(1,0)){\n        // formula & iteration changes\n        fragColor.z += min(100.0,fragColor.z*(pow(2.0,iTimeDelta*float(keyState(KEY_RIGHT)-keyState(KEY_LEFT)))-1.0));\n    }else if(p==ivec2(2,0)){\n        vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n        vec4 cameraPosition;\n        // get/update camera position\n        if (flags.y==1.0){\n            // animation\n            cameraPosition = vec4(defaultAnimation(iTime),0.0);\n        }else{\n            // normal controls\n            cameraPosition = texelFetch(iChannel0,ivec2(2,0),0);\n            cameraPosition.xy -= 2.0*iTimeDelta*vec2(float(keyState(KEY_A)-keyState(KEY_D)),float(keyState(KEY_W)-keyState(KEY_S)))/cameraPosition.z;\n            cameraPosition.z *= pow(2.0,iTimeDelta*float(keyState(KEY_UP)-keyState(KEY_DOWN)));\n        }\n        fragColor = cameraPosition;\n    }\n}\n\n// animation that plays until the first user input is received\nvec3 defaultAnimation(float t){\n    float theta = 0.3*t*t/(t+2.0);\n    float a = 0.5*theta-0.25*PI;\n    a = cos(a-0.5*sin(a));\n    float b = 1.0-abs(a);\n    b = b*b;\n    a = sign(a)*(1.0-b*b*b*b*b);\n    a = 0.5+0.5*a;\n    vec3 pos;\n    pos.xy = (0.625+a*0.125)*vec2(-sin(theta),-cos(theta))+vec2((a-1.0)*0.125,0.0);\n    pos.z = (3.0-2.0*a)*(1.0+3.0*t*t/(t*t+5.0));\n    return pos;\n}\n\n// number of relevant keys that are currently pressed\nfloat keysDown(){\n    float temp = dot(vec4(keyStates(KEY_UP,KEY_DOWN,KEY_UP,KEY_DOWN)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_W,KEY_A,KEY_S,KEY_D)),vec4(1.0));\n    return temp;\n}\n\nint keyState(int key){\n    return int(texelFetch(iChannel1,ivec2(key,0),0).x);\n}\n\nivec4 keyStates(int key1, int key2, int key3, int key4){\n    return ivec4(keyState(key1),keyState(key2),keyState(key3),keyState(key4));\n}\n\nint keyPressed(int key){\n    return int(texelFetch(iChannel1,ivec2(key,1),0).x);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_E = 69; // nice.\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_F = 70;\n\nconst float PI = 3.14159265358979323846264;\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(dot(a,vec2(1.0,-1.0)*b),dot(a,b.yx));\n}\n\nvec2 cdiv(vec2 a, vec2 b){\n    return vec2(dot(a,b),dot(a.yx,vec2(1.0,-1.0)*b))/dot(b,b);\n}\n\nvec2 clog(vec2 a){\n    return vec2(0.5*log(dot(a,a)),atan(a.y,a.x));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}