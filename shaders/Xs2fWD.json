{
    "Shader": {
        "info": {
            "date": "1500929190",
            "description": "Greetings adventurer!\nControls: arrow keys\nTIPs:\n-Attack by walking into enemies\n-Walk into a wall to skip a turn\n-Time movement to attack first\n-Lure enemies into traps\nBased on \"Pixel Dungeon\" (http://pixeldungeon.watabou.ru/)",
            "flags": 112,
            "hasliked": 0,
            "id": "Xs2fWD",
            "likes": 239,
            "name": "[SH17B] Pixel Shader Dungeon",
            "published": 3,
            "tags": [
                "game",
                "pixel",
                "sprite",
                "dungeon",
                "sh17b",
                "crawler"
            ],
            "usePreview": 1,
            "username": "knarkowicz",
            "viewed": 24212
        },
        "renderpass": [
            {
                "code": "// Based on \"Pixel Dungeon\" (http://pixeldungeon.watabou.ru/)\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_POTION\t\t\t= 2.;\nconst float ITEM_SPAWNER\t\t= 3.;\nconst float LOG_ID_DMG\t\t\t= 1.;\nconst float LOG_ID_XP\t\t\t= 2.;\nconst float LOG_ID_LEVEL_UP\t\t= 3.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst vec2  REF_RES\t            = vec2( 200. );\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    // 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t// 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    // 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    // 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    // 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) / 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid SpriteKey( inout vec3 color, vec2 p )\n{\n    p -= vec2( 5., 2. );\n    p = p.x < 0. ? vec2( 0. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 8. ? 139824 : 0 ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 2232611 : 0 ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 1179666 : 0 ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 1245202 : 0 ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 1192482 : 0 ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 74256 : 0 ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 135680 : 0 ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.45 ) : color;\n    color = i == 2. ? vec3( 0.83 ) : color;\n    color = i == 3. ? vec3( 0.95 ) : color;\n}\n\nvec2 FrameOffset( float frame, float tick )\n{\n    vec2 ret = vec2( 0. );\n    ret.x = frame == 1. ? 1. : ( frame == 2. ? -1. : 0. );\n    ret.y = frame == 3. ? 1. : ( frame == 4. ? -1. : 0. );\n    return floor( 16. * ret * ( tick / TICK_NUM ) );\n}\n\nfloat EnemyHP( float id )\n{\n    return 8. + id * 15.;\n}\n\nfloat MaxXP( float level )\n{\n\treturn 10. + level * 5.;\t   \n}\n\nfloat MaxHP( float level )\n{\n\treturn 21. + level * 3.;\t   \n}\n\nfloat TextSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return texture( iChannel3, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255.;\n}\n\nvoid PrintChar( inout float sdf, inout vec2 p, float c )\n{\n    p.x -= 4.;\n    sdf = min( sdf, TextSDF( p * .1, c ) );\n}\n\nvoid PrintVal( inout float sdf, inout vec2 p, float val )\n{\n    if ( val > 9. )\n    {\n        p.x -= 4.;\n        float d = floor( val * 0.1 );\n        sdf = min( sdf, TextSDF( p * .1, 48. + d ) );\n        val -= d * 10.;\n    }\n    \n    p.x -= 4.;\n\tsdf = min( sdf, TextSDF( p * .1, 48. + val ) );\n}\n\nvoid RastText( inout vec3 color, float t, float l, vec3 textColor )\n{\n    float alpha = Smooth( 1. - ( 2. * l - 1. ) );\n    color = mix( color, vec3( 0. ), saturate( exp( -t * 20. ) ) * alpha );\n    color = mix( color, textColor, Smooth( -t * 100. ) * alpha );    \n}\n\nvoid DrawText( inout vec3 color, vec2 edge, vec2 center, vec2 world, in GameState s )\n{\n    // xp\n    if ( s.logPos[ 0 ].x > 0. )\n    {\n        float t = 1e4;\n        \n        vec2 p = world;\n        p -= s.logPos[ 0 ] * 16.;\n        p.x += 8.;\n        p.y -= s.logLife[ 0 ] * 16.;\n        PrintChar( t, p, 43. );\n        PrintVal( t, p, s.logVal[ 0 ] );\n        PrintChar( t, p, 69. );\n        PrintChar( t, p, 88. );\n        PrintChar( t, p, 80. );\n        \n\t\tif ( s.logId[ 0 ] > 0. )\n        {\n            p = world;\n            p -= s.logPos[ 0 ] * 16.;\n            p.x += 16.;\n            p.y -= s.logLife[ 0 ] * 16. - 8.;\n           \tPrintChar( t, p, 76. );\n            PrintChar( t, p, 69. );\n            PrintChar( t, p, 86. );\n            PrintChar( t, p, 69. );\n            PrintChar( t, p, 76. );\n            PrintChar( t, p, 32. );\n            PrintChar( t, p, 85. );\n            PrintChar( t, p, 80. );\n            PrintChar( t, p, 33. );\n        }\n        \n        RastText( color, t, s.logLife[ 0 ], vec3( 1., 1., 0. ) );\n    }    \n    \n    // heal\n    if ( s.logPos[ 1 ].x > 0. )\n    {\n        float t = 1e4; \n        vec2 p = world;\n        p -= s.logPos[ 1 ] * 16.;\n        p.x += 8.;\n        p.y -= s.logLife[ 1 ] * 16.;      \n        PrintChar( t, p, 43. );\n        PrintVal( t, p, s.logVal[ 1 ] );\n        PrintChar( t, p, 72. );\n        PrintChar( t, p, 80. );\n        RastText( color, t, s.logLife[ 1 ], vec3( 0., 1., 0. ) ); \n    }\n    \n    // dmg\n    for ( int i = 2; i < LOG_NUM; ++i )\n    {\n\t\tfloat t = 1e4;        \n        \n        if ( s.logPos[ i ].x > 0. )\n        {\n            vec2 p = world;\n            p -= s.logPos[ i ] * 16.;\n            p.y -= s.logLife[ i ] * 16.;        \n            PrintVal( t, p, s.logVal[ i ] );\n        }\n        \n        RastText( color, t, s.logLife[ i ], vec3( 1., 0., 0. ) );     \n    }\n    \n    // game over\n    if ( s.state == STATE_GAME_OVER )\n    {      \n        float alpha = Smooth( ( s.stateTime - 0.33 ) * 4. );\n        \n        color = mix( color, color.yyy * .5, alpha );\n        \n        float t = 1e4; \n        \n        vec2 p = .25 * center;\n        p.x += 24.;\n        p.y += 6.;\n        PrintChar( t, p, 89. );\n        PrintChar( t, p, 79. );\n        PrintChar( t, p, 85. );\n        p.x -= 4.;\n        PrintChar( t, p, 68. );\n        PrintChar( t, p, 73. );\n        PrintChar( t, p, 69. );\n        PrintChar( t, p, 68. );\n        \n        RastText( color, t, 1. - alpha, vec3( 1., 0., 0. ) );     \n    }\n    \n    // level\n    vec2 p = edge + vec2( 2.2, 20.8 );\n    float t = 1e4;\n    PrintChar( t, p, 48. + s.level + 1. );\n    color = mix( color, vec3( 1. ), Smooth( -t * 100. ) ); \n}\n\nfloat Rectangle( vec2 p, vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return min( max( d.x, d.y ), 0. ) + length( max( d, 0. ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    GameState s;\n    LoadState( s );    \n    \n    vec2 playerPos = s.playerPos * 16. + FrameOffset( s.playerFrame, s.tick ); \n    \n    vec2 resMult\t= floor( iResolution.xy / REF_RES );\n    float resRcp    = 1. / max( min( resMult.x, resMult.y ), 1. );\n    vec2 screenSize = floor( iResolution.xy * resRcp );\n    vec2 pixel      = floor( fragCoord.xy * resRcp );\n\tvec2 camera     = clamp( playerPos - floor( screenSize / 2. ), vec2( -32. ), vec2( 32. * 16. + 32. ) - screenSize );\n    vec2 world      = pixel + camera;\n    vec2 tile\t\t= floor( world / 16. );\n    vec2 worldMod16 = floor( mod( world, 16. ) );\n    vec4 map\t\t= texelFetch( iChannel1, ivec2( tile ), 0 );\n    vec2 edgeFlt\t= fragCoord.xy * resRcp - vec2( 0., screenSize.y );\n    vec2 centerFlt\t= fragCoord.xy * resRcp - screenSize / 2.;\n    vec2 worldFlt\t= fragCoord.xy * resRcp - vec2( 0., 16. ) + camera;\n    float fog\t\t= texture( iChannel1, ( tile + worldMod16 / 16. ) / iChannelResolution[ 0 ].xy ).w;\n    float tick2     = s.tick > TICK_NUM / 2. ? 1. : 0.;\n    \n    vec3 color = texelFetch( iChannel2, ivec2( fragCoord ), 0 ).xyz;\n    \n    color *= fog;    \n    float light = length( playerPos + 8. - world );\n\tcolor *= vec3( Smooth( ( 4. * 16. - light ) * .05 ) * .8 + .2 );\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        float maxHP = EnemyHP( s.enemyId[ i ] );\n\t\tvec2 enemy = world - s.enemyPos[ i ] * 16. + FrameOffset( s.enemyFrame[ i ], s.tick );        \n        if ( s.enemyPos[ i ].x > 0.\n             && s.enemyHP[ i ] < maxHP\n             && enemy.x >= 0. && enemy.x < 16. && enemy.y - 16. >= 0. && enemy.y - 16. < 2. )\n        {\n            color = enemy.x < 16. * s.enemyHP[ i ] / maxHP ? vec3( 0., 1., 0. ) : vec3( 1., 0., 0. );\n        }\n    }\n    \n\tif ( pixel.x >= screenSize.x - 8. - 16. * s.keyNum && pixel.x < screenSize.x - 8. )\n    {\n        SpriteKey( color, vec2( mod( pixel.x - 8., 16. ), pixel.y - screenSize.y + 24. ) );\n    }\n    \n    if ( pixel.y >= screenSize.y - 9. && pixel.x < 4. * MaxHP( s.level ) + 7. + pixel.y - screenSize.y )\n    {\n       \tcolor = vec3( .33, .35, .31 );\n    }\n    if ( pixel.y >= screenSize.y - 8. && pixel.x < 4. * MaxHP( s.level ) + 6. + pixel.y - screenSize.y )\n    {\n       \tcolor = vec3( .64, .65, .58 );\n    }\n    if ( pixel.y >= screenSize.y - 7. && pixel.x < 4. * MaxHP( s.level ) + 5. + pixel.y - screenSize.y )\n    {\n       \tcolor = vec3( .24, .25, .22 );\n    }    \n    if ( pixel.y >= screenSize.y - 3. )\n    {\n  \t\tcolor = vec3( .33, .35, .31 );\n    }\n    if ( pixel.y >= screenSize.y - 2. )\n    {\n  \t\tcolor = vec3( .48, .5, .45 );\n    }    \n    if ( pixel.y >= screenSize.y - 1. )\n    {\n        color = vec3( .24, .25, .22 );\n    }\n    \n    float rect = floor( Rectangle( pixel - vec2( 6., screenSize.y - 16. ), vec2( 5. ) ) );\n    color = rect == 0. ? vec3( .64, .65, .58 ) : color;\n    color = rect == 1. ? vec3( .33, .35, .31 ) : color;\n    color = rect <  0. ? vec3( .24, .25, .22 ) : color;\n    \n    float xpBar = s.xp / MaxXP( s.level );\n    if ( pixel.y >= screenSize.y - 1. && pixel.x < screenSize.x * xpBar )\n    {\n        color = mix( vec3( 1., .8, .4 ), vec3( 1. ), pixel.x / screenSize.x );\n    } \n    \n    if ( pixel.y >= screenSize.y - 7. && pixel.y < screenSize.y - 3. && pixel.x < 4. * s.hp + 5. + pixel.y - screenSize.y )\n    {\n       color = mix( vec3( .65, .22, .29 ), vec3( .9, .4, .36 ), ( pixel.y - screenSize.y + 5. ) / 3. );\n    }\n    \n    if ( pixel.x == 0. && pixel.y >= screenSize.y - 9. && pixel.y < screenSize.y - 2. )\n    {\n       \tcolor = vec3( .33, .35, .31 );\n    }\n    \n    DrawText( color, edgeFlt, centerFlt, worldFlt, s );\n    \n\tfragColor = vec4( color, 1. );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// gameplay loop\n\n//#define EASY_MODE\n//#define KEY_AUTOREPEAT\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_FOOD\t\t\t= 2.;\nconst float ITEM_POTION\t\t\t= 3.;\nconst float ITEM_SPAWNER\t\t= 4.;\nconst float ITEM_SPAWNER_2\t\t= 5.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst float KEY_LEFT  \t\t\t= 37.5f / 256.0f;\nconst float KEY_UP    \t\t\t= 38.5f / 256.0f;\nconst float KEY_RIGHT \t\t\t= 39.5f / 256.0f;\nconst float KEY_DOWN  \t\t\t= 40.5f / 256.0f;\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    // 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t// 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    // 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    // 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    // 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) / 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nvoid StoreValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nvec4 SaveState( in GameState s, in vec2 fragCoord, bool reset )\n{\n    vec4 ret = vec4( 0. );\n    StoreValue( vec2( 0., 0. ), vec4( s.tick, PackXY( s.hp, s.level ), s.xp, s.keyNum ), ret, fragCoord );\n    StoreValue( vec2( 1., 0. ), vec4( PackXY( s.playerPos ), PackXY( s.playerFrame, s.playerDir ), PackXY( s.bodyPos ), s.bodyId ), ret, fragCoord );\n    StoreValue( vec2( 2., 0. ), vec4( PackXY( s.state, s.keyLock ), s.stateTime, PackXY( s.despawnPos ), s.despawnId ), ret, fragCoord );\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        StoreValue( vec2( 3., float( i ) ), \n                   vec4( PackXY( s.enemyPos[ i ] ), \n                         PackXY( s.enemyFrame[ i ], s.enemyDir[ i ] ), \n                         PackXY( s.enemyHP[ i ], s.enemyId[ i ] ),\n                         PackXY( s.enemySpawnPos[ i ] ) ), ret, fragCoord );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n        StoreValue( vec2( 4., float( i ) ), vec4( s.logPos[ i ], s.logLife[ i ], PackXY( s.logId[ i ], s.logVal[ i ] ) ), ret, fragCoord );\n    }\n\n\tif ( reset )    \n    {\n        ret = vec4( 0. );\n\t\tStoreValue( vec2( 0., 0. ), vec4( 0., 21., 0., 0. ), ret, fragCoord );        \n        StoreValue( vec2( 1., 0. ), vec4( PackXY( 3., 2. ), 0., 0., 0. ), ret, fragCoord );\n        StoreValue( vec2( 2., 0. ), vec4( s.state, 0., 0., 0. ), ret, fragCoord );\n    }\n    \n    return ret;\n}\n\nvoid LogDmg( inout GameState s, vec2 pos, float val )\n{\n    float maxLife = -1.;\n    if ( s.logPos[ 2 ].x > 0. && s.logPos[ 3 ].x > 0. )\n    {\n        maxLife = max( s.logLife[ 2 ], s.logLife[ 3 ] );\n    }\n    \n    for ( int i = 2; i < LOG_NUM; ++i )\n    {\n        if ( s.logPos[ i ].x <= 0. || maxLife == s.logLife[ i ] )\n        {\n            s.logPos[ i ]  = pos;\n            s.logLife[ i ] = 0.;\n            s.logId[ i ]   = 0.;\n            s.logVal[ i ]  = val;            \n            break;\n        }\n    }   \n}\n\nvoid LogXP( inout GameState s, vec2 pos, float val )\n{\n    s.logPos[ 0 ]  = pos;\n    s.logLife[ 0 ] = 0.;\n    s.logId[ 0 ]   = 0.;\n\ts.logVal[ 0 ]  = val;\n}\n\nvoid LogHeal( inout GameState s, vec2 pos, float val )\n{\n    s.logPos[ 1 ]  = pos;\n    s.logLife[ 1 ] = 0.;\n    s.logId[ 1 ]   = 0.;\n\ts.logVal[ 1 ]  = val;\n}\n\nvoid LogLevelUp( inout GameState s, vec2 pos )\n{\n    s.logPos[ 0 ]  = pos;\n    s.logLife[ 0 ] = 0.;\n    s.logId[ 0 ]   = 1.;\n}\n\nfloat Rand( vec2 n )\n{\n\treturn fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat MaxXP( float level )\n{\n\treturn 10. + level * 5.;\t   \n}\n\nfloat MaxHP( float level )\n{\n\treturn 21. + level * 3.;\t   \n}\n\nfloat EnemyDmg( float id )\n{    \n    float dmg = 1. + 2. * id + floor( ( 4. + 2. * id ) * Rand( vec2( iTime, iTime ) ) );\n#ifdef EASY_MODE\n    dmg = floor( dmg * .5 );\n#endif\n    return dmg;\n}\n\nfloat EnemyHP( float id )\n{\n    return 8. + id * 15.;\n}\n\nfloat EnemyXP( float id )\n{\n    return 3. + id * 5.;\n}\n\nfloat TrapDmg( bool player )\n{\n    float dmg = 10. + floor( 8. * Rand( vec2( iTime, iTime ) ) );\n#ifdef EASY_MODE\n    if ( player )\n    \tdmg = floor( dmg * .5 );\n#endif    \n    return dmg;\n}\n\nfloat PlayerDmg( inout GameState s )\n{\n    return s.level + 1. + floor( 4. * Rand( vec2( iTime + 11.1, iTime + 11.1 ) ) );\n}\n\nvoid UpdateEnemies( inout GameState s )\n{\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n    \tif ( s.tick == 0. )\n    \t{\n            s.enemyFrame[ i ] = 0.;\n        }\n        \n       \tif ( s.enemyPos[ i ].x > 0. && s.enemyHP[ i ] <= 0. )\n        {\n            float xp = EnemyXP( s.enemyId[ i ] );\n            s.xp += xp;\n            s.bodyPos = s.enemyPos[ i ];\n            s.bodyId  = s.enemyId[ i ] + 1.;\n            s.enemyPos[ i ] = vec2( 0., 0. );\n            LogXP( s, s.playerPos, xp );\n        }        \n\n        vec4 map = texelFetch( iChannel1, ivec2( s.enemyPos[ i ] ), 0 );\n        if ( map.x == TILE_TRAP && s.tick == 1. )\n        {\n            float dmg = TrapDmg( false );\n            s.enemyHP[ i ] -= dmg;\n            LogDmg( s, s.enemyPos[ i ], dmg );\n        }        \n        \n        vec2 move = vec2( 0., 0. );\n    \tvec2 toPlayer = s.playerPos - s.enemyPos[ i ];\n        vec2 moveX = vec2( sign( toPlayer.x ), 0. );\n        vec2 moveY = vec2( 0., sign( toPlayer.y ) );\n        vec4 mapX  = texelFetch( iChannel1, ivec2( s.enemyPos[ i ] + moveX ), 0 );\n        vec4 mapY  = texelFetch( iChannel1, ivec2( s.enemyPos[ i ] + moveY ), 0 );\n        \n        if ( mapX.x >= TILE_WALL )\n        {\n            moveX = vec2( 0. );\n        }\n\n        if ( mapY.x >= TILE_WALL )\n        {\n            moveY = vec2( 0. );\n        }             \n        \n        for ( int j = 0; j < ENEMY_NUM; ++j )\n        {\n            if ( j != i && s.enemyPos[ j ] == s.enemyPos[ i ] + moveX )\n            {\n                moveX = vec2( 0. );\n            }\n            if ( j != i && s.enemyPos[ j ] == s.enemyPos[ i ] + moveY )\n            {\n                moveY = vec2( 0. );\n            }\n        }\n\n        move = moveX.x != 0. ? moveX : moveY;\n        if ( moveX.x != 0. && moveY.y != 0. )\n        {\n            move = abs( toPlayer.x ) > abs( toPlayer.y ) ? moveX : moveY;\n        }\n        \n        if ( s.tick == TICK_NUM )\n        {\n        \tif ( s.enemyPos[ i ] + move == s.playerPos )\n            {\n                float dmg = EnemyDmg( s.enemyId[ i ] );\n                s.hp -= dmg;\n                s.enemyFrame[ i ] = 5.;\n                LogDmg( s, s.playerPos, dmg );\n            }\n\t\t\telse\n            {\n\t\t\t\ts.enemyPos[ i ] += move;\n                s.enemyFrame[ i ] = move.x == 1. ? 1. : ( move.x == -1. ? 2. : ( move.y == 1. ? 3. : ( move.y == -1. ? 4. : 0. ) ) );\n                s.enemyDir[ i ] = move.x > 0. ? 0. : ( move.x < 0. ? 1. : s.enemyDir[ i ] );\n            }\n        }\n    }    \n}\n\nvoid CheckSpawnPos( inout vec2 spawnPos, inout float spawnId, vec2 tile )\n{\n\tvec4 map = texelFetch( iChannel1, ivec2( tile ), 0 );\n    if ( map.y == ITEM_SPAWNER || map.y == ITEM_SPAWNER_2 )\n    {\n        spawnPos = tile;\n        spawnId  = map.y == ITEM_SPAWNER ? 0. : 1.;\n    } \n}\n\nvoid SpawnEnemies( inout GameState s, vec2 playerMove )\n{    \n    // despawn out of range\n    s.despawnPos = vec2( 0. );\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        if ( s.tick == 1. && s.enemyPos[ i ].x > 0. && length( s.playerPos - s.enemyPos[ i ] ) > 5. )\n        {\n            s.despawnPos    = s.enemySpawnPos[ i ];\n            s.despawnId     = s.enemyId[ i ];\n            s.enemyPos[ i ] = vec2( 0. );\n            break;\n        }\n    }    \n    \n    vec2 spawnPos = vec2( 0., 0. );\n    float spawnId = 0.;\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 4. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 3. - playerMove.yx * 1. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 3. + playerMove.yx * 1. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 2. - playerMove.yx * 2. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 2. + playerMove.yx * 2. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 1. - playerMove.yx * 3. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 1. + playerMove.yx * 3. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 0. - playerMove.yx * 4. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 0. + playerMove.yx * 4. );    \n    \n    if ( spawnPos.x > 0. )\n    {\n        for ( int i = 0; i < ENEMY_NUM; ++i )\n        {        \n            if ( s.enemyPos[ i ].x <= 0. )\n            {\n                s.enemyId[ i ]       = spawnId;\n                s.enemyPos[ i ]      = spawnPos;\n                s.enemyHP[ i ]       = EnemyHP( spawnId );\n                s.enemySpawnPos[ i ] = spawnPos;\n                break;\n            }\n        }    \n    }\n}\n\nvoid UpdateLog( inout GameState s )\n{\n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n        s.logLife[ i ] += iTimeDelta;\n        if ( s.logLife[ i ] > 1. )\n        {\n            s.logPos[ i ] = vec2( 0. );\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // don't compute gameplay outside of the data area\n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {\n\t\tdiscard;    \n    }\n\n    // keys\n    bool keyLeft  \t= texture( iChannel2, vec2( KEY_LEFT, .25 ) ).x > .5;\n    bool keyRight \t= texture( iChannel2, vec2( KEY_RIGHT, .25 ) ).x > .5;\n    bool keyUp  \t= texture( iChannel2, vec2( KEY_UP, .25 ) ).x > .5;\n    bool keyDown \t= texture( iChannel2, vec2( KEY_DOWN, .25 ) ).x > .5;    \n    \n    GameState s;\n    LoadState( s );\n    \n    s.tick = max( floor( s.tick - 1. ), 0. );    \n    \n    bool reset = false;\n    if ( iFrame < 1 || s.state == STATE_START )\n    {\n        reset   = true;\n        s.state = STATE_GAME;\n    }\n    else if ( s.state == STATE_GAME )\n    {\n        if ( s.hp <= 0. )\n        {\n            s.state \t= STATE_GAME_OVER;\n\t\t\ts.stateTime = 0.;\n        }\n    }\n    else if ( s.state == STATE_NEXT_LEVEL )\n    {\n        s.state = STATE_GAME;\n        s.playerPos = vec2( 3., 2. );\n    \tfor ( int i = 0; i < ENEMY_NUM; ++i )\n    \t{           \n            s.enemyPos[ i ] = vec2( 0. );\n    \t}\n    }\n    else if ( s.state == STATE_GAME_OVER )\n    {\n        s.stateTime += .33 * iTimeDelta;\n        if ( s.stateTime >= 1. )\n        {\n            s.state = STATE_START;\n        }\n    }\n\n    \n    // level up\n    if ( s.xp >= MaxXP( s.level ) )\n    {\n        s.xp -= MaxXP( s.level );\n        s.level = min( s.level + 1., 9. );\n        s.hp\t= MaxHP( s.level );\n        LogLevelUp( s, s.playerPos );\n    }\n    \n    \n#ifdef KEY_AUTOREPEAT    \n    s.keyLock = 0.;\n#else\n    s.keyLock = keyLeft || keyRight || keyDown || keyUp ? s.keyLock : 0.;    \n#endif\n\n    vec2 move = vec2( 0., 0. );\n    if ( s.state == STATE_GAME && s.tick == 0. && s.keyLock == 0. )\n    {\n        s.playerFrame = 0.;\n        if ( keyLeft )\n        {\n            move.x = -1.;\n            s.playerDir = 1.;\n        }   \n        else if ( keyRight )\n        {\n            move.x = 1.;\n            s.playerDir = 0.;\n        }   \n        else if ( keyDown )\n        {\n            move.y = -1.;\n        }\n        else if ( keyUp )\n        {\n            move.y = 1.;\n        }             \n    }\n  \n    vec4 map = texelFetch( iChannel1, ivec2( s.playerPos + move ), 0 );\n    if ( abs( move.x + move.y ) > 0. && map.x < TILE_WALL )\n    {\n        bool enemy = false;\n        for ( int i = 0; i < ENEMY_NUM; ++i )\n        {\n            if ( s.enemyPos[ i ] == s.playerPos + move )        \n            {\n                float dmg = PlayerDmg( s );\n                s.playerFrame = 6.;\n                s.enemyHP[ i ] -= dmg;\n                LogDmg( s, s.enemyPos[ i ], dmg );\n            }\n        }\n        \n        if ( s.playerFrame != 6. )\n        {\n    \t\ts.playerPos += move;\n            s.playerFrame = keyLeft ? 1. : ( keyRight ? 2. : ( keyDown ? 3. : 4. ) );\n        \n        \tif ( map.y == ITEM_KEY )\n        \t{\n            \ts.keyNum += 1.;\n        \t}        \n            \n        \tif ( map.y == ITEM_FOOD || map.y == ITEM_POTION )\n        \t{\n                float heal = map.y == ITEM_FOOD ? 5. : 50.;\n                heal = min( heal, MaxHP( s.level ) - s.hp );\n            \ts.hp += heal;\n                LogHeal( s, s.playerPos, heal );\n        \t}      \n            \n            if ( map.x == TILE_TRAP )\n            {\n                float dmg = TrapDmg( true );\n                s.hp -= dmg;\n                LogDmg( s, s.playerPos, dmg );\n            }  \n        }\n        \n        s.tick    = TICK_NUM;\n        s.keyLock = 1.;\n    }\n    else if ( map.x == TILE_DOOR_LOCKED && s.keyNum > 0. )\n    {\n        s.playerFrame = keyLeft ? 1. : ( keyRight ? 2. : ( keyDown ? 3. : 4. ) );\n        s.keyNum -= 1.;\n        s.playerPos += move;\n        s.tick    = TICK_NUM;\n        s.keyLock = 1.;\n    }\n    else if ( map.x >= TILE_WALL )\n    {\n     \t// wait\n        s.playerFrame = 5.;\n        s.tick        = TICK_NUM;\n        s.keyLock     = 1.;\n    }    \n\n    UpdateEnemies( s );\n    SpawnEnemies( s, move ); \n\tUpdateLog( s );\n    \n\t// next level\n    if ( map.x == TILE_STAIRS_DOWN )\n    {     \n        s.state = STATE_NEXT_LEVEL;\n    }\n    \n    fragColor = SaveState( s, fragCoord, reset );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// map\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_FOOD\t\t\t= 2.;\nconst float ITEM_POTION\t\t\t= 3.;\nconst float ITEM_SPAWNER\t\t= 4.;\nconst float ITEM_SPAWNER_2\t\t= 5.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    // 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t// 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    // 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    // 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    // 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) / 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nvec4 Map( vec2 p )\n{\n    int v = 0;\n\tv = p.y == 31. ? ( p.x < 8. ? 842150450 : ( p.x < 16. ? 573710370 : ( p.x < 24. ? 8754 : 589443584 ) ) ) : v;\n\tv = p.y == 30. ? ( p.x < 8. ? 286331154 : ( p.x < 16. ? 286335521 : ( p.x < 24. ? 589308177 : 554766882 ) ) ) : v;\n\tv = p.y == 29. ? ( p.x < 8. ? 286331154 : ( p.x < 16. ? 572592401 : ( p.x < 24. ? 287318289 : 554766609 ) ) ) : v;\n\tv = p.y == 28. ? ( p.x < 8. ? 572662306 : ( p.x < 16. ? 539042338 : ( p.x < 24. ? 555753745 : 554766882 ) ) ) : v;\n\tv = p.y == 27. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 590422016 : ( p.x < 24. ? 555754002 : 572662272 ) ) ) : v;\n\tv = p.y == 26. ? ( p.x < 8. ? 589505314 : ( p.x < 16. ? 554770432 : ( p.x < 24. ? 555745810 : 0 ) ) ) : v;\n\tv = p.y == 25. ? ( p.x < 8. ? 554766610 : ( p.x < 16. ? 554770432 : ( p.x < 24. ? 555889170 : 589443634 ) ) ) : v;\n\tv = p.y == 24. ? ( p.x < 8. ? 554766610 : ( p.x < 16. ? 286334976 : ( p.x < 24. ? 286331153 : 554766609 ) ) ) : v;\n\tv = p.y == 23. ? ( p.x < 8. ? 555884834 : ( p.x < 16. ? 554770995 : ( p.x < 24. ? 555885073 : 554836514 ) ) ) : v;\n\tv = p.y == 22. ? ( p.x < 8. ? 287318304 : ( p.x < 16. ? 554770705 : ( p.x < 24. ? 555889169 : 554827776 ) ) ) : v;\n\tv = p.y == 21. ? ( p.x < 8. ? 572530976 : ( p.x < 16. ? 286335266 : ( p.x < 24. ? 555946257 : 555885106 ) ) ) : v;\n\tv = p.y == 20. ? ( p.x < 8. ? 143666 : ( p.x < 16. ? 572727584 : ( p.x < 24. ? 286331425 : 554832145 ) ) ) : v;\n\tv = p.y == 19. ? ( p.x < 8. ? 135442 : ( p.x < 16. ? 539037984 : ( p.x < 24. ? 571613713 : 554766882 ) ) ) : v;\n\tv = p.y == 18. ? ( p.x < 8. ? 135442 : ( p.x < 16. ? 539042336 : ( p.x < 24. ? 34734609 : 554832384 ) ) ) : v;\n\tv = p.y == 17. ? ( p.x < 8. ? 570560786 : ( p.x < 16. ? 539042355 : ( p.x < 24. ? 856896017 : 572662274 ) ) ) : v;\n\tv = p.y == 16. ? ( p.x < 8. ? 305279266 : ( p.x < 16. ? 539042065 : ( p.x < 24. ? 286331409 : 2 ) ) ) : v;\n\tv = p.y == 15. ? ( p.x < 8. ? 286331168 : ( p.x < 16. ? 857809169 : ( p.x < 24. ? 286331427 : 143922 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 8. ? 304226592 : ( p.x < 16. ? 286331153 : ( p.x < 24. ? 286331153 : 590483729 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 570433824 : ( p.x < 16. ? 572596770 : ( p.x < 24. ? 286331426 : 554832418 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 8480 : ( p.x < 16. ? 287383552 : ( p.x < 24. ? 286331394 : 554832386 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 840966450 : ( p.x < 16. ? 287383586 : ( p.x < 24. ? 571613698 : 554766850 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 287318290 : ( p.x < 16. ? 286335009 : ( p.x < 24. ? 34734082 : 572658176 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 287318290 : ( p.x < 16. ? 572596257 : ( p.x < 24. ? 34746882 : 135680 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 304095506 : ( p.x < 16. ? 2171682 : ( p.x < 24. ? 571544064 : 36835891 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 301998354 : ( p.x < 16. ? 2167057 : ( p.x < 24. ? 286331392 : 34672913 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 570434082 : ( p.x < 16. ? 2171426 : ( p.x < 24. ? 304226816 : 34742818 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 2170880 : ( p.x < 24. ? 301989888 : 34738450 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 36844082 : ( p.x < 16. ? 36778496 : ( p.x < 24. ? 302134048 : 34672914 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 571543826 : ( p.x < 16. ? 571544099 : ( p.x < 24. ? 302125346 : 34738449 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 286331154 : ( p.x < 16. ? 286331153 : ( p.x < 24. ? 302125329 : 34746930 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 571543826 : ( p.x < 16. ? 571544098 : ( p.x < 24. ? 302125346 : 34672913 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 35791394 : ( p.x < 16. ? 35791360 : ( p.x < 24. ? 570565152 : 35791394 ) ) ) : v;\n    float t = float( ( v >> int( 4. * p.x ) ) & 15 );\n    t = t == 2. ? 6. : t;\n    t = t == 3. ? 7. : t;\n    t = p.x == 15. && p.y == 30. ? 2. : t;\n    t = p.x == 9. && p.y == 29. ? 2. : t;\n    t = p.x == 11. && p.y == 29. ? 2. : t;\n    t = p.x == 12. && p.y == 27. ? 2. : t;\n    t = p.x == 17. && p.y == 27. ? 2. : t;\n    t = p.x == 17. && p.y == 25. ? 2. : t;\n    t = p.x == 15. && p.y == 24. ? 2. : t;\n    t = p.x == 18. && p.y == 24. ? 2. : t;\n    t = p.x == 21. && p.y == 24. ? 2. : t;\n    t = p.x == 23. && p.y == 24. ? 2. : t;\n    t = p.x == 28. && p.y == 24. ? 2. : t;\n    t = p.x == 2. && p.y == 23. ? 2. : t;\n    t = p.x == 6. && p.y == 23. ? 2. : t;\n    t = p.x == 15. && p.y == 21. ? 2. : t;\n    t = p.x == 18. && p.y == 21. ? 2. : t;\n    t = p.x == 30. && p.y == 21. ? 2. : t;\n    t = p.x == 16. && p.y == 20. ? 2. : t;\n    t = p.x == 23. && p.y == 20. ? 2. : t;\n    t = p.x == 11. && p.y == 19. ? 2. : t;\n    t = p.x == 21. && p.y == 19. ? 2. : t;\n    t = p.x == 28. && p.y == 19. ? 2. : t;\n    t = p.x == 2. && p.y == 16. ? 2. : t;\n    t = p.x == 6. && p.y == 15. ? 2. : t;\n    t = p.x == 12. && p.y == 15. ? 2. : t;\n    t = p.x == 11. && p.y == 14. ? 2. : t;\n    t = p.x == 24. && p.y == 14. ? 2. : t;\n    t = p.x == 2. && p.y == 11. ? 2. : t;\n    t = p.x == 21. && p.y == 11. ? 2. : t;\n    t = p.x == 28. && p.y == 11. ? 2. : t;\n    t = p.x == 13. && p.y == 10. ? 2. : t;\n    t = p.x == 21. && p.y == 9. ? 2. : t;\n    t = p.x == 7. && p.y == 8. ? 2. : t;\n    t = p.x == 27. && p.y == 8. ? 2. : t;\n    t = p.x == 22. && p.y == 7. ? 2. : t;\n    t = p.x == 28. && p.y == 4. ? 2. : t;\n    t = p.x == 24. && p.y == 3. ? 2. : t;\n    t = p.x == 10. && p.y == 2. ? 2. : t;\n    t = p.x == 14. && p.y == 2. ? 2. : t;\n    t = p.x == 17. && p.y == 2. ? 2. : t;\n    t = p.x == 26. && p.y == 29. ? 8. : t;\n    t = p.x == 22. && p.y == 25. ? 8. : t;\n    t = p.x == 21. && p.y == 17. ? 8. : t;\n    t = p.x == 13. && p.y == 14. ? 8. : t;\n    t = p.x == 18. && p.y == 14. ? 8. : t;\n    t = p.x == 12. && p.y == 4. ? 8. : t;\n    t = p.x == 6. && p.y == 2. ? 8. : t;\n    t = p.x == 17. && p.y == 29. ? 4. : t;\n    t = p.x == 4. && p.y == 24. ? 4. : t;\n    t = p.x == 16. && p.y == 23. ? 4. : t;\n    t = p.x == 29. && p.y == 23. ? 4. : t;\n    t = p.x == 2. && p.y == 18. ? 4. : t;\n    t = p.x == 17. && p.y == 17. ? 4. : t;\n    t = p.x == 8. && p.y == 15. ? 4. : t;\n    t = p.x == 9. && p.y == 15. ? 4. : t;\n    t = p.x == 21. && p.y == 15. ? 4. : t;\n    t = p.x == 20. && p.y == 14. ? 4. : t;\n    t = p.x == 22. && p.y == 14. ? 4. : t;\n    t = p.x == 21. && p.y == 13. ? 4. : t;\n    t = p.x == 29. && p.y == 12. ? 4. : t;\n    t = p.x == 14. && p.y == 11. ? 4. : t;\n    t = p.x == 26. && p.y == 4. ? 4. : t;\n    t = p.x == 12. && p.y == 2. ? 4. : t;\n    t = p.x == 2. && p.y == 2. ? 9. : t;\n    t = p.x == 29. && p.y == 29. ? 3. : t;\n    float i = 0.;\n    i = p.x == 1. && p.y == 30. ? 1. : i;\n    i = p.x == 1. && p.y == 24. ? 1. : i;\n    i = p.x == 17. && p.y == 16. ? 1. : i;\n    i = p.x == 1. && p.y == 7. ? 1. : i;\n    i = p.x == 25. && p.y == 5. ? 1. : i;\n    i = p.x == 1. && p.y == 3. ? 1. : i;\n    i = p.x == 19. && p.y == 3. ? 1. : i;\n    i = p.x == 8. && p.y == 30. ? 2. : i;\n    i = p.x == 18. && p.y == 30. ? 2. : i;\n    i = p.x == 27. && p.y == 28. ? 2. : i;\n    i = p.x == 13. && p.y == 26. ? 2. : i;\n    i = p.x == 14. && p.y == 26. ? 2. : i;\n    i = p.x == 6. && p.y == 25. ? 2. : i;\n    i = p.x == 13. && p.y == 25. ? 2. : i;\n    i = p.x == 14. && p.y == 25. ? 2. : i;\n    i = p.x == 10. && p.y == 22. ? 2. : i;\n    i = p.x == 19. && p.y == 21. ? 2. : i;\n    i = p.x == 3. && p.y == 19. ? 2. : i;\n    i = p.x == 17. && p.y == 19. ? 2. : i;\n    i = p.x == 30. && p.y == 18. ? 2. : i;\n    i = p.x == 10. && p.y == 16. ? 2. : i;\n    i = p.x == 23. && p.y == 16. ? 2. : i;\n    i = p.x == 27. && p.y == 14. ? 2. : i;\n    i = p.x == 14. && p.y == 12. ? 2. : i;\n    i = p.x == 19. && p.y == 12. ? 2. : i;\n    i = p.x == 23. && p.y == 12. ? 2. : i;\n    i = p.x == 1. && p.y == 10. ? 2. : i;\n    i = p.x == 11. && p.y == 3. ? 2. : i;\n    i = p.x == 13. && p.y == 3. ? 2. : i;\n    i = p.x == 27. && p.y == 3. ? 2. : i;\n    i = p.x == 23. && p.y == 1. ? 2. : i;\n    i = p.x == 1. && p.y == 29. ? 3. : i;\n    i = p.x == 8. && p.y == 10. ? 3. : i;\n    i = p.x == 19. && p.y == 7. ? 3. : i;\n    i = p.x == 3. && p.y == 30. ? 4. : i;\n    i = p.x == 12. && p.y == 30. ? 4. : i;\n    i = p.x == 2. && p.y == 25. ? 4. : i;\n    i = p.x == 20. && p.y == 24. ? 4. : i;\n    i = p.x == 22. && p.y == 24. ? 4. : i;\n    i = p.x == 6. && p.y == 22. ? 4. : i;\n    i = p.x == 12. && p.y == 21. ? 4. : i;\n    i = p.x == 19. && p.y == 20. ? 4. : i;\n    i = p.x == 27. && p.y == 20. ? 4. : i;\n    i = p.x == 12. && p.y == 19. ? 4. : i;\n    i = p.x == 1. && p.y == 17. ? 4. : i;\n    i = p.x == 19. && p.y == 16. ? 4. : i;\n    i = p.x == 17. && p.y == 14. ? 4. : i;\n    i = p.x == 15. && p.y == 10. ? 4. : i;\n    i = p.x == 12. && p.y == 9. ? 4. : i;\n    i = p.x == 7. && p.y == 7. ? 4. : i;\n    i = p.x == 20. && p.y == 7. ? 4. : i;\n    i = p.x == 9. && p.y == 2. ? 4. : i;\n    i = p.x == 19. && p.y == 2. ? 4. : i;\n    i = p.x == 10. && p.y == 29. ? 5. : i;\n    i = p.x == 22. && p.y == 29. ? 5. : i;\n    i = p.x == 25. && p.y == 29. ? 5. : i;\n    i = p.x == 13. && p.y == 24. ? 5. : i;\n    i = p.x == 30. && p.y == 24. ? 5. : i;\n    i = p.x == 16. && p.y == 16. ? 5. : i;\n    i = p.x == 30. && p.y == 11. ? 5. : i;\n    i = p.x == 6. && p.y == 10. ? 5. : i;\n    i = p.x == 1. && p.y == 8. ? 5. : i;\n    i = p.x == 21. && p.y == 7. ? 5. : i;\n    i = p.x == 26. && p.y == 5. ? 5. : i;\n    return p.x < 0. || p.y < 0. || p.x > 31. || p.y > 31. ? vec4( 0. ) : vec4( t, i, 0., 0. );\n}\n\nfloat Rand( vec2 n )\n{\n\treturn fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // don't compute map outside of map area\n    if ( fragCoord.x >= 40. || fragCoord.y >= 40. ) \n    {\n\t\tdiscard;    \n    }    \n    \n    vec2 tile = floor( fragCoord );\n    \n    vec4 map = texelFetch( iChannel1, ivec2( tile ), 0 );\n    \n    GameState s;\n    LoadState( s );    \n    \n    // create map\n\tif ( s.state == STATE_START || s.state == STATE_NEXT_LEVEL || iFrame < 1 )\n    {\n        map = Map( tile );\n    }   \n    \n    if ( tile == s.playerPos )\n    {\n     \tif ( s.tick == 1. && ( map.y == ITEM_KEY || map.y == ITEM_FOOD || map.y == ITEM_POTION ) )\n        {\n            // pickup item\n\t\t\tmap.y = 0.;\n        }\n     \tif ( map.x == TILE_DOOR_LOCKED && s.tick == TICK_NUM )\n        {\n\t\t\tmap.x = TILE_DOOR_OPEN;\n        }    \n     \tif ( map.x == TILE_TRAP && s.tick == 1. )\n        {\n\t\t\tmap.x = TILE_TRAP_OFF;\n        }           \n    }\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        if ( tile == s.enemyPos[ i ] && map.x == TILE_TRAP && s.tick == 1. )\n        {\n            map.x = TILE_TRAP_OFF;\n        }\n    }\n    \n    if ( tile == s.bodyPos && map.x == TILE_TRAP )\n    {\n\t\tmap.x = TILE_TRAP_OFF;\n    }\n    \n    // fog of war\n    if ( s.state == STATE_GAME && length( s.playerPos - tile ) < 5. )\n    {    \n        map.w = 1.;\n    }\n    \n    if ( s.state == STATE_GAME && tile == s.bodyPos )\n    {\n        map.z = s.bodyId;\n    }\n\n    if ( tile == s.playerPos && s.hp <= 0. )\n    {\n        map.z = 2.;\n    }\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        if ( s.state == STATE_GAME && s.enemyPos[ i ].x > 0. && tile == s.enemySpawnPos[ i ] )\n        {\n            map.y = 0.;\n        }\n    }\n    \n    if ( s.state == STATE_GAME && s.despawnPos.x > 0. && tile == s.despawnPos )\n    {\n        map.y = s.despawnId > 0. ? ITEM_SPAWNER_2 : ITEM_SPAWNER;\n    }\n\n \tfragColor = map;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// background\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_FOOD\t\t\t= 2.;\nconst float ITEM_POTION\t\t\t= 3.;\nconst float ITEM_SPAWNER\t\t= 3.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst vec2  REF_RES\t            = vec2( 200. );\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    // 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t// 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    // 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    // 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    // 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) / 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid SpriteEarth( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 8. ? 17961233 : ( p.x < 16. ? 536941073 : 0 ) ) : v;\n\tv = p.y == 14. ? ( p.x < 8. ? 18944274 : ( p.x < 16. ? 269549841 : 0 ) ) : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 269553937 : ( p.x < 16. ? 554766353 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 1118481 : ( p.x < 16. ? 572662032 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 554766609 : ( p.x < 16. ? 555815424 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 572662049 : ( p.x < 16. ? 286261777 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 16781602 : ( p.x < 16. ? 268440097 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 4385 : ( p.x < 16. ? 536875298 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 303108641 : ( p.x < 16. ? 286265617 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 35790865 : ( p.x < 16. ? 304152593 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 16843025 : ( p.x < 16. ? 286327056 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 16781841 : ( p.x < 16. ? 286261521 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 285352193 : ( p.x < 16. ? 287310081 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 70162 : ( p.x < 16. ? 269484049 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 4625 : ( p.x < 16. ? 269488417 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 529 : ( p.x < 16. ? 268505361 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = vec3( 0.16, 0.14, 0.14 );\n    color = i == 1. ? vec3( 0.17, 0.16, 0.15 ) : color;\n    color = i == 2. ? vec3( 0.19, 0.17, 0.16 ) : color;\n}\n\nvoid SpriteEarth2( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 13. ? 0 : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 8960 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 69920 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 16 : 0 ) : v;\n\tv = p.y == 9. ? 0 : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 3342336 : 0 ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 35794944 : ( p.x < 16. ? 65536 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 17899520 : 0 ) : v;\n\tv = p.y == 5. ? 0 : v;\n\tv = p.y == 4. ? 0 : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 1 : 0 ) ) : v;\n\tv = p.y == 2. ? 0 : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 8192 : ( p.x < 16. ? 12288 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 70144 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.42, 0.4, 0.38 ) : color;\n    color = i == 2. ? vec3( 0.55, 0.53, 0.51 ) : color;\n    color = i == 3. ? vec3( 0.72, 0.69, 0.65 ) : color;\n}\n\nvoid SpriteWater( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 8. ? 286404882 : ( p.x < 16. ? 842142226 : 0 ) ) : v;\n\tv = p.y == 14. ? ( p.x < 8. ? 286261795 : ( p.x < 16. ? 286405169 : 0 ) ) : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 269553970 : ( p.x < 16. ? 286339873 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 17965330 : ( p.x < 16. ? 554840865 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 1179665 : ( p.x < 16. ? 322122513 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 19988481 : ( p.x < 16. ? 858923265 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 303108385 : ( p.x < 16. ? 303116817 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 273 : ( p.x < 16. ? 287449616 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 17826065 : ( p.x < 16. ? 303112464 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 285212945 : ( p.x < 16. ? 285212945 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 16777233 : ( p.x < 16. ? 553648400 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 17825793 : ( p.x < 16. ? 287375360 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 268435457 : ( p.x < 16. ? 571613184 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 268439826 : ( p.x < 16. ? 822153489 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 268439827 : ( p.x < 16. ? 805380369 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 286339345 : ( p.x < 16. ? 841158944 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = vec3( 0.21, 0.38, 0.29 );\n    color = i == 1. ? vec3( 0.24, 0.41, 0.33 ) : color;\n    color = i == 2. ? vec3( 0.27, 0.44, 0.36 ) : color;\n    color = i == 3. ? vec3( 0.3, 0.47, 0.37 ) : color;\n}\n\nvoid SpriteFloor( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 33555717 : ( p.x < 8. ? 84149251 : ( p.x < 12. ? 67371267 : 67437569 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844037 : ( p.x < 8. ? 16777216 : ( p.x < 12. ? 65793 : 50594817 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 33620997 : ( p.x < 8. ? 197893 : ( p.x < 12. ? 33752323 : 50660608 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 67109893 : ( p.x < 8. ? 328709 : ( p.x < 12. ? 67306756 : 84149504 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 83886851 : ( p.x < 8. ? 263428 : ( p.x < 12. ? 50660099 : 84214272 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 83886337 : ( p.x < 8. ? 17040644 : ( p.x < 12. ? 65537 : 16843009 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 50397957 : ( p.x < 8. ? 328965 : ( p.x < 12. ? 84215042 : 67371266 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 83952645 : ( p.x < 8. ? 17106181 : ( p.x < 12. ? 84149508 : 67436547 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 33620485 : ( p.x < 8. ? 16909317 : ( p.x < 12. ? 84214788 : 67240197 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 16842752 : ( p.x < 8. ? 257 : ( p.x < 12. ? 84149508 : 65540 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 50594305 : ( p.x < 8. ? 132101 : ( p.x < 12. ? 67372293 : 67371269 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67437825 : ( p.x < 8. ? 17040645 : ( p.x < 12. ? 50595075 : 67371010 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 67371777 : ( p.x < 8. ? 16974852 : ( p.x < 12. ? 65792 : 84213760 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 50528256 : 65537 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33620485 : ( p.x < 8. ? 67437828 : ( p.x < 12. ? 84148226 : 67437312 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 83952645 : ( p.x < 8. ? 84214532 : ( p.x < 12. ? 84148484 : 84215040 ) ) ) : v;\n    float i = float( ( v >> int( 8.0 * p.x ) ) & 255 );\n    color = vec3( 0.21, 0.2, 0.19 );\n    color = i == 1. ? vec3( 0.23, 0.23, 0.21 ) : color;\n    color = i == 2. ? vec3( 0.27, 0.27, 0.25 ) : color;\n    color = i == 3. ? vec3( 0.3, 0.29, 0.28 ) : color;\n    color = i == 4. ? vec3( 0.31, 0.31, 0.29 ) : color;\n    color = i == 5. ? vec3( 0.33, 0.32, 0.31 ) : color;\n}\n\nvoid SpriteWood( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 8. ? 17830178 : ( p.x < 16. ? 286401058 : 0 ) ) : v;\n\tv = p.y == 14. ? 0 : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 303182643 : ( p.x < 16. ? 806424850 : 0 ) ) : v;\n\tv = p.y == 12. ? 0 : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 807481906 : ( p.x < 16. ? 858993459 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 537989394 : ( p.x < 16. ? 304222738 : 0 ) ) : v;\n\tv = p.y == 9. ? 0 : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 572732211 : ( p.x < 16. ? 34677025 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 554832402 : ( p.x < 16. ? 19013905 : 0 ) ) : v;\n\tv = p.y == 6. ? 0 : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 288568115 : ( p.x < 16. ? 858993410 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 286331426 : ( p.x < 16. ? 286331137 : 0 ) ) : v;\n\tv = p.y == 3. ? 0 : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 572732208 : ( p.x < 16. ? 303174161 : 0 ) ) : v;\n\tv = p.y == 1. ? 0 : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 34677011 : ( p.x < 16. ? 858993459 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = vec3( 0.25, 0.18, 0.098 );\n    color = i == 1. ? vec3( 0.31, 0.23, 0.11 ) : color;\n    color = i == 2. ? vec3( 0.35, 0.26, 0.12 ) : color;\n    color = i == 3. ? vec3( 0.4, 0.29, 0.12 ) : color;\n}\n\nvoid SpriteWall( inout vec3 color, vec2 p )\n{    \n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 100927239 : ( p.x < 8. ? 17106437 : ( p.x < 12. ? 67372806 : 328452 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 17171974 : ( p.x < 12. ? 101123847 : 393991 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 84280838 : ( p.x < 8. ? 329222 : ( p.x < 12. ? 84281094 : 329221 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 1 : ( p.x < 8. ? 65537 : ( p.x < 12. ? 256 : 16777472 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 17105926 : ( p.x < 8. ? 117703683 : ( p.x < 12. ? 17171975 : 117901062 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 17172231 : ( p.x < 8. ? 117835526 : ( p.x < 12. ? 460295 : 117901063 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 329222 : ( p.x < 8. ? 84346629 : ( p.x < 12. ? 17106437 : 84281093 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 16842753 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16777473 : 65536 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 67372036 : ( p.x < 8. ? 101058052 : ( p.x < 12. ? 67372545 : 100664836 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117900038 : ( p.x < 8. ? 101058311 : ( p.x < 12. ? 67503872 : 100730374 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 84280839 : ( p.x < 8. ? 84215046 : ( p.x < 12. ? 84280577 : 83887366 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 65793 : ( p.x < 8. ? 16777473 : ( p.x < 12. ? 257 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 84281095 : ( p.x < 8. ? 117703424 : ( p.x < 12. ? 33818119 : 117900032 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 117835270 : ( p.x < 8. ? 117901057 : ( p.x < 12. ? 117900806 : 101122817 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 84280583 : ( p.x < 8. ? 101123328 : ( p.x < 12. ? 84215046 : 101123584 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16842753 : ( p.x < 8. ? 16842752 : ( p.x < 12. ? 16777472 : 16843008 ) ) ) : v;\n    float i = float( ( v >> int( 8.0 * p.x ) ) & 255 );\n    color = vec3( 0.33 );\n    color = i == 1. ? vec3( 0.38 ) : color;\n    color = i == 2. ? vec3( 0.5, 0.6, 0.56 ) : color;\n    color = i == 3. ? vec3( 0.55, 0.65, 0.6 ) : color;\n    color = i == 4. ? vec3( 0.61, 0.71, 0.66 ) : color;\n    color = i == 5. ? vec3( 0.67 ) : color;\n    color = i == 6. ? vec3( 0.75 ) : color;\n    color = i == 7. ? vec3( 0.85 ) : color;\n}\n\nvoid SpriteWallHole( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 100992775 : ( p.x < 8. ? 50660869 : ( p.x < 12. ? 84215558 : 33883141 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 33817606 : ( p.x < 12. ? 100992261 : 33948679 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 84280838 : ( p.x < 8. ? 117901060 : ( p.x < 12. ? 67569415 : 33883653 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 33686019 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 101058054 : 50463490 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 100926726 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 101058054 : 117900550 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 100927239 : ( p.x < 8. ? 67078 : ( p.x < 12. ? 101056768 : 117900550 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 100926982 : ( p.x < 8. ? 518 : ( p.x < 12. ? 100794368 : 84280582 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 100794883 : ( p.x < 8. ? 16777734 : ( p.x < 12. ? 100794369 : 33751558 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 100926725 : ( p.x < 8. ? 16843014 : ( p.x < 12. ? 100729089 : 100795398 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 100992006 : ( p.x < 8. ? 33620998 : ( p.x < 12. ? 100925698 : 100860934 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 100926983 : ( p.x < 8. ? 67372550 : ( p.x < 12. ? 101057540 : 84018182 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16909059 : ( p.x < 8. ? 67503622 : ( p.x < 12. ? 101057542 : 33686017 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 67372807 : ( p.x < 8. ? 67503617 : ( p.x < 12. ? 33949190 : 117900034 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 84280838 : ( p.x < 8. ? 50529026 : ( p.x < 12. ? 84083202 : 101123074 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 84280583 : ( p.x < 8. ? 50594818 : ( p.x < 12. ? 67371779 : 101123586 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 50528771 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 50463234 : 50529026 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.059, 0.059, 0.035 );\n    color = i == 1. ? vec3( 0.18, 0.19, 0.16 ) : color;\n    color = i == 2. ? vec3( 0.28, 0.29, 0.29 ) : color;\n    color = i == 3. ? vec3( 0.4, 0.44, 0.42 ) : color;\n    color = i == 4. ? vec3( 0.54, 0.58, 0.56 ) : color;\n    color = i == 5. ? vec3( 0.64, 0.69, 0.67 ) : color;\n    color = i == 6. ? vec3( 0.75 ) : color;\n    color = i == 7. ? vec3( 0.88 ) : color;\n}\n\nvoid SpriteDoorClosed( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 117769991 : ( p.x < 8. ? 50661125 : ( p.x < 12. ? 84215559 : 50660613 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844551 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50790657 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 67176199 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 50659586 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 67175171 : ( p.x < 8. ? 16843010 : ( p.x < 12. ? 33620225 : 50528514 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 16844039 : ( p.x < 8. ? 258 : ( p.x < 12. ? 33619968 : 117899522 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 258 : ( p.x < 12. ? 33619968 : 117899522 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 16843010 : ( p.x < 12. ? 33620225 : 84345090 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33620739 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33817090 : 50528514 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 33621253 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 16908802 : 100925697 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33621255 : ( p.x < 8. ? 33817090 : ( p.x < 12. ? 16909314 : 117702913 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 84148482 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16843779 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 50528514 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 117899522 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67176199 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 117899522 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 67175687 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 117899522 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16843523 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50528513 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0 );\n    color = i == 1. ? vec3( 0.19, 0.14, 0.14 ) : color;\n    color = i == 2. ? vec3( 0.4, 0.26, 0.098 ) : color;\n    color = i == 3. ? vec3( 0.35 ) : color;\n    color = i == 4. ? vec3( 0.53, 0.38, 0.19 ) : color;\n    color = i == 5. ? vec3( 0.59, 0.67, 0.64 ) : color;\n    color = i == 6. ? vec3( 0.8, 0.64, 0.49 ) : color;\n    color = i == 7. ? vec3( 0.8 ) : color;\n}\n\nvoid SpriteDoorOpen( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 100927239 : ( p.x < 8. ? 33818116 : ( p.x < 12. ? 67372806 : 33817604 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844551 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 33947905 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 67078 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33816832 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 66050 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 66566 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 117899520 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 66823 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 117899520 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 66822 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 67502336 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 66050 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 66564 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 84082944 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 66566 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 100860160 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 66823 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 67305728 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 66306 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 66823 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 117899520 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67078 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 101122304 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 66567 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 101122304 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 66050 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.15, 0.15, 0.14 ) : color;\n    color = i == 2. ? vec3( 0.35 ) : color;\n    color = i == 3. ? vec3( 0.53, 0.37, 0.21 ) : color;\n    color = i == 4. ? vec3( 0.59, 0.67, 0.64 ) : color;\n    color = i == 5. ? vec3( 0.8, 0.64, 0.49 ) : color;\n    color = i == 6. ? vec3( 0.75 ) : color;\n    color = i == 7. ? vec3( 0.85 ) : color;\n}\n\nvoid SpriteDoorLocked( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 117769991 : ( p.x < 8. ? 50661125 : ( p.x < 12. ? 84215559 : 50660613 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844551 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50790657 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 67176199 : ( p.x < 8. ? 33685762 : ( p.x < 12. ? 33686017 : 50659586 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 67175171 : ( p.x < 8. ? 16843010 : ( p.x < 12. ? 33620225 : 50528514 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 16844039 : ( p.x < 8. ? 258 : ( p.x < 12. ? 33619968 : 117899522 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 84214017 : ( p.x < 12. ? 16843525 : 117899522 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 50529537 : ( p.x < 12. ? 16974595 : 84345090 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33620739 : ( p.x < 8. ? 16974594 : ( p.x < 12. ? 16974593 : 50528513 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 33621253 : ( p.x < 8. ? 84215045 : ( p.x < 12. ? 84215045 : 100925697 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33621255 : ( p.x < 8. ? 50529029 : ( p.x < 12. ? 50529027 : 117702913 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 197381 : ( p.x < 12. ? 50529024 : 84148481 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16843779 : ( p.x < 8. ? 197381 : ( p.x < 12. ? 50529024 : 50528513 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 50529029 : ( p.x < 12. ? 50529027 : 117899521 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33621767 : ( p.x < 8. ? 50529027 : ( p.x < 12. ? 50529027 : 117899521 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33621255 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843265 : 117899521 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16843523 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50528513 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.024, 0.0078, 0 );\n    color = i == 1. ? vec3( 0.19, 0.13, 0.11 ) : color;\n    color = i == 2. ? vec3( 0.38, 0.25, 0.094 ) : color;\n    color = i == 3. ? vec3( 0.42, 0.39, 0.38 ) : color;\n    color = i == 4. ? vec3( 0.53, 0.38, 0.2 ) : color;\n    color = i == 5. ? vec3( 0.59, 0.62, 0.56 ) : color;\n    color = i == 6. ? vec3( 0.8, 0.64, 0.49 ) : color;\n    color = i == 7. ? vec3( 0.8 ) : color;\n}\n\nvoid SpriteStairsDown( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 50529284 : ( p.x < 8. ? 67306243 : ( p.x < 12. ? 67372036 : 50594820 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 117901060 : ( p.x < 8. ? 117835271 : ( p.x < 12. ? 101123847 : 50726407 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 33751553 : ( p.x < 8. ? 33751555 : ( p.x < 12. ? 33620483 : 50791170 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 50529028 : ( p.x < 8. ? 16908548 : ( p.x < 12. ? 16843265 : 67568129 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 117835523 : ( p.x < 8. ? 16843011 : ( p.x < 12. ? 16842753 : 67567873 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117835524 : ( p.x < 8. ? 50463235 : ( p.x < 12. ? 65539 : 67567873 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 2 : 50790400 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 117901060 : ( p.x < 8. ? 84280580 : ( p.x < 12. ? 33620482 : 50790401 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 117900804 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 84149250 : 50724866 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117900803 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 84149506 : 50790657 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 67372034 : 50725890 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 100992260 : ( p.x < 12. ? 67372035 : 50725377 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 84215043 : ( p.x < 12. ? 67437570 : 67568129 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67306243 : ( p.x < 8. ? 50529028 : ( p.x < 12. ? 16908546 : 50790658 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 101123588 : ( p.x < 8. ? 117901062 : ( p.x < 12. ? 117835270 : 50792199 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 67371780 : ( p.x < 8. ? 67371779 : ( p.x < 12. ? 67306499 : 67372035 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.13 );\n    color = i == 1. ? vec3( 0.2 ) : color;\n    color = i == 2. ? vec3( 0.26 ) : color;\n    color = i == 3. ? vec3( 0.31 ) : color;\n    color = i == 4. ? vec3( 0.35 ) : color;\n    color = i == 5. ? vec3( 0.44 ) : color;\n    color = i == 6. ? vec3( 0.51 ) : color;\n    color = i == 7. ? vec3( 0.56 ) : color;\n}\n\nvoid SpriteStairsUp( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 50529284 : ( p.x < 8. ? 84215045 : ( p.x < 12. ? 84214533 : 84215043 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 67569412 : ( p.x < 8. ? 50463234 : ( p.x < 12. ? 33751811 : 84215043 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 50791940 : ( p.x < 8. ? 50594820 : ( p.x < 12. ? 67437829 : 84215042 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 50726404 : ( p.x < 8. ? 50791943 : ( p.x < 12. ? 84215045 : 84215042 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 67503875 : ( p.x < 8. ? 50726662 : ( p.x < 12. ? 67371780 : 84214786 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 67503876 : ( p.x < 8. ? 67503878 : ( p.x < 12. ? 50791943 : 50529027 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 50792196 : ( p.x < 8. ? 50792199 : ( p.x < 12. ? 67569414 : 50594819 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 16843009 : ( p.x < 8. ? 67569415 : ( p.x < 12. ? 67503878 : 50791942 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 17105665 : ( p.x < 8. ? 67503623 : ( p.x < 12. ? 67569158 : 50726663 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 17105664 : ( p.x < 8. ? 65793 : ( p.x < 12. ? 67503878 : 50791942 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 50529025 : ( p.x < 8. ? 16974597 : 50726663 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 50529025 : ( p.x < 8. ? 16974595 : ( p.x < 12. ? 257 : 50726406 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 50529025 : ( p.x < 8. ? 50529027 : ( p.x < 12. ? 197379 : 67569158 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 50397440 : ( p.x < 8. ? 50529027 : ( p.x < 12. ? 196865 : 65536 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16974080 : ( p.x < 8. ? 16974593 : ( p.x < 12. ? 50397441 : 197377 ) ) ) : v;\n\tv = p.y == 0. ? 0 : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.12 );\n    color = i == 1. ? vec3( 0.17 ) : color;\n    color = i == 2. ? vec3( 0.21, 0.2, 0.19 ) : color;\n    color = i == 3. ? vec3( 0.23, 0.23, 0.22 ) : color;\n    color = i == 4. ? vec3( 0.26, 0.26, 0.25 ) : color;\n    color = i == 5. ? vec3( 0.31, 0.31, 0.29 ) : color;\n    color = i == 6. ? vec3( 0.5 ) : color;\n    color = i == 7. ? vec3( 0.53 ) : color;\n}\n\nvoid SpriteKey( inout vec3 color, vec2 p )\n{\n    p -= vec2( 5., 2. );\n    p = p.x < 0. ? vec2( 0. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 8. ? 139824 : 0 ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 2232611 : 0 ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 1179666 : 0 ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 1245202 : 0 ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 1192482 : 0 ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 74256 : 0 ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 135680 : 0 ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.45 ) : color;\n    color = i == 2. ? vec3( 0.83 ) : color;\n    color = i == 3. ? vec3( 0.95 ) : color;\n}\n\nvoid SpriteFood( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 4. );\n    p = p.x < 0. ? vec2( 0. ) : p;\n    \n    int v = 0;\n\tv = p.y == 7. ? ( p.x < 8. ? 3355392 : 0 ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 52498736 : 0 ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 839979795 : 0 ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 839979283 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 839979283 : 0 ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 841027875 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 52568624 : 0 ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 3355392 : 0 ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.24 ) : color;\n    color = i == 2. ? vec3( 0.29, 0.74, 0.79 ) : color;\n    color = i == 3. ? vec3( 0.91 ) : color;\n}\n\nvoid SpritePotion( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 2. );\n    p = p.x < 0. ? vec2( 0. ) : p;\n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 4. ? 50331648 : ( p.x < 8. ? 4 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 84280832 : ( p.x < 8. ? 394757 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 50724864 : ( p.x < 8. ? 1540 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 17170432 : ( p.x < 8. ? 1537 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 17170432 : ( p.x < 8. ? 1537 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 16844288 : ( p.x < 8. ? 393473 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16843014 : ( p.x < 8. ? 100729089 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 33686022 : ( p.x < 8. ? 100796162 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 33686022 : ( p.x < 8. ? 100796162 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33686022 : ( p.x < 8. ? 100794882 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33687040 : ( p.x < 8. ? 393730 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 1542 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.24 ) : color;\n    color = i == 2. ? vec3( 0.91, 0, 0.12 ) : color;\n    color = i == 3. ? vec3( 0.6, 0.38, 0.2 ) : color;\n    color = i == 4. ? vec3( 0.71, 0.49, 0.31 ) : color;\n    color = i == 5. ? vec3( 0.83, 0.76, 0.71 ) : color;\n    color = i == 6. ? vec3( 0.85 ) : color;\n    color = i == 7. ? vec3( 1 ) : color;\n}\n\nvoid SpriteRatDead( inout vec3 color, vec2 p )\n{\n    p -= vec2( 2., 1. );\n    p = p.x < 0. ? vec2( 9. ) : p;  \n    \n    int v = 0;\n\tv = p.y == 8. ? ( p.x < 4. ? 33685504 : ( p.x < 8. ? 5 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 67371520 : ( p.x < 8. ? 1 : ( p.x < 12. ? 131586 : 0 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 67371522 : ( p.x < 8. ? 50397442 : ( p.x < 12. ? 84149252 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67372034 : ( p.x < 8. ? 67240452 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67371521 : ( p.x < 8. ? 50594308 : ( p.x < 12. ? 16843268 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 67372033 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 84149250 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67371264 : ( p.x < 8. ? 67371524 : ( p.x < 12. ? 50594818 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16844289 : ( p.x < 8. ? 67240450 : ( p.x < 12. ? 16908804 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 257 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 100729089 : 460551 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 0.81, 0.31, 0.33 ) : color;\n    color = i == 6. ? vec3( 0.8, 0.49, 0.51 ) : color;\n    color = i == 7. ? vec3( 0.93, 0.58, 0.6 ) : color;\n}\n\nvoid SpriteSkeletonDead( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 0. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 84215040 : ( p.x < 8. ? 328965 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 101058053 : ( p.x < 8. ? 84280838 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67372547 : ( p.x < 8. ? 33817604 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 17171971 : ( p.x < 8. ? 83953158 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 101057024 : ( p.x < 8. ? 84280326 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 50462720 : ( p.x < 8. ? 197893 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 131072 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.81 ) : color;\n    color = i == 6. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteTrap( inout vec3 color, vec2 p, float pulse )\n{\n    int v = 0;\n\tv = p.y == 15. ? 0 : v;\n\tv = p.y == 14. ? 0 : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 16777218 : ( p.x < 12. ? 33554434 : 1 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117506048 : ( p.x < 8. ? 84017157 : ( p.x < 12. ? 84017157 : 5 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 117440512 : ( p.x < 8. ? 83887621 : ( p.x < 12. ? 83887621 : 1543 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 100663296 : ( p.x < 8. ? 67108870 : ( p.x < 12. ? 67108868 : 4 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 16777218 : ( p.x < 12. ? 33554434 : 2 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 83951616 : ( p.x < 8. ? 84017157 : ( p.x < 12. ? 117571589 : 517 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 83886080 : ( p.x < 8. ? 83887623 : ( p.x < 12. ? 117638661 : 1029 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 67108864 : ( p.x < 8. ? 67108868 : ( p.x < 12. ? 100664070 : 6 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 16777218 : ( p.x < 12. ? 33554434 : 2 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 117571584 : ( p.x < 8. ? 117571589 : ( p.x < 12. ? 84017157 : 5 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 83886080 : ( p.x < 8. ? 83887621 : ( p.x < 12. ? 84018181 : 1031 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67108864 : ( p.x < 8. ? 67108868 : ( p.x < 12. ? 100663300 : 516 ) ) ) : v;\n\tv = p.y == 1. ? 0 : v;\n\tv = p.y == 0. ? 0 : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.13, 0.13, 0.12 ) : color;\n    color = i == 2. ? vec3( 0.21, 0.2, 0.19 ) : color;\n    color = i == 3. ? vec3( 0.33, 0.32, 0.31 ) : color;\n    color = i == 4. ? vec3( 0.37, 0.37, 0.36 ) : color;\n    color = i == 5. ? pulse * vec3( 0.93, 0.35, 0 ) : color;\n    color = i == 6. ? vec3( 0.44, 0.43, 0.42 ) : color;\n    color = i == 7. ? pulse * vec3( 1, 0.47, 0.051 ) : color;\n}\n\nvoid SpriteMoss( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? 0 : v;\n\tv = p.y == 14. ? 0 : v;\n\tv = p.y == 13. ? 0 : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 318767104 : ( p.x < 16. ? 3145731 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 318767360 : ( p.x < 16. ? 52428851 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 321912832 : ( p.x < 16. ? 1114129 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 322109440 : ( p.x < 16. ? 51523586 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 322109440 : ( p.x < 16. ? 51589120 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 305135616 : ( p.x < 16. ? 34799667 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 285212672 : ( p.x < 16. ? 819 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 819 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 196608 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 3354624 : ( p.x < 16. ? 256 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 1118464 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 204800 : 0 ) : v;\n\tv = p.y == 0. ? 0 : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.37, 0.39, 0.14 ) : color;\n    color = i == 2. ? vec3( 0.39, 0.41, 0.16 ) : color;\n    color = i == 3. ? vec3( 0.41, 0.42, 0.18 ) : color;\n}\n\nvec2 FrameOffset( float frame, float tick )\n{\n    vec2 ret = vec2( 0. );\n    ret.x = frame == 1. ? 1. : ( frame == 2. ? -1. : 0. );\n    ret.y = frame == 3. ? 1. : ( frame == 4. ? -1. : 0. );\n    return floor( 16. * ret * ( tick / TICK_NUM ) );\n}\n\nfloat Rand( vec2 n )\n{\n\treturn fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat WaterSDF( vec2 p )\n{\n    float ret = length( p - vec2( 16., 16. ) ) - 16.;\n    ret = min( ret, length( p - vec2( 20., 60. ) ) - 16. );\n    ret = min( ret, length( p - vec2( 18., 38. ) ) - 12. );\n    \n    ret = min( ret, length( p - vec2( 286., 20. ) ) - 36. );\n    \n    ret = min( ret, length( p - vec2( 20., 120. ) ) - 16. );\n    ret = min( ret, length( p - vec2( 20., 160. ) ) - 16. );\n    \n    ret = min( ret, length( p - vec2( 16., 400. ) ) - 20. );\n    \n    ret = min( ret, length( p - vec2( 470., 30. ) ) - 20. );\n    ret = min( ret, length( p - vec2( 480., 80. ) ) - 20. );\n    ret = min( ret, length( p - vec2( 430., 10. ) ) - 20. );\n    \n    ret = min( ret, length( p - vec2( 415., 320. ) ) - 30. );\n    \n    ret = min( ret, length( p - vec2( 130., 320. ) ) - 40. );\n    \n\tret = min( ret, length( p - vec2( 300., 100. ) ) - 50. );    \n    \n    ret = min( ret, length( p - vec2( 80., 480. ) ) - 50. ); \n    \n    ret = min( ret, length( p - vec2( 80., 224. ) ) - 50. ); \n    \n    ret = min( ret, length( p - vec2( 200., 360. ) ) - 50. ); \n    \n    ret += sin( p.y * .75 ) * 1.;    \n    return floor( ret );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    GameState s;\n    LoadState( s );    \n    \n    vec2 playerPos = s.playerPos * 16. + FrameOffset( s.playerFrame, s.tick ); \n    \n    vec2 resMult\t= floor( iResolution.xy / REF_RES );\n    float resRcp    = 1. / max( min( resMult.x, resMult.y ), 1. );\n    vec2 screenSize = floor( iResolution.xy * resRcp );\n    vec2 pixel      = floor( fragCoord.xy * resRcp );\n    vec2 camera     = clamp( playerPos - floor( screenSize / 2. ), vec2( -32. ), vec2( 32. * 16. + 32. ) - screenSize );\n    vec2 world      = pixel + camera;\n    vec2 tile\t\t= floor( world / 16. );\n    vec2 worldMod16 = floor( mod( world, 16. ) );\n    vec4 map\t\t= texelFetch( iChannel1, ivec2( tile ), 0 );\n    \n    vec3 color = vec3( 0. );\n    SpriteEarth( color, worldMod16 );\n    if ( Rand( tile / 32. ) > .8 )\n    {\n    \tSpriteEarth2( color, worldMod16 );\n    }\n\n    float waterSDF = WaterSDF( world );\n    if ( map.x != 0. )\n    {\n\t\tSpriteFloor( color, worldMod16 );\n        \n \t\tvec3 water;\n        SpriteWater( water, floor( mod( floor( world + vec2( 0., float( iFrame ) * .2 ) ), 16. ) ) );\n        \n        float alpha = waterSDF >= 0. ? 0. : 1.;\n        alpha = waterSDF == -1. ? 0.25 : alpha;\n        alpha = waterSDF == -2. ? 0.5 : alpha;\n        \n    \tcolor = mix( color, water, alpha );\n    }\n    \n    // decoration\n    if ( map.x == TILE_FLOOR && waterSDF >= 0. )\n    {\n\t\tif ( Rand( tile / 32. - 3.15 ) > .8 )\n    \t{\n       \t\t SpriteMoss( color, worldMod16 );\n        } \n        else if ( Rand( tile / 32. - 7.19 ) > .9 )\n        {\n            SpriteEarth2( color, worldMod16 );\n        }\n        else if ( Rand( tile / 32. - 13.19 ) > .95 )\n        {\n            SpriteTrap( color, worldMod16, 0. );\n        }   \n    }\n    \n    if ( map.x == TILE_STAIRS_UP )\n    {\n        SpriteStairsUp( color, worldMod16 );\n    }\n    if ( map.x == TILE_STAIRS_DOWN )\n    {\n        SpriteStairsDown( color, worldMod16 );\n    }     \n    \n    if ( map.x == TILE_WALL )\n    {\n    \tSpriteWall( color, worldMod16 );\n    }\n    if ( map.x == TILE_WALL_HOLE )\n    {\n    \tSpriteWallHole( color, worldMod16 );\n    }       \n    if ( map.x == TILE_DOOR_LOCKED )\n    {\n        SpriteDoorLocked( color, worldMod16 );\n    }\n    if ( map.x == TILE_DOOR_OPEN )\n    {\n        bool open = s.playerPos == tile || map.z > 0.;\n\t\tfor ( int i = 0; i < ENEMY_NUM; ++i )        \n        {\n            if ( tile == s.enemyPos[ i ] )\n            {\n                open = true;\n            }\n        }\n\n        if ( open )\n        {\n        \tSpriteDoorOpen( color, worldMod16 );\n        }\n        else\n        {\n            SpriteDoorClosed( color, worldMod16 );\n        }\n    }\n    if ( map.x == TILE_TRAP || map.x == TILE_TRAP_OFF )\n    {\n        SpriteTrap( color, worldMod16, map.x == TILE_TRAP ? sin( iTime * 2. ) * .25 + .75 : 0. );\n    }\n\n    if ( map.y == ITEM_KEY )\n    {\n        SpriteKey( color, worldMod16 );\n    }\n    if ( map.y == ITEM_FOOD )\n    {\n        SpriteFood( color, worldMod16 );\n    }\n    if ( map.y == ITEM_POTION )\n    {\n        SpritePotion( color, worldMod16 );\n    }\n    \n    if ( map.z == 1. )\n    {\n        SpriteRatDead( color, worldMod16 );\n    }\n    \n    if ( map.z == 2. )\n    {\n        SpriteSkeletonDead( color, worldMod16 );\n    }\n    \n\tfragColor = vec4( color, 1. );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// items and enemies\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_POTION\t\t\t= 2.;\nconst float ITEM_SPAWNER\t\t= 3.;\nconst float LOG_ID_DMG\t\t\t= 1.;\nconst float LOG_ID_XP\t\t\t= 2.;\nconst float LOG_ID_LEVEL_UP\t\t= 3.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst vec2  REF_RES\t            = vec2( 200. );\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    // 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t// 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    // 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    // 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    // 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) / 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid SpriteRat( inout vec3 color, vec2 p )\n{\n\tp -= vec2( 0., 1. );    \n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554946 : ( p.x < 12. ? 131586 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67241730 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 33948678 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 16843010 : 5 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 66052 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 197635 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33686532 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 33817602 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67371522 : ( p.x < 12. ? 16909313 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 50397441 : ( p.x < 12. ? 83951877 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8.0 * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 0.81, 0.31, 0.33 ) : color;\n    color = i == 6. ? vec3( 1, 0.4, 0.3 ) : color;\n    color = i == 7. ? vec3( 0.86, 0.53, 0.55 ) : color;\n}\n\nvoid SpriteRatAttack( inout vec3 color, vec2 p )\n{\n\tp -= vec2( 0., 1. );    \n    \n    int v = 0;\n\tv = p.y == 10. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33685504 : ( p.x < 12. ? 33686016 : 2 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 117571584 : ( p.x < 12. ? 67372034 : 516 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67240448 : ( p.x < 12. ? 67503108 : 518 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 132100 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 132100 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 83952644 : 393477 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 50397953 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33686532 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 33817602 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67371522 : ( p.x < 12. ? 16909313 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 50397441 : ( p.x < 12. ? 100729094 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 1, 0.09, 0.09 ) : color;\n    color = i == 6. ? vec3( 0.9, 0.36, 0.31 ) : color;\n    color = i == 7. ? vec3( 0.86, 0.53, 0.55 ) : color;\n}\n\nvoid SpriteRatWalk( inout vec3 color, vec2 p )\n{\n    p -= vec2( 0., 1. );\n    \n    int v = 0;\n\tv = p.y == 12. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554946 : ( p.x < 12. ? 131586 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67241730 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 33948678 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 16843010 : 5 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 66052 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 197635 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33686532 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 33817602 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67371522 : ( p.x < 12. ? 16909313 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 117440512 : ( p.x < 8. ? 16974081 : ( p.x < 12. ? 65793 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 460551 : ( p.x < 8. ? 83886080 : ( p.x < 12. ? 327680 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 0.81, 0.31, 0.33 ) : color;\n    color = i == 6. ? vec3( 1, 0.4, 0.3 ) : color;\n    color = i == 7. ? vec3( 0.86, 0.53, 0.55 ) : color;\n}\n\nvoid SpriteSkeleton( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 8. ) : p;        \n    \n    int v = 0;\n\tv = p.y == 13. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 101058054 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117900800 : ( p.x < 8. ? 117901063 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 67568384 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117900032 : ( p.x < 8. ? 17237761 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 117571584 : ( p.x < 8. ? 117704455 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 50726403 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554434 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117835264 : ( p.x < 8. ? 101123847 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67108870 : ( p.x < 8. ? 328965 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 1539 : ( p.x < 8. ? 33554944 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 101057282 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 196608 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 1536 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 771 : ( p.x < 8. ? 50528256 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.8 ) : color;\n    color = i == 6. ? vec3( 0.81 ) : color;\n    color = i == 7. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteSkeletonWalk( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 8. ) : p;     \n    \n    int v = 0;\n\tv = p.y == 13. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 101058054 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117900800 : ( p.x < 8. ? 117901063 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 67568384 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117900032 : ( p.x < 8. ? 17237761 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 117571584 : ( p.x < 8. ? 117704455 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 50726403 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554434 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117835264 : ( p.x < 8. ? 101123847 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67108870 : ( p.x < 8. ? 328965 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 393984 : ( p.x < 8. ? 33554944 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 100860416 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 196608 : ( p.x < 8. ? 100990976 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 1536 : ( p.x < 8. ? 393984 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 197376 : 0 ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.8 ) : color;\n    color = i == 6. ? vec3( 0.81 ) : color;\n    color = i == 7. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteSkeletonAttack( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 10. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 13. ? ( p.x < 4. ? 100663296 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117833728 : ( p.x < 8. ? 117901063 : ( p.x < 12. ? 1543 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 117637120 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 516 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117637120 : ( p.x < 8. ? 117899527 : ( p.x < 12. ? 1537 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67569415 : ( p.x < 12. ? 1543 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 101057794 : ( p.x < 12. ? 3 : 0 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 512 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 101058048 : ( p.x < 8. ? 100861446 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 84213760 : ( p.x < 8. ? 50464005 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554944 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 101058054 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 196608 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 1536 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 771 : ( p.x < 8. ? 50528256 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.8 ) : color;\n    color = i == 6. ? vec3( 0.81 ) : color;\n    color = i == 7. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteWarriorHead( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33686016 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33685504 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 516 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67371520 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 132100 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67239936 : ( p.x < 8. ? 117901062 : ( p.x < 12. ? 132103 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 84148736 : ( p.x < 8. ? 84214021 : ( p.x < 12. ? 769 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 84148992 : ( p.x < 8. ? 101057798 : ( p.x < 12. ? 1029 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 67239936 : ( p.x < 8. ? 67372038 : ( p.x < 12. ? 1028 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 67239936 : ( p.x < 8. ? 33686020 : ( p.x < 12. ? 514 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.64, 0.2, 0.047 ) : color;\n    color = i == 3. ? vec3( 0.52, 0.35, 0.22 ) : color;\n    color = i == 4. ? vec3( 0.77, 0.47, 0.29 ) : color;\n    color = i == 5. ? vec3( 0.72, 0.59, 0.47 ) : color;\n    color = i == 6. ? vec3( 0.86, 0.71, 0.59 ) : color;\n    color = i == 7. ? vec3( 1, 0.85, 0.75 ) : color;\n}\n\nvoid SpriteWarriorStand( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 101057536 : ( p.x < 8. ? 33620485 : ( p.x < 12. ? 770 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16908802 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 261 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 17040897 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 258 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 33620736 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 770 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33619968 : ( p.x < 8. ? 33685761 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16908544 : ( p.x < 8. ? 33619968 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16843008 : ( p.x < 8. ? 16842752 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.09, 0.11, 0.18 ) : color;\n    color = i == 2. ? vec3( 0.28, 0.35, 0.45 ) : color;\n    color = i == 3. ? vec3( 1, 0.36, 0.043 ) : color;\n    color = i == 4. ? vec3( 1, 0.65, 0.25 ) : color;\n    color = i == 5. ? vec3( 0.54, 0.67, 0.73 ) : color;\n    color = i == 6. ? vec3( 1, 0.85, 0.56 ) : color;\n    color = i == 7. ? vec3( 0.91, 1, 1 ) : color;\n}\n\nvoid SpriteWarriorWalk( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 101057536 : ( p.x < 8. ? 33620485 : ( p.x < 12. ? 770 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33620481 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 261 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67371521 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 257 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 33751296 : ( p.x < 8. ? 33687301 : ( p.x < 12. ? 1797 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33619968 : ( p.x < 8. ? 33620225 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16842752 : ( p.x < 8. ? 16842752 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16842752 : 0 ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.09, 0.11, 0.18 ) : color;\n    color = i == 2. ? vec3( 0.29, 0.34, 0.45 ) : color;\n    color = i == 3. ? vec3( 1, 0.36, 0.043 ) : color;\n    color = i == 4. ? vec3( 1, 0.62, 0.23 ) : color;\n    color = i == 5. ? vec3( 0.54, 0.67, 0.73 ) : color;\n    color = i == 6. ? vec3( 1, 0.91, 0.62 ) : color;\n    color = i == 7. ? vec3( 0.87, 1, 1 ) : color;\n}\n\nvoid SpriteWarriorAttack( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 101057536 : ( p.x < 8. ? 16910085 : ( p.x < 12. ? 1026 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33687298 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 67503367 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16844292 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 50528770 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777987 : ( p.x < 8. ? 117901058 : ( p.x < 12. ? 261 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33620226 : ( p.x < 12. ? 263 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33619968 : ( p.x < 8. ? 16777217 : ( p.x < 12. ? 258 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16842752 : ( p.x < 8. ? 16777217 : ( p.x < 12. ? 257 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.09, 0.11, 0.18 ) : color;\n    color = i == 2. ? vec3( 0.28, 0.35, 0.45 ) : color;\n    color = i == 3. ? vec3( 1, 0.36, 0.043 ) : color;\n    color = i == 4. ? vec3( 1, 0.65, 0.25 ) : color;\n    color = i == 5. ? vec3( 0.54, 0.67, 0.73 ) : color;\n    color = i == 6. ? vec3( 1, 0.85, 0.56 ) : color;\n    color = i == 7. ? vec3( 0.91, 1, 1 ) : color;\n}\n\nvec2 FrameOffset( float frame, float tick )\n{\n    vec2 ret = vec2( 0. );\n    ret.x = frame == 1. ? 1. : ( frame == 2. ? -1. : 0. );\n    ret.y = frame == 3. ? 1. : ( frame == 4. ? -1. : 0. );\n    return floor( 16. * ret * ( tick / TICK_NUM ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    GameState s;\n    LoadState( s );    \n    \n    vec2 playerPos = s.playerPos * 16. + FrameOffset( s.playerFrame, s.tick ); \n    \n    vec2 resMult\t= floor( iResolution.xy / REF_RES );\n    float resRcp    = 1. / max( min( resMult.x, resMult.y ), 1. );\n    vec2 screenSize = floor( iResolution.xy * resRcp );\n    vec2 pixel      = floor( fragCoord.xy * resRcp );\n\tvec2 camera     = clamp( playerPos - floor( screenSize / 2. ), vec2( -32. ), vec2( 32. * 16. + 32. ) - screenSize );\n    vec2 world      = pixel + camera;\n    vec2 tile\t\t= floor( world / 16. );\n    vec2 worldMod16 = floor( mod( world, 16. ) );\n    vec4 map\t\t= texelFetch( iChannel1, ivec2( tile ), 0 );\n    float tick2     = s.tick > TICK_NUM / 2. ? 1. : 0.;\n    \n    vec3 color = texelFetch( iChannel2, ivec2( fragCoord ), 0 ).xyz;\n    \n    vec2 warrior = world - playerPos;\n    warrior.x = s.playerDir > 0. ? 13. - warrior.x : warrior.x - 2.;\n    warrior.y -= 1.;\n    if ( warrior.x >= 0. && warrior.y >= 0. && warrior.x < 16. && warrior.y < 16. \n         && s.hp > 0. )\n    {\n        float walk = s.playerFrame > 0. && tick2 == 1. ? 1. : 0.;\n        if ( warrior.x >= 1. - walk )\n        {\n        \tSpriteWarriorHead( color, warrior - vec2( 1. - walk, 7. ) );   \n        }\n\n        if ( s.playerFrame == 6. && tick2 == 1. )\n        {\n            SpriteWarriorAttack( color, warrior );\n        }        \n        else if ( walk == 1. )\n        {\n\t\t\tSpriteWarriorWalk( color, warrior );\n        }\n        else if ( warrior.x >= 1. )\n        {\n\t\t\tSpriteWarriorStand( color, warrior - vec2( 1., 0. ) );\n        }\n    }\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n    \tvec3 enemyColor = color;\n        \n        vec2 enemy = world - s.enemyPos[ i ] * 16. + FrameOffset( s.enemyFrame[ i ], s.tick );\n\t\tenemy.x = s.enemyDir[ i ] > 0. ? 15. - enemy.x : enemy.x;\n        if ( enemy.x >= 0. && enemy.y >= 0. && enemy.x < 16. && enemy.y < 16. && s.enemyPos[ i ].x > 0. )\n    \t{\n            if ( s.enemyFrame[ i ] == 5. && tick2 == 1. )\n            {\n                if ( s.enemyId[ i ] == 0. )\n                \tSpriteRatAttack( enemyColor, enemy );\n                else\n                    SpriteSkeletonAttack( enemyColor, enemy );\n            }\n            else if ( s.enemyFrame[ i ] > 0. && tick2 == 1. )\n            {\n                if ( s.enemyId[ i ] == 0. )\n                \tSpriteRatWalk( enemyColor, enemy );\n                else\n                \tSpriteSkeletonWalk( enemyColor, enemy );\n            }\n            else\n            {\n                if ( s.enemyId[ i ] == 0. )\n        \t\t\tSpriteRat( enemyColor, enemy );\n                else\n                    SpriteSkeleton( enemyColor, enemy );\n\t\t\t}\n        }\n        \n        // fog of war\n        float dist = length( playerPos - s.enemyPos[ i ] * 16. );\n\t\tcolor = mix( color, enemyColor, saturate( ( 64. + 16. - dist ) / 32. ) );\n    }\n    \n\tfragColor = vec4( color, 1. );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 11519,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/space_lion/diablo-ost-matt-uelmen-into-town"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}