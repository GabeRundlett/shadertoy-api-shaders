{
    "Shader": {
        "info": {
            "date": "1604875988",
            "description": "testing fft implementation, using uniforms through api",
            "flags": 0,
            "hasliked": 0,
            "id": "tddfDn",
            "likes": 2,
            "name": "cherry blossom tree 2",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "jemappelle",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\nfloat opSubtract(float o0, float o1){return max(-o0,o1);}\n\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.5 + .5;\n}\n\nfloat sphere(vec3 d, float r){\n  \t//d = mod(d, 2.)-2.*0.5;  \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.5) - r;\n}\n\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat map(vec3 d){\n  \td = mod(d, 2.)-2.*0.5;  \n  \treturn mix(sdRoundedX(d.xy, 0.1, 0.12), (sphere(d, 0.4)), cos(iTime*0.8*0.8)) * abs(sdCappedTorus(d, vec2(midFreqFFT,0.4), midFreqFFT/3., 0.4));\n}\n\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.01,0.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.x, 1.,length(uv.x));\n  \n  \tvec3 ro = vec3(0.+cos(iTime)/2.,zMotion,-8.+(iTime*4.)); \n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv,1.));\n    //vec3 rd = normalize(vec3(uv,shapeColour));\n    \n    //Sound test\n    //float fft = texture(iChannel0, vec2(uv.x,uv.y)).x;\n    \n  \tbool hit = false;\n  \tfloat shading = 0.;\n  \n  \tfor(float i = 0.; i < 15.; i++){\n    \tfloat env = map(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/100.;\n      \t\tbreak;\n    \t}\n    \t//p += env * sin(rd-ro/50.);\n    \t//p += env - (sin(env+ro/100.)+atan(ro+rd));\n        sin(p += env - (sin(env+ro/100.)+atan(rd))) + atan(rd-ro/50.);\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*8.5)*0.1;\n  \tuv.y += sin(uv.x*8.5+iTime)*0.1;\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.1)-0.2*0.5;\n  \n  \t//Shape\n  \tfloat verLine = sin(smoothstep(0.05, 0.9,length(uv.y/(circle*midFreqFFT))));\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n  \n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n        \n        //Colour as static\n        //color = mix(vec3(0.8,0.05,0.2), vec3(0.1,0.0,0.0), vec3(diffuse_directional(n,l)));\n        \n        //Colour with uniform\n        //color = mix(vec3(highFreqFFT-sin(verLine/cos(circle/(shading*2.)))/4.,0.01,midFreqFFT/8.-cos(verLine)), vec3(lowFreqFFT/4.,0.0,midFreqFFT/4.), \n        //            mix(vec3(circle/verLine), vec3(shading-verLine),vec3(diffuse_directional(n,l))));\n    \t\n        color = mix(vec3(0.05-sin(verLine*cos(circle/(verLine*uv.y*abs(shading))))/4.,0.01,midFreqFFT/8.-cos(verLine)), vec3(0.0,0.05,lowFreqFFT/sin(verLine-sin(circle-(iTime*uv.x*abs(uv.y))))/4.), \n        mix(vec3(circle/verLine), vec3(shading-verLine),vec3(diffuse_directional(n,l))));\n        \n        hit = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading);\n        color = vec3(circle - verLine+shading) - vec3(0.9,0.9,0.9);\n    \t//color = vec3(circle *= sin(verLine/1.)*iTime);\n  \t}\n  \tfloat t = length(ro*p);\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.6,0.1,0.1), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 0.1) + vec4((color * circle / 1.5), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}