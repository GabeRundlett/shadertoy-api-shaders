{
    "Shader": {
        "info": {
            "date": "1608649033",
            "description": "Visualization of the coordinate space while applying an IFS. It animates through the rotation, and after each cycle it will increase the number of iterations.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sfSDH",
            "likes": 4,
            "name": "IFS behind the scenes",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "ifs"
            ],
            "usePreview": 0,
            "username": "darkeclipz",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "// Fork of \"MÃ¶bius transformation 1\" by Reedbeta. https://shadertoy.com/view/4tXyWs\n// 2019-02-25 23:03:29\n// Changed to show the coordinate space with the IFS applied to it.\n\n#define PI 3.14159\n\nvec2 ifs(vec2 p, float s, float r, int n) {\n    float co = cos(r), si = sin(r);\n    mat2 rot = mat2(co, si, -si, co);\n    for(int i=0; i < n; i++) {\n        p.x = abs(p.x);\n        p -= vec2(1.0, 0);\n        p *= rot;\n        p *= s;\n    }\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float s = 1.11;\n    float t = mod((iTime / 4.), 10.);\n    float r = fract(t) * 2.0 * PI;\n    \n    uv *= 3. + t / 6.;\n    uv = ifs(uv, s, r, int(t));\n    \n    fragColor.a = 1.0;\n\trenderGrid(uv, fragColor.rgb);\n    renderUnitSquare(uv, fragColor.rgb);\n    renderAxes(vec2(0), uv, fragColor.rgb);\n    \n    float pixelSize = 1. / iResolution.y;\n    vec3 col = vec3(1) * smoothstep(0.5, 0.5-10.*pixelSize, length(uv))*.25 + .75;\n    fragColor.rgb *= col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 10.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderUnitSquare(vec2 pos, inout vec3 fragColor)\n{\n#if 0\n    // Put a texture in there\n    if (pos.x >= 0.0 && pos.y >= 0.0 && pos.x <= 1.0 && pos.y <= 1.0)\n    {\n        fragColor.rgb = texture(iChannel0, pos).rgb;\n    }\n#endif\n\n    float dist = sdistQuadConvex(vec2(0, 0),\n                                 vec2(1, 0),\n                                 vec2(1, 1),\n                                 vec2(0, 1), pos);\n    stroke(dist, vec3(0, 0, 1), fragColor, 0.007, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.1;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b)\n{\n    return cmul(a, vec2(b.x, -b.y)) / dot(b, b);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}