{
    "Shader": {
        "info": {
            "date": "1638577661",
            "description": "It's fun with perlin noise, you dolt!",
            "flags": 0,
            "hasliked": 0,
            "id": "7tcXRn",
            "likes": 4,
            "name": "eindacor_perlinfun",
            "published": 3,
            "tags": [
                "perlin"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 338
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define INVERT true\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getRandomVector(float seed) {\n    vec2 outVec;\n    if (seed < .25) {\n        outVec = vec2(1., 1.);\n    } else if (seed < .5) {\n        outVec = vec2(-1., 1.);\n    } else if (seed < .75) {\n        outVec = vec2(1., -1.);\n    } else {\n        outVec = vec2(-1., -1.);\n    }\n    \n    return outVec;\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getModifiedDot(vec2 uv, vec2 p, float gridDimension, float pHash) {\n    float rotation = sin(iTime * .15 + pHash) * 2. * PI;\n    if (pHash < .5) {\n        rotation *= -1.;\n    }\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    return dot((uv - p) / gridDimension, getRandomVector(pHash) * rotationMatrix);\n}\n\n\nfloat getPerlinValue(vec2 uv, float gridDimension, bool hideLines) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n    \n    float rotation = sin(iTime * .15) * 2. * PI;\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    float dot0 = getModifiedDot(uv, p0, gridDimension, p0Hash);\n    float dot1 = getModifiedDot(uv, p1, gridDimension, p1Hash);\n    float dot2 = getModifiedDot(uv, p2, gridDimension, p2Hash);\n    float dot3 = getModifiedDot(uv, p3, gridDimension, p3Hash);\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    float val = biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n\n    float xLerp = mod(uv.x / 2., gridDimension);\n    float revealMargin = gridDimension * .95;\n\n    if (hideLines || xLerp < revealMargin) {\n        return abs(val);\n    } else {\n        float marginLerp = (xLerp - revealMargin) / (1. - revealMargin);\n        float distFromCenterMargin = abs(.5 - marginLerp);\n        float marginSmooth = smoothstep(0.499, .5, distFromCenterMargin);\n        return mix(clamp(val, 0., 1.), abs(val), marginSmooth);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    float timeScale = .08;\n    \n    uv += vec2(sin(iTime * timeScale), iTime * timeScale);\n    \n    vec3 background = vec3(0.2, 0., 0.);\n    vec3 color1 = vec3(1., 0.75, .25);\n    vec3 color2 = vec3(1.);\n    vec3 color3 = vec3(2.5);\n    \n    float gridSize = .15;\n    \n    float perlinVal1 = pow(getPerlinValue(uv, gridSize, false), .15);\n    float perlinVal2 = log(getPerlinValue(uv, gridSize, false)) / 4.;\n    float perlinVal3 = pow(getPerlinValue(uv, gridSize * 5., true), 2.);\n    \n    vec3 color = mix(mix(mix(background, color1, perlinVal1), color2, perlinVal2), color3, perlinVal3 * .7);\n    \n    if (INVERT) {\n        fragColor = vec4(1. - clamp(color.r, 0., 1.), 1. - clamp(color.g, 0., 1.), 1. - clamp(color.b, 0., 1.), 1.);\n    } else {\n        fragColor = vec4(vec3(color), 1.);\n    }\n    \n    return;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}