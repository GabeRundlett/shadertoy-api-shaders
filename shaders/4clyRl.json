{
    "Shader": {
        "info": {
            "date": "1721457828",
            "description": "fractal https://glslsandbox.com/e#70924.0",
            "flags": 0,
            "hasliked": 0,
            "id": "4clyRl",
            "likes": 1,
            "name": "menger structures",
            "published": 3,
            "tags": [
                "fractal",
                "menger",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "\n#define time iTime\n#define resolution iResolution.xy\n#define EPS 0.001\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// unsigned rounded box: bs = box size, erad = edge radius\nfloat udRoundBox( vec3 pos, vec3 bs, float erad )   \n{ return length(max(abs(pos)-bs, -0.25))-erad; }\n\n\nfloat map(vec3 p) {\n\tfloat r = 8.0;\n\n\tfloat d = udRoundBox(p, vec3(r*0.5), r*0.3);\n\n\tfor (int i = 0; i < 5; i++) {\n//\t\tp.xy *= rot(time * 0.05);\n\t\tp.yz *= rot(time * 1.04);\n\t\tp.zx *= rot(time * 0.08);\n\t\tp = abs(p) - r;\n\t\tr /= 3.0;\n//\t\td = min(d, sdSphere(p, r));\n\t\td = min(d, udRoundBox(p, vec3(r*0.7), r*0.3));\n\t}\n//\td = sdSphere(p, r);\n\treturn d;\n}\nfloat map2(vec3 p) {\n\tfloat r = 8.0;\n\tfloat d = sdSphere(p, r);\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tp.xy *= rot(time * 1.5);\n\t\tp.yz *= rot(time * 0.4);\n\t\tp.zx *= rot(time * 0.3);\n\t\tp = abs(p) - r;\n\t\tr /= 3.0;\n\t\td = min(d, sdSphere(p, r));\n\t}\n\n//\td = sdSphere(p, r);\n\treturn d;\n}\n\n\nvec3 getNormal(vec3 p) {\n\tconst vec2 eps = vec2(EPS, 0);\n    \n\tfloat d = map(p);\n\treturn normalize(vec3(\n\t\tmap(p + eps.stt) - d,\n\t\tmap(p + eps.tst) - d,\n\t\tmap(p + eps.tts) - d));\n}\nvec3 getNormal2(vec3 p) {\n\tconst vec2 eps = vec2(EPS, 0);\n\tfloat d = map2(p);\n\treturn normalize(vec3(\n\t\tmap(p + eps.stt) - d,\n\t\tmap(p + eps.tst) - d,\n\t\tmap(p + eps.tts) - d));\n}\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// https://www.iquilezles.org/www/articles/menger/menger.htm\n\nfloat map3(vec3 p) {\n\t\n\tp.zx *= rot(time * 0.3);\n\tfloat d = sdBox(p, vec3(1));\n\n\tfloat s = 1.0;                   // 0-1-2-3-4-3-2-1-0\n\tint imax = int(mod(abs(sin(time*0.5)*2.0+2.8), 4.8));\n\tfor (int i = 0; i < 10; i++) {\n\t\t\n\t\tvec3 a = mod(p * s, 2.0) - 1.0;\n\t\ts *= 3.0;\n\t\tvec3 r = abs(1.0 - 3.0 * abs(a));\n\t\tfloat da = max(r.x, r.y);\n\t\tfloat db = max(r.y, r.z);\n\t\tfloat dc = max(r.z, r.x);\n\t\tfloat c = (min(da, min(db, dc)) - 1.0) / s;\n\t\td = max(d, c);\n\t}\n\n\treturn d;\n}\n\nvec3 getNormal3(vec3 p) {\n\tconst vec2 eps = vec2(EPS, 0);\n\tfloat d = map3(p);\n\treturn normalize(vec3(\n\t\tmap(p + eps.stt) - d,\n\t\tmap(p + eps.tst) - d,\n\t\tmap(p + eps.tts) - d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n       vec2 uv2 = fragCoord/iResolution.xy-0.5;\n          vec2 uv3 = fragCoord/iResolution.xy-0.5;\n    uv*=1.3;\n     uv.x+=0.25;\n      uv2.x-=0.25;\n       uv.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n        uv2.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n\tvec3 rd = normalize(vec3(uv, 0.5));\n\n\tvec3 ro = vec3(12, 0, -50);\n        \n\tvec3 light = normalize(vec3(1, 1, -1));\n\tfloat dist = 0.0;\n\tfloat bright = 0.0;\n\tvec3 p = rd;\n    p.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n\tfor (int i = 0; i < 50; i++) {\n\t\tp = ro + rd * dist;\n        \n   \n\t\tfloat d = map(p);\n\t\tif (d < EPS) {\n\t\t\tbright = max(dot(light, getNormal(p)), 0.1);\n\t\t\tbreak;\n\t\t}\n\t\tdist += d;\n\t}\n    \n    vec3 rd2 = normalize(vec3(uv2, 0.5));\n\tvec3 ro2 = vec3(-10.,05 , -60);\n\tvec3 light2 = normalize(vec3(10, 1, -60));\n\tfloat dist2 = 0.0;\n\tfloat bright2 = 0.0;\n\tvec3 p2 = rd2;\n      p2.xy*=-mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n       \n\tfor (int i = 0; i < 50; i++) {\n\t\tp2 = ro2 + rd2 * dist2;\n\t\tfloat d2 = map2(p2);\n\t\tif (d2 < EPS) {\n\t\t\tbright2 = max(dot(light2, getNormal2(p2)), 0.1);\n\t\t\tbreak;\n\t\t}\n\t\tdist2 += d2;\n\t}\n    \nvec3 rd3 = normalize(vec3(uv3, 1));\n\tvec3 ro3 = vec3(0, 0, -5);\n\tvec3 light3 = normalize(vec3(0, 0, -3));\n\tfloat dist3 = 0.0;\n\tfloat bright3 = 0.0;\n\n\tfor (int i = 0; i < 50; i++) {\n\t\tvec3 p3 = ro3 + rd3 * dist3;\n\t\tfloat d3 = map3(p3);\n\t\tif (d3 < EPS) {\n\t\t\tbright3 = max(dot(light3, getNormal3(p3)), 0.5);\n\t\t\tbreak;\n\t\t}\n\t\tdist3 += d3;\n\t}\n\tfragColor = vec4( vec3(0.5,0.1,1.)*bright+vec3(0.5,2.1,1.)*bright2+bright3*vec3(1.0,1.1,0.), 1);\n   \n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}