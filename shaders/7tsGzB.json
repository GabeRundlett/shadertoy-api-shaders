{
    "Shader": {
        "info": {
            "date": "1622374673",
            "description": "Rotating Color Balls",
            "flags": 0,
            "hasliked": 0,
            "id": "7tsGzB",
            "likes": 12,
            "name": "Rotating Color Balls",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "caogtaa",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "// shape control\n#define GRIDS 3.\n#define ITER 5.\n\n// 1/SPEED seconds per round\n#define ROTATE_SPEED  0.05\n\n#define PI 3.14159265\n#define SQRT2 1.41421356\n\nfloat Ring(vec2 uv, vec2 o, float r, float width) {\n\tfloat dist = distance(uv, o);\n\treturn abs(dist - (r - width));\n}\n\nfloat sdCircle(vec2 uv, vec2 o, float r, float blur) {\n    float dist = distance(uv, o);\n    return smoothstep(r, r-0.5-blur, dist);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    float blur = 3. / iResolution.y;\n    float mask = 0.;\n    float rotate_speed = ROTATE_SPEED;\n    float grids = GRIDS;\n    float part_id = 0.;\n    vec3 bg = vec3(0.);\n    \n    float angle;\n    float dist = length(uv);\n    bg = hsb2rgb(vec3(1./9., dist, 1.0));\n    vec3 last_color = vec3(0.);\n    for (float i = 0.; i < ITER; ++i) {\n        \n        float angle = atan(uv.y, uv.x);\n        \n        // angle = Remap(-PI, PI, 0., 1., angle);\n        angle = angle / (2. * PI) + 0.5;\n        \n        // align angle = 0 to +Y axis, totate by time\n        // angle = 0 对齐到 x正轴，追加一些旋转\n        angle = fract(angle + 0.5 + iTime * rotate_speed);\n\n        // divide area by angle\n        // 等分角度\n        grids = GRIDS + part_id;\n        part_id = floor(angle * grids);\n        float part_angle = fract(angle * grids);\n        \n        float every_other = mod(part_id, 2.0) * 2.0 - 1.0;\n        rotate_speed *= every_other * 2.0;\n        \n        // inverse map uv\n        // 将网格化后的角度重新映射回笛卡尔坐标\n        vec2 guv = vec2(cos(part_angle / grids * 2. * PI), sin(part_angle / grids * 2. * PI)) * dist;\n\n        // map uv to BBox of the inner circle of current sub area, circle radius become 1\n        // gr是(guv区域并uv大圆的)内接圆\n        // guv从[0,1]映射到以内接圆为中心的坐标，内接圆半径长度是1\n        float theta = 2. * PI / grids;\n        float S = sin(theta * 0.5);\n        float gr = S/(1.+S);\n        vec2 go = vec2(sqrt(1.-2.*gr), gr);\n        \n        // 坐标映射\n    \tuv = (guv - go) / gr;\n        dist = length(uv);\n        \n        // scale blur along with uv\n        // 坐标缩放后blur需要变粗\n        blur /= gr;\n        \n        // mix colors        \n        float compX = part_id / grids;\n        last_color = hsb2rgb(vec3(compX, dist, 1.0));\n        bg = bg * 0.75 + last_color * sdCircle(uv, vec2(0.), 1., blur) * 0.5;\n    }\n    \n    float width = 0.01;\n    float ring = Ring(uv, vec2(0.), 1., width);\n    // mask = ring;\n    mask += smoothstep(width+blur, width, ring);\n    \n    vec3 color = vec3(0.);\n    color += bg;\n    color += last_color * mask;\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}