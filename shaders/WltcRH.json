{
    "Shader": {
        "info": {
            "date": "1608491981",
            "description": "An experiment of Bending, but Both ends remain straight.",
            "flags": 0,
            "hasliked": 0,
            "id": "WltcRH",
            "likes": 6,
            "name": "Bending experiment",
            "published": 3,
            "tags": [
                "bending"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 434
        },
        "renderpass": [
            {
                "code": "// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\n//https://www.shadertoy.com/view/ldl3zn\nvec3 WarpDomain( const in vec3 vPos )\n{\n    vec3 vResult = vPos;\n\n    float fUnbend = clamp(atan(vResult.x, vResult.z), 0.0, PI * sin(iTime));\n    R(vResult.zx, fUnbend);\n     \n    float fDroopBlend = max(-vResult.y, 0.0);\n    vResult.y += fDroopBlend * 0.4;\n    vResult.z += sin(vResult.x * 1.0  + vResult.y * 2.0 + iTime) * fDroopBlend * 0.05;\n    return vResult;\n}\n\n\nvec3 ro = vec3(0), rd = vec3(0);\nvec3 col = vec3(0);\nfloat curve(float x){\n    return x*x*(3.0-2.0*x);\n}\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n\n\tvec3 cp001 = p;\n\tcp001.xyz += vec3(0., -1., 0.);\n    \n    // Bending...\n    #if 1\n\t{\n        vec3 q = cp001;\n        float r = s2u(sin(iTime))*PI*.5; // rotation radian\n        float range = .5+s2u(sin(iTime*.5)); // range of bending\n        \n        float sgn = sign(q.x);\n        float smoothRange = sms(-sms(0., 1., p.z-.2), range, q.x*sgn) * sgn *.5;\n        \n        R(q.xz, r*smoothRange);\n        cp001 = q;\n    }\n    #else\n    {\n        cp001 = WarpDomain(cp001);\n    }\n    #endif\n    \n    \n\td = sdCapsule(rot(cp001+vec3(0.3713, 0., 0.), vec3(0., 0., 1.5708)), 0.5900, 3.4100);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(0.3713, 0., 0.), vec3(0., 0.6647, 0.)), vec3(0.5295, 1., 1.)), d, 0.1900);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(-0.7288, 0., 0.), vec3(1.0374, 0.6176, 0.4935)), vec3(0.6807, 0.9020, 0.9020)), d, 0.1570);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(1.3413, 0., 0.), vec3(0.8924, 0.5617, 0.2927)), vec3(0.6807, 0.9020, 0.9020)), d, 0.1900);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(2.2848, 0., 0.), vec3(1.0186, 0.6089, 0.4699)), vec3(0.4136, 0.7825, 0.7825)), d, 0.1900);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(-1.7662, 0., 0.), vec3(3.4214, 2.4668, 0.6159)), vec3(0.4972, 1.1038, 1.1038)), d, 0.1390);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(3.1596, 0., 0.), vec3(0.5278, 0.5633, -0.3009)), vec3(0.6807, 1.0448, 1.0448)), d, 0.1900);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(-2.5247, 0., 0.), vec3(0.6248, 0.5416, -0.1472)), vec3(0.6807, 0.9020, 0.9020)), d, 0.1900);\n\tres = v4OpUnion(vec4(d, MAT_ERNST0_001), res);\n\n\td = sdPlane(p);\n\tres = v4OpUnion(vec4(d, MAT_ERNST0), res);\n\n\td = sdCappedCylinder(rot(cp001+vec3(-3.3399, 0., 0.), vec3(0., 0., 1.5708)), vec2(0.4595, 0.4595))-0.0100;\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.0280);\n\n\td = sdEllipsoid(cp001+vec3(-4.5001, 0., 0.), vec3(0.6139, 0.6139, 0.6139));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0_002), res);\n\n    return res;\n}\n\nvec4 intersect()\n{\n    float d = 1.;\n    vec3  m = MAT_VOID;\n\n    for (int i = 0; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        m = res.yzw;\n        res.x *= .5;\n        if (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n        d += res.x;\n        if (d >= MAX_DIST) break;\n    }\n\n    return vec4(d,m);\n}\n\nvec3 normal(vec3 p)\n{\n    float c=sdScene(p).x;\n    float e=MIN_DIST*.1;\n    return normalize(vec3(\n        sdScene(p+vec3(e,0.,0.)).x-c,\n        sdScene(p+vec3(0.,e,0.)).x-c,\n        sdScene(p+vec3(0.,0.,e)).x-c)\n    );\n}\n\nfloat shadow(vec3 o, vec3 n)\n{\n    float mint=L0_str;\n    float maxt=L0_end;\n    float k = L0_sft;\n    float res = 1.;\n    float t=mint;\n    float ph = 1e10;\n    for( int i=0; i < ITERATION; i++)\n    {\n        float h = sdScene(o + L0_dir*t).x;\n#if 1\n        res = min( res, k*h/t);\n#else\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n#endif\n        t += h;\n\n        if( res<0.0001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nfloat specular(vec3 p, vec3 n, vec3 ld)\n{\n    float power = 30.;\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    vec3 base_col = hit.yzw;\n\n    if (hit.x>=MAX_DIST)\n    {\n        col=FOG_COL;\n    }\n    else\n    {\n        vec3 n = normal(p);\n        vec3 offset = n * .00001;\n        float light1 = saturate(dot(n, L0_dir));\n        float light2 = saturate(dot(n, L1_dir));\n        float shadow = shadow(p+offset, n);\n\n        float ao=0.;\n        ao = ambientOcclusion(p, n, .1, .5);\n        ao += ambientOcclusion(p, n, .5, .5);\n        ao += ambientOcclusion(p, n, 2., 2.);\n        ao += ambientOcclusion(p, n, 4., 2.);\n        ao = smoothstep(0., 4., ao);\n\n        float shade = 0.;\n        shade = light1;\n\n        vec3 shadeLight1 = vec3(L0_col*light1);\n        vec3 shadeLight2 = vec3(L1_col*light2);\n\n        col = shadeLight1;\n        col *= shadow;\n        col+= shadeLight2*ao;\n        col+= AMB_COL*ao*AMB_STRENGTH;\n        col*= base_col;\n\n        col = mix(col, col+L0_col, specular(p+offset, n, L0_dir)*shadow*1.);\n        col = mix(col, FOG_COL, saturate(pow(distance(ro,p)/MAX_DIST+FOG_START, FOG_POW)));\n    }\n}\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid camera(vec2 uv)\n{\n    perspectiveCam(uv, ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.)*iResolution.y/iResolution.x;\n    uv.x *= iResolution.x / iResolution.y;\n\n    init();\n    camera(uv);\n    render();\n    col = ACESFilm(col);\n    col = pow(col, vec3(.9));\n\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define pabs(x) sqrt(x*x+.05)\n#define sabs(x) sqrt(x*x+1e-2)\n#define smin(a,b) ((a)+(b)-sabs((a)-(b)))*.5\n#define smax(a,b) ((a)+(b)+sabs((a)-(b)))*.5\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat sdPlane(in vec3 p){\n    return p.y;\n}\n\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\nfloat sdCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\n\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n\n    // iq:\n    //float h = max(r-abs(a-b),0.0);\n    //return min(a, b) - h*h*0.25/r;\n}\n\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r)\n{\n    float h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n    float res = mix(b.x,a.x,h)-r*h*(1.0-h);\n    return vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ERNST_RENDER_SCALE float(1.)\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\n#define MIN_DIST 0.0100\n#define MAX_DIST 1000.\n#define ITERATION 100\n#define MAT_VOID vec3(-1)\n\n#define MAT_ERNST0_002 vec3(0.6921, 0.6105, 0.5361)\n#define MAT_ERNST0 vec3(0.8000, 0.8000, 0.8000)\n#define MAT_ERNST0_001 vec3(0.6921, 0.5156, 0.5499)\n\n#define AMB_COL vec3(0.6921, 0.8030, 1.)\n#define AMB_STRENGTH 0.3000\n#define FOG_COL vec3(1., 1., 1.)\n#define FOG_START -0.4200\n#define FOG_POW 1.\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3  Camera_pos;\nvec4  Camera_quat;\nfloat Camera_fov;\nvec3  sdLight001_dir;\nvec3  sdLight001_col;\nfloat sdLight001_clip_start;\nfloat sdLight001_clip_end;\nfloat sdLight001_softness;\n#define L0_dir sdLight001_dir\n#define L0_col sdLight001_col\n#define L0_str sdLight001_clip_start\n#define L0_end sdLight001_clip_end\n#define L0_sft sdLight001_softness\nvec3  sdLight002_dir;\nvec3  sdLight002_col;\nfloat sdLight002_clip_start;\nfloat sdLight002_clip_end;\nfloat sdLight002_softness;\n#define L1_dir sdLight002_dir\n#define L1_col sdLight002_col\n#define L1_str sdLight002_clip_start\n#define L1_end sdLight002_clip_end\n#define L1_sft sdLight002_softness\n\nvoid init()\n{\n\tCamera_pos = vec3(0., 0.6800, 19.9716);\n\tCamera_quat = vec4(0., 0., 0., 1.);\n\tCamera_fov = 0.3456;\n\tsdLight001_dir = normalize(vec3(-0.1719, 0.5966, 0.7839));\n\tsdLight001_col = vec3(1.2428, 1.2082, 1.0403);\n\tsdLight001_clip_start = 0.0500;\n\tsdLight001_clip_end = 30.;\n\tsdLight001_softness = 50.;\n\tsdLight002_dir = normalize(vec3(0.1719, -0.5966, -0.7839));\n\tsdLight002_col = vec3(0.0922, 0.0922, 0.0922);\n\tsdLight002_clip_start = 0.0500;\n\tsdLight002_clip_end = 30.;\n\tsdLight002_softness = 50.;\n\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid perspectiveCam(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    vec3 dir = quat_rotate(Camera_quat, vec3(0,0,-1)).xzy;\n    vec3 up = quat_rotate(Camera_quat, vec3(0,1,0)).xzy;\n    vec3 pos = Camera_pos.xzy;\n    float fov = Camera_fov;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\n\n\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}