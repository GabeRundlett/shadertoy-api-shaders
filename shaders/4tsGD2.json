{
    "Shader": {
        "info": {
            "date": "1425313244",
            "description": "outtake from https://www.pouet.net/prod.php?which=66150 :-)",
            "flags": 0,
            "hasliked": 0,
            "id": "4tsGD2",
            "likes": 1,
            "name": "robotiks",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "ahihi",
            "viewed": 69
        },
        "renderpass": [
            {
                "code": "#define TAU 6.283185307179586\n\nfloat scale(float l0, float r0, float l1, float r1, float x) {\n\treturn (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nvec2 rect2polar(vec2 p) {\n    return vec2(atan(p.y, p.x), length(p));\n}\n\nvec2 polar2rect(vec2 p) {\n    return vec2(cos(p.x) * p.y, sin(p.x) * p.y);\n}\n\n#define NO_MATERIAL 0\n#define HEAD_MATERIAL 1\n#define EYE_MATERIAL 2\n#define TOOTH_MATERIAL 3\n#define GROUND_MATERIAL 4\n\nstruct ObjectDistance {\n    float distance;\n    int material;\n};\n\nObjectDistance distanceUnion(ObjectDistance a, ObjectDistance b) {\n    if(a.distance < b.distance) {\n        return a;\n    } else {\n     \treturn b;\n    }\n}\n\nObjectDistance distanceDifference(ObjectDistance b, ObjectDistance a) {\n    if(-a.distance > b.distance) {\n        a.distance *= -1.0;\n        return a;\n    } else {\n        return b;\n    }        \n}\n\nObjectDistance sphere(float radius, int material, vec3 p) {\n  \treturn ObjectDistance(length(p) - radius, material);\n}\n\nObjectDistance box(vec3 b, int material, vec3 p)\n{\n  vec3 d = abs(p) - b;\n  return ObjectDistance(\n      min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),\n      material\n  );\n}\n\nObjectDistance cylinder(vec2 h, int material, vec3 p)\n{\n  vec2 d = abs(vec2(length(p.xy), p.z)) - h;\n  return ObjectDistance(\n      min(max(d.x, d.y), 0.0) + length(max(d, 0.0)),\n      material\n  );\n}\n\nObjectDistance ground(float y, int material, vec3 p) {\n     return ObjectDistance(p.y - y, material);   \n}\n\nvec3 focus() {\n    return vec3(0.0, 0.0, -4.0*iTime);\n}\n\n#define N_TEETH 6.0\nObjectDistance head(vec3 p) {\n    ObjectDistance od = box(vec3(1.0), HEAD_MATERIAL, p);\n    \n    float pad = 0.3;\n    float r_eye = 0.25;\n    \n    vec2 h_eye = vec2(r_eye, r_eye);\n    float d_eye = 1.0 - r_eye - pad;\n    vec3 p_eye = vec3(d_eye, d_eye, -(1.0 - h_eye.y + 0.01));\n    od = distanceDifference(\n    \tod,\n        cylinder(h_eye, EYE_MATERIAL, p - p_eye)\n    );\n    od = distanceDifference(\n      \tod,\n        cylinder(h_eye, EYE_MATERIAL, p - p_eye * vec3(-1.0, 1.0, 1.0))\n    );\n    \n    vec3 b_mouth = vec3(1.0 - pad, 0.3, 0.5);\n    vec3 p_mouth = vec3(0.0, -(1.0 - b_mouth.y - pad), -(1.0 - b_mouth.z + 0.01));\n    od = distanceDifference(\n        od,\n        box(b_mouth, HEAD_MATERIAL, p - p_mouth)\n    );\n    \n    \n    float pad_tooth = 0.01;\n    float l_mouth = -(b_mouth.x - pad_tooth);\n    float r_mouth = -l_mouth;\n    for(float i = 0.0; i < N_TEETH; i++) {\n        float t_tooth = abs(mod(iTime - 0.2*i, 2.0) - 1.0);\n        vec3 b_tooth = vec3(\n            b_mouth.x / N_TEETH - pad_tooth,\n            scale(0.0, 1.0, 0.2*b_mouth.y, 0.5*b_mouth.y, t_tooth),\n            0.08\n        );\n        vec3 p_tooth = vec3(\n            scale(0.0, 1.0, l_mouth, r_mouth, i/N_TEETH) + b_mouth.x / N_TEETH / 1.0,\n            p_mouth.y + b_mouth.y - b_tooth.y,\n            -0.9\n        );\n        od = distanceUnion(\n        \tod,\n            box(b_tooth, TOOTH_MATERIAL, p - p_tooth)\n        );\n        vec3 p_tooth1 = vec3(\n            p_tooth.x,\n            p_mouth.y - b_mouth.y + b_tooth.y,\n            p_tooth.z\n        );\n        od = distanceUnion(\n            od,\n            box(b_tooth, TOOTH_MATERIAL, p - p_tooth1)\n        );\n    }\n    \n    \n    return od;\n}\n\nObjectDistance robot(vec3 p) {\n    return head(p);\n}\n\nObjectDistance sceneDistance(vec3 p) {    \n\tObjectDistance od;\n    \n    p -= focus();\n    \n    od = ground(-1.0, GROUND_MATERIAL, p);\n    \n    vec3 q = vec3((mod(p.x, 2.0) - 1.0) * 1.05, p.yz);\n    float t = iTime - 0.2*floor(p.x/2.0);\n    float jump = abs(sin(2.0*t));\n    q.y -= jump;\n    \n    // do the rotation thing\n    vec2 q_zy_p = rect2polar(q.zy);\n    vec2 q2_zy_p = q_zy_p + vec2(-4.0*t, 0.0);\n    vec2 q2_zy = polar2rect(q2_zy_p);\n    vec3 q2 = vec3(q.x, q2_zy.yx);\n    \n    od = distanceUnion(\n        od,\n        robot(q2)\n    );\n            \n    return od;\n}\n\n#define THRESHOLD 0.0001\n#define MAX_STEP 0.5\n#define SHADOW_THRESHOLD 0.01\n#define MAX_ITERATIONS 256\n#define MAX_SHADOW_ITERATIONS 32\n#define NORMAL_DELTA 0.01\n#define MAX_DEPTH 60.0\n\nstruct MarchResult {\n    float length;\n    float distance;\n    int material;\n    int iterations;\n};\n    \nMarchResult march(vec3 origin, vec3 direction) {\n    MarchResult result = MarchResult(0.0, 0.0, NO_MATERIAL, 0);\n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n\t    ObjectDistance sd = sceneDistance(origin + direction * result.length);\n        result.distance = sd.distance;\n        result.material = sd.material;\n        result.iterations++;\n        \n        if(result.distance < THRESHOLD || result.length > MAX_DEPTH) {\n            break;\n        }\n        \n        //result.length += min(MAX_STEP, result.distance * (1.0 - 0.5*THRESHOLD));\n        result.length += result.distance * (1.0 - 0.5*THRESHOLD) /* * 1.4; // lol */;\n    }\n\n    if(result.length > MAX_DEPTH) {\n        result.material = NO_MATERIAL;\n    }\n    \n    return result;\n}\n\nfloat marchShadow(vec3 lightPos, vec3 surfacePos, float k) {\n    vec3 origin = lightPos;\n    vec3 target = surfacePos;\n    \n    vec3 travel = target - origin;\n    vec3 forward = normalize(travel);\n    float maxLength = length(travel) * 0.9;\n    \n    float length = 0.0;\n    float distance = 0.0;\n    float light = 1.0;\n    int iterations = 0;\n    for(int i = 0; i < MAX_SHADOW_ITERATIONS; i++) {\n        if(length >= maxLength - SHADOW_THRESHOLD) {\n         \tbreak;\n        }\n        \n        ObjectDistance od = sceneDistance(origin + forward * length);\n        distance = od.distance;\n        \n        if(distance < SHADOW_THRESHOLD) {\n            return 0.0;\n        }\n        \n        light = min(light, k * distance / length);\n        length += distance * 0.999;\n        \n        iterations++;\n    }\n\n    //return 1.0 - float(iterations) / float(MAX_SHADOW_ITERATIONS);\n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pxPos = 2.0*(0.5 * iResolution.xy - fragCoord.xy) / iResolution.xx;\n    \n    vec2 camXZ = polar2rect(vec2(-TAU/4.0 + 0.3 * iTime, 3.0));\n  \tvec3 camPos = vec3(camXZ.x, 1.0 + 0.5 * sin(1.0 * iTime), camXZ.y);\n    camPos = focus() + vec3(2.0*sin(0.6*iTime), 2.0, -6.5);\n    \n    vec3 camLook = focus();\n    \n    vec3 camUp = vec3(0.0, 1.0, 0.0); \n    vec3 camForward = normalize(camLook - camPos);\n    vec3 camLeft = normalize(cross(camUp, camForward));\n    vec3 camUp2 = cross(camForward, camLeft);\n    vec3 camPosForward = camPos + camForward;\n    vec3 screenPos = camPosForward - pxPos.x * camLeft - pxPos.y * camUp2;\n    vec3 rayForward = normalize(screenPos - camPos);\n    \n    MarchResult mr = march(camPos, rayForward);\n    \t\n    vec3 rayEnd = camPos + mr.length * rayForward;\n    vec3 color;\n    vec3 bgColor = vec3(0.1);\n    \n    if(mr.material == NO_MATERIAL) {\n        color = bgColor;\n    } else {\n        vec3 baseColor;\n        \n        if(mr.material == HEAD_MATERIAL) {\n            baseColor = vec3(0.8);\n        } else if(mr.material == EYE_MATERIAL) {\n            baseColor = vec3(1.0, 0.0, 0.0);\n        } else if(mr.material == TOOTH_MATERIAL) {\n            baseColor = vec3(1.0);\n        } else if(mr.material == GROUND_MATERIAL) {\n            float tile = mod(floor(rayEnd.x) + floor(rayEnd.z), 2.0);\n            \n            if(tile < 1.0) {\n\t         \tbaseColor = vec3(0.2);\n            } else {\n                baseColor = vec3(0.3);\n            }\n        }\n        \n        float deltaTwice = 2.0 * NORMAL_DELTA;\n        vec3 dx = vec3(NORMAL_DELTA, 0.0, 0.0);\n        vec3 dy = vec3(0.0, NORMAL_DELTA, 0.0);\n        vec3 dz = vec3(0.0, 0.0, NORMAL_DELTA);\n        vec3 normal = normalize(vec3(\n            /*(sceneDistance(rayEnd + dx).distance - sceneDistance(rayEnd - dx).distance) / deltaTwice,\n            (sceneDistance(rayEnd + dy).distance - sceneDistance(rayEnd - dy).distance) / deltaTwice,\n            (sceneDistance(rayEnd + dz).distance - sceneDistance(rayEnd - dz).distance) / deltaTwice*/\n            (sceneDistance(rayEnd + dx).distance) / NORMAL_DELTA,\n            (sceneDistance(rayEnd + dy).distance) / NORMAL_DELTA,\n            (sceneDistance(rayEnd + dz).distance) / NORMAL_DELTA\n        ));\n\n       \tvec2 lightXZ = polar2rect(vec2(-0.5 * iTime, 3.0));\n        vec3 lightPos = vec3(lightXZ.x, 5.0, lightXZ.y);\n\t\tlightPos = camPos * vec3(1.0, 1.0, 1.0);\n        \n        float ambient = 0.2;\n        float diffuse = max(0.0, dot(normal, normalize(lightPos - rayEnd)));\n        float specular = pow(diffuse, 16.0);\n\t\tfloat shadow = 1.0;\n        shadow = marchShadow(lightPos, rayEnd, 32.0);\n\n        color = ((ambient + shadow * diffuse) * baseColor + specular) * (1.0 - mr.length * 0.01);\n        //color = vec3(rayIterations / MAX_TRACE_ITERATIONS, 0.0, shadow);\n\n    }\n        \n\t//color = mix(vec3(0.0), vec3(0.0, 1.0, 0.0), float(mr.iterations)/float(MAX_ITERATIONS));\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}