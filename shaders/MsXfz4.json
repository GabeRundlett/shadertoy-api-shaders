{
    "Shader": {
        "info": {
            "date": "1495029295",
            "description": "Example Path Tracer which does Next Event Estimation and Multiple Importance Sampling.\nSingle pass version: https://www.shadertoy.com/view/ldBcDt",
            "flags": 32,
            "hasliked": 0,
            "id": "MsXfz4",
            "likes": 171,
            "name": "Path Tracer MIS (progressive)",
            "published": 3,
            "tags": [
                "pathtracer",
                "microfacet",
                "pbr",
                "pt",
                "render",
                "ggx"
            ],
            "usePreview": 1,
            "username": "koiava",
            "viewed": 19702
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Display : average down and do gamma adjustment\n\nfloat lineDistance(vec2 a, vec2 b, vec2 p) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n\tfloat t = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa-ba*t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    \n    // color grading and vigneting\n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    const vec2 slider_pos = vec2(30.0, 30.0);\n    const float slider_size = 200.0;\n    const float slider_width = 8.0;\n    if (lineDistance(slider_pos + vec2(0.0, -slider_width), slider_pos + vec2(slider_size, -slider_width),  fragCoord.xy) < 1.0 ||\n        lineDistance(slider_pos + vec2(0.0, slider_width), slider_pos + vec2(slider_size, slider_width),  fragCoord.xy) < 1.0 ||\n        lineDistance(slider_pos + vec2(0.0, -slider_width), slider_pos + vec2(0.0, slider_width),  fragCoord.xy) < 1.0 ||\n        lineDistance(slider_pos + vec2(slider_size, -slider_width), slider_pos + vec2(slider_size, slider_width),  fragCoord.xy) < 1.0 \n             ) {\n        col = vec3(0.3, 0.3, 0.3);\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PIXEL_SAMPLES \t\t1\t\t//samples per pixel. Increase for better image quality\n#define DL_SAMPLES\t\t\t1\t\t//direct light samples\n#define MAX_DEPTH\t\t\t4\t\t//GI depth\n#define LENS_SIZE\t\t\t0.3\t\t//depth of field\n#define CLAMP_VALUE\t\t\t16.0\t\t//biased rendering\n//#define CLAMP_CAUSTICS\t\t\t\t//biased rendering\n#define TEXTURES\t\t\t//uncomment to enable textures\n#define NORMAL_MAPS\t\t//uncomment to enable normal mapping(textures are necessery for normal mapping)\n\n#define SPHERE_LIGHT\n//#define CONCENTRIC_DISK\n\nconst vec3 backgroundColor = vec3( 0.0 );\n\n//pos in uv space where we store various data\nconst vec2 acc_start_uv = vec2(0.0); //accumulation start frame\nconst vec2 camera_pos_uv = vec2(1.0, 0.0); //camera pos\nconst vec2 camera_dir_uv = vec2(2.0, 0.0); //camera pos\n\nint getAccStart() {\n\tif( iMouse.z > 0.0 ) {\n        return iFrame;\n    } else {\n        return int(texture( iChannel3, (acc_start_uv + vec2(0.5, 0.5))/iResolution.xy ).x);\n    }\n}\n\nvec4 LoadVec4(vec2 uv) { return texture( iChannel3, (uv + vec2(0.5, 0.5))/iResolution.xy ); }\n    \nbool is_inf(float val) {\n\treturn val != val;\n    //return isinf(val);\t//webGL 2.0 is required\n}\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n\n\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n\n    \n#define SURFACE_ID_BASE\t0\n#define LIGHT_ID_BASE\t64\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_DISK\t\t4\n#define OBJ_TORUS\t\t5\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n\n//Weighted sum of Lambertian and Blinn brdfs\nstruct Material {\n    vec3 diffuse_color_;\n    int diffuse_color_tex_;\n    vec3 specular_color_;\n    float specular_roughness_;\n    int specular_roughness_tex_;\n    float specular_weight_;\n    int specular_weight_tex_;\n    int normal_map_;\n    float tex_scale_;\n};\n    \nstruct Light {\n    vec3 color_;\n    float intensity_;\n};\n    \n\n    \nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n    \n// ************ SCENE ***************\nLight lights[2];\nMaterial materials[7];\nObject objects[8];\nCamera camera;\nCamera cameraOld;\n//***********************************\n#if __VERSION__ < 300\nMaterial getMaterial(int i) {\n    if(i==0) return materials[0]; else\n        if(i==1) return materials[1]; else\n            if(i==2) return materials[2]; else\n                if(i==3) return materials[3]; else\n                    if(i==4) return materials[4]; else\n                        if(i==5) return materials[5]; else\n                            return materials[6];\n}\n\nLight getLight(int i) {\n    if(i==0) return lights[0]; else\n        return lights[1];\n    //return lights[i];\n}\n#else\nMaterial getMaterial(int i) { return materials[i]; }\nLight getLight(int i) { return lights[i]; }\n#endif\n\n\nvec3 getColor(vec2 uv, int tex) {\n#ifdef TEXTURES\n    if(tex==0)\treturn /*(int(mod((uv.x+uv.y)*10.0,2.0)) == 1)? vec3(0.05) : vec3(1.0);//*/texture( iChannel0, uv).xyz; else\n    if(tex==1)\treturn texture( iChannel1, uv).xyz; else\n    \t\t\treturn texture( iChannel2, uv).xyz;\n#else\n    if(tex==0)\treturn vec3(0.8, 0.5, 0.3);\n    if(tex==1)\treturn vec3(0.5, 0.5, 0.6);\n\t\t\t\treturn vec3(0.7, 0.7, 0.7);\n#endif\n}\n\n#define GET_COLORS(smplr, idx) duv = vec2(1.0) / iChannelResolution[idx].xy; c = getColor(uv , smplr); c1 = getColor( uv + vec2(duv.x, 0.0), smplr); c2 = getColor(uv - vec2(duv.x, 0.0),  smplr); c3 = getColor(uv + vec2(0.0, duv.y), smplr); c4 = getColor(uv - vec2(0.0, duv.y), smplr);\nvec3 getNormal(vec2 uv, int tex ) {\n#ifdef NORMAL_MAPS\n    float heightScale = 0.004;\n    float dHdU, dHdV;\n    \n    float hpx, hmx, hpy, hmy, h0;\n    vec3 c, c1, c2, c3, c4;\n    vec2 duv;\n    \n#if __VERSION__ < 300\n    if(tex==0){\n        GET_COLORS(0, 0);\n    } else if(tex==1) {\n        GET_COLORS(1, 1);\n    } else {\n        GET_COLORS(2, 2);\n    }\n#else\n    switch(tex){\n        case 0: {GET_COLORS(0, 0);}\n        case 1: {GET_COLORS(1, 1);}\n        case 2: {GET_COLORS(2, 2);}\n    }\n#endif\n    \n    h0\t= heightScale * dot(c , vec3(1.0/3.0));\n    hpx = heightScale * dot(c1, vec3(1.0/3.0));\n    hmx = heightScale * dot(c2, vec3(1.0/3.0));\n    hpy = heightScale * dot(c3, vec3(1.0/3.0));\n    hmy = heightScale * dot(c4, vec3(1.0/3.0));\n    dHdU = (hmx - hpx) / (2.0 * duv.x);\n    dHdV = (hmy - hpy) / (2.0 * duv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0));\n#else\n    return vec3(0.0, 0.0, 1.0);\n#endif\n}\n\nvec3 getRadiance(vec2 uv) {\n    return /*getColor(uv, 2)*lights[0].color_**/vec3(1.0, 1.0, 1.0)*lights[0].intensity_;\n}\n\nvoid createMaterial(vec3 diff,\n                    int diff_tex,\n                    vec3 spec,\n                    float roughness,\n                    int roughness_tex,\n                   \tfloat weight,\n                    int weight_tex,\n                    int normal_map,\n                    float tex_scale,\n                    out Material mtl) {\n    mtl.diffuse_color_ = diff;\n    mtl.diffuse_color_tex_ = diff_tex;\n    mtl.specular_color_ = spec;\n    mtl.specular_roughness_ = roughness;\n    mtl.specular_roughness_tex_ = roughness_tex;\n    mtl.specular_weight_ = weight;\n    mtl.specular_weight_tex_ = weight_tex;\n    mtl.normal_map_ = normal_map;\n    mtl.tex_scale_ = tex_scale;\n}\n\nvoid createLight(vec3 color, float intensity, out Light light) {\n    light.color_ = color;\n    light.intensity_ = intensity;\n}\n\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createTorus( mat4 transform, float R, float r, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_TORUS;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = R*R;\n    obj.params_[1] = r*r;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//min x\n    obj.params_[1] = minY;\t\t\t//min y\n    obj.params_[2] = maxX;\t\t\t//max x\n    obj.params_[3] = maxY;\t\t\t//max y\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createDisk(mat4 transform, float r, float R, int mtl, out Object obj) {\n    obj.type_ = OBJ_DISK;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r*r;\n    obj.params_[1] = R*R;\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\n// ************************   Scattering functions  *************************\nbool sameHemisphere(in vec3 n, in vec3 a, in vec3 b){\n\treturn ((dot(n,a)*dot(n,b))>0.0);\n}\n\nbool sameHemisphere(in vec3 a, in vec3 b){\n\treturn (a.z*b.z>0.0);\n}\n\nfloat cosTheta(vec3 w) { return w.z; }\nfloat cosTheta2(vec3 w) { return cosTheta(w)*cosTheta(w); }\nfloat absCosTheta(vec3 w) { return abs(w.z); }\nfloat sinTheta2(vec3 w) { return max(0.0, 1.0 - cosTheta2(w)); }\nfloat sinTheta(vec3 w) { return sqrt(sinTheta2(w)); }\nfloat tanTheta2(vec3 w) { return sinTheta2(w) / cosTheta2(w); }\nfloat tanTheta(vec3 w) { return sinTheta(w) / cosTheta(w); }\n\nfloat cosPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 1.0 : clamp(w.x / sin_Theta, -1.0, 1.0); }\nfloat sinPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 0.0 : clamp(w.y / sin_Theta, -1.0, 1.0); }\nfloat cosPhi2(vec3 w) { return cosPhi(w) * cosPhi(w); }\nfloat sinPhi2(vec3 w) { return sinPhi(w) * sinPhi(w); }\n\nfloat ggx_eval(vec3 wh, float alphax, float alphay) {\n    float tan2Theta = tanTheta2(wh);\n    if (is_inf(tan2Theta)) return 0.;\n    float cos4Theta = cosTheta2(wh) * cosTheta2(wh);\n    float e = ((cosPhi2(wh) + sinPhi2(wh)) / (alphax * alphay)) * tan2Theta;\n    return 1.0 / (PI * (alphax * alphay) * cos4Theta * (1.0 + e) * (1.0 + e));\n}\n\n//Here we sample only visible normals, so it takes view direction wi\n//Visible normal sampling was first presented here: https://hal.archives-ouvertes.fr/hal-01509746\n//We use method which first converts everything is space where alpha is 1 \n//does uniform sampling of visible hemisphere and converts sample back\n//https://hal.archives-ouvertes.fr/hal-01509746\nvec3 ggx_sample(vec3 wi, float alphax, float alphay, vec2 xi) {\n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(xi.x);\n    float phi = (xi.y < a) ? xi.y / a*PI : PI + (xi.y - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((xi.y < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\n\nfloat ggx_lambda(vec3 w, float alphax, float alphay) {\n    float absTanTheta = abs(tanTheta(w));\n    if (is_inf(absTanTheta)) return 0.;\n    // Compute _alpha_ for direction _w_\n    float alpha_ = sqrt((cosPhi2(w) + sinPhi2(w)) * (alphax * alphay));\n    float alpha2Tan2Theta = (alpha_ * absTanTheta) * (alpha_ * absTanTheta);\n    return (-1.0 + sqrt(1.0 + alpha2Tan2Theta)) / 2.0;\n}\n\nfloat ggx_g1(vec3 w, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(w, alphax, alphay));\n}\n\nfloat ggx_g(vec3 wo, vec3 wi, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(wo, alphax, alphay) + ggx_lambda(wi, alphax, alphay));\n}\n\nfloat ggx_pdf(vec3 wi, vec3 wh, float alphax, float alphay) {\n    return ggx_eval(wh, alphax, alphay) * ggx_g1(wi, alphax, alphay) * abs(dot(wi, wh)) / abs(wi.z);\n}\n\nfloat SchlickFresnel(in float Rs, float cosTheta) {\n    return Rs + pow(1.0 - cosTheta, 5.) * (1. - Rs);\n}\n\nvec3 mtlEval(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    float alpha = mtl.specular_roughness_;\n    \n    if(!sameHemisphere(E_local, L_local)) {\n        return vec3(0.0);\n    }\n    \n    //Specular reflection ***********************************\n    float cosThetaO = abs(E_local.z), cosThetaI = abs(L_local.z);\n    vec3 wh = L_local + E_local;\n    // Handle degenerate cases for microfacet reflection\n    if (cosThetaI == 0.0 || cosThetaO == 0.0) return vec3(0.);\n    if (wh.x == 0.0 && wh.y == 0.0 && wh.z == 0.0) return vec3(0.);\n    \n    wh = normalize(wh);\n    \n    float F = SchlickFresnel(0.1, dot(L_local, wh));\n    vec3 spec_Refl = \tmtl.specular_color_ * \n        \t\t\t\tggx_eval(wh, alpha, alpha) *\n        \t\t\t\tggx_g(E_local, L_local, alpha, alpha) *\n        \t\t\t\tF / (4.0 * cosThetaI * cosThetaO);\n    \n    vec3 diff_refl = \tvec3(INV_PI) * \n        \t\t\t\tmtl.diffuse_color_ * \n        \t\t\t\t(vec3(1.0) - F);\n    \n    return \tmix(diff_refl, spec_Refl, mtl.specular_weight_);\n}\n\nfloat pdfDiffuse(in vec3 L_local) {\n    return INV_PI * L_local.z;\n}\n\nfloat pdfSpecular(in float alphau, in float alphav, in vec3 E_local, in vec3 L_local) {\n    vec3 wh = normalize(E_local + L_local);\n    return ggx_pdf(E_local, wh, alphau, alphav) / (4.0 * dot(E_local, wh));\n}\n\nvec3 mtlSample(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec2 xi, out vec3 L, out float pdf, out float spec) {\n    float alpha = mtl.specular_roughness_;\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    //convert directions to local space\n    vec3 E_local = inv_trans * E;\n    vec3 L_local;\n    \n    if (E_local.z == 0.0) return vec3(0.);\n    \n    //Sample specular or diffuse lobe based on fresnel\n    if(rnd() < mtl.specular_weight_) {\n    \tvec3 wh = ggx_sample(E_local, alpha, alpha, xi);\n        L_local = reflect(-E_local, wh);\n        pdf = pdfSpecular(alpha, alpha, E_local, L_local);\n    } else {\n        L_local = sampleHemisphereCosWeighted( xi );\n        pdf = pdfDiffuse(L_local);\n    }\n    \n    //convert directions to global space\n    L = trans*L_local;\n    \n    if(!sameHemisphere(Ns, E, L) || !sameHemisphere(Ng, E, L)) {\n        pdf = 0.0;\n    }\n    \n    return mtlEval(mtl, Ng, Ns, E, L);\n}\n\nfloat mtlPdf(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    float alpha = mtl.specular_roughness_;\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    if(!sameHemisphere(Ng, E_local, L_local)) {\n        return 0.0;\n    }\n    float diff_pdf = abs(L_local.z)*INV_PI;\n    \n    if (!sameHemisphere(E_local, L_local)) return 0.0;\n    vec3 wh = normalize(E_local + L_local);\n    float spec_pdf = ggx_pdf(E_local, wh, alpha, alpha) / (4.0 * dot(E_local, wh));\n    \n    return mix(diff_pdf, spec_pdf, mtl.specular_weight_);\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, vec3(obj.params_[0], obj.params_[1], obj.params_[2]), vec3(obj.params_[3], obj.params_[4], obj.params_[5]), forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_DISK ) {\n        hitResult = rayDiskIntersection( rayLocal, obj.params_[0], obj.params_[1], forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.mtl_id_ = obj.mtl_id_;\n        \n        return true;\n    } else {\n    \treturn false;\n    }\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    \n    CHECK_OBJ( objects[0] )\n    CHECK_OBJ( objects[1] )\n    CHECK_OBJ( objects[2] )\n    CHECK_OBJ( objects[3] )\n    CHECK_OBJ( objects[4] )\n    CHECK_OBJ( objects[5] )\n    CHECK_OBJ( objects[6] )\n    CHECK_OBJ( objects[7] )\n    \n    return ( nearestDist < 1000.0 );\n}\n\nvoid initScene() {\n    float time = 100.0;//iTime;\n    \n    //create lights\n    createLight(vec3(1.0, 1.0, 0.9), 40.0, lights[0]);\n    \n    //Create materials\n    createMaterial(vec3(0.6, 1.0, 0.6), -1, vec3(0.5, 1.0, 0.5), 0.15, -1, 0.6, -1, 2, 1.0, materials[0]);\n    createMaterial(vec3(1.0, 1.0, 1.0), 0, vec3(1.0, 1.0, 1.0), 0.0, 0, 0.2, -1, 0, 2.0, materials[1]);\n    createMaterial(vec3(0.3, 0.5, 1.0), 1, vec3(1.0, 1.0, 1.0), 0.0, 1, 0.4, 1, 1, 1.0, materials[2]);\n    createMaterial(vec3(0.5, 0.5, 0.5), -1, vec3(0.9, 0.9, 1.0), 0.03, 2, 1.0, -1, -1, 1.0, materials[3]);\n    createMaterial(vec3(1.0, 1.0, 1.0), 2, vec3(1.0, 1.0, 1.0), 0.0, 2, 0.4, 2, 2, 1.0, materials[4]);\n    \n    //init lights\n    float r = 1.0;\n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float x = xFactor*7.0;\n    float z = -3.0-yFactor*5.0;\n    float a = -1.2+sin(time*0.23);\n    mat4 trans = createCS(\tvec3(x, 5.0+sin(time), z),\n                          \tvec3(0.0, sin(a), cos(a)),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n#ifdef SPHERE_LIGHT\n    createSphere(trans, r, LIGHT_ID_BASE+0, objects[0] );\n#else\n    createPlane(trans, -2.0, -1.0, 2.0, 1.0, LIGHT_ID_BASE+0, objects[0]);\n#endif\n    \n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, SURFACE_ID_BASE+1, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -4.0, 10.0, 2.0, SURFACE_ID_BASE+1, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, SURFACE_ID_BASE+1, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.5, -0.3, -2.0, 1.0 ));\n\n    createSphere(trans, 0.7, SURFACE_ID_BASE+2, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 0.0, -4.5, 1.0 ));\n\n    createSphere(trans, 1.0, SURFACE_ID_BASE+3, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), SURFACE_ID_BASE+0, objects[6]);\n    \n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 3.5, 0.5, -4.2, 1.0 ));\n\n    createSphere(trans, 1.5, SURFACE_ID_BASE+4, objects[7] );\n    /*\n    //torus\n    trans = createCS(\tvec3(3.0, 1.0, -4.0),\n                        vec3(-0.5, 0.0, 0.5),\n                  \t    vec3(1.0, 0.0, 0.0));\n    createTorus(trans, 1.5, 0.3, SURFACE_ID_BASE+4, objects[7]);*/\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin float fovV,\n                \tin float radius,\n                \tin float focus_dist,\n                \tout Camera c\n               ) {\n    const vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    c.rotate[2] = normalize( pos-target ); //back\n\tc.rotate[0] = normalize( cross( upDir, c.rotate[2] ) ); //right\n\tc.rotate[1] = cross( c.rotate[2], c.rotate[0] ); //up\n    c.fovV = fovV;\n    c.pos = pos;\n    c.focusDist = focus_dist;\n    c.lensSize = radius;\n    c.iPlaneSize = 2.*tan(0.5*c.fovV)*vec2(iResolution.x/iResolution.y,1.);\n}\n\n\nRay genRay( in Camera c, in vec2 uv, in vec2 xi ) {\n    Ray ray;\n    \n    vec2 ixy = (uv-0.5)*c.iPlaneSize;\n\tvec3 dirLocal = normalize(vec3(ixy, -1.0));\n    vec3 posGlobal = c.pos;//cs_.posToGlobal(vec3(0.0));\n\tvec3 dirGlobal = c.rotate*dirLocal;\n\treturn Ray(posGlobal, dirGlobal);\n\n    /*\n\tvec2 ixy = (uv - 0.5) * c.iPlaneSize;\n    \n    if( c.lensSize > EPSILON ) {\n        vec2 uv = uniformPointWithinCircle( c.lensSize, xi );\n        vec3 newPos = c.pos + c.rotate[0]*uv.x*c.lensSize + c.rotate[1]*uv.y*c.lensSize;\n        vec3 focusPoint = c.pos - c.focusDist*c.rotate[2];\n        vec3 newBack = normalize(newPos - focusPoint);\n        vec3 newRight = normalize( cross( c.rotate[1], newBack ) );\n        vec3 newUp = cross( newBack, newRight );\n        mat3 newRotate;\n        newRotate[0] = newRight;\n        newRotate[1] = newUp;\n        newRotate[2] = newBack;\n\n\n        ray.origin = newPos;\n        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    } else {\n        ray.origin = c.pos;\n        ray.dir = c.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    }\n\n\treturn ray;*/\n}\n\nvec2 getPixel(in Camera c, in vec3 pos) {\n    vec3 posLocal = inverse(c.rotate) * (pos - c.pos);\n    vec3 dirLocal = normalize(posLocal);\n\n    vec2 uv = -vec2(dirLocal.x / dirLocal.z, dirLocal.y / dirLocal.z);\n\n    //convert uv from [-iPlaneSize*0.5, iPlaneSize.x*0.5) range to [0.0, 1.0)\n    uv = (uv + c.iPlaneSize*0.5) / c.iPlaneSize;\n    uv -= vec2(0.5) / iResolution.xy;//fix for half pixel shift \n    return uv;\n}\n\n#ifdef SPHERE_LIGHT\nvec3 sampleLightSource( \tin vec3 x,\n                          \tfloat Xi1, float Xi2,\n                          \tout LightSamplingRecord sampleRec ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    \n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    \n    float sin_theta_max_2 = sph_r2 / dc_2;\n\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    float cos_theta = mix( cos_theta_max, 1.0, Xi1 );\n    float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    float sin_theta = sqrt(sin_theta_2);\n    sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );\n    sampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n        \n    //Calculate intersection distance\n\t//http://ompf2.com/viewtopic.php?f=3&t=1914\n    sampleRec.d = dc*cos_theta - sqrt(sph_r2 - dc_2*sin_theta_2);\n    \n    return lights[0].color_*lights[0].intensity_;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                            in vec3 wi,\n                           \tin float d,\n                            in float cosAtLight ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    float solidangle;\n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sph_r2 ) {\n    \tfloat sin_theta_max_2 = clamp( sph_r2 / dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0/solidangle;\n}\n#else\nvec3 sampleLightSource(\t\tin vec3 x,\n                          \tfloat Xi1, float Xi2,\n                       out LightSamplingRecord sampleRec) {\n    float min_x = objects[0].params_[0];\t\t\t//min x\n    float min_y = objects[0].params_[1];\t\t\t//min y\n    float max_x = objects[0].params_[2];\t\t\t//max x\n    float max_y = objects[0].params_[3];\t\t\t//max y\n    float dim_x = max_x - min_x;\n    float dim_y = max_y - min_y;\n    vec3 p_local = vec3(min_x + dim_x*Xi1, min_y + dim_y*Xi2, 0.0);\n    vec3 n_local = vec3(0.0, 0.0, 1.0);\n    vec3 p_global = toVec3( objects[0].transform_*vec4(p_local, 1.0) );\n    vec3 n_global = toVec3( objects[0].transform_*vec4(n_local, 0.0) );\n    \n    float pdfA = 1.0 / (dim_x*dim_y);\n    sampleRec.w = p_global - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    float cosAtLight = dot(n_global, -sampleRec.w);\n    vec3 L = cosAtLight>0.0?getRadiance(vec2(Xi1,Xi2)):vec3(0.0);\n    sampleRec.pdf = PdfAtoW(pdfA, sampleRec.d*sampleRec.d, cosAtLight);\n    \n\treturn L;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                               in vec3 wi,\n                             \tfloat d,\n                              \tfloat cosAtLight\n                             ) {\n    float min_x = objects[0].params_[0];\t\t\t//min x\n    float min_y = objects[0].params_[1];\t\t\t//min y\n    float max_x = objects[0].params_[2];\t\t\t//max x\n    float max_y = objects[0].params_[3];\t\t\t//max y\n    float dim_x = max_x - min_x;\n    float dim_y = max_y - min_y;\n    float pdfA = 1.0 / (dim_x*dim_y);\n    return PdfAtoW(pdfA, d*d, cosAtLight);\n}\n#endif\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.mtl_id_ >= LIGHT_ID_BASE );\n}\n\nbool isVisible(in vec3 from, in vec3 to) {\n    vec3 d = to - from;\n    float l = length(d);\n    d /= l;\n    \n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    bool hit = raySceneIntersection( Ray(from, d), EPSILON, true, tmpHit, distToHit );\n    \n    return (!hit || distToHit > l);\n}\n\nLight pickOneLight(out float lightPickingPdf) {\n    lightPickingPdf = 1.0;\n    return lights[0];\n}\n\nvoid fixMtl(inout Material mtl, vec2 uv, out vec3 ns) {\n    uv *= mtl.tex_scale_;\n    if(mtl.diffuse_color_tex_!=-1){\n        mtl.diffuse_color_ = getColor(uv, mtl.diffuse_color_tex_);\n    }\n    \n    if(mtl.specular_roughness_tex_!=-1){\n        mtl.specular_roughness_ = (1.0 - sqrt(getColor(uv, mtl.specular_roughness_tex_).x))*0.8;\n    } else {\n        mtl.specular_roughness_ = sqrt(mtl.specular_roughness_);\n    }\n    \n    if(mtl.specular_weight_tex_!=-1){\n        mtl.specular_weight_ = (getColor(uv, mtl.specular_weight_tex_).x)*0.6;\n    }\n    if(mtl.normal_map_!=-1){\n        ns = getNormal(uv, mtl.normal_map_ );\n    } else {\n        ns = vec3(0.0, 0.0, 1.0);\n    }\n}\n\nvec3 sampleBSDF(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex,\n                \tout vec3 wo,\n                \tout float brdfPdfW,\n                \tout vec3 fr,\n                \tout bool hitRes,\n                \tout SurfaceHitInfo hit,\n               \t\tout float spec) {\n    float strataSize = 1.0 / float(strataCount);\n    vec3 Lo = vec3(0.0);\n    for(int i=0; i<DL_SAMPLES; i++){\n        vec2 xi = vec2(rnd(), strataSize * (float(strataIndex) + rnd()));\n        fr = mtlSample(mtl, ng, ns, wi, xi, wo, brdfPdfW, spec);\n        \n        //fr = eval(mtl, ng, ns, wi, wo);\n\n        float dotNWo = dot(wo, ns);\n        //Continue if sampled direction is under surface\n        if ((dot(fr,fr)>0.0) && (brdfPdfW > EPSILON)) {\n            Ray shadowRay = Ray(x, wo);\n\n            //abstractLight* pLight = 0;\n            float cosAtLight = 1.0;\n            float distanceToLight = -1.0;\n            vec3 Li = vec3(0.0);\n\n            {\n                float distToHit;\n\n                if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {\n                    if(hit.mtl_id_>=LIGHT_ID_BASE) {\n                        distanceToLight = distToHit;\n                        cosAtLight = dot(hit.normal_, -wo);\n                        if(cosAtLight > 0.0) {\n                            Li = getRadiance(hit.uv_);\n                            //Li = lights[0].color_*lights[0].intensity_;\n                        }\n                    } else {\n                        hitRes = true;\n                    }\n                } else {\n                    hitRes = false;\n                    //TODO check for infinite lights\n                }\n            }\n\n            if (distanceToLight>0.0) {\n                if (cosAtLight > 0.0) {\n                    vec3 contribution = (Li * fr * dotNWo) / brdfPdfW;\n\n                    if (useMIS/* && !(mtl->isSingular())*/) {\n                        float lightPickPdf = 1.0;//lightPickingPdf(x, n);\n                        float lightPdfW = sampleLightSourcePdf( x, wi, distanceToLight, cosAtLight );\n                        //float lightPdfW = sphericalLightSamplingPdf( x, wi );//pLight->pdfIlluminate(x, wo, distanceToLight, cosAtLight) * lightPickPdf;\n\n                        contribution *= misWeight(brdfPdfW, lightPdfW);\n                    }\n\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 salmpleLight(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                  \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex ) {\n    vec3 Lo = vec3(0.0);\t//outgoing radiance\n\n    for(int i=0; i<DL_SAMPLES; i++) {\n        float lightPickingPdf;\n        Light light = pickOneLight(lightPickingPdf);\n\n        vec3 wo;\n        float lightPdfW, lightDist;\n\n        LightSamplingRecord rec;\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(strataCount);\n        Xi2 = strataSize * (float(strataIndex) + Xi2);\n\n        vec3 Li = sampleLightSource( x, Xi1, Xi2, rec );\n        //vec3 Li = sampleSphericalLight( x, Xi1, Xi2, rec );\n        wo = rec.w;\n        lightPdfW = rec.pdf;\n        lightDist = rec.d;\n        lightPdfW *= lightPickingPdf;\n\n        float dotNWo = dot(wo, ns);\n\n        if ((dot(wo, ng) > 0.0) && (dotNWo > 0.0) && (lightPdfW > EPSILON)) {\n            vec3 fr = mtlEval(mtl, ng, ns, wi, wo);\n            if(dot(fr,fr)>0.0) {\n                Ray shadowRay = Ray(x, wo);\n                if (isLightVisible( shadowRay )) {\n                    vec3 contribution = (Li * fr * dotNWo) / lightPdfW;\n\n                    if (useMIS /*&& !(light->isSingular())*/) {\n                        float brdfPdfW = mtlPdf(mtl, ng, ns, wi, wo);\n                        contribution *= misWeight(lightPdfW, brdfPdfW);\n                    }\n\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 Radiance( in Ray r, int strataCount, int strataIndex ) {\n    vec3 Lo = vec3(0.0), fr, directLight, pathWeight = vec3(1.0, 1.0, 1.0);\n    vec3 wo;\n    float woPdf;\n    float dotWoN;\n    bool hitResult;\n\n    //Calculate first intersections to determine first scattering event\n    Ray ray = r;\n    SurfaceHitInfo event;\n    SurfaceHitInfo nextEvent;\n    float dist = -1.0;\n    if(!raySceneIntersection( ray, 0.0, false, event, dist )) {\n        return Lo;\n    } else {\n        //We have to add emmision component on first hit\n        if( event.mtl_id_ >= LIGHT_ID_BASE ) {\n            Light light = getLight(event.mtl_id_ - LIGHT_ID_BASE);\n            float cosAtLight = dot(event.normal_, -ray.dir);\n            if(cosAtLight > 0.0) {\n                Lo = getRadiance(event.uv_);\n                //Lo = light.color_*light.intensity_;\n            }\n        }\n    }\n    \n    float prev_spec;\n\n    for (int i = 0; i < MAX_DEPTH; i++) {\n        if(event.mtl_id_>=LIGHT_ID_BASE){\n        \tbreak;\n    \t}\n        \n        vec3 x = event.position_;\n        vec3 wi = -ray.dir;\n        if(dot(wi, event.normal_) < 0.0) {\n            event.normal_ *= -1.0;\n        }\n        \n        Material mtl = getMaterial(event.mtl_id_);\n    \tvec3 ng = event.normal_, ns;\n    \tfixMtl(mtl, event.uv_, ns);\n    \n        mat3 frame;\n        frame[0] = event.tangent_;\n        frame[1] = cross( ng, event.tangent_ );\n        frame[2] = ng;\n        ns = frame*ns;\n        \n        if (dot(wi,ns) < 0.0) { break; }\n        \n        if(i!=0) {\n            strataCount = 1; strataIndex = 0;\n        }\n        \n        float spec;\n\n        //Calculate direct light with 'Light sampling' and 'BSDF sampling' techniques\n        //Both techniques are weighted with MIS.\n        //see page 252 \"glossy highlights from area light sources\" in Eric Veachs thesis\n\t\t//https://graphics.stanford.edu/papers/veach_thesis/thesis-bw.pdf\n        //In addition BSDF sampling determines next hit event where we want to continue path\n       \tdirectLight  = salmpleLight (x, ng, ns, wi, mtl, true, strataCount, strataIndex);\n        directLight += sampleBSDF   (x, ng, ns, wi, mtl, true, strataCount, strataIndex, wo, woPdf, fr, hitResult, nextEvent, spec);\n       \n#ifdef CLAMP_CAUSTICS\n        if(i!=0) {\n            if(prev_spec < spec) {\n                break;\n            }\n        }\n        prev_spec = spec;\n#endif\n        if(pathWeight.x > 1.0 || pathWeight.y > 1.0 || pathWeight.z > 1.0)\n            break;\n        \n        Lo += directLight*pathWeight; \n\n        if (!hitResult || (dotWoN = dot(event.normal_, wo))<0.0) { break; }\n        if (woPdf == 0.0) { break; }\n        pathWeight *= fr*dotWoN / woPdf;\n\n        //Update values for next iteration\n        ray = Ray(event.position_, wo);\n        event = nextEvent;\n    }\n\n    return Lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    float fov = radians(40.0);\n    \n    vec3 camera_pos = (iFrame == 0)? vec3( 0.3, 3.0,  4.8 ) : LoadVec4(camera_pos_uv).xyz;\n    vec3 camera_dir = (iFrame == 0)? vec3( 1.0, 0.4, -5.0 ) : LoadVec4(camera_dir_uv).xyz;\n    \n    initCamera(camera_pos, camera_dir, fov, LENS_SIZE, 9.2, cameraOld);\n    \n    \n    if(iMouse.w > 0.0) {\n        //slider\n        const vec2 slider_pos = vec2(30.0, 30.0);\n        const float slider_size = 200.0;\n    \tconst float slider_width = 8.0;\n        \n        if (iMouse.x > slider_pos.x &&\n            iMouse.x < slider_pos.x + slider_size &&\n            iMouse.y > slider_pos.y - slider_width &&\n            iMouse.y < slider_pos.y + slider_width ) {\n        \tfloat slider = (iMouse.x - slider_pos.x) / slider_size;\n            \n            slider -= 0.5; //(-0.5, 0.5)\n            \n            camera_pos += vec3(1.0, 0.0, 0.0) * slider * 0.3;\n        }\n    }\n    \n    initCamera(camera_pos, camera_dir, fov, LENS_SIZE, 9.2, camera);\n    initScene();\n\n    vec3 accumulatedColor = vec3( 0.0 );\n    float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n    float strataSize = oneOverSPP;\n\n    for( int si=0; si<PIXEL_SAMPLES; ++si ){\n        vec2 uv = (fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() )) / iResolution.xy;\n        Ray ray = genRay( camera, uv, vec2(rnd(), rnd()) );\n\n        vec3 Li = Radiance( ray, PIXEL_SAMPLES, si );\n        accumulatedColor += clamp(Li, vec3(.0), vec3(CLAMP_VALUE));\n    }\n    accumulatedColor = accumulatedColor*oneOverSPP;\n\n    vec3 col_acc;\n    vec2 coord = floor(fragCoord.xy);\n    if(all(equal(coord.xy, acc_start_uv))) {\n        col_acc = vec3(getAccStart());\n    } else if(all(equal(coord.xy, camera_pos_uv))) {//camera_pos_uv\n        col_acc = camera_pos;\n    } else if(all(equal(coord.xy, camera_dir_uv))) {//camera_pos_uv\n        col_acc = camera_dir;\n    } else {\n        if(iFrame == 0) {\n            col_acc = accumulatedColor;\n        } else {\n            int frame_start = getAccStart();//int(texture( iChannel3, vec2(0.5, 0.5) / iResolution.xy ).x);\n            int spp1 = iMouse.z > 0.0 ? 0 : iFrame - frame_start;\n            int spp2 = 1;\n            vec3 col_new = accumulatedColor;\n            col_acc = texture( iChannel3, fragCoord/iResolution.xy ).xyz;\n            col_acc = mix(col_acc, col_new, float(spp2)/float(spp1+spp2));\n        }\n    }\n    \n    fragColor = vec4( col_acc, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n    float lensSize;\n    float focusDist;\n    vec2 iPlaneSize;\n};\n\nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int mtl_id_;\n};\n\n//////////////////////////////////////////////////////////////////////////\n// From smallVCM\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n\nfloat misWeight( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\n\n// Geometry functions ***********************************************************\nvec2 radialSampleDisk(in vec2 xi) {\n    float r = sqrt(1.0 - xi.x);\n    float theta = xi.y*TWO_PI;\n\treturn vec2(cos(theta), sin(theta))*r;\n}\n\n//https://pdfs.semanticscholar.org/4322/6a3916a85025acbb3a58c17f6dc0756b35ac.pdf\n//https://github.com/mmp/pbrt-v3/blob/9f717d847a807793fa966cf0eaa366852efef167/src/core/sampling.cpp#L113\nvec2 concentricSampleDisk(in vec2 xi) {\n    // Map uniform random numbers to $[-1,1]^2$\n    vec2 uOffset = 2. * xi - vec2(1, 1);\n\n    // Handle degeneracy at the origin\n    if (uOffset.x == 0.0 && uOffset.y == 0.0) return vec2(.0);\n\n    // Apply concentric mapping to point\n    float theta, r;\n    if (abs(uOffset.x) > abs(uOffset.y)) {\n        r = uOffset.x;\n        theta = (PI/4.0) * (uOffset.y / uOffset.x);\n    } else {\n        r = uOffset.y;\n        theta = (PI/2.0) - (PI/4.0) * (uOffset.x / uOffset.y);\n    }\n    return r * vec2(cos(theta), sin(theta));\n}\n\nvec2 uniformPointWithinCircle( in float radius, in vec2 xi ) {\n    vec2 p;\n#ifdef CONCENTRIC_DISK\n    p = concentricSampleDisk(xi);\n#else\n    p = radialSampleDisk(xi);\n#endif\n    p *= radius;\n    return p;\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\n//taken from: https://www.shadertoy.com/view/4sSSW3\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n) {\n    vec3 x;\n    vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvec3 l2w( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted(in vec2 xi) {\n#ifdef CONCENTRIC_DISK\n    vec2 xy = concentricSampleDisk(xi);\n    float r2 = xy.x*xy.x + xy.y*xy.y;\n    return vec3(xy, sqrt(max(0.0, 1.0 - r2)));\n#else\n    float theta = acos(sqrt(1.0-xi.x));\n    float phi = TWO_PI * xi.y;\n    return sphericalToCartesian( 1.0, phi, theta );\n#endif\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in vec2 xi ) {\n    return l2w( sampleHemisphereCosWeighted( xi ), n );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, vec3 boxMin, vec3 boxMax, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, boxMin.x, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_ = (isect.position_.yz - boxMin.yz)/(boxMax.yz - boxMin.yz);\n        } else if( EQUAL_FLT( isect.position_.x, boxMax.x, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_ = (isect.position_.yz - boxMin.yz)/(boxMax.yz - boxMin.yz);\n        } else if( EQUAL_FLT( isect.position_.y, boxMin.y, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_ = (isect.position_.xz - boxMin.xz)/(boxMax.xz - boxMin.xz);\n        } else if( EQUAL_FLT( isect.position_.y, boxMax.y, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_ = (isect.position_.xz - boxMin.xz)/(boxMax.xz - boxMin.xz);\n        } else if( EQUAL_FLT( isect.position_.z, boxMin.z, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_ = (isect.position_.xy - boxMin.xy)/(boxMax.xy - boxMin.xy);\n        } else if( EQUAL_FLT( isect.position_.z, boxMax.z, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_ = (isect.position_.xy - boxMin.xy)/(boxMax.xy - boxMin.xy);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayDiskIntersection( in Ray ray, in float r2, in float R2, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    float d2 = dot(isect.position_, isect.position_);\n    \n    if( d2 < r2 || d2 > R2 )\n        return false;\n    \n    if( !forShadowTest ) {\n        float R = sqrt(R2);\n        isect.uv_.x \t\t= (isect.position_.x - R)/(2.0*R);\n        isect.uv_.y \t\t= (isect.position_.y - R)/(2.0*R);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}