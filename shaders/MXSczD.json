{
    "Shader": {
        "info": {
            "date": "1727036455",
            "description": "combination of https://www.shadertoy.com/view/l32yRh https://www.shadertoy.com/view/43fcWS https://www.shadertoy.com/view/MXscDX",
            "flags": 0,
            "hasliked": 0,
            "id": "MXSczD",
            "likes": 1,
            "name": "colorful combination ",
            "published": 3,
            "tags": [
                "color",
                "combination"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 59
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst int zoom = 40;\nconst float brightness = 0.975;\nfloat fScale = 1.25;\n\nfloat cosRange(float amt, float range, float minimum) {\n\treturn (((1.0 + cos(radians(amt))) * 0.5) * range) + minimum;\n}\n#define PI 3.14159265359\n#define S 4.\n// the wave amplitude\n#define A 1.9\n// the wave lenght\n#define WAVEL 1.1\n\n\n// taken from thebookofshaders.com\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n// taken from thebookofshaderx.com\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvec2 cartesianToPolar(vec2 cartesian) {\n    float r = length(cartesian);          \n    float theta = atan(cartesian.y, cartesian.x); \n    return vec2(r, theta);  \n    \n}\nvec3 pcg3d(vec3 p){\n    uvec3 q = floatBitsToUint(p)*1234567890u+123456789u;\n    q.x +=q.y*q.z; q.y +=q.x*q.z; q.z+=q.x*q.y;\n    q^=q>>16u;\n    q.x +=q.y*q.z; q.y +=q.x*q.z; q.z+=q.x*q.y;\n    return vec3(q)/float(-1U);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 1.25;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n      // Remap the space to -1. to 1 in a function of time\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    //uv = sin(iTime) * uv +uv * cos(iTime);\n    \n   // uv = rotate2d( sin(iTime)) * uv;\n    \n   \n    //uv = cartesianToPolar(uv);\n    vec2 wave1Center = vec2(-1., -0.5);\n    //vec2 wave2Center = vec2(1., 0.5);\n    wave1Center= vec2(0.);\n     vec4 c=fragColor;\n    vec2 u=fragCoord;\n    float disFromWave1Center = distance(uv, wave1Center);\n    //float disFromWave2Center = distance(uv, wave2Center);\n     u = 300.0 * (u - 0.5 * iResolution.xy) / iResolution.y;   // Normalize UVs.\n    u.x += iTime * 22.0;                                      // Animate UV scroll.\n    ivec2 v = ivec2(u);                                       // Pixel position integer coordinates.\n    c += c =  vec4(((0x01030508 * v.x - 0x0163F413C * v.y)  * // Packed Pythagorean sines and cosines.\n                    (0x0A882424 * v.x - 0x01040C0F0 * v.y)) + // Again with different rotations.\n                   ((0x01030508 * v.y + 0x0163F413C * v.x)  * // Again but now for other axis.\n                    (0x0A882424 * v.y + 0x01040C0F0 * v.x)))  // Add missing rotations and scales.\n                    / 43e8 + 0.5;                    \n    float wave1 =  A * sin(disFromWave1Center / WAVEL - iTime / WAVEL);\n    //float wave2 =  A * sin(disFromWave2Center / WAVEL - iTime / WAVEL) ;\n \n    uv+= uv + uv * (wave1) / WAVEL;\n\tvec2 p  = (3.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n    \n\tfloat ct = cosRange(time*7.0, 3.0, 7.1);\n\tfloat xBoost = cosRange(time*0.2, 3.0, 3.0);\n\tfloat yBoost = cosRange(time*0.1, 10.0, 5.0);\n\t \n\np+=uv+c.xy;\n    // ### PLAY WITH SPACE START ### move space from the center to the vec2(0.0)\n  \n\tfScale = cosRange(time * 15.5, 1.25, 0.705);\n\t\n\tfor(int i=1;i<zoom;i++) {\n\t\tfloat _i = float(i);\n\t\tvec2 newp=p;\n\t\tnewp.x+=0.25/_i*sin(_i*p.y+time*cos(ct)*0.5/20.0+0.005*_i)*fScale+xBoost;\t\t\n\t\tnewp.y+=0.25/_i*sin(_i*p.x+time*ct*0.3/40.0+0.03*float(i+15))*fScale+yBoost;\n\t\tp=newp;\n\t}\n\t\n\tvec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(p.x+p.y));\n\tcol *= brightness;\n     \n    vec3 col2 = vec3(0.);\n    for(float i=0.,im=256.;i<im;i++){\n    vec3 rnd = pcg3d(vec3(i));\n    vec2 uuv = uv;\n    uuv.y += (rnd.y-.5)*1.;\n    float offx;\n    uuv.x  += (offx=sin(i/im*6.28+iTime*(.1+i/im*.1)))*.6;\n        uuv.y  += (offx=sin(i/im*6.28+iTime*(.1+i/im*.1)))*.6;\n    float d = length(uuv)-.05*abs(cos(offx*1.75));\n \n    d= exp(-im*abs(d)*.25); \n    col2+=mix(vec3(.2,.4,1.),vec3(1.,.4,.2),rnd.z)*d*exp(-3.*fract(iTime+i/im+rnd.z));\n    }\n    \n    fragColor = vec4(min(vec3(1.,1.,1.),col+fwidth(col)),1.0);\n    // Add border\n    float vigAmt = 10.77;\n    float vignette = (1.-vigAmt*(uv.y-.5)*(uv.y-.5))*(1.-vigAmt*(uv.x-.5)*(uv.x-.5));\n\tfloat extrusion = (col.x + col.y + col.z) / 4.0;\n    extrusion *= 3.5;\n    extrusion *= vignette;\n    \n\tfragColor = vec4(col+ col2, extrusion);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}