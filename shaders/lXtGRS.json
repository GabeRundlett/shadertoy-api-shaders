{
    "Shader": {
        "info": {
            "date": "1716688615",
            "description": "use the mouse\n\nmore 3d ish version of: https://www.shadertoy.com/view/flcyRB",
            "flags": 0,
            "hasliked": 0,
            "id": "lXtGRS",
            "likes": 11,
            "name": "color companions 3",
            "published": 3,
            "tags": [
                "volumetric"
            ],
            "usePreview": 0,
            "username": "pb",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "//philip.bertani@gmail.com\n\nfloat focus = 0.;\nfloat focus2 = 0.;\n#define pi  3.14159265\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 1e6 );\n}\n\nmat3 rxz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(cc,0.,-ss,\n                0.,1.,0.,\n                ss,0.,cc);                \n}\nmat3 ryz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(1.,0.,0.,\n                0.,cc,-ss,\n                0.,ss,cc);\n}      \n\nfloat noise(vec3 p) {\n    vec2 i = floor(p.yz);\n    vec2 f = fract(p.yz);\n    float a = random(i + vec2(0.,0.));\n    float b = random(i + vec2(1.,0.));\n    float c = random(i + vec2(0.,1.));\n    float d = random(i + vec2(1.,1.));\n    vec2 u = f*f*(3.-2.*f);\n    \n    return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;\n\n}\n\nfloat fbm3d(vec3 p) {\n    float v = 0.;\n    float a = .5;\n    vec3 shift = vec3(focus - focus2);  //play with this\n    \n    float angle = pi/3. ;\n    float cc=cos(angle), ss=sin(angle);  \n    mat3 rot = mat3( cc,  0., ss, \n                      0., 1., 0.,\n                     -ss, 0., cc );\n                     \n    for (float i=0.; i<2.; i++) {\n        v += a * noise(p);\n        p = rot * p * 2. + shift;\n        a *= .5 *(1.+ 2.5*(focus+focus2));  //changed from the usual .5\n    }\n    return v;\n}\n\n           \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float coord_scale = 1.5;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mm = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    if ( iMouse.w == 0. ) mm.xy += vec2(2.5,.6);\n\n    uv *= coord_scale;\n    mm *= coord_scale;\n\n    vec3 rd = normalize( vec3(uv, -2.) );  \n    vec3 ro = vec3(0.,1.,0.);\n    \n    float delta = pi/100.;\n    \n    mat3 rot = rxz(-mm.x*delta) * ryz(-mm.y*delta);\n    \n    ro -= rot[2]*iTime;\n    \n    \n    vec3 q;\n    \n    \n    focus = length(uv-mm);\n    focus = sqrt(focus);\n    focus = 2./(1.+focus/2.); \n\n    focus2 = length(uv+mm );\n    focus2 = 1.6/(1.+focus2*focus2);\n    \n    \n    float i=0., stepsize=1.;\n    vec3 cc=vec3(0);\n    vec3 p=ro;\n    for (; i<4.; i++) {\n        \n        p += rd * stepsize;\n           \n        q.x = fbm3d(p);\n        q.y = fbm3d(p.yzx);\n        q.z = fbm3d(p.zxy);\n        \n        float f = fbm3d(p + q);\n       \n        cc += q * f * exp(-i*i/10.);\n    }\n    \n    cc.r += 2.5*focus*focus; cc.g+= 1.5*focus; cc.b += 7.*focus2; cc.r-=4.*focus2;    \n    cc /= 7.;\n    \n    fragColor = vec4( pow(cc,vec3(2.)),1.0);\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}