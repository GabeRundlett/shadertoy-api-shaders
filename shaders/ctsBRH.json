{
    "Shader": {
        "info": {
            "date": "1692612904",
            "description": "A 2.5D arrangement of lights & particles circling an invisible sphere.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctsBRH",
            "likes": 6,
            "name": "Glow Lights",
            "published": 3,
            "tags": [
                "sphere",
                "25d",
                "pseudorandom"
            ],
            "usePreview": 0,
            "username": "QuantumSuper",
            "viewed": 270
        },
        "renderpass": [
            {
                "code": "// Glow Lights 0.4.230821 by QuantumSuper\n// 2.5d arrangement of lights & particles circling an invisible sphere\n\n#define PI 3.14159265359\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\nfloat hash21(vec2 p){p = fract(p*vec2(13.81,741.76)); p += dot(p, p+42.23); return fract(p.x*p.y);} //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\n\nfloat particle(vec2 p){ //single particle shape\n    return smoothstep( .1, .0, length(p)) * smoothstep( .1, .06, length(p-vec2(0.,.02)));\n}\n\nfloat particleLayer(vec2 p){ //pseudo-random 2d particle plane\n    float id = hash21(floor(p));\n    return smoothstep(0.,1.,id) *\n        particle((fract(p)-vec2(.5+.4*cos(id*iTime),.5+.4*sin(.8*id*iTime))) * rotM(id*2.*PI)/vec2(cos(.5*id*iTime),1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){    \n    // General initializations\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n\tvec3 col = vec3(0);\n    \n    // Center orbs \n    vec3 p, camPos = vec3(0,0,-1.5); //vec3 camDir = vec3(0,0,1); \n    float v1, v2, a = 11.;\n    for (float n=1.;n<a;n++){            \n        v1 = iTime*2.3 + n/a*PI*4.;\n        v2 = iTime + n/a*PI;\n        p = vec3( cos(v1)*cos(v2), sin(v1)*cos(v2), sin(v2)) * .5; //parametric sphere\n        p.yz *= rotM(n); //vary orientation\n        col += 1./((p.z-camPos.z)*(p.z-camPos.z)+dot(p.xy,p.xy)) * //vary brightness with distance\n            .001 / max( .001, length(uv-camPos.xy-p.xy/(p.z-camPos.z)) - .02/(p.z-camPos.z)) * //orb shape, vary size with distance\n            (.5 + clamp( .01/max( .001, length(uv-camPos.xy-p.xy/(p.z-camPos.z)+.005*normalize(p.xy))), .0, .9)) * //light spot\n            vec3(mod(n+.3,2.),mod(n*n*.3,2.),mod(n*PI,2.)); //color\n    }    \n\n    // Particle layers    \n    uv *= rotM(iTime*.1-.5*length(uv)); //rotate inner faster\n    float aFrac, amp = 0.; \n    for (float n=0.;n<4.;n++){\n        aFrac = fract(-.05*iTime+.25*n)-.02*1.;\n        amp += 1.4*(.2+.8*1.)*particleLayer( (uv*length(uv)+n*vec2(.1,.05))*25.*aFrac) * smoothstep(1.,.33,aFrac) * (.1+.9*smoothstep(.33,.66,aFrac));\n        \n    }\n    col *= (1.+amp*40.) * 1.5;\n    \n    // Finalizations\n    col *= .3*hash21(uv*iTime) + .7; //noise\n\tcol -= length(uv) * .005; //vignette\n\tcol = pow(col, vec3(.4545)); //gamma correction    \n    fragColor = vec4(col,1.);\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}