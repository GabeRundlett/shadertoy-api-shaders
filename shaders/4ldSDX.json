{
    "Shader": {
        "info": {
            "date": "1481863541",
            "description": "A branchless kenburns effect with focal point settings and CSS cover math. The focalpoint is really only useful when you have a gl context that is resizable in a window, and assets of varied sizes and orientations.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ldSDX",
            "likes": 2,
            "name": "Kenburns Effect",
            "published": 3,
            "tags": [
                "kenburns"
            ],
            "usePreview": 0,
            "username": "aferriss",
            "viewed": 491
        },
        "renderpass": [
            {
                "code": "vec2 moveBy, uv;\n\nvec4 rectmix(vec4 rectA, vec4 rectB, float percent){\n    vec2 resolution = iResolution.xy;\n\t\n    rectA.xy *= resolution;\n\trectA.zw *= resolution;\n\trectB.xy *= resolution;\n\trectB.zw *= resolution;\n\n\trectA.y = 1.0 - rectA.y;\n\trectB.y = 1.0 - rectB.y;\n\treturn rectA * (1.0 - percent) + rectB * percent;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 resolution = iResolution.xy;\n    \n    //right to left, no zoom\n    //vec2 fromPos = vec2(0.1, 0.0);\n    //vec2 fromDim = vec2(0.9, 0.9);\n   \t//vec2 destPos = vec2(-0.1, 0.0);\n    //vec2 destDim = vec2(0.9, 0.9);\n    \n    //fullscreen to top left zoom in\n    vec2 fromPos = vec2(0.0, 0.0);\n    vec2 fromDim = vec2(1.0, 1.0);\n   \tvec2 destPos = vec2(-0.25, -0.25);\n    vec2 destDim = vec2(0.5, 0.5);\n    \n    vec2 focalPoint = resolution*0.5;\n    float progress = mod(iTime*0.1, 1.0);\n    \n    vec2 assetSize = resolution;\n    vec2 position = (fragCoord / resolution.xy)*2.0 - 1.0;\n\tvec2 p = position;\n\t\n\t//aspect fix -- css cover math\n\tvec2 originalRatio = vec2(resolution.x / assetSize.x, resolution.y / assetSize.y);\n\tfloat coverRatio = max(originalRatio.x, originalRatio.y);\n\tvec2 newImageSize = vec2(assetSize.x * coverRatio, assetSize.y * coverRatio);\n\tp *= resolution / newImageSize;\n\n\tvec2 focalPosNrm = clamp(focalPoint / assetSize, 0.0,1.0);\n\tvec2 focalDiff;\n\tvec2 changedSize;\n\n\tfloat leftOrRight = 1.0 - floor(focalPosNrm.x + 0.5); // is the focal point x > 0.5\n\tfloat topOrBottom = 1.0 - floor(focalPosNrm.y + 0.5); // is the focal point y > 0.5\n\tfloat portOrLand = mix(0.0,1.0, floor(clamp(assetSize.x / assetSize.y, 0.0,1.0))); // is it portrait or landscape\n\n\tfocalDiff.x = mix( focalPosNrm.x * 2.0 - 1.0, \n\t\tmix(focalPosNrm.x * 2.0 - 1.0, (0.5 - focalPosNrm.x) * 2.0, leftOrRight), \n\t\tportOrLand);\n\n\tfocalDiff.y = mix(focalPosNrm.y * 2.0 - 1.0, (0.5 - focalPosNrm.y) * 2.0, topOrBottom);\n\n\tchangedSize.x = mix( \n\t\tmix(min(focalDiff.x, 1.0 - resolution.x/newImageSize.x ),max(focalDiff.x, resolution.x/newImageSize.x - 1.0 ), leftOrRight), \n\t\tmin(focalDiff.x, 1.0 - resolution.x/newImageSize.x ), \n\t\tportOrLand);\n\n\tchangedSize.y = mix(\n\t\tmix(min(focalDiff.y, 1.0 - resolution.y/newImageSize.y) ,min(focalDiff.y, 1.0 - resolution.y/newImageSize.y ), topOrBottom),\n\t\tmin(focalDiff.y, 1.0 - resolution.y/newImageSize.y ),\n\t\tportOrLand);\n\t\n\tmoveBy.x = mix( changedSize.x, mix(changedSize.x, -changedSize.x, leftOrRight), portOrLand);\n\tmoveBy.y = mix( mix(-changedSize.y, changedSize.y, topOrBottom), mix(-changedSize.y, changedSize.y, topOrBottom), portOrLand);\n\n\tvec4 bound = rectmix(vec4(fromPos , fromDim), vec4(destPos , destDim ), progress );\n\tvec2 finalPos = bound.xy ;\n\tvec2 finalDim = bound.zw ;\n\n\tuv = p;\n\t// ken burns scale\n\tuv *= finalDim / resolution;\n\tuv += finalPos / resolution;\n\n\t// focal point movement\n\tuv += moveBy;\n\n\t// convert uv to 0.0 - 1.0\n\tuv = vec2(0.0,1.0) + vec2(0.5,-0.5) * (uv + 1.0);\n    \n\tfragColor = texture(iChannel0, vec2(uv.x, 1.0-uv.y));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}