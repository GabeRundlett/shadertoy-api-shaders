{
    "Shader": {
        "info": {
            "date": "1719257690",
            "description": "Proof that the single scattering mBRDF of an isotropic volume should be  albedo / (PI*(cosI + cosO)). Explains the denominator in Chandrasekhar's BRDF and Disney's subsurface term.",
            "flags": 0,
            "hasliked": 0,
            "id": "mdKyW3",
            "likes": 2,
            "name": "Subsurface BRDF (Proof)",
            "published": 3,
            "tags": [
                "bsdf"
            ],
            "usePreview": 0,
            "username": "Tech_",
            "viewed": 135
        },
        "renderpass": [
            {
                "code": "\nconst vec3 lightIrradiance = vec3(2.0);\n\nvec3 ComplexFresnelNonPolarized(float cosThetaI, ComplexVec3 n1, ComplexVec3 n2)\n{\n    ComplexVec3 eta          = ComplexDiv(n1, n2);\n    float       sinThetaISqr = 1.0 - pow2(cosThetaI);\n    ComplexVec3 cosThetaT    = ComplexSqrt(ComplexSub(1.0, ComplexMult(ComplexPow2(eta), sinThetaISqr)));\n\n    // Senkrecht (perpendicular) reflectance\n    ComplexVec3 xS     = ComplexMult(eta, cosThetaI);\n    ComplexVec3 nomS   = ComplexSub(xS, cosThetaT);\n    ComplexVec3 denomS = ComplexAdd(xS, cosThetaT);\n    vec3 rS            = pow2(ComplexAbs(ComplexDiv(nomS, denomS)));\n    \n    // Parallel reflectance\n    ComplexVec3 xP     = ComplexMult(eta, cosThetaT);\n    ComplexVec3 nomP   = ComplexSub(xP, cosThetaI);\n    ComplexVec3 denomP = ComplexAdd(xP, cosThetaI);\n    vec3 rP            = pow2(ComplexAbs(ComplexDiv(nomP, denomP)));\n    \n    return (rS + rP) * 0.5;\n}\n\nvec3 DielectricFresnelNonpolarized(float cosThetaI, vec3 n1, vec3 n2)\n{\n    vec3  eta          = n1 / n2;\n    float sinThetaISqr = 1.0 - pow2(cosThetaI);\n    vec3  cosThetaT    = sqrt(max0(1.0 - pow2(eta) * sinThetaISqr));\n    \n    vec3 rS = pow2((eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT));\n    vec3 rP = pow2((eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI));\n\n    return (rS + rP) * 0.5;\n}\n\nvec3 UnitHemisphericalAlbedo(vec3 f0)\n{\n    return pow(0.996901 * f0, 0.637487 + 0.570946 * sqrt(f0));\n}\n\nvec3 FresnelHemisphereAvg(vec3 f0)\n{\n    return 0.342004 * (pow(0.655311 * tan(f0), vec3(0.210603)) + tan(f0 + 0.0859915));\n}\n\nvec3 RoughK(vec3 f0)\n{\n    /*\n        Fresnel correction factor for highly reflective\n        and rough Hammon materials.\n        \n        ~ Tech\n    */\n    \n    return max0(cos(asin(f0) + 0.0164359) * cos(pow(f0, vec3(0.0696184))));\n}\n\nfloat PhaseIsotropic()\n{\n    return rcp(4.0 * PI);\n}\n\nfloat PhaseNishinaKlein(float cosTheta, float e) \n{\n    return e / (TAU * log(1.0 + 2.0 * e) * (-e * cosTheta + e + 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n    \n    vec2 gridRes = vec2(1.0, 1.0);\n    float gridAr = gridRes.y / gridRes.x;\n    vec2 grid = fract(coord * gridRes);\n    vec2 gridID = floor(coord * gridRes);\n    vec2 gridCoord = (grid - 0.5) / min(vec2(ar / gridAr, gridAr / ar), 1.0);\n    gridCoord = gridCoord * 2.0;\n\n    vec3 rayDir    = vec3(0.0, 0.0, -1.0);\n    vec3 rayOrigin = vec3(2.0 * gridCoord, 10.0);\n    \n    float lightAngle = PI * 0.65;\n    vec3  lightPos   = vec3(-cos(lightAngle), 0.8, sin(lightAngle)) * 10.0;\n    \n    vec3  center = vec3(0.0, 0.0, 0.0);\n    float radius = 1.6;\n    \n    float intersection = IntersectSphere(rayOrigin - center, rayDir, radius);\n    \n    if (intersection >= 0.0)\n    {\n        vec3 hitPos   = rayOrigin + intersection * rayDir;\n        vec3 normal   = normalize(hitPos - center);\n        vec3 lightDir = normalize(lightPos + center - hitPos);\n        \n        vec3 sigmaS = vec3(0.0294477, 0.0327525, 0.0345487);\n        vec3 sigmaT = vec3(0.3924360, 0.1083800, 0.0661210);\n        vec3 rho    = vec3(0.0750382, 0.3022010, 0.5225070);\n        \n        vec3 scattering = vec3(0.0);\n        \n        float maxRayDepth = intersection;\n        \n        const int STEPS  = 10000; \n        // const int TSTEPS = 4000;\n        \n        float rayStep = maxRayDepth * rcp(float(STEPS));\n        vec3  rayInc  = rayDir * rayStep;\n        vec3  rayPos  = hitPos + 0.5 * rayInc;\n        \n        vec3 throughput = vec3(1.0);\n        float density   = 500.0;\n        \n        if (coord.x > 0.5)\n        {\n            float NdotL = saturate(dot(normal, lightDir));\n            float NdotV = dot(normal, -rayDir);\n        \n            scattering = NdotL > 0.0 ? rho * rcp(NdotL + NdotV) * NdotL * INV_PI : vec3(0.0);\n        }\n        else\n        {\n            sigmaT *= density;\n            sigmaS *= density;\n            \n            for (int i = 0; i < STEPS; i++)\n            {\n                vec3 stepScattering = sigmaS * rayStep;\n                vec3 stepExtinction = exp(-sigmaT * rayStep);\n\n                float lD = IntersectSphere(rayPos, lightDir, radius);\n                vec3 lightTransmittance = min(vec3(1.0), exp(-sigmaT * lD));\n\n                scattering += stepScattering * throughput * lightTransmittance * PhaseIsotropic() * 4.0;\n\n                vec3 T = throughput;\n\n                throughput *= stepExtinction;\n                rayPos += rayInc;\n            }\n        }\n        \n        fragColor = vec4(LinearTosRGB(TonemapPrism(scattering)), 0.0);\n        return;\n    }\n    \n    fragColor = vec4(0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float EPS = 1e-6;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define rcp(x) (1.0 / (x))\n#define max0(x) max(x, 0.0)\n#define maxEPS(x) max(x, EPS)\n\nfloat pow2(float x) { return x * x; }\nvec2  pow2(vec2  x) { return x * x; }\nvec3  pow2(vec3  x) { return x * x; }\n\nfloat pow3(float x) { return x * x * x; }\nvec2  pow3(vec2  x) { return x * x * x; }\nvec3  pow3(vec3  x) { return x * x * x; }\n\nfloat pow4(float x) { return pow2(pow2(x)); }\nvec2  pow4(vec2  x) { return pow2(pow2(x)); }\nvec3  pow4(vec3  x) { return pow2(pow2(x)); }\n\nfloat pow5(float x) { return pow3(x) * pow2(x); }\nvec2  pow5(vec2  x) { return pow3(x) * pow2(x); }\nvec3  pow5(vec3  x) { return pow3(x) * pow2(x); }\n\nfloat avg(vec3 x) { return rcp(3.0) * (x.x + x.y + x.z); }\n\nconst float PI = radians(180.0);\nconst float TAU = 2.0 * PI;\nconst float INV_PI = rcp(PI);\nconst float PHI = (1.0 + sqrt(5.0)) / 2.0;\n\nstruct ComplexVec3\n{\n    vec3 r;\n    vec3 i;\n};\n\n// https://en.wikipedia.org/wiki/Refractive_index (0C, 1atm)\nComplexVec3 airIOR = ComplexVec3(vec3(1.000293), vec3(0.0));\n\nstruct MaterialData \n{\n    vec3 albedo;\n    float roughness;\n    bool isMetal;\n    vec3 f0;\n    float porosity;\n    float subsurface;\n    float ao;\n    float emissive;\n    float opacity;\n    ComplexVec3 ior;\n};\n\nstruct CoatingLayer\n{\n    vec3 f0;\n    ComplexVec3 ior;\n    float roughness;\n    vec3 sigmaS;     // Scattering coefficient\n    vec3 sigmaT;     // Absorption coefficient\n    vec3 rho;        // Scattering albedo\n    float thickness; // [m]\n};\n\nMaterialData MaterialFromCoat(CoatingLayer coat)\n{\n    return MaterialData(\n        vec3(1.0),\n        coat.roughness,\n        false,\n        coat.f0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        coat.ior\n    );\n}\n\n// Complex Math\nComplexVec3 ComplexAdd(ComplexVec3 a, ComplexVec3 b)\n{\n    ComplexVec3 c;\n    c.r = a.r + b.r;\n    c.i = a.i + b.i;\n    return c;\n}\n\nComplexVec3 ComplexAdd(ComplexVec3 a, float b)\n{\n    return ComplexVec3(a.r + b, a.i);\n}\n\nComplexVec3 ComplexSub(ComplexVec3 a, float b)\n{\n    return ComplexVec3(a.r - b, a.i);\n}\n\nComplexVec3 ComplexMult(ComplexVec3 a, ComplexVec3 b) \n{\n    ComplexVec3 c;\n    c.r = a.r * b.r - a.i * b.i;\n    c.i = a.i * b.r + a.r * b.i;\n    return c;\n}\n\nComplexVec3 ComplexMult(ComplexVec3 a, float b) \n{\n    return ComplexVec3(a.r * b, a.i * b);\n}\n\nComplexVec3 ComplexDiv(ComplexVec3 a, ComplexVec3 b) \n{\n    ComplexVec3 c;\n    vec3 denom = b.r * b.r + b.i * b.i;\n    c.r = (a.r * b.r + a.i * b.i) / denom;\n    c.i = (a.i * b.r - a.r * b.i) / denom;\n    return c;\n}\n\nComplexVec3 ComplexSub(ComplexVec3 a, ComplexVec3 b) \n{\n    ComplexVec3 c;\n    c.r = a.r - b.r;\n    c.i = a.i - b.i;\n    return c;\n}\n\nComplexVec3 ComplexSub(float a, ComplexVec3 b) \n{\n    return ComplexVec3(a - b.r, b.i);\n}\n\nvec3 ComplexAbs(ComplexVec3 num) \n{\n    return sqrt(num.r * num.r + num.i * num.i);\n}\n\nComplexVec3 ComplexSqrt(ComplexVec3 num) \n{\n    ComplexVec3 c;\n    vec3 absNum = ComplexAbs(num);\n    c.r =               sqrt(max(absNum + num.r, 0.0) * 0.5);\n    c.i = sign(num.i) * sqrt(max(absNum - num.r, 0.0) * 0.5);\n    return c;\n}\n\nComplexVec3 ComplexPow2(ComplexVec3 num)\n{\n    ComplexVec3 c;\n    c.r = num.r * num.r - num.i * num.i;\n    c.i = 2.0 * num.r * num.i;\n    return c;\n}\n\nfloat IORToF0(float ior)\n{\n    return pow2((1.0 - ior) / (1.0 + ior));\n}\n\nvec3 IORToF0(vec3 ior)\n{\n    return pow2((1.0 - ior) / (1.0 + ior));\n}\n\nfloat F0ToIOR(float f0)\n{\n    return 2.0 / maxEPS(1.0 - sqrt(f0)) - 1.0;\n}\n\nvec3 F0ToIOR(vec3 f0)\n{\n    return 2.0 / maxEPS(1.0 - sqrt(f0)) - 1.0;\n}\n\n/*\n    From https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n*/\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = saturate(color);\n\n    return color;\n}\n\nvec3 EvaluateLSICurve(vec3 x, float l, float s, float i)\n{\n    vec3 a = pow(x / l, vec3(2.0 * rcp(s)));\n    return i * pow(a / (a + 1.0), vec3(0.5 * s)) + (1.0 - i);\n}\n\n#define tonemapConfiguration TONEMAP_CINEMATIC\nvec3 TonemapPrism(vec3 color)\n{\n    /*\n        Custom parameterized tone.\n        Can yield a variety of different desired looks.\n\n        ~ Tech\n    */\n\n    const mat2x3 TONEMAP_CINEMATIC = mat2x3(\n        0.25085, 1.37, 0.95,\n        0.31357, 1.62, 1.00\n    );\n\n    const mat2x3 TONEMAP_NEUTRAL = mat2x3(\n        0.325, 1.0, 0.3,\n        0.813, 1.0, 1.0\n    );\n\n    vec3 toe       = EvaluateLSICurve(color, tonemapConfiguration[0][0], tonemapConfiguration[0][1], tonemapConfiguration[0][2]);\n    vec3 shoulder  = EvaluateLSICurve(color, tonemapConfiguration[1][0], tonemapConfiguration[1][1], tonemapConfiguration[1][2]);\n\n    return toe * shoulder;\n}\n\n/* https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code */\nfloat IntersectSphere(vec3 rayPos, vec3 rayDir, float radius)\n{\n    float b = dot(rayPos, rayDir);\n    float c = dot(rayPos, rayPos) - radius * radius;\n\n    if (c > 0.0 && b > 0.0) return -1.0;\n\n    float d = b * b - c;\n\n    if (d < 0.0)    return -1.0;\n    if (d > b * b)  return -b + sqrt(d);\n\n    return -b - sqrt(d);\n}\n\n/* https://www.shadertoy.com/view/4djSRW */\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 UniformSphereSample(vec2 hash) \n{\n    hash = vec2(hash.x * TAU, hash.y * 2.0 - 1.0);\n    return vec3(vec2(sin(hash.x), cos(hash.x)) * sqrt(1.0 - pow2(hash.y)), hash.y);\n}\n\nvec3 UniformHemisphereSample(vec3 vector, vec2 hash) \n{\n    vec3 dir = UniformSphereSample(hash);\n    return dot(dir, vector) < 0.0 ? -dir : dir;\n}\n\nvec3 LinearTosRGB(vec3 x)\n{\n\tvec3 sRGBLo = x * 12.92;\n\tvec3 sRGBHi = pow(abs(x), vec3(1.0 / 2.4)) * 1.055 - 0.055;\n\treturn mix(sRGBHi, sRGBLo, step(x, vec3(0.0031308)));\n}\n\nvec3 SRGBToLinear(vec3 x)\n{\n    vec3 linearLo = x / 12.92;\n    vec3 linearHi = pow((x + 0.055) / 1.055, vec3(2.4));\n    return mix(linearHi, linearLo, step(x, vec3(0.04045)));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}