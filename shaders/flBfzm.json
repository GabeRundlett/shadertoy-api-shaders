{
    "Shader": {
        "info": {
            "date": "1656518394",
            "description": "Lots of reflective quartic surfaces. Inspired by [url]https://www.shadertoy.com/view/XddfW7[/url] by @wyatt.",
            "flags": 48,
            "hasliked": 0,
            "id": "flBfzm",
            "likes": 19,
            "name": "Quartic Reflections",
            "published": 3,
            "tags": [
                "reflections",
                "quartic"
            ],
            "usePreview": 1,
            "username": "mla",
            "viewed": 506
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Quartic Reflections, mla, 2022.\n//\n// Inspired by https://www.shadertoy.com/view/XddfW7 by @wyatt - this\n// one uses a nice quartic solver and also computes the normals\n// analytically.\n//\n// A central cyclide and four smaller Goursat surfaces, all contained\n// in one larger Goursat surface.\n//\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>: cycle through some interesting Goursat parameters\n// 'c': inner cyclide\n// 'g': outer goursat quartic\n// 'r': autorotation\n// 'x': no light bounce\n// 'w': white objects\n// 't': textured objects\n// 'p': postprocessing\n// 'q': choose cubic solver\n//\n// http://mathworld.wolfram.com/GoursatsSurface.html\n// https://www.mathcurve.com/surfaces/goursat/goursat.shtml\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint maxbounces = 3;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\n// The Kahan cubic algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (false && r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Evaluate cubic and derivative.\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint cubic(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  X = -(B/A)/3.0;\n  float t,r,s,q,dq,x0;\n  eval(X,A,B,C,D,q,dq,b1,c2);\n  t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n  t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n  x0 = X - s*r;\n  if (x0 != X) {\n    // We really do need this many iterations here\n    for (int i = 0; i < 6; i++) {\n      X = x0;\n      eval(X,A,B,C,D,q,dq,b1,c2);\n      if (dq == 0.0) break;\n      x0 -= (q/dq);\n    }\n    if (abs(A)*X*X > abs(D/X)) {\n      c2 = -D/X; b1 = (c2 - C)/X;\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\n// Special wrapper for cubic function for solving quartic.\n// Find largest real root of x**3 + a*x**2 + b*x + c\n// Assume c < 0\nfloat qcubic0(float a, float b, float c) {\n  if (c == 0.0) return 0.0;\n  vec3 res;\n  int nroots = cubic(1.0,a,b,c,res);\n  if (nroots == 1) return res.x;\n  else return max(res.x,max(res.y,res.z));\n}\n\nfloat cuberoot(float x) {\n  return sign(x)*pow(abs(x),1.0/3.0);\n}\n\nfloat dcubic(float p, float q) {\n  // NB: solves x³+3px+q = 0 & returns largest real root,\n  // which is just what we want for Lanczos.\n  float h = q*q + 4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = -0.5*(q+sgn(q)*r); // Largest root of quadratic\n    float t = cuberoot(u);\n    return t - p/t;\n  } else {\n    float theta = atan(r,-q); // 0 <= theta < PI\n    float k = 2.0*sqrt(abs(p));\n    return k*cos(theta/3.0);\n  }\n}\n\nfloat qcubic1(float b, float c, float d) {\n  b /= 3.0; c /= 3.0;\n  // Now we are solving x³ + 3bx² + 3cx + d = 0\n  float p = c-b*b;\n  float q = 2.0*b*b*b - 3.0*b*c + d;\n  float x = dcubic(p,q); // Solve depressed cubic\n  x -= b; // Undepress\n  return x;\n}\n\nfloat qcubic(float b, float c, float d) {\n  if (key(CHAR_Q)) return qcubic0(b,c,d);\n  else {\n    float x = qcubic1(b,c,d);\n    for (int i = 0; i < 1; i++) {\n      // Polish root with Newton-Raphson, one round is enough.\n      float fx = d + x*(c+x*(b+x));\n      float f1x = c+x*(2.0*b+3.0*x);\n      if (f1x != 0.0) x -= fx/f1x;\n    }\n    return x;\n  }\n}\n\nint quartic0(float c1, float c2, float c3, float c4, out vec4 res) {\n  // Lanczos's quartic solution\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  // There should be a positive root, but sometimes the cubic\n  // solver doesn't find it directly (probably a double root\n  // around zero).\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int n0 = quadratic(1.0,alpha+a,beta+b,res.xy);\n  int n1 = quadratic(1.0,alpha-a,beta-b,res.zw);\n  if (n0 == 0) res.xy = res.zw;\n  return n0 + n1;\n}\n\n// Ferrari's method, from Hall and Knight, 1887.\n// Similar to Lanczos, but has some visible instabilities.\nint quartic2(float p, float q, float r, float s, out vec4 roots) {\n  p *= 0.5; r *= 0.5;\n  float B = -0.5*q;\n  float C = p*r-s;\n  float D = 0.5*(s*(q-p*p)-r*r);\n  float k = qcubic(B,C,D);\n  float a = sqrt(p*p+2.0*k-q); // The sign is immaterial\n  float b = (p*k-r)/a;         // Get b from a directly\n  int n0 = quadratic(1.0,p-a,k-b,roots.xy);\n  int n1 = quadratic(1.0,p+a,k+b,roots.zw);\n  if (n0 == 0) roots.xy = roots.zw;\n  return n0 + n1;\n}\n\n// Solver by @oneshade, based on Descartes' method\nint quartic1(in float b, in float c, in float d, in float e, inout vec4 roots) {\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cuberoot(ro - rh) + cuberoot(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this produces the least wild behaviour.\n  bool flip = abs(B/A) >= abs(D/E);\n  float c1,c2,c3,c4;\n  if (!flip) {\n    c1 = B/A; c2 = C/A; c3 = D/A; c4 = E/A;\n  } else {\n    // Solve for reciprocal\n    c1 = D/E; c2 = C/E; c3 = B/E; c4 = A/E;\n  }\n  nroots = quartic0(c1,c2,c3,c4,roots);\n  if (flip) {\n    // We have solved for the reciprocal.\n    for (int i = 0; i < 4; i++) {\n      if (i == nroots) break;\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  return nroots;\n}\n\nint Goursat = 0;\nint Cyclide = 1;\n\nstruct Surface {\n  int type;\n  vec4 params;\n  vec3 p;\n};\n\n// Goursat Quartic Surfaces\n// Equation: pp.pp + k(p.p)^2 + k'a^2(p.p) + k''a^4 = 0\n// Derivative: 4ppp + 4k(p.p)p + 2k'a^2p\n// Expansion with p => p+tr:\n// pp => (p+tr)(p+tr) = pp + 2tpr + t^2rr\n// pp.pp => (pp + 2tpr + t^2rr).(pp + 2tpr + t^2rr)\n//  = pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr \n// p.p  => (p+tr).(p+tr) = p.p + 2tp.r + t^2r.r = p.p + 2tp.r + t^2\n// (p.p)^2 = (p.p + 2tp.r + t^2)(p.p + 2tp.r + t^2) =\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 2(2t(p.p)(p.r) + (p.p)t^2 + 2t^3(p.r))\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 4t(p.p)(p.r) + 2(p.p)t^2 + 4t^3(p.r))\n// ie.\n// pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr +\n// k(p.p^2 + t4[(p.p)(p.r)] + t^2[4(p.r)^2 + 2(p.p)] + t^3[4(p.r)] + t^4) +\n// k'a^2(p.p + 2tp.r + t^2) +\n// k''a^4\n// collecting terms:\n// t^0: pp.pp +   k(p.p)^2 +             k'a^2(p.p) + k''a^4\n// t^1: 4pp.pr + 4k(p.p)(p.r) +         2k'a^2(p.r)\n// t^2: 6pp.rr +  k[4(p.r)^2 + 2(p.p)] + k'a^2\n// t^3: 4pr.rr + 4k(p.r)\n// t^4: rr.rr +   k\n\nint goursatsurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  float t = dot(p,r);\n  p -= t*r; // Now dot(p,r) == 0\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float k2 = surface.params[2];\n  float a = surface.params[3];\n  vec3 pp = p*p;\n  vec3 pr = p*r;\n  vec3 rr = r*r;\n  float p2 = dot(p,p);\n  float a2 = a*a;\n  float a4 = a2*a2;\n\n  float A =     dot(rr,rr) +     k;\n  float B = 4.0*dot(pr,rr);\n  float C = 6.0*dot(pp,rr) + 2.0*k*p2    + k1*a2;\n  float D = 4.0*dot(pp,pr);\n  float E =     dot(pp,pp) +     k*p2*p2 + k1*a2*p2 + k2*a4;\n\n  int res = quartic(A,B,C,D,E,roots);\n  roots -= t;\n  return res;\n}\n\nvec3 goursatnormal(Surface surface, vec3 p) {\n  // 4ppp + 4k(p.p)p + 2k'a^2p\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float a = surface.params[3];\n  return 4.0*p*p*p + 4.0*k*dot(p,p)*p + 2.0*k1*a*a*p;\n}\n\n// Dupin Cyclides\nint cyclidesurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  float t = dot(p,r);\n  p -= t*r; // Now p.r == 0\n  float a = surface.params.x;\n  float b = surface.params.y;\n  float c = surface.params.z;\n  float d = surface.params.w;\n  // t0 = (p+tr).(p+tr) + K = (p.p + t^2 + K) (assuming p.r == 0)\n  // t0*t0 = (p.p + K + t^2)(p.p + K + t^2) =   (p.p + K)^2 + 2t^2(p.p + K) + t^4\n  // t = X.(p+tr) + Y = X.p + tX.r + Y      = tX.r + X.p + Y [X,Y = M,-L or N,0]\n  // t*t = (X.p + Y + tX.r)(X.p + Y + tX.r) = (X.p + Y)^2 + 2t(X.p + Y)(X.r) + t^2(X.r)^2\n  float K = (b+d)*(b-d); float L = c*d;\n  vec3 M = vec3(a,0,0); vec3 N = vec3(0,b,0);\n  float pp = dot(p,p);\n  float Mr = dot(M,r); float Mp = dot(M,p);\n  float Nr = dot(N,r); float Np = dot(N,p);\n  float A = 1.0;\n  float B = 0.0;\n  float C = 2.0*(pp+K) - 4.0*Mr*Mr - 4.0*Nr*Nr;\n  float D = -8.0*((Mp-L)*Mr + Np*Nr);\n  float E = (pp+K)*(pp+K) - 4.0*(Mp-L)*(Mp-L) - 4.0*Np*Np;\n  int res = quartic(A,B,C,D,E,roots);\n  roots -= t;\n  return res;\n}\n\nvec3 cyclidenormal(Surface surface, vec3 p) {\n  float a = surface.params.x;\n  float b = surface.params.y;\n  float c = surface.params.z;\n  float d = surface.params.w;\n  float K = (b+d)*(b-d);\n  float L = c*d;\n  vec3 M = vec3(a,0,0);\n  vec3 N = vec3(0,b,0);\n  float t0 = dot(p,p) + K;\n  float t1 = dot(M,p) - L;\n  float t2 = dot(N,p);\n  return 2.0*(2.0*t0*p - 4.0*t1*M - 4.0*N*t2);\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 basecolor;\n  float t;\n};\n\nint dosurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  p -= surface.p;\n  if (surface.type == Goursat) return goursatsurface(surface,p,r,roots);\n  if (surface.type == Cyclide) return cyclidesurface(surface,p,r,roots);\n}\n  \nvec3 donormal(Surface surface, vec3 p) {\n  p -= surface.p;\n  if (surface.type == Goursat) return goursatnormal(surface,p);\n  if (surface.type == Cyclide) return cyclidenormal(surface,p);\n}\n\nvec3 getcol(vec3 dir) {\n  if (key(CHAR_W)) return vec3(0.8);\n  if (key(CHAR_T)) return pow(texture(iChannel0,dir).rgb,vec3(2.2));\n  return pow(abs(dir),vec3(1.4));\n}\n\nbool solve(Surface surface, vec3 p, vec3 r, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p,r,roots);\n  bool found = false;\n  for (int i = 0; i < nroots; i++) {\n    // Find closest root that is a little away from p,\n    // to avoid problems if p is in the surface.\n    if (roots[i] > 0.0001 && roots[i] < result.t) {\n      result.t = roots[i];\n      found = true;\n    }\n  }\n  if (!found) return false;\n  result.p = p + result.t*r;\n  result.n = normalize(donormal(surface, result.p));\n  if (dot(result.n,r) > 0.0) result.n = -result.n;\n  result.basecolor = getcol(result.n);\n  return true;\n}\n\n// Interesting parameters from:\n// https://www.mathcurve.com/surfaces.gb/goursat/goursat.shtml\nconst vec4 gparams[] =\n  vec4[](vec4(0,0,-1,0.5),\n         //vec4(0,0,-1,1),\n         vec4(0,-1,0,1),\n         vec4(-1,-0.25,0.25,1),\n         //vec4(-1,1,1,1),\n         vec4(0,-2,2,1),\n         //vec4(-0.5,-1,0.5,1),\n         //vec4(-0.5,1,-1.5,1),\n         vec4(-1,4,-6,1),\n         vec4(-1,1,1,1),\n         vec4(-1,2,-2,1));\n\nvec4 goursatparams(int i) {\n  if (i >= 0 && i < gparams.length()) return gparams[i];\n  return vec4(-0.333,-0.666,0.666,1);\n}\n\nint nparams = 10;\n\nint imod(int n, int m) {\n    return n-n/m*m;\n}\n\nvec4 tparams (float t) {\n  float ttime = 0.5*t;\n  float rtime = floor(ttime);\n  ttime -= rtime;\n  return mix(goursatparams(int(rtime)%nparams),\n             goursatparams(int(rtime+1.0)%nparams),\n             ttime);\n}\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 col = vec3(0);\n  float att = 0.5;\n  for (int bounce = 0; bounce <= maxbounces; bounce++) {\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    bool hit = false;\n    if (!key(CHAR_C)) {\n      float a = 1.0; float b = 0.95;\n      float c = sqrt(a*a-b*b); float d = 0.1;//sin(iTime);\n      Surface s = Surface(Cyclide,vec4(a,b,c,d),vec3(0));\n      hit = solve(s,p,r,res) || hit;\n    }\n    if (!key(CHAR_G)) {\n      Surface s = Surface(Goursat,vec4(0,0,-1,2),vec3(0));\n      hit = solve(s,p,r,res) || hit;\n    }\n    int isurface = max(0,3+keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n    for (int i = -1; i <= 1; i+=2)\n      for (int j = -1; j <= 1; j+=2)\n        for (int k = -1; k <= 1; k+=2) {\n          Surface s = Surface(Goursat,gparams[isurface%gparams.length()],vec3(i,j,k));\n          s.params.a = 0.4;\n          hit = solve(s,p,r,res) || hit;\n        }\n    vec3 bgcol = vec3(0);\n    if (key(CHAR_B)) bgcol = getcol(r);\n    if (!hit) {\n      col += att*bgcol;\n      break;\n    }\n    col += att*applylighting(res.basecolor,res.p,res.n,r);\n    if (key(CHAR_X)) break;\n    p = res.p;\n    r = reflect(r,res.n);\n    r = normalize(r);\n    att *= 0.5;\n  }\n  return col;\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime;\n    //p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.1618*t);\n  }\n  return p;\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n#define float3 vec3\nfloat3 ACESFilm(float3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    x = x*(a*x+b)/(x*(c*x+d)+e);\n    return x;\n}\nvec3 postprocess(vec3 color) {\n  // Some experimental tone mapping.\n  color = ACESFilm(color);\n  //color = 2.0*color/(1.0+color);\n  //color = color*color*(3.0-2.0*color);\n  color = clamp(color,0.0,1.0);\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.2-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 2.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 p = vec3(0,0,-camera);\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  int AA = 1;\n  //if (key(CHAR_A)) AA = 2;\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = vec3(uv, 2.0);\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  vec2 q = fragCoord/iResolution.xy;\n  if (!key(CHAR_P)) color = postprocess(color);\n  color = pow(color,vec3(0.4545));\n  if (alert) color = vec3(1,0,0);\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n#if 0\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0) {\n      t.xy = initselection(i-1); // Current coordinates\n  } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n#endif\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float PI =  3.141592654;\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\n// const int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\nconst int CHAR_G = 71;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_ALT = 18;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}