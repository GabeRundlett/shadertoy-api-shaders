{
    "Shader": {
        "info": {
            "date": "1457314218",
            "description": "An explanation about 3D noise created from a 2D texture. The difficulty is to allow the noise to be continuous along the 3rd axis.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ms3SRr",
            "likes": 27,
            "name": "Noise Volume Explanation",
            "published": 3,
            "tags": [
                "sampling",
                "noisevolume"
            ],
            "usePreview": 1,
            "username": "Bers",
            "viewed": 1893
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// (trilinearSampling/Noise function from : Inigo Quilez https://www.shadertoy.com/view/XslGRr)\n// Created : Dec 2014\n// Modified : Jan 2016\n//\n// This shader was created in order to understand and explain the noise stacking trick \n// used in many excellent volumetric shaders (Clouds, amongst many).\n// It uses a single texture lookup (r+g channels) to generate 3D noise.\n//\n// Therefore, here goes the explaination:\n//\n// \t\tFirst, the sampled result is a trilinear interpolation.\n//      (See images here : https://en.wikipedia.org/wiki/Trilinear_interpolation)\n//      Since the texture() function takes care internally of the fractional interpolation\n//      on the XZ texture plane, one only needs to interpolate between 2 XZ layers in order \n//      to add the 3rd (Y) dimension to the noise and produce a noise volume.\n//\n//      The tricky part here is the [37x17] offset. Why 37x17? If you change this number, you will\n//      essentially get garbage (discontinuities) along the Y-axis. Why is that? Well, it is because\n//      the RGB noise texture is \"hacked\" for this :). The 3 noise layers are NOT random, they only are\n//      a tranlated version of each other. Indeed, the 37x17 is the exact translation to align\n//      the red texture plane on the green texture plane. The B texture plane has a different offset\n//      (I do not remember what it is, but the noise layering trick also works between any channel\n//       when you plug in the exact offset across them. The 64x64 RBG noise textures are\n//       also built that way)\n//\n//      So, now that we know the offset between noise layers, how does that helps in\n//      contructing a noise volume? Well, it helps making the noise volume CONTINOUS across\n//      sections on the Y-Axis. Indeed, when the fractionnal part of the Y-Axis coordinates\n//\t\treturns to zero (t.y), the translated XZ coordinates (by [37x17]) allow us to swap the \n//      R&G channels seamlessly, and continue interpolation along the Y Axis like if it was\n//      a continuous noise volume.\n//\n//      And to finish, \"t = t * t * (3.0 - 2.0 * t)\" is simply an easing function\n//      to convert from purely linear interpolation to a more rounded/organic transition.\n//\t\tThe noise volume will still work if you remove this line, yet it will look\n//      much less smooth.\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\nfloat trilinearSampling(vec3 p)\n{\n    const float TEXTURE_RES = 256.0; //Texture resolution\n    p *= TEXTURE_RES;   //Computation in pixel space (1 unit = 1 pixel)\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    vec3 t = p-pixCoord;     //Pixel interpolation position, linear [0-1]\n    t = t * t * (3.0 - 2.0 * t); //interpolant easing function\n    //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels ->\n    //this is no keypad smashing, but the actual translation embedded in the noise texture).\n    vec2 layer_translation = -pixCoord.y*vec2(37.0,17.0)/TEXTURE_RES;\n    vec2 layer1_layer2 = texture(iChannel0,layer_translation+(pixCoord.xz+t.xz+0.5)/TEXTURE_RES,-100.0).rg;\n    return mix( layer1_layer2.x, layer1_layer2.y, t.y );\n}\n\nconst float PI = 3.14159;\nconst float INFINITY = 200000.0;\n\n//Utility function to compute the distance along a ray to reach a plane, in 3D.\n//The value returned is the distance along ray (in \"d\" units) to the plane intersection.\n//o = ray origin\n//d = ray direction\n//pn = plane normal\n//pp = arbitrary point on the plane\nfloat planeLineIntersect(vec3 o,vec3 d,vec3 pn,vec3 pp)\n{\n    //Note : The plane normal is the optimal direction for a ray to reach it.\n    //The equation below can be conceptualized this way : \"How far is the plane\"/\"approach rate\".\n    //No need to normalize pn, as dot product above and under cancel out and do not scale the result.\n    return dot(pp-o,pn)/dot(d,pn);\n}\n\nfloat _sign(float x)\n{\n    if(x>0.)\n        return 1.0;\n    else\n        return -1.0;\n}\n\n//A very basic rotation.\nvec3 rotate(vec3 p, const float yaw, const float pitch)\n{\n    p.xz = vec2( p.x*cos(yaw)+p.z*sin(yaw),\n                 p.z*cos(yaw)-p.x*sin(yaw));\n    p.yz = vec2( p.y*cos(pitch)+p.z*sin(pitch),\n                 p.z*cos(pitch)-p.y*sin(pitch));\n    return p;\n}\n\n//This function returns the intersection point of a ray cast towards a plane.\n//o = ray origin\n//d = ray direction\n//center : the plane center\n//[yaw,pitch] = rad angles\n//Size = plane size\n//return value : distance along the ray to intersec the plane\nfloat plane(vec3 o, vec3 d, vec3 center, vec2 yawPitch, vec2 size)\n{\n    //The plane is not really rotated nor translated. The ray being cast is, however, which yields\n    //the same result.\n    o = o-center;\n    float yaw = yawPitch.x;\n    float pitch = yawPitch.y;\n    d = rotate(d,-yaw,-pitch);\n    o = rotate(o,-yaw,-pitch);\n    \n    //t = distance along the ray to reach the plane.\n    float t = planeLineIntersect(o,d,vec3(0,-_sign(d.y),0),vec3(0,0,0));\n    \n    //Intersection position : (o:start)+(t:step size)*(d:direction)\n    vec3 p = o+t*d;\n    \n    if( abs(p.x) <= size.x && abs(p.z) <= size.y) //xz plane\n    \treturn t;\n    \n    return INFINITY; //Did not cross the plane. Return infinity.\n}\n\n//A very unintersting animation. This is just to show the volumetric lookup values.\nvec4 animatedNoisePlane(vec3 o, vec3 d, vec3 offset, float fTime)\n{\n    float planeAngle = -0.2;\n    vec3 planePos = offset+vec3(0,0,-6);\n    \n    //Rotate layers from in time interval : [0-1]\n    if(fTime<1.)\n    {\n    \tplaneAngle += fTime*PI;\n    }\n    //Move layers up and down between time : [1-2]\n\telse\n    {\n        planePos += vec3(0,0.5+0.5*sin(-PI/2.+fTime*2.*PI),0);\n    }\n    \n    float t = plane(o,d,planePos,vec2(0.0,planeAngle),vec2(2));\n    \n    //Intersection position : (o:start)+(t:step size)*(d:direction)\n    vec3 p = o+t*d;\n    \n    //Background\n    if(t>=INFINITY || t<0.0 )\n        return vec4(0);\n    \n    //Noise volume at position p (scaled at 1:100)\n    return vec4(vec3(trilinearSampling(p*0.01)),0.25); //0.5 is alpha\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Centered, scaled uv coordinates (x:[-0.5;0.5])\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    \n    //The 3 axis of the camera\n    vec3 camR = vec3(1,0,0);\n    vec3 camU = vec3(0,1,0);\n    vec3 camD = vec3(0,0,-1);\n    vec3 o = vec3(0,1,0);//Camera origin\n    vec3 d = normalize(uv.x*camR+uv.y*camU+camD); //ray direction : use uv coordinate to cast the ray\n    \n    //Arbitrary time scale\n    float fTime = fract(iTime*0.2)*2.0;\n    \n    //Accumulate the values for the 4 lookup planes.\n    float fOffset = 0.0;\n    vec4 cAccum = vec4(0);\n    for(int i=0; i < 4; ++i)\n    {\n        fOffset += 0.5;\n        vec4 c = animatedNoisePlane(o,d,vec3(0,fOffset,-fOffset),fTime);\n        cAccum += (1.0-cAccum.w)*c*c.w;\n    }\n    \n    fragColor = cAccum*1.5;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}