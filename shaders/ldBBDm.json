{
    "Shader": {
        "info": {
            "date": "1500908002",
            "description": "Boaty McBoatface is taking a cave diving detour from his usual duties!! :)\nMouse X scrubs time.\n\nInfo...\n[url]https://youtu.be/dO4UhTamnb8[/url]\n\n\nMy usual anti-aliasing stack rendering is now WebGL 2 only.",
            "flags": 64,
            "hasliked": 0,
            "id": "ldBBDm",
            "likes": 103,
            "name": "[SH17B] Boaty Goes Caving",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "sea",
                "water",
                "caustics",
                "sh17b",
                "boaty"
            ],
            "usePreview": 1,
            "username": "Dave_Hoskins",
            "viewed": 10058
        },
        "renderpass": [
            {
                "code": "//[SH17B] Boaty Goes Caving\n// The unsolicited travels of Boaty McBoatface..\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Information on Boaty McBoatface https://youtu.be/dO4UhTamnb8\n// I don't think it actually has a head-light, but what the hell...\n\n// The objects are rendered by tracing through the scene scraping off any geometry that gets within an expanding limit\n// This provides a form of anti-alising and makes a nice fuzzy distance focus.\n\n// The ocean has 4 layers, a blotchy background effect, floating detritus, water caustic light, and a god-ray effect.\n// Other features are a movable spot-light & scattering, a blurry propellor and a very cool sound track found on SoundCloud that I've bought.\n\n#define FLOATY_BITS\n\nstruct March\n{\n    vec3 pos;\n    float alpha;\n    float dist;\n};\n\n#define STACK_SIZE 8\nMarch stack[STACK_SIZE];\n\nint spointer;\nfloat gTime, focus, specular, floatyBits, scatter;\nvec3 diver, sunLight, headLight, heading;\nmat3 diverMat;\n\n#define TAU 6.28318530718\n#define SUN_COLOUR vec3(.9, 1.2, 1.2)\n#define FOG_COLOUR vec3(.0, .16, .13)\n\n//========================================================================\n// Utilities...\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n#define F length(.5-fract(k.xyw*=mat3(-2,-1,2, 3,-2,1, 1,2,2)*\n\nfloat getCaustic(vec2 p)\n{\n    vec4 k = vec4(gTime*.005);\n    k.xy = p/8e1;\n    \n    return pow(min(min(F.5)),F.4))),F.3))),8.)*40.;\n}\n    \n\n// Thanks to iq for all the shape stuff...\n\n//----------------------------------------------------------------------------------------\n\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xy), p.z );\n    float d1 = -q.x-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n//----------------------------------------------------------------------------------------\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat rBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\n//----------------------------------------------------------------------------------------\nfloat cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//--------------------------------------------------------------------------\nvec3 texCube(in sampler2D tex, in vec3 p, in vec3 n )\n{\n  \n\tvec3 x = textureLod(tex, p.yz, 0.0).xyz;\n\tvec3 y = textureLod(tex, p.zx, 0.0).xyz;\n\tvec3 z = textureLod(tex, p.xy, 0.0).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(1e-20+abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//----------------------------------------------------------------------------------------\nvec2 rot2D(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\n//----------------------------------------------------------------------------------------\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n//----------------------------------------------------------------------------------------\n// Thanks to Nimitz for the triangular noise stuff...\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\nfloat noise3d(in vec3 p, in int si)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (int i=0; i<= si; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg);\n\n        bp *= 1.8;\n\t\tz *= 1.4;\n\t\tp *= 1.3;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.2;\n\t}\n\treturn rz;\n}\n\n//----------------------------------------------------------------------------------------\nfloat sMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n//----------------------------------------------------------------------------------------\nfloat sMax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n//========================================================================================\n\nfloat sphereRadius(float t)\n{\n\tt = abs(t-focus);\n\tt *= 0.02;\n\treturn clamp(t*t, 20.0/iResolution.y, 2000.0/iResolution.y);\n}\n\n//--------------------------------------------------------------------------\nvec2 cameraPath( float t )\n{\n    vec2 p = vec2(120.0 * sin(.01*t), 20.+ cos(.0071*t) * 80.0+sin(0.003*t)*80.0 );\n\treturn p;\n} \n\n//--------------------------------------------------------------------------\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+ 0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//--------------------------------------------------------------------------\nfloat diverMap(vec3 p)\n{\n\tvec3 fin = p, fin2 = p;\n    \n    vec3 b = diverMat * (diver - p);\n    float d = segment(b, vec3(.0, 0, 0), vec3(0,0,-4), 1.5, 1.3); \n    d = sMin(d, cylinder(b+vec3(0,0,0), vec2(.5,2)), 3.1); \n    d = min(d, rBox(b+vec3(0,0,1), vec3(3.0, .0, .5), .001));\n\n   \n    fin = diverMat * (diver - fin);\n    fin.xy = rot2D(fin.xy, .5);\n    //fin.x = abs(fin.x);     \n   \tfin += vec3(1.,0,3.5);\n    \n    d = min(d, rBox(fin, vec3(1.0, .02, .2), .01));\n    \n    fin2 = diverMat * (diver - fin2);\n    fin2.xy = rot2D(fin2.xy, -.5);\n    fin2 += vec3(-1.,0,3.5);\n\n   \td = min(d, rBox(fin2, vec3(1.0, .01, .2), .001));\n    \n    fin  = diverMat * (diver - p);\n    d = min(d, rBox(fin+vec3(0,1,3.5), vec3(.01, 1.0, .2), .001));\n    \n    \n    fin = diverMat * (diver - p);\n    fin.xy = rot2D(fin.xy, -abs(length(fin)*4.)+gTime*.8);\n    fin += vec3(0.,0,4.);\n    d = min(d, rBox(fin, vec3(.6, .15, .01), .01));\n\t\n\treturn d;\n}\n\nvoid diverCol(vec3 p, in float di, inout vec3 alb)\n{\n   \tvec3 fin = p, fin2 = p;\n    \n    vec3 b = diverMat * (diver - p);\n    float d = segment(b, vec3(.0, 0, 0), vec3(0,0,-3.5), 1.5, 1.2); \n    \n    d = sMin(di, cylinder(b+vec3(0,0,0), vec2(.5,2)), 3.1);\n\n\n    if (d  < 2.5)\n    {\n        alb = vec3(.8,.8,0);\n        specular  = 1.0;\n    }\n\n    \n    \n    d = min(d, rBox(b+vec3(0,0,1), vec3(3.0, .0, .5), .001));\n    if (d < 0.1) alb = vec3(1,1,1);\n   \n    fin = diverMat * (diver - fin);\n    fin.xy = rot2D(fin.xy, .5);\n    //fin.x = abs(fin.x);     \n   \tfin += vec3(1.,0,3.5);\n    \n    d = min(d, rBox(fin, vec3(1.0, .02, .2), .01));\n    \n    fin2 = diverMat * (diver - fin2);\n    fin2.xy = rot2D(fin2.xy, -.5);\n    fin2 += vec3(-1.,0,3.5);\n\n   \td = min(d, rBox(fin2, vec3(1.0, .01, .2), .001));\n    \n    fin  = diverMat * (diver - p);\n    d = min(d, rBox(fin+vec3(0,1,3.5), vec3(.01, 1.0, .1), .001));\n       \n    fin = diverMat * (diver - p);\n   fin.xy = rot2D(fin.xy, -abs(length(fin)*4.)+gTime*.8);\n    fin += vec3(0.,0,4.);\n\td = min(d, rBox(fin, vec3(.6, .15, .01), .01));\n    if (d < .2)\n    {\n        alb = vec3(1,1,1);\n        specular  = 1.0;\n    }\n\t\n}\n\n//--------------------------------------------------------------------------\nfloat map( in vec3 p, const in int detail )\n{\n    vec3 q = p * 0.0007;\n    //q.y*= 2.;\n    float d = noise3d(q, detail)*370.;\n    d = p.y-d+20.;\n\n    q = p;\n    q.xy -= cameraPath(q.z);\n    q.y*=2.;  \n    d = sMax(d, (10.-length(q.xy)), 400.);\n    d = min(diverMap(p), d);\n    if (detail <8 )\n    {\n        vec3 light= (diverMat*(p-diver));\n        light.xz = rot2D(light.xz, sin(gTime*.03)*1.1);\n\n        float s = sdCone( light, vec3(8,8,10))/length(light*light);\n        scatter += max(-s, 0.0);\n    }\n    return d;\n}\n\n//--------------------------------------------------------------------------\nfloat rays(vec2 uv, vec3 dir)\n{\n    float bri = 0.0;\n    uv.x*= 1.0+dir.y*.5;\n    uv.x += dir.x*.1;\n\n    bri += getCaustic(uv * vec2(40., 0.1))*.2;\n    bri -= pow(abs(1.0-uv.y)*.5,16.0);\n    bri  = clamp(bri,0.0,1.0);\n    \n    return bri;\n}\n//--------------------------------------------------------------------------\nvec3 getOcean(vec3 dir, vec2 uv, vec3 pos)\n{\n    vec3 col;\n    vec3 clou = dir * 2. + pos*.01+iTime*.2;\n\tfloat t = noise(dir);\n    t += noise(clou * 2.1) * .5;\n    t += noise(clou * 4.3) * .25;\n    t += noise(clou * 7.9) * .125;\n\tcol = FOG_COLOUR + vec3(.04,.08,.1) *t;\n    col+= pow(max(dot(sunLight, dir), 0.0)*.8, 4.0);\n    return col;\n}\n\nfloat cloudy(in vec3 pos)\n{\n    pos = pos*.01 - gTime*.005;\n    float t = noise(pos) * .5;\n    t += noise(pos * 2.) * .25;\n    t += noise(pos * 4.) * .125;\n    t =  pow(max(t-.5, 0.), 4.0)*40.;\n    return t;\n}\n\n//--------------------------------------------------------------------------\nvec3 getNormal(vec3 p, float e)\n{\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), 9) - map(p-vec3(e,0.0,0.0), 9),\n                            map(p+vec3(0.0,e,0.0), 9) - map(p-vec3(0.0,e,0.0), 9),\n                            map(p+vec3(0.0,0.0,e), 9) - map(p-vec3(0.0,0.0,e), 9) ) );\n}\n\n//--------------------------------------------------------------------------\n//Fill the stack by marching through the scene...\nfloat marchScene(in vec3 rO, in vec3 rD, vec2 co)\n{\n\tfloat t = hash12(co)*3.;\n\tvec4 normal = vec4(0.0);\n\tvec3 p;\n    float alphaAcc = 0.0;\n\n    spointer = 0;\n\tfor( int j=0; j < 100; j++ )\n\t{\n        // Check if it's full or too far...\n\t\tif (spointer == STACK_SIZE || t > 800.0 || alphaAcc >= 1.) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = sphereRadius(t);\n\t\tfloat h = map(p, 4);\n\t\tif( h < sphereR)\n\t\t{\n            float alpha = (1.0 - alphaAcc) * min(((sphereR-h) / sphereR), 1.0);\n\t\t\tstack[spointer].pos = p;\n            stack[spointer].alpha = alpha;\n            stack[spointer].dist = t;\n            alphaAcc += alpha;\n\t        spointer++;\n        }\n\t\tt +=  h*.45 + t*.004;\n\t}\n    return alphaAcc;\n}\t\n\n//--------------------------------------------------------------------------\n// Grab the colour...\nvec3 albedo(vec3 pos, vec3 nor)\n{\n    specular  = .0;\n    vec3 alb  = texCube(iChannel0, pos*.0005, nor);\n    vec3 alb2 = texCube(iChannel2, pos*.005, nor);\n    \n    alb = mix(alb2, alb,  smoothstep(-150., 70.0, pos.y));\n    alb=alb*alb*1.2;\n    \n    diverCol(pos, 200.0, alb);\n\n    return alb;\n}\n\n//--------------------------------------------------------------------------\nfloat shadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    \n    float t = .0;\n    for( int i = 0; i < 12; i++ )\n    {\n\t\tfloat h = map(ro + rd*t, 2);\n        res = min( res, 3.*h/t );\n        t += h*1.5+.2;\n    }\n    return clamp( res, 0., 1.0 );\n}\n\n// Set up a camera matrix\n//--------------------------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nconst int   STAR_VOXEL_STEPS = 8;\nconst float STAR_VOXEL_STEP_SIZE = 3.;\n\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n}\nvec3 getDotColour(float t)\n{\n\treturn vec3(t*.3,t*.6,t*.5);\n}\n\n// This code is the starfield stuff from iapafoto\n// https://www.shadertoy.com/view/Xl2BRR\nvec4 detritus(in vec3 ro, in vec3 rd, in float tmax) { \n \n    float d =  0.;\n    \n    vec3 ros = ro + rd*d;\n    ros /= STAR_VOXEL_STEP_SIZE;\n\tvec3 pos = floor(ros),\n\t     mm, ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ros + 0.5 + rs*0.5) * ri;\n\t\n    float dint;\n\tvec3 offset, id;\n    vec4 col = vec4(0);\n    vec4 sum = vec4(0);\n    \n    \n\tfor( int i=0; i<STAR_VOXEL_STEPS; i++ ) {\n\n        id = hash33(pos);\n        float size  = hash11(float(i))*.03+.01;\n        offset = clamp(id+.1*cos(id+(id.x)*iTime),size, 1.-size);\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint > 0. && dint*STAR_VOXEL_STEP_SIZE<tmax)\n        {\n            //col.rgb = \n            col = (vec4(getDotColour(id.x), .6)*(smoothstep(size, 0.0,d)));\n            col.a *= smoothstep(float(STAR_VOXEL_STEPS),0.,dint);\n            col.rgb *= col.a/dint;   \n            sum += (1.-sum.a)*col;\n            if (sum.a>.99) break;\n        }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n  \n\treturn sum*.75;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 lighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n  \n\tfloat sh = shadow(pos+normal*(.05+(1.0-specular)*10.),  sunLight);\n    // Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0))*sh;\n    col +=  getCaustic(pos.xz*1.1+gTime*.02)*max(normal.y, 0.)*sh*.3*SUN_COLOUR;\n    \n    col += mat * max(dot(headLight,normal), 0.0) * smoothstep(.7, .9, dot(heading, headLight))*1.6;\n    // Ambient...\n\tcol += mat  * abs(normal.y*.07);\n    \n    normal = reflect(eyeDir, normal); // Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 8.0)  * SUN_COLOUR * sh * specular;\n\n\treturn min(col, 1.0);\n}\n\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunLight  = normalize( vec3(  0.5, 0.8,  0.3 ) );\n    specular = 0.0;\n\tfloat m = (iMouse.x/iResolution.x)*500.0+170.;\n\tgTime = (iTime*4.0+m)*8.;\n    vec2 xy = abs((fragCoord.xy / iResolution.xy)-.5);\n    if (xy.y > .39)\n\t{\n\t\t// Top and bottom cine-crop - what a waste! :)\n\t\tfragColor=vec4(0,0,0,1);\n\t\treturn;\n\t}\n\tvec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    diver.z = gTime + 10.;  diver.xy = cameraPath(diver.z);\n    heading.z = diver.z+50.; heading.xy = cameraPath(heading.z);\n    heading = normalize(diver-heading);\n   \n    // Use the camera matrix function to orientate the submarine and spin it's light...\n    diverMat = setCamera(vec3(0), heading, 0.);\n\theading.xz = rot2D(heading.xz, sin(gTime*.03)*1.1);\n\n    \n\tvec3 camPos, camTar;\n    camPos.z = gTime+sin(gTime*.02)*.5;\t\tcamPos.xy = cameraPath(camPos.z);\n    camPos.y+=sin(gTime*.005)*6.;\n    camTar.z = gTime+200.; camTar.xy = cameraPath(camTar.z);\n    focus = 30.;//(diver.z- camPos.z)*.6;\n   \n        \n    mat3 camMat = setCamera(camPos, camTar, sin(gTime*.01)*.6);\n    vec3 dir = camMat * normalize( vec3(uv,cos((length(uv)))));\n     vec3 ocean = getOcean(dir, uv, camPos);\n    vec3 col = vec3(0);\n    scatter = 0.0;\n    \n    float alpha = marchScene(camPos, dir, fragCoord);\n    // Render the stack...\n    if (alpha > .0)\n    {\n\n        for (int i = 0; i < spointer; i++)\n        {\n            vec3  p = stack[i].pos; \n            float d = stack[i].dist;\n            \n            vec3 nor =  getNormal(p, sphereRadius(d)*.5);\n            vec3 mat = albedo(p, nor);\n            \n   \t        headLight = normalize(diver-p);\n            vec3  temp = lighting(mat, p, nor, dir, d);\n            temp = mix(ocean, temp , exp(-d*.005));\n            col += temp * stack[i].alpha;\n        }\n    }\n    col += ocean *  (1.0-alpha);\n    // Get shadow from the camera for the god-ray stuff...\n    float sh = shadow(camPos,  sunLight)*.4;\n    \n    #ifdef FLOATY_BITS\n    vec4 star = detritus(camPos*.4, dir,  40.);\n\tcol = col.rgb * (1.0 - star.a)+star.rgb;\n    #endif\n\n    col += rays(uv+heading.xz*.2, dir)*sh;\n    if (dir.y > 0.0 && alpha < .5)\n    {\n        float d = ((220.0-camPos.y) / dir.y);\n    \tvec2 sur = (dir.xz*d) + camPos.xz;\n    \tcol += getCaustic(sur)*pow(abs(dir.y), 2.0)*.15;\n    }\n\n    \n    col = min(col+scatter*.08, 1.0);\n    col = col*col*(3.0-col*2.0);\n    //col = col*col*3.0;\n\tcol = sqrt(col);\n    col *= pow(abs(35.0* (.39-xy.y))*(.5-xy.x), .3 );\n\tfragColor = vec4(col*smoothstep(.0, 4.,iTime), 1);//texture(iChannel1, fract(uv)).xyz,1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 11955,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/a-sound-effect/dive-deep-preview"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}