{
    "Shader": {
        "info": {
            "date": "1599241436",
            "description": "Based on https://www.shadertoy.com/view/ltj3zW but with extinction in addition to single scattering.\n\nBased on this paper https://www.arnoldrenderer.com/research/egsr2012_volume.pdf",
            "flags": 0,
            "hasliked": 0,
            "id": "ttjBRG",
            "likes": 15,
            "name": "Equiangular Scatter & Extinction",
            "published": 3,
            "tags": [
                "volumetric",
                "scattering",
                "sampling",
                "equiangular",
                "extinction"
            ],
            "usePreview": 0,
            "username": "fu5ha",
            "viewed": 1190
        },
        "renderpass": [
            {
                "code": "#define AA_SAMPLES \t\t\t2\t\t\t\t//Increase for higher overall quality\n#define VOLUME_SAMPLES\t\t4\t\t\t\t//Increase for higher volume quality\n#define CAMERA_LENS_RADIUS\t0.5\t\t\t\t//Increase for DoF\n#define FRAME_TIME\t\t\t0.05\t\t\t//Increase for Motion blur\n#define VOLUME_SCATTERING\t0.15\t\t\t//Increase for more scattering\n#define VOLUME_EXTINCTION   0.1\t\t\t\t//Increase for more extinction\n#define GAMMA \t\t\t\t2.2\t\t\t\t//\n\nfloat frameSta;\nfloat frameEnd;\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.00001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n#define MATERIAL_COUNT \t\t10\n#define BSDF_COUNT \t\t\t3\n#define BSDF_R_DIFFUSE \t\t0\n#define BSDF_R_GLOSSY \t\t1\n#define BSDF_R_SPECULAR \t2\n#define BSDF_R_LIGHT \t\t3\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//************************************************************************************\n#define BRIGHTNESS(c) (0.2126*c.x + 0.7152*c.y + 0.0722*c.z)\n\n// Data structures ****************** \nstruct Sphere { int materialId; vec3 pos; float radius; float radiusSq; float area; };\nstruct LightSample { vec3 pos; vec3 intensity; vec3 normal; float weight; };\nstruct Plane { vec4 abcd; };\nstruct Range { float min_; float max_; };\nstruct Material { vec3 color; float roughness_; int bsdf_; };\nstruct RayHit { vec4 pos_dist; vec3 normal; vec3 E; vec2 uv; int materialId; };\nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera { mat3 rotate; vec3 pos; vec3 target; float fovV; float lensSize; float focusDist; };\n//***********************************\n    \n// ************ SCENE ***************\nPlane ground;\n#define LIGHT_COUNT 2\nSphere spherelight[LIGHT_COUNT];\nSphere sphereGeometry;\nCamera camera;\n//***********************************\n\nSphere GetLightSphere( int lightId ) {\n    return spherelight[lightId];\n}\n\n#define MTL_LIGHT_1\t\t\t0\n#define MTL_LIGHT_2\t\t\t1\n#define MTL_WALL\t\t\t2\n#define MTL_SPHERE\t\t\t4\n\nMaterial materialLibrary[MATERIAL_COUNT];\n#define INIT_MTL(i,bsdf,phongExp,colorVal) materialLibrary[i].bsdf_=bsdf; materialLibrary[i].roughness_=phongExp; materialLibrary[i].color=colorVal;\nvoid initMaterialLibrary()\n{\n    INIT_MTL( MTL_WALL, BSDF_R_DIFFUSE, 0.0,  vec3( 1.0 ) );\n    \n    vec3 color = vec3( 256.0, 240.0, 160.0 );\n    vec3 blue = vec3( 200.0, 200.0, 256.0 );\n    \n    INIT_MTL( MTL_LIGHT_1, BSDF_R_LIGHT, 0.0, color*(sin(iTime*1.3)+1.1)*2.0 );\n    INIT_MTL( MTL_LIGHT_2, BSDF_R_LIGHT, 0.0, blue*2.0 );\n    INIT_MTL( MTL_SPHERE, BSDF_R_DIFFUSE, 0.0,  vec3( 0.8 ) );\n}\n\nvoid UpdateMaterial() {\n    \n}\n\nMaterial getMaterialFromLibrary( int index ){\n\treturn materialLibrary[index];\n}\n\nvoid initScene() {\n    float time = iTime;\n    float frameSta = iTime;\n    float frameEnd = frameSta + FRAME_TIME;\n    \n    //init lights\n    float r = 0.15;\n    spherelight[0] = Sphere( MTL_LIGHT_1, vec3( 2.0, 2.5, -4.0 ), r, r*r, r*r*4.0*PI );\n   // r = 0.2;\n    spherelight[1] = Sphere( MTL_LIGHT_2, vec3( -1.0, 3.5, -2.0 ), r, r*r, r*r*4.0*PI );\n\n    //ground\n    ground.abcd = vec4( 0.0, 1.0, 0.0, 1.0 );\n    \n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    sphereGeometry = Sphere( MTL_WALL, vec3( xFactor*5.0, 1.0, -5.0-yFactor*4.0 ), 1.0, 1.0, 4.0*PI );\n}\n\nvoid updateScene() {\n    vec3 pos1 \t= vec3( 2.0, 2.5 + sin(frameSta*0.15)*1.74, -4.0 + sin(frameSta*0.3)*2.734 );\n    vec3 pos2 \t= vec3( 2.0, 2.5 + sin(frameEnd*0.15)*1.74, -4.0 + sin(frameEnd*0.3)*2.734 );\n    spherelight[0].pos = mix( pos1, pos2, rnd() );\n    \n    float y1\t= 1.0 + sin(frameSta*0.7123);\n    float y2 \t= 1.0 + sin(frameEnd*0.7123);\n    sphereGeometry.pos.y = mix( y1, y2, rnd() );\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool raySphereIntersection( Ray ray, in Sphere sph, out float dist ) {\n    float t = -1.0;\n\tvec3  ce = ray.origin - sph.pos;\n\tfloat b = dot( ray.dir, ce );\n\tfloat c = dot( ce, ce ) - sph.radiusSq;\n\tfloat h = b*b - c;\n    if( h > 0.0 ) {\n\t\tt = -b - sqrt(h);\n\t}\n    \n    if ( t > 0.0 ) {\n    \tdist = t;\n        return true;\n    }\n\t\n\treturn false;\n}\n\nbool rayPlaneIntersection( Ray ray, Plane plane, out float t ){\n    float dotVN = dot( ray.dir, plane.abcd.xyz );\n   \n\tt = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;\n    return ( t > 0.0 );\n}\n// ***************************************************************************\n\n \n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 sampleHemisphere( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\n//tacken from sjb\nvoid sampleEquiAngular(\n\tRay ray,\n\tfloat maxDistance,\n\tfloat Xi,\n\tvec3 lightPos,\n\tout float dist_to_sample,\n\tout float pdf)\n{\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(lightPos - ray.origin, ray.dir);\n\t\n\t// get distance this point is from light\n\tfloat D = length(ray.origin + delta*ray.dir - lightPos);\n\n\t// get angle of endpoints\n\tfloat thetaA = atan(-delta, D);\n\tfloat thetaB = atan(maxDistance - delta, D);\n\t\n\t// take sample\n\tfloat t = D*tan(mix(thetaA, thetaB, Xi));\n\tdist_to_sample = delta + t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\n//*****************************************************************************\n\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( in vec3 pos, in vec3 target, in vec3 upDir, in float fovV, in float lensSize, in float focusDist ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n    camera.lensSize = lensSize;\n    camera.focusDist = focusDist;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(AA_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( sin(frameSta*0.154)*2.0, 2.0 + sin(frameSta*0.3)*2.0, cameraZ + sin(frameSta*0.8) );\n    pos2 = vec3( sin(frameEnd*0.154)*2.0, 2.0 + sin(frameEnd*0.3)*2.0, cameraZ + sin(frameEnd*0.8) );\n    camera.pos = mix( pos1, pos2, r1 );\n    \n    pos1 = vec3( sin(frameSta*0.4)*0.3, 1.0, -5.0 );\n    pos2 = vec3( sin(frameEnd*0.4)*0.3, 1.0, -5.0 );\n    camera.target = mix( pos1, pos2, r1 );\n    \n\tvec3 back = normalize( camera.pos-camera.target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 )\n{\n    Ray ray;\n    \n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\treturn ray;\n}\n\nbool raySceneIntersection( in Ray ray, in float distMin, out RayHit hit, out int objId, out float dist ) {\n    float nearest_dist = 10000.0;\n    \n    //check lights\n    for( int i=0; i<LIGHT_COUNT; i++ ) {\n        float distToLight;\n        if( raySphereIntersection( ray, spherelight[i], distToLight ) && (distToLight > distMin) && ( distToLight < nearest_dist ) ) {\n            nearest_dist = distToLight;\n\n            hit.pos_dist = vec4(ray.origin + ray.dir*nearest_dist, nearest_dist);\n            hit.normal = normalize(hit.pos_dist.xyz - spherelight[i].pos);\n            hit.materialId = i;\n            objId = i;\n        }\n    }\n    \n    //check sphere\n    float distToSphere;\n    if( raySphereIntersection( ray, sphereGeometry, distToSphere ) && (distToSphere > distMin) && ( distToSphere < nearest_dist ) ) {\n        nearest_dist = distToSphere;\n\n        hit.pos_dist = vec4(ray.origin + ray.dir*nearest_dist, nearest_dist);\n        hit.normal = normalize(hit.pos_dist.xyz - sphereGeometry.pos);\n        \n        vec3 n = normalize( vec3( hit.normal.x, 0.0, hit.normal.z ) );\n        float u = acos( dot( vec3(1.0, 0.0, 0.0), n ) )/PI;\n        float v = acos( dot( vec3(0.0, 1.0, 0.0), hit.normal ) )/PI;\n        \n        hit.uv = vec2( u, v );\n        \n        hit.materialId = MTL_SPHERE;\n        objId = 2;\n    }\n    \n    //check ground\n    float distToPlane;\n    if( rayPlaneIntersection( ray, ground, distToPlane ) && (distToPlane > distMin) && (distToPlane < nearest_dist ) ){\n        nearest_dist = distToPlane;\n\n        hit.pos_dist = vec4(ray.origin + ray.dir*nearest_dist, nearest_dist);\n        hit.normal = ground.abcd.xyz;\n        float uvScale = 2.0;\n        hit.uv = vec2( abs( mod( hit.pos_dist.x, uvScale )/uvScale ), abs( mod(hit.pos_dist.z, uvScale)/uvScale ) );\n        hit.materialId = MTL_WALL;\n        objId = 3;\n    }\n    \n    dist = nearest_dist;\n    if( nearest_dist < 1000.0 ) {\n    \thit.E = ray.dir*(-1.0);\n        return true;\n    } else {\n    \treturn false;\n    }\n}\n\nfloat brdfEvalBrdfPhong( in  vec3 N, in vec3 E, in vec3 L, in float roughness ){\n    vec3 R = reflect( E*(-1.0), N );\n    float dotLR = dot( L, R );\n    dotLR = max( 0.0, dotLR );\n    return pow( dotLR, roughness + 1.0 )*(roughness + 1.0)*(INV_PI);\n}\n\nfloat brdfEvalBrdfDiffuse( in vec3 N, in vec3 L ){\n    return clamp( dot( N, L ), 0.0, 1.0 )*INV_PI;\n}\n\n// GGX *****************************************************************************************\nfloat ggx_eval( in float dotNH, float alpha ) {\n    float cosThetaM = dotNH;\n    \n    if( cosThetaM < EPSILON ) {\n        return 0.0;\n    } else {\n        float alpha2 = alpha * alpha;\n        float cosThetaM2 = cosThetaM * cosThetaM;\n        float tanThetaM2 = (1.0 - cosThetaM2) / cosThetaM2;\n        float cosThetaM4 = cosThetaM2 * cosThetaM2;\n        return alpha2 / ( PI * cosThetaM4 * pow( alpha2 + tanThetaM2, 2.0 ) );\n    }\n}\n\nvec3 ggx_sample( vec3 N, float alpha, float Xi1, float Xi2 ) {\n    vec3 Z = N;\n    vec3 X = sampleHemisphere( N, Xi1, Xi2 );\n    vec3 Y = cross( X, Z );\n    X = cross( Z, Y );\n    \n    float alpha2 = alpha * alpha;\n    float tanThetaM2 = alpha2 * Xi1 / (1.0 - Xi1);\n    float cosThetaM  = 1.0 / sqrt(1.0 + tanThetaM2);\n    float sinThetaM  = cosThetaM * sqrt(tanThetaM2);\n    float phiM = TWO_PI * Xi2;\n    \n    return X*( cos(phiM) * sinThetaM ) + Y*( sin(phiM) * sinThetaM ) + Z*cosThetaM;\n}\n\nfloat ggx_g1( in float dotNV, in float dotHV, float alpha ) {\n    if( (dotHV/dotNV) < EPSILON ) {\n        return 0.0;\n    } else {\n        float cosThetaV_2 = dotNV*dotNV;\n        float tanThetaV_2 = 1.0 - cosThetaV_2;\n        float alpha2 = alpha*alpha;\n        return 2.0 / ( 1.0 + sqrt( 1.0 + alpha2 * tanThetaV_2 / cosThetaV_2 ) );\n    }\n}\n\nvec3 evalBRDF( vec3 n, vec3 l, vec3 v, float m, vec3 cdiff, vec3 cspec ) {\n\tvec3  h = normalize( l + v );\n\tfloat dotNH = max( dot( n, h ), 0.0 );\n\tfloat dotNV = max( dot( n, v ), 0.0 );\n\tfloat dotNL = max( dot( n, l ), 0.0 );\n\tfloat dotHV = max( dot( h, v ), 0.0 );\n    float dotHL = dotHV;\n    \n    float G = ggx_g1( dotNV, dotHV, m )*ggx_g1( dotNL, dotHL, m );\n    float D = ggx_eval( dotNH, m );\n    vec3  F = cspec + ( 1.0  - cspec ) * pow( 1.0 - dotHL, 5.0 );\n\n\t// BRDF Torrance-Sparrow specular\n\tvec3 spec = (F * D * G) / ( dotNV * dotNL * 4.0 );\n\t\n\t// BRDF Lambertian diffuse\n\tvec3 diff = (cdiff * ( 1.0 - F ));\n\t\n\t// Punctual Light Source ( cancel pi )\n\treturn ( spec + diff ) * dotNL;\n}\n\nvec3 calcDirectLight( vec3 pos, out vec3 wi, Sphere lightSphere, vec3 lightColor ) {\n    vec3 Li = lightColor;\n    vec3 Lo = vec3( 0.0 );\n    \n    vec3 dirToLightCenter = lightSphere.pos - pos;\n    float distToLightCenter2 = dot(dirToLightCenter, dirToLightCenter);\n    float cos_a_max = sqrt( 1.0 - clamp( lightSphere.radiusSq / distToLightCenter2, 0.0, 1.0 ) );\n    float omega = TWO_PI * (1.0 - cos_a_max);\t//solid angle\n    float cosa = mix(cos_a_max, 1.0, rnd());\n    float sina = sqrt(1.0 - cosa*cosa);\n\n    wi = uniformDirectionWithinCone( dirToLightCenter, TWO_PI*rnd(), sina, cosa );\n    float pWi = (1.0/omega);\n\n    Ray shadowRay = Ray( pos, wi );\n    float dist;\n    raySphereIntersection( shadowRay, lightSphere, dist );\n\n    float tmpDist;\n    RayHit tmpHit;\n    int tmpObjId;\n    raySceneIntersection( shadowRay, EPSILON, tmpHit, tmpObjId, tmpDist );\n    float eps = tmpDist*0.0001;\n\n    if( EQUAL_FLT( tmpDist, dist, eps ) ) {\n        float throughput = exp(-VOLUME_EXTINCTION * dist);\n        Lo += throughput * Li / pWi;\n    }\n\n    return Lo;\n}\n\nvec3 calcLightOnSurface( RayHit hit ) {\n    vec3 Lo = vec3( 0.0 );\n    Material surfMtl = getMaterialFromLibrary( hit.materialId );\n\n    if( surfMtl.bsdf_ == BSDF_R_LIGHT ) {\n        Lo = surfMtl.color;\n    } else {\n        vec3 surfColor = surfMtl.color;\n        float specVal = 0.7;\n            \n        if( hit.materialId == MTL_WALL ) {\n            surfColor = texture( iChannel0, hit.uv ).xyz;\n        } else if( hit.materialId == MTL_SPHERE ) {\n            surfColor = texture( iChannel1, hit.uv ).xyz;\n            specVal = 1.0 - BRIGHTNESS(texture( iChannel1, hit.uv ).xyz);\n        }\n        \n        vec3 wi;\n        \n        for( int i=0; i<LIGHT_COUNT; i++ ) {\n            vec3 Li = materialLibrary[i].color;\n            vec3 directLight = calcDirectLight( hit.pos_dist.xyz, wi, spherelight[i], Li );\n            \n            if( dot( wi,hit.normal ) > 0.0 ) {\n                vec3 cdiff = vec3( specVal );\n                vec3 cspec = vec3( 1.0 - specVal );\n                vec3 brdf = evalBRDF( hit.normal, wi, hit.E, 0.4, cdiff, cspec );\n\n                Lo += directLight*brdf*surfColor;\n            }\n        }\n        float throughput = exp(-VOLUME_EXTINCTION * hit.pos_dist.w);\n        Lo *= throughput/float(LIGHT_COUNT);\n    }\n    \n    return Lo;\n}\n\nvec3 calcLightOnParticle( vec3 particlePos, Sphere lightSphere, vec3 Li ) {\n    vec3 wi;\n    return calcDirectLight( particlePos, wi, lightSphere, Li );\n}\n\nvec3 Radiance( in Ray ray ) {\n    vec3 surfaceShaded = vec3(0.0);\n   \n    \n    RayHit hit;\n    int objId;\n    float dist = 100.0;\n    if( raySceneIntersection( ray, 0.0, hit, objId, dist ) ) {\n        surfaceShaded = calcLightOnSurface( hit );\n    }\n    \n    \n    vec3 particleShaded = vec3(0.0);\n    for( int i=0; i<LIGHT_COUNT; i++ ) {\n\t\tvec3 Li = (i==0)?materialLibrary[MTL_LIGHT_1].color:materialLibrary[MTL_LIGHT_2].color;\n        for (int s=0; s<VOLUME_SAMPLES; s++) {\n        \tfloat particleDist;\n        \tfloat particlePdf;\n            float Xi = (1.0/float(VOLUME_SAMPLES))*(float(s) + rnd());\n        \tsampleEquiAngular( ray, dist, Xi, spherelight[i].pos, particleDist, particlePdf );\n        \tvec3 particlePos = ray.origin + particleDist*ray.dir;\n        \n        \tfloat throughput = exp(-VOLUME_EXTINCTION * particleDist);\n\n        \tparticleShaded += VOLUME_SCATTERING * throughput * calcLightOnParticle( particlePos, spherelight[i], Li )/(particlePdf * FOUR_PI * float(VOLUME_SAMPLES));\n        }\n    }\n    particleShaded *= 1.0/float(LIGHT_COUNT);\n    \n    return surfaceShaded + particleShaded;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    frameSta = iTime;\n    frameEnd = frameSta + FRAME_TIME;\n\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n\tfloat sinTime = sin(iTime*0.2);\n   \n    float fov = radians(45.0);\n\n    initCamera( vec3( 0.0, 0.0, 0.0 ), vec3( 0.0, 0.0, 0.0 ), vec3( 0.0, 1.0, 0.0 ), fov, CAMERA_LENS_RADIUS, 8.0 );\n    \n    initMaterialLibrary();\n    initScene();\n    \n\tvec3 accumulatedColor = vec3( 0.0 );\n\tfor(int si=0; si<AA_SAMPLES; ++si ){\n    \tupdateScene();\n        updateCamera( si );\n        \n        vec2 screenCoord = fragCoord.xy + vec2( (1.0/float(AA_SAMPLES))*(float(si)+rnd()), rnd() );\n        Ray ray = genRay( screenCoord, rnd(), rnd() );\n        \n        if( length( ray.dir ) < 0.2 ) {\n            accumulatedColor = vec3( 0.0 );\n        } else {\n        \taccumulatedColor += Radiance( ray );\n        }\n\t}\n\t\n\t//devide to sample count\n\taccumulatedColor = accumulatedColor*(1.0/float(AA_SAMPLES));\n\t\n\t//gamma correction\n    accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n    \n\t\n\tfragColor = vec4( accumulatedColor,1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}