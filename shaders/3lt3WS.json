{
    "Shader": {
        "info": {
            "date": "1578290810",
            "description": "generalization of Sierpinski's method",
            "flags": 0,
            "hasliked": 0,
            "id": "3lt3WS",
            "likes": 10,
            "name": "Recursive Platonic solids",
            "published": 3,
            "tags": [
                "imi202001"
            ],
            "usePreview": 0,
            "username": "tomoe",
            "viewed": 470
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define PHI 1.618033988749895\n#define v1 vec3(1.0, 0.0, 0.0)\n#define v3 vec3(0.0, 0.0, 1.0)\nvec3 v2, w1, w2, w3;\nvec3 vtxP, edgN, faceN;\nfloat rad = 1.0;\nvoid init(float m) {\n    v2 = vec3(-0.5, sqrt(0.75 - pow(cos(PI / m), 2.0)), - cos(PI / m));\n    float triProd = dot(cross(v1, v2), v3);\n    w1 = normalize(cross(v3, v2) / triProd);\n    w2 = normalize(cross(v1, v3) / triProd);\n    w3 = normalize(cross(v2, v1) / triProd);\n}\nfloat edgSDF(vec3 p, float t) {// t:thickness\n    return max(abs(dot(p - vtxP, faceN)), abs(dot(p - vtxP, edgN))) - t;\n}\nfloat vtxSDF(vec3 p, float t) {\n    return length(p - vtxP) - t;\n}\nfloat faceSDF(vec3 p, float t) {\n    return dot(p - vtxP, faceN) - t;\n}\n#define fold(w)p = p - 2.0 * max(dot(w, p), 0.0) * w;\nfloat tetraSDF(vec3 p) {\n    init(3.0);\n    float scale = 2.0;\n    float scalePow = 1.0;\n    vtxP = rad * w1;\n    for(int i = 0; i < 4; i ++ ) {\n        fold(v1)fold(v3)fold(v2)fold(v3)fold(v1)fold(v2)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }  \n    edgN = w2;\n    faceN = w3;\n    return edgSDF(p, 0.1) / scalePow;\n}\nfloat cubeSDF(vec3 p) {\n    init(4.0);\n    vtxP = rad * w3;\n    float scale = 2.5;\n    float scalePow = 1.0;\n    for(int i = 0; i < 4; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w1;\n    return faceSDF(p, 0.5) / scalePow;\n}\nfloat octaSDF(vec3 p) {\n    init(4.0);\n    vtxP = rad * w1;\n    float scale = 2.0;\n    float scalePow = 1.0;\n    for(int i = 0; i < 3; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w3;\n    return min(edgSDF(p, 0.02), vtxSDF(p, 0.3)) / scalePow;\n}\nfloat dodecaSDF(vec3 p) {\n    init(5.0); \n    vtxP = rad * w1;\n    float scale = PHI + 1.0;\n    float scalePow = 1.0;\n    for(int i = 0; i < 3; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w3;\n    return faceSDF(p, 0.0) / scalePow;\n}\nfloat icosaSDF(vec3 p) {\n    init(5.0);\n    vtxP = rad * w3;\n    float scale = PHI + 1.0;\n    float scalePow = 1.0;\n    for(int i = 0; i < 3; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w1;\n    return edgSDF(p, 0.08) / scalePow;\n}\nmat3 euler(float h, float p, float r) {\n    return mat3(\n        cos(r) * cos(h) - sin(r) * sin(p) * sin(h), - sin(r) * cos(p), cos(r) * sin(h) + sin(r) * sin(p) * cos(h),\n        sin(r) * cos(h) + cos(r) * sin(p) * sin(h), cos(r) * cos(p), sin(r) * sin(h) - cos(r) * sin(p) * cos(h),\n        - cos(p) * sin(h), sin(p), cos(p) * cos(h)\n    );\n}\n#define seq(v, s)d = mix(d, v, smoothstep(s - 0.3, s, t));\nfloat sceneSDF(vec3 p) {\n    float seqStep = 5.0;\n    float t = abs(mod(iTime * 0.5, seqStep * 2.0) - seqStep);\n    float d = tetraSDF(p);\n    seq(cubeSDF(p), 1.0)\n    seq(octaSDF(p), 2.0)\n    seq(dodecaSDF(p), 3.0)\n    seq(icosaSDF(p), 4.0)\n    return d;\n}\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n            sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p + vec3(-d, 0.0, 0.0)),\n            sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p + vec3(0.0, - d, 0.0)),\n            sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p + vec3(0.0, 0.0, - d))\n        ));\n    }\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //camera transform\n    float t = 0.3 * iTime;\n    mat3 g = euler(t, t, t);\n\n    // camera\n    vec3 cPos = g * vec3(0.0, 0.0, 2.0);\n    vec3 cDir = g * vec3(0.0, - 0.0, - 1.0);\n    vec3 cUp = g * vec3(0.0, 1.0, 0.0);\n    float targetDepth = 1.0;\n    vec3 cSide = cross(cDir, cUp);\n\n    // light\n    vec3 lightPos = g * vec3(0.0, 1.0, 1.0);\n\n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    vec3 rPos = cPos ;\n\n    // marching loop\n    for(int i = 0; i < 60; i ++ ) {\n        rPos += sceneSDF(rPos) * ray;\n    }\n\n    // collision detection\n    if (sceneSDF(rPos) < 0.001) {\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(normalize(lightPos - rPos), normal), 0.01, 1.0);\n        vec3 amb = vec3(0.0, 1.0, 0.0);\n        fragColor = vec4(diff * amb, 1.0);\n    } else {\n        fragColor = vec4(1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}