{
    "Shader": {
        "info": {
            "date": "1577560800",
            "description": "MDTMJVM = Middecembertomidjanuaryvember\nA month of coding stuff.\nCoding some of the days at http://twitch.tv/wwrighter",
            "flags": 32,
            "hasliked": 0,
            "id": "Wlc3D2",
            "likes": 7,
            "name": "[twitch] Day 10 of MDTMJVM",
            "published": 3,
            "tags": [
                "truchet",
                "tiling",
                "evvvvil"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 539
        },
        "renderpass": [
            {
                "code": "// color scheme screams evvvvil \n// but... eeeh :D \n\n//#define TRIPPY\n\nbool TRIPPY = false;\n\n#define dmin(a, b) (a.x < b.x) ? a : b\n\n#define fov 0.9\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n  vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*1. + right*uv.x*fov + up*uv.y*fov;\n}\n\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define pi acos(-1.)\n\n#define dmin(a, b) (a.x < b.x) ? a : b // takes 2 vec2, does a minimum of them \n#define dmax(a, b) (a.x > b.x) ? a : b\n\n#define pmod(p, x) (mod(p,x) - x*0.5)\n\n\nfloat sdBox(vec3 p, vec3 r){\n  p = abs(p);\n  p-= r;\n  return max(p.x, max(p.y, p.z));\n}\n\nfloat rand;\n\n\nfloat sdTorus(vec3 p, float r, float w){\n  float polarPosPipe = atan(p.y, p.x); \n  vec2 t = vec2(length(p.xy) - r, p.z);\n  return length(t) - w;\n}\n\n//float sdBox(vec3 p )\n\nfloat pulse = 0.;\n\nfloat sdCyllinder(vec3 p, float r){\n  p = abs(p)- r;\n  return max(p.x, p.y) ;\n}\n\nfloat sdCyllinderXZ(vec3 p, vec2 r){\n  r.x *= 0.704; // ?? uhm... ookaay, professional botching\n  p.xz = abs(p.xz)- r;\n  return max(p.x, p.z) ;\n}\n\nfloat sdCoolCyllinder(vec3 p, float r){\n  float dCyllA = sdCyllinder(p, r);\n  float dCyllB = sdCyllinder(p, r*0.6);\n  \n  //d = max(d, (fract(p.y*10.) - 0.2 ));  \n  float d = max(dCyllA,-dCyllB);\n  \n  //d = max(d, p.z);\n  \n  return dCyllA;\n}\n\nfloat r31(vec3 p) {\n    return fract(sin(p.x*46.4142 + p.y*51.2421 + p.z*32.23)*125.215);\n}\n\n#define WIDTH 0.1\n\nvec2 mapA(vec3 p, float scale, vec3 offs){ // gets distance to everything\n  vec2 d = vec2(10e3); // d.x = distance, d.y = id\n  \n  p -= offs;\n  p *= scale;\n  float width = WIDTH/scale;\n  \n  vec3 id = floor(p);\n  \n  \n  rand = r31(id);\n  p = pmod(p, 1.);\n  \n    if(TRIPPY) {\n        for (int i = 0; i < 2; i++) {\n            p.x = abs(p.x);\n            p.y = abs(p.y);\n            //p.x -= 0.4;\n            p.y -= 0.-0.;\n            p.xy *= rot(0.2 + sin(iTime)*0.0 + id.x*0.2);\n            //p.yz *= rot(0.2 + sin(iTime)*0.0 + id.y*0.1 - id.z*0.6);\n        }\n    }\n    \n  if (rand < 0.4) {\n    \n\n  } else {\n    p.yz *= rot(0.5*pi);\n  }\n  vec3 posPipeA = p -  vec3(-0.25,-0.25,0);\n  vec3 posPipeB = p - vec3(0.25,0.25,0);\n  posPipeA.xy *= rot(-0.25*pi);\n  posPipeB.xy *= rot(-0.25*pi);\n\n  \n  d = dmin(d, vec2(sdCyllinderXZ(posPipeA, vec2(WIDTH)), 2.));\n  d = dmin(d, vec2(sdCyllinderXZ(posPipeB, vec2(WIDTH)), 2.));\n  d = dmin(d, vec2(sdCoolCyllinder(p, WIDTH), 2.));\n  d.y = 2.;\n  \n  d.x *= 0.17;\n  return d;\n}\n\n\nvec2 map(vec3 p){ // gets distance to everything\n  vec2 d = vec2(10e3); // d.x = distance, d.y = id\n  \n  float width = WIDTH;\n  vec3 id = floor(p);\n  \n  rand = r31(id);\n  p = pmod(p, 1.);\n  \n  if (rand < 0.5) {\n    \n\n  } else {\n    p.yz *= rot(0.5*pi);\n  }\n    vec3 posPipeA = p -  vec3(-0.25,-0.25,0);\n    vec3 posPipeB = p - vec3(0.25,0.25,0);\n    posPipeA.xy *= rot(-0.25*pi);\n    posPipeB.xy *= rot(-0.25*pi);\n\n    \n    \n    d = dmin(d, vec2(sdCyllinderXZ(posPipeA, vec2(width)), 1.));\n    d = dmin(d, vec2(sdCyllinderXZ(posPipeB, vec2(width)), 1.));\n    d = dmin(d, vec2(sdCoolCyllinder(p, width), 1.));\n  \n  \n  vec2 d2 = mapA(p, 5., vec3(0.2,2.,0));\n  \n  d.x *= 0.7;\n  \n  d = dmax(d, -d2);\n  \n  return d;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.002, 0.);\n  return normalize(map(p).x - vec3(\n    map(p - t.xyy).x,\n    map(p - t.yxy).x,\n    map(p - t.yyx).x\n  ));\n}\n\n\n\nvec3 glow = vec3(0);\n\n#define spectra(x,t) (0.5 + 0.5*sin(vec3(0.6,0.2,0.7)*x + t)) \n#define rotSpeed 1.\n\nvec4 render(vec2 uv) {\n  vec3 col = vec3 (0);\n\n  //vec3 ro = vec3(0 + sin(iTime*0.001)*2. + 6.5,-4.,0 + sin(iTime*0.001)*1000.);\n  vec3 ro = vec3(0. + sin(iTime*0.01)*0. + 4.,-1.,0. + sin(iTime*0.001)*1000.);\n  //vec3 lookAt = ro + vec3(0. + sin(iTime)*0.5,0,1);\n  vec3 lookAt = ro + normalize(vec3(sin(iTime*0.6),cos(iTime*0.6),sin(iTime*0.4)));\n  \n  \n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  float t = 0.;\n  float tBeforeReflect = 0.;\n  bool didReflect = false;\n  vec3 p = ro;\n  \n  float attenuation = 1.;\n    #define ITERS 80\n  for (int i = 0; i < ITERS; i++) {\n    vec2 d = map(p);\n      if(!didReflect) {\n    \tglow += spectra(d.x*1. + t*1. + p.x*0.1, 10.)*0.009;\n      }\n    \n    if (d.x < 0.001){\n      vec3 lDir = normalize(vec3(-1));\n      vec3 n = getNormal(p);\n       \n      vec3 albedo = vec3(0);\n      float metalness = 0.;\n      if (d.y == 1.) {\n        albedo = vec3(0.0001);\n        metalness = 0.1;\n      } else {\n        albedo = vec3(0.37,0.26,0.);  \n        metalness = 0.0;\n      }\n      \n      float diff = max(dot(lDir, n),0.);\n      float fres = pow(max(dot(n, -rd), 0.), 4.);\n      float spec = pow(max(dot(n, normalize(lDir -rd)), 0.), 6.);\n      //float specular = pow(max(dot(n, -rd), 0.), 4.);\n      \n  \n      //col += (albedo*diff + fres*diff*0.1)*attenuation;\n        \n        if (d.y == 1.) {\n      \t\tcol += (albedo*diff + pow(fres*spec, 4.)*0.01 )*attenuation;\n        } else {\n      \t\tcol += (albedo*diff*1.4 + fres*spec*0.3 )*attenuation*0.5;\n        }\n      attenuation -= 1. - metalness;\n      attenuation = max(attenuation, 0.);\n    \n        if (!didReflect) {\n            tBeforeReflect = t;\n        }\n  \t  \tdidReflect = true;\n        if (didReflect) {\n            t = 0.;\n            d.x = 0.4;\n            ro = p;\n            rd = reflect(rd, n);\n            //rd = refract(rd, n, 1.);\n        }\n      \n      //break;\n      }\n      if (t > 25. || i == ITERS - 1 && !didReflect ) {\n        tBeforeReflect = t;\n        break;\n      }\n      \n      \n     t += d.x;\n     p = ro + rd*t;\n  }\n  vec3 fog = smoothstep(0.,1.,tBeforeReflect*0.2 - 0.4)*vec3(0.1,0.1,0.1)*0.1;\n  col += fog;\n\n    \n    \n  col += pow(glow,vec3(2.))*2.;\n  col = ACESFilm(col);  \n  col = pow(col, vec3(0.45));\n  \n  return vec4(col, 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    TRIPPY = (iTime < 10.) ? false : true;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 ACESFilm( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return max(vec3(.0), min(vec3(1.0), (x*(a*x+b))/(x*(c*x+d)+e) ) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Calculates camera positions\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if (iFrame > 1) {\n    \n    }\n    //fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}