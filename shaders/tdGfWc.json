{
    "Shader": {
        "info": {
            "date": "1608258564",
            "description": "Adaptive importance sampling\nTesting on a scrambled caustic scene",
            "flags": 48,
            "hasliked": 0,
            "id": "tdGfWc",
            "likes": 18,
            "name": "Adaptive importance sampling",
            "published": 3,
            "tags": [
                "random",
                "pathtracing",
                "importancesampling"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 574
        },
        "renderpass": [
            {
                "code": "//MIT License\n//Copyright 2020 Mykhailo Moroz\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//Inspired by Nvidia's \"Spatiotemporal reservoir resampling\" paper\n//https://research.nvidia.com/sites/default/files/pubs/2020-07_Spatiotemporal-reservoir-resampling/ReSTIR.pdf\n\n//Basically I thought what if instead of storing a reservoir of light source strategies\n//we would fit virtual light sources using gaussian distributions for each pixel?\n//This shadertoy is a \"kinda\" proof of concept that this does work\n\n//Considering the limitations of shadertoy this particular implementation only works well\n//with 4 distributions, and only with 1 sample per frame per pixel\n\n//The gaussians were fitted by clusterizing the samples using k-means, i.e. \n//counting only the closest samples to this distribution.\n\n//The convergence speed is greately improved because of spacio-temporal reuse,\n//but its quite hard to keep it unbiased, and until the distributions are stabilized the samples\n//are quite biased, similarly to metropolis light transport.\n\n//This can be extended to more than 1 ray bounce if the surface is in screenspace.\n//For surfaces outside of that(and volumetric things) we can use a volumetric grid \n//and store/update the distributions there. A sparse voxel octree is probably a good choice for that.\n\n//I recommend using the unofficial shadertoy plugin to incread the number of \n//paint calls per frame for faster convergence (8x+ recommended)\n//since I can not use more SPP because I need to fit the gaussian and accumulate samples\n//which would require at least 8 channels in a texture\n\n//The current bottleneck of this algorithm is the multi gaussian fitting algo,\n//k-means gives suboptimal results\n\n//Keyboard buttons:\n// M - distribution mean display\n// S - distribution sigma display\n// C - comparison with pure uniform path tracing\n//Look in Common for constants to tune, you can enable spectral path tracing there too\n\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\nfloat draw_distribution(vec2 p, vec3 d)\n{\n    vec4 data = ch1(p);\n    vec3 mean = normalize(data.xyz);\n    float sigma = length(data.xyz);\n    return gpdf(d, mean, sigma);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    INIT;\n    \n    vec4 data = ch1(p);\n   \n    //light distribution\n    float sigma = length(data.xyz);\n    float wsum = data.w;\n    vec3 mean = normalize(data.xyz);\n    \n    vec4 l = ch2(p); \n    c = tanh(vec4(1., 1.05, 1.2, 1.0)*10.*pow(l/l.w, vec4(1.5)));\n\n    if(isKeyToggled(KEY_M))\n        c.xyz = vec3(1.)*(0.5*mean + 0.5);\n    else if(isKeyToggled(KEY_S))\n        c.xyz = vec3(5.)*sigma;\n    \n    //render incoming light\n    if(isKeyToggled(KEY_A))\n    {\n        vec3 x = 20.*vec3((iMouse.xy - 0.5*R.xy)/600., 0.);\n        vec3 d = normalize(vec3(2.*(p.xy - 0.5*R.xy)/600., 1.0));\n        float S = trace(x, d, 460.0);\n        \n        float D = 0.;\n        vec2 ci = cell_size*floor(iMouse.xy/cell_size);\n        range(i, 0, cell_S) range(j, 0, cell_S)\n            D += draw_distribution(ci +vec2(i,j), d);\n        \n        c.xyz = vec3(S, S, D);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//spectral path tracing\n//monochromatic converges faster\n//#define SPECTRAL\n#define BLUR\n#define BLUR_STR 0.1\n\n//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//texture sampling\n#define ch0(p) texelFetch(iChannel0, ivec2(mod(p, R)), 0)\n#define ch1(p) texelFetch(iChannel1, ivec2(mod(p, R)), 0)\n#define ch2(p) texelFetch(iChannel2, ivec2(mod(p, R)), 0)\n#define ch3(p) texelFetch(iChannel3, ivec2(mod(p, R)), 0)\n\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//adaptive importance sampling params\n#define temporal_loss 0.1\n#define spacial_blur 0.05\n//pixel cell with the gaussian distributions\n#define cell_size 2.0\n#define cell_S 2\n#define cell_L 4\n\nfloat time; vec2 mouse; vec2 R;\n\n#define INIT time = float(iFrame)/60.; mouse = iMouse.xy; R = iResolution.xy;\n\n//random number generation\n\n//WIP\n//#define BLUE\n\nuint ns; vec2 pix;\n\nvoid RNGupdate()\n{\n    // integer hash copied from Hugo Elias\n\tns = (ns << 13U) ^ ns;\n    ns = ns * (ns * ns * 15731U + 789221U) + 1376312589U;\n}\n\n//https://www.shadertoy.com/view/WsfBDf\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat IGN(int d, vec2 s) \n{\n    s += (float(ns%25093u + uint(d)) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pix.x + s.x) + 0.00583715f*float(pix.y + s.y)));  \n}\n\n\n#ifdef BLUE\n    #define INIT_RNG ns = uint(iFrame*24676); pix = p;\n\n    vec2 rnd2() \n    {\n        RNGupdate();\n        uvec2 k = ns * uvec2(ns,ns*16807U);\n        return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n    }\n\n    float rand() \n    {\n        vec2 s = rnd2()*1e4;\n        return IGN(0, s);\n    }\n\n    vec2 rand2() \n    {\n        vec2 s = rnd2()*1e4;\n        return vec2(IGN(0, s),IGN(1, s));\n    }\n\n    vec4 rand4() \n    {\n        vec2 s = rnd2()*1e4;\n        return vec4(IGN(0, s),IGN(1, s),IGN(2, s),IGN(3, s));\n    }\n#else\n    #define INIT_RNG ns = uint(iFrame*24676) + uint(p.x*5557.0) + uint(p.y*8482.0);\n\n    float rand() \n    {\n        RNGupdate();\n        return float( (ns * ns) & uvec2(0x7fffffffU))/float(0x7fffffff);\n    }\n\n    vec2 rand2() \n    {\n        RNGupdate();\n        uvec2 k = ns * uvec2(ns,ns*16807U);\n        return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n    }\n\n    vec4 rand4() \n    {\n        RNGupdate();\n        uvec4 k = ns * uvec4(ns,ns*16807U,ns*48271U,ns*21171U);\n        return vec4( k & uvec4(0x7fffffffU))/float(0x7fffffff);\n    }\n#endif\n\n// Implements the Box-Muller transform\n// to generate normally distributed random numbers\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = clamp(rand2(), 0.01, 1.0);\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n\tvec4 Z = clamp(rand4(), 0.01, 1.0);\n    return mean + sigma * sqrt(-2.0 * log(Z.xxyy)) * \n           vec4(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w),sin(TWO_PI * Z.w));\n}\n\nfloat gpdf(vec3 delta, vec3 d, float R)\n{\n    float ddot = dot(delta, d);\n    float ddot2 = ddot*ddot;\n    float sigma2 = R*R;\n    \n    //probability distribution function(unbiased)\n    return (1.0/TWO_PI)*(ddot2/sigma2 + 1.0)*exp( (ddot2 - dot(delta, delta))/(2.0 * sigma2) );\n}\n\n//sample random direction from a point to a 3D normal distribution\nvec3 gdir(in vec3 p0, in vec3 N, in vec3 p1, in float R, out float pdf)\n{\n    //sample random point from the cloud\n    vec3 rn = nrand4(R, vec4(p1,0)).xyz;\n    \n    //random direction\n    vec3 d = normalize(rn - p0);\n    //reflect to the positive hemisphere\n    d *= sign(dot(N,d));\n    \n    vec3 delta = p0 - p1;\n    \n    pdf = gpdf(delta, d, R);\n\n    return d;\n}\n\n//sample uniform direction in a hemisphere\nvec3 udir(vec3 N, out float pdf)\n{\n    //sample random point from the cloud\n    vec3 rn = normalize(nrand4(1.0, vec4(0.0)).xyz);\n    \n    pdf = 1.0/TWO_PI;\n    \n    //random direction\n    return rn * sign(dot(N, rn));\n}\n\n\n//data packing \n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))\n\n\n//useful\n\n#define sqr(x) (x)*(x)\n\n//https://www.shadertoy.com/view/ls2Bz1\nvec3 spectral_spektre (float l)\n{\n\tfloat r=0.0,g=0.0,b=0.0;\n\t\t\tif ((l>=400.0)&&(l<410.0)) { float t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n\telse if ((l>=410.0)&&(l<475.0)) { float t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n\telse if ((l>=545.0)&&(l<595.0)) { float t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n\telse if ((l>=595.0)&&(l<650.0)) { float t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n\telse if ((l>=650.0)&&(l<700.0)) { float t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n\t\t\tif ((l>=415.0)&&(l<475.0)) { float t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n\telse if ((l>=475.0)&&(l<590.0)) { float t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n\telse if ((l>=585.0)&&(l<639.0)) { float t=(l-585.0)/(639.0-585.0); g=0.82-(0.80*t)           ; }\n\t\t\tif ((l>=400.0)&&(l<475.0)) { float t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n\telse if ((l>=475.0)&&(l<560.0)) { float t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n\n\treturn vec3(r,g,b);\n}\n\n//scene\n\nfloat sample_light(vec3 r)\n{\n    vec3 ldir = normalize(vec3(0.,0., 1.0));\n    return 500.*step(0.996, dot(r, ldir));\n}\n\n//wavy surface\nfloat map(vec3 p)\n{\n    return 0.7*(4.5-p.z+0.6*cos(length(p.xy)) - 0.6*sin(0.5*distance(p.xy, vec2(30,10)))\n                + 0.6*sin(0.8*p.x+10.*mouse.x/R.x) + 0.4*cos(0.3*p.x + 0.6*p.y - 10.*mouse.y/R.y) +\n                 + 0.4*cos(-0.6*p.x + 0.1*p.y) + 0.7*cos(-0.3*p.x - 0.5*p.y)\n                 + 0.2*cos(2.0*p.x - 0.2*p.y) + 0.1*cos(1.7*p.x - 2.2*p.y));\n                 //+ 0.07*cos(4.0*p.x + 3.2*p.y) + 0.03*cos(0.1*p.x - 5.2*p.y));\n}\n\nvec4 grad(vec3 p, float dx) \n{\n\tconst vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx))/4.;\n}\n\n\nvec3 ray_march(inout vec3 p, in vec3 d)\n{\n    for(int i = 0; i < 32; i++)\n    {\n        float DE = map(p);\n        p += DE*d;\n    }\n    return normalize(grad(p, 0.01).xyz);\n}\n\n//refraction index wavelength dependence \nfloat dispersion(float w)\n{\n    //return 2.8;\n    return 8.0 - 8.0*(w - 300.)/500.;\n}\n\nfloat trace(in vec3 p, in vec3 d, float w)\n{\n    vec3 N = ray_march(p,d);\n    vec3 d1 = refract(d, N, dispersion(w));\n    return sample_light(d1);\n}\n\n\n//Keyboard constants\nconst int KEY_SPACE  = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//SAMPLE RAYS USING THE APPROXIMATED LIGHT DISTRIBUTION FOR IMPORTANCE SAMPLING \nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    INIT;\n    INIT_RNG;\n    \n    vec3 N = vec3(0,0,1);\n    vec3 P =20.*vec3(((p-0.5*R.xy + rand2() - 0.5)/600.0), 0.);\n    \n    vec4 prev_sample = ch0(p);\n   \n    //choose a random cell\n    vec2 ci = cell_size*(floor(p/cell_size + 2.*rand2() - 1.0));\n    //choose a random distribution\n    vec2 dx = (cell_size-1.0)*round(rand2());\n    vec4 data = ch1(ci+dx);\n   \n    //light distribution\n    float sigma = length(data.xyz);\n    if(isKeyToggled(KEY_C)) sigma=(p.x > R.x*0.5)?sigma:1.0;\n    float ill = data.w;\n    vec3 mean = normalize(data.xyz);\n    \n    float pdf;\n    vec3 r = gdir(vec3(0), N, mean, sigma, pdf);\n    \n    #ifdef SPECTRAL\n        //sample random wavelength\n        float wl = 430.0 + 270.0*pow(rand(),3.0);\n    #else\n        //monochromatic ish\n        float wl = 460. + 10.*p.x/R.x;\n    #endif\n    \n    float S = trace(P, r, wl)/pdf;\n    \n    //store the sample dir, wavelength and ill \n    c = vec4(r*wl, S);\n    \n    if(iFrame < 1) c = vec4(0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//UPDATE THE APPROXIMATED LIGHT DISTRIBUTION\n//n^2 gaussian distributions\n//n*n pixel cell\n\nvec4 cell[cell_L];\nint local;\n\nvoid load_distribution(vec2 p, out float wsum, out float sigma, out vec3 mean)\n{\n    vec4 data = ch1(p);\n    wsum = data.w;\n    mean = normalize(data.xyz);\n    sigma = length(data.xyz);\n}\n\nvec4 load_neigh(vec2 p, int d, out float wsum)\n{\n    vec2 x = vec2(d/cell_S, d%cell_S);\n    vec3 mean; float sigma;\n    load_distribution(p + x, wsum, sigma, mean);\n    return vec4(mean, sigma);\n}\n\nvoid load_cell(vec2 p)\n{\n    vec2 ci = cell_size*floor(p/cell_size);\n    vec2 cd = floor(p) - ci;\n    local = int(cd.y*cell_size + cd.x);\n    float wsum;\n    for(int i = 0; i<cell_L; i++)\n        cell[i] = load_neigh(ci, i, wsum);\n}\n\n//reject all samples that do not fall into this distribution\nfloat rejection(vec3 d)\n{\n    //distance rejection\n    int id = 0;\n    float dmin = 1e10;\n    float dlocal = 0.;\n    for(int i = 0; i<cell_L; i++)  \n    {\n        float d = distance(cell[i].xyz, d);\n        if(i == local) dlocal = d;\n        if(d < dmin) {id = i; dmin = d;}\n    }\n    \n    return step(1.0,dmin/dlocal);\n    \n    \n    //probability rejection\n    //(is not stable)\n    \n    /*float p0 = 0.;\n    float p1 = 0.;\n    for(int i = 0; i<4; i++)  \n    {\n        float p = gpdf(d, cell[i].xyz, cell[i].w);\n        if(i == local) p1 += p;\n        else p0 += p;\n    }\n    return smoothstep(0.3, 3.0, 3.*p1/p0);\n    */\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    INIT;\n    INIT_RNG;\n    load_cell(p);\n   \n    //light distribution\n    float wsum; vec3 mean; float sigma;\n   \n    //load\n    load_distribution(p, wsum, sigma, mean);\n    \n    //neighbor cell blur\n    float wsum0, sigma0; vec3 mean0;\n    float sigmaB = sigma*wsum; vec3 meanB = mean*wsum; float wsumB = wsum;\n    vec2 deltas[4] = vec2[4](vec2(1,0),vec2(-1,0),vec2(0,1),vec2(0,-1));\n    \n    for(int i = 0; i < 4; i++)\n    {\n        load_distribution(p + cell_size*deltas[i], wsum0, sigma0, mean0);\n        wsum0 *= spacial_blur;\n        sigmaB += sigma0*wsum0; meanB += mean0*wsum0; wsumB += wsum0; \n    }\n    \n    sigma = sigmaB/wsumB; mean = meanB/wsumB; \n    \n    //loss \n    wsum *= (1. - temporal_loss);\n    \n    vec2 ci = cell_size*floor(p/cell_size);\n    //update light distribution using local pixels\n    float sigma2 = sigma*sigma*wsum;\n    vec3 mean1 = mean*wsum;\n    range(i, -1, cell_S) range(j, -1, cell_S)\n    {\n        vec2 delta = vec2(i, j);\n       \n        vec4 cur_sample = ch0(ci + delta);\n        \n        float pdf = length(cur_sample.xyz); \n        float s = cur_sample.w;\n        vec3 d = normalize(cur_sample.xyz);\n        \n        vec3 dx = d - mean;\n        float rej = rejection(d);\n        float w = rej*s;\n        //update sigma\n        sigma2 += dot(dx,dx)*w;\n        //update mean\n        mean1 += d*w;\n        \n        //weight sum\n        wsum += w;\n    }\n    \n    mean = normalize(mean1);\n    sigma = sqrt(sigma2/wsum);\n    \n\n    \n    if(iFrame < 1 || isnan(sigma) || isinf(sigma) || isnan(mean.x))\n    {\n       //default light distribution\n       sigma = 1.0;\n       wsum = 1.;\n       float p;\n       mean = normalize(vec3(0,0,1) + udir(vec3(0,0,1), p));\n    }\n    \n    c = vec4(mean*sigma, wsum);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//TAA\n\nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    INIT;\n    vec4 data = ch1(p);\n   \n    //light distribution\n    float sigma = length(data.xyz);\n    float wsum = data.w;\n    vec3 mean = normalize(data.xyz);\n    \n    vec4 prev = ch2(p);\n    #ifdef BLUR\n    vec3 prevL = prev.xyz/(prev.w+0.001);\n    //bilateral blur to remove grain\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        if(i==0 && j==0) continue;\n        vec2 dx = vec2(i,j);\n        vec4 s = ch2(p+dx);\n        vec3 L = s.xyz/(s.w+0.001);\n        float w = BLUR_STR*smoothstep(0., 200., prev.w)*exp(-45.*dot(L - prevL,L - prevL) - dot(dx,dx)/4.);\n        prev += vec4(L, 1.)*w;\n    }\n    #endif\n   \n    vec4 light_sampl = ch0(p);\n    \n    float wl = length(light_sampl.xyz);\n    \n    //bias to reduce variance\n    if(!isKeyToggled(KEY_C))\n        light_sampl = clamp(light_sampl, 0., 100.);\n    else\n        light_sampl = clamp(light_sampl, 0., 3000.);\n    float mx = (1.0/TWO_PI)*(1.0/(sigma*sigma) + 1.0);\n   \n    c = prev + vec4(spectral_spektre(wl)*light_sampl.w,1);\n    \n    if(iMouse.z > 1.0 || iFrame < 150)\n    {\n        c.xyz /= c.w/60.0;\n        c.w = 60.0;\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}