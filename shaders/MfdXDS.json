{
    "Shader": {
        "info": {
            "date": "1714482646",
            "description": "haha raymarcher go brrrrrrrrr",
            "flags": 0,
            "hasliked": 0,
            "id": "MfdXDS",
            "likes": 1,
            "name": "super epic raymarcher 2",
            "published": 3,
            "tags": [
                "raymarcher"
            ],
            "usePreview": 0,
            "username": "derpygamer2142",
            "viewed": 113
        },
        "renderpass": [
            {
                "code": "#define epsilon 0.1\n#define maxDist 500.0\n#define fov 90.0\n\nfloat sphere (vec3 p, vec4 s) {\n        return length(s.xyz - p) - s.w;\n}\nfloat atan2 (float x, float y) {\n    return radians(degrees(atan(x/y)) + (180.0 * float(y < 0.0)));\n}\n\nvec3 rotateVec(vec3 v, float xr, float yr, float zr) {\n    // i didn't make this matrix but at this point idk who to credit so i'll just say i stole it from 3dgas\n    float sx = sin(xr);\n    float sy = sin(yr);\n    float sz = sin(zr);\n    \n    float cx = cos(xr);\n    float cy = cos(yr);\n    float cz = cos(zr);\n    float rotmat[] = float[9] (\n        (cx * cz) - (sx * sy * sz),\n        0.0 - (sz * cy),\n        (sy * cx * sz) + (sx * cz),\n        (sy * sx * cz) + (cx * sz),\n        cy * cz,\n        (sx * sz) - (sy * cx * cz),\n        0.0 - (sx * cy),\n        sy,\n        cy * cx\n    );\n    \n    return vec3(\n        (rotmat[0] * v.x) + (rotmat[1] * v.y) + (rotmat[2] * v.z),\n        (rotmat[3] * v.x) + (rotmat[4] * v.y) + (rotmat[5] * v.z),\n        (rotmat[6] * v.x) + (rotmat[7] * v.y) + (rotmat[8] * v.z)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 balls[] = vec4[1] (vec4(0.0, 0.0, 25.0, 5.0)); // haha balls\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 coords = fragCoord;\n   \n    float focalLength = iResolution.x / tan(radians(fov/2.0)); // this thingy used focal length but fov is cooler\n    \n    coords.x -= iResolution.x/2.0;\n    coords.y -= iResolution.y/2.0;\n    \n    float heldDist = 9999.99; // big number go brrrrr\n    float raylen = 0.0;\n    vec4 last = vec4 (0.0,0.0,5555555.3,5.0);\n    \n    \n    vec3 rp = vec3 (0.0, 0.0, 0.0);\n    vec3 rv = normalize(vec3 (coords.xy, focalLength)); // directiony thingy\n    float ypos = sin(iTime * 2.0) * 5.0;\n    while ((raylen < maxDist) && (heldDist > epsilon)) {\n        for (int i = 0; i < balls.length(); i++) {\n            float checkDist = sphere(rp, balls[i]); // how far away is the thing\n            balls[i].y = ypos;\n            if (checkDist < heldDist) {\n                heldDist = checkDist;\n                last = balls[i];\n            }\n            //heldDist = min(checkDist, heldDist); // update distance\n        }\n        \n        // zooooom\n        raylen += heldDist;\n        rp += rv*heldDist;\n    }\n    \n   \n    if (raylen >= maxDist) {\n    // no bonk\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    else {\n        // bonk\n        // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model\n        // this is most likely wrong\n        // til it's blinn not bling\n        vec3 lightvec = normalize(vec3(1.0,1.0,-1.0));\n        vec3 normal = normalize(rp - last.xyz);\n        vec3 halfa = normalize(lightvec + rv);\n        float spec = pow(max(dot(halfa, normal),0.0),6.0);\n        float l = (dot(normal, lightvec)*0.5) + spec;\n        vec3 rotnormal = rotateVec(normal, (iTime*50.0) * (3.14159 / 180.0), (iTime*15.0) * (3.14159 / 180.0), 0.0);\n        vec2 uv = vec2 (1.0 - (atan2(rotnormal.x,rotnormal.z)/6.28318 + 0.5), rotnormal.y*0.5 + 0.5); // 6.28318 = 2pi\n        vec4 tex = texture(iChannel0,uv);\n        fragColor = vec4(tex.rgb + l,1.0);\n    }\n    \n    \n    //fragColor = vec4(uv.x,1.0-uv.y,0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}