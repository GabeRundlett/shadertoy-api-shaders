{
    "Shader": {
        "info": {
            "date": "1680074059",
            "description": "One hundred thousand voronoi-rendered particles, animated with curl noise. Particles are rendered into a density field, which is interpreted as a height map with refractive properties and glossy lighting.\n\n*mouse to attract particles*\n*space to reset* \n",
            "flags": 48,
            "hasliked": 0,
            "id": "DddXW8",
            "likes": 16,
            "name": "Noisy Flow",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "simulation",
                "particles",
                "physics",
                "softbody",
                "gummy",
                "pdb"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 312
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Voronoi-rendered particles, animated with curl noise. Particles are rendered into a\n//  density field, which is interpreted as a height map with refractive properties and\n//  glossy lighting.\n//\n//  This is another shader that is (meant to be) based on curl noise. I've created my\n//  own curl noise field based on my interpetation of\n//  \n//      https://raw.githubusercontent.com/petewerner/misc/master/Curl%20Noise%20Slides.pdf\n//\n//  But I'm not sure if I'm doing it right so any advice is appreciated! I've done a few\n//  other curl noise shaders, but so far only to advect a density field:\n//\n//      Velvel Curl Noise PRM         https://shadertoy.com/view/cllXW4\n//      Cloudy Volumetric Torus       https://shadertoy.com/view/ds3Gz8\n//      Smoke of Many Colors          https://shadertoy.com/view/ddGGzd\n//\n//  In this new shader, the curl field is used to animate particles which are then\n//  rendered with voronoi tracking. The noise function is 3D, which we animate through\n//  slices of, giving gently changing 2D noise, which is a trick I learned from Shane's\n//\n//      Visualizing Curl Noise        https://shadertoy.com/view/mlsSWH\n//\n//  I suppose the interpretation of the depth buffer as a height map is a 2.5D effect,\n//  of a different sort. I've used this 2.5D effect before, with voronoi particles, way\n//  back to some of my first shadertoys:\n//\n//      Flowing Water                 https://shadertoy.com/view/7s3Bz2\n//      Tesla Valve                   https://shadertoy.com/view/sdVfzy\n//      Gummy Worm Pachinko           https://shadertoy.com/view/cdlXDH\n//\n//  So the core building blocks of this shader already existed, I'm just putting them\n//  together with a new presentation. Letting the particles leave trails was at least\n//  partly inspired by leon's particle systems such as\n// \n//      Frooty                        https://www.shadertoy.com/view/mtj3Dy\n//\n//  I'm in awe of leon's shaders but I was excited when I started to see \"baroque\"\n//  patterns arising out of the particle movement in this shader, not as good as his\n//  but pretty cool anyway. BTW you won't get all the particles unless you have at\n//  least 500k pixels in your buffers.\n//\n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a voronoi search to help out building neighborhoods\n//  Buffer C renders the particles: rgb contains color, alpha contains density\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec3 LIGHT_DIR_A = normalize(vec3(-1,-1,1));\nconst vec3 LIGHT_DIR_B = normalize(vec3(1,-1,1));\nconst vec4 LIGHT_COLOR_A = vec4(1,0,1,0);\nconst vec4 LIGHT_COLOR_B = vec4(0,1,1,0);\n\nvec2 gradient(vec2 fragCoord)\n{\n    vec2 delta = vec2(1, 0);\n    float xGrad = texture(iChannel0, (fragCoord + delta.xy) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.xy) / iResolution.xy).a;\n        \n    float yGrad = texture(iChannel0, (fragCoord + delta.yx) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.yx) / iResolution.xy).a;\n\n    return vec2(xGrad, yGrad);\n}\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{   \n    vec2 grad = gradient(fragCoord);\n\n    vec4 color = texture(iChannel0, fragCoord/iResolution.xy);\n    vec2 p = fragCoord/iResolution.xy;\n    \n    const vec4 background = vec4(0);\n    float density = color.a;\n    vec3 norm = normalize(vec3(-grad.x, 1, -grad.y));\n    vec3 pToC = vec3(0.0, 1.75-p.x, 0.5 - p.y);\n    float gummySpecA = computeSpecular(0.8, 15.0, norm, LIGHT_DIR_A, pToC);\n    float gummySpecB = computeSpecular(0.8, 15.0, norm, LIGHT_DIR_B, pToC);\n    color += gummySpecA * LIGHT_COLOR_A + gummySpecB * LIGHT_COLOR_B;\n    vec4 water = texture(iChannel1, p + grad * 10.) * color; // Refract :)\n    fragColor = mix(background, water, smoothstep(0.5, 1.0, density)); // Blur edges\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int MAX_PARTICLES = 100000; // controls the maximum number of particles\n\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return p * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution);\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat distanceFromWalls(vec2 point, vec3 resolution)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, point.x);\n    minDist = min(minDist, resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y);\n    minDist = min(minDist, 1. - point.y);\n        \n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution )\n{\n\tvec2 delta = vec2( 0.001, 0.0 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + delta.xy, resolution ); \n    float downTinyChangeInX = distanceFromWalls( point - delta.xy, resolution ); \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    float upTinyChangeInY   = distanceFromWalls( point + delta.yx, resolution ); \n    float downTinyChangeInY = distanceFromWalls( point - delta.yx, resolution ); \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n\tvec2 normal = vec2(tinyChangeInX, tinyChangeInY);\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define NUM_PARTICLE_DATA_TYPES 5\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDImpl(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDImpl(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 prev;\n    \n    ivec4 neighbors[4];\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.prev = particleData4.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS:  \n        return vec4(p.pos, p.prev);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nstruct fxState\n{\n    float resolution;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    fxState state;\n    state.resolution = data.x;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state)\n{\n    return vec4(state.resolution, 0, 0, 0);\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p, float ar)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / length2(b), 0., 1.);// proj coord on line\n    return length2((p - b * h) * vec2(ar, 1)); // squared dist to segment\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes particle positions and neighbors\n// ---------------------------------------------------------------------------------------\n\nconst float PARTICLE_REPEL_SIZE = .00125; // how close can particles get\nconst float COLLISION_STIFFNESS = .4; // how strongly do particles repel\nconst float MAX_VEL = .02; // how fast can particles go\nconst float DAMPING = .97; // slows down particles\nconst float CURL_RATE = .001; // how stong is the curl field\nconst float CURL_SCALE = .6; // scale on the curl field\nconst float TIME_SCALE = .01; // how fast the curl field evolves\n\nfloat noise(vec3 p)\n{\n    p *= CURL_SCALE;\n\n    return .45 * textureLod(iChannel2, p, 0.).x\n         + .22 * textureLod(iChannel2, 2.3 * p, 0.).x\n         + .2  * textureLod(iChannel2, 4.4 * p, 0.).x\n         + .05 * textureLod(iChannel2, 6.3 * p, 0.).x\n         - .5;\n}\n\nvec2 curl(vec2 u)\n{\n    vec3 p = vec3(u, iTime * TIME_SCALE);\n    const vec2 eps = vec2(1, 0);\n    \n    float a = noise(p + eps.yxx) - noise(p - eps.yxx);\n    float b = noise(p - eps.xxy) - noise(p + eps.xxy);\n    \n    return vec2(a, b) / (eps.x + eps.x);\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=MAX_PARTICLES) return;\n    \n    fxParticle data = fxGetParticle(id);\n    fxState state = fxGetState();\n    \n    if (dataType >= POS)\n    {\n        if (iFrame == 0 || state.resolution < 0.)\n        {\n            // init particles\n            vec3 h1 = hash3(uvec3(id) * uvec3(3, 6, 9)) - .5;\n\n            data.pos = vec2(iResolution.x / iResolution.y, 1) * h1.xy + .5 * vec2(iResolution.x/iResolution.y, 1);\n            data.prev = data.pos;\n        }\n        else\n        {\n            // handle position integration\n            vec2 prev = data.prev;\n            vec2 deltaPos = prev - data.pos;\n            float vel2 = length2(deltaPos);\n            if (vel2 > MAX_VEL * MAX_VEL)\n            {\n                prev = data.pos + inversesqrt(vel2) * deltaPos * MAX_VEL;\n            }\n            data.prev = data.pos;\n            data.pos = data.pos + CURL_RATE * curl(data.pos) + (data.pos - prev) * DAMPING;\n            \n            // handle collisions with neighbors\n            for(int i = 0; i < 4; i++)\n            {\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid == id - 1 || cid == id + 1 || cid==-1 || cid == 0 || cid >= MAX_PARTICLES) continue;\n                    \n                    fxParticle n = fxGetParticle(cid);\n                    \n                    vec2 deltaPos = data.pos - n.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    vec2 dir = deltaPos / dist;\n \n                    if (dist < PARTICLE_REPEL_SIZE)\n                    {\n                        data.pos = mix(data.pos, n.pos + PARTICLE_REPEL_SIZE * dir, COLLISION_STIFFNESS);\n                    }\n                }\n            }       \n            \n            // handle mouse input\n            if (iMouse.z > 0.)\n            {\n                vec2 m = (iMouse.xy) / iResolution.y;\n                const float MOUSE_RANGE = .2;\n                if (distance(m, data.pos) < MOUSE_RANGE)\n                {\n                    const float MOUSE_STRENGTH = .01;\n                    data.pos = mix(data.pos, m, MOUSE_STRENGTH);\n                }\n            }\n            \n            // handle boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution);\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                vec2 distNormal = getNormalFromWalls(data.pos, iResolution);\n                data.pos -= .5 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n            }\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(data.neighbors[0][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[1][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[2][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[3][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 2;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k);\n            //pick random id of particle\n            int p = int(mod(h*34534.0, float(MAX_PARTICLES)));\n            sort0(bestIds, bestDists, id, int(p), dataType, data.pos);  //sort this\n        }\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 || id >= MAX_PARTICLES ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes neighbors to each screen pixel to accelerate rendering\n// ---------------------------------------------------------------------------------------\n\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord)\n{\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tivec2 ifc = ivec2(fragCoord);\n\n    if (ifc == ivec2(0))\n    {\n        fxState state = fxGetState();\n        \n        if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.resolution) || keyDown(KEY_SPACE))\n        {\n            state.resolution = -iResolution.x * iResolution.y; // negative resolution => reset\n        }\n        else\n        {\n            state.resolution = abs(state.resolution);\n        }\n        \n        fragColor = fxPutState(state);\n        return;\n    }\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    ivec4 old   = fxGetClosest( ifc );      \n\n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, screen2world(fragCoord));\n        insertion_sort( new, dis, id, dis2 );\n    }\n    \n    // Search randomly in the nearest 15x15 neighbors instead of just\n    // the next-door neighbors. Seems to allow faster particle movement\n    uint searchRange = 15u;\n    uint searchCount = 8u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, screen2world(fragCoord));\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n\n    int searchIterations = 2;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash3(uvec3(fragCoord, iFrame * searchIterations + k)).x;\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Renders particles: rgb contains color, alpha contains density\n// ---------------------------------------------------------------------------------------\n\nconst float PARTICLE_SIZE = .007; // how big are particles drawn\n\nvoid renderParticle(in fxParticle p, int id, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    p.prev.x *= iResolution.y / iResolution.x;\n    float dist = sqrt(fxLinePointDist2(p.pos, p.prev, fragCoord, iResolution.x / iResolution.y));\n   \n    fragColor.a = max(fragColor.a, smoothstep(PARTICLE_SIZE * 4., PARTICLE_SIZE * .3, dist));\n    if (dist < PARTICLE_SIZE)\n    {\n        fragColor.rgb = mix(fragColor.rgb, sin(iTime * .7 + vec3(0, 11, 33)) * .3 + .7, .5);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0) * .999;\n    \n  \tvec2 p = fragCoord/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n\n    //draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, id, p, fragColor);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}