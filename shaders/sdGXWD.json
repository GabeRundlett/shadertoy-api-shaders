{
    "Shader": {
        "info": {
            "date": "1634650550",
            "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nTry to be smart by tracking the closest samples on 2 different curve segments.\nFourier-series based curves: see https://www.desmos.com/calculator/iej4fjazoe",
            "flags": 0,
            "hasliked": 0,
            "id": "sdGXWD",
            "likes": 16,
            "name": " Fab19 #inktober2021 \"loop\"",
            "published": 3,
            "tags": [
                "2d",
                "short",
                "fourierseries",
                "inktober2021"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 397
        },
        "renderpass": [
            {
                "code": "// --- utils from https://www.shadertoy.com/view/llySRh\n\n#define H(p)     fract( sin( (p) * 78.233 ) * 43758.5453 )\n#define hue(v) ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length( p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );\n}\n// -----------------------------------------------------------\n\nvec2 f(float t) {                               // curve P(t)\n    vec2 P = vec2(0);\n    for (float f, i = 0.; i < 6.; i++ )         // Fourier series \n        f = exp2(i)*t + 6.283*H(i) + i*iTime,\n        P += vec2(cos(f),sin(f)) / pow(1.4, i); // spectrum 1.4^-f, random phase\n    return P;\n}\n#define D(t)  l = dot( P = f(t) - U, P )        // distanceÂ² to curve(t)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U = 2.5*( u+u - R ) / R.y;\n    float l, d0 = 9., d1=d0, T0,T1,t0,t1,e, t=0., dt = .015, dt2 = dt/4.;\n    O-=O;\n    for ( ; t < 6.283; t+=dt )                  // Sample the curve and get the 2 closests\n        D(t),                                   //   that are not on the same segment.\n          l < d0 ?  t<=T0+dt ? d0=l,T0=t        // Prev best was on same segment: don't update 2nd best\n                             : ( d1=d0, T1=T0, d0=l, T0=t ) // independant best: save old as 2nd best\n        : l < d1 && t> T0+dt ? d1=l,T1=t : t;   // update 2nd best only if not on best segment\n        \n    if (iMouse.z > 0.) O += smoothstep(8./R.y, 0., sqrt(min(d0,d1))-.01 ); // test: draw dots\n \n    t0=T0; t1=T1;    \n    for ( t = -dt; t < dt; t += dt2 )           // Look more accurately around 1st and second\n        D(T0+t), l < d0 ? d0=l,  t0=T0+t : t,   //   closest curve segments.\n        D(T1+t), l < d1 ? d1=l,  t1=T1+t : t;\n        \n                           // draw upstream and dowstream segment for 1st and 2nd best\n#define  L(t) smoothstep(  8./R.y, 0.,                      \\\n                           min ( line(U, f(t-dt2), f(t) ),  \\\n                                 line(U, f(t+dt2), f(t) )   \\\n                        ) -.01 )                            \\\n              * hue(t) \n    O += max( L(t0), L(t1) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}