{
    "Shader": {
        "info": {
            "date": "1707706425",
            "description": "Superman's cape",
            "flags": 0,
            "hasliked": 0,
            "id": "lXsGRj",
            "likes": 10,
            "name": "Superman's cape",
            "published": 3,
            "tags": [
                "superman"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 195
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T (iTime-2.)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define FUI floatBitsToUint\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sabs(in float v, in float k) {return smax(-v, v, k);}\nfloat sclamp(in float v, in float mi, in float ma, in float k) {return smin(smax(v, mi, k), ma, k);}\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\n\nfloat hash21(vec2 ip, float seed) {\n  uvec2 p = FUI(ip); uint s = FUI(seed); uvec2 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y) / float(0xFFFFFFFFU);\n}\n\nmat3x2 voro(in vec2 p, in float seed, float k){\n  vec2 Pi = floor(p); vec2 Pf = fract(p);\n  float dmin = 1e20; float dmi = 10.0; float dma = -dmi;\n  vec2 off = vec2(0.0); vec2 dif = vec2(0.0);\n  for(int j=-1; j<=1; j++){\n    for(int i=-1; i<=1; i++){\n      vec2 lattice = vec2(i,j);\n      vec2 offset = vec2(\n      hash21(Pi+lattice, seed+3.328123),\n      hash21(Pi+lattice, seed+5.58931));\n      vec2 diff = lattice + offset - Pf;\n      float ne = dot(diff, diff);\n      float lt = slt(ne, dmi, k);\n      float gt = sgt(ne, dma, k);\n      dmi = smin(dmi, ne, k);\n      dma = smax(dma, ne, k);\n      off = mix(off, offset, lt);\n      dif = mix(dif, diff, lt);\n    }\n  }\n\n  return mat3x2(off, dif, vec2(dmi, dma));\n}\n\n#define ZERO min(iFrame, 0)\n#define STEPS 90\n#define SHADOW_STEPS 30\n#define NEAR 0.009\n#define FAR 50.0\n\nvec2 boxuv(vec3 p, vec3 n) {\n    return mix(mix(p.xz, p.yz, abs(dot(n, vec3(1, 0, 0)))), p.xy, abs(dot(n, vec3(0,0,1))));\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.0));\n}\n\nfloat groundSDF(vec3 p) {\n    vec2 uv = p.xz;\n    \n    vec2 lv = fract(uv);\n    lv = lv*lv*(3.0-2.0*lv);\n    vec2 alv = abs(lv-0.5);\n    \n    float ind = 0.25*smoothstep(0.3, 3.2, length(alv));\n    \n    return p.y + ind;\n}\n\nstruct Data {\n    int id;\n};\n\n#define NEW_DATA Data(-1)\n\n#define ID_BOX 0\n#define ID_GROUND 1\n\nfloat sdf(vec3 p, inout Data data) {\n    vec3 ba = p;\n    \n    \n    p.yz *= rot(0.59);\n    \n    p.xz *= rot(((sin(T+p.y)*0.5+p.y))*0.1);\n    mat3x2 vo =  voro((p.xy*1.9)+vec2(sin(T-0.25*p.y), cos(T+0.25*p.x)), 3.390281, 0.5);\n    mat3x2 vo2 = voro((p.xy-vec2(0, 0.5))*mix(2.0, 1.0,\n        0.5*exp(cos(p.x*p.y*10.)-1.)\n    ), 44.39281, 0.05);\n    \n    p.z += 0.25*exp(vo2[2].x-1.);\n    p.z += 0.5*sin((p.y*(mix(2.0, 4.0, 0.5*vo[0].x)+1.2*vo[2].x)+T)*0.5+(0.5*cos(T*2.)));\n    \n    float box = (boxSDF(p - vec3(0, 1.25, 0), vec3(1.0, 1.25, 0.01))/1.9)-0.05;\n    box += smoothstep(abs(p.x)*sgt(p.y, 1.5, 1.), 0.0, 0.6);\n    \n    p = ba;\n    float ground = groundSDF(p);\n    float dist = FAR;\n    \n    if (ground < dist) { data.id = ID_GROUND; dist = ground; }\n    if (box < dist) { data.id = ID_BOX; dist = box; }\n    \n    return dist/2.2;\n}\n\nfloat getShadow(vec3 ro, vec3 rd, vec3 N, vec3 L) {\n    float NdotL = dot(N, L);\n    float d = NEAR*NdotL;\n    Data data = NEW_DATA;\n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        if (next < 0.0) break;\n        d += clamp(next, 0.05, 0.5);\n    }\n    float k = exp((d / (1.0 + d))-1.);\n    return clamp(k*k, 0.05, 1.0);\n}\n\nvec3 castRay(vec3 ro, vec3 rd) {\n    Data data = NEW_DATA;\n    vec3 L = normalize(vec3(1, 1.5, -3));\n    \n    vec3 col = vec3(0.0);\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        if (abs(next) <= NEAR) break;\n        if (abs(next) >= FAR) return vec3(0.01);\n        d += next;\n    }\n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NEAR*2., 0.0);\n    vec3 n = normalize(sdf(p, data) - vec3(\n        sdf(p - e.xyy, data),\n        sdf(p - e.yxy, data),\n        sdf(p - e.yyx, data)\n    ));\n    \n    float shadow = getShadow(p, L, n, L);\n    \n    vec3 albedo = data.id == ID_GROUND ? vec3(0.89) : vec3(0.9, 0.105, 0.16);\n    vec3 diffuse = albedo / M_PI;\n    float NdotL = clamp(dot(n, L), 0.005, 1.0);\n    vec3 att = vec3(0.97, 0.81, 0.77) * NdotL * 4.0;\n    col += diffuse*att*shadow;\n    \n    return col;\n}\n\n\n////////////////////////////////////////////////////////\nvec3 look(vec3 ro, vec3 point, vec2 uv) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\nvoid mainImage(out vec4 o, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc-0.5*R.xy)/R.y;\n  vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y,iMouse.zw);\n  vec3 ro = vec3(0, 2.5, 0.0);\n  vec3 rd = normalize(vec3(uv, 1.0));\n  \n  float Z = 4.0;\n  float c = float(m.z > 0.001);\n  \n  float ax = c > 0.0 ? (m.x*TAU) : mix(-0.7, 0.7, 0.5+0.5*sin(T-2.0));\n  float ay = c > 0.0 ? (m.y*TAU*2.) : 0.0;\n\n  ro.x -= sin(ax)*Z;\n  ro.z -= cos(ax)*Z;\n  ro.y += ay;\n  \n  rd = look(ro, vec3(0, 1., 0), uv);\n \n  col += castRay(ro, rd);\n  \n  col = aces(col);\n  col = pow(col, vec3(1.0 / 2.2));\n  //mat3x2 vo = voro(uv*10., 5.598381, 0.5);\n  //col = vo[1].xxx;\n  o = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}