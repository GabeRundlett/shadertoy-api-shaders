{
    "Shader": {
        "info": {
            "date": "1691173362",
            "description": "It has been far too long since I did my last shader here on ShaderToy. This is a good opportunity to try something new this time around. So here is my first attempt at 'atmosphereic scattering'. The scene does not really 'sell' it yet. But kind of works.",
            "flags": 0,
            "hasliked": 0,
            "id": "dtXyDj",
            "likes": 22,
            "name": "atmospheric scattering - 1st try",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "scattering",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 1497
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// A first attempt of getting an effect of 'atmospheric scattering' working.\n//\n// Copyright 2023 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 64; \nconst float EPSILON = .0001;\nconst float STEP_BIAS = .95;\n\nfloat sdPlane (vec3 p, float d)\n{\n    return p.y - d;\n}\n\nfloat sdSphere (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat map (vec3 p)\n{\n    float ground = sdPlane (p, -.2);\n    float r = .01*sin(120.*p.y*p.x + 5.*iTime);\n    float ball1 = sdSphere (p - vec3 (2.*cos(iTime), .2, sin(iTime)), .1);\n    float ball2 = sdSphere (p - vec3 (.3, .4 + .2*cos(3.*iTime), .0), .2);\n    float ball3 = sdSphere (p - vec3 (-.2, .3, -.2), .2);\n    float ball4 = sdSphere (p - vec3 (-.4, .2, .4), .3 + r); \n    float balls = min (ball1, min (ball2, min (ball3, ball4)));\n\n    return min (ground, balls);\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (.001, .0);\n    float d = map (p);\n    vec3 n = vec3 (map (p + e.xyy) - d,\n                   map (p + e.yxy) - d,\n                   map (p + e.yyx) - d); \n\n    return normalize (n);\n}\n\nfloat shadow (vec3 ro, vec3 rd) \n{\n    float value = 1.; \n    const float steps = 10.;\n    const float s = 1./steps;\n    float t = .25;\n    float d = .0; \n\n    for (float i = .0; i < steps; ++i) {\n        d = map (ro + t*rd);\n        value = clamp (min (value, 8.*d/t), .0, 1.);\n        if (abs (d) < EPSILON*(1. + .125*d)) break;\n        t += d*STEP_BIAS;\n    }   \n\n    return value;\n}\n\nconst vec3 lpos1 = vec3 (-1.);\nconst vec3 lcol1 = vec3 (.3, .2, .2);\n\nfloat rnd (vec3 value)\n{\n    float v = dot (value, vec3 (12.324, 34.439, 78.1858));\n    return fract (sin (v) * 783.94 + 82.2453);\n}\n\nfloat raymarch (vec3 ro, vec3 rd, out float atmophere, out float attenuation)\n{\n    float d = .0;\n    float t = .0;\n\n    atmophere = .0;\n    attenuation = 1.;\n\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + d*rd;\n        float ldist = distance (p, lpos1 + .15*rnd(rd));\n        float illum = 1./(ldist*ldist);\n        vec3 ldir = normalize (p - lpos1);\n        vec3 n = normal (p);\n        float sha = shadow (p, normalize (p - lpos1));\n        t = map (p);\n        atmophere += illum*.25*attenuation*sha;\n        if (abs (t) < EPSILON*(1. + .125*t)) {\n            break;\n        }\n        attenuation *= .95;\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 light (vec3 light_pos, vec3 light_col, vec3 surf_pos, vec3 surf_norm, vec3 rd)\n{\n    vec3 light_dir = normalize (surf_pos - light_pos);\n    float light_dist = distance (surf_pos, light_pos);\n    float diffuse = max (.0, dot (surf_norm, light_dir));\n    float sha = shadow (surf_pos - 0.01*surf_norm, light_dir);\n    vec3 h = normalize (light_dir - rd);\n    float spec = pow (max (dot (h, surf_norm), .0), 4.);\n\n    return sha*diffuse*light_col*spec;\n}\n\nvec3 shade (vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n    float attenuation = 1.0;\n    float atmosphere = 0.0;\n\n    vec3 lpos2 = vec3 (.0, -2., .0);\n    vec3 lcol2 = vec3 (.6);\n    vec3 lpos3 = vec3 (2., -1.5, .0);\n    vec3 lcol3 = vec3 (.1, .4, .8);\n    vec3 lamb = vec3 (.1);\n\n    return lamb +\n           light (lpos1, lcol1, p, n, rd) +\n           light (lpos2, lcol2, p, n, rd) +\n           light (lpos3, lcol3, p, n, rd);\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1.0, .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward*zoom);\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float camdist = 4.;\n    vec3 ro = vec3 (camdist*cos(iTime), .8 + .4*cos (2.*iTime), camdist*sin(iTime));\n    vec3 aim = vec3 (.0, .2, .0);\n    float zoom = 1.25;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    float atmophere = .0;\n    float attenuation = .0;\n    float d = raymarch (ro, rd, atmophere, attenuation);\n    float fog = 1./(1. + d*d*.1);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p);\n    vec3 color = fog*shade (ro, rd, p, n);\n    color += atmophere*(lcol1);\n\n    float alpha = 1.0;\n\n    // tone-mapping\n    color = color/(1. + color);\n\n    // 'film-grain'\n    color += .025*rnd(rd);\n\n    // tint\n    color *= vec3 (.975, .9, .825);\n\n    // gamma-correction\n    color = .25*color + .75*sqrt (color);\n\n    // color-correction\n    color = smoothstep (vec3(.0125), vec3(.9875), color);\n\n    fragColor = vec4 (color, alpha);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}