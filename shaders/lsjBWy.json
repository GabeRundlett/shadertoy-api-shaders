{
    "Shader": {
        "info": {
            "date": "1502060378",
            "description": "numbers from 0 to 9\ngot inspired by a shader from ollj [url=https://www.shadertoy.com/view/4d2BDy]corner serif[/url]\nseems to be pretty heavy",
            "flags": 0,
            "hasliked": 0,
            "id": "lsjBWy",
            "likes": 15,
            "name": "numbers from 0 to 9",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "number",
                "font",
                "digit",
                "fonts"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 838
        },
        "renderpass": [
            {
                "code": "float lineforcorner(vec2 p, float rot, float size) {\n    return length(max(abs(p)-vec2(size*2.0-rot,rot),vec2(0.0)));\n}\n\nfloat corner (vec2 p,float size) {\n    return lineforcorner(p-size*sign(p.x+p.y+0.0001),sign(p.x+p.y+0.0001)*size+size,size);\n}\n\n//line df by iq https://iquilezles.org/articles/distfunctions\nfloat line( vec2 p, vec2 a, vec2 b ) \n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat halfdonut(vec2 p, float size) {\n    vec2 p2 = p;\n    p2.y = max(p.y,0.0);\n    return length(vec2(abs(length(p2)-size),p.y-p2.y));\n}\n\nfloat quarterdonut(vec2 p, float size) {\n    float len = length(max(p,vec2(0.0)))-size+min(max(p.x,p.y),0.0);\n    return length(vec2(len,min(min(p.x,p.y),0.0)));\n}\n\nfloat halfdonutfor3(vec2 p, float size) {\n    vec2 p2 = p;\n    p2.y = max(p.y,0.0);\n    return length(vec2(abs(length(p2)-size),min(p.y,-size/2.0)+size/2.0));\n}\n\n\nfloat num1(vec2 p, float size) {\n    return length(max(abs(p)-vec2(0.0,size),vec2(0.0)));\n}\nfloat num0(vec2 p, float size) {\n    return abs(num1(p,size/2.0)-size/2.0);\n}\nfloat num2(vec2 p, float size) {\n    return min(min(\n        halfdonut(p-vec2(0.0,size/2.0),size/2.0),\n        line(p,vec2(size/2.0),vec2(-size/2.0,-size))),\n        length(max(abs(p-vec2(0.0,-size))-vec2(size/2.0,0.0),vec2(0.0))));\n}\nfloat num3(vec2 p, float size) {\n    return halfdonutfor3(vec2(abs(p.y)-size/2.0,p.x),size/2.0);\n}\nfloat num4(vec2 p, float size) {\n    return min(\n        num1(p-vec2(size/2.0,0.0),size),\n        corner(vec2(-p.x,p.y)-size/4.0,size/4.0));\n}\nfloat num5(vec2 p, float size) {\n    return min(min(\n        corner(-p-vec2(size)*vec2(0.5/4.0,-3.5/4.0),size/8.0),\n        halfdonut(vec2(p.x,abs(p.y+size/8.0)-size*(0.5+1.0/8.0)),size/4.0)),\n        num1(p-vec2(size/4.0,-size/8.0),size*(0.5+1.0/8.0)));\n}\nfloat num6(vec2 p, float size) {\n    return min(min(\n        num0(p-vec2(0.0,-size/2.0),size/2.0),\n        halfdonut(p-vec2(0.0,size-size/4.0),size/4.0)),\n        num1(p-vec2(-size/4.0,size/4.0),size/2.0));\n}\nfloat num7(vec2 p, float size) {\n    return min(\n        length(max(abs(p-vec2(0.0,size))-vec2(size/2.0,0.0),vec2(0.0))),\n        line(p,vec2(size/2.0,size),vec2(-size/2.0,-size)));\n}\nfloat num8(vec2 p, float size) {\n    return abs(length(abs(p)-vec2(0.0,size/2.0))-size/2.0);\n}\nfloat num9(vec2 p, float size) {\n    return num6(-p,size);\n}\n\nfloat num(vec2 p, float size, float num) {\n    float len = length(p-vec2(-0.75,-0.3))-0.01;\n    num *= 100.0;\n    \n    while (num >= 1.0) {\n        float len2;\n        switch(int(num)%10) {\n            case 0: len2 = num0(p,size);break;\n            case 1: len2 = num1(p,size);break;\n            case 2: len2 = num2(p,size);break;\n            case 3: len2 = num3(p,size);break;\n            case 4: len2 = num4(p,size);break;\n            case 5: len2 = num5(p,size);break;\n            case 6: len2 = num6(p,size);break;\n            case 7: len2 = num7(p,size);break;\n            case 8: len2 = num8(p,size);break;\n            case 9: len2 = num9(p,size);break;\n    \t}\n        len = min(len,len2);\n        num /= 10.0;\n        p.x+=0.5;\n    }\n    \n    return len;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y*1.5;\n    \n    \n    /*float len = min(min(min(min(min(min(min(min(min(\n        num0(uv-vec2(0.5,0.0)*-4.5,sin(iTime)*0.5+0.5),\n        num1(uv-vec2(0.5,0.0)*-3.5,sin(iTime)*0.5+0.5)),\n        num2(uv-vec2(0.5,0.0)*-2.5,sin(iTime)*0.5+0.5)),\n        num3(uv-vec2(0.5,0.0)*-1.5,sin(iTime)*0.5+0.5)),\n        num4(uv-vec2(0.5,0.0)*-0.5,sin(iTime)*0.5+0.5)),\n        num5(uv-vec2(0.5,0.0)* 0.5,sin(iTime)*0.5+0.5)),\n        num6(uv-vec2(0.5,0.0)* 1.5,sin(iTime)*0.5+0.5)),\n        num7(uv-vec2(0.5,0.0)* 2.5,sin(iTime)*0.5+0.5)),\n        num8(uv-vec2(0.5,0.0)* 3.5,sin(iTime)*0.5+0.5)),\n        num9(uv-vec2(0.5,0.0)* 4.5,sin(iTime)*0.5+0.5))*2.0;\n    */\n    float len = num(uv-vec2(2.4,1.0),0.3,iFrameRate);\n    len = min(len,num(uv-vec2(2.4,0.0),0.3,123456789.0));\n    len = min(len,num(uv-vec2(2.4,-1.0),0.3,iTime));\n    \n    //fragColor = vec4(mod(clamp(1.0-len,0.0,1.0),0.995));\n    //fragColor -= 1.0-step((abs(uv.y)),0.35);\n    //fragColor -= step(mod(abs(uv.x),0.5),0.02);\n\t\n    \n    //below is the distance coloring by iq from https://www.shadertoy.com/view/ldl3W8\n\t// isolines\n    vec3 col = len*(0.5 + 0.5*sin(64.0*len))*vec3(1.0);\n    // borders\t\n    col = mix( vec3(1.0,0.6,0.0), col, smoothstep( 0.01, 0.04, len ) );\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}