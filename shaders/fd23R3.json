{
    "Shader": {
        "info": {
            "date": "1617901042",
            "description": "A collection of fractals related to the mandelbrot set, each with their interior colored based on stability. See the image tab for more details.",
            "flags": 48,
            "hasliked": 0,
            "id": "fd23R3",
            "likes": 5,
            "name": "fractal interiors",
            "published": 3,
            "tags": [
                "fractal",
                "interactive",
                "zoomable"
            ],
            "usePreview": 0,
            "username": "peabrainiac",
            "viewed": 365
        },
        "renderpass": [
            {
                "code": "/*\n * A collection of fractals with their interior colored by stability, to show otherwise hidden structures\n * and minibrots and distinguish those stable from chaotic regions.\n * \n * The controls are:\n *  - WASD to move around\n *  - up and down arrow keys to zoom\n *  - E and Q to switch between fractals\n *  - left and right arrow keys to change formula parameters\n *  - R and F to change the iteration count (though be warned, this does not play well together with the coloring method used here)\n * Using any of those will stop the animation and reset the fractal, so you can then start to explore it on your own.\n * \n * The fractals shown here are, in order:\n *  - the mandelbrot set (boring, mainly in here for completeness)\n *  - the moebius mandelbrot set (slightly less boring)\n *  - the mandelbar set (also boring)\n *  - the perpendicular burning ship and related fractals\n *  - the burning ship and related fractals (you start here)\n *  - the buffalo fractal and related fractals\n *  - more to be implemented later...\n * \n * If you want to dig into the code, Buffer A contains the actual fractal-related code,\n * while Buffer B contains all of the controls. This whole piece of code is licensed under the unlicense (see below),\n * so feel free to fork and edit it as you like.\n * \n *  - - - - -\n * \n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org/>.\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float color(vec2 c);\nfloat getMaxEigenvalueAbs(mat2 j);\n\n// formula functions. these all follow the same pattern: position and max iterations in, iterations and jacobian out.\n// specifically, j should indicate how z_{2*iter} reacts to slight changes to z_iter.\n// this information will then be used to estimate how sensitive the orbit is to slight perturbations,\n// and thus whether it belongs to a minibrot or a chaotic region.\nvoid mandelbrot(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid mandelbar(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid moebiusMandelbrot(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid burningShip(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid perpendicularBurningShip(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid buffalo(in vec2 c, in int iter, in float param, out int i, out mat2 j);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if (texelFetch(iChannel1,ivec2(0),0).x==0.0){\n        // if the update flag in buffer B is not set, simply keep the old value\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }else{\n        vec3 pos = texelFetch(iChannel1,ivec2(2,0),0).xyz;\n        vec2 c = 5.0*vec2(1.,-1.)*(fragCoord-iResolution.xy*0.5)/length(iResolution);\n        c = c*2.0/pos.z+pos.xy;\n        fragColor = vec4(vec3(color(c)),1.0);\n    }\n}\n\n// computes the brightness the pixel at a given fractal coordinate should have\nfloat color(vec2 c){\n    vec3 config = texelFetch(iChannel1,ivec2(1,0),0).xyz;\n    int formula = int(config.x);\n    float param = config.y;\n    int iter = int(config.z);\n    int i;\n    mat2 j;\n    if (formula==0){\n        mandelbrot(c,iter,param,i,j);\n    }else if (formula==1){\n        moebiusMandelbrot(c,iter,param,i,j);\n    }else if (formula==2){\n        mandelbar(c,iter,param,i,j);\n    }else if (formula==3){\n        perpendicularBurningShip(c,iter,param,i,j);\n    }else if (formula==4){\n        burningShip(c,iter,param,i,j);\n    }else if (formula==5){\n        buffalo(c,iter,param,i,j);\n    }else{\n        //burningShip(c,i,j);\n    }\n    if (i<2*iter){\n        return 0.25*float(i)/float(2*iter);\n    }else{\n        return max(0.25,1.0-0.25*pow(getMaxEigenvalueAbs(j),10.0/float(iter)));\n    }\n}\n\n// returns the absolute value of the larger of the two complex eigenvalues of a given matrix.\nfloat getMaxEigenvalueAbs(mat2 j){\n    float p = -j[0][0]-j[1][1];\n    float q = j[0][0]*j[1][1]-j[0][1]*j[1][0];\n    float rad = p*p*0.25-q;\n    return rad<0.0?sqrt(p*p*0.25-rad):abs(p*0.5)+sqrt(rad);\n}\n\nvoid mandelbrot(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        d = 2.0*vec4(z.x*d.xy-z.y*d.zw,z.x*d.zw+z.y*d.xy);\n        z = z2;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\nvoid mandelbar(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,-2.0*z.x*z.y)+c;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,-2.0*z.x*z.y)+c;\n        d = 2.0*vec4(z.x*d.xy-z.y*d.zw,-(z.x*d.zw+z.y*d.xy));\n        z = z2;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\nvoid moebiusMandelbrot(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 temp = vec2(cos(param),sin(param));\n    mat2 rot = mat2(temp.xy,vec2(-temp.y,temp.x));\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z = rot*z;\n        float sy = sign(abs(z.x)-1.0);\n        z.y *= -sy;\n        z.x -= (sy+1.0)*sign(z.x);\n        z = z*rot;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z2 = rot*z2;\n        float sy = sign(abs(z2.x)-1.0);\n        z2.y *= -sy;\n        z2.x -= (sy+1.0)*sign(z2.x);\n        d = 2.0*vec4(z.x*d.xy-z.y*d.zw,-sy*(z.x*d.zw+z.y*d.xy));\n        z = z2*rot;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\nvoid burningShip(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 temp = vec2(cos(param),sin(param));\n    mat2 rot = mat2(temp.xy,vec2(-temp.y,temp.x));\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z = abs(rot*z)*rot;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z2 = rot*z2;\n        vec2 s = 2.0*sign(z2);\n        d = vec4(s.x*(z.x*d.xy-z.y*d.zw),s.y*(z.x*d.zw+z.y*d.xy));\n        z = abs(z2)*rot;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\nvoid perpendicularBurningShip(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 temp = vec2(cos(param),sin(param));\n    mat2 rot = mat2(temp.xy,vec2(-temp.y,temp.x));\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z = rot*z;\n        z.y = abs(z.y);\n        z = z*rot;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z2 = rot*z2;\n        vec2 s = 2.0*vec2(1.0,sign(z2.y));\n        d = vec4(s.x*(z.x*d.xy-z.y*d.zw),s.y*(z.x*d.zw+z.y*d.xy));\n        z = vec2(z2.x,abs(z2.y))*rot;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\n\nvoid buffalo(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 temp = vec2(cos(param),sin(param));\n    mat2 rot = mat2(temp.xy,vec2(-temp.y,temp.x));\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y);\n        z = abs(rot*z)*rot+c;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y);\n        z2 = rot*z2;\n        vec2 s = 2.0*sign(z2);\n        d = vec4(s.x*(z.x*d.xy-z.y*d.zw),s.y*(z.x*d.zw+z.y*d.xy));\n        z = abs(z2)*rot+c;\n    }\n    j = mat2(d.xz,d.yw);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n * stored values, in order:\n *  - refresh flag, animation flag, reset flag\n *  - formula id, formula param, iterations\n *  - X, Y, zoom\n */\nconst vec3[] defaultValues = vec3[](vec3(1.0,1.0,0.0),vec3(4.0,0.0,50.0),vec3(0.0,0.0,1.0));\n\nfloat keysDown();\nint keyState(int key);\nivec4 keyStates(int key1, int key2, int key3, int key4);\nint keyPressed(int key);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 p = ivec2(fragCoord);\n    if (p.y>0||p.x>=3){\n        discard;\n    }else if (iFrame==0){\n        fragColor = vec4(defaultValues[p.x],1.0);\n    }else{\n        fragColor = texelFetch(iChannel0,p,0);\n        if (p==ivec2(0)){\n            // flag updates\n            float keys = keysDown();\n            if (fragColor.y==1.0){\n                if (keys/*+iMouse.x+iMouse.y*/>0.0){\n                    // animation end because of user input\n                    fragColor.xyz = vec3(1.0,0.0,1.0);\n                }\n            }else{\n                //refresh flag update\n                fragColor.x = min(1.0,keys+step(mod(float(iFrame),30.0),0.0));\n                fragColor.z = 0.0;\n            }\n        }else if(p==ivec2(1,0)){\n            // formula & iteration changes\n            vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n            fragColor.x = mod(fragColor.x+float(keyPressed(KEY_E)-keyPressed(KEY_Q)),6.0);\n            if (flags.y==1.0){\n                // animation\n                fragColor.y = 0.15*iTime*iTime/(iTime+2.0);\n            }else{\n                if (flags.z==1.0){\n                    fragColor.y = 0.0;\n                }\n                // normal controls\n                float zoom = texelFetch(iChannel0,ivec2(2,0),0).z;\n                float paramChange = iTimeDelta/zoom*float(keyState(KEY_RIGHT)-keyState(KEY_LEFT));\n                fragColor.y = mod(fragColor.y+paramChange,2.0*PI);\n                fragColor.z += min(100.0,fragColor.z*(pow(2.0,iTimeDelta*float(keyState(KEY_R)-keyState(KEY_F)))-1.0));\n            }\n        }else if(p==ivec2(2,0)){\n            // zoom & position changes\n            vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n            if (flags.y==1.0){\n                // animation\n                float theta = 0.3*iTime*iTime/(iTime+2.0);\n                float a = 0.5*theta-0.25*PI;\n                a = cos(a-0.5*sin(a));\n                float b = 1.0-abs(a);\n                b = b*b;\n                a = sign(a)*(1.0-b*b*b*b*b);\n                a = 0.5+0.5*a;\n                fragColor.xy = (0.625+a*0.125)*vec2(-sin(theta),-cos(theta))+vec2((a-1.0)*0.125,0.0);\n                fragColor.z = (3.0-2.0*a)*(1.0+3.0*(iTime*iTime)/((iTime*iTime)+5.0));\n            }else{\n                if (flags.z==1.0){\n                    fragColor.xyz = vec3(-0.5,-0.5,2.0);\n                }\n                // normal controls\n                fragColor.xy -= 2.0*iTimeDelta*vec2(float(keyState(KEY_A)-keyState(KEY_D)),float(keyState(KEY_W)-keyState(KEY_S)))/fragColor.z;\n                float zoomChange = iTimeDelta*float(keyState(KEY_UP)-keyState(KEY_DOWN));\n                fragColor.z *= pow(2.0,zoomChange);\n            }\n        }\n    }\n}\n\nfloat keysDown(){\n    float temp = dot(vec4(keyStates(KEY_UP,KEY_RIGHT,KEY_DOWN,KEY_LEFT)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_W,KEY_A,KEY_S,KEY_D)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_Q,KEY_E,KEY_R,KEY_F)),vec4(1.0));\n    return temp;\n}\n\nint keyState(int key){\n    return int(texelFetch(iChannel1,ivec2(key,0),0).x);\n}\n\nivec4 keyStates(int key1, int key2, int key3, int key4){\n    return ivec4(keyState(key1),keyState(key2),keyState(key3),keyState(key4));\n}\n\nint keyPressed(int key){\n    return int(texelFetch(iChannel1,ivec2(key,1),0).x);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_E = 69; // nice.\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_F = 70;\n\nconst float PI = 3.14159265358979323846264;\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}