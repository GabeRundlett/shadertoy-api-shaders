{
    "Shader": {
        "info": {
            "date": "1609147495",
            "description": "surface with cyclic regular polyhedral toroidal  symmetry\n\nuse mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "wldcD4",
            "likes": 19,
            "name": "polyhedral toroidal surface",
            "published": 3,
            "tags": [
                "sdf",
                "sphere",
                "tiling"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 893
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"polyhedral toroidal surface\"\n//\n// created by Colling Patrik (cyperus) in 2020\n//\n// CODE snippets from\n// - jorge2017a1 => https://www.shadertoy.com/view/3sjyDh\n// - mla\n// - iq \n//\n// DOCUMENTATION:\n// - https://math.stackexchange.com/questions/1469554/polyhedral-symmetry-in\n//   -the-riemann-sphere\n// - https://iquilezles.org/articles/raymarchingdf\n// - https://iquilezles.org/articles/intersectors\n//\n// DESCRIPTION:\n// - Choose a cyclic regular polyhedral base transformation. Parameterize.\n//   {torus, spherical-truncated-tetrahedron, spherical-truncated-octahedron,\n//   spherical-truncated-dodecahedron}\n// - Activate up to 2 levels of toroidal transformations. Parameterize.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// const\nconst float PI = 3.14159265359;\n\nfloat sig(float x) { return x >= 0. ? +1. : -1.; }\n\n// 2D transformations: vec2 => vec2\n// complex\nvec2 cmul(vec2 za,vec2 zb) // za*zb\n{\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) // 1/z\n{\n    return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) // z/w\n{\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, int n) // z^n\n{\n    vec2 w = z;\n    for (int i = 1; i < n; i++){\n    w = cmul(w,z);\n    }\n    return w;\n}\n\nvec2 crot(vec2 z,float a) // z*e^(i*a)\n{\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) // (z*e^ia)^n-x0\n{\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// 3D-transformations: vec3 => vec3\n//color\nvec3 hsv2rgb(float h, float s, float v)  // hue, saturation, value\n{\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.,4.,2.),6.)-3.)-1., 0., 1. );\n    rgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\n    return v * mix( vec3(1.), rgb, s);\n}\n\nvec2 isphere(in vec3 ro, in vec3 rd, in float r )\n{\n    // sphere centered at the origin, with size rd\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;\n\n    if( h<0. ) return vec2(-1.);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n// https://www.shadertoy.com/view/fdfSDH\n// mla https://www.shadertoy.com/view/lsGyzm\nvec4 inverseStereographic(vec3 p) {\n  float k = 2.0/(1.0+dot(p,p));\n  return vec4(k*p,k-1.0);\n}\nvec3 stereographic(vec4 p4) {\n  float k = 1.0/(1.0+p4.w);\n  return k*p4.xyz;\n}\n\nvec3 rot4D(in vec3 p, in float t, in float r_inv){\n    p /=r_inv;                             // normalize\n    vec4 p4 = inverseStereographic(p);     // Project to 4d\n    p4.zw = cmul(p4.zw, vec2(cos(-t),sin(-t)));// Rotate in the 4th dimension\n    p = stereographic(p4);                 // Project back to 3d\n    p *=r_inv;                             // unnormalize\n    return p;\n}\n////////////////////////////////////////////////////////////////////////////////\n\nfloat map( in vec3 p, out vec4 mat ){\n    //// sdf's\n    int k, n;\n    vec3 pn = normalize(p);\n    vec2 z;\n    float r, au, av;\n    float sr = 1.; // Torus\n    \n    \n    //float r_inv = sqrt(abs(ba_sh_a)); // inversion bending radius (torus-spheres transformation)\n    //p = rot4D(p, 0.125 *iTime, r_inv);\n\n    /// cyclic regular Polyeder ba_id in {1,2,3}    \n    if(  ba_id == 0 || ba_id == 1 || ba_id == 2 || ba_id == 3 ){    \n\t\t// Fk,2(z)\n\t\tif (ba_id == 0)\n        {\n            k = 7; n = 2;\n            float a1 = float(k);            \n            vec2 zk;\n            if (pn.z < 0.) // stereographic (north pol)\n            {\n                z = pn.xy/(1.0-(pn.z));\n                zk = cpow(z,k);\n                z = a1 * cdiv(zk, cpow(zk - vec2(1.,0.) ,n));\n            }else          // stereographic (south pol)\n            {\n                z = vec2(pn.x, -pn.y)/(1.+pn.z);\n                zk = cpow(z,k);\n                z = a1 * cdiv(zk, cpow(vec2(1.,0.) - zk ,n));     \n            }\n        }\n        \n\t\t// F3,3(z)\n\t\tif (ba_id == 1)\n        {\n            k = 3; n = 3;\n            float a1 = 2. * sqrt(2.);\n            vec2 zk;\n            if (pn.z < 0.) // stereographic (north pol)\n            {\n                z = pn.xy/(1.-pn.z);\n                zk = cpow(z,k);\n                z = 1./(8.*a1) * zk;\n                z = cmul(z, cpow(zk - vec2(a1,   0.), k));\n                z = cdiv(z, cpow(zk + vec2(1./a1,0.), n));\n            }else          // stereographic (south pol)\n            {\n                z = vec2(pn.x, -pn.y)/(1.+pn.z);\n                zk = cpow(z,k);\n                z = 1./(8.*a1)*cinv(zk);       \n                z = cmul(z, cpow(vec2(1.,0.) - zk * a1, k));\n                z = cdiv(z, cpow(vec2(1.,0.) + zk / a1, n));    \n            }\n\t\t}\n\n\t\t// F4,3(z)\n\t\tif (ba_id == 2)\n        {\n            k = 4; n = 3;\n            float a1 = 108.;\n            vec2 zk;\n            if (pn.z < 0.) // stereographic (north pol)\n            {        \n                z = vec2(pn.x, pn.y)/(1.-pn.z);\n                zk = cpow(z,k);\n                z = a1 * zk;\n                z = cmul(z, cpow(zk          - vec2(1.,0.),          k));\n                z = cdiv(z, cpow(cmul(zk,zk) + 14.*zk + vec2(1.,0.), n));\n            }else          // stereographic (south pol) \n            {\n                z = vec2(pn.x, -pn.y)/(1.+pn.z);\n                zk = cpow(z,k);\n                z = a1 * zk;\n                z = cmul(z, cpow(vec2(1.,0.) - zk,                   k));\n                z = cdiv(z, cpow(vec2(1.,0.) + 14.*zk + cmul(zk,zk), n)); \n            }\n\t\t}\n\n\t\t// F5,3(z)\n\t\tif (ba_id == 3)\n        {\n            k = 5; n = 3;\n            float a1 = 1728.;\n            vec2 zk, zk2;\n            if (pn.z < 0.) // stereographic (north pol)\n            {  \n                z = pn.xy/(1.+abs(pn.z));\n                zk = cpow(z,k); \n                zk2 = cmul(zk,zk);\n                z = a1 * zk;\n                z = cmul(z, cpow(zk2 - 11. * zk - vec2(1.,0.), k));\n                z = cdiv(z, cpow(cmul(zk2,zk2)\n                               +228.*cmul(zk2,zk)\n                               +494.*zk2\n                               -228.*zk\n                               +vec2(1.,0.), n));\n            } else         // stereographic (south pol)                    \n            {\n                z = vec2(pn.x, -pn.y)/(1.+pn.z);\n                zk = cpow(z,k);\n                zk2 = cmul(zk,zk);\n                z = a1 * zk; \n                z = cmul(z, cpow(vec2(1.,0.) - 11. * zk - zk2, k));\n                z = cdiv(z, cpow(vec2(1.,0.)\n                               +228.*zk\n                               +494.*zk2\n                               -228.*cmul(zk2,zk)\n                               +cmul(zk2,zk2), n));\n            }\n\t\t}\n        \n        // sense of rotation of the polygon: sig(sr) in {-1.,+1.}\n        // number of sides of the polygon: abs(sr) in {n,k}\n        sr = float(length(z)>1.0?-n:k);\n\n\t\t// au\n\t\tau = atan(z.y,z.x) - .5 * PI * sig(sr);\n        \n\t\t// av       \n\t\tfloat f_v_distri = .5 * ba_sh_a / ba_v_distri;        \n\t\tf_v_distri = sqrt( 1. + pow( f_v_distri ,2.)) + f_v_distri;\n        \n\t\t// length(w) in [0., 1., +inf] => [-inf, 0., +inf] => av in [-0.5*PI,+0.5*PI]\n\t\tav = atan(log(length(z))*f_v_distri);\n\n\t\t// spherical => cartesian\n\t\tp = length(p)\n          * vec3( sin(av) * cos(au),\n\t\t\t\t  sin(av) * sin(au),\n\t\t\t\t  cos(av) );\n\t}\n\n\t/// Torus:\n\t// 3D-space: cartesian3D => cylinder3D transformation\n\tau = atan(p.y, p.x); //float in [-PI, +PI]\n\tr = length(p.xy);\t //float in [0., +inf]\n\t// 2D-space: complex plane := radial plane in cylinderc coordinates\n\tz = vec2(r, p.z);\n    \n\t/// 2Djulia :realaxis-translation, fraction == 2 => (torus,sphere,2spheres)\n\tz = cmul(z,z); z.x -= ba_sh_a;\n\tfloat ssr = sig(sr);\n\n\t//float fru = 1.0; // fractions in u-direction\n\t/// 2Djulia realaxis-translation,fraction,rotation,torsion\n\tif (j1_ON){\n\tfloat j1_sh = j1_sh_a0 + j1_sh_a1 * cos(float(j1_sh_f1) *(au - PI*(j1_sh_p1+j1_sh_pv1*iTime)));\n\tfloat j1_to = ssr * (au*float(j1_to_c)/float(j1_to_f) + PI*(j1_to_p+j1_to_pv*iTime));\n\tz = crpt(z, j1_to, j1_to_f,  j1_sh);\n\t//fru *= (j1_sh_f1 == 0)?1.0:float(j1_sh_f1);\n\t}\n\n\t/// 2Djulia realaxis-translation,fraction,rotation, torsion\n\tif (j2_ON){\n\tfloat j2_sh = j2_sh_a0 + j2_sh_a1 * cos(float(j2_sh_f1) * (au - PI*(j2_sh_p1+j2_sh_pv1*iTime)));\n\tfloat j2_to = ssr * (au*float(j2_to_c)/float(j2_to_f) + PI*(j2_to_p+j2_to_pv*iTime));\n\tz = crpt(z, j2_to, j2_to_f,  j2_sh);\n\t//fru *= (j2_sh_f1 == 0)?1.0:float(j2_sh_f1);\n\t}\n\n\tmat = vec4(z,au,sr);\n\tfloat res = log(length(z)/end_r0); // TODO:  :( Not perfect!\n\n\treturn res;\n\t}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n\tfloat res = -1.0; // init no rayintersection\n\n\t// boundingshape\n\tvec2 dis = isphere( ro, rd ,abs(bb_size));\n\tif( dis.y<0.0 ) // Does ray hit boundingshape?\n\t\treturn -1.0;\n\tdis.x = max( dis.x, max(rm_rlmin,0.0) );// start_raylength from bb_near_hit or raylength_minimum\n\tdis.y = min( dis.y, 10.0 );\t// end_raylength from bb_far_hit or raylength_maximum\n\t// raymarch signed distance field\n\tvec4 data; // data from surface hit point and accumulated data while raymarching\n\n\tfloat fh = (0.5-0.0001)*rm_p3slmul*rm_p3slmul*rm_p3slmul + 0.0001; // slider response curve\n\tfloat t = dis.x;\n\tfor( int i=0; i<rm_imax; i++  )\n\t{\n\t\tvec3 pos = ro + rd*t;\n\t\tfloat th = 0.0001*px*t; // delta_sdf_surface_hit\n\t\tfloat h = map(pos, data);\n\t\tif( t>dis.y || h<th ) break; // ray is outside boundingshape OR sdf_surface_hit.\n\t\tt += h*fh; // step_length * step_length_multiplier\n\t}\n\n\tif( t<dis.y ) // Is ray inside boundingshape?\n\t{\n\t\trescol = data; // return data\n\t\tres = t; // return ray_length\n\t}\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos, in float px )\n{\n\tvec4 tmp; // dummy variable\n\tvec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n\treturn normalize( e.xyy*map( pos + e.xyy,tmp ) +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<1; i++ )\n\t{\n\t\tvec4 temp;\n\t\tfloat h = map( ro + rd*t, temp );\n\t\tres = min( res, 8.0*h/t );\n\t\tt += h*.25;\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0., 1. );\n}\n\n// from iq\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\t// antialeasing\n\tfor( int i=0; i<1; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n\t\tvec3 aopos =  nor * hr + pos;\n\t\tvec4 temp;\n\t\tfloat dd = map( aopos, temp );\n\t\tocc += -(dd-hr)*sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// transform from mla\nvec3 transform(in vec4 p){\n\tif (iMouse.x > 0.0)\n\t{\n\t\tfloat phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n\t\tfloat theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n\t\tp.yz = crot(p.yz,theta);\n\t\tp.zx = crot(p.zx,-phi);\n\t}\n\t//p.xz = crot(p.xz,p.w*0.1);\n\treturn p.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// time\n\tfloat time = iTime;\n\t// camera\n\tfloat fle = 2.0;\n\tvec3 ro = transform(vec4(0,0,-cam_dist,time)).xyz;\n\tvec2 uv = (2.0*(fragCoord-0.5*iResolution.xy))/iResolution.y;\n     \n    // ray direction\n\tvec3 rd = normalize(transform(vec4(uv,fle,time)));\n\t// get ray distance to (intersection) hit point\n\tvec4 mat = vec4(0.0);\n\tfloat px = 2.0/( iResolution.y*fle );\n\tfloat t = intersect( ro, rd, mat, px );\n\n\t// light\n\tconst vec3 ld = 0.5*vec3(0.,-.5,-1.); // ligth direction\n\tconst vec3 lc = vec3(0.4);// ligth color\n\tvec3 bg = vec3(0.8,0.9,1.0)*(0.6+0.4*rd.y);\t// background-color\n\n\t// color\n\tvec3 col = vec3(0.6,0.4,0.7);\n\n\tif (t < 0.0){ // sky\n\t\tcol = bg;\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,lc),0.0,1.0), 20.0 ); // sun\n\t}\n    else{ // hit with object surface\n        vec3 p = ro + rd * t;\n\t\tvec3 n = calcNormal( p, px );\n\t\t//vec2 mat_uv = vec2(mat.w, atan(mat.z, mat.y) ); //angle-u angle-v\n\n\t\tif(texture_ON){\n\t\t\t//texture_data\n\t\t\tvec2 z = mat.xy; float au = mat.z; float sr = mat.w; float ssr = sig(sr);\n\n\t\t\t// texture_coords\n\t\t\tfloat u = au/PI;\n\t\t\tfloat v = ssr*atan(z.y, z.x)/PI;\n\n\t\t\t// texture_color\n\t\t\tu -= j2_sh_pv1 * iTime;\n\t\t\tfloat col_h = 1.0; // h in [-0.5,0.0,+0.5] => [green_cyan,red,blue_cyan]\n\t\t\t//col_h *= 0.5*v;\n\t\t\tcol_h *= 0.5*u;\n\t\t\tfloat col_s = 1.0;\n\t\t\t//col_s *= 0.9+0.1*ssr; // show polygon rotation sens in u-direction\n\t\t\tfloat col_v = 1.0;\n\t\t\tcol_v *= .5+.5*fract(float(tex_u_subdiv)*1.0*(.5+.5*u));\n\t\t\tcol_v *= .5+.5*fract(float(tex_v_subdiv)*2.0*(.5+.5*v));\n\n\t\t\tcol = hsv2rgb(col_h,col_s,col_v);\n\t\t}\n\t\telse col = -n;\n\n\t\tif(shade_ON){\n\t\t\t// lighting\n\t\t\tfloat occ = calcAO( p, n );\n\t\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\t\t\tvec4 temp; // dummy variable\n\t\t\tfloat dif = clamp( dot( n, ld ), 0.0, 1.0 ) * map( p+n*1.16, temp);\n\t\t\tfloat spe = pow(clamp( dot( rd, ld ), 0.0, 1.0 ),16.0);\n\t\t\tfloat sss = map( p - n*0.001, temp)/0.01;\n\t\t\t// shading\n\t\t\tdif *= softshadow( p, ld, 0.1, 1. );\n\t\t\tvec3 brdf = vec3(0.0);\n\t\t\tbrdf += 0.2*dif*vec3(1.00,0.90,0.60);\n\t\t\tbrdf += 0.2*spe*vec3(0.8,0.60,0.20)*dif;\n\t\t\tbrdf += 0.2*amb*vec3(0.40,0.60,0.40)*occ;\n\t\t\tbrdf += 0.4;\n\t\t\tcol.rgb *= brdf;\n\t\t}\n\n\t\tif(fog_ON){\n\t\t\t// fog\n\t\t\tcol = mix( bg,col, exp( -0.025*t*t));\n\t\t}\n\t}\n\t// gamma\n\tcol = sqrt(col);\n\n    fragColor = vec4(col,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define PRESET_Shape_000\n#define PRESET_Shape_001\n//#define PRESET_Shape_002\n//#define PRESET_Shape_003\n//#define PRESET_Shape_004\n//#define PRESET_Shape_005\n//#define PRESET_Shape_006\n//#define PRESET_Shape_007\n\n#ifdef PRESET_Shape_000\nconst float cam_dist = 4.7470617;\nconst float bb_size = -3.0;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 333;\nconst float rm_p3slmul = 0.3;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 11;\nconst int tex_v_subdiv = 2;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 1;\nconst float ba_v_distri = 1.0;\nconst float ba_sh_a = -5.87952;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 5.0;\nconst float j1_sh_a1 = 0.5;\nconst int j1_sh_f1 = 1;\nconst float j1_sh_p1 = -0.037736;\nconst float j1_sh_pv1 = 0.3;\nconst int j1_to_c = 0;\nconst int j1_to_f = 2;\nconst float j1_to_p = 0.03773606;\nconst float j1_to_pv = 0.1;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = -2.0;\nconst float j2_sh_a1 = 3.5;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = -0.19999999;\nconst float j2_sh_pv1 = 0.07;\nconst int j2_to_c = -1;\nconst int j2_to_f = 4;\nconst float j2_to_p = 0.0;\nconst float j2_to_pv = 0.05;\n#endif // PRESET_Shape_000\n\n#ifdef PRESET_Shape_001\nconst float cam_dist = 4.852944;\nconst float bb_size = -6.0;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 333;\nconst float rm_p3slmul = 0.3;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 11;\nconst int tex_v_subdiv = 2;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 3;\nconst float ba_v_distri = 0.5;\nconst float ba_sh_a = -4.5;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 1.0291395;\nconst float j1_sh_a1 = 0.5;\nconst int j1_sh_f1 = 1;\nconst float j1_sh_p1 = 0.0;\nconst float j1_sh_pv1 = 0.3;\nconst int j1_to_c = 1;\nconst int j1_to_f = 2;\nconst float j1_to_p = 0.0;\nconst float j1_to_pv = 0.1;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = -2.0;\nconst float j2_sh_a1 = 3.5;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = -0.19999999;\nconst float j2_sh_pv1 = 0.07;\nconst int j2_to_c = -1;\nconst int j2_to_f = 4;\nconst float j2_to_p = 0.0;\nconst float j2_to_pv = 0.05;\n#endif // PRESET_Shape_001\n\n#ifdef PRESET_Shape_002\nconst float cam_dist = 5.67198;\nconst float bb_size = -3.849708;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 303;\nconst float rm_p3slmul = 0.268786;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 3;\nconst float ba_v_distri = 0.3669623;\nconst float ba_sh_a = -4.219776;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 1.0291395;\nconst float j1_sh_a1 = 0.10017967;\nconst int j1_sh_f1 = 3;\nconst float j1_sh_p1 = 0.12568402;\nconst float j1_sh_pv1 = 0.0631578;\nconst int j1_to_c = 1;\nconst int j1_to_f = 2;\nconst float j1_to_p = -0.92714;\nconst float j1_to_pv = 0.16120201;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = -1.88995;\nconst float j2_sh_a1 = 3.4928207;\nconst int j2_sh_f1 = 2;\nconst float j2_sh_p1 = -0.19999999;\nconst float j2_sh_pv1 = 0.0746412;\nconst int j2_to_c = -1;\nconst int j2_to_f = 4;\nconst float j2_to_p = 0.060109973;\nconst float j2_to_pv = -0.1896174;\n#endif // PRESET_Shape_002\n\n#ifdef PRESET_Shape_003\nconst float cam_dist = 5.67198;\nconst float bb_size = -5.531712;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 1460;\nconst float rm_p3slmul = 0.378815;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = true;\nconst bool fog_ON = false;\nconst int ba_id = 3;\nconst float ba_v_distri = 0.48437533;\nconst float ba_sh_a = -8.0;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = -0.31099987;\nconst float j1_sh_a1 = 1.62679;\nconst int j1_sh_f1 = 0;\nconst float j1_sh_p1 = 0.425838;\nconst float j1_sh_pv1 = 0.0631578;\nconst int j1_to_c = 4;\nconst int j1_to_f = 5;\nconst float j1_to_p = -0.31100398;\nconst float j1_to_pv = 0.0588516;\nconst bool j2_ON = false;\nconst float j2_sh_a0 = 1.6149902;\nconst float j2_sh_a1 = 0.0;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = 0.14624596;\nconst float j2_sh_pv1 = -0.050988004;\nconst int j2_to_c = 0;\nconst int j2_to_f = 3;\nconst float j2_to_p = 0.012920022;\nconst float j2_to_pv = 0.3;\n#endif // PRESET_Shape_003\n\n#ifdef PRESET_Shape_004\nconst float cam_dist = 5.67198;\nconst float bb_size = -5.531712;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 1460;\nconst float rm_p3slmul = 0.378815;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = true;\nconst bool fog_ON = false;\nconst int ba_id = 1;\nconst float ba_v_distri = 0.48437533;\nconst float ba_sh_a = -8.0;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = -0.31099987;\nconst float j1_sh_a1 = 1.62679;\nconst int j1_sh_f1 = 2;\nconst float j1_sh_p1 = 0.425838;\nconst float j1_sh_pv1 = 0.0631578;\nconst int j1_to_c = -1;\nconst int j1_to_f = 5;\nconst float j1_to_p = 0.0;\nconst float j1_to_pv = 0.0;\nconst bool j2_ON = false;\nconst float j2_sh_a0 = 1.6149902;\nconst float j2_sh_a1 = 0.0;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = 0.14624596;\nconst float j2_sh_pv1 = -0.050988004;\nconst int j2_to_c = 0;\nconst int j2_to_f = 3;\nconst float j2_to_p = 0.012920022;\nconst float j2_to_pv = 0.3;\n#endif // PRESET_Shape_004\n\n#ifdef PRESET_Shape_005\nconst float cam_dist = 5.67198;\nconst float bb_size = -5.531712;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 1460;\nconst float rm_p3slmul = 0.378815;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = false;\nconst bool fog_ON = false;\nconst int ba_id = 1;\nconst float ba_v_distri = 1.0;\nconst float ba_sh_a = -3.4506078;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 2.0095701;\nconst float j1_sh_a1 = -1.6746399;\nconst int j1_sh_f1 = 2;\nconst float j1_sh_p1 = -0.029586017;\nconst float j1_sh_pv1 = 0.0631578;\nconst int j1_to_c = 2;\nconst int j1_to_f = 3;\nconst float j1_to_p = 0.0;\nconst float j1_to_pv = 0.0;\nconst bool j2_ON = false;\nconst float j2_sh_a0 = 1.6149902;\nconst float j2_sh_a1 = 0.0;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = 0.14624596;\nconst float j2_sh_pv1 = -0.050988004;\nconst int j2_to_c = 0;\nconst int j2_to_f = 3;\nconst float j2_to_p = 0.012920022;\nconst float j2_to_pv = 0.3;\n#endif // PRESET_Shape_005\n\n#ifdef PRESET_Shape_006\nconst float cam_dist = 5.663412;\nconst float bb_size = 2.4986763;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 387;\nconst float rm_p3slmul = 0.302387;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 1;\nconst float ba_v_distri = 1.0;\nconst float ba_sh_a = -3.39568;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 1.7441897;\nconst float j1_sh_a1 = 2.9328198;\nconst int j1_sh_f1 = 1;\nconst float j1_sh_p1 = 0.0;\nconst float j1_sh_pv1 = 0.0;\nconst int j1_to_c = -1;\nconst int j1_to_f = 3;\nconst float j1_to_p = -0.031620026;\nconst float j1_to_pv = 0.0;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = 1.5714302;\nconst float j2_sh_a1 = -0.19048023;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = 0.0;\nconst float j2_sh_pv1 = 0.0;\nconst int j2_to_c = 0;\nconst int j2_to_f = 2;\nconst float j2_to_p = 0.012920022;\nconst float j2_to_pv = 0.3;\n#endif // PRESET_Shape_006\n\n#ifdef PRESET_Shape_007\nconst float cam_dist = 4.852944;\nconst float bb_size = -3.0;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 333;\nconst float rm_p3slmul = 0.3;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 11;\nconst int tex_v_subdiv = 2;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 0;\nconst float ba_v_distri = 0.5;\nconst float ba_sh_a = -4.5;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 1.0291395;\nconst float j1_sh_a1 = 0.5;\nconst int j1_sh_f1 = 1;\nconst float j1_sh_p1 = 0.0;\nconst float j1_sh_pv1 = 0.3;\nconst int j1_to_c = 1;\nconst int j1_to_f = 2;\nconst float j1_to_p = 0.0;\nconst float j1_to_pv = 0.1;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = -2.0;\nconst float j2_sh_a1 = 3.5;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = -0.19999999;\nconst float j2_sh_pv1 = 0.07;\nconst int j2_to_c = -1;\nconst int j2_to_f = 4;\nconst float j2_to_p = 0.0;\nconst float j2_to_pv = 0.05;\n#endif // PRESET_Shape_007\n\n//Synthclipse///////////////////////////////////////////////////////////////////\n/*\n//! <group name=\"came\">\nuniform float cam_dist; //! slider[0.0, 4.0, 6.0]       // camera distance\n//! <group name=\"ray_march\">\nuniform float bb_size; //! slider[-6., 2.0, 6.0]\t\t// bounding box size\nuniform float rm_rlmin; //! slider[0.0, 1.0, 8.0]\t\t// ray march ray_length minimum\nuniform int   rm_imax; //! slider[100, 700, 2000]\t\t// ray march maximal number of iterations\nuniform float rm_p3slmul; //! slider[0.0, 0.2, 1.0]\t\t// ray march power(step length multiplier,3)\n//! <group name=\"color\">\nuniform bool texture_ON; //! checkbox[true]\nuniform int tex_u_subdiv; //! slider[1, 6, 12]\nuniform int tex_v_subdiv; //! slider[1, 6, 12]\nuniform bool shade_ON; //! checkbox[false]\nuniform bool fog_ON; //! checkbox[false]\n//! <group name=\"base0\">\nuniform int   ba_id; //! slider[0,2,3]\t\t\t// root-transformation id\nuniform float ba_v_distri; //! slider[0.01, 1.0, 1.0]\t// root-v distribution\nuniform float ba_sh_a; //! slider[-8., 3., 8.]\t\t// root-shift amplitude\nuniform float end_r0; //! slider[0.1, 1.0, 1.0]\t// leaf-transformation radius r0\n//! <group name=\"julia1\">\nuniform bool j1_ON; //! checkbox[true]\n// shift in u-direction any normalized periodic function.\n// shift = sh_a0 + sh_a1 * npfunc(sh_f1 * (au/PI-(sh_p1 + sh_pv1 * iTime)));\nuniform float j1_sh_a0; //! slider[-8., -3., 8.]\t// 0.degree amplitude\nuniform float j1_sh_a1; //! slider[-8., 0., 8.]\t\t// 1.degree amplitude\nuniform int   j1_sh_f1; //! slider[-18, 1, 18]\t\t// 1.degree frequency\nuniform float j1_sh_p1 ; //! slider[-1., 0.0, +1.]\t// 1.degree phase\nuniform float j1_sh_pv1; //! slider[-0.3, 0.0, 0.3]\t// 1.degree phase\n// torsion in v-direction\n// to = ssr * ( au/PI*j2_to_c/j2_to_f + (to_p + to_pv * iTime) );\nuniform int   j1_to_c; //! slider[-10, 3, 10]\t\t// counter torsion //TEST: int\nuniform int\t  j1_to_f; //! slider[1, 4, 6]\t\t\t// fraction torsion\nuniform float j1_to_p; //! slider[-1., 0.03, +1.]\t// phase\nuniform float j1_to_pv; //! slider[-0.3, 0.0, 0.3]\t// phase velocity\n//! <group name=\"julia2\">\nuniform bool j2_ON; //! checkbox[true]\n// shift in u-direction any normalized periodic function.\n// shift = sh_a0 + sh_a1 * npfunc(sh_f1 * (au/PI-(sh_p1 + sh_pv1 * iTime)));\nuniform float j2_sh_a0; //! slider[-8., -3., 8.]\t// 0.degree amplitude\nuniform float j2_sh_a1; //! slider[-8., 0., 8.]\t\t// 1.degree amplitude\nuniform int   j2_sh_f1; //! slider[-18, 1, 18]\t\t// 1.degree frequency\nuniform float j2_sh_p1 ; //! slider[-1., 0.0, +1.]\t// 1.degree phase\nuniform float j2_sh_pv1; //! slider[-0.3, 0.0, 0.3]\t// 1.degree phase velocity\n// torsion in v-direction\n// to = ssr * ( au/PI*j2_to_c/j2_to_f + (to_p + to_pv * iTime) );\nuniform int   j2_to_c; //! slider[-10, 3, 10]\t\t// counter torsion\nuniform int\t  j2_to_f; //! slider[1, 4, 6]\t\t\t// fraction torsion\nuniform float j2_to_p; //! slider[-1., 0.03, +1.]\t// phase\nuniform float j2_to_pv; //! slider[-0.3, 0.0, 0.3]\t// phase velocity\n*/\n////////////////////////////////////////////////////////////////////////////////",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}