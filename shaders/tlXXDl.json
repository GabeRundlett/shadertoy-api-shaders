{
    "Shader": {
        "info": {
            "date": "1564592149",
            "description": "dragon quest shit",
            "flags": 0,
            "hasliked": 0,
            "id": "tlXXDl",
            "likes": 10,
            "name": "KING SLIME",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "game"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 498
        },
        "renderpass": [
            {
                "code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// Edge detection code from:https://www.shadertoy.com/view/MsSGD1\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define EDGE_WIDTH 0.05\n#define PI 3.141592653589793\n#define SLIME_BODY_COLOR vec3(0.1,0.9,1.0)\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec3 crownTex(vec2 uv) {\n    vec3 col = vec3(1.0,0.1,0.9);\n    col = (uv.x>=-0.3 && uv.x< 0.3)? vec3(0.0,1.0,0.0):col;\n    uv *= rot(radians(90.0));\n    col = (uv.x>=-0.3 && uv.x< 0.3)? vec3(0.0,1.0,0.0):col;\n    return col;   \n}\n\nvec4 sdCrown(vec3 p, vec3 crownPos) {\n    int num = 8;\n    float res = 4.0;\n    float prevres = 0.0;\n    float deg = 360.0/float(num);\n    float crownDist = 1.0;\n    \n    for(int i = 0; i<num; i++){\n        float rad = radians(deg*float(i));\n        float x = cos(rad)*crownDist;\n        float z = sin(rad)*crownDist;\n        float sp = length(p+vec3(x,-0.75,z)+crownPos)-0.15;\n        res = min(res,sdRoundCone((p+vec3(x,0.0,z)+crownPos),0.23,0.1,0.5));\n        res = min(res,sp);\n    }\n    \n    float rcd1 = sdRoundedCylinder(p+vec3(0.0,0.2,0.0)+crownPos, 0.58,0.28,0.07);\n    res = min(res,rcd1);\n    \n    float rcd2 = sdRoundedCylinder(p+vec3(0.0,-0.6,0.0)+crownPos, 0.45,0.6,0.02);\n    float rcd3 = sdRoundCone(p+vec3(0.0,-1.2,0.0)+crownPos, 0.23,0.1,0.5);\n    \n    vec4 crownBtm = vec4(vec3(1.1,0.9,0.0),res);\n    vec4 crownMid = vec4(crownTex(p.xz),rcd2);\n    vec4 crownTop = vec4(vec3(1.1,0.9,0.0),rcd3);\n    \n    return combine(combine(crownBtm,crownMid),crownTop);\n}\n\nvec3 slimeFaceTex(vec3 p) {\n    vec2 uv = p.xy;\n    vec2 uvRef = uv;\n    vec3 col = SLIME_BODY_COLOR;\n    \n    uvRef.x = abs(uvRef.x)-0.21;\n    float eyeBg = length(uvRef+vec2(0.0,0.6))-0.15;\n    float eye = length(uvRef+vec2(0.0,0.6))-0.13;\n    float eyeBall = length(uvRef+vec2(0.0,0.6))-0.03;\n    uvRef = uv;\n    \n    float mouth = sdArc( (uvRef+vec2(0.0,0.2))*rot(radians(225.0)), vec2(0.6,0.61), vec2(0.2,0.3), 0.71, 0.085 );\n    float toungue = sdArc( (uvRef+vec2(0.0,0.2))*rot(radians(225.0)), vec2(0.6,0.6), vec2(0.16,0.3), 0.7, 0.05 );\n    \n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.015,eyeBg) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eye) );\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.015,eyeBall) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,mouth) );\n    col = mix( col, vec3(0.7,0.0,0.0), 1.0-smoothstep(0.01,0.015,toungue) );  \n\n    col = (p.z>0.01)? col:SLIME_BODY_COLOR;\n    \n    return col;\n}\n\nvec4 sdBody(vec3 p) {\n    float anim = sin(iTime*5.0)*0.015;\n    float rcd = sdRoundedCylinder(p+vec3(0.0,1.2,0.0), 1.0+anim,1.1,0.02);\n    vec4 body = vec4(slimeFaceTex(p),rcd);\n    \n    p.x = abs(p.x)-0.55;\n    vec4 cheek = vec4(SLIME_BODY_COLOR,length(p+vec3(0.0,0.9,-1.65))-(0.3+anim*2.0));\n    \n    return combine(body,cheek);\n}\n\nfloat sinOut(float t) {\n  return sin(t * PI*0.5);\n}\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * PI*0.5) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat bounceOut(float t) {\n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec4 map(vec3 p){\n    float animTime = mod(iTime,3.5);\n\tfloat jump = 0.0;\n    float jumpDist = 0.5;\n\tjump -= sinOut(animscene(animTime, 0.5, 0.3))*jumpDist;\n\tjump += bounceOut(animscene(animTime, 0.8, 0.6))*jumpDist;\n    \n    float jump2 = 0.0;\n\tjump2 -= sinOut(animscene(animTime, 0.52, 0.3))*jumpDist;\n\tjump2 += bounceOut(animscene(animTime, 0.82, 0.6))*jumpDist;\n    \n    float jump3 = 0.0;\n    float floorHeight = 0.2;\n\tjump3 += sinOut(animscene(animTime, 1.02, 0.3))*floorHeight;\n\tjump3 -= elasticOut(animscene(animTime, 1.22, 2.5))*floorHeight;\n    \n    vec3 crownPos = vec3(0.0,-0.3+jump2,0.0);\n    vec4 crown = sdCrown(p,crownPos); \n    vec4 body = sdBody(p+vec3(0.0,jump,0.0));\n    \n    float height = (sin(p.x*jump3)+sin(p.z*jump3));\n    vec4 f = vec4(vec3(0.0,0.9,0.3),p.y+3.0+height);\n    return  combine(combine(crown,body),f);\n}\n\nvec3 normalMap(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n        map(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n        map(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n    ));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = map(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = p;\n    \n    float time = iTime*2.0;\n    \n    vec3 ro = vec3( 3.5*cos(0.1*time + 6.0), 0.0, -0.5+5.5*sin(0.1*time + 6.0) );\n    vec3 ta = vec3( 0.0, -0.4, -0.7 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    float zoom = 1.5;\n    vec3 rd = ca * normalize( vec3(p.xy,zoom) );\n    \n    float t, dist;\n    float lastDistEval = 1e10;\n    float edge = 0.0;\n    t = 0.0;\n    vec3 distPos = ro+rd;\n    vec4 distCl = vec4(0.0);\n    for(int i = 0; i < 64; i++){\n        distCl = map(distPos);\n        dist = distCl.w;\n        t += dist;\n        distPos = ro+rd*t;\n        \n        if (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n            edge = 1.0;\n        }\n        if (dist < lastDistEval) lastDistEval = dist;\n        if(dist < 0.01 || dist > 30.0) break;\n    }\n\n    vec3 color;\n    float shadow = 1.0;\n    if(dist < 1.0){\n        // lighting\n        vec3 lightDir = vec3(0.0, 1.0, 0.0);\n        vec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n        vec3 normal = normalMap(distPos);\n\n        // difuse color\n        float diffuse = clamp(dot(light, normal), 0.5, 1.0);\n        float lambert = max(.0, dot( normal, light));\n        \n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n        // shadow\n        shadow = shadowMap(distPos + normal * 0.001, light);\n\n        // result\n        color += vec3(lambert);\n        color = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n    }else{\n        color =.84*max(mix(vec3(0.6,0.9,1.0)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n        \n        uv.x += iTime*0.1;\n        float triangleWave = asin(sin(uv.x*3.2))*0.2;\n        color = mix( color, vec3(0.4,0.2,0.01), 1.0-smoothstep(0.01,0.015,p.y+0.05+triangleWave) );\n        \n        triangleWave = asin(sin(uv.x*3.7))*0.2;\n        color = mix( color, vec3(0.5,0.2,0.01), 1.0-smoothstep(0.01,0.015,p.y-0.05+triangleWave) );\n    \tuv = p;\n    }\n\n    // rendering result\n    float brightness = 1.5;\n    vec3 dst = (color * max(0.8, shadow))*brightness;\n    \n    // add edge detection result\n    dst = mix(dst,vec3(0.1,0.1,0.1),edge);\n    \n    // UI\n    vec3 uicol = vec3(0.0);\n    vec2 dialogPos = vec2(1.05,-0.65);\n    float dialogBg = sdBox(uv+dialogPos, vec2(0.5,0.1));\n    uicol = mix( uicol, vec3(0.9), 1.0-smoothstep(0.1,0.09,dialogBg) );\n    uicol = mix( uicol, vec3(0.1), 1.0-smoothstep(0.12,0.1,dialogBg) );\n    \n    float fakeChar0 = sdBox(uv+ vec2(1.5,dialogPos.y), vec2(0.05,0.05));\n    uicol = mix( uicol, vec3(0.5), 1.0-smoothstep(0.01,0.015,fakeChar0) );\n    float fakeChar1 = length(uv+ vec2(1.35,dialogPos.y))-0.05;\n    uicol = mix( uicol, vec3(0.5), 1.0-smoothstep(0.01,0.015,fakeChar1) );\n    float fakeChar2 = sdBox(uv+ vec2(1.2,dialogPos.y), vec2(0.05,0.05));\n    uicol = mix( uicol, vec3(0.5), 1.0-smoothstep(0.01,0.015,fakeChar2) );\n    float fakeChar3 = length(uv+ vec2(1.05,dialogPos.y))-0.05;\n    uicol = mix( uicol, vec3(0.5), 1.0-smoothstep(0.01,0.015,fakeChar3) );\n    float fakeChar4 = sdBox(uv+ vec2(0.9,dialogPos.y+0.04), vec2(0.05,0.005));\n    uicol = mix( uicol, vec3(0.5+sin(iTime*9.0)*0.5), 1.0-smoothstep(0.01,0.015,fakeChar4) );\n    \n    fragColor = vec4(dst+uicol, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}