{
    "Shader": {
        "info": {
            "date": "1501050569",
            "description": "Left / right arrow keys steer you through the adventure. Clicking on the left/right sides of the screen also steers. Let me know what works / doesn't work and I can try to fix it. :D",
            "flags": 48,
            "hasliked": 0,
            "id": "MltGWN",
            "likes": 46,
            "name": "[SH17B] Escape the Gamegrid",
            "published": 3,
            "tags": [
                "raytracing",
                "game",
                "tron",
                "raytrace"
            ],
            "usePreview": 1,
            "username": "otaviogood",
            "viewed": 2587
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n\nThis is a real-time ray traced tron style adventure game.\n\nUse left/right arrow keys to steer.\n\nWhen the movie Tron was made back in 1982, it took one of the best supercomputers in the world to\nray trace the scenes. Now that it's 2017, I decided I'd try to do a real-time ray traced Tron game.\nThis game uses ray tracing (not ray marching / sphere tracing). It was really problematic trying to\nget boolean geometry working in shaders, so I can't recommend it to much, but you can see what I\ngot working. In some ways, it works much faster than ray marching, but some video cards run it slowly.\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n#define saturate(a) clamp(a, 0.0, 1.0)\n\nstruct Ray\n{\n    vec3 p0, dirNormalized;\n    vec3 hitNormal;\n    float t;\n};\nstruct RayHit\n{\n    vec3 normMin, normMax;\n    float tMin, tMax;\n    vec3 hitMin, hitMax;\n    float material;\n};\nconst float bignum = 256.0*256.0;\nRayHit NewRayHit()\n{\n    RayHit rh;\n    rh.tMin = bignum;\n    rh.tMax = bignum;\n    rh.hitMin = vec3(0.0);\n    rh.hitMax = vec3(0.0);\n    rh.normMin = vec3(0.0);\n    rh.normMax = vec3(0.0);\n    rh.material = 0.0;\n    return rh;\n}\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat fade = 1.0;\nfloat exposure = 1.0;\n\n\n\n// -------------------- Start of shared state / variables --------------------\n#define PI 3.141592653\nconst ivec2 kTexState1 = ivec2(0, 160);\nconst float gameGridRadius = 16.0;\nconst vec2  gameGridCenter = vec2(80.0, 80.0);\nconst vec2 iotower = vec2(100.5, 6.5);\n// Thumbnail is 288x162 res\nconst vec2 smallestResolution = vec2(288.0, 162.0);\n\nvec3 bikeAPos = vec3(0.0);\nfloat bikeAAngle = 0.0;\nvec3 bikeBPos = vec3(0.0);\nfloat bikeBAngle = 0.0;\nvec4 keyStateLURD = vec4(0.0);\nvec2 rotQueueA = vec2(0.0);\nvec2 rotQueueB = vec2(0.0);\nfloat bitsCollected = 0.0;\nfloat framerate = 0.0;\nfloat gameStage = 0.0;\nfloat message = 0.0;\nvec4 camFollowPos = vec4(0.0);\nvec4 indicatorPulse = vec4(0.0);\nvec4 animA = vec4(0);\n\nvec4 LoadValue(ivec2 uv) { return texelFetch(iChannel0, uv, 0); }\n\nvoid StoreValue(ivec2 st, vec4 value, inout vec4 fragColor, in vec2 fragCoord)\n{ fragColor = (ivec2(fragCoord.xy) == st)? value : fragColor; }\n\nvoid LoadState()\n{\n    vec4 state1 = LoadValue(kTexState1);\n    bikeAPos = state1.xyz;\n    bikeAAngle = state1.w;\n    keyStateLURD = LoadValue(kTexState1 + ivec2(1, 0));\n    vec4 tempRotQueue = LoadValue(kTexState1 + ivec2(2, 0));\n    rotQueueA = tempRotQueue.xy;\n    rotQueueB = tempRotQueue.zw;\n    vec4 state2 = LoadValue(kTexState1 + ivec2(3, 0));\n    bitsCollected = state2.x;\n    framerate = state2.y;\n    gameStage = state2.z;\n    message = state2.w;\n    camFollowPos = LoadValue(kTexState1 + ivec2(4, 0));\n    indicatorPulse = LoadValue(kTexState1 + ivec2(5, 0));\n    vec4 state3 = LoadValue(kTexState1 + ivec2(6, 0));\n    bikeBPos = state3.xyz;\n    bikeBAngle = state3.w;\n    animA = LoadValue(kTexState1 + ivec2(7, 0));\n}\n\nvoid StoreState(inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 state1 = vec4(bikeAPos, bikeAAngle);\n    StoreValue(kTexState1, state1, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(1, 0), keyStateLURD, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(2, 0), vec4(rotQueueA.xy, rotQueueB), fragColor, fragCoord);\n    vec4 state2 = vec4(bitsCollected, framerate, gameStage, message);\n    StoreValue(kTexState1 + ivec2(3, 0), state2, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(4, 0), camFollowPos, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(5, 0), indicatorPulse, fragColor, fragCoord);\n    vec4 state3 = vec4(bikeBPos, bikeBAngle);\n    StoreValue(kTexState1 + ivec2(6, 0), state3, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(7, 0), animA, fragColor, fragCoord);\n}\n// -------------------- End of shared state / variables --------------------\n\n\n\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\n\n// http://web.cse.ohio-state.edu/~parent/classes/681/Lectures/19.RayTracingCSGHandout.pdf\n// These are hacks that don't do complete booleans of all the depth complexity. :(\nRayHit Difference(RayHit a, RayHit b)\n{\n    RayHit rh = NewRayHit();\n    //rh.tMin = bignum;\n    //rh.tMax = bignum;\n    if (a.tMax != bignum)\n    {\n        if (a.tMin < b.tMin) return a;\n        else\n        {\n            if (b.tMax < a.tMin) return a;\n            else if (b.tMax < a.tMax)\n            {\n                rh = b;\n                rh.normMin = b.normMax;\n                rh.tMin = b.tMax;\n                rh.hitMin = b.hitMax;\n                // ACCOUNT FOR THE Back SIDE OF THE SHAPE???!!!!\n            }\n        }\n    }\n    return rh;\n}\nRayHit Union(RayHit a, RayHit b)\n{\n    if (a.tMin < b.tMin)\n    {\n/*        if ((b.tMax > a.tMax) && (b.tMax != bignum))\n        {\n            a.tMax = b.tMax;\n            a.normMax = b.normMax;\n            a.hitMax = b.hitMax;\n        }*/\n        return a;\n    }\n    else {\n        /*if ((a.tMax > b.tMax) && (a.tMax != bignum))\n        {\n            b.tMax = a.tMax;\n            b.normMax = a.normMax;\n            b.hitMax = a.hitMax;\n        }*/\n        return b;\n    }\n}\nRayHit Intersection(RayHit a, RayHit b)\n{\n    if ((b.tMin < a.tMin) && (b.tMax > a.tMin)) {\n        b.tMin = a.tMin;\n        b.normMin = a.normMin;\n        b.hitMin = a.hitMin;\n        return b;\n    }\n    else if ((a.tMin < b.tMin) && (a.tMax > b.tMin)) {\n        a.tMin = b.tMin;\n        a.normMin = b.normMin;\n        a.hitMin = b.hitMin;\n        return a;\n    }\n    RayHit rh = NewRayHit();\n    //rh.tMin = bignum;\n    //rh.tMax = bignum;\n    return rh;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\n// returns normal and t\n/*vec4 SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return vec4(bignum);\n    float t = -b - sqrt(h);\n\n    vec3 normal = normalize(radialVec + dirVecPLZNormalizeMeFirst * t);\n    return vec4(normal, t);\n}*/\n// note: There are faster ways to intersect a sphere.\nRayHit SphereIntersect2(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, float material)\n{\n    RayHit rh = NewRayHit();\n    rh.material = material;\n    vec3 delta = spherePos - pos;\n    float projdist = dot(delta, dirVecPLZNormalizeMeFirst);\n    vec3 proj = dirVecPLZNormalizeMeFirst * projdist;\n    vec3 bv = proj - delta;\n    float b = length(bv);\n    if (b > rad) {\n        //rh.tMin = bignum;\n        //rh.tMax = bignum;\n        return rh;\n    }\n    float x = sqrt(rad*rad - b*b);\n    rh.tMin = projdist - x;\n    if (rh.tMin < 0.0) {\n        rh.tMin = bignum;\n        return rh;\n    }\n    rh.tMax = projdist + x;\n    rh.hitMin = pos + dirVecPLZNormalizeMeFirst * rh.tMin;\n    rh.hitMax = pos + dirVecPLZNormalizeMeFirst * rh.tMax;\n    rh.normMin = normalize(rh.hitMin - spherePos);\n    rh.normMax = normalize(spherePos - rh.hitMax);\n    return rh;\n}\n\nvec4 PlaneYIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 planePos)\n{\n    // Ray trace a ground plane to infinity\n    pos -= planePos;\n    float t = -pos.y / dirVecPLZNormalizeMeFirst.y;\n    if (t > 0.0) {\n        vec3 normal = vec3(0.0, 1.0 * sign(-dirVecPLZNormalizeMeFirst.y), 0.0);\n        return vec4(normal, t);\n    } else return vec4(bignum);\n}\n\nvec3 ElementwiseEqual(in vec3 a, in float b) {\n\treturn abs(sign(a - b));\n}\n\n// https://tavianator.com/fast-branchless-raybounding-box-intersections/\nRayHit BoxIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 boxPos, vec3 rad, float material)\n{\n    vec3 bmin = boxPos - rad;\n    vec3 bmax = boxPos + rad;\n    vec3 rayInv = 1.0 / dirVecPLZNormalizeMeFirst;\n\n    vec3 t1 = (bmin - pos) * rayInv;\n    vec3 t2 = (bmax - pos) * rayInv;\n\n    vec3 vmin = min(t1, t2);\n    vec3 vmax = max(t1, t2);\n\n    float tmin = max(vmin.z, max(vmin.x, vmin.y));\n    float tmax = min(vmax.z, min(vmax.x, vmax.y));\n\n    RayHit rh = NewRayHit();\n    //rh.tMin = bignum;\n    //rh.tMax = bignum;\n    if ((tmax <= tmin)) return rh;\n    if ((tmin <= 0.0)) return rh;\n    //if ((tmax <= tmin) || (tmin <= 0.0)) return rh;\n    rh.tMin = tmin;\n    rh.tMax = tmax;\n    rh.hitMin = pos + dirVecPLZNormalizeMeFirst * rh.tMin;\n    rh.hitMax = pos + dirVecPLZNormalizeMeFirst * rh.tMax;\n    // optimize me!\n    //if (t1.x == tmin) rh.normMin = vec3(-1.0, 0.0, 0.0);\n    //if (t2.x == tmin) rh.normMin = vec3(1.0, 0.0, 0.0);\n    //if (t1.y == tmin) rh.normMin = vec3(0.0, -1.0, 0.0);\n    //if (t2.y == tmin) rh.normMin = vec3(0.0, 1.0, 0.0);\n    //if (t1.z == tmin) rh.normMin = vec3(0.0, 0.0, -1.0);\n    //if (t2.z == tmin) rh.normMin = vec3(0.0, 0.0, 1.0);\n    rh.normMin = ElementwiseEqual(t1, tmin) - ElementwiseEqual(t2, tmin);\n    // optimize me!\n    //if (t1.x == tmax) rh.normMax = -vec3(-1.0, 0.0, 0.0);\n    //if (t2.x == tmax) rh.normMax = -vec3(1.0, 0.0, 0.0);\n    //if (t1.y == tmax) rh.normMax = -vec3(0.0, -1.0, 0.0);\n    //if (t2.y == tmax) rh.normMax = -vec3(0.0, 1.0, 0.0);\n    //if (t1.z == tmax) rh.normMax = -vec3(0.0, 0.0, -1.0);\n    //if (t2.z == tmax) rh.normMax = -vec3(0.0, 0.0, 1.0);\n    rh.normMax = ElementwiseEqual(t1, tmax) - ElementwiseEqual(t2, tmax);\n    rh.material = material;\n    return rh;\n}\n\nfloat waterLevel = 0.0;\nvec3 CalcNormal(const in vec3 pos, const in vec3 rayVec)\n{\n    // find the axis that is closest to 1.0 or 0.0.\n    vec3 normal = vec3(0.0);\n    vec3 frpos = 0.5-abs(0.5-fract(pos));\n    vec3 fr = frpos * 2.0;\n    fr = pow(fr, vec3(0.25));\n    float sum = fr.x + fr.y + fr.z;\n    vec3 div = fr / sum;\n    float minAll = min(frpos.x, min(frpos.y, frpos.z));\n    if (frpos.x == minAll) normal = vec3(-1.0, 0.0, 0.0) * sign(rayVec.x);\n    if (frpos.y == minAll) normal = vec3(0.0, -1.0, 0.0) * sign(rayVec.y);\n    if (frpos.z == minAll) normal = vec3(0.0, 0.0, -1.0) * sign(rayVec.z);\n    //normal = normalize(div + normal);\n\n    // Water wave normals\n    if (pos.y < waterLevel+0.01) {\n        normal.x += texture(iChannel1, (pos.xz + localTime)*0.125).x*0.2-0.1;\n        normal.y += texture(iChannel1, (pos.zx - localTime)*0.1).x*0.2-0.1;\n        //normal = normalize(normal);\n    }\n    return normal;\n}\n\n//#define DISTANCE_FIELD\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material index.\nfloat DistanceToTerrain(in vec3 p)\n{\n#ifdef DISTANCE_FIELD\n\treturn p.y - texelFetch(iChannel0, ivec2(p.xz+gameGridCenter),0).x;\n#else\n\treturn texelFetch(iChannel0, ivec2(p.xz+gameGridCenter),0).x;\n#endif\n}\n\nconst float smallVal = 0.000625;\nRayHit MarchOneRay(const in vec3 start, const in vec3 rayVec,\n                 out vec3 posI, const in int maxIter)\n{\n    RayHit rh = NewRayHit();\n    rh.material = 256.0;\n\tfloat dist = 1000000.0;\n\tfloat t = 0.0;\n\tvec3 pos = vec3(0.0);\n    vec3 signRay = max(vec3(0.0), sign(rayVec));\n\t// ray marching time\n    pos = start;\n    posI = floor(start);\n    vec3 delta = signRay - fract(pos);\n    vec3 hit = (delta/rayVec);\n    vec3 signRayVec = sign(rayVec);\n    vec3 invAbsRayVec = abs(1.0 / rayVec);\n    // This is the highest we can ray march before early exit.\n    float topBounds = max(10.0, start.y);\n    for (int i = 0; i < maxIter; i++)\t// This is the count of the max times the ray actually marches.\n    {\n#ifdef DISTANCE_FIELD\n        //dist = DistanceToTerrain(posI);\n\t\tdist = posI.y - texelFetch(iChannel0, ivec2(posI.xz+gameGridCenter),0).x;\n#else\n\t\tvec4 terrainTex = texelFetch(iChannel0, ivec2(posI.xz+gameGridCenter),0);\n        dist = terrainTex.x;\n#endif\n        if ((terrainTex.y != 0.0) && (dist >= posI.y)) {\n            if (round(posI.y) == 1.0)\n            {\n                float inGameGrid = max(abs(posI.x), abs(posI.z));\n                float tex = mod(terrainTex.y, 16.0);\n                // Only draw yellow trail walls if we're inside the game grid.\n                if (inGameGrid <= gameGridRadius) {\n                    vec3 boxSizeX = vec3(0.02, 0.25, 0.02);\n                    vec3 boxSizeZ = vec3(0.02, 0.25, 0.02);\n                    boxSizeX.x += sign(float(int(tex)&1))*0.25;\n                    boxSizeX.x += sign(float(int(tex)&2))*0.25;\n                    boxSizeZ.z += sign(float(int(tex)&4))*0.25;\n                    boxSizeZ.z += sign(float(int(tex)&8))*0.25;\n                    vec3 boxOffsetX = posI + 0.5 - vec3(0,0.25,0);\n                    vec3 boxOffsetZ = posI + 0.5 - vec3(0,0.25,0);\n                    // Shrink the blue trail when bad guy dies\n                    if (terrainTex.y >= 16.0) {\n                        float anim = saturate(animA.x);\n                        boxSizeX.y *= anim;\n                        boxSizeZ.y *= anim;\n                        boxOffsetX.y -= (1.0 - anim) * 0.25;\n                        boxOffsetZ.y -= (1.0 - anim) * 0.25;\n                    }\n                    boxOffsetX.x -= sign(float(int(tex)&1))*0.25;\n                    boxOffsetX.x += sign(float(int(tex)&2))*0.25;\n                    boxOffsetZ.z -= sign(float(int(tex)&4))*0.25;\n                    boxOffsetZ.z += sign(float(int(tex)&8))*0.25;\n                    RayHit rh = BoxIntersect(pos, rayVec, boxOffsetX, boxSizeX, 1.0);\n                    rh = Union(rh, BoxIntersect(pos, rayVec, boxOffsetZ, boxSizeZ, 1.0));\n                    if (rh.tMin == bignum) dist = smallVal;\n                    else {\n                        rh.material = 128.0;\n                        if (terrainTex.y >= 16.0) rh.material = 129.0;\n                        return rh;\n                    }\n                }\n            }\n            if (terrainTex.y == 256.0) {\n                vec3 bpos = pos - (posI + 0.5);\n                bpos = RotateY(bpos, localTime*8.0);\n                vec3 rayVecR = RotateY(rayVec, localTime*8.0);\n                bpos += (posI + 0.5);\n                RayHit rh = BoxIntersect(bpos, rayVecR, posI + 0.5, vec3(0.28), 8.0);\n                if (rh.tMin == bignum) dist = smallVal;  // Missed powerup. Keep ray marching.\n                else return rh;  // Hit powerup\n            }\n            //vec4 hitS = SphereIntersect(pos, rayVec, posI + 0.5, 0.5);\n            //if (hitS.w == bignum) dist = smallVal;\n        }\n        // || (t > maxDepth)\n#ifdef DISTANCE_FIELD\n        if ((dist < smallVal) || (posI.y > topBounds)) break;\n#else\n        if ((dist >= posI.y) || (posI.y > topBounds)) break;\n#endif\n\n        vec3 absHit = abs(hit);\n        t = min(absHit.x, min(absHit.y, absHit.z));\n        vec3 walk = step(absHit, vec3(t));\n        hit += walk * invAbsRayVec;\n        posI += walk * signRayVec;\n        /*if (t == absHit.x) {\n            hit.x += invAbsRayVec.x;\n            posI.x += signRayVec.x;\n        }\n        if (t == absHit.y) {\n            hit.y += invAbsRayVec.y;\n            posI.y += signRayVec.y;\n        }\n        if (t == absHit.z) {\n            hit.z += invAbsRayVec.z;\n            posI.z += signRayVec.z;\n        }*/\n    }\n#ifdef DISTANCE_FIELD\n    if (dist >= smallVal) return rh;\n#else\n    if (dist < posI.y) return rh;\n#endif\n    // Hit the voxel terrain\n    pos = t * rayVec + start;\n\t//vec4 tex = texelFetch(iChannel0, ivec2(pos.xz+gameGridCenter),0);\n    //if (abs(pos.y - tex.x) > 2.5) rh.material = 1.0;\n    rh.tMin = t;\n    rh.hitMin = pos;\n    rh.normMin = CalcNormal(pos, rayVec);\n    rh.tMax = rh.tMin + 1.0;\n    return rh;\n}\n\n\nRayHit Wheel(vec3 camPos, vec3 rayVec, float offset, float squeeze, float material)\n{\n    RayHit ray;\n    ray = SphereIntersect2(camPos, rayVec, vec3(offset, 0.25, 0.0), 0.25, material);\n    ray = Intersection(ray, BoxIntersect(camPos, rayVec, vec3(offset, 0.25, 0.0), vec3(0.5, 0.25, squeeze), material));\n    ray = Difference(ray, SphereIntersect2(camPos, rayVec, vec3(offset, 0.25, 0.3), 0.25, 3.0));\n    ray = Difference(ray, SphereIntersect2(camPos, rayVec, vec3(offset, 0.25, -0.3), 0.25, 3.0));\n    ray = Union(ray, SphereIntersect2(camPos, rayVec, vec3(offset, 0.25, 0.0), 0.10, 0.0));\n    return ray;\n}\n\nRayHit Bike(vec3 camPos, vec3 rayVec, vec3 bpos, float bangle, float material)\n{\n    mat3 m = mat3(\n        1.0, 0.0, 0.0, // first column (not row!)\n        0.0, 1.0, 0.0, // second column\n        0.0, 0.0, 1.0  // third column\n    );\n//    float cos = cos(rad);\n  //  float sin = sin(rad);\n    //return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n\n    // could optimize by not recalcing the sin/cos every time. or matrixing?\n    bpos -= camPos;\n    bpos = RotateY(bpos, bangle);\n    rayVec = RotateY(rayVec, bangle);\n    bpos += camPos;\n\n    camPos -= bpos;\n    RayHit bi = BoxIntersect(camPos, rayVec, vec3(0.0, 0.33, 0.0), vec3(1.0, 0.33, 0.15), 0.0);\n    //bi.normMin = RotateY(bi.normMin, -bangle);\n    //return bi;\n    //vec4 sp = SphereIntersect(camPos, rayVec, vec3(0.0), 1.0);\n    if (bi.tMin == bignum)\n    {\n        RayHit rh = NewRayHit();\n        //rh.tMin = bignum;\n        return rh;\n    }\n    RayHit ray = Wheel(camPos, rayVec, 0.5, 0.145, material);\n    RayHit r2 = Wheel(camPos, rayVec, -0.5, 0.12, material);\n    ray = Union(ray, r2);\n    RayHit body = SphereIntersect2(camPos, rayVec, vec3(0, -0.63, 0.0), 1.25, material);\n    body = Intersection( body, BoxIntersect(camPos, rayVec, vec3(0.0, 0.4, 0.0), vec3(0.5, 0.25, 0.06), material));\n    if ((body.hitMin.y > 0.5) && (body.hitMin.x > 0.1)) body.material = 3.0;\n    RayHit body2 = SphereIntersect2(camPos, rayVec, vec3(0, -0.75, 0.0), 1.25, 2.0);\n    body2 = Intersection(body2, BoxIntersect(camPos, rayVec, vec3(0.0, 0.4, 0.0), vec3(0.35, 0.2, 0.09), 2.0));\n    ray = Union(ray, body);\n    ray = Union(ray, body2);\n\n    //ray = BoxIntersect(camPos, rayVec, vec3(0.0, 0.33, 0.0), vec3(1.0, 0.33, 0.01)*0.9, 0.0);\n    ray.normMin = RotateY(ray.normMin, -bangle);\n\n    ray.hitMin = RotateY(ray.hitMin, -bangle)+bpos;\n\n    return ray;\n}\n\nfloat effect = 1.0;\nvec3 CalcTexColor(RayHit ray, vec3 camPos)\n{\n    vec3 texColor = vec3(0.3);\n    if (ray.material == 1.0) {\n        // Bike's yellow\n        texColor = vec3(1.0, 0.4, 0.1);\n    }\n    else if (ray.material == 2.0) texColor *= vec3(0.25);\n    else if (ray.material == 3.0) texColor *= vec3(0.0);\n    //else if (ray.material == 5.0) texColor *= vec3(1.0, 0.1, 0.06);\n    else if (ray.material == 5.0) texColor *= vec3(0.05, 0.4, 1.0);\n    else if (ray.material == 8.0) texColor = vec3(0.0, 1.5, 0.0);  // bit collecting powerups\n    else if (ray.material == 9.0) {\n        // I/O tower\n        texColor = texture(iChannel1, ray.hitMin.xy*0.01 - localTime * 0.4).xxx;\n        // IO tower changes to blue once you can transmit information.\n        if ((gameStage >= 300.0) && (gameStage < 1000.0)) texColor *= vec3(2.0, 4.0, 8.0);\n        else texColor *= vec3(8.0, 1.0, 1.5);\n    }\n    else if (ray.material == 128.0) {\n        texColor *= vec3(1.0, 0.6, 0.1)*6.0;\n        texColor += pow(abs(1.0-fract(ray.hitMin.y)), 4.0);\n        texColor.g -= pow(abs(fract(ray.hitMin.y)), 4.0)*0.5;\n    }\n    else if (ray.material == 129.0) {\n        texColor *= vec3(0.05, 0.3, 0.8)*6.0;\n        texColor += pow(abs(1.0-fract(ray.hitMin.y)), 4.0);\n        texColor.g -= pow(abs(fract(ray.hitMin.y)), 4.0)*0.5;\n    }\n    else if (ray.material == 256.0) {\n        vec3 gridXYZ = abs(fract(ray.hitMin+0.5)-0.5)*2.0;\n        float grid = max(gridXYZ.y, max(gridXYZ.x, gridXYZ.z));\n        texColor = vec3(0.05, 0.2, 0.9) * 4.0 * saturate(grid - 0.8);// * ray.normMin.y;\n        // Make the grid fade toward the back for antialiasing / mip map style\n        float dist = 1.0/distance(ray.hitMin, camPos);\n        // Also make the grid lines wider toward the back for mip mapped look\n        float wide = 1.0 + dist*28.0;\n        texColor = vec3(0.05, 0.2, 0.9) * saturate(pow(abs(grid),wide));\n        texColor += vec3(1.0, 0.8, 0.3) * 1.0 * saturate(pow(abs(grid), 8.0)*dist);\n        //if (ray.normMin.y < 0.5) texColor += vec3(0.5,0.1,0.1);\n        //vec3 maxd = max(dFdx(ray.hitMin), dFdy(ray.hitMin));\n        //float delta = max(max(maxd.x, maxd.y), maxd.z);\n        //texColor *= 1.0-saturate(delta);\n        // hack to fix grid aliasing in the distance\n        texColor *= saturate(vec3(6.0) * dist);\n\n        // highlight the game grid\n        float inGameGrid = max(abs(ray.hitMin.x-0.5), abs(ray.hitMin.z-0.5));\n        if (inGameGrid < gameGridRadius) {\n            texColor += vec3(0.0, 0.05, 1.05)*0.1;\n        }\n\n        grid = fract(ray.hitMin.y);\n        if (ray.normMin.y == 0.0) texColor += vec3(3.0,0.0,0.0) * pow(abs(grid-0.5)*2.0,12.0);\n        // Water color\n        if (ray.hitMin.y < waterLevel+0.01) texColor = vec3(0, 0.07, .38);\n    }\n    // indicator pulse\n    float pulseRad = length(ray.hitMin - indicatorPulse.xyz);\n    texColor += saturate(sin((pulseRad - localTime*2.0)*8.0) - pulseRad*0.03) * saturate(indicatorPulse.w);\n\n    // teleport in effect\n    float noise = texture(iChannel1, ray.hitMin.xz*0.5 + iTime*7.0).x;\n    texColor += vec3(0.01, 0.2, 1.0) * noise*28.0 * effect;\n\n    return texColor;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec3 GetEnvColor2(vec3 camPos, vec3 rayDir, vec4 bike, bool cinematicHack)\n{\n    if (cinematicHack) {\n        vec3 col = texture(iChannel3, RotateZ(rayDir, 0.0)).xyz;\n        vec4 normalT = PlaneYIntersect(camPos, rayDir, bike.xyz);\n        vec3 hit = camPos + rayDir * normalT.w;\n        float shadowSize = 1.73;\n        float shadow = saturate(shadowSize*length(hit-bike.xyz - vec3(0.5, 0, 0)));\n        shadow *= saturate(shadowSize*length(hit-bike.xyz + vec3(0.5, 0, 0)));\n        return col * shadow;\n    }\n    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(rayDir, /*sunDir*/ vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    //final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    //final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\nRayHit RayTraceScene(vec3 camPos, vec3 rayVec, const in int maxIter, bool cinematicHack)\n{\n    RayHit ray = Bike(camPos, rayVec, bikeAPos, bikeAAngle, 1.0);\n    if (!cinematicHack) {\n        ray = Union(ray, Bike(camPos, rayVec, bikeBPos, bikeBAngle, 5.0));\n        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -1.0), 0.0));\n        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -2.0), 0.0));\n        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -3.0), 0.0));\n        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -4.0), 0.0));\n\n        vec3 posI;\n        RayHit voxels = MarchOneRay(camPos, rayVec, posI, maxIter);\n        ray = Union(ray,voxels);\n\n        // I/O Tower\n        ray = Union(ray, BoxIntersect(camPos, rayVec, vec3(iotower.x, 0.25, iotower.y), vec3(0.5, 256.0, 0.5), 9.0));\n    }\n    return ray;\n}\n\nvoid RenderScene(vec3 camPos, vec3 rayVec, inout vec3 finalColor, bool cinematicHack)\n{\n\tRayHit ray = RayTraceScene(camPos, rayVec, 176, cinematicHack);\n\n    if (ray.tMin != bignum)\n    {\n        // calculate the reflection vector for highlights\n        vec3 ref = normalize(reflect(rayVec, ray.normMin));\n        vec3 refColor = GetEnvColor2(camPos, ref, vec4(bikeAPos, bikeAAngle), cinematicHack) * 1.5;\n\n        RayHit refRay = RayTraceScene(ray.hitMin + ref*0.01, ref, 16, cinematicHack);\n        \n        vec3 texColor = CalcTexColor(ray, camPos);\n        vec3 lightColor = vec3(1.0) * (saturate(ray.normMin.y *0.5+0.5))*1.25;\n        finalColor = texColor * lightColor;\n        float fresnel = saturate(1.0 - dot(-rayVec, ray.normMin));\n        fresnel = mix(0.5, 1.0, fresnel);\n        if ((ray.material == 256.0) && (ray.normMin.y == 1.0)) refColor *= vec3(1.0, 0.5, 0.2)*3.0*dot(ray.normMin, -rayVec);\n        finalColor += refColor * fresnel * 0.4;\n        // fog\n\t\tfinalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-ray.tMin*0.0007));\n        if (cinematicHack) {\n            // fog the bike as it drives into the distance\n            vec3 backCol = texture(iChannel3, RotateZ(rayVec, 0.0)).xyz;\n            finalColor *= (rayVec.y * 0.5 + 0.5);\n            finalColor = mix(finalColor, backCol, saturate(-bikeAPos.x*0.01));\n            // Fade towards bottom so shadow matches photo better\n        }\n\n        if (refRay.tMin != bignum) {\n\t        vec3 refTexColor = CalcTexColor(refRay, camPos);\n            finalColor = mix(finalColor, refTexColor, 0.1);\n        }\n    } else {\n        finalColor = GetEnvColor2(camPos, rayVec, vec4(bikeAPos, bikeAAngle), cinematicHack);\n    }\n    //finalColor = vec3(0.03)*ray.tMin;\n\n/*    if (ray.tMin != bignum)\n    {\n        finalColor = ray.normMin * 0.5 + 0.5;\n\t    finalColor.r += pow(sin(ray.hitMin.x*32.0)*0.5+0.5, 64.0);\n\t    finalColor.g += pow(sin(ray.hitMin.y*32.0)*0.5+0.5, 64.0);\n\t    finalColor.b += pow(sin(ray.hitMin.z*32.0)*0.5+0.5, 64.0);\n        finalColor *= 0.01;\n        finalColor.b += ray.hitMin.z*ray.hitMin.z*0.05;\n    }*/\n\n}\n\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    fade = 1.0;\n    effect = 0.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv /= 2.0;  // zoom in\n\n    bool cinematicHack = false;\n    // End game cinematic\n    if ((gameStage >= 600.0) && (gameStage < 700.0)) {\n        cinematicHack = true;\n        bikeAAngle = PI;\n        bikeAPos = vec3(0);\n    }\n\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.5,0) + vec3(bikeAPos.x, max(1.0, bikeAPos.y), bikeAPos.z);\n\n    // debugging camera\n    float mx=-iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=iMouse.y/iResolution.y*3.14*0.95 + PI/2.0;\n    vec3 bikeDir = round(vec3(cos(bikeAAngle), 0.0, -sin(bikeAAngle)));\n    if (cinematicHack) {\n        camPos = vec3(2,1.0,0.95);\n        float uplook = smoothstep(0.0, 1.0, saturate((gameStage - 605.0)*0.0625))*10.0;\n        //uplook = saturate((gameStage - 604.0)*0.25);\n        camLookat=vec3(0,1.0 + uplook,0.95);\n    } else {\n    \tcamPos = camFollowPos.xyz;\n        if ((gameStage >= 100.0) && (gameStage < 102.0)) {\n            camLookat = mix(camLookat, vec3(bikeBPos.x, 1.0, bikeBPos.z), saturate((gameStage-100.0)*0.5));\n        }\n        if ((gameStage >= 102.0) && (gameStage < 104.0)) {\n            camLookat = mix(vec3(bikeBPos.x, 1.0, bikeBPos.z), camLookat, saturate((gameStage-102.0)*0.5));\n        }\n    }\n    // debug camera\n\t//camPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*82.0 + bikeAPos;\n\n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n    // End game cinematic\n    if (cinematicHack) {\n        cinematicHack = true;\n        bikeAAngle = PI;\n        float accel = pow(3.0, max(0.0, gameStage - 604.0));\n        bikeAPos = vec3(-accel+1.0, 0.3, 0.125);\n        effect = 1.0-saturate((gameStage - 600.0) * 0.5);\n    }\n\n\t// ----------------------------- Ray trace the scene ------------------------------\n\n    vec3 finalColor = vec3(0.0);\n\tRenderScene(camPos, rayVec, finalColor, cinematicHack);\n\n    // vignette?\n    finalColor *= saturate(1.0 - length(uv/2.5));\n    finalColor *= exposure;\n    if ((gameStage >= 500.0) && (gameStage < 600.0)) finalColor = mix(finalColor, vec3(1), saturate((gameStage - 500.0) * 0.5));\n    if ((gameStage >= 600.0) && (gameStage < 700.0)) {\n        finalColor = mix(vec3(1), finalColor, saturate((gameStage - 600.0) * 0.5));\n        finalColor = mix(finalColor, vec3(1.0), saturate((gameStage - 607.0) * 0.333));\n    }\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(saturate(finalColor)*saturate(fade));\n}\n\nvoid HUD(inout vec3 finalColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy/iResolution.xy;// * 2.0 - 1.0;\n    uv.y = 1.0 - uv.y;\n    uv *= 8.0;\n    uv.x *= 2.0;\n    vec2 uvf = fract(uv);\n    vec2 uvi = floor(uv);\n    float map = texelFetch(iChannel0, ivec2(uvi), 0).w;\n    vec2 charPos = vec2(mod(map, 16.0), floor(map / 16.0));\n    vec4 tex = texture(iChannel2, (uvf + charPos) / 16.0f, -100.0);\n\tfinalColor = finalColor * pow(saturate(tex.w+0.4), 6.0);\n\tfinalColor = mix(finalColor, vec3(1.0), tex.x);\n\t//finalColor = vec3(uvi/16.0,0);\n    //if (fragCoord.x < iTimeDelta*1000.0) finalColor = vec3(1);\n}\n\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n//        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Load state, unless we're in small thumbnail mode, then there is no state.\n    if (iResolution.y > 160.0) LoadState();\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n    localTime = iTime;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n    HUD(finalColor, fragCoord);\n#endif\n\n    //finalColor += texelFetch(iChannel0, ivec2(fragCoord.x, iResolution.y-fragCoord.y), 0).xyz*256.0;\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define saturate(a) clamp(a, 0.0, 1.0)\n\nconst float kKeyLeft  = 37.5 / 256.0;\nconst float kKeyUp    = 38.5 / 256.0;\nconst float kKeyRight = 39.5 / 256.0;\nconst float kKeyDown  = 40.5 / 256.0;\nconst float kKeySpace = 32.5 / 256.0;\n\nfloat SampleKey(float key)\n{\n\treturn step(0.5, texture(iChannel1, vec2(key, 0.25)).x);\n}\n\nfloat localTimeDelta = 0.0;\n\n// -------------------- Start of shared state / variables --------------------\n#define PI 3.141592653\nconst ivec2 kTexState1 = ivec2(0, 160);\nconst float gameGridRadius = 16.0;\nconst vec2  gameGridCenter = vec2(80.0, 80.0);\nconst vec2 iotower = vec2(100.5, 6.5);\n// Thumbnail is 288x162 res - actually 256x144 is smallest. :(\nconst vec2 smallestResolution = vec2(288.0, 162.0);\n\nvec3 bikeAPos = vec3(0.0);\nfloat bikeAAngle = 0.0;\nvec3 bikeBPos = vec3(0.0);\nfloat bikeBAngle = 0.0;\nvec4 keyStateLURD = vec4(0.0);\nvec2 rotQueueA = vec2(0.0);\nvec2 rotQueueB = vec2(0.0);\nfloat bitsCollected = 0.0;\nfloat framerate = 0.0;\nfloat gameStage = -1.0;\nfloat message = 0.0;\nvec4 camFollowPos = vec4(0.0);\nvec4 indicatorPulse = vec4(0.0);\nvec4 animA = vec4(0);\n\nvec4 LoadValue(ivec2 uv) { return texelFetch(iChannel0, uv, 0); }\n\nvoid StoreValue(ivec2 st, vec4 value, inout vec4 fragColor, in vec2 fragCoord)\n{ fragColor = (ivec2(fragCoord.xy) == st)? value : fragColor; }\n\nvoid LoadState()\n{\n    vec4 state1 = LoadValue(kTexState1);\n    bikeAPos = state1.xyz;\n    bikeAAngle = state1.w;\n    keyStateLURD = LoadValue(kTexState1 + ivec2(1, 0));\n    vec4 tempRotQueue = LoadValue(kTexState1 + ivec2(2, 0));\n    rotQueueA = tempRotQueue.xy;\n    rotQueueB = tempRotQueue.zw;\n    vec4 state2 = LoadValue(kTexState1 + ivec2(3, 0));\n    bitsCollected = state2.x;\n    framerate = state2.y;\n    gameStage = state2.z;\n    message = state2.w;\n    camFollowPos = LoadValue(kTexState1 + ivec2(4, 0));\n    indicatorPulse = LoadValue(kTexState1 + ivec2(5, 0));\n    vec4 state3 = LoadValue(kTexState1 + ivec2(6, 0));\n    bikeBPos = state3.xyz;\n    bikeBAngle = state3.w;\n    animA = LoadValue(kTexState1 + ivec2(7, 0));\n}\n\nvoid StoreState(inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 state1 = vec4(bikeAPos, bikeAAngle);\n    StoreValue(kTexState1, state1, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(1, 0), keyStateLURD, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(2, 0), vec4(rotQueueA.xy, rotQueueB), fragColor, fragCoord);\n    vec4 state2 = vec4(bitsCollected, framerate, gameStage, message);\n    StoreValue(kTexState1 + ivec2(3, 0), state2, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(4, 0), camFollowPos, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(5, 0), indicatorPulse, fragColor, fragCoord);\n    vec4 state3 = vec4(bikeBPos, bikeBAngle);\n    StoreValue(kTexState1 + ivec2(6, 0), state3, fragColor, fragCoord);\n    StoreValue(kTexState1 + ivec2(7, 0), animA, fragColor, fragCoord);\n}\n// -------------------- End of shared state / variables --------------------\n\n// Font rendering macros\n#define _SPACE if (uv == cursorPos) letter = 32.0; cursorPos.x++;\n#define _EXCLAMATION if (uv == cursorPos) letter = 33.0; cursorPos.x++;\n#define _SLASH if (uv == cursorPos) letter = 47.0; cursorPos.x++;\n#define _A if (uv == cursorPos) letter = 65.0; cursorPos.x++;\n#define _B if (uv == cursorPos) letter = 66.0; cursorPos.x++;\n#define _C if (uv == cursorPos) letter = 67.0; cursorPos.x++;\n#define _D if (uv == cursorPos) letter = 68.0; cursorPos.x++;\n#define _E if (uv == cursorPos) letter = 69.0; cursorPos.x++;\n#define _F if (uv == cursorPos) letter = 70.0; cursorPos.x++;\n#define _G if (uv == cursorPos) letter = 71.0; cursorPos.x++;\n#define _H if (uv == cursorPos) letter = 72.0; cursorPos.x++;\n#define _I if (uv == cursorPos) letter = 73.0; cursorPos.x++;\n#define _J if (uv == cursorPos) letter = 74.0; cursorPos.x++;\n#define _K if (uv == cursorPos) letter = 75.0; cursorPos.x++;\n#define _L if (uv == cursorPos) letter = 76.0; cursorPos.x++;\n#define _M if (uv == cursorPos) letter = 77.0; cursorPos.x++;\n#define _N if (uv == cursorPos) letter = 78.0; cursorPos.x++;\n#define _O if (uv == cursorPos) letter = 79.0; cursorPos.x++;\n#define _P if (uv == cursorPos) letter = 80.0; cursorPos.x++;\n#define _Q if (uv == cursorPos) letter = 81.0; cursorPos.x++;\n#define _R if (uv == cursorPos) letter = 82.0; cursorPos.x++;\n#define _S if (uv == cursorPos) letter = 83.0; cursorPos.x++;\n#define _T if (uv == cursorPos) letter = 84.0; cursorPos.x++;\n#define _U if (uv == cursorPos) letter = 85.0; cursorPos.x++;\n#define _V if (uv == cursorPos) letter = 86.0; cursorPos.x++;\n#define _W if (uv == cursorPos) letter = 87.0; cursorPos.x++;\n#define _X if (uv == cursorPos) letter = 88.0; cursorPos.x++;\n#define _Y if (uv == cursorPos) letter = 89.0; cursorPos.x++;\n#define _Z if (uv == cursorPos) letter = 90.0; cursorPos.x++;\n#define _0 if (uv == cursorPos) letter = 48.0; cursorPos.x++;\n#define _1 if (uv == cursorPos) letter = 49.0; cursorPos.x++;\n#define _2 if (uv == cursorPos) letter = 50.0; cursorPos.x++;\n#define _3 if (uv == cursorPos) letter = 51.0; cursorPos.x++;\n#define _4 if (uv == cursorPos) letter = 52.0; cursorPos.x++;\n#define _5 if (uv == cursorPos) letter = 53.0; cursorPos.x++;\n#define _6 if (uv == cursorPos) letter = 54.0; cursorPos.x++;\n#define _7 if (uv == cursorPos) letter = 55.0; cursorPos.x++;\n#define _8 if (uv == cursorPos) letter = 56.0; cursorPos.x++;\n#define _9 if (uv == cursorPos) letter = 57.0; cursorPos.x++;\n\nvoid ResetAll(vec2 fragCoord, inout vec4 finalOut)\n{\n    bikeAPos = vec3(0.5, 1.0, 0.5);\n    bikeAAngle = 0.0;\n    bikeBPos = vec3(0.5, 1.0, 2.5);\n    bikeBAngle = 0.0;\n    bitsCollected = 0.0;\n\tcamFollowPos = vec4(sin(iTime*0.5)*6.0, 2.5, cos(iTime*0.5)*6.0, 0.0);\n    gameStage = -1.0;\n    message = 81.0;\n    animA = vec4(256.0, 0, 0, 0);\n    indicatorPulse = vec4(0, -256.0, 0, 0);\n\n    float tex = texelFetch(iChannel2, ivec2(fragCoord.xy), 0).x;\n    finalOut = vec4(0);\n    float inGameGrid = max(abs(fragCoord.x - gameGridCenter.x), abs(fragCoord.y - gameGridCenter.y));\n    if (inGameGrid < gameGridRadius) {\n        finalOut = vec4(0.0);\n        // Border around gamegrid\n        if (inGameGrid >= gameGridRadius - 1.0) finalOut.x = 2.0;\n    } else {\n        finalOut.x = tex*20.0-8.0;\n        finalOut.x = max(-1.0, finalOut.x);\n\n        // Make maze\n\t  \tvec2 uv = fragCoord.xy;///iResolution.xy;\n        uv = uv / 12.0;\n        vec2 uvf = fract(uv);\n        float rnd = texelFetch(iChannel3, ivec2(uv), 0).x;\n        float hv = ((rnd>.5)?uvf.x:uvf.y);\n        //finalOut.yz = uvf*0.0001;//smoothstep(.5,.6, hv)*80.0);\n        finalOut.x *= smoothstep(.5,.55, hv);// + uvf.x*uvf.y;\n\t\t//finalOut.x = (hv/256.0);\n\n        // I/O tower base\n        float tower = distance(fragCoord - gameGridCenter, iotower);\n        if (tower <= 17.5) {\n            finalOut.xy = vec2(max(0.0, 9.5 - round(tower)), 0.0);\n            if (fragCoord.y - gameGridCenter.y == iotower.y) finalOut.xy = vec2(0.0, 0.0);\n        }\n\n        // Place power-ups\n        if (distance(fragCoord, vec2(80.0+20.5, 50.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0-40.5, 50.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0-28.5, 125.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0+42.5, 122.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0+67.5, 27.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0+55.5, 75.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0+78.5, 86.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0+42.5, 82.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0+96.5, 122.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0+128.5, 63.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0-4.5, 57.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0-4.5, 102.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n        if (distance(fragCoord, vec2(80.0+54.5, 52.5)) <= 0.5) finalOut.xy = vec2(1.0, 256.0);\n\n        if (inGameGrid <= gameGridRadius + 5.0) finalOut.x = 0.0;\n        finalOut.xy = floor(finalOut.xy);\n    }\n}\n\nfloat TextRenderer(inout vec4 fragColor, in vec2 fragCoord) {\n    // Font printing and HUD\n    float letter = 32.0;\n    ivec2 uv = ivec2(fragCoord);\n    if ((bitsCollected > 0.0) && (uv == ivec2(0, 0))) letter = 48.0 + bitsCollected;\n\n    // Frame rate printouts\n    //if (uv == ivec2(0, 1)) letter = 48.0 + floor(framerate);\n    //if (uv == ivec2(1, 1)) letter = 48.0 + mod(floor(framerate*10.0),10.0);\n    //if (uv == ivec2(2, 1)) letter = 48.0 + mod(floor(framerate*100.0),10.0);\n\n    ivec2 cursorPos = ivec2(1, 2);\n    if ((message >= 10.0) && (message <= 18.0)) {\n        cursorPos = ivec2(3, 1);\n        _E _S _C _A _P _E _SPACE _T _H _E;\n        cursorPos = ivec2(4, 2);\n        _G _A _M _E _G _R _I _D;\n    }\n    if ((message >= 20.0) && (message <= 28.0)) {\n        cursorPos = ivec2(6, 1);\n        _D _E _A _D;\n    }\n    if ((message >= 30.0) && (message <= 38.0)) {\n        cursorPos = ivec2(5, 1);\n        _E _S _C _A _P _E _EXCLAMATION;\n    }\n    /*if ((message >= 40.0) && (message <= 48.0)) {\n        cursorPos = ivec2(1, 1);\n        _B _U _F _F _E _R _SPACE _O _V _E _R _R _U _N;\n        cursorPos = ivec2(0, 2);\n        _P _R _O _G _R _A _M _S _SPACE _E _S _C _A _P _E _D;\n    }*/\n    if ((message >= 50.0) && (message <= 58.0)) {\n        cursorPos = ivec2(5, 1);\n        _G _O _SPACE _T _O;\n        cursorPos = ivec2(3, 2);\n        _I _SLASH _O _SPACE _T _O _W _E _R;\n    }\n    if ((message >= 60.0) && (message <= 68.0)) {\n        cursorPos = ivec2(4, 1);\n        _T _R _A _N _S _M _I _T;\n    }\n    if ((message >= 70.0) && (message <= 78.0)) {\n        cursorPos = ivec2(1, 1);\n        _C _O _L _L _E _C _T _SPACE _8 _SPACE _B _I _T _S;\n    }\n    if ((message >= 80.0) && (message <= 88.0)) {\n        cursorPos = ivec2(1, 6);\n        _C _L _I _C _K _SPACE _O _R _SPACE _S _P _A _C _E;\n        cursorPos = ivec2(5, 7);\n        _S _T _A _R _T _S;\n    }\n    if ((message >= 90.0) && (message <= 98.0)) {\n        cursorPos = ivec2(2, 1);\n        _Y _O _U _SPACE _D _I _D _SPACE _N _O _T;\n        cursorPos = ivec2(5, 2);\n        _E _S _C _A _P _E;\n        cursorPos = ivec2(3, 3);\n        _T _R _Y _SPACE _A _G _A _I _N;\n    }\n    if ((message >= 100.0) && (message <= 108.0)) {\n        cursorPos = ivec2(3, 1);\n        _E _S _C _A _P _E _SPACE _T _H _E;\n        cursorPos = ivec2(4, 2);\n        _G _A _M _E _G _R _I _D;\n        cursorPos = ivec2(7, 5);\n        _B _Y;\n        cursorPos = ivec2(3, 6);\n        _O _T _A _V _I _O _SPACE _G _O _O _D;\n    }\n\n    return letter;\n}\n\n// Print a single floating point number to the screen\nvoid PrintNum(inout float letter, in vec2 fragCoord, float num, ivec2 pos) {\n    ivec2 uv = ivec2(fragCoord);\n\n    // Print 4 whole number digits, a decimal point, and 2 fractional digits.\n    if (uv == ivec2(pos.x + 0, pos.y)) {\n        letter = 48.0 + floor(mod(num/1000.0, 10.0));\n        if (num < 0.0) letter = 45.0;\n    }\n    num = abs(num);\n    if (uv == ivec2(pos.x + 1, pos.y)) letter = 48.0 + floor(mod(num/100.0, 10.0));\n    else if (uv == ivec2(pos.x + 2, pos.y)) letter = 48.0 + floor(mod(num/10.0, 10.0));\n    else if (uv == ivec2(pos.x + 3, pos.y)) letter = 48.0 + floor(mod(num, 10.0));\n    else if (uv == ivec2(pos.x + 4, pos.y)) letter = 46.0;\n    else if (uv == ivec2(pos.x + 5, pos.y)) letter = 48.0 + mod(floor(num*10.0),10.0);\n    else if (uv == ivec2(pos.x + 6, pos.y)) letter = 48.0 + mod(floor(num*100.0),10.0);\n}\n\nvoid MoveBikeA(inout vec4 finalOut, in vec2 fragCoord) {\n    if ((gameStage >= 100.0) && (gameStage < 104.0)) {\n        return;\n    }\n    vec4 keyOrigLURD = keyStateLURD;\n    keyStateLURD = vec4(SampleKey(kKeyLeft), SampleKey(kKeyUp),\n                        SampleKey(kKeyRight), SampleKey(kKeyDown));\n\n    // Handle mouse clicks for left / right - for mobile phone controls.\n    float lastMouseX = animA.w;\n    if ((lastMouseX < 0.0) && (iMouse.z > 0.0)) {\n        if (abs(iMouse.z) < iResolution.x / 2.0) keyStateLURD.x = 1.0;\n        if (abs(iMouse.z) >= iResolution.x / 2.0) keyStateLURD.z = 1.0;\n    }\n    animA.w = iMouse.z;\n\n    if ((keyStateLURD.x > 0.5) && (keyStateLURD.x != keyOrigLURD.x)) {\n        if (rotQueueA.x == 0.0) rotQueueA.x = -1.0;\n        else rotQueueA.y = -1.0;\n    }\n    if ((keyStateLURD.z > 0.5) && (keyStateLURD.z != keyOrigLURD.z)) {\n        if (rotQueueA.x == 0.0) rotQueueA.x = 1.0;\n        else rotQueueA.y = 1.0;\n    }\n\n    // Move the bike\n    vec3 oldPos = bikeAPos;\n    vec3 dir = round(vec3(cos(bikeAAngle), 0.0, -sin(bikeAAngle)));\n    float cycleASpeed = min(1.0, localTimeDelta*4.0);//4\n    bikeAPos += dir * cycleASpeed;\n    if (floor(bikeAPos+0.5) != floor(oldPos+0.5)) {\n        if (rotQueueA != vec2(0.0)) {\n            // Turn the bike exactly at the grid crossing\n            vec3 newPos = floor(bikeAPos)+vec3(0.5, 0.0, 0.5);\n            float remainder = length(bikeAPos - newPos);\n            bikeAPos = newPos;\n            bikeAAngle += rotQueueA.x * 3.141592653*0.5;\n            // Cycle the input queue\n            rotQueueA.x = 0.0;\n            rotQueueA = rotQueueA.yx;\n            // Add the remaining movement vector, but in the new direction\n            dir = round(vec3(cos(bikeAAngle), 0.0, -sin(bikeAAngle)));\n            bikeAPos += dir * remainder;\n        }\n\n        // This must happen after the turn, or we will crash into walls we turned away from\n        ivec2 tpos = ivec2(floor(bikeAPos.xz+0.5*dir.xz)+gameGridCenter);\n        vec4 tex = texelFetch(iChannel0, tpos, 0);\n        //temp = tex.x;\n        // If not a powerup\n        if (tex.y < 256.0) {\n            // Death by wall\n            if (floor(tex.x) >= floor(bikeAPos.y)) {\n                gameStage = 1000.0;\n                message = 28.0;\n            }\n            // Death by pit\n            if (floor(tex.x+1.0) < floor(bikeAPos.y)) {\n                gameStage = 1000.0;\n                message = 28.0;\n            }\n        }\n    }\n\n    ivec2 tpos = ivec2(bikeAPos.xz+gameGridCenter);\n    vec4 tex = texelFetch(iChannel0, tpos, 0);\n\n    float inGameGrid = max(abs(bikeAPos.x), abs(bikeAPos.z));\n    // If the bike is in the gamegrid and the pixel in in the gamegrid part of the buffer\n    if ((floor(bikeAPos.xz) == floor(fragCoord - gameGridCenter)) &&\n        (inGameGrid < gameGridRadius)) {\n        finalOut.x = round(bikeAPos.y);\n        int trail = int(tex.y);\n        if (abs(dir.x) > abs(dir.z)) {  // If driving down the x axis\n            if (fract(bikeAPos.x) < 0.5) trail |= 1;\n            else trail |= 2;\n        } else {\n            if (fract(bikeAPos.z) < 0.5) trail |= 4;\n            else trail |= 8;\n        }\n        finalOut.y = float(trail);\n    }\n    // pick up power ups\n    if (tex.y == 256.0) {\n        bitsCollected += 1.0;\n        if (ivec2(fragCoord) == tpos) {\n            finalOut.xy = vec2(0.0, 0.0);\n        }\n        indicatorPulse = vec4(bikeAPos, 1.0);\n        if (bitsCollected >= 8.0) {\n            gameStage = 300.0;\n            message = 55.0;\n        }\n    }\n    camFollowPos.xyz = mix(camFollowPos.xyz, bikeAPos - dir * 5.0 + vec3(0, 2.4, 0), 0.05*localTimeDelta*60.0);\n\n    if ((gameStage >= 100.0) && (gameStage < 200.0) && (inGameGrid > gameGridRadius)) {\n        gameStage = 200.0;\n        message = 75.0; // collect 8 bits\n    }\n    // If I/O tower is enabled and you touch it, win game.\n    if (distance(bikeAPos.xz, iotower) < 0.5) {\n        if ((gameStage >= 300.0) && (gameStage < 400.0)) {\n            gameStage = 500.0;\n            message = 63.0; // transmit\n        } else if (gameStage < 300.0) {\n            message = 75.0; // collect 8 bits\n        }\n    }\n}\n\nvoid MoveBikeB(inout vec4 finalOut, in vec2 fragCoord) {\n    float cycleBSpeed = min(1.0, localTimeDelta*4.0);\n    vec3 dir = round(vec3(cos(bikeBAngle), 0.0, -sin(bikeBAngle)));\n    vec2 perp = dir.zx * vec2(-1.0, 1.0);\n    float rand = fract(sin(iTime * 123.4567)* 123.4567) * 2.0 - 1.0;\n    vec2 randPerp = perp * sign(rand);\n    ivec2 tpos = ivec2(floor(bikeBPos.xz+(0.5+1.0)*dir.xz)+gameGridCenter);\n    vec4 tex = texelFetch(iChannel0, tpos, 0);\n    tpos = ivec2(floor(bikeBPos.xz+(0.5+1.0)*dir.xz + randPerp)+gameGridCenter);\n    vec4 texPerp = texelFetch(iChannel0, tpos, 0);\n    if (animA.x == 256.0) {\n        // Bike AI - super advanced, of course.\n        // Avoid walls\n        if (floor(tex.x) >= floor(bikeBPos.y)) {\n            if (floor(texPerp.x) >= floor(bikeBPos.y)) {\n                if (rotQueueB == vec2(0)) {\n                    if (sign(rand) < 0.0) rotQueueB.x = 1.0;\n                    else rotQueueB.x = -1.0;\n                }\n            }\n        }\n        // Randomly turn\n        if ((abs(rand) < 0.002) && (floor(texPerp.x) < floor(bikeBPos.y))) {\n            if (rotQueueB == vec2(0)) {\n                if (sign(rand) > 0.0) rotQueueB.x = 1.0;\n                else rotQueueB.x = -1.0;\n            }\n        }\n\n        // Move the bike\n        vec3 oldPos = bikeBPos;\n        bikeBPos += dir * cycleBSpeed;\n        if (floor(bikeBPos+0.5) != floor(oldPos+0.5)) {\n            if (rotQueueB != vec2(0.0)) {\n                // Turn the bike exactly at the grid crossing\n                vec3 newPos = floor(bikeBPos)+vec3(0.5, 0.0, 0.5);\n                float remainder = length(bikeBPos - newPos);\n                bikeBPos = newPos;\n                bikeBAngle += rotQueueB.x * 3.141592653*0.5;\n                // Cycle the input queue\n                rotQueueB.x = 0.0;\n                rotQueueB = rotQueueB.yx;\n                // Add the remaining movement vector, but in the new direction\n                dir = round(vec3(cos(bikeBAngle), 0.0, -sin(bikeBAngle)));\n                bikeBPos += dir * remainder;\n            }\n\n            if (animA.x == 256.0) {\n                // This must happen after the turn, or we will crash into walls we turned away from\n                tpos = ivec2(floor(bikeBPos.xz+0.5*dir.xz)+gameGridCenter);\n                tex = texelFetch(iChannel0, tpos, 0);\n                // If not a powerup\n                if (tex.y < 256.0) {\n                    // Bad guy death by wall\n                    if (floor(tex.x) >= floor(bikeBPos.y)) {\n                        animA.x = 1.0;\n                        indicatorPulse = vec4(bikeBPos, 3.0);\n                        if (tex.y == 0.0) {\n                            gameStage = 100.0;\n                            message = 36.0; // ESCAPE!\n                        } else {\n                            message = 98.0; // you did not escape. try again.\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // Death animation\n    if ((animA.x >= 0.0) && (animA.x <= 1.0)) {\n        animA.x -= localTimeDelta;\n        bikeBPos.y -= (1.0 - animA.x) * 0.25;\n        bikeBPos += dir * cycleBSpeed;\n    }\n\n    tpos = ivec2(bikeBPos.xz+gameGridCenter);\n    tex = texelFetch(iChannel0, tpos, 0);\n    float inGameGrid = max(abs(bikeBPos.x), abs(bikeBPos.z));\n\n    if (animA.x == 256.0) {\n        // If the bike is in the gamegrid and the pixel in in the gamegrid part of the buffer\n        if ((floor(bikeBPos.xz) == floor(fragCoord - gameGridCenter)) &&\n            (inGameGrid < gameGridRadius)) {\n            finalOut.x = round(bikeBPos.y);\n            int trail = int(tex.y);\n            if (abs(dir.x) > abs(dir.z)) {  // If driving down the x axis\n                if (fract(bikeBPos.x) < 0.5) trail |= 16 + 1;\n                else trail |= 16 + 2;\n            } else {\n                if (fract(bikeBPos.z) < 0.5) trail |= 16 + 4;\n                else trail |= 16 + 8;\n            }\n            finalOut.y = float(trail);\n        }\n        // pick up power ups\n        if (tex.y == 256.0) {\n            bitsCollected += 1.0;\n            if (ivec2(fragCoord) == tpos) {\n                finalOut.xy = vec2(0.0, 0.0);\n            }\n        }\n    } else {\n        // Erase blue trail completely after death anim\n        if (animA.x <= 0.0) {\n            if ((finalOut.y >= 16.0) && (finalOut.y < 32.0)) {\n                finalOut.xy = vec2(0, 0);\n            }\n        } else {\n            // Destroy the wall where the bad guy bike hit\n            if (gameStage >= 100.0) {\n                if (distance(floor(bikeBPos.xz + dir.xz), floor(fragCoord - gameGridCenter)) < 4.0) {\n                    finalOut.x = 0.0;//round(bikeBPos.y - 1.0);\n                }\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Early out in the hopes of doing less work for higher framerate.\n    if ((fragCoord.x > smallestResolution.x + 2.0) || (fragCoord.y > smallestResolution.y + 4.0)) {\n        discard;\n        return;\n    }\n    localTimeDelta = min(0.1, iTimeDelta);\n    float temp = 3.0;\n    fragColor = vec4(0.0);\n    LoadState();\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tvec4 old = texture(iChannel0, uv, -100.0);\n    vec4 finalOut = old;\n    bool gameDidntStart = ((iMouse.z <= 0.0) && (SampleKey(kKeySpace) <= 0.0)) && (gameStage < 0.0);\n    if ((iTime <= 1.0) || (iFrame < 4) || (gameStage >= 1004.0) || gameDidntStart || (iResolution.y < 280.0)) ResetAll(fragCoord, finalOut);\n    else if (gameStage < 600.0) {\n        if (gameStage <= 0.0) {\n            // start game\n            gameStage = 0.0;\n            message = 13.0;\n        }\n\t\tMoveBikeA(finalOut, fragCoord);\n\t\tMoveBikeB(finalOut, fragCoord);\n    }\n\n    // Death animation\n    if ((gameStage >= 1000.0) && (gameStage <= 1004.0)) {\n        float alpha = saturate(gameStage-1000.0);\n        bikeAPos.y -= alpha * 0.25;\n\t    vec3 dir = round(vec3(cos(bikeAAngle), 0.0, -sin(bikeAAngle)));\n\t    float cycleASpeed = min(1.0, localTimeDelta*4.0);//4\n        bikeAPos += dir * cycleASpeed * (1.0-alpha);\n    }\n\n    if ((gameStage >= 503.0) && (gameStage < 600.0)) {\n        gameStage = 600.0; // real world\n    }\n    if ((gameStage >= 608.0) && (gameStage < 700.0)) message = 108.0;\n\n    framerate = mix(framerate, iTimeDelta * 60.0, 0.01);\n    message -= localTimeDelta;\n    if (mod(message, 10.0) > 8.0) message = 0.0;\n    indicatorPulse.w = max(0.0, indicatorPulse.w - 0.015625);\n\n    // Increment gameStage var for animation. Count from start to start + 90.\n    if (mod(gameStage, 100.0) < 90.0) gameStage += localTimeDelta;\n\n\n\tfinalOut.w = TextRenderer(fragColor, fragCoord);\n    //PrintNum(finalOut.w, fragCoord, SampleKey(kKeySpace), ivec2(0, 0));\n    //PrintNum(finalOut.w, fragCoord, gameStage, ivec2(0, 0));\n    //PrintNum(finalOut.w, fragCoord, iMouse.z, ivec2(0, 5));\n    //PrintNum(finalOut.w, fragCoord, bikeAPos.y, ivec2(9, 7));\n\n    StoreState(fragColor, fragCoord);\n    // Thumbnail is 288x162 res - actually 256x144 is smallest. :(\n    // 500x281 is smallest editor view framebuffer size.\n    if ((fragCoord.x < 256.0) && (fragCoord.y < 160.0)) fragColor = finalOut;\n    //fragColor = vec4(k1 * 1000.0, sign(uv.x - kKeyLeft),1.0,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}