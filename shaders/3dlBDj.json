{
    "Shader": {
        "info": {
            "date": "1589104671",
            "description": "Wanted to toy around with quadtree uvs and made a neat little visualisation.\n\nHash functions from David Hoskins https://www.shadertoy.com/view/4djSRW",
            "flags": 0,
            "hasliked": 0,
            "id": "3dlBDj",
            "likes": 25,
            "name": "Box of Madness",
            "published": 3,
            "tags": [
                "2d",
                "crt",
                "tiling",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "Zauwara",
            "viewed": 672
        },
        "renderpass": [
            {
                "code": "float shiftStr = 1.5;\nfloat timeScale = 0.8;\n\nfloat noiseScale = 1.0;\n\nfloat scanLineWidth = 5.0;\nfloat scanLineSpeed = 20.0;\nfloat scanLineIntensity = 0.05;\n\nvec2 quadTreeUV(vec2 uv, float depth, float hash) {\n    \n    vec2 ret = uv;\n    \n    for(float i = 1.0; i < depth; i++) {\n        \n        ret = mod(ret, vec2(0.5)) * 2.0;\n        \n        float x = pow(2.0, i);\n        \n        if (hash12(floor(uv * x) * 1000.0) > 0.6) {\n            \n            return ret;\n        }\n    }\n    \n    return ret;\n}\n\nfloat fill(vec2 fragCoord) {\n    float sideLength = min(iResolution.x,iResolution.y) * 0.9;\n    vec2 sqMin = (iResolution.xy - vec2(sideLength)) / 2.0;\n    vec2 sqMax = (iResolution.xy + vec2(sideLength)) / 2.0;\n    \n    if(any(lessThan(fragCoord,sqMin)) || any(greaterThan(fragCoord, sqMax))) {\n        return 1.0;\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - sqMin) / vec2(sideLength);\n    \n    float t = 1.0 - mod(iTime * timeScale, 1.0);\n\t\n    vec2 qTuv = quadTreeUV(uv, 6.0, 0.0);\n    \n    float distS = max(abs(qTuv.x - 0.5), abs(qTuv.y - 0.5)) * 2.0; \t\t// for squares\n    //float distC = length(qTuv - 0.5) * 2.0;\t\t\t\t\t\t\t// for circles\n    //float distD = (abs(qTuv.x - 0.5) + abs(qTuv.y - 0.5)) * 2.0;\t\t// for diamonds\n    //float distO = max(distS, distD / 1.5);\t\t\t\t\t\t\t// for octagons\n    \n    \n    float o = pow(distS, 5.0);\n    float i = pow(distS, 2.0);\n    \n    float outer = 1.0 - step(o, 0.8) * (1.0 - step(o, 0.1));\n    float inner = step(i, t * 0.6 - 0.1) * (1.0 - step(i, t * 0.6 - 0.2));\n    \n    return outer - inner;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fC )\n{\n    // compute base img colorshifted\n    fragColor = vec4(\n        fill(fC + vec2(-shiftStr, -shiftStr)),\n        fill(fC + vec2( 0.0,  shiftStr)),\n        fill(fC + vec2( shiftStr, -shiftStr)),\n        1.0\n    );\n    \n    // add noise\n    fragColor += vec4((vec3(hash12(floor(fC / noiseScale) + iTime)) - 0.5) * 0.4, 1.0);\n    \n    // scanlines\n    fragColor *= floor(mod(fC.y + iTime * scanLineSpeed, scanLineWidth * 2.0) / scanLineWidth) * scanLineIntensity + (1.0 - scanLineIntensity);\n    \n    // vignette\n    float cd = pow(length(abs(fC / iResolution.xy - vec2(0.5, 0.5)) * 1.25), 3.0);\n    fragColor -= vec4(vec3(cd), 0.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}