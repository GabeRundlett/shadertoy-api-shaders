{
    "Shader": {
        "info": {
            "date": "1480692165",
            "description": "Headphones are highly recommended.",
            "flags": 97,
            "hasliked": 0,
            "id": "4ltXzj",
            "likes": 3,
            "name": "Musical Tunnel",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "raycast",
                "music",
                "audio",
                "function",
                "soundcloud"
            ],
            "usePreview": 0,
            "username": "hopskotchrainbow",
            "viewed": 1056
        },
        "renderpass": [
            {
                "code": "/*\n\tRAYMARCHING SOUNDCLOUD SHADER\n\t    ########    \n\t  ##        ##  \n\t##            ##\n\t#\t\t\t   #\n\t#\t\t\t   #\n\t# # # # # # # ##\n\t## # # # # # # #\n\t#  _\t\t_  #\n\t#_/.\\______/.\\_#\n\t# \\_/      \\_/ #\n\t#\t\t\t   #\n\t#\t\t\t   #\n\t# \\\t\t\t / #\n\t#  \\________/  #\n\t#\t\t\t   #\n\t #\t\t\t  #\n\t  ############\n\n\tLayers\n\t===========================================\n\n\tBuffer A-- SoundCloud Music Visualizer\n\t\tChannel0-- The Audio Content Sampler2D\n\t\tof the song to play\n*/\n\n// Pi = 3.14152865\n#define pi 3.14152865\n\n// DEFINES\n\n// defines the epsilion (the least that the tracer will stop at)\n// can not be zero or less; otherwise this results in raytrace issues\n#define eps 0.005\n\n// defines the tunnel speed (z scale) of the music visualizer.\n// A speed of 10 means that the tunnel looks like it's going 1\" per second.\n#define speed 30.0\n\n// defines the maximum number of iterations for raytracing\n// WARNING: the larger the number, the slower the shader will run\n// and the more memory it will use. It is recommanded you set it to\n// 64 or less. If you have a fast computer or high-end graphics\n// card, then you may set it to 96.\n#define maxIterations 80\n\n// Project the 3D space into a 2D output image\nvec2 tex( vec3 point ){\n    float nz = atan(point.x, point.y);\n    nz = nz/(pi*4.0)+1.25;\n    vec2 hoz = vec2(fract(nz), fract(-(point.z/speed)));\n    return hoz;\n}\n\n// Music visualizer (r and g are left / right sound base, b and a are waveform treble / bass)\nvec4 visualizer(vec3 point) {\n    vec2 hoz = tex( point );\n    vec4 t = textureLod(iChannel0, hoz, 0.0);\n    return t;\n}\n\nfloat scene(vec3 point) {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float depth = 0.5;\n    if (iMouse.z >= 0.0) {\n        depth = 0.1+m.y*0.9;\n    }\n    float nd = length(point.xy);\n    nd = 1.2-nd*1.2;\n    vec2 hoz = tex( point );\n    vec4 t = visualizer(point);\n    nd -= t.r*depth;\n    return nd;\n}\n\nvec3 CalcNormal(vec3 point) {\n    return normalize(vec3(\n        scene(point+vec3(eps,0.0,0.0))-scene(point-vec3(eps,0.0,0.0)),\n        scene(point+vec3(0.0,eps,0.0))-scene(point-vec3(0.0,eps,0.0)),\n        scene(point+vec3(0.0,0.0,eps))-scene(point-vec3(0.0,0.0,eps))\n    ));\n}\n\n\nvoid raycast(vec3 origin, vec3 direction, out vec3 iNormal, out vec3 iCoordinate, out float iDepth, out bool iHit, out float iCDepth) {\n    vec3 d = normalize(direction);\n    // The reason is that the direction is a unit vector; it may not be the same\n    // as the direction specified.\n    float depth = 0.0;\n    // Now we need to initialize the results.\n    iNormal = vec3(0.0,0.0,-1.0);\n    iDepth=0.0;\n    iHit=false;\n    iCoordinate = origin;\n    iCDepth=0.0;\n    for (int i=0;i<maxIterations;++i) {\n        vec3 coord = origin+d*depth;\t// Calculate the absolute coordinates\n        float s = scene(coord);\n        vec3 n = CalcNormal(coord);\n        iCDepth=float(i)/float(maxIterations);\n        if (s <= eps) {\n            iCoordinate=coord;\n            iHit=true;\n            iDepth=depth;\n            iNormal=n;\n            return;\n        }\n        depth += s;\n    }\n    iCDepth=1.0;\n}\n\nfloat diffuse(vec3 iNormal, vec3 iCoordinate, vec3 iLight) {\n    vec3 fNormal = normalize(iNormal);\n    vec3 fLight = normalize(iLight-iCoordinate);\n    return dot(fLight,fNormal)*0.8+0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy-iResolution.xy/2.;\n    pos /= max(iResolution.x,iResolution.y);\n    vec3 hpoint = vec3(pos, 1.0);\n    vec3 iNormal;\n    vec3 iCoordinate;\n    float iDepth;\n    float iCDepth;\n    bool iHit;\n    raycast(vec3(0.0,0.0,0.0),hpoint,iNormal,iCoordinate,iDepth,iHit,iCDepth);\n    vec3 color = vec3(0.0,0.0,0.0);\n    vec3 iLight = vec3(0.6,0.3,1.5);\n    if (iHit) {\n        float brightness = diffuse(iNormal,iCoordinate,iLight);\n        vec4 vx = visualizer(iCoordinate);\n        color = vx.gba*brightness;\n        color=mix(color,vec3(0.0),iCDepth);\n    }\n    vec2 m = iMouse.xy/iResolution.xy;\n    float blend = 0.0;\n    if (iMouse.z >= 0.0) {\n        blend = m.x;\n    }\n    vec4 texf = textureLod(iChannel0, fragCoord.xy/iResolution.xy, 0.0);\n    blend *= texf.a;\n    color = mix(color, texf.rgb, blend);\n    if (fragCoord.y >= 8.0 && fragCoord.y <= 24.0) color = vec3(0.7,0.89,0.9);\n\tfragColor = vec4(color,1.0);\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tvec3 hpoint = normalize(fragRayDir);\n    vec3 iNormal;\n    vec3 iCoordinate;\n    float iDepth;\n    float iCDepth;\n    bool iHit;\n    raycast(vec3(0.0,0.0,0.0),hpoint,iNormal,iCoordinate,iDepth,iHit,iCDepth);\n    vec3 color = vec3(0.0,0.0,0.0);\n    vec3 iLight = vec3(0.6,0.3,1.5);\n    if (iHit) {\n        float brightness = diffuse(iNormal,iCoordinate,iLight);\n        vec4 vx = visualizer(iCoordinate);\n        color = vx.gba*brightness;\n        color=mix(color,vec3(0.0),iCDepth);\n    }\n    vec2 m = iMouse.xy/iResolution.xy;\n    float blend = 0.0;\n    if (iMouse.z >= 0.0) {\n        blend = m.x;\n    }\n    vec4 texf = textureLod(iChannel0, fragCoord.xy/iResolution.xy,0.0);\n    blend *= texf.a;\n    color = mix(color, texf.rgb, blend);\n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tRAYMARCHING SOUNDCLOUD SHADER\n\t    ########    \n\t  ##        ##  \n\t##            ##\n\t#\t\t\t   #\n\t#\t\t\t   #\n\t# # # # # # # ##\n\t## # # # # # # #\n\t#  _\t\t_  #\n\t#_/.\\______/.\\_#\n\t# \\_/      \\_/ #\n\t#\t\t\t   #\n\t#\t\t\t   #\n\t# \\\t\t\t / #\n\t#  \\________/  #\n\t#\t\t\t   #\n\t #\t\t\t  #\n\t  ############\n\n\tLayers\n\t===========================================\n\n\tBuffer A-- SoundCloud Music Visualizer\n\t\tChannel0-- The Audio Content Sampler2D\n\t\tof the song to play\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float mix1 = texture(iChannel0, vec2(uv.x, 0.0)).r;\n    float mix2 = texture(iChannel0, vec2(uv.x, 0.25)).r;\n    float mix3 = texture(iChannel0, vec2(uv.x, 0.5)).r;\n    float mix4 = texture(iChannel0, vec2(uv.x, 0.75)).r;\n    vec2 pixsize = 1.0/iResolution.xy;\n    vec2 shift = uv-vec2(0.0,pixsize);\n    fragColor = vec4(mix1,mix2,mix3,mix4);\n    if (fragCoord.y >= 1.0) {\n        fragColor = textureLod(iChannel1, shift,0.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 5755,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/f-777/space-battle-ludicrous-speed-album"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}