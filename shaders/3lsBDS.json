{
    "Shader": {
        "info": {
            "date": "1597622161",
            "description": "SchwarzChristoffel tiling\n\nbased on mla@[url]https://www.shadertoy.com/view/tsfyRj[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsBDS",
            "likes": 10,
            "name": "SchwarzChristoffel tiling",
            "published": 3,
            "tags": [
                "complex",
                "conformal",
                "tiling",
                "schwarzchristoffel"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 519
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"SchwarzChristoffel tiling\"\n//\n// created by Colling Patrik (cyperus) in 2020-08-16\n//\n// based on code from\n// - \"The Schwarz-Christoffel mapping:\" by Matthew Arcus in 2020\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// FEATURES:\n// - inverse Mobius (use mouse)\n// - Schwarz-Christoffel\n// - square and hexagonal tiling with cyclic mirroring\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// const\nconst float PI = 3.14159265359,\n    PI_2 = PI/2., PI_3 = PI/3., PI_4 = PI/4., PI_6 = PI/6.,\n    SQRT2 = sqrt(2.), SQRT_2 = 1./SQRT2,  \n    SQRT3 = sqrt(3.), SQRT_3 = 1./SQRT3;\n\n// 1D\nfloat csteps(float x,float b) {\n    //centered step, step width b\n    return b*floor((x/b+0.5));\n}\n\nfloat signeveodd(float x) {\n    return sign(mod(x-0.5,2.)-1.);\n}\n\nfloat smoothpuls(float x,float b) {\n    return smoothstep(abs(b),0.,abs(x));\n}\n\n// complex\nvec2 cmul(vec2 z, vec2 w) {\n\treturn vec2(z.x*w.x-z.y*w.y,\n                z.x*w.y+z.y*w.x);\n}\nvec2 cinv(vec2 z) {\n\treturn z*vec2(1,-1)/dot(z,z);\n}\nvec2 cdiv(vec2 z, vec2 w) {\n\treturn cmul(z,cinv(w));\n}\nvec2 cpow(vec2 z, int n) {\n\tfloat r = length(z);\n\tfloat theta = atan(z.y,z.x);\n\treturn pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\nvec2 crot(vec2 z,float a) {\n\tfloat si = sin(a), co = cos(a);\n\treturn mat2(co,-si,si,co)*z;\n}\n\n// grid's\nvec2 recgrid2rec(in vec2 Z, out vec2 Z_id, out float  z_sr) {  \n    // maps a grid of unit-squares to one unit-square\n    // The unit-square is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = crot(Z,PI_4);\t\t// F:orientation-offset of cell\n    Z/= SQRT_2;\t\t\t\t// F:scale cell\n    Z_id = 2.*floor(Z*.5+0.5);\t// global cell offset id (...,-4,-2,0,+2,+4,...)\n    vec2 Z_lo = Z-Z_id;\t\t\t// local cell coord's\n    Z = Z_lo;\t\t\t\t// mape grid-cell to unit-cell\n    z_sr = signeveodd(0.5*(Z_id.x+Z_id.y));// sense of rotation of local cell    \n    Z_id = vec2(signeveodd(Z_id.x*0.5),signeveodd(Z_id.y*0.5));//(...,-2,-1,0,+1,+2,...)\n    Z.x *= Z_id.x;//mirror x\n    Z.y *= Z_id.y;//mirror y\n    Z *= SQRT_2;\t\t\t// B:scale cell\n    return crot(Z,-PI_4);\t// B:orientation-offset of cell\n}\n\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id) {        \n    // maps a grid of unit-hexagons to one unit-hexagon\n    // with edge orientation pointing in x plus direction\n    // using cubic coordinates\n    // The unit-hexagon is inside of the unit-circle    \n    // ==> https://www.redblobgames.com/grids/hexagons/\n\t// ==> https://bl.ocks.org/patricksurry/0603b407fa0a0071b59366219c67abca\n\tconst mat2 M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI_6);\t\t// F:orientation-offset of cell     \n    Z = iM*Z/0.75;          // F:scale cell\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);// plane: x+y+z=0\n    U_id = 2.*floor(U*0.5+0.5);\t\t// global cell offset id \n    vec3 U_lo = U-U_id;\t\t\t\t// local cell coord's\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) U_lo.x = -U_lo.y-U_lo.z;\n    if (aU_lo.y > aU_lo.z) U_lo.y = -U_lo.x-U_lo.z;\n    else U_lo.z = -U_lo.x-U_lo.y;\n    Z = U_lo.rb; \t\t\t// mape grid-zell to unit-zell\n    Z = M*Z*0.75; \t\t\t// B:scale of cell\n    return crot(Z,-PI_6);\t// B:orientation-offset of cell  \n}\n\nvec2 hex2tri(in vec2 Z, out float a_id, out float a_cy) {\n    // maps 6 triangles inside a unit-hexagon to one unit-triangle\n    // The unit-hexagon is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = crot(Z,-PI_6); \t\t// orientation adaption  tri2hex ==> hexgrid2hex \n    Z = crot(Z,PI_3);\t\t// F:orientation-offset of simplex  \n    float a = atan(Z.y,Z.x);   \n    a_id = floor(a/PI_3+0.5);// triangle offset id ((-3),-2,-1,0,1,2,(3))\n    float a_lo = a-PI_3*a_id;\t\t\t// local coord's angle\n    a_cy = signeveodd(a/PI_3);\t\t\t// cycle even +1, odd -1\n    Z = crot(Z,PI_3*a_id);\t\t\t\t// mape grid-zell to unit-triangle\n    Z = (Z-vec2(SQRT_3,0.))*SQRT3; \t\t// translation,scale unit-triangle\n    Z.y *= a_cy;\t\t\t\t\t\t// y-mirror cyclic\n    return crot(Z,-PI_3);\t\t\t\t// B:orientation-offset of unit-triangle\n}\n\n//color\nvec3 h2rgb(float h) {\t\t// hue, saturation, value\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n    return rgb;\n}\n\n// inface: vec2 => bool\nbool inudisk(vec2 z){\n    // in unit disk\n\treturn (length(z)<1.);\n}\n\nbool inupoly(vec2 z,int k) {\n    const float PI = 3.14159265359;\n    // in unit polygon\n    k = abs(k);\t\t\t//poly-num-edges\n    bool m = true;\t\t//bit-mask    \n    if (k<3) {\n        m = false;\n    } else {   \n        float a = PI/float(k);\n        float h = cos(a);//\n        for (int i=0; i<k; i++) {\n            float a1 = 2.*a*float(i);\n            vec2 w = vec2(cos(a1),sin(a1));\n            if(dot(w,z)>h) m = false;\n        }\n    }\n    return m;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// This code is from Matthew Arcus, 2020. \"The Schwarz-Christoffel mapping:\"\n// https://www.shadertoy.com/view/tsfyRj\n////////////////////////////////////////////////////////////////////////////////\nfloat binomial(float a, int n) {\n    float s = 1.0;\n    for (int i = n; i >= 1; i--,a--) {\n        s *= float(a)/float(i);\n    }\n    return s;\n}\n\n// The Lanczos approximation, should only be good for z >= 0.5,\n// but we get the right answers anyway.\nfloat gamma(float z) {\n    const float[8] p = float[](\n        676.5203681218851,\n        -1259.1392167224028,\n        771.32342877765313,\n        -176.61502916214059,\n        12.507343278686905,\n        -0.13857109526572012,\n        9.9843695780195716e-6,\n        1.5056327351493116e-7\n    );\n    z -= 1.0;\n    float x = 0.99999999999980993; // Unnecessary precision\n    for (int i = 0; i < 8; i++) {\n        float pval = p[i];\n        x += pval/(z+float(i+1));\n    }\n    float t = z + 8.0 - 0.5;\n    return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// The Beta function\nfloat B(float a, float b) {\n    return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\n// Original Octave/Matlab code for main function:\n// w=z(inZ).*( 1-cn(1)*h+(-cn(2)+(K+1)*cn(1)^2)*h.^2+\n// (-cn(3)+(3*K+2)*(cn(1)*cn(2)-(K+1)/2*cn(1)^3))*h.^3+\n// (-cn(4)+(2*K+1)*(2*cn(1)*cn(3)+cn(2)^2-(4*K+3)*(cn(1)^2*cn(2)-(K+1)/3*cn(1)^4)))*h.^4+\n// (-cn(5)+(5*K+2)*(cn(1)*cn(4)+cn(2)*cn(3)+(5*K+3)*(-.5*cn(1)^2*cn(3)-.5*cn(1)*cn(2)^2+\n//   (5*K+4)*(cn(1)^3*cn(2)/6-(K+1)*cn(1)^5/24))))*h.^5./(1+h/C^K) );\n\nvec2 inversesc(vec2 z, int K) {\n    float cn[6];\n    for (int n = 1; n <= 5; n++) {\n        cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K); // Series Coefficients\n    }\n    float C = B(1.0/float(K),1.0-2.0/float(K))/float(K); // Scale factor\n    z *= C; // Scale polygon to have diameter 1\n    vec2 h = cpow(z,int(K));\n    float T1 = -cn[1];\n    float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n    float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n    float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n    float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n    vec2 X = vec2(1,0)+h/pow(C,float(K));\n    vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n    return w;\n}\n\nvec3 getcolor(vec2 z, int K) {\n    if (iMouse.x > 0.0) {\n        // Apply an inversion/Mobius transformation\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/min(iResolution.x,iResolution.y); \n        m /= dot(m,m); // m inverted in unit circle\n        z -= m;\n        z *= (dot(m,m)-1.0)/dot(z,z);\n        z += m;\n    }\n    // And a rotation (also a Mobius transformation)\n    z = crot(z,0.5*iTime);\n    float r = length(z);\n    float theta = atan(z.y,z.x);\n    vec3 col = h2rgb(theta/(2.0*PI));\n    // uv-lines\n    float A = 4.0;\n    float B = 2.0*float(K);\n    float a = -log(r)*A;\n    float ds = 0.07;\n    if (a <= 6.0+ds) {\n        a = fract(a);\n        float b = fract(theta/PI*B);\n        float d = min(min(a,1.0-a),min(b,1.0-b));\n        col *= mix(0.2,1.0,smoothstep(-ds,ds,d));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int K = (3+int(0.1*iTime)%2);\n    \n    vec2 z = 2.*(2.*fragCoord.xy - iResolution.xy)/min(iResolution.x,iResolution.y);\n\n    if (K==4) {\n    vec2 recgrid_id = vec2(0.); float recgrid_sr;\n    z = recgrid2rec(z, recgrid_id, recgrid_sr);\n    }\n \n    if (K==3) {\n      vec3 U_id = vec3(1.,1.,1.); float a_id = 1.; float a_cy = 0.;\n      z = hexgrid2hex(z, U_id);\n      z = hex2tri(z, a_id, a_cy);\n    }\n    \n    z = inversesc(z,K);\n\n    // color \n    vec3 col = getcolor(z,K);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(0.6*col,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}