{
    "Shader": {
        "info": {
            "date": "1657115965",
            "description": "Using a subdivided icosahedral grid partitioning to render a star weave pattern onto the surface of a sphere.",
            "flags": 32,
            "hasliked": 0,
            "id": "fs3BWH",
            "likes": 71,
            "name": "Spherical Icosahedral Star Weave",
            "published": 3,
            "tags": [
                "bezier",
                "sphere",
                "star",
                "icosahedron",
                "polar",
                "knot",
                "dodecahedron",
                "polyhedron"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 904
        },
        "renderpass": [
            {
                "code": "/*\n\n    Spherical Icosahedral Star Weave\n    --------------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    //\n    // See Buffer A for an explanation.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Spherical Icosahedral Star Weave\n    --------------------------------\n    \n    Placing an interwoven 3D polyhedral star pattern onto the surface of a\n    sphere. It's a broad description, since there doesn't appear to be a \n    general concensus on what to call these things. :)\n    \n    An interwoven 3D polyhedral star pattern is really cool to look at. \n    You may have seen it in static image form on the internet. I noticed\n    that it's a favorite amongst the 3D printed art crowd too. However, due \n    to realtime constraints and the long drawn out construction process \n    within 3D tools like Blender, they're not very common on Shadertoy.\n    \n    I remember putting in a request years ago after looking at one of Paul \n    Nylander's images, and Djinn Kahn put together an unlisted one which was \n    based on interlinked triangulated Beziers between an icosahedron and its \n    dual dodecahedron... \n    \n    Like I said, it's a drawn out process, and that is without subdivision.\n    Unfortunately, the really cool looking objects are based on subdivided \n    icosahedrons, which consist of irregular triangles, and that complicate\n    things further. The star weave usually involves multiple point Beziers,\n    which theoretically is as simple as inputting a larger number, but slows \n    things down even further.\n    \n    Therefore, I had to abandon my realtime 3D plans for the moment and \n    settle for a textured version. You may have noticed there's a bit of \n    code here, which may be a little off putting to someone who'd like to \n    make one of these. Just remember that a lot of it is prettying up, and \n    conceptually speaking, this is merely the rendering of a pattern onto a \n    curved triangle face.\n    \n    I'm going to produce a proper 3D version in static path traced form as a \n    compromise, and will upload that later. Without subdivision, a realtime \n    version is already possible, and with compromises a subdivided one would \n    be possible too, but I would like to produce a nice smooth looking one. \n    I have some ideas that I'll try out.\n    \n    As for for why the final design resembles a tacky Louis Vuitton knockoff, \n    I'm not sure how I arrived there, but I've visited a lot of tourist\n    markets in my time. :D\n   \n    \n\n\tOther examples:\n    \n    // Star objects are annoying to model at the best of times, not fun to \n    // code, and are even less fun to produce inside a pixel shader \n    // environment, so only one person has even bothered to try. Djinn Kahn \n    // has an awesome grasp of geometry, but unfortunately, not a lot of \n    // spare time, so he doesn't post often. The link is unlisted, due to the \n    // compile time being very long on some machines.\n    //\n    surface knot starting point - DjinnKahn \n    https://www.shadertoy.com/view/lly3DK\n\n*/\n\n#define ZERO min(0, iFrame)\n\n// Max ray distance.\n#define FAR 20.\n\n// Star weaves on the internet consist of five and six pronged stars over the \n// top of tri-pronged shapes, but sometimes the reverse pattern will appear.\n//#define REVERSE_PATTERN\n           \n// I've called it a scheme because I plan to expand on it, but for now\n// it's just a representation of the amount of subdisions, which is \n// one, two or none at all. The latter looks pretty boring, but allows\n// you to study the pattern and joins more closely.\n//\n// No subdivsions: 0, One subdivision: 1, Two subdivisions: 2.\n#define SCHEME 1\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\n\n\n/////////\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Back plane triangle pattern scale.\nconst float scale = 1./2.5;\n\n\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0)/scale;\n\n\nfloat gTri;\nvec4 getTriVerts(vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //float tri = p.x/rect.x < -p.y/rect.y? 1. : 0.;\n    // Base on the bottom (0.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 0. : 1.;\n   \n    p = unskewXY(p, sk);\n    \n    const vec2[4] vertID = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5));\n\n\n    if(gTri>.5){\n        vID = vec2[3](vertID[0], vertID[2], vertID[1]);\n    }\n    else {\n        vID = vec2[3](vertID[2], vertID[0], vertID[3]);\n    }\n    \n    //id -= (vID[0] + vID[1] + vID[2])/3.;\n    \n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect, sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n\n    // Centered at the zero point.\n    return vec4(p, id);\n}\n\n//////////\n/*\nfloat getTriVerts(vec2 p){\n\n    \n    // Rectangle grid vertices.\n    const vec2[4] vert = vec2[4](vec2(-.5, .5)*rect, vec2(.5)*rect, vec2(.5, -.5)*rect, vec2(-.5)*rect);\n\n    // Skew the rectangular grid.\n    p = skewXY(p, sk);\n\n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= (floor(p/rect) + .5)*rect; \n    \n    // Base on the bottom (0.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? -1. : 1.;\n   \n    // Unskew.\n    p = unskewXY(p, sk);\n    \n    // Triangle vertex points.\n    vec2[3] v;\n    // \n    if(gTri>.0){\n        v = vec2[3](vert[0], vert[2], vert[1]);\n    }\n    else {\n        v = vec2[3](vert[2], vert[0], vert[3]);\n    }\n    \n    for(int i = 0; i<3; i++) v[i] = unskewXY(v[i], sk); // Unskew.\n    \n    // Centering at the zero point.\n    p -= v[2]/3.; // Equivalent to: (v[0] + v[1] + v[2])/3.;\n\n\n    // Centered at the zero point.\n    return length(p);\n}\n*/\n\n// Faster, more compiler friendly version for equilateral triangles.\nfloat getTriVerts(vec2 p){\n\n    \n    // Skew the rectangular grid.\n    p = skewXY(p, sk);\n\n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= (floor(p/rect) + .5)*rect; \n    \n    \n    // Triangle offset point.\n    vec2 v = dot(p, 1./rect)<.0? -rect/2. : rect/2.;\n    v = unskewXY(v, sk); // Unskew.\n    \n    \n    // Unskew.\n    p = unskewXY(p, sk);\n    // Centering at the zero point.\n    p -= v/3.;\n\n    // Centered at the zero point.\n    return length(p);\n}\n//////////\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3.);\n    p.yz *= rot2(iTime/6.); \n    \n    return p;\n    \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    float wall = -(length(p - sphPos - vec3(0, 0, -(16. - 2.))) - 16.);\n    //float wall = -(length(p.xz - sphPos.xz - vec2(0, -(16. - 2.))) - 16.);\n    // Flat plane back wall.\n    //float wall = -p.z + 2.;// + length(p - sphPos - vec3(0, 0, 0))*.25;\n\n    // Adding subtle spherical curves in a triangle pattern on the \n    // back wall to allow more intersting light reflection.\n    float tr = getTriVerts(p.xy - vec2(0, .075));\n    wall += tr*.25;\n\n    /////    \n\n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(q) - .5;\n\n\n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, 1e5, 1e5);\n\n    // Shortest distance.\n    return  min(sph, wall);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = ZERO; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for \n        // this tidbit. So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(occ>1e5) break; // Fake break for compiler reasons.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n///////\n\n/* \n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r){\n\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n*/\n/////////\n\n \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n#define PI 3.14159265359\n#define TAU 6.2831853\n#define PHI 1.618033988749895 \n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout vec3[3] gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = ZERO; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the latitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : - 1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n\n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n\n\n    return q;\n}\n/////////\n\n\n// IQ's line distance formula.\nfloat distLine(vec3 p, vec3 a, vec3 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Standard cubic Bezier interpolation.\nvec4 bezierT(in float t){ \n    float u = 1. - t;\n    return vec4(u*u*u, t*u*u*3., t*t*u*3., t*t*t);\n}\n\n// Cubic Bezier spline -- Not cheap, unfortunately, but thankfully,\n// it's good enough for this example. I was hoping there'd be a better way,\n// but so far, it appears to be the only way.\nfloat distSpline(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3){\n\n    // Distance.\n    float d = 1e5, t = 0.;\n    \n    mat4x3 m43 = mat4x3(p0, p1, p2, p3);\n    \n    // It's not absolutely necessary, but I'm mapping the points\n    // to the surface of the sphere as I go along.\n    vec3 bc1 = normalize(p0)*.5;//normalize(m43*bezierT(0.))*.5;\n\n    // Several lines to approximate a smooth curve. Ouch! :) It's being called\n    // outside the raymarching loop, so we can get away with it.\n    const int N = 16;\n    for(int i = ZERO; i<N; i++){ \n    \n        vec3 bc2 = m43*bezierT(float(i + 1)/float(N));\n        bc2 = normalize(bc2)*.5; // Mapping to the surface of the sphere.\n        \n        //d = min(d, distLine(p, bc1, bc2));\n        float w = float(i)/float(N);\n        float l = length(p - bc1)/length(bc1 - bc2);\n        // Variable thickness. More at the start, but you can do it\n        // the other way around, or not at all.\n        const float th = .0075;\n        d = min(d, distLine(p, bc1, bc2) - (1. - (w + l/float(N)))*th);\n        bc1 = bc2;\n        \n        //if(d<-1e5) break;\n    }\n   \n    return d;\n}\n\n\n// Incircle of a 3D triangle: Basically the 3D extension of\n// the 2D version... I was in a hurry, but it seems about right.\n// Let me know if the logic doesn't follow.\n// \nvec3 inCircle(in vec3 v0, in vec3 v1, in vec3 v2){\n    \n    // Side lengths.\n    vec3 len = vec3(length(v2 - v1), length(v0 - v2), length(v1 - v0));\n    return mat3(v0, v1, v2)*len/dot(len, vec3(1));\n}\n\n/*\n// Angle between 3D vectors. Similar to the 2D version. It's easy to derive\n// this yourself, or look it up on the internet.\nfloat angle(vec3 p0, vec3 p1){\n\n    return acos(dot(p0, p1)/(length(p0)*length(p1)));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .25, -1.75);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    /*\n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    */\n    \n    // Object identification.\n    objID = vID[0]<vID[1]? 0 : 1;\n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel1, ref).xyz; refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, sn), 0.), 16.); // Specular reflection.\n        vec3 rCol = spRef*refTx*1.; //smoothstep(.03, 1., spRef)   \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            vec3[3] gVert, gVertID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, gVertID, rad);\n   \n            gVert[0] = sphericalToWorld(gVertID[0]);//vec3(0, rad, 0);\n            gVert[1] = sphericalToWorld(gVertID[1]);\n            gVert[2] = sphericalToWorld(gVertID[2]);\n            \n            \n            vec3[3] v = gVert, vID = gVertID;\n            \n            // Edge mid points, edge tangents and exit and entry points.\n            vec3[3] vE, vN;\n            //vec3[6] vE2;\n            \n            // Edge mid points.\n            vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n            vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n            vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n             \n            \n            /////\n            #if SCHEME > 0\n            // Triangle subdivision, if desired.\n            //\n            // Number of subdivisions.\n            #if SCHEME == 1\n            const int subDivNum = 1;\n            #else\n            const int subDivNum = 2;\n            #endif\n            //\n            // There'd be faster ways to do this, but this is\n            // relatively cheap, and it works well enough.\n            for(int i = ZERO; i<subDivNum; i++){\n            \n                // Create three line boundaries within the triangle to \n                // partition into four triangles. Pretty standard stuff.\n                // By the way, there are other partitionings, but this \n                // is the most common. At some stage, I'll include some\n                // others, like the three triangle version connecting the \n                // center to the vertices.\n                //\n                if(dot(lq, cross(vE[0], vE[1]))>0.){\n                    v[0] = vE[0]; v[2] = vE[1];\n                }\n                else if(dot(lq, cross(vE[1], vE[2]))>0.){\n                    v[0] = vE[2]; v[1] = vE[1];\n                }\n                else if(dot(lq, cross(vE[2], vE[0]))>0.){\n                    v[1] = vE[0]; v[2] = vE[2];\n                }\n                else {\n                    v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n                }\n                \n                // Recalculating the edge mid-vectors for the next iteration.\n                vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n                vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n                vE[2] = normalize(mix(v[2], v[0], .5))*rad;                \n            }\n            #endif\n            /////    \n            \n  \n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness.\n            vec3 ctr = normalize((v[0] + v[1] + v[2]))*rad;\n            // The unique cell ID, which is used for randomness, etc.\n            vec3 id = ctr;\n            \n \n\n\n            // Icosahedral cell boundary.\n            //\n            // Rendering lines onto a sphere is a little different to those on a plane.\n            // Lines between points translate to great arcs between points. This is\n            // just three triangle edge borders. I normally do these individually, but\n            // discovered this matrix short cut in on of Mattz's examples. Quite obvious...\n            // once someone else did it. :)\n            mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n            vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n            //\n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            float cellLine = min(min(ep.x, ep.y), ep.z) - .0035;\n \n            \n            \n            // Calculating the tangent vectors for each edge, as well as the two\n            // entry and exit points on each side of the mid-edge point. All are\n            // used to produce the random curves within each triangle cell.\n            for(int i = ZERO; i<3; i++){\n                \n                // Edge tangent vectors.\n                vN[i] = normalize(cross(v[(i + 1)%3] - v[i], v[i]));\n            } \n\n            \n\n            // Debug stuff.\n            // vec3 fiveStar = vec3(0);\n\n            // Rendering the spline curves between entry and exit points.\n            \n            float line = 1e5;\n            float line2 = 1e5;\n            \n            vec3 cn = normalize(inCircle(v[0], v[1], v[2]))*rad;\n            \n            for(int i = ZERO; i<3; i++){\n   \n                int ip1 = (i + 1)%3;  \n                int ip2 = (i + 2)%3; \n                //vec3 cntr0 =  normalize(v[0] + v[1] + v[2])*rad; \n                \n                // Edge entry points -- One on each side of the mid point.\n                float mOffs = .5/8.; // length(v[i] - v[ip1])/4.; //Edge mid point offset.\n                \n      \n                float spLn, ndg;\n                vec3 a, b, aN, bN, tN;\n                \n                // Three pronged central Bezier lines.\n                //tN = normalize(v[ip1] - v[i]);\n                // You have to set up four Bezier points to run the lines through. The end points\n                // are kind of set, since they need to begin at the center and exit at points\n                // near the midpoint of the edges. Where you place the other two points dictates\n                // the shape of the curve, and that's up to you. For me, I use vectors aN and bN \n                // that point away from \"a\" and \"b\" respectively, then I use them to estimate \n                // where the second and third points should be... Sounds annoying? It is. :D \n                // However, with practice, it gets better. :)\n                a = cn; \n                b = normalize(mix(v[i], v[ip1], .5 - mOffs))*rad;  // Just past the mid edge.\n                aN = normalize(cross(normalize(v[i] - cn)*rad, v[ip2] - v[ip1]));\n                bN = vN[i];\n\n                // How far we wish to nudge out the second and third Bezier points... \n                // That's an artform in its own right, which is just another way to say, \n                // I'm guessing. :)\n                ndg = length(a - b)/2.6;\n\n                // Take four points and render a spline curve. Rendering spline curves\n                // is simple enough, but if you're not sure, there is plenty of information\n                // on them.\n                spLn = distSpline(lq, a, normalize(a + aN*ndg)*rad, normalize(b + bN*ndg)*rad, b); \n                line = min(line, spLn);\n\n                // Five and six pronged stars eminating from the triangle vertices.\n                //tN = v[ip2] - v[ip1];\n                a = v[i];\n                b = normalize(mix(v[i], v[ip1], .5 + mOffs))*rad; // Just past the mid edge.\n                // Where you place the points is up to you. This was the tweak that I preferred.\n                aN = normalize(mix(cn, vE[ip2], .5) - v[i]);//normalize(cross(v[i], vE[ip2] - vE[ip1]));\n                bN = vN[i];\n\n                // How far we wish to nudge out the second and third Bezier points.\n                ndg = length(a - b)/2.6;\n\n\n                //vec2 q = p*vec2(-1, 1);\n                // Take four points and render a spline curve.\n                spLn = distSpline(lq, normalize(a - aN*ndg*.25)*rad, normalize(a + aN*ndg)*rad, \n                                      normalize(b + bN*ndg)*rad, b);  \n           \n                line2 = min(line2, spLn);\n                \n                // Using stupid tricks in a futile attempt to get the compile times down.\n                //if(line2<-1e8) break;\n           \n                /*\n                // Debug.\n                float ang = angle(cross(v[(i + 1)%3], v[i]), cross(v[(i + 2)%3], v[i]));\n                if(abs(ang - 6.2831/5.)<.001) fiveStar[i] = 1.;\n                */\n           }\n\n            // Give the edge some thickness.\n            #if SCHEME > 1\n            line -= .008;\n            line2 -= .008;\n            #elif SCHEME == 1\n            line -= .014;\n            line2 -= .014;\n            #else\n            line -= .025;\n            line2 -= .025;\n            #endif\n     \n            //line = 1e5; line2 = 1e5;\n            \n            // Cell vertices.\n            vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            float vert = min(min(v3.x, v3.y), v3.z);\n            \n            // Rounding off the centers.\n            // Rounding off the centers.\n            #if SCHEME == 1\n            line = smin(line, length(lq - cn) - .018, .015);\n            line2 = smin(line2, vert - .048, .015);\n            line2 = min(line2, vert - .05);\n            #elif SCHEME == 0\n            line = smin(line, length(lq - cn) - .033, .015);\n            line2 = smin(line2, vert - .063, .015);\n            line2 = min(line2, vert - .065);\n            #endif\n            \n            \n            \n            // Rendering the vertices, borders and Bezier curvers.\n            \n            \n            // Smoothing factor.\n            float sf = .003; \n            \n            // Triangle cell lines.\n            const float lNum = 80.;\n            float tLns = (abs(fract(cellLine*lNum - .333) - .5)*2. - .125)/lNum/2.;\n            texCol = mix(vec3(.1), vec3(0), (1. - smoothstep(0., sf, tLns))*.7);\n            \n            // Cell border lines.\n            //texCol = mix(texCol, texCol + .1, (1. - smoothstep(0., sf*2., cellLine)));\n            //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, cellLine))*.9);\n            \n            #ifdef REVERSE_PATTERN\n            // Reversing the pattern is as simple as reversing the rendering order.\n            float tmp = line; line = line2; line2 = tmp;\n            #endif\n            \n            vec3 lCol = vec3(1, .925, .85);\n            // Other colors: vec3(.5, 1, 1.5);//vec3(.75, 1.4, .3);//vec3(1, .925, .85);\n            vec3 trCol = vec3(.8, .55, .35)/1.5; // Trim color.\n            \n  \n            // Adding some specular reflection.\n            trCol += rCol*.7;\n            lCol += rCol*.7;\n            texCol += rCol*.1;\n \n            // Rendering the bezier curves themselves. \n            \n    \n            //float sh = max(.05 - ln[i]/.025, 0.);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*6., line))*.75);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, line));\n            texCol = mix(texCol, lCol, 1. - smoothstep(0., sf, line + .01));\n            #if SCHEME <= 1\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, abs(line + .00875) - .00175));\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, abs(line + .005) - .001));\n            #else\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, line + .006));\n            #endif \n\n            //sh = max(.05 - ln2[i]/.025, 0.);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*6., line2))*.75);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, line2));\n            texCol = mix(texCol, lCol, 1. - smoothstep(0., sf, line2 + .01));\n            #if SCHEME <= 1\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, abs(line2 + .00875) - .00175));\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, abs(line2 + .005) - .001));\n            #else\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, line2 + .006));\n            #endif               \n\n            \n            // Cell vertices.\n            #if SCHEME == 1\n            vert -= .0195;\n            #elif SCHEME == 0\n            vert -= .0275;\n            #endif\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, vert + .005));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .0115));\n            texCol = mix(texCol, vec3(.18, .15, .12) + rCol*.5, 1. - smoothstep(0., sf, vert + .0165));\n \n            \n        }\n        else { \n        \n            //  Wall.\n            \n            \n            // Texture coordinates and normal.\n            vec3 txP = sp;\n            vec3 txN = sn;\n            \n            // Moving the pattern down a bit.\n            txP.y -= .075;\n            \n            // Rotating the pattern for a different perspective.\n            // Would need to be matched inside the distance function too.\n            //txP.xy *= rot2(3.14159/6.);\n            \n            \n            // Cell coordinate, ID and triangle orientation id.\n            // Cell vertices and vertex ID.\n            vec2[3] v, vID;\n\n            // Returns the local coordinates (centered on zero), cellID, the \n            // triangle vertex ID and relative coordinates.\n            vec4 p4 = getTriVerts(txP.xy, vID, v);\n            vec2 p = p4.xy;\n            vec2 id = p4.zw;\n            float tri = gTri;\n            vec2 triID = id + (vID[0] + vID[1] + vID[2])/3.;\n            \n            // Smoothing factor.\n            float sf = .003;\n            \n            // Nearest vertex ID.\n            float vert = 1e5;\n            \n            vec2 vertID;\n            for(int i = 0; i<3; i++){\n                float vDist = length(p - v[i]);\n                if(vDist<vert){\n                    vert = vDist;\n                    vertID = id + vID[i];\n                }\n            }\n \n             \n            // Border triangles, bump highlights, etc. It was made up on the spot, and\n            // I'm pretty sure there'd be better ways to do it. 3D bump mapping would\n            // be better, but I'm keeping things simple and cheaper.\n            vec2 q = tri<.5? p : p*vec2(1, -1);\n            float tr = (max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3. + .0125)/1.;\n            tr = max(tr, -(vert - .07));\n            \n            \n            \n            // Intial background triangle color.\n            texCol = mix(texCol, vec3(.085), (1. - smoothstep(0., sf, tr))*.9);\n            \n            // Subtle reflection.\n            texCol += rCol*.1;\n            \n            // Concentric triangle lines.\n            const float lNum = 26.;\n            float tLns = (abs(fract(tr*lNum + .25) - .5)*2. - .333)/lNum/2.;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, max(tr, tLns)))*.7);\n         \n            // Vertices with subtle reflection.\n            vert -= .0675;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*6., vert))*.75);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(.18, .15, .12) + rCol*.7, 1. - smoothstep(0., sf, vert + .015));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .035));\n            texCol = mix(texCol, vec3(.085) + rCol*.5, 1. - smoothstep(0., sf, vert + .05));\n           \n \n            \n        }\n        /*\n        // Extra objects.\n        else if(objID==2){ \n\n            texCol = vec3(1);\n        }\n        else { // Wall.\n   \n            texCol = vec3(1);\n        }\n        */\n    \n                \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .7, .4)*spec*freS*sh);\n \n            // Shading.\n        col *= ao*atten;\n       \n\t\n\t}\n    \n \n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(aCol, 0.), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}