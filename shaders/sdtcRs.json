{
    "Shader": {
        "info": {
            "date": "1653986893",
            "description": "This is a raymarcher for Apple's mac pro grill.\n\nClick and drag with the mouse!",
            "flags": 0,
            "hasliked": 0,
            "id": "sdtcRs",
            "likes": 7,
            "name": "Apple Mac Pro Universe",
            "published": 3,
            "tags": [
                "raymarcher",
                "apple",
                "mac"
            ],
            "usePreview": 0,
            "username": "copperbotte",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "\nfloat sdf_sphere(vec3 wPos, vec3 sPos, float sSize)\n{\n    float sdf = length(wPos - sPos) - sSize;\n    \n    //if(sdf < 0.0) normal = -normalize(wPos - sPos);\n    //else normal = normalize(wPos - sPos);\n    \n    return sdf;\n}\n\n// Thanks iQ!! https://iquilezles.org/articles/distfunctions/\nfloat sdf_cube(vec3 wPos, vec3 cPos, vec3 cSize)\n{\n    vec3 diff = abs(wPos - cPos) - cSize;\n    \n    // Outer is the vector from the current point to each side of the cube, offset by its size.\n    // If multiple offset are larger than 0, the distance is given by length instead of one side only.\n    vec3 outer = max(diff, 0.0);\n    \n    // Inner is the minimum distance to any side, which is guaranteed to be a straight line distance.\n    float inner = min(max(max(diff.x, diff.y), diff.z), 0.0);\n    \n    // The side closest to the cube has a length of 1.\n    //vec3 invec = diff / inner; \n    \n    float sdf = length(outer) + min(max(max(diff.x, diff.y), diff.z), 0.0);\n    //if(0.0 <= sdf) normal = normalize(wPos - outer - cSize);\n    //else normal = \n    return sdf;\n    \n    \n    //return length(outer) + min(max(max(diff.x, diff.y), diff.z), 0.0);\n}\n\n// Global SDF\nfloat Sdf(in vec3 wPos)\n{   \n    const float s3 = sqrt(3.0);\n    float sRad = s3/4.0;\n\n    //float s = sdf_sphere(wPos, vec3(0.0, 1.0 - sRad, 0.0), sRad);\n    float csize = (2.0/3.0)*sRad;\n    float c = sdf_cube(wPos, vec3(0.0, -csize, 0.0), vec3(1000.0, csize, 1000.0));\n\n    //float sdf = min(s, c);\n    //float sdf = max(-s, c);\n    \n    float sdf = c;\n    \n////////////////////////////////////////////////////////////////////////////////\n    \n    // https://saccade.com/blog/2019/06/how-to-make-apples-mac-pro-holes/\n    //     The Mac pro's grill is made of a grid of spheres cut into a flat\n    // surface.  The spheres centers are on the surface, spaced equilaterally.\n    // Their radii is selected such that the top of each sphere touches the\n    // bottom of the sphere the next row up.  The surface has another set of\n    // spheres cut underneath, offset such that the spheres align with the\n    // centroid of the triangular grid.  The thickness of plate is 2/3 r, so the\n    // spheres intersect with regular triangular holes.\n    // \n////////////////////////////////////////////////////////////////////////////////\n    //     For an equilateral grid with spheres spaced every unit, we can \n    // represent this as a coordinate system with a shear:\n    // \n    //     Each sphere repeats along the x axis every unit, offset by a half unit \n    // for each y. It also repeats along the y axis, offset by 1/3 the y height \n    // for each z. This can be encoded by a matrix:\n    //\n    // [x]   [1  1/2    0] [i]\n    // [y] = [0 s3/2 s3/6]*[j]\n    // [z]   [0    0 s3/6] [k]\n    // where s3 is sqrt(3).\n    // \n    //     To find the closest sphere to a point on the grid, coordinates are \n    // first transformed into this coordinate system via its inverse:\n    // \n    // [i]   [s3 -1  1]      [x]\n    // [j] = [ 0  2 -2]*s3/3*[y]\n    // [k]   [ 0  0  6]      [z]\n    //\n    // Then, the coordinates are rounded, then transformed back.\n    \n    //     Using the full 3x3 matrix seems to introduce errors, going to fall back\n    // to manually computing z.\n    \n    \n    /*\n    mat3x3 smat = mat3x3(1,    0.5,      0,\n                         0, s3/2.0, s3/6.0,\n                         0,      0, s3/3.0);\n    mat3x3 ismat = mat3x3(s3, -1,  1,\n                           0,  2, -2,\n                           0,  0,  6)*s3/3.0;\n    /*/\n    mat3x3 smat = mat3x3(1,    0.5,      0,\n                         0, s3/2.0,      0,\n                         0,      0, s3/6.0);\n    mat3x3 ismat = mat3x3(s3, -1,  0,\n                           0,  2,  0,\n                           0,  0,  6)*s3/3.0;\n    //*/                    \n                          \n    for(int i=0; i<2; ++i)\n    {\n        for(int j=0; j<2; ++j)\n        {\n            vec3 drift = vec3(float(i), float(j), 0);\n            \n            vec3 coords = (drift + round(wPos.xzy * ismat)) * smat;\n            float s = sdf_sphere(wPos, vec3(coords.x, 0, coords.y), sRad); \n            sdf = max(sdf, -s);\n            \n            vec3 offset = vec3(0, sqrt(3.0)/3.0, 0);\n            drift = vec3(float(i), float(j), 1);\n            coords = (drift + round((wPos.xzy + offset) * ismat)) * smat - offset;\n            s = sdf_sphere(wPos, vec3(coords.x, -sRad, coords.y), sRad); \n            sdf = max(sdf, -s);\n        }\n    }\n    \n    return sdf;\n}\n\n\n// SDF Raymarch\nvec3 raymarch(in vec3 rPos, in vec3 rDir)\n{\n    vec3 sPos = rPos;\n    \n    float dir = sign(Sdf(sPos));\n    \n    for(int i=0; i<100; ++i)\n    {\n        float sdf = Sdf(sPos);\n        sPos += rDir * dir * sdf;\n        if(abs(sdf) < 1e-4)\n            return sPos;\n    }\n    \n    return sPos;\n}\n\n\n// Color each world position by firing a ray off\nvec3 color_wpos(in vec3 wPos, in vec3 rDir)\n{\n    // Find the sdf's local gradient\n    const float epsilon = 1e-5;\n    \n    // thx iq!! https://iquilezles.org/articles/normalsSDF/\n    const vec2 k = vec2(1,-1);\n    vec3 normal = normalize(\n        k.xyy*Sdf( wPos + k.xyy*epsilon ) + \n        k.yyx*Sdf( wPos + k.yyx*epsilon ) + \n        k.yxy*Sdf( wPos + k.yxy*epsilon ) + \n        k.xxx*Sdf( wPos + k.xxx*epsilon ) );\n    \n    // Light with PBR Phong\n    float theta = iTime;\n    vec3 lDir = normalize(vec3(sin(theta),2,cos(theta)));\n    float diffuse = max(0.0, dot(lDir, normal));\n    \n    vec3 refl = reflect(rDir, normal);\n    float power = 10.0;\n    float specular = pow(max(0.0, dot(refl, lDir)), power);\n    \n    float reflectivity = 0.2;\n    float L = mix(diffuse, specular*(power + 2.0)/2.0, reflectivity); // /3.141592;\n    \n    // Check if the raymarch yeets off very far\n    vec3 endPos = raymarch(wPos + lDir*100.0, -lDir);\n    if(length(endPos - wPos) < 1e-2)\n        return vec3(L + 0.1);\n    else\n        return vec3(0.1);\n}\n\n// Generate a ray to march\nvoid generate_ray(in vec2 xy, out vec3 rPos, out vec3 rDir)\n{\n    rPos = vec3(0,0,20);\n    //rPos = vec3(0,0,2);\n    \n    vec3 dir = vec3(xy, -1);\n    rDir = normalize(dir);\n    \n    float theta = iTime / 10.0;\n    float phi = 3.141592/4.0;\n    \n    if(0.5 < iMouse.z)\n    {\n        theta = ((iMouse.x / iResolution.x)*2.0 - 1.0)*3.141592;\n        phi += ((iMouse.y / iResolution.y)*2.0 - 1.0)*3.141592 * iResolution.y/iResolution.x;\n    }\n    float ct = cos(theta);\n    float st = sin(theta);\n    float cp = cos(phi);\n    float sp = sin(phi);\n\n    mat3x3 pitch = mat3x3(1.0, 0.0, 0.0,\n                          0.0,  cp, -sp,\n                          0.0,  sp,  cp);\n\n    mat3x3 yaw = mat3x3( ct, 0.0, -st,\n                        0.0, 1.0, 0.0,\n                         st, 0.0,  ct);\n\n    mat3x3 view = yaw * pitch;\n    rPos = view * rPos;\n    rDir = view * rDir;\n    \n}\n\n// Seperate sample function for integration\nvec3 sample_image( in vec2 uv )\n{\n    // Correct for aspect ratio, convert so 0 is the center\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 rPos, rDir;\n    generate_ray(xy, rPos, rDir);\n    vec3 sPos = raymarch(rPos, rDir);\n    \n    if(abs(Sdf(sPos)) < 0.01)\n        col = color_wpos(sPos, rDir);\n    \n    // Output to screen\n    return col;\n}\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n \n    const int samples = 4;\n    const float s_f = float(samples);\n \n    for(int i=0; i<samples; ++i)\n    {\n        vec2 rng = vec2(rnd(), rnd()) - 0.5;\n        //vec2 rng = vec2(0);\n    \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = (fragCoord+rng)/iResolution.xy;\n        vec3 C = sample_image(uv);\n        C = pow(C, vec3(2.2));\n        col += C;\n    \n    }\n    \n    col /= s_f;\n    \n    // adjust for srgb color space\n    // rough approx\n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}