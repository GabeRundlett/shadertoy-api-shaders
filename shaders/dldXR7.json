{
    "Shader": {
        "info": {
            "date": "1685458595",
            "description": "A recreation of https://lazybrush.dulnan.net/\n\nControls:\n- Mouse to draw\n- L: toggle between quadratic bezier curves and line segments\n- S: toggle SDF visualisation\n- P: toggle mouse points\n\nSettings in Buffer B",
            "flags": 48,
            "hasliked": 0,
            "id": "dldXR7",
            "likes": 57,
            "name": "Smooth Mouse Drawing",
            "published": 3,
            "tags": [
                "mouse",
                "sdf",
                "bezier",
                "draw",
                "quadratic",
                "brush",
                "lazy"
            ],
            "usePreview": 0,
            "username": "fad",
            "viewed": 1391
        },
        "renderpass": [
            {
                "code": "// A recreation of https://lazybrush.dulnan.net/\n\n// Controls:\n// - Mouse to draw\n// - L: toggle between quadratic bezier curves and line segments\n// - S: toggle SDF visualisation\n// - P: toggle mouse points\n\n// Settings in Buffer B\n\n// Modified sdBezier() function originally from\n// Quadratic Bezier SDF With L2 - Envy24\n// https://www.shadertoy.com/view/7sGyWd\n\n#define LINE_WIDTH (iResolution.y * 0.01)\n#define POINT_RADIUS (iResolution.y * 0.007)\n\nconst int KEY_L = 76;\nconst int KEY_S = 83;\nconst int KEY_P = 80;\n\nbool keyToggled(int keyCode) {\n    return texelFetch(iChannel1, ivec2(keyCode, 2), 0).r > 0.0;\n}\n\nvec4 blendOver(vec4 front, vec4 back) {\n    float a = front.a + back.a * (1.0 - front.a);\n    return a > 0.0\n        ? vec4((front.rgb * front.a + back.rgb * back.a * (1.0 - front.a)) / a , a)\n        : vec4(0.0);\n}\n\nvoid blendInto(inout vec4 dst, vec4 src) {\n    dst = blendOver(src, dst);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = vec4(1.0);\n\n    float qd = texture(iChannel0, fragCoord / iResolution.xy).x;\n    float ld = texture(iChannel0, fragCoord / iResolution.xy).y;\n    float pd = texture(iChannel0, fragCoord / iResolution.xy).z;\n    float sd = (keyToggled(KEY_L) ? ld : qd) - LINE_WIDTH / 2.0;\n    \n    blendInto(fragColor, vec4(0.0, 0.0, 0.0, clamp(0.5 - sd, 0.0, 1.0)));\n    \n    if (!keyToggled(KEY_S)) {\n        float spacing = iResolution.y * 0.02;\n        float thickness = max(iResolution.y * 0.002, 1.0);\n        float opacity = clamp(\n            0.5 + 0.5 * thickness - \n            abs(mod(sd - (spacing - thickness) * 0.5, spacing) - spacing * 0.5), \n            0.0, 1.0\n        ) * 0.5 * exp(-sd / iResolution.y * 8.0);\n        blendInto(fragColor, vec4(0.0, 0.0, 0.0, opacity));\n    }\n    \n    if (keyToggled(KEY_P)) {\n        blendInto(fragColor, vec4(1.0, 0.0, 0.0, clamp(POINT_RADIUS - pd + 0.5, 0.0, 1.0)));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This buffer tracks smoothed mouse positions over multiple frames.\n\n// See https://lazybrush.dulnan.net/ for what these mean:\n#define RADIUS (iResolution.y * 0.015)\n#define FRICTION 0.05\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    if (fragCoord.y != 0.5 || fragCoord.x > 3.0) {\n        return;\n    }\n\n    if (iFrame == 0) {\n        if (fragCoord.x == 2.5) {\n            fragColor = iMouse;\n        } else {\n            fragColor = vec4(0.0);\n        }\n        \n        return;\n    }\n    \n    vec4 iMouse = iMouse;\n    const float magic = 1e25;\n    \n    if (iMouse == vec4(0.0)) {\n        float t = iTime * 3.0;\n        iMouse.xy = (vec2(cos(3.14159 * t) + sin(0.72834 * t + 0.3), sin(2.781374 * t + 3.47912) + cos(t)) * 0.25 + 0.5) * iResolution.xy;\n        iMouse.z = magic;\n    }\n    \n    vec4 mouseA = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 mouseB = texelFetch(iChannel0, ivec2(2, 0), 0);\n    vec4 mouseC;\n    mouseC.zw = iMouse.zw;\n    float dist = distance(mouseB.xy, iMouse.xy);\n    \n    if (mouseB.z > 0.0 && (mouseB.z != magic || iMouse.z == magic) && dist > 0.0) {\n        vec2 dir = (iMouse.xy - mouseB.xy) / dist;\n        float len = max(dist - RADIUS, 0.0);\n        float ease = 1.0 - pow(FRICTION, iTimeDelta * 10.0);\n        mouseC.xy = mouseB.xy + dir * len * ease;\n    } else {\n        mouseC.xy = iMouse.xy;\n    }\n    \n    if (fragCoord.x == 0.5) {\n        fragColor = mouseA;\n    } else if (fragCoord.x == 1.5) {\n        fragColor = mouseB.z == magic && iMouse.z != magic ? vec4(0.0) : mouseB;\n    } else {\n        fragColor = mouseC;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer maintains the SDF for the drawing.\n\n// .x: SDF with quadratic bezier curves\n// .y: SDF with linear segments\n// .z: SDF for mouse points\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    return distance(ap, ab * clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float qd = 1e30;\n    float ld = 1e30;\n    float pd = 1e30;\n    \n    if (iFrame != 0) {\n        qd = texelFetch(iChannel1, ivec2(fragCoord), 0).r;\n        ld = texelFetch(iChannel1, ivec2(fragCoord), 0).g;\n        pd = texelFetch(iChannel1, ivec2(fragCoord), 0).b;\n    }\n    \n    vec4 mouseA = iFrame > 0 ? texelFetch(iChannel0, ivec2(0, 0), 0) : vec4(0.0);\n    vec4 mouseB = iFrame > 0 ? texelFetch(iChannel0, ivec2(1, 0), 0) : vec4(0.0);\n    vec4 mouseC = iFrame > 0 ? texelFetch(iChannel0, ivec2(2, 0), 0) : iMouse;\n    \n    // A: mouse from previous previous frame\n    // B: mouse from previous frame\n    // C: mouse from this frame\n    \n    mouseA.xy += 0.5;\n    mouseB.xy += 0.5;\n    mouseC.xy += 0.5;\n    \n    if (mouseC.z > 0.0) {\n        pd = min(pd, distance(fragCoord, mouseC.xy));\n    }\n    \n    if (mouseB.z > 0.0 && mouseC.z > 0.0) {\n        ld = min(ld, sdSegment(fragCoord, mouseB.xy, mouseC.xy));\n    } else if (mouseC.z > 0.0) {\n        ld = min(ld, distance(fragCoord, mouseC.xy));\n    }\n    \n    if (mouseB.z <= 0.0 && mouseC.z > 0.0) {\n        qd = min(qd, distance(fragCoord, mouseC.xy));\n    } else if (mouseA.z <= 0.0 && mouseB.z > 0.0 && mouseC.z > 0.0) {\n        qd = min(qd, sdSegment(fragCoord, mouseB.xy, mix(mouseB.xy, mouseC.xy, 0.5)));\n    } else if (mouseA.z > 0.0 && mouseB.z > 0.0 && mouseC.z > 0.0) {\n        qd = min(qd, abs(sdBezier(fragCoord, mix(mouseA.xy, mouseB.xy, 0.5), mouseB.xy, mix(mouseB.xy, mouseC.xy, 0.5))));\n    } else if (mouseA.z > 0.0 && mouseB.z > 0.0 && mouseC.z <= 0.0) {\n        qd = min(qd, sdSegment(fragCoord, mix(mouseA.xy, mouseB.xy, 0.5), mouseB.xy));\n    }\n    \n    fragColor.r = qd;\n    fragColor.g = ld;\n    fragColor.b = pd;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// solveQuadratic(), solveCubic(), solve() and sdBezier() are from\n// Quadratic Bezier SDF With L2 - Envy24\n// https://www.shadertoy.com/view/7sGyWd\n// with modification. Thank you! I tried a lot of different sdBezier()\n// implementations from across Shadertoy (including trying to make it\n// myself) and all of them had bugs and incorrect edge case handling\n// except this one.\n\nint solveQuadratic(float a, float b, float c, out vec2 roots) {\n    // Return the number of real roots to the equation\n    // a*x^2 + b*x + c = 0 where a != 0 and populate roots.\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        return 0;\n    }\n\n    if (discriminant == 0.0) {\n        roots[0] = -b / (2.0 * a);\n        return 1;\n    }\n\n    float SQRT = sqrt(discriminant);\n    roots[0] = (-b + SQRT) / (2.0 * a);\n    roots[1] = (-b - SQRT) / (2.0 * a);\n    return 2;\n}\n\nint solveCubic(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 where a != 0 and populate roots.\n    const float TAU = 6.2831853071795862;\n    float A = b / a;\n    float B = c / a;\n    float C = d / a;\n    float Q = (A * A - 3.0 * B) / 9.0;\n    float R = (2.0 * A * A * A - 9.0 * A * B + 27.0 * C) / 54.0;\n    float S = Q * Q * Q - R * R;\n    float sQ = sqrt(abs(Q));\n    roots = vec3(-A / 3.0);\n\n    if (S > 0.0) {\n        roots += -2.0 * sQ * cos(acos(R / (sQ * abs(Q))) / 3.0 + vec3(TAU, 0.0, -TAU) / 3.0);\n        return 3;\n    }\n    \n    if (Q == 0.0) {\n        roots[0] += -pow(C - A * A * A / 27.0, 1.0 / 3.0);\n        return 1;\n    }\n    \n    if (S < 0.0) {\n        float u = abs(R / (sQ * Q));\n        float v = Q > 0.0 ? cosh(acosh(u) / 3.0) : sinh(asinh(u) / 3.0);\n        roots[0] += -2.0 * sign(R) * sQ * v;\n        return 1;\n    }\n    \n    roots.xy += vec2(-2.0, 1.0) * sign(R) * sQ;\n    return 2;\n}\n\nint solve(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 and populate roots.\n    if (a == 0.0) {\n        if (b == 0.0) {\n            if (c == 0.0) {\n                return 0;\n            }\n            \n            roots[0] = -d/c;\n            return 1;\n        }\n        \n        vec2 r;\n        int num = solveQuadratic(b, c, d, r);\n        roots.xy = r;\n        return num;\n    }\n    \n    return solveCubic(a, b, c, d, roots);\n}\n\nfloat sdBezier(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 A = a - 2.0 * b + c;\n    vec2 B = 2.0 * (b - a);\n    vec2 C = a - p;\n    vec3 T;\n    int num = solve(\n        2.0 * dot(A, A),\n        3.0 * dot(A, B),\n        2.0 * dot(A, C) + dot(B, B),\n        dot(B, C),\n        T\n    );\n    T = clamp(T, 0.0, 1.0);\n    float best = 1e30;\n    \n    for (int i = 0; i < num; ++i) {\n        float t = T[i];\n        float u = 1.0 - t;\n        vec2 d = u * u * a + 2.0 * t * u * b + t * t * c - p;\n        best = min(best, dot(d, d));\n    }\n    \n    return sqrt(best);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}