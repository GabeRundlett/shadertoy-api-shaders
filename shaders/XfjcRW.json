{
    "Shader": {
        "info": {
            "date": "1721974862",
            "description": "originals  https://www.shadertoy.com/view/McScRW https://www.shadertoy.com/view/4sBfDw  \n https://www.shadertoy.com/view/4tyfWy",
            "flags": 0,
            "hasliked": 0,
            "id": "XfjcRW",
            "likes": 3,
            "name": "cosmic star 4",
            "published": 3,
            "tags": [
                "fractal",
                "star",
                "cosmos"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 156
        },
        "renderpass": [
            {
                "code": "uvec3 pcg3d(uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.z; v.y += v.z * v.x; v.z += v.x * v.y;\n    v ^= v >> 16u;\n    v.x += v.y * v.z; v.y += v.z * v.x; v.z += v.x * v.y;\n    return v;\n}\n#define PI 3.1415926536\nvec3 pcg33(vec3 p)\n{\n    uvec3 r = pcg3d(floatBitsToUint(p));\n    return vec3(r) / float(0xffffffffu);\n}\n\nvec3 pcg23(vec2 p)\n{\n    return pcg33(p.xyx);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 star(vec2 uv, vec2 id)\n{\n    vec3 r = pcg23(id);\n    float size = r.z;\n    uv += (r.xy - .5);\n    float d = length(uv);\n    float l = size * .0002 / (d * d);\n    float s1 = min(1., (.002 / abs(uv.x)) + (.002 / abs(uv.y)));\n    uv *= rot(PI * .25);\n    float s2 = min(1., (.002 / abs(uv.x)) + (.002 / abs(uv.y)));\n    float s = s1 * smoothstep(.25, 0., d) + s2 * smoothstep(.15, 0., d);\n    s *= smoothstep(.95, 1., size) * .5;\n    float b = l +  .5 * s;\n    b *= smoothstep(1., .5, d);\n    float blink_i = smoothstep(0., .8, fract(r.z * 1000.));\n    float blink_f = smoothstep(0., 1., fract(r.z * 100.));\n    float blink = (.5+.5*sin(blink_f * iTime * 10.))*(blink_i*.5);\n    return b * (1.0 - blink) * vec3(\n        .5*smoothstep(1., .5, size)+.5,\n        (.25 + .75*smoothstep(0., 0.5, size)) * (.5+.5*smoothstep(1., 0.5, size)) ,\n        smoothstep(0., .5, size));\n        \n}\n\nvec3 layer(vec2 uv, vec2 id)\n{\n    vec3 col = vec3(0);\n    for (float x = -1.; x <= 1.; x++)\n    {\n        for (float y = -1.; y <= 1.; y++)\n        {\n            vec2 off = vec2(x, y);\n            col += star(uv - off, id + off);\n        }\n    }\n    return col;\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n#define N 6.\n\n\nfloat ltime;\n\nfloat noise(vec2 p)\n{\n  return sin(p.x*10.) * sin(p.y*(3. + sin(ltime/11.))) + .2; \n}\n\nmat2 rotate(float angle)\n{\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n\nfloat fbm(vec2 p)\n{\n  p *= 1.1;\n  float f = 0.;\n  float amp = .5;\n  for( int i = 0; i < 3; i++) {\n    mat2 modify = rotate(ltime/50. * float(i*i));\n    f += amp*noise(p);\n    p = modify * p;\n    p *= 2.;\n    amp /= 2.2;\n  }\n  return f;\n}\n\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\n  q = vec2( fbm(p + vec2(1.)),\n\t    fbm(rotate(.1*ltime)*p + vec2(3.)));\n  r = vec2( fbm(rotate(.2)*q + vec2(0.)),\n\t    fbm(q + vec2(0.)));\n  return fbm(p + 1.*r);\n\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n#define M_PI 3.14159265359\n\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = \n        permute\n        (\n            permute\n            ( \n                permute\n                (\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0)\n                )\n                + i.y + vec4(0.0, i1.y, i2.y, 1.0 )\n            )\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 )\n        );\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\n// p: position\n// o: how many layers\n// f: frequency\n// lac: how fast frequency changes between layers\n// r: how fast amplitude changes between layers\nfloat fbm4(vec3 p, float theta, float f, float lac, float r)\n{\n    mat3 mtx = mat3(\n        cos(theta), -sin(theta), 0.0,\n        sin(theta), cos(theta), 0.0,\n        0.0, 0.0, 1.0);\n\n    float frequency = f;\n    float lacunarity = lac;\n    float roughness = r;\n    float amp = 1.0;\n    float total_amp = 0.0;\n\n    float accum = 0.0;\n    vec3 X = p * frequency;\n    for(int i = 0; i < 4; i++)\n    {\n        accum += amp * snoise(X);\n        X *= (lacunarity + (snoise(X) + 0.1) * 0.006);\n        X = mtx * X;\n\n        total_amp += amp;\n        amp *= roughness;\n    }\n\n    return accum / total_amp;\n}\n\nfloat fbm8(vec3 p, float theta, float f, float lac, float r)\n{\n    mat3 mtx = mat3(\n        cos(theta), -sin(theta), 0.0,\n        sin(theta), cos(theta), 0.0,\n        0.0, 0.0, 1.0);\n\n    float frequency = f;\n    float lacunarity = lac;\n    float roughness = r;\n    float amp = 1.0;\n    float total_amp = 0.0;\n\n    float accum = 0.0;\n    vec3 X = p * frequency;\n    for(int i = 0; i < 8; i++)\n    {\n        accum += amp * snoise(X);\n        X *= (lacunarity + (snoise(X) + 0.1) * 0.006);\n        X = mtx * X;\n\n        total_amp += amp;\n        amp *= roughness;\n    }\n\n    return accum / total_amp;\n}\n\nfloat turbulence(float val)\n{\n    float n = 1.0 - abs(val);\n    return n * n;\n}\n\nfloat pattern(in vec3 p, inout vec3 q, inout vec3 r)\n{\n    q.x = fbm4( p + 0.0, 0.0, 1.0, 2.0, 0.33 );\n    q.y = fbm4( p + 6.0, 0.0, 1.0, 2.0, 0.33 );\n\n    r.x = fbm8( p + q - 2.4, 0.0, 1.0, 3.0, 0.5 );\n    r.y = fbm8( p + q + 8.2, 0.0, 1.0, 3.0, 0.5 );\n\n    q.x = turbulence( q.x );\n    q.y = turbulence( q.y );\n\n    float f = fbm4( p + (1.0 * r), 0.0, 1.0, 2.0, 0.5);\n\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime * .05;\n    float t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .57)) * 2.2;\n\tfloat si = sin(t2);\n\tfloat co = cos(t2);\n\tmat2 ma = mat2(co, si, -si, co);\n\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\tvec2 p = fragCoord.xy / iResolution.xy;\n  ltime = iTime;\n  float ctime = iTime + fbm(p/8.)*40.;\n  float ftime = fract(ctime/6.);\n  ltime = floor(ctime/6.) + (1.-cos(ftime*3.1415)/2.);\n  ltime = ltime*6.;\n  vec2 q;\n  vec2 r;\n  float f = pattern(p, q, r);\n  vec3 col3 = hsv2rgb(vec3(q.x/10. + ltime/100. + .4, abs(r.y)*3. + .1, r.x + f));\n  float vig = 1. - pow(4.*(p.x - .5)*(p.x - .5), 10.);\n  vig *= 1. - pow(4.*(p.y - .5)*(p.y - .5), 10.);\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0);\n\t\t\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col2 = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n    uv *= rot(t);\n    \n    for (float f = 0.; f < 1.; f += 1. / N)\n    {\n        float depth = fract(f + t);\n        float scale = mix(10., .1, depth);\n        vec2 uv2 = uv*ma * scale;\n        uv2 += vec2(123.45, 55.22) * f;\n        vec2 gv = fract(uv2) - .5;\n        vec2 id = floor(uv2);\n        col += depth * layer(gv, id) * smoothstep(1., .95, depth);\n    }\n     vec2 st = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    st.x *= aspect;\n\n    vec2 uv3 = st*ma;\n\n    float t3 = iTime * 0.1;\n\n    vec3 spectrum[4];\n    spectrum[0] = vec3(0.94, 0.02, 0.03);\n    spectrum[1] = vec3(0.04, 0.04, 0.22);\n    spectrum[2] = vec3(1.00, 0.80, 1.00);\n    spectrum[3] = vec3(0.20, 0.40, 0.50);\n\n    uv3 -= 0.5;\n    uv3 *= 3.5;\n\n    vec3 p3 = vec3(uv3.x, uv3.y, t3);\n    vec3 q3 = vec3(0.0);\n    vec3 r3 = vec3(0.0);\n    float f3 = pattern(p3, q3, r3);\n\n    vec3 color = vec3(0.0);\n    color = mix(spectrum[1], spectrum[3], pow(length(q3), 4.0));\n    color = mix(color, spectrum[0], pow(length(r3), 1.4));\n    color = mix(color, spectrum[2], f);\n\n    color = pow(color, vec3(2.0));\n    col = pow(col+col2, vec3(0.4545));\n    fragColor = vec4(col, 1.);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.75)*1.+color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}