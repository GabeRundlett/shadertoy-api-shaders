{
    "Shader": {
        "info": {
            "date": "1722012429",
            "description": "Packing small objects into a Mobius strip.",
            "flags": 32,
            "hasliked": 0,
            "id": "Xf2czW",
            "likes": 73,
            "name": "Packed Mobius Strip",
            "published": 3,
            "tags": [
                "raymarch",
                "sphere",
                "mobius",
                "ring",
                "strip",
                "moebius",
                "band"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "/*\n\n    Packed Mobius Strip\n    -------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n \n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 1.5 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 1.5, coc = .5;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Mobius Packed Strip\n    -------------------\n    \n    I've been busy travelling this year, so haven't been on Shadertoy much. A \n    couple of weeks ago, by pure chance, I went past the convention center in \n    Helsinki where they're hosting this year's Assembly demo party. This \n    reminded me that I haven't posted anything in ages, so I fired up my laptop \n    and repurposed an old example.\n    \n    Anyway, forward facing Mobius rings are commonplace in the geometric design \n    world. Hitting a scene with strategically positioned warm and cool lights is \n    another cliche, so this is not exactly interesting or original, but it was \n    fun and simple to make.\n    \n    There's not a lot to this: Create a square torus then twist it around the\n    long toroidal axis to produce a Mobius ring. Once you've done that, break \n    the toroidal axis into repeat squares. In turn, break the individual square \n    axes into repeat cell segments in order to render tiny beaded objects. The\n    details are contained in the \"map\" function.\n    \n    I'm not travelling from city to city now, so the plan is to code more. I'll \n    try to post something more interesting next.\n    \n    \n\n\tRelated examples:\n    \n    // Dr2 has a heap of Mobius related material that's worth the look.\n    Moebius Gears 2 - Dr2\n    https://www.shadertoy.com/view/wsXyW2\n    \n    // Flockaroo has a lot of great geometric examples. Like myself, I \n    // wish he'd post more often. :)\n    moebius gears 2 - flockaroo\n    https://www.shadertoy.com/view/ls2BDc\n    \n    \n*/\n\n\n// Attempting not to unroll loops.\n#define ZERO min(0, iFrame)\n\n// Max ray distance.\n#define FAR 10.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .1, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like \n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n*/\n\n// Texture sample.\nvec3 getTex(sampler2D iCh, vec2 p){\n\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n\n// IQ's box routine.\nfloat sBoxS(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n// IQ's box routine.\nfloat sBoxS(in vec3 p, in vec3 b, float r){\n\n  vec3 d = abs(p) - b + r;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - r;\n}\n\n// Object rotation, with some optional mouse movement.\nvec3 objRot(vec3 p){\n\n    // Mouse movement.\n    if(iMouse.z>1.){\n        p.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        p.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n\n    // The object originally sat in the XZ plane, so rather than rearrange\n    // the coordinate system, I've lazily applied some quick rotation.\n    p.yz = rot2(-PI/2.)*p.yz;\n    p.xz = rot2(iTime/2.)*p.xz; \n    return p;\n\n}\n\n \n// Create multiple copies of an object - https://iquilezles.org/articles/sdfrepetition/\nvec2 opRepLim( in vec2 p, in float s, in vec2 lima, in vec2 limb ){\n   \n    return p - s*clamp(floor(p/s + .5), lima, limb);\n}\n\n\n\n \n// Texture coordinates. It's easier to save them in the distance field and\n// reuse them later, rather than recalculate them all over again. The downside\n// is expense, but it's not really noticeable here.\nvec2 txCoord;\n \n\n// Scene distance function.\nfloat map(vec3 p){\n    \n\n    /*\n    // Raised background to match the pattern. Interesting,\n    // but not suited to this example.\n    float sf = bgPat2(p.xy, 0.);\n    sf = smoothstep(-.125, .125, sf);// + sf;\n    float fl = -p.z + 2.;// - sf*.05;\n    */\n    \n    float fl = -p.z + 2.;// - sf*.05;\n    \n    \n    // Rotate the object.\n    vec3 rP = objRot(p);\n    \n    // Number of toroidal twists. Smaller half number multiples will work.\n    float twists = 1.5;\n \n    \n    // Toroidal strip dimensions.\n    vec2 dim = vec2(.1, .1);\n    float r = .35; // Toroidal radius.\n    \n    // Disc coordinates.\n    vec3 q = rP; \n    vec2 tc = vec2(length(q.xz) - r, rP.y);\n    \n    \n    // Disc repeat.\n    vec3 q2 = rP;\n    float aN = 48.; // 48 repeat square planes.\n    float a = mod(atan(q2.z, q2.x), TAU);\n    float na = (floor(a*aN/TAU) + .5)/aN;\n    float sR = r*TAU/aN;\n    \n    // Construct repeat cells about the larger toroidal axis.\n    q2.xz *= rot2(-na*TAU);\n    q2.x -= r; // Move out from the center by the large radial distance.\n    \n    // Twist each repeat plane about the smaller poloidal axis. Comment\n    // this line out to see what it does, if you're not sure.\n    q2.xy *= rot2(-na*TAU*twists/2. + iTime*.5);  \n\n    // Split each repeat plane into 5-by-5 repeat cells sing IQ's clamped\n    // repeat object formula.\n    q2.xy = opRepLim(q2.xy, sR, vec2(-2), vec2(2));\n   \n \n    // Construct a tiny spherical object in each cell.\n    float bead = length(q2) - r*TAU/aN*.65;\n    // Option rouded cubes.\n    //float dimR = r*TAU/aN*.6;\n    //float bead = sBoxS(q2, vec3(dimR), dimR*.65);\n       \n    // Creating a solid toroidal object, mostly for debug purposes, by\n    // is used for texturing as well.\n    tc *= rot2(-a*twists/2. + iTime*.5); // Twisting the toroidal plane itself.\n    \n    \n    // Saving some polar coordinates to use for texturing.\n    float ux = abs(tc.x) - dim.x<abs(tc.y) - dim.y? tc.x : tc.y; \n    txCoord = vec2(ux, a/TAU);\n    \n    \n    // Used for debugging.\n    \n    // Solid toroidal object. Uzed for texture debugging.\n    float tor = 1e5;\n    //float tor = sBoxS(tc, dim + .01, .03); // Creating the solid central strip.\n    \n    // Debugging. Take the beads out of the scene.\n    //bead = 1e5;\n    \n   \n     // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(fl, bead, tor, 1e5);\n    \n    // Shortest distance.\n    return  min(min(fl, bead), tor);\n \n}\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n   \n    for(int i = ZERO; i<96; i++){\n    \n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.8; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t){\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = ZERO; i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n \n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable.\n    const int maxIter = 32; \n    \n    // Bumping the ray off the surface to avoid self collisions.\n    // The constant coincides with the hit condition in the \"trace\" function. \n    ro += n*.0015; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.; // Initial shadow value.\n    float t = 0.; // Initial distance.\n    float end = max(length(rd), 0.0001); // Distance from the jump point to the light.\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down.\n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this.\n        // So many options here, and none are perfect: \n        // dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Return the shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break; // Faux exit.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n/////\n// Code block to produce some layers of fine mist. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\nfloat trig3(in vec3 p){\n\n    p = cos(p*2. + (sin(p.yzx) + 1. + vec3(-.15, 1, .5)*iTime*2.)*1.57);\n    return dot(p, vec3(.1666)) + .5;\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p){\n\n    // 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.25, -0.866, 0.433, 0.9665, 0.25, -0.2455127, \n                                 -0.058, 0.433, 0.899519 )*1.5;\n  \n\tfloat res = 0.;\n    \n    float t = trig3(p*PI);\n\tp += (t - iTime*.25);\n    p = m3RotTheta*p;\n    //p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p*PI); \n\tp += (t - iTime*.25)*.7071;\n    p = m3RotTheta*p;\n     //p = (p+0.7071)*1.5;\n    res += t*.7071;\n\n    t = trig3(p*PI);\n\tres += t*.5;\n\t \n\treturn res/2.2071;\n}\n\n// Some layers of cheap trigonometric noise to produce some subtle mist.\n// Start at the ray origin, then take some samples of noise between it and \n// the surface hit point. Apply some very simplistic lighting along the way.  \n// It's not particularly well thought out, but it doesn't have to be.\nvec3 getMist(in vec3 ro, in vec3 rd, in vec3 lp, in vec3 lp2, in float t){\n\n    vec3 mist = vec3(0);\n    \n    //vec3 lCol1 = vec3(1, .1, .05);\n    //vec3 lCol2 = vec3(.2, .4, 1);\n    \n    for (int i = 0; i<8; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp - ro)/1.; \n\t    vec3 sAtt = .5/(1. + sDi*.25 + sDi*sDi*.15)*vec3(1);\n        \n        sDi = length(lp2 - ro)/1.; \n        vec3 sAtt2 = .5/(1. + sDi*.25 + sDi*sDi*.15)*vec3(1);\n        \n\t    // Noise layer.\n        mist += trigNoise3D(ro)*(sAtt + sAtt2)/8.;\n        // Advance the starting point towards the hit point.\n        ro += rd*t/8.;\n        \n        // A bit of vortex action.\n        //rd.xy *= rot2(rd.z*.05);\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return max(mist + hash31(ro)*.1 - .05, 0.);\n\n} \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // \"Look At\" position.\n    vec3 ro = lk + vec3(cos(iTime/2.)*.05, .2, -1.5); // Camera position.\n \tvec3 lp = lk + vec3(2, 1, 1); // Light position. // Red.\n \tvec3 lp2 = lk + vec3(-2, 1, -.35); // Light position. // Blue.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n   \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the texture coordinates.\n    vec2 svTxCoord = txCoord;\n    \n\n    // Obtain the object ID.\n    objID = 0;\n    float obD = vID[0];\n    \n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\t    vec3 ld2 = lp2 - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n\t    float lDist2 = max(length(ld2), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n \t    ld2 /= lDist2;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n        float sh2 = softShadow(sp, lp2, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 4./(1. + lDist*.25);\n\t    float atten2 = 4./(1. + lDist2*.25);\n\n        /*\n    \t// Regular lighting.\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n\t    float diff2 = max( dot(sn, ld2), 0.);\n\n        // Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    float spec2 = pow(max(dot(reflect(ld2, sn), rd ), 0.), 32.); \n        */\n        \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // Object coloring. \n        \n        if(objID==0){ // Background wall.\n            \n            // Background coloring and texturing.\n            \n            //vec3 tx = texture(iChannel0, txP.xy/3. + vec2(.25, .5), 0.).xyz; tx *= tx;\n            vec3 tx = getTex(iChannel0, sp.xy/3. + vec2(.25, .5));\n             \n            texCol = vec3(.8, 1, 1.2)*(tx*2. + .1)/8.;\n            \n            // Applying a simple wavy background pattern. The blurry background\n            // almost makes it redundant, but it's there anyway.\n            float pat = bgPat(sp.xy, 0.);\n   \n            // Applying the pattern to the backgrorund plane.\n            texCol = mix(texCol, texCol*.85, 1. - smoothstep(0., .01, pat));\n            \n            // Regular lighting.\n            //spec /= 64.;\n            //spec2 /= 64.;\n            \n           \n        }\n        else if(objID==1){ //  Mobius beads.\n        \n            // Using the saved coordinates from the distance function \n            // to texture the mobius bands. The sides aren't technically\n            // correct, but no one will notice.\n            vec3 tx = getTex(iChannel0, svTxCoord*vec2(2, 4)); \n            \n            // Graphite.\n            texCol = vec3(.075)*(tx*2. + .05);\n            \n            // Regular lighting.\n            //diff *= diff;\n            //diff2 *= diff2;\n            \n            \n        }\n        else { // Solid Mobius strip, if not hidden.\n         \n            // Using the saved coordinates from the distance function \n            // to texture the mobius strip.\n            vec3 tx = getTex(iChannel0, svTxCoord*vec2(2, 4));      \n             \n            // Coloring the individual blocks with the saved ID.\n            texCol = tx/2. + .02;             \n        }\n        \n        \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        //// https://www.shadertoy.com/view/ttGfz1\n        float am = pow(length(sin(sn*2.)*.5 + .5)/sqrt(3.), 2.)*.5; // Studio.\n\n        // Red and blue lights. It's an industry cliche, but effective.\n        vec3 lCol1 = vec3(1, .1, .05);\n        vec3 lCol2 = vec3(.2, .4, 1);\n       \n        /*\n        // Regular lighting.\n        \n        // Combining the above terms to produce the final color.\n        vec3 col1 = texCol*(diff*sh + am + spec*16.*sh);\n        // Shading.\n        col1 *= atten;\n        \n        vec3 col2 = texCol*(diff2*sh2 + am + spec2*16.*sh2);\n        // Shading.\n        col2 *= atten2;\n        */\n        \n        // BRDF.\n        \n        /////////\n        // Greyscale texture value -- used for varying surface roughness.\n        float gr = dot(texCol, vec3(.299, .587, .114));\n \n        // Material type: Dielectics, with varying roughnesss and reflectance.\n        float matType = 0., roughness = gr*2. + .105, reflectance = .725;\n        if(objID==0){\n           // Background use less reflectance and more roughness.\n           reflectance = .125;\n           roughness = gr*4. + .305;\n        }\n        \n\n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(texCol, sn, ld, -rd, matType, roughness, reflectance, vec3(4));\n\n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        vec3 col1 = (texCol*am*(sh*.5 + .5) + ct*(sh))*atten;\n\n\n            // Cook-Torrance based lighting.\n        vec3 ct2 = BRDF(texCol, sn, ld2, -rd, matType, roughness, reflectance, vec3(1));\n\n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        vec3 col2 = (texCol*am*(sh2*.5 + .5) + ct2*(sh2))*atten2;\n        \n        //////\n        \n        \n\n        // Applying the colored lights to the respective lit materials.\n        col = (lCol1*col1 + lCol2*col2)*ao;\n        \n\n\t}\n    \n    // Blend the scene and the background with some very basic, 4-layered fog.\n    vec3 mist = getMist(ro, rd, lp, lp2, t);\n    vec3 fog = mist*(col*4. + vec3(1)*.05);//vec3(2.5, 1.75, .875)* mix(1., .72, mist)*(rd.y*.25 + 1.);\n    col = mix(col, fog, smoothstep(0., 1., t/6.));\n    \n    // Simpler fog, sans mist.\n    // Fog -- A bit redundant here, but it does have a minor effect.\n    //vec3 fog = vec3(0);\n    //col = mix(col, fog, smoothstep(0., .99, t/FAR));\n    \n    \n    // Save to \"Buffer A\" for post processing and gamma correction.\n    fragColor = vec4(clamp(col, 0., 1.), t);\n    \n    /*       \n    // Temporal blur. Requires adding \"Buffer A\" to \"iChannel1\".\n    vec4 preCol = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./4.; \n    fragColor = mix(preCol, vec4(max(col, 0.), t), blend);\n    */\n    \n\t\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "///////////////////////////\n#define PI 3.14159265\n#define TAU 6.2831853\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef, vec3 lCol){\n     \n    vec3 h = normalize(v + l); // Half vector.\n\n    // Standard BRDF dot product calculations.\n    float nv = clamp(dot(n, v), 0., 1.);\n    float nl = clamp(dot(n, l), 0., 1.);\n    float nh = clamp(dot(n, h), 0., 1.);\n    float vh = clamp(dot(v, h), 0., 1.);  \n\n\n    // Specular microfacet (Cook- Torrance) BRDF.\n    //\n    // F0 for dielectics in range [0., .16] \n    // Default FO is (.16 * .5^2) = .04\n    // Common Fresnel values, F(0), or F0 here.\n    // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n    // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n    // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n    vec3 f0 = vec3(.16*(fresRef*fresRef)); \n    // For metals, the base color is used for F0.\n    f0 = mix(f0, col, type);\n    vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n    // Microfacet distribution... Most dominant term.\n    float D = D_GGX(nh, rough); \n    // Geometry self shadowing term.\n    float G = G_Smith(nv, nl, rough); \n    // Combining the terms above.\n    vec3 spec = F*D*G/(4.*max(nv, .001));\n\n\n    // Diffuse calculations.\n    vec3 diff = vec3(nl);\n    diff *= 1. - F; // If not specular, use as diffuse (optional).\n    diff *= (1. - type); // No diffuse for metals.\n\n\n    // Combining diffuse and specular.\n    // You could specify a specular color, multiply it by the base\n    // color, or multiply by a constant. It's up to you.\n    return (col*diff + lCol*spec*PI);\n  \n}\n////////////////////\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    //f.xy = mod(f.xy, GRID_SIZE);\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n// Wavy repeat striped pattern.\nfloat bgPat(vec2 p, float tm){\n\n    // Overall pattern rotation.\n    p *= rot2(-PI/6.);\n    \n    // Scaling and translation.\n    const float gSc = 2.;\n    p *= gSc;\n    \n    // Stripe ID -- Not used here.\n    //vec2 ip = floor(p);\n \n    // Screen coordinate perturbation.    \n    vec2 offs = vec2(0, sin(p/gSc*PI*2. + cos(p.yx/gSc*PI*3. + tm)*PI/4.) )*.05*gSc;\n   \n    // Applying the UV offset above.    \n    p.xy -= offs;\n    p.y -= dot(sin(p - cos(p.yx*1.25 + tm)), vec2(.1));\n    \n    // Repeat line distance field.\n    float d = (abs(fract(p.y) - .5) - .2);\n    \n    // Experiments.\n    //if(mod(ip.y, 2.)==0.)\n    //if((ip.y)==2. || (ip.y)==-4.)\n    //d = max(d, -((abs(mod(p.x, 1.) - .5) - .2)));\n    //d = min(d + .05, abs(d - .04) - .04);\n    //if(abs(ip.y + 1.)>5.) d = 1e5;\n    \n    return d/gSc;\n    \n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}