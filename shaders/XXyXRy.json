{
    "Shader": {
        "info": {
            "date": "1720082099",
            "description": "combination of sources  https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/43GXRy",
            "flags": 1,
            "hasliked": 0,
            "id": "XXyXRy",
            "likes": 4,
            "name": "line change with synapsys",
            "published": 3,
            "tags": [
                "fractal",
                "line",
                "cosmos",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "\n\n#define iterations 13\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define S(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0., 1.);\n    return length(pa-ba*t);\n\n\n}\n\nfloat N21(vec2 p){\n    p=fract(p*vec2(233.34,851.73));\n    p+=dot(p,p+23.45);\n    return fract(p.x*p.y);\n\n}\n\nvec2 N22(vec2 p){\n    float n=N21(p);\n    return vec2(n,N21(p+n));\n\n}\n\nvec2 GetPos(vec2 id,vec2 offs){\n    \n    \n    vec2 n = N22(id+offs)*iTime;\n    \n    return offs+cos(n)*sin(n)*.5;\n\n}\nfloat Line(vec2 p,vec2 a, vec2 b){\n    float d = DistLine(p,a,b);\n    float m = S(.06,.01,d);\n    float d2 = length(a-b);\n    m *= S(2.2, .8, d2)+S(.05,.03,abs(d2-.75));\n    return m;\n\n}\nfloat Layer(vec2 uv){\n    float m =0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.;y<=1.;y++){\n        for(float x=-1.;x<=1.;x++){\n            p[i++] = GetPos(id,vec2(x,y));\n            \n        }\n    \n    }\n    float t = iTime*10.0;\n    for(int i=0;i<9;i++){\n        m+= Line(gv,p[4],p[i]);\n        vec2 j = (p[i] - gv)*15.;\n        float sparkle = 1./dot(j,j);\n        \n        m += sparkle*(sin(t+fract(p[i].x)*10.)*.5+.5);\n    \n    }\n    m+= Line(gv,p[1],p[3]);\n    m+= Line(gv,p[1],p[5]);\n    m+= Line(gv,p[7],p[3]);\n    m+= Line(gv,p[7],p[5]);\n    return m;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05) );// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.3-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n#define REFLECTION_NUMBER 40\n\nmat3 rotation(float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat3( c, -s, 0.,  s, c, 0.,  0., 0., 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\nvec2 mo = length(iMouse.xy - vec2(0.0)) < 1.0 ? vec2(0.0) : (iMouse.xy - iResolution.xy*.5)/iResolution.y*3.;\n    \n   \n    vec3 huv = vec3(uv, 0.);\n    huv *= rotation(iTime*.2);\n    \n    vec3 axisOrigin = vec3(0., 0., 1.);\n    vec3 axisDirection = vec3(normalize(vec2(1., 1.)), 0.);\n    \n    for(int i = 0; i < REFLECTION_NUMBER; i++)\n    {\n        float offset = (3.1415 * 2. / float(REFLECTION_NUMBER) ) * float(i);\n        float axisRotation = offset;\n    \tvec3 tuv = (huv - axisOrigin) * rotation(-axisRotation);\n    \tif(tuv.y < 0.)\n    \t{\n    \t\tvec3 invuv = tuv;\n        \tinvuv.y = -invuv.y;\n        \tinvuv = (invuv * rotation(axisRotation)) + axisOrigin;\n        \thuv = invuv;\n    \t}\n    }\n    \n    vec3 col2 = vec3(texture(iChannel0, huv.xy - vec2(iTime *.2, 0.) ));\n    \n    vec3 sky = vec3(texture(iChannel1, huv.xy)).xyz;\n    \n    col2 = mix(sky, col2, abs(sin(iTime/2.0)));\n\n    float gradient = uv.y;\n    float m = 0.;\n    float t = iTime*.1;\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c,-s,s,c);\n  ;\n\n    for( float i=0.;i<=1.;i+=1./7.){\n        float z=fract(i*i+t);\n        float size = mix(59.,.5,z);\n        float fade = S(0.,.2,z)*S(1.,.0,z);\n        m+=Layer(uv*size+i*200.)*fade;\n    }\n    vec3 base = sin(t*5.*vec3(.345,.456,.657))*.5+.6;\n    vec3 col = m*base;\n    col -=gradient*base;\n\tvec3 from=vec3(1.,.5,0.5);\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor*=vec4(col,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}