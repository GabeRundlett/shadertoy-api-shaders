{
    "Shader": {
        "info": {
            "date": "1524817190",
            "description": "Sliders control x- and y-axis frequencies (use to clear image after resize)",
            "flags": 32,
            "hasliked": 0,
            "id": "4s3fW8",
            "likes": 8,
            "name": "Variable Lissajous Figures",
            "published": 3,
            "tags": [
                "interactive",
                "graph",
                "lissajous"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 657
        },
        "renderpass": [
            {
                "code": "// \"Variable Lissajous Figures\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nfloat PrCylDf (vec3 p, float r, float h);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec4 LoadTx (vec2 uv);\nvec4 Loadv4 (ivec2 idVar);\n\nvec3 ltDir, qHit;\nvec2 pPos;\nfloat dstFar, hue;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = PrBoxDf (q, vec3 (1., 0.005, 1.));\n  DMINQ (1);\n  d = max (PrBoxAn2Df (q.xz, vec2 (1.02), 0.03), abs (q.y - 0.04) - 0.06);\n  DMINQ (2);\n  q = p;\n  q.xz -= pPos;\n  q.y -= 0.1;\n  d = PrCylDf (q.xzy, 0.02 * (1. + 0.5 * q.y / 0.1), 0.1);\n  DMINQ (3);\n  q = p;\n  q.y -= 0.06;\n  d = min (PrCylDf ((q - vec3 (0., 0.005, pPos.y)).yzx, 0.005, 1.05),\n     PrCylDf (q - vec3 (pPos.x, -0.005, 0.), 0.005, 1.05));\n  DMINQ (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0003 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj;\n  pPos = Loadv4 (ivec2 (0, 0)).rg;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = (vn.y > 0.99) ? LoadTx (0.5 * qHit.xz + 0.5) : vec4 (0.4, 0.4, 0.3, 0.1);\n    else if (idObj == 2) col4 = (abs (qHit.y - 0.06) < 0.01 && max (abs (qHit.x), abs (qHit.z)) < 1.01) ?\n       vec4 (0.4, 0.4, 0.4, 0.) : vec4 (0.8, 0.7, 0.7, 0.2);\n    else if (idObj == 3) col4 = (vn.y > 0.99 && length (qHit.xz) < 0.02) ?\n       vec4 (HsvToRgb (vec3 (hue, 1., 1.)), 0.2) : vec4 (0.7, 0.5, 0.2, 0.2);\n    else if (idObj == 4) col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec2 freq)\n{\n  vec4 wgBx[2];\n  vec3 cc;\n  vec2 ut, ust;\n  float vW[2], asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.4 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[1] = vec4 (0.45 * asp, 0., 0.012 * asp, 0.18);\n  vW[0] = freq.x / 20.;\n  vW[1] = freq.y / 20.;\n  for (int k = 0; k < 2; k ++) {\n    cc = vec3 (0.1, 1., 0.1);\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = vec3 (0.3);\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? vec3 (1., 1., 0.) : vec3 (0.6);\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 1.5);\n    if (max (abs (ut.x), abs (ut.y)) < 0.02 && max (ut.x, ut.y) > 0.013) col = cc;\n    col = mix (col, cc, ShowInt (0.5 * uv - (wgBx[k].xy + wgBx[k].zw) * vec2 (1., -1.) -\n       vec2 (-0.001, -0.06), 0.028 * vec2 (asp, 1.), 2., clamp (floor (20. * vW[k]), 0., 20.)));\n  }\n  return col;\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) * (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa, freq;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  stDat = Loadv4 (ivec2 (0, 0));\n  freq.x = stDat.z;\n  freq.y = stDat.w;\n  stDat = Loadv4 (ivec2 (2, 0));\n  ori = vec2 (stDat.x, stDat.y);\n  hue = stDat.z;\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -9.);\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n  rd = vuMat * normalize (vec3 (uv, 8.));\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, freq);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.7, 2.3);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvec4 Loadv4 (ivec2 idVar)\n{\n  return texture (txBuf, (vec2 (idVar) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Variable Lissajous Figures\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec3 HsvToRgb (vec3 c);\nvec4 LoadTx (vec2 uv);\nvec4 Loadv4 (ivec2 idVar);\nvoid Savev4 (ivec2 idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 pPos, freq;\nfloat hue, iFrameS;\nconst float pi = 3.14159;\n\nvec4 ShowScene (vec2 uv, vec4 col)\n{\n  float t;\n  t = 2. * pi * (0.003 / max (1., length (freq))) * (float (iFrame) - iFrameS);\n  pPos = 0.93 * vec2 (cos (freq.x * t), sin (freq.y * t));\n  hue = mod (0.55 * t, 1.);\n  if (length (2. * (uv - 0.5) - pPos) < 0.01) col = vec4 (HsvToRgb (vec3 (hue, 1., 1.)), 1.);\n  return col;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 wgBx[2], mPtr, mPtrP, stDat;\n  vec2 canvas, uvtx, ust;\n  ivec2 iFrag;\n  float tCur, asp, el, az, vW;\n  int wgSel, wgReg, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  uvtx = fragCoord / txSize;\n  iFrag = ivec2 (fragCoord);\n  doInit = (iFrame <= 5);\n  wgSel = -1;\n  wgReg = -2;\n  if (doInit) {\n    freq = vec2 (9., 7.);\n    mPtrP = mPtr;\n    az = 0.;\n    el = -0.5 * pi;\n  } else {\n    stDat = Loadv4 (ivec2 (0, 0));\n    freq.x = stDat.z;\n    freq.y = stDat.w;\n    stDat = Loadv4 (ivec2 (1, 0));\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (ivec2 (2, 0));\n    el = stDat.x;\n    az = stDat.y;\n    iFrameS = stDat.w;\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.4 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[1] = vec4 (0.45 * asp, 0., 0.012 * asp, 0.18);\n    for (int k = 0; k < 2; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = 2. * pi * mPtr.x;\n      el = -0.5 * pi + 1.5 * pi * mPtr.y;\n    } else {\n      az = 0.;\n      el = -0.5 * pi;\n    }\n  } else {\n    if (wgSel < 2) {\n      for (int k = 0; k < 2; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = 0.05 * floor (20. * clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0.05, 0.95));\n          break;\n        }\n      }\n      if      (kSel == 0) freq.x = 20. * vW;\n      else if (kSel == 1) freq.y = 20. * vW;\n      doInit = true;\n    }\n  }\n  if (doInit) iFrameS = float (iFrame);\n  fragColor = ShowScene (uvtx, doInit ? vec4 (0.1, 0.1, 0.1, 0.) : LoadTx (uvtx));\n  if (iFrag.y == 0 && iFrag.x <= 2) {\n    if (iFrag.x == 0) stDat = vec4 (pPos, freq);\n    else if (iFrag.x == 1) stDat = vec4 (mPtr.xyz, float (wgSel));\n    else if (iFrag.x == 2) stDat = vec4 (el, az, hue, iFrameS);\n    Savev4 (iFrag, stDat, fragColor, fragCoord);\n  }\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvec4 Loadv4 (ivec2 idVar)\n{\n  return texture (txBuf, (vec2 (idVar) + 0.5) / txSize);\n}\n\nvoid Savev4 (ivec2 idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vec2 (idVar) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}