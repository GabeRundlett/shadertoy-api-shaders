{
    "Shader": {
        "info": {
            "date": "1516528045",
            "description": "it's wrong that pentagon can't tile the plane ( true for *regular* pentagons ). ;-) \n\nInspired by [url]http://www.ianislallemand.com/projects/design/generative-tilings[/url]\nMore here: [url]http://mathworld.wolfram.com/PentagonTiling.html[/url]\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ltBBzK",
            "likes": 20,
            "name": "pentagonal tiling",
            "published": 3,
            "tags": [
                "tiling",
                "short",
                "pentagon"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 819
        },
        "renderpass": [
            {
                "code": "// inspired by http://www.ianislallemand.com/projects/design/generative-tilings\n// http://mathworld.wolfram.com/PentagonTiling.html\n\n//#define S(v) smoothstep(3., 0., abs(v)/fwidth(v))\n#define s(v) smoothstep(e, 0., v)                    // draw AA region v<0\n#define S(v) s(abs(v))                               // draw AA line v=0\n#define l(x,y,a,b) dot( vec2(x,y), normalize(vec2(a,b)) ) // line equation\n#define L(x,y,a,b) S(l(x,y,a,b))                     // draw line equation\n//#define P(x,y,a,b) s(l(x,y,a,b))                   // draw region under line\n#define P(x,y,a,b) step(l(x,y,a,b),0.)               // draw region under line\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tU *= 10./iResolution.y;\n\tfloat h = (sqrt(3.)+1.)/2., \n          c = sqrt(3.)-1., r=h+c/2., // NB: r = sqrt(3)\n          e =  15./iResolution.y, b, i,v;\n    vec2 T = mod(U, r+r)-r, V = abs(T);              // first tile in bricks\n                                                     // center = 1 supertile, corners = 1/4 neighboor supertiles\n\n    O.r = P( V.x, V.y-h, -(c/2.-h), r );             // id 0-7 in supertile\n    O.g = P( V.x-c/2., V.y, -sqrt(3.), 1 );\n    i = step(.5,O.r) + 2.*step(.5,O.g);\n    O.b = float(    (i==1. && T.y>0.)                // <><> not antialiased\n                 || (i==3. && T.x>0.)                // -> re#def P()\n                 || (i==0. && T.x>0.)\n                 || (i==2. && T.y>0.)  );\n\n    U = floor(U/(r+r))* 2.;                          // supertile id\n    if (O.r==0.) U += sign(T);\n    //O = vec4(U,0,0)/4.;\n\n    i = (O.r + 2.*O.g + 4.*O.b) + 8.*(U.x + 12.*U.y); // tile id\n  //i = (O.r + 2.*O.g + 4.*O.b)*8.1 +(U.x + 12.*U.y); \n  //i = O.r + 1.7*O.g + 4.3*O.b + 8.7* (U.x + 12.7*U.y);\n    O = .6 + .6 * cos( i  + vec4(0,23,21,0)  );      // -> color\n    O *= .4+.6*fract(1234.*sin(43.*i));\n\n    b = float(  S(V.x)   * step(h,V.y)               // tiles border\n              + S(r-V.x) * step(V.y,c/2.) \n              + L( V.x, V.y-h, -(c/2.-h), r )\n              + S(V.y)   * step(V.x,c/2.)\n              + S(r-V.y)  * step (r-V.x,c/2.)\n              + L( V.x-c/2., V.y, -sqrt(3.), 1 )\n             );\n    O *= 1.-b;                                      // draw border           \n}\n\n\n/*  O = vec4(   ( V.x < e && V.y > h ) \n             || ( V.x > r-e &&  V.y < c/2. )\n             || abs((V.y-h)*r-(c/2.-h)*V.x) < e\n             || ( V.x < c/2. && V.y < e )\n             || ( V.x > r-c/2. && V.y > r-e )\n             || abs(V.y - (V.x-c/2.)*sqrt(3.)) < e\n            );\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}