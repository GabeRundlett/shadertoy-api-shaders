{
    "Shader": {
        "info": {
            "date": "1572542139",
            "description": "a tunnel inspired by hexeosis psy loop visuals",
            "flags": 0,
            "hasliked": 0,
            "id": "tsdSRf",
            "likes": 9,
            "name": "Shadertober 30 Catch",
            "published": 3,
            "tags": [
                "raymarching",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 495
        },
        "renderpass": [
            {
                "code": "// SHADERTOBER 30 Catch\n// Poulet vert 31-10-2019\n// thanks iq for sdf functions\n// inspired by hexeosis psy loop visuals\n\n#define VOLUME 0.001\n#define PI 3.14159\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Scene setup\nvec2 map(vec3 p)\n{\n    // base full world\n    vec3 bp = p + vec3(0.0);\n    bp = opRep(bp, vec3(1.0));\n    float b = sdBox(bp, vec3(1.0));\n    \n    // tunnels\n    vec3 tp = p + vec3(0.0);\n    tp = opRep(tp, vec3(0.0, 0.0, 1.0));\n    float t = sdBox(tp, vec3(1.0));\n    \n    tp = p + vec3(1.0, 0.0, 0.0);\n    tp = opRep(tp, vec3(0.0, 0.0, .5));\n    t = min(t, sdBox(tp, vec3(.5)));\n    \n    tp = p + vec3(-1.0, 0.0, 0.0);\n    tp = opRep(tp, vec3(0.0, 0.0, .5));\n    t = min(t, sdBox(tp, vec3(.5)));\n    \n    tp = p + vec3(0.0, 1.0, 0.0);\n    tp.xy *= rot(PI/4.0);\n    tp = opRep(tp, vec3(0.0, 0.0, .5));\n    t = min(t, sdBox(tp, vec3(.5)));\n    \n    tp = p + vec3(0.0, -1.0, 0.0);\n    tp.xy *= rot(PI/4.0);\n    tp = opRep(tp, vec3(0.0, 0.0, .5));\n    t = min(t, sdBox(tp, vec3(.5)));\n    \n    b = max(b, -t);\n    \n    // lines\n    vec3 lp = p + vec3(1.5, 0.0, 0.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 2.0));\n    float l = sdBox(lp, vec3(0.1, .5, 1.0));\n    \n    lp = p + vec3(-1.5, 0.0, 0.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 2.0));\n    l = min(l, sdBox(lp, vec3(0.1, .5, 1.0)));\n    \n    lp = p + vec3(0.0, 1.0, 0.0);\n    lp.xy *= rot(PI/4.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 2.0));\n    l = min(l, sdBox(lp, vec3(0.5, .5, 1.0)));\n    \n    lp = p + vec3(0.0, 0.9, 0.0);\n    lp.xy *= rot(PI/4.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 1.0));\n    l = max(l, -sdBox(lp, vec3(0.5, .5, 1.0)));\n    \n    lp = p + vec3(0.0, -1.0, 0.0);\n    lp.xy *= rot(PI/4.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 2.0));\n    l = min(l, sdBox(lp, vec3(0.5, .5, 1.0)));\n    \n    lp = p + vec3(0.0, -0.9, 0.0);\n    lp.xy *= rot(PI/4.0);\n    lp = opRep(lp, vec3(0.0, 0.0, 1.0));\n    l = max(l, -sdBox(lp, vec3(0.5, .5, 1.0)));\n    \n    // torus\n    vec3 ap = p + vec3(0.0);\n    ap.yz *= rot(PI/2.0);\n    ap = opRep(ap, vec3(0.0, 1.0, 0.0));\n    float a = sdTorus(ap, vec2(3.0, .1));\n    \n    // rooms\n    vec3 rp = p + vec3(0.0);\n    rp = opRep(rp, vec3(0.0, 0.0, 10.0));\n    float r = sdBox(rp, vec3(5.0, 5.0, 2.0));\n    \n    b = max(b, -r);\n    l = max(l, -r);\n    \n    \n    // Materials\n    vec2 scene = vec2(b, 0.0);\n    scene = opU2(scene, vec2(l, 1.0));\n    scene = opU2(scene, vec2(a, 2.0));\n    \n    return scene;\n}\n\nvec3 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec3(t, ray.y, float(i)/128.);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec3(-1.0, 0.0, 0.0);\n}\n\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x) - c);\n}\n\nfloat GetLight(vec3 N, vec3 lightPos)\n{\n    return max(dot(N, normalize(lightPos)), 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(fract(floor(pos.z)*.05), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    polyCol *= step(fract(pos.z+.1), .8);\n    \n    if(t.x == -1.0)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {    \n        vec3 N = GetNormal(pos);\n        \n        vec3 mainL = vec3(1.0, 1.0, 0.0);\n        float mainlight = GetLight(N, mainL);\n        \n        vec2 ledFreq = vec2(.15, .17);\n        vec2 ledUV =  vec2(-pos.x+5.08, -pos.y-.5);\n        \n        float depth = t.z;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(1.0)*mainlight*.5+.5;\n            col.y -= uv.y;\n            col *= .1;\n        }\n        else if(t.y == 1.0) // effect\n        {\n            col = polyCol;\n            \n        }\n        else if(t.y == 2.0) // effect\n        {\n            col = vec3(1.0);\n            col.x = uv.y;\n            \n        }\n        \n        col *= 1.0-t.z;\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    float time = iTime * 10.0;\n    \n    \n    vec3 cp = vec3(0.0, 0.0, time-5.0);\n    vec3 ct = vec3(0.0, 0.0, time);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    vec3 gradient = mix(vec3(1.0, 0.25, 0.3), vec3(0.3, 0.1, 1.0), -uv.y);\n    \n    col *= gradient;\n    \n    col = sqrt(clamp(col, 0.0, 1.0));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}