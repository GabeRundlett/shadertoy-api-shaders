{
    "Shader": {
        "info": {
            "date": "1475190036",
            "description": "Based on [url=https://www.shadertoy.com/view/llG3zy]Faster Voronoi Borders[/url] and my older [url=https://www.shadertoy.com/view/4lBXRV]15th Pentagonal Tiling[/url] shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtK3RG",
            "likes": 26,
            "name": "Voronoi Floor Tiling",
            "published": 3,
            "tags": [
                "voronoi",
                "tiling"
            ],
            "usePreview": 1,
            "username": "tomkh",
            "viewed": 1461
        },
        "renderpass": [
            {
                "code": "// Voronoi Floor Tiling \n// by Tom'2016\n\n// Based on https://www.shadertoy.com/view/llG3zy (Faster Voronoi Borders)\n// and https://www.shadertoy.com/view/4lBXRV (my older 15th Pentagonal Tiling)\n\n// Do you like colors? \n//  Put 0 if not ;)\n//  Put 1 for 12 colors\n//  Put 2 for 6 colors\n#define USE_COLORS 2\n\n#define ANIMATE 1\n#define ANIM_SPEED .25\n\nconst int iterations = 64;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = .04;\nconst float fog_start = 16.;\n\nconst float cam_dist = 13.5;\n\n//---------------------------------------------\n// Tiling code\n\nvec2 hash2(vec2 p)\n{\n#if ANIMATE == 0\n   // Dave Hoskins hash as in https://www.shadertoy.com/view/4djSRW\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y))*.9+.05;\n#elif 1\n   // Dave Hoskins hash with animation\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   vec2 v = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n   #if 1\n   return sin(iTime*ANIM_SPEED + v*6.283185)*.45 + .5;\n   #else\n   // This version doesn't work, but if we switch \"v\" and \"6.283185\" it works ?!\n   return sin(iTime*ANIM_SPEED + 6.283185*v)*.45 + .5;\n   #endif\n#else\n   // Texture-based\n   vec2 v = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n   return sin(iTime*ANIM_SPEED + 6.283185*v)*.45 + .5;\n#endif\n}\n\n// Faster variant based on Inigo Quilez's implementation,\n// see https://www.shadertoy.com/view/llG3zy for explanation\nvec2 dTile( vec2 x )\n{\n    x *= .7;\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.0001 ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec2( n.x + mg.x, md*1.5 );\n}\n\n//---------------------------------------------\n\nconst float bump = .1;\nconst float ground = .2;\n\nfloat dField(in vec3 p)\n{\n   float d = p.y + ground;\n   \n   vec2 tile = dTile(p.xz);\n   float d3;\n   //d3 = min(.05,smoothstep(0.,1.,tile.y*20.)*.05)*.5;\n   d3 = min(.05,tile.y)*.5;\n   d3 += tile.y*.3;\n   d3 = min(d3,bump);\n   //d3 = smoothstep(0.,1.,d3/cut)*cut;\n   d -= d3;\n   return d;\n}\n\nvec3 dNormal(in vec3 p, in float eps)\n{\n   vec2 e = vec2(eps,0.);\n#if 0\n   // less pleasent, but faster\n   e.x *= 2.;\n   float v = dField(p);\n   return normalize(vec3(\n      dField(p + e.xyy) - v,\n      dField(p + e.yxy) - v,\n      dField(p + e.yyx) - v ));\n#else\n   return normalize(vec3(\n      dField(p + e.xyy) - dField(p - e.xyy),\n      dField(p + e.yxy) - dField(p - e.yxy),\n      dField(p + e.yyx) - dField(p - e.yyx) ));\n#endif\n}\n\nvec4 trace(in vec3 ray_start, in vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   \n   // Intersect with ground plane first\n   \n   if (ray_dir.y >= 0.) return vec4(0.);\n   \n   float dist;\n   dist = (ray_start.y + ground - bump)/-ray_dir.y;\n   p += dist*ray_dir;\n   ray_len += dist;\n   if (ray_len > ray_max) return vec4(0.);\n   //return vec4(p, ray_len);\n   \n   for(int i=0; i<iterations; ++i) {\n   \t  dist = dField(p);\n      if (dist < dist_eps*ray_len) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, ray_len);\n}\n\nvec3 shade(in vec3 ray_start, in vec3 ray_dir,\n   in vec3 light_dir, in vec3 fog_color, in vec4 hit)\n{   \n   vec3 dir = hit.xyz - ray_start;\n   vec3 norm = dNormal(hit.xyz, .015);//*hit.w);\n   float diffuse = max(0.0, dot(norm, light_dir));\n   float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n   spec = pow(spec, 32.0)*.7;\n\n   vec2 tile = dTile(hit.xz);\n   float sh = tile.x;\n#if USE_COLORS == 2\n   sh = (abs(mod(sh+6.,12.)-6.)+2.5)*(1./9.);\n#else\n   sh = mod(sh,12.)*(1./12.);\n#endif\n   float sd = min(tile.y,.05)*20.;\n#if USE_COLORS == 0\n   vec3 base_color = vec3(.5);\n#else\n   // Ken Silverman's EvalDraw colors ;)\n   vec3 base_color =\n    vec3(exp(pow(sh-.75,2.)*-10.),\n         exp(pow(sh-.50,2.)*-20.),\n         exp(pow(sh-.25,2.)*-10.));\n#endif\n   vec3 color = mix(vec3(0.),vec3(1.),diffuse)*base_color +\n      spec*vec3(1.,1.,.9);\n   color *= sd;\n   \n   float fog_dist = max(0.,length(dir) - fog_start);\n   float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n   color = mix(color, fog_color, fog);\n\n   return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, .25));\n   \n   // Simple model-view matrix:\n   float ms = 2.5/iResolution.y;\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -ms :\n      -iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat3 cam_mat = mat3(\n      co, 0., si,\n      0., 1., 0.,\n     -si, 0., co);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y) * -ms - .1:\n      cos(-iTime*.5)*.4 + .8;\n   ang = max(0.,ang);\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat3(\n      1., 0., 0.,\n      0., co, si,\n      0.,-si, co);\n\n   vec3 pos = cam_mat*vec3(0., 0., -cam_dist);\n   vec3 dir = normalize(cam_mat*vec3(uv, 1.));\n\n   vec3 color;\n   vec3 fog_color = vec3(min(1.,.4+max(-.1,dir.y*.8)));\n   vec4 hit = trace(pos, dir);\n   if (hit.w == 0.) {\n      color = fog_color;\n   } else {\n      color = shade(pos, dir, light_dir, fog_color, hit);\n   }\n   \n   // gamma correction:\n   color = pow(color,vec3(.7));\n   \n   fragColor = vec4(color, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}