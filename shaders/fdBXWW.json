{
    "Shader": {
        "info": {
            "date": "1620184129",
            "description": "www.twitch.com/kanjicoder     <--Render Engine\nhttps://d3m0.herokuapp.com/  <--Tech Demos\nCompositing box gradients to create two box wire frames. Pinching those wire frames. And then rotating them in opposite directions by rotating their input UVs.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdBXWW",
            "likes": 0,
            "name": "Rotating Hour Glasses",
            "published": 3,
            "tags": [
                "rotation",
                "boxgradient"
            ],
            "usePreview": 0,
            "username": "DEKTEN",
            "viewed": 225
        },
        "renderpass": [
            {
                "code": "//: www.twitch.com/kanjicoder\n//: Been working on a fractal auto tiling engine.\n//: I made a build system that allows me to compile C99 as\n//: C99 or GLSL. Which allows me to run unit tests on my\n//: shader code. Come give me a visit and I'll give you\n//: a technical demo and explain why I think I am up to\n//: something no one has ever done before.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //: org: origin\n    //: u_v: UV's as in UVW\n    //: sg1 , sg2 : Square_Gradient 1 & 2\n    //: ca1 , ca2 : Current Angles 1 & 2\n    //: l_1 , l_2 : lengths 1 & 2\n    //: uv1 , uv2 : u_v copies 1 & 2\n    //: c_1 , c_2 : Colors 1 & 2\n    //: t_1 , t_2 : Thickness 1 & 2\n    //: d_1 , d_2 : Distance 1 & 2\n    //: v_a ......: Variable \"A\" (yes, not creative at all)\n    \n    //:Center Gradient , copy UVs twice:\n        vec2  u_v = ((fragCoord.xy * 2.0)-iResolution.xy) / iResolution.y ;\n        vec2  uv1 = vec2( u_v );\n        vec2  uv2 = vec2( u_v );\n    \n    //:Rotate Two Sets Of UV's in opposite directions:\n    //:SEE[ https://www.shadertoy.com/view/Mt2XDK ]\n        vec2 org = vec2(0.0, 0.0) ;\n        float ca1 = -(iTime * 36.0); //:current_angle_1\n        float ca2 = +(iTime * 36.0); //:current_angle_2\n\n        uv1 -= org;\n        float ang_001 = radians(90.0) - radians(ca1) + atan(uv1.y, uv1.x);\n        float l_1 = length(uv1);\n        uv1 = vec2(cos(ang_001) * l_1, sin(ang_001) * l_1) + org;\n\n        uv2 -= org;\n        float ang_002 = radians(90.0) - radians(ca2) + atan(uv2.y, uv2.x);\n        float l_2 = length(uv2);\n        uv2 = vec2(cos(ang_002) * l_2, sin(ang_002) * l_2) + org;\n\n        uv1.x = uv1.x / ( uv1.y);\n        uv1.y = uv1.y / ( 0.5  );\n\n        uv2.x = uv2.x / ( 0.5  );\n        uv2.y = uv2.y / ( uv2.x);\n    \n    //:Create Square Gradients:\n        vec2  sg1 = vec2( max( abs(uv1.x),abs(uv1.y) ) );\n        vec3  c_1 = vec3( 1.0 );\n\n        vec2  sg2 = vec2( max( abs(uv2.x),abs(uv2.y) ) );\n        vec3  c_2 = vec3( 1.0 );\n    \n    //:Create Box Lines:\n        float t_1=(cos(iTime*1.0)*2.0); //:Thickness #1\n        float t_2=(sin(iTime*1.0)*2.0); //:Thickness #2\n     \n        float d_1 = length(sg1 - vec2(clamp(sg1.x,-.5,.5),0));\n        c_1 -= (smoothstep( 1.00-t_1 , 1.00         , d_1 )); //:blackBox\n        c_1 -= (smoothstep( 1.00-t_1 , 1.00-t_1-t_1 , d_1 )); //:Whitebox\n\n        float d_2 = length(sg2 - vec2(clamp(sg2.x,-.5,.5),0));\n        c_2 -= (smoothstep( 1.00-t_2 , 1.00         , d_2 )); //:blackBox\n        c_2 -= (smoothstep( 1.00-t_2 , 1.00-t_2-t_2 , d_2 )); //:Whitebox\n\n    //:Blend Two Patterns:\n        vec3 v_a =( c_1 + c_2 );\n  \n     fragColor = vec4( (v_a) , 1.0 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}