{
    "Shader": {
        "info": {
            "date": "1591974623",
            "description": "Cellular automaton particle tracking with full conservation of mass/energy and approximately particle number",
            "flags": 32,
            "hasliked": 0,
            "id": "3lsyW8",
            "likes": 19,
            "name": "Reintegration tracking",
            "published": 3,
            "tags": [
                "particles",
                "ca"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 563
        },
        "renderpass": [
            {
                "code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\n    vec4 U = decode(texel(ch0, pos).zw);\n    vec4 P = textureLod(ch1, pos/R, 0.);\n    vec4 D = pixel(ch2, pos);\n    float ang = atan(D.w, D.z);\n    float mag = length(D.zw);\n\tvec3 rho = vec3(1.,1.7,4.)*(0.*U.w+5.*smoothstep(0.2, 0.3, P.w));\n    // Output to screen\n    fragColor = vec4(sqrt(rho)*(0.15+hsv2rgb(vec3(ang, 1., mag))),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(x.x) + 65535u*uint(x.y);\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec4 decode(vec2 x)\n{\n    uint v = floatBitsToUint(x.x);\n    uint m = floatBitsToUint(x.y);\n    return vec4(unpack(v),unpack(m)*128.); \n}\n\nvec2 encode(vec4 x)\n{\n    uint v = pack(x.xy);\n    uint m = pack(x.zw/128.);\n    return vec2(uintBitsToFloat(v),uintBitsToFloat(m)); \n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define mass 0.1\n#define div 0.7\nfloat border(vec2 p)\n{\n    return -sdBox(p - R*0.5, R*0.5);\n}\n\n#define h 0.1\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z);\n}\n\nvec2 Force(vec2 dx)\n{\n    return 10.*dx*exp(-dot(dx,dx));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n        \n    //particle position\n    vec2 x = vec2(0.);\n    //particle velocity, mass and grid distributed density\n    vec4 vm = vec4(0.); \n    vec2 F = vec2(0., -0.0002);\n    vec2 dF = vec2(0.);\n    \n    //reintegration advection\n    //basically sum over all updated neighbors \n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n        vec2 x0 = data.xy; //update position\n        //how much mass falls into this pixel(is exact, 0 or full)\n        vm.w += vm0.z*G((pos - x0)/1.5);\n        float D = step(max(abs(pos.x - x0.x),\n                           abs(pos.y - x0.y)), 0.5);\n        vm0.z *= (vm0.z<4.*mass)?D:(0.25*step(max(abs(pos.x - x0.x),\n                          \t\t                  abs(pos.y - x0.y)), 1.002));\n        if(vm0.z>=4.*mass) \n        {\n            x0 = mix(x0, pos, 1.);\n        }\n           \n        //add weighted positions by mass\n        x += x0*vm0.z;\n        //add weighted velocities by mass\n        vm.xy += vm0.xy*vm0.z;\n        //add mass\n        vm.z += vm0.z;\n        dF += vm0.z*Force(pos - x0)*(1. - D);\n    }\n    \n    if(vm.z != 0.) //not vacuum\n    {\n        //normalize\n        x /= vm.z;\n        vm.xy /= vm.z;\n        \n        vec3 dx = vec3(-1.,0,1.);\n        vec2 px = x;\n        vec3 rand = hash32(pos+x)-0.5;\n        \n    \t//update velocity\n         //border \n    \tvec3 N = bN(px);\n        float vdotN = step(abs(N.z), 10.)*dot(N.xy, vm.xy);\n        vm.xy = vm.xy - 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n        F += N.xy*step(abs(N.z), 10.)/N.z;\n        \n        //global force field\n        \n        vec4 GF = pixel(ch1, px);\n\n        F += (-GF.xy + (GF.zw - vm.xy)*0.2 - 0.01*vm.xy*step(N.z, 15.)); \n        if(iMouse.z > 0.)\n        {\n            vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n            float d = distance(iMouse.xy, x)/20.;\n            F += 0.1*dm*exp(-d*d);\n        }\n   \t    vm.xy += 0.4*F*dt/(0.01+vm.z);\n        //velocity limit\n        float v = length(vm.xy);\n        vm.xy /= (v > 1.)?v:1.;\n        x += (vm.xy + dF)*dt;\n    }\n    else\n    {\n        x = pos;\n        vm.xyz = vec3(0.);\n    }\n    \n\n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.1) \n        {\n            x = pos;\n            vm = vec4(0.3*vec2(2.*rand.xy - 1.), 4.*mass, mass);\n        }\n        else\n        {\n            x = pos;\n        \tvm = vec4(0.);\n        }\n    }\n    \n    U = vec4(x, encode(vm));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Radius 3\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec4 avm = vec4(0.);\n    float sum = 1.;\n    range(i, -Radius, Radius)\n    {\n        ivec2 p = ivec2(pos) + ivec2(i,0);\n        if(p.x >= 0 && p.x < int(R.x))\n        {\n            float k = G(vec2(i,0)*1.5/float(Radius));\n            vec4 d = decode(texel(ch0, p).zw);\n        \tavm += vec4(d.xy*d.z, d.zw)*k;\n        \tsum += k;\n        }\n    }\n    U = avm/sum;\n    U.xy = avm.xy/(avm.z+0.0001); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Radius 3\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec4 avm = vec4(0.);\n    float sum = 1.;\n    range(i, -Radius, Radius)\n    {\n        ivec2 p = ivec2(pos) + ivec2(0,i);\n        float k = G(vec2(0,i)*1.5/float(Radius));\n        vec4 d = texel(ch0, p);\n        avm += vec4(d.xy*d.z, d.zw)*k;\n        sum += k;\n    }\n    U = avm/sum;\n    U.z = 0.5*U.z*clamp(pow(abs(U.z/0.07), 6.) - 1., -1., 1.); //water\n    //U.z = 1.2*U.z;//gas\n    U.xy = avm.xy/(avm.z+0.0001); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//force field\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n   vec3 dx = vec3(-1., 0., 1.);\n   U.xy = 0.5*vec2(texel(ch0, pos + dx.zy).z - texel(ch0, pos + dx.xy).z,\n                   texel(ch0, pos + dx.yz).z - texel(ch0, pos + dx.yx).z);\n   //average velocity\n   vec4 a = texel(ch0, pos); \n   U.zw = a.xy;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}