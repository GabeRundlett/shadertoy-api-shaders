{
    "Shader": {
        "info": {
            "date": "1683994859",
            "description": "The Barth sextic, seen as a stereographic projection from the hypersphere S³. Animation is applying a Clifford translation (one sided quaternion multiplication) to S³.\n\n Various controls, see code header.",
            "flags": 48,
            "hasliked": 0,
            "id": "DlXXR2",
            "likes": 26,
            "name": "Barth Sextic Surfaces",
            "published": 3,
            "tags": [
                "quaternion",
                "surface",
                "barth",
                "decic",
                "sextic"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 349
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////////////////////////\n//\n// Barth Sextic Surfaces.\n//\n// Barth discovered a 1-parameter family of sextic surfaces,\n// with 'the' Barth sextic corresponding to parameter k = 0.5\n// containing 65 nodes, the maximum possible for a surface of order 6.\n//\n// Here, the surface in ℙ³ is stereographically projected to ℝ³ via\n// the double cover of ℙ³ by S³. ie. point p = (x,y,z,w) on the\n// hypersphere corresponds to point in ℙ³ with homogeneous coordinates\n// (x,y,z,w) (which is also represented by -p on the hypersphere\n// so the surface is duplicated by the projection).\n//\n// <mouse>: rotate view of surface\n// <up>/<down>: zoom in/out\n// 'a': enable AA\n// 'c','t': align various surface features with rotation\n// 'k': animate surface parameter k\n// 'm': mirror effect (best with AA enabled)\n// 'q': toggle S³ quaternion rotation\n// 's': use projection (x,y,z,w) -> (x/w,y/w,z/w)\n//\n///////////////////////////////////////////////////////////\n\nbool doMirror = false;\nbool doGamma = true;\nbool doSpecular = true;\nbool doDiffuse = true;\n\nconst float ambient = 0.5;\nconst float diffuse = 0.5;\nfloat specpower = 4.0;\n\nconst vec3 defaultColor = vec3(0.7,1.0,1.0);\n\nconst float PI =  3.141592654;\nconst float TWOPI = 2.0*PI;\nconst float phi = 1.618033;\nconst float phi2 = phi*phi;\nconst float phi4 = phi2*phi2;\n\nvec3 light;\n\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec4 transform4(vec3 p3) {\n  vec4 p = vec4(p3,0);\n  if (key(CHAR_S)) {\n    p.w = 1.0;\n  } else {\n    // Invert at south pole of S3 - equivalent to a stereographic projection.\n    p.w += 1.0;\n    p *= 2.0/dot(p,p);\n    p.w -= 1.0;\n  }\n  if (key(CHAR_Q)) return p;\n  float k = 0.0;\n  k = 0.1*PI*iTime;\n  vec3 axis = vec3(0,0,-1);\n  // axis = normalize(axis);\n  p = qmul(p,vec4(sin(k)*axis,cos(k)));\n  if (!key(CHAR_C)) p.xz = rotate(p.xz,0.55); // Pentagon centred\n  if (key(CHAR_T)) p.yz = rotate(p.yz,0.36);   // Triangle centred\n  return p;\n}\n\nfloat Barth0(vec4 p, float K) {\n  float x = p.x; float y = p.y;\n  float z = p.z; float w = p.w;\n  float x2 = x*x; float y2 = y*y;\n  float z2 = z*z; float w2 = w*w;\n  float A = 4.0*(phi2*x2-y2)*(phi2*y2-z2)*(phi2*z2-x2);\n  float B = x2 + y2 + z2 - w2;\n  return (1.0-K)*(1.0+2.0*phi)*w2*B*B - K*A;\n}\n\nfloat Barth(vec4 p, float K) {\n  // Slightly more compact version.\n  vec4 p2 = p*p;\n  vec3 t = phi2*p2.xyz-p2.yzx;\n  float A = 4.0*t.x*t.y*t.z;\n  float B = dot(p2.xyz,vec3(1))-p2.w;\n  return (1.0-K)*(1.0+2.0*phi)*p2.w*B*B - K*A;\n}\n\n// Barth Decic\nfloat Barth10(vec4 p){//decic\n  float r2 = dot(p.xyz,p.xyz);\n  vec4 p2 = p*p;\n  float r4 = dot(p2.xyz,p2.xyz);\n  vec4 p4 = p2*p2;\n  // 8.0*(p2.xyz-phi4*p2.yzx)*(r4-2.0*dot2(p.xyz*p.yzx))+(3.0+5.0*phi)*...\n  return (8.0*(p2.x-phi4*p2.y)*(p2.y-phi4*p2.z)*(p2.z-phi4*p2.x)*\n          (r4-2.0*((p.x*p.y)*(p.x*p.y)+(p.x*p.z)*(p.x*p.z)+(p.y*p.z)*(p.y*p.z)))\n         +(3.0+5.0*phi)*(r2-p2.w)*(r2-p2.w)*(r2-(2.0-phi)*p2.w)*(r2-(2.0-phi)*p2.w)*p2.w);\n}\n\nfloat Fun(vec3 p3) {\n  vec4 p = transform4(p3);\n  //return Barth10(p);\n  float K = 0.5;\n  if (key(CHAR_K)) K = sin(-0.1*PI*iTime)+0.01; // K is mixing parameter\n  return Barth(p,K);\n}\n\nvec3 getColor(vec3 r, vec3 n) {\n  if (!doMirror) {\n    //return defaultColor;\n    return smoothstep(0.0,1.0,abs(n));\n  } else {\n    vec3 color = textureLod(iChannel0,n,1.0).rgb;\n    color = pow(color,vec3(2.2));\n    return color;\n  }\n}\n\n// Solution parameters.\nconst int iterations = 200;    // Maximum number of iterations\nconst float maxincrease = 1.03; // Largest allowed step increase.\nconst float maxstep = 2.0;     // The largest step that can be taken.\nconst float minstep = 0.001;  // The smallest step\nconst float initstep = 0.1;\nconst float maxdist = 20.0;\n\nvec3 solve(vec3 p0, vec3 r) {\n  bool bracketed = false;\n  bool found = false;\n  float step = initstep;\n  vec3 color = vec3(0);//texture(iChannel0,r,0.0).rgb;\n  color = pow(color,vec3(2.2));\n  vec3 p = p0;\n  float t0 = 0.0, t1;\n  float f0 = Fun(p), f1;\n  // The idea here is to step forward carefully until a change of\n  // sign, then use bisection to home in on (hopefully) closest root.\n  for (int i = 0; i < iterations; i++) {\n    //assert(i < 50);\n    t1 = t0 + step;\n    if (t1 > maxdist) return color;\n    p = p0 + t1*r;\n    f1 = Fun(p);\n    if (f0*f1 <= 0.0) {\n      // We can hit exactly 0 - this counts as bracketed.\n      bracketed = true;\n      break;\n    } else {\n      float step0 = step;\n      step = f1*step/(f0-f1);\n      if (!key(CHAR_R) && step < 0.0) step = 1.0; // Don't step backwards - check this!\n      step = abs(step);\n      step = min(step,t1*maxstep);\n      // Don't grow step by more than a certain amount\n      step = max(step,minstep);\n      step = min(step,maxincrease*step0);\n      t0 = t1; f0 = f1;\n    }\n  }\n  if (!bracketed) return color;\n  for (int i = 0; i < 10; i++) {\n    //assert(i < 5);\n    // Once we are bracketed, just use bisection\n    // We could use eg. the secant method, but this is fine and\n    // is reasonably quick (since the stepping procedure tends\n    // to produce fairly small intervals).\n    if ((t1-t0)/t0 < minstep) break;\n    float t2 = (t0 + t1)/2.0;\n    p = p0+t2*r;\n    float f2 = Fun(p);\n    if (f0*f2 <= 0.0) {\n      t1 = t2; f1 = f2;\n    } else {\n      t0 = t2; f0 = f2;\n    }\n  }\n\n  // Compute gradient & normal\n  float eps = 1e-3;\n  vec2 delta = max(t0,1.0)*vec2(eps,0.0);\n  p = p0 + t0*r; // Ensure p corresponds to t0 and a0\n#if 1\n  vec3 n = vec3(Fun(p + delta.xyy), Fun(p + delta.yxy), Fun(p + delta.yyx)) - f0;\n#else\n  // Not sure how much difference this makes, not a lot, I suspect.\n  vec3 n = vec3(Fun(p + delta.xyy) - Fun(p - delta.xyy),\n                Fun(p + delta.yxy) - Fun(p - delta.yxy),\n                Fun(p + delta.yyx) - Fun(p - delta.yyx));\n#endif\n  vec4 p4 = transform4(p);\n  float grad = abs(length(n));\n  n = normalize(n);\n\n  // Point normal towards eye\n  //assert(dot(r,n) < 0.0);\n  if (dot(r,n) > 0.0) n *= -1.0;\n  vec3 baseColor = getColor(r,n);\n  color = baseColor;\n  if (!doMirror) {\n    color *= ambient;\n    float k = dot(light,n);\n    if (doDiffuse && k > 0.0) {\n      color += baseColor*diffuse*k;\n    }\n    if (doSpecular && k > 0.0) {\n      float specular = pow(max(0.0,dot(reflect(light,n),r)),specpower);\n      color += 0.8*specular*vec3(1);\n    }\n  }\n  return color;\n}\n\nvec3 transform(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  //p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  doMirror = key(CHAR_M);\n  light = vec3(0.5,1,1);\n  // Projection parameters\n  float camera = 4.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 p = vec3(0,0,camera);\n  p = transform(p);\n  light = transform(light); // Light moves with camera\n  light = normalize(light);\n  vec3 color = vec3(0);\n  int AA = key(CHAR_A) ? 2 : 1;\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 inc = vec2(i,j)/float(AA);\n      vec2 uv = (2.0*(fragCoord+inc) - iResolution.xy)/iResolution.y;\n      vec3 r = normalize(vec3(uv,-2));\n      r = transform(r);\n      r = normalize(r);\n      color += solve(p,r);\n    }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n//#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n//#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n//#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n//#define keycount(code) (int(store((code),0).x))\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_I = 73;\nconst int CHAR_K = 75;\nconst int CHAR_M = 77;\n\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state  \n  }\n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}