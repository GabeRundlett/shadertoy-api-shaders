{
    "Shader": {
        "info": {
            "date": "1647045513",
            "description": "Volumetric lighting on a mandelbulb.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdBfDK",
            "likes": 12,
            "name": "BulbVolumetrics",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "#define AA 1\nconst int steps = 50;\n\nvec3 calcNormal( in vec3 p, float d ){\n    float h = 0.0001*d;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h, iTime);\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=ZERO; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor, iTime);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat getVL(vec3 ro, vec3 rd, float maxLen){\n\n    const float stepsize = 0.02;\n                float vl = 0.;\n                 float t = 0.;\n    const float d = 2.2;\n    for(int i=0;i<200;i++){\n        float s = length(ro+t*rd);\n        #define scatter\n        #ifdef scatter\n        float e = exp(-s);\n        vl += 0.25*texture(iChannel0, normalize(ro+t*rd)).x * e;\n        vl += max(0.,1. - e)*0.01;\n        #else\n        vl += 0.25*texture(iChannel0, normalize(ro+t*rd)).x * exp(-s);\n        #endif\n        t += stepsize;\n        if (t > maxLen)\n            break;\n    }\n    \n    return vl;\n}\n\n//iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec4 render(vec3 ro, vec3 rd){\n    // World info\n       vec3 p = intersection(ro,rd, steps, iTime);\n      float d = distance(p,ro);\n       tdp md = sdMandelBulb(p, iTime);\n    float trp = distance(md.pos, p);\n    \n    //Shading\n     vec3 nor = calcNormal(p, d);\n    float occ = calcAO(p, nor);\n\n    //Colors\n    vec3 col = vec3(0);\n    vec3 bcl = vec3(0.1);\n    vec3 scl = vec3(1.,0.8,0.6);\n    vec3 amb = vec3(0.6,0.8,1.);\n    vec3 vol = palette(iTime*0.066, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.33, 0.67));\n    //\n    if (map(p, iTime) < 0.1) {\n        col += bcl;\n        col += .4*amb*occ*occ*occ; \n        col += pow(1.-abs(dot(nor,rd)), 4.)*0.3*vol;\n        col += vol*max(0.,(.5-occ*occ));\n        \n        vec3 hvc = normalize(-normalize(p)-rd);\n        col += pow(max(0.,dot(nor,hvc)),10.);\n    } else\n        col = vec3(0.2);\n        \n    float vl = getVL(ro, rd, distance(p,ro)); \n    \n    col += vol * smoothstep(0.,12.,vl);\n    \n    return vec4(col, 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3   ro = vec3(0, 0, -2.5);\n    mat3 yrot = roty(iTime*0.4);\n    mat3 xrot = rotx(0.7);\n           ro*=xrot*yrot;\n           ro += vec3(0,0.2,0);\n\n    vec4 tot = vec4(0);\n    \n    //Super sampling\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 u = ((fragCoord+o) / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n        vec3 rd = normalize(vec3(u, 1));\n        tot += render(ro, rd*xrot*yrot) / float(AA*AA);\n    }}\n\n    \n    // Output to screen\n    \n    tot = smoothstep(vec4(0), vec4(1.01), tot);\n    \n    fragColor = tot;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Shadow map of sorts, used for the volumetric lighting\n/*\nWe basicly start 1 unit away from the bulb in the direction rd,\nand then march towards the bulb.\n\nWe can get away with very few steps because the lighting is supposed to be kinda fuzzy\n\nThe function that sampels this map is in the image pass at line 40\n*/\n\n//lol\nconst int steps = 1;\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\n    ro = rd*1.;//Starting pos\n    rd *= -1.; //March to the center\n    \n    vec3 p = intersection(ro, rd, steps, iTime);\n    \n    float g = length(p);\n    \n    //uncomment for uniform glow\n    //g = 0.;\n    \n    //uncomment for no lighting\n    // g= 1.;\n    \n    // Output to cubemap\n    fragColor = vec4(smoothstep(1.,.98,g));\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "//Was created so that orbit traps could be used for coloring but I didn't end up using them\nstruct tdp{\n    vec3 pos;\n    float dist;\n};\n\n#define ZERO min(iFrame, 0)\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n//Returns the distance to the mandel bulb and the transformed pos of p\ntdp sdMandelBulb(vec3 p, float time) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.;\n\tfloat r, theta, phi;\n\tfloat dr = .84;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 4; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n\t\tphi = asin(z.z / r) + time*0.4;\n\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn tdp(z, 0.5 * log(r) * r / dr);\n}\n\n\nconst float pi = 3.14159265359;\n\n//Distance to the scene\nfloat map(vec3 p, float time){\n    return sdMandelBulb(p, time).dist;\n}\n\n\nvec3 intersection(vec3 ro, vec3 rd, int steps, float time){\n    for(int i=0;i < steps;i++){\n        float dist = map(ro, time);\n        ro += rd*dist*0.92;\n        if(dist <0.01)\n            break;\n    }\n    return ro;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}