{
    "Shader": {
        "info": {
            "date": "1667514946",
            "description": "CC0: Gnarly colorful apollonian \nThe glow coloring of Fractal doodling: https://www.shadertoy.com/view/ds2GRW\ninspired me to revisit an old shader of mine and spice it up\n",
            "flags": 0,
            "hasliked": 0,
            "id": "csB3D1",
            "likes": 69,
            "name": "Gnarly colorful apollonian ",
            "published": 3,
            "tags": [
                "apollonian"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 738
        },
        "renderpass": [
            {
                "code": "// CC0: Gnarly colorful apollonian \n// The glow coloring of Fractal doodling: https://www.shadertoy.com/view/ds2GRW\n//  inspired me to revisit an old shader of mine and spice it up\n\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst int   max_iter      = 70;\n \n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size*0.5;\n  vec2 c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c,vec2(2))*2.0 - vec2(1.0);\n  return c;\n}\n\nfloat apollonian(vec3 p, out float ss) {\n  float s = mix(1.4, 1.45, smoothstep(0.9, 1.0, sin(-length(p.xz)+TAU*TIME/10.0))); \n  float scale = 1.5;\n\n  const int rep = 5;\n  mat2 rr = ROT(PI/5.5);\n\n  for(int i=0; i<rep; ++i) {\n    mod1(p.y, 2.0);\n    modMirror2(p.xz, vec2(2.0));\n    p.xz *= rr;\n\n    float r2 = dot(p,p);\n    float k = s/r2;\n    p *= k;\n    scale *= k;\n  }\n  \n  float d = -(box(p - 0.1, vec3(1.0, 2.0, 1.)) - 0.6);\n  ss = scale;\n  return 0.25*d/scale;\n}\n\nvec3 glow(vec3 ro, vec3 rd) {\n  float res;\n  float t = .75;\n  int iter = max_iter;\n\n  vec3 col = vec3(0.0);    \n  for(int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + rd * t;\n    float ss;\n    res = apollonian(p, ss);\n    col += 0.06*(0.5+0.5*cos(3.0+vec3(1.0, 2.0, 3.0)+0.8*log(ss)))*exp(-0.05*t-.5*res*float(i*i));\n    if(res < 0.0003 * t || res > 20.) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n    \n  return col;\n}\n\nvec3 render(vec2 p) {\n  vec3 ro = 1.2*vec3(-1.0, .8, -0.0);\n  ro.xz   *= ROT(TIME/10.0);\n  const vec3 la = vec3(0.0, 1.6, 0.0); \n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 3.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  return glow(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q; \n  p.x*=RESOLUTION.x/RESOLUTION.y;\n \n  vec3 col = render(p);\n  col -= 0.1*vec3(1.0, 2.0, 0.5);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n\n  fragColor=vec4(col, 1.0); \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}