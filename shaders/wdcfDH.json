{
    "Shader": {
        "info": {
            "date": "1604965743",
            "description": "Based on https://www.shadertoy.com/view/MsB3zK\n[mouse drag] - camera position\n#define ANTIALIASING - Activate antialiasing (line 6 of Buffer A tab)\n\nAlso check out my playable HTML5 Junkbot remake:\nhttps://github.com/1j01/janitorial-android",
            "flags": 96,
            "hasliked": 0,
            "id": "wdcfDH",
            "likes": 17,
            "name": "Lego Junkbot",
            "published": 3,
            "tags": [
                "raymarching",
                "trash",
                "distancefunction",
                "robot",
                "lego",
                "legoman",
                "minifig",
                "junkbot",
                "recycling"
            ],
            "usePreview": 0,
            "username": "1j01",
            "viewed": 533
        },
        "renderpass": [
            {
                "code": "// See \"Buffer A\" tab for main code, info, and configuration\n//\n// This shader is a postprocessing step that adds a tilt-shift defocus effect,\n// based on the color (RGB) and depth information stored in the alpha channel.\n//\n// https://en.wikipedia.org/wiki/Depth_of_field\n\n\n\n\n// Created by sebastien durand - 05/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//---------------------------------------------------\n// The depth of field process:\n// For each of the neighboring pixels, the algorithm calculates if the\n// reconstructed 3D point of a pixel is effectively in the\n// 3D cone (circle) of confusion of the pixel. Otherwise it is ignored.\n// This avoids artfacts on the edges of objects.\n// The valid neighboring pixels are averaged together.\n//\n// Inspired by Dave Hoskins bokeh disc [https://www.shadertoy.com/view/4d2Xzw]\n//---------------------------------------------------\n\n\n\n#define WITH_DOF\n#define WITH_CONE_TEST\n\n\n#ifdef WITH_DOF\n\nconst float fov = 12.;\nconst float aperture = 1.;\n\nconst float cosAngle = cos(radians(aperture/2.));\nconst float GA = 2.399;  // golden angle = 2pi/(1+phi)\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec2 res;\n    \n\n\nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn side*dot(normalize(o-p), n) >= cosAngle;\n}\n\nvec3 RD(const vec2 q) {\n    return normalize(vec3((2.* q.x - 1.) * res.x/res.y,  (2.* q.y - 1.), fov));\n}\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.04, (2./iResolution.y) * (1.+t));\n}\n\nvec3 dof(sampler2D tex, vec2 uv, float fdist) {\n    \n\tvec4 colMain = texture(tex, uv);\n    \n    const float amount = 1.;\n    \n    float rad = min(.3, coc(abs(colMain.w-fdist)));//.3; // TODO calculate this for Max distance on picture\n    \n    float r=1.;\n    \n    vec3 cn = RD(uv),    // Cone axis    \n         co = cn*fdist,  // Cone origin\n         sum = vec3(0.),  \n     \t bokeh = vec3(1),\n         acc = vec3(0),\n         pixPos;\n    \n\n    vec2 pixScreen,\n         pixel = 1./iResolution.xy,        \n         angle = vec2(0, rad);\n    \n    vec4 pixCol;\n    \n    bool isInCone = false;\n\tfor (int j=0;j<120;j++) {  \n        r += 1./r;\n\t    angle *= rot;\n        \n        pixScreen = uv + pixel*(r-1.)*angle; // Neighbourg Pixel\n        pixCol = texture(tex, pixScreen);    // Color of pixel (w is depth)      \n        pixPos = pixCol.w * RD(pixScreen);   // Position of 3D point in camera base\n#ifdef WITH_CONE_TEST\n        if (inCone(pixPos, co, cn, sign(fdist - pixCol.w))) \n#endif            \n        {        // true if the point is effectivelly in the cone\n            bokeh = pow(pixCol.xyz, vec3(9.)) * amount +.4;\n            acc += pixCol.xyz * bokeh;\t\t\t\n            sum += bokeh;\n            isInCone = true;\n        }\n\t}\n        \n    \n \treturn (!isInCone) ? colMain.xyz : // Enable to deal with problem of precision when at thin begining of the cone\n       acc.xyz/sum;\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    \n    res = iResolution.xy;\n    vec2 mouse = (iMouse.xy/iResolution.xy)*6.28;\n    vec3 ro = 45.*vec3(-cos(mouse.x), max(.8,mouse.x-2.+sin(mouse.x)*cos(mouse.y)), -.5-sin(mouse.y));\n\n    float fdist = length(ro);//; 64.;\n    \n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tfragColor=vec4(dof(iChannel0,uv,fdist),2.);\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tfragColor= texture(iChannel0,uv);\n}\n\n\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 24528,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/user455094288/junkbot-undercover-theme"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lego Junkbot by Isaiah Odhner - 2020-11-9\n// Based on \"Go Go LegoMan !\" by sebastien durand - 01/2014\n// https://www.shadertoy.com/view/MsB3zK\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define ANTIALIASING\nconst float AA = 3.; // Anti-Aliasing Level (uncomment #define ANTIALIASING to use)\n\n//#define DYNAMIC_WRAP_INTERVAL\n//#define RUBBISH\n//#define DEBUG_RECYCLING_SYMBOL\n\n// Possible Improvements:\n// - Get brick proportions just right; I think the sloped brick is a little too tall, and maybe the square brick is a little short?\n// - Add rubbish in bins. Work started - uncomment #define RUBBISH to see.\n// - It would be nice if the ground was made of lego.\n// - Prevent feet clipping into ground when walking.\n// - Also the animation could be a lot more dynamic,\n//   by bending the legs like in Junkbot and other lego video games / animations,\n//   maybe moving junkbot forward relative to the camera for part of the walk cycle.\n//   Note that texturing the legs currently duplicates code for rotation based on the animation.\n// - Better camera control\n// - Of course other elements from the game could be added, even interactivity.\n\n#define TAO 6.28318530718\n#define NB_ITER 120\n#define MAX_DIST 400.\n#define PRECISION .002\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst vec2 \n    V01 = vec2(0,1),\n    Ve = vec2(.001,0),\n    leg1 = vec2(0,-.1),\n    leg2 = vec2(0,-.8),\n    hand2 = vec2(-.1,.25);\t\n\nconst vec3\n    bhat = vec3(.47*4.*.392,.14,.45),\n    bbody = vec3(.47*4.*.392,.14*3.,.45*2.),\n    bbody1 = vec3(.75,.6,1.),\n    v0 = vec3(0),\n    body0 = vec3(0,-.15,0),\n    head0 = vec3(0,body0.y-1.05,0),\n    hat0 = vec3(0,head0.y-.77,0),\n    middle1 = vec3(0,.44,0),\n    middle2 = vec3(.65,.1,.325),\n    middle3 = vec3(.76,0,0),\n    arm0 = vec3(.7,-.55,0),\n    hand0 = vec3(.4,1.,.5),\n    arm1 = vec3(-.25,-.5,0),\n    arm2 = vec3(-.4,-1.,-.5),\n    hand1 = vec3(.02,.15,0);\n\nconst vec3 recycling_bin_offset =\n    #ifdef DYNAMIC_WRAP_INTERVAL\n    vec3(1., 0., 0.)\n    #else\n    vec3(-1., 0., -.5)\n    #endif\n    ;\n\nconst lowp float \n    legh = 1., \n    lege=.34, \n    legx=.31, \n    handa = -.7;\n//face_a = 1.1;\n//face_r = 27.;\n\nconst float \n    face_x = 30.,    //27.*0.453596121, //face_r*cos(a); // precalcul\n    face_y = -27.*0.89120736; //face_r*sin(a); // precalcul\n\n// Global variables\nfloat time;\nvec3 sunLight, deltaMan;//, armn;\n//mat2 handmat;\nvec2 fCoord;\nint scene;\nfloat anim;\n\n#ifdef DYNAMIC_WRAP_INTERVAL\n    float wrapInterval;\n#else\n    #define wrapInterval 5.\n#endif\n\n\nfloat hash( const in vec3 p ) {\n    float h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat hashsym( const in vec3 p ) {\n    return hash(p) * 2.0 - 1.0;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(ac,nor),pc))<2.0)\n        ?\n        min( min(\n            dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n            dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n            dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n        :\n        dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(dc,nor),pc)) +\n         sign(dot(cross(ad,nor),pd))<3.0)\n        ?\n        min( min( min(\n            dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n            dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n            dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n            dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n        :\n        dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat udQuad( vec2 p, vec2 a, vec2 b, vec2 c, vec2 d )\n{\n    // TODO: delete me, use sdBox\n    return udQuad( vec3(p, 0), vec3(a, 0), vec3(b, 0), vec3(c, 0), vec3(d, 0) );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n\n// h = .5, //  half of height\n// r1 = 1., //main rayon\n// r2 = .2, // top border\nfloat roundCylinder(in vec3 p, in float h, in float r1, in float r2) {\n    float\n        a = abs(p.y)-(h-r2),\n        b = length(p.xz)-r1;\n    return min(min(max(a, b), max(a-r2, b+r2)), length(vec2(b+r2,a))-r2);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hat(in vec3 p) {\n    // yellow topper\n\n    vec3 vd = abs(p) - bbody1;\n    p.x = abs(p.x);\n    float d = length(max(abs(p)-bhat,0.0));//-.05;\n    return max(abs(p.z)-.392, d);\n}\n\nfloat head(in vec3 p) {\n    // orange sloped brick\n\n    vec3 vd = abs(p) - bbody1;\n    vd.z -= 0.16;\n    float d = min(max(vd.x,max(vd.y,vd.z)),0.0) + length(max(vd,0.0));\n    p.z = -p.z;\n    p.z -= .392;\n    p.y *= 4.6;\n    d = max(dot(p.zy, vec2(.5, .08))-.25,d);\n    return max(abs(p.z)-2.*.392, d);\n}\n\nfloat body(in vec3 p) {\n    // orange square brick\n\n    vec3 vd = abs(p) - bbody1;\n    p.x = abs(p.x);\n    p.z += .392;\n    float d = length(max(abs(p)-bbody,0.0))-.025;\n    return max(abs(p.z)-2.*.392, d);\n}\n\nfloat faceSticker(in vec3 p) {\n    // sticker thickness is needed especially in scene where body rotates,\n    // to avoid the face going black or darkening when it should actually get lighter (when facing into the light more)\n    float stickerThickness = .03;\n    float width = 4.0*.392 - stickerThickness * 2. - .05;\n    float height = 1.1 - stickerThickness * 2.;\n    vec3 offset = vec3(width/2., 0.4, 1.2 - stickerThickness);\n    return udQuad(p+offset,\n                  vec3(0., 0., 0.),\n                  vec3(0., height, 0.),\n                  vec3(width, height, 0.),\n                  vec3(width, 0., 0.)\n                 ) - stickerThickness;\n}\n\nfloat leg(in vec3 p) {\n    float d = length(p.zy)-lege;\n    d = min(d, length(max(abs(p+vec3(0.,legh*.5,-.08))-vec3(legx,legh*.5,lege-.08),0.)));\n    d = min(d, length(max(abs(p+vec3(0.,legh,.02))-vec3(legx,.15,lege+.02),0.)));\n    d = max(abs(p.x)-legx, d)-.02;\n    vec3 dd = abs(p+vec3(0.,legh,-.08))-vec3(legx-.1,legh+.2,lege-.18);\n    float d2 = min(max(dd.x,max(dd.y,dd.z)),0.) + length(max(dd,0.));\n    dd = abs(p+vec3(0.,legh+.1,.02))-vec3(legx-.1,.15,lege-.98);\n    d2 = min(d2, min(max(dd.x,max(dd.y,dd.z)),0.0) + length(max(dd,0.)));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-leg1)-.24));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-leg2)-.24));\n    return max(-d2,d);\n}\n\nvec2 minObj(in vec2 o1, in vec2 o2) {\n    return (o1.x<o2.x) ? o1 : o2;\n}\n\nivec2 getId(in vec3 p) {\n    return ivec2(\n        (wrapInterval*100.+p.x)/wrapInterval,\n        (wrapInterval*100.+p.z)/wrapInterval\n    )-100;\n}\n\nvec2 legoman(in vec3 p, in ivec2 id) {\n\n    float a, bodyA;\n    vec3 p0 = p;\n    float sa,ca;//, anim=0.;\n\n    if (scene!=1) {\n        anim = -1.1+cos(float(-id.y)*.7 + 6.*iTime);\n    } else { // walking\n        anim = (p0.x<0.?1.:-1.)*cos(6.*iTime-4.);\n    }\n\n    if (scene==1) {\n        p += deltaMan;\n    }\n    else if(scene==2) {\n        bodyA = .12*anim;\n        R(p.yz, -bodyA);\n    }\n\n    vec2 dHat = vec2(hat(p+hat0),0.);\n    vec2 dHead = vec2(head(p+head0),1.);\n    vec2 dBody = vec2(body(p+body0),2.);\n    vec2 dFaceSticker = vec2(faceSticker(p+body0),2.);\n\n    float middle = length(max(abs(p+middle1)- middle2,0.0))-.05;\n    middle = min(middle,roundCylinder(p.yxz+middle3,.06,.39,.02));\n    vec2 dMiddle = vec2(middle,3.);   \n    p.x = -abs(p.x);\n\n    vec3 p1 = p;\n    p1.y +=.77;\n\n    if (scene==1) { // id.x==0 && id.y==0) {\n        R(p1.yz, .4*anim); \n    } else if (scene == 2) {\n        R(p1.yz, 2.*bodyA); \n    }\n\n    vec2 dLeg = vec2(leg(p1+vec3(.38,.77-.77,0)),4.);\n\n    p += arm0;\n\n    if (scene!=0 || id.x==0 && id.y==0) {\n        R(p.yz, .5 - anim);\n    }\n\n    //vec2 dArm = vec2(arm(p),5.);\n    //vec2 dHand = vec2(hand(p+hand0),6.);\n\n    return minObj(\n        minObj(\n            minObj(\n                minObj(\n                    minObj(\n                        dBody,\n                        dFaceSticker\n                    ),\n                    dHead\n                ),\n                dHat\n            ),\n            dMiddle\n        ),\n        dLeg\n    );\n}\n\nfloat recycling_bin(in vec3 pos, ivec2 id) {\n    vec3 q = pos - vec3(-1.0,0.0,1.0);\n    float d = onion( sdCappedCylinder( q, vec2(0.6,1.8) ), 0.05);\n    d = max( d, pos.y ); // cut off top\n\n    // add papers (debris, rubbish, trash, refuse)\n    #ifdef RUBBISH\n    float paperThickness = 0.02;\n    for (float i = 0.; i < 5.; i += 1.) {\n        d = min(d,\n                udQuad(\n                    q - vec3(\n                        hashsym(vec3(i, id)) * 0.1,\n                        hashsym(vec3(i+30., id)) * 0.1 - 0.2,\n                        hashsym(vec3(i+60., id)) * 0.1\n                    ),\n                    vec3(hashsym(vec3(i+0.1, id)), hashsym(vec3(i+0.2, id)), hashsym(vec3(i+0.3, id))) * 0.4,\n                    vec3(hashsym(vec3(i+0.4, id))*0.1, hashsym(vec3(i+0.5, id)), hashsym(vec3(i+0.6, id))) * 0.4,\n                    vec3(hashsym(vec3(i+0.7, id))*0.1, hashsym(vec3(i-0.1, id))*0.1, hashsym(vec3(i-0.2, id))) * 0.4,\n                    vec3(hashsym(vec3(i-0.3, id)), hashsym(vec3(i-0.4, id))*0.1, hashsym(vec3(i-0.5, id))) * 0.4\n                ) - paperThickness\n               );\n    }\n    #endif\n    \n    return d;\n}\n\nvec2 DE(in vec3 p) {\n    ivec2 id = getId(p);\n    p.xz = mod(p.xz, wrapInterval)-0.5*wrapInterval;\n    vec2 obj = minObj(legoman(p, id), vec2(p.y+1.93,10.));\n    if (hash(vec3(id, 0.)) < 0.2 && scene != 1) {\n        obj = minObj(obj, vec2(recycling_bin(p + recycling_bin_offset, id), 333.));\n    }\n    return obj;\n}\n\n\nvec3 Normal(in vec3 p, in vec3 ray, in float t) {\n    float pitch = .2 * t / iResolution.x;\n\n\n    vec2 d = vec2(-1,1) * pitch;\n\n    vec3 p0 = p+d.xxx; // tetrahedral offsets\n    vec3 p1 = p+d.xyy;\n    vec3 p2 = p+d.yxy;\n    vec3 p3 = p+d.yyx;\n\n    float f0 = DE(p0).x;\n    float f1 = DE(p1).x;\n    float f2 = DE(p2).x;\n    float f3 = DE(p3).x;\n\n    vec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n    //return normalize(grad);\t// prevent normals pointing away from camera (caused by precision errors)\n    return normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float res = 1.0, h, t = mint+.1*hash(ro+rd);\n    for( int i=0; i<48; i++ ) {\n        //  if (t < maxt) {\n        h = DE( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += .1;\n        //  }\n    }\n    return clamp(res, 0., 1.);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float dd, hr=.01, totao=.0, sca=1.;\n    for(int aoi=0; aoi<5; aoi++ ) {\n        dd = DE(nor * hr + pos).x;\n        totao += -(dd-hr)*sca;\n        sca *= .7;\n        hr += .05;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n}\n\nfloat recycling_symbol(in vec2 p, bool reverse_arrow_direction) {\n    p *= 100.;\n    // this offset is for junkbot's benefit, could be factored out\n    p.x += 35.;\n    p.y -= 15.;\n    \n    if (reverse_arrow_direction) {\n        p.xy = p.yx;   \n    }\n\n    // flip depending on quadrant\n    if (p.x < 0.) {\n        if (p.y < 0.) {\n            p.x = -p.x;\n        } else {\n            p.xy = p.yx;\n        }\n    } else if (p.y < 0.) {\n        p.xy = p.yx;\n        p.x = -p.x;\n        p.y = -p.y;\n    } else {\n    \tp.y = -p.y;\n    }\n\n    const vec2 arrow_point = vec2(0., -30.); // tip\n    const float arrow_head_width = 30.; // width at base\n    const float arrow_head_length = 15.; // tip to base distance\n    const float arrow_shaft_width = 14.; // line thickness\n    const float arrow_shaft_1_length = 19.5; // length of line adjacent to arrow head\n    const float arrow_shaft_2_length = 32.; // length of tail line (away from arrow head)\n    const vec2 arrow_base_point = vec2(arrow_point.x + arrow_head_length, arrow_point.y);\n    const vec2 arrow_elbow_point = arrow_base_point + vec2(arrow_shaft_1_length, 0.);\n\n    float d = min(\n        sdTriangle(p,\n                   arrow_point,\n                   arrow_base_point + vec2(0, -arrow_head_width/2.),\n                   arrow_base_point + vec2(0, arrow_head_width/2.)\n                  ),\n        min(\n            sdBox(\n                p - arrow_base_point - vec2(arrow_shaft_1_length/2., 0.),\n                vec2(arrow_shaft_1_length/2., arrow_shaft_width/2.)\n            ),\n            sdBox(\n                p - arrow_elbow_point - vec2(\n                    arrow_shaft_1_length/2. - arrow_shaft_width,\n                    arrow_shaft_2_length/2. - arrow_shaft_width/2.\n                ),\n                vec2(arrow_shaft_width/2., arrow_shaft_2_length/2.)\n            )\n        )\n    );\n    \n    #ifdef DEBUG_RECYCLING_SYMBOL\n    const float debug_grid_thickness = 0.5;\n    const float debug_grid_interval = 5.;\n    if (\n        mod(p.x + debug_grid_thickness/2., debug_grid_interval) < debug_grid_thickness ||\n        mod(p.y + debug_grid_thickness/2., debug_grid_interval) < debug_grid_thickness\n    ) {\n        d /= 10.;\n    }\n    #endif\n    \n    return d;\n}\n\nvec3 getTexture(in vec3 p, in float m) {\n    ivec2 id = getId(p);\n\n    vec3 p0 = p;\n    p.xz = mod(p.xz, wrapInterval)-0.5*wrapInterval;\n\n    if (m != 333.) {\n        if (scene==1) {\n            p += deltaMan;\n        } else if (scene == 2) {\n\n            float anim = -1.1+cos(float(-id.y)*.7 + 6.*iTime);\n\n            float bodyA = .12*anim;\n            float sa=sin(bodyA); \n            float ca=cos(bodyA);\n            p.yz *= mat2(ca, -sa, sa, ca);\n        }\n    }\n    vec3 c;   \n\n    if (m==1. || m==2.) {\n        // head or body (orange bricks)\n        c = vec3(1.,.5,0.);\n\n        // Draw blinds/grate/breadbox texture\n        vec2 p2 = p.xy;\n        p2.y -= 1.46;\n        p2 *= 100.;\n        float px = abs(p2.x);\n        float e = 4.-.08*px;\n        float v =\n            p.y < 1.73 && p.y > 0.95 && p.x > -0.5 && p.x < 0.5 ?\n            mod(p.y+.1, .15) * mod(e, 5.) * 15.\n            : 5000.; // ~infinity\n        v = clamp(v, 0., 1.);\n        c = mix(vec3(.3, .1, 0.), c, v);\n\n        float g = mod(iTime, TAO*3.);\n        //if (id.x==0 && id.y==0 && g > 2.5*TAO) {\n        //    R(p.xz, -.8*cos(2.*g+1.57));\n        //}\n        if (p.z<-1.1) {\n            // Draw face\n            vec2 p2 = p.xy;\n            p2.y -= 0.4;\n            p2 *= 100.;\n            float mouth_y = -0.;\n            float mouth_thickness = 2.;\n            float mouth_width = 40.;\n            float eye_spacing = face_x;\n            float eye_y = -face_y*1.1;\n            float eye_gaze_x = -7.;\n            if (id.x==0 && id.y==0 && g > 2.5*TAO) {\n                eye_gaze_x = -7. * cos(2.*g+1.57);\n            }\n            float px = abs(p2.x);\n            float e = 4.-.08*px;\n            float vw = // distance to white\n                // whites of the eyes\n                abs(p2.y-eye_y) < 5. ? \n                length(vec2(px,p2.y)-vec2(eye_spacing,eye_y))-5.8*e\n                : 5000.; // ~infinity \n            vw = clamp(vw, 0., 1.);\n            float pupil_x = abs(p2.x + eye_gaze_x);\n            float vb = // distance to black\n                // mouth\n                (px<mouth_width && abs(p2.y-mouth_y)<mouth_thickness) ? 0. :\n            // pupils\n            abs(p2.y-eye_y) < 5. ? \n                length(vec2(pupil_x,p2.y)-vec2(eye_spacing-5.5,eye_y))-5.8\n                : 5000.; // ~infinity \n            vb = clamp(vb, 0., 1.);\n            c = mix(vec3(2), c, vw);\n            c = mix(vec3(0), c, vb);\n        } else {\n            // Draw recycling symbol\n            float vb = recycling_symbol(p.zy, p.x < 0.);\n            vb = clamp(vb, 0., 1.);\n            c = mix(vec3(.6, .2, 0.), c, vb);\n        }\n    } else if (m==10.) {\n        // ground\n        if (scene!=1) time = 0.;\n        float d = .3*sin(2.2+time);\n        c = vec3(.75-.25*(mod(floor(p0.x),2.)+mod(floor(p0.z+d-time*.18),2.)));\n        //c = vec3(.5+.5*smin(mod(floor(p0.x),2.),mod(floor(p0.z+d-time*.18),2.),1.));\n    } else if(m == 3.) {\n        // pants crotch/hinge\n        c = vec3(.6,.6,.6);\n        //} else if(m == 6.) {\n        // hands, I guess\n        //c = vec3(1.,1.,0);\n    } else if(m == 4.) {\n        // legs\n        c = vec3(.6,.6,.6);\n\n        vec2 p2 = p.zy * 100.;\n\n        //float vg = mod(distance(p2, vec2(0., -80.)), 16.) - 4.;\n        vec2 center = vec2(0., -80.); // center of rotation of hinge joint\n\n        // rotate around center\n        p2 -= center;\n        if (scene == 1) {\n            R(p2, -.4*anim);\n        }else if (scene == 2) {\n            R(p2, -.25*anim);\n        }\n        p2 += center;\n\n        float dist_to_center = distance(p2, center);\n        // using onion technique described here https://iquilezles.org/articles/distfunctions\n        float vg = abs(abs(dist_to_center - 13.) - 5.) - 2.;\n\n        vg = min(vg,\n                 udQuad(p2,\n                        center + vec2(-2., -85.),\n                        center + vec2(+2., -85.),\n                        center + vec2(+2., -20.),\n                        center + vec2(-2., -20.)\n                       )\n                );\n        float flare_width = 5.;\n        float flare_length = 6.;\n        for (float i = 0.; i < 4.; i+=1.) {\n            vg = min(vg,\n                     udQuad(p2,\n                            center + vec2(-flare_length, -85.+flare_width*(i*2.+1.)),\n                            center + vec2(+flare_length, -85.+flare_width*(i*2.+1.)),\n                            center + vec2(+flare_length, -85.+flare_width*(i*2.+0.)),\n                            center + vec2(-flare_length, -85.+flare_width*(i*2.+0.))\n                           )\n                    );\n        }\n        vg = clamp(vg, 0., 1.);\n        c = mix(vec3(.2, .2, .2), c, vg);\n    } else if(m == 0.) {\n        c = vec3(1.2,1.2,0); // hat (yellow topper)\n    } else if(m == 333.) {\n        c = vec3(0.,0.,1.); // recycling bin (blue and white)\n\n        vec3 p2 = p + recycling_bin_offset;\n        if (length(p2.xz + vec2(1., -1.)) < .55) {\n            // inside + rubbish\n            c = vec3(1.);\n        } else {\n            float vb = recycling_symbol(p2.zy + vec2(-1.3, 1.), true);\n            vb = clamp(vb, 0., 1.);\n            c = mix(vec3(1.), c, vb);\n        }\n    } else {\n        c = vec3(1);\n    }\n    if (m==10. || !(id.x==0 && id.y==0)) {\n        // black & white\n        float a = (c.r+c.g+c.b)*.33;\n        c = vec3(1.,.95,.85)*a;\n    }\n\n    return c;\n}\n\n\nvec3 Render(in vec3 p, in vec3 rd, in float t, in float m) {\n    vec3  col = getTexture(p, m),\n        nor = Normal(p, rd, t);\n    float sh = 1.,\n        ao = calcAO(p, nor ),\n        amb = clamp(.5+.5*nor.y, .0, 1.),\n        dif = clamp(dot( nor, sunLight ), 0., 1.),\n        bac = clamp(dot( nor, normalize(vec3(-sunLight.x,0.,-sunLight.z))), 0., 1.)*clamp( 1.0-p.y,0.0,1.0);\n\n    if( dif>.02 ) { sh = softshadow( p, sunLight, .02, 10., 12.); dif *= (.1+sh); }\n\n    vec3 brdf = vec3(0.0);\n    brdf += .2*ao*amb*vec3(0.10,0.11,0.13);\n    brdf += .2*ao*bac*vec3(0.15);\n    brdf += 1.2*dif*vec3(1.,.9,.7);\n\n    float pp = /*1.1**/clamp( dot(reflect(rd,nor), sunLight ), 0.0, 1.);\n    float spe = 1.2*sh*pow(pp,16.0);\n    float fre = .2*ao*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    col = col*(brdf + spe) + .2*fre*(0.5+0.5*col);\n    return col;\n}\n\n\nmat3 lookat(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n        rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp) {\n    return lookat(cp-ro, V01.xyx)*normalize(vec3(((iMouse.z > 0. ? 1. : 2.)*fCoord-iResolution.xy)/iResolution.y, 12.0));\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    #ifdef DEBUG_RECYCLING_SYMBOL\n    float vb = recycling_symbol(fragCoord.xy/iResolution.y - vec2(1.2, 0.35), iMouse.z < 0.);\n    vb = clamp(vb, 0., 1.);\n    fragColor = mix(vec4(1.), vec4(0.,0.,1.,1.), vb);\n    return;\n    #endif\n\n    // - Precalculate global variables ------------------------------\n    time = 3.14+12.*iTime;\n    sunLight = normalize(vec3(-10.25,30.33,-7.7));\n    deltaMan = vec3(0,.05*sin(1.72+time),0);\n    //armn = normalize(arm2 - arm1);\n    //handmat = mat2(cos(handa), -sin(handa), sin(handa), cos(handa));\n\n    float tAnim = mod(iTime, 3.14*9.);  \n    scene = tAnim > 3.14*9. ? 1:\n    tAnim > 3.14*7. ? 2:\n    tAnim > 3.14*6. ? 0 : 1;\n    // The way the wrapping works, objects can't be near the boundary without artifacts,\n    // and the animations aren't continuous anyways,\n    // so space things out more while showing recycling bins\n    // and hide recycling bins during the walking animation\n    // (also avoiding animating the bins moving along the ground)\n    #ifdef DYNAMIC_WRAP_INTERVAL\n        wrapInterval = scene == 1 ? 5. : 10.;\n    #endif\n\n\n    //------------------------------------------------------------\n\n    vec2 \n        obj, \n        mouse = (iMouse.xy/iResolution.xy)*6.28,\n        q = fragCoord.xy/iResolution.xy;\n\n    vec3 \n        ro = 45.*vec3(-cos(mouse.x), max(.8,mouse.x-2.+sin(mouse.x)*cos(mouse.y)), -.5-sin(mouse.y)),\n        rd, cp = V01.xxx;\n\n    vec3 ctot = vec3(0);\n    float ttot = 0.;\n\n    #ifdef ANTIALIASING \n    for (float i=0.;i<AA;i++) \n    {\n        fCoord = fragCoord.xy+.4*vec2(cos(6.28*i/AA),sin(6.28*i/AA));\t\n        //   \tfCoord = fragCoord.xy+.5*mod(vec2(iFrame/2, iFrame),2.);\t\n        #else\n        fCoord = fragCoord.xy;\n        #endif\n        // Camera origin (o) and direction (d)\n        rd = RD(ro, cp);\n\n        // Ray marching\n        float m=0.;\n        float t=0.,d=1.;\n\n        for(int i=0;i<NB_ITER;i++){\n            if (abs(d)<PRECISION || t>MAX_DIST) break;\n            obj = DE(ro+rd*t);\n            t+=d=obj.x *.85;\n            if (abs(d)<PRECISION) {\n                m=obj.y;\n            }\n        }\n\n        // Render colors\n        if(t<MAX_DIST){// if we hit a surface color it\n            ctot += Render(ro + rd*t, rd,t, m);\n            ttot += t;\n        }\n        #ifdef ANTIALIASING \t\t\n    }\n    ctot /= AA;\n    ttot /= AA;\n    #endif \n    ctot = pow(ctot, vec3(.6));\n    ctot *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .11); // vignetting\n    fragColor = vec4(ctot,ttot);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}