{
    "Shader": {
        "info": {
            "date": "1450089159",
            "description": "Arlo, from Pixar's movie The Good Dinosaur, simplified and remade as a procedural distance field. I'm using ray differentials to do heightmap and texture filtering without edge artifacts. Video [url]https://www.youtube.com/watch?v=yMpG6qEb8js[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4dtGWM",
            "likes": 130,
            "name": "Arlo",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield",
                "sdf"
            ],
            "usePreview": 1,
            "username": "iq",
            "viewed": 22183
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Needless to say this is pure fan-art. While I did work in the film\n// a few years before I made this shader, I did not work on the\n// character Arlo (rather I worked on the environments), and I didn't\n// use any of Pixar's assets to make this shader. In fact, I modeled\n// Arlo's SDF here in Shadertoy directly as I always do, eyeballing\n// the proportions and colors from memory and by looking at online\n// posters of the film.\n\n// The shader uses ray differentials to do proper texture filtering,\n// more information here:\n// https://iquilezles.org/articles/filteringrm\n\n\n// https://iquilezles.org/articles/intersectors\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n\treturn vec2(-b - h, -b+h);\n}\n\n// https://iquilezles.org/articles/distfunctions\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\n// https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n#define ZERO (min(iFrame,0))\n\n//---------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/biplanar\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n, in float k, in vec3 g1, in vec3 g2 )\n{\n    vec3 m = pow( abs(n), vec3(k) );\n\tvec4 x = textureGrad( sam, p.yz, g1.yz, g2.yz );\n\tvec4 y = textureGrad( sam, p.zx, g1.zx, g2.zx );\n\tvec4 z = textureGrad( sam, p.xy, g1.xy, g2.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\n// https://iquilezles.org/articles/texture\nvec4 textureImproved( sampler2D tex, in vec2 res, in vec2 uv, in vec2 g1, in vec2 g2 )\n{\n\tuv = uv*res + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\n\tuv = (uv - 0.5)/res;\n\treturn textureGrad( tex, uv, g1, g2 );\n}\n\n//---------------------------------------------------------------------------\n\nmat3 base( in vec3 ww )\n{\n    vec3  vv  = vec3(0.0,0.0,1.0);\n    vec3  uu  = normalize( cross( vv, ww ) );\n    return mat3(uu.x,ww.x,vv.x,\n                uu.y,ww.y,vv.y,\n                uu.z,ww.z,vv.z);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n//---------------------------------------------------------------------------\n\nvec2 leg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdSegment( p, pa, pb );\n\n    float d3 = b.x - 0.15;\n    b = sdSegment( p, pb, pc );\n    d3 = smin( d3, b.x - 0.15, 0.1 );\n\n    // knee\n    float d4 = sdEllipsoid( p, pb+vec3(-0.02,0.05,0.0), vec3(0.14) );\n    //d4 -= 0.01*abs(sin(50.0*p.y));\n    d4 -= 0.015*abs(sin(40.0*p.y));\n    d3 = smin( d3, d4, 0.05 );\n\n    // paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.2,0.0,0.0)*(-1.0+2.0*h);\n    d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.4,0.25,0.4) );\n\n    // nails\n    float d6 = sdEllipsoid( fc, vec3(0.32,-0.06,0.0)*(-1.0+2.0*h), 0.95*vec3(0.1,0.2,0.15));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.21*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.26), 0.95*vec3(0.1,0.2,0.15)) );\n    // space for nails\n    d4 = smax( d4, -d6, 0.03 );\n\n    // shape paw\n    float d5 = sdEllipsoid( fc, vec3(0.0,1.85*(-1.0+2.0*h),0.0), vec3(2.0,2.0,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n    d5 = sdEllipsoid( fc, vec3(0.0,-0.75*(-1.0+2.0*h),0.0), vec3(1.0,1.0,1.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n\n    d3 = smin( d3, d4, 0.1 );\n    \n    // muslo\n    d4 = sdEllipsoid( p, pa+vec3(0.0,0.2,-0.1*l), vec3(0.35)*m );\n    d3 = smin( d3, d4, 0.1 );\n\n\treturn vec2(d3,d6);\n}\n\n\n// make all these zero for the rest position\nconst float headOffCenter = 0.5;\nconst vec3  headAngle = vec3(-0.2,-0.4,1.6);\n\nvec3 headTransform( in vec3 p )\n{\n    const vec3 ce = vec3(-2.6,1.7,headOffCenter);\n    \n    p -= ce;\n    p.xy = mat2(cos(headAngle.x),sin(headAngle.x),-sin(headAngle.x),cos(headAngle.x))*p.xy;\n    p.yz = mat2(cos(headAngle.y),sin(headAngle.y),-sin(headAngle.y),cos(headAngle.y))*p.yz;\n    p.xz = mat2(cos(headAngle.z),sin(headAngle.z),-sin(headAngle.z),cos(headAngle.z))*p.xz;\n    p += ce;\n    p.z -= headOffCenter;\n    \n    return p;\n}\n\nvec2 mapArlo( vec3 p )\n{\n// bounding volumes\n//res.x = min(res.x,length(p-vec3(-0.05,0.45,0.2))-3.5);\n//res.x = min(res.x,sdLine(p,vec3(-1.5,0.65,0.4),vec3(1.3,-0.7,0.2)).x-2.28);\n\n\n    // body\n    vec3 q = p;\n    float co = cos(0.2);\n    float si = sin(0.2);\n    q.xy = mat2(co,si,-si,co)*q.xy;\n    float d1 = sdEllipsoid( q, vec3(0.0,0.0,0.0), vec3(1.3,0.75,0.8) );\n    float d2 = sdEllipsoid( q, vec3(0.05,0.45,0.0), vec3(0.8,0.6,0.5) );\n    float d = smin( d1, d2, 0.4 );\n    \n    //neck wrinkles\n    float r = length(p-vec3(-1.2,0.2,0.0));\n    d -= 0.05*abs(sin(35.0*r))*exp(-7.0*abs(r)) * clamp(1.0-(p.y-0.3)*10.0,0.0,1.0);\n\n    // tail\n    {\n    vec2 b = sdBezier( vec3(1.0,-0.4,0.0), vec3(2.0,-0.96,-0.5), vec3(3.0,-0.5,1.5), p );\n    float tr = 0.3 - 0.25*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.2 );\n    }\n    \n    // neck\n    {\n    vec2 b = sdBezier( vec3(-0.9,0.3,0.0), vec3(-2.2,0.5,0.0), vec3(-2.6,1.7,headOffCenter), p );\n    float tr = 0.35 - 0.23*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.15 );\n\t}\n\n    float dn;\n    // front-left leg\n    {\n    vec2 d3 = leg( p, vec3(-0.8,-0.1,0.5), vec3(-1.5,-0.5,0.65), vec3(-1.9,-1.1,0.65), 1.0, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = d3.y;\n    }\n    // back-left leg\n    {\n    vec2 d3 = leg( p, vec3(0.5,-0.4,0.6), vec3(0.3,-1.05,0.6), vec3(0.8,-1.6,0.6), 0.5, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    // front-right leg\n    {\n    vec2 d3 = leg( p, vec3(-0.8,-0.2,-0.5), vec3(-1.0,-0.9,-0.65), vec3(-0.7,-1.6,-0.65), 1.0, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    // back-right leg\n    {\n    vec2 d3 = leg( p, vec3(0.5,-0.4,-0.6), vec3(0.8,-0.9,-0.6), vec3(1.6,-1.1,-0.7), 0.5, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n        \n    // head\n    p = headTransform(p);\n    vec3 s = vec3(p.xy,abs(p.z));\n    {\n    vec2 l = sdSegment( p, vec3(-2.7,2.36,0.0), vec3(-2.6,1.7,0.0) );\n    float d3 = l.x - (0.22-0.1*smoothstep(0.1,1.0,l.y));\n        \n    // mouth\n    vec3 mp = p-vec3(-2.7,2.16,0.0);\n    l = sdSegment( mp*vec3(1.0,1.0,1.0-0.2*abs(mp.x)/0.65), vec3(0.0), vec3(-3.35,2.12,0.0)-vec3(-2.7,2.16,0.0) );\n        \n    float d4 = l.x - (0.12 + 0.04*smoothstep(0.0,1.0,l.y));      \n    float d5 = sdEllipsoid( s, vec3(-3.4,2.5,0.0), vec3(0.8,0.5,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n        \n    d3 = smin( d3, d4, 0.1 );\n        \n    // mouth bottom\n    {\n    vec2 b = sdBezier( vec3(-2.6,1.75,0.0), vec3(-2.7,2.2,0.0), vec3(-3.25,2.12,0.0), p );\n    float tr = 0.11 + 0.02*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.001+0.06*(1.0-b.y*b.y) );\n    }\n        \n    // brows    \n    vec2 b = sdBezier( vec3(-2.84,2.50,0.04), vec3(-2.81,2.52,0.15), vec3(-2.76,2.4,0.18), s+vec3(0.0,-0.02,0.0) );\n    float tr = 0.035 - 0.025*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.025 );\n\n    // eye wholes\n    d4 = sdEllipsoid( s, vec3(-2.79,2.36,0.04), vec3(0.12,0.15,0.15) );\n    d3 = smax( d3, -d4, 0.025 );    \n        \n    // nose holes    \n    d4 = sdEllipsoid( s, vec3(-3.4,2.17,0.09), vec3(0.1,0.025,0.025) );\n    d3 = smax( d3, -d4, 0.04 );    \n        \n    d = smin( d, d3, 0.02 );\n    }\n    vec2 res = vec2(d,0.0);\n    \n    // eyes\n    float d4 = sdSphere( s, vec3(-2.755,2.36,0.045), 0.16 );\n    if( d4<res.x ) res = vec2(d4,1.0);\n    \n    float te = textureLod( iChannel0, 3.0*p.xy, 0.0 ).x;\n    float ve = normalize(p).y;\n    res.x -= te*0.01*(1.0-smoothstep(0.6,1.5,length(p)))*(1.0-ve*ve);\n    \n    if( dn<res.x )  res = vec2(dn,3.0);\n\n    return res;\n}\n\nvec2 legSimple( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdSegment( p, pa, pb );\n\n    float tr = 0.15;// - 0.2*b.y;\n    float d3 = b.x - tr;\n\n    b = sdSegment( p, pb, pc );\n    tr = 0.15;// - 0.2*b.y;\n    d3 = smin( d3, b.x - tr, 0.1 );\n\n    // paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.2,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.4,0.25,0.4) );\n\n    // nails\n    float d6 = sdEllipsoid( fc, vec3(0.32,-0.06,0.0)*(-1.0+2.0*h), 0.95*vec3(0.1,0.2,0.15));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.21*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.26), 0.95*vec3(0.1,0.2,0.15)) );\n    // space for nails\n    d4 = smax( d4, -d6, 0.03 );\n\n    // shape paw\n    float d5 = sdEllipsoid( fc, vec3(0.0,1.85*(-1.0+2.0*h),0.0), vec3(2.0,2.0,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n    d5 = sdEllipsoid( fc, vec3(0.0,-0.75*(-1.0+2.0*h),0.0), vec3(1.0,1.0,1.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n\n    d3 = smin( d3, d4, 0.1 );\n\n\treturn vec2(d3,d6);\n}\n\nfloat mapArloSimple( vec3 p )\n{\n    // body\n    vec3 q = p;\n    float co = cos(0.2);\n    float si = sin(0.2);\n    q.xy = mat2(co,si,-si,co)*q.xy;\n    float d1 = sdEllipsoid( q, vec3(0.0,0.0,0.0), vec3(1.3,0.75,0.8) );\n    float d2 = sdEllipsoid( q, vec3(0.05,0.45,0.0), vec3(0.8,0.6,0.5) );\n    float d = smin( d1, d2, 0.4 );\n    \n    // tail\n    {\n    vec2 b = sdBezier( vec3(1.0,-0.4,0.0), vec3(2.0,-0.96,-0.5), vec3(3.0,-0.5,1.5), p );\n    float tr = 0.3 - 0.25*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.2 );\n    }\n    \n    // neck\n    {\n    vec2 b = sdBezier( vec3(-0.9,0.3,0.0), vec3(-2.2,0.5,0.0), vec3(-2.6,1.7,0.0), p );\n    float tr = 0.35 - 0.23*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.15 );\n    //d = min(d,d3);\n\t}\n\n    float dn;\n    // front-left leg\n    {\n    vec2 d3 = legSimple( p, vec3(-0.8,-0.1,0.5), vec3(-1.5,-0.5,0.65), vec3(-1.9,-1.1,0.65), 1.0, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = d3.y;\n    }\n    // back-left leg\n    {\n    vec2 d3 = legSimple( p, vec3(0.5,-0.4,0.6), vec3(0.3,-1.05,0.6), vec3(0.8,-1.6,0.6), 0.5, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    // front-right leg\n    {\n    vec2 d3 = legSimple( p, vec3(-0.8,-0.2,-0.5), vec3(-1.0,-0.9,-0.65), vec3(-0.7,-1.6,-0.65), 1.0, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    // back-right leg\n    {\n    vec2 d3 = legSimple( p, vec3(0.5,-0.4,-0.6), vec3(0.8,-0.9,-0.6), vec3(1.6,-1.1,-0.7), 0.5, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    \n    // head\n    p = headTransform(p);\n    vec3 s = vec3(p.xy,abs(p.z));\n    {\n    vec2 l = sdSegment( p, vec3(-2.7,2.36,0.0), vec3(-2.6,1.7,0.0) );\n    float d3 = l.x - (0.22-0.1*smoothstep(0.1,1.0,l.y));\n        \n    // mouth\n    //l = sdLine( p, vec3(-2.7,2.16,0.0), vec3(-3.35,2.12,0.0) );\n    vec3 mp = p-vec3(-2.7,2.16,0.0);\n    l = sdSegment( mp*vec3(1.0,1.0,1.0-0.2*abs(mp.x)/0.65), vec3(0.0), vec3(-3.35,2.12,0.0)-vec3(-2.7,2.16,0.0) );\n        \n    float d4 = l.x - (0.12 + 0.04*smoothstep(0.0,1.0,l.y));      \n    float d5 = sdEllipsoid( s, vec3(-3.4,2.5,0.0), vec3(0.8,0.5,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n            \n    d3 = smin( d3, d4, 0.1 );\n\n    // mouth bottom\n    {\n    vec2 b = sdBezier( vec3(-2.6,1.75,0.0), vec3(-2.7,2.2,0.0), vec3(-3.25,2.12,0.0), p );\n    float tr = 0.11 + 0.02*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.001+0.06*(1.0-b.y*b.y) );\n    }\n        \n    // brows    \n    vec2 b = sdBezier( vec3(-2.84,2.50,0.04), vec3(-2.81,2.52,0.15), vec3(-2.76,2.4,0.18), s+vec3(0.0,-0.02,0.0) );\n    float tr = 0.035 - 0.025*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.025 );\n\n    d = smin( d, d3, 0.01 );\n    }\n    \n    return min(d,dn);\n}\n\nvec3 drddx, drddy;\n\nvec2 mapTerrain( vec3 p, float t )\n{\n    float h = -2.0+0.03;\n\n    h += 5.0*textureImproved( iChannel2, iChannelResolution[2].xy, 0.0004*p.xz, 0.0004*t*drddx.xz, 0.0004*t*drddy.xz ).x;\n    \n    float di = smoothstep(100.0,500.0,length(p.xz) );\n    h += 2.0*di;\n    h *= 1.0 + 3.0*di;\n\n\tconst float stonesClip = 100.0;\n    if( (p.y-h)<0.5 && t<stonesClip )\n    {\n        float at = 1.0-smoothstep( stonesClip/2.0, stonesClip, t );\n        float gr = textureGrad( iChannel2, 0.004*p.xz, 0.004*t*drddx.xz, 0.004*t*drddy.xz ).x;\n        float pi = textureGrad( iChannel0, 0.400*p.xz, 0.400*t*drddx.xz, 0.400*t*drddy.xz ).x;\n            \n        gr = smoothstep( 0.2, 0.3, gr-pi*0.3+0.15 );\n        h += at*(1.0-gr)*0.15*pi;\n        h += at*0.1*textureGrad( iChannel2, 0.04*p.xz, 0.04*t*drddx.xz, 0.04*t*drddy.xz ).x;\n    }\n\n    float d = 0.8*(p.y-h);\n    \n    return vec2(d,2.0);\n}\n\nfloat mapTotal( in vec3 pos )\n{\n    float d1 = mapArlo( pos ).x;\n    float d2 = mapTerrain( pos, length(pos) ).x;\n    return min(d1,d2);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTotal( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapTotal( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapTotal( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapTotal( pos + e.xxx ) );\n#else\n    // trick by klems, to prevent the compiler from inlining map() 4 times\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = mapTotal(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\nfloat calcOcclusionArlo( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));\n        dir = normalize( nor + dir );\n        occ += (h-mapArlo( pos + h*dir ).x);\n    }\n    return clamp( 1.0 - 9.0*occ/8.0, 0.0, 1.0 );    \n}\n\nfloat calcOcclusionTerrain( in vec3 pos, in vec3 nor, float t )\n{\n\tfloat occ = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));\n        dir = normalize( nor + dir );\n        occ += (h-mapTerrain( pos + h*dir, t ).x);\n    }\n    return clamp( 1.0 - 9.0*occ/8.0, 0.0, 1.0 );    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadowArlo( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    \n    // check bounding volume first\n    vec2 bv = sphIntersect( ro, rd, vec4(-0.05,0.45,0.2,3.5) );\n    if( bv.y>0.0 )\n    {\n        float t = 0.01;\n        if( bv.x>0.0 ) t=max(t,bv.x);\n        for( int i=0; i<32; i++ )\n        {\n            float h = mapArloSimple(ro + rd*t );\n            res = min( res, k*h/t );\n            t += clamp( h, 0.04, 0.5 );\n\t\t    if( res<0.01 || t>bv.y) break;\n        }\n        res = smoothstep(0.0,1.0,res);\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadowTerrain( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    float t = 0.1;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = mapTerrain(pos, length(pos)).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.05, 10.0 );\n\t\tif( res<0.01 ) break;\n    }\n    return smoothstep(0.0,1.0,res);\n}\n\n// https://iquilezles.org/articles/filteringrm\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 rdx, in vec3 rdy )\n{\n    const vec3 sunDir = normalize( vec3(0.1,0.05,0.2) );\n    const float eps = 0.001;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps*t );\n    float kk;\n\n    vec3 mateD = vec3(0.2,0.16,0.11);\n    vec3 mateS = vec3(0.2,0.12,0.07);\n    float mateK = 0.0;\n    float mateN = 16.0;\n    float focc = 1.0;\n    \n    // derivatives\n    vec3 dposdx = t*drddx;\n    vec3 dposdy = t*drddy;\n    calcDpDxy( ro, rd, rdx, rdy, t, nor, dposdx, dposdy );\n\n    if( m<0.5 ) // arlo\n    {\n        mateD = vec3(0.05,0.2,0.04)*0.7;\n        mateS = vec3(2.0,1.0,1.0)*0.5;\n    \n        // back\n        float pz = smoothstep(0.0,1.0,max(0.0,pos.y-0.0));\n        float pp = smoothstep( 0.6, 1.6, sin(pos.x*18.0) + pz*1.5 );\n        pp *= 1.0-smoothstep(0.1,1.5,length(pos-vec3(0.0,1.0,0.0)));\n        mateD = mix( mateD, vec3(0.05,0.2,0.08)*0.54, pp );         \n    \n        // nose\n        mateD = mix( mateD, vec3(0.13,0.21,0.04)*0.7,1.0-smoothstep(0.0,0.5,length(pos-vec3(-3.45,2.15,0.0))));\n\n        // belly\n        mateD = mix( mateD, vec3(0.16,0.22,0.10)*0.55,smoothstep(0.5,1.0,-nor.y)*(1.0-smoothstep(0.9,1.2,length(pos))));\n\n        // neck\n        vec2 b = sdSegment( pos, vec3(-0.9,-0.3,0.0), vec3(-2.6,1.7,0.0) );\n        float tr = 0.3;// - 0.25*b.y;\n        float d3 = b.x - tr;\n        float bn = 1.0-smoothstep(0.05,0.15,d3);\n        bn *= smoothstep(0.0,0.5,-nor.y);\n        bn *= 1.0-smoothstep(0.7,1.0,b.y);\n        mateD = mix( mateD, vec3(0.1,0.23,0.07)*0.7,bn);\n\n        vec3 tc = texcube( iChannel1, 0.2*pos, nor, 4.0, 0.2*dposdx, 0.2*dposdy ).xyz;\n        mateD *= 0.7+0.6*tc*tc;\n\n        float te = texcube( iChannel0, 2.0*pos, nor, 4.0, 2.0*dposdx, 2.0*dposdy ).x;\n        mateD *= 0.9 + 0.1*te;    \n    \n        mateK = 0.75*(0.5+0.5*tc.x*te);\n        \n        mateD.z += 0.05*(texcube( iChannel1, 0.025*pos, nor, 4.0, 0.025*dposdx, 0.025*dposdy ).x-0.5);\n    }\n\telse if( m<1.5 ) // eyes\n    {\n        vec3 uvw = headTransform(pos);\n        mateD = vec3(0.2,0.2,0.2)*0.7;\n        mateK = 2.0;\n        mateS = vec3(0.4);\n        mateN = 128.0;\n        vec3 cen = vec3(-2.755,2.36,0.1*sign(uvw.z));\n        vec3 dir = normalize(uvw-cen);\n        vec3 view = vec3(-1.0,-0.1,0.1);//normalize( ro-(cen) );\n        float d = dot( dir, view ); \n        \n        float p = 1.0-smoothstep( 0.82, 0.83, d );\n        mateD *= p;\n        mateS *= p;\n        float r  = pow(clamp( (d-0.83)/(1.0-0.83),0.0,1.0),2.0);\n        \n        float br = 3.5*pow(clamp(dot( nor, view ),0.0,1.0),32.0);\n        mateD = mix( mateD, vec3(0.03,0.015,0.0)*2.5*(1.0+br), smoothstep(0.0,0.05,r) );\n        mateD = mix( mateD, vec3(0.00,0.000,0.0), smoothstep(0.5,0.60,r) );\n        \n        float ff = smoothstep( 0.0, 0.1, -uvw.x-2.75 );\n        mateD *= ff;\n        mateS *= ff;\n        mateK *= ff;\n    }\n\telse if( m<2.5 ) // terrain\n    {\n        mateD = vec3(0.1,0.05,0.02);\n        mateD = pow( textureGrad( iChannel1, 0.3*pos.xz, 0.3*dposdx.xz, 0.3*dposdy.xz ).xyz, vec3(1.5))*0.3*vec3(1.1,1.0,0.9);\n        mateK = 1.0;\n        mateS = vec3(0.0,0.0,0.0);\n        focc = textureGrad( iChannel0, 0.5*pos.xz, 0.5*dposdx.xz, 0.5*dposdy.xz ).x;\n        \n        // grass        \n        float gr = textureGrad( iChannel2, 0.004*pos.xz, 0.004*dposdx.xz, 0.004*dposdy.xz ).x;\n        float pi = textureGrad( iChannel0, 0.400*pos.xz, 0.400*dposdx.xz, 0.400*dposdy.xz ).x;\n        gr = smoothstep( 0.2, 0.3, gr-pi*0.3+0.15 );\n        float hi = smoothstep( 0.85, 1.0, nor.y )*gr;//iq\n        mateD = mix( mateD, vec3(0.25,0.14,0.0)*0.4*(0.75+0.5*pi), hi );\n        focc = mix( focc, 1.0, hi );\n        mateK *= 1.0-hi;\n        \n        mateD *= 0.9;\n    }\n\telse //if( m<3.5 ) // nails\n    {\n        mateD = vec3(0.12,0.12,0.05)*1.3;\n        mateK = 0.0;\n        mateS = vec3(0.0,0.0,0.0);\n        float gr = texcube( iChannel2, 0.8*pos*vec3(1.0,0.2,1.0), nor, 4.0, 0.8*dposdx*vec3(1.0,0.2,1.0), 0.8*dposdy*vec3(1.0,0.2,1.0) ).x;\n        mateD *= 0.6 + 0.8*gr;\n    }    \n    \n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = min(calcOcclusionArlo(pos,nor),\n                    calcOcclusionTerrain(pos,nor,t) )*focc;\n        \n\n    vec3 col = vec3(0.0);\n    // sun\n    {\n    float dif = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    if( dif>0.0 )\n    {\n        dif *= min( calcShadowArlo( pos, sunDir, 32.0 ),\n                    calcShadowTerrain( pos, sunDir, 32.0 ) );\n    }\n    dif = clamp(dif, 0.0, 1.0 );\n    vec3  hal = normalize( sunDir-rd );\n    float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n    float sli = 0.04+0.96*pow(clamp(1.0-dot(hal,sunDir),0.0,1.0),5.0);\n    col += mateD*4.0*vec3(1.1,0.7,0.3)*dif;\n    col +=      12.0*vec3(1.0,0.9,0.8)*dif*pow(spe,mateN)*mateK*sli;\n    // sss\n    col += mateD*10.0*fre*(0.2+0.8*dif*occ)*mateS;\n    }\n    \n    // sky dome\n    {\n    float dif = occ*(0.5+0.5*nor.y);\n    float spe = smoothstep( -0.2, 0.2, reflect( rd, nor ).y );\n    float sli = 0.04+0.96*pow(fre,5.0);\n    col += mateD*5.4*vec3(0.2,0.6,1.3)*dif;\n    col +=       3.0*vec3(0.3,0.4,1.0)*dif*mateK*spe*sli*occ;\n    }\n    \n    // ground bounce\n    {\n    float bou = clamp( 0.5-0.5*nor.y, 0.0, 1.0 );\n    col += mateD*2.5*vec3(0.4,0.1,0.1)*bou*(0.5+0.5*occ);\n    }\n    \n    // back bounce\n    {\n    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );\n    col += mateD*1.0*vec3(0.8,0.5,0.4)*bak*occ;\n    }\n\n    // fog\n    col = mix( col, vec3(0.4,0.5,0.8), 1.0-exp(-.0007*t));\n    \n    return col;        \n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0);\n    float maxdist = 1500.0;\n    \n    // Arlo\n    vec2 bv = sphIntersect( ro, rd, vec4(-0.05,0.45,0.2,3.5) );\n    if( bv.y>0.0 )\n    {\n        vec2 tmp;\n        float t = 8.0;\n        if( bv.x>0.0 ) t = max( t, bv.x );\n        for( int i=0; i<128; i++ )\n        {\n            vec3 p = ro + t*rd;\n            vec2 h = mapArlo( p );\n            tmp = vec2(t,h.y);\n            if( h.x<(0.0001*t) ||  t>bv.y ) break;\n            t += h.x*0.9;\n        }\n        if( t<bv.y )\n        {\n            maxdist = t;\n            res = tmp;\n        }\n    }\n        \n    // terrain\n    float tp = (55.0-ro.y)/rd.y;\n    {\n        if( tp>0.0 ) maxdist = min(maxdist,tp);\n        float t = 5.0;\n        vec2 tmp;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 p = ro + t*rd;\n            vec2 h = mapTerrain( p, t );\n            tmp = vec2(t,h.y);\n            if( h.x<(0.0001*t) || t>maxdist ) break;\n            t += h.x*0.75;\n        }\n\n        if( t<maxdist )\n        {\n            res = tmp;\n        }\n    }\n    \n    return res;\n}\n\nfloat cloud( in vec2 uv )\n{\n    uv = uv.yx;\n    \n    float f  = 0.5*texture( iChannel0, uv*1.0 ).x;\n          f += 0.3*texture( iChannel0, uv*2.1 ).x;\n          f += 0.2*texture( iChannel2, uv*0.5 ).x;\n          f += 0.1*texture( iChannel2, uv*1.1 ).x;\n    \n    return smoothstep(0.3,1.0,f);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{\n    // sky\n    vec3 col = clamp(vec3(0.2,0.4,0.5)*1.3 - rd.y,0.0,1.0);\n    \n    // clouds\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n    vec2 uv = (ro+t*rd).xz;\n    float cl1 = cloud( .000051*uv );\n\tfloat cl2 = cloud( .000051*(uv+200.0*rd.xz));\n    vec3 ccol = mix( vec3(0.3,0.1,0.3)*0.55, vec3(1.5,0.4,0.1)*3.0, clamp(cl2-cl1,0.0,1.0) );\n    col = mix( col, ccol, cl1 );\n    }\n    // horizon\n    col = mix( col, vec3(0.4,0.5,0.6), exp(-abs(15.0*rd.y)) ) ;\n\n    vec2 tm = raycast( ro, rd );\n    if( tm.y>-0.5  )\n    {\n        col = shade( ro, rd, tm.x, tm.y, rdx, rdy );\n    }\n\n    return pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // camera\n    float an = 5.9 - 0.5*cos(0.07*(iTime-10.0));\n    vec3 ro = vec3(12.5*sin(an),0.45,12.5*cos(an));\n    vec3 ta = vec3(0.0,0.6,0.0);\n\n    // ray\n    mat3 ca = setCamera( ro, ta, -0.05 );\n    vec3 rd = normalize( ca * vec3(p,-4.5) );\n\n    // ray differentials\n    vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n    vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n    vec3 rdx = normalize( ca * vec3(px,-4.5) );\n    vec3 rdy = normalize( ca * vec3(py,-4.5) );\n    drddx = rdx - rd;\n    drddy = rdy - rd;\n\n    // render\n    vec3 col = render( ro, rd, rdx, rdy);\n\n    //float sun = clamp( 0.2 + 0.8*dot(rd,sunDir), 0.0, 1.0 );\n\t//col += vec3(0.4,0.3,0.2)*1.0*pow(sun,8.0);\n\n    // grade\n    col = col*0.6 + 0.4*col*col*(3.0-2.0*col);\n        \n    // vignette    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}