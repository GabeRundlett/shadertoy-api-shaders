{
    "Shader": {
        "info": {
            "date": "1678258160",
            "description": "An experiment with volumetric rendering. Voxel shadows are precomputed in buffer A.\n\n*WASD/QE to control camera*\n*mouse to move light*\n*P to toggle animation*\n*Left/right arrows to change voxel resolution*\n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "ds3Gz8",
            "likes": 15,
            "name": "Cloudy Volumetric Torus",
            "published": 3,
            "tags": [
                "noise",
                "torus",
                "clouds",
                "cloud",
                "light",
                "voxel",
                "volumetric",
                "transparent",
                "translucent"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 330
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  An experiment with volumetric rendering. Voxel shadows are precomputed in buffer A. I\n//  chose a torus as a subject because you can see interesting shadows cast across the hole.\n//  \n//  This shader operates on the same basic principle as tmst's\n//\n//      Volumetric lighting                        https://shadertoy.com/view/tdjBR1\n//\n//  Meaning, the light reaching each point in a 3D space is pre-computed, which is then\n//  used during rendering. You can see the benefit first-hand of the precomputation by\n//  disbling ENABLE_LIGHT_BUFFER in the Common tab. I'm hoping to keep going and make some\n//  more shaders using this rendering engine. As such, any and all suggestions are welcome!\n//  \n//  The voxel grid has variable dimensions; press the left and right arrows to change the\n//  resolution. A fly cam is available; WASD to move horizontally and RF to move up and down.\n//  You can move the light source with the mouse.\n//\n//  I really phoned in the light scattering computations here...just faked it with a bit\n//  more blue light being bounced/absorbed. Advice about that would be particularly\n//  appreciated. I understand the basic ideas of Rayleigh and Mie scattering, and I've \n//  tried to approximate the effects by coloring the bounced and blocked light. Am I\n//  missing out on some feature(s) that I'd get with a more rigorous approach? Currently\n//  the light precalculation only computes shadows from the light source...maybe I should\n//  try looking at other nearby voxels for bounced light? But which ones and how many?\n//\n//  Another thing I feel a bit stuck on is trying to limit the visible voxel blocks. I tried\n//  blurring but that seemed to cost definition. I am rendering the voxels as actual box\n//  volumes so they should be soft at their edges, but the voxel edges are still apparent.\n//  tmst's Volumetric Lighting looks super smooth though, how does he do it? Do I need to \n//  interpolate density between voxels? The only way I can think do to that would be very\n//  expensive.\n//\n//  I tried two different voxel traversal algorithms, from these two shaders:\n//\n//      fb39ca4's  Branchless Voxel Raycasting:    https://shadertoy.com/view/4dX3zl\n//      mhnewman's Cube Falls:                     https://shadertoy.com/view/dtSGWd\n//\n//  I've used the math from \"Branchless Voxel Raycasting\" on other shaders so I was curious\n//  to try mhnewman's when I noticed it was different. You can switch between implementations\n//  with ENABLE_BRANCHLESS_VOXELS in the Common tab. On my graphics card, it looks like the\n//  Cube Falls traversal is slightly faster. If you are getting the opposite that would be\n//  interesting to hear about. If you want to try to compare, I recommend pressing P to pause\n//  the animation, to get more consistent FPS readings.\n//\n//  Buffer A computes the light reaching each voxel by traversing ray towards light\n//  Image computes each pixel by traversing voxels from camera\n//\n// ---------------------------------------------------------------------------------------\n\n// super-cheesy colorization: block a bit more blue light and also bounce a bit more blue light\n// is this oversimplifying things? or is bluifying the bounced rays and redifying the transmitted rays close enough?\nconst vec3 LIGHT_BLOCK = vec3(1, .8, .5) * 1.;\nconst vec3 LIGHT_BOUNCE = vec3(.8, .8, 1) * 1.;\n\n// https://iquilezles.org/articles/boxfunctions/\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n\n    return vec2( tN, tF );\n}\n\n#if ENABLE_BRANCHLESS_VOXELS\n// voxel traversal loop from fb39ca4's Branchless Voxel Raycasting: https://shadertoy.com/view/4dX3zl/\nvoid castRay(vec3 cameraPos, vec3 rayDir, int maxIter, float maxDist, out float dist, out vec3 norm, inout vec3 color)\n{\n    float totalD = 1.;\n    vec3 totalL = vec3(0);\n\n\tivec3 mapPos = ivec3(floor(cameraPos + 0.));\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    ivec3 rayStep = ivec3(sign(rayDir));\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - cameraPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n    bool hit = false;\n    dist = 0.;\n\t\n\tfor (int i = 0; i < maxIter && dist < maxDist; i++)\n    {\n        float voxelD = voxelDensity(vec3(mapPos), iChannel2);\n        if (voxelD > MIN_DENS)\n        {\n            vec2 ts = boxIntersection(cameraPos - vec3(mapPos) - .5, rayDir, vec3(.5));\n            voxelD *= (ts.y - ts.x) / 2.; // fade towards voxel edges\n            \n            totalD -= voxelD;\n            totalL *= 1. - LIGHT_BLOCK * voxelD; // block light coming from point by density in this voxel\n            \n#if ENABLE_LIGHT_BUFFER\n            uvec3 addr = uvec3(vec3(mapPos) + vec3(g_VoxelSide / 2u, 0, g_VoxelSide / 2u));\n            uvec2 coords = coordFromAddr(addr, uint(iResolution.x));\n            float light = texelFetch(iChannel0, ivec2(coords), 0).x;            \n#else\n            vec3 delta = vec3(mapPos) - g_State.lightPos;\n            vec3 lightDir = -normalize(delta);\n            float block = integrateDensityAlongRay(vec3(mapPos) + .5 + lightDir, lightDir, int(g_VoxelSide), 100., iChannel2, iTime);\n            float light = max(AMBIENT_LIGHT, block * LIGHT_INTENS * length2(g_State.lightPos) / length2(delta));\n#endif\n\n            totalL += LIGHT_BOUNCE * voxelD * light; // add light contribution from bounced light\n\n            if (totalD <= 0.)\n            {\n                totalD = 0.; // cloud is dense enough to be opaque; abort\n                break;\n            }\n        }\n\n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n        \n        vec3 perpWallDist = sideDist - deltaDist;\n        dist = max(max(perpWallDist.x, perpWallDist.y), perpWallDist.z);\n\t}\n\t\n\tcolor = color * totalD + totalL;\n}\n#else\n// voxel traversal loop from mhnewman's Cube Falls: https://shadertoy.com/view/dtSGWd\nvoid castRay(vec3 eye, vec3 ray, int maxIter, float maxDist, out float dist, out vec3 norm, inout vec3 color)\n{\n    float totalD = 1.;\n    vec3 totalL = vec3(0);\n\n    vec3 pos = floor(eye);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 ris = ri * rs;\n    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;\n    \n    vec3 dim = vec3(0);\n    dist = 0.;\n    for (int i = 0; i < maxIter && dist < maxDist; ++i)\n    {\n        float voxelD = voxelDensity(pos, iChannel2);\n        if (voxelD > MIN_DENS)\n        {\n            vec2 ts = boxIntersection(eye - pos - .5, ray, vec3(.5));\n            voxelD *= (ts.y - ts.x) / 2.; // fade towards voxel edges\n            \n            totalD -= voxelD;\n            \n#if ENABLE_LIGHT_BUFFER\n            uvec3 addr = uvec3(pos + vec3(g_VoxelSide / 2., 0, g_VoxelSide / 2.));\n            uvec2 coords = coordFromAddr(addr, uint(iResolution.x));\n            float light = texelFetch(iChannel0, ivec2(coords), 0).x;            \n#else\n            vec3 delta = pos - g_State.lightPos;\n            vec3 lightDir = -normalize(delta);\n            float block = integrateDensityAlongRay(pos + .5 + lightDir, lightDir, int(g_VoxelSide), 100., iChannel2, iTime);\n            float light = max(AMBIENT_LIGHT, block * LIGHT_INTENS * length2(g_State.lightPos) / length2(delta));\n#endif\n\n            totalL += pow(LIGHT_BLOCK, vec3(1. - totalD)) * voxelD * light * LIGHT_BOUNCE; // add light contribution from bounced light\n\n            if (totalD <= 0.)\n            {\n                totalD = 0.; // cloud is dense enough to be opaque; abort\n                break;\n            }\n\n        }\n    \n        dim = step(dis, dis.yzx);\n\t\tdim *= (1.0 - dim.zxy);\n        \n        dis += dim * ris;\n        pos += dim * rs;\n        \n        dist = dot(dis - ris, dim);\n    }\n    \n\tcolor = color * totalD + totalL;\n}\n#endif\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 u )\n{\n    fxGetState();\n    computeVoxelSide(iResolution.xy);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n    \n    vec2 ts = boxIntersection(cameraPos - vec3(0, g_VoxelSide / 2., 0), rayDir, vec3(g_VoxelSide / 2.));\n    \n    float dist = 1e6;\n    fragColor.rgb = vec3(.01,.01,.05) + .1 * u.y / iResolution.y;\n    if (ts.x != -1.)\n    {\n        vec3 norm;\n        castRay(cameraPos + rayDir * ts.x, rayDir, int(g_VoxelSide) * 2, ts.y - ts.x, dist, norm, fragColor.rgb);\n    }\n    \n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.a = dist;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float LIGHT_INTENS = .15; // light intensity\nconst float AMBIENT_LIGHT = .05; // ambient light\nconst float MIN_DENS = 1e-3; // miminum density\n\n#define ENABLE_LIGHT_BUFFER 1 // disable to test buffer A light pre-computation\n#define ENABLE_BRANCHLESS_VOXELS 0 // enable to test alternate voxel traveral math\n\n// UTILITY\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nfloat length2(vec3 v) { return dot(v, v); }\n\nconst float PI = 3.141592653589793;\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_Q 81\n#define KEY_E 69\n\n#define KEY_P 80\n\n// STATE MANAGEMENT\n\nstruct fxState\n{\n    vec3 lightPos;\n    float camAngle;\n    float camPitch;\n    float camOrbit;\n    float resolution;\n    float bufferScale;\n    float animation;\n    bool animationPaused;\n} g_State;\n\nvoid fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(0, 1), 0);\n    vec4 data2 = texelFetch(sampler, ivec2(0, 2), 0);\n    \n    g_State.camAngle = data0.x;\n    g_State.camPitch = data0.y;\n    g_State.camOrbit = data0.z;\n    g_State.resolution = data0.w;\n    g_State.bufferScale = data1.x;\n    g_State.animation = data1.y;\n    g_State.animationPaused = data1.z != 0.;\n    g_State.lightPos = data2.xyz;\n}\n\n#define fxGetState() fxGetStateImpl(iChannel0)\n\nvec4 fxPutState(ivec2 ifc)\n{\n    if (ifc == ivec2(0, 2))\n        return vec4(g_State.lightPos, 0);\n    else if (ifc == ivec2(0, 1))\n        return vec4(g_State.bufferScale, g_State.animation, g_State.animationPaused ? 1. : 0., 0);\n    \n    return vec4(g_State.camAngle, g_State.camPitch, g_State.camOrbit, g_State.resolution);\n}\n\nbool fxIsStatePixel(ivec2 ifc)\n{\n    return ifc == ivec2(0) || ifc == ivec2(0, 1) || ifc == ivec2(0, 2);\n}\n\nconst uint NUM_STATE_PIXELS = 3u;\n\n// VOXELS\n\n// the length of the side of the voxel cube\nfloat g_VoxelSide = 0.;\n\n// compute the largest voxel side length that will fit in our buffer\nvoid computeVoxelSide(vec2 res)\n{\n    float pixels = res.x * res.y * g_State.bufferScale;\n    g_VoxelSide = trunc(pow(pixels, 1./3.));\n}\n\n// compute the voxel address from the buffer coordinates where its data is stored\nuvec3 addrFromCoord(uvec2 p, uint width)\n{\n    uint id = p.y * width + p.x - NUM_STATE_PIXELS;\n    uint y = id / uint(g_VoxelSide * g_VoxelSide);\n    uint xz = id - y * uint(g_VoxelSide * g_VoxelSide);\n    uint x = xz / uint(g_VoxelSide);\n    uint z = xz - x * uint(g_VoxelSide);\n    return uvec3(x, y, z);\n}\n\n// compute the buffer coordinates for a particular voxel\nuvec2 coordFromAddr(uvec3 p, uint width)\n{\n    uint id = p.z + uint(g_VoxelSide) * p.x + uint(g_VoxelSide) * uint(g_VoxelSide) * p.y + NUM_STATE_PIXELS;\n    uint y = id / width;\n    uint x = id - y * width;\n    return uvec2(x, y);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraPos = vec3(0, 0, g_State.camOrbit * float(g_VoxelSide));\n    cameraPos.yz *= rotate(g_State.camPitch);\n    cameraPos.xz *= rotate(g_State.camAngle);\n    cameraPos.y += g_VoxelSide / 2.;\n    cameraLookAt = vec3(0, g_VoxelSide / 2., 0);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    vec3 up = vec3(0,1,0);\n    cameraLeft = -normalize(cross(cameraFwd, up));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\n// DENSITY MAP\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map(vec3 p, sampler3D noiseSampler)\n{\n    return .45 * textureLod(noiseSampler, p, 0.).x\n         + .22 * textureLod(noiseSampler, 2.3 * p, 0.).x\n         + .2  * textureLod(noiseSampler, 4.4 * p, 0.).x\n         + .05 * textureLod(noiseSampler, 6.3 * p, 0.).x\n         - .3;\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nfloat boxDistance( in vec3 p, in vec3 rad ) \n{\n    vec3 d = abs(p)-rad;\n    return length(max(d,0.0)) + min(max(max(d.x, d.y), d.z),0.0);\n}\n\nfloat voxelDensity(vec3 pos, sampler3D noiseSampler)\n{\n    float time = g_State.animation;\n    vec3 p2 = pos - vec3(0, g_VoxelSide / 2., 0);\n    if (boxDistance(p2, vec3(g_VoxelSide / 2.)) >= 0.) return 0.; // first cull to the voxel bounding box\n\n    p2.xz *= rotate(1.6);\n    p2.yx *= rotate(time*.2);\n    \n    float shape = 1. - sdTorus(p2/(g_VoxelSide / 7.), vec2(2, .5));\n\n    if (shape <= MIN_DENS) return 0.; // don't compute the noise where there is no torus\n\n    return max(0., map(pos * .4 / float(g_VoxelSide) + time * .008, noiseSampler) * shape);\n}\n\n#if ENABLE_BRANCHLESS_VOXELS\n// voxel traversal loop from fb39ca4's Branchless Voxel Raycasting: https://shadertoy.com/view/4dX3zl/\nfloat integrateDensityAlongRay(vec3 cameraPos, vec3 rayDir, int maxIter, float maxDist, sampler3D noiseSampler, float iTime)\n{\n\tivec3 mapPos = ivec3(floor(cameraPos + 0.));\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    ivec3 rayStep = ivec3(sign(rayDir));\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - cameraPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n\t\n    float totalD = 1.;\n    float dist = 0.;\n\tfor (int i = 0; i < maxIter && dist < maxDist && totalD > 0.; ++i)\n    {\n        totalD -= voxelDensity(vec3(mapPos), noiseSampler) * .5;\n\n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n        \n        vec3 perpWallDist = sideDist - deltaDist;\n        dist = max(max(perpWallDist.x, perpWallDist.y), perpWallDist.z);\n\t}\n    \n  \treturn max(0., totalD);\n}\n#else\n// voxel traversal loop from mhnewman's Cube Falls: https://shadertoy.com/view/dtSGWd\nfloat integrateDensityAlongRay(vec3 eye, vec3 ray, int maxIter, float maxDist, sampler3D noiseSampler, float iTime)\n{\n    vec3 pos = floor(eye);\n    vec3 ri = 1. / ray;\n    vec3 rs = sign(ray);\n    vec3 ris = ri * rs;\n    vec3 dis = (pos - eye + .5 + rs * .5) * ri;\n    \n    vec3 dim = vec3(0);\n    \n    float dist = 0.;\n    float totalD = 1.;\n    for (int i = 0; i < maxIter && dist < maxDist && totalD > 0.; ++i)\n    {    \n        totalD -= voxelDensity(pos, noiseSampler) * .5;\n        \n        dim = step(dis, dis.yzx);\n\t\tdim *= (1. - dim.zxy);\n        \n        dis += dim * ris;\n        pos += dim * rs;\n        \n        dist = dot(dis - ris, dim);\n    }\n\n\treturn max(0., totalD);\n}\n#endif\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes the light reaching each voxel\n// ---------------------------------------------------------------------------------------\n\nvoid updateCamera()\n{\n    if (keyDown(KEY_W)) g_State.camPitch -= .1;\n    if (keyDown(KEY_S)) g_State.camPitch += .1;\n    g_State.camPitch = clamp(g_State.camPitch, -1.5, 1.5);\n    if (keyDown(KEY_A)) g_State.camAngle -= .1;\n    if (keyDown(KEY_D)) g_State.camAngle += .1;\n    if (keyDown(KEY_Q)) g_State.camOrbit += .1;\n    if (keyDown(KEY_E)) g_State.camOrbit -= .1;\n    g_State.camOrbit = max(.1, g_State.camOrbit);\n}\n\nvoid updateLightPos()\n{\n    vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    if (iMouse.z > 0.)\n    {\n        g_State.lightPos = vec3(m.x * 300., m.y * 300., 200);\n        g_State.lightPos = trunc(g_State.lightPos) + .5;\n    }\n}\n\nbool updateState(ivec2 ifc)\n{\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(g_State.resolution))\n    {\n        g_State.lightPos = vec3(-300, 200, 200);\n        g_State.resolution = -iResolution.x * iResolution.y;\n        g_State.camAngle = .001;\n        g_State.camPitch = .1;\n        g_State.camOrbit = 1.2;\n        g_State.bufferScale = 1.;\n        g_State.animation = 8.;\n        g_State.animationPaused = false;\n    }\n    else\n    {\n        g_State.resolution = abs(g_State.resolution);\n\n        updateCamera();\n        updateLightPos();\n\n        if (keyDown(KEY_LEFT)) g_State.bufferScale *= .99;\n        if (keyDown(KEY_RIGHT)) g_State.bufferScale /= .99;\n        \n        if (keyClick(KEY_P)) g_State.animationPaused = !g_State.animationPaused;\n        \n        if (!g_State.animationPaused) g_State.animation += iTimeDelta;\n\n        g_State.bufferScale = min(1., g_State.bufferScale);\n    }\n\n    return fxIsStatePixel(ifc);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fxGetState();\n    \n    ivec2 ifc = ivec2(fragCoord);\n    if (updateState(ifc))\n    {\n\n        fragColor = fxPutState(ifc);\n        return;\n    }\n\n#if ENABLE_LIGHT_BUFFER\n    computeVoxelSide(iResolution.xy);\n\n    uvec3 addr = addrFromCoord(uvec2(ifc), uint(iResolution.x));\n    \n    if (addr.y >= uint(g_VoxelSide)) return;\n    \n    vec3 pos = vec3(addr) - vec3(g_VoxelSide / 2., 0, g_VoxelSide / 2.);\n    float dens = voxelDensity(pos, iChannel2);\n\n    if (dens < MIN_DENS)\n    {\n        fragColor.x = 0.; // skip voxels with no density...we'll never query them\n        return;\n    }\n    \n    vec3 delta = pos - g_State.lightPos;\n    vec3 lightDir = -normalize(delta);\n    float block = integrateDensityAlongRay(pos + .5 + lightDir, lightDir, int(g_VoxelSide), 100., iChannel2, iTime);\n    fragColor.x = max(AMBIENT_LIGHT, block * LIGHT_INTENS * length2(g_State.lightPos) / length2(delta));\n#endif // ENABLE_LIGHT_BUFFER\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}