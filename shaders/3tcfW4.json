{
    "Shader": {
        "info": {
            "date": "1612702966",
            "description": "Another variation of the Mandelbox.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tcfW4",
            "likes": 6,
            "name": "Mandelbox MB-4",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "mandelbox"
            ],
            "usePreview": 0,
            "username": "darkeclipz",
            "viewed": 373
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define MaxSteps 50.\n#define MinDistance 0.001\n#define eps 0.001\n\n// more ideas for different Mandelboxes:\n// http://archive.bridgesmathart.org/2018/bridges2018-547.pdf\n\nfloat distFromOrigin = 0.0;\nfloat lissoujasSize = 3.5;\n\nvec3 magma(float t) { // from Mattz\n    t *= 2.0;\n    if(t > 1.0) { t = 2.0-t; }\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 viridis_quintic( float x )\n{\n    x *= 2.0;\n    if(x > 1.0) { x = 2.0-x; }\n\t//x = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\n// from iq\nfloat sdPlane(in vec3 p, in vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n// from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n        \n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 boxFold(vec3 z, vec3 r) {\n\treturn clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n// http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    // float c2 = distFromOrigin / lissoujasSize * 3.5;\n    float c2 = distFromOrigin / lissoujasSize * 3.8;\n    float fixedRadius2 = 6.5 - c2;\n    float minRadius2 = 0.3;\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t\tdz*=temp;\n\t} \n    else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t\tdz*=temp;\n\t}\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 mengerFold(vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n    return z;\n}\n\n\n\n// http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\nvec2 DE(vec3 z)\n{\n    float Iterations = 20.;\n    \n    float c1 = (distFromOrigin/lissoujasSize)*2.5;\n    float Scale = 2. + c1;\n    \n    //Scale = 5.8-(distFromOrigin/lissoujasSize)*1.5;\n\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n    float trap = 1e10;\n\tfor (float n = 0.; n < Iterations; n++) {\n        //z = mengerFold(z);\n        z = boxFold(z, vec3(2.2));       // Reflect\n        sphereFold(z, dr);    // Sphere Inversion\n        z.xz = -z.zx;\n        //sphereFold(z, dr);    // Sphere Inversion\n\t\tz = boxFold(z, vec3(0.9));       // Reflect\n        \n\t\tsphereFold(z, dr);    // Sphere Inversion\n        z=Scale*z + offset;  // Scale & Translate\n        dr = dr*abs(Scale)+1.0;\n        trap = min(trap, length(z));\n\t}\n\tfloat r = length(z);\n\treturn vec2(r/abs(dr), trap);\n}\n\nvec2 scene(vec3 p) {  \n    \n    vec2 box = DE(p);\n\treturn box;\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p).x;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0.2, i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        t += dt;\n        if(dt < MinDistance*(1.0+t/10.0)) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\nfloat G1V(float dotNV, float k) {\n    return 1.0 / (dotNV * (1.0 - k) + k);\n}\n\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat brdf_ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    float alpha = roughness * roughness;\n    vec3 H = normalize(V+L);\n    float dotNL = clamp(dot(N,L), 0., 1.);\n    float dotNV = clamp(dot(N,V), 0., 1.);\n    float dotNH = clamp(dot(N,H), 0., 1.);\n    float dotLH = clamp(dot(L,H), 0., 1.);\n    float alphaSqr = alpha*alpha;\n    float pi = 3.14159;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (pi * denom * denom);\n    float dotLH5 = pow(1.0 - dotLH, 5.0);\n    float F = F0 + (1.0 - F0) * dotLH5;\n    float k = alpha / 2.0;\n    float vis = G1V(dotNL, k) * G1V(dotNV, k);\n    return dotNL * D * F * vis;\n}\n\nvec3 calcLight(vec3 P, vec3 N, vec3 Lpos, vec3 V, vec3 diffuse, vec3 specular) {\n    vec3 L = normalize(Lpos-P);\n    float NdotL = max(dot(N, L), 0.0);\n    vec3 diff = NdotL * diffuse;\n    vec3 spec = brdf_ggx(N, V, L, 0.3, 0.02) * specular;\n    return diff + spec;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd, vec3 ro, float trap) {\n    \n    vec3 V = normalize(ro-p);\n    vec3 L = normalize(ro-p);\n    vec3 N = sn;\n    vec3 Refl = reflect(L, N);\n    float NdotL = max(0.0, dot(N, L));\n    \n\n    float pulse = smoothstep(.2, -.2, abs(fract(0.25*trap + 0.1)-0.5));\n    \n    vec3 ambient = vec3(0.);\n    vec3 diffuse = magma(fract(0.15*trap)) \n        + 1.0*magma(fract(0.15*trap)) * pulse\n        ;\n\n    vec3 specular = magma(fract(0.15*trap));\n    \n    //diffuse = vec3(1.0);\n    //specular = vec3(1.0);\n    \n    \n    vec3 front = calcLight(p, N, ro, V, diffuse, vec3(1.0));\n    vec3 bac = calcLight(p, N, vec3(0,1,0), V, diffuse, vec3(1.0));\n    vec3 center = calcLight(p, N, vec3(0,0,0), V, diffuse, vec3(1.0));\n    \n    return ambient + 0.8*front + 0.3*bac + 0.55*center;\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvec3 camPos(float t) {\n    float x = cos(5.0*t);\n    float y = sin(3.0*t);\n    float z = cos(7.0*t);\n    return lissoujasSize*vec3(x,y,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 fog = vec3(.3,.2,.3) * 0.5;\n    vec3 col = vec3(fog);\n\n    float speed = 0.02;\n    float time = (iTime +93.6) * speed;\n    \n    vec3 ro = camPos(time);\n    \n    distFromOrigin = length(ro);\n    \n    \n    vec3 ta = camPos(time+speed);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    \n    //mat3 rot = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    \n    //ro -= vec3(0,1,15);\n    \n    vec3 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = clamp(light(p, n, rd, ro, hit.z), 0.0, 1.0);\n        col *= (.5*hit.y+.5);   // occlusion \n        \n        float fog_max = 5.5,\n              fog_min = 4.;\n        float fog_alpha = clamp(1. - (fog_max - t) / (fog_max - fog_min), 0.0, 1.0);\n        col = mix(col, fog, fog_alpha);\n    }\n    else {\n        col = vec3(fog);\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}