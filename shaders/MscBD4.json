{
    "Shader": {
        "info": {
            "date": "1525119327",
            "description": "Dreamy clouds over the fbm Full Moon.",
            "flags": 0,
            "hasliked": 0,
            "id": "MscBD4",
            "likes": 10,
            "name": "Dream Time Moon",
            "published": 3,
            "tags": [
                "moon"
            ],
            "usePreview": 0,
            "username": "gambhiro",
            "viewed": 633
        },
        "renderpass": [
            {
                "code": "// Dream Time Moon\n//\n// https://www.shadertoy.com/view/MscBD4\n\n// Dreamy clouds over the fbm Full Moon.\n\n// Little New Year's --\n// and the moon has deigned\n// to rise!\n//\n// (Issa)\n\nvec3 g_camera_pos   = vec3(0.0, 0.0, -25.0);\nvec3 g_camera_front = vec3(0.0, 0.0, 1.0);\nvec3 world_up       = vec3(0.0, 1.0, 0.0);\nvec3 g_light_pos    = vec3(20.0, 9.0, -30.0);\n\nvec2 castRay(vec3 ro, vec3 rd);\nvec3 calcNormal(vec3 pos);\nvec3 materialColor(vec3 ro, vec3 rd, float mat_id, vec3 pos);\nvec2 map(vec3 p);\n\nfloat noise(vec2 x);\nfloat noise(vec3 x);\nfloat fbm(vec2 x);\nfloat fbm(vec3 x);\n\n#define INFINITY 100.0\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(INFINITY, 0.0);\n\n  res.x = length(vec3(0.0) - p) - 2.0;\n  res.y = 1.0;\n\n  return res;\n}\n\nvec3 materialColor(vec3 ro, vec3 rd, float mat_id, vec3 pos) {\n  vec3 final_col = vec3(0.0);\n  vec3 nor = vec3(0.0);\n\n  if (mat_id > -1.0) {\n    nor = calcNormal(pos);\n  }\n\n  // sunrise gradient background\n  vec3 bg_bottom = vec3(0.631, 0.580, 0.517) * vec3(1.3, 1., 1.); // rgb(161, 148, 132)\n  vec3 bg_top = vec3(0.439, 0.521, 0.596); // rgb(112, 133, 152)\n  vec3 bg_base = mix(bg_bottom, bg_top, rd.y + 0.5);\n\n  if (mat_id == 1.0) {\n    // moon\n    vec3 view_dir = normalize(ro - pos);\n    vec3 light_dir = normalize(pos - g_light_pos);\n\n    // NOTE cheap world-space pos texturing but nah. moon stays in place.\n\n    vec3 base = vec3(1.0, 0.85, 0.82) * vec3(0.52);\n    vec3 crater = mix(base, vec3(1.0), smoothstep(0.45, 0.6, fbm(pos)));\n\n    vec3 white_dust = pow(noise(pos*50.0) * vec3(0.9), vec3(2.0));\n    vec3 black_dust = pow(noise(pos*40.0) * vec3(0.9), vec3(4.0));\n    vec3 col = 0.9*base + 1.0*crater + 0.3*white_dust - 0.5*black_dust;\n\n    float diff = max(dot(nor, -light_dir), 0.0);\n\n    //col = mix(bg_base, col, diff);\n    col = mix(mix(bg_base, col+vec3(.3), diff), bg_base, 0.5);\n\n    final_col = clamp(col, 0., 1.);\n  } else if (mat_id == 2.0) {\n    // black silhouette\n    final_col = vec3(0.);\n  } else {\n    // background\n    vec3 col = bg_base;\n    final_col = clamp(col, 0., 1.);\n  }\n\n  return final_col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float time = iTime;\n  vec3 col = vec3(0.0);\n\n  // normalized image plane, (0,0) is the center, (0.5,0.5) is top right\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  // scale to fit width\n  p.x *= iResolution.x / iResolution.y;\n\n  // === Camera ===\n\n  // ray origin is camera position\n  vec3 ro = g_camera_pos;\n\n  // camera vectors\n  vec3 cam_front = normalize(g_camera_front);\n  vec3 cam_right = normalize(cross(cam_front, world_up));\n  vec3 cam_up    = normalize(cross(cam_right, cam_front));\n\n  // ray direction toward camera front vector, shifted with screen pos xy\n  vec3 rd = normalize(p.x*cam_right + p.y*cam_up + 2.0*cam_front);\n\n  // === Render ===\n\n  vec2 res = castRay(ro, rd);\n  col = materialColor(ro, rd, res.y, ro+rd*res.x);\n\n  // add clouds\n  vec3 cloud_col = vec3(1.0);\n  float t1 = iTime*0.2;\n  float t2 = iTime*0.2 + sin(iTime*0.2 + 2.0)*2.0+2.0;\n\n  float cloud_fbm1 = smoothstep(0.4, 0.91, fbm(rd.xy*7.0 + vec2(t1, 0.0)));\n  float cloud_fbm2 = smoothstep(0.4, 0.91, fbm(rd.xy*7.0 + vec2(t2, 0.0)));\n\n  col = mix(mix(col, cloud_col, cloud_fbm1),\n            mix(col, cloud_col, cloud_fbm2), sin(iTime*0.2) + 1.0);\n\n  // gamma correction, 1.0 / 2.2 = 0.4545\n  col = pow(col, vec3(0.4545));\n\n  fragColor = vec4(col, 1.0);\n}\n\n// === Raymarch Helpers ========================================================\n\nvec2 castRay(vec3 ro, vec3 rd) {\n  float tmax = INFINITY; // far clip\n  float precis = 2e-3; // hit precision\n  float sm = 0.9; // smaller steps\n\n  float t = 0.1; // first step size\n  float m = -1.0; // material id\n\n  for (int i=0; i<150; i++) {\n    vec2 res = map(ro + rd * t);\n    if (res.x < precis || t > tmax) break;\n    t += res.x * sm;\n    m = res.y;\n  }\n\n  if (t > tmax) m = -1.0;\n\n  return vec2(t,m);\n}\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ).x +\n                    v2 * map( pos + v2*eps ).x +\n                    v3 * map( pos + v3*eps ).x +\n                    v4 * map( pos + v4*eps ).x );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 2e-3);\n}\n\n// === Noise ===================================================================\n\n// 1D, 2D & 3D Value Noise by morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define NUM_NOISE_OCTAVES 6\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n\n  // Four corners in 2D of a tile\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n\n  // Simple 2D lerp using smoothstep envelope between the values.\n  // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n  //\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n  //\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n  // Same code, with the clamps in smoothstep and common subexpressions\n  // optimized away.\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n\n  // For performance, compute the base input to a 1D hash from the integer part of the argument and the\n  // incremental change to the 1D based on the 3D -> 1D wrapping\n  float n = dot(i, step);\n\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}