{
    "Shader": {
        "info": {
            "date": "1580222789",
            "description": "Inside the Tokamak, use mouse (with button pressed) to look around",
            "flags": 0,
            "hasliked": 0,
            "id": "ttV3Dt",
            "likes": 4,
            "name": "Tokamak",
            "published": 3,
            "tags": [
                "raymarching",
                "mouse"
            ],
            "usePreview": 0,
            "username": "lucasassone",
            "viewed": 499
        },
        "renderpass": [
            {
                "code": "\nvec3 rotate(vec3 p, float angle, vec3 axis){\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\nconst float THRESHOLD = 0.0001;\nconst float maiorRadius = 5.0;\nconst float minorRadius = 3.0;\n\n// --------------------------------------------------------------------------\n\n// distance estimators\nfloat torusDist(vec3 p) {\n\tfloat f1 = min(abs(0.3 * sin(10.0 * atan(p.z, p.x))), 0.1);\n\tvec2 uv = vec2(-atan(p.z, p.x), atan(p.y, length(p.xz) - maiorRadius)) / 2.0 / 3.141592 + 0.5;\n\tfloat f2 = max(sin(200. * uv.x) * sin(200. * uv.y) - 0.95, 0.0);\n\tfloat dis1 = minorRadius - (f1 + f2) - length(vec2(length(p.xz) - maiorRadius, p.y));\n\treturn dis1;\n}\n\nfloat tubesDist(vec3 p) {\n\tfloat d1 = length(vec2(length(p.xz) - (maiorRadius + minorRadius - 0.5), p.y - 1.3)) - 0.2;\n\tfloat d2 = length(vec2(length(p.xz) - (maiorRadius + minorRadius - 0.5), p.y + 1.3)) - 0.2;\n\tfloat d3 = length(vec2(length(p.xz) - (maiorRadius - minorRadius + 0.6), p.y + 1.5)) - 0.2;\n\tfloat d4 = length(vec2(length(p.xz) - (maiorRadius - minorRadius + 1.0), p.y + 2.0)) - 0.2;\n\treturn min(min(d1, d2), min(d3, d4));\n}\n\nfloat floorDist(vec3 p) {\n\treturn p.y + 2.7;\n}\n\nfloat ceilDist(vec3 p) {\n\tfloat f = max(sin(10. * atan(p.z, p.x)) - 0.6, 0.0);\n\tfloat d1 = length(vec2(length(p.xz) - maiorRadius + 1.0, p.y - minorRadius - 2.0)) - 2.5 - f;\n\tfloat d2 = length(vec2(length(p.xz) - maiorRadius - 1.0, p.y - minorRadius - 2.0)) - 2.5 - f;\n\treturn min(d1, d2);\n}\n\nfloat protonsDist(vec3 p) {\n\tvec3 p1 = rotate(p, 10.0 * iTime, vec3(0., 1., 0.));\n\tfloat d1 = length(vec2(length(p1.xz) - maiorRadius, p1.y + 0.0)) - 0.1 * (sin(0.5 * atan(p1.z, p1.x)) + 1.0);\n\treturn d1;\n}\n\nfloat sceneDist(vec3 p) {\n\tfloat v = min(min(torusDist(p), tubesDist(p)), min(floorDist(p), ceilDist(p)));\n\treturn min(v, protonsDist(p));\n}\n\n// --------------------------------------------------------------------------\n\nvec3 torusColor(vec3 p) {\n\treturn vec3(0.9, 0.9, 1.0);\n}\n\nvec3 floorColor(vec3 p) {\n\treturn vec3(max(sin(50.0 * p.x) - 0.5, 0.0) + max(sin(50.0 * p.z) - 0.5, 0.0));\n}\n\nvec3 ceilColor(vec3 p) {\n\treturn vec3(0.9, 0.9, 1.0);\n}\n\nvec3 tubesColor(vec3 p) {\n\treturn vec3(0.8, 0.9, 1.0);\n}\n    \n// --------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( gl_FragCoord.xy * 2. - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec2 mo = iMouse.xy / iResolution.xy - 0.5;\n\n\tvec3 cameraPos = vec3(0., -0.5, -7.);\n\tfloat screenZ = 2.0;\n\tvec3 rayDirection = normalize(vec3(p, screenZ));\n\n\trayDirection = rotate(rayDirection, -0.05, vec3(0., 0., 1.));\n\n\trayDirection = rotate(rayDirection, 2. * mo.x, vec3(0., 1., 0.));\n\trayDirection = rotate(rayDirection, 2. * mo.y, vec3(1., 0., 0.));\n\n\tcameraPos = rotate(cameraPos, iTime, vec3(0., 1., 0.));\n\trayDirection = rotate(rayDirection, iTime, vec3(0., 1., 0.));\n\n\tfloat depth = 0.0;\n\tvec3 col = vec3(1.0);\n\tvec3 rayPos;\n\n\t// ray marching\n\tint i = 0;\n\tfor (i = 0; i < 99; i++) {\n\t\trayPos = cameraPos + rayDirection * depth;\n\t\tfloat dist = sceneDist(rayPos);\n\t\tif (dist < THRESHOLD) {\n\t\t\tif      (torusDist(rayPos) < THRESHOLD) col = torusColor(rayPos);\n\t\t\telse if (floorDist(rayPos) < THRESHOLD) col = floorColor(rayPos);\n\t\t\telse if (ceilDist(rayPos)  < THRESHOLD) col = ceilColor(rayPos);\n\t\t\telse if (tubesDist(rayPos) < THRESHOLD) col = tubesColor(rayPos);\n\t\t\tif (protonsDist(rayPos) < THRESHOLD) col = vec3(100.0);\n\t\t\tbreak;\n\t\t}\n\t\tdepth += dist;\n\t}\n\n\tcol = col * (1.6 / (1.0 + 0.1 * depth)); // scurisce con la profondita'\n\tcol = 0.1 * col * max(0.3 * float(i), 1.0); // effetto aura (schiarisce all'aumentare di i)\n    col = mix(col, vec3(0.6, 0.5, 1.0), max(1.0 - minorRadius - rayPos.y, 0.0));\n\n\t// luce rossa lampeggiante\n\tfloat f = sin(6. * iTime) * 0.3 + 0.3;\n\tcol = col * vec3(1., 1. - f, 1. - f);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}