{
    "Shader": {
        "info": {
            "date": "1699214166",
            "description": "GLSL port of CRT-Easymode: https://github.com/libretro/common-shaders/blob/master/crt/shaders/crt-easymode.cg",
            "flags": 0,
            "hasliked": 0,
            "id": "cltyD4",
            "likes": 4,
            "name": "CRT-Easymode",
            "published": 3,
            "tags": [
                "crt"
            ],
            "usePreview": 0,
            "username": "starfreakclone",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "// This is largely the crt-easymode shader found at https://github.com/libretro/glsl-shaders/blob/master/crt/shaders/crt-easymode.glsl.\n\n#define FragColor fragColor\n\n#define COMPAT_PRECISION\n\n#define OutputSize iResolution.xy\n#define TextureSize iResolution.xy\n#define InputSize iResolution.xy\n#define Texture iChannel0\n\n#define COMPAT_TEXTURE texture\n\n#if 0\nuniform COMPAT_PRECISION vec2 OutputSize;\nuniform COMPAT_PRECISION vec2 TextureSize;\nuniform COMPAT_PRECISION vec2 InputSize;\nuniform sampler2D Texture;\nCOMPAT_VARYING vec4 TEX0;\n#endif\n\n#define FIX(c) max(abs(c), 1e-5)\n#define PI 3.141592653589\n\n#define TEX2D(c) dilate(COMPAT_TEXTURE(Texture, c))\n\n// compatibility #defines\n#define Source Texture\n#define vTexCoord uv\n\n#define SourceSize vec4(TextureSize, 1.0 / TextureSize) //either TextureSize or InputSize\n#define outsize vec4(OutputSize, 1.0 / OutputSize)\n\n#ifdef PARAMETER_UNIFORM\n// All parameter floats need to have COMPAT_PRECISION in front of them\nuniform COMPAT_PRECISION float SHARPNESS_H;\nuniform COMPAT_PRECISION float SHARPNESS_V;\nuniform COMPAT_PRECISION float MASK_STRENGTH;\nuniform COMPAT_PRECISION float MASK_DOT_WIDTH;\nuniform COMPAT_PRECISION float MASK_DOT_HEIGHT;\nuniform COMPAT_PRECISION float MASK_STAGGER;\nuniform COMPAT_PRECISION float MASK_SIZE;\nuniform COMPAT_PRECISION float SCANLINE_STRENGTH;\nuniform COMPAT_PRECISION float SCANLINE_BEAM_WIDTH_MIN;\nuniform COMPAT_PRECISION float SCANLINE_BEAM_WIDTH_MAX;\nuniform COMPAT_PRECISION float SCANLINE_BRIGHT_MIN;\nuniform COMPAT_PRECISION float SCANLINE_BRIGHT_MAX;\nuniform COMPAT_PRECISION float SCANLINE_CUTOFF;\nuniform COMPAT_PRECISION float GAMMA_INPUT;\nuniform COMPAT_PRECISION float GAMMA_OUTPUT;\nuniform COMPAT_PRECISION float BRIGHT_BOOST;\nuniform COMPAT_PRECISION float DILATION;\n#else\n\n#if 0 // Original values.\n#define SHARPNESS_H 0.5\n#define SHARPNESS_V 1.0\n#define MASK_STRENGTH 0.3\n#define MASK_DOT_WIDTH 1.0\n#define MASK_DOT_HEIGHT 1.0\n#define MASK_STAGGER 0.0\n#define MASK_SIZE 1.0\n#define SCANLINE_STRENGTH 1.0\n#define SCANLINE_BEAM_WIDTH_MIN 1.5\n#define SCANLINE_BEAM_WIDTH_MAX 1.5\n#define SCANLINE_BRIGHT_MIN 0.35\n#define SCANLINE_BRIGHT_MAX 0.65\n#define SCANLINE_CUTOFF 400.0\n#define GAMMA_INPUT 2.0\n#define GAMMA_OUTPUT 1.8\n#define BRIGHT_BOOST 1.2\n#define DILATION 1.0\n\n#pragma parameter SHARPNESS_H             \"Sharpness Horizontal\"     0.5   0.0  1.0     0.05\n#pragma parameter SHARPNESS_V             \"Sharpness Vertical\"       1.0   0.0  1.0     0.05\n#pragma parameter MASK_STRENGTH           \"Mask Strength\"            0.3   0.0  1.0     0.01\n#pragma parameter MASK_DOT_WIDTH          \"Mask Dot Width\"           1.0   1.0  100.0   1.0\n#pragma parameter MASK_DOT_HEIGHT         \"Mask Dot Height\"          1.0   1.0  100.0   1.0\n#pragma parameter MASK_STAGGER            \"Mask Stagger\"             0.0   0.0  100.0   1.0\n#pragma parameter MASK_SIZE               \"Mask Size\"                1.0   1.0  100.0   1.0\n#pragma parameter SCANLINE_STRENGTH       \"Scanline Strength\"        1.0   0.0  1.0     0.05\n#pragma parameter SCANLINE_BEAM_WIDTH_MIN \"Scanline Beam Width Min.\" 1.5   0.5  5.0     0.5\n#pragma parameter SCANLINE_BEAM_WIDTH_MAX \"Scanline Beam Width Max.\" 1.5   0.5  5.0     0.5\n#pragma parameter SCANLINE_BRIGHT_MIN     \"Scanline Brightness Min.\" 0.35  0.0  1.0     0.05\n#pragma parameter SCANLINE_BRIGHT_MAX     \"Scanline Brightness Max.\" 0.65  0.0  1.0     0.05\n#pragma parameter SCANLINE_CUTOFF         \"Scanline Cutoff\"          400.0 1.0  1000.0  1.0\n#pragma parameter GAMMA_INPUT             \"Gamma Input\"              2.0   0.1  5.0     0.1\n#pragma parameter GAMMA_OUTPUT            \"Gamma Output\"             1.8   0.1  5.0     0.1\n#pragma parameter BRIGHT_BOOST            \"Brightness Boost\"         1.2   1.0  2.0     0.01\n#pragma parameter DILATION                \"Dilation\"                 1.0   0.0  1.0     1.0\n#endif\n#define SHARPNESS_H 0.5\n#define SHARPNESS_V 1.0\n#define MASK_STRENGTH 0.6\n#define MASK_DOT_WIDTH 1.0\n#define MASK_DOT_HEIGHT 1.0\n#define MASK_STAGGER 0.0\n#define MASK_SIZE 1.0\n#define SCANLINE_STRENGTH 1.0\n#define SCANLINE_BEAM_WIDTH_MIN 1.5\n#define SCANLINE_BEAM_WIDTH_MAX 1.5\n#define SCANLINE_BRIGHT_MIN 0.35\n#define SCANLINE_BRIGHT_MAX 0.65\n#define SCANLINE_CUTOFF 400.0\n#define GAMMA_INPUT 2.0\n#define GAMMA_OUTPUT 1.8\n#define BRIGHT_BOOST 1.2\n#define DILATION 1.0\n\n#endif\n\n// Set to 0 to use linear filter and gain speed\n#define ENABLE_LANCZOS 1\n\nvec4 dilate(vec4 col)\n{\n    vec4 x = mix(vec4(1.0), col, DILATION);\n\n    return col * x;\n}\n\nfloat curve_distance(float x, float sharp)\n{\n\n/*\n    apply half-circle s-curve to distance for sharper (more pixelated) interpolation\n    single line formula for Graph Toy:\n    0.5 - sqrt(0.25 - (x - step(0.5, x)) * (x - step(0.5, x))) * sign(0.5 - x)\n*/\n\n    float x_step = step(0.5, x);\n    float curve = 0.5 - sqrt(0.25 - (x - x_step) * (x - x_step)) * sign(0.5 - x);\n\n    return mix(x, curve, sharp);\n}\n\nmat4 get_color_matrix(vec2 co, vec2 dx)\n{\n    return mat4(TEX2D(co - dx), TEX2D(co), TEX2D(co + dx), TEX2D(co + 2.0 * dx));\n}\n\nvec3 filter_lanczos(vec4 coeffs, mat4 color_matrix)\n{\n    vec4 col        = color_matrix * coeffs;\n    vec4 sample_min = min(color_matrix[1], color_matrix[2]);\n    vec4 sample_max = max(color_matrix[1], color_matrix[2]);\n\n    col = clamp(col, sample_min, sample_max);\n\n    return col.rgb;\n}\n\nvec4 compute(vec2 uv)\n{\n    vec2 dx     = vec2(SourceSize.z, 0.0);\n    vec2 dy     = vec2(0.0, SourceSize.w);\n    vec2 pix_co = vTexCoord * SourceSize.xy - vec2(0.5, 0.5);\n    vec2 tex_co = (floor(pix_co) + vec2(0.5, 0.5)) * SourceSize.zw;\n    vec2 dist   = fract(pix_co);\n    float curve_x;\n    vec3 col, col2;\n\n#if ENABLE_LANCZOS\n    curve_x = curve_distance(dist.x, SHARPNESS_H * SHARPNESS_H);\n\n    vec4 coeffs = PI * vec4(1.0 + curve_x, curve_x, 1.0 - curve_x, 2.0 - curve_x);\n\n    coeffs = FIX(coeffs);\n    coeffs = 2.0 * sin(coeffs) * sin(coeffs * 0.5) / (coeffs * coeffs);\n    coeffs /= dot(coeffs, vec4(1.0));\n\n    col  = filter_lanczos(coeffs, get_color_matrix(tex_co, dx));\n    col2 = filter_lanczos(coeffs, get_color_matrix(tex_co + dy, dx));\n#else\n    curve_x = curve_distance(dist.x, SHARPNESS_H);\n\n    col  = mix(TEX2D(tex_co).rgb,      TEX2D(tex_co + dx).rgb,      curve_x);\n    col2 = mix(TEX2D(tex_co + dy).rgb, TEX2D(tex_co + dx + dy).rgb, curve_x);\n#endif\n\n    col = mix(col, col2, curve_distance(dist.y, SHARPNESS_V));\n    col = pow(col, vec3(GAMMA_INPUT / (DILATION + 1.0)));\n\n    float luma        = dot(vec3(0.2126, 0.7152, 0.0722), col);\n    float bright      = (max(col.r, max(col.g, col.b)) + luma) * 0.5;\n    float scan_bright = clamp(bright, SCANLINE_BRIGHT_MIN, SCANLINE_BRIGHT_MAX);\n    float scan_beam   = clamp(bright * SCANLINE_BEAM_WIDTH_MAX, SCANLINE_BEAM_WIDTH_MIN, SCANLINE_BEAM_WIDTH_MAX);\n    //float scan_weight = 1.0 - pow(cos(vTexCoord.y * 2.0 * PI * SourceSize.y) * 0.5 + 0.5, scan_beam) * SCANLINE_STRENGTH;\n    float scan_weight = 1.0 - pow(cos(vTexCoord.y * SourceSize.y) * 0.5 + 0.5, scan_beam) * SCANLINE_STRENGTH;\n\n    float mask   = 1.0 - MASK_STRENGTH;    \n    vec2 mod_fac = floor(vTexCoord * outsize.xy * SourceSize.xy / (InputSize.xy * vec2(MASK_SIZE, MASK_DOT_HEIGHT * MASK_SIZE)));\n    int dot_no   = int(mod((mod_fac.x + mod(mod_fac.y, 2.0) * MASK_STAGGER) / MASK_DOT_WIDTH, 3.0));\n    vec3 mask_weight;\n\n    if      (dot_no == 0) mask_weight = vec3(1.0,  mask, mask);\n    else if (dot_no == 1) mask_weight = vec3(mask, 1.0,  mask);\n    else                  mask_weight = vec3(mask, mask, 1.0);\n\n#if 0\n    if (InputSize.y >= SCANLINE_CUTOFF) \n        scan_weight = 1.0;\n#endif\n\n    col2 = col.rgb;\n    col *= vec3(scan_weight);\n    col  = mix(col, col2, scan_bright);\n    col *= mask_weight;\n    col  = pow(col, vec3(1.0 / GAMMA_OUTPUT));\n\n    return vec4(col * BRIGHT_BOOST, 1.0);\n}\n\n/* There was an interesting discussion about getting a better CRT-staggered look which is closer to a slot mask: https://forums.libretro.com/t/crt-easymode/1648\n\nThanks for the compliment Patrick.\n\nI believe your friend is referring to the RGB mask that, by default, mimics an aperture grille pattern running vertically along the screen. The mask in this shader is fixed pixel, so the density of the pattern will vary depending on your display’s resolution. On a lower res screen it may appear more like an LCD grid, whereas on a 4K display it will appear very fine and perhaps closer to a real CRT with an aperture grille. I use a 1080p monitor and I wouldn’t call the mask realistic at that resolution, but I just happen to like the way it looks.\n\nYour friend may also be more accustomed to CRTs with shadow masks. You can see the differnce here:\n\nCrt-easymode can be configured in a Lottes style shadow mask (a la crt-lottes) by setting the following parameters like so: MASK_SUBPIXEL_WIDTH 2.0, MASK_SUBPIXEL_HEIGHT 1.0, MASK_STAGGER 3.0.\n\nYou can see a preview here (second pic):\n\nviewtopic.php?f=6&t=2360 96\n\nIf someone prefers having no mask, they can set MASK_STRENGTH to 0.0 – and if they do that I recommend also lowering BRIGHT_BOOST to 1.0 as that parameter is meant to make up for the brightness loss caused by the mask.\n\nAlso, in case you’re still using RetroArch 1.0.0.2, lord ashram has a dropbox where he posts test builds. These newer builds have a parameter menu that lets you adjust shader parameters from within RetroArch.\n\n1.0.0.3 Beta is apparently coming soon too.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n#endif\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = compute(uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}