{
    "Shader": {
        "info": {
            "date": "1507566599",
            "description": "Mouse movement\nD - dark scene\nS - toggle sub-surface\nA,R - toggle occlusion\nL - lens effects\n\n\nfork of \nhttps://www.shadertoy.com/view/lslXRj\n\nsubsurface(),specular(),shades() care cleaner,\nsorted better, but i kinda ruined the hashing noise",
            "flags": 16,
            "hasliked": 0,
            "id": "XtByRW",
            "likes": 50,
            "name": "Wax fake sss",
            "published": 3,
            "tags": [
                "sss",
                "lens",
                "shadow",
                "specular",
                "glow",
                "occlusion",
                "flare",
                "subsurface",
                "hdr",
                "scatter",
                "wax"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 2917
        },
        "renderpass": [
            {
                "code": "//sign 3d wax occlusion\n//self  : https://www.shadertoy.com/view/XtByRW\n//parent: https://www.shadertoy.com/view/lslXRj\n// Ben Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//bind keys to Toggle-Functions:\n#define kAmbientOcclusion    kA\n#define kReflectionOcclusion kR\n#define kSubsurface          kS\n#define kLensFX              kL\n#define kDarkScene           kD\n\n//#define FAST\n#ifdef FAST\n const int iterMarch  =40;\n const float traceSize=.005;\n #else\n const int iterMarch  =80;\n const float traceSize=.002;\n#endif\n\n#define doAlbedo\n\n//all occlusion effects are +1 trace() for each light (total)\n#define doOcclusion\n#ifdef doOcclusion\n //Ambient Occlusion (cheap)\n #define doOccludeAmbient\n //fake subsurface scatter\n #define doOccludeSubSurfaceScatter\n //a waxy glow\n #define doOccludeWax\n //occlude specular\n #define doOccludeReflection\n //occlude Frensel\n #define doOcclusionSpecFrensel\n#endif\n\n//specular is VERY bad when lipschitz continuity is suboptimal\n//any twist() deform makes bad lipschitz.\n\n#define doLens\n#ifdef doLens\n #define doLensHDR\n #define doLensGain\n //lens flares are +1 trace() for each light\n #define doLensFlare\n //#define doVignette\n //#define doLensnoise\n#endif\n\n#define doGamma\n#define doGamma45\n\n\n//const.key\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n//const.irrational\nconst float tau=6.2831853;\nconst float phi=acos(5.)*.5+.5;\n//const.global\nvec3 envBright = vec3(1);\nconst vec3 darkEnvBrightness = vec3(.02,.03,.05);\n//const.ui , javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle ){\n float keyVal = textureLod( iChannel3,vec2((float(key)+.5)/256.,toggle?.75:.25),.0).x;\n return (keyVal>.5)?true:false;}\nbool Toggle(int val){return !ReadKey( val, true );}\n\nvec2 Noise( in vec3 x ){return x.xy;return mix(x.yx,x.xz, x.y);}\n\n#define ss01(a) smoothstep(.0,1.,a)\n#define weakc(a) exp2(-2.*pow(a,2.))\nfloat SmoothMax(float a,float b, float s )\n{return a-sqrt(s*s+pow(max(.0,a-b),2.));}\n\n//--shapes:\n/*\nfloat Tet2( vec3 p, vec3 c, float r ){p -= c;\n;const vec2 s=vec2(-1,1)/sqrt(3.)\n;return max(max(max(dot(p,s.xxx),dot(p,s.yyx))\n,dot(p,s.yxy)),dot(p,s.xyy)) - r*mix(1.,s.x,1.);}\nfloat Cube(vec3 p,float r ){\t\n;return max(max(abs(p.x),abs(p.y)),abs(p.z))-r*mix(1.0,1.0/sqrt(3.),.5);\n}\n*/\n\nfloat Oct(vec3 p, float r){const vec2 s=vec2(1,-1)/sqrt(3.)\n;return max(max(max(abs(dot(p,s.xxx)),abs(dot(p,s.yyx)))\n,abs(dot(p,s.yxy))),abs(dot(p,s.xyy)))-r*mix(1.,s.x,.5);}\n\nfloat CubeFrame( vec3 p, float r ){\n;r=r*mix(1.,1./sqrt(3.),.5);\n;p=abs(p)\n;float s=r*.1\n;p-=vec3(r-s)\n;if (p.x<p.z) p=p.zyx\n;if (p.y<p.z) p=p.xzy//this looks dumb on many levels.\n;p.z = max(0.,p.z)\n;return length(p)-s;}\n\nfloat spicalcandle(vec3 p){\n;p.xz = p.xz*cos(p.y*4.0)+vec2(1,-1)*p.zx*sin(p.y*4.0)\n;return max(max( p.y+.2, -p.y-1.)\n,(min(max(abs(p.x),abs(p.z))\n,max(abs(p.x+p.z),abs(p.z-p.x))/sqrt(2.0))-.15)*.8);}\n\nfloat dg( vec3 p, float t ){float \n a=CubeFrame(p-vec3(0,-.05,0),.3)\n,b=length(p-vec3(0,-1.,0))-.4\n,c=Oct(p-vec3(0,.2,0),.2)\n,d=length(p-vec3(0,.48,0))-.1\n,e=spicalcandle(p)//bad continuity testing\n;return\tmin(min(d,c),min(a,min(b,e)));}\n\nfloat dg( vec3 p){return dg(p,.0 );}\n\n//background\nvec3 cSky(vec3 ray){return envBright\n*vec3(.4,.6,1.0)*(mix(.8,0.,exp2(-(1.0/max(ray.y,.01)))));}\n\n//[u]ViewRayPoint      (onSurface)\n//[t]DistanceToSurface (scaled by *.1)\n//[d]LightDirection    (onSurface-onLightSource)\nfloat subSurface(vec3 u,float t,vec3 d){//ss01(a)==smoothstep(0,1,a)\n;return ss01(dg(u+d*t)/t);}//https://www.shadertoy.com/view/lslXRj\n//normal,h1,lightCut1,specPower\nfloat Specular(vec3 n,vec3 h,float l,float p){\n return pow(max(.0,dot(n,h))*l,p)*p/32.;}\n//[u]=PositionViewRay\n//[t]=DirectionViewRay\n//[n]=Normal (first derivative at [u])\n//[d]=DirectionLight\n//[c]=ColorLight\n//[C]=ColorMatrial\n//[m]=ShadowMask\n//[e]=DistnceToSurface\n//[a]=Ambient\n//[p]=specPower\nvec3 Shades(vec3 u,vec3 t,vec3 n,vec3 d,vec3 c,vec3 C,float m,float e,vec3 a,float p){\n#ifdef doOccludeSubSurfaceScatter\n;if(Toggle(kSubsurface)){\n ;float tr=e*.1;\n ;a+=C*c*subSurface(u,tr,d);}\n#endif\n;float ndotl1=max(.0,dot(n,d))\n#ifdef doOccludeWax\n;a+=C*c*m*ndotl1\n;a+=c*m*Specular(n,normalize(d-t) ,smoothstep(.0,.1,ndotl1),p)\n#endif\n;return a;}\n\n//[u]=Position_ViewRRay\n//[t]=DirectionViewRRay\n//[n]=normal,first derivative at Position_ViewRRay\n//LightDirections,LightColors,shadowMasks\n//[d]=DistnceToSurface\nvec3 Shade(vec3 u,vec3 ray,vec3 n\n,vec3 ld1,vec3 ld2,vec3 lc1,vec3 lc2\n,float sm1,float sm2,float d){  \n;vec3 light=vec3(0);\n;vec3 a=envBright*mix(vec3(.2,.27,.4),vec3(.4),(-n.y*.5+.5));// ambient\n//;a=mix( vec3(.03,.05,.08), vec3(.1),(-n.y+1.0) );\n//;vec3 a = envBright*mix(vec3(.2,.27,.4),vec3(.4),(-n.y*.5+.5)); \n//\t\ta = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); \n;light+=a\n//ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n;float specular=Noise(u/vec3(.05,.2,.05)).x\n;vec3 rray = reflect(ray,n)\n;vec3 reflection=cSky(rray)\n;float aoRange=d/20.\n#ifdef doOcclusion\n ;float occlusion=max(0.,1.-dg(u+n*aoRange)/aoRange)// can be > 1.0\n ;occlusion=weakc(occlusion)//used multiple times\n #ifdef doOccludeAmbient\n // reduce occlusion to imply indirect sub surface scattering:\n ;if(Toggle(kAmbientOcclusion))a*=occlusion*.8+.2\n #endif\n ;float p=exp2(3.0+5.0*specular)//specular power\n ;vec3 MC=vec3(.9,.5,.5)\n ;light+=Shades(u,ray,n,ld1,lc1,MC,sm1,d,a,p)\n ;light+=Shades(u,ray,n,ld2,lc2,MC,sm2,d,a,p)\n #ifdef doAlbedo\n ;vec3 albedo=vec3(.7,.5,1)\n ;light*=albedo;\n #endif  \n #ifdef doOccludeReflection\n ;if(Toggle(kReflectionOcclusion)){\n  // specular occlusion, adjust the divisor for the gradient we expect // can be > 1.0\n  ;float specOcclusion = max( 0.0, 1.0 - dg( u + rray*aoRange )/(aoRange*max(.01,dot(rray,n))))\n  ;specOcclusion=weakc(specOcclusion)// tweak the curve\n  ;specOcclusion*=occlusion;// prevent heavily occluded sparkles\n  ;reflection*=specOcclusion\n ;}\n #endif\n #ifdef doOccludeFrensel\n // could fire an additional ray for more accurate reflection|frensel;\n ;float fresnel=pow(1.+dot(n,ray),5.)\n ;fresnel=mix(mix(.0,.01,specular),\n              mix(.4, 1.,specular),fresnel)\n ;light=mix(light,reflection,fresnel)\n #endif\n#endif\n;return light;}\n\n//pos,ray,traceStart,traceEnd\nfloat Trace( vec3 u, vec3 t, float a, float b ){float h\n;for(int i=0;i<iterMarch;i++)\n{h=dg(u+a*t,a);if(h<traceSize||a>b)break;a=a+h;\n}return mix(.0,a,step(a,b));} \n//TraceMin() returns the minimum distance. important to occlude NEARBY light.\nfloat TraceMin( vec3 u, vec3 t,float a,float b ){;float c=b,h\n;for( int i=0;i<iterMarch;i++){h=dg(u+a*t, a )\n ;c=min(h,c);if(a>b)break;a=a+max(h,.1);}return c;}\n   \n//simplicial normal! strangely this looks bad with the 3x cross?\n//possibly too small e?\nvec3 Normal( vec3 u,vec3 ray,float f){\n;float e=2.*f/iResolution.x;\n#ifdef FAST\n// don't sample smaller than the interpolation errors in Noise()\n;e=max(e,.001);\n#endif\t\n;vec2 d=vec2(-1,1) * e;\n;vec3 p0=u+d.xxx,p1=u+d.xyy,p2=u+d.yxy,p3=u+d.yyx\n;e=dg(p0,f)\n;float b=dg(p1,f),c=dg(p2,f);f=dg(p3,f)\n\t\n;vec3 g = p0*e+p1*b+p2*c+p3*f - u*(b+c+f+e)\n;return normalize(g-max(.0,dot(g,ray))*ray)\n;}\n\n//---Camera\nvec3 Ray(float z,in vec2 u)\n{return vec3( u.xy-iResolution.xy*.5,iResolution.x*z );}\nvec3 Rotate(inout vec3 v,vec2 a ){\n;vec4 cs=vec4(cos(a.x),sin(a.x),cos(a.y),sin(a.y))\n;v.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1)\n;v.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1)\n;vec3 p;p.xz=cs.wz*-cs.x;p.y=cs.y;return p;}\nvoid BarrelDistortion(inout vec3 r,float d){//rey,degree\n;r.z/=d;\n;r.z=r.z*r.z-dot(r.xy,r.xy)//fisheye-lens\n;r.z=d*sqrt(r.z);}\n// would love to get some disperson on this, but that means more rays\n\n//fragCoord,ray,lightCol,light,lightVisible,sky,\nvec3 LensFlare(vec2 u, vec3 ray, vec3 lightCol, vec3 light, float lightVisible, float sky ){\n;u/=iResolution.x;\n;float l=(dot(light,ray)*.5+.5),d=0.;\n#ifdef doLensnoise\n;float d=1.-texture( iChannel1, u ).r;\n#endif\n;return(((pow(l,30.)+.05)*d*.1\n+pow(l,200.0))*lightVisible + sky*1.0*pow(l,5e3))*lightCol\n+5.*pow(smoothstep(.9999,1.,l),20.0)\n*smoothstep(.5,1.0,lightVisible)*normalize(lightCol);}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord ){\n;vec3 ray = Ray(1.0,fragCoord);\n;if(Toggle(kLensFX))BarrelDistortion(ray,.5)\n;if(Toggle(kDarkScene))envBright=darkEnvBrightness\n;ray = normalize(ray)\n;vec3 localRay=ray\n;vec2 mouse=.5-iMouse.yx/iResolution.yx;\n;float T = iTime*.1\n;vec3 pos = 3.0*Rotate( ray, vec2(.2,1.0-T)+vec2(-1.0,-6.3)*mouse )\n//pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n;vec3 col\n;vec3 lightDir1 = normalize(vec3(3,1,-2));\n;float lt = iTime;\n;vec3 lightPos = vec3(cos(lt*.9),sin(lt/phi),sin(lt))*vec3(.6,1.2,.6);\n;vec3 lightCol1 = vec3(1.1,1,.9)*.7*envBright;\n;vec3 lightCol2 = vec3(.8,.4,.2)*1.0;\n;float lightRange2 = .4; // distance of intensity = 1.0\n;float t=Trace(pos,ray,.5,40.);\n;if (t>.0){\n ;vec3 p = pos + ray*t;\n ;vec3 lightDir2 = lightPos-p;// shadow test\n ;float lightIntensity2 = length(lightDir2);\n ;lightDir2/=lightIntensity2;\n ;lightIntensity2 = lightRange2/(.1+lightIntensity2*lightIntensity2);\n ;float s1=Trace(p,lightDir1,.05,2.)\n ,s2=Trace(p,lightDir2,.05,2.)\n ;vec3 n=Normal(p,ray,t);\n ;o.xyz=Shade(p,ray,n,lightDir1,lightDir2,lightCol1\n ,lightCol2*lightIntensity2,(s1>.0)?0.:1.,(s2>.0)?0.:1.,t );\n ;float f=200.;// fog\n ;o.xyz=mix( vec3(.8), o.xyz,exp2(-t*vec3(.4,.6,1.)/f))\n;}else\n{;o.xyz = cSky( ray );}\n#ifdef doLens\n;if(Toggle(kLensFX)){\n ;vec3 lightDir2 = lightPos-pos\n ;float lightIntensity2 = length(lightDir2)\n ;lightDir2 /= lightIntensity2\n ;lightIntensity2=lightRange2/(.1+lightIntensity2*lightIntensity2)\n #ifdef doLensFlare\t\n ;float s1 = TraceMin( pos, lightDir1, .5, 40.0 )\n ;float s2 = TraceMin( pos, lightDir2, .5, 40.0 )\n ;o.xyz+=LensFlare(fragCoord,ray,lightCol1,lightDir1                ,smoothstep(-.04,.1,s1),step(t,.0));\n ;o.xyz+=LensFlare(fragCoord,ray,lightCol2*lightIntensity2,lightDir2,smoothstep(-.04,.1,s2),step(t,.0));\n #endif\n #ifdef doVignette\n ;o.xyz*= smoothstep(.5,.0,dot(localRay.xy,localRay.xy));\n #endif\n #ifdef doLensHDR\n // compress bright colours, ( because bloom vanishes in vignette )\n ;vec3 c = (o.xyz-1.);\n ;c=sqrt(c*c+.05); // soft abs\n ;o.xyz = mix(o.xyz,1.0-c,.48); // .5 = never saturate, .0 = linear\n #endif\n #ifdef doLensGain\n ;vec2 gn=fragCoord.xy+floor(iTime*60.0)*vec2(37,41);\n ;vec2 fn=vec2(cos(iTime),sin(iTime))/iResolution.xy;\n #ifdef doLensnoise\n  ;fn=texture(iChannel0,.5*gn/iResolution.xy ).rb;\n #endif\n ;o.xyz *= mix( vec3(1),mix(vec3(1,.5,0),vec3(0,.5,1),fn.x),.1*fn.y);\n #endif\n}   \n#endif\n#ifdef doGamma\n// compress bright colors\n;float l = max(o.x,max(o.y,o.z))\n//...dot(o.xyz,normalize(vec3(2,4,1)));\n;l=max(l,.01)\n// prevent div by zero, darker colours will have no curve\n;float l2 = SmoothMax(l,1.0,.01)\n;o.xyz *= l2/l;\n #endif\n#ifdef doGamma45\n;o.xyz=pow(o.xyz,vec3(1./2.2))\n#endif\n;o.w=1.;}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}