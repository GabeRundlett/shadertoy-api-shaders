{
    "Shader": {
        "info": {
            "date": "1723960761",
            "description": "Simple real time ray tracing demo. There's no denoising so it's very grainy. The ray tracer does one bounce with 32 rays. I'd like to do more but it's starting to take a while to compile.",
            "flags": 0,
            "hasliked": 0,
            "id": "lcXfW7",
            "likes": 0,
            "name": "Noisy RT Spheres",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "triggthediscovery",
            "viewed": 99
        },
        "renderpass": [
            {
                "code": "// This is a basic RT demo. I'm mostly unfamiliar with\n// Ray tracing, so wanted to start with something simple to\n// test. It should show light bounce and ambient occlusion,\n// though with my inexperience I doubt anything here is\n// very correct. It's very noisy since it's a single pass\n// shader, I want to make a denoiser version to \n// make it less noisy, but that's a project for another\n// day.\n//\n// provided under CC0.\n\nvec3 light_dir;\n\nstruct Sphere {\n    vec3 pos;\n    float size;\n    vec3 col;\n    bool em;\n};\n\nstruct NormAndCol {\n    vec3 col;\n    vec3 norm;\n    float dist;\n    bool em;\n};\n\nSphere spheres[10];\n\nconst float reflectivity_i = 12.0;\nconst float max_dist = 1000.0;\nconst float floor_level = 0.0;\nconst float checkerboard = 0.5;\nconst float checkerboard2 = checkerboard/2.0;\nconst float ambient_light = 0.1;\nconst float light_adj = 0.1;\n\nconst int num_spheres = 4;\n\nvec2 muv;\n\nSphere make_sphere(vec3 pos, float size, vec3 col, bool em) {\n    Sphere ret;\n    \n    ret.pos = pos;\n    ret.size = size;\n    ret.col = col;\n    ret.em = em;\n    \n    return ret;\n}\n\nNormAndCol n_a_c(vec3 col, vec3 norm, float dist) {\n    NormAndCol ret;\n    \n    ret.col = col;\n    ret.norm = norm;\n    ret.dist = dist;\n    ret.em = false;\n    \n    return ret;\n}\n\nNormAndCol n_a_c(vec3 col, vec3 norm, float dist, bool em) {\n    NormAndCol ret;\n    \n    ret.col = col;\n    ret.norm = norm;\n    ret.dist = dist;\n    ret.em = em;\n    \n    return ret;\n}\n\nNormAndCol sphere_check(vec3 in_vec, vec3 in_pos, int num) {\n    Sphere sphere = spheres[num];\n\n    float dist = dot(in_vec, normalize(sphere.pos - in_pos)) * distance(in_pos, sphere.pos);\n\n    float center_dist = distance(in_pos + (in_vec * dist), sphere.pos);\n    \n    if (dist < 0.001 || center_dist > sphere.size) {\n        return n_a_c(vec3(0), vec3(0), max_dist+1.0);\n    }\n \n    float surface_dist = dist - sqrt((sphere.size*sphere.size) - (center_dist*center_dist));\n\n    vec3 norm = normalize(in_pos + (in_vec * surface_dist) - sphere.pos);\n\n    return n_a_c(sphere.col, norm, surface_dist, sphere.em);\n}\n\nNormAndCol floor_check(vec3 in_vec, vec3 in_pos) {\n    if (in_pos.y < (floor_level+0.0011) || in_vec.y > 0.0) {\n        return n_a_c(vec3(0), vec3(0), max_dist+1.0);\n    }\n    \n    float dist = (in_pos.y - floor_level) / -in_vec.y;\n\n    vec3 int_point = in_pos + (in_vec*dist);\n    \n    bool x_int = mod(int_point.x, checkerboard) < checkerboard2;\n    bool z_int = mod(int_point.z, checkerboard) < checkerboard2;\n    \n    float fog = (clamp(pow(dist/5.0, 0.2)-0.65, 0.0, 0.5));\n\n    if (x_int ^^ z_int) {\n        return n_a_c(vec3(fog*0.8), vec3(0,1,0), dist);\n    } else {\n        return n_a_c(vec3((1.0-fog)*0.8), vec3(0,1,0), dist);\n    }\n}\n\n// Basic raycast to get surface properties of closest object.\nNormAndCol raycast(vec3 in_vec, vec3 in_pos, vec3 sky_col) {\n    NormAndCol best = n_a_c(sky_col, vec3(1,0,0), max_dist);\n    \n    NormAndCol floor_pt = floor_check(in_vec, in_pos);\n    \n    if (floor_pt.dist < best.dist) {\n        best = floor_pt;\n    }\n    \n    for (int i=0; i< num_spheres; i++) {\n        NormAndCol sphere_pt = sphere_check(in_vec, in_pos, i);\n\n        if (sphere_pt.dist < best.dist) {\n            best = sphere_pt;\n        }\n    }\n    \n    return best;\n}\n\n// Raycast with sun shadow.\nvec3 raycast_sun(vec3 in_vec, vec3 in_pos, vec3 sky_col) {\n    NormAndCol best = raycast(in_vec, in_pos, sky_col);\n    \n    vec3 hit_pos = in_pos + (in_vec * best.dist) + (best.norm*0.001);\n    \n    NormAndCol sun_ray = raycast(light_dir, hit_pos, sky_col);\n\n    if (best.dist < max_dist && !best.em) {\n        if (sun_ray.dist < 200.0 || dot(best.norm, light_dir) <= 0.0) {\n            return best.col * ambient_light;\n        } else {\n            return best.col * (dot(best.norm, light_dir)+light_adj);\n        }\n    } else {\n        return best.col;\n    }\n}\n\n// Will produce a psuedorandom number. \nfloat prand(float inp, float r) {\n    return (mod((inp * (r + muv.x + muv.y + iTime * 345.5)), reflectivity_i)-(reflectivity_i/2.0));\n}\n\n// Will produce a vector, perturbed by a random amount. \nvec3 vrand(vec3 n_norm, vec3 hit_pos, float randval, float reflec) {\n    vec3 uv_off = vec3(prand(hit_pos.x, randval), prand(hit_pos.y, randval), prand(hit_pos.z, randval))/reflec; \n    return normalize((dot(n_norm, uv_off) < 0.0 ? -uv_off : uv_off) + n_norm);\n}\n\n    \nconst float randvals[28] = float[28](8919.1292, 1784.5088, 6216.0980, 6492.3341,\n    2646.1919, 4576.1178, 4730.7670, 7761.9003, 5326.5280, 3548.3277,\n    3548.3277, 7780.2459, 1535.5654, 4564.7646, 0958.7310, 7809.0190,\n    8593.0232, 9513.5604, 0941.2978, 5740.3064, 8812.9880, 4678.4305,\n    0878.8439, 1279.8077, 3661.6533, 8763.0873, 2675.9525, 2757.7824);\n    \nconst float randvals_r[4] = float[4](5989.3674, 8468.4691, 7914.5528, 9398.3939);\nconst float reflect_r[4] = float[4](16.0*reflectivity_i, 12.0*reflectivity_i, 8.0*reflectivity_i, 4.0*reflectivity_i);\n\n// Raycast with bounces.\nvec3 raycast_full(vec3 in_vec, vec3 in_pos, vec3 sky_col) {\n    NormAndCol best = raycast(in_vec, in_pos, sky_col);\n    \n    vec3 hit_pos = in_pos + (in_vec * best.dist) + (best.norm*0.001);\n    \n    NormAndCol sun_ray = raycast(light_dir, hit_pos, sky_col);\n\n    // r_norm is the reflection of the input vector, a_norm is the\n    // surface vector. These are used to approximate reflections and\n    // ambient lighting.\n    vec3 r_norm = in_vec - (2.0*dot(best.norm, in_vec)*best.norm);\n    r_norm = normalize(r_norm);\n    \n    vec3 a_norm = best.norm;\n\n    vec3 uv_off;\n    \n    // A quick explanation, bounce_col_r is for relections which override\n    // the surface color somewhat (as defined by reflection_strength).\n    // bounce_col_a overwrites the color somewhat, but is mostly multiplicative.\n    vec3 bounce_col_a = vec3(0);\n    vec3 bounce_col_r = vec3(0);\n\n    for (int i=0; i<4; i++) {\n        bounce_col_r += raycast_sun(vrand(r_norm, hit_pos, randvals_r[i], reflect_r[i]), hit_pos, sky_col);\n    }\n\n    for (int i=0; i<28; i++) {\n        bounce_col_a += raycast_sun(vrand(a_norm, hit_pos, randvals[i], 1.0), hit_pos, sky_col);\n    }\n\n    bounce_col_r /= 4.0;\n    bounce_col_a /= 32.0;\n    bounce_col_a += vec3(0.8);\n\n    // This is intended to approximate fresnel.\n    float reflection_strength = 1.0 - abs(dot(a_norm, in_vec));\n    \n    if (reflection_strength > 0.5) {\n        reflection_strength = (cos((reflection_strength)*6.28)+1.0)/2.0;\n    } else {\n        reflection_strength = 0.0;\n    }\n    reflection_strength *= 0.4;\n    reflection_strength = clamp(reflection_strength, 0.0, 1.0);\n    \n    vec3 col;\n    \n    if (best.dist < max_dist) {\n        best.col *= bounce_col_a;\n    \n        if (sun_ray.dist < 200.0 || dot(best.norm, light_dir) <= 0.0) {\n            col = best.col * ambient_light;\n        } else {\n            col = best.col * (dot(best.norm, light_dir)+light_adj);\n        }\n        \n        col *= (1.0-reflection_strength);\n        col += bounce_col_r*reflection_strength;\n        col += bounce_col_a/64.0;\n    } else {\n        col = best.col;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    spheres[0] = make_sphere(vec3(cos((iTime)/1.0)/2.5,0.7,0.7), 0.1, vec3(1,0,0), false);\n    spheres[1] = make_sphere(vec3(0.65,0.3,0.0), 0.55, vec3(0,1,0), false);\n    spheres[2] = make_sphere(vec3(-0.65,0.3,0.0), 0.55, vec3(0,0,1), false);\n    spheres[3] = make_sphere(vec3(0.0,0.8,1.0), 0.2, vec3(80), true);\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= vec2(0.5);\n    \n    muv = uv;\n    \n    muv.x = prand(muv.x, 5989.3674);\n    muv.y = prand(muv.y, 6752.1546);\n\n    float ang = (iTime+30.0)/10.0;\n    float dist = 3.0;\n\n    vec3 in_vec_p = vec3(sin(ang)*dist, 0.8, -(cos(ang)*dist));\n    vec3 in_vec_d = normalize(-in_vec_p);\n    light_dir = normalize(vec3(0.3, 1.0, -1.0));\n    \n    float fov = 2.8;\n    vec3 in_vec_d_hold = in_vec_d;\n\n    in_vec_d.x += (in_vec_d_hold.z*(uv.x*fov));\n    in_vec_d.z -= (in_vec_d_hold.x*(uv.x*fov));\n    in_vec_d.y += uv.y*fov/1.8;\n    \n    in_vec_d = normalize(in_vec_d);\n    \n    // Sky gradient.\n    vec3 col = mix(vec3(0.6,0.8,1), vec3(0.3,0.5,1), uv.y);\n\n    vec3 n_col = raycast_full(in_vec_d, in_vec_p, col);\n    n_col = (n_col);\n\n    fragColor = vec4(n_col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}