{
    "Shader": {
        "info": {
            "date": "1641332670",
            "description": "Recreating one of the movie posters from The Exorcist (1973).\n(Best viewed full-screen.)",
            "flags": 0,
            "hasliked": 0,
            "id": "ftGSDV",
            "likes": 107,
            "name": "The Exorcist",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "bw",
                "character",
                "horror",
                "movie",
                "reproduction",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 8429
        },
        "renderpass": [
            {
                "code": "// 'The Exorcist' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/ftGSDV (YouTube: https://youtu.be/NseO7v3iylU)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Recreating one of the movie posters from The Exorcist (1973).\n// (Best viewed full-screen.)\n//\n// Tricks to get the performance:\n//  - No 'max dist' check in main marching loop, as all\n//    primary rays will hit something.\n//  - Dedicated marching loop for the spotlight effect\n//    (avoiding adding overhead to the main scene when\n//    calculating normals, shadows, etc).\n//  - The man is 2D (with very subtle animation), and\n//    mostly rounded boxes.\n//  - Lots of axis folding(/reflection).\n//    There's only one window, one brick pillar, one\n//    fence rail, one window shutter, ...\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA\t// Disable this line for extra performance.\n\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b, c)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t,\n      fade = 1.;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 3.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat box2d(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(.45, .2);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p) {\n\tp.x -= clamp(p.x, 0., 10.);\n\treturn length(p) - .1;\n}\n\nfloat tor(vec3 p) {\n\tconst vec2 t = vec2(.24, .05);\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nvec3 rayDir(vec2 uv) {\n\tvec3 r = normalize(cross(vec3(0, 1, 0), vec3(0, 0, 1)));\n\treturn normalize(vec3(0, 0, 1.5) + r * uv.x + cross(vec3(0, 0, 1), r) * uv.y);\n}\n\nvec3 toWorld(vec3 p) {\n\tp.yz *= mat2(.99875, .04998, -.04998, .99875);\n\tp.y += 1.2;\n\tp.xz -= vec2(2.1875, 17);\n\tp.xz *= mat2(.96891, .2474, -.2474, .96891);\n\treturn p;\n}\n\nfloat beam(vec3 p) {\n\tp -= vec3(-15, 16.4, 42);\n\tp.xy += p.z * vec2(.49, -.44);\n\treturn min(p.z + 62.4, box(p, vec3(2, 3.5, 50)));\n}\n\nHit map(vec3 p) {\n\tp = toWorld(p);\n\n\t// Lamp.\n\tvec3 q = p + vec3(3.9, 1.9, 2);\n\tfloat l = length(q.xz),\n\t      d = l - .2 + .01 * p.y;\n\td = smin(d, cyl(q) - .05, .5);\n\tq.y = abs(q.y - .8) - .25;\n\td = min(d, tor(q));\n\tHit h = Hit(d, 8, q);\n\n\t// Pavement.\n\td = min(max(p.y + 2.1, p.z), box(p + vec3(0, 2, 1.8), vec3(99, .1, 1.8)));\n\tminH(d, 1, p);\n\n\t// Fence walls. (mirror x)\n\tq = p;\n\tq.x = abs(q.x + .8) - 11.;\n\td = box(q - vec3(0, -.5, 0), vec3(8, .15, .4));\n\tminH(d, 4, q);\n\td = cap(q + vec3(7.5, -.5, 0));\n\tminH(d, 9, q);\n\td = box(q - vec3(0, -1.4, 0), vec3(8, .75, .2));\n\n\t// Pillars.\n\tq.x = abs(p.x) - 4.;\n\tif (p.x > 0.) q.x = abs(q.x) - 1.4; // Make right-most pillar.\n\td = min(d, box(q, vec3(.5, 2, .5))); // Driveway pillars.\n\td = min(d, box(q - vec3(0, 1.6, 0), vec3(.55, .1, .55)));\n\tminH(d, 3, q);\n\n\t// Pillar tops.\n\tif (p.x < 4.) {\n\t\tq.y -= 2.6;\n\t\tl = length(q);\n\t\tfloat f = max(l - .5, q.y);\n\t\td = f < d ? smin(d, f, .25) : f;\n\t\td = smin(d, l - .35, .1);\n\t\tminH(d, 4, q);\n\t}\n\n\t// House.\n\td = min(box(p - vec3(12.5, 0, 24), vec3(5, 25, 18)), 42.1 - p.z);\n\n\t// 90 degree fold to make windows appear on both walls.\n\tq = p - vec3(7.5, 0, 42);\n\tif (q.x > q.z) {\n\t\tq.xz = q.zx;\n\t\tq.x += 3.;\n\t}\n\n\t// Windows.\n\tq.xy += vec2(15.75, -9.3);\n\tq.xy = abs(abs(q.xy) - 7.25);\n\td = max(d, -box(q, vec3(2.7, 5.2, 2)));\n\tminH(d, 3, q);\n\tq.z -= .7;\n\td = box(q, vec3(2.7, 5.2, .2));\n\tminH(d + .1, 6, q);\n\tminH(box(q - vec3(4, 0, 0), vec3(1.25, 5.2, 1)), 7, q);\n\tq.x = abs(q.x - 1.25) - .6;\n\tq.y = abs(abs(q.y) - 2.5) - 1.2;\n\td = max(d, -box(q, vec3(.45, 1, 1.2)));\n\tminH(d, 5, q);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - vec3(-7.5, 6.5, 25));\n\tvec3 ld = normalize(vec3(-7.5, 6.5, 25) - p);\n\tfor (float i = Z0; i < 30.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick ambient occlusion.\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p).d / h); }\n\nbool puddle(vec3 p) { return p.z > -3.4 && step(.45, n21(p.xz * 2.) + .13) < .5; }\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tfloat c;\n\tvec3 ld = normalize(vec3(-7.5, 6.5, 25) - p);\n\tvec2 spe = vec2(10, 1);\n\tif (h.id == 3) {\n\t\th.p.x += .1;\n\t\tc = .02 + max2(S(.04, 0., abs(fract(vec2(h.p.y * 2., h.p.x + .5 * step(.5, fract(h.p.y - .25)))) - .5))) * .06;\n\t}\n\telse if (h.id == 1) {\n\t\tfloat f = step(h.p.z, -3.61);\n\t\tc = mix(.1, .01, f) + .1 * step(h.p.z + 3.2, 0.) * S01(abs(fract(h.p.x * .3) - .5) * 60. + f);\n\t\tif (f > .5) {\n\t\t\tf = step(.66, abs(fbm(h.p * 20.)));\n\t\t\tspe.y = 5.5 * f;\n\t\t\tc += .3 * f;\n\t\t}\n\t}\n\telse if (h.id == 7) {\n\t\tc = .15;\n\t\tc *= .2 + .8 * S01(4. * abs(fract(h.p.y * 3.15) - .5));\n\t}\n\telse if (h.id == 6) c = mix(.008, S(25., 0., length(p.xy - vec2(-20, 10))), step(p.x, -3.));\n\telse if (h.id == 4) c = .25;\n\telse if (h.id == 8) {\n\t\tc = .6;\n\t\tspe = vec2(50, 30);\n\t}\n\telse c = .15; // Rails, window frame\n\treturn mix((sat(.1 + .9 * dot(ld, n)) + (sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y)) * (.1 + .9 * shadow(p)) * mix(aof(p, n, .2), aof(p, n, 2.), .7) * c, 1., S(.7, 1., 1. + dot(rd, n)) * .01) * vec3(.4, .32, .28);\n}\n\nvec3 scene(vec3 rd, vec2 uv) {\n\tt = mod(iTime, 30.);\n\tfade = min(1., abs(t));\n\n\t// March the scene.\n\tfloat i, od, g, f, man,\n\t      d = 0.;\n\tvec3 op, n, col,\n\t     p = vec3(0);\n\tHit h;\n\tfor (i = Z0; i < 80.; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t\tp = d * rd;\n\t}\n\n\tod = d;\n\top = p;\n\tn = N(p, d);\n\tcol = lights(p, rd, n, h);\n\n\t// Make puddles reflective.\n\tif (h.id == 1 && puddle(h.p)) {\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\td = 0.;\n\t\tfor (i = Z0; i < 50.; i++) {\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < .0015) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += .005 + .9 * lights(p, rd, N(p, d), h);\n\t}\n\n\t// March the spotlight.\n\tg = 0.;\n\td = 0.;\n\tp = vec3(0);\n\tfor (i = Z0; i < 80.; i++) {\n\t\tvec3 q = toWorld(p);\n\t\tfloat sdf = beam(q) + (h31(q) - .5) * .3;\n\t\tg += .5 / (.01 + pow(abs(sdf), 1. + 4. * S(-80., 125., q.z)));\n\t\td += sdf;\n\t\tif (d >= od) break;\n\t\tp = d * rd;\n\t}\n\n\t// Add fog.\n\tf = fbm(rd * 8. + t * vec3(.05, -.07, .2));\n\tcol = mix(col, vec3(4, 3.2, 2.8), sat(g) * f * .3 * S(26.5, 60., op.z));\n\n\t// Man.\n\tuv -= vec2(.175, .059);\n\tuv.x += (uv.y + .5) * (uv.y + .5) * sin(t) * .01;\n\tvec2 tuv = uv;\n\tuv *= mat2(.90045, -.43497, .43497, .90045);\n\tman = step(.1, step(0., length(uv + vec2(0, .1122)) - .12) + step(0., length(uv - vec2(0, .1122)) - .12));\n\n\t// Hat.\n\tf = step(0., box2d(uv, vec2(.014 - .2 * uv.y, .024 + .01 * sin(abs(uv.x) * 8.))) - .01) + step(uv.y, 0.);\n\tman *= step(.1, f);\n\n\t// Face.\n\tuv *= mat2(.995, .09983, -.09983, .995);\n\tf = step(0., box2d(uv, vec2(.019 + .3 * uv.y, .032)) - .007) + step(0., uv.y);\n\tman *= step(.1, f);\n\n\t// Collar.\n\ttuv += vec2(.004, .03);\n\tman *= step(0., box2d(tuv, vec2(.02 - .3 * tuv.y, .01)));\n\n\t// Torso.\n\ttuv += vec2(.005, .104);\n\ttuv *= mat2(.995, -.09983, .09983, .995);\n\tman *= step(0., box2d(tuv, vec2(.07 - .2 * tuv.y + sin(tuv.y * 18.) * .01, .099 - .3 * abs(tuv.x))) - .005);\n\n\t// Hands.\n\ttuv.x = abs(tuv.x);\n\ttuv *= mat2(.96891, .2474, -.2474, .96891);\n\ttuv += vec2(-.033, .095);\n\tman *= step(0., box2d(tuv, vec2(.01 + .05 * tuv.y, .01)) - .008);\n\n\t// Briefcase.\n\ttuv = uv + vec2(-.01, .293);\n\ttuv *= mat2(.95534, .29552, -.29552, .95534);\n\tman *= step(0., box2d(tuv, vec2(.034 - .05 * tuv.y, .04 + .05 * tuv.x)) - .005);\n\tman *= step(0., box2d(tuv - vec2(.014, .054), vec2(.01, .005)) - .003);\n\n\t// Jacket bottom.\n\tman *= step(0., box2d(tuv - vec2(.074, .02), vec2(.05, .046)) - .003);\n\n\t// Legs.\n\ttuv -= vec2(.053, -.08);\n\ttuv *= mat2(.99875, .04998, -.04998, .99875);\n\tman *= step(0., box2d(tuv, vec2(.016 + (sin(tuv.y * 80. - 2.25) - tuv.y * 40.) * mix(5e-4, .0015, step(0., tuv.x)), .06)) - .004);\n\ttuv -= vec2(.055, .01);\n\ttuv *= mat2(.99875, .04998, -.04998, .99875);\n\tman *= step(0., box2d(tuv, vec2(.016 + (sin(tuv.y * 60.) - tuv.y * 40.) * mix(5e-4, .0015, step(0., tuv.x)), .065)) - .004);\n\tif (tuv.y > -.06) col *= man;\n\treturn col;\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * fade, 0)\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tvec3 col = scene(rayDir(uv), uv);\n#ifdef AA\n\tif (fwidth(col.r) > .01) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++) {\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++)\n\t\t\t\tcol += scene(rayDir(uv + (vec2(dx, dy) - .5) / R.xy), uv + (vec2(dx, dy) - .5) / R.xy);\n\t\t}\n\n\t\tcol /= 5.;\n\t}\n\n#endif\n\tcol += .003 * h21(fc);\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = rgba(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}