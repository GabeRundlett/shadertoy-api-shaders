{
    "Shader": {
        "info": {
            "date": "1643324609",
            "description": "Mapping a cubemap to dual paraboloids and reconstruction of environment.\n\n- GPU Gems 3, Chapter 20, Table 20-2, Equations for Scaled Dual-Paraboloid Mapping\n- https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=923191",
            "flags": 32,
            "hasliked": 0,
            "id": "NdScWR",
            "likes": 3,
            "name": "Dual Paraboloids",
            "published": 3,
            "tags": [
                "mapping"
            ],
            "usePreview": 0,
            "username": "4rknova",
            "viewed": 531
        },
        "renderpass": [
            {
                "code": "#define PI\t\t\t3.14159265359\n#define RADIAN\t\t180. / PI\n#define CAMERA_FOV\t60. * RADIAN\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\n\nvoid generate_ray(Camera c, out Ray r, in vec2 fragCoord)\n{\n\tfloat ratio = iResolution.x / iResolution.y;\n\n\tvec2  uv = (2.0 * fragCoord.xy / iResolution.xy - 1.)\n\t\t\t * vec2(ratio, 1.0);\n\t\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(CAMERA_FOV * .5)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\tr.d = normalize(tmat * r.d);\n}\n\n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    vec2 uv = p / iResolution.xy;\n    \n    vec3 target = normalize(vec3(uv.x, uv.y, 1.0 / tan(CAMERA_FOV * 0.5)));\n\tvec3 source = vec3(0,sin(iTime),0);\n    \n    Camera cam;\n\tcam.p = vec3(0., 0., 75.);\n\tcam.u = vec3(0., 1., 0.);\n    \n    #ifdef USE_MOUSE\n\tcam.t = vec3(iMouse.x / iResolution.x * 180. -90., \n\t        iMouse.y / iResolution.y * 180. -90., 0.);\n    #else\n\tcam.t = vec3( 360. * sin(mod(iTime * .64, 2. * PI)),\n                   90. * cos(mod(iTime * .43, 2. * PI)),\n                   25. * cos(mod(iTime * .20, 2. * PI)));\n    #endif\t\t   \n    \n    Ray ray;\n\tgenerate_ray(cam, ray, p);\n    \n    vec2 st = dir2uv(ray.d);\n    \n    vec3 sample_upper = texture(iChannel0, st).xyz;\n    vec3 sample_lower = texture(iChannel1, st).xyz;\n    \n    vec3 res = vec3(0);\n     \n    if (ray.d.z > 0.0) res = sample_upper;\n    else               res = sample_lower;\n    \n    c = vec4(res, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 c, in vec2 p )\n{\n    vec2 uv = p / iResolution.xy * 2.0 - 1.0;\n    vec3 dir = uv2dir(uv, UPPER);        \n    vec3 res = texture(iChannel0, dir).xyz;\n    if (length(uv) > 1.01) res *= 0.5;\n    c = vec4(res, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define UPPER (0.0)\n#define LOWER (1.0)\n\n// Formulas from https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=923191\n// and GPU Gems 3, Chapter 20, Table 20-2, Equations for Scaled Dual-Paraboloid\n// Mapping\n   \nvec3 uv2dir(vec2 uv, float side)\n{    \n    vec3 dir = vec3(uv, 0);\n    \n    float lsq = (uv.x * uv.x) + (uv.y * uv.y);\n    \n    if (side <= UPPER) dir.z =  0.5 - 0.5 * lsq;   \n    else               dir.z = -0.5 + 0.5 * lsq;\n    \n    return normalize(dir);\n}\n\nvec2 dir2uv(vec3 dir)\n{\n    float denom = 1.0 ;\n    \n    if (dir.z >= 0.0 ) denom /= (1.0 + dir.z);\n    else               denom /= (1.0 - dir.z); \n    \n    return 0.5* denom * dir.xy + 0.5; \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 c, in vec2 p )\n{\n    vec2 uv = p / iResolution.xy * 2.0 - 1.0;\n    vec3 dir = uv2dir(uv, LOWER);        \n    vec3 res = texture(iChannel0, dir).xyz;\n    if (length(uv) > 1.01) res *= 0.5;\n    c = vec4(res, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}