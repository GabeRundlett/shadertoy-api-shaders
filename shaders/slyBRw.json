{
    "Shader": {
        "info": {
            "date": "1664225572",
            "description": "nothing interesting here !\nJust had to publish to help inspect a GLSL bug.\n\nThe real comparative shader was [url] https://shadertoy.com/view/NtcfDn [/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "slyBRw",
            "likes": 2,
            "name": "2efficient poisson distribution",
            "published": 3,
            "tags": [
                "glsl",
                "bug"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 238
        },
        "renderpass": [
            {
                "code": "// DEBUG sub-part2 \"efficient poisson distribution\" by FabriceNeyret2. https://shadertoy.com/view/NtcfDn\n\n// top-left: Brute force distribution of all points is way too costly\n// bottom-right: smaller distrib or N=Poisson points per cell is equivalent but hugely cheaper ( as in Cell noise Workey paper: http://www.rhythmiccanvas.com/research/papers/worley.pdf )\n// top-right: fix density small distrib per cell is ok if the number of points per cell is big enough.\n//                                but for small density it lacks lacunarity. cf https://www.desmos.com/calculator/sjjo3qgnfp\n#define Z     min(0.,iTime)\n#define H(p)  fract(sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453)\n#define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n#define Poisson(n, seed)  Normal(n,sqrt(n),seed)               // approx valid for n not too small https://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\n#define Normal(m,s,seed)  m + s * Gauss(seed)\n#define Gauss(u)          sqrt(-2.*log(u.x)) * cos(6.283*u.y ) // takes u = rand2_uniform()\n\n#define D(seed,aa) O += max(0., 1.- R.y/3./aa * length( abs(U) - H(seed)*R/R.y ) ) // * H(seed+7.5).x // variant with varying intensity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, I,\n          U = ( 2.*u - R ) / R.y;\n    float d = ( length(iMouse.xy)<20. ? .5+.5*sin(iTime) : iMouse.y/R.y ) * min(R.x*R.y, 1e6) / 100., // min(): debug Windows crash\n          S = 1.; // put 0 to use same seed in each cell\n    O-=O;  // if ( iTime<.1 || ( iTime >= 10. && iTime < 10.3 )) return; // debug Windows crash\n    if ( U.y > 0. ) \n        if ( U.x > 0. )                               // --- top left: brute force draw Npix*d Uniform points \n           {\n            I = floor( U *= 8. ); U = fract(U);       // --- top right:draw Npix*d/64 Uniform points per cell \n            for( float k=Z; k < d/64.; k++ )          // at 640x360 , d=1% : 36 dots ( per cell )\n                D(k - S*(7.7*I.x-13.3*I.y) , 8. );\n        }\n        \n    O = sqrt(O);                                      // to sRGB\n    if ( int(u.x)/4 == int(R.x)/8 || int(u.y) == int(R.y)/2 ) O = vec4(1,0,0,1);  // red separator\n    if (u.x<10. && u.y/R.y < (iTime-texture(iChannel0,vec2(0)).y)*55. ) O = vec4(0,1,0,1); // iTimeDelta don't work in icon\n    else if(u.x<12.) O = vec4(0,.4,0,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 U )\n{\n    O.x = iTime;\n    O.y = texture(iChannel0, vec2(0)).x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}