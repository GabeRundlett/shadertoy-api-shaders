{
    "Shader": {
        "info": {
            "date": "1715656914",
            "description": "...",
            "flags": 0,
            "hasliked": 0,
            "id": "MfVSR3",
            "likes": 8,
            "name": "catalan tiling",
            "published": 3,
            "tags": [
                "tiling",
                "pentagon"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "//sqrt of 3\n#define r3 1.73205080757\n\nfloat sdLine(vec2 a, vec2 b, float r, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0) * ab;\n    return length(p - p2) - r;\n}\n\n//draws the lines between the pentagons\nfloat pentagrid(vec2 uv){\n    vec2 cuv = floor(uv/r3);\n    uv = fract(uv/r3)*r3;\n    float d = 1e20;\n    //checkerboard pattern where alternate cells are transposed\n    if (mod(cuv.x,2.0) == mod(cuv.y,2.0)){\n        d = min(d, sdLine(vec2(r3/2.0 - 0.5, 0),vec2(r3/2.0 + 0.5, r3),0.01,uv));\n        d = min(d, sdLine(vec2(0, r3/2.0 + 0.5),vec2(r3, r3/2.0 - 0.5),0.01,uv));\n        d = min(d, sdLine(vec2(0, 0),vec2(r3/2.0 - 0.5, 0),0.01,uv));\n        d = min(d, sdLine(vec2(r3, r3),vec2(r3/2.0 + 0.5, r3),0.01,uv));\n        d = min(d, sdLine(vec2(0, r3),vec2(0, r3/2.0 + 0.5),0.01,uv));\n        d = min(d, sdLine(vec2(r3, 0),vec2(r3, r3/2.0 - 0.5),0.01,uv));\n    } else {\n        d = min(d, sdLine(vec2(0, r3/2.0 - 0.5),vec2(r3, r3/2.0 + 0.5),0.01,uv));\n        d = min(d, sdLine(vec2(r3/2.0 + 0.5, 0),vec2(r3/2.0 - 0.5, r3),0.01,uv));\n        d = min(d, sdLine(vec2(0, 0),vec2(0, r3/2.0 - 0.5),0.01,uv));\n        d = min(d, sdLine(vec2(r3, r3),vec2(r3, r3/2.0 + 0.5),0.01,uv));\n        d = min(d, sdLine(vec2(r3, 0),vec2(r3/2.0 + 0.5, 0),0.01,uv));\n        d = min(d, sdLine(vec2(0, r3),vec2(r3/2.0 - 0.5, r3),0.01,uv));\n    }\n    return d;\n}\n\n//returns the incenter of the pentagon a point is in\nvec2 pentacoords(vec2 uv){\n    vec2 cuv = floor(uv/r3);\n    uv = fract(uv/r3)*r3;\n    //checkerboard pattern where alternate cells are transposed\n    if (mod(cuv.x,2.0) == mod(cuv.y,2.0)){\n        vec2 ruv = mat2(-r3,-1,1,-r3)*(uv-r3/2.0)*0.25; //change of basis to \"windmill\" basis\n        cuv *= r3;\n        if (ruv.x < 0.0 && ruv.y < 0.0){\n            return cuv + vec2(r3, (3.0*r3 - 3.0)/2.0); //right\n        } else if (ruv.x > 0.0 && ruv.y < 0.0){\n            return cuv + vec2((3.0 - r3)/2.0, r3); //up\n        } else if (ruv.x < 0.0 && ruv.y > 0.0){\n            return cuv + vec2((3.0*r3 - 3.0)/2.0, 0); //down\n        } else {\n            return cuv + vec2(0, (3.0 - r3)/2.0); //left\n        }\n    } else {\n        cuv *= r3;\n        vec2 ruv = mat2(r3,1,1,-r3)*(uv-r3/2.0)*0.25; //change of basis to \"anti-windmill\" basis\n        if (ruv.x < 0.0 && ruv.y < 0.0){\n            return cuv + vec2(r3, (3.0*r3 - 3.0)/2.0) - vec2(r3,0); //up\n        } else if (ruv.x > 0.0 && ruv.y < 0.0){\n            return cuv + vec2((3.0*r3 - 3.0)/2.0, 0) + vec2(0,r3); //left\n        } else if (ruv.x < 0.0 && ruv.y > 0.0){\n            return cuv + vec2((3.0 - r3)/2.0, r3) - vec2(0,r3); //right\n        } else {\n            return cuv + vec2(0, (3.0 - r3)/2.0) + vec2(r3,0); //down\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.y*6.0;\n\n    vec2 col = pentacoords(uv).xy*0.2*smoothstep(0.0,0.01,pentagrid(uv));\n\n    fragColor = vec4(col,0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}