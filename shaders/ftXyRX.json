{
    "Shader": {
        "info": {
            "date": "1648372705",
            "description": "Raymarching experiments, v2",
            "flags": 64,
            "hasliked": 0,
            "id": "ftXyRX",
            "likes": 2,
            "name": "More cubic roundy thingies",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "xfennec",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "// based on Rémi Papillié's WebGL conference\n// https://www.youtube.com/watch?v=s6t0mJsgUKw\n\n// see also:\n// https://www.shadertoy.com/view/MsBGW1 (shading, AO)\n// \n\n// NOTE :\n// smooth-min (blending SDF)\n// https://iquilezles.org/articles/smin\n\n\nvec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\n\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 saturation(vec3 color, float value) {\n  // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\n  const vec3 luminosityFactor = vec3(0.2126, 0.7152, 0.0722);\n  vec3 grayscale = vec3(dot(color, luminosityFactor));\n\n  return mix(grayscale, color, 1.0 + value);\n}\n\n\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n}\n\nfloat map(vec3 pos, float beat) {\n    vec3 posBox = pos + vec3(0.0, 0.0,  0.0);\n    \n    // space yz rotation\n    posBox.yz = rotate(posBox.yz, pos.x * cos(iTime*1.25)* ((1.0 + beat)*0.2) * 0.004);\n    \n    posBox = opRep(posBox, vec3(10.0));\n    //posBox = opRepLim(posBox, vec3(5.0), vec3(3.0));\n    \n    float zfact = pos.z * 0.1;\n    posBox.yz = rotate(posBox.yz, zfact);\n    posBox.xy = rotate(posBox.xy, iTime * 0.3 + (beat * 0.5));\n    posBox.xz = rotate(posBox.xz, iTime * 0.01 + (beat * 0.2));\n    \n    float dBox = sdRoundBox(posBox, vec3(1.5, 1.5, 1.5), 0.2);\n    \n\treturn dBox;\n}\n\nvec3 computeNormal(vec3 pos, float beat) {\n    vec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy, beat) - map(pos - eps.xyy, beat),\n        map(pos + eps.yxy, beat) - map(pos - eps.yxy, beat),\n        map(pos + eps.yyx, beat) - map(pos - eps.yyx, beat)\n    ));\n}\n\nfloat diffuse(vec3 normal) {\n\t//return max(dot(normal, lightDir), 0.0);\n\treturn dot(normal, lightDir) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // map uv from 0..1 to -1..1 (x will be scaled using viewport ratio)\n    uv -= 0.5;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1);\n    \n\n    int tx = int(uv.x*512.0); // sound texture is 512x2\n\tfloat fft = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; // 1st row is frequency data\n\n\t// crude beat detection\n    float bass = 0.0;\n    int samples = 10;\n    for(int i = 0 ; i < samples ; ++i) {\n        bass += texelFetch( iChannel0, ivec2(i,0), 0 ).x;\n    }\n    bass /= float(samples);\n    float beat = smoothstep(0.9, 1.0, bass);\n\n\n    // right-hand\n    vec3 cam = vec3(\n        -5.0 + -3.0 * sin(iTime) + (beat * 1.0),\n        -5.0 + -3.0 * cos(iTime) + (beat * 1.0),\n        -100.0 * sin(iTime)\n    );\n\n    vec3 dir = normalize(vec3(uv, 1.0));\n\n    vec3 color = vec3(0.0);\n    vec3 pos = cam;    \n\n    for (int i = 0 ; i < 256 ; ++i) {\n        float d = map(pos, beat);\n        if (d < 0.01) {\n            //color = 1.0-pos*0.05;\n            color = (10.0-pos);\n            color = normalize(color) * 3.0;\n            //color = vec3(1.0);\n            float z = (1500.0 - (pos.z - cam.z)) / 3000.0;\n            color *= z;\n\n            break;\n        }\n        if (pos.z > 1000.0 + cam.z) {\n            break;\n        }\n        pos += d * dir;\n    }\n\n    \n    vec3 finalColor = color * diffuse(computeNormal(pos, beat));\n    //finalColor = saturation(finalColor, beat * 1.5);\n    finalColor = contrast(finalColor, 1.0 + beat * 1.0);\n    \n\n    // Output to screen\n    //fragColor = vec4(color, 1.0);\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 28678,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/royksopp/breathe?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// distance functions, inigo quilez\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdPlane(vec3 pos) {\n    return pos.y;\n}\n\nfloat sdSphere(vec3 pos, float radius)\n{\n  return length(pos)-radius;\n}\n\nfloat sdRoundBox(vec3 pos, vec3 size, float radius)\n{\n  vec3 q = abs(pos) - (size - vec3(radius));\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n  vec3 q = abs(pos) - size;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n// repetition\nvec3 opRep(vec3 pos, vec3 factor)\n{\n    return mod(pos + 0.5*factor, factor) - 0.5*factor;\n}\n\nvec3 opRepLim(vec3 pos, vec3 factor, vec3 limit)\n{\n    return pos - factor*clamp(round(pos/factor), -limit, limit);\n}\n\n\n// NOT USED (YET?)\n// https://www.shadertoy.com/view/Wtl3zN \n// adapted from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(\n    \toc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0,\n        0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}