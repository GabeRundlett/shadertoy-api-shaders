{
    "Shader": {
        "info": {
            "date": "1643203909",
            "description": "I wanted to use a colouring to control the flow of stuff.",
            "flags": 32,
            "hasliked": 0,
            "id": "7s2yRD",
            "likes": 2,
            "name": "ColourFlow",
            "published": 3,
            "tags": [
                "mouse",
                "fluid",
                "flow",
                "userinput"
            ],
            "usePreview": 0,
            "username": "intrakits",
            "viewed": 258
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texture(iChannel0, fragCoord/iResolution.xy);\n    //fragColor = vec4(abs(c.xy)*1.0f, abs(c.z)*100.0f, c.w);\n    \n    vec3 col = vec3(iqnoise(fragCoord/iResolution.xy*scale, irr, .2));\n    if(col.x>.5){\n        col=vec3(0.);\n        col.x = 0.;\n        col.y=1.;\n    }\n    else{\n        col=vec3(0.);\n        col.x=1.;\n        col.y = 0.;\n    }\n    c.xyz= mix(c.xyz,col,.4);\n    fragColor = vec4(c.xyz,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 t = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 r = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 b = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 l = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(iqnoise(uv*scale, irr, .2));\n    col.z=0.;\n\n    if(col.x>.5){\n        col=vec3(0.);\n        col.x = r.x*delta;\n        col.y=r.x;\n    }\n    else{\n        col=vec3(0.);\n        col.x=b.y;\n        col.y = b.y*delta;\n    }\n    \n    fragColor = vec4(col.xy,0,1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// advection & boundary & control\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = texelFetch(iChannel0, ivec2(fragCoord), 0);  \n    \n    float d = length((fragCoord/iResolution.xy)-(iMouse.xy/iResolution.xy));\n    float r = .02;\n    float blur = .001;\n    vec3 col =  vec3(smoothstep(r,r-blur,d));\n    \n    vec4 a = texture(iChannel0, (fragCoord)/iResolution.xy);\n    col += a.xyz;\n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 t = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 r = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 b = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 l = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(iqnoise(uv*scale, irr, .2));\n    col.z=0.;\n    \n    if(col.x>.5){\n        col=vec3(0.);\n        col.x = r.x*delta;\n        col.y=b.y;\n    }\n    else{\n        col=vec3(0.);\n        col.x=r.x;\n        col.y = b.y*delta;\n    }\n   \n /*   col = vec3(iqnoise(uv*30., irr, .2));\n    if(col.x>.5){\n        col=vec3(0.);\n        col.x = 0.;\n        col.y=1.;\n    }\n    else{\n        col=vec3(0.);\n        col.x=1.;\n        col.y = 0.;\n    }*/\n    fragColor = vec4(col.xy,0,1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float irr = 0.9;\nfloat delta = 0.999;\nfloat scale = 10.;\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}