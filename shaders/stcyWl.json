{
    "Shader": {
        "info": {
            "date": "1660776027",
            "description": "triangular prism doing weird things with normals and refraction, it only looks cool when it is moving so don't pause it",
            "flags": 32,
            "hasliked": 0,
            "id": "stcyWl",
            "likes": 14,
            "name": "Unintuitive Crystal",
            "published": 3,
            "tags": [
                "refraction",
                "prism",
                "crystal"
            ],
            "usePreview": 0,
            "username": "pb",
            "viewed": 568
        },
        "renderpass": [
            {
                "code": "//philip.bertani@gmail.com\n//see Buffer A please\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n   \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 ro,rd,pp;\nmat3 rot;\nvec3 light;\nbool hitPrism;\nfloat totdist;\n#define pi 3.14159265\n\n\n//thanks iq\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nmat3 rot_xz_xy(float a1, float a2) {\n    //rotation matrices - can't live with'em, can't live without'em\n    //even the rodrigues formula is a matrix in the end...\n    float c1=cos(a1),c2=cos(a2),s1=sin(a1),s2=sin(a2);\n                     \n    return mat3( c2*c1, s2, c2*s1,\n                -s2*c1, c2, -s2*s1,\n                  -s1,   0.,  c1 );\n}\n\nfloat dist_func01(vec3 p) {\n\n    hitPrism = false;\n    \n    vec3 q = rot*p;\n    float prism = sdTriPrism(q,vec2(1.,1.));\n\n    p = mod(p-2.,4.)-2.;\n\n    float dist = length(p) - .3;\n    \n    if ( prism  < dist ) {\n        dist = prism;\n        hitPrism = true;\n    }\n   \n    return dist;\n}\n\nvec3 gradient(vec3 p) {\n\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = .0001 * dpn; \n\n    vec3 df = dpn.xxx * dist_func01(p+dp.xxx) +\n              dpn.yyx * dist_func01(p+dp.yyx) +\n              dpn.xyy * dist_func01(p+dp.xyy) +\n              dpn.yxy * dist_func01(p+dp.yxy);\n\n    return normalize(df); \n\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n  \n    float  rf = .9;  // rf > 1.  causes rays to diverge behind lens\n    \n    float tt = mod(iTime,20.);\n\n    \n    light = normalize( vec3( -.5, 0., -1.) ) ;\n    xy = (2.*xy - iResolution.xy) / iResolution.y;\n    \n    ro = vec3(0.,0.,-2.5);\n    rd = normalize( vec3(xy,2.) );\n    \n    vec3 p = ro;\n    \n    rot = rot_xz_xy(iTime/3.,iTime/5.);\n    \n    float init_eps=1e-8;\n    float n=0.,dist,threshold=init_eps;\n    totdist=0.;\n    vec3 color=vec3(0.);\n    float pc = 0.;\n\n    for(;n<300.;n++) {\n        \n        dist = dist_func01(p);\n        \n        if ( dist < init_eps && hitPrism )  {\n\n            vec3 pp = p - 200.*dist*rd;  //first mistake (used to be -2)\n            vec3 nn = gradient(pp);\n            vec3 rd2 =  refract( rd, nn, rf);  //change ray direction\n            \n            p = pp + .25*rd2;  //second mistake  (used to be +.8)\n            \n            rd = rd2;\n            \n            color += vec3( 10.,3.,0.);\n            \n            pc += 1.;           \n        \n        }\n          \n        else if ( dist < threshold && !hitPrism ) {\n          \n            color += 3.*vec3(.3,.5,.8);\n            \n            vec3 nn = gradient(p+dist*rd) ;\n           \n            color *= max(0.,dot(nn,light));\n            \n            break;   \n           \n        }\n        \n        else {\n            p += dist * rd;\n        }\n        \n \n        totdist += dist;\n        threshold = init_eps * (1. + totdist*50. );\n \n  \n\n    }\n    \n    color *= exp(-totdist*totdist/500.);\n    \n    float sqpc = sqrt(pc);\n    color.r += .03*sqpc;\n    color.g += .02*sqpc;\n    \n    rgba = vec4(color,1.);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}