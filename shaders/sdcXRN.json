{
    "Shader": {
        "info": {
            "date": "1632738623",
            "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/",
            "flags": 0,
            "hasliked": 0,
            "id": "sdcXRN",
            "likes": 9,
            "name": "Slowtember 13-15: Sky",
            "published": 3,
            "tags": [
                "slowtember"
            ],
            "usePreview": 0,
            "username": "klemek",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415927\n#define E .001\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nfloat estep(float threshold, float x, float e) {\n    return smoothstep(threshold + e, threshold - e, x);\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return fract(v);\n}\n\nmat2 rot(float angle) {\n    return mat2(\n        cos(angle * 2. * PI), -sin(angle * 2. * PI),\n        sin(angle * 2. * PI), cos(angle * 2. * PI)\n    );\n}\n\nfloat ell(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv *= rot(angle);\n    float t;\n    float c;\n    vec2 p;\n    if (size.x >= size.y) {\n        t = size.x;\n        c = sqrt((size.x * .5) * (size.x * .5) - (size.y * .5) * (size.y * .5));\n        p = vec2(c, .0);\n    } else {\n        t = size.y;\n        c = sqrt((size.y * .5) * (size.y * .5) - (size.x * .5) * (size.x * .5));\n        p = vec2(.0, c);\n    }\n    return estep(t, length(uv - p) + length(uv + p), e * 4.);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define SKY vec3(.4, .9, 1.)\n#define CLOUD_COMPLEXITY 20\n\nfloat cloud_base(vec2 uv, float seed) {\n    float cloud = .0;\n    \n    float min_x = .0;\n    float max_x = .0;\n    \n    float posx, posy;\n    vec2 pos, size;\n    \n    for(int i = 0; i < CLOUD_COMPLEXITY; i++) {\n        size = vec2(.1 + rand(seed++) * .2, .1 + rand(seed++) * .1);\n        posx = rand(seed++);\n        posy = rand(seed++);\n        pos = vec2((posx*posx - .5) * .5, (posy*posy) * .1 + size.y * .2);\n    \n        min_x = min(min_x, pos.x);\n        max_x = max(max_x, pos.x);\n    \n        cloud += ell(uv, pos, size, .0, (rand(seed++) - .5) * .1, E);\n    }\n    \n    return n(cloud);\n}\n\nvec3 cloud(vec3 c, vec2 uv, float t, float y) {\n    uv += vec2(t, .0);\n    float seed = floor(uv.x + .5);\n    uv.x = fract(uv.x + .5) - .5;\n    \n    uv -= vec2(rand(seed++) * .1, y + (rand(seed++) - .5) * .3);\n\n    float base = cloud_base(uv, seed);\n    float shadow_in = base - cloud_base(uv - vec2(.01, .05), seed) * base;\n\n    c = mask(c, vec3(1.), .9 * (base - shadow_in));\n    c = mask(c, vec3(.9), .9 * shadow_in);\n    \n    return c;\n}\n\nvec3 image(vec2 uv, float t) {\n    vec3 c = SKY;\n    \n    c = cloud(c, uv, t * .3, .2);\n    c = cloud(c, uv, t * .4, .0);\n    c = cloud(c, uv, t * .5, -.2);\n    \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 c = image(uv, iTime);\n    \n    fragColor = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}