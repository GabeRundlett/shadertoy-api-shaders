{
    "Shader": {
        "info": {
            "date": "1699793383",
            "description": "Raymarching 2D SDF quadtree prisms using a quasi-traversal method.",
            "flags": 0,
            "hasliked": 0,
            "id": "mltyDX",
            "likes": 111,
            "name": "2D SDF Quadtree Prisms",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "voxel",
                "square",
                "quadtree",
                "subdivide"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1799
        },
        "renderpass": [
            {
                "code": "/*\n\n    2D SDF Quadtree Prisms\n    ----------------------\n    \n    Raymarching 2D SDF quadtree prisms using a quasi-traversal method.\n    \n    I love the 2D SDF quadtree aesthetic. I'm not sure why, but I think\n    I like the marriage of art, math and basic computer science algorithms...\n    \n    Anyway, I wanted to play around with Xor's really cool 3D XOR example\n    (link below) so searched for it. Alongside it, I saw XOR's version of \n    Panna_Pudi's rotating square SDF in quadtree form, so naturally got \n    curious as to what they'd look like mixed together... I doubt I'm \n    starting the next art movement here, but it's an interesting visual.\n    \n    Anyway, I kept the coloring simple to honor the style of shaders it was \n    based on. I also stuck with a similar 2D SDF. The demoscene fan in me \n    wanted to use a 3D wireframe cube or 2D metaballs SDF as the subject\n    matter... Maybe next time. :)\n    \n    \n    \n    Inspired by:\n    \n    // Awesome visuals for the amount of code used.\n    Bricks [300] - Xor\n    https://www.shadertoy.com/view/cdKBDy\n    \n    // It has a kind of tech-drawing aesthetic to it that I\n    // find really appealing.\n    Quadicube in 456 chars\n    https://www.shadertoy.com/view/7djyWc\n    // Short version of:\n    Quadicube - panna_pudi \n    https://www.shadertoy.com/view/NsByWV\n\n*/\n\n \n// Maximum ray distance.\n#define FAR  15.\n\n// Global tile scale. Value of about \"1./2.\" to \"1./6\" work, \n// but it's designed to work with the currect value.\n#define GSCALE vec3(1./4.);\n\n// Light type: Point: 0, Direct: 1\n#define LIGHT_TYPE 0\n\n// Forward camera speed for that tunnel boring effect. \n// Set to zero for a static camera.\n#define CAM_Z 1./3.\n\n// I like the look of offset rows to mix things up a bit. Comment\n// it out, if you prefer a more traditional subdivided look.\n#define OFFSET_ROWS\n\n// Grey faces, or not.\n#define GREY_FACES\n\n// Colored prism sides, or not.\n#define COLORED_SIDES\n\n// Single face color override.\n//#define SINGLE_FACE_COLOR\n\n// Bore out some holes.\n//#define HOLES\n\n//////////////\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n \n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1664525U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n \n/*\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n*/\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n \n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;   \n     \n}\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Storing the 2D SDF object value. Used for coloring later.\nfloat gBx;\n\n// Height map value.\nfloat hm(in vec2 p){ \n \n    // Moving the pattern forward. Not necessary, but it looks interesting.\n    p.y -= iTime*CAM_Z;\n \n    // Moving the object around a bit.\n    p -= (vec2(cos(iTime), sin(iTime)))*vec2(.5, .25);\n    \n    // Rotation.\n    p = rot2(cos(iTime/2.)*3.14159*.85)*p;\n    \n    // A 2D SDF box.\n    float bx = sBoxS(p, vec2(1.25), .1);\n    gBx = bx;\n\n    // Integrating the box border with a box imprint... Kind of.\n    return min(bx + .65, abs(bx));\n \n }\n\n// Subdivided rectangle grid.\nvec4 getGrid(vec2 p, inout vec2 sc){    \n   \n   \n    #ifdef OFFSET_ROWS\n    // Optional: Offset alternate rows.\n    if(mod(floor(p.y/sc.y), 2.)<.5) p.x += sc.x/2.;\n    #endif\n    \n    vec2 q = p;\n    \n    // Cell ID and local coordinates.\n    vec2 ip = (floor(p/sc) + .5)*sc;\n    p -= ip;\n    \n    // Partitioning into cells and providing the local cell ID\n    // and local coordinates.\n    const int n = 2;\n    for(int i = 0; i<n; i++){\n        // Random subdivision -- One big cell becomes four smaller ones.\n        //if(hash21(ip + float(i + 1)*.007)<.5){//(1./float(i + 2))\n        if(hm(ip)>float(n - i)/float(n)/4.) break;\n            \n        p = q;\n        sc /= 2.; // Cut the scale in half.\n        // New cell ID and local coordinates.\n        ip = (floor(p/sc) + .5)*sc;\n        p -= ip;\n        \n    }\n    \n    // Returning the local coordinates and local cell ID.\n    return vec4(p, ip);\n}\n\n\n \n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec2 gP;\nvec4 gID;\n\n\n// A simple glow variable.\nvec3 glow;\n\nfloat map(vec3 q3) {\n\n\n    // Floor. Redundant here.\n    float fl = q3.y + .5;\n \n \n    vec3 sc = GSCALE; // Scale.\n    // Local coordinates and cell ID.\n    vec4 p4 = getGrid(q3.xz, sc.xz); \n    vec2 p = p4.xy;\n    vec2 id = p4.zw;\n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    //vec3 rC = (gDir*sc - vec3(p.x, q3.y, p.y))/gRd;\n    vec2 rC = (gDir.xz*sc.xz - p)/gRd.xz; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n\n    // The extruded block height. See the height map function, above.\n    float h = hm(id);\n    // Adding some subtle randomized animation to break things up a bit.\n    h = clamp(h*2., 0., 1.)*.95 + (sin(hash21(id + .05)*6.28315289 + iTime)*.5 + .5)*.05;\n \n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness.\n    //sc.xz -= .02*(hash21(id)*.9 + .1);\n\n    // Lower box prism.\n    float d2 = sBoxS(p, sc.xz/2., 0.);\n    //float d2 = sBoxS(p, sc.xz/2., .25*sc.x); // Rounded squares.\n    //float d2 = length(p) - sc.x/2.; // Circles. Interesting, but...\n    \n    #ifdef HOLES\n    if(sc.x>1./16.) d2 = max(d2, -(d2 + sc.x/2.5));\n    #endif\n    \n    // Creating the extruded prisms.\n    float d = opExtrusion(d2, q3.y - h/2., h/2., 0.);\n    \n    \n    // Placing a slightly rounded surface on the faces. Not absolutely\n    // necessary, but it sparkles the light a little more.\n    vec3 p3 = vec3(p.x, q3.y - (h - 3.)  - .0045, p.y);\n    d = min(d, max(length(p3) - 3., d2));\n    \n    d -= min(-d2*2., .06)*.15; // Some beveling.\n    //d += d2*.1; // Raised tops.\n    \n    // Add some gradient glow to the sides.\n    if(q3.y<h){\n        float dd = max(h - q3.y, 0.)/h;\n        glow += max(1. - dd, 0.);    \n    }\n\n    // Saving the box dimensions and local coordinates.\n    gSc = vec3(sc.x, h, sc.z);\n    gP = p;\n    gID = vec4(d, d2, id);\n \n \n    // Scene distance.\n    return min(fl, d);\n}\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map\n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.002, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n \n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    \n    float d, t = hash31(ro + rd)*.25; // Glow jitter.\n    //const float tol = TOLERANCE;\n    vec2 dt = vec2(1e8, 0); // IQ's edge desparkle trick.\n\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5; // sign(rd)*.5;\n    gRd = rd;\n    \n\n    // Initialize the glow to zero.\n    glow = vec3(0);\n\n    const int iter = 128;\n    int i = 0;\n     \n    for (i = 0; i < 128; i++) {\n       \n        d = map(ro + rd*t);\n         \n        \n        // IQ's clever edge desparkle trick. :)\n        if (d<dt.x) { dt = vec2(d, t); } \n\n        if (d<.001 || t > FAR) {\n          break;\n        }\n\n        t += min(d*.9, gCD);\n    }\n    \n    if(i == iter - 1) { t = dt.y; }\n\n\n    return min(t, FAR);\n}\n\nfloat softShadow(in vec3 p, in vec3 ld, in float lDist, in float k) {\n    \n    float res = 1.;\n    float t = 0.;\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., ld) - .5;\n    gRd = ld; \n\n    for (int i=0; i<64; i++){\n\n        float d = map(p + ld*t);\n        res = min(res, k*d/t);\n        if (d<0. || t>lDist) break;\n\n        t += clamp(min(d*.9, gCD), .01, .25);\n    }\n    return clamp(res, 0., 1.);\n}\n\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash23(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir(in vec3 p, in vec3 n){\n\n    vec2 rnd = hash23(p);\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n \n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<12; i++){\n    \n        float hr = (float(i) + 1.)*.35/12.; \n        //float fi = float(i + 1);\n        //vec3 rnd = vec3(hash31(p + fi), hash31(p + fi + .1), hash31(p + fi + .3)) - .5;\n        //vec3 rn = normalize(n + rnd*.15);\n        vec3 rn = cosDir(p + n*hr, n); // Random half hemisphere vector.\n        float d = map(p + rn*hr);\n        \n        occ = occ + max(hr - d, 0.)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\n\nvec4 render(vec3 ro, vec3 rd){\n\n\n    #if LIGHT_TYPE == 0\n    vec3 lp = ro + vec3(2, 1, 6);\n    #else\n    vec3 ld = normalize(vec3(2, 1. + 4., 6));//-vec3(-1.5, -3, -3)\n    float lDist = FAR;\n    #endif\n    \n\n    float t = rayMarch(ro, rd);\n\n    // Saving the global scale, local cell coorinates and cell ID.\n    vec3 svSc = gSc;\n    vec2 svP = gP;\n    vec4 svGID = gID;\n    \n    // Saving the 2D object field from the distance function. Used for coloring.\n    float svBX = gBx;\n\n\n    // Initializing.\n    vec3 col = vec3(0);\n   \n    if (t < FAR){\n  \n        // Position and normal.\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        \n        // Light.\n        #if LIGHT_TYPE == 0\n        vec3 ld = lp - p;\n        float lDist = length(ld);\n        ld /= lDist;\n        #endif\n        \n         \n        // Shadow and ambient occlusion.\n        float shd = softShadow(p + n*.0015, ld, lDist, 8.);\n        float ao = calcAO(p, n);\n\n \n        // Block ID and corresponding height.\n        vec2 id = svGID.zw;\n  \n        // The rotating box used in the height function. Used for coloring.\n        float bx = abs(svBX + .35) - .25;\n    \n        // Background color.\n        vec3 bgCol = mix(vec3(.8, .8, 1)*1.1, vec3(.65, .6, .9)/1.25, hash21(id + .13));\n        \n        // Shape color.\n        vec3 shCol = mix(vec3(1, .05, .04)*1.5, vec3(1, .1, .1)/2., hash21(id + .14));\n        shCol = mix(shCol, .5 + .45*cos(6.2831*hash21(id + .15)/6. + vec3(0, 1.3, 2)*1.5 + .5), .25);\n        shCol = shCol*1.3 + .05;\n          \n       \n        // Coloring the prism sides.\n        vec3 an = abs(n);\n        int face = max(an.x, an.z)<an.y? 1 : 0;\n        #ifdef COLORED_SIDES\n        if(face == 0){\n            bgCol = mix(bgCol, bgCol*shCol*2., .95);\n            shCol = mix(bgCol/2., bgCol*shCol, .5);//vec3(.7, .9, 1.2)/1.2;\n            bgCol = mix(bgCol, shCol, .5);\n            shCol = bgCol;\n             \n        }\n        #else\n        if(face == 0){\n            shCol = bgCol;\n        }\n        #endif\n        \n        // Further background color refining.    \n        bgCol *= vec3(.7, .9, 1.2)*.85;\n        \n        // Coloring the faces dark grey.\n        #ifdef GREY_FACES\n        if(face==1){ \n            shCol = vec3(1./3.)*dot(shCol, vec3(.299, .587, .114)); \n            bgCol = shCol;              \n        }\n        #endif\n        \n        // Making the shape face color the same as the background.\n        #ifdef SINGLE_FACE_COLOR\n        #ifdef COLORED_SIDES\n        if(face == 1)\n        #endif\n        { shCol = bgCol; }\n        #endif\n    \n        // Applying the shape color to the background. \n        vec3 oCol = mix(bgCol, shCol, (1. - smoothstep(0., .25, bx))*min(svSc.x*10., 1.));\n \n        \n        // Leftover effect from another shader. Interesting... but no. :)\n        //vec2 id2 = floor(id/2.);\n        //if(mod(id2.x + id2.y, 2.)<.5) oCol = mix(oCol, oCol.zyx, .5);\n      \n        // Texture coordinates that match the animation.\n        vec3 txP = vec3(p.x, p.y - svSc.y, p.z);\n        vec3 tx = tex3D(iChannel0, txP/2. + .5, n);\n        \n       \n        // Subtle texture color.\n        oCol *= tx*2. + .45;\n         \n        // Very subtle diffuse texturing. Almost not worth the trouble, \n        // but it's done now. :)\n        vec3 rTxP = txP;\n        rTxP.xz *= rot2(3.14159/9.);\n        vec3 dTx = tex3D(iChannel2, rTxP/vec3(4, 1, 1.), n);\n        float difSt = dot(dTx, vec3(.299, .587, .114));\n\n        // Diffuse value.\n        float dif = max(dot(ld, n), 0.);\n        dif = pow(dif, 2. + difSt*16.); // Diffusivity based on texture.\n        \n        // Specular value.\n        float spe = pow(max(dot(reflect(ld, n), rd), 0.), 8. + 8.*difSt);\n\n  \n\n        // Last minute edge routine. I've returned the nearest 2D object ID and \n        // dimensions from the raymarching routine, and the rest sorts itself out.\n        float ew = .0075*(1. + t*.1); // Edge width.\n        float h = svSc.y; // Height.\n        vec2 sc = svSc.xz; // Top face dimensions.\n        float rct = svGID.y;//sBoxS(svP, sc/2., .0);\n        #ifdef HOLES\n        if(sc.x>1./16.) rct = max(rct, -(rct + sc.x/2.5));\n        #endif\n        float top = max(abs(p.y - h), abs(rct)); // Top.\n        float side = abs(abs(svP.x) - sc.x/2.); // Sides.\n        side = max(side, abs(abs(svP.y) - sc.y/2.));\n        float objEdge = min(top, side - ew*.4) - ew; // Combining.\n        \n        // Using the diffuse value to mix the color up a bit.\n        oCol = mix(oCol, oCol.yxz, dif*dif/5.);\n      \n        \n        // Cheap specular reflections.\n        float speR = pow(max(dot(normalize(ld - rd), n), 0.), 5.);\n        vec3 rf = reflect(rd, n); // Surface reflection.\n        vec3 rTx = texture(iChannel1, -rf).xyz; rTx *= rTx;\n        oCol += oCol*speR*rTx*4.;\n\n        \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //\n        // Studio.\n        float am = pow(length(sin(n*2.)*.5 + .5)/sqrt(3.), 2.)*1.5; \n        // Outdoor.\n        //float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); \n        \n        \n        // Specular color.\n        vec3 speCol = vec3(1, .7, .4);\n        // Mixing the specular color.\n        //speCol = mix(speCol.zyx, speCol, (1. - smoothstep(0., .25, bx))*min(svSc.x*10., 1.));\n\n\n        // Lit color.\n        col = oCol*(am + dif*shd + speCol*spe*shd*4.)*ao;\n        \n\n        \n        // Adding a touch of glow to the column walls.\n        col += col*col*glow/4.;\n\n \n        // Applying the edges to the prism.\n        col = mix(col, col*.1, 1. - smoothstep(0., .005, objEdge));\n\n\n        // Light attenuation. Barely visible, but it's there\n        float rt = t/FAR;\n        col *= 1.5/(1. + rt*.2); \n\n    }\n  \n    // Fog. Not visible, but it's there anyway.\n    col = mix(col, vec3(0), smoothstep(.3, .99, t/FAR));\n    \n    // Returning the final color for this pass... There's only one\n    // pass here, but a render function is useful when you want to\n    // bounce light around.\n    return vec4(col, t);\n  \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    // Coordinates.\n    vec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Look vector and camera origin.\n    vec3 lk = vec3(0, 0, iTime*CAM_Z);\n    vec3 ro = lk + vec3(cos(iTime/4.)*.02, 4, -1. + sin(iTime/2.)*.05);\n  \n    // Setting up a camera using the usual process. The variable names\n    // here suggest that this lot came from one of IQ's examples.\n    vec3 ww = normalize(lk - ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww ));\n    vec3 vv = cross(ww, uu);\n    const float FOV = 3.14159/3.; // Field of view.\n    vec3 rd = normalize(u.x*uu + u.y*vv + ww/FOV); // Unit direction vector.\n    \n    // A bit of ray warping just to mix things up.\n    vec2 offs = vec2(fbm(rd.xz*12.), fbm(rd.xz*12. + .35));\n    const float oFct = .01;\n    rd.xz -= (offs - .5)*oFct; \n    rd = normalize(rd);\n    \n    /*\n    // Mouse movement.\n    if(iMouse.z>1.){\n        rd.yz *= rot2((iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        rd.xz *= rot2((iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n    */\n\n    // Render... I was going to perform a couple of passes, but decided against \n    // it. However, it's usually a good idea to have a separate render function.\n    vec4 c4 = render(ro, rd);\n    vec3 col = c4.xyz;\n    // Vignette and very rough Reinhard tone mapping.\n    col *= smoothstep(1.5, .5, length(2.*fragCoord/iResolution.xy - 1.)*.7);\n    col /= 1. + col/2.5;\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(pow(max(col, 0.), vec3(.4545)), 1);\n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}