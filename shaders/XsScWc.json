{
    "Shader": {
        "info": {
            "date": "1494004832",
            "description": "many cubes, rendered with several ray-plane-intersections.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsScWc",
            "likes": 10,
            "name": "grid of cubes",
            "published": 3,
            "tags": [
                "3d",
                "planeintersection"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 803
        },
        "renderpass": [
            {
                "code": "/**/\n\nfloat mid(vec3 p) {\n    p = min(p,p.yzx);\n    return max(max(p.x,p.y),p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    vec3 pos = vec3(0.0,0.0,iTime);\n    //the direction of the ray is made very simple, looks forward in positive z\n    vec3 dir = normalize(vec3(uv,1.0));\n    vec3 signdir = sign(dir);\n    //the length of the ray\n    float dist = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        //moves position to cube space(0,0,0 is between 8 cubes)\n        vec3 pos2 = mod(pos+1.0,2.0)-1.0;\n        \n        //planes is a bad variable name, but it contains the ray-plane distances/intersections to 3 planes, one for x, y and z\n        //i know that there is no cubes in x, y and z between -0.5,0.5,\n        //so if the ray points far forward it can jump pretty farin one step,\n        vec3 planes  = 0.75-pos2*signdir;\n        //if x, y or z is over 0.5 or under -0.5 i set its length to 0\n        planes *= step(abs(pos2),vec3(1.0));\n        //turns it from closest point distance to ray-plane intersection distance, you can comment this out if you want a distance field\n        planes /= dir*signdir;\n        //takes the longest distance,\n        //if you take not the longest, not the smallest but the middle you get a nice pattern, useful for menger sponge\n        float len  = max(max(planes.x,planes.y),planes.z);\n        //float len = mid(planes);\n        \n        //moves the ray position forward\n        pos += dir*len;\n        dist += len;\n        \n        //if it hits a cube it breaks out of the loop\n        if (len < 0.001) {\n            break;\n        }\n    }\n    //moves position to cube space(0,0,0 is in the middle of the cube)\n    vec3 pos2 = mod(pos,2.0)-1.0;\n    //finds the normal, finds the x,y or z furthest from 0, and checks if it is over or under 0\n    vec3 normal = vec3(greaterThan(abs(pos2),max(abs(pos2.yzx),abs(pos2.zxy))))*sign(pos2);\n    //colors the cubes with random colors, don't need to say more about this\n    fragColor = vec4((sin(pos*3.0+dist+iTime)*0.5+0.5)/(dist+1.0)*2.0+(normal*0.25+0.25),1.0);\n    //makes the color darker the farther the ray has traveled\n    fragColor *= 2./(2. + dist*dist*.0001);\n}\n/**/\n\n/**\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 pos = vec3(1.0,0.0,iTime);\n    \n    vec3 dir = normalize(vec3(uv,1.0));\n    vec3 signdir = sign(dir);\n    float dist = 0.0;\n    vec3 normal;\n    \n    //these 3 variables are used for \n    float hitcount = 0.0; //how many times the ray has reflected\n    float number = 1.0;   //divides by 2 everytime the ray hits\n    float number2 = 0.0;\n    for (int i = 0; i < 48; i++) {\n        \n        vec3 pos2 = mod(pos+1.0,2.0)-1.0;\n        vec3 num  = 0.5-pos2*signdir;\n        num *= step(abs(pos2),vec3(0.5));\n        num /= dir*signdir;\n        float len  = max(max(num.x,num.y),num.z);\n        \n        if (len < 0.001) {\n            hitcount++;\n            number *= 0.5;\n            number2 += number;\n            fragColor += vec4((sin(pos*3.0+dist+iTime)*0.5+0.5)/(dist+1.0)*2.0+normal*0.2,1.0)*number;\n            if (hitcount == 4.0) break;\n            \n            dir = reflect(dir,normal);\n            signdir = sign(dir);\n            pos += dir*0.1;\n        }\n        \n        normal = vec3(equal(vec3(len),num));\n        \n        pos += dir*len;\n        dist += len;\n    }\n    \n    fragColor /= number2;\n    fragColor *= 2./(2. + dist*dist*.001);\n    //fragColor = vec4(dot(normal,vec3(0.5,0.25,1.0)));\n\t//fragColor = vec4((sin(pos*3.0+dist+iTime)*0.5+0.5)/(dist+1.0)*2.0+normal*0.2,1.0);\n    //fragColor.xyz = normal;\n}\n\n/**/\n\n/**\n//golfed version by coyote 276 chars\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float d = 1., t = iTime, l = d;\n    \n    vec4 D = normalize(vec4(U+U - (O.xy=iResolution.xy), O.y ,0)),\n         p = D/D,\n         n;\n    p.z = t;\n\n    while (l > .001)\n        O = step(l,n)*.2,\n        n = mod(p,2.)-1.,\n        n = (.5*sign(D)-n)\n             * step(abs(n),.5+D-D)\n            / D,\n        l  = max(max(n.x,n.y),n.z),\n        p += D*l,\n        d += l;\n    \n\tO +=  (1.+sin(p*3.+d+t)) / d;\n}\n/**/\n\n//golfed version by FabriceNeyret2 283 chars\n/**\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float d = 1., t = iTime, l=1.;\n    \n    vec4 p = vec4(1,1,t,1),\n         D = normalize(vec4(U+U - (O.xy=iResolution.xy), O.y ,0)),\n         n;\n\n    while (l > .001)\n        O = step(l,n)*.2,\n        n = mod(p,2.)-1.,\n        n = (.5*sign(D)-n)\n             * step(abs(n),vec4(.5))\n            / D,\n        l  = max(max(n.x,n.y),n.z),\n        p += D*l,\n        d += l;\n    \n\tO +=  (1.+sin(p*3.+d+t)) / d;\n}\n/**/\n\n//golfed version with changed look 275 chars\n/**\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float d = 0., t = iTime, l=1.;\n    \n    vec4 p = vec4(0,0,t,0),\n         D = normalize(vec4(U+U - (O.xy=iResolution.xy), O.y ,0)),\n         n;\n\n    while (l > .001)\n        O = step(l,n)*.2,\n        n = mod(p+1.,2.)-1.,\n        n = (.5*sign(D)-n)\n             * step(abs(n),vec4(.5))\n            / D,\n        l  = max(max(n.x,n.y),n.z),\n        p += D*l,\n        d += l;\n    \n\tO +=  (1.+sin(p*3.+d+t)) / (d+1.);\n}\n\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}