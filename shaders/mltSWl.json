{
    "Shader": {
        "info": {
            "date": "1685899169",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!",
            "flags": 0,
            "hasliked": 0,
            "id": "mltSWl",
            "likes": 27,
            "name": "Year of Truchets #031",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 562
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #031\n    06/04/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    layout based off https://www.shadertoy.com/view/DddSDl\n\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MAX_DIST    18.\n#define MIN_DIST    1e-5\n\n// globals\nvec3 hit,hitPoint,trigger,stored;\nfloat time=0.,spd=.3,tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ghs,shs;\nmat2 r45,rx,ry;\nconst float db = 12.;\n\nvec2 hash2( vec2 p ){ return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\n//@iq extrude\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec3 tile(vec2 q, vec2 id) {\n\n    float hs = hash21(id);\n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    float wd = .025;\n    \n    if(hs>.5) q *= rot(1.5707);\n    hs = fract(hs*575.913);\n    \n    vec2 sp = vec2(length(q-.5),length(q+.5));\n    vec2 p = sp.x<sp.y? q-.5 : q+.5;\n\n    // main pattern\n    float d = abs(length(p)-.5)-wd;\n    float g = length(abs(q)-.5)-(.425-wd);\n    float c = min(length(q.x)-wd,length(q.y)-wd);\n    // alt patterns\n    if (hs>.85) d = c;ghs=hs;\n    hs = fract(hs*415.372);\n  \n    if (ck>.5 && hs<.8) d = min(length(abs(q)-vec2(.5,0))-wd,length(q.x)-wd);\n\n    // accents\n    float b = length(abs(q)-.5)-.125;\n    float d2 = abs(max(abs(q.x),abs(q.y))-.5)-.01;\n    d2=max(d2,-b);\n \n    return vec3(d,b,d2);\n}\nfloat glow=0.;\n\nvec2 map(vec3 pos, float sg){\n    vec2 res = vec2(1e5,0);\n    pos.xz*=r45;\n    pos.xz+=vec2(ga1,ga2);\n    pos.z-=spd;\n  \n    vec2 id = floor(pos.xz);\n    vec2 uv = fract(pos.xz)-.5;\n    vec2 xd =  floor(pos.xz-.5);\n    vec2 vv = fract(pos.xz-.5)-.5;\n    \n    float hs = hash21(xd);\n    // render tiles once at first loop\n    vec3 t1 = trigger.x>1.? stored : tile(uv,id);\n    if(trigger.x<1.) stored = t1;\n    vec3 pp = vec3(uv.x,pos.y,uv.y);\n    float d1 = opx(t1.x,pos.y,.95);\n    if(d1<res.x) {\n        res = vec2(d1,2.);\n        hit=pp;\n    }\n    \n    float d2 = opx(abs(t1.y)-.02,pos.y,.1+(hs*.75));\n    d2 = min(opx(t1.y,pos.y,.05),d2);\n    if(d2<res.x) {\n        res = vec2(d2,3.);\n        hit=pos;\n    }\n     \n    float d3 = opx(t1.z,pos.y,.01);\n    if(d3<res.x) {\n        res = vec2(d3,4.);\n        hit=pos;\n    }\n    \n    float ff = .8+.5*sin((hs*25.5)+(T*.45*hs));\n    float d4 = hs<.8?1e5:length(vec3(vv.x,pos.y-ff,vv.y))-.05;\n           \n    if(sg==1.&&d4<d2) { glow += .00065/(.001+d4*d4);}\n    if(d4<res.x&&sg!=0.) {\n        res = vec2(d4,5.);\n        hit=vec3(vv.x,pos.y-ff,vv.y);\n    }\n    \n    float gnd = pos.y+.01;\n    if(gnd<res.x) {\n        res = vec2(gnd,1.);\n        hit=pos;\n    }\n\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 O, in vec2 F) { \n\n    //  precal //\n    vec3 col = vec3(0); \n    spd = T*.1;\n    r45 = rot(.78);\n    tspeed = T*.5;\n    tmod = mod(tspeed,12.);\n    \n    float t1 = lsp(00.,02.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    \n    float t2 = lsp(03.,05.,tmod);\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    \n    float t3 = lsp(06.,08.,tmod);\n    t3 = eoc(t3); t3 = t3*t3*t3;\n    \n    float t4 = lsp(09.,11.,tmod);\n    t4 = eoc(t4); t4 = t4*t4*t4;\n    \n    ga1 = (t1*db)-(t3*db);\n    ga2 = (t2*db)-(t4*db);\n    \n    ga3 = (t1-t3);\n    ga4 = (t2-t4);\n    \n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.125-.0625)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*.125-.0625)*PI;\n\n    rx = rot(x-.7);\n    ry = rot(y+(ga3-ga4)*PI);\n       \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,5.);\n    vec3 rd = normalize(vec3(uv,-1.));\n    \n    // mouse //\n    ro.zy*=rx;ro.xz*=ry;\n    rd.zy*=rx;rd.xz*=ry;\n\n    float d = 0.,m = 0.;\n    vec3 color = vec3(0), n = vec3(0),p = vec3(0);\n    \n    // marcher\n    for(int i=0;i<100;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p,1.);\n        trigger.x = i>1? 1.:0.; // set trigger\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.4: ray.x*.9;\n        m  = ray.y;\n    } \n    \n    hitPoint=hit;\n    shs=ghs;\n    \n    if (d < MAX_DIST) \n    {\n        vec3 n = normal(p, d);\n        vec3 lpos =vec3(5,12,-5);\n        vec3 l = normalize(lpos-p);\n        float diff = clamp(dot(n,l),.05,1.);\n        \n        //shadows\n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        vec3 h = vec3(0);\n        \n        \n        if(m==1.) {\n            h = vec3(.005);\n            vec3 hp = hitPoint;\n            float ft = fract((hp.x-hp.z)*12.)-.5;\n            if (shs>.8) h = mix(vec3(.8,.35,0),vec3(.1),mod(floor(ft),2.)==0.?1.:0.);\n            if (shs<.5) h =vec3(.05);\n        }\n        \n        if(m==2.) {\n    \n            h = vec3(.6);\n            vec3 hp = hitPoint;\n            float ft = fract((hp.x-hp.z)*6.)-.5;\n            if (hp.y>.8) h = mix(vec3(1,.5,0),vec3(.04),mod(floor(ft),2.)==0.?1.:0.);\n            h = (hp.y<.1||hp.y>.9) ? vec3(.1) : h;\n        }\n        \n        if(m==3.) h = vec3(.09);\n        if(m==4.) h = vec3(.2);\n        \n        color = h*diff;\n    }\n    color = mix(color,vec3(.32,.40,.48), 1.-exp(-.001*d*d*d));\n    color = mix(color,vec3(.96,.87,.69),clamp(glow*.5,0.,1.));\n    color=pow(color,vec3(.4545));\n\n    O = vec4(color, 0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}