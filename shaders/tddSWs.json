{
    "Shader": {
        "info": {
            "date": "1573165428",
            "description": "Version of https://www.shadertoy.com/view/3stXDX with cleaner visualization to emphasize the use of fonts for shape creation.",
            "flags": 0,
            "hasliked": 0,
            "id": "tddSWs",
            "likes": 32,
            "name": "Font Forest 2",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "font"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 623
        },
        "renderpass": [
            {
                "code": "// Inspired by FabriceNeyret2's https://www.shadertoy.com/view/tdcXW2\n// Original version: https://www.shadertoy.com/view/3stXDX\n\n#define FDIST 0.5\n#define MAXSTEP 100\n#define TOL 0.001\n#define MAXDIST 20.\n#define INTERP_SCALE 0.3\n#define REPEAT_SCALE 1.75\n#define MOUSE_SCALE 0.014\n#define TEXSCALE vec2(1.5, 1.)\n#define TEX_BIAS 0.49803921568\n#define VERT_SPEED 0.5\n#define ROT_SPEED 0.25\n#define OFFSET_SCALE 8.\n\n// comment this to change to deterministic character order,\n// or if you have weird artifacts where segments don't line up (on macbook GPUs)\n#define SHUFFLE\n\nfloat rand(vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\nfloat randoffset(vec2 uv) {\n    vec2 id = floor((uv+REPEAT_SCALE*0.5)/REPEAT_SCALE);\n    return rand(id);\n}\n\nfloat noise1D(float t) {\n    return fract(14950.5*sin(1905.1*t));\n}\n\nvec2 id2coord(in float id) {\n    #ifdef SHUFFLE\n    id = floor(noise1D(id) * 256.);\n    #endif\n    return vec2(mod(id, 16.), floor(id/16.))/16.;\n}\n\nvoid transform(inout vec3 ro) {\n    \n    float offset = randoffset(ro.xy)*256.;\n    ro = vec3(mod(ro.xy+REPEAT_SCALE*0.5, REPEAT_SCALE)-REPEAT_SCALE*0.5, ro.z/INTERP_SCALE + offset);\n}\n\n/**\nCompute analytic gradient\n*/\nvec3 grad(in vec3 ro) {\n    float realz = ro.z;\n    float of = randoffset(ro.xy) * OFFSET_SCALE;\n    transform(ro);\n    float t = ro.z;\n    float id = floor(t);\n    vec2 offset = clamp(ro.xy+0.5, 0., 1.)/16.;\n    vec2 coords1 = id2coord(id) + offset;\n    vec2 coords2 = id2coord(id+1.) + offset;\n    \n    vec4 tex1 = textureGrad(iChannel0,coords1,dFdx(offset),dFdy(offset));\n    vec4 tex2 = textureGrad(iChannel0,coords2,dFdx(offset),dFdy(offset));\n    \n    float dist1 = tex1.w-TEX_BIAS;\n    float dist2 = tex2.w-TEX_BIAS;\n    \n    vec2 norm1 = (tex1.yz-TEX_BIAS)*2.;\n    vec2 norm2 = (tex2.yz-TEX_BIAS)*2.;\n    \n    float tf = fract(t);\n    float alpha = smoothstep(0., 1., tf);\n    vec3 n = vec3(norm1 * (1.-alpha) + norm2 * alpha, (dist2 - dist1) * INTERP_SCALE * 6. * (tf - tf*tf));\n    n.y = -n.y;\n    return mix(normalize(n), vec3(0., 0., 1.), smoothstep(-INTERP_SCALE-TOL, -INTERP_SCALE, realz - iTime * VERT_SPEED + of));\n}\n\nfloat map(in vec3 ro) {\n    float realz = ro.z;\n    float of = randoffset(ro.xy) * OFFSET_SCALE;\n    transform(ro);\n    float t = ro.z;\n    float id = floor(t);\n    vec2 offset = clamp(ro.xy+0.5, 0., 1.)/16.;\n    vec2 coords1 = id2coord(id) + offset;\n    vec2 coords2 = id2coord(id+1.) + offset;\n    \n    float dist1 = textureGrad(iChannel0, coords1,dFdx(offset), dFdy(offset)).w-TEX_BIAS;\n    float dist2 = textureGrad(iChannel0, coords2,dFdx(offset), dFdy(offset)).w-TEX_BIAS;\n    vec2 displacement = abs(ro.xy)-0.5;\n    float alpha = smoothstep(0., 1., fract(t));\n    float d = max(max(displacement.x, displacement.y), 0.5*(dist1 * (1.-alpha) + dist2*alpha));\n    return min(REPEAT_SCALE-1.,max(d, realz - iTime*VERT_SPEED + INTERP_SCALE + of));\n}\n\nvec2 raymarch(in vec3 eye, in vec3 rd) {\n    float t = 0.0;\n    int i;\n    for (i=0; i<MAXSTEP; i++) {\n        vec3 pos = eye + rd*t;\n        float dist = map(pos);\n        t += dist;\n        if (abs(dist) < TOL || t > MAXDIST) break;\n    }\n    return vec2(t, i);\n}\n\nbool shadowmarch(in vec3 eye, in vec3 rd, float lightdist) {\n    float t = 0.0;\n    float minstep = 0.01;\n    for (int i=0; i<50; i++) {\n        vec3 pos = eye + rd * t;\n        float dist = map(pos);\n        if (dist < 0.) return true;\n        else if (t > lightdist) return false;\n        float s = max(dist, minstep);\n        minstep += 0.001;\n        t += s;\n        \n    }\n    return false;\n}\n\nfloat shade(in vec3 n, in vec3 ro, in vec3 lightpos, bool shadow) {\n    vec3 l = lightpos - ro;\n    float ldist = length(l);\n    if (shadow && shadowmarch(ro + n*TOL*2., l/ldist, ldist)) {\n    \treturn 0.;\n    }\n    return max(0.,smoothstep(0., 1., dot(l, n)/ldist))*min(1., 1.5/(ldist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.xx;\n\t\n    vec3 up = vec3(0, 0, 1);\n    float rotfac = iTime*ROT_SPEED + iMouse.x*MOUSE_SCALE;\n    vec3 eye = vec3(REPEAT_SCALE*0.6*cos(rotfac), REPEAT_SCALE*0.6*sin(rotfac), iTime*VERT_SPEED);\n    vec3 lightpos = vec3(REPEAT_SCALE*0.5, REPEAT_SCALE*0.5, iTime*VERT_SPEED+0.5);\n    vec3 lightpos2 = vec3(-REPEAT_SCALE*0.5, -REPEAT_SCALE*0.5, iTime*VERT_SPEED-0.5);\n    vec3 w = normalize(vec3(-eye.xy, iMouse.y > 1. ? (iMouse.y-iResolution.y*0.7) * MOUSE_SCALE * REPEAT_SCALE * 0.33 : -0.5*cos(iTime*0.13)-0.5));\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w*FDIST + u*uv.x + v*uv.y);\n    \n\tvec2 t = raymarch(eye, rd);\n    vec3 ro = t.x * rd + eye;\n    vec3 n = grad(ro);\n    \n    float fac1 = shade(n, ro, lightpos, false);\n    float fac2 = shade(n, ro, lightpos2, false);\n    vec3 lighting = (fac1*vec3(0.7, 0.8, 1.) + fac2*vec3(0.7, 0.6, 0.6))*0.7;\n    lighting += vec3(0.3)*smoothstep(0.2, 1., dot(-rd, n))*min(1., 0.5/(t.x*t.x));\n    \n    // --- glowing letters ---\n    // X-ray glow\n    float h = (fract(ro.z/INTERP_SCALE)-0.5)*INTERP_SCALE;\n    float newt = INTERP_SCALE*0.5/abs(rd.z) - h/rd.z;\n    vec3 roo = newt * rd + ro;\n    float edgefac = (1.+sin(iTime*10.)*.2) * (sin((roo.x+roo.y + iTime*.1)*350.)*.5+.5) * smoothstep(0.005, 0., abs(map(roo)));\n    \n    // surface glow\n    float alpha = smoothstep(0.85, 1., 2.*abs(fract(ro.z/INTERP_SCALE)-0.5));\n    vec3 emissioncol =  vec3(0.5, 1., 0.7);\n    float emissionfac = (alpha + edgefac) * min(1., 0.5/(t.x*t.x)) * min(0.75, (0.07/(newt)));\n    \n    // extrusion glow\n    float of = randoffset(ro.xy) * OFFSET_SCALE;\n    float shifted = ro.z - iTime * VERT_SPEED + of;\n    float emissionfac2 = smoothstep(-INTERP_SCALE-0.02, -INTERP_SCALE, shifted);\n    float emissionfac22 = 0.75*smoothstep(-INTERP_SCALE-0.05, -INTERP_SCALE, shifted);\n    vec3 emission = emissionfac*emissioncol + emissionfac2*vec3(1., 0.6, 0.) + emissionfac22*vec3(1., 0.2, 0.);\n    \n    // --------------------\n    \n    // fog\n    float fogfac = min(1.,t.x*0.05);\n    vec3 fogcol = mix(vec3(1., 0.2, 0.0), 0.2*vec3(2, 3, 5), rd.z*.5+.5);\n    \n    vec3 finalcol = mix(lighting + emission, fogcol, fogfac);\n    fragColor = vec4(pow(finalcol, vec3(0.75)),1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}