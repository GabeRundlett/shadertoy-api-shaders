{
    "Shader": {
        "info": {
            "date": "1643224986",
            "description": "Based on something animated I saw in a C4D group. Need to figure a better way for the math/timing - brute force based on mod of time/direction. ",
            "flags": 0,
            "hasliked": 0,
            "id": "ssSyRD",
            "likes": 20,
            "name": "Spinning Discs",
            "published": 3,
            "tags": [
                "raymarching",
                "animation",
                "looping"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 367
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Spinning Discs | Motion Replication\n    01/26/22 @byt3_m3chanic \n    \n    Based on something animated I saw in a C4D group. Need to figure a better\n    way for the math/timing - brute force based on mod of time.\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .001\n#define MAX_DIST    175.\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat lsp(float b,float e,float t) { return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t=t-1.)*t*t+1.; }\n\nfloat capp( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global\nvec3 hp,hitPoint;\nfloat tmod,ga1,ga2,ga3,ga4,ga5,ga6,ga7,ga8,ga9,ga10,ga11,ga12;\nmat2 er1,er2,er3,er4,er5,er6,er7,er8,er9,er10,er11,er12;\nmat2 dr1,dr2,dr3;\n\nfloat getcap(vec3 p, float h) {\n    float c1 = capp(p,1.5,h);  \n    p.x=abs(p.x)-2.;\n    return max(c1,-capp(p,1.5,h*2.));\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p+=vec3(1.35,2.2,-.25);\n    \n    vec3 pd = p-vec3(0,0,1);\n    pd.xz*=dr1;\n    float r1 = getcap(pd,1.5);\n    if(r1<res.x) {\n        res = vec2(r1,1.);\n        hp=pd;\n    }\n    \n    pd = p-vec3(2,-.25,1);\n    pd.xz*=dr2;\n    float r2 = getcap(pd,1.);\n    if(r2<res.x) {\n        res = vec2(r2,2.);\n        hp=pd;\n    }\n     \n    pd = p-vec3(-2,-.25,1); \n    pd.xz*=dr3;\n    float r3 = getcap(pd,.75);\n    if(r3<res.x) {\n        res = vec2(r3,3.);\n        hp=pd;\n    }\n\n    vec3 pxa = vec3(p.x,p.y,p.z-1.);\n    vec3 pxb = vec3(p.x,p.y,p.z-1.);\n    vec3 pxc = vec3(p.x+3.,p.y,p.z-1.);\n    vec3 pxd = vec3(p.x-3.,p.y,p.z-1.);\n\n    if(tmod<1.){\n    // move center\n        pxa.xz*=er1;\n        pxb.xz*=er1;\n        pxa.x+=1.;\n        pxb.x-=1.;\n    } else if(tmod<2.){\n    // move right\n        pxa = vec3(p.x-2.,p.y,p.z-1.);\n        pxd = vec3(p.x-2.,p.y,p.z-1.);\n        pxb = vec3(p.x+1.,p.y,p.z-1.);\n        pxc = vec3(p.x+3.,p.y,p.z-1.);\n        pxa.xz*=er2;\n        pxd.xz*=er2;\n        pxa.x+=1.;\n        pxd.x-=1.;\n    } else if(tmod<3.){\n    // move left\n        pxa = vec3(p.x-3.,p.y,p.z-1.);\n        pxd = vec3(p.x-1.,p.y,p.z-1.);\n        pxb = vec3(p.x+2.,p.y,p.z-1.);\n        pxc = vec3(p.x+2.,p.y,p.z-1.);\n        pxb.xz*=er3;\n        pxc.xz*=er3;\n        pxb.x-=1.;\n        pxc.x+=1.;       \n        \n    } else if(tmod<4.){\n    // move center\n        pxa = vec3(p.x-3.,p.y,p.z-1.);\n        pxb = vec3(p.x+3.,p.y,p.z-1.);\n        pxc = vec3(p.x,p.y,p.z-1.);\n        pxd = vec3(p.x,p.y,p.z-1.);\n        pxc.xz*=er4;\n        pxd.xz*=er4;\n        pxc.x+=1.; \n        pxd.x-=1.;\n    } else if(tmod<5.){\n    // move right\n        pxb = vec3(p.x+3.,p.y,p.z-1.);\n        pxc = vec3(p.x-2.,p.y,p.z-1.);\n        pxa = vec3(p.x-2.,p.y,p.z-1.);\n        pxd = vec3(p.x+1.,p.y,p.z-1.);\n        pxa.xz*=er5;\n        pxc.xz*=er5;\n        pxa.x-=1.; \n        pxc.x+=1.;\n        \n    } else if(tmod<6.){\n    // move left\n        pxc = vec3(p.x-3.,p.y,p.z-1.);\n        pxa = vec3(p.x-1.,p.y,p.z-1.);\n        pxb = vec3(p.x+2.,p.y,p.z-1.);\n        pxd = vec3(p.x+2.,p.y,p.z-1.);\n        pxd.xz*=er6;\n        pxb.xz*=er6;\n        pxd.x-=1.; \n        pxb.x+=1.;\n    } else if(tmod<7.){\n    // move center\n        pxc = vec3(p.x-3.,p.y,p.z-1.);\n        pxd = vec3(p.x+3.,p.y,p.z-1.);\n        pxb = vec3(p.x,p.y,p.z-1.);\n        pxa = vec3(p.x,p.y,p.z-1.);\n        pxb.xz*=er7;\n        pxa.xz*=er7;\n        pxb.x+=1.;\n        pxa.x-=1.;\n    } else if(tmod<8.){\n    // move right\n        pxd = vec3(p.x+3.,p.y,p.z-1.);\n        pxa = vec3(p.x+1.,p.y,p.z-1.);\n        pxc = vec3(p.x-2.,p.y,p.z-1.);\n        pxb = vec3(p.x-2.,p.y,p.z-1.);\n        pxc.xz*=er8;\n        pxb.xz*=er8;\n        pxc.x-=1.;\n        pxb.x+=1.;\n    } else if(tmod<9.){\n    // move left\n        pxd = vec3(p.x+2.,p.y,p.z-1.);\n        pxa = vec3(p.x+2.,p.y,p.z-1.);\n        pxc = vec3(p.x-1.,p.y,p.z-1.);\n        pxb = vec3(p.x-3.,p.y,p.z-1.);\n        pxa.xz*=er9;\n        pxd.xz*=er9;\n        pxa.x-=1.;\n        pxd.x+=1.;\n    } else if(tmod<10.){\n     // move center\n        pxd = vec3(p.x,p.y,p.z-1.);\n        pxc = vec3(p.x,p.y,p.z-1.);\n        pxa = vec3(p.x+3.,p.y,p.z-1.);\n        pxb = vec3(p.x-3.,p.y,p.z-1.);\n        pxc.xz*=er10;\n        pxd.xz*=er10;\n        pxc.x-=1.;\n        pxd.x+=1.;\n    } else if(tmod<11.){\n    // move right\n        pxd = vec3(p.x-2.,p.y,p.z-1.);\n        pxb = vec3(p.x-2.,p.y,p.z-1.);\n        pxc = vec3(p.x+1.,p.y,p.z-1.);\n        pxa = vec3(p.x+3.,p.y,p.z-1.);\n        pxb.xz*=er11;\n        pxd.xz*=er11;\n        pxb.x-=1.;\n        pxd.x+=1.;\n    } else if(tmod<12.){\n    // move left\n        pxd = vec3(p.x-3.,p.y,p.z-1.);\n        pxb = vec3(p.x-1.,p.y,p.z-1.);\n        pxc = vec3(p.x+2.,p.y,p.z-1.);\n        pxa = vec3(p.x+2.,p.y,p.z-1.);\n        pxa.xz*=er12;\n        pxc.xz*=er12;\n        pxa.x+=1.;\n        pxc.x-=1.;\n    }   \n    \n    float s8 = length(pxa-vec3(0,1.95,0))-.35;\n    if(s8<res.x) {\n        res = vec2(s8,8.);\n        hp=pxa;\n    }\n    pxa.x=abs(pxa.x)+1.025;\n    float d1 = capp(pxa,1.5,1.5);\n    if(d1<res.x) {\n        res = vec2(d1,4.);\n        hp=pxa;\n    }\n    \n    float s3 = length(pxb-vec3(0,1.05,0))-.15;\n    if(s3<res.x) {\n        res = vec2(s3,9.);\n        hp=pxb;\n    }\n    pxb.x=abs(pxb.x)+1.025;\n    float d3 = capp(pxb,1.5,.75);\n    if(d3<res.x) {\n        res = vec2(d3,5.);\n        hp=pxb;\n    }\n    \n    float s2 = length(pxc-vec3(0,.15,0))-.25;\n    if(s2<res.x) {\n        res = vec2(s2,6.);\n        hp=pxc;\n    }\n    pxc.x=abs(pxc.x)+1.025;\n    float d2 = capp(pxc+vec3(0,.35,0),1.5,.15);\n    if(d2<res.x) {\n        res = vec2(d2,7.);\n        hp=pxc;\n    }  \n    \n    float s4 = length(pxd-vec3(0,.35,0))-.2;\n    if(s4<res.x) {\n        res = vec2(s4,4.);\n        hp=pxd;\n    }\n    pxd.x=abs(pxd.x)+1.025;\n    float d4 = capp(pxd+vec3(0,.25,0),1.5,.25);\n    if(d4<res.x) {\n        res = vec2(d4,8.);\n        hp=pxd;\n    }\n    \n    float fx = p.y+.5;\n    if(fx<res.x) {\n        res = vec2(fx,0.);\n        hp=p;\n    }\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        if(t.x<1e-4) hit = true;\n        d += i<32? t.x*=.8:t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>65.) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 hue(float t){ \n    const vec3 d = vec3(0.365,0.910,0.067);\n    return .55 + .35*cos(PI2*t*(vec3(.95,.97,.98)*d)); \n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p, hit, 100);\n    d = ray.x;\n    m = ray.y;\n    hitPoint = hp;\n\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(-1.5,8,-2.5);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        float t=.25;\n        for( int i =0; i<16; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.75 * pow(max(dot(view, ret), 0.), 24.);\n\n        vec3 h = vec3(.5);\n        float px = fwidth(hitPoint.x);\n        \n        if(m==0.) {\n            float scale = 1.;\n            \n            vec2 uv = fract(hitPoint.xz*scale)-.5;\n            vec2 id= floor(hitPoint.xz*scale);\n            \n            float hs =hash21(id);\n            h=vec3(0.45);\n            ref=h;\n\n            float chk = mod(id.x+id.y,2.) * 2.-1.;\n            if(chk>.5) {\n                h=hue(hs);\n                ref=h;\n            }\n        }\n        \n        if(m==1.) {\n           h=vec3(0.004,0.322,0.616);\n           vec2 f = vec2(atan(hitPoint.z,hitPoint.x)/PI2,hitPoint.y);\n           f.x=fract(f.x*12.)-.5;\n           float c = length(f-vec2(0,.5))-.25;\n           c=smoothstep(.011+px,px,abs(abs(abs(c)-.1)-.05)-.02);\n           if(length(hitPoint.xz)>1.495) h=mix(h,vec3(1),c);\n           ref = h*.5;\n        }\n        \n        if(m==2.) {\n           h=vec3(0.518,0.545,0.518);\n           vec2 f = vec2(atan(hitPoint.z,hitPoint.x)/PI2,hitPoint.y);\n\n           f.x=fract(f.x*12.)-.5;\n           float sw = .5-.15*sin(f.x*PI2);\n           float c = length(f.y-sw)-.1;\n           \n           c=smoothstep(.011+px,px,abs(abs(abs(c)-.1)-.05)-.015);\n           if(length(hitPoint.xz)>1.495) h=mix(h,vec3(1),c);\n           ref = h*.5;\n        }\n        \n        if(m==3.) {\n           h=vec3(0.925,0.557,0.827);\n           vec2 f = vec2(atan(hitPoint.z,hitPoint.x)/PI2,hitPoint.y);\n           f=fract(f*vec2(24.,6.))-.5;\n           if(length(hitPoint.xz)>1.495) {\n           if(f.x*f.y>0.) h=vec3(.2);\n           }\n           ref = h*.15;\n        }\n        \n        if(m==4.) {\n            h=vec3(0.188,0.188,0.188);\n            ref = h*.15;\n        }\n        if(m==5.) {\n            h=vec3(0.675,0.784,0.867);\n            ref = h;\n        }\n        if(m==6.) {\n            h=vec3(0.278,0.529,0.761);\n            ref = h*.25;\n        }\n        if(m==7.) {\n            h=vec3(0.690,0.690,0.690);\n            ref = h*.5;\n        }\n        if(m==8.) {\n            h=vec3(0.859,0.694,0.541);\n            ref = h*.65;\n        }\n        if(m==9.) {\n            h=vec3(0.910,0.808,0.710);\n            ref = h*.25;\n        }\n        if(m==10.) {\n            h=vec3(0.859,0.694,0.541);\n            ref = h*.5;\n        }\n        RC = h * diff + min(spec,shdw);\n        if(bnc<1) RC = mix(RC,vec3(.05), 1.-exp(-.0025*d*d*d));\n        \n        ro = p+n*.002;\n        rd = reflect(rd,n);\n        \n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nconst vec3 FC = vec3(0.149,0.157,0.173);\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    tmod = mod(T*.5,12.);\n    if(tmod<1.){\n        float t1 = lsp(0.0, 1.0, tmod);\n        ga1 = eoc(t1);\n        ga1 = ga1*ga1*ga1;\n        er1=rot(ga1*PI);\n    } else if(tmod<2.){\n        float t2 = lsp(1.0, 2.0, tmod);\n        ga2 = eoc(t2);\n        ga2 = ga2*ga2*ga2;\n        er2=rot(-ga2*PI);\n    } else if(tmod<3.){\n        float t3 = lsp(2.0, 3.0, tmod);\n        ga3 = eoc(t3);\n        ga3 = ga3*ga3*ga3;\n        er3=rot(ga3*PI);\n    } else if(tmod<4.){\n        float t4 = lsp(3.0, 4.0, tmod);\n        ga4 = eoc(t4);\n        ga4 = ga4*ga4*ga4;\n        er4=rot(-ga4*PI);\n    } else if(tmod<5.){\n        float t5 = lsp(4.0, 5.0, tmod);\n        ga5 = eoc(t5);\n        ga5 = ga5*ga5*ga5;\n        er5=rot(ga5*PI);\n    } else if(tmod<6.){\n        float t6 = lsp(5.0, 6.0, tmod);\n        ga6 = eoc(t6);\n        ga6 = ga6*ga6*ga6;\n        er6=rot(-ga6*PI);\n    } else if(tmod<7.){\n        float t7 = lsp(6.0, 7.0, tmod);\n        ga7 = eoc(t7);\n        ga7 = ga7*ga7*ga7;\n        er7=rot(ga7*PI);\n    } else if(tmod<8.){\n        float t8 = lsp(7.0, 8.0, tmod);\n        ga8 = eoc(t8);\n        ga8 = ga8*ga8*ga8;\n        er8=rot(-ga8*PI);\n    } else if(tmod<9.){\n        float t9 = lsp(8.0, 9.0, tmod);\n        ga9 = eoc(t9);\n        ga9 = ga9*ga9*ga9;\n        er9=rot(ga9*PI);\n    } else if(tmod<10.){\n        float t10 = lsp(9.0,10.0, tmod);\n        ga10 = eoc(t10);\n        ga10 = ga10*ga10*ga10;\n        er10=rot(-ga10*PI);\n    } else if(tmod<11.){\n        float t11 = lsp(10.0,11.0, tmod);\n        ga11 = eoc(t11);\n        ga11 = ga11*ga11*ga11;\n        er11=rot(ga11*PI);\n    } else if(tmod<12.){\n        float t12 = lsp(11.0,12.0, tmod);\n        ga12 = eoc(t12);\n        ga12 = ga12*ga12*ga12; \n        er12=rot(-ga12*PI);\n    }   \n  \n    dr1=rot((ga1*PI)+(-ga4*PI)+(ga7*PI)+(-ga10*PI));\n    dr2=rot((-ga2*PI)+(ga5*PI)+(-ga8*PI)+(ga11*PI));\n    dr3=rot((ga3*PI)+(-ga6*PI)+(ga9*PI)+(-ga12*PI));\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    float zoom = 5.5;\n    vec3 ro = vec3(uv*zoom,-zoom-2.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    mat2 rx =rot(.78);\n    mat2 ry =rot(-.78);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0., f = 0.;\n    bool hit = false;\n \n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    C = mix(C,vec3(.05), 1.-exp(-.00015*fA*fA*fA));\n    C = mix(C,FC,smoothstep(0.,1.,f*0.015));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}