{
    "Shader": {
        "info": {
            "date": "1611718347",
            "description": "This shader represents BigETI's avatar.\n\nUncomment `ENABLE_SNAPSHOT_MODE` to take a snapshot of my avatar.",
            "flags": 32,
            "hasliked": 0,
            "id": "ttVcWy",
            "likes": 4,
            "name": "BigETI's Avatar",
            "published": 3,
            "tags": [
                "z",
                "tetris",
                "bigeti",
                "eti",
                "tetrimino"
            ],
            "usePreview": 0,
            "username": "BigETI",
            "viewed": 288
        },
        "renderpass": [
            {
                "code": "#define ENABLE_BACKGROUND\n#define ENABLE_TETRIMINO_GLOW\n//#define DISABLE_COLORS\n//#define ENABLE_SNAPSHOT_MODE\n\n// Anti aliasing level\n#ifdef ENABLE_SNAPSHOT_MODE\nconst uint antiAliasing = 4U;\n#else\nconst uint antiAliasing = 1U;\n#endif\n\n#ifdef ENABLE_BACKGROUND\n\n// Background circle color\nconst vec4 backgroundColor = vec4(0.0, 0.0, 1.0, 1.0);\n\n#endif\n\n#ifdef ENABLE_TETRIMINO_GLOW\n\n// Glow effect size in pixels\nconst uint glowSize = 48U;\n\n// Glow effect iteration step size (more equals faster, but less quality)\n    #ifdef ENABLE_SNAPSHOT_MODE\nconst uint glowIterationStepSize = 1U;\n    #else\nconst uint glowIterationStepSize = 4U;\n    #endif\n#endif\n\n// Color multiplier\n#ifdef DISABLE_COLORS\nconst vec3 colorMultiplier = vec3(0.25, 1.0, 2.0);\n#else\nconst vec3 colorMultiplier = vec3(1.0, 1.0, 1.0);\n#endif\n\n// Music beats per minute\nconst float beatsPerMinute = 114.0;\n\n// Pi\nconst float pi = 3.1415926535897932384626433832795028841971693993751058209749445923;\n\n// Half of pi\nconst float halfPi = 1.5707963267948966192313216916397514420985846996875529104874722961;\n\n// Alpha factor for beats\nconst float beatsAlphaFactor = pi * beatsPerMinute / 60.0;\n\n// Alpha blends colors\nvec4 AlphaBlendColors(const vec4 baseColor, const vec4 appendColor)\n{\n    vec3 color = mix(baseColor.rgb, appendColor.rgb, appendColor.a);\n    return vec4(color.x, color.y, color.z, baseColor.a + ((1.0 - baseColor.a) * appendColor.a));\n}\n\n// Rotates given UV coordinates\nvec2 Rotate(const vec2 uv, const float alpha)\n{\n\tfloat sine_result = sin(alpha);\n\tfloat cosine_result = cos(alpha);\n\treturn mat2(cosine_result, -sine_result, sine_result, cosine_result) * uv;\n}\n\n// Gets scene UV coordinates\nvec2 GetSceneUV(const vec2 fragCoord)\n{\n    return (fragCoord - (iResolution.xy * 0.5)) / iResolution.y * 2.0;\n}\n\n// Gets tetrimino UV coordinates\nvec2 GetTetriminoUV(vec2 uv)\n{\n#ifdef ENABLE_SNAPSHOT_MODE\n    return uv * 0.5 + vec2(0.5, 0.5);\n#else\n    float cosine_of_beats_alpha_factor = cos(iTime * beatsAlphaFactor);\n    float cosine_of_beats_alpha_factor_cubed = cosine_of_beats_alpha_factor * cosine_of_beats_alpha_factor * cosine_of_beats_alpha_factor;\n    return Rotate(uv * 0.5, cosine_of_beats_alpha_factor_cubed * halfPi * 0.125) * (1.0 - (cosine_of_beats_alpha_factor_cubed * cosine_of_beats_alpha_factor_cubed * 0.125)) + vec2(0.5, 0.5);\n#endif\n}\n\nfloat GetBrightness(const vec3 color)\n{\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n// Samples scene\nvec4 SampleScene(const vec2 fragmentCoordinates)\n{\n    vec2 uv = GetSceneUV(fragmentCoordinates);\n    \n    // Background circle\n#ifdef ENABLE_BACKGROUND\n    vec4 color = AlphaBlendColors(vec4(0.0, 0.0f, 0.0, 1.0), backgroundColor * vec4(1.0, 1.0, 1.0, clamp(1.0 - distance(vec2(0.0, 0.0), uv), 0.0, 1.0)));\n#else\n    vec4 color = vec4(0.0);\n#endif\n\n    // Tetrimino\n    vec4 tetrimino_color = texture(iChannel0, GetTetriminoUV(uv));\n\n    // Tetrimino glow effect\n#ifdef ENABLE_TETRIMINO_GLOW\n    if (tetrimino_color.a < 1.0)\n    {\n        float tetrimino_alpha_sum = 0.0;\n        for (int x = -int(glowSize), y; x <= int(glowSize); x += int(glowIterationStepSize))\n        {\n            for (y = -int(glowSize); y <= int(glowSize); y += int(glowIterationStepSize))\n            {\n                float fragment_distance_squared = float(x * x) + float(y * y);\n                if (fragment_distance_squared < float(glowSize * glowSize))\n                {\n                    tetrimino_alpha_sum += texture(iChannel0, GetTetriminoUV(GetSceneUV(fragmentCoordinates + vec2(x, y)))).a;\n                }\n            }\n        }\n        color = AlphaBlendColors(color, vec4(1.0, 1.0, 1.0, tetrimino_alpha_sum / float((4U * glowSize * glowSize) + 1U)) * float(glowIterationStepSize));\n    }\n#endif\n#ifdef DISABLE_COLORS\n    color = AlphaBlendColors(color, tetrimino_color);\n    float brightness = GetBrightness(color.rgb);\n    return vec4(brightness * colorMultiplier.r, brightness * colorMultiplier.g, brightness * colorMultiplier.b, color.a);\n#else\n    color = AlphaBlendColors(color, tetrimino_color);\n    color.r *= colorMultiplier.r;\n    color.g *= colorMultiplier.g;\n    color.b *= colorMultiplier.b;\n    return color;\n#endif\n}\n\n// Main entry point\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n    vec4 color_sum = vec4(0.0);\n    for (uint x = 0U, y; x != antiAliasing; x++)\n    {\n        for (y = 0U; y != antiAliasing; y++)\n        {\n            color_sum += SampleScene(fragmentCoordinates + vec2(((float(x) + 0.5) / float(antiAliasing)) - 0.5, ((float(y) + 0.5) / float(antiAliasing)) - 0.5));\n        }\n    }\n    fragmentColor = color_sum / float(antiAliasing * antiAliasing);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Tetrimino width\nconst uint tetriminoWidth = 19U;\n\n// Tetrimino height\nconst uint tetriminoHeight = 19U;\n\n// Color palette of tetrimino\nconst vec4 tetriminoColorPalette[] = vec4[]\n(\n    // Background\n    vec4(0.0, 0.0, 0.0, 0.0),\n    \n    // Primary (red)\n    vec4(1.0, 0.0, 0.0, 1.0),\n    \n    // Light (light red)\n    vec4(1.0, 141.0 / 255.0, 141.0 / 255.0, 1.0),\n    \n    // Shadow (dark red)\n    vec4(122.0 / 255.0, 0.0, 0.0, 1.0)\n);\n\n// Bitmap of tetrimino\nconst uint tetriminoBitmap[tetriminoWidth * tetriminoHeight] = uint[]\n(\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 2U, 2U, 2U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 3U, 3U, 3U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 2U, 2U, 2U, 3U, 2U, 2U, 2U, 2U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 3U, 3U, 3U, 3U, 2U, 3U, 3U, 3U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 2U, 2U, 2U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 3U, 3U, 3U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U\n);\n\n// Samples tetrimino\nvec4 SampleTetrimino(vec2 uv)\n{\n    //vec2 tetrimino_uv = vec2((uv.x + 1.0) * 0.5, (1.0 - uv.y) * 0.5);\n    vec2 tetrimino_uv = vec2(uv.x, 1.0 - uv.y);\n    int x = int(round(tetrimino_uv.x * float(tetriminoWidth)));\n    int y = int(floor(tetrimino_uv.y * float(tetriminoHeight)));\n    return ((x >= 0) && (x < int(tetriminoWidth)) && (y >= 0) && (y < int(tetriminoHeight))) ? tetriminoColorPalette[tetriminoBitmap[x + (y * int(tetriminoWidth))]] : vec4(0.0);\n}\n\n// Main entry point\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n    fragmentColor = SampleTetrimino(fragmentCoordinates / iResolution.xy);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}