{
    "Shader": {
        "info": {
            "date": "1496880984",
            "description": "differentiation\nsuccessful take into swiveling and substituting a lot of arithmetic.\n\na nice dive into calculating the LOCAL lipschitz constant on the go? (line 600)\nnot really sure if this is useful.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdfBzj",
            "likes": 10,
            "name": "023 Derivative Arithmetic 3",
            "published": 3,
            "tags": [
                "derivative",
                "complex",
                "mercury",
                "hgsdf",
                "automaticdifferentiation",
                "derivativearithmetic",
                "differentiation",
                "calculus"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 761
        },
        "renderpass": [
            {
                "code": "//dad: https://www.shadertoy.com/view/4dVGzw\n//but with swiveled parameters:\n//dad: has .xyz as Dfdx() Dfdx() Dfdz(), via automatic differentiation\n//THIS has .yzw as Dfdx() Dfdx() Dfdz(), via automatic differentiation\n\n//brother: https://www.shadertoy.com/view/XlV3Dy\n//brother: Has the goursat_surface, C0-discontinuous isosurface example\n//THIS has derivative arithmetic fields of hg_sdf:\n//  mercury.sexy/hg_sdf/\n//But where a hg_sdf_function returns the distance to point [p].\n//THIS returns distance to point [p] as .x \n//...and N_first_derivatives along N_domains as .yzw, .yz or .y\n//...for point [p]\n\n//sister: https://www.shadertoy.com/view/MsXBRB\n//focuses on simpler implicit surfaces and .got pretty much absorbed into THIS. \n//As this is a process of understanding may things overlapping into one \"venn-kitchen\"\n//and any constrains to simplify to a special case are welcome to ease_in.\n\n\n//#define SuperPrim\n//optionally show superprim \n//== https://www.shadertoy.com/results?query=superprim\n\n#define IterRm 64\n//max raymarch iterations|steps\n\n#define IterSh 16\n//softshadow iterations\n\n#define ReciprocalAbsLipschitz .99\n//if(lipschitzConstant>1., distance is overestimated.\n//multiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n\n//Automatic differentiation is worth it;\n//-for more precise surface normals and curvature. (perfect corners)\n//-for more precise anti-alasing\n//-for faster better gradient|contour calculation. (2d ovals. metaballs)\n//-for https://en.wikipedia.org/wiki/Contour_integration\n//-for Fluid dynamics, pressure waves (With a buffer over time)\n//-for EM-fields: https://en.wikipedia.org/wiki/Surface_integral\n//- - - for all that is in the todo list, at the bottom of this file\n//\n//The \"art\" here is, defining an implicit isosurface\n//  https://en.wikipedia.org/wiki/Implicit_surface\n//  https://en.wikipedia.org/wiki/Isosurface\n//...as a(n extended) distance_field equivalent with Arithmetic that\n//...automatically calculate its first derivatives for any point.\n//An overview of that is best explained in\n//  https://www.youtube.com/watch?v=qb40J4N1fa4\n//That way you get all the Contour lines, gradients, normals...\n//  https://en.wikipedia.org/wiki/Contour_line\n//  https://en.wikipedia.org/wiki/Gradient\n//  https://en.wikipedia.org/wiki/Surface_normal\n//...along all the domains (dimensions) of a surface\n//  https://en.wikipedia.org/wiki/Surface_%28topology%29\n//...very cheaply, because the surface normal (contour)\n//...is the cross()_product of the surfaces first derivatives.\n//\n// The above \"art\" requires a[Derivative Arithmetic] set \n// for [Automatic Differentiation].\n// Derivative arithmetic [DA] is great for\n// https://en.wikipedia.org/wiki/Smoothness\n// ... of shapes that lack C0-continuity but have C1-continuity.\n// based on    : https://www.shadertoy.com/view/4dVGzw\n// inspired by : https://www.shadertoy.com/view/Mdl3Ws \n//explained at : http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n//wiki         : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n//summary:     : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n//\n//My [DA] uses a simple namespace:\n//All common arithmetic namespaces get a \"*d\" suffix added.\n//That \"*d\" means \"also calculate first derivatives \n//... for all the domains\".\n//That also increases type float to vec4, and vec3 to \"mat4\" for inOut.\n\n\n//Using f'(x)= f(d)/dx notation for derivates:\n//https://en.wikipedia.org/wiki/Derivative#Notation\n//\n//this defines common operations but on a (pseudo) dual number (i,j), defined as:\n//[i] stays \"underived\"\n//[j] has one fimension FOR EACH domain. <-> \"pseudo\" dual\n//[j] calculates the gradient as byproduct, according to the\n//  https://en.wikipedia.org/wiki/Chain_rule\n//[j] is always precise and this way usually calculates faster than using central differences,\n//mostly because a lot of operations have a lot of values cancel each other out, allowing \"shortcuts\".\n//especially canceling out a lot of domainVectors at once, which is nice for vectorHardware.\n//\n//Because graphic cards are good with domain operators on vectors.\n//...we define dual number (where one part calculates \n//...with derivative of the other part and itself)\n//...as type vec4(float,vec3)\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct DAVec3{}] and [da_domain(vec3 p)]:\n//...are resolved with [struct DAVec2{}] and [da_domain(vec2 p)]:\n#define m4 mat4\n#define m3 mat3\n#define m2 mat2\n#define v4 vec4\n#define v3 vec3\n#define v2 vec2\n#define v1 float\n\n#define sat(a) clamp(a,0.,1.)\n\nstruct DAVec3{v4 x;v4 y;v4 z;};//for 3 domains (density/distance field)\n//https://en.wikipedia.org/wiki/Isosurface\nDAVec3 da_domain(v3 p){return DAVec3(v4(p.x,1.,0.,0.),\n                                     v4(p.y,0.,1.,0.),\n                                     v4(p.z,0.,0.,1.));}\nstruct DAVec2{v3 x;v3 y;};//for 2 domains (heightmap, isoline, contour)\n//https://en.wikipedia.org/wiki/Contour_line\nDAVec2 da_domain(v2 p){return DAVec2(v3(p.x,1.,0.),\n                                     v3(p.y,0.,1.));}\nstruct DAVec1{v2 x;};//for 1 domain (linear equation)\nDAVec1 da_domain(v1 p){return DAVec1(v2(p,1.));}\n//I will likely replace these with mat4, mat3 mat2.\n//Not sure yet, but it would make things simpler.\n\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n#define pow2d(a) v2(a*a,2.*a)\n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\nv2 absd(v2 a){return v2(abs(a.x),a.y  *sign(a.x));}\nv3 absd(v3 a){return v3(abs(a.x),a.yz *sign(a.x));}\nv4 absd(v4 a){return v4(abs(a.x),a.yzw*sign(a.x));}\nv2 sind(v2 a){return v2(sin(a.x),cos(a.x)*a.y);}\nv3 sind(v3 a){return v3(sin(a.x),cos(a.x)*a.yz);}\nv4 sind(v4 a){return v4(sin(a.x),cos(a.x)*a.yzw);}\nv2 cosd(v2 a){return v2(cos(a.x),sin(a.x)*-a.y);}\nv3 cosd(v3 a){return v3(cos(a.x),sin(a.x)*-a.yz);}\nv4 cosd(v4 a){return v4(cos(a.x),sin(a.x)*-a.yzw);}\nv2 logd(v2 a){return v2(log(a.x),a.y/a.x);}\nv3 logd(v3 a){return v3(log(a.x),a.yz/a.x);}\nv4 logd(v4 a){return v4(log(a.x),a.yzw/a.x);}\nv2 expd(v2 a){v1 x=exp(a.x);return v2(x,x*a.y);}\nv3 expd(v3 a){v1 x=exp(a.x);return v3(x,x*a.yz);}\nv4 expd(v4 a){v1 x=exp(a.x);return v4(x,x*a.yzw);}\n//sqrt() and divisions require a worksave reciprocal operator:\nv1 rec(float a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n//single parameter operations are MUCH simpler here:\nv2 sqrtd(v2 a){v1 q=sqrt(a.x);return v2(q,.5*rec(q)*a.y);}\nv3 sqrtd(v3 a){v1 q=sqrt(a.x);return v3(q,.5*rec(q)*a.yz);}\nv4 sqrtd(v4 a){v1 q=sqrt(a.x);return v4(q,.5*rec(q)*a.yzw);}\n//        pow (x,y) exp (     log (x)*y )//wait till we define muld()\n//#define powd(x,y) expd(muld(logd(x),x))//wait till we define muld()\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//for a 3d min(), a float parameter becomes vec4(a,0,0,0)\n//...because only .x determines breanching of min()\n//There are exponential many permutations of min()\n#define cond4(a) v4(a,0,0,0)\n#define cond3(a) v3(a,0,0)\n#define cond2(a) v2(a,0)\n#define min1 {return mix(b,a,step(a.x,b.x));}\n#define min3 {return mind(b,a);}\nv4 mind(v4 a,v4 b)min1\nv4 mind(v3 a,v4 b){return mind(v4(a,0),b);}\nv4 mind(v2 a,v4 b){return mix(v4(a,0,0),b,step(b.x,a.x));}\nv4 mind(v1 a,v4 b){return mix(cond4(a) ,b,step(b.x,a));}\nv4 mind(v4 a,v3 b){return mix(v4(b,0)  ,a,step(a.x,b.x));}\nv4 mind(v4 a,v2 b){return mix(v4(b,0,0),a,step(a.x,b.x));}\nv4 mind(v4 a,v1 b){return mix(cond4(b) ,a,step(a.x,b));}\nv3 mind(v3 a,v3 b)min1\nv3 mind(v2 a,v3 b){return mind(v3(a,0),b);}\nv3 mind(v1 a,v3 b){return mind(v2(a,0),b);}\nv3 mind(v3 a,v2 b)min3\nv3 mind(v3 a,v1 b)min3\nv2 mind(v2 a,v2 b)min1\nv2 mind(v1 a,v2 b){return mind(v2(a,0),b);}\nv2 mind(v2 a,v1 b)min3\nv1 mind(v1 a,v1 b){return min(a,b);}\n//negation identity: max(a,b)=-min(-a,-b)\n#define maxd(a,b) -mind(-a,-b)\n//3-domain matrix tripples:\nm4 maxdm(m4 a,v3 p){return m4(maxd(a[0],p.x),\n                              maxd(a[1],p.y),\n                              maxd(a[2],p.z),0,0,0,0);}\nm4 maxdm(m4 a,v1 p){return maxdm(a,v3(p));}\nm4 mindm(m4 a,v3 p){return m4(mind(a[0],p.x),\n                              mind(a[1],p.y),\n                              mind(a[2],p.z),0,0,0,0);}\nm4 mindm(m4 a,v1 p){return mindm(a,v3(p));}\nv4 maxdm(v4 a,v4 b,v4 c){return maxd(maxd(a,b),c);}\nv4 maxdm(m4 a){return maxdm(a[0],a[1],a[2]);}\n//v4 modd(v4 a,v4 b){return v4(mod(a.x,b.x),mod(a.yzw,1.));}\n//v4 modd(v4 a,v1 b){return v4(mod(a.x,b  ),mod(a.yzw,1.));}\n//v4 modd(v1 a,v4 b){return v4(mod(a  ,b.x),0,0,0        );}\n#define mab mod(a.x,b.x)\n#define may mod(a.yzw,1.));}\nv2 modd(v2 a,v2 b){return v2(mod(a.x,b.x),mod(a.y,1.));}\nv4 modd(v4 a,v1 b){return v4(mod(a.x,b),may\nv3 modd(v3 a,v1 b){return v3(mod(a.x,b),mod(a.yz,1.));}\nv2 modd(v2 a,v1 b){return v2(mod(a.x,b),mod(a,1.));}\nv4 modd(v4 a,v2 b){return v4(mab,may\nv4 modd(v4 a,v3 b){return v4(mab,may\nv3 modd(v3 a,v2 b){return v3(mab,mod(a.yz,1.));}\nv4 modd(v2 a,v4 b){return v4(mab,0,0,0);}\nv4 modd(v3 a,v4 b){return v4(mab,0,0,0);}\nv4 modd(v1 a,v4 b){return v4(mod(a,b.x),0,0,0);}\nv3 modd(v1 a,v3 b){return v3(mod(a,b.x),0,0  );}\nv2 modd(v1 a,v2 b){return v2(mod(a,b.x),0    );}\n\n/*\nv4 subd(v4 a,v4 b){return a-b;}\nv4 subd(v4 a,v1 b){return v4(a.x-b  , a.yzw);}\nv4 subd(v1 a,v4 b){return v4(a  -b.x,-b.yzw);}\nv4 addd(v4 a,v4 b){return a+b;}\nv4 addd(v4 a,v1 b){return subd(a,-b);}//addition as invrse substraction\nv4 addd(v1 a,v4 b){return subd(a,-b);}\n*/\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\nv4 subd(v4 a,v4 b){return a-b;}//3d translation\nv3 subd(v3 a,v3 b){return a-b;}//2d translation\nv2 subd(v2 a,v2 b){return a-b;}//1d translation\nv4 subd(v4 a,v1 b){return v4(a.x-b  ,a.yzw);}\nv4 subd(v4 a,v2 b){return v4(a.x-b.x,a.yzw);}\nv4 subd(v4 a,v3 b){return v4(a.x-b.x,a.yzw);}\nv3 subd(v3 a,v1 b){return v3(a.x-b  ,a.yz);}\nv3 subd(v3 a,v2 b){return v3(a.x-b.x,a.yz);}\nv2 subd(v2 a,v1 b){return v2(a.x-b  ,a.y);}\nv4 subd(v1 a,v4 b){return v4(a  -b.x,-b.yzw);}\nv4 subd(v2 a,v4 b){return v4(a.x-b.x,-b.yzw);}\nv4 subd(v3 a,v4 b){return v4(a.x-b.x,-b.yzw);}\nv3 subd(v1 a,v3 b){return v3(a  -b.x,-b.yz);}\nv3 subd(v2 a,v3 b){return v3(a.x-b.x,-b.yz);}\nv2 subd(v1 a,v2 b){return v2(a  -b.x,-b.y);}\n//glide-translations along multiple domains:\nDAVec3 subd(DAVec3 p,v3 s){return DAVec3(subd(p.x,s.x),\n                                         subd(p.y,s.y),\n                                         subd(p.z,s.z));}\nDAVec2 subd(DAVec2 p,v2 s){return DAVec2(subd(p.x,s.x),\n                                         subd(p.y,s.y));}\nDAVec1 subd(DAVec1 p,v1 s){return DAVec1(subd(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first derivatives.\nv4 subdabsd(v4 p,float s){return subd(absd(p),s);}\nv3 subdabsd(v3 p,float s){return subd(absd(p),s);}\nv2 subdabsd(v2 p,float s){return subd(absd(p),s);}\nm4 subdabsd(DAVec3 p,v3 s){return m4(subdabsd(p.x,s.x),\n                                     subdabsd(p.y,s.y),\n                                     subdabsd(p.z,s.z),0,0,0,0);}\nm3 subdabsd(DAVec2 p,v2 s){return m3(subdabsd(p.x,s.x),\n                                     subdabsd(p.y,s.y),0,0,0);}\nm2 subdabsd(DAVec1 p,v2 s){return m2(subdabsd(p.x,s.x),0,0);}\n//addition is negated substraction.\n#define addd(a,b) subd(a,-b)\n#define adddabsd(a,b) subdabsd(a,-b)\n/*\nv4 muld(v4 a,v4 b){return v4(a.x*b.x,a.yzw*b.w+a.x*b.yzw);}\nv4 muld(v4 a,v1 b){return a*b;}\nv4 muld(v1 a,v4 b){return a*b;}\nv4 divd(v4 a,v4 b){return v4(a.x/b.x,(a.yzw*b.x-a.x*b.yzw)/(b.x*b.x));}\nv4 divd(v4 a,v1 b){return a/b;}\nv4 divd(v1 a,v4 b){return v4(a/b.x,(-a*b.yzw)/(b.x*b.x));} \n*/\n//multiplication applies the product rule (within chain rule)\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb b){return a*b;}\nv4 muld(v4 a,v1 atb\nv4 muld(v1 a,v4 atb\nv3 muld(v3 a,v1 atb\nv3 muld(v1 a,v3 atb\nv2 muld(v2 a,v1 atb\nv2 muld(v1 a,v2 atb //scalar multiplication is tautological product_rule.\nv4 muld(v4 a,v4 b){return v4(a.x*b.x,a.yzw*b.x+a.x*b.yzw);}\nv3 muld(v3 a,v3 b){return v3(a.x*b.x,a.yz *b.x+a.x*b.yz );}\nv2 muld(v2 a,v2 b){return v2(a.x*b.x,a.y  *b.x+a.x*b.y  );}\nv3 muld(v2 a,v3 b){return v3(a.x*b.x,a.yy *b.x+a.x*b.yz );}\nv3 muld(v3 a,v2 b){return v3(a.x*b.x,a.yz *b.x+a.x*b.yy );}\nv4 muld(v4 a,v3 b){return v4(a.x*b.x,a.yzw*b.x+a.x*b.yzz);}//nonsense?\nv4 muld(v4 a,v2 b){return v4(a.x*b.x,a.yzw*b.x+a.x*b.yyy);}\nv4 muld(v3 a,v4 b){return v4(a.x*b.x,a.yzz*b.x+a.x*b.yzw);}//nonsense?\nv4 muld(v2 a,v4 b){return v4(a.x*b.x,a.yyy*b.x+a.x*b.yzw);}\nDAVec3 muld(DAVec3 p,v3 s){return DAVec3(muld(p.x,s.x),\n                                         muld(p.y,s.y),\n                                         muld(p.z,s.z));}\nDAVec2 muld(DAVec2 p,v2 s){return DAVec2(muld(p.x,s.x),\n                                         muld(p.y,s.y));}\nDAVec1 muld(DAVec1 p,v1 s){return DAVec1(muld(p.x,s));}\n//reciprocal derivatives are most confusing.\nv4 divd(v4 a,v1 b){return a/b;}\nv3 divd(v3 a,v1 b){return a/b;}\nv2 divd(v2 a,v1 b){return a/b;}//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.x*b.x));}\nv4 divd(v1 a,v4 b){return v4(a  /b.x,(-a  *b.yzw)bxx\nv4 divd(v2 a,v4 b){return v4(a.x/b.x,(-a.x*b.yzw)bxx\nv4 divd(v3 a,v4 b){return v4(a.x/b.x,(-a.x*b.yzw)bxx\nv4 divd(v4 a,v4 b){return v4(a.x/b.x,(a.yzw*b.x-a.x*b.yzw)bxx\nv4 divd(v4 a,v3 b){return v4(a.x/b.x,(a.yzw*b.x-a.x*b.yzz)bxx//nonsense?\nv4 divd(v4 a,v2 b){return v4(a.x/b.x,(a.yzw*b.x-a.x*b.yyy)bxx//nonsense?\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define powd(x,y) expd(muld(logd(x),x))\n\n//It gets trickier with functions that take 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives.\nv2 lengthd(v2 x,v2 y){v1 q=length(v2(x.x,y.x));\n return v2(q,(x.y*x.x+y.y*y.x)*rec(q));}\nv3 lengthd(v3 x,v3 y){v1 q=length(v2(x.x,y.x));\n return v3((x.yz*x.x+y.yz*y.x)*rec(q),q);}\nv4 lengthd(v4 x,v4 y){v1 q=length(v2(x.x,y.x));\n return v4(q,(x.yzw*x.x+y.yzw*y.x)*rec(q));}\nv4 lengthd2(m4 u){return lengthd(u[0],u[1]);}//2*3domain\n//above is planar length 2 inpout parameters. below is 3d length.\nv4 lengthd(v4 x,v4 y,v4 z){float q=length(v3(x.x,y.x,z.x));\n return v4(q,(x.yzw*x.x+y.yzw*y.x+z.yzw*z.x)*rec(q));}\nv4 lengthd(m4 u){return lengthd(u[0],u[1],u[2]);}//3*3domain\n//the utility of a length() function is clear.\n\n//some operations cancel out a bit more, \n//...to (nearly, or even more) tautological|identical identities:\n//<- wooha, a recursive meta-entendre-tautology!\n//vec4 da_fract(i4 a){return a;}//derivative of fract(a)=a => tautological.\n//this whole section is likely erroneous, i am missing something?\nv4 floord4(v4 a){return cond4(a.x);}\nv4 floord4(v3 a){return cond4(a.x);}\nv4 floord4(v2 a){return cond4(a.x);}\nv4 floord4(v1 a){return cond4(a);}\nv3 floord3(v3 a){return cond3(a.x);}\nv3 floord3(v2 a){return cond3(a.x);}\nv3 floord3(v1 a){return cond3(a);}\nv2 floord2(v2 a){return cond2(a.x);}\nv2 floord2(v1 a){return cond2(a);}\n#define fractd4(a) subd(a,floord4(a))\n#define fractd3(a) subd(a,floord3(a))\n#define fractd2(a) subd(a,floord2(a))\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should do:\nv4 dotd(DAVec3 a, DAVec3 b){ \n v4 t0=muld(a.x,b.x),t1=muld(a.y,b.y),t2=muld(a.z,b.z); \n return addd(addd(t0,t1),t2);}\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n\n//Below are translations of the hg_sdf library\n//...to use the above Derivative Arithmetic\n//...serving as examples. on how to translate between 2 arithmetics.\n\n//return distance to unit sphere\nv4 fSphere(DAVec3 p){v4 q=lengthd(p.x,p.y,p.z);return subd(q,1.);;}\n//return distance to infinite line segment\nv4 fRay(DAVec3 p){p.x.w=mix(0.,p.x.w,step(p.x.w,0.));\n v4 q=lengthd(p.x,p.y,p.z);return subd(q,1.);}\n//fRay() was an error that I chose to keep.\n\n//return distance to box size (s),\n//... corners extrude, keeping all agngles, underestimating distances.\nfloat fBoxCheap(v3 p,v3 b){\n v3 q=abs(p);q=q-p;//mirror clamp\n return max(max(q.x,q.y),q.z);}\nvec4 fBoxCheap(DAVec3 p,v3 s){\n m4 u=subdabsd(p,s);//mirror clamp\n return maxdm(u);}\n                             \n//return distance to box size (s), corners extrude to rounded spheres.\nfloat fBox(vec3 p,vec3 s){\n v3 d=abs(p)-s;//mirror clamp\n v1 a=length(max(d,0.));//rounded corners\n v3 q=min(d,0.);//clamp\n v1 b=max(max(q.x,q.y),q.z);//keep largest of 3\n return a+b;}//add //hg_sdf\nvec4 fBox(DAVec3 p,vec3 s){//v3 s=v3(1.5,.5,1.5);\n m4 d=subdabsd(p,s);//mirror clamp\n v4 a=lengthd(maxdm(d,0.));//rounded corners\n m4 q=mindm(d,0.);//clamp\n v4 b=maxdm(q);//keep largest of 3\n return addd(a,b);}//add\n             \n//a more readable version of a very parametric implicit surface.\n//one operation per line keeps it BASIC and modifiable.\nvec4 sdSuperprim(DAVec3 p, v4 s,vec2 r) {\n //vec2 r=vec2(.2,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n vec4 dx,dy,dz,d,e,f,q,a,b,c;\n dx=vec4(0);dy=vec4(0);dz=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n dx=absd(p.x);\n dx=subd(dx,s.x);\n dy=absd(p.y);\n dy=subd(dy,s.y);\n dz=absd(p.z);\n dz=subd(dz,s.z);\n \n d=addd(dx,r.x);\n d=maxd(d,0.);\n e=addd(dy,r.x);\n e=maxd(e,0.);\n q=lengthd(d,e);\n f=maxd(dx,dy);\n f=mind(-r.x,f);\n \n q=addd(q,f);\n q=addd(q,s.w);\n q=absd(q);\n q=subd(q,s.w);\n ///return...\n a=addd(q ,r.y);\n a=maxd(a,0.);    \n b=addd(dz,r.y);\n b=maxd(b,0.);\n a=lengthd(a,b);\n c=mind(-r.y,maxd(q,dz));\n c=addd(a,c);\n return c;\n}\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s,out vec2 r) {\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n}}//  https://www.shadertoy.com/results?query=superprim\n                             \n                             \nfloat fOpUnionRound(float a,float b,float r){\n vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nvec4 fOpUnionRound(vec4 a, vec4 b,float r){\n vec4 x=subd(r,a);x=maxd(x,0.);\n vec4 y=subd(r,b);y=maxd(y,0.);x=lengthd(x,y);\n vec4 m=mind(a,b);m=maxd(r,m);return subd(m,x);}\n//does not seem to have good lipschitz.\nfloat fOpIntersectionRound(float a,float b,float r){\n  vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nvec4 fOpIntersectionRound(vec4 a, vec4 b,float r){\n vec4 x=addd(r,a);x=maxd(x,0.);\n vec4 y=addd(r,b);y=maxd(y,0.);x=lengthd(x,y);\n vec4 m=maxd(a,b);m=mind(-r,m);return addd(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,-b,r)\n\n\nfloat pMod1(inout float p,float s){p/=s;\n float c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\nv4 pMod1(vec4 p,float s){p=divd(p,s);\n //vec4 c=floord4(p);//c=subd(c,.5);//float c=floor((p)+.5);\n p=addd(p,.5);p=fractd4(p);p=subd(p,.5);p=muld(p,s);//p=(fract(p+.5)-.5)*s;\n return p;}\n                             \nvec2 pR45(vec2 p){return (p+vec2(p.y,-p.x))*sqrt(.5);}\nmat4 pR45(mat4 p){float s=sqrt(.5);\n p[0]=addd(p[1],p[0]);p[0]=muld(p[0],s);\n p[1]=subd(p[1],p[0]);p[1]=muld(p[0],s);return p;}\n                             \n//commented out, because it apperrs broken:\n//my fract() <- mod() is likely nonsense!\n//float fOpDifferenceColumns _M(-1.)\n//                             p.y+=c;p.x-=0.70710678118*(r+c);if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return-min(min(max(-length(p)+c,p.x),a),b);}\n//#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\n/*\n//unknown error\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\nv4 fOpUnionColumns(v4 a, v4 b, float r, float n) {\n if(a.x<r&&b.x<r){\n  mat4 p=mat4(a,b,0,0,0,0,0,0,0,0);\n  float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n  p=pR45(p);\n  p[0]=subd(p[0],sqrt(2.)/2.*r);\n  p[0]=addd(p[0],columnradius*sqrt(2.));\n  if (mod(n,2.) == 1.) {\n   p[1]=addd(p[1],columnradius);\n  }\n  p[1]=pMod1(p[1],columnradius*2.);\n  vec4 r=lengthd(p[0],p[1]);\n  r=subd(r,columnradius);\n  r=mind(r,p[0]);\n  r=mind(r,a);\n  r=mind(r,b);\n  return r;\n }\n return mind(a,b);\n}\n*/\n                             \n                             /*\n//also fails\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n    float s=r/n;\n\tb=b-r;\n    float d=b-a+s;\n    d=mod(d,2.*s);\n    d=d-s;\n    d=abs(d);\n    d=b+a+d;\n    d=d*.5;     \n\treturn min(min(a,b),d);\n}\nv4 fOpUnionStairs(v4 a, v4 b, float r, float n) {\n    float s=r/n;\n\tb=subd(b,r);\n    a=subd(b,a);\n    a=addd(a,s);//float d=b-a+s;\n    vec4 d=modd(a,2.*s);//d=mod(d,2.*s);\n    d=subd(d,s);\n    d=absd(d);\n    d=addd(a,d);\n    d=addd(b,d);\n    d=muld(d,.5);  \n    d=mind(d,a);\n    d=mind(d,b);\n    return d;\n\treturn min(min(a,b),d);\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n*/\n\n//demo playground for boolean unions of implicit surfaces.\nvec4 aBool(DAVec3 p){\n vec4 box=fBox(p,vec3(1));\n p=subd(p,vec3(-1,1,1));//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n vec4 box2=fBox(p,vec3(1));\n //return mind(box,box2);//(box or     box2)\n //return maxd(box,box2);//(box and     box2)\n //return maxd(box,-box2);//(box and not box2)\n //return fOpUnionRound(box,box2,1.);\n //return fOpIntersectionRound(box,box2,.3);\n return fOpDifferenceRound(box,box2,.5);\n}\n\n//set camera position & target\nvoid setCam(out vec3 o,out vec3 i,v1 t,v1 m){\n o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\nstruct DAMValue{vec4 d;float m;};\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.x>b.d.x)return b;return a;}\nDAMValue plane(DAVec3 p){return DAMValue(addd(p.y,1.),1.);}\n//DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n//return distance to surface of DistanceField\nDAMValue df(DAVec3 p){vec4 r;\n#ifndef SuperPrim\n //simpler more static parametric surfaces:\n r=aBool(p);\n //r=fSphere(p);\n //r=fBox(p,vec3(1));\n //r=fBoxCheap(p,vec3(1));\n float holesize=mix(.6,5.,sin(iTime*3.)*.5+.5);\n vec4 s=fSphere(muld(p,vec3(holesize)));r=maxd(r,-s);\n //scaling by holesize is bad for lipschitz constant.\n#else\n //superprim() is a very parametric implicit surface.\n float t=iTime,u=ss01(ss01(fract(t)));\n vec4 a,b;vec2 c,d;\n getfactor(imsc(t   ),a,c);\n getfactor(imsc(t+1.),b,d);\n DAVec3 q=DAVec3(p.y,p.z,p.x);\n if(iMouse.z>.5){\n  vec2 m=iMouse.xy/iResolution.xy;\n  r=sdSuperprim(q,vec4(vec3(1.0),mix(a.x,b.x,u)),m);\n }else\n  r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n#endif\n //return DAMValue(r,0.);\n return min2(plane(p),DAMValue(r,0.));}\n\n//return distance & materialID\nvec2 dm(v3 p){DAMValue d=df(da_domain(p));return vec2(d.d.x,d.m);}\n//return material at p with normal n\nvec4 material(v3 p,v3 n ){vec4 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n return mix(vec4(n*.5+.5,.1)\n           ,vec4(d.yzw*.5 +.5,.0)*abs(mod(d.x,.1)/.1-.5)\n           ,sat(dm(p).y));}\n\n//return soft shadow of light source at [o], \n//... with light direction [i] pointing from [o] to surface point [p]\nfloat shadow(v3 o,v3 i){\n const float a=32.;//shadow hardnes\n float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n for(int j=0;j<IterSh;j++){\n  h=dm(o+i*t).x;\n  r=min(r,h*a/t);\n  t+=clamp(h,.02,2.);}//limit max and min stepping distances\n return clamp(r,0.,1.);}\n//  iquilezles.org/articles/rmshadows\n\n//return p, modified by light , shadow, envMap...\nvec3 light(v3 p,v3 n,v3 i,v1 d,v4 m){\n vec3 l=normalize(vec3(1.,.7,.9));//light direction\n float o=max(0.,dot(n,l)),\n c=max(0.,dot(n,normalize(l-i))),\n s;if(c>.01)s=shadow(p+.01*n,l); \n const vec3 LigCol=vec3(1.);//light color\n vec3 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n r+=s*c*pow(o,40.);//specular\n //r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n r*=exp(-.01*d*d);//fog  \n return r;}\n\n//return distance along ray (raymarch till surface)\nfloat rm(v3 o,v3 i){\n const float m=20.;//distance.Max\n float e=.0,h=e,t=0.;//intersection.precission\n for(int j=0;j<IterRm;j++){\n  if(h<e)break;if(t>m)return -1.;\n          //wait a moment, do i not have the lipschitz for the point\n     //or at least 3 for 3 domains of the point\n     //by using [DA]?\n     //i mean, i could really insert this here, right?\n     //and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  //i am pretty sure that i am missing a dotproduct here\n  //the gradient must be dorproducted onto the ray direction?\n  DAMValue s=df(da_domain(o+i*t));\n  float r=ReciprocalAbsLipschitz;\n  //r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n     //its not a good estimate, but it is a LOT better?\n     //nah it totally fails for concave isosurfaces.\n  h=s.d.x*r;t+=h;}return t;}\n\n//return surface normal\nvec3 getN(in vec3 p){DAMValue d=df(da_domain(p));return d.d.yzw;}\n//.yzw store the first derivatives on the 3 domains, \n//this is equivalent to the gradient at p.\n//If (p is near a surface) the gradient is a surface normal\n//d.d.* addresses a vec4. where *.yzw==gradient\n//d.m.* addresses a material\n             \n//return camera matrix\nmat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n return mat3(u,normalize(cross(u,w)),w);}\n\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\nvoid mainImage( out vec4 r,in vec2 fragCoord ){\n vec2 p=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y,\n m=iMouse.xy/iResolution.xy;  //mouse\n vec3 o,i;\n setCam(o,i,iTime,m.y+.2);//camMovement\n const float roll=0.,lens=2.;//camRoll,CamLensLength\n vec3 d=normalize(calcLookAtMatrix(o,i,roll)*vec3(p.xy,lens));//ray.direction\n vec3 c=vec3(0);\n float t=rm(o,d);//Distance.raymarched\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n r=vec4(c,1.);}\n                             \n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//\n//todo, curvature stuff, because I want a minimal surface !\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}