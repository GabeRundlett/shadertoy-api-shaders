{
    "Shader": {
        "info": {
            "date": "1715717546",
            "description": "Effects of using separate filters for color and alpha channels.\n\nMouse click selects color (vertical) and alpha (horizontal) filters.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ftXD7",
            "likes": 1,
            "name": "Separate color/alpha filters",
            "published": 3,
            "tags": [
                "filter",
                "blending",
                "alpha"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 103
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Demo of  effects of using separate filters for color and alpha channels.\n// Not optimized. May be slow.\n\n// Mouse y selects color filter (bottom-to-top):\n//     Nearest\n//     Linear\n//     Catmull-Rom\n//     B-spline\n// Mouse x does the same for alpha filter (left-to-right),\n// except each is further subdivided according to sharpening\n// applied:\n//     Linear\n//     Smoothstep\n//     Quintic smoothstep\n//     Smoothstep, twice\n\nvec3 linear2srgb(vec3 rgb)\n{\n    return mix(12.92*rgb,1.055*pow(rgb,vec3(1.0/2.4))-0.055,step(0.0031308,rgb));\n}\n\nvec3 srgb2linear(vec3 rgb)\n{\n    return mix(rgb/12.92,pow((rgb+0.055)/1.055,vec3(2.4)),step(0.04045,rgb));\n}\n\nvec4 texel(vec2 r)\n{\n    // Crop to sprite size.\n    r=clamp(r,vec2(0),vec2(40,32));\n    // Snap to texel center.\n    vec2 uv=floor(r+0.5)+0.5;\n    // Animation.\n    uv.x+=40.0*floor(8.0*iTime);\n    uv=mod(uv,vec2(240,32));\n    // Load texel.\n    vec4 ret=texture(iChannel0,uv/vec2(textureSize(iChannel0,0)));\n    // Decode sRGB, which Shadertoy doesn't\n    // seem to do automatically.\n    ret.xyz=srgb2linear(ret.xyz);\n    // Convert to premultiplied alpha,\n    // which original texture is not.\n    ret.xyz*=ret.w;\n    return ret;\n}\n\nfloat mitchell_netravali_kernel(float B,float C,float t)\n{\n    t=abs(t);\n    if(t<1.0) return ((6.0-2.0*B)+t*t*((-18.0+12.0*B+6.0*C)+t*(12.0-9.0*B-6.0*C)))/6.0;\n    if(t<2.0) return ((8.0*B+24.0*C)+t*((-12.0*B-48.0*C)+t*((6.0*B+30.0*C)+t*(-B-6.0*C))))/6.0;\n    return 0.0;\n}\n\nvec4 mitchell_netravali_weights(float B,float C,float x)\n{\n    return vec4(\n        mitchell_netravali_kernel(B,C,1.0+x),\n        mitchell_netravali_kernel(B,C,0.0+x),\n        mitchell_netravali_kernel(B,C,1.0-x),\n        mitchell_netravali_kernel(B,C,2.0-x));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float S=8.0; // Scale.\n    vec3 col=0.5+0.5*cos(iTime+1e-2*fragCoord.xyx+vec3(0,2,4));\n    vec2 g=vec2(16,4)*(fragCoord/iResolution.xy);\n    vec2 m=vec2(16,4)*(iMouse.xy/iResolution.xy);\n    if(floor(g.x)==floor(m.x)) col*=2.0;\n    if(floor(g.y)==floor(m.y)) col*=2.0;\n    const float pi=3.14159265358979;\n    col*=1.0-smoothstep(4.0*fwidth(g.x),0.0,abs(sin(pi*g.x)));\n    col*=1.0-smoothstep(2.0*fwidth(g.x),0.0,abs(sin(0.25*pi*g.x)));\n    col*=1.0-smoothstep(4.0*fwidth(g.y),0.0,abs(sin(pi*g.y)));\n    col*=1.0-smoothstep(4.0*fwidth(g.y),0.0,abs(sin(pi*g.y)));\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/S+vec2(20,16);\n    uv-=0.5;\n    vec2 c=floor(uv);\n    vec4 Txx=texel(c+vec2(-1,-1));\n    vec4 Txy=texel(c+vec2(-1,-0));\n    vec4 Txz=texel(c+vec2(-1,+1));\n    vec4 Txw=texel(c+vec2(-1,+2));\n    vec4 Tyx=texel(c+vec2(-0,-1));\n    vec4 Tyy=texel(c+vec2(-0,-0));\n    vec4 Tyz=texel(c+vec2(-0,+1));\n    vec4 Tyw=texel(c+vec2(-0,+2));\n    vec4 Tzx=texel(c+vec2(+1,-1));\n    vec4 Tzy=texel(c+vec2(+1,-0));\n    vec4 Tzz=texel(c+vec2(+1,+1));\n    vec4 Tzw=texel(c+vec2(+1,+2));\n    vec4 Twx=texel(c+vec2(+2,-1));\n    vec4 Twy=texel(c+vec2(+2,-0));\n    vec4 Twz=texel(c+vec2(+2,+1));\n    vec4 Tww=texel(c+vec2(+2,+2));\n    // B-spline.\n    vec4 Bx=mitchell_netravali_weights(1.0,0.0,(uv-c).x);\n    vec4 By=mitchell_netravali_weights(1.0,0.0,(uv-c).y);\n    // Catmull-Rom.\n    vec4 Cx=mitchell_netravali_weights(0.0,0.5,(uv-c).x);\n    vec4 Cy=mitchell_netravali_weights(0.0,0.5,(uv-c).y);\n    vec4 N=texel(uv);\n    vec4 L=mix(\n        mix(Tyy,Tyz,(uv-c).y),\n        mix(Tzy,Tzz,(uv-c).y),(uv-c).x);\n    vec4 B=\n        Bx.x*(By.x*Txx+By.y*Txy+By.z*Txz+By.w*Txw)+\n        Bx.y*(By.x*Tyx+By.y*Tyy+By.z*Tyz+By.w*Tyw)+\n        Bx.z*(By.x*Tzx+By.y*Tzy+By.z*Tzz+By.w*Tzw)+\n        Bx.w*(By.x*Twx+By.y*Twy+By.z*Twz+By.w*Tww);\n    vec4 C=\n        Cx.x*(Cy.x*Txx+Cy.y*Txy+Cy.z*Txz+Cy.w*Txw)+\n        Cx.y*(Cy.x*Tyx+Cy.y*Tyy+Cy.z*Tyz+Cy.w*Tyw)+\n        Cx.z*(Cy.x*Tzx+Cy.y*Tzy+Cy.z*Tzz+Cy.w*Tzw)+\n        Cx.w*(Cy.x*Twx+Cy.y*Twy+Cy.z*Twz+Cy.w*Tww);\n    vec4 T=N;\n    switch(int(m.y))\n    {\n        case 0: T=N; break;\n        case 1: T=L; break;\n        case 2: T=C; break;\n        case 3: T=B; break;\n    }\n    float A=N.w;\n    switch(int(m.x)>>2)\n    {\n        case 0: A=N.w; break;\n        case 1: A=L.w; break;\n        case 2: A=C.w; break;\n        case 3: A=B.w; break;\n    }\n    A=clamp(A,0.0,1.0);\n    switch(int(m.x)&3)\n    {\n        case 0: A=A; break;\n        case 1: A=smoothstep(0.0,1.0,A); break;\n        case 2: A=A*A*A*(A*(A*6.0-15.0)+10.0); break;\n        case 3: A=smoothstep(0.0,1.0,A);A=smoothstep(0.0,1.0,A); break;\n    }\n    T.xyz=max(T.xyz,vec3(0.0));\n#if 1\n    // Optional(?).\n    // Since we are using premultiplied alpha,\n    // we adjust color, once alpha is changed.\n    if(T.w!=0.0) T.xyz*=A/T.w;\n    else         T.xyz=vec3(0);\n#endif\n    T.w=A;\n    col=T.xyz+col*(1.0-T.w);\n    col=linear2srgb(col);\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}