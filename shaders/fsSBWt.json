{
    "Shader": {
        "info": {
            "date": "1657687861",
            "description": "System where particles repel each other and also a force pushes them toward the center of the screen, making a blobby thing.",
            "flags": 32,
            "hasliked": 0,
            "id": "fsSBWt",
            "likes": 47,
            "name": "A Blobby Mass",
            "published": 3,
            "tags": [
                "2d",
                "mouse",
                "particles",
                "blob",
                "soft"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 617
        },
        "renderpass": [
            {
                "code": "// Cole Peterson (Plento)\n\n\n/*\n    System where particles repel each other and also a force pushes them\n    toward the center of the screen, making a blobby thing.\n*/\n\n// A few drawing options\n#define DRAW_CLOUDS\n#define DRAW_PARTICLES\n#define DRAW_BORDER\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec3 col = vec3(0.);\n    \n    // Draw particles and cloudy smoothmin stuff\n    float md = 999.;\n    for(int i = 0; i < nParticles; i++){\n        float d = length(u - ch(iChannel0, vec2(i,0.)).xy);\n       \n        #ifdef DRAW_CLOUDS\n        md = smoothmin(md, d, 90.); \n        col += (ss(10.,1., md)) * (.5+.5*cos(vec3(3.0, 1.8, 0.4)*float(md)*.02));\n        #endif\n        \n        #ifdef DRAW_PARTICLES\n        col = mix(vec3(10), col, ss(.008*R.y,.008*R.y + 5., d));\n        #endif\n    }\n    \n    col /= float(nParticles);\n    col *= .6;\n    \n    // Blob border\n    #ifdef DRAW_BORDER\n    col = mix(vec3(.5), col, ss(R.y*.0003, R.y*.0003 + 0.3, abs(md*.1)));\n    #endif\n    \n    f = vec4(1.-exp(-col*col*5.), 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Buffer A: Track particles.\n\n// Apply force toward center of screen\nvec2 radialForce(vec2 pos){\n    vec2 v = R.xy*.5 - pos;\n    float d = (R.y*.5) - max(length(v), 4.);\n    return normalize(v)*(60. / (d*d));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    ivec2 iu = ivec2(u);\n    \n    // Only do this pixel if its for a particle\n    if(iu.x < nParticles || iu.y == 0){\n        // The particle info in this pixel\n        vec4 bA = ch(iChannel0, u);\n    \n        // Loop through all particles\n        for(int i = 0; i < nParticles; i++){\n            // Not looking at self\n            if( i != iu.x){\n                // Calculate repulsive force from each particle\n                vec2 p = ch(iChannel0, vec2(i,0.)).xy;\n                vec2 v = bA.xy - p;\n     \t\t\tfloat d = max(length(v), 10.0);\t   \n                \n                // Apply repulsive force\n                bA.zw += (150.0 / (d*d))*normalize(v)*dt;\n            }\n    \t}\n        \n        // Mouse\n        if(iMouse.z > 0.){\n            vec2 v = bA.xy - iMouse.xy;\n         \tfloat r = mForce / max(length(v), .001);\n            vec2 n = normalize(v);\n            bA.zw += r*n*dt;\n        }\n        \n        // Apply force from the edges of the bounds\n        bA.zw += dt*bForce*radialForce(bA.xy);\n        \n        // Update position and velocity\n        bA.xy += bA.zw*dt;\n        //bA.zw -= friction*bA.zw*dt*iTimeDelta;\n        bA.zw -= friction*bA.zw*dt;\n        // Limit max velocity\n        bA.zw = clamp(bA.zw, -maxVel, maxVel);\n        \n        // Init\n    \tif(iFrame < 5){\n            bA.xy = hash22(u)*R.xy * 0.5 + R.xy*0.25;\n            bA.zw = vec2(0);\n    \t}\n        \n        f = bA;\n    }\n    else return;\n   \n    \n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define ch(chan, p) texelFetch(chan, ivec2(p), 0)\n\n// Number of particles\nconst int nParticles = 200;\n\n// Sim speed\nfloat dt = .7;\n\n// Radial force (force pushing inward)\nconst float bForce = 320.;\n\n// Mouse force\nconst float mForce = 250.f;\n\n// Max velocity\nconst vec2 maxVel = vec2(8.);\n\n// Particle friction\nconst float friction = .0065;\n\n\n// Dave Hoshkin hash https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat smoothmin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}