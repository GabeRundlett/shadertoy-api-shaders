{
    "Shader": {
        "info": {
            "date": "1718834410",
            "description": "A Cornell box to test Monte Carlo-based path marching of an SDF-based scene with different material types. Also note the possibility to smoothly blend different materials, e.g., metal and glass as done for the object in the bottom-left.",
            "flags": 32,
            "hasliked": 0,
            "id": "M3dSz7",
            "likes": 15,
            "name": "Virnell Box",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "cornellbox",
                "materials",
                "glass",
                "montecarlo",
                "pathmarching",
                "roughness"
            ],
            "usePreview": 0,
            "username": "virmoesiae",
            "viewed": 219
        },
        "renderpass": [
            {
                "code": "// My first attempt at combining SDFs for describing a scene with stochastic\n// approaches for light transport as usually seen in ray-tracing shaders and\n// renderers in general. The main features are:\n// 1) Modelling of light reflection (both diffuse and specular) and transmission\n//    with refraction;\n// 2) Material properties are smoothly mixable, allowing to achieve e.g., a\n//    smooth transition from a metallic to a glassy material, as shown with the\n//    object in the bottom-left of the box;\n// 3) Material properties inclusive of surface roughness to model opaque\n//    metal and glass;\n// 4) Schlick approximation to model increase in reflectiveness of non-purely-\n//    specularly-reflective materials (my way of saying dielectrics, e.g., \n//    glass) at grazing view angles, although the effect is barely noticeable \n//    in this demo.\n\n// Check BufferA for controllable parameter shortcuts (via #define-s)\n\n//----------------------------------------------------------------------------//\n\nvec3 tonemapACES(vec3 v)\n{\n    v = vec3(\n        .59719f*v.x + .35458f*v.y + .04823f*v.z,\n        .07600f*v.x + .90834f*v.y + .01566f*v.z,\n        .02840f*v.x + .13383f*v.y + .83777f*v.z\n    );\n    v = (v*(v + .0245786f) - .000090537f)/\n        (v*(.983729f*v + .4329510f) + .238081f);\n    return vec3(\n        1.60475f*v.x + -.53108f*v.y + -.07367f*v.z,\n        -.10208f*v.x + 1.10813f*v.y + -.00605f*v.z,\n        -.00327f*v.x + -.07276f*v.y + 1.07602f*v.z\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    fragColor.rgb = tonemapACES(fragColor.rgb/fragColor.a);\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// My first attempt at combining SDFs for describing a scene with stochastic\n// approaches for light transport as usually seen in ray-tracing shaders and\n// renderers in general. The main features are:\n// 1) Modelling of light reflection (both diffuse and specular) and transmission\n//    with refraction;\n// 2) Material properties are smoothly mixable, allowing to achieve e.g., a\n//    smooth transition from a metallic to a glassy material, as shown with the\n//    object in the bottom-left of the box;\n// 3) Material properties inclusive of surface roughness to model opaque\n//    metal and glass;\n// 4) Schlick approximation to model increase in reflectiveness of non-purely-\n//    specularly-reflective materials (my way of saying dielectrics, e.g., \n//    glass) at grazing view angles, although the effect is barely noticeable \n//    in this demo.\n\n//----------------------------------------------------------------------------//\n\n// The box is a cube with sides of size 3, centered at vec3(0)\n#define CAMERA_POSITION vec3(0.,0.,-4.5)\n#define CAMERA_DIRECTION vec3(0.,0.,1.)\n\n// For convenience\n#define METAL_SPHERE_ROUGHNESS 0.00\n#define ICE_CUBE_ROUGHNESS 0.075\n#define WHITE_WALL_REFLECTANCE .025\n#define WHITE_WALL_ROUGHNESS .025\n\n// Naive implementation but works fine\n#define ANTI_ALIASING true\n\n// Number of rays propagated per pixel\n#define N_SAMPLES 1\n\n// Maximum number of bounces per ray\n#define N_BOUNCES 8\n\n// Increase to avoid visual artifacts if SDFs get excessively non-Euclidean\n#define SAFETY_FACTOR 2.\n\n// Max number of ray marching steps\n#define MAX_STEPS 250 \n\n// Minimum distance from any scene surface below which ray marching stops\n#define MIN_DIST 5e-4\n\n// Maximum distance from any scene surface beyond which ray marching stops\n#define MAX_DIST 100.\n\n// Useful quantities\n#define PI 3.14159\n#define PIBY2 1.57078\n#define PIBY4 0.785398\n#define UP vec3(0,1,0)\n#define RT vec3(-1,0,0)\n#define FW vec3(0,0,1)\n\n//----------------------------------------------------------------------------//\n// Misc\n\nvec3 rotate(vec3 v, float t, vec3 a)\n{\n    vec4 q = vec4(sin(t/2.0)*a.xyz, cos(t/2.0));\n    return v + 2.0*cross(q.xyz, cross(q.xyz, v) + q.w*v);\n}\n\n//----------------------------------------------------------------------------//\n// Pseudo-random stuff from https://www.shadertoy.com/view/Xt3cDn\n\nuint baseHash(uvec2 p) \n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat gSeed;\n\nfloat hash1()\n{\n    uint n = baseHash(floatBitsToUint(vec2(gSeed+=.1,gSeed+=.1)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash2() \n{\n    uint n = baseHash(floatBitsToUint(vec2(gSeed+=.1,gSeed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3() \n{\n    uint n = baseHash(floatBitsToUint(vec2(gSeed+=.1,gSeed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 randomUnitVector()\n{\n    vec3 h = hash3() * vec3(2.,6.283185,1.)-vec3(1,0,0);\n    return pow(h.z, 1./3.)*vec3(sqrt(1.-h.x*h.x)*vec2(sin(h.y),cos(h.y)),h.x);\n}\n\n//----------------------------------------------------------------------------//\n// Materials\n\nstruct Material\n{\n    vec3  color;\n    float emittance;\n    float diffusiveReflectance;\n    float specularReflectance;\n    float transmittance;\n    float roughness;\n    float refractiveIndex;\n};\n\n// Material of the final 'hit' point\nMaterial gSceneMaterial;\n\n// Refractive index of the 'void' material encompassing all regions where the\n// scene SDF is positive\nfloat gVoidRefractiveIndex = 1.0;\n\n// Refractive index of the material that contains the current 'hit' point\nfloat gSceneRefractiveIndex = 1.0;\n\n#define MATERIAL_LIGHT_SOURCE(color, emittance) Material(color, emittance, 1.,0.,0.,0.,0.)\n#define MATERIAL_LAMBERTIAN(color) Material(color, 0.,1.,0.,0.,0.,0.)\n#define MATERIAL_METAL(color, roughness) Material(color, 0.,0.,1.,0.,roughness,0.)\n// Parameters are: \n//      color;\n//      reflectance at 90Â°  (ref);\n//      transmittance       (tra); \n//      surface roughness   (rgh);\n//      index of refraction (eta);\n// Parameters ref and tra need not sum to 1., they are normalized automatically\n#define MATERIAL_GLASS(color, ref, tra, rgh, eta) Material(color, 0.,0., ref, tra, rgh, eta)\n\nMaterial mixMaterials(Material m1, Material m2, float h)\n{\n    return Material\n    (\n        mix(m2.color, m1.color, h),\n        mix(m2.emittance, m1.emittance, h),\n        mix(m2.diffusiveReflectance, m1.diffusiveReflectance, h),\n        mix(m2.specularReflectance, m1.specularReflectance, h),\n        mix(m2.transmittance, m1.transmittance, h),\n        mix(m2.roughness, m1.roughness, h),\n        mix(m2.refractiveIndex, m1.refractiveIndex, h)\n    );\n}\n\nvoid mixWithSceneMaterial(Material m, float h)\n{\n    gSceneMaterial = mixMaterials(gSceneMaterial, m, h);\n}\n\n//----------------------------------------------------------------------------//\n// SDFs\n\nfloat sphereSDF(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat rectCuboidSDF(vec3 p, vec3 l)\n{\n    vec3 q = abs(p)-l/2.;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torusSDF(vec3 p, float ro, float ri)\n{\n    vec2 q = vec2(length(p.xz)-ro,p.y);\n    return length(q)-ri;\n}\n\n// SDF Operations (not all of them are used). The 'f' parameter is used as a\n// mixing factor to mix materials to provide smooth material transitions (i.e.,\n// a material that smoothly transitions from metal to e.g. lambertian or glass,\n// as weird as that may look)\n\nfloat uniteSDFs(float sdf1, float sdf2, out float f)\n{\n    if (sdf1 < sdf2)\n    {\n        f = 1.;\n        return sdf1;\n    }\n    f = 0.;\n    return sdf2;\n}\n\nfloat subtractSDFs(float sdf1, float sdf2, out float f)\n{\n    f = 0.;\n    return max(-sdf1, sdf2);\n}\n\nfloat intersectSDFs(float sdf1, float sdf2, out float f)\n{\n    if (sdf1 > sdf2)\n    {\n        f = 1.;\n        return sdf1;\n    }\n    f = 0.;\n    return sdf2;\n}\n\nfloat smoothUniteSDFs(float sdf1, float sdf2, float s, out float f)\n{\n    f = clamp(0.5+0.5*(sdf2-sdf1)/s, 0.0, 1.0);\n    return mix(sdf2, sdf1, f)-s*f*(1.0-f);\n}\n\nfloat smoothSubtractSDFs(float sdf1, float sdf2, float s, out float f)\n{\n    f = clamp(0.5-0.5*(sdf2+sdf1)/s, 0.0, 1.0);\n    return mix(sdf2, -sdf1, f + s*f*(1.0-f));\n}\n\nfloat smoothIntersectSDFs(float sdf1, float sdf2, float s, out float f)\n{\n    f = clamp(0.5-0.5*(sdf2-sdf1)/s, 0.0, 1.0);\n    return mix(sdf2, sdf1, f)+s*f*(1.0-f);\n}\n\n//----------------------------------------------------------------------------//\n// Ray\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nRay cameraRay(vec2 uv, vec3 cp, vec3 f, float fov)\n{\n    if (ANTI_ALIASING)\n        uv += ((hash2()-.5)/iResolution.xy)/2.;\n    vec3 l = normalize(cross(vec3(0,1,0),f));\n    vec3 u = normalize(cross(f,l));\n    return Ray(cp,normalize(cp+f*fov-uv.x*l+uv.y*u-cp));\n}\n\n//----------------------------------------------------------------------------//\n//----------------------------------------------------------------------------//\n//----------------------------------------------------------------------------//\n\n// The material computation is flag-controlled to save on (a lot) of performance\nfloat sceneSDF(vec3 p, bool computeMaterial)\n{\n    float scene, fMix;\n    \n    // Box with light source\n    vec3 box = vec3(3);\n    scene = min(min(p.y+box.y/2., -p.y+box.y/2.), -p.z+box.z/2.);\n    if (computeMaterial)\n    {\n        gSceneMaterial = MATERIAL_LAMBERTIAN(vec3(1.));\n        gSceneMaterial.diffusiveReflectance = 1.-WHITE_WALL_REFLECTANCE;\n        gSceneMaterial.specularReflectance = WHITE_WALL_REFLECTANCE;\n        gSceneMaterial.roughness = WHITE_WALL_ROUGHNESS;\n    }\n    scene = uniteSDFs(scene, p.x+box.x/2., fMix);\n    if (computeMaterial)\n        mixWithSceneMaterial(MATERIAL_LAMBERTIAN(vec3(.75,.15,0.)), fMix);\n    scene = uniteSDFs(scene, -p.x+box.x/2., fMix);\n    if (computeMaterial)\n        mixWithSceneMaterial(MATERIAL_LAMBERTIAN(vec3(0.,.5,0.)), fMix);\n    scene = subtractSDFs(p.z+box.z/2., scene, fMix);\n    float light = rectCuboidSDF(p-UP*(box.y/2.), vec3(box.x/3., .01, box.z/3.));\n    scene = uniteSDFs(scene, light, fMix);\n    if (computeMaterial)\n        mixWithSceneMaterial(MATERIAL_LIGHT_SOURCE(vec3(1.), 40.), fMix);\n        \n    // Stuff in box\n    // Lambertian parallelopiped in the back-left\n    vec3 p0 = rotate(p+vec3(-box.x/5., .5, -box.z/4.), -.5, UP);\n    scene = uniteSDFs(scene, rectCuboidSDF(p0, vec3(1.,2.,1.)), fMix);\n    if (computeMaterial)\n        mixWithSceneMaterial(MATERIAL_LAMBERTIAN(vec3(1.)), fMix);\n    \n    // Blue-ish metal sphere\n    p0 = p+vec3(box.x/4., -box.y/8., 0.);\n    scene = uniteSDFs(scene, sphereSDF(p0, .625), fMix);\n    if (computeMaterial)\n        mixWithSceneMaterial\n        (\n            MATERIAL_METAL(vec3(.75,.875,1.), METAL_SPHERE_ROUGHNESS), \n            fMix\n        );\n        \n    // Ice-cube-like thing (i.e., glass with some surface roughness)\n    p0 = rotate(rotate(p+vec3(.125, .5, .5), 1., UP), 1.1, RT);\n    scene = uniteSDFs\n    (\n        scene, \n        rectCuboidSDF(p0, vec3(.6))-.1-.025*(.5+.5*cos(25.*p.x*p.y*p0.z)), \n        fMix\n    );\n    if (computeMaterial)\n        mixWithSceneMaterial\n        (\n            MATERIAL_GLASS(vec3(1.), .06, .94, ICE_CUBE_ROUGHNESS, 1.33),\n            fMix\n        );\n        \n    // Weird thing to demostrate blending of different materials, e.g., metal\n    // and glass\n    p0 = rotate(rotate(p+vec3(-.75, 1, .75), -.54, RT), -.63, FW);\n    float fMixTor;\n    float tor = torusSDF(p0-vec3(.3,0.,0.)-.1*sin(5.*p0.x*p0.z), .35, .15);\n    p0 = p0+vec3(.3,0.,0.);\n    tor = smoothUniteSDFs\n    (\n        tor, \n        sphereSDF(p0,.25)+.075*cos(20.*p0.z), \n        .25, \n        fMixTor\n    );\n    scene = uniteSDFs(scene, tor, fMix);\n    if (computeMaterial)\n    {\n        Material m = mixMaterials\n        (\n            MATERIAL_METAL(vec3(1.), .05),\n            MATERIAL_GLASS(vec3(1.), .06, 1., 0., 1.33),\n            fMixTor\n        );\n        mixWithSceneMaterial(m, fMix);\n    }\n    \n    return scene;\n}\n\n//----------------------------------------------------------------------------//\n//----------------------------------------------------------------------------//\n//----------------------------------------------------------------------------//\n\n// True if path-marching inside a material\nbool gInside = false;\n\nvec3 sceneNormal(vec3 p, float h)\n{\n    vec2 e = vec2(1.0,-1.0);\n    vec3 n = normalize( e.xyy*sceneSDF(p+e.xyy*h, false)+\n                        e.yxy*sceneSDF(p+e.yxy*h, false)+\n                        e.yyx*sceneSDF(p+e.yyx*h, false)+\n                        e.xxx*sceneSDF(p+e.xxx*h, false));\n    return gInside ? -n : n;\n}\n\n//----------------------------------------------------------------------------//\n\nfloat rayMarch(Ray r)\n{\n    float s = 0.;\n    float ds = 0.;\n    vec3 p;\n    for (int q=0; q<MAX_STEPS; q++)\n    {\n        p = r.origin+r.direction*s;\n        ds = sceneSDF(p, false)/SAFETY_FACTOR;\n        if (gInside)\n            ds *= -1.;\n        s += ds;\n        if ((ds < MIN_DIST && ds > 0.) || s > MAX_DIST)\n            break;\n    }\n    s = s*float(s <= MAX_DIST);\n    return s; \n}\n\n//----------------------------------------------------------------------------//\n\n// The result is stored in gSceneMaterial (global)\nvoid computeMaterial(vec3 p, out vec3 n)\n{\n    n = sceneNormal(p, MIN_DIST);\n    sceneSDF(p-n*10.*MIN_DIST, true);\n}\n\n//----------------------------------------------------------------------------//\n\nint gBounce = 0;\nint gSample = 0;\nvoid scatter(inout Ray ray, float s)\n{\n    ray.origin += s*ray.direction*(1.-MIN_DIST);\n    vec3 n;\n    computeMaterial(ray.origin, n);\n    ray.origin += n*10.*MIN_DIST;\n    \n    // These should be interpreted as the probability of the ray to\n    // undergo isotropic scattering (x), specular reflection (y) or\n    // transmission through the medium\n    vec3 coeff = vec3(\n        gSceneMaterial.diffusiveReflectance,\n        gSceneMaterial.specularReflectance,\n        gSceneMaterial.transmittance);\n    float sum = coeff.x+coeff.y+coeff.z;\n    coeff /= sum;\n    \n    // If material is purely diffusive\n    if (coeff.x > 1.-1e-6)\n    {\n        // Trick to sample a direction from a distribution\n        // that reflects Lambert's law (i.e., whose pdf\n        // is cos-theta wherein theta is the sampled\n        // direction angle with respect to the surface\n        // normal). This is the simplest form of\n        // importance sampling, for Lambertian materials\n        // only\n        ray.direction = normalize(n+randomUnitVector());\n        return;\n    }\n    \n    // At near-grazing angles, the only part of the rough surface we can see\n    // are the microfacet 'hill-tops', which tend to have their microfacet\n    // normals reasonably aligned with the macroscopic surface normal.\n    // To 'model' this, I 'attenuate' the roughness based on how grazing the \n    // view angle is. The smoothstep bounds are arbitrary\n    if (gSceneMaterial.roughness > 0.)\n        gSceneMaterial.roughness *= smoothstep(.0, .5, dot(-ray.direction, n));\n       \n    // Microfacet normal & reflected ray\n    vec3 mfn = normalize(n+gSceneMaterial.roughness*randomUnitVector());\n    vec3 mfr = reflect(ray.direction, mfn);\n    \n    // If material is purely reflective\n    if (coeff.x > .999999)\n    {\n        ray.direction = mfr;\n        return;\n    }\n    \n    // Enchance reflectiveness via Schlick approximation for Fresnel reflectance\n    // I am well aware that the base reflectance (i.e., the reflectance at\n    // normal incidence, i.e., my coeff.y) should not be a direct input, rather, \n    // it should be computed based on the material refractive indices at both \n    // inteface sides, but having the user directly specify the reflectance is \n    // more intuitive when compared to having to reason about the refractive \n    // indices of non-transmissive materials, which do actually exist but make\n    // no intuitive sense. In short, if you want greater physical accuracy, make\n    // sure to always override coeff.y with the ratio of refractive indices\n    // (eta0/eta1 below), and to always provide refractive indices for all \n    // materials (this would require a bit of code refactoring)\n    coeff.y += (1.-coeff.y)*pow(1.-dot(mfr, n), 5.);\n    coeff.z = max(1.-coeff.x-coeff.y, 0.f);\n    coeff.x = 1.-coeff.y-coeff.z;\n    \n    // Determine what type of scattering the ray undergoes\n    float discriminant = fract(gSeed);\n    \n    if (discriminant <= coeff.x)        // Diffusion\n        ray.direction = normalize(n+randomUnitVector());\n    else if (discriminant < 1.-coeff.z) // Reflection\n        ray.direction = mfr;\n    else                                // Transmission with refraction\n    {\n        ray.origin -= 2.*n*10.*MIN_DIST;\n        gInside = sceneSDF(ray.origin, false) < 0. ? true : false;\n        // gSceneRefractiveIndex always stores the refractive index of the\n        // material the ray-marched point is currently in\n        float eta0 = gSceneRefractiveIndex;\n        float eta1 = \n            gInside ? gSceneMaterial.refractiveIndex : gVoidRefractiveIndex;\n        gSceneRefractiveIndex = eta1;\n        ray.direction = refract(ray.direction, mfn, eta0/eta1);\n        if (length(ray.direction) == 0.) // I.e., total reflection\n            ray.direction = mfr;\n    }\n}\n\n//----------------------------------------------------------------------------//\n\nvec3 computeColor(in Ray ray)\n{\n    vec3 pathColor = vec3(1);\n    vec3 color = vec3(0);\n    for (gBounce=0; gBounce<N_BOUNCES; gBounce++)\n    {\n        float s = rayMarch(ray);\n        if (s > 0.)\n        {\n            scatter(ray, s);\n            color += pathColor*gSceneMaterial.color*gSceneMaterial.emittance;\n            pathColor *= gSceneMaterial.color;\n        }\n        else\n            break;\n    }\n    return color;\n}\n\n//----------------------------------------------------------------------------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    gSeed = \n        float(baseHash(floatBitsToUint(fragCoord)))/\n        float(0xffffffffU)+fract(iTime);\n    \n    Ray ray;\n    fragColor = vec4(0);\n    for (gSample=0; gSample<N_SAMPLES; gSample++)\n    {\n        gBounce = 0;\n        ray = cameraRay(uv, CAMERA_POSITION, CAMERA_DIRECTION, 1.);\n        \n        float s0 = sceneSDF(ray.origin, true);\n        gSceneRefractiveIndex = \n            s0 > 0. ? \n            gVoidRefractiveIndex : \n            gSceneMaterial.refractiveIndex;\n        gInside = s0 > 0. ? false : true;\n        \n        fragColor += vec4(computeColor(ray),1.)/float(N_SAMPLES);\n    }\n    fragColor += texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (isnan(fragColor.r))\n        fragColor = vec4(0,0,0,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}