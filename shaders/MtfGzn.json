{
    "Shader": {
        "info": {
            "date": "1622109209",
            "description": "An experiment in negative spaces.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtfGzn",
            "likes": 9,
            "name": "SphereMiner",
            "published": 3,
            "tags": [
                "raymarched"
            ],
            "usePreview": 0,
            "username": "bloodnok",
            "viewed": 362
        },
        "renderpass": [
            {
                "code": "/*\n\tPinching noise and basic raymarching setup from Octavio Good: https://www.shadertoy.com/view/4dSXDd\n*/\n\n// noise functions\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nvec3 noise3(vec3 uv)\n{\n    return vec3(\n        noise(uv),\n        noise(uv.yzx + vec3(35.654,135.7,17.2)),\n        noise(uv.zxy + vec3(19.7,39.7,117.7))\n        );\n}\n\nfloat PI=3.14159265;\n\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\nfloat sdInvSphere( vec3 p, float s )\n{\n\treturn -sdSphere(p,s);\n}\nfloat sdqSphere( vec3 p, float ss )\n{\n\treturn dot(p,p)-ss;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    //vec2 d3 = vec2(-d2.x,d2.y);\n    //return max(-d2,d1);\n    return (-d1.x > d2.x) ? vec2(-d1.x,d1.y) : d2;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\nvec2 distanceToScene(vec3 p)\n{\n    /*\n\tfloat t = sdSphere(p - vec3(0.0), 0.1);\n    t = min(t,sdSphere(p - vec3(0.3), 0.5));\n    t = min(t,sdSphere(p - vec3(-0.1), 0.2));\n    t = min(t,sdSphere(p - vec3(0.0,0.2,-0.2), 0.3));\n    t = min(t,sdSphere(p - vec3(0.1,0.0,-0.5), 0.5));\n    t = t - noise(p*50.0) * 0.01;\n*/\n  \n    vec2 res = vec2(10000.0,0.0);\n    \n//    float t = 10000.0;//sdSphere(p - vec3(0.0), 0.1);\n    \n    \n    for(float i=-0.5;i<5.0;i+=0.9)\n    {\n        res = opU(res,vec2(sdSphere(p - vec3(0.0,-0.05,i), 0.5),1.0));\n        \n        res = opU(res,vec2(sdSphere(p - vec3(-0.5,-0.05,i), 0.1),0.9));\n        res = opU(res,vec2(sdSphere(p - vec3(0.5,-0.05,i), 0.1),0.9));\n    }\n    \n    //t = sqrt(t);\n    //if (camDist<5.0){\n    \n    float ns = 10.0, na = 0.02;\n    float n = 0.0;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    \n    res.x-=n;\n    \n        //t = t - noise(p*20.0) * 0.02;\n        //t = t - noise(p*40.0) * 0.01;\n        //t = t - noise(p*80.0) * 0.005;\n    \t//t = t - noise(p*200.0) * 0.001;\n    //}\n    \n    //return t;\n    return opS(res,vec2(sdSphere(p - vec3(0.0,0.0,-0.5), 50.0),0.0));\n}\n\n//float distanceToScene(vec3 p)\n//{\n//    return distanceToScene(p,0.0).x;\n//}\n    \nvec3 getNormal(vec3 p, float dist)\n{\n    vec3 e = vec3(0.0025, 0, 0);\n    return normalize(vec3(dist - distanceToScene(p - e.xyy).x,\n                        dist - distanceToScene(p - e.yxy).x,\n                        dist - distanceToScene(p - e.yyx).x));\n}\n\nfloat shadowMarch(vec3 p0, vec3 d)\n{\n    vec3 p;\n    float s = 1.0;\n    float t = 0.0;\n    \n    for(int i=0;i<16;i++)\n    {\n        p = p0 + d * t;\n        float dist = distanceToScene(p).x;\n        \n        //s *= (1.0 - smoothstep(0.001,0.002,dist)*0.8);\n       \n        t += max(dist,0.1);\n        //s *= 1.0 - clamp(abs(dist),0.0,1.0);\n        \n        //if (s<0.01) break;\n        //if (abs(dist)<0.001) break;\n            \n        \n        //t+=0.1;\n        //if (s<0.001) break;\n        //p = p0 + d * t * 0.05;\n        //float dist= distanceToScene(p);\n        //s *= (1.0 - smoothstep(0.0,0.001,dist)*0.5);\n\t\t\n    }\n    \n    return s;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = distanceToScene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.025, 0.20 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 tempToColour(float t)\n{\n    return vec3(\n        smoothstep(500.0,2000.0,t) * 0.95,\n        smoothstep(900.0,5000.0,t),\n        smoothstep(2000.0,10000.0,t)\n       )*4.0;\n}\n\nfloat OrenNayar(float roughness, float albedo, vec3 rd, vec3 nor, vec3 light)\n{\n    // oren-nayar\n    //float roughness = 0.5;\n    //float albedo = 1.0;\n    float roughness2 = roughness*roughness;\n    float onA = 1.0 - 0.5 * (roughness / (roughness+0.57));\n    float onB = 0.45 * (roughness / (roughness+0.09));\n\n    float ndotl = dot(nor,light);\n    float ndotv = dot(nor,-rd);\n\n    float ai = acos(ndotl);\n    float ar = acos(ndotv);\n\n    float onAlpha = max(ai,ar);\n    float onBeta = min(ai,ar);\n    float onGamma = dot(-rd - nor * dot(-rd,nor),light - nor * dot(light,nor)); // ?\n\n    return (albedo / 3.1415927) * max(0.0,dot(nor,light)) * (onA + (onB * max(0.0,onGamma) * sin(onAlpha) * tan(onBeta)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 lightV = normalize(vec3(-1.0,0.8,0.0));\n    vec3 lightC = vec3(0.85,0.9,1.0) * 0.05;\n    vec3 camLightC = vec3(0.95,0.92,0.8) * 0.5;\n    \n    vec2 muv = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    \n\tvec3 camPos = vec3(0.0,0.0,1.5+sin(iTime * 0.1) * 2.0);\n    //vec3 camFacing;\n\tvec3 camUp=vec3(0.0,1.0,0.0);\n\tvec3 camLookat=vec3(muv.x*4.0,muv.y*4.0,camPos.z + 1.0);\n    \n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * 0.8 * sideNorm * (iResolution.x/iResolution.y) + uv.y * 0.8 * upNorm;\n\tvec3 relVec = normalize(worldPix - camPos);\n    \n    \n    // material parameters\n    vec3 emmissive = vec3(0.0);\n    vec3 albedo = vec3(0.0);\n    float specexp = 30.0;\n    float spec = 0.0;\n    float roughness = 0.0;\n    \n    \n    // Raymarch\n    float t = 0.0;\n    vec2 dist = vec2(0.1,0.0);\n    float distMax = 20.0;\n    vec3 p = vec3(0.0);\n    \n    for(int i=0;i<64;i++)\n    {\n        if ((dist.x > distMax) || (abs(dist.x) < 0.001)) break;\n        \n        p = camPos + relVec * t*0.95;\n        dist = distanceToScene(p);\n        t += dist.x;//*0.9999;\n    }\n    \n    vec3 nor = getNormal(p,dist.x);\n\n    // material\n    if (dist.y>0.95)\n    {\n        vec3 n3 = noise3(p * 400.0);\n        \n        albedo = vec3(0.3) + n3 * vec3(0.05,0.07,0.1);\n        roughness = 0.9;\n        \n        nor = normalize(nor + (n3 - 0.5) * 0.2);\n        \n        float sn = noise(p*vec3(0.5,9.0,9.0)) + noise(p*30.0) * 0.05;\n        //spec = (smoothstep(0.9,0.92,sn) * (1.0-smoothstep(0.95,0.97,sn))) * smoothstep(0.5,0.7,noise(p*3.0));\n        spec = smoothstep(0.99,0.992,sn);\n        \n        spec += smoothstep(0.7,0.95,noise(p * 15.0)) * 0.05;\n        \n        albedo *= (1.0-spec*0.5); \n        roughness *= (1.0-spec);\n    }\n    else if (dist.y > 0.85)\n    {\n        float temperature = \n            500.0 + \n            smoothstep(0.0,1.0,noise(p*3.0)) * 300.0 + \n            //smoothstep(0.6,1.0,noise(p*40.0)) * 950.0 + \n            smoothstep(0.7,1.0,noise(p*40.0)) * 3000.0;\n        temperature *= abs(sin(iTime * 0.05));\n        emmissive = tempToColour(temperature);\n        albedo = vec3(0.3);\n    }\n    \n    vec3 col = vec3(0.0);\n    //vec3 diffuse = vec3(0.2);\n    \n    // hit\n    if (abs(dist.x) < 0.1)\n    {\n        \n        // diffuse\n        col = albedo * clamp(dot(nor,lightV),0.0,1.0) * lightC;\n        \n        // camera light\n        vec3 camLightV = (camPos-p + vec3(0.1,-0.22,-0.1));\n        float camLightPower = 1.0 / dot(camLightV,camLightV);\n        camLightV = normalize(camLightV);\n        //camLightPower *= shadowMarch(p,-camLightV);\n        //camLightPower *= (softshadow(p,camLightV,0.02, 0.5));\n        \n        float diffuse = OrenNayar(1.0, 1.0, relVec, nor, camLightV);\n        \n        col += albedo * clamp(diffuse,0.0,1.0) * camLightC * camLightPower;\n        \n        // specular\n        vec3 refl = reflect(relVec,nor);\n        col += spec * pow(clamp(dot(refl,camLightV),0.0,1.0),specexp) * camLightC * camLightPower;\n        \n        // emmissive\n        col += emmissive;\n        \n        //col = nor * 0.5 + 0.5;\n    }\n\n    float fog = 1.0 - 1.0 / exp(  t * 0.9);\n    \n    \n    col = mix(col,vec3(0.0),fog);\n    fog = max(0.0,fog-0.2);\n    col = mix(col,vec3(0.6,0.8,1.0)*0.1,fog*fog);\n\n    \n    // gamma\n    col = pow(col,vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}