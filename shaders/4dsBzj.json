{
    "Shader": {
        "info": {
            "date": "1497045783",
            "description": "mouse.y has an effect, hard to describe.\n\ngoing trough all FM synthesis shadertoys with decent instruments at their core. collected them here.\none messy envelope gallery\n\nhaving some newbie fun with direct Fourier transform. mainImage() is very \"twiddly\".",
            "flags": 8,
            "hasliked": 0,
            "id": "4dsBzj",
            "likes": 41,
            "name": "FM instrument collection 2017-06",
            "published": 3,
            "tags": [
                "envelope",
                "fourier",
                "instrument",
                "dft",
                "arp",
                "arpeggio",
                "thermodynamic"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 1806
        },
        "renderpass": [
            {
                "code": "//https://www.shadertoy.com/view/MdjXWc\n// FM Reverb\n// Created by Dmitry Andreev - and'2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//for a more colorblind friendly mode (green shifts to blue) ?\n//#define colorblind\n\n\n#define PI acos(-1.)\n\n#define sat(a) clamp(a,0.,1.)\n\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float tt = fract(t);\n    float tn = t - tt;\n    tt = smoothstep(0.0, 1.0, tt);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, tt);\n}\n\nfloat sine(float x)\n{\n    return sin(2.0 * PI * x);\n}\n\nvec2 sine(vec2 v) { return vec2(sine(v.x), sine(v.y)); }\n\n\n\n\n#define globalTranspose 0\n#define TT(d) mod(mod(time,1.0)-d,1.0)\n\n//sine wave with vibrato, nice lead (background).\nfloat ld(float time,int note,float speed,float arpVolume){\n    note+=globalTranspose;    \n    float base_a4=440.0;\n    float baseFreq=1.0;\n    float globalTime=0.0;\n    float freq=base_a4*pow(2.0,float(note)/12.0)*baseFreq;\n    freq*=speed;    \n    freq+=freq*step(mod(time,0.1),0.05)*arpVolume;\n\t\n    //vibrato\n    float vibratoDelay=0.2;\n    freq+=1.0+sin(time*20.0*speed)/PI*0.001*freq*step(0.0,time-vibratoDelay);\n\n    float t=1.0-(time*1.0);\n    t=max(t,0.0);\n\t\n    //create sqr duty wave\n    float duty=cos(time*2.0+globalTime*0.5)/PI;\n    duty=duty*0.2+0.8;\n    float f1=fract(t*freq);\n    float f2=fract(duty+t*freq);\n    float f=f1-f2;\n    f= clamp(f,-1.0,1.0);\n    \n\tfloat t2=time*baseFreq;\n    f*=pow(max(0.0,1.0-(t2*1.0)),1.5);\n\n    //hihat\n    //f+=rand(time)*0.2*pow(1.0-t2,16.0);\n    return f;}\n\nfloat lead(float t,float arpVolume){\n    float c=0.0;\n    float speed=0.5;\n\n    #define LD(d,n)   c+=ld(TT(d),n,1.0/speed,arpVolume)*step(0.0,time-d);\n   \n    float time=mod(t*speed,32.0);\n    if (time>8.0 && time<16.0)time-=8.0;\n\n    int i=0;\n    float f=0.0;\n    if (time<1.0)\n    {\n        LD(0.0,i);\n        LD(0.5,i+2);\n\t}\n\telse\n    if (time<2.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i+3);\n        LD(0.125*1.0,i+5);\n        LD(0.125*3.0,i);\n        LD(0.125*5.0,i-2);\n\t}\n\telse\n    if (time<3.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i);\n        LD(0.5,i+2);\n    }\n    else\n    if (time<4.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i+3);\n        LD(0.125*1.0,i+5);\n        LD(0.125*3.0,i+10);\n        LD(0.125*5.0,i+7);\n    }\n    else\n    if (time<5.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i);\n        LD(0.5,i+2);\n\t}\n\telse\n    if (time<6.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i+3);\n        LD(0.125*1.0,i+5);\n        LD(0.125*3.0,i);\n        LD(0.125*5.0,i-2);\n\t}\n\telse\n    if (time<7.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i);\n        LD(0.5,i-2);\n    }\n    else\n    if (time<8.0)\n    {\n\t\ttime=fract(time);\n        i=-12;\n        LD(0.0,i+7);\n        LD(0.125*1.0,i+10);\n        LD(0.125*2.0,i+5);\n        LD(0.125*3.0,i+7);\n    }\n    return c;\n}\n\n\nvec2 synthWave(float t){\n t=mod(t,32.);\n return vec2(lead(t,.0));\n}\n\n\n#define DFTitterations 352.\n#define scrollspeedX 5.\n//scaleY scales an overlapping modulo circle, \n//... with a circilar complex-plane \"ovetone echo\". \n//... This is the confusing part about Fourier Transformation.\n//.1  circles trough 3 cotaves. \n//.05 circles trough 5 octaves. \n//.03 circles trough 8 octaves.\n//direct fourier transform for fragment [u] on synthWave(t)\nfloat FourierTransform(vec2 u,float scaleY){\n u.x=floor((u.x+iTime/scrollspeedX)*DFTitterations)/DFTitterations;\n //rasterizing by DFTitterations makes pixels square?\n u.x=(u.x-1.)*scrollspeedX;\n float n=DFTitterations;\n float a=2.*PI*floor(u.y*n*.5)/n;\n vec2 j=vec2(cos(a),sin(a));\n vec2 d=vec2(1,0),f=vec2(0);\n for(int i=0;i<int(n);i++){\n  float x=float(i)/n,t=x*scaleY+u.x;\n  vec2  w=synthWave(t);\n  x=(w.x+w.y)*.25*(1.-cos(2.*PI*x));//Hann window\n  f+=d*x;\n  d=d.xy*j.x+vec2(-1,1)*d.yx*j.y;}\n float y=.5*length(f);\n return sat(sqrt(y/(1.+y)));}\n\n\nvec3 hsv2rgb(in vec3 c){vec3 r=clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n return c.z*mix(vec3(1.),r*r*(3.-2.*r),c.y);}\n\n/*\nfloat remap(float l,float h,float x){return sat((x-l)/(h-l));}\n//return silly slow 4 color ramp, famous for fourier transforms.\nvec3 blueRedYellowWhite(float y){vec3 c=mix(vec3(0)\n        ,vec3(0.2,0.2,0.7),remap(.00,0.25,y));//blue\n c=mix(c,vec3(0.9,0.1,0.0),remap(.25,0.50,y));//red\n c=mix(c,vec3(1.0,1.0,0.3),remap(.50,0.75,y));//yellow\n return mix(c,vec3(1.0,1.0,1.0),remap(.75,1.00,y));}//white\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n vec2  u=fragCoord.xy/iResolution.xy;\n vec2 m=iMouse.xy*.2/iResolution.xy;\n if(iMouse.z<=0.) m=vec2(.05);\n u.x+=.5;\n //u.y/=DFTScaleY;\n float y=FourierTransform(u,m.y);\n y=y/acos(y);//push all towards \"1\"\n u.x=abs(u.x-1.);\n float a=1.-sqrt(u.x*1.5);\n y=mix(y*.1,y-a,a);\n //near      the \"now\" timeline, the contrast is higher.\n //away from the \"now\" timeline, the contrast is lower.\n \n vec3 c;\n //c=blueRedYellowWhite(y);\n c=y*.5+hsv2rgb(vec3(y*.49,2./(y+.1),y));//Fourier transform infreared image\n \n #ifdef colorblind\n  c/=log(y)+.1;//good contrast for colorblind\n  c+=y*.5;\n #else\n  c/=sqrt(y)+.1;//even out colors\n  c+=y*.5;\n #endif\n c=max(vec3(0),c);\n if(u.x<.005)c+=.5;//brighter vertical line at \"now\"\n \n fragColor = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//parent: https://www.shadertoy.com/view/ldXBzj \n//self:   https://www.shadertoy.com/view/4dsBzj\n\n//i keep confusing these 2 labels all the time\n#define pow2(a) exp2(a)\n#define sat(a) clamp(a,0.,1.)\n\n\n//arp = Arpeggiator, = chord with offset over time, can overlap or not.\n// https://en.wikipedia.org/wiki/Arpeggio   is common for string instruments.\n//\n//https://www.shadertoy.com/view/4ssfzj\n//emulates a whole xm-chip, and xm-sequencer.\n#define PHI_INC(cnt, val)cnt< 0.0?0.0:exp2(float(val)/12.0)*clamp(cnt, 0.0, 1.0), cnt -= 1.0\n#define PHI_REP(cnt, val)cnt< 0.0?0.0:exp2(float(val)/12.0)*max(cnt, 0.0)\nfloat arpeggio3(float p, int d0, int d1, int d2){\n    float phi = 0.0;\n    float mp = mod(p, 3.0);\n    float cp = floor(p / 3.0);\n    phi += PHI_INC(mp, d0);\n    phi += PHI_INC(mp, d1);\n    phi += PHI_INC(mp, d2);\n    float f0 = exp2(float(d0) / 12.0);\n    float f1 = exp2(float(d1) / 12.0);\n    float f2 = exp2(float(d2) / 12.0);\n    phi += (f0 + f1 + f2) * cp;\n    return phi;}\n//https://www.shadertoy.com/view/XlBGz3\n\n//this is a maess of namespace conflicts \n//...and very different approaches to very similar things.\n//just look at all the ways they define a rotation:\n//which leads to my conclusion:\n//most people have no clue what they are doing,\n//...just by looking at their low efficiency.\n\n//*exp(-3.0*time);//fadeout over time\n#define pi2 6.283185307179586476925286766559\n#define CON pi2\n#define TWOPI pi2\n#define PI2 pi2\n#define TAU pi2\n#define pi 3.1415926535897932384626433832795\n#define PI pi\n//edgy, and i assume LOW precision, due to doing a mult.\n//#define pi radians(180.)\n//#define pi2 radians(360.)\n//edgy, highest precision for complex transforms \n//...or if compiler insists on 64 or 128 bit float.\n//#define pi acos(-1.)\n//#define pi2 pi*2.\n//exp(i*pi2)=0.; i*i=-1.; should be utilized to define pi2=6.28...\n//above is eulers identity, with pi*2, going \"full rotation\"\n\n\n\nfloat si(float i){return sin(fract(i)* pi*2.); }\n//clamped siene sounds more like a metallic flute if(with overtones)\nfloat csi(float i){return clamp(si(i),-.707,.707); }             \nfloat saw(float i){return fract(i)*2.-1.;}\nfloat sq(float i){return mix(0.,1.,step(fract(i),.5));}\nfloat noise(float i){return fract(sin(i*.011753)*122.3762)*2.-1.;}\n//(https://www.shadertoy.com/view/4sSSWz)\n\n//organ with soft overtones\nfloat organ(float t,int k){if(k<1||k>=0xC0)return 0.;//null key\n float f=27.5*pow(2.,float(k)/12.),r=0.;t*=f;\n for(int i = 1;i<8;i++){\n  r+=csi(float(i)*t)*pow(.6,float(i));}\n //*pow(.6,float(i)) diminishes amplitude exponentially for each overtone.\n r*=(1.+si(t*10.)/8.);\n return r*5.*inversesqrt(f);}//https://www.shadertoy.com/view/lstXWS\n\n\n//final fantasy 7, glockenspiel and harp, with echo\n//[f]frequency [t]time\nfloat instrument(float f, float t ){f*=t;\n float y=.7*sin(   pi2*f)*exp(-.0075*f);\n      y+=.2*sin(2.*pi2*f)*exp(-.0055*f);return y*sat(t/.004);}\nfloat instrument2(float f,float t){    \n float p=.2+0.8*max(0.,6.-.01*f);f*=t;\n p*=sin(pi2*f)*exp(-f*0.2);\n float y=.70*sin(     pi2*f+p)*exp(-.005*f);\n      y+=.20*sin(2.01*pi2*f+p)*exp(-.0055*f);\n      y+=.16*sin(4.01*pi2*f+p)*exp(-.009*f);\n return y*sat(t/.004);}\n//https://www.shadertoy.com/view/XllXWN\n\n\n\n#define trunc(a) float(int(a))\nfloat notetrunc(float t){return trunc(sin(0.25*t)*4.+cos(0.375*t)*4.0);}\n//https://www.shadertoy.com/view/4sXSWf\n\n//smooth abs() ==??\nfloat sAbs1(float x,float k){return sqrt(x*x+k);}\n//nice smin?\nfloat sMin(float a, float b, float k){\n return (a+b-sAbs1(a-b,k))*.5;}\n//as usual, max() =-min(-,-)\nfloat sMax(float a, float b, float k){return -sMin(-a, -b, k); }\n//identity of SMOOTH clamp\nfloat sClamp(float x, float a, float b, float k){\n    return sMin(b,sMax(a,x,k),k);}\n//smooth clamped sine instrument\nfloat sndsmoothclampedsin(float time){\n  return sClamp(pow(sin(6.2831*440.0*fract(time*.94)),64.),-.25,.55,.04);\n}\n\n\n/*\n{\n    //above this code n is set within a loop.\n    //soothing harry potter sine\n    //...  //https://www.shadertoy.com/view/lssXWS\n    // calc frequency and time for note\t  \n    float noteFreq = 440.0*pow( 2.0, (n-69.0)/12.0 );\n    float noteTime = 0.18*(t-x);\n    // compute instrument\t\n    float y  = 0.5*sin(6.2831*1.00*noteFreq*noteTime)*exp(-0.0015*1.0*noteFreq*noteTime);\n\t      y += 0.3*sin(6.2831*2.01*noteFreq*noteTime)*exp(-0.0015*2.0*noteFreq*noteTime);\n\t      y += 0.2*sin(6.2831*4.01*noteFreq*noteTime)*exp(-0.0015*4.0*noteFreq*noteTime);\n          y += 0.1*y*y*y;\t  \n          y *= 0.9 + 0.1*cos(40.0*noteTime);\n\t      y *= smoothstep(0.0,0.01,noteTime); \n    // accumulate echo\t  \n    tot += y * vec2(0.5+0.2*h,0.5-0.2*h) * (1.0-sqrt(h)*0.85);\n      ///... tot is an accumulator for echo outside of a loop\n}*/\n\nfloat hash(float x){return fract(sin(x)*265871.1723);}\nfloat noize(float t){return fract(sin(t*3314.9)*342.0);}\nfloat rand21(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat n2f(float note){return 55.0   *pow(2.0,(note- 3.0)/12.);}\nfloat noteMIDI(float n){return 440.0*pow(2.0,(n   -69.0)/12.);}\n\n\n#define beatLength 1.\nfloat noteFreq(int note){return n2f(float(note+39));}\nfloat introHorn(int note, float time){    \n float g = time - 0.5;\n g=mix(pow(1.0-g,1.0-g*0.4),(1.0-g),step(0.,g));\n float b=6.2831*noteFreq(note)*g*0.5;\n float m=0.0;\n m+=sin(b*1.)*1.;\n m+=sin(b*2.)*.75;\n m+=sin(b*3.)*.75;\n m+=sin(b*4.)*.5;\n m+=sin(b*5.)*.75;\n m+=sin(b*6.)*.5;\n return m*=0.25;//overtones\n}//earthbound mother2 battle horn   https://www.shadertoy.com/view/MljGRd\n//cos+seesaw mix \"earthbound kraken\"\n//[n]notePitch [t]time [o]octave [s]SawTwiddleFactor\nfloat krakenSynth(int n,float t,float o,float s){\n float b=noteFreq(n),m=b*pow2(o-3.-s),q=b*pow2(o+2.);\n m=1.0-mod(t*m,1.0);m=pow(m,8.);//saw wave\n return m*cos(6.2831*t*q)-m;}//mixed with cos wave \nfloat krakenLead(float t){\n float n=t/beatLength,\n s=mod(floor(n),32.),b=floor(n/32.);\n if(fract(n)<.68){\n  float u=floor(s/3.),w=mod(s,3.);\n  if(s>=16.){t=5.-floor((s-16.)/3.);w=mod(s-16.,3.);}if(s>=29.)w++;\n  float o=-u;if(w==2.)o++;\n  int c=3;   if((b>0.)&&(mod(b,2.)==0.))c+=4;\n  return krakenSynth(c,mod(t,beatLength),o,-u);\n }return 0.;}\n//low pitch ship horn, with shitty envelope\nfloat bassSynth(int n,float t){const float l=.5;\n if(t>l)return 0.;\n float b=6.2831*t*noteFreq(n);\n float i=1.-pow(1.-(t/l),32.);//shitty envelope in\n i*=1.-pow(t/l,8.);//shitty envelope out\n return(sin(b*pow2(-6.0))*1.5\n       +sin(b*pow2(-5.0))*.5\n       +sin(b*pow2(-4.0))*.05)*i;}\n//https://www.shadertoy.com/view/MljGRd\n//wailing whale syren.\nfloat wailSynth(int n, float t){\n const float a = 4.0;//start time\n const float e = 32.0;//end time\n float f = max(0.,min(1.0,(t-a)/(e-a)));\n float i=pow(f,2.0);//shitty envelope in\n i*=1.0-(pow(f,2.0));//shitty envelope out\n float b = 6.2831*t*noteFreq(n)*0.25;\n b+=sin(t*4.5)*3.0;\n return(sin(b)\n       +sin(b*3.)\n       +sin(b*4.)*.75)*i;}//https://www.shadertoy.com/view/MljGRd\nfloat krakenWail(float t){float b=t/beatLength;\n int n=(mod(floor(b/32.0),2.0)==0.)?2:3;\n return wailSynth(n,mod(b,32.0));}\nvec2 mainSoundEarthBoundBattle(float t){ \n return vec2(introHorn(0,t));\n return vec2(krakenWail(t));//return vec2(wailSynth(0,t));\n return vec2(bassSynth(60,t));\n return vec2(krakenLead(t));\n}\n\n//https://www.shadertoy.com/view/Xtl3DB\n//buzz electric, with doppler erffect\nfloat ssaw(float t){return 4.0*(abs(fract(t+0.75)-0.5)-0.25);}\nfloat snd(float time){\n\tfloat a1=ssaw(50.0*time);\n\ta1=sign(a1)*pow(abs(a1),1.1+sin(time*20.0));\treturn a1;}\n#define SPEEDOFSOUND 20.0\n#define DAMPING 1.0\nfloat phys(float time, float dist){\n\tfloat tim=time-dist/SPEEDOFSOUND;\n\treturn snd(tim)*exp(-dist*DAMPING);}\nvec2 rep(vec2 p, vec2 a){return abs(mod(p+a,a*2.0)-a);}\nfloat DEL(in vec3 z0){z0.xz=rep(z0.xz,vec2(7.0,6.0));\n\tz0=abs(z0)-vec3(2.74,0.83,2.74);\n\treturn length(z0+vec3(-0.82,0.0,-1.0));}\nvec3 herert(vec3 fw,vec3 up){fw=normalize(fw);return normalize(cross(fw,normalize(up)));}\nvec2 mainSound2(float time){\n\tfloat tim=time*0.25;\n\tvec3 ro=vec3(sin(tim)*(2.0+tim)-4.0,0.5,cos(tim)-4.0);\n\tvec3 rt=0.1*herert(vec3(-4.0,-0.6,-4.0)-ro,vec3(0.0,1.0,0.0));\n\tfloat d1=DEL(ro),d2=DEL(ro+rt);\n\tfloat a1=phys(time,d1),a2=phys(time,d2);\n\treturn vec2(a1,a2);}\n\n\n//bubble noise  //n += note(C4, m, 0.0, 2.0, time);\nfloat noteBubble(float hz, int type, float s, float d, float t) {\n    float f=0.4;\n    s *= f;\n    d *= f;\n    if(t >= s && t <= s+d) {\n        t -= s;\n        float rt = t;\n\t\tt *= CON;\n    \tif(type == 1) {\n            rt = pow(rt+1.0,10.0);\n            if(rt < 1.0) {\n                rt = 1.0;\n            }\n    \t\treturn (sin(t*hz)/rt);\n        } else if(type == 2) {\n            float n = sin(t*hz);\n            n *= fract(rt*hz);\n            return n;\n        } else if(type == 3) {\n            t += sin(t*5.0)*0.005;\n            float n = sin(t*hz);\n            return n;\n        } else if(type == 4) {\n            t *= rt*4.0+0.5;\n        \tfloat n = sin(t*hz);\n            rt = pow(rt*4.0+0.5,20.0);\n            if(rt < 1.0) {\n                rt = 1.0;\n            }\n            return n/rt;\n        }}}//https://www.shadertoy.com/view/XdScDy\n\n\n// base piano\nvec2 Instr1(float de,float time){\n\tfloat f0=440.0*de*0.001953125;\n  \tfloat f1=440.0*de*0.001953125;\n  \tfloat f2=440.0*de*0.001953125;\n  \tfloat a=sin(2.0*f0*pi*time);\n    float b=sin(4.0*f0*pi*time)*0.08;\n    float c=sin(8.0*f0*pi*time)*0.04;\n    float d=sin(16.0*f0*pi*time)*0.002;\n    float e=sin(32.0*f0*pi*time)*0.001;\n    float f=sin(f0*pi*time)*0.02;\n  \treturn vec2((a+b+c+e+f)*0.5*exp(-1.0*time));}\n// bass\nvec2 Instr2(float de,float time){\n\tfloat x=pi*time*2.0;\n\tfloat f0=de*110.0*0.015625;\n    float f1=0.2;\n  \tfloat f2=0.25;\n  \tfloat a=sin(2.0*f0*pi*time);\n  \tfloat c=f1*time+f2*a;\n  \tfloat b=sin(a*c*2.0*pi);\n  \treturn vec2((b)*0.9*exp(-0.3*time)*exp(-0.3*time)*exp(-0.1*time));}\n// light piano\nvec2 Instr3(float de,float time){\n\tfloat f0=440.0*de*0.001953125;\n  \tfloat f1=440.0*de*0.001953125;\n  \tfloat f2=440.0*de*0.001953125;\n  \tfloat a=sin(2.0*f0*pi*time);\n    float b=sin(4.0*f0*pi*time)*0.08;\n    float c=sin(8.0*f0*pi*time)*0.04;\n    float d=sin(16.0*f0*pi*time)*0.002;\n    float e=sin(32.0*f0*pi*time)*0.001;\n    float f=sin(f0*pi*time)*0.02;\n  \treturn vec2((a+b+c+e+f)*0.5*exp(-0.6*time)*exp(-1.0*time));}\n//https://www.shadertoy.com/view/llsSDf\n\n\n\nfloat collisSound(float starttime,float time){ // ball vs ball collision sound\n    float stime = time-starttime;\n    return clamp(sin(stime*(0.18-stime)*10000.0)*exp(stime*-50.0)*3.0,-0.4,0.4);\n}//https://www.shadertoy.com/view/MtSXR1\n\n\nfloat instrumentBanjo( float freq, float time ){\n    freq = 440.0*pow(freq/440.0,1.003); // spread\n    float ph = 1.0;\n    ph *= sin(6.2831*freq*time);\n    ph *= 0.2+0.8*max(0.0,6.0-0.01*freq);\n    ph *= exp(-time*freq*0.2);\n    float y = 0.0;\n    y += 0.70*sin(1.00*6.2831*freq*time+ph)*exp(-0.5*0.007*freq*time);\n    y += 0.20*sin(2.01*6.2831*freq*time+ph)*exp(-0.5*0.011*freq*time);\n    y += 0.20*sin(3.01*6.2831*freq*time+ph)*exp(-0.5*0.015*freq*time);\n    y += 0.16*sin(4.01*6.2831*freq*time+ph)*exp(-0.5*0.018*freq*time);\n    y += 0.13*sin(5.01*6.2831*freq*time+ph)*exp(-0.5*0.021*freq*time);\n    y += 0.10*sin(6.01*6.2831*freq*time+ph)*exp(-0.5*0.027*freq*time);\n    y += 0.09*sin(8.01*6.2831*freq*time+ph)*exp(-0.5*0.030*freq*time);\n    y += 0.07*sin(9.01*6.2831*freq*time+ph)*exp(-0.5*0.033*freq*time);\n    y += 0.45*y*y*y;       \n    y *= 1.0 + 1.5*exp(-8.0*time);\n    y *= clamp( time/0.004, 0.0, 1.0 );\n\n    y *= 2.5-1.5*clamp( log2(freq)/10.0,0.0,1.0);\n\treturn y;\t\n}//banjo (piratey) from https://www.shadertoy.com/view/ldXXDj\n//return vec2(instrumentBanjo(440.,time));\n\n//dr who bass (sans sequence)\nvec2 bass(float time, float tt, float note){\n    if (tt<0.0)\n      return vec2(0.0);\n\n    float freqTime = 6.2831*time*n2f(note);\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(-2.0*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(-2.0*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )*exp(-1.0*tt) );}\n//https://www.shadertoy.com/view/4dSXRm\n\nfloat note(float nr){//dr who themerin sequence\n    if (nr<=15.)  return -120.;\n    if (nr<=16.)  return 31.;\n    if (nr<=17.)  return 56.;\n    if (nr<=22.)  return 55.;\n    if (nr<=23.)  return -120.;\n    if (nr<=24.)  return 58.;\n    if (nr<=25.)  return 42.;\n    if (nr<=30.)  return 43.;\n    if (nr<=33.)  return -120.;\n    if (nr<=34.5)  return 43.;\n    if (nr<=35.5)  return 39.;\n    if (nr<=37.0)  return 31.;\n    if (nr<=39.0)  return 34.;\n    if (nr<=39.5)  return 32.;\n    if (nr<=40.5)  return 31.;\n    if (nr<=41.0)  return -120.;\n    if (nr<=42.5)  return 31.;\n    if (nr<=43.0)  return 44.;\n    if (nr<=46.0)  return 43.;\n    return -120.0;}\n#define RES 0.02\nfloat getSample(float time, float tt, float FM){\n    tt -= mod(tt,RES);\n    float note1 = note(tt);\n    float note2 = note(tt+0.5);\n    if (note1 <0.0)     return 0.0;    \n    float stepper = smoothstep(0.1,0.5,mod(tt,0.5));\n    float note = mix(note1,note2,stepper);    \n    float angle = PI2*n2f(note)*time;\n    return sin(angle+FM*sin(angle*2.033));}\nvec2 theramin(float time, float tt){\n    tt = mod(tt,48.0);\n    tt += 1.33;\n    float FM = 0.0;\n    if (tt>=32.)\n        FM = PI2/2.;\n    float sampl;\n    float ta = mod(tt-RES/2.0,RES)-RES/2.0;\n    float halfSin = RES/4.0;//4.0/frequency;\n    if (abs(ta)<halfSin)    {\n        float sample1 = getSample(time,tt-RES/2.0,FM);\n        float sample2 = getSample(time,tt+RES/2.0,FM);\n        sampl = mix(sample1,sample2,smoothstep(-halfSin,halfSin,ta));\n    }\n    else\n        sampl = getSample(time,tt,FM);\n    \n    return vec2( sampl);}////https://www.shadertoy.com/view/4dSXRm\n\n\nfloat Sin(float x){return sin(x * 3.1415 * 2.0);}\n//sin electric string\nfloat Instrument( const in vec2 vFreqTime ){\n    float f = vFreqTime.x;\n    float t = vFreqTime.y;    \n    if( t < 0.0 ) return 0.0;\n    float x = 0.0;\n    float a = 1.0;\n    float h = 1.0;\n    for(int i=0; i<4; i++){\n        x += Sin( f * t * h ) * exp2( t * -a );\n        x += Sin( f * (t+0.005) * h * 0.5 ) * exp2( t * -a * 2.0 ) ;\n        h = h + 1.01;\n        a = a * 2.0;\n    }return x;}//return vec2(Instrument(vec2(440.,time)));\n//https://www.shadertoy.com/view/MdsGzr\n\n\n\n\nfloat res;//this one writes in a global mutable...\nvoid explosionSound(float time){\n    if (time<0.5 && time>0.0) { // explosion sound\n        float freq = 1000.0 * (1.0-time*2.0);\n        float freqintegrated = 1000.0 * (-time*time*1.0+time);\n        res += noize(float(int(freqintegrated))) ;\n//        res += fract(freqintegrated)>0.5 ? -0.2 : 0.2;\n}}//https://www.shadertoy.com/view/4l2GzR\n\n\n// Sine wave\n//#define sine(freq, time) (sin(6.28318531*time*freq))\n// Saw wave\n//#define saw(freq, time) ((time*freq - floor(time*freq)) * 2.0 - 1.0)\n// Square wave\n//#define square(freq, time) (sign(sin(6.28318531*time*freq)))\n// Triangle wave\n//#define tri(freq, time) (1.0 - abs(mod(freq*time, 1.0)-2.0))\n//https://www.shadertoy.com/view/Mt2GDz\n\nfloat ntof(float n){if(n<12.0)return 0.0;return 440.0 * pow(2.0, (n - 67.0) / 12.0);}\nfloat ssaw2(float t){return 4.0*abs(fract(t)-0.5)-1.0;}\nfloat rnd(float t){return fract(sin(t*341.545234)*1531.2341);}\nfloat srnd(float t){float t2=fract(t);return mix(rnd(floor(t)),rnd(floor(t+1.0)),t2*t2*(3.0-2.0*t2));}\n//https://www.shadertoy.com/view/MlXGDn\n\nfloat osc_noise(float p){p *= 20000.;float F = floor(p), f = fract(p);\n return mix(hash(F), hash(F+1.), f);}\nfloat osc_sine(float p){return sin(p*pi2);}\nfloat osc_saw(float p){return p*2.-1.;}\nfloat osc_square(float p,float x){return -1.+2.*step(x,p);}\nfloat osc_sinefm(float pc, float pm, float b){return sin(pc*pi2+b*sin(pm*pi2));}\nfloat osc_tri(float p, float x){\n float a = smoothstep(0., x, p), b = smoothstep(1., x, p);\n return (a * b) * 2. - 1.;}\n////https://www.shadertoy.com/view/MlfGRM\n\n\n\n//integer modulo\nint imod(int x, int y){return x - (x / y) * y;}\n\n//bitwise square wave\nconst int seq1[] = int[](66,89,125,54,89,66,54,37);\nconst int seq2[] = int[](81,106,125,54,106,81,54,37);\nint g(int i,int x,int t,int o){\n    return((3&x&(i*(((3&i>>16)!=0?seq1[t%8]:seq2[t%8])+51)>>o))<<4);\n}//https://www.shadertoy.com/view/4dlyWl\n\n\n#define BPM 112.\n//same idea but with an AR envelope\nfloat seqAR(float t, float gate, float atk, float rel, float ofst){\n    float p = ((t*PI*BPM/120.)-ofst*TAU-PI*0.5+gate );\n    float tp = fract(p/PI*.5);\n    \n    //The envelopes have to be scaled based on the gate length\n    gate = clamp(gate,-1.,1.);\n    float scl = (1.-abs(gate));\n    atk *= scl;\n    rel *= scl;\n    //Attack envelope\n\tif (tp > 0.5) return smoothstep( gate-atk, gate+atk, cos(p));\n    //Release envelope\n\treturn smoothstep( gate-rel, gate+rel, cos(p));}\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave){\n\treturn sin(t*note*exp2(octave)*PI);}\nfloat saw(float t, float note, float octave){\n\treturn fract(t*note*exp2(octave-1.))-0.5;}\nfloat tri(float t, float note, float octave){\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;}\nfloat sqr(float t, float note, float octave){\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;}\n//simple frequency modulation (3->1)\nfloat fmsq(float t, float note, float octave){\n\tfloat fm = sn(t,note,octave-1.)*0.0008;\n\tfloat fm2 = sn(t,note,octave+1.)*0.0007;\n\tfloat fm3 = sn(t,note,octave+2.)*0.00055;\n\treturn sqr(t+fm+fm2+fm3,note,octave);}\n//very fake filtered saw (not used)\nfloat filterSaw(float t, float note, float octave, float cutoff, float q){\n    float saw = fract(t*note*exp2(octave-1.))-0.5;\n    float sn = cos((t*note*exp2(octave)*PI)+PI*0.5);\n    float filt = smoothstep(cutoff-q,cutoff+q,abs(saw)*2.);\n    return mix(saw,sn,filt);}\n//a slightly more complex intrument using the sequencer for harmonic envelopes\n//freq is how often the note is triggered\nfloat additive(float t, float note, float octave, float freq){\n    float x = t*freq;\n    float rz = 0.;\n    float atk = 0.01;\n    float rel = 1.;\n    float h = 1.;\n    float pw = 1.;\n    float dcy = .0;    \n    for(int i=0;i<6;i++)    {\n        rz += sn(t*h, note, octave)*seqAR(x, dcy ,atk, rel, 0.)*pw;\n        dcy += .1;\n        pw  -= .1;\n        h = float(i)+1.001;\n    }\n    rz = saw(rz*0.002,note,octave)*seqAR(x, .0 ,atk, rel, 0.);\n    return rz;}//https://www.shadertoy.com/view/MdfXW2\n\n\n// regular sine\nfloat wave0(float x){return sin(pi2*x);}\n// half sine + pause\nfloat wave1(float x){return max(sin(x*pi2),0.0);}\n// half sine, double frequency\nfloat wave2(float x){return abs(sin(x*pi2));}\n// quarter sine + pause, double frequency\nfloat wave3(float x) {return abs(sin(x*pi2))*step(fract(x*2.0),0.5);}\n// sine + pause, double frequency\nfloat wave4(float x){return sin(x*pi2*2.0)*step(fract(x),0.5);}\n// half sine + pause, double frequency\nfloat wave5(float x) {return abs(sin(x*pi2*2.0))*step(fract(x),0.5);}\n// square wave\nfloat wave6(float x) {return step(fract(x),0.5)*2.0-1.0;}\n// saw wave\nfloat wave7(float x) {return 1.0 - 2.0*fract(x);}\n// normalizes arguments so the sum is 1\nvec4 normsum(vec4 p) {return p / (p.x+p.y+p.z+p.w);}\n//https://www.shadertoy.com/view/ll23RK\n// v = vec4(attack,decay,hold,release), s = sustain amplitude\nfloat adsr(float t, vec4 v, float s) {\n    v.xyw = max(vec3(2.2e-05),v.xyw);\n    // attack term\n    float ta = t/v.x;\n    // decay / sustain amplitude term\n    float td = max(s, 1.0-(t-v.x)*(1.0-s)/v.y);\n    // length / release term\n    float tr = (1.0 - max(0.0,t-(v.x+v.y+v.z))/v.w);\n    return max(0.0, min(ta, tr*td));\n}//https://www.shadertoy.com/view/ll23RK\n\n#define C 1046.50\n#define D 1174.66\n#define E 1318.51\n#define F 1396.91\n#define G 1567.98\n#define A 1760.00\n#define B 1975.53\n#define C2 2093.00\nfloat[] notes = float[](C, D, E, F, G, A, B, C2); \nfloat note(int idx, int octave, float amp, float t) {\n\treturn amp*sin(exp2(float(octave))*notes[idx%8]*mod(t,2.0)*6.28318*0.2);   \n}//https://www.shadertoy.com/view/ldXBzH\nfloat noteSaw(int idx, int octave, float amp, float t) {\n\treturn amp*tan(sin(exp2(float(octave))*notes[idx%8]*mod(t,2.0)*6.28318*0.2));   \n}//https://www.shadertoy.com/view/ldXBzH\nfloat noteSquare(int idx, int octave, float amp, float t) {\n\treturn 3.0*amp*pow(fract(exp2(float(octave))*notes[idx%8]*floor(mod(4.0*t,2.0)+1.0)*mod(t,2.0)*0.05)-0.5,1.0);   \n}//https://www.shadertoy.com/view/ldXBzH\n\n\nfloat rand(float t){\n    return fract(sin(t*1793.326) * 43758.5453);\n}//https://www.shadertoy.com/view/XscXzn\n//hihat\n//f+=rand(time)*0.5*pow(1.0-t2,16.0);*/\n\n#define TT(d) mod(mod(time,1.0)-d,1.0)\n//https://www.shadertoy.com/view/XscXzn\n\n//electric base guitar, electric shaver\nfloat bs(float time,int note){\n    float baseFreq=1.0;\n    \n    int globalTranspose=0;\n    note+=globalTranspose;\n    \n    float base_a4=110.0;\n    float freq=base_a4*pow(2.0,float(note)/12.0)*baseFreq;\n    \n    float t=1.0-(time*1.0);\n    t=max(t,0.0);\n\t\n    //float PI=3.141592;\n    //create sqr duty wave\n    float duty=cos(time*4.0)/PI;\n    duty=duty*0.5+0.5;\n    float f1=fract(t*freq);\n    float f2=fract(duty+t*freq);\n    float f=f1-f2;\n    f= clamp(f,-1.0,1.0);\n    \n\tfloat t2=time*baseFreq;\n    f*=pow(max(0.0,1.0-(t2*2.0)),3.0);\n\n    return f;\n}//https://www.shadertoy.com/view/XscXzn\n\nint globalTranspose=0;\nfloat baseFreq=1.0;\nfloat globalTime=0.0;\n//float PI=3.141592;\nfloat speed=1.2;\n\n//precision instrument elemet.\nfloat ws(float x,float a){\n\treturn x*(abs(x) + a)/(x*x + (a-1.0)*abs(x) + 1.0);\n}//https://www.shadertoy.com/view/XscXzn\n\n//snare drum (high pitch)\nfloat sn(float _time){\n    float freq=680.0*baseFreq;\n\tfloat c=0.0;\n    const int  num=11;\n    for (int i=0;i<num;i++)\n    {\n        float time=_time-float(i)*(0.09+float(i)*0.01);\n\n        if (time<0.0) continue;\n        float t=1.0-(time*1.0);\n        t=max(t,0.0);\n        t=pow(t,2.0);\n        float f=sin(t*freq)/PI;\n    \tf=ws(f,2.9);\n        t=time*baseFreq;\n        f*=pow(max(0.0,1.0-(t*6.0)),4.0);\n        f+=rand(time)*0.4*pow(1.0-t,20.0);\n    \tf=ws(f,1.9);\n\t    f= clamp(f,-1.0,1.0);\n        f*=0.7;\n        c+=f/float(1+(i*i*4));\n    }\n    \n    return c*0.35;        \n}//https://www.shadertoy.com/view/XscXzn\n\nfloat bd(float time){\n    float freq=100.0*baseFreq;\n    float vol=0.4;\n    float depth=4.0;\n\n    float t=1.0-(time*4.0);\n    t=max(t,0.0);\n    t=pow(t,depth);\n    float f=cos(t*freq)/PI;\n    \n    float t2=time*baseFreq;\n    \n    f*=pow(1.0-t2,8.0);\n//    f=ws(f,2.0);\n    f+=rand(time)*pow(1.0-t2,1464.0)*0.5;\n\n    return clamp(f*vol,-1.0,1.0);\n}//https://www.shadertoy.com/view/XscXzn\n\nfloat drums(float t)\n{\n    float c=0.0;\n\n    float n = 0.0, b = 0.0, x = 0.0;\n    #define BD(d)   c+=bd(TT(d));\n    #define SN(d)   c+=sn(TT(d));\n\t\n    float time=mod(t,4.0);\n\n    if (time<1.0)\n    {\n        BD(0.0);\n        SN(0.5);\n        BD(0.75);\n    }\n\telse\n    if (time<2.0)\n    {\n        BD(0.0);\n        SN(0.5);\n    }\n\telse\n    if (time<3.0)\n    {\n        BD(0.0);\n        SN(0.5);\n        BD(0.75);\n    }\n    else\n    if (time<4.0)\n    {\n        BD(0.0);\n        SN(0.25);\n        SN(0.5);\n        SN(0.75);\n    }    \n    return c;\n}//https://www.shadertoy.com/view/XscXzn\n\n//looks like square wave, 3 voices and echo\nfloat ap(float _time,int note[3],float speed,float delay){\n    note[0]+=globalTranspose;\n    note[1]+=globalTranspose;\n    note[2]+=globalTranspose;\n    float base_a4=440.0;\n    float c=0.0;\n    for (int i=0;i<3;i++){//loop for echo\n        float time=_time+float(i)*delay;\n        float freq=base_a4*pow(2.0,float(note[i])/12.0)*baseFreq;\n        freq*=speed;\n\n        //vibrato\n        float vibratoDelay=0.1;\n        freq+=1.0+sin(time*20.0*speed)/PI*0.0005*freq*step(0.0,time-vibratoDelay);\n\n        float t=1.0-(time*1.0);\n        t=max(t,0.0);\n\n        //create sqr duty wave\n        float duty=cos(time*5.0)/PI;\n        float f1=fract(t*freq);\n        float f2=fract(duty+t*freq);\n        float f=f1-f2;\n        f= clamp(f,-1.0,1.0);\n\n        float t2=time*baseFreq;\n        f*=pow(max(0.0,1.0-(t2*1.0)),1.5);\n        \n        c+=f;\n    }return c;}//https://www.shadertoy.com/view/XscXzn\n\nfloat arp(float t){\n    float c=0.0;\n    float speed=4.0;\n    float delay=-0.4;\n\n    #define ARP(d,n)   c+=ap(TT(d),n,1.0/speed,delay);\n    \t\n    float time=mod(t*speed,4.0*speed);\n\t\n    float  g=time/speed;\n    int i[3];\n    if (g<1.0)\n\t    {i[0]=0;i[1]=3;i[2]=7;ARP(0.0,i);}\n\telse if (g<2.0)\n    \t{int a=-2;i[0]=0+a;i[1]=4+a;i[2]=7+a;ARP(0.0,i);}\n\telse if (g<3.0)\n    \t{int a=-4;i[0]=0+a;i[1]=4+a;i[2]=7+a;ARP(0.0,i);}\n\telse if (g<4.0)\n    \t{int a=-4;i[0]=0+a;i[1]=4+a;i[2]=7+a;ARP(0.0,i);}\n\n    return c*0.4;}//https://www.shadertoy.com/view/XscXzn\n\n//sine wave with vibrato, nice lead (background).\nfloat ld(float time,int note,float speed,float arpVolume){\n    note+=globalTranspose;    \n    float base_a4=440.0;\n    float freq=base_a4*pow(2.0,float(note)/12.0)*baseFreq;\n    freq*=speed;    \n    freq+=freq*step(mod(time,0.1),0.05)*arpVolume;\n\t\n    //vibrato\n    float vibratoDelay=0.2;\n    freq+=1.0+sin(time*20.0*speed)/PI*0.001*freq*step(0.0,time-vibratoDelay);\n\n    float t=1.0-(time*1.0);\n    t=max(t,0.0);\n\t\n    //create sqr duty wave\n    float duty=cos(time*2.0+globalTime*0.5)/PI;\n    duty=duty*0.2+0.8;\n    float f1=fract(t*freq);\n    float f2=fract(duty+t*freq);\n    float f=f1-f2;\n    f= clamp(f,-1.0,1.0);\n    \n\tfloat t2=time*baseFreq;\n    f*=pow(max(0.0,1.0-(t2*1.0)),1.5);\n\n    //hihat\n    //f+=rand(time)*0.2*pow(1.0-t2,16.0);\n    return f;}\n\nfloat lead(float t,float arpVolume){\n    float c=0.0;\n    float speed=0.5;\n\n    #define LD(d,n)   c+=ld(TT(d),n,1.0/speed,arpVolume)*step(0.0,time-d);\n   \n    float time=mod(t*speed,32.0);\n    if (time>8.0 && time<16.0)time-=8.0;\n\n    int i=0;\n    float f=0.0;\n    if (time<1.0)\n    {\n        LD(0.0,i);\n        LD(0.5,i+2);\n\t}\n\telse\n    if (time<2.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i+3);\n        LD(0.125*1.0,i+5);\n        LD(0.125*3.0,i);\n        LD(0.125*5.0,i-2);\n\t}\n\telse\n    if (time<3.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i);\n        LD(0.5,i+2);\n    }\n    else\n    if (time<4.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i+3);\n        LD(0.125*1.0,i+5);\n        LD(0.125*3.0,i+10);\n        LD(0.125*5.0,i+7);\n    }\n    else\n    if (time<5.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i);\n        LD(0.5,i+2);\n\t}\n\telse\n    if (time<6.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i+3);\n        LD(0.125*1.0,i+5);\n        LD(0.125*3.0,i);\n        LD(0.125*5.0,i-2);\n\t}\n\telse\n    if (time<7.0)\n    {\n\t\ttime=fract(time);\n        LD(0.0,i);\n        LD(0.5,i-2);\n    }\n    else\n    if (time<8.0)\n    {\n\t\ttime=fract(time);\n        i=-12;\n        LD(0.0,i+7);\n        LD(0.125*1.0,i+10);\n        LD(0.125*2.0,i+5);\n        LD(0.125*3.0,i+7);\n    }\n    return c;\n}\n\n\n//Simple mixing function with balance control  (balance range 0..1)\nvec2 mixb(float x, float bal){bal = clamp(bal,0.,1.);\n return vec2(x * bal, x*(1.-bal));}\n//https://www.shadertoy.com/view/MdfXW2\n\n\n//looks like envelopes\nfloat env_ar(float t, float a, float r){return smoothstep(0.,a,t)*smoothstep(r,0.,t-a);}\nfloat env_asr(float t, float ts, float a, float r) {\n    return smoothstep(0.,a,t)*smoothstep(r,0.,t-a-ts);}\n//https://www.shadertoy.com/view/MlfGRM\n\n\n// A hacky linear decay\nfloat decay(float seqTime, float start, float length, float amount){\n    return 1.0 - clamp((seqTime - start) / length, 0.0, amount);}\n//https://www.shadertoy.com/view/Mt2GDz\n\n// Pans the given instrument by a certain amount\n// Set amount to -1.0 for left-panning, set to 0.0 for center, set to 1.0 for right-panning\nvec2 pan(float inst, float amount){\n    amount = (amount + 1.0) / 2.0;\n    return vec2(inst * (1.0 - amount), inst * amount);}\n//https://www.shadertoy.com/view/Mt2GDz\n\n\nvec2 mainSound( in int samp, float t )\n{\n     t=mod(t,32.);\n    return .2*vec2(lead(t,.0));\n    return .2*vec2( sin(6.2831*440.0*t)*.1 );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}