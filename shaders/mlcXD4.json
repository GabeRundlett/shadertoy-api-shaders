{
    "Shader": {
        "info": {
            "date": "1685570241",
            "description": "moving poles in laplace transform of an ODE\nBlue is real\nred is imaginary\n\nBecause behind each ODE there is a flower :)",
            "flags": 0,
            "hasliked": 0,
            "id": "mlcXD4",
            "likes": 1,
            "name": "Laplace Transform moving poles",
            "published": 3,
            "tags": [
                "laplacetransform"
            ],
            "usePreview": 0,
            "username": "supernlogn",
            "viewed": 140
        },
        "renderpass": [
            {
                "code": "\nconst vec2 c_i = vec2(0,1);\nconst float PI = 3.1415926535897;\nconst int numberOfLeaves = 8;\nconst int X = numberOfLeaves/2;\nvec2 c_cjg(in vec2 c) {\nreturn vec2(c.x, -c.y);\n}\n\nvec2 c_mul(in vec2 a, in vec2 b) {\nreturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 c_pow(in vec2 c, int p) {\n    vec2 temp = vec2(1.0,0.0);\nfor (int i = 0; i < p; ++i) {\ntemp = c_mul(temp, c);\n}\n    return temp;\n}\nvec2 c_div(in vec2 a, in vec2 b) {\n    return\n        vec2(a.x*b.x + a.y*b.y,\n             a.y*b.x - a.x * b.y)\n        / (b.x * b.x + b.y * b.y)\n        ;\n}\nvec2 c_exp(in vec2 c) {\n    return exp(c.x) * vec2(cos(c.y),sin(c.y));\n}\n//uses the even-odd split formula, there are probably better ways\nvec2 c_sin(in vec2 c) {\n    return\n        c_div(\n        c_exp(c_mul(c_i , c))\n            -c_exp(c_mul(-c_i , c))\n            ,\n            2.*c_i\n\n        );\n}\nvec2 c_cos(in vec2 c) {\n    return\n        c_div(\n        c_exp(c_mul(c_i , c))\n            +c_exp(c_mul(-c_i , c))\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\nvec2 c_sinh(in vec2 c) {\n    return\n        c_div(\n        c_exp(c)\n            -c_exp(-c)\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\nvec2 c_cosh(in vec2 c) {\n    return\n        c_div(\n        c_exp(c)\n            +c_exp(-c)\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\n\nvec2 c_add(in vec2 c, float r)\n{\nreturn vec2(c.x+r, c.y);\n}\n\nvec2 func(in vec2 xy)\n{\n    float omega = 0.4;\n    vec2 s = vec2(xy.y,xy.x) - vec2(0.50,0.450);\n    float pole1 = 10.00 * cos(omega * iTime);\n    float pole2 = 5.0 * sin(omega * iTime);\n    vec2 preret = c_div(vec2(1,0), c_mul(c_pow(c_div(s,vec2(0.5,0)),X),c_mul(c_add(s,pole1), c_add(s,pole2))));\n    vec2 ret = preret;\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 complex_val = func(uv);\n    // Time varying pixel color\n    vec3 col;    \n    col = 0.1 + abs(complex_val.x) *vec3(0.0,0.784,0.635) + abs(complex_val.y) * vec3(0.784, 0.635, 0.784);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}