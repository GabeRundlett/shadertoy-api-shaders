{
    "Shader": {
        "info": {
            "date": "1631627240",
            "description": "I was listening to Blood Dragon Theme when the 2nd challenge was announced, so why not mix it with some speed?\nhttps://www.shadertoy.com/events/competition2016",
            "flags": 96,
            "hasliked": 0,
            "id": "Ndy3Dw",
            "likes": 7,
            "name": "Fork [SH16B] Sp oneWisdom 194",
            "published": 3,
            "tags": [
                "retro",
                "demo",
                "challenge",
                "speed",
                "drive",
                "80",
                "shadertoycompetition",
                "sh16b"
            ],
            "usePreview": 0,
            "username": "oneWisdom",
            "viewed": 449
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    // chromatic abberation\n    float caStrength\t= 0.005;\n    vec2 caOffset \t\t= screenUV - 0.5;\n\tvec2 caUVG\t\t\t= screenUV + sin(iTime)*sin(iTime)*sin(iTime)+ caOffset * caStrength;\n\tvec2 caUVB\t\t\t= screenUV + sin(iTime)*sin(iTime)+ caOffset * caStrength * 2.0;\n\n    vec3 color;\n    color.x = texture( iChannel0, screenUV ).x;\n    color.y = texture( iChannel0, caUVG ).y;\n    color.z = texture( iChannel0, caUVB ).z;    \n    \n    fragColor = vec4( color, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Scene traycing\n\n//#define DEBUG_CAMERA\n//#define DEBUG_LIGHTING\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat gMaterial     \t\t= 0.0;\nfloat gTime         \t\t= 0.0;\nfloat gCarOffset    \t\t= 0.0;\nfloat gStreetLampDist\t\t= 100000.0;\nfloat gCarLampDist\t\t\t= 100000.0;\nfloat gReflStreetLampDist\t= 100000.0;\nfloat gFogDensity\t\t\t= 0.1;\nfloat gFogHeightFalloff\t\t= 0.1;\n\nconst float MTRL_ROAD           = 1.0;\nconst float MTRL_BUILDING       = 2.0;\nconst float MTRL_CAR            = 3.0;\nconst float MTRL_STREETLAMPS    = 4.0;\nconst float MTRL_TUNNEL\t\t\t= 5.0;\nconst float INTERIOR_START      = 59.0;\nconst float INTERIOR_END        = 67.0;\n\nfloat Saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat Torus( vec3 p, float r, float h )\n{\n    vec2 q = vec2( length( p.yz ) - h, p.x );\n    return length( q ) - r;\n}\n\nfloat Plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat HexPrism( vec3 p, float h, float r )\n{\n    vec3 q = abs( p );\n    return max( q.z - r, max( ( q.x * 0.866025 + q.y * 0.5 ), q.y ) - h );\n}\n\nfloat Rectangle( vec2 p, vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat RepeatAngle( inout vec2 p, float n ) \n{\n\tfloat angle = 2.0 * MATH_PI / n;\n\tfloat a = atan( p.y, p.x ) + angle / 2.0;\n\tfloat r = length( p );\n\tfloat c = floor( a / angle );\n\ta = mod( a, angle ) - angle / 2.;\n\tp = vec2( cos( a ), sin( a ) ) * r;\n\treturn c;\n}\n\nfloat Circle( vec2 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat Intersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n    vec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n    return min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat SubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float r ) \n{\n    vec2 u = max( vec2( r - a, r - b ), vec2( 0.0, 0.0 ) );\n    return max( r, min( a, b ) ) - length( u );\n}\n\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Rand( vec2 co )\n{\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat StreetLamps( vec3 p )\n{\n    p = abs( p );\n    \n    float rx = 50.0;\n    p.x = mod( p.x, rx ) - 0.5 * rx;\n    p.z -= 15.0;\n    \n    float a = Box( p, vec3( 0.3, 12.0, 0.3 ) );\n    \n    p += vec3( 0.0, -12.7, 3.5 );\n    Rotate( p.yz, -0.4 * MATH_PI );\n    float b = Box( p, vec3( 0.5, 4.0, 0.3 ) );\n    \n    float bloom = Box( p + vec3( 0.0, -0.5, 0.6 ), vec3( 0.5, 3.0, 0.1 ) );\n    gStreetLampDist = min( gStreetLampDist, bloom );\n    \n    return Union( a, b );\n}\n\nfloat Pyramid( vec3 p, float h ) \n{\n    vec3 q = abs( p );\n    return max( -p.y, ( q.x + q.y + q.z - h ) / 3.0 );\n}\n\nfloat Pyramids( vec3 p )\n{    \n    p += vec3( -1220.0, 0.0, 0.0 );    \n    vec3 t = p;\n\n    float rx = 200.0;\n    float rz = 150.0;\n    t.x = t.x > 0.0 ? mod( t.x, rx ) - 0.5 * rx : t.x;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    \n    Rotate( t.xz, 0.5 );        \n    float a = Pyramid( t, 30.0 );\n    \n    t = p;\n\n    rx = 400.0;\n    rz = 300.0;\n    t.x = t.x > 0.0 ? mod( t.x, rx ) - 0.5 * rx : t.x;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    \n    Rotate( t.xz, 0.5 );        \n    float b = Pyramid( t, 80.0 );    \n    \n    return Union( a, b );\n}\n\nfloat Obelisks( vec3 p )\n{    \n    p += vec3( -1220.0, -50.0, 0.0 );       \n    \n    float rx = 200.0;\n    float rz = 150.0;\n    p.x = mod( p.x, rx ) - 0.5 * rx;\n    p.z = mod( p.z, rz ) - 0.5 * rz;\n    \n    Rotate( p.xz, 0.5 + gTime * 1.5 );\n    float a = Pyramid( p, 30.0 );\n    Rotate( p.xz, -1.0 - gTime * 3.0 );\n    \n    p.y += 7.0;\n    \n    Rotate( p.yx, -MATH_PI );\n    float b = Pyramid( p, 20.0 );    \n    \n    return Union( a, b );\n}\n\nfloat Buildings( vec3 p )\n{        \n    vec3 t = p;\n    float rx = 200.0;\n    float rz = 100.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float a = HexPrism( t.xzy, 18.0, 40.0 );\n    float at = HexPrism( t.xzy, 12.0, 50.0 );\n    a = Substract( a, at );    \n    \n    t = p + vec3( 100.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float b = Box( t, vec3( 20.0, 66.0, 20.0 ) );\n    float bt = Box( t + vec3( 0.0, -66.0, 0.0 ), vec3( 15.0, 6.1, 15.0 ) );\n    b = Substract( b, bt );\n    \n    rz = 200.0;\n    t = p + vec3( 150.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float c = Box( t, vec3( 20.0, 99.0, 20.0 ) );\n    \n    rz = 200.0;\n    t = p + vec3( 50.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float d = Cylinder( t, 20.0, 4.0 * 33.0 );\n    \n    return Union( Union( Union( a, b ), c ), d );\n}\n\nfloat Car( vec3 p )\n{        \n    p.x = -p.x;     \n    p.y -= 0.3;\n    \n    float a = Box( p, vec3( 4.2, 0.9, 1.8 ) );   \n    \n    vec3 t = p + vec3( -6.0, 0.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float b = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -5.0, 0.0, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float c = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 2.0, -0.2, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float d = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 2.0, -0.3, 0.0 );\n    Rotate( t.yx, -0.05 );\n    float e = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 2.0, 1.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float f = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );     \n    \n    t = p;\n    t.z = abs( t.z );\n    t += vec3( -3.9, -0.6, 0.0 );\n    float spoiler = Box( t, vec3( 0.2, 0.05, 1.7 ) );\n    spoiler = Union( spoiler, Box( t - vec3( 0.0, -0.25, 1.4 ), vec3( 0.2, 0.3, 0.15 ) ) );\n    \n    float bloom = Box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\n    gCarLampDist = min( gCarLampDist, bloom );\n    \n    t = p + vec3( 1.0, -0.6, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float frontWindow = Box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float backWindow = Box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = Union( Substract( a, Union( Union( Union( b, c ), Intersect( d, e ) ), f ) ), spoiler );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    Rotate( t.yz, -0.9 );\n    float sideCutPlanes = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = SubstractChamfer( body, Union( backWindow, frontWindow ), 0.1 );\n    body = SubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.7 );\n    float wheel = Cylinder( t, 0.7, 1.0 );\n    body = Substract( body, wheel );\n    \n    wheel = Substract( Cylinder( t, 0.55, 0.3 ), Sphere( t + vec3( 0.0, -0.15, 0.0 ), 0.35 ) );\n    \n    body = Union( body, wheel );\n    \n    return body;\n}\n\nfloat Curb( vec3 p )\n{\n    float y = p.y - 0.5;\n    float z = -abs( p.z ) + 14.0;    \n    return max( y, z );   \n}\n\nfloat Tunnel( vec3 p )\n{\n    vec3 t = p;\n    t += vec3( -2510.0, 0.0, 0.0 );\n    float a = Box( t, vec3( 200.0, 16.0, 50.0 ) );\n    float b = Box( t, vec3( 201.0, 14.0, 16.0 ) );    \n    a = Substract( a, b );\n        \n    t = p;\n    t += vec3( -7870.0, 0.0, 0.0 );\n    float c = Box( t, vec3( 200.0, 16.0, 50.0 ) );\n    float d = Box( t, vec3( 201.0, 14.0, 16.0 ) );    \n    c = Substract( c, d );\n    \n    float rx = 12.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = abs( t.z );\n    b = Box( t + vec3( 0.0, 0.0, -16.0 ), vec3( 4.0, 12.0, 2.0 ) );   \n    \n    return Substract( Union( a, c ), b );\n}\n\nfloat CarInterior( vec3 p )\n{\n    p.y -= 3.0;\n    \n    vec3 t = p;\n    Rotate( t.xy, -0.7 );\n    float wheel     = Torus( t + vec3( 0.0, 3.2, 2.0 ), 0.24, 2.4 );\n    vec3 s = t + vec3( 0.0, sin( 0.3 * t.z - 1.7 ) * 0.3 + 0.1, 0.0 );\n    float dashboard = Box( s + vec3( -1.6, 2.0, 0.0 ), vec3( 0.8, 2.0, 10.0 ) );\n    Rotate( t.xy, 0.3 );\n    float d         = Box( t + vec3( -0.1, 2.2, 0.8 ), vec3( 1.0, 1.2, 7.0 ) );\n    dashboard = SubstractRound( dashboard, d, 0.4 );\n    \n    return Union( wheel, dashboard );\n}\n\nfloat TerrainAO( vec3 p )\n{\n    float ret = 1.0;\n    \n    vec3 t = p + vec3( -gCarOffset, -1.0, -3.0 );\n    float car = Box( t, vec3( 2.8, 5.0, 1.6 ) );\n    ret = min( ret, smoothstep( 0.0, 1.0, car * 0.9 ) );\n  \n    t = abs( p );\n    float rx = 50.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.y -= 2.0;\n    t.z -= 15.0;\n    float streetLamps = Cylinder( t, 0.2, 2.0 );\n    ret = min( ret, smoothstep( 0.0, 1.0, streetLamps * 0.1 ) );\n    \n    t = p;\n    rx = 200.0;\n    float rz = 100.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float buildings = HexPrism( t.xzy, 18.0, 40.0 );        \n    \n    t = p + vec3( 100.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    buildings = Union( buildings, Box( t, vec3( 20.0, 66.0, 20.0 ) ) );\n    \n    rz = 200.0;\n    t = p + vec3( 150.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    buildings = Union( buildings, Box( t, vec3( 20.0, 99.0, 20.0 ) ) );\n    \n    rz = 200.0;\n    t = p + vec3( 50.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    buildings = Union( buildings, Cylinder( t, 20.0, 4.0 * 33.0 ) );\n    \n    ret = min( ret, smoothstep( 0.0, 1.0, buildings * 0.05 ) );\n    return mix( ret, 1.0, 0.5 );\n}\n\nfloat Scene( vec3 p )\n{    \n    float terrain   = Union( Plane( p, vec4( 0.0, 1.0, 0.0, 0.0 ) ), Curb( p ) );\n    float tunnel    = Tunnel( p );\n    \n    if ( gTime >= 77.0 )\n    {\n        vec3 t = p;\n        t.z = abs( p.z );\n        terrain = Substract( terrain, Plane( t, vec4( 0.0, 0.0, -1.0, 18.0 ) ) );\n        terrain = Union( terrain, Box( t + vec3( -7700.0, 0.0, -20.0 ), vec3( 10000.0, 3.0, 2.0 ) ) );\n    }\n\n    float buildings = gTime <= 25.0 ? Pyramids( p ) : ( gTime < 77.0 ? Buildings( p ) : Obelisks( p ) );\n    float streetLamps = StreetLamps( p );\n    \n    p += vec3( -gCarOffset, -1.0, -3.0 );\n    float car = gTime > INTERIOR_START && gTime < INTERIOR_END ? CarInterior( p ) : Car( p );\n                        \n    float ret = Union( Union( Union( Union( terrain, buildings ), streetLamps ), car ), tunnel );\n\n    gMaterial = MTRL_TUNNEL;    \n\tgMaterial = terrain \t<= ret ? MTRL_ROAD \t\t\t: gMaterial;\n    gMaterial = buildings \t<= ret ? MTRL_BUILDING\t\t: gMaterial;\n    gMaterial = car \t\t<= ret ? MTRL_CAR \t\t\t: gMaterial;\n    gMaterial = streetLamps <= ret ? MTRL_STREETLAMPS \t: gMaterial;\n \n    return ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 500.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 64; ++i )\n    {\n        if ( h < 0.01 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = Scene( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.01, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),\n        Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),\n        Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );\n    return normalize( -nor );\n}\n\nfloat SpeedMeterY( vec2 p )\n{\n    p -= vec2( 4.0, 3.8 );\n    float d = Circle( p, 0.02 );\n    \n\tvec2 t = p;\n    RepeatAngle( t, 8.0 );\n    d = min( d, Rectangle( t + vec2( -0.7, 0.0 ), vec2( 0.08, 0.01 ) ) );\n    \n    t = p;\n    Rotate( t.xy, 0.4 );\n    RepeatAngle( t, 8.0 );\n    d = min( d, Rectangle( t + vec2( -0.7, 0.0 ), vec2( 0.03, 0.01 ) ) );\n    d = max( d, -Circle( p + vec2( 0.0, 0.71 ), 0.51 ) );\n    \n    return d;\n}\n\nfloat SpeedMeterR( vec2 p, float t )\n{\n    p -= vec2( 4.0, 3.8 );\n\n    Rotate( p.xy, t + 0.5 + 0.5 * sin( t + 2.0 * gTime ) );\n    float d = Rectangle( p + vec2( -0.32, 0.0 ), vec2( 0.18, 0.01 ) );\n    \n    return d;\n}\n\nvec3 Dashboard( vec3 p3 )\n{\n    p3.x -= gCarOffset;\n    \n    vec2 p;\n    p.x = p3.z;\n    p.y = p3.y * 1.3 + 1.8;\n\n\tvec3 color \t= vec3( 0.0 );\n    vec3 yellow = vec3( 0.9, 0.7, 0.1 );\n    vec3 red \t= vec3( 1.0, 0.1, 0.4 );\n    vec3 purple\t= vec3( 0.54, 0.42, 0.78 );\n    \n    float dy = min( SpeedMeterY( p ), SpeedMeterY( p + vec2( 2.0, 0.0 ) ) );\n    \n    float horBarsY = 100000.0;\n    // yellow horizontal bars\n    for ( int i = 0; i < 4; ++i )\n    {\n        float ampl\t= texture( iChannel3, vec2( ( 2.0 * float( i ) + 1.5 ) / 8.0, 0.25 ) ).x;\n        float sizeX = 0.7 * floor( Saturate( 1.4 * sqrt( ampl ) ) * 6.0 ) / 6.0;\n        horBarsY = min( horBarsY, Rectangle( p - vec2( 7.3 + sizeX, 3.05 + float( i ) * 0.4 ), vec2( sizeX, 0.03 ) ) );\n    }\n    \n    float dr = 100000.0;\n    // vertical bars\n    for ( int i = 0; i < 3; ++i )\n    {\n        float sy = 0.45 + floor( ( 0.1 * ( 3.0 * sin( 14.0 * gTime ) + sin( 7.0 * gTime ) ) ) / 0.2 ) * 0.2;\n\t\tsy *= i == 1 ? 1.0 : 0.39;\n\t\tdr = min( dr, Rectangle( p - vec2( 5.6 + float( i ) * 0.4, 3.8 ), vec2( 0.1, sy ) ) );\n    }\n    \n    vec2 t = p;\n    t.y = mod( t.y, 0.2 ) - 0.5 * 0.2;\n\tfloat di = Rectangle( t, vec2( 100.0, 0.06 ) );\n    dr = max( dr, -di );\n    \n    dr = min( dr, min( SpeedMeterR( p, 0.0 ), SpeedMeterR( p + vec2( 2.0, 0.0 ), 1.0 ) ) );\n\n    // red horizontal bars\n    float horBarsR = 100000.0;\n    for ( int i = 0; i < 4; ++i )\n    {\n        float ampl\t= texture( iChannel3, vec2( ( 2.0 * float( i ) + 0.5 ) / 8.0, 0.25 ) ).x;\n        float sizeX = 0.7 * floor( Saturate( 1.4 * sqrt( ampl ) ) * 6.0 ) / 6.0;\n        sizeX = 0.7 * floor( sizeX * 6.0 ) / 6.0;\n        horBarsR = min( horBarsR, Rectangle( p - vec2( 7.3 + sizeX, 3.225 + float( i ) * 0.4 ), vec2( sizeX, 0.03 ) ) );\n    }    \n    \n    // horizontal bar segments\n    t = p;\n    t.x += 0.2;\n    t.x = mod( t.x, 0.26 ) - 0.5 * 0.26;\n\tdi = Rectangle( t, vec2( 0.06, 100.0 ) );\n    dr = min( dr, max( horBarsR, -di ) );\n    dy = min( dy, max( horBarsY, -di ) );\n    \n    float dp = 100000.0;\n    p.x = mod( p.x, 2.0 ) - 1.0;\n    dp = min( dp, Rectangle( p - vec2( 0.0, 3.8 ), vec2( 0.01, 1.2 ) ) );\n    \n    color += 2.0 * yellow \t* Saturate( exp( -dy * 40.0 ) );\n    color += 1.5 * red \t\t* Saturate( exp( -dr * 40.0 ) );\n    color += 1.0 * purple\t* Saturate( exp( -dp * 40.0 ) );\n    return p3.x - p3.y * 0.3 > -0.7 ? color : vec3( 0.0 );\n}\n\nmat3 CameraLookAt( vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize( ta - ro);\n    vec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n    vec3 cu = normalize( cross( cw, cp ) );\n    vec3 cv = normalize( cross( cu, cw ) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 Sky( vec3 rayDir )\n{\n    // sky and sun\n    vec3 skyPos     = rayDir;\n    vec2 skyAngle   = vec2( atan( skyPos.z, skyPos.x ), acos( skyPos.y ) );\n\n    float sun = 1.0 - clamp( 6.0 * length( skyAngle - vec2( 0.0, 1.5 ) ) - 1.0, 0.0, 1.0 );\n    float sky = clamp( 1.0 - 1.5 * skyPos.y, 0.0, 1.0 );\n\n    float sunLines = 1.0 - clamp( sin( skyPos.y * skyPos.y * 500.0 ), 0.0, 1.0 );\n    vec3 sunColor = mix( vec3( 1.0, 0.2, 0.5 ), vec3( 1.0, 0.2, 0.0 ) * 4.0, clamp( skyPos.y * 6.0, 0.0, 1.0 ) );\n    sun *= gTime > 0.3 ? 3.0 - 2.0 * smoothstep( 0.0, 1.0, ( gTime - 0.3 ) * 0.5 ) : 1.0;\n    vec3 color = vec3( 0.54, 0.42, 0.78 ) * 0.2 * sky * 4.0 + sunColor * sun * sunLines;\n\n    // stars\n    vec2 starTile   = floor( skyAngle.xy * 20.0 );\n    vec2 starPos    = fract( skyAngle.xy * 20.0 ) * 2.0 - 1.0;\n    float starRand  = Rand( starTile + vec2( 0.1, 0.3 ) );\n    starRand = starRand > 0.9 ? starRand : 0.0;\n    color += vec3( 2.0 ) * starRand * clamp( 1.0 - ( 6.0 + 3.0 * sin( gTime * 2.0 + 20.0 * skyAngle.y ) ) * length( starPos ), 0.0, 1.0 ) * ( sun > 0.0 ? 0.0 : 1.0 );\n    return color;\n}\n\nfloat SceneRefl( vec3 p )\n{\n    p = abs( p );\n    \n    float rx = 50.0;\n    p.x = mod( p.x, rx ) - 0.5 * rx;\n    p.z -= 15.0;\n    \n    float a = Box( p, vec3( 0.3, 12.0, 0.3 ) );\n    \n    p += vec3( 0.0, -12.7, 3.5 );\n    Rotate( p.yz, -0.4 * MATH_PI );\n    float b = Box( p, vec3( 0.5, 4.0, 0.3 ) );\n    \n    float bloom = Box( p + vec3( 0.0, -0.5, 0.6 ), vec3( 0.5, 3.0, 0.1 ) );\n    gReflStreetLampDist = min( gReflStreetLampDist, bloom );\n    \n    return Union( a, b );\n}\n\nfloat CastReflectionRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 100.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 16; ++i )\n    {\n        if ( h < 0.01 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = SceneRefl( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n    \n    return t;\n}\n\nvec3 SceneReflection( vec3 pos, vec3 normal, vec3 rayDir )\n{\n\tvec3 reflDir = reflect( rayDir, normal );\n    float t = CastReflectionRay( pos + 0.5 * reflDir, reflDir );\n    float w = abs( normal.x - 1.0 ) < 0.5 ? 0.3 : 1.0;    \n    \n    vec3 color = Sky( reflDir ) * mix( 1.0, 0.7, w * float( t >= 0.0 ) );\n    color += w * vec3( 0.54, 0.42, 0.78 ) * 2.0 * vec3( Saturate( exp( -gReflStreetLampDist * 0.6 ) ) );\n    return color;\n}\n\nvec3 SceneBloom( vec3 rayOrigin, vec3 rayDir )\n{\n    vec3 color = vec3( 0.0 );\n\n    vec3 center = vec3( 25.0, 14.0, 16.0 );\n    vec3 left   = vec3( 0.0, 0.0, 1.0 );\n    center += left * clamp( dot( rayOrigin - center, left ), -7.0, 7.0 );   \n    \n\tcolor += vec3( 0.54, 0.42, 0.78 ) * 0.5 * vec3( Saturate( exp( -gStreetLampDist * 0.6 ) ) );\n    color += vec3( 1.2, 0.1, 0.2 ) * 0.3 * vec3( Saturate( exp( -gCarLampDist * 2.0 ) ) );\n\n    return color;\n}\n\nfloat SmoothNoise( vec3 v )\n{\n\tvec3 i = floor( v );\n\tvec3 f = fract( v );\n\n\tf = f * f * ( -2.0 * f + 3.0 );\n\n\tvec2 uv\t\t= ( i.xy + vec2( 7.0, 17.0 ) * i.z ) + f.xy;\n\tfloat lowz\t= textureLod( iChannel0, ( uv.xy + 0.5 ) / 64.0, 0.0 ).x;\n\n\tuv\t\t\t= ( i.xy + vec2( 7.0, 17.0 ) * ( i.z + 1.0 ) ) + f.xy;\n\tfloat highz = textureLod( iChannel0, ( uv.xy + 0.5 ) / 64.0, 0.0 ).x;\n\tfloat r\t\t= mix( lowz, highz, f.z );\n\n\treturn 2.0 * r - 1.0;\n}\n\nfloat DensityNoise( vec3 pos, vec3 noisePosScale, vec3 noisePosScaleBias, float noiseScale, float noiseBias )\n{\n\tpos = pos * noisePosScale + noisePosScaleBias;\n\n\tfloat noise = SmoothNoise( pos ) + 0.5 * SmoothNoise( pos * 3.07 );\n\tnoise = Saturate( noise * noiseScale + noiseBias );\n\n\treturn noise;\n}\n\nvoid VolumetricFog( inout vec3 color, vec3 rayOrigin, vec3 rayDir, float sceneT, vec2 fragCoord )\n{\n    sceneT = sceneT <= 0.0 ? 200.0 : sceneT;\n    \n    vec3 seed = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    float dither = fract( seed.z * fract( dot( fragCoord.xy, seed.xy ) ) );\n    \n    float fogAlpha = 0.0;\n    for ( int i = 0; i < 32; ++i )\n    {\n        float t = ( float( i ) + 0.5 + dither ) * 5.0;\n        if ( t <= sceneT )\n        {\n        \tvec3 p = rayOrigin + t * rayDir;\n        \tfloat s = DensityNoise( p, vec3( 0.3 ), vec3( 0.0, 0.0, 0.0 ), 1.0, 0.0 ) * exp( -p.y * gFogHeightFalloff );\n            fogAlpha += gFogDensity * t * exp( -gFogDensity * t ) * s;\n        }\n    }\n    fogAlpha = 1.0 - Saturate( fogAlpha );\n    color = color * fogAlpha + vec3( 1.0 ) * ( 1.0 - fogAlpha );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime       = iChannelTime[ 3 ];\n    gCarOffset  = 100.0 * gTime;\n    \n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * screenUV;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    float mbStrength\t= 1.0;\n    float fov\t\t\t= 1.2;\n    float cameraOffset  = gCarOffset;\n    float theta         = clamp( 10.0 * mo.y, 0.01, 0.55 * MATH_PI );\n    float phi           = 6.0 * mo.x;\n    vec3 target         = vec3( gCarOffset + 1.0, 3.0, 3.0 );    \n    float zoom          = 15.0;\n\n    // center game camera\n\tgFogDensity\t\t\t= 0.1;\n\tgFogHeightFalloff\t= mix( 0.1, 0.3, Saturate( ( gTime - 13.0 ) * 0.25 ) );\n    mbStrength\t\t\t= 1.0;\n    zoom            \t= 10.0 + 1.2 * sin( gTime );\n    cameraOffset    \t= gCarOffset;\n    target          \t= vec3( gCarOffset + 2.0, 5.0, 3.0 );\n    phi             \t= 2.8;\n    theta           \t= 1.267;    \n\n    if ( gTime > 18.8 )\n    {\n        // right side near camera\n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 0.3;        \n        mbStrength\t\t\t= 1.0;\n        float camWeight \t= smoothstep( 0.0, 1.0, Saturate( ( gTime - 18.8 ) * 0.25 ) );\n        zoom            \t= mix( zoom, 8.0 + sin( gTime ), camWeight );\n        cameraOffset    \t= gCarOffset;\n        target          \t= vec3( gCarOffset + 2.0, 5.0, 3.0 );    \n        phi             \t= mix( phi, 2.35, camWeight );\n        theta          \t\t= mix( theta, 1.27, camWeight );\n    }\n    if ( gTime > 33.0 )\n    {\n        // top chase camera     \n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 0.01;        \n        mbStrength\t\t\t= 0.0;        \n        zoom            \t= 130.0;\n        cameraOffset    \t= gCarOffset - ( gTime - 38.0 ) * 80.0;\n        target          \t= vec3( cameraOffset + 2.0, 5.0, 0.0 );\n        phi             \t= 2.3;\n        theta           \t= 0.4;\n    }\n    if ( gTime > 43.0 )\n    {\n        // building camera\n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 10.0;        \n        mbStrength\t\t\t= 0.0;\n        fov\t\t\t\t\t= 2.0;\n        cameraOffset    \t= gCarOffset - 10.0;\n        target         \t \t= vec3( gCarOffset + 2.0, 15.0, -16.0 );    \n        zoom            \t= 1.0;    \n        phi             \t= 0.0;\n        theta           \t= 0.0;\n    }\n    if ( gTime > 53.5 )\n    {\n        // left side near low camera  \n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 0.3;                \n        mbStrength\t\t\t= 1.0;\n        fov\t\t\t\t\t= min( 1.2 + ( gTime - 53.5 ) * 0.2, 0.8 );\n        zoom            \t= 8.0 + 3.0 * cos( gTime );\n        cameraOffset    \t= gCarOffset;\n        target          \t= vec3( gCarOffset + 2.0, 5.0, -1.0 );\n        phi             \t= 3.14;\n        theta           \t= 1.4;\n    }\n    if ( gTime > INTERIOR_START )\n    {\n        // interior camera\n        mbStrength\t\t= 1.0;\n        fov\t\t\t\t= 2.0;\n        zoom            = 7.0;    \n        cameraOffset    = gCarOffset;\n        target          = vec3( gCarOffset + 1.0, 2.8, 5.5 );        \n        phi             = 2.46;\n        theta           = 1.17;  \n    }\n    if ( gTime > INTERIOR_END )\n    {        \n        // center game camera and left side near camera     \n        mbStrength\t\t= 1.0;\n        fov\t\t\t\t= 1.2;\n\t\tfloat camWeight = gTime < 95.0 ? smoothstep( 0.0, 1.0, Saturate( ( gTime - 80.0 ) * 0.25 ) ) : smoothstep( 1.0, 0.0, Saturate( ( gTime - 95.0 ) * 0.25 ) );\n        zoom            = mix( 10.0, 6.0, camWeight ) + 1.3 * sin( gTime );\n        cameraOffset    = gCarOffset;\n        target          = vec3( gCarOffset + 2.0, 5.0, mix( 3.0, -1.0, camWeight ) );\n        phi             = mix( 2.8, 3.5, camWeight );\n        theta           = mix( 1.267, 0.8, camWeight );\n    }\n    if ( gTime > 99.5 )\n    {\n        fov\t= max( 1.2 - ( gTime - 99.5 ) * 0.5, 0.5 );\n    }\n    if ( gTime > 100.0 )\n    {\n        gCarOffset += ( gTime - 100.0 ) * 10.0;\n    }\n    \n#ifdef DEBUG_CAMERA\n    // orbiting debug camera\n    cameraOffset  = gCarOffset;\n    theta         = clamp( 10.0 * mo.y, 0.01, 0.55 * MATH_PI );\n    phi           = 6.0 * mo.x;\n    target        = vec3( gCarOffset + 1.0, 3.0, 3.0 );    \n    zoom          = 5.0;\n#endif\n    \n    vec3 rayOrigin;    \n    rayOrigin.x = zoom * sin( theta ) * cos( phi ) + cameraOffset;\n    rayOrigin.y = zoom * cos( theta );\n    rayOrigin.z = zoom * sin( theta ) * sin( phi );\n\n    mat3 worldToCamera = CameraLookAt( rayOrigin, target, 0.0 );\n    \n    // ray direction\n    vec3 rayDir = worldToCamera * normalize( vec3(p.xy,fov) );  \n    vec3 color = vec3( 0.0 );\n    \n    float t = CastRay( rayOrigin, rayDir );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos );\n        vec3 sunDir = normalize( vec3( -300., -200.0, 0.0 ) ); // sun pos\n        vec3 sunColor = vec3( 1.0, 0.2, 0.0 ) * 0.5;\n        \n        vec3 posLS  = pos * 0.1;        \n        vec3 nrmLS  = normal;\n        vec3 absNrm = abs( nrmLS );\n\n        float maxAbsNrm = max( max( absNrm.x, absNrm.y ), absNrm.z );\n        vec2 uvXZ   = absNrm.x >= maxAbsNrm ? posLS.zy : posLS.xy; \n        vec2 uvXYZ  = absNrm.y >= maxAbsNrm ? posLS.xz : uvXZ;\n      \n        vec3 diffuseColor = vec3( 1.0 );\n        vec3 specularColor = vec3( 0.04 );\n        vec3 emissive = vec3( 0.0 );\n        \n        // road\n        diffuseColor = vec3( pos.y > 20.0 ? 0.3 : 0.5 );\n        if ( gMaterial == MTRL_ROAD && abs( pos.z ) < 14.0 )\n        {\n            diffuseColor = vec3( 0.5 );\n            if ( abs( pos.z ) < 0.2 )\n            {\n                diffuseColor = vec3( 1.0 );\n            }\n\n\t\t\tif ( ( abs( pos.z + 7.0 ) < 0.2 || abs( pos.z - 7.0 ) < 0.2 ) )\n            {\n                diffuseColor = vec3( 0.5 + 0.5 * exp( -4.0 * abs( 2.0 * fract( pos.x * 0.1 ) - 1.0 ) ) );\n            }\n            \n            // red trail\n            float trailX = pos.x - gCarOffset;\n            emissive = 1.2 * vec3( 1.1, 0.0, 0.0 ) \n                * Saturate( exp( -0.4 * abs( pos.z - 3.0 ) ) )\n                * Saturate( 1.0 + trailX * 0.002 )\n                * Saturate( -0.5 - trailX * 0.5 );\n        }\n        \n        // lamp\n        if ( gMaterial == MTRL_STREETLAMPS )\n        {\n            emissive = pos.y > 11.5 && normal.y > 0.5 ? vec3( 1.0 ) : vec3( 0.0 );\n        }        \n        \n        if ( gMaterial == MTRL_BUILDING && abs( normal.y ) < 0.1 )\n        {\n            diffuseColor = vec3( 0.7 );\n                \n            vec2 tilePos    = fract( uvXZ * 4.0 );\n            vec2 tileId     = uvXZ * 4.0 - tilePos;\n            vec2 edge       = min( clamp( ( tilePos - 0.2 ) * 5.0, 0.0, 1.0 ), clamp( ( 1.0 - tilePos ) * 5.0, 0.0, 1.0 ) );       \n            float bump      = edge.x * edge.y;\n\n            float tileRand = Rand( tileId );\n            vec3 tileColor = vec3( 0.3 );\n            tileColor = tileRand > 0.5 ? vec3( 1.0, 0.3, 0.5 ) * 1.2 : tileColor;\n            tileColor = tileRand > 0.7 ? vec3( 1.0, 0.5, 0.0 ) * 1.2 : tileColor;\n            tileColor = tileRand > 0.9 ? vec3( 1.0, 0.5, 0.9 ) * 1.2 : tileColor;\n            emissive = 1.0 * bump * tileRand * tileColor;\n            \n            emissive *= clamp( 4.0 * abs( tilePos.x - 0.5 ) + 0.5, 0.0, 1.0 );\n            emissive *= clamp( 4.0 * abs( tilePos.y - 0.5 ) + 0.5, 0.0, 1.0 );\n        }\n        \n        if ( gMaterial == MTRL_BUILDING )\n        {\n            float buildingLine = abs( 2.0 * fract( uvXZ.y * 2.0 - 0.05 ) - 1.0 );\n            emissive += 2.0 * vec3( 0.54, 0.42, 0.78 ) * ( exp2( -buildingLine * 4.0 ) );\n            if ( pos.y < 5.0 )\n            {\n                emissive = vec3( 0.0 );\n            }    \n            \n            if ( abs( -normal.y - 1.0 ) < 0.1 )\n            {\n                diffuseColor \t= vec3( 0.3 );\n                emissive \t\t= vec3( 0.0 );\n            }\n        }\n        \n        if ( gMaterial == MTRL_TUNNEL )\n        {\n            diffuseColor = vec3( 0.8 );\n        }        \n        \n        // car \n        if ( gMaterial == MTRL_CAR )\n        {\n            diffuseColor = vec3( 0.1 );\n            specularColor = vec3( 0.6 );\n            \n            // car lamp emissive\n            vec2 pl = pos.zy;\n            pl.x = abs( pl.x - 3.0 );\n            float dl = Rectangle( pl + vec2( -1.0, -1.3 ), vec2( 0.4, 0.06 ) );\n            float es = Saturate( exp( -dl * 20.0 ) );\n            emissive = 1.5 * vec3( 1.2, 0.1, 0.3 ) * es;\n            specularColor *= 1.0 - es;\n        }\n        \n        // car interior\n        if ( gMaterial == MTRL_CAR && gTime > INTERIOR_START && gTime < INTERIOR_END )\n        {\n            diffuseColor    = vec3( 0.2 );\n            specularColor   = vec3( 0.04 );\n            emissive        = Dashboard( pos );\n        }\n        \n        float wrap = 0.5;\n        vec3 diffuse = diffuseColor * sunColor * Saturate( ( dot( normal, sunDir ) + wrap ) / ( 1.0 + wrap ) );\n        color = diffuse;\n        \n        vec3 halfVec2       = normalize( sunDir + rayDir );\n        float NdotH2        = dot( normal, halfVec2 );\n        color += sunColor * specularColor * Saturate( dot( normal, sunDir ) ) * pow( clamp( NdotH2, 0.0, 1.0 ), 32.0 );        \n        \n        // local lights\n        vec3 pos2       = pos;\n        pos2.x = mod( pos2.x, 50.0 );                \n\n        vec3 tubeColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 tubePos    = vec3( 25.0, -10.0, 0.0 );\n        vec3 tubeLeft   = vec3( 0.0, 0.0, 1.0 );        \n        tubePos += tubeLeft * clamp( dot( pos2 - tubePos, tubeLeft ), -7.0, 7.0 );        \n        \n        vec3 tubeDir = normalize( tubePos - pos2 );\n        float tubeAtt = 1.0 / pow( length( tubePos - pos2 ), 2.0 );\n        color += diffuseColor * tubeColor * tubeAtt * Saturate( dot( normal, tubeDir ) );\n        \n        // car lights\n        vec3 spotColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 spotPos    = vec3( 3.1 + gCarOffset, -1.5, 3.0 );\n        vec3 spotDir    = normalize( spotPos - pos );\n        float spotAtt = 1.0 / pow( length( spotPos - pos ), 2.0 );\n        spotAtt *= Saturate( -spotDir.x * 6.0 - 4.0 );\n        color += diffuseColor * spotColor * spotAtt * Saturate( dot( normal, spotDir ) );                \n\n        // ambient\n        color += 0.1 * vec3( 0.54, 0.42, 0.78 ) * clamp( -normal.y + 0.5, 0.0, 1.0 );        \n        color *= gMaterial == MTRL_ROAD   ? TerrainAO( pos ) : 1.0;\n        \n        // emissive\n        color += emissive;\n                \n        // reflection\n        float fresnel = Saturate( pow( 1.0 + dot( rayDir, -normal ), 5.0 ) );\n        specularColor = mix( specularColor, vec3( 1.0 ), fresnel );\n        specularColor = gMaterial == MTRL_ROAD || gMaterial == MTRL_TUNNEL? specularColor * 0.05 : specularColor;        \n        color += specularColor * 0.5 * SceneReflection( pos, normal, rayDir );\n        \n        // back plane\n        color *= 1.0 - clamp( ( t - 200.0 ) * 0.01, 0.0, 1.0 ) * 0.8;\n        \n        // wireframe\n        vec2 tilePos = mod( uvXYZ * vec2( gMaterial == MTRL_BUILDING ? 2.0 : 0.5, 2.0 ), 1.0 );\n        tilePos = abs( 2.0 * tilePos - 1.0 );\n        float wireframe = ( exp2( -tilePos.x * 6.0 ) + exp2( -tilePos.y * 6.0 ) );         \n        float wireframeAlpha = gTime > 50.0 ? Saturate( ( pos.x - 7080.0 ) * 0.05 ) * Saturate( ( 8080.0 - pos.x ) * 0.05 ) : Saturate( 1.0 - ( gTime - 13.5 ) / 4.0 );\n        wireframeAlpha = gMaterial == MTRL_CAR ? 0.0 : wireframeAlpha;\n        \n        color = mix( color, Sky( rayDir ) + wireframe * vec3( 0.54, 0.42, 0.78 ) * 1.2, wireframeAlpha );\n        mbStrength *= 1.0 - wireframeAlpha;\n        \n#ifdef DEBUG_LIGHTING\n\t\tcolor = mix( vec3( 1.0, 0.5, 0.0 ), vec3( 0.0, 0.0, 1.0 ), 0.5 * normal.y + 0.5 );\n#endif\n    }\n    else\n    {\n        color \t\t= Sky( rayDir );\n        mbStrength \t= 0.0;\n    }\n    \n    VolumetricFog( color, rayOrigin, rayDir, t, fragCoord );\n\tcolor += SceneBloom( rayOrigin, rayDir );\n    color *= Saturate( ( 107.0 - gTime ) / 5.0 );\n    \n    fragColor = vec4( color, mbStrength );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 4160,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/daawatcha-1/blood-dragon-theme"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Post processing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    // radial blur\n    vec4 mainSample = texture( iChannel0, screenUV );    \n    vec2 blurOffset = ( screenUV - vec2( 0.5 ) ) * 0.002 * mainSample.w;\n    vec3 color = mainSample.xyz;\n\tfor ( int iSample = 1; iSample < 16; ++iSample )\n\t{\n\t\tcolor += texture( iChannel0, screenUV - blurOffset * float( iSample ) ).xyz;\n\t}    \n    color /= 16.0;\n    \n    // vignette\n    float vignette = screenUV.x * screenUV.y * ( 1.0 - screenUV.x ) * ( 1.0 - screenUV.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n    \n    float scanline   = clamp( 0.95 + 0.05 * cos( 3.14 * ( screenUV.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille  \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * screenUV.x * 640.0 * 1.0 ), 0.0, 1.0 );\n    color *= scanline * grille * 1.2;    \n        \n    fragColor = vec4( color, 1.0 );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}