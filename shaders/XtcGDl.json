{
    "Shader": {
        "info": {
            "date": "1472272111",
            "description": " Simulating analog composite artifacting by modulating the image into an NTSC-like signal and demodulating it.",
            "flags": 32,
            "hasliked": 0,
            "id": "XtcGDl",
            "likes": 31,
            "name": "Composite Artifacting",
            "published": 3,
            "tags": [
                "analog",
                "ntsc",
                "composite",
                "artifact"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 2653
        },
        "renderpass": [
            {
                "code": "//Composite color artifact simulator\n//Change Buf A to change the input image.\n\n#define HUE 0.0\n#define SATURATION 40.0\n#define BRIGHTNESS 1.0\n\n#define COMPOSITE 0 //Composite demodulated image\n#define RGB 1 //Raw RGB input image\n#define LUMA 2 //Luma component\n#define CHROMA 3 //Chroma component\n#define SIGNAL 4 //Modulated image\n#define SPLIT 5 //Left = Input RGB, Right = Output composite\n\n#define VIEW_MODE COMPOSITE\n\n#define F_COL (1.0 / 4.0)\n#define F_LUMA_LP (1.0 / 6.0)\n\n#define FIR_SIZE 29\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nmat3 yiq2rgb = mat3(1.000, 1.000, 1.000,\n                    0.956,-0.272,-1.106,\n                    0.621,-0.647, 1.703);\n\n//Angle -> 2D rotation matrix \nmat2 rotate(float a)\n{\n    return mat2( cos(a), sin(a),\n                -sin(a), cos(a));\n}\n\nfloat sinc(float x)\n{\n\treturn (x == 0.0) ? 1.0 : sin(x*pi)/(x*pi);   \n}\n\n//https://en.wikipedia.org/wiki/Window_function\nfloat WindowBlackman(float a, int N, int i)\n{\n    float a0 = (1.0 - a) / 2.0;\n    float a1 = 0.5;\n    float a2 = a / 2.0;\n    \n    float wnd = a0;\n    wnd -= a1 * cos(2.0 * pi * (float(i) / float(N - 1)));\n    wnd += a2 * cos(4.0 * pi * (float(i) / float(N - 1)));\n    \n    return wnd;\n}\n\n//FIR lowpass filter \n//Fc = Cutoff freq., Fs = Sample freq., N = # of taps, i = Tap index\nfloat Lowpass(float Fc, float Fs, int N, int i)\n{    \n    float wc = (Fc/Fs);\n    \n    float wnd = WindowBlackman(0.16, N, i);\n    \n    return 2.0*wc * wnd * sinc(2.0*wc * float(i - N/2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Fs = iResolution.x;\n    float Fcol = Fs * F_COL;\n    float Flumlp = Fs * F_LUMA_LP;\n    float n = floor(fragCoord.x);\n    \n\tvec2 uv = fragCoord.xy;\n    \n    float luma = texelFetch(iChannel0, ivec2(uv), 0).r;\n    vec2 chroma = vec2(0);\n    \n    //Filtering out unwanted high freqency content from the chroma(IQ) signal.\n    for(int i = 0;i < FIR_SIZE;i++)\n    {\n        int tpidx = FIR_SIZE - i - 1;\n        float lp = Lowpass(Flumlp, Fs, FIR_SIZE, tpidx);\n        chroma += texelFetch(iChannel0, ivec2(uv) + ivec2(i - FIR_SIZE/2, 0), 0).yz * lp;\n    }\n    \n    chroma *= rotate(tau * HUE);\n    \n    vec3 color = yiq2rgb * vec3(BRIGHTNESS * luma, chroma * SATURATION);\n    \n    #if(VIEW_MODE == COMPOSITE)\n    \tfragColor = vec4(color, 0);\n    \n    #elif(VIEW_MODE == RGB)\n   \t\tfragColor = texture(iChannel1, uv / iResolution.xy);\n    \n    #elif(VIEW_MODE == LUMA) \n    \tfragColor = vec4(luma);\n    \n    #elif(VIEW_MODE == CHROMA)\n    \tfragColor = vec4(40.0*chroma+0.5,0,0);\n    \n    #elif(VIEW_MODE == SIGNAL)\n    \tfragColor = 0.5 * texture(iChannel2, uv / iResolution.xy).rrrr+0.25;\n    \n    #elif(VIEW_MODE == SPLIT)\n    \tif(uv.x < iResolution.x/2.0)\n        {\n            fragColor = texture(iChannel1, uv / iResolution.xy);\n        }\n        else\n        {\n    \t\tfragColor = vec4(color, 0);\n        }\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//RGB Input shader\n\n//Raymarch settings\n\n#define MIN_DIST 0.001\n#define MAX_DIST 32.0\n#define MAX_STEPS 96\n#define STEP_MULT 0.9\n#define NORMAL_OFFS 0.01\n#define FOCAL_LENGTH 0.8\n\n//Scene settings\n\n//#define SHOW_RAY_COST\n\n//Colors\n#define SKY_COLOR_1 vec3(0.60,0.00,0.00)\n#define SKY_COLOR_2 vec3(1.00,0.50,0.00)\n\n#define SUN_COLOR_1 vec3(1.00, 0.00, 0.00)\n#define SUN_COLOR_2 vec3(1.00, 1.00, 0.00)\n\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(1.00, 0.20, 0.60)\n\n#define WATER_COLOR vec3(0.50, 1.00, 2.90)\n\n//Parameters\n#define GRID_SIZE 0.20\n#define GRID_LINE_SIZE 1.25\n\n#define WATER_LEVEL 0.20\n#define WATER_FOG_SIZE 0.05\n\n#define SUN_DIRECTION vec3( 0.10,-1.00,-0.03)\n\n#define CLOUD_SCROLL vec2(0.002, 0.001)\n#define CLOUD_BLUR 2.0\n#define CLOUD_SCALE vec2(0.04, 0.10)\n\n#define MOUNTAIN_SCALE 6.0\n#define MOUNTAIN_SHIFT 5.3\n\n//Color modes\n//vec3(#,#,#) Number of bits per channel\n\n//24 bit color\n#define RGB888 vec3(8,8,8)\n//16 bit color\n#define RGB565 vec3(5,6,5)\n#define RGB664 vec3(6,6,4)\n//8 bit color\n#define RGB332 vec3(3,3,2)\n#define RGB242 vec3(2,4,2)\n#define RGB222 vec3(2,2,2) //+2 unused\n\n//#define DITHER_ENABLE\n#define COLOR_MODE RGB242\n\n//Object IDs\n#define SKYDOME 0.\n#define FLOOR 1.\n#define RIVER 2.\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nvec3 dither(vec3 color, vec3 bits, vec2 pixel)\n{\n    vec3 cmax = exp2(bits)-1.0;\n    \n    vec3 dithfactor = mod(color, 1.0 / cmax) * cmax;\n    float dithlevel = texture(iChannel2,pixel / iChannelResolution[2].xy).r;\n    \n    vec3 cl = floor(color * cmax)/cmax;\n    vec3 ch = ceil(color * cmax)/cmax;\n    \n    return mix(cl, ch, step(dithlevel, dithfactor));\n}\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n//==== Distance field operators/functions by iq. ====\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n\nvec2 sdSphere(vec3 p, float s, float id)\n{\n  return vec2(length(p) - s, id);\n}\n\nvec2 sdPlane(vec3 p, vec4 n, float id)\n{\n  // n must be normalized\n  return vec2(dot(p,n.xyz) + n.w, id);\n}\n\nvec2 sdColumn(vec3 p, float r, float id)\n{\n    return vec2(((abs(p.x)+abs(p.y))-r)/sqrt(2.0), id);\n}\n\nvec2 dfRiver(vec3 p, float id)\n{\n    float offs = sin(p.y)*0.15 + sin(p.y * 0.2);\n    \n    return sdColumn(p.xzy + vec3(offs,0,0), 0.4, id);\n}\n\n//Distance to the scene\nvec2 Scene(vec3 p)\n{\n    vec2 d = vec2(MAX_DIST, SKYDOME);\n    \n    d = opU(sdPlane(p, vec4(0, 0,-1, 0), FLOOR), d);\n    \n    d = opS(dfRiver(p, RIVER), d);\n    \n\treturn d;\n}\n\n//Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz).x - Scene(p - off.xyz).x,\n            Scene(p + off.zxy).x - Scene(p - off.zxy).x,\n            Scene(p + off.yzx).x - Scene(p - off.yzx).x\n        )\n    );\n}\n\n//Raymarch the scene with the given ray\nMarchResult MarchRay(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec2 object = Scene(orig + dir * dist);\n        \n        //Add the sky dome and have it follow the camera.\n        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));\n        \n        dist += object.x * STEP_MULT;\n        \n        id = object.y;\n        \n        steps++;\n        \n        if(abs(object.x) < MIN_DIST * dist)\n        {\n            break;\n        }\n    }\n    \n    MarchResult result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    result.id = id;\n    \n    return result;\n}\n\n//Scene texturing/shading\nvec3 Shade(MarchResult hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.0);\n\n    if(hit.id == FLOOR)\n    {\n        vec2 uv = abs(mod(hit.position.xy + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); \n        \n        uv /= fwidth(hit.position.xy);\n        \n        float riverEdge = dfRiver(hit.position, 0.0).x / fwidth(hit.position.xy).x;\n                                                       \n        float gln = min(min(uv.x, uv.y), riverEdge) / GRID_SIZE;\n        \n    \tcolor = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n    } \n    \n    if(hit.id == RIVER)\n    {\n        vec2 uv = vec2(hit.position.z, abs(mod(hit.position.y + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0)); \n        uv /= fwidth(hit.position.xy);\n        \n        float gln = min(uv.x, uv.y) / GRID_SIZE;\n        \n    \tcolor = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n    }\n    \n    //Distance fog\n    color *= 1.0 - smoothstep(0.0, MAX_DIST*0.9, hit.dist);\n    \n    //Water\n    float waterMix = smoothstep(WATER_LEVEL - WATER_FOG_SIZE, WATER_LEVEL + WATER_FOG_SIZE, hit.position.z);\n    \n    color = mix(color, WATER_COLOR, waterMix);  \n    \n    if(hit.id == SKYDOME)\n    {\n        //Sky gradient\n        //Causes weird position-colored artefacts around the horizon (AMD R9 270)\n        //color = mix(SKY_COLOR_1, SKY_COLOR_2, -hit.position.z/16.0);\n    \tcolor += mix(SKY_COLOR_1, SKY_COLOR_2, -hit.position.z/16.0);\n        \n        //Sun\n        vec3 sunDir = normalize(SUN_DIRECTION);\n        \n        float sun = smoothstep(0.950, 0.952, dot(direction, sunDir));\n        \n        vec3 sunCol = mix(SUN_COLOR_1, SUN_COLOR_2, -hit.position.z/16.0);\n\n        color = mix(color, sunCol, sun);\n        \n        //Clouds\n        vec2 cloudUV = CLOUD_SCALE * direction.xy / dot(direction, vec3(0, 0,-1));\n        cloudUV += CLOUD_SCROLL * iTime;\n        \n        color *= smoothstep(0.5, 0.3, texture(iChannel1, cloudUV, CLOUD_BLUR).r) * 0.5 + 0.5;\n        \n        //Mountains\n        float a = atan(hit.position.y, hit.position.x)/tau + 0.5;\n        a -= 3.28;\n        \n        float mountains = MOUNTAIN_SCALE * texture(iChannel0, vec2(a, 0.1),-99.0).r - hit.position.z - MOUNTAIN_SHIFT;\n        \n        color = mix(color, vec3(0.0), 1.0 - smoothstep(0.6, 0.7, mountains));  \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    //Auto mode\n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.8 / 8.0);\n        angles.x = tau * (3.9 / 8.0) + sin(iTime * 0.1) * 0.3;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, 15.5 * tau / 64.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = vec3(0, 0,-2) * rotate;\n    \n    vec3 dir = normalize(vec3(uv - res / 2.0, FOCAL_LENGTH)) * rotate;\n    \n    //Ray marching\n    MarchResult hit = MarchRay(orig, dir);\n    \n    //Shading\n    vec3 color = Shade(hit, dir, orig);\n    \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps / float(MAX_STEPS));\n    #endif\n    \n    #ifdef DITHER_ENABLE\n    color = dither(color, COLOR_MODE, fragCoord);\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Modulator\n\n#define F_COL (1.0 / 4.0)\n\nfloat tau = atan(1.0)*8.0;\n\nmat3 rgb2yiq = mat3(0.299, 0.596, 0.211,\n                    0.587,-0.274,-0.523,\n                    0.114,-0.322, 0.312);\n\n//Complex oscillator, Fo = Oscillator freq., Fs = Sample freq., n = Sample index\nvec2 Oscillator(float Fo, float Fs, float n)\n{\n    float phase = (tau*Fo*floor(n))/Fs;\n    return vec2(cos(phase),sin(phase));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Fs = iResolution.x;\n    float Fcol = Fs * F_COL;\n    float n = floor(fragCoord.x);\n    \n    vec3 cRGB = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    vec3 cYIQ = rgb2yiq * cRGB;\n    \n    vec2 cOsc = Oscillator(Fcol, Fs, n);\n    \n    float sig = cYIQ.x + dot(cOsc, cYIQ.yz);\n\n    fragColor = vec4(sig,0,0,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Demodulator\n\n#define F_COL (1.0 / 4.0)\n#define F_LUMA_LP (1.0 / 6.0)\n#define F_COL_BW (1.0 / 50.0)\n\n#define FIR_SIZE 29\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n//Complex multiply\nvec2 cmul(vec2 a, vec2 b)\n{\n   return vec2((a.x * b.x) - (a.y * b.y), (a.x * b.y) + (a.y * b.x));\n}\n\nfloat sinc(float x)\n{\n\treturn (x == 0.0) ? 1.0 : sin(x*pi)/(x*pi);   \n}\n\n//https://en.wikipedia.org/wiki/Window_function\nfloat WindowBlackman(float a, int N, int i)\n{\n    float a0 = (1.0 - a) / 2.0;\n    float a1 = 0.5;\n    float a2 = a / 2.0;\n    \n    float wnd = a0;\n    wnd -= a1 * cos(2.0 * pi * (float(i) / float(N - 1)));\n    wnd += a2 * cos(4.0 * pi * (float(i) / float(N - 1)));\n    \n    return wnd;\n}\n\n//FIR lowpass filter \n//Fc = Cutoff freq., Fs = Sample freq., N = # of taps, i = Tap index\nfloat Lowpass(float Fc, float Fs, int N, int i)\n{    \n    float wc = (Fc/Fs);\n    \n    float wnd = WindowBlackman(0.16, N, i);\n    \n    return 2.0*wc * wnd * sinc(2.0*wc * float(i - N/2));\n}\n\n//FIR bandpass filter \n//Fa/Fb = Low/High cutoff freq., Fs = Sample freq., N = # of taps, i = Tap index\nfloat Bandpass(float Fa, float Fb, float Fs, int N, int i)\n{    \n    float wa = (Fa/Fs);\n    float wb = (Fb/Fs);\n    \n    float wnd = WindowBlackman(0.16, N, i);\n    \n    return 2.0*(wb-wa) * wnd * (sinc(2.0*wb * float(i - N/2)) - sinc(2.0*wa * float(i - N/2)));\n}\n\n//Complex oscillator, Fo = Oscillator freq., Fs = Sample freq., n = Sample index\nvec2 Oscillator(float Fo, float Fs, float N)\n{\n    float phase = (tau*Fo*floor(N))/Fs;\n    return vec2(cos(phase),sin(phase));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Fs = iResolution.x;\n    float Fcol = Fs * F_COL;\n    float Fcolbw = Fs * F_COL_BW;\n    float Flumlp = Fs * F_LUMA_LP;\n    float n = floor(fragCoord.x);\n    \n    float y_sig = 0.0;    \n    float iq_sig = 0.0;\n    \n    vec2 cOsc = Oscillator(Fcol, Fs, n);\n\t\n    n += float(FIR_SIZE)/2.0;\n    \n    //Separate luma(Y) & chroma(IQ) signals\n    for(int i = 0;i < FIR_SIZE;i++)\n    {\n        int tpidx = FIR_SIZE - i - 1;\n        float lp = Lowpass(Flumlp, Fs, FIR_SIZE, tpidx);\n        float bp = Bandpass(Fcol - Fcolbw, Fcol + Fcolbw, Fs, FIR_SIZE, tpidx);\n        \n        y_sig += texelFetch(iChannel0, ivec2(n - float(i), fragCoord.y), 0).r * lp;\n        iq_sig += texelFetch(iChannel0, ivec2(n - float(i), fragCoord.y), 0).r * bp;\n    }\n    \n    //Shift IQ signal down from Fcol to DC \n    vec2 iq_sig_mix = cmul(vec2(iq_sig, 0), cOsc);\n    \n    fragColor = vec4(y_sig, iq_sig_mix, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}