{
    "Shader": {
        "info": {
            "date": "1603294179",
            "description": "mouse supported",
            "flags": 32,
            "hasliked": 0,
            "id": "wsKcWw",
            "likes": 28,
            "name": "ShallowWaterEquation",
            "published": 3,
            "tags": [
                "simulation",
                "water",
                "rain",
                "shallowwaterequation"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 1030
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvec2 hash2(vec2 p) \n{\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\nvec2 hash2(float n) \n{ \n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); \n}\n\nfloat hash1(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\n\nfloat cloud(vec2 x)\n{\n    float f = 2.;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for(int i=0; i<3+min(0,iFrame); i++)\n    {\n        float n = noise(vec2(x.x, x.y-iTime*0.3));\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nfloat terrian(vec2 p)\n{    \n    p*=0.0035;\n    float f = 1.7;\n    float s = 0.5;\n    float a = 0.;\n    float b = 0.5;\n    for(int i=0; i<9+min(0,iFrame); i++)\n    {\n        float n = noise(p);\n        a += b*n;\n        b *= s;\n        p = f*m2*p;\n    }\n\t\n    a=smoothstep(-0.5,0.7,a);\n    \n    return a*300.;\n}\n\n\nvec3 terrian_normal(vec2 pos, float t)\n{   \n    vec2 e = vec2(0.001*t,0.0);\n\treturn normalize(vec3(terrian(pos-e.xy)-terrian(pos+e.xy),\n                           2.0*e.x,\n                           terrian(pos-e.yx)-terrian(pos+e.yx)));\n}\n\nfloat march_terrian(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float t = tmin;\n    vec3 p=ro+t*rd;\n    float d=p.y-terrian(p.xz);\n\n    float sgn=sign(d);\n    float told=t;\n    bool bisect=false;\n        \n    for (int i=0;i<256+min(0,iFrame);i++)\n    {\n        if(abs(d)<0.002*t || t>tmax) break;            \n       \tif(sign(d)!=sgn)\n        {\n            bisect=true;\n            break;\n        }\n        \n        told=t;\n        if(d>1.)t+=d*0.4;\n        else t+=log(abs(d)+1.1)*1.;\n        p=ro+t*rd;\n       \td=p.y-terrian(p.xz);\n    }\n    \n    if(bisect)\n    {\n        float m = 0.;\n        p=ro+told*rd;\n        sgn=sign(p.y-terrian(p.xz));\n        for(int i=0; i<6; i++)\n        { \n            m=(told+t)*.5;\n            p=ro+rd*m;\n            d=p.y-terrian(p.xz);\n            if(abs(d)<0.002*t)break;\n            d*sgn<0. ? t=m : told=m;\n        }\n        t=(told+t)*.5;\n    }\n    return t;\n}\n\n\nfloat water(vec2 p)\n{\n    p*=0.05;\n\tfloat f = 2.;\n    float s = 0.4;\n    float a = 0.0;\n    float b = 0.1;\n\n   \n    float n = texture(iChannel2, p.xy*.1-vec2(0.45,.2)).x * 5.;\n    a += n;\n    #if FBM\n    for(int i=0; i<5+min(0,iFrame); i++)\n    {\n        float n = noise(vec2(p.x+10.,p.y-iTime*1.));\n        a += b*n;\n        b *= s;\n        p = f*m2*p;\n    }\n    #endif\n\treturn 3.*a;\n}\n\nvec3 water_normal(vec2 pos, float t) \n{\n\tvec2 e=vec2(1e-7*t*t*t,0.0);\n    return normalize(vec3(water(pos-e.xy)-water(pos+e.xy),\n                          2.0*e.x,\n                          water(pos-e.yx)-water(pos+e.yx)));\n}\n\nfloat intersect_water(vec3 ro, vec3 rd)\n{\n    float t=2000.;\n    if(rd.y <-0.01)\n    {\n      \tfloat t0=-(ro.y-20.)/rd.y;\n      \tt=min(t,t0);\n    }\n    return t;\n}\n\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat terrian_shadow(vec3 ro, vec3 rd, vec2 fragCoord)\n{\n    float res=1.0;\n    float t=.5+0.5*hash1(fragCoord);\n\n    float h;    \n    for(int i=0;i<20+min(0,iFrame);i++)\n    {\n        vec3 p=ro+t*rd;\n        h=p.y-terrian(p.xz);\n        res=min(16.0*h/t, res);\n        t+=clamp(h,1.+.1*t,30.);\n        if(res<0.001*t)\n            break;\n    }\n    return clamp(res, 0., 1.);\n}     \n\n\nvec3 sun_dir=normalize(vec3(-5., 1.5, 4.6));\nvec3 sun_col=vec3(1.);\n\nvec3 terrian_material(vec3 pos, vec3 n)\n{\n    float tree_pdf=smoothstep(0.,.5,n.y);\n    tree_pdf*=1.-smoothstep(20.,50.,pos.y);\n    vec3 mate=pow(texcube(iChannel0, pos*0.008, n).xyz,vec3(3.));\n    mate=mix(mate, .05*vec3(.7, 1., .2), tree_pdf);\n    tree_pdf=smoothstep(0.2,.3,n.y)*smoothstep(50.,200.,pos.y);\n    mate=mix(mate, .08*vec3(.5, 1., .2), tree_pdf);\n\treturn mate;\n}\n\nvec3 render_terrian(vec3 ro, vec3 rd, float t, vec2 fragCoord)\n{\n    vec3 pos=ro+t*rd;\n    vec3 n=terrian_normal(pos.xz, t);\n\n    vec3 sky=vec3(0.2,0.7,1.);\n    \n    vec3 mate=terrian_material(pos, n);\n    n=bump_mapping(pos*.1,n,0.15);\n    float sha=terrian_shadow(pos+.5*n, sun_dir, fragCoord);\n    float dif=max(0.,dot(n,sun_dir));\n    float bac=max(0.,dot(n,-sun_dir));\n    float amb=max(0.,dot(n,vec3(0,1,0)));\n    vec3 Lo=4.0*dif*sun_col*sha;\n    Lo+=0.5*bac*sun_col;\n    Lo+=4.5*amb*sky;\n   \tLo*=smoothstep(-1.,10.,pos.y);\n    return Lo*mate*0.2;        \n}\n\n// sky from iq's rainforest  https://www.shadertoy.com/view/4ttSWf\nvec3 render_sky(vec3 ro, vec3 rd)\n{\n    // darker on top of the head\n    vec3 col=0.8*vec3(0.45,0.6,1.0)-rd.y*vec3(0.4,0.36,0.4);\n\n    float t=(1000.0-ro.y)/rd.y;\n    if(t>0.0)\n    {\n        vec2 uv=(ro+t*rd).xz-vec2(4710.,235.);\n        float cl=cloud(uv*0.0015);\n        float dl=smoothstep(-0.2,0.6,cl);\n        col=mix(col, vec3(1.0), 0.6*dl);\n    }\n    \n    \n\treturn col;\n}\n\nvec3 render_water(vec3 ro, vec3 rd, float t, float t1, vec2 fragCoord, vec3 sky)\n{\n    vec3 pos=ro+t*rd;\n    vec3 n=water_normal(pos.xz, t);\n\n    vec3 mate=vec3(.8,.9,1.)*0.5;\n\n    float sha=terrian_shadow(pos+.1*n, sun_dir, fragCoord);\n    float dif=max(0.,dot(n,sun_dir));\n    float amb=max(0.,dot(n,vec3(0,1,0)));\n    float fre=clamp(1.0+dot(rd,n), .0, 1.); \n    vec3 refl=reflect(rd,n);\n    vec3 refr=refract(rd,n,1./1.33);\n    float spe=max(0.0, pow(clamp(dot(sun_dir, refl), 0.0, 1.0), 5.0));\n\n    vec3 Lo=2.0*dif*sun_col*sha;\n    Lo+=2.*amb*sky;\n    Lo+=2.5*pow(fre,8.)*vec3(1.);\n    Lo+=2.5*spe*vec3(1.);\n\tvec3 col=Lo*mate*0.2;\n    \n    float t_terrian=march_terrian(pos+1.*n, refl, 0.5, 500.);\n    vec3 reflcol=render_sky(pos,refl)*.5;\n    \n    float falloff=0.;\n    \n    if(t_terrian<500.) \n    {\n        falloff=1.-smoothstep(0.5,500.,t_terrian);\n        reflcol=.4*falloff*falloff*render_terrian(pos+1.*n, refl, t_terrian, fragCoord);\n    }\n\n    vec3 refrcol=render_terrian(ro, rd, t1, fragCoord);\n    \n    falloff=1.-smoothstep(0.5,500.,t1-t);\n    col=mix(col,refrcol,falloff*falloff);\n      \n    col=mix(col, reflcol, fre);   \n    return col;\n}\n\n\n\nvec3 scene(vec3 ro, vec3 rd, vec2 fragCoord, out float t)\n{\n    vec3 bg=vec3(.6,.8,1.1);\n    vec3 col=render_sky(ro, rd);\n    float t0=intersect_water(ro,rd);\n    float t1=march_terrian(ro, rd, 50., 2000.);\n    t=min(t0,t1);\n    \n  \tif(t>=2000.) return col;\n        \n    if(t1<t0)\n    {\n        col=render_terrian(ro, rd, t1, fragCoord);  \n    }\n    else\n    {\n        col=render_water(ro, rd, t0, t1, fragCoord, col);\n    }\n    \n    col=mix(col,bg, 1.0-exp(-1.5e-7*t*t) );\n    \n    return col;\n}\n\n\nvec3 tonemap(vec3 x) \n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0,1,0)));\n    vec3 u=normalize(cross(r,f));\n    return mat3(r,u,f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord.xy/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(0.,100.,0.);\n    vec3 ta=ro+vec3(0,-0.2,-1.);\n        \n   \tmat3 cam=camera(ro, ta); \n    vec3 rd=normalize(cam*vec3(p.xy,PI/2.));\n    vec3 col=vec3(0.6,0.8,1.1);\n\n    float t=0.;\n    \n    col=scene(ro,rd,fragCoord.xy, t);\n    //col = texture(iChannel2, q).xxx;\n    \n    // rain by Dave Hoskins\n    #if RAIN\n    //if(iTime > RAIN_START_TIME)\n    {\n        vec2 st = 256. * (p* vec2(.5, .01)+vec2(iTime*.13-q.y*.1, iTime*.13));\n        float f = noise(st) * noise( st*0.773) * 1.55;\n        f = 0.25 + clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\n        col += 0.2 * f * vec3(1.2) * smoothstep(RAIN_START_TIME-.5, RAIN_START_TIME+.5, iTime);\n    }\n    #endif\n    \n    col=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n\tcol=col*0.6+0.4*col*col*(3.0-2.0*col);\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\n    fragColor.xyz=col;;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define H0 1.0\n\nfloat g = GRAVITY;\n\nvec2 hash21(float p)\n{\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize=1./iResolution.xy;\n    vec2 pos=fragCoord.xy*pixelSize;\n    \n     // use linear texture filter for the averaging\n    vec2 v_avg = texture(iChannel0, pos-pixelSize*.5).xy;\n        \n   \tvec2 U = texture(iChannel0, pos).xy;\n    \n    if(iFrame == 0)\n    {\n        U=vec2(0);\n    }\n    \n    if(iMouse.z > 0.)\n    {\n        vec2 mpos = iMouse.xy / iResolution.xy;\n        U += (1.-smoothstep(0.,0.01,length(mpos-pos))) * .3;\n    }\n    \n    #if RAIN\n    if(iTime > RAIN_START_TIME && iFrame % 1 == 0)\n    {\n        vec2 mpos = hash21(float(iFrame));\n        U += (1.-smoothstep(0.,0.01,length(mpos-pos))) * .2;\n    }\n    #endif\n    \n    \n    float h00 = texture(iChannel1, pos).x;\n    float h10 = texture(iChannel1, pos + _10).x;\n    float h01 = texture(iChannel1, pos + _01).x;\n     \n  \tvec2 Unew;\n \n    Unew.x = U.x + dt * (CORIOLIS_PARAM * v_avg.x - g * (h10 - h00) / dx);\n    Unew.y = U.y + dt * (CORIOLIS_PARAM * v_avg.y -g * (h01 - h00) / dy);\n  \n    \n\n\n    fragColor = vec4(Unew, 0, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvec2 hash21(float p)\n{\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize=1./iResolution.xy;\n    vec2 pos=fragCoord.xy*pixelSize;\n        \n   \tfloat H = 0.;\n    if(iFrame == 0)\n    {\n        H=0.;\n    }\n    \n    if(iMouse.z > 0.)\n    {\n        vec2 mpos = iMouse.xy / iResolution.xy;\n        H -= (1.-smoothstep(0.,0.01,length(mpos-pos))) * 5.3;\n    }\n   \n    \n    float h = texture(iChannel1, pos).x + H;\n    \n    vec2 U0 = texture(iChannel0, pos).xy;\n    float u1 = texture(iChannel0, pos - _10).x;\n    float v1 = texture(iChannel0, pos - _01).y;\n    \n    // .99 for attenuation\n    float hnew = .99*h - dt * DEPTH * ((U0.x - u1) / dx + (U0.y - v1) / dy);\n    \n  \n\n    fragColor = vec4(hnew, 0., 0., 0.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// passthrough pass, for workaround a shadertoy bug:\n// the wrap mode of buffers would always change back to \"clamp\" even you set to \"repeat\" in Image pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 pos = fragCoord.xy * pixelSize;\n    \n    fragColor.xyz = vec3(texture(iChannel1, pos).x, 0., 0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Very Basic Shallow Water Equation\n\n\n#define RAIN 1\n#define RAIN_START_TIME 3.\n#define FBM 1\n#define PI 3.1415926535\n\n\n#define SHOWSIM 0\n\n#define dx 1.\n#define dy 1.\n\n\n#define _10 vec2(pixelSize.x, 0)\n#define _01 vec2(0, pixelSize.y)\n#define _11 (pixelSize.xy)\n\n\n#define GRAVITY 9.8\n#define DEPTH 10.\n#define CORIOLIS_PARAM  2e-4\n\n// CFL\n#define dt  (0.5 * min(dx, dy) / sqrt(GRAVITY * DEPTH))\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}