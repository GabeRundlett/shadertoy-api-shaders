{
    "Shader": {
        "info": {
            "date": "1605311295",
            "description": "Can't find why I get those glitches ðŸ˜ž\nif anyone here could give me a tip, it would be really appreciated :)\n\n#EDIT: Thanks to Ivan Dianov for pointing out that the gyroid SDF is not exact and should then be divided",
            "flags": 0,
            "hasliked": 0,
            "id": "wddfDM",
            "likes": 13,
            "name": "Giroid sphere",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "makio135",
            "viewed": 610
        },
        "renderpass": [
            {
                "code": "// Antialiasing: number of samples in x and y dimensions\n#define AA 2\n\n#define MIN_DIST 0.001\n#define MAX_DIST 10.\n\n#define PI 3.1415926\n#define TAU 6.2831853\n\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\n// from https://github.com/doxas/twigl\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nfloat sdSphere(vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n  p *= scale;\n  return abs(dot(sin(p*.5), cos(p.zxy * 1.23)) - bias) / scale - thickness;\n}\n\nvec2 sceneSDF(vec3 p) {\n  p *= rotate3D(iTime * .2, vec3(0, 1, 0));\n  \n  float gyroid = sdGyroid(p, 10., .01, 0.) * .55;\n  float d = opIntersection(sdSphere(p, 1.5), gyroid);\n\n  return vec2(d, 1.);\n}\n\n// Compute camera-to-world transformation.\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n  vec3 cw = normalize(ta - ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  return mat3(cu, cv, cw);\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float tmin = MIN_DIST;\n    float tmax = MAX_DIST;\n   \n#if 0\n    // bounding volume\n    float tp1 = (0.0 - ro.y) / rd.y; \n    if(tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y; \n    if(tp2 > 0.0) { \n        if(ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2 );\n    }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for(int i = 0; i < 100; i++) {\n        float precis = 0.0005 * t;\n        vec2 res = sceneSDF(ro + rd * t);\n        if(res.x < precis || t > tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m =- 1.0;\n    return vec2(t, m);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal(in vec3 pos) {\n  // epsilon = a small number\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\n  return normalize(\n    e.xyy * sceneSDF(pos + e.xyy).x + \n    e.yyx * sceneSDF(pos + e.yyx).x + \n    e.yxy * sceneSDF(pos + e.yxy).x + \n    e.xxx * sceneSDF(pos + e.xxx).x\n  );\n}\n\nvec3 computeColor(vec3 ro, vec3 rd, vec3 pos, float d, float m) {\n  vec3 nor = calcNormal(pos);\n  return nor;\n}\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render(in vec3 ro, in vec3 rd) { \n  // cast ray to nearest object\n  vec2 res = castRay(ro, rd);\n  float distance = res.x; // distance\n  float materialID = res.y; // material ID\n\n  vec3 col = vec3(245,215,161)/255.;\n  if(materialID > 0.0) {\n    vec3 pos = ro + distance * rd;\n    col = computeColor(ro, rd, pos, distance, materialID);\n  }\n  return vec3(clamp(col, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Ray Origin)\\t\n  vec3 ro = vec3(2.3);\n  vec3 ta = vec3(0.0);\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  vec3 color = vec3(0.0);\n\n#if AA>1\n  for(int m = 0; m < AA; m++)\n  for(int n = 0; n < AA; n++) {\n  // pixel coordinates\n  vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n  vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + o)) / iResolution.y;\n#else\n  vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n#endif\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  // render\\t\n  vec3 col = render(ro, rd);\n\n  color += col;\n#if AA>1\n  }\n  color /= float(AA*AA);\n#endif\n\n\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}