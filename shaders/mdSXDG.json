{
    "Shader": {
        "info": {
            "date": "1673814215",
            "description": "- drag mouse to rotate the camera\n- more information see code\n- should run smooth on fullscreen\n- give it some time to terraform \n\nmusic: der Schamane - live analog recording session 2020",
            "flags": 64,
            "hasliked": 0,
            "id": "mdSXDG",
            "likes": 10,
            "name": "Terraforming in progress...",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "kifs"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "//               = Terraforming in progress... =         \n//               by Maximilian Knape   ·∑>| 2023            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n\n\"\n...strange frequencies generating stunning interference patterns on nearly every surface.\nBy following the symmetrical wave patterns to its core we found a kind of ancient technology.\nIt may seem old to us, but it feels like it's still fully active and oddly somehow alive.\nAfter a few days we were able to recover parts of the communication protocol from this object:\n\n    [...]\n    MX3I-2718 | 3708110813 : landing site found\n    MX3I-2718 | 3708110901 : landing successful\n    MX3I-2718 | 3708110903 : system cool down\n    MX3I-2718 | 3708122100 : terraforming module initializing\n    MX3I-2718 | 3708122254 : terraforming in progress...\n    MX3I-2718 | 3708122255 : estimate date of completion...\n    MX3I-2718 | 3709040723 : earliest possible returnal in 231y249d2h56m3s\n    MX3I-2718 | 3709040724 : deactivation message - \"I will be eagerly awaiting you, but \n                             now it's time to let go. I will never forget you and who created me...\"\n    MX3I-2718 | 3709040725 : set transmission state to standby\n    MX3I-2718 | 3709040726 : [BASE SIGNAL LOST]\n\n    [END OF LOG - DRONE MX3I-2718]\n\nThis is all we have for now.\nI hope this clears things up and we all know we need to prepare now!\n\nLove and Light\nCommander W. Bright\nStarfleet 73b1\nGalactic Federation\n\n\nPS: We drilled some holes in the ground and discovered caverns filled with a kind of extremely hot lava.\n\"\n\n*/\n\n#define GAMMA vec3(.4545)\n\n#define MAX_STEPS 200\n#define STEP_FAC .9\n#define MAX_DIST 300.\n#define MIN_DIST .1\n\n#define SURF_DIST .01\n#define SURF_MUL 40.\n#define SURF_EXP 1.5\n\n#define GLOW_INT 1.0\n#define PP_CONT 0.6\n#define PP_VIGN 2.0\n#define AO_OCC 0.28\n#define AO_SCA 0.6\n\n#define iTime iTime*.8\n#define PI 3.14159265358979\n#define S(x,y,t) smoothstep(x,y,t)\n\n\nmat2 Rot(float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define Rot2D(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 Rot(vec3 p, vec3 r) //las\n{\n    Rot2D(p.xz, r.y);\n    Rot2D(p.yx, r.z);\n    Rot2D(p.zy, r.x);\n    return p;\n}\n\nfloat smin( float a, float b, float k ) //iq\n{\n    float h = max(k-abs(a-b),0.);\n    return min(a, b) - h*h*.25/k;\n}\n\nfloat sin3(float x) { return sin(x)*sin(x)*sin(x); }\nvec3  sin3(vec3 x)  { return sin(x)*sin(x)*sin(x); }\n\nconst int iters = 7;\nconst vec3 fTra = vec3(0);\nconst vec3 fRot = vec3(0);\nconst vec4 k = vec4(2., 3.2, 4.5, 4.5);\n\nvec2 Map(vec3 p) \n{    \n    float d, col;\n    \n    vec3 po = p;\n    int i;\n    float x1, y1, \n    s = 10.,\n    lp = length(p);\n    p /= 2.;\n    p.xz = mod(abs(p.xz - s/2.), s) - s/2.;\n    p.y +=  length(dot(cos(po.zx/50.), sin(po.xz/30. + vec2(iTime/50.))))*10. * S(10., 50., lp)- \n            pow(length(po/100.), 3.)*3. +\n            S(20., 50., lp)*3.;\n    \n    float r = p.x*p.x + p.y*p.y + p.z*p.z;\n    \n    for(i = 0; i < iters && r < 1e10; i++)\n    {\n        if (i > 0) \n        {\n            p += fTra - 1. - sin3(iTime / vec3(33,42,51));\n            p = Rot(p, fRot + .00001 + PI*.5*sin3(PI + iTime / vec3(61,52,43)));\n        }\n\n        p = abs(p);\n\n        if (p.x-p.y < 0.) { x1=p.y; p.y=p.x; p.x=x1;}\n        if (p.x-p.z < 0.) { x1=p.z; p.z=p.x; p.x=x1;}\n        if (p.y-p.z < 0.) { y1=p.z; p.z=p.y; p.y=y1;}\n\n        p.z -= 0.5 * k.x * (k.y - 1.) / k.y;\n        p.z = -abs(p.z);\n        p.z += 0.5 * k.x * (k.y - 1.) / k.y;\n\n        p.x = k.y * p.x - k.z * (k.y - 1.);\n        p.y = k.y * p.y - k.w * (k.y - 1.);\n        p.z = k.y * p.z;\n\n        r = p.x*p.x + p.y*p.y + p.z*p.z;\n    }\n    \n    d = length(p) * pow(k.y, float(-i));\n    col = 0.1;\n\n    float wv = sin(p.x/1e3+p.z/1e3);\n    float bt = pow(max(0., po.y + .1*wv), 1.2);\n    col = mix(col, 1.95, step(bt, d));\n    d = smin(d, bt*.6, 1.+.5*sin(po.x/1e2+iTime/3.));\n    \n    float sd = length(po - vec3(0,17.+sin(iTime/5.),0)) - .2*S(.3, 0., abs(fract(iTime/3.)-.5));\n    float sp = sd - 4.*(1.+pow(abs(cos(p.y/1e3)), 2.)*.1);\n    col = mix(col, 4.7, step(sp, d));\n    d = min(d, sp);\n    \n    s = sd - 4.05;\n    col = mix(col, -3.4, step(s, d));\n    d = min(d, s);\n\n    return vec2(d, col);\n}\n\nvec3 Normal(vec3 p) \n{\n    vec2 e = vec2(.001, 0);\n    return normalize(Map(p).x - vec3(Map(p-e.xyy).x, Map(p-e.yxy).x,Map(p-e.yyx).x));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST) * \n                (1. - S(20., -.4 - 2.7*S(30., 10., p.y), length(p.xz)));\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (pow(dO/MAX_DIST, SURF_EXP)*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(vec3 ro, vec3 lp, float k) //Shane\n{\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i<maxIterationsShad; i++)\n    {\n        float h = Map(ro + rd*dist).x;\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.) + .0, 1.); \n}\n\n\nfloat CalcAO(const in vec3 p, const in vec3 n) //iq\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = .001 + .150 * float(i) / 4.0;\n        float d = Map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return S(.0, 1. , 1. - 1.5 * occ);    \n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c ) //iq\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb);\n    \n\treturn c.z * mix( vec3(1.), rgb, c.y);\n}\n\nconst vec3 ambCol = vec3(.01,.02,.03) * 3.;\nconst vec3 sunCol = vec3(1., .8, .7) * 1.;\nconst vec3 skyCol = vec3(.3, .6, 1.) * 1.;\nconst float specExp = 5.;\n\nvec3 Shade(vec3 col, float mat, vec3 p, vec3 n, vec3 rd, vec3 lP) \n{\n    vec3  lidi = normalize(lP - p);\n    float mafa = max(mat, .0),\n          amoc = CalcAO(p, n),\n          shad = SoftShadow(p + n*.015, lP, 2.),\n          diff = max(dot(n, lidi), 0.) * shad,\n          spec = pow(diff, max(1., specExp * mafa)),\n          refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mafa)) * shad,\n          indi = 1.;\n    \n    return mix( indi * mix(ambCol, skyCol, .03) * col * amoc +       //ambient\n                mix(diff * col * sunCol,                             //diffuse\n                (spec * col + refl * mafa), mafa) * sunCol,          //specular\n                \n                col  * S(0., 1., amoc * amoc + .5),                  //emission\n                max(-mat, 0.));\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., .85, .7);\n        case 1: return hsv2rgb_smooth(vec3(.61, .7, .5));\n        case 2: return hsv2rgb_smooth(vec3(.18, .3, .9));\n        case 3: return hsv2rgb_smooth(vec3(.3+.3*(.5+.5*sin(iTime/21.)), .6, .8));\n        case 4: return hsv2rgb_smooth(vec3(.95, .8, .6));\n    }\n    return vec3(0);\n}\n\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    vec3 ro = vec3(0., 20., -50. + sin3(iTime/42.) * 20.);\n    ro.yz *= Rot(m.y * PI/4. + PI/1.6);\n    ro.xz *= Rot(-m.x * PI + iTime/30.);\n    vec3 rd = R(uv, ro, vec3(0, 20, 0), 0.8);\n    \n    \n    vec3 lPos = vec3(1,3,3)*100.; \n    \n    vec3 col = skyCol;\n    vec3 p = vec3(0.);\n    \n    vec3 rmd = RayMarch(ro, rd);\n    p = ro + rd * rmd.x;\n    \n    vec3 bg = mix(vec3(0), skyCol, S(-100., 150., p.y));\n\n    if(rmd.x < MAX_DIST) \n    {\n        vec3 n = Normal(p);\n        \n        float shine = fract(rmd.z)*abs(rmd.z)/rmd.z;\n        int ix = int(floor(abs(rmd.z)));\n        col = Palette(ix);\n        \n        if (ix == 1) \n        {\n            n = n * (dot(sin(p.xz/2.*Rot(1.+.1*sin(iTime/8.))), cos(p.xz/3.)*Rot(1.+.1*sin(iTime/5.)))*.03 + 1.);\n            col = col * (1. + (p.y+.1)*5.);\n            col = col * (1. + .05*pow(clamp(S(250., 20., length(p))*(p.y+.1)*4.5, 0., 1.1), 30.));\n        }\n        else if (ix == 0) col = mix(col, vec3(.6), .5+.5*dot(sin3(p/17.+5.), cos(Rot(p/13., vec3(4)))));\n        \n        col = Shade(col, shine, p, n, rd, lPos);   \n        //col = vec3(1) * CalcAO(p, n);\n    }\n    \n    float disFac = S(0., 1., pow(rmd.x / MAX_DIST, 2.));\n    \n    col = mix(col, bg, disFac);\n    col += pow(max(0., rmd.y / float(MAX_STEPS)), 1.5) * normalize(ambCol) * GLOW_INT;\n    \n    float dir = dot(rd, normalize(lPos));\n    col += pow(dir * disFac * .5+.5, 10.) * sunCol *.4;\n    col += 2e-5/(1e-5+S(1., -1., dir * disFac)) * sunCol;\n    \n    col *= 1. - 1./(1. + iTime/3.);\n    \n    fragColor = PP(col, uv);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 31980,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/derschamane/mozhart-poweredub"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}