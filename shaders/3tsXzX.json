{
    "Shader": {
        "info": {
            "date": "1563767621",
            "description": "water",
            "flags": 0,
            "hasliked": 0,
            "id": "3tsXzX",
            "likes": 7,
            "name": "water12",
            "published": 3,
            "tags": [
                "water"
            ],
            "usePreview": 1,
            "username": "colton81",
            "viewed": 1006
        },
        "renderpass": [
            {
                "code": "//afl_ext 2017 \n\n// its from here https://github.com/achlubek/venginenative/blob/master/shaders/include/WaterHeight.glsl \nfloat wave(vec2 uv, vec2 emitter, float speed, float phase){\n\tfloat dst = distance(uv, emitter);\n\treturn pow((0.5 + 0.5 * sin(dst * phase - iTime * speed)), 5.0);\n}\n\n#define GOLDEN_ANGLE_RADIAN 2.39996\nfloat getwaves(vec2 uv){\n\tfloat w = 0.0;\n\tfloat sw = 0.0;\n\tfloat iter = 0.0;\n\tfloat ww = 1.0;\n    uv += iTime * 0.5;\n\t// it seems its absolutely fastest way for water height function that looks real\n\tfor(int i=0;i<6;i++){\n\t\tw += ww * wave(uv * 0.06 , vec2(sin(iter), cos(iter)) * 10.0, 2.0 + iter * 0.08, 2.0 + iter * 3.0);\n\t\tsw += ww;\n\t\tww = mix(ww, 0.0115, 0.4);\n\t\titer += GOLDEN_ANGLE_RADIAN;\n\t}\n\t\n\treturn w / sw;\n}\nfloat getwavesHI(vec2 uv){\n\tfloat w = 0.0;\n\tfloat sw = 0.0;\n\tfloat iter = 0.0;\n\tfloat ww = 1.0;\n    uv += iTime * 0.5;\n\t// it seems its absolutely fastest way for water height function that looks real\n\tfor(int i=0;i<24;i++){\n\t\tw += ww * wave(uv * 0.06 , vec2(sin(iter), cos(iter)) * 10.0, 2.0 + iter * 0.08, 2.0 + iter * 3.0);\n\t\tsw += ww;\n\t\tww = mix(ww, 0.0115, 0.4);\n\t\titer += GOLDEN_ANGLE_RADIAN;\n\t}\n\t\n\treturn w / sw;\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth){\n    vec2 ex = vec2(e, 0);\n    H = getwavesHI(pos.xy) * depth;\n    vec3 a = vec3(pos.x, H, pos.y);\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwavesHI(pos.xy - ex.xy) * depth, pos.y)), \n                           normalize(a-vec3(pos.x, getwavesHI(pos.xy + ex.yx) * depth, pos.y + e))));\n}\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n#define mouse (iMouse.xy / iResolution.xy)\nvec3 getRay(vec2 uv){\n    uv = (uv * 2.0 - 1.0)* vec2(iResolution.x / iResolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n    \n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), mouse.x * 2.0 - 1.0) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (mouse.y * 2.0 - 1.0)) * proj;\n    return ray;\n}\n\nfloat rand2sTimex(vec2 co){\n    return fract(sin(dot(co.xy * iTime,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n    vec3 pos = start;\n    float h = 0.0;\n    float hupper = depth;\n    float hlower = 0.0;\n    vec2 zer = vec2(0.0);\n    vec3 dir = normalize(end - start);\n    for(int i=0;i<318;i++){\n        h = getwaves(pos.xz) * depth - depth;\n        if(h + 0.01 > pos.y) {\n            return distance(pos, camera);\n        }\n        pos += dir * (pos.y - h);\n    }\n    return -1.0;\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\n\tsundir.y = max(sundir.y, -0.07);\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n\tfloat mymie = sundt * special_trick * 0.2;\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.004 * (special_trick + -6.0 * sundir.y * sundir.y));\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n\treturn bluesky2 + mymie * suncolor;\n} \nvec3 getatm(vec3 ray){\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\n    \n}\n\nfloat sun(vec3 ray){\n \tvec3 sd = normalize(vec3(1.0));   \n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n \t\n\tfloat waterdepth = 2.1;\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\n\tvec3 ray = getRay(uv);\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n    if(ray.y >= -0.01){\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\n        //tonemapping\n        C = normalize(C) * sqrt(length(C));\n     \tfragColor = vec4( C,1.0);   \n        return;\n    }\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\n    vec3 pos = orig + ray * dist;\n\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\n    vec2 velocity = N.xz * (1.0 - N.y);\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\n    vec3 R = reflect(ray, N);\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\t\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\n    //tonemapping\n    C = normalize(C) * sqrt(length(C));\n    \n\tfragColor = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}