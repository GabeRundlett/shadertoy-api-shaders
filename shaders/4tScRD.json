{
    "Shader": {
        "info": {
            "date": "1507580828",
            "description": "fork of \nhttps://www.shadertoy.com/view/XsfGWj\n\nEyeball R&D for Blitz Games Studios (which, sadly, closed today, hence me sharing this). Loosely based on Jorge Jimenez's Siggraph 2012 paper.",
            "flags": 16,
            "hasliked": 0,
            "id": "4tScRD",
            "likes": 9,
            "name": "unrealistic eye",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "subsurfacescattering",
                "eye"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1036
        },
        "renderpass": [
            {
                "code": "// Ben Weston - 15/08/2013\n\n/*\n-Eye ball effects:\nRay-marched shape\nRay-traced iris refraction\nFake photon mapping on iris\nSubsurface scattering on sclera\nHDR reflections with fresnel\nEyelid reflection occlusion\nEyelid ambient occlusion\nProcedural textures\nProcedural animation\n*/\n\n#define SpinningEye\n#define doFresnel\n#define doSpecular\n#define doAOEyelids\n\n// ------- EDIT THESE THINGS! -------\n\n// Constants\n#define tau 6.28318530717958647692\n\n#define u5(a) ((a)*.5+.5)\n\n// Precision controls\nconst float eps =.003;\nconst float eps1=eps*.5;//firstderivative epsilon should be smaller.\nconst float shadowOffset = .1;\nconst int traceDepth = 100; // takes time\n\n\n\n// Camera (also rotated by mouse)\nconst vec3 CamPos = vec3(0,0.0,-250.0);\nconst vec3 CamLook = vec3(0,0,0);\nconst float CamZoom = 10.0;\n//const float NearPlane = 0.0; // actually not needed\nconst float drawDistance = 1000.0;\nconst vec3 cSky = vec3(.4,.25,.2);//fillLightColour*.5;//vec3(.1,.3,.5);\n// Eye params\nconst float IrisAng    =tau/12.;\nconst float PupilAng   = (1.6*IrisAng/5.0);\nconst float EyeRadius  = 10.0;\nconst float BulgeRadius= 6.0; // used for photon trace, must be bigger than EyeRadius*sin(IrisAng)\n\n\n\n\n// KEY CONTROLS - (click on eye to give keyboard focus)\nconst int Key_M = 77; // mouse controls camera / eye direction\nconst int Key_E = 69; // refraction on/off\nconst int Key_P = 80; // photon mapping on/off\nconst int Key_L = 76; // change photon mapping technique (both fake, but one is imitating reality and the other is prettier)\nconst int Key_S = 83; // subsurface scattering on/off\nconst int Key_A = 65; // ambient occlusion on/off\nconst int Key_R = 82; // reflection on/off\nconst int Key_O = 79; // reflection eyelid occlusion on/off\nconst int Key_C = 67; // iris colour\nconst int Key_N = 78; // iris normal\n\n// Lights\n#if 0\n\t// High-contrast light edge-on\n\tconst vec3 lightDir = vec3(-2,2,.5);\n\tconst vec3 lightColour = vec3(1.0);\n\tconst vec3 fillLightDir = vec3(0,1,0);\n\tconst vec3 fillLightColour = vec3(.65,.7,.8)*.7;//vec3(.15,.2,.25);\n#else\n\t// more neutral \"good\" lighting (doesn't show off the effects)\n\tconst vec3 lightDir = vec3(-2,2,-1);\n\tconst vec3 lightColour = vec3(.83,.8,.78);\n\tconst vec3 fillLightDir = vec3(0,1,0);\n\tconst vec3 fillLightColour = vec3(.65,.7,.8);\n#endif\n\n\n\nvec2 Noise2( in vec3 x )\n{vec3 p = floor(x.xzy)\n;vec3 f = fract(x.xzy);f=f*f*(3.0-2.0*f);\n//vec3f2=f*f;f=f*f2*(10.0-15.0*f+6.0*f2);\n;vec2 u = (p.xy+vec2(37.0,17.0)*p.z) + f.xy\n;vec4 rg=textureLod( iChannel0,(u+.5)/256.,.0 )\n;return mix(rg.yw,rg.xz,f.z );}\n\t\t\nfloat Noise( in vec3 x ){return Noise2(x).x;}\n\n\n\n// Gamma correction\n#define GAMMA (2.2)\n// simulate a monitor, converting colour values into light values\nvec3 ToLinear(in vec3 col){return pow( col, vec3(GAMMA));}\n// convert back into colour values, so the correct light will come out of the monitor\nvec3 ToGamma( in vec3 col ){return pow( col, vec3(1./GAMMA));}\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle)\n{float keyVal = texture( iChannel3,vec2((float(key)+.5)/256.0,toggle?.75:.25 )).x\n;return (keyVal>.5)?true:false;}\n\nvec3 SkyDome(vec3 rd)\n{return mix(ToLinear(cSky)*2.0*Noise(rd)\n,vec3(8),smoothstep(.8,1.,rd.y/max((rd.x+1.),abs(rd.z))));}\n\n\nvec4 ComputeEyeRotation()\n{vec2 rot\n;if(!ReadKey(Key_M,true)&&iMouse.w>.00001\n)rot = .25*vec2(1.0,1.0)*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x\n;else\n{;float time = iTime*.5\n ;time+= Noise(vec3(0,time,0));\n //add noise to time (this adds SO MUCH character!)\n ;float flick = floor(time)+smoothstep(0.0,0.05,fract(time))\n //itnrpolates over noise to animate.\n ;rot=vec2(.2,.1)*tau\n *(texture(iChannel0, vec2((flick+.5)/256.,.5), -100.).rb-.5)\n;}\n;return vec4(cos(rot.x),sin(rot.x),cos(rot.y),sin(rot.y));}\n\n\nvec3 ApplyEyeRotation( vec3 u,vec4 r)\n{u.yz=r.z*u.yz+r.w*u.zy*vec2(1,-1)\n;u.xz=r.x*u.xz+r.y*u.zx*vec2(1,-1);return u;}\n\n// Shape\nfloat gd( vec3 u, vec4 r){u=ApplyEyeRotation(u,r);\n;vec2 s = vec2(length(u.xy),u.z);//slice\n;float aa=atan(s.x,-s.y);\n;float b = cos(tau*.2*aa/IrisAng);//iris bulge\n;b=b*.8-.8;\n;b*=smoothstep(tau*.25,0.0,aa);\t\n;b+=cos(tau*.25*aa/IrisAng)*.5*smoothstep(-.02,.1,IrisAng-aa); // slightly softer\n;return length(s)-EyeRadius-b;}\n\n\nfloat GetEyelidMask(vec3 u,vec4 r){\n;vec3 v=u;\n;float t=-.1;\n#ifdef SpinningEye\n;t=iTime*.3\n#endif\n;v.xy=cos(t)*u.xy+sin(t)*u.yx*vec2(1,-1);\n;float highLid=tan(max(tau*.05,asin(r.w)+IrisAng+.05));\n;float lowLid=tan(tau*.1);\n;float b=smoothstep(.0,.02,abs(Noise(vec3(iTime*.2,0,0))-.5 ))//blink\n;highLid*=b;\n;lowLid *=b;\n;return min((-v.z-2.0)-(-v.y/lowLid)\n           ,(-v.z-2.0)-(v.y/highLid));}\n\t\nfloat GetIrisPattern( vec2 u )\n{return Noise(vec3(10.*u/pow(length(u),.7), 0));}\n\n//return some noisy bumps for natural specular.\nvec3 bumps(vec3 p,float m){vec3 b=vec3(.7*Noise2(p*3.),0)\n;b.z=sqrt(1.-dot(b.xy,b.xy));return mix(vec3(0,0,1),b,m);}\n\nvec3 sss(vec3 n,vec3 lightDirN){\n;float ndotl=dot(n,lightDirN);\n;vec3 l=pow(ToLinear(vec3(.5,.3,.25)),vec3(mix( 3.,0.,smoothstep(-1.,.2,ndotl))));\n//\tfloat subsurface = max(0.0,-2.0*ndotl*EyeRadius);\n//\tl = pow(ToLinear(vec3(.5,.3,.25)),vec3(subsurface*.2)); // more intense the further light had to travel\n//fake,because that^ approximation gives a hard terminator\n;if(ReadKey( Key_S, true ))l=vec3(max(0.0,ndotl))\n//l = mix( l, vec3(max(0.0,ndotl)), 0.5 );\n;return l;}\n\nfloat vein(vec3 u,float a){\n;float t = atan(u.x,u.y)+Noise(u*1.)*tau*.03;\n;float v=(sin(t*60.)*.5+.5);\n;v*=v;\n;v*=u5(sin(t*13.));\n;return a*v*v*.5;}\n  \n\n#define u5(a)  ((a)*.5+.5)\n#define u25(a) ((a)*.25+.25)\n#define ss01(a) smoothstep(0.,1.,a)\n\n//iris photon sss?\n//irisAs() is subroutine of irisAs()\n//irisB is faster; -1 less normalize(sqrt())...\nvec3 irisAs(vec3 o,vec3 l){float d=dot(o,l)\n;return normalize(l+o*(cos(acos(d)/1.33)-d));}\n//return photonsFL and set photonsL of an iris\n//ppos,localLightDir,localFillLightDir,irisNorm,photonsL,rad\nfloat irisA(vec3 u,vec3 l,vec3 m,vec3 n,out float p,float r){\n;vec3 o=normalize(vec3(u.xy,-sqrt(max(.0,BulgeRadius*BulgeRadius-r*r)) ));\n//;l.z = -cos(acos(-l.z)/1.33); //debug visualize isolines\n//;m.z = -cos(acos(-m.z)/1.33); //debug visualize isolines\n;p=ss01(dot(n,irisAs(o,l)));//soften terminator\n;return u5(dot(n,irisAs(o,m)));}\nfloat irisB(vec3 u,vec3 l,vec3 m,vec3 n,out float p,float r){\n//reasonable match to the dark crescent effect seen in photos and offline photon mapping, but it looks wrong to me.\n;l.z=-cos(acos(-l.z)/1.5);;l=normalize(l);\n;m.z=-cos(acos(-m.z)/1.5);;m=normalize(m); \n;p=ss01(dot(n,l)); // soften the terminator\n;p*=.3+.7*smoothstep( 1.2,.9,length(u.xy/r+.2*l.xy/(l.z-.05)) );\n;return(dot(n,m)*.5+.5);}\n\n\n//[er]EyeRotation\nvec3 Shading(vec3 u,vec3 n,vec3 rd, vec4 er ){\n;vec3 view = normalize(-rd);\n\n;vec2 elm = vec2(GetEyelidMask(u, er),u.x/tan(tau*.23));\n;bool b=elm.x<0.0||(-u.z-3.0)<(u.x/tan(tau*.23));\n;b=any(lessThan(elm,vec2(0.,u.z+3.)));\n;if(b)return ToLinear(cSky);\n\t\n\t\n    //\n\tvec3 pos=ApplyEyeRotation(u,er);\t\n\tfloat ap=atan(length(pos.xy)/-pos.z);\n    ap+=tau*u25(sign(-ap));//if(ap<.0)ap+=tau/2.;\n\t\n // refract ray\n ;vec3 iR=ApplyEyeRotation(-view,er);\n ;vec3 localNorm=ApplyEyeRotation(n,er);\n ;if(!ReadKey(Key_E,true)){        \n  ;float a=dot(iR,localNorm)\n  ;iR+=localNorm*(cos(acos(a)*1.33)-a);}\n ;iR=normalize(iR)\t\n //intersect with plane\n ;float planeDist = -cos(IrisAng)*EyeRadius\n ;float t = (planeDist-pos.z)/iR.z\n ;vec3 ppos=t*iR+pos\n //polar coord map\n ;float r = length(ppos.xy)\n ;float irisr = EyeRadius*sin(IrisAng)\n ;vec3 rn=vec3(.001,0,0);rn.xy=vec2//irisNorm (initially its eps)\n (GetIrisPattern(ppos.xy-rn.xy)-GetIrisPattern(ppos.xy+rn.xy)\n ,GetIrisPattern(ppos.xy-rn.yx)-GetIrisPattern(ppos.xy+rn.yx));\n ;rn.xy+=-.01*normalize(ppos.xy)*sin(1.*tau*r/irisr)//add bumps\n ;rn.z=-.15// scale bumps\n ;rn =normalize(rn);\n ;if(ReadKey(Key_N,true))rn=-vec3(0,0,1);\n\t\t\n // crudely sampling the photon mapping density lighting\n //apply lighting with this modified normal\n ;vec3 ln = normalize(lightDir)\n ;vec3 l=ApplyEyeRotation(ln,er)\n //Bend light imitate of offline photon-mapping:\n // Jimenez's paper makes this seem very complex\n // ,because their mapping used a non-flat receiver\n // With neglible self-shadowing, the main effect condenses to; [multiply by a normal]\n //  We would get better results by using the actual normal.\n ;vec3 m=ApplyEyeRotation(normalize(fillLightDir),er);//is needed later on\n ;float photonsL, photonsFL;//iris photon party\n ;if(!ReadKey(Key_P,true)){\n  ;if(!ReadKey(Key_L,true)){\n  ;photonsFL=irisA(ppos,l,m,rn,photonsL,r)\n ;}else{\n  ;photonsFL=irisB(ppos,l,m,rn, photonsL,irisr)\n ;}\n }else{\n ;photonsL = max( 0.0, dot(rn,l) ) \n ;photonsFL = .5+.5*dot(rn,l);}\n;vec3 ambientOcclusion = vec3(1),eyelidShadow = vec3(1);\n#ifdef doAOEyelids\nif(!ReadKey(Key_A,true)){\n ;float elms=smoothstep(5.,0.,elm.x)\n ;ambientOcclusion = mix( vec3(1),ToLinear(vec3(.8,.7,.68)),pow(elms,1.) );\n ;float gelm=smoothstep(2.,-2.,GetEyelidMask(u+lightDir*1.0,er));\n ;eyelidShadow=mix(vec3(1),ToLinear(vec3(.8,.7,.68)),gelm);}\n#endif\nvec3 pl=photonsL *ToLinear(lightColour);\nvec3 fl=photonsFL*ToLinear(fillLightColour);\n;fl*=ambientOcclusion\n;l*=eyelidShadow\n//iris color base: \n;float pupilr = EyeRadius*sin(PupilAng);\n;float irisPattern = GetIrisPattern(ppos.xy); // reduce contrast of this now we have actual lighting!\n//;vec3 iris=mix(mix( vec3(.3,.1,.1)*.5+.5*vec3(.6,.4,.1), vec3(.6,.4,.1), irisPattern ) // hazel\n//         ,mix(vec3(.2,.2,.2)*.5+.5*vec3(.5,.45,.2), vec3(.5,.45,.2), irisPattern );//...\n//;vec3 iris=mix(mix( vec3(.1,.1,.4), vec3(.7,.9,1), irisPattern ) // blue\n//\t\t   ,mix( vec3(.1,.1,.4), vec3(.3,.4,.7), irisPattern )\n//         ,smoothstep(pupilr*2.0,irisr,r));\n\n;float ssass= mix(smoothstep(pupilr,irisr,r),Noise(ppos),.7)\n;vec3 sexp=2.*vec3(1.2-sqrt(irisPattern));\n;sexp =pow(vec3(.65,.82,.85),sexp);\n;vec3 iris=ToLinear(mix(sexp,vec3(1,.5,.2),.7*ssass*ssass));\n;if ( ReadKey( Key_C, true ) )iris = vec3(1);\n;iris*=pow(smoothstep(irisr+1.,irisr-1.5,r),GAMMA)//darken outer\n;iris*=pl+fl//iris occlusion\n;iris*=smoothstep(pupilr-.01,pupilr+.5,r)//darken pupil\n;float veins=vein(pos,smoothstep(IrisAng,tau*.2,ap))\n;vec3 sclera=ToLinear(mix(vec3(1,.98,.96),vec3(.9,.1,0),veins))\n#ifndef doSss\n;pl=sss(n,ln)\n#endif\n;pl*=ToLinear(lightColour)*eyelidShadow; \n;fl=ToLinear(fillLightColour)*u5(dot(n,m))\n;fl*=ambientOcclusion\n;float bsi=smoothstep(-.1,.1,ap-IrisAng)//BlendScaleraIris\n;vec3 ir=mix(iris,sclera*(pl+fl),bsi)//this ir has a different context than the other iR!\n// eyelid ambient occlusion/radiosity\n//;if ( !ReadKey( Key_A, true ))\n//r*= mix(vec3(1),ToLinear(vec3(.65,.55,.55)),exp2(-elm.x*2.));\n//r*= mix(vec3(1),ToLinear(vec3(.8,.7,.68)),pow(smoothstep( 5.,.0,elm.x ),1.));\n// bumps - in specular only to help sub-surface scattering look smooth\n;vec3 bump=bumps(pos,bsi)\n;n.xy+=bump.xy*.1\n;n=normalize(n)\t\n//reflection map\n;float ndoti=dot(view,n);vec3 reflection=SkyDome(-view+2.0*ndoti*n);\n;float glossiness=mix(.7,1.,bump.z);\n#ifdef doFresnel\n;float fresnel=mix(.04*glossiness,1.,pow(1.-ndoti,5.));\n;if(!ReadKey(Key_R,true))ir=mix(ir,reflection,fresnel);\n#endif\n//ideally fressnel commutes before specular,simple model sums anyways.\n#ifdef doSpecular   \n;vec3 h = normalize(view+lightDir);\n;float specular = pow(max(0.0,dot(h,n)),2000.0);\n;reflection+=specular*32.*glossiness*ToLinear(lightColour);\n#endif    \n;if(!ReadKey(Key_O,true))\n{float g=GetEyelidMask(normalize(u+rd*2.)*EyeRadius,er);\n ;reflection*=smoothstep(.8,1.,g);}\n//anti-alias the edge\n;float mask2=max(-elm.x,u.z+3.+u.x/tan(tau*.23));\n;mask2=smoothstep(.0,.3,-mask2)\n;return mix(ToLinear(cSky),ir,mask2);}\n\n//y=er\nfloat Trace(vec3 u,vec3 t, vec4 y){float r=.0,d=1.\n;for(int i=0;i<traceDepth;i++\n){\n// ;bool b= abs(r-.5*(drawDistance))>drawDistance////drawDistance>r||r>.0\n//if(abs(s-.5*(b-a))<b-a)==if(b<s||s<a)   \n//;b=abs(d)<eps1||b\n ;bool b=any(lessThan(vec2(abs(d),drawDistance),vec2(eps1,abs(r-.5*drawDistance)))) \n ;if(b)continue\n ;d=gd(u+t*r,y);r= r+d;}return r;}//vec4(ro+rd*r,d);\n\n// get normal\nvec3 GetNormal(vec3 p,vec4 r){const vec2 d=vec2(eps1,0)\n;return normalize(vec3(gd(p+d.xyy,r)-gd(p-d.xyy,r)\n,gd(p+d.yxy,r)-gd( p-d.yxy,r),gd(p+d.yyx,r)-gd( p-d.yyx,r)));}\t\t\t\t\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 GetRay(vec3 d,float z, vec2 u)//dir,zoom,uv\n{u-=.5;;u.x*=iResolution.x/iResolution.y\n;d=z*normalize(d)\n;vec3 r=normalize(cross(vec3(0,1,0),d));//right\n;vec3 p=normalize(cross(d,r));//up\n;return d+r*u.x+p*u.y;}\n\nvoid mainImage(out vec4 o,in vec2 u){o.w=1.;u=u/iResolution.xy\n;vec3 p=CamPos,t=CamLook\n;vec2 camRot=.5*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x\n;if(!ReadKey(Key_M,true))camRot=vec2(0)\n;p.yz=cos(camRot.y)*p.yz+sin(camRot.y)*p.zy*vec2(1,-1);\n;p.xz=cos(camRot.x)*p.xz+sin(camRot.x)*p.zx*vec2(1,-1);\n;vec4 r=ComputeEyeRotation();\n//underground camera:\n//;if(gd(p,er)<=0.){o=vec4(0);return;}\n;t=GetRay(t-p,CamZoom,u);\n//This is where I would put my zNears, if I had any!\n//;p+=t*(NearPlane/CamZoom);\n;t=normalize(t);\n;float q=Trace(p,t,r)\n;o.xyz=ToLinear(cSky)\n;if(q>.0&&q<drawDistance\n){p+=q*t\n ;vec3 n=GetNormal(p,r)\n ;float s=1.;// shadow test\n //;if(Trace(p+lightDir*shadowOffset,lightDir,r)\n // <drawDistance)s=.0;\n  o.xyz=Shading(p,n,t,r );\n  //o.xyz=mix(cSky,result,exp(-t*t*.000001) );//fog\n  ;o.xyz=ToGamma(o.xyz)\n  //;o.w=1.;\n;}}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}