{
    "Shader": {
        "info": {
            "date": "1672091636",
            "description": "Tube",
            "flags": 0,
            "hasliked": 0,
            "id": "clXGzX",
            "likes": 13,
            "name": "[Tube]",
            "published": 3,
            "tags": [
                "tube"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 225
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n// Useful for filling inside of shape\n/*\nvec2 ellipse(vec2 f, vec2 p, float r, float sy, float sx) {\n    f -= round(p);\n    return vec2(abs(f.x) - round(sy*sqrt(r*r-f.y*f.y/(sx*sx))),\n                abs(f.y) - round(sx*sqrt(r*r-f.x*f.x/(sy*sy))));                           \n}\n//*/\n\n// Sometimes has sharp corners\nfloat ellipse(vec2 f, vec2 p, float r, float sy, float sx) {\n    f -= round(p);\n    // For a function F(), we check that either:\n    // f.x == F(f.y) or f.y == F^-1(f.x)\n    // f.xy takes integer values and so does F(), F^-1()\n    // so equality is possible\n    // https://www.desmos.com/calculator/1kwd2kzxmp\n    float dx = abs(abs(f.x) - round(sy*sqrt(r*r-f.y*f.y/(sx*sx))));\n    float dy = abs(abs(f.y) - round(sx*sqrt(r*r-f.x*f.x/(sy*sy))));                         \n    return step(min(dx,dy), 0.);         \n}\n\n// Unused, but cheaper method if you only need circles\nfloat circle(vec2 f, vec2 p, float r) {\n    f = abs(f - p);\n    r *= r;\n    float d = dot(f, f);\n    float h = dot(f - vec2(1,0), f - vec2(1,0));\n    float v = dot(f - vec2(0,1), f - vec2(0,1));\n    return step(min(h,v),r) - step(d,r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    float t = iTime;\n    vec2 res = iResolution.xy;   \n    vec2 uv = (f - 0.5 * res) / res.y;\n    float sc = 75.;\n    vec2 ipos = round(sc * uv) - 0.;\n\n    vec2 p = vec2(0);\n\n    // Start oscillating tube after 8 seconds\n    float mx = clamp(t - 8., 0., 1.);\n    \n    float n = 64.;\n    bool reverse = (sin(t) < 0.); // sin(2t) is cool too\n    for (float i = 0.; i <= n; i++) {\n        // Reverse the for loop when tube has rotated pi radians\n        // (so darker tube colors get drawn first)\n        if (reverse) i = n - i;\n        \n        // Offset tube value\n        float io = 2. * pi * i / n;\n        \n        // Tube (tube)\n        vec2 p2 = p + (i-n/2.) * vec2(cos(t),0.);\n        \n        // Squash each circle as they turn (tube)\n        float c = abs(sin(t));        \n        \n        // Tube\n        float el = ellipse(ipos, p2, \n                           14.5 + mx * 6. * thc(20.,.75*t+.25*io), \n                           c, 1.);\n                           \n        // Tube colors\n        float drk = ceil(i/n * 6.) / 6.;\n        if (col.b == 0.) \n            col.b = drk * el * (1.+8.*sign(uv.y)*uv.y*uv.y);          \n               \n        // Reset tube index\n        if (reverse) i = n - i;\n   }\n   \n   col = vec3(.6, .4, 1) * col.b + 0.16;\n   \n   fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}