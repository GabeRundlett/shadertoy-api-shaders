{
    "Shader": {
        "info": {
            "date": "1634012917",
            "description": "Same as original: Click and drag to set vertex position. \n\nInspired by [url]https://twitter.com/cs_kaplan[/url]. See [url]https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling[/url] for details.",
            "flags": 0,
            "hasliked": 0,
            "id": "sstSD2",
            "likes": 9,
            "name": "Fork pentagonal tiling variation",
            "published": 3,
            "tags": [
                "tiling",
                "pentagonal",
                "variations",
                "cairo"
            ],
            "usePreview": 0,
            "username": "alvarobyrne",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////\n//original at https://www.shadertoy.com/view/fs3SWj\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//     https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//     https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//     https://www.shadertoy.com/view/ltBBzK\n//     (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 10.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    lcoord = vec2(-10.0);\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 10.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    //lpos=vec3(1.,0.0,-10.00);\n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );\n    hgrad = vec2(0.5/h);\n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color;\n    color = CELL_COLORS[cell];\n    color= vec3(1.);\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    //color = vec3(0.5);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R;\n    R=reflect(L, N);\n    R= vec3(1.0);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0., 10./iResolution.y, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}