{
    "Shader": {
        "info": {
            "date": "1697180763",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "DsdBWN",
            "likes": 4,
            "name": "spqr domain trick 12",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "spqr",
            "viewed": 178
        },
        "renderpass": [
            {
                "code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(sin((p3.x + p3.y) * p3.z)*3523.252);\n}\nvec3 hash33 (vec3 p) {\n    float x = hash31(p);\n    float y = hash31(p + vec3(1231.41, 48.42, 77.12));\n    float z = hash31(p + vec3(17.94, 111.42, 212.55));\n    return vec3(x,y,z);\n    \n}\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n   // return max(max(q.x,q.y),q.z);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm31( vec3 a)\n{\n    vec3 p = vec3(a);\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n  \n    return f;\n}\nvec3 fbm33 (vec3 a) {\n    float x = fbm31(a);\n    float y = fbm31(a + vec3(12.99,53.12,193.11));\n    float z = fbm31(a + vec3(83.11, 121.53, 221.59));\n    \n    return vec3(x,y,z);\n    \n    \n}\nfloat sph (vec3 p, float n) {\n    return length(p) -n ;\n}\nfloat jerk (float t) {\n    float i =floor(t);\n    float r =fract(t);\n    r = pow(r,6.);\n \n    \n    return i + r;\n}\nfloat field (vec3 p, float scale) {\n   \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   vec3 f1 = hash33(id*10.);\n \n \n  \n   float ball = box(p + vec3(f1*sin(jerk(iTime))*.3), vec3(.1));\n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball*.8)/scale;\n}\nfloat map (vec3 p){\n    // geo\n\n   float a =field(p,1.);\n   return a;\n  \n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat tick(float t){\n    float i = floor(t);\n    float f = fract(t);\n    f = smoothstep(0.,1.,f);\n    return i + f;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat path (float t) {\n    float a = sin(sin(t) + .3 * t);\n    return a;\n    \n}\nfloat pathfbm(float t) {\n    float a = 0.;\n    \n    a += path( (t+0. ) );\n    a += path( (t+21.)*2.)/2.1;\n    a += path( (t+211.)*5.)/5.1;\n    \n    return a/2.;\n}\n\nfloat glider(float t) {\n    float dip_interval = 20.0;\n    float dip_depth = 10.0;\n    \n    // Up and down fluctuating motion\n    float y_sine = 5.0 * sin(0.2 * t);\n    \n    // Time since last dip\n    float time_since_last_dip = mod(t, dip_interval);\n    \n    // Modulating function that drops quickly but recovers slowly\n    float modulating_func = 1.0 - sin(time_since_last_dip + 0.5 * sin(time_since_last_dip));\n    \n    // Gaussian dip function\n    float y_gauss = -dip_depth * exp(-pow((time_since_last_dip - dip_interval / 2.0), 2.0) / (2.0 * pow((dip_interval / 6.0), 2.0)));\n    \n    // Continuously blend the Gaussian and sinusoidal functions, modulated by the new function\n    float h = y_sine + y_gauss * modulating_func;\n    \n    // Scale the output by a factor of 3\n    h /= 3.0;\n    \n    return h;\n}\n\nfloat gliderfbm(float t) {\n  float n = 0.;\n  n += glider(t);\n  n += glider((t+5.12) * 2.)/2.;\n  //n += glider((t+11.42) * 4.)/4.;\n  return n;\n  \n}\nfloat fbmao (vec3 p, vec3 n, float aodist ) {\n    float val = 0.;\n    for (float i = 0.; i < 2.; i++) {\n        val += (getao(p,n,aodist *.2 * pow(1.5,i))* 0.5 + 0.5)/(i+1.);\n    }\n    return +val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  float tt = iTime * .4;\n \n  // nav\n\n\n\n  vec3 s = vec3(0);\n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(cos(tt*.2));\n  arm.zy *= rot(cos(tt*.3));\n  vec3 t = s + arm;\n  \n  vec3 fwd = vec3(0,0,1) * tt;\n  \n  s += fwd;\n  t += fwd;\n \n\n \n\n  \n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z <200.; ++z) {\n    i = z;\n    d=abs(map(p));\n    if(d<0.001) {\n      hit = true;\n      break;\n    }\n    if ( dd > 100.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n  vec3 light1 = normalize(vec3(-1));// + t)/2.;//normalize(vec3(5,-5,-1));\n  vec3 light2 = normalize(vec3(2,3,-5));// + t)/2.;//normalize(vec3(5,-5,-1));\n\n  \n  if (dot(n,light1) < 0.) {\n      light1 = -light1;\n  }\n   if (dot(n,light2) < 0.) {\n      light2 = -light2;\n  }\n  \n  \n  vec3 col = vec3(.6)*1.3;\n  float aodist = .4;\n  \n  float fresnel = 1. - dot(n,r);\n  float ao =(getao(p,n,aodist*0.35)*0.5+0.5);\n  //float ao =// fbmao(p,n,aodist *.2);\n  //    (getao(p,n,aodist*.2)*0.5+0.5) * \n  //    (getao(p,n,aodist*0.35)*0.5+0.5) * \n  //    (getao(p,n,aodist*0.5)*0.5+0.5);\n  //float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n  float diff1 = dot(n,light1)*.9+.5;\n  float diff2 = dot(n,light2)*.9+.5;\n \n  float spec1 =pow(max(dot(reflect(-light1,n),-r),0.),1.) * 1.;\n  float spec2 =pow(max(dot(reflect(-light2,n),-r),0.),1.) * 1.;\n  //float iff = pow(1.-i/100.,2.);\n  \n  \n  //col *= diff;\n  col *= ao;\n  col *= (spec1 + spec2)/2.;\n  col *= (diff1 + diff2)/2.;\n // col *= spec2;\n  \n  //col += fresnel;\n  //col *= diff;\n\n  \n \n \n  if ( ! hit ) {\n\n    col = vec3(1) - pow(r.y,.2);\n  }\n\n  //col = vec3(1) * fbm(uv*10.+iTime);\n \n  //col = vec3(1) * fbm(uv*10.);\n  if (length(col) > 1.5) {\n      col = vec3(0);\n  }\n  col = smoothstep(0.,1.,col)*2.;\n  //col = sqrt(col);\n  fragColor = vec4(col, 1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}