{
    "Shader": {
        "info": {
            "date": "1491390804",
            "description": "This shader was created as part of a small first demoscene project for a university course.\nThe viewer flies through an endless reflective tunnel.\n\nYou can watch the demo this was taken from here: https://www.youtube.com/watch?v=eUk_yZvCj5s",
            "flags": 0,
            "hasliked": 0,
            "id": "4d2yRm",
            "likes": 10,
            "name": "3D reflective raymarching tunnel",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "reflection",
                "tunnel",
                "lighting"
            ],
            "usePreview": 0,
            "username": "croxxx",
            "viewed": 820
        },
        "renderpass": [
            {
                "code": "// ##############################\n// BEGIN\tIQ methods\n// ##############################\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n\t// n must be normalized\n\treturn dot(p,n.xyz) + n.w;\n}\nfloat sdTorus88( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length8(p.xy)-t.x,p.z);\n\treturn length8(q)-t.y;\n}\n\n// Union\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1,d2);\n}\n// Substraction\nfloat opS( float d1, float d2 )\n{\n\treturn max(-d1,d2);\n}\n// Repetition\nvec3 opRep( vec3 p, vec3 c )\n{\n\treturn mod(p,c)-0.5*c;\n}\n// ##############################\n// END\t\tIQ methods\n// ##############################\n\n// ##############################\n// BEGIN\tCamera helpers\n// ##############################\nfloat iCamPosX = 0.0;\nfloat iCamPosY = 0.0;\nfloat iCamPosZ = 0.0;\nfloat iCamRotX = 0.0;\nfloat iCamRotY = 0.0;\nfloat iCamRotZ = 0.0;\n\nvec3 calcCameraPos()\n{\n\treturn vec3(iCamPosX, iCamPosY, iCamPosZ);\n}\nvoid rotateAxis(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution)\n{\n\tfloat tanFov = tan(fov / 2.0 * 3.14159 / 180.0) / resolution.x;\n\tvec2 p = tanFov * (fragCoord * 2.0 - resolution.xy);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 1.0));\n\trotateAxis(rayDir.yz, iCamRotX);\n\trotateAxis(rayDir.xz, iCamRotY);\n\trotateAxis(rayDir.xy, iCamRotZ);\n\treturn rayDir;\n}\n// ##############################\n// END\t\tCamera helpers\n// ##############################\n\nconst vec3 repSpacing = vec3( 50.0, 50.0, 1.5 );\n\n//\tCalculates distance to nearest object given a point\nfloat distFunc( vec3 point )\n{\n\tvec3 point2 = opRep( point, repSpacing );\n\trotateAxis( point2.xy, (iTime+floor(point.z/repSpacing.z))/4.0 );\n\treturn sdTorus88( point2-vec3( 0, 0, 0 ), vec2( 2.0, 0.5 ) );\n}\n\n\nvec3 getNormal( in vec3 pos )\n{\n\t// IQ\n\tvec2 e = vec2( 1.0,-1.0 ) * 0.001;\n\treturn normalize( e.xyy*distFunc( pos + e.xyy ) +\n\t\t\t\t\t  e.yyx*distFunc( pos + e.yyx ) +\n\t\t\t\t\t  e.yxy*distFunc( pos + e.yxy ) +\n\t\t\t\t\t  e.xxx*distFunc( pos + e.xxx ) );\n}\n\nbool isEdge(const vec3 point)\n{\n\tfloat d = 0.05;\n\t//get points a little bit to each side of the point\n\tvec3 right = point + vec3(d, 0.0, 0.0);\n\tvec3 left = point + vec3(-d, 0.0, 0.0);\n\tvec3 up = point + vec3(0.0, d, 0.0);\n\tvec3 down = point + vec3(0.0, -d, 0.0);\n\tvec3 behind = point + vec3(0.0, 0.0, d);\n\tvec3 before = point + vec3(0.0, 0.0, -d);\n\n\tvec3 normRight = getNormal(right);\n\tvec3 normLeft = getNormal(left);\n\tvec3 normUp = getNormal(up);\n\tvec3 normDown = getNormal(down);\n\tvec3 normBehind = getNormal(behind);\n\tvec3 normBefore = getNormal(before);\n\n\tvec3 normal = getNormal(point);\n\n\tconst float limit = 0.99;\n\n\t// float gradient1 = abs(dot(normal, normRight - normLeft));\n\t// float gradient2 = abs(dot(normal, normUp - normDown));\n\t// float gradient3 = abs(dot(normal, normBehind - normBefore));\n\n\tif(abs(dot(normal, normRight)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normLeft)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normUp)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normDown)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normBehind)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normBefore)) < limit) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\n//vec3 lightColor = clamp(vec3( afFrequencies[0]+afFrequencies[1], afFrequencies[2]+afFrequencies[3], afFrequencies[4]+afFrequencies[5] ), 0.0, 1.0);\n\n\nconst float lightAttenuation = 0.02;\nvec3 getShadedColor( vec3 hitPosition, vec3 normal, vec3 cameraPosition )\n{\n\t//\tlight relative to camera position\n\tvec3 lightPosition = vec3(sin(iTime), 1.0, cos(iTime));\n\tlightPosition += cameraPosition;\n\n\t//\tSpecular highlight factor\n\tfloat materialShininess = 16.0;\n\tvec3 materialSpecularColor = vec3( 1.0 );\n\n\t//\tOutput color\n\tvec3 outputColor = vec3( 0.0 );\n\n\t//\tCalculate eye vector and its reflection\n\t//vec3 ev = normalize( hitPosition - cameraPosition );\n\t//vec3 ref_ev = reflect( ev, normal );\n\tvec3 surfaceToLight = normalize(lightPosition - hitPosition);\n\tvec3 surfaceToCamera = normalize(cameraPosition - hitPosition);\n\n\t//\tsurface color\n\tvec3 surfaceColor = vec3( 1.0 );\n\n\t//\tedge detection\n\t// if(isEdge(hitPosition))\n\t// {\n\t// \tsurfaceColor = vec3( 0.3 );\n\t// }\n\n\t//\tambient component\n    vec3 lightColor = vec3(abs(sin(iTime*0.84)), abs(cos(iTime)), abs(sin(iTime*1.337)))*0.5;\n\tvec3 ambientColor = surfaceColor * lightColor * 0.0; // ambient factor\n\n\t//\tdiffuse component\n\tfloat diffuseCoefficient = max(0.0, dot(normal, surfaceToLight));\n\tvec3 diffuseColor = diffuseCoefficient * surfaceColor * lightColor;\n\n\t//\tspecular component\n\tfloat specularCoefficient = 0.0;\n\tif(diffuseCoefficient > 0.0) {\n\t\tspecularCoefficient = pow(max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, normal))), materialShininess);\n\t}\n\tvec3 specularColor = specularCoefficient * materialSpecularColor * lightColor;\n\n\t//\tlight attenuation (falloff based on distance, fog)\n\tfloat distanceToLight = length(lightPosition - hitPosition);\n\tfloat attenuation = 1.0 / (1.0 + lightAttenuation * pow(distanceToLight, 2.));\n\n\toutputColor = ambientColor + attenuation*(diffuseColor + specularColor);\n\n\t//\tgamma correction\n\t//vec3 gamma = vec3(1.0/2.2);\n\t//outputColor = vec3(pow(outputColor, gamma));\n\n\t//\treturn shading result\n\treturn outputColor;\n}\n\nconst float epsilon = 0.0001;\nconst int maxSteps = 256;\nconst float maxT = 110.0;\nfloat trace(vec3 ro, vec3 rd, out vec3 point, out bool objectHit)\n{\n\tfloat t = 0.0;\n\tpoint = ro;\n\n\tfor(int steps = 0; steps < maxSteps; ++steps)\n\t{\n\t\t//check how far the point is from the nearest surface\n\t\tfloat dist = distFunc(point);\n\t\t//if we are very close\n\t\tif(epsilon > dist)\n\t\t{\n\t\t\tobjectHit = true;\n\t\t\tbreak;\n\t\t}\n\t\t//not so close -> we can step at least dist without hitting anything\n\t\tt += dist;\n\t\t// return immediately if maximum t is reached\n\t\tif(t > maxT)\n\t\t{\n\t\t\tobjectHit = false;\n\t\t\treturn maxT;\n\t\t}\n\t\t//calculate new point\n\t\tpoint = ro + t * rd;\n\t}\n\n\treturn t;\n}\n\nconst int reflectionBounces = 2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//\tSet up Camera\n\tvec3 camP = calcCameraPos(); // Camera position\n\tcamP += vec3( repSpacing.x/2.0+sin( iTime ), repSpacing.y/2.0+cos( iTime ), 6.0*iTime );\n\tvec3 camDir = calcCameraRayDir( 80.0, fragCoord.xy, iResolution.xy ); // Camera view direction\n\n\t//\tSet up ray\n\tvec3 point;\t\t// Set in trace()\n\tbool objectHit;\t// Set in trace()\n\n\t//\tInitialize color\n\tvec3 color = vec3(0.0);\n\n\tfloat t = trace(camP, camDir, point, objectHit);\n\tif(objectHit)\n\t{\n\t\t//\tLighting calculations\n\t\tvec3 normal = getNormal(point);\n\t\tcolor = getShadedColor( point, normal, camP );\n\n\t\t//\tReflections\n\t\tfor(int i = 0; i < reflectionBounces; i++)\n\t\t{\n\t\t\tvec3 pointRef;\t// Set in trace()\n\t\t\tcamDir = reflect(camDir, normal);\n\t\t\ttrace(point + camDir*0.001, camDir, pointRef, objectHit);\n\t\t\tif(objectHit)\n\t\t\t{\n\t\t\t\t// Get color of reflection\n\t\t\t\tcolor += 0.3 * getShadedColor( pointRef, getNormal(pointRef), point );\n\t\t\t}\n\t\t\tpoint = pointRef;\n\t\t}\n\t}\n\n\t//\tfog\n\tvec3 fogColor = vec3( 0.1, 0.1+0.4*(1.0-sin(iTime)), 0.1+0.5*(1.0-sin(iTime)) );\n\tfloat FogDensity = 0.05;\n\tfloat fogFactor = 1.0 /exp(t * FogDensity);\n\tfogFactor = clamp( fogFactor, 0.0, 1.0 );\n\tcolor = mix(fogColor, color, fogFactor);\n\n\tfragColor = vec4(color, 0.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}