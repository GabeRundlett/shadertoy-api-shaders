{
    "Shader": {
        "info": {
            "date": "1558284825",
            "description": "Cookie",
            "flags": 0,
            "hasliked": 0,
            "id": "wllGDX",
            "likes": 5,
            "name": "Cookie Collective - 15/05/2019",
            "published": 3,
            "tags": [
                "cookie"
            ],
            "usePreview": 0,
            "username": "Fusion",
            "viewed": 429
        },
        "renderpass": [
            {
                "code": "// Les formes - https://iquilezles.org/articles/distfunctions\nvec3 rotatingColor (float time) {\n    float pi = 3.141592;\n    float demiPi = pi / 2.0;\n    \n    vec3 color = vec3(0.0);\n    vec3 index = vec3(mod(time, pi + demiPi) - demiPi,\n                      mod(time + demiPi, pi + demiPi) - demiPi,\n                      mod(time + pi, pi + demiPi) - demiPi);//Goes from -1 to 2\n    \n    if (index.x < demiPi)\n    color.y = abs(cos(index.x));\n   \n    if (index.y < demiPi)\n    color.z = abs(cos(index.y));\n    \n    if (index.z < demiPi)\n    color.x = abs(cos(index.z));\n\n\treturn color;\n}\n\n\nmat2 rotation(float a){\n \tfloat c = cos(a);\n    float s = sin (a);\n    \n    return mat2(c,s,-s,c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat map (vec3 pos)\n{\n    pos.xy *= rotation(pos.z * .3); //Faire une rotation\n \tpos.z -= iTime * .5; //Fait avancer en profondeur\n    \n    float size = 2.;\n    pos = mod(pos, size)-size/2.; //position de la \"boite\" Modulo\n    \n    float distanceToGeometry = sdBox(pos, vec3(.45)); //Taille de la sphÃ¨re\n    return distanceToGeometry;\n}\n    \n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = fragCoord/iResolution.xy;\n    position = position *2. -1.; //Remet la position au centre \n    \n    position.x *= iResolution.x / iResolution.y;\n    \n    //float circle = length(position)-0.5;\n    //circle = step(abs(sin(iTime))/2., circle);\n    //circle = step(1., circle);\n    \n    \n    \n    vec3 eye = vec3(0,0,-2);\n    vec3 ray = normalize(vec3(position, 1.));\n    vec3 currPos = eye;\n    float shade = 0.0;\n    for (int index = 0; index < 75; ++index)\n    {\n        float dist = map(currPos);\n        if (dist < 0.0001) {\n            shade = 1.0-float(index)/75.;\n            break;\n        }\n        currPos += ray * dist *.5;\n    }\n    \n    \n    \n    \n    \n    \n    //fragColor = vec4(pow(1.-length(pos - eye) /3., 2.));\n    //fragColor= vec4(pow(shade, 2.));\n    fragColor = vec4(shade); //shade,pow(shade/2., .7),0.,0.);\n    \n    float invertedShade = abs(shade - 1.0);\n    fragColor = vec4(fragColor.xyz * rotatingColor(iTime - (currPos.z / 10.)),  0.0);\n    fragColor += vec4(vec3 (invertedShade),  0.0);\n    \n    \n    //fragColor *= (currPos.z) * (abs(sin(iTime) / 2.) + 0.5);\n    \n    //fragColor.r = fragColor.r * (currPos.z) * (abs(sin(iTime) / 2.) + 0.5);\n\t//fragColor.g *= (abs(sin(iTime)) /3. + 0.6);\n    //fragColor.g = sin(currPos.y);\n    \n    \n    //fragColor = vec4(abs(position),10.*fract(iTime/5.)/5.,10.);\n}\n\n\n\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.);",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}