{
    "Shader": {
        "info": {
            "date": "1722644168",
            "description": "laser show visualizer ",
            "flags": 36,
            "hasliked": 0,
            "id": "4fScR3",
            "likes": 1,
            "name": "Fork Inside nuc NikolaErce 064",
            "published": 3,
            "tags": [
                "sound",
                "fft",
                "godrays",
                "laser"
            ],
            "usePreview": 0,
            "username": "NikolaErceg",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "// Hacked together by 0rblivius\n\n// Sources: https://glslsandbox.com/e#60588.0 \n//          https://glslsandbox.com/e#60805.1 \n//          https://www.shadertoy.com/view/4tyfWy\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //output\n     vec4 r1 = texture(iChannel0, fragCoord/iResolution.xy).rgba;\n    vec4 r2 = texture(iChannel1, fragCoord/iResolution.xy).rgba;\n         fragColor = r1+r2;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define resolution iResolution.xy\n#define time iTime\n#define pi 3.1415926\n#define tau pi*2.\n\nvec2 cmul(vec2 z1, vec2 z2) { return vec2(z1.x * z2.x - z1.y * z2.y, z1.x * z2.y + z1.y * z2.x ); }\nvec2 cdiv(vec2 z1, vec2 z2) { vec2 conj = vec2(z2.x, -z2.y); return cmul(z1, conj) / (length(z2) * length(z2)); }\n\nvec2 ccos(vec2 z)\t\t\t{ return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y)); }\nvec2 csin(vec2 z)\t\t\t{ return vec2(sin(z.x) * cosh(z.y),  cos(z.x) * sinh(z.y)); }\n\nvec2 newton(vec2 z)\t\t\t{ return z - (1.35 - 0.35 * sin(0.3*iTime))*cdiv(csin(z), ccos(z)); }\nvec2 rot(vec2 z, float a)\t{ return vec2(z.x*cos(a) - z.y*sin(a), z.y*cos(a) + z.x*sin(a)); }\n\n\nvec3 calculateColor(vec2 z)\n{\n    \n    //--- invert complex plane ---//\n    \n    z = vec2(z.x, z.y) / dot(z, z);\n\n    \n    //--- iterate newton formula until small const (0.14) ---//\n    \n    int i = 0;\n    for (i = 0; i < 80; i++)\n    {\n        vec2 n = newton(z);\n        if (length(z - n) < 0.14) break;\n        \n        z = rot(n, 0.401*sin(0.512*iTime));\n    }\n    \n    \n    //--- return color by binary decomposition ---//\n    \n    return\tz.x < 0.0? vec3(0.0) :\n\t    \tz.y < 0.0? vec3(1.0 - 0.5*log(float(i)/80.0), 0.95, 0.9 - 0.39*float(i)/80.0) : vec3(1.0);\n}\n\nvec4 colours[8];\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvec3 interpColours (in vec3 orig, in vec3 target, in float t)\n{\n\n\treturn vec3(orig.x + (target.x - orig.x)*t, \n\t    \torig.y + (target.y - orig.y)*t,\n\t    \torig.z + (target.z - orig.z)*t);\n}\n\nfloat cosEase(float angle,float rez,float offs)\n{\n\treturn (1.-(0.5-((1.+cos(angle*rez+offs*pi))/2.)));\n}\n\n\nfloat deformCircle (in float angle, in float deformationAmount, in float phase)\n{\n\treturn cosEase(angle,4.,phase)*deformationAmount + 1.-deformationAmount;\n}\n\n\n\nvec3 aces(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvec2 rotateUV(vec2 uv, float angle) {\n    angle = angle*tau;\n    mat2 matrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    return matrix * uv;\n}\n\n\nvec3 hueShift(vec3 col, float shift) {\n    vec3 m = vec3(cos(shift), -sin(shift) * .57735, 0);\n    m = vec3(m.xy, -m.y) + (1. - m.x) * .33333;\n    return mat3(m, m.zxy, m.yzx) * col;\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n\n     O=vec4(0,0,0,1);\n     C.xy = rotateUV(C - .5*iResolution.xy, cos(iTime*.1)*sin(iTime*.1)) + .5*iResolution.xy;\n     vec2 uv = ( C - .5*iResolution.xy ) / iResolution.y;\n     \n    vec2 p =  uv*2.;\n\t\n\tfloat time = time + length(p)*cos(time/4. - 0.04*length(p)*cos(time*time/8. + 0.0002*length(p)*cos(time*time*time/16.)));\n\tvec3 color = vec3(0.000,0.302,0.502);\n\t   float snd = 2.*texture(iChannel0, vec2(0.1,0.75)).r;\n\n\tfloat f = 0.0;\n\tfor(float i = 0.0; i < 20.0; i++){\n\t\t\n\t\tfloat s = sin(time + i * pi / 10.0) * (2.) * sin(1.*iTime);\n\t\tfloat c = cos(time + i * pi / 10.0) * (2.) * cos(1.*iTime);\n \n\t\tf += 0.0002 / (abs(p.x + c / (1.+length(p))) * abs(p.y + s / (1.+length(p)))) / (1.+length(p));\n\t}\n\t\n    \n     float ZOOM = 2.*(1.+5.*snd);\n    vec2 z = ZOOM * (C - 0.5*iResolution.xy) / iResolution.y;\n    \t\n        float t = iTime * .2 + ((.25 + .05 * sin(iTime * .1))/(length(z.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n\n    \n     \n    float a = 2.0;\n    float e2 = 0.5/min(iResolution.x, iResolution.y);    \n    vec3 col = vec3(0);\n\n       colours[0] = vec4 (vec3(255.,155.,69.) / 255.0, 0.5);\n\tcolours[1] = vec4 (vec3(225.,214.,66.) / 255.0, 1.0);\n\tcolours[2] = vec4 (vec3(63.,179.,163.) / 255.0, 1.0);\n\tcolours[3] = vec4 (vec3(56.,127.,184.) / 255.0, 1.0);\n\tcolours[4] = vec4 (vec3(37.,84.,163.) / 255.0, 1.0);\n\tcolours[5] = vec4 (vec3(101.,86.,163.) / 255.0, 1.0);\n\tcolours[6] = vec4 (vec3(178.,87.,159.) / 255.0, 1.0);\n\tcolours[7] = vec4 (vec3(238.,75.,93.) / 255.0, 1.0);\n\tvec2 position = ( gl_FragCoord.xy / min (resolution.x, resolution.y) ) * 2.0 - 1.0;\n\t\n    \n\tposition.x -=  (resolution.x / resolution.y)*0.5;\n   \n    position.x+=0.01;\n    \n\tfloat a3 = atan (position.x, position.y);\n\tfloat r = length (position);\n        vec3 col3 = vec3(0.);\n\tfloat grad = abs(a3) / pi;\n\tfloat edgeLim = 0.8+abs(sin(time*0.3))*0.05;\n\tfloat innerEdge = edgeLim - 0.1;\n\tfor (int i=0; i<8; i++)\n\t{\n        float snd = texture(iChannel0, vec2(float(i)/8.,0.1)).r+\n                    texture(iChannel0, vec2(float(i)/8.+0.01,0.1)).r;\n   \n      \n        \n\t\tedgeLim = 0.; //snd*5.*tan(round(iTime*2.)*pi/4.); //tan(iTime*float(i)/4.);\n\t\tfloat phase = time*(float(i))*0.5;\n\t\tvec3 rc;\n\t\tif(float(i)==7.)\n\t\t{\n\t\t\trc = snd*interpColours(colours[i].xyz,colours[0].xyz,grad);\n\t\t} else\n\t\t{\n\t\t\trc = snd*interpColours(colours[i].xyz,colours[i+1].xyz,grad);\n\t\t}\n\t\t\n\t\tfloat edge = deformCircle (a3, 0.2, phase) * edgeLim;\n\t\tfloat inEdge = deformCircle (a3, 0.1, phase) * innerEdge;\n\t\tcol3 += clamp(float(r < edge) * (smoothstep (r, edge, edge-0.01)),0.,1.) * rc;\n\t\tcol3 -= clamp(float(r < inEdge && r < edge) * (smoothstep (r, inEdge, inEdge-0.01)),0.,1.) * rc;\n\t\tedgeLim = innerEdge;\n\t\tinnerEdge = edgeLim - 0.1;\n\t}\n\t     \n        \n    vec3 n1,q,r3=iResolution,\n    d=normalize(vec3((C*2.-r3.xy)/r3.y,1)); \n    \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g),.2)*1./e/7e3\n    )\n    \n    \n    {\n        n1=g*d*snd+col3*snd;\n        float snd = 0.15*texture(iChannel0, vec2(0.25,0.25)).r;\n   \n        n1.z*=ceil(col.y);\n        a=30.;\n        n1=mod(n1-a,a*2.)-a+2.*snd;\n        s=3.;\n        for(int i=0;i++<9;){\n            n1=.4+snd-abs(n1);\n           \n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            s*=e=1.25-snd;\n            n1=abs(n1)*e-\n                vec3(\n                    (80.*(1.-snd)*abs(sin(iTime))*(1.+snd)),\n                    100,\n                   snd+abs(sin(snd))+.35\n                 );\n         }\n         g+=e=length(n1.yz)/s;\n    }\n    uv *= 2.*( cos(iTime * 2.0) -2.5); // scale\n     \n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,1.15)*12., 1.0);\n       O+= vec4((vec3(hueShift(f * color, iTime))), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Source: God Rays\n\n//uniforms\n#define DECAY     0.99\n#define DENSITY   1.\n#define WEIGHT    0.05\n#define EXPOSURE  0.05\n#define SAMPLES_COUNT   300\n\n#define LIGHT_SOURCE_TEXTURE iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col=vec4(0,0,0,1);\n    \n    vec2 ligthPos = (iMouse.xy == vec2(0.))? vec2(0.5) : iMouse.xy/iResolution.xy;\n    vec2 delta = uv - ligthPos;\n    delta *= 1.0 /  float(SAMPLES_COUNT) * DENSITY;\n    \n    float illuminationDecay = 1.0;    \n    \n    for(int i = 0; i < SAMPLES_COUNT; i++)\n    {\n        uv -= delta;\n\t\tvec4 samp = texture(LIGHT_SOURCE_TEXTURE , uv)*0.4;\n\t\tsamp *= illuminationDecay * WEIGHT;\n\t\tcol += samp.rgba;\n\t\tilluminationDecay *= DECAY;\n    }\n    \n    col *= EXPOSURE;\n    \n    //output\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}