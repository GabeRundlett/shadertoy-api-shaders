{
    "Shader": {
        "info": {
            "date": "1693078207",
            "description": "Testing an implementation of tracking 8 voronoi particles per cell instead of the usual 4.\n\nLeft: 4 neighbors per cell\nRight: 8 neighbors per cell\n\n*mouse x: particle speed*\n*mouse y: horizontal split*\n*space: reset*\n*1-8: render the Nth closest*",
            "flags": 48,
            "hasliked": 0,
            "id": "DtsBWM",
            "likes": 13,
            "name": "Packed Voronoi Tracking",
            "published": 3,
            "tags": [
                "voronoi",
                "particles",
                "tracking",
                "jfa"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 284
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another voronoi experiment, in the same genre as its predecessor. This shows a case\n//  where there is a benefit to maintaining eight voronoi neighbors per cell. The proof\n//  that it helps in this case is that the right side of the screen is brighter; we're\n//  missing fewer of the particles on that side.\n//\n//  Just as before, you can control the particle speed with mouse X. Mouse Y moves the\n//  horizontal bar up and down. Above the bar, the particles are rendered using the\n//  voronoi buffer. Below the bar, a debug view of the voronoi buffer is shown. Drag\n//  the bar up to get a good luck at the debug draw, and down to see the particles.\n//\n//  There is a completely new feature! Press the number keys 1-8 to change the debug\n//  draw to render the ids of the Nth closest particle to each pixel (default view is\n//  1, i.e. the closest particle).\n//\n//  In order to store eight neighbors per pixel, only 65534 particles are allowed,\n//  because the particle ids are stored in the upper and lower 16 bits of each component.\n//  That might or might not be enough particles depending on your needs.\n//\n//  The only reason this strategy makes a difference is that the particles are so crowded\n//  together, so that more than four can actually need to be rendered per pixel. If you\n//  click the mouse all the way to the left to slow the particles down, you can see even\n//  when the voronoi is allowed to completely converge, the right side is still brighter.\n//\n//  If you hold shift, only the four closest particles will be drawn on both sides. At\n//  slow speeds left and right look the same, as the voronoi can completely converge.\n//  But if you click on the right side to speed the particles up, you can see that\n//  the right side is brighter than the left again. This is because of the additional\n//  information transfer when you track eight neighbors. You might be able to see this\n//  additional information transfer in the form of increased \"clarity\" in the voronoi\n//  debug draw on the right, at the correct resolution and particle speed.\n//\n//  However, it's also clearly more expensive. If I run many random samples with the\n//  eight neighbor algorithm, it slows down the shader much faster than with a non-packed\n//  \"normal\" voronoi update. It's probably about four times as expensive per sample, since\n//  sorting eight things into eight is about four times as expensive as sorting four into\n//  four. So in cases when there is not a lot of particle overdraw, it might be better to\n//  use a non-packed voronoi buffer since you could run four times more samples for the\n//  same cost.\n// ---------------------------------------------------------------------------------------\n\n// render four particles from the voronoi buffer\nvoid renderParticles(vec2 p, uvec4 o, inout vec4 O)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        uint id = o[i];\n        if (id == -1U || id >= MAX_PARTICLES) break;\n        vec4 v = getParticle(id);\n        float d = fxLinePointDist(v.xy, v.zw, p);\n        O.xyz += pow(smoothstep(.05, .01, d), 1.) * vec3(1, .25, .1) * .5;\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 h = texelFetch(iChannel0, ivec2(R.x - 1., R.y - 1.), 0).yw, // state y: horiz split point; w: numeric selection\n         p = (u - .5 * R) / R.y;\n         \n    uvec4 oa, ob;\n    getClosest(u, oa, ob);\n    \n    if (p.y > h.x)\n    {\n        O = vec4(0);\n    \n        renderParticles(p, oa, O);\n        if (!keyDown(KEY_SHIFT)) renderParticles(p, ob, O);\n    }\n    else\n    {\n        // render voronoi below vertical split\n        uint id = h.y < 4. ? oa[int(h.y)] : ob[int(h.y) - 4];\n        O.rgb = pow(sin(vec3(id) * vec3(1, 2, 3)), vec3(7.));;\n    }\n    \n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(3. / R.y, 0., abs(p.y - h.x)));    // horizontal bar\n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(3. / R.y, 0., abs(p.x))); // vertical bars\n    O.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle \"sim\" and state management\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec4 s = texelFetch(iChannel0, ivec2(R - .5), 0); // state stored in upper right corner\n\n    if (u == R - .5)\n    {\n        // persistent state tracking\n        // state pixel has:\n        // xy: mouse position\n        // z: time\n        // w: number selection\n        \n        // record user mouse position\n        if (iMouse.z > 0.) s.xy = (iMouse.xy - .5 * R) / R;\n        \n        // update particle time\n        s.z += (s.x + .5) * .003; // z holds particle time\n        \n        // handle number selection\n        for (int i = 0; i < 9; ++i)\n            if (keyClick(KEY_1 + i)) s.w = float(i);\n            \n        // init\n        if (iFrame == 0) s = vec4(0);\n        \n        O = s;\n        return;\n    }\n    \n    O.zw = texelFetch(iChannel0, ivec2(u), 0).xy; // zw holds previous position\n    \n    float idx = u.x + u.y * R.x; // which particle\n    if (uint(idx) >= MAX_PARTICLES) return;\n    \n    // this is not really a simulation at all, just a stateless animation to give our tracker something to do\n    idx = idx * .06 + s.z;\n    O.x = (.7 * sin(idx) + .3 * sin(idx * 40.4)) * .45 * R.x / R.y;\n    O.y = cos(idx * 10.) * .4;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tPacked voronoi tracking buffer, tracking eight neighbors per pixel\n// ---------------------------------------------------------------------------------------\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    if (id == -1U || id >= MAX_PARTICLES) return 1e6;\n    \n    vec4 v = getParticle(id);\n    return min(length2(v.xy - u), length2(v.zw - u));\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\n// the furthest distance (whether from the vector or the input) will end up in i and d\nvoid insertionSort(inout uvec4 i, inout vec4 d, inout uint i_, inout float d_)\n{\t\n    uint ip = i_;\n    float dp = d_;\n    if (d_ < d[0])             \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(ip,i.xyz),    d = vec4(dp,d.xyz);\n    else if(d_ < d[1])             \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.x,ip,i.yz), d = vec4(d.x,dp,d.yz);\n    else if(d_ < d[2])            \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.xy,ip,i.z), d = vec4(d.xy,dp,d.z);\n    else if(d_ < d[3])           \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.xyz,ip),    d = vec4(d.xyz,dp);\n}\n\n// sort a single particle into two four-element vectors (8 total slots)\nvoid insertionSort2(inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db, uint id, vec2 p)\n{\n    if (any(equal(uvec4(id),na)) || any(equal(uvec4(id),nb))) return; // don't insert the same id twice\n    \n    float d = distance2Particle(id, p);\n    insertionSort(na, da, id, d);\n    insertionSort(nb, db, id, d);\n}\n\n// consider a new set of four candidate particles to insert into our arrays\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db)\n{\n    for (int j = 0; j < 4; j++)\n        insertionSort2(na, nb, da, db, old[j], p);\n}\n\n// consider a new set of eignt candidate particles to insert into our arrays\nvoid sortNbs2(uvec4 a, uvec4 b, vec2 p, inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db)\n{\n    sortNbs(a, p, na, nb, da, db);\n    sortNbs(b, p, na, nb, da, db);\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x )\n{\n    const uint k = 1103515245U;  // GLIB C\n    \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n\tvec2 p = (u - .5 * R) / R.y;\n    uvec4 na = uvec4(-1U), nb = uvec4(-1U); // the eight new closest particle ids\n    vec4 da = vec4(1e6), db = vec4(1e6);  // the distances of the eight closest particles\n\n    if (iFrame > 0 && !keyClick(KEY_SPACE))\n    {\n        // start with our previous frame's values, and look up the distances\n        uvec4 oa, ob;\n        getClosest(u, oa, ob);\n        sortNbs2(oa, ob, p, na, nb, da, db);\n        \n        // search a random nearby cell for possible improvements to our arrays\n        // note: this would typically be in a loop, taking multiple samples per frame, for faster convergence\n        vec3 h = hash3(uvec3(u, iFrame)) - .5;\n        uvec4 ta, tb;\n        getClosest(u + h.xy * 100., ta, tb);\n        sortNbs2(ta, tb, p, na, nb, da, db);\n\n        // search a random cell in the entire buffer to kick-start the process\n        // note: this would typically be in a loop, taking multiple samples per frame, for faster convergence\n        uint id = uint(h.z*float(MAX_PARTICLES));\n        insertionSort2(na, nb, da, db, id, p);\n    }\n    \n    // kill the second four neighbors on the left side of the screen, for demonstration purposes\n    if (p.x < 0.) nb = uvec4(-1);\n    \n    O = saveClosest(na, nb);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const uint MAX_PARTICLES = 3000U;\n#define R iResolution.xy\n\n// compute squared length of vector\nfloat length2(vec2 v) { return dot(v, v); }\n\n// compute distance to line segment\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return sqrt(length2(p - b * h)); // squared dist to segment\n}\n\n// pack two unsigned vectors into one, keeping only the bottom 16 bits\nuvec4 pack2(uvec4 a, uvec4 b)\n{\n    return (a & 0xffffU) | ((b & 0xffffU) << 16);\n}\n\n// unpack a packed unsigned vector packed by pack2\nvoid unpack2(uvec4 p, out uvec4 a, out uvec4 b)\n{\n    a = p & 0xffffU;\n    b = (p & 0xffff0000U) >> 16;\n}\n\n// get the eight closest particles to some screen pixel\n//    u - pixel position\n//    a - closest 4 particles\n//    b - next 4 closest particles\n#define getClosest(X, Y, Z) getClosestImpl(iChannel1, X, Y, Z)\nvoid getClosestImpl(sampler2D smp, vec2 u, out uvec4 a, out uvec4 b)\n{\n    vec4 o = texelFetch(smp, ivec2(u), 0);\n    uvec4 p = floatBitsToUint(o);\n    unpack2(p, a, b);\n}\n\n// export the eight closest ids to the shader output\nvec4 saveClosest(uvec4 a, uvec4 b)\n{\n    return uintBitsToFloat(pack2(a, b));\n}\n\n// get the info for one particle: position in xy, previous position in zw\n#define getParticle(X) getParticleImpl(iChannel0, uint(R.x), X)\nvec4 getParticleImpl(sampler2D smp, uint wd, uint id)\n{\n    return texelFetch(smp, ivec2(id % wd, id / wd), 0);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_1 49",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}