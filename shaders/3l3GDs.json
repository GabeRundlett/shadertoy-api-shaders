{
    "Shader": {
        "info": {
            "date": "1577900142",
            "description": "Use WASD/arrow + mouse to move around. C -clear box, space - shoot ball. P- pause. Molecular dynamics in 3d on a fragment shader! lol^3",
            "flags": 48,
            "hasliked": 0,
            "id": "3l3GDs",
            "likes": 13,
            "name": "Molecular dynamics 3D v2",
            "published": 3,
            "tags": [
                "3d",
                "voronoi",
                "simulation",
                "particles",
                "molecular"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 620
        },
        "renderpass": [
            {
                "code": "// Fork of \"Lorentz Attractor 3D\" by michael0884. https://shadertoy.com/view/3lt3WX\n// 2019-12-31 20:33:24\n\n// Fork of \"Volumetric shader template\" by michael0884. https://shadertoy.com/view/tlc3Wf\n// 2019-12-30 20:57:24\n\n//hack \n#define fakech0 ch0\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakech3 ch3\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nvec4 ambient_occlusion(in vec4 pos, inout vec4 norm)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\t\n\t//step out\n    vec3 color = vec3(0.);\n    float mind =  max(0.05*norm.w, sphere_rad*0.5);\n\tpos.xyz += mind*norm.xyz;\n    norm.xyz = cosdistr(norm.xyz, 0.01);\n\t//march in the direction of the normal\n\tfor(int i = 0; i < 2; i++)\n\t{\n        pos.w = abs(map(pos.xyz));\n\t\tpos.xyz += pos.w*norm.xyz;\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n       \n\t\tocclusion_angle += clamp((pos.w - mind)/(norm.w),0.,1.);\n\t}\n     color += 2.*ambient_sky_color(norm.xyz)  + 5.*texture(ch2, norm.xzy).xyz;\n\treturn vec4(color*(occlusion_angle*0.65+0.35), occlusion_angle)/2.;\n}\n\n\n\n\nvec3 lighting(vec4 color, vec2 pbr, vec4 pos, vec4 dir, vec4 norm, float shadow) \n{\n\tvec3 albedo = color.xyz;\n\tnorm.w = dir.w;\n    vec3 N = norm.xyz;\n\tvec4 ambient_color = ambient_occlusion(pos, norm);\n\t\n\tfloat metallic = pbr.x;\n\tvec3 F0 = vec3(0.04); \n\tF0 = mix(F0, albedo, metallic);\n\t\n\t//reflectance equation\n\tvec3 Lo = vec3(0.0);\n\tvec3 V = -dir.xyz;\n\t\n\t\n\t{ //ambient occlusion contribution\n\t\tfloat roughness = pbr.y;\n\t\tvec3 L = normalize(norm.xyz);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = ambient_color.xyz;        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\tvec3 sun_color = sky_color(light);\n\n\t{ //light contribution\n\t\tfloat roughness = pbr.y;\n\t\tvec3 L = normalize(light);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = sun_color*shadow;        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\treturn Lo;\n}\n\n#define sky vec3(20,80,235)/255.\nvec3 ray_march(vec3 p, vec3 r)\n{\n    float td = 0.;\n    int i;\n    for(i = 0; i < MAX_MARCHES; i++)\n    {\n    \tfloat de = map(p);\n        if(de < rayfov*td || td > MAX_DIST)\n        {\n            break;\n        }\n        p += de*r;\n        td += de;\n    }\n    vec3 col =sdcolor(p);\n    if(td > MAX_DIST || i > MAX_MARCHES)\n    {\n        col = sky_color(r);\n    }\n    else\n    {\n        vec4 norm = calcNormal(p,MIN_DIST);\n        p += r*(norm.w-rayfov*td);\n        #ifdef SHADOWS\n      \t\tfloat shad = shadow_march(vec4(p+norm.xyz*0.05,0.), vec4(light,0.), 400.,0.03);\n        #else\n        \tfloat shad = 1.;\n        #endif\n        \n        col = lighting(vec4(col,0.), vec2(0.2,0.3), vec4(p, 0.), vec4(r, td), norm, shad);\n    }\n   \n    return col;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + fragCoord.x + fragCoord.y*3.141592653;\n    rayfov = FOV/iResolution.x;\n     SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n   \n    vec2 uv = (fragCoord - 0.5*size)/max(size.x, size.y);\n\n    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;\n \tvec3 ray = getRay(angles, uv);\n    vec3 cray = getRay(angles, vec2(0.));\n    \n    vec4 cpos = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0);\n    \n    light = vec3(0.6,0.50,1.);\n    light.z = max(light.z, 0.9);\n    light = normalize(light);\n   \t\n    vec3 pos = cpos.xyz;\n\n    // Output to screen\n    vec4 t = texel(ch0, fragCoord);\n    vec3 p = dim3from2(fragCoord);\n    #ifdef VOLUMETRIC\n   \t fragColor = 2.*ray_march_vol(pos, ray);\n    #else\n     fragColor = 1.*vec4(HDRmapping(ray_march(pos, ray), 0.8),1);\n\t#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p, s) texture(a, p/vec2(s))\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n//#define VOLUMETRIC\n#define SHADOWS\n\n//shows bonds/links between atoms, is unstable\n//#define LINKS\n#define FULL_UNION\n#define sphere_rad 1.2\n\n#define MAX_MARCHES 300\n#define DX 1.5\n#define OPACITY 0.2\n\nfloat rayfov;\nvec3 light;\n\n#define shadow_steps 90\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.\n\nfloat dt = 0.5;\n\n#define MOUSE_INDX 0\n#define ANGLE_INDX 1\n#define POS_INDX   2\n#define VEL_INDX   3\n#define SPEED_INDX 4\n#define MANIP_INDX 5\n\n//3d slice aspect ratio \n#define ar vec2(1.35,0.8)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d), textureSize(ch, 0));\n}\n\nvec4 texel(sampler2D ch, ivec2 p)\n{\n    return pixel(ch, vec2(p + 1), textureSize(ch, 0));\n}\n\nvec4 texel(sampler2D ch, vec2 p)\n{\n    return pixel(ch, round(p+1.), textureSize(ch, 0));\n}\n\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n\nfloat seed = 0.;\nfloat rand()\n{\n    float r = hash(seed);\n    seed = r;\n    return r;\n}\n\nvec3 rand3()\n{\n    vec3 r = hash31(seed);\n    seed = r.x*1.54879 + r.y*2.554963 + r.z*0.857836;\n    return r;\n}\n\nvec4 rand4()\n{\n    vec4 r = hash41(seed);\n    seed = r.x*1.54879 + r.y*2.554963 + r.z*0.857836 + r.w*3.5823758;\n    return r;\n}\n\n//normally distributed random numbers\nvec3 randn()\n{\n    vec4 rand = rand4();\n    vec3 box_muller = sqrt(-2.*log(max(vec3(rand.x,rand.x,rand.z),1e-8)))*vec3(sin(2.*PI*rand.y),cos(2.*PI*rand.y),sin(2.*PI*rand.w));\n    return box_muller;\n}\n\n//uniformly inside a sphere\nvec3 random_sphere()\n{\n    return normalize(randn())*pow(rand(),0.333333);\n}\n\nvec3 cosdistr(vec3 dir, float w)\n{\n    vec3 rand_dir = normalize(randn());\n    vec3 norm_dir = normalize(rand_dir - dot(dir,rand_dir)*dir);\n    float u = w*rand();\n    return normalize(dir*sqrt(1. - u) + norm_dir*sqrt(u));\n}\n\nbool inside(vec3 p)\n{\n    if(p.x > 1. && p.y > 1. && p.z > 1. && p.x < float(size3d.x)-1. && p.y < float(size3d.y)-1. && p.z < float(size3d.z)-1.)\n    {\n        return true;\n    }\n    else return false;\n}\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d - 1.) - p;\n    return min(minv(p),minv(a)) + 1.;\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\n//encoding 2 values in one number\nfloat scaleFactor = 65530.0;\nfloat cp = 256.0 * 256.0;\n\n\n/* packs given two floats into one float */\nvec4 enc(vec4 x, vec4 y) {\n    vec4 x1 = round(x * scaleFactor);\n    vec4 y1 = round(y * scaleFactor);\n    vec4 f = (y1 * cp) + x1;\n    return f;\n}\n\n/* unpacks given float to two floats */\nvoid dec(in vec4 f, out vec4 x, out vec4 y){\n  vec4 dy = floor(f / cp);\n  vec4 dx = f - (dy * cp);\n  y = (dy / scaleFactor);\n  x = (dx / scaleFactor);\n}\n\nstruct particle\n{\n    vec4 pos;\n    vec4 vel;\n};\n\nparticle get(sampler2D ch, vec3 p)\n{\n    p = clamp(p, vec3(0.), size3d);\n    vec4 data = voxel(ch, p);\n    particle part;\n    dec(data, part.pos, part.vel);\n    part.pos.xyz *= size3d;\n    part.vel *= 10.;\n    return part;\n}\n\nvec4 save(particle a)\n{\n    //scale the numbers to be in a [-1,1] range\n    a.pos.xyz /= size3d;\n    return enc(a.pos, 0.1*a.vel);\n}\n    \nfloat force(float d)\n{\n    d *= 4.;\n    return -2.*(0.5*exp(-0.5*d) - 2.*exp(-3.*d));\n}\n\n\n//ray marching primitives, credits to Inigo Quilez \n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLineBox(vec3 p, vec3 b, float r)\n{\n    p = abs(p);\n    float cx = sdCapsule(p, b, vec3(b.x,b.y,0), r);\n    float cy = sdCapsule(p, b, vec3(0,b.y, b.z), r);\n    float cz = sdCapsule(p, b, vec3(b.x,0, b.z), r);\n    return min(min(cx, cy),cz);\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\n//SIMULATION STUFF\nuniform sampler2D fakech0;\nuniform sampler2D fakech1;\nuniform sampler2D fakech2;\nuniform sampler2D fakech3;\n    \nvoid Check(inout particle U, vec3 pos, vec3 dx)\n{\n    particle neighbor = get(fakech0, pos + dx);\n    //check if the stored neighbouring particle is closer to this position \n    if(length(neighbor.pos.xyz - pos) < length(U.pos.xyz - pos))\n    {\n        U = neighbor; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout particle U, vec3 p, int r)\n{\n    Check(U, p, vec3(-r, 0, 0));\n    Check(U, p, vec3(r, 0, 0));\n    Check(U, p, vec3(0, -r, 0));\n    Check(U, p, vec3(0, r, 0));\n    Check(U, p, vec3(0, 0, -r));\n    Check(U, p, vec3(0, 0, r));\n}\n\n//get the force from a particle in p0 to a particle at p\nvec3 getForce(vec3 p0, vec3 p)\n{\n\tparticle neighbor = get(fakech0, p0);\n    vec3 dx = neighbor.pos.xyz - p;\n    //only count if neighbor particle is inside of its cell to exclude repeated forces\n    if(maxv(abs(neighbor.pos.xyz - round(p0))) <= 0.5)\n        return normalize(dx)*force(length(dx));\n    else\n        return vec3(0.);\n}\n\n#define rad 2\nvec3 calc_force(vec3 p)\n{\n    vec3 p0 = round(p);\n    vec3 force = vec3(0.);\n    for( int i=-rad; i<=rad; i++ )\n        for( int j=-rad; j<=rad; j++ )\n            for( int k=-rad; k<=rad; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        if(dx != vec3(0))\n          force += getForce(p0+dx, p);\n    }\n    \n    return force;\n}\n\n\nvoid init(out particle U, in vec3 p)\n{\n    if(distance2border(p) > 10.)\n    {\n        U.pos.xyz = vec3(4.*floor(p.xyz/4.));\n        U.pos.w = hash13(U.pos.xyz+10.);\n        U.vel.xyz = 0.05*(hash33(U.pos.xyz+0.1)*2. - 1.);\n    }    \n    else\n    {\n        U.pos = vec4(1e5);\n        U.vel = vec4(0.);\n    }\n}\n\nvoid SimulationStep(inout particle U)\n{\n    vec4 border = border_grad(U.pos.xyz);\n    vec3 cvec = -U.pos.xyz*vec3(0,0,1);\n    vec3 G = 0.15*normalize(cvec)/size3d;\n   \n    vec3 force =calc_force(U.pos.xyz);\n    vec3 bound =1.*normalize(border.xyz)*exp(-0.4*border.w*border.w);\n    float cooling = 1. - (1.-exp(-0.3*length(U.vel.xyz)))*(0.01*exp(-0.05*dot(cvec,cvec)) + 0.01*exp(-0.4*border.w*border.w) + 0.04*exp(-0.1*dot(force,force)));\n    U.vel.xyz =  U.vel.xyz*cooling + dt*(bound+force+G);\n    U.pos.xyz += dt*U.vel.xyz;\n}\n\nvoid UpdateVoronoi(inout particle U, in vec3 p)\n{\n    //check neighbours \n    CheckRadius(U, p, 1);\n    CheckRadius(U, p, 2);\n    CheckRadius(U, p, 3);\n    CheckRadius(U, p, 4);\n}\n\n\n\n\n//Rendering \n\nfloat SDF_particle(vec3 p0, vec3 p)\n{\n    particle point = get(fakech0, p0);\n    return length(point.pos.xyz - p) - sphere_rad;\n}\n\nfloat SDF_particle_wlink(vec3 p0, vec3 p, vec3 p1)\n{\n    particle point = get(fakech0, p0);\n    float pde = length(point.pos.xyz - p) - sphere_rad;\n    #ifdef LINKS\n        if(length(point.pos.xyz - p1) < 4.)\n        {\n             pde = min(pde, sdCapsule(p, point.pos.xyz, p1, sphere_rad*0.2));\n        }\n    #endif\n    return pde;\n}\n\nvec4 opunion(vec4 a, vec4 b)\n{\n    if(a.w < b.w) return a;\n    else return b;\n}\n\n//distance estimator to the voronoi particle field\nfloat DE(vec3 p)\n{\n\tfloat de = 1e5;\n   \n   \tvec3 p0 =  round(clamp(p, vec3(0), size3d));\n    if(minv(abs(p - size3d*0.5)) > 0.55*maxv(size3d)) \n        de = length(p - size3d*0.5);\n    else\n    {\n        particle centr_partic = get(fakech0, p0);\n        vec3 p1 = centr_partic.pos.xyz;\n        de = min(de, length(p1-p) - sphere_rad);\n        de = min(de, SDF_particle_wlink(p0+vec3(1,0,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(-1,0,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,1,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,-1,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,0,1), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,0,-1), p, p1));\n        if(de < sphere_rad*2.)\n        {\n            de = min(de, SDF_particle_wlink(p0+vec3(1,1,1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,1,1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,-1,1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,-1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(1,-1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(1,1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(1,-1,1), p, p1));\n        }\n    }\n    \n    return de;\n}\n\nvec3 particle_color(vec3 p)\n{\n    vec4 a = vec4(1e5);\n    vec3 p0 = round(p);\n    for( int i=-1; i<=1; i++ )\n        for( int j=-1; j<=1; j++ )\n            for( int k=-1; k<=1; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        particle thisp = get(fakech0, p0+dx);\n        a = opunion(a, vec4(jet_range(thisp.pos.w, -0.1, 1.2), SDF_particle(p0+dx, p)));\n    }\n    return a.xyz;\n}\n\nvec3 COL(vec3 p)\n{\n    if(inside(p))\n    {\n        return particle_color(p)*exp(-0.25*pow(max(DE(p),0.),2.));\n    }\n    else return vec3(0.);\n}\n\nvec4 ray_march_vol(vec3 p, vec3 r)\n{\n    vec4 color = vec4(0., 0., 0., 0.);\n    vec4 background = vec4(0.1);\n    for(int i = 0; i < 90; i++)\n    {\n        vec3 tcolor = COL(p);\n        float density = length(tcolor);\n        float noise  =(1.+0.5*rand());\n        float d = 4.*DX*exp(-2.*min(density,2.))*noise;\n        float opacity = 1.-exp(-OPACITY*density*d);\n        float newa = max(color.w + (1. - color.w)*opacity,0.0001);\n        color.xyz = (color.xyz*color.w + (1.-color.w)*opacity*tcolor)/newa;\n        color.w = newa;\n        if(1. - newa < 0.02) break;\n        p += r*d;\n    }\n    return background + color;\n}\n\nvec3 sdcolor(vec3 p)\n{\n    vec3 c = vec3(0.);\n    if(inside(0.8*(p-size3d*0.5) + size3d*0.5))\n    {  \n        c = particle_color(p);\n    }\n    else c = vec3(1.);\n    if(sdLineBox(p - size3d*0.5, size3d*0.5, 0.5) < 1. || p.z < 1.) c = vec3(1.);\n    return c;\n}\n\n\nfloat map(vec3 p)\n{\n    float de_partic = DE(p); \n    de_partic = min(de_partic, sdPlane(p, vec4(0,0,1,0)));\n    return min(de_partic, sdLineBox(p - size3d*0.5, size3d*0.5, 0.5));\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//usual ray marching stuff\n\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = map(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n        vec3 ra =rand3()-0.5;\n        \n\t\tpos.w = (1. + 0.1*ra.x)*abs(map(pos.xyz));\n        dir.xyz = normalize(dir.xyz + 0.01*pos.w*ra/2.5*rayfov*dir.w);\n\t\n\t\tfloat angle = max((pos.w - 2.5*rayfov*dir.w)/(max(0.0001,dir.w)*light_angle), 0.);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\tph = pos.w;\n\t\t\n        if(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(2.*rayfov*dir.w, MIN_DIST))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\n\n///PBR functions \nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n///END PBR functions\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n    pos = pos.xzy;\n\t// Atmosphere Scattering\n\tvec3 fsun = light.xzy;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./0.7)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.z;\n    pos.z = 0.;\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//3d voronoi particle tracking\nvoid Interactivity(inout particle U, vec3 p)\n{\n    vec2 angles = texel(ch3,  ivec2(ANGLE_INDX,0)).xy;\n    vec3 cray = getRay(angles, vec2(0.));\n    vec3 cpos = texelFetch(ch3,  ivec2(POS_INDX,0), 0).xyz;\n    vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    //add particle\n    if(manip.x > 0.5) \n    {\n        if(length(p - cpos) < 4.) \n        {\n            U.pos.xyz = cpos+cray*0.6;\n            U.vel.xyz = cray*0.6;\n            U.pos.w = 0.5*sin(iTime)+0.5;\n            U.vel.w = 0.5*sin(iTime)+0.5;\n        }\n    }\n    //remove everything\n    if(manip.y > 0.5) \n    {\n        U.pos.xyz = vec3(10.);\n        U.vel.xyz = vec3(0.);\n        U.pos.w = 0.;\n        U.vel.w = 0.;\n    }\n}\n\n\n//hack \n#define fakech0 ch1\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakecha ch3\n\n\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n     vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    dt = manip.z*dt;\n    //voxel pos\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    \n    if(iFrame < 1)\n    {\n        init(U, p);\n    }\n    else\n    {\n        //get voxel particle\n        U = get(ch0, p);\n        UpdateVoronoi(U,p);\n        Interactivity(U, p);\n        SimulationStep(U);\n    }\n    \n    pix = save(U);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//3d voronoi particle tracking\n//hack \n#define fakech0 ch0\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakech3 ch3\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    \n      vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    dt = manip.z*dt;\n    \n    //voxel pos\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    \n    if(iFrame < 1)\n    {\n        init(U, p);\n    }\n    else\n    {\n        //get voxel particle\n        U = get(ch0, p);\n        UpdateVoronoi(U,p);\n       // Interactivity(U, p);\n        SimulationStep(U);\n    }\n    \n    pix = save(U);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//3d voronoi particle tracking\n//hack \n#define fakech0 ch0\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakech3 ch3\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    \n    vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    dt = manip.z*dt;\n    \n    //voxel pos\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    \n    if(iFrame < 1)\n    {\n        init(U, p);\n    }\n    else\n    {\n        //get voxel particle\n        U = get(ch0, p);\n        UpdateVoronoi(U,p);\n        //Interactivity(U, p);\n        SimulationStep(U);\n    }\n    \n    pix = save(U);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/// UTILITY\n///\n/// Using the GPU as the CPU here, pretty inefficient I guess\n\n//hack \n#define fakech0 ch0\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakech3 ch3\n\n#define N_instructions 10.\n\n#define CAMERA_SPEED 1.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n//Keyboard constants\nconst int KEY_SPACE  = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( ch3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n    \n    if(fragCoord.x <= N_instructions && fragCoord.y <= 1.)\n    {\n        SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n  \t    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    \n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = texelFetch(ch1,  ivec2(I,0), 0);\n        vec4 mouse = texelFetch(ch1,  ivec2(MOUSE_INDX,0), 0);\n        vec2 mousespeed = texelFetch(ch1,  ivec2(MOUSE_INDX,0), 0).xy;\n        vec4 angles = texelFetch(ch1,  ivec2(ANGLE_INDX,0), 0);\n        mat3 camera = transpose(getCamera(angles.xy));\n        vec4 posit = texelFetch(ch1,  ivec2(POS_INDX,0), 0);\n        vec4 vel = texelFetch(ch1,  ivec2(VEL_INDX,0), 0);\n\t\tvec4 speed = texelFetch(ch1,  ivec2(SPEED_INDX,0), 0);\n        vec4 norm = calcNormal(posit.xyz, 0.01);\n        norm.xyz = norm.xyz/(length(norm.xyz) + 0.01);\n        switch(I)\n        {\n        case MOUSE_INDX:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE_INDX:  //angle computation\n           \n   \t\t\tfragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n    \t\tfragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n            fragColor.zw *= 0.8;\n            fragColor.y *= 1.- 0.01*clamp(length(vel.xyz),0.,1.);\n             if(iFrame < 1)\n            {\n                fragColor.xy = vec2(-PI*0.5,0.2);\n            }\n            break;\n            \n        case POS_INDX:  //position\n          \n            float DeX = length(vel.xyz*speed.x)+0.0001;\n            float MAXDX = map(fragColor.xyz + vel.xyz*speed.x) + norm.w;\n            if(DeX > MAXDX)\n                vel *= 0.25;\n            fragColor.xyz += vel.xyz*speed.x;\n   \t\t\tfragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = size3d*vec3(1.7,0.3,0.7);\n            }\n           \n            break;\n         case VEL_INDX:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            fragColor.xyz *= 0.8; //slowing down\n            \n            //collision detection, removing the normal velocity component \n            #define collision_dist 0.1\n          \tfragColor.xyz += norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/collision_dist);\n            break;\n          case SPEED_INDX: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.x = CAMERA_SPEED;\n            }\n            break; \n          case MANIP_INDX:\n            if(isKeyPressed(KEY_SPACE) && iFrame%10==0)\n   \t   \t\t{\n   \t\t\t\tfragColor.x = 1.;\n            }\n            else\n            {\n                fragColor.x = 0.;\n            }\n            \n            if(isKeyPressed(KEY_C))\n   \t   \t\t{\n   \t\t\t\tfragColor.y = 1.;\n            }\n            else\n            {\n                fragColor.y = 0.;\n            }\n            \n            if(isKeyPressed(KEY_P) && iFrame%10==0)\n   \t   \t\t{\n   \t\t\t\tfragColor.z = 1. - fragColor.z;\n            }\n            \n             if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(0.,0.,1.);\n            }\n            break; \n        }   \n    } else discard;\n    \n   \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}