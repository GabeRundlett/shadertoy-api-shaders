{
    "Shader": {
        "info": {
            "date": "1492447364",
            "description": "simpler fork of\nhttps://www.shadertoy.com/view/4ldSRj\n\n(incorrectly) raymarched version in :\nhttps://www.shadertoy.com/view/ldjyWw",
            "flags": 0,
            "hasliked": 0,
            "id": "ldjyWw",
            "likes": 32,
            "name": "voronoi rain splashes b",
            "published": 3,
            "tags": [
                "voronoi",
                "ripples",
                "water",
                "worley",
                "raindrops",
                "vorley"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 3004
        },
        "renderpass": [
            {
                "code": "/*this is a fork of https://www.shadertoy.com/view/4ldSRj\n\ncleaned up, \ncore almost identical,\ncommented-out environmental reflection mapping.\n*/\n\n//set camera\n#define camPos    vec3(0,4,-4)\n#define camTarget vec3(0)\n#define upDir     vec3(0,1,0)\n\n\n#define HASHSCALE3 vec3(.1031,.1030,.0973)\n#define HASHSCALE1 .1031\n//hashes from https://www.shadertoy.com/view/4djSRW\n/*\nfloat hash11(float p){vec3 p3=fract(vec3(p)*HASHSCALE1);\n p3+=dot(p3,p3.yzx+19.19);\n return fract((p3.x+p3.y)*p3.z);}\nvec2 hash22(vec2 p){vec3 p3=fract(vec3(p.xyx)*HASHSCALE3);\n p3+=dot(p3,p3.yzx+176.1958);\n return fract((p3.xx+p3.yz)*p3.zy);}\n*/\nvec3 hash33(vec3 p3){p3=fract(p3*HASHSCALE3);\n p3+=dot(p3,p3.yxz+19.19);\n return fract((p3.xxy + p3.yxx)*p3.zyx);}\n#define vorRainSpeed  .8\n#define vorRainScale 1.0\n//worley rain subroutine\nfloat bias(float s,float b){return s/((((1./b)-2.)*(1.-s))+1.);}\n//worley rain\nvec3 vorRain(vec3 p,float r){\n vec3 vw,xy,xz,s1,s2,xx;\n vec3 yz=vec3(0),bz=vec3(0),az=vec3(0),xw=vec3(0);\n p=p.xzy;p/=vorRainScale;\n vec3 uv2=p,p2=p;\n p=vec3(floor(p)); \n float t=iTime*vorRainSpeed;\n //vec2 rand = vw/vec2(iterations);\n vec2 yx=vec2(0);\n for(int j=-1;j<=1;j++)\n for(int k=-1;k<=1;k++){\n  vec3 offset=vec3(float(j),float(k),0.);\n  //hashed for grid\n  s1.xz=hash33(p+offset.xyz+127.43+r).xz;\n  //hashed for timer for switching positions of raindrop\n  s2.xz=floor(s1.xx + t);\n  //add timer to random value so that everytime a ripple fades, a new drop appears\n  xz.xz=hash33(p+offset.xyz+(s2)+r).xz;\n  xx=hash33(p+offset.xyz+(s2-1.));\n  s1=mod(s1+t,1.);\n  //p2=(p2-p2)+vec3(s1.x,0.0,s1.y);\n  p2=mod(p2,1.0);\n  float op=1.-s1.x;//opacity\n  op=bias(op,.21);//optional smooth blending\n  //change the profile of the timer\n  s1.x=bias(s1.x,.62);//optional harder fadeout\n  float size=mix(4.,1.,s1.x);//ripple.expansion over time\n  //move ripple formation from the center as it grows\n  float size2=mix(.005,2.0,s1.x);\n  // make the voronoi 'balls'\n  xy.xz=vec2(length((p.xy+xz.xz)-(uv2.xy-offset.xy))*size);\n  //xy.xz *= (1.0/9.0);\n  xx=vec3(length((p2)+xz)-(uv2-offset)*1.30);\n  //xx=1.-xx;//optional?\n  xy.x=1.-xy.x;//mandatory!\n  xy.x*=size2;//almost optional viscosity\n  #define ripp if(xy.x>.5)xy.x=mix(1.,0.,xy.x);xy.x=mix(0.,2.,xy.x) \n  ripp;ripp;\n  xy.x=smoothstep(.0,1.,xy.x);\n  xy*=op;// fade ripple over time\n  yz =1.-((1.-yz)*(1.-xy));\n  //ops += mix(0.0,xy.x,op.x);\n  //yz = yz.xxx;\n  //yz = max(yz,xy);\n  //yz += p;\n  //xw = max(xx,xw);\n }return vec3(yz*.1);}\n\n//less ripples is really prettier than more ripples.\n#define iterRippleCount 2.\n//only problem is that many drops hit at the very same time, so 2 is reasonable minimum.\n//returns height  of water ripples at [p]\nfloat dfRipples(vec3 p){\n float pl=(p.y+1.);\n vec3 r=vec3(0);\n for(float i=0.;i<iterRippleCount;i++){\n  r+=vorRain(p,i+1.);\n }return pl-r.x;}\n\n//return direction of ray, set by [p]PositionOnScreen and camera data.\n//[o]canPos [t]camTarget [u]upDirection (sets angle)\nvec3 CamCross(vec2 p,vec3 o,vec3 t,vec3 u){vec3\n d=normalize(t-o),r=normalize(cross(u,d)),\n Up=p.y*cross(d,r);r*=p.x*iResolution.x/iResolution.y;\nreturn normalize(((o+d+r+Up)*.86)-(camPos));}\n//shit cam uses too many cross() and normalize()\n\nvoid mainImage( out vec4 Out, in vec2 In){\n vec2 u=In.xy / iResolution.xy;\n u=-1.+2.*u;\n float midPoint = u.x + .5;\n vec2 po;\n float mixer1=mix(-4.,4. ,.5+.5*sin(iTime*.024));\n float mixer2=mix(-4.,4. ,.5+.5*cos(iTime*.024));\n float mixer3=mix(-1.,1.6,.5+.5*cos(iTime*.14));\n float mixer4=mix( 1.,.01,.5+.5*cos(iTime*.4));\n float move=iTime*1.5;\n\n // props to all this vector math from a reddit tutorial: \n // https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\n\n vec3 rayDir=CamCross(u,camPos,camTarget,upDir);\n   \n // help from Andy Whittock - a non-ray-marched version;\n vec3 plane1=vec3(0,-.01,0);\n float d=-dot(camPos,plane1)/dot(rayDir,plane1);\n float fog=smoothstep(0.,1.,clamp(d/20.,0.,1.));\n vec3 hitPoint=(camPos+(d*rayDir));  \n hitPoint+=.2;\n //texturing\n\n #define EPSILON .06\n float std=dfRipples(hitPoint);\n vec2 eps=vec2(EPSILON,0.);\n float v1=dfRipples(hitPoint+eps.xyy);\n float v2=dfRipples(hitPoint+eps.yxy);\n float v3=dfRipples(hitPoint+eps.yyx);\n vec3 n=vec3(v1,v2,v3)-std; \n n=normalize(n);\n //n=normalize(der+plane1);//cheesy way to get something like a normal\n \n /* //reflecting to a sphere-map\n //vec3 ref2=reflect(rayDir,normal);\n //vec3 refr=normal;//texture(iChannel0,ref2).xyz;\n //vec3 refl=normal;//texture(iChannel0,-ref2).xyz;\n //vec3 L=normalize(vec3(17.5,12.5,12.5));\n //float LDist=length(L-pos);\n //float atten=min(2.0, 1.0/(LDist/4.50));//atten=1.0;\n //vec3 diffuse=vec3(.50,.5,.5);\n //float light=max(.0,dot(normalize(L), normal2));  \n //vec3 ref=-reflect(rayDir,normal);\n */\n    \n vec3 col=vec3(0);\n /*\n float fresnel=1.+(dot(normal,rayDir))*.5;\n fresnel=bias(fresnel,.35);\n fresnel=pow(fresnel,2.4);\n refl=mix(vec3(0.0),refl,fresnel);\n col=mix(refl,refr,.0);//col = mix(refl,refr,fresnel);\n */\n \n col=n;\n //col=der*.5+.5;\n //vec3 fogColor=vec3(0.3,.6,1.);\n //col=mix(refl,fogColor,fog);\n \n //col.y*=.4;\n //col.y=0.;\n \n col=col.zxy;//swivel for \"blue\" flat water.\n col.xy*=.5;\n    \n /*\n hitPoint=fract(hitPoint);\n hitPoint=vec3(length(hitPoint));\n col=mix(col,hitPoint,.2);\n */ \n    \n //col=mix(col,vec3(log(std)),.1);\n    \n //col=vec3(fract(std*100.));\n //col=sqrt(col);   \n \n Out=vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}