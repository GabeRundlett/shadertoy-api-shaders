{
    "Shader": {
        "info": {
            "date": "1457611190",
            "description": "Interactively explore the Pannini projection (see the source)",
            "flags": 32,
            "hasliked": 0,
            "id": "Ms3SzH",
            "likes": 12,
            "name": "Pannini's Rotunda",
            "published": 3,
            "tags": [
                "projection",
                "architecture",
                "widget"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 884
        },
        "renderpass": [
            {
                "code": "// \"Pannini's Rotunda\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Interactively explore the Pannini (or Panini) projection, a method for\n  reducing distortion in wide-angle images.\n  \n  The left slider widget (activated by button-down inside its box) controls\n  the focal length, starting from extreme wide angle. The right slider\n  controls the Pannini factor, with a logarithmic scale and range 0-150\n  (approx).\n\n  The green/red button toggles automatic or manual motion and viewing; in\n  manual mode the mouse controls view direction.\n\n  Vertical lines remain vertical, but serious distortion occurs at wide\n  angles!!\n\n  The scene is based on the earlier \"Flame Ascending\".\n  \n  For the maths see: T.K. Sharpless et al (2010)\n     (tksharpless.net/vedutismo/Pannini/panini.pdf)\n\n  Relation to standard projections (the cylindrical versions):\n  \n   x - horizontal coordinate (y coordinate is rectilinear and unaffected)\n   a - corresponding azimuth angle\n   f - proportional to lens focal length\n   p - Pannini factor \n\n   Pannini:       x = f*(p+1)*sin(a)/(p+cos(a)) \n   Rectlinear:    x = f*tan(a)         (p = 0)\n   Stereographic: x = f*2*tan(a/2)     (p = 1)\n   Orthographic:  x = f*sin(a)         (p large)\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4v3 (ip);\n  t2 = Hashv4v3 (ip + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    a *= 0.5;\n    p *= 4. * mr;\n  }\n  return f;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  p.z -= h * clamp (p.z / h, -1., 1.);\n  return length (p) - r;\n}\n\nfloat PrCapsShDf (vec3 p, float rIn, float rEx, float h)\n{\n  float s;\n  p.z -= h * clamp (p.z / h, -1., 1.);\n  s = length (p);\n  return max (s - rEx, rIn - s);\n}\n\nfloat PrFlatDiskDf (vec3 p, float w, float r)\n{\n  p.x -= w * clamp (p.x / w, -1., 1.);\n  return length (p.xy) - r;\n}\n\nfloat PrFlatCylShDf (vec3 p, float w, float rIn, float rEx, float h)\n{\n  float s;\n  p.x -= w * clamp (p.x / w, -1., 1.);\n  s = length (p.xy);\n  return max (max (s - rEx, rIn - s), abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvec3 sunDir, fBallPos, qHit;\nfloat dmRad, dmLen, dmUpRad, dmUpLen, psgLen, psgWid, psgHt, capRad, wThk, udBase,\n   fBallRad, tCur, tCyc, capPos, ltFac, qLenH, qAngH, dstFar;\nint idObj, runState;\nconst int idDm = 1, idDmUp = 2, idPsg = 3, idFlor = 4, idCol = 5, idHot = 6,\n  idArch = 7;\n\nvec3 GrndCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w;\n  float f;\n  w = 5. * ro.xz;\n  f = Fbm2 (w);\n  vn = normalize (vec3 (f - Fbm2 (w + vec2 (0.01, 0.)), 0.1,\n     f - Fbm2 (w + vec2 (0., 0.01))));\n  col = 0.4 * mix (vec3 (0.4, 0.3, 0.1), vec3 (0.4, 0.5, 0.2), f) *\n       (1. - 0.1 * Noisefv2 (31. * w));\n  col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n  col = mix (col, vec3 (0.05, 0.1, 0.25) + 0.25, pow (1. + rd.y, 32.));\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.05, 0.1, 0.25) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.2 * pow (sd, 6.) + 0.4 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    sd = - ro.y / rd.y;\n    ro += sd * rd;\n    col = GrndCol (ro, rd);\n  }\n  return col;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, dc, dm, dr;\n  dMin = dstFar;\n  q = p;\n  qLenH = length (q.xz);\n  qAngH = atan (q.z, - q.x) / (2. * pi);\n  dr = (q.y > dmLen) ? abs (fract (18. * (atan (q.y - dmLen, qLenH) /\n     (2. * pi) - 0.25)) - 0.5) : 2. * abs (abs (q.y / dmLen - 0.5) - 0.5);\n  dr = wThk * clamp (4. * min (dr, abs (fract (8. * qAngH) - 0.5)) - 0.1, 0., 0.25);\n  dm = max (PrCapsShDf (q.xzy, dmRad - wThk + dr, dmRad - dr, dmLen),\n     max (0.14 * dmRad - length (p.xz), - q.y));\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * qAngH) + 0.5) / 4.);\n  qq = q;\n  q.x -= wThk - dmRad;\n  d = max (PrFlatCylShDf (q.yzx, psgHt, psgWid - 1.3 * wThk,\n     psgWid - 0.9 * wThk, wThk), - q.y); \n  if (d < dMin) { dMin = d;  idObj = idArch;  qHit = q; }\n  q.x -= - psgLen;\n  dc = PrFlatDiskDf (q.yzx, psgHt, psgWid - wThk);\n  dr = wThk * clamp (min (4. * abs (fract ((q.x - 0.5 * psgLen) /\n     (0.95 * psgLen)) - 0.5),\n     8. * abs (fract ((q.y + psgHt) / (1.95 * psgHt)) - 0.5)) - 0.2, 0., 0.25);\n  d = max (max (PrFlatCylShDf (q.yzx, psgHt, psgWid - wThk, psgWid - dr, psgLen),\n     dmRad - 0.5 * wThk - qLenH), - q.y);\n  if (d < dMin) { dMin = d;  idObj = idPsg;  qHit = q; }\n  q = p;\n  d = max (dm, - dc);\n  if (d < dMin) { dMin = d;  idObj = idDm;  qHit = q; }\n  q.y -= udBase;\n  d = max (max (PrCapsShDf (q.xzy, dmUpRad - wThk, dmUpRad, dmUpLen), - q.y),\n     0.05 * dmRad - qLenH);\n  if (d < dMin) { dMin = d;  idObj = idDmUp;  qHit = q; }\n  q = p;\n  d = PrCylDf (q.xzy, 6. * dmRad, 0.01 * dmLen);\n  d = max (d, capRad - qLenH);\n  q.y -= capPos;\n  d = min (d, PrCylDf (q.xzy, capRad, 0.05 * dmLen));\n  if (d < dMin) { dMin = d;  idObj = idFlor;  qHit = qq; }\n  q = p;\n  q.y -= -0.2 * dmLen;\n  d = max (PrCylDf (q.xzy, capRad, 0.2 * dmLen), 0.99 * capRad - qLenH);\n  if (d < dMin) { dMin = d;  idObj = idHot; }\n  q = p;\n  q.y -= dmLen;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * qAngH) + 0.5) / 8.);\n  q.xy -= vec2 (2. * wThk, -0.5 * dmLen);\n  d = PrCapsDf (q.xzy, 0.035 * dmRad, 0.5 * dmLen);\n  if (d < dMin) { dMin = d;  idObj = idCol;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat FBallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  return (d >= 0.) ? - b - sqrt (d) : dstFar;\n}\n\nfloat FBallLum (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, f, ri, t;\n  p = ro + dHit * rd - fBallPos;\n  dp = 0.033 * fBallRad * rd;\n  ri = 0.9 / fBallRad;\n  t = 3. * tCur;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    q = 20. * p;\n    q.y -= t;\n    f = Fbm3 (q);\n    q = 35. * p;\n    q.y -= 1.9 * t;\n    f += Fbm3 (q);\n    s = length (p);\n    g += max (0.075 * max (1. - s * ri, 0.) * (f - 1.1), 0.);\n    if (s > fBallRad || g > 1.) break;\n  }\n  return g;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.3 + 0.7 * clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvoid SetConfig ()\n{\n  float tIn, tm;\n  dmRad = 1.2;\n  dmLen = 1.3;\n  dmUpRad = 0.17 * dmRad;\n  dmUpLen = 0.08 * dmLen;\n  psgLen = 0.4 * dmRad;\n  psgHt = 0.55 * dmLen;\n  psgWid = 0.22 * dmLen;\n  capRad = 0.3 * dmRad;\n  wThk = 0.06;\n  udBase = dmLen + sqrt (dmRad * dmRad - dmUpRad * dmUpRad) - wThk;\n  fBallRad = 0.3;\n  tCyc = 15.;\n  tIn = mod (tCur / tCyc, 1.);\n  capPos = -0.04 * dmLen - 0.3 * dmLen * SmoothBump (0.05, 0.15, 0.05, tIn);\n  ltFac = SmoothBump (0.1, 0.95, 0.05, tIn);\n  fBallPos = vec3 (0.);\n  tm = 0.07;\n  fBallPos.y = fBallRad + capPos + (dmLen + dmRad - fBallRad) *\n     ((tIn > tm) ? (tIn - tm) / (1. - tm) : (tm - tIn) / tm);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  float ti[6], a, rHi, rLo, trkCyc;\n  ti[0] = 0.;\n  ti[1] = ti[0] + 0.05;\n  ti[2] = ti[1] + 0.2;\n  ti[3] = ti[2] + 0.5;\n  ti[4] = ti[3] + 0.2;\n  ti[5] = ti[4] + 0.05;\n  trkCyc = 4. * tCyc;\n  a = floor (t / trkCyc);\n  t = fract (t / trkCyc);\n  if      (t < ti[1]) a += 0.25 * (t - ti[0]) / (ti[1] - ti[0]);\n  else if (t < ti[2]) a += 0.25;\n  else if (t < ti[3]) a += 0.25 + 0.5 * (t - ti[2]) / (ti[3] - ti[2]);\n  else if (t < ti[4]) a += 0.75;\n  else if (t < ti[5]) a += 0.75 + 0.25 * (t - ti[4]) / (ti[5] - ti[4]);\n  rHi = 3.5 * dmRad;\n  rLo = 0.8 * dmRad;\n  p = vec3 (0., 0.8 * psgHt, - rHi + (rHi - rLo) * SmoothBump (0.15, 0.85, 0.1, t));\n  p.xz = Rot2D (p.xz, pi * a);\n  return p;\n}\n\nbool ChkInside ()\n{\n  vec3 q;\n  bool isIn;\n  isIn = false;\n  if (idObj == idDm) {\n    q = qHit;\n    q.y -= dmLen;\n    isIn = (((q.y < 0.) ? qLenH : length (q)) < dmRad - 0.3 * wThk);\n  } else if (idObj == idDmUp) {\n    q = qHit;\n    q.y -= dmUpLen;\n    isIn = (((q.y < 0.) ? qLenH : length (q)) < dmUpRad - 0.01 * wThk);\n  } else if (idObj == idPsg) {\n    q = qHit;\n    q.y -= psgHt;\n    isIn = (((q.y < 0.) ? abs (qHit.z) : length (q.yz)) < psgWid - 0.9 * wThk);\n  } else if (idObj == idFlor) {\n    isIn = (abs (qHit.z) < psgWid &&\n       abs (qHit.x) < dmRad + 2. * psgLen - wThk || qLenH < dmRad);\n  } else if (idObj == idCol || idObj == idHot || idObj == idArch) isIn = true;\n  return isIn;\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float zmVar, float pnVar)\n{\n  vec4 wgBx[3];\n  vec2 ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.41 * asp, 0.1, 0.012 * asp, 0.15);\n  wgBx[1] = vec4 (0.47 * asp, 0.1, 0.012 * asp, 0.15);\n  wgBx[2] = vec4 (0.44 * asp, -0.15, 0.025, 0.);\n  ust = abs (0.5 * uv - wgBx[0].xy) - wgBx[0].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[0].xy;\n  ust.y -= (zmVar - 0.5) * 2. * wgBx[0].w;\n  ust = abs (ust) - 0.6 * wgBx[0].zz;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 2.) col = vec3 (1., 0.3, 1.);\n  ust = abs (0.5 * uv - wgBx[1].xy) - wgBx[1].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[1].xy;\n  ust.y -= (pnVar - 0.5) * 2. * wgBx[1].w;\n  ust = abs (ust) - 0.6 * wgBx[1].zz;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 2.) col =\n     (pnVar > 0.3) ? vec3 (1., 0., 0.1) : ((pnVar > 0.1) ?\n     vec3 (1., 1., 0.1) : vec3 (0.1, 1., 0.1));\n  if (length (0.5 * uv - wgBx[2].xy) < wgBx[2].z)\n     col = (runState > 0) ? vec3 (0.2, 0.7, 0.2) : vec3 (0.7, 0.2, 0.2);\n  return col;\n}\n\nvec4 ObjCol (vec3 ro, bool inside)\n{\n  vec4 objCol;\n  vec2 u;\n  float f;\n  if (inside) {\n    if (idObj == idDm || idObj == idDmUp) objCol = vec4 (0.4, 0.1, 0.1, 0.3);\n    if (idObj == idDm) {\n      if (((qHit.y < dmLen) ? qLenH : length (qHit - vec3 (0., dmLen, 0.))) >\n         dmRad - 0.77 * wThk) {\n        if (qHit.y < dmLen) {\n          u = vec2 (1.5 * (fract (4. * qAngH + 0.5) - 0.5), qHit.y / dmLen - 0.6);\n          u *= u;\n          objCol.rgb = mix (objCol.rgb, vec3 (0.3, 0.3, 1.),\n             SmoothBump (0.01, 0.025, 0.005,\n             abs (80. * dot (u, u) - 0.14) - 0.005));\n        }\n      } else objCol = vec4 (0.5, 0.5, 0.8, 0.3);\n    } else if (idObj == idFlor) {\n      f = SmoothBump (0.7, 1.1, 0.1, Fbm2 (17. * ro.xz));\n      objCol = vec4 (mix (vec3 (0.3, 0.8, 0.4), vec3 (0.2, 0.6, 0.3), f),\n         1. - 0.95 * f);\n    } else if (idObj == idCol) {\n      objCol = vec4 (0.7, 0.7, 0., 0.3) * (0.7 +\n         0.3 * sin (pi * mod (20. * (atan (qHit.x, qHit.z) / (2. * pi) + 0.5 +\n           qHit.y / dmLen), 1.)));\n    } else if (idObj == idHot) objCol = vec4 (1., 0., 0., 0.) *\n       (0.3 + 0.7 * Noiseff (50. * tCur));\n    else if (idObj == idPsg) objCol = vec4 (0.3, 0.3, 1., 0.3);\n    else if (idObj == idArch) objCol = vec4 (0.3, 0.3, 1., 0.3);\n  } else {\n    if (idObj == idDm || idObj == idPsg) objCol = vec4 (0.85, 0.8, 0.8, 0.7);\n  }\n  return objCol;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 roo, col, vn, flmCol, ltDir, ltVec;\n  float dstHit, dstFbHit, fIntens, ltDist, f;\n  int idObjT;\n  bool isIn, isBg;\n  dstFbHit = FBallHit (ro, rd, fBallPos, fBallRad);\n  roo = ro;\n  dstHit = ObjRay (ro, rd);\n  isBg = false;\n  if (dstHit < dstFar) {\n    idObjT = idObj;\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    isIn = ChkInside ();\n    objCol = ObjCol (ro, isIn);\n    if (isIn) {\n      if (idObj == idFlor) {\n        f = fract (5. * qLenH / dmRad) - 0.15;\n        if (abs (f) < 0.04) {\n          vn.xz -= 20. * f * ro.xz / qLenH;\n          vn = normalize (vn);\n        }\n      }\n      ltVec = fBallPos - ro;\n      ltDist = length (ltVec);\n      ltDir = (fBallPos - ro) / ltDist;\n      f = max (dot (vn, ltDir), 0.);\n      col = objCol.rgb * (0.1 + vec3 (1., 0.8, 0.8) * f * (0.1 + 0.9 * f) +\n         vec3 (1., 0., 0.7) * objCol.a *\n         pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n      if (idObj != idHot) col *= (0.2 + 0.8 * ltFac) /\n         (1. + 0.5 * pow (ltDist, 4.));\n    } else {\n      if (idObj == idDmUp || idObj == idDm && qHit.y > dmLen &&\n         length (qHit - vec3 (0., dmLen, 0.)) - dmRad < -0.23 * wThk) {\n        rd = reflect (rd, vn);\n        isBg = true;\n      } else if (idObj == idFlor) col = GrndCol (ro, rd);\n      else col = objCol.rgb * (0.3 +\n         0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.7 * max (0., max (dot (vn, sunDir), 0.)) +\n         objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n    }\n  } else isBg = true;\n  if (isBg) col = BgCol (ro, rd);\n  col *= ObjAO (ro, vn);\n  if (dstFbHit < min (dstHit, dstFar)) {\n    fIntens = (dstFbHit < dstFar) ? FBallLum (roo, rd, dstFbHit) : 0.;\n    f = clamp (0.7 * fIntens, 0., 1.);\n    f *= f;\n    flmCol = 1.5 * (0.7 + 0.3 * Noiseff (20. * tCur)) *\n       mix (vec3 (1., 0.1, 0.1), vec3 (1., 1., 0.5), f * f);\n    col = mix (col, flmCol, ltFac * min (fIntens * fIntens, 1.));\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (0.7));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, wgBx[2];\n  mat3 vuMat;\n  vec3 ro, rd, vd, u, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, f, a, asp, zmVar, pnVar, zmFac, pnFac, tRun;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  SetConfig ();\n  stDat = Loadv4 (0);\n  zmVar = stDat.x;\n  pnVar = stDat.y;\n  el = stDat.z;\n  az = stDat.w;\n  stDat = Loadv4 (1);\n  runState = int (stDat.y);\n  tRun = stDat.z;\n  asp = canvas.x / canvas.y;\n  ro = TrackPath (tRun);\n  if (runState > 0) {\n    vd = mix (vec3 (- ro.x, 0.3 * dmLen, - ro.z), fBallPos - ro, \n      smoothstep (-0.5, 0., 1. - length (ro.xz) / dmRad));\n    vd = normalize (vd);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  } else {\n    ori = vec2 (el, az - atan (ro.x, - ro.z));\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n       mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  }\n  dstFar = 20.;\n  zmFac = 0.2 + 2.8 * zmVar;\n  pnFac = exp (5. * pnVar) - 1.;  \n  a = atan (uv.x / (asp * zmFac));\n  rd = vuMat * normalize (vec3 (((1. + pnFac) * sin (a) / (pnFac + cos (a))) * asp,\n     uv.y / zmFac, 1.));\n  a = 0.022 * pi * tCur;\n  sunDir = normalize (vec3 (cos (a), 3. + cos (0.55 * a), sin (a)));\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, zmVar, pnVar);\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Pannini's Rotunda\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[3], stDat, mPtr, mPtrP;\n  vec2 iFrag, canvas, ust;\n  float az, el, asp, zmVar, pnVar, tCur, tCurP, tRun;\n  int pxId, wgSel, wgReg, runState;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId > 2) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  runState = 1;\n  tRun = 0.;\n  zmVar = 0.3;\n  pnVar = 0.25;\n  el = 0.;\n  az = 0.;\n  wgSel = -1;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n  } else {\n    stDat = Loadv4 (0);\n    zmVar = stDat.x;\n    pnVar = stDat.y;\n    el = stDat.z;\n    az = stDat.w;\n    stDat = Loadv4 (1);\n    wgSel = int (stDat.x);\n    runState = int (stDat.y);\n    tRun = stDat.z;\n    tCurP = stDat.w;\n    mPtrP = Loadv4 (2);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.41 * asp, 0.1, 0.012 * asp, 0.15);\n    wgBx[1] = vec4 (0.47 * asp, 0.1, 0.012 * asp, 0.15);\n    wgBx[2] = vec4 (0.44 * asp, -0.15, 0.025, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 0;\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) - wgBx[1].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 1;\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[2].xy) < wgBx[2].z) wgReg = 2;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      el = clamp (0.5 * pi * mPtr.y, -0.49 * pi, 0.49 * pi);\n      az = clamp (pi * mPtr.x, - pi, pi);\n    }\n  } else {\n    if (wgSel == 0) {\n      zmVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    } else if (wgSel == 1) {\n      pnVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[1].y) / wgBx[1].w, 0., 1.);\n    } else if (wgSel == 2) {\n      if (mPtrP.z <= 0.) runState = 1 - runState;\n    }\n  }\n  if (runState > 0) tRun += tCur - tCurP;\n  tCurP = tCur;\n  if (pxId == 0) stDat = vec4 (zmVar, pnVar, el, az);\n  else if (pxId == 1) stDat = vec4 (float (wgSel), float (runState), tRun, tCurP);\n  else if (pxId == 2) stDat = mPtr;\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}