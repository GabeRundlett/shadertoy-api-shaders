{
    "Shader": {
        "info": {
            "date": "1681904186",
            "description": "Simple path tracing with direct shadow sampling ",
            "flags": 32,
            "hasliked": 0,
            "id": "cl33R8",
            "likes": 7,
            "name": "PT-Sphere-Box",
            "published": 3,
            "tags": [
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "jvb",
            "viewed": 302
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(texture(iChannel0,uv).xyz,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\n#define PROCESSING_TEXTURE_SHADER\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n\n#define PI 3.1415926535\n\n#define BOUNCES         3\n#define SHADOW_VOLUME   1\n#define USE_AMBIENT     0\n#define MULTISAMPLE_TEX 0\n#define BARREL          1\n#define CROP_Y          0\n#define SSAMPLES        10\n#define GAMMA           1\n#define COLOR_GRAIN     1\n\n\nvec3 uniformlyRandomDirection(float seed);\nvec3 uniformlyRandomVector(float seed);\n\nvec3 rotatey(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.z*sin(ang),p.y,p.x*sin(ang)+p.z*cos(ang));  }\nvec3 rotatex(in vec3 p, float ang) { return vec3(p.x,p.y*cos(ang)-p.z*sin(ang),p.y*sin(ang)+p.z*cos(ang));  }\nvec3 rotatez(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.y*sin(ang),p.x*sin(ang)+p.y*cos(ang),p.z);  }\n\nvec2 sph(in vec3 p, float r, float o) { return vec2(length(p)-r, o); }\nvec2 rbox(in vec3 p, in vec3 b, float r, float o) { return vec2(length(max(abs(p)-b,0.0))-r, o); }\nvec2 sdbox( vec3 p, vec3 b, float o ) { vec3 d = abs(p) - b; return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), o); }\nvec2 plane(in vec3 p, in vec3 n, float d, float o) { return vec2(dot(p,n)-d, o); }\n\nvec2 min2(in vec2 o1, in vec2 o2) { if (o1.x < o2.x) return o1; else return o2; }\nvec2 max2(in vec2 o1, in vec2 o2) { if (o1.x > o2.x) return o1; else return o2; }\nfloat lightgap = 1.0;\n\n\nvec3 lightpos;\nvec3 lightsize; \n\nvec2 scene(in vec3 p)\n{\n    vec2 d = vec2(1000.0, 0);\n    vec3 op = p;\n\n    lightpos = vec3(sin(time)*7.0,cos(time)*3.0,sin(time*0.7)*12.0);\n    lightsize = vec3(1,1,1)*1.0; \n\n    d = min2(d, vec2(-1,1)*sdbox(p-vec3(0,0,0), vec3(8,4,16), 3.0));\n    d = min2(d, vec2(1,1)*sdbox(p-vec3(0,-3,-8), vec3(1,1,1), 3.0));\n    d = min2(d, vec2(1,1)*sdbox(p-vec3(2.3,-3,-7.7), vec3(1,2,1), 3.0));\n    d = min2(d, vec2(1,1)*sph(p-vec3(-2.3,-3,-7.7), 1.0, 3.0));\n//    d = min2(d, vec2(1,1)*sdbox(p-lightpos, lightsize*1.0, 1.0));\n    \n    return d;\n}\n\n\n\nvec3 get_ambient(in vec3 p)\n{\n    vec3 s0 = vec3(0);\n    return s0;\n}\n\nvec3 get_tex(in vec3 p)\n{\n    vec3 op = p;\n    vec3 col = vec3(1);\n\t\n\tif (abs(lightpos.x-p.x)<lightsize.x && abs(lightpos.y-p.y)<lightsize.y && abs(lightpos.z-p.z)<lightsize.z) return vec3(22); \n    return vec3(0.0)+0.0*sin(p.z*0.3+2.0);\n}\nvec3 get_normal(in vec3 p)\n{\n    vec3 eps = vec3(0.00001, 0, 0);\n    float nx = scene(p + eps.xyy).x - scene(p - eps.xyy).x;\n    float ny = scene(p + eps.yxy).x - scene(p - eps.yxy).x;\n    float nz = scene(p + eps.yyx).x - scene(p - eps.yyx).x;\n    return normalize(vec3(nx,ny,nz));\n}\n\n\nfloat random(vec3 scale, float seed) {\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nfloat PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat seed;\nfloat rand1()\n{\n    vec2 s = gl_FragCoord.xy/resolution.xy;\n    float n = fract(sin(seed+=1.0)*43758.5453123);\n    return fract(n + fract(sin(dot(vec2(n * s.y, s.x)*0.123,vec2(12.9898,78.233))) * 43758.5453));\n}\n//returns a random unit vector inside the given hemisphere\nvec3 rndDirHemisphere(vec3 n)\n{\n    float r2 = rand1();\n    float phi = 2.0*PI*rand1();\n    float sina = sqrt(r2);\n    float cosa = sqrt(1. - r2);\n    vec3 w = normalize(n), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n    return normalize((u*cos(phi) + v*sin(phi)) * sina + w * cosa);\n}\n\n\nvec3 cosineWeightedDirection(float seed, vec3 normal) {\n#if 0\n    float a = 2.0*random(vec3(12.9898, 78.233, 151.7182), seed)-1.0;\n    float b = 2.0*random(vec3(63.7264, 10.873, 623.6736), seed)-1.0;\n    float c = sqrt(1.0-a*a);\n    vec3 r = vec3(c*cos(b),a,c*sin(b));\n    return dot(r,normal) > 0.0 ? r : -r;\n#else\n    float u = random(vec3(12.9898, 78.233, 151.7182), seed);\n    float v = random(vec3(63.7264, 10.873, 623.6736), seed);\n    float r = sqrt(u);\n    float angle = 6.283185307179586 * v;\n    vec3 sdir, tdir;\n    if (abs(normal.x)<.5) {\n        sdir = cross(normal, vec3(1,0,0));\n    } else {\n        sdir = cross(normal, vec3(0,1,0));\n    }\n    tdir = cross(normal, sdir);\n    return r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal;\n#endif\n}\n\nvec3 uniformlyRandomDirection(float seed) {\n    float u = random(vec3(12.9898, 78.233, 151.7182), seed);\n    float v = random(vec3(63.7264, 10.873, 623.6736), seed);\n    float z = 1.0 - 2.0 * u; float r = sqrt(1.0 - z * z);\n    float angle = 6.283185307179586 * v;\n    return vec3(r * cos(angle), r * sin(angle), z);\n}\n\nvec3 uniformlyRandomVector(float seed) {\n    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));\n}\n\nbool shadowray(out float shadow_dist, in vec3 ro, in vec3 rd, float time)\n{\n    \n    vec3 colorMask = vec3(1.0);\n    vec3 color = vec3(0.0);\n    vec3 surfaceColor = vec3(0);\n    vec3 tex = vec3(0);\n    \n    vec3 pos = ro;\n    float dist = 0.0;\n    vec2 d = vec2(0);\n    bool hit = true; \n    for (int i = 0; i < 64; i++) {\n        d = scene(pos);\n\t    if (abs(d.x) < 0.00001) { hit = true; break; }\n        pos += rd*d.x;\n    }\n    dist = length(pos - ro);\n\t#if 0\n\tif (dist < length(rd)) \t\n\t\treturn true;  \n\telse\n\t\treturn false; \n\t#endif\n\tshadow_dist = dist; \n    return hit;\n}\n\nvec3 mr(in vec3 ro, in vec3 rd, float time)\n{\n    \n    vec3 colorMask = vec3(1.0);\n    vec3 color = vec3(0.0);\n    vec3 surfaceColor = vec3(0);\n    vec3 tex = vec3(0);\n    \n    vec3 pos = ro;\n    float dist = 0.0;\n    vec2 d = vec2(0);\n    for (int i = 0; i < 80; i++) {\n        d = scene(pos);\n        if (abs(d.x) < 0.00001) break;\n        pos += rd*d.x;\n    }\n    dist = length(pos - ro);\n    if (true) {\n        float o = d.y;\n        vec3 n = get_normal(pos);\n        float shade = 1.0; //0.9+0.1*ambientOcclusion(pos+0.001*n, 1.0*n);\n        \n        tex = get_tex(pos);\n        \n        float refl = 0.0;\n        if (d.y == 1.0) {\n            if (abs(pos.z+8.0) < mouse.x*100.0 && abs(pos.y+2.0) > mouse.y*5.0)\n                surfaceColor = vec3(1,1,1)*(30.0);\n            else\n                surfaceColor = vec3(1,1,1)*0.0;\n            \n\t\t\tsurfaceColor = vec3(1,1,1)*300.0;\n            refl = 0.4;\n        }\n        else if (d.y == 2.0) {\n            surfaceColor = tex*vec3(1,1,1)*(0.0);\n            refl = 0.4;\n        }\n        else if (d.y == 3.0) {\n            surfaceColor = tex*vec3(1,1,1);\n            refl = 1.0;\n        }\n    }\n    return surfaceColor;\n}\n\nvec3 rm(in vec3 ro, in vec3 rd, float time)\n{\n    vec3 colorMask = vec3(1.0);\n    vec3 color = vec3(0.0);\n    vec3 surfaceColor = vec3(0);\n    vec3 tex = vec3(0);\n\tfor (int bounce = 0; bounce < BOUNCES; bounce++) {\n        vec3 pos = ro;\n        float dist = 0.0;\n        vec2 d = vec2(0);\n        \n        if (bounce == 0) {\n            for (int i = 0; i < 64; i++) {\n                d = scene(pos);\n                if (abs(d.x) < 0.00001) break;\n                pos += rd*d.x;\n            }\n        }\n        else {\n            for (int i = 0; i < 32; i++) {\n                d = scene(pos);\n                if (abs(d.x) < 0.00001) break;\n                pos += rd*d.x;\n            }\n        }\n        dist = length(pos - ro);\n        float o = d.y;\n        vec3 n = get_normal(pos);\n        float shade = 1.0;\n        if (true) {           \n #if SHADOW_VOLUME\n            vec3 lp = lightpos + uniformlyRandomVector(time)*lightsize;\n            vec3 l =  lp- pos;\n            float dp = 2.0*clamp(dot(n,normalize(l)), 0.0, 1.0); \n            //float dp = 2.0;\n            float shadow_dist = 0.0; \n            if (bounce >= 0) {\n                if ( shadowray(shadow_dist,pos+0.001*n, normalize(l), time) == false) {\n                    dp = 0.0;\n                }\n            if (shadow_dist < length(l)) dp = 0.0; \n\t\t\tcolor += 1.0*vec3(1.0)*dp;\n            }\n#endif\n            if (true) {\n#if MULTISAMPLE_TEX\n                tex = vec3(0);\n                for (int i = 0; i < 16; i++) {\n                    float AA = 0.01;\n                    tex += get_tex(pos + AA*uniformlyRandomVector(float(time)+float(i)));\n                }\n                tex /= 16.0;\n#else\n                tex = get_tex(pos);\n#endif\n            }\n            \n#if USE_AMBIENT\n            color += get_ambient(pos);\n#endif\n            float refl = 0.0;\n            if (d.y == 1.0) {\n\t\t\t\tsurfaceColor = vec3(1,1,1)*300.0;\n                refl = 0.4;\n            }\n            else if (d.y == 2.0) { // unlit\n                surfaceColor = tex*vec3(1,1,1)*(0.0);\n                refl = 0.4;\n            }\n            else if (d.y == 3.0) {\n                surfaceColor = tex*vec3(1,1,1);\n                refl =1.0;\n            }\n            colorMask *= surfaceColor;\n\t\t\tcolor += 1.0*shade*surfaceColor*clamp(dist, 1.0, 1.0); //*colorMask;\n            float rr = random(vec3(36.7539, 50.3658, 306.2759), time+float(bounce));\n            refl = clamp(refl*rr, 0.0, 1.0);\n            ro = pos+n*0.0001;\n            vec3 rd2 = reflect(rd, n);\n            rd = normalize(rndDirHemisphere(n));\n            rd = normalize(mix(rd, rd2, refl));\n        }\n    }\n    return clamp(color*0.1, 0.0, 2.0);\n}\n\n\nvoid make_camera(out vec3 ro, out vec3 rd, in vec2 p, float time)\n{\n    \n    float AA = 0.0025;\n    p += uniformlyRandomVector(time).xy*AA;\n    vec3 campos = vec3(sin(time)*10.0,1,0);\n    vec3 camtar = vec3(0,1,1);\n    vec3 camup = vec3(0,1,0);\n    \n    vec3 camdir = normalize(camtar-campos);\n    vec3 cu = normalize(cross(camdir, camup));\n    vec3 cv = normalize(cross(cu, camdir));\n    \n    \n    ro = vec3(0,-0.0,2.0);\n    rd = normalize(vec3(p.x,p.y,-2.));\n    \n#if BARREL\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*0.4, 0.))));\n    rd.z *= -1.0;\n#endif\n    \n    vec2 tmouse = vec2(10.6+time*0.001, 3.7+time*0.002);\n    tmouse = vec2(mouse.x*1.0,mouse.y*1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{    \n    vec2 p = 2.0*( fragCoord.xy / resolution.xy )-1.0;\n    p.x *= resolution.x/resolution.y;\n    \n    int pass = 0;\n    vec2 uv = fragCoord.xy / resolution.xy;\n    seed = (uv.y + (time+float(pass)) * 0.523413187) * sqrt(uv.x * 0.77777777 * time);\n    \n#if CROP_Y\n    if (abs(p.y) > 0.6) { gl_FragColor = vec4(0); return; }\n#endif\n    \n    vec3 color = vec3(0.0);\n    vec3 ro, rd;\n    for (int i = 0; i < SSAMPLES; i++) {\n        make_camera(ro,rd,p,time+float(i+pass));\n        color += rm(ro, rd, time+float(i+pass));\n    }\n    color /= float(SSAMPLES);\n    \n#if GAMMA\n    color = pow(color,1.0/vec3(1.3))*1.0;\n#endif\n    color *= vec3(0.98,0.98,1.0);\n#if COLOR_GRAIN\n    color += uniformlyRandomVector(time)*0.05;\n#endif\n\t\t\n\tcolor = mix(color, texture(iChannel0,fragCoord.xy/resolution.xy).xyz, 0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}