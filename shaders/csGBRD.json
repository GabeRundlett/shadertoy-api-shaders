{
    "Shader": {
        "info": {
            "date": "1698463925",
            "description": "My idea of convolution reverb, which is pasting an impulse every sample and multiplying it by that sample's amplitude.\nI added a time offset like in the fork. If you remove the offset it's more accurate, but sounds worse and needs more samples.",
            "flags": 8,
            "hasliked": 0,
            "id": "csGBRD",
            "likes": 22,
            "name": "Convolution Reverb (Kinda)",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "convolution",
                "synthesis",
                "synth",
                "saw",
                "song",
                "reverb",
                "gpusound",
                "supersaw",
                "chords"
            ],
            "usePreview": 0,
            "username": "MysteryPancake",
            "viewed": 745
        },
        "renderpass": [
            {
                "code": "// From https://www.shadertoy.com/view/cdXSWj\nvec3 drawTrack(vec2 uv, vec2 samp, float offset, vec3 color) {\n    float glow = min(1.0, 0.03 / abs(uv.y - samp.x * 0.05 - offset));\n    float line = min(1.0, 0.003 / abs(uv.y - samp.y * 0.05 - offset));\n    return line + glow * color * 0.4;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    Song song = getSong(iTime + (uv.x - 1.0) * SPB * 0.1, REVERB_SAMPLES / 4);\n    Song songNow = getSong(iTime, 0);\n    float boom = 1.0 - songNow.sidechain;\n    \n    // Draw foreground\n    vec3 col = drawTrack(uv, song.drums, 0.8 + boom * 0.1, vec3(1.0, 0.0, 0.0));\n    col += drawTrack(uv, song.bass, 0.6 + boom * 0.2, vec3(1.0, 1.0, 0.0));\n    col += drawTrack(uv, song.leads, 0.4 - boom * 0.2, vec3(0.0, 0.0, 1.0));\n    col += drawTrack(uv, song.reverb, 0.2 - boom * 0.1, vec3(0.5, 0.0, 1.0));\n    \n    // Draw background\n    vec2 center = uv - 0.5;\n    vec2 coolUv = fract(center / dot(center, center));\n    float dist = sin(iTime * 4.0 - length(coolUv - 0.5) * 24.0 - 8.0 * boom) * 0.5 + 0.5;\n    col += min(2.0, (0.05 + boom) / dist) * uv.yxx * (0.1 + boom);\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 mainSound(int samp, float time) {\n    Song song = getSong(time, REVERB_SAMPLES);\n    vec2 dry = (song.leads + song.bass) * song.sidechain + song.drums;\n    vec2 wet = song.reverb * song.sidechain;\n    return mix(dry, wet, WETNESS) * 0.45;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "const float BPM = 120.0;\nconst float SPB = 60.0 / BPM; // Seconds per beat\n\nconst float TUNING = 440.0;\nconst int MIDIOFFSET = 69;\n\nconst float TAU = 6.28318530;\n\nconst int REVERB_SAMPLES = 512;\nconst float WETNESS = 0.5;\n\n// MIDI note to frequency formula\nfloat noteFreq(int note) {\n\treturn TUNING * exp2(float(note - MIDIOFFSET) / 12.0);\n}\n\n// From https://www.shadertoy.com/view/clXSR7\nfloat waveSaw(float freq, float time) {\n    return fract(freq * time + 0.5) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Impulse for convolution, this will be sampled NUM_SAMPLES times\nvec2 impulse(float time) {\n    time *= iSampleRate;\n    return hash22(vec2(time * 452.3, time * 274.6)) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/tttfRj\nfloat noise(float s) {\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = smoothstep(0.0, 1.0, sf);\n    return mix(hash11(float(si)), hash11(float(si + 1)), sf) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float bandwidth) {\n    return sin(TAU * freq * fract(time)) * noise(time * bandwidth);\n}\n\n// From https://www.shadertoy.com/view/sls3WM\n// Sliding pitch sine wave, used for bass drop and kick\nfloat drop(float time, float df, float dftime, float freq) {\n    return sin(TAU * (freq * time - df * dftime * exp(-time / dftime)));\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat kick(float time) {\n    float body = drop(time, 512.0, 0.01, 60.0) * smoothstep(0.3, 0.0, time);\n    float click = coloredNoise(time, 8000.0, 2000.0) * smoothstep(0.007, 0.0, time);\n    return body * 2.0 + click * 1.5;\n}\n\nvec2 hats(float time) {\n    float falloff = (cos(time * TAU * 0.25 / SPB) + 2.5) * 8.0;\n    vec2 noise = hash22(vec2(time * iSampleRate, time * iSampleRate * 123.4)) * 2.0 - 1.0;\n    float volume = exp(-falloff * mod(time, SPB / 3.0));\n    return noise * volume;\n}\n\n// No optimization here, not feeling like it today\nfloat leadSynth(float time) {\n    const int notes[] = int[](\n        64,54,57,\n        64,54,57,\n        64,54,57,\n        62,52,57,\n        61,54,57,\n        61,54,57,\n        61,54,57,\n        59,57,52\n    );\n    float beatTime = 1.5 * time / SPB;\n    int note = notes[int(abs(beatTime)) % notes.length()];\n    float volume = step(fract(beatTime), 0.5 + sin(time * TAU * 0.125 / SPB) * 0.05);\n    return waveSaw(noteFreq(note), time) * volume;\n}\n\nfloat leadBass(float time) {\n    const int notes[] = int[](\n        38,38,38,\n        38,38,50,\n        38,38,38,\n        40,40,52,\n        42,42,42,\n        42,54,42,\n        42,42,54,\n        37,49,40\n    );\n    float beatTime = 1.5 * time / SPB;\n    int bass = notes[int(abs(beatTime)) % notes.length()];\n    float volume = step(fract(beatTime - 0.5), 0.4 + cos(time * TAU * 0.125 / SPB) * 0.1);\n    return waveSaw(noteFreq(bass), time) * volume;\n}\n\nstruct Song {\n    vec2 leads;\n    vec2 drums;\n    vec2 bass;\n    vec2 reverb;\n    float sidechain;\n};\n\nSong getSong(float time, int reverb) {\n    Song song;\n    song.reverb = vec2(0.0);\n    for (int i = 0; i < reverb; i++) {\n        float timeOffset = float(i) / iSampleRate;\n        \n        // Butcher the settings every 2nd time for variety\n        bool variety = mod(time - timeOffset, SPB * 64.0) > SPB * 32.0;\n        float offsetScale = variety ? 0.5 : 1.2;\n        float timeScale = variety ? 2.0 : 1.0;\n        \n        // Convolution reverb doesn't have a random time offset, but it sounds better with it\n        timeOffset += hash11(timeOffset * 126.7) * offsetScale;\n        \n        song.reverb += leadSynth(time * timeScale - timeOffset) * impulse(timeOffset);\n    }\n    song.reverb *= 0.105;\n    \n    song.leads = vec2(leadSynth(time));\n    song.bass = vec2(leadBass(time) * 1.3);\n    song.drums = hats(time) * 0.7 + kick(mod(time, SPB)) * 0.8;\n    song.sidechain = 0.3 + min(1.0, mod(time, SPB) * 6.0) * 0.7;\n    \n    return song;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}