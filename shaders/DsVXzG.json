{
    "Shader": {
        "info": {
            "date": "1681261404",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nJust had a timing idea from my last shader",
            "flags": 0,
            "hasliked": 0,
            "id": "DsVXzG",
            "likes": 16,
            "name": "Year of Truchets #009",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles",
                "truchetcore"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 262
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #009\n    04/12/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(26.37,45.93)))*4374.23); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n//@iq shapes\nfloat box( vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.025;\n}\nfloat box( vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat speed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,time=0.;\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0);\nmat2 r45,r25;\n\nconst float size = 1.35;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\nconst float spce = size;\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    vec3 q = vec3(0);\n    float id = 0.;\n    p.z+=time;\n    for(int i = 0; i<2; i++)\n    {\n        // based on @Shanes multi-tap stuff\n        // though cut down to two taps\n        float cnt = i==0 ? size : dbl;\n        q = vec3(p.x-cnt,p.yz);\n        id = floor(q.x/dbl) + .5;\n        q.x -= (id)*dbl;\n        float qf = (id)*dbl + cnt;\n        vec3 r = q; \n\n        float xid = floor(mod(qf,10.));\n        float t3 = lsp(xid, xid+1., tmod);\n        t3 = eoc(t3);\n        t3 = t3*t3*t3;\n        \n        float sw = t3*size;\n        float ga1 = floor(time*.1)*size;\n        r.z-=sw+ga1;\n        \n        float zid = floor((r.z + hlf)/size);\n        r.z = mod(r.z+hlf,size)-hlf;\n   \n        float hs = hash21(vec2(qf,zid));\n        if (hs>.5) r.x *= -1.;\n\n        vec2 d2 = vec2(length(r.xz-hlf), length(r.xz+hlf));\n        vec2 gx = d2.x<d2.y ? vec2(r.xz-hlf) : vec2(r.xz+hlf);\n        vec3 tq = vec3(gx.x,r.y,gx.y);\n\n        float thk = .2+.1*sin(p.x*.72);//(p.z-sw-ga1)\n        float d3 = box(r,vec3(hlf*.88));\n        float d4 = trs(tq,vec2(hlf,thk));\n\n        \n        if (hs>.6) d4 = min(length(r.yz)-thk,length(r.yx)-thk);\n        if (hs>.07&&hs<.1) d4 = min(length(r.yz)-thk, length(vec3(r.yx,abs(r.z)-hlf))-thk);\n        if (hs<.07) d4 = min(length(r.yx)-thk, length(vec3(abs(r.x)-hlf,r.yz))-thk);\n\n        d4 = max(abs(d4)-.05,-d4);\n        d3 = max(d3,d4);\n\n        if (d3<res.x){\n            hs = fract(hs*432.32);\n            res = vec2(d3,hs<.5?4.:3.);\n            hit= r;\n            gid = vec3(id,qf, 1.);\n        }\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.25:ray.x*.75;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 hue(float t) {\n    t+=T*.045;\n    return .45 + .35*cos(PI2*t*(vec3(.12,.47,.92)+vec3(0.88,.97,.85))); \n}\n\nvec4 FC = vec4(.075);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,100);\n    hitPoint = hit;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(10.,15.,25.);\n        vec3 l = normalize(lpos);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint*vec3(-1.,1,1);\n \n        float diff = clamp(dot(n,l),.1,.95);\n\n        // materials  \n        if(m==3.){\n            h = hue((25.+sid.y)*.035);\n            ref = h*.5;\n        }\n        if(m==4.){\n            h = vec3(.05);\n            ref = vec3(.05);\n        }\n        C = (diff*h);\n        \n       // C = mix(FC.rgb,C,exp(-.000005*d*d*d));\n        ro = p+n*.0001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    time = (T+512.32);\n    tmod = mod(time, 10.);\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,6.25);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? .5 : .5-(M.y/R.y * .5 - .25) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n    mat2 rx=rot(1.-.2*sin(T*.1)), ry=rot(.3*sin(T*.1));\n    \n    ro.yz*=rx,ro.xz*=ry;\n    rd.yz*=rx,rd.xz*=ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00075*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}