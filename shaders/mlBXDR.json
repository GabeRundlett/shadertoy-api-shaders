{
    "Shader": {
        "info": {
            "date": "1675918963",
            "description": "A fingerprint magnet.\nJust a quick test while I'm working on a more complex scene. Semi-accurate thin-film interference effect for the smudges, and semi-accurate PBR.",
            "flags": 32,
            "hasliked": 0,
            "id": "mlBXDR",
            "likes": 7,
            "name": "Smudged orb",
            "published": 3,
            "tags": [
                "sdf",
                "marble",
                "pbr",
                "iridescent",
                "thinfilm"
            ],
            "usePreview": 0,
            "username": "A_Toaster",
            "viewed": 287
        },
        "renderpass": [
            {
                "code": "#define EPS 0.0001\n#define NORM_EPS (EPS * 2.)\n#define SHADOW_BIAS (0.)\n#define MAX_DIST 10.\n\n#define PI 3.1415926535\n\nconst vec3 cam_origin = vec3(0., 0.75, 0.);\n\nconst vec3 ambient_boost = vec3(0.0);\n\n// Function prototypes\nvec3 calcNormal( in vec3 pos);\n\n\n// From https://www.shadertoy.com/view/XdsGDB\n// Set up a camera looking at the scene.\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\n// Noise functions\n// -----------------------------------------------------------------\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n// SDF Functions\n// -----------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat dot2(vec3 p) {\n    return dot(p,p);\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opU( float d1, float d2 ) { return min(d1, d2); }\n\n// polynomial smooth min\nfloat opSU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n// Smooth min returning mix factor\nvec2 opSUMix( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\nfloat opSS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 opMirrorZ(vec3 p){\n    return vec3(p.x, p.y, abs(p.z));\n}\n\n\n// Pedestal SDF\n// -----------------------------------------------------------------\n\nfloat pedestal_ridges(vec3 p) {\n    p.xz = abs(p.xz);\n    return min(\n        sdVerticalCapsule(p - vec3(0.7, -3.5, 1.), 3., 0.15),\n        sdVerticalCapsule(p - vec3(1., -3.5, 0.7), 3., 0.15)\n    );\n}\n\n\nfloat ground_displacement(vec3 p) {\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    vec3 q2 = p * 40.;\n    float f2 = noise( q2 ); q2 = m*q2*2.03;\n    f2 += 0.5*noise( q2 ); q2 = m*q2*2.04;\n    f2 += 0.25*noise( q2 ); q2 = m*q2*2.05;\n    f2 += 0.125*noise( q2 );\n    //f2 = f2 * f2 * (2. - f2);\n    \n    return f2 * 0.125;\n}\n\n\nfloat ground(vec3 p) {\n    vec3 q = p + vec3(0., 0.10, 0.);\n    float d = opSU(\n        opSU(\n            sdBox(q, vec3(1., 0.1, 1.)),\n            sdBox(q + vec3(0., 0.15, 0.), vec3(.95, 0.1, .95)),\n            0.05\n        ),\n        opSU(\n            sdBox(q + vec3(0., 2., 0.), vec3(0.85, 2., 0.85)),\n            opSS(\n                pedestal_ridges(q),\n                sdBoxFrame(q + vec3(0., 2., 0.), vec3(0.9, 2., 0.9), 0.2),\n                0.005\n            ),\n            0.03\n        ),\n        0.09\n    );\n    \n    // Calculate displacement if very close\n    if(d < 0.1)\n        d -= 0.002 * ground_displacement(p) + 0.01;\n    // Otherwise decrease distance a bit to avoid overshoot\n    else d -= .02;\n    return d;\n}\n\n// ball SDF\n// -----------------------------------------------------------------\n\nfloat ball(vec3 p){\n\n    \n    return sdSphere(p - vec3(0., 1., 0.), 0.75);\n}\n\nfloat map(vec3 p) {\n    return min(\n        ground(p),\n        ball(p)\n    );\n}\n\n\nfloat fract_noise(vec3 p) {\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n                    \n    vec3 q1 = p;\n    \n    float f1 = 0.5000*noise( q1 ); q1 = m*q1*2.01;\n    f1 += 0.2500*noise( q1 ); q1 = m*q1*2.02;\n    f1 += 0.1250*noise( q1 ); q1 = m*q1*2.03;\n    return f1;\n}\n\nfloat marble(vec3 p) {\n    float f1 = fract_noise(p);\n    f1 = smoothstep(0.5, 0.6, f1);\n    f1 = pow(4.0*f1*(1.0-f1), 2.);\n    \n    return f1;\n}\n\nvoid material(in vec3 p, out vec3 albedo, out float roughness, out float ao, out float metallic, out float film_thickness, out vec3 normal) {\n    float ground = ground(p);\n    float ball = ball(p);\n    \n    if(ground < ball) {\n        // Ground material\n        float d = clamp(ground_displacement(p) * 5., 0., 1.);\n        d = pow(1. - d, 2.);\n        float c = marble(p * vec3(2., 0.5, 2.))\n            + marble(p * vec3(5., 1., 5.));\n        c = clamp(c, 0., 1.);\n        albedo = vec3(0.23, 0.23, 0.23);\n        roughness = mix(0.65, 0.6, c);\n        ao = mix(1., 0.7, d);\n        metallic = c * 0.3;\n        film_thickness = 0.;\n    } else {\n        // ball material\n        albedo = vec3(0.35, 0.34, 0.31);\n        vec3 p2 = vec3(p.x * sin(iTime) + p.z * cos(iTime), p.y, p.x * cos(iTime) + p.z * -sin(iTime)); \n        float oiliness = smoothstep(0.25, 1., fract_noise(p2 * 2.));\n        \n        roughness = mix(0.3, 0.8, oiliness);\n        ao = 1.;\n        metallic = mix(0.99, 0.7, oiliness);\n        \n        film_thickness = 10. * oiliness + 1.;\n    }\n    \n    normal = calcNormal(p);\n}\n\n// Raymarching functions\n// -----------------------------------------------------------------\nbool intersect( in vec3 ro, in vec3 rd, out float dist )\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t\tif( h < EPS * dist) return true;\n\t\th = map(ro + rd * dist);\n        dist += h * 1.;\n\t\tif( dist > MAX_DIST) return false;\n    }\n\treturn false;\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.005, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\n// From https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos)\n{\n    const float h = NORM_EPS;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h);\n    }\n    return normalize(n);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 1.0*occ, 0.0, 1.0 );\n}\n\n\n//Tonemapping\n// -----------------------------------------------------------------\n\n// linear to tonemapped\nvec3 ACES(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n}\n\n// tonemapped to linear\nvec3 ACES_Inv(vec3 x) {\n    return (sqrt(-10127.*x*x + 13702.*x + 9.) + 59.*x - 3.) / (502. - 486.*x); // thanks to https://www.wolframalpha.com/input?i=2.51y%5E2%2B.03y%3Dx%282.43y%5E2%2B.59y%2B.14%29+solve+for+y\n}\n\n\n\n// Rendering functions\n// -----------------------------------------------------------------\n// https://learnopengl.com/PBR/Theory\n\n// Irridescent thin film interference effect\nvec3 thinFilm(float ndotv, float thickness, float metallic) {\n    // Relative wavelengths of each component\n    const vec3 freqs = vec3(700./435., 565./435., 1.);\n    const float ior = 2.;\n    float n2 = sin(acos(ndotv)) / ior;\n    float cos2 = cos(asin(n2));\n    float dist = thickness / cos2;\n    \n    // Strength of thin film effect is controlled by reflection angle\n    // and mettalicity of material.\n    // Power to make irridescence stronger\n    float strength = pow(metallic * ndotv, 0.2);\n    \n    vec3 rgb = (cos(dist * freqs) *strength * 0.5) + vec3(0.5);\n    return rgb;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nvec3 light(\n    vec3 light_dir, vec3 light_col, vec3 normal, vec3 rd, float attenuation,\n    vec3 albedo, float roughness, float metallic, vec3 F0, float film_thickness\n) {\n        // Shading calculations\n        vec3 V = -rd; // Camera direction\n        vec3 H = normalize(light_dir - rd);\n        \n        float ndotl = max(dot(normal, light_dir), 0.);\n        float hdotv = max(dot(H, V), 0.);\n        float ndotv = max(dot(normal, V), 0.);\n        \n        vec3 radiance = light_col * attenuation;\n        \n        vec3 F = fresnelSchlickRoughness(hdotv, F0, roughness);\n        F *= thinFilm(ndotv, film_thickness, metallic);\n        \n        \n        float NDF = DistributionGGX(normal, H, roughness);\n        float G   = GeometrySmith(normal, V, light_dir, roughness);\n        \n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * ndotv * ndotl  + 0.0001;\n        vec3 specular     = numerator / denominator; \n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n\n        kD *= 1.0 - metallic;\n        \n        return (kD * albedo / PI + specular) * radiance * ndotl;\n}\n\nvec3 ambient(\n    vec3 normal, vec3 rd, float ao,\n    vec3 albedo, float roughness, float metallic, vec3 F0, float film_thickness\n) {\n    vec3 V = -rd;\n    vec3 F = fresnelSchlickRoughness(max(dot(normal, V), 0.0), F0, roughness);\n    \n    vec3 R = reflect(-V, normal);\n    \n    F *= thinFilm(dot(V, normal), film_thickness, metallic);\n    // Diffuse\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    vec3 irradiance = textureLod(iChannel1, normal.zyx, 4.8).rgb + ambient_boost;\n    vec3 diffuse    = irradiance * albedo;\n    \n    //Specular\n    const float MAX_REFLECTION_LOD = 16.0;\n    vec3 prefilteredColor = textureLod(iChannel0, R.zyx,  roughness * MAX_REFLECTION_LOD + 1.).rgb;  \n    \n    \n    vec2 envBRDF  = texelFetch(iChannel2, ivec2(vec2(max(dot(normal, V), 0.0), roughness) / vec2(255.)), 0).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y) * albedo;\n    \n    return (kD * diffuse + specular) * ao;\n}\n\n// -----------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 ro, rd;\n    \n    vec2 camRot = vec2(2.,3.5)+vec2(-4.,7.)*(iMouse.yx/iResolution.yx);\n    \n    CamPolar(ro, rd,\n             cam_origin, // Origin\n             camRot, // Rotation\n             3.5, // Distance\n             1.2, //Zoom\n             fragCoord);\n    \n    vec3 sun_dir = normalize(vec3(-0.25, 1., -1.));\n    vec3 sun_color = vec3(23.47, 21.31, 20.79);\n    \n    float dist;\n    \n    vec3 color;\n    if (intersect(ro, rd, dist)) {\n        //Foreground object\n        vec3 hit_pt = ro + rd * dist;\n        \n        // Get material\n        vec3  albedo; // Subsurface color\n        float roughness;\n        float ao;          // Microsurface AO\n        float metallic;\n        float film_thickness;\n        vec3 normal;\n        \n        material(hit_pt, albedo, roughness, ao, metallic, film_thickness, normal);\n        \n        // Square roughness\n        roughness = roughness * roughness;\n        \n        vec3 F0 = mix(vec3(0.04), albedo, metallic);\n        \n        // Calculate AO and shadows\n        \n        ao = ao * calcAO(hit_pt, normal);\n        float shadow = softShadow(hit_pt + normal * dist * SHADOW_BIAS, sun_dir, 0.01, 3.);\n        float attenuation = shadow * ao;\n        \n        \n        // Shading calculations\n        vec3 Lo = light(sun_dir, sun_color, normal, rd, attenuation, albedo, roughness, metallic, F0, film_thickness);\n        vec3 ambient = ambient(normal, rd, ao, albedo, roughness, metallic, F0, film_thickness);\n        \n        color = Lo + ambient * 2.;\n    } else {\n        //Background\n        color = ACES_Inv(textureLod(iChannel0, rd.zyx, 1.4).rgb) * 2.;\n    }\n    \n    \n    color = ACES(color);\n    \n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Pre-calculated BRDF LUT for reflections\n\n#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define INV_SQRT_PI 0.56418958354\n\nvec2 SampleEquirectangular(vec3 dir)\n{\n    vec2 uv = vec2(atan(dir.z, dir.x), asin(dir.y));\n    uv *= vec2(0.1591, 0.3183);\n    uv += 0.5;\n    return uv;\n}\n\nvec3 F_Schlick(float NoV, vec3 F0, float roughness)\n{\n\treturn F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - NoV, 5.0);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\nfloat G_SmithIBL(float roughness, float NoL, float NoV)\n{\n\tfloat k = roughness * roughness * 0.5;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nfloat G_SmithDirect(float roughness, float NoL, float NoV)\n{\n\tfloat k = (roughness + 1.0) * (roughness + 1.0) * 0.125;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness, vec3 n)\n{\n\tfloat a = roughness * roughness;\n    float phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    vec3 h;\n    h.x = sinTheta * cos(phi);\n    h.y = sinTheta * sin(phi);\n    h.z = cosTheta;\n    \n    vec3 up = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    vec3 tangentX = normalize(cross(up, n));\n    vec3 tangentY = cross(n, tangentX);\n    return tangentX * h.x + tangentY * h.y + n * h.z;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n    uint bits = i;\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    float inv = float(bits) * 2.3283064365386963e-10;\n\treturn vec2(float(i)/float(N), inv);\n}\n\n\nvec2 IntegrateBRDF(float roughness, float NoV)\n{\n\tvec3 v;\n    v.x = sqrt(1.0 - NoV * NoV);\n    v.y = 0.0;\n    v.z = NoV;\n    \n    float A = 0.0;\n    float B = 0.0;\n    \n    vec3 n = vec3(0.0, 0.0, 1.0);\n    \n    const uint numSamples = 1024u;\n    for (uint i = 0u; i < numSamples; i++)\n    {\n    \tvec2 Xi = Hammersley(i, numSamples);\n        vec3 h = ImportanceSampleGGX(Xi, roughness, n);\n        vec3 l = 2.0 * dot(v, h) * h - v;\n        \n        float NoL = clamp(l.z, 0.0, 1.0);\n        float NoH = clamp(h.z, 0.0, 1.0);\n        float VoH = clamp(dot(v, h), 0.0, 1.0);\n        \n        if (NoL > 0.0)\n        {\n            float G = G_SmithIBL(roughness, NoL, NoV);\n            float G_Vis = G * VoH / (NoH * NoV);\n            float Fc = pow(1.0 - VoH, 5.0);\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    \n    return vec2(A, B) / float(numSamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if (iFrame > 0) {\n        if(fragCoord.x > 256. || fragCoord.y > 256.){\n            fragColor = vec4(0.);\n        } else {\n    \n    \n            vec2 uv = fragCoord / vec2(256.);\n            float NoV = uv.x;\n            float roughness = uv.y;\n            fragColor = vec4(IntegrateBRDF(roughness, NoV).xy, 0.0, 1.0);\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}