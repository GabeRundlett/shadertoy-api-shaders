{
    "Shader": {
        "info": {
            "date": "1726785990",
            "description": "Tried to deal with precision. I found that 4 layer FBM looks good to me and then figured it could be vectorized to control performance more.  But then this opens it up to 8 layers easily etc. Made by Rik Riesmeijer, 2024 - CC0: Copyright free. Enjoy!",
            "flags": 0,
            "hasliked": 0,
            "id": "43scWX",
            "likes": 2,
            "name": "Lowp & Mediump Vector FBM (CC0)",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "fbm",
                "domain",
                "four",
                "cc0",
                "layer",
                "public",
                "free",
                "vectorization",
                "copyrightfree",
                "vectorized",
                "vfbm"
            ],
            "usePreview": 0,
            "username": "rikr",
            "viewed": 59
        },
        "renderpass": [
            {
                "code": "// Lower Precision Vector FBM By Rik Riesmeijer (CC0)\n// So far it seems to be slower because of the memory overhead and such to vectorize it..\nprecision mediump float;\n\n// Hand picked and scaled pythagorean sine and cosines to polar representation curve.\nconst mediump vec4 s = vec4(0.016, 0.018, -0.025, -0.1200), // pythagorean sines.\n                   t = vec4(0.012, 0.040,  0.060,  0.0700), // pythagorean cosines.\n                   u = vec4(0.5  , 0.25 ,  0.125,  0.0625); // Layer weights.\n\n// Lowp has the same expressive power as a signed byte in the worst case. Ints are highp version.\n// ivec4 j = ivec4(3,  7, -9, -25), // Signed Byte valued version based on above floats.\n//       i = ivec4(4, 12, 40,  60); // Signed Byte valued version based on above floats.\n\n// Now we put the integers divided by 32 for lowest precision mantissa.\nconst lowp vec4 w = vec4(0.09375, 0.21875, -0.28125, -0.78125), // Sines: ints/32 is optimal.\n                q = vec4(0.125  , 0.375  ,  1.25   ,  1.875  ), // Cosines: same here for correct scale.\n                b = vec4(0.5    , 0.25   ,  0.125  ,  0.0625 ); // Layer weights (already sbyte sized).\n\n//const ivec4 k = ivec4(-15, 8, 8, 15); // Integer version again. (highp)\nconst mediump mat2 r =  mat2(-0.15, 0.08, 0.08, 0.15);   // Rotation for second step in 8 layer fbm.\nconst lowp mat2 m = mat2(-0.46875, 0.25, 0.25, 0.46875); // Lowp version of r.\n\n// Hash for noise.\n//ivec4  ih(ivec4  x) { return (0x37354953 ^ x) * x * (x ^ 0x28433481); } // Highp hash.\n//vec4 h(vec4 x, vec4 y) { return vec4(ih(ivec4(x) * ih(ivec4(y)))) / 43e8 + 0.5; }\nmediump vec4 h(vec4 x, vec4 y) { return fract(sin(mod(x * 1e1 + y * 2e2, 9e3)) * 3e3); }\nlowp vec4 lh(vec4 x, vec4 y) { // lowp \"hash\".\n    return fract(x += x += x = tan(x * 1.875 + y * 0.09375) * 1.875); // No out of range numbers.\n}\n\n// Lowp FBM.\nlowp float lvfbm(vec2 v) {                                        // vectorized lowp 4 layers\n    lowp vec4 x = w * v.x - q * v.y,                              // X cached.\n              y = w * v.x + q * v.y,                              // Y cached.\n              a = smoothstep(0.0, 1.0, fract(x)),                 // X mix cached.\n              e = smoothstep(0.0, 1.0, fract(y));                 // Y mix cached\n    x = floor(x), y = floor(y);                                   // Floors in place.\n    return dot(b, mix(mix(h(x, y      ), h(x + 1.0, y      ), a), // Interpolate bottom.\n                      mix(h(x, y + 1.0), h(x + 1.0, y + 1.0), a), // Interpolate top.\n                      e));                                        // Interpolate left right.\n}\nlowp float lfbm(vec2 v) { return lvfbm(v) + 0.0625 * lvfbm(m * v.yx); } // 8 Layers. (Max for lowp)\n\n// Mediump FBM\nmediump float vfbm(vec2 v) {                                      // vectorized with 4 layers\n    vec4 x = s * v.x - t * v.y,                                   // X cached.\n         y = t * v.x + s * v.y,                                   // Y cached.\n         a = smoothstep(0.0, 1.0, fract(x)),                      // X mix cached.\n         e = smoothstep(0.0, 1.0, fract(y));                      // Y mix cached.\n    x = floor(x), y = floor(y);                                   // Floors in place.\n    return dot(u, mix(mix(h(x, y      ), h(x + 1.0, y      ), a), // Interpolate bottom.\n                      mix(h(x, y + 1.0), h(x + 1.0, y + 1.0), a), // Interpolate top.\n                      e));                                        // Interpolate left right.\n}                                                                 // Do this twice for good result.\nfloat fbm(vec2 v) { return vfbm(v) + 0.0625 * vfbm(r * v); }      // 8 Layers.\n\nvoid mainImage(out vec4 c, vec2 v) {\n    v = 100.0 * (v - 0.5 * iResolution.xy) / iResolution.y;\n    for(int i = 0; i < 1; i++)\n    c = vec4(v.x > 0.0? fbm(v * 10.0 + 20.0 * iTime) : lfbm(v));\n    \n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}