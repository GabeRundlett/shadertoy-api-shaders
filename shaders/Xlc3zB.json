{
    "Shader": {
        "info": {
            "date": "1618010560",
            "description": "second commit for https://www.pouet.net/prod.php?which=68093 :)\n2016(?)\n\nfollow up for https://www.shadertoy.com/view/ldVXDm",
            "flags": 0,
            "hasliked": 0,
            "id": "Xlc3zB",
            "likes": 12,
            "name": "Planet 7120 - second commit",
            "published": 3,
            "tags": [
                "demoscene"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 364
        },
        "renderpass": [
            {
                "code": "#define getNormal getNormalHex\n#define V vec3\n#define W vec2\n#define F float\n#define FAR 330.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n\n//#define FOG 1.\n\n#define PI 3.14159265\n//#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nF \n    Z = 0., \n    J = 1., \n\tvol = 0.,\n\tnoise = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),.0);\n}\n\n\nfloat B(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\n#define fromRGB(a, b, c) vec3(F(a), F(b), F(c)) / 255.;\n    \nvec3 \n    light = vec3(0. ,0., 1.),\n\tlightDir;\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3) ); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 Rep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 color;  \n    float mirror;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 ){\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n\ngeometry map(vec3 p) {\n    //p.y += sin(t * 1.+ p.z / 10.) * 3. + sin(p.x / 3.);\n    vec3 bp = p;\n    vec3 fp = p;\n    vec3 op = p;\n    float localNoise = B(p / 15.) * 5.;\n    \n    \n    p.y -= localNoise;\n    \n    // ----------\n    geometry box;\n    \n    \n    bp.y += -23.;\n    bp.z += -10. - t * 20.;\n    \n    pR(bp.xz, t);\n    pR(bp.yx, t * 4.6);\n    \n    pModPolar(bp.xy, 3.);\n    pMirrorOctant(bp.xz, vec2(.3) + sin(t / 4.) / 2.);\n    bp.x *= 1.4;\n    \n    box.dist = fBox(bp, vec3(4., 9., 1.) * .6 + vol);\n    box.dist = mix(box.dist, fSphere(bp, 2. + localNoise * .4), 1. - min(vol + t * 0.01, 1.));\n    box.materialIndex = 4.;\n   // box.space = bp;\n    box.color = vec3(1.7) + sin(t * 14.);\n    box.diffuse = 2.;\n    box.specular = 4.;\n    box.mirror = .6;\n    \n    \n\t// ------------\n    geometry floor;\n\n    vec3 floorP = p;\n    \n    floorP.y += -5. - min(floorP.z * 0.005 , 5.) - sin(p.z * 0.01) * 3.;\n    floor.dist = fBox2Cheap(floorP.xy, vec2(128., 2.5)),\n    floor.materialIndex = 0.;\n    //floor.space = p;\n    floor.color = vec3(1., .8, .6);//* localNoise;\n    floor.diffuse = 8.;\n    floor.specular = 4.0;\n    floor.mirror = 0.;\n    \n    // ------------\n    geometry water;\n    \n    fp = op;\n    fp.y -= 11. ;//+ sin(localNoise * 0.3) * 0.2 + 0.1 * (sin(fp.z + localNoise) + sin(fp.x));\n    water.dist = fBox2Cheap(fp.xy, vec2(128., 3.)),\n    water.materialIndex = 5.;\n    //water.space = fp;\n    water.color = fromRGB(126, 165, 179);\n    water.diffuse = 2.;\n    water.specular = 17.;\n    water.mirror = 0.3;\n    \n    // ----------\n    geometry obj;\n    \n    p.xz -= 25.;\n    p.y += 140. - min(p.z / 4., 140.);\n    \n    vec2 pM = pMod2(p.xz, vec2(50.));\n    \n    pMirrorOctant(p.zy, \n                  vec2(\n                      1. * mod(pM.x, 14.), \n                      5. + ceil(13. * (sin(pM.x) * 3.+ 1.)) \n                  )\n                 );\n    pMirrorOctant(p.xz, vec2(13., 18. + mod(pM.y * 5., 16.)));\n    \n    pR(p.zy, 1.17 + p.x / 10. );\n\n    p.x += 2.5 ;\n    \n    pModPolar(p.xz, 12.5 - (sin(pM.x) * 10.+ (sin(1. / 3.) * 10.)));\n\t\n    pMirrorOctant(p.zy, vec2(8.4, 6.));\n    pMirrorOctant(p.xy, vec2(3.5, 5.));\n    \n    p.yx += 2.;\n    // \n    // \n    p.x += sin(p.z / 100.) * 40.;\n    \n    obj.dist = fBox2Cheap(p.xy, vec2(4.4, 2.5));\n    obj.color = vec3(0., 1., 0.);\n    //obj.space = p;\n    obj.color = vec3(1.);\n    obj.diffuse = 5.;\n    obj.specular = 0.2;\n    obj.mirror = 0.;\n    //p.z -= 3.;\n    \n    geometry obj2;\n    obj2.dist = fBox(p, vec3(6., 7.4, 1.3));\n    obj2.color = vec3(1., 0., 1.);\n    //obj2.space = p;\n    obj2.color = vec3(1.);\n    obj2.diffuse = 8.;\n    obj2.specular = 1.;\n    obj2.mirror = 0.;\n    obj2.dist = smin(obj.dist, obj2.dist, sin(p.z / 10.) / 3. + .5);\n    \n    floor.dist = smin(obj.dist, floor.dist, .45);\n    \n    p = op;\n    p.x -= 2.;\n\n    p = mod(p, 5.);// p.z = mod(p.z, 12.) - .1;//sin(p.z);\n    p.y -= 25.;\n    //;;p.z -= 100.;\n    geometry obj3;\n    obj3.dist = fBox(p, vec3(3., 7.4,1.3));\n    obj3.color = vec3(1., 0., 1.);\n    //obj3.space = p;\n    obj3.color = vec3(1.);\n    obj3.diffuse = 8.;\n    obj3.specular = 1.;\n    obj3.mirror = 0.;\n    \n    obj = geoU(obj, obj2);\n    obj = geoU(obj, obj3);\n    obj = geoU(obj, floor);\n    obj = geoU(obj, water);\n    obj = geoU(obj, box);\n    \n    \n    //-----\n    p = op;\n    p.y -= 5.;\n    p.xz = mod(p.xz, 40.) - 20.;\n    if (op.z > 1030.) {\n        p.x += p.z * 0.1;\n    pMirrorOctant(p.yz, vec2(12.5, 20.));\n    pModPolar(p.zx, 5.);\n\n    obj2.dist = fBox(p, vec3(1., 15., 6.));\n    obj2.mirror = .2;\n    obj2.color = vec3(1., 0., 1.);\n    \n    obj2.color += ceil(sin(mod(op.x / 3. + op.z / 2.- t * 4., 5.))) * 4.;\n    obj2.specular = 3.;\n    \n    obj = geoU(obj, obj2);\n    }\n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 70;\n\ngeometry trace(vec3 o, vec3 d, int maxI) {\n\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1. / 250.;\n    float functionSign = map(o).dist < 0. ? -1. : +1.;\n    geometry mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 4.5;\n    float end = max(length(rd), .01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.6), 1.0);\n}\n\n\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist, e = .001;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(e,0,0)).dist-d,\n                map(pos+vec3(0,e,0)).dist-d,\n                map(pos+vec3(0,0,e)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    return clamp(map(hitp + normal * dist).dist / dist, .4, 1.);\n}\n\nvec3 clouds(vec3 rd, vec3 ro) {\n    vec2 uv = rd.xz / rd.y;\n   //ro.z /= 2.;\n    vec3 clouds = vec3(\n        B(\n            vec3(\n                uv + vec2(0., ro.z  * .01), 9.\n            )\n        ) * 1.6\n\n    );\n \tclouds = pow(clouds, vec3(2.)) + vec3(sin(uv.y) / 2. + .5, .5, 0.);\n    clouds.b += sin(ro.z * 0.01);\n    return clouds * max(0., rd.y);\n}\n\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir, vec3 ro)\n{\n   \n    float sunSize = 3.5;\n    float sunAmount = max(dot(rd, lightDir), 0.4);\n    float v = pow(1.2 - max(rd.y, 0.0), 1.1);\n    vec3 cl = vec3(0.);//fromRGB(0,136,254);\n    //cl.b *= sin(p.z * 0.3);\n    vec3 sky = mix(cl, vec3(.1, .2, .3) * 1., v);\n \n    sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 122.0)* sunSize, 0.2 * sunSize);\n    sky += vec3(3., 0., 0.) * rd.y;\n    return clamp(sky, 0.0, 1.0) + clouds(rd, ro);;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), obj.diffuse);\n    // Standard specualr term.\n    float spec = max(dot(reflect(-ld, sn), -rd), obj.specular / 2.);\n\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = obj.color;//getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    //sceneCol += ();// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return objCol * (diff + .15) * spec * .1;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n    F \tmat = 0.,\n        camShY = 0.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n   \n    if (abs(uv.y) > .35) {\n     \tfragColor *= 0.;\n        return;\n    }\n    \n    uv *= 4.;\n    \n    light = vec3(0., 77., 100.);        \n    \n    vec3 \n        vuv = vec3(cos(t) / 6., 1., sin(t) * .3 ), // up\n    \tro = vec3(-2. + sin(t),  22. + camShY, t * 20.);// + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 1.); // pos\n    \n    //ro.z += camShY;\n    vec3\n        vrp =  vec3(sin(t), + sin(t * 2.), +11.) + ro + \n        \tvec3(\n                -2., \n                -4. + sin(t) / 3., \n                0. + sin(t / 3.) / 4.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \trd = normalize(\n            vpn + uv.x * u * iResolution.x/iResolution.y + uv.y * cross(vpn, u)\n        ),\n        hit,\n        ord = rd;\n\t\n    vec3 sceneColor = vec3(0.);\n    \n    geometry tr = trace(ro, rd, 0);    \n    \n    //float fog = smoothstep(FAR * FOG, 0., tr.dist) * 1.;\n    hit = ro + rd * tr.dist;\n    \n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 3.);\n    \n    float \n        ao = getAO(hit, sn, .2);\n\t\n    ao *= saturate(getAO(hit + sn * .2, sn, .5));\n    ao *= saturate(getAO(hit + sn * 1., sn, 3.0));\n    \n\tvec3 sky = Sky(rd, true, normalize(light), ro) * 1.;\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n        sceneColor *= ao; \n        sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.dist * 4. / FAR));\n        sceneColor = mix(sceneColor, lightColour, 0.1);        \n\n        if (tr.mirror > 0.) {   \n            float mirror = tr.mirror;\n            vec3 refSceneColor = sceneColor;\n            rd = reflect(rd, sn);// + sin(t));\n\n            tr = trace(hit + rd * .02, rd, 99);\n            if (tr.dist < FAR) {\n                hit = hit + rd * tr.dist;\n                sn = getNormal(hit);\n                refSceneColor = mix(sceneColor, abs(doColor(hit, rd, sn, light, tr)), mirror);                \n            } else {\n             \tsky = Sky(rd, true, normalize(light), ro);\n                refSceneColor = mix(refSceneColor, sky, mirror * 2.);\n               \n            }\n            \n            sceneColor = mix(sceneColor, refSceneColor, mirror);\n            \n        } else {\n            sceneColor = mix(sceneColor, sky, .0);  \n        }\n\n    } else {\n        sceneColor = sky;\n    }\n\n    if (t < 20.) {\n        float ot = min(t, 20.),den1 = 0., f, distC = 1.0;\n            \n        vec3 steamColor1 = vec3(1.4);\n\n        vec3 rro;\n        \n        ro.z /= 8.;\n\n        for (float i = 0.; i <= 10.; i++) {\n\n            rro = ro + ord * distC;// + steamColor2;\n\n            f = B(rro);\n            f *= 1.8;\n            den1 += pow(f, 2.) * .004 * (20. - ot) / 3.;\n\n\n            distC += .01;\n            if (distC > tr.dist) break;// ro += rd * distC;\n        }\n\n        sceneColor = mix(sceneColor, steamColor1,  clamp(den1, 0., 1.) * 2.); \n    \n    }\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0), 1.0);\n    fragColor = pow(fragColor, vec4(1.2));    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}