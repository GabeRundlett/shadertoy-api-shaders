{
    "Shader": {
        "info": {
            "date": "1718698922",
            "description": "Inside Hyperspace Music Visualizer",
            "flags": 33,
            "hasliked": 0,
            "id": "M33XRN",
            "likes": 5,
            "name": "Ring of Fire Music Visualizer",
            "published": 3,
            "tags": [
                "tunnel",
                "sound",
                "fft",
                "hyperspace"
            ],
            "usePreview": 0,
            "username": "orblivius",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "// Fork of \"Hyperspace Visualizer\" by orblivius. https://shadertoy.com/view/l3V3D1\n// 2024-06-18 08:21:46\n\n// Hyperspace music visualizer\n// by Orblivius\n\n// Fork of \"The Hole adventure\" by vovach777. https://shadertoy.com/view/lXG3D1\n// 2024-06-05 17:43:33\n\n\nfloat map(float v, float v_min, float v_max, float out1, float out2)\n{\n    if ( v_max - v_min == 0. )\n        return out2;\n        \n     return (clamp(v,v_min,v_max) - v_min) / (v_max - v_min) * (out2-out1)+out1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  mouseCoord = iMouse.xy / iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n    vec2  rolling = vec2(sin(iTime), cos(iTime))*.5;\n  \n    vec2 uv = vec2( map(fragCoord.x,0., iResolution.x,-1.,1.),  map(fragCoord.y,0., iResolution.y,-ar,ar)    ) + rolling*0.25;\n     vec2 uv2 = rotateUV(uv, iTime*0.03);\n   float z = 2. / max(length(uv),0.1);\n    float angle = map( atan(uv.y,uv.x), -PI, PI, 0., 1. );\n      float angle2 = map( atan(uv2.y,uv2.x), -PI, PI, 0., 1. );\n    float zmax =  map(rolling.x,-1.,1.,0.075,0.15);\n    float fade = map(z,0.,  8.- .001*zmax , 1.0, 0.);\n    \n    vec3 color =  texture(iChannel0, vec2( angle2 +rolling.y*0.04, z * zmax)  ).rgb     * vec3(2.,.3,.7) ;\n     vec3 color2 =  vec3( pow( texture(iChannel2, vec2( angle+0.5+rolling.y*0.04,z *  (zmax)  + iTime*0.1)  ).r*1.2 ,2.1)) * vec3(.8,.1,1.5);\n   color2 =  hueShift(color2, .8); \n   color = hueShift(color, 5.5); color*= color; \n    \n     fragColor = vec4( (color +  color2) * fade , 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec3 rain(vec2 fragCoord)\n{\n\tfragCoord.x -= mod(fragCoord.x, 16.);\n    //fragCoord.y -= mod(fragCoord.y, 16.);\n    \n    float offset=sin(fragCoord.x*15.);\n    float speed=cos(fragCoord.x*3.)*.3+.12;\n   \n    float y = 5.*fract(fragCoord.y/iResolution.y + iTime*speed + offset);\n    return vec3(random(vec2(offset)),random(vec2(offset)*y),random(vec2(offset)*speed)) / (y*5.);\n}\n\n\n#define BARS_COUNT 120\n#define BAR_HEIGHT 0.7\n#define BAR_SPACING_PERCENTAGE .302 // Normalized (0.0 = no spacing, 1.0 = full bar width)\n#define BAR_COLOR vec3(1.0, 0.0, 1.0) // Color of the bars\n#define BACKGROUND_COLOR vec3(0.0, 0.0, 0.0) // Color of the background\n#define MIRROR_FLAG 1 // Set to 1 to mirror the waveform horizontally\n#define ORIENTATION_FLAG 0 // Set to 1 to put bass on the right\n#define CENTER_OVERLAP 0.008 // Control the overlap in the center\n#define COLOR_POLARITY_FLAG 0 // Set to 1 to switch foreground and background colors\n#define BASS_BALANCE 0.001 // Normalized (0.0 = favor highs, 1.0 = favor lows)\n#define GRADIENT_FLAG 1 // Set to 1 to enable gradient, 0 to disable\n#define GRADIENT_POLARITY_FLAG 0 // Set to 1 to invert gradient colors\n#define GRADIENT_OFFSET 0.1 // Normalized (0.0 = start from background, 1.0 = start from bar color)\n#define GRADIENT_MULTIPLIER 1. // Normalized (0.0 = low intensity, 1.0 = high intensity)\n#define GRADIENT_CONTRAST .2 // Normalized (0.0 = no contrast, 1.0 = high contrast)\n#define MIRROR_Y_BOTTOM_FLAG 1 // Set to 1 to mirror the bottom half to the top\n#define MIRROR_Y_TOP_FLAG 1 // Set to 1 to mirror the top half to the bottom\n#define LOUDNESS_EXPONENT 3.0 // Controls the exponential scaling of loudness\n\n// Get the band value from the texture\nfloat getBand(int index) {\n    // Equal-loudness contour approximation\n    float normIndex = float(index) / float(BARS_COUNT);\n    float freq = pow(normIndex, mix(1.5, 0.5, BASS_BALANCE)); // Exaggerate emphasis based on BASS_BALANCE\n\n    if (ORIENTATION_FLAG == 1) {\n        freq = 1.0 - freq; // Flip bass to the right\n    }\n\n    return texture(iChannel0, vec2(freq, 0.0)).r;\n}\n\n// Function to get gradient color based on height and gradient parameters\nvec3 getGradientColor(float t) {\n    if (GRADIENT_FLAG == 1) {\n        float dynamicOffset = GRADIENT_OFFSET;\n        t = dynamicOffset + t * GRADIENT_MULTIPLIER;\n        t = clamp(t, 0.0, 1.0);\n        \n        t = pow(t, mix(1.0, 3.0, GRADIENT_CONTRAST));\n        \n        vec3 color = mix(BACKGROUND_COLOR, BAR_COLOR, t);\n        \n        if (GRADIENT_POLARITY_FLAG == 1) {\n            color = vec3(1.0) - color;\n        }\n        \n        return color;\n    } else {\n        return BAR_COLOR;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 originalUv = uv;\n    \n    float totalBars = float(BARS_COUNT) * (MIRROR_FLAG == 1 ? 2.0 : 1.0);\n    float barWidth = 1.0 / (totalBars + (totalBars - 1.0) * BAR_SPACING_PERCENTAGE); // Ensure float arithmetic\n    float barSpacing = barWidth * BAR_SPACING_PERCENTAGE;\n    \n    vec3 color = BACKGROUND_COLOR;\n\n    // Draw bars\n    for (int i = 0; i < BARS_COUNT; i++) {\n        float bandValue = getBand(i) * BAR_HEIGHT;\n\n        // Apply exponential scaling to the band value\n        bandValue = pow(bandValue, LOUDNESS_EXPONENT);\n\n        float barX = (barWidth + barSpacing) * float(i);\n\n        // Draw left side\n        if (uv.x > barX && uv.x < barX + barWidth) {\n            float barTop = 0.5 + bandValue / 2.0;\n            float barBottom = 0.5 - bandValue / 2.0;\n\n            if (uv.y > barBottom && uv.y < barTop) {\n                float gradientFactor = (uv.y - barBottom) / (barTop - barBottom); // Calculate gradient factor based on height\n                color = getGradientColor(gradientFactor); // Apply gradient color\n            }\n        }\n\n        // Draw right side (mirror) with overlap\n        if (MIRROR_FLAG == 1) {\n            float overlap = CENTER_OVERLAP;\n            barX = 1.0 - (barWidth + barSpacing) * float(i + 1) + overlap;\n\n            if (uv.x > barX && uv.x < barX + barWidth) {\n                float barTop = 0.5 + bandValue / 2.0;\n                float barBottom = 0.5 - bandValue / 2.0;\n\n                if (uv.y > barBottom && uv.y < barTop) {\n                    float gradientFactor = (uv.y - barBottom) / (barTop - barBottom); // Calculate gradient factor based on height\n                    color = getGradientColor(gradientFactor); // Apply gradient color\n                }\n            }\n        }\n    }\n\n    // Apply post-process mirroring effects\n    if (MIRROR_Y_BOTTOM_FLAG == 1) {\n        uv.y = 1.0 - uv.y; // Mirror the bottom to the top\n        vec3 mirrorColor = BACKGROUND_COLOR;\n\n        // Draw bars again with mirrored coordinates\n        for (int i = 0; i < BARS_COUNT; i++) {\n            float bandValue = getBand(i) * BAR_HEIGHT;\n\n            // Apply exponential scaling to the band value\n            bandValue = pow(bandValue, LOUDNESS_EXPONENT);\n\n            float barX = (barWidth + barSpacing) * float(i);\n\n            // Draw left side\n            if (uv.x > barX && uv.x < barX + barWidth) {\n                float barTop = 0.5 + bandValue / 2.0;\n                float barBottom = 0.5 - bandValue / 2.0;\n\n                if (uv.y > barBottom && uv.y < barTop) {\n                    float gradientFactor = (uv.y - barBottom) / (barTop - barBottom); // Calculate gradient factor based on height\n                    mirrorColor = getGradientColor(gradientFactor); // Apply gradient color\n                }\n            }\n\n            // Draw right side (mirror) with overlap\n            if (MIRROR_FLAG == 1) {\n                float overlap = CENTER_OVERLAP;\n                barX = 1.0 - (barWidth + barSpacing) * float(i + 1) + overlap;\n\n                if (uv.x > barX && uv.x < barX + barWidth) {\n                    float barTop = 0.5 + bandValue / 2.0;\n                    float barBottom = 0.5 - bandValue / 2.0;\n\n                    if (uv.y > barBottom && uv.y < barTop) {\n                        float gradientFactor = (uv.y - barBottom) / (barTop - barBottom); // Calculate gradient factor based on height\n                        mirrorColor = getGradientColor(gradientFactor); // Apply gradient color\n                    }\n                }\n            }\n        }\n        color = mix(color, mirrorColor, step(0.5, originalUv.y)); // Combine original and mirrored colors based on position\n    }\n\n    if (MIRROR_Y_TOP_FLAG == 1) {\n        uv = originalUv;\n        uv.y = 1.0 - uv.y; // Mirror the top to the bottom\n        vec3 mirrorColor = BACKGROUND_COLOR;\n\n        // Draw bars again with mirrored coordinates\n        for (int i = 0; i < BARS_COUNT; i++) {\n            float bandValue = getBand(i) * BAR_HEIGHT;\n\n            // Apply exponential scaling to the band value\n            bandValue = pow(bandValue, LOUDNESS_EXPONENT);\n\n            float barX = (barWidth + barSpacing) * float(i);\n\n            // Draw left side\n            if (uv.x > barX && uv.x < barX + barWidth) {\n                float barTop = 0.5 + bandValue / 2.0;\n                float barBottom = 0.5 - bandValue / 2.0;\n\n                if (uv.y > barBottom && uv.y < barTop) {\n                    float gradientFactor = (uv.y - barBottom) / (barTop - barBottom); // Calculate gradient factor based on height\n                    mirrorColor = getGradientColor(gradientFactor); // Apply gradient color\n                }\n            }\n\n            // Draw right side (mirror) with overlap\n            if (MIRROR_FLAG == 1) {\n                float overlap = CENTER_OVERLAP;\n                barX = 1.0 - (barWidth + barSpacing) * float(i + 1) + overlap;\n\n                if (uv.x > barX && uv.x < barX + barWidth) {\n                    float barTop = 0.5 + bandValue / 2.0;\n                    float barBottom = 0.5 - bandValue / 2.0;\n\n                    if (uv.y > barBottom && uv.y < barTop) {\n                        float gradientFactor = (uv.y - barBottom) / (barTop - barBottom); // Calculate gradient factor based on height\n                        mirrorColor = getGradientColor(gradientFactor); // Apply gradient color\n                    }\n                }\n            }\n        }\n        color = mix(color, mirrorColor, step(originalUv.y, 0.5)); // Combine original and mirrored colors based on position\n    }\n\n    // Apply color polarity inversion\n    if (COLOR_POLARITY_FLAG == 1) {\n        color = vec3(1.0) - color;\n    }\n    vec3 vcol = rain(fragCoord);\n    fragColor = vec4(color+vec3(0.2,0.4,0.7)*vcol, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define BPM 120.0\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPS 0.0001\n#define _beat (iTime * BPM / 60.0)\n#define beat (mod(_beat, 32.0))\n#define TAU 6.283184\n\nbool between(float x, float from, float to) {\n    return from <= x && x < to;\n}\n\n// primitives\nfloat sdCircle(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdRect(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return max(d.x, d.y) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdTriangle(vec2 p, float size) {\n    vec2 s = size * vec2(0.25, 0.43301270189);\n    p.y -= size * 0.14433756729;// sqrt(3) / 12\n\treturn sdRect(p, vec2(s.x - p.y * s.x / s.y, s.y));\n}\n\n// operations\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1,d2);\n}\n\nvec2 opRep(vec2 p, vec2 c) {\n\treturn mod(p, c) - 0.5 * c;\n}\n\nfloat opRep(float p, float c) {\n\treturn mod(p, c) - 0.5 * c;\n}\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n// color\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, saturate(p - K.xxx), c.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// https://www.shadertoy.com/view/3tX3R4\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\n// https://gist.github.com/mattatz/d7b8decb481947d2e37eab98aff2d0ad\n// https://neort.io/art/bj2225k3p9f9psc9ovf0?index=0&origin=my_profile\nfloat ease_in_quad(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn c*(t/=d)*t + b;\n}\nvec3 aces(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n    \n    \n    \n    \nvec2 rotateUV(vec2 uv, float angle) \n{\n    angle = angle*TAU;\n    mat2 matrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    return matrix * uv;\n}\n\n\nvec3 hueShift(vec3 col, float shift){\nvec3 m = vec3(cos(shift), -sin(shift) * .57735, 0);\nm = vec3(m.xy, -m.y) + (1. - m.x) * .33333;\nreturn mat3(m, m.zxy, m.yzx) * col;\n}\n\nfloat ease_out_quad(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn -c *(t/=d)*(t-2.) + b;\n}\n\nfloat ease_in_out_quad(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\tif ((t/=d/2.)<1.) return c/2.*t*t + b;\n\treturn -c/2. * ((--t)*(t-2.) - 1.) + b;\n}\n\nfloat ease_in_cubic(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn c*(t/=d)*t*t + b;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Fork of \"star and universe\" by nayk. https://shadertoy.com/view/XffXDf\n// 2024-01-22 05:55:07\n\n/*https://www.shadertoy.com/view/4tyfWy  https://www.shadertoy.com/view/MfsSD2  https://www.shadertoy.com/view/lslyRn*/\n#define iterations 20\n#define formuparam 0.53\n\n#define volsteps 15\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n      p.xy*=mat2(cos(iTime*0.005),sin(iTime*0.005),-sin(iTime*0.005),cos(iTime*0.005));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\t\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.1; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*vec3(0.015,0.015,0.015); // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n#define TAU 6.283184\n\nconst vec4 lineColor = vec4(0.25, 0.5, 1.0, 1.0);\nconst vec4[] bgColors = vec4[]\n(\n    lineColor * 0.5,\n    lineColor - vec4(0.2, 0.2, 0.7, 1)\n);\n\n\n// probably can optimize w/ noise, but currently using fourier transform\nfloat random(float t)\n{\n    return (cos(t) + cos(t * 1.3 + 1.3) + cos(t * 1.4 + 1.4)) / 3.0;   \n}\n\n\n\nfloat arc(float r, vec2 uv, float orientation, float radius, float section)\n{\n    uv = rotateUV(uv, orientation);\n    float theta = atan(uv.x, uv.y)/TAU;\n\n    float t = 100. * section;\n    float value = \n        min(2.0, pow(0.001 / abs(r - radius),2.)) *\n        min(2.0, pow(0.005 / abs(theta / t),t / 1.));\n    \n    return value;\n}\nfloat radial(float r, vec2 uv, float orientation, float radius, float section)\n{\n    uv = rotateUV(uv, orientation);\n    float theta = atan(uv.x, uv.y)/TAU;\n\n    //float value = min(2.0, 0.002 / abs(theta)) *;\n\n    float t = 100. * section;\n    float value = \n        min(2.0, 0.00025 / abs(theta)) *\n        min(2.0, pow(0.005 / abs((r - radius) / t),t / 2.));\n\n    return value;\n}\n\nfloat rich_beautiful_healthy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nfloat hash11(float p) {\n    return float(pcg(uint(p)))/4294967296.;\n}\n\nvec2 hash21(float p) {\n    return vec2(pcg2d(uvec2(p, 0)))/4294967296.;\n}\n\nvec3 hash33(vec3 p3) {\n    return vec3(pcg3d(uvec3(p3)))/4294967296.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    vec2 uv2=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.002);\n\tfloat time=iTime*speed+.25;\n\n float aspect = iResolution.x / iResolution.y;\n    \n\n    float r = length(uv);\n    \n\n    const vec3 base_color = vec3(0.2, 0.3, 1.0);\n    \n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n    vec2 center = (iResolution.xy/2.);\n\t float c0 = 0., c1 = 0.;\n\n \n    // Some blueish tone\n    const vec3 blue_shift = vec3(1.0, 1.0, 1.0);\n    vec3 color = vec3(.3,0.3,1.1);\n\n    float verticalFade = cos(uv2.y * 13.28) * 0.05 + 0.5;\n    fragColor = mix(bgColors[1], bgColors[1], uv2.x/1.);\n    fragColor *= verticalFade/2.;\n\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n \n   // fragColor += vec4(c0*blue_shift,0.5);\n   //  fragColor += vec4(c1*base_color,1.0);\n     // uv *=  ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n   // float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n\n   // fragColor*= vec4( vec3(0.5,0.1,0.01), 1.0);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Crossing storms, by ukeshet\n// Based on https://twitter.com/zozuar/status/1441384708441456651, with added periodic darkening + lightening.\n// As mentioned in comments: the @zozuar tweet is apparently based on nimitz (twitter: @stormoid) https://www.shadertoy.com/view/3l23Rh\n\nfloat rs = 0.;\nfloat hash21(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\n\nfloat perlinNoise(vec2 uv)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    vec2 blur = smoothstep(.0, 1., fuv);\n    vec2 bl = vec2(.0, .0);\n    vec2 br = vec2(1., .0);\n    vec2 tl = vec2(.0, 1.);\n    vec2 tr = vec2(1., 1.);\n    vec2 bln = hash22(iuv + bl);\n    vec2 brn = hash22(iuv + br);\n    vec2 tln = hash22(iuv + tl);\n    vec2 trn = hash22(iuv + tr);\n    float b  = mix(dot(bln, fuv - bl), dot(brn, fuv - br), blur.x);\n    float t  = mix(dot(tln, fuv - tl), dot(trn, fuv - tr), blur.x);\n    float c = mix(b, t, blur.y);\n   \n       \n    return (c);\n}\n\nfloat fbm(vec2 uv, int octaves)\n{\n    float value = 0.;\n    float ampitude  = 2.;\n    float freq = 2. ;\n   \n\n    \n    for(int i = 0; i < octaves; i++)\n    {  \n      value += perlinNoise(uv) * ampitude;\n        uv *= freq;\n        ampitude *= .15+rs*.3;\n    }\n    return value;\n}\n\n\nmat2 R(float q){return mat2(cos(q),sin(q),-sin(q),cos(q));}\nvoid mainImage(out vec4 Col,in vec2 FC) \n{\n    vec2 uvv = (FC - 0.5 * iResolution.xy)/iResolution.y;\n      rs = 2.*texture(iChannel0, vec2(abs(FC.x/iResolution.x-0.5),0.15)).r;\n    vec3 col1, col2; \n    uvv.y = 0.2*uvv.y + fbm(uvv.yx + (.3*iTime) , 10);\n    float dist1 = abs(uvv.y);\n    \n    dist1 = hash21(vec2(sin(iTime))) / dist1;\n    col1 = mix(vec3(0.), vec3(.02), dist1);\n \n    \n    \n    Col = vec4(col1,dist1);\n   \n   \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define MOTION_BLUR 0.5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 s = texture(iChannel0, uv);\n    vec4 d = texture(iChannel1, uv);\n    fragColor = vec4(s.rgb*MOTION_BLUR,s.a) + vec4((d.rgb),d.a) * MOTION_BLUR;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}