{
    "Shader": {
        "info": {
            "date": "1575751072",
            "description": "Blodbylgje - Time to chill with Kati RÃ¡n!\nDepth of Field alters distance depending on camera tilt.\nInspiration: [url]https://youtu.be/fGyHeRWP94g[/url]\n",
            "flags": 96,
            "hasliked": 0,
            "id": "3ldGzH",
            "likes": 60,
            "name": "Blodbylgje",
            "published": 3,
            "tags": [
                "3d",
                "waves",
                "raymarch",
                "water",
                "blodbylgje",
                "bloodwave"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 1745
        },
        "renderpass": [
            {
                "code": "// Blodbylgje. Bokeh disc.\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define GOLDEN_ANGLE 2.39996\n\n#define ITERATIONS 150\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n//-------------------------------------------------------------------------------------------\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius, float a)\n{\n\tvec3 acc = vec3(0), div = acc;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    vec2 asp = vec2(1, a);\n    \n    \n\tfor (int j = 0; j < ITERATIONS; j++)\n    {  \n        // the approx increase in the scale of sqrt(0, 1, 2, 3...)\n        r += 1. / r;\n\t    vangle = rot * vangle;\n        vec3 col = texture(tex, uv + (r-1.) * asp * vangle ).xyz; /// ... Sample the image\n\t\tvec3 bokeh = pow(col, vec3(3));\n\t\tacc += col * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn acc / div;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy; //... Needs to be 0-1 in both axis\n\tfloat rad = texture(iChannel0, uv).w;\n     // Aspect needs to be included in the rotation add for the bokeh to look natural...\n    float asp = iResolution.x /iResolution.y;\n    rad  = min(rad, 8.0);\n\n    vec3 col = Bokeh(iChannel0, uv, rad, asp);\n    // Colour fixup...\n    col = min(col*vec3(1.2, 1.3,1.4), 1.0);\n   \n    col = sqrt(col*col*(3.0 - 2.0* col));   \n\tfragColor = vec4(col * smoothstep(0.0, 8.0, iTime), 1.0);\n   \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 31624,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/kati_ran/blodbylge-bloodwave?si=81566436743f4404a289fa91f2529259&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Blodbylgje - \n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 sun  = normalize(vec3(1.,.25,0.56));\nvec2 move;\nfloat pix;\n\n//--------------------------------------------------------------------------------\nmat3 getCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getSky(vec3 rd)\n{\n\tvec3 col = mix(vec3(.3,.4,.6), vec3(1., 1.,1.), abs(rd.y*rd.y*rd.y));\n\tcol += vec3(1.0,.7, .3) * pow(max(dot(rd, sun), 0.0), 70.0)*2.;\n    return col;\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 f ) {\n    vec2 i = floor(f);\n    f = fract(f);\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//--------------------------------------------------------------------------------\n#define ROT_ANGLE .43\nmat2 rotMat2 = mat2(cos(ROT_ANGLE), sin(ROT_ANGLE), -sin(ROT_ANGLE), cos(ROT_ANGLE)) * 2.211;\nfloat mapOcean(vec2 p, const int it)\n{\n\tp *= .048;\n\tfloat d = 0.0, a = 4.1;\n\tvec2 m = move;\n    \n\tp -= m*.7;\n    d  += sin(p.x*2.0)*.3+cos((p.x+p.y)*2.3)*.3;\n   \n    for (int i = 0; i < it; i++)\n    {\n        p-=m;\n        //float k = 5.0-(float(i)/ 5.0);\n\t\tfloat h = pow(abs(noise(p)), 1.2);\n\t\td += h * a;\n\t    p *= rotMat2;\n        a *= .35;\n        m*= 1.87;\n    }\n    \n    return d-29.5;\n}\n\n//--------------------------------------------------------------------------------\nfloat map(vec3 p)\n{\n    float d = 0.0;\n    d = mapOcean(p.xz, 4) + p.y;\n    return d;\n}\nfloat map(vec3 p, int  it)\n{\n    float d = 0.0;\n    d = mapOcean(p.xz, it) + p.y;\n    return d;\n}\n\n\n//--------------------------------------------------------------------------------\nfloat rayMarch(vec3 ro, vec3 rd, vec2 cor)\n{\n    float l = hash(cor);\n    int i;\n    for (i = 0; i < 150; i++)\n    {\n        vec3 p = ro + rd * l;\n        float d = map(p);\n        if (d < .04 || l > 800.0) break;\n        l += d*.75 + l * .004;\n\t}\n    //if (i >= 150) l = 800.0;\n    return l;\n}\n\n//--------------------------------------------------------------------------------\nvec3 normal(vec3 p, float ds)\n{\n    ds *= ds;\n\tfloat e = min(5., pix * ds);\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), 9) - map(p-vec3(e,0.0,0.0), 9),\n                            map(p+vec3(0.0,e,0.0), 9) - map(p-vec3(0.0,e,0.0), 9),\n                            map(p+vec3(0.0,0.0,e), 9) - map(p-vec3(0.0,0.0,e), 9)));\n}\n\n\n\n//--------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    pix = .05/iResolution.y;\n    float time = iTime+265.;\n#ifdef USE_MOUSE\n    time += iMouse.x * 450.0 / iResolution.x;\n#endif\n\n    // Normalise coordinates to whatever resolution / ratio we have...\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    \n    /// Init output...\n    vec3 col = vec3(0.);\n\n    // Setup camera...\n    vec3 camera = vec3(100,30,100);\n\tvec3 lookat = vec3(170.,30.-sin(time*.2)*5.-15.,140.);\n  \n    mat3 camMat = getCamMat(camera, lookat, 0.0);\n    vec3 rd \t= camMat * normalize( vec3(uv, 3.5));\n    \n    move = vec2(time * .01, time * .015);\n    \n    float dis = rayMarch(camera, rd, fragCoord.xy);\n    if (dis < 800.0)\n    {\n        vec3 p  = camera + rd * dis;\n        vec3 nor = normal(p, dis);\n\n        vec3 ref = reflect(rd, nor);\n        \n        // Normal light...\n        col =  vec3(.2,.35,.3) * max(dot(nor, sun), 0.0);\n\t\t\n        // Reflected light...\n        \n        col += getSky(ref) * pow(max(dot(ref, sun), 0.0), 40.0);\n      \n        // Peak lighting...\n        float d1 = map(p);\n        float d2 = map(p+rd*15.0);\n\t\tcol= mix(col, col+vec3(.05,.15,.18), smoothstep(-4., 3., d2-d1));\n        \n\t\t// Fog...\n        col += getSky(nor) * abs(nor.y)*vec3(0.02,0.04,.06);\n        col = mix(col, vec3(col.z, col.x*.1,0), .3+(cos(time*.03)*.3));\n        col = mix(getSky(rd), col, exp(-dis*.01));\n        \n    }else\n    {\n       col = getSky(rd);\n    } \n    col = clamp(col, 0.0, 1.0);\n\n    // blur with previous image, depending on frame rate...\n #ifdef OFF_LINE\n    float blur = .4;\n#else\n    float blur = (iTimeDelta/.08);\n#endif\n    blur = clamp(blur, 0.2, .9);\n\tvec3 back = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n    col = mix(back, col, blur);\n    \n    fragColour = vec4(col,abs(dis*.003-.3+sin(time*.2)*.3));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Blodbylgje - \n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// #define OFF_LINE\n// #define USE_MOUSE",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}