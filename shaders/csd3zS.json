{
    "Shader": {
        "info": {
            "date": "1677469677",
            "description": "A planet in the habitable zone of a binary star system.",
            "flags": 0,
            "hasliked": 0,
            "id": "csd3zS",
            "likes": 1,
            "name": "Fork Kepler 256 Luna5ama 672",
            "published": 3,
            "tags": [
                "earth",
                "alienplanet"
            ],
            "usePreview": 0,
            "username": "Luna5ama",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\nprecision lowp float;\n\nfloat PI=3.14159265;\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 15.0;\nvec3 environmentSphereColor = vec3(0.3001, 0.501, 0.901) * 0.0;\n\nfloat distFromSphere;\nvec3 normal;\nvec3 texBlurry;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dense = 16.0;\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = 0.2 / sunIntensity;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tsunIntensity = max(0.0, sunIntensity - 3.0);\n\n\tlocalRay.x = localRay.x + 1.0 - iTime * 0.1;\n\t//vec3 right = normalize(cross(sunDir, vec3(0.0,1.0,0.0)));\n\t//vec3 up = normalize(cross(sunDir, right));\n\tvec2 wrap = fract((localRay.xy)*dense);\n\tvec4 rand = texture(iChannel2, floor(localRay.xy*dense)/dense).xyzw;\n\tvec3 starColor = rand.xyz;\n\tstarColor = starColor * 0.75 + 0.25;\n\trand.xy = rand.xy * 2.0 - 1.0;\n\tvec2 center = vec2(0.5, 0.5) + rand.xy * 0.9;// floor(fract((localRay.xy)*8.0)) + 0.5;\n\tfloat star = length(wrap - center);\n\tfloat test = star;\n\tstar = saturate((1.0 - star));\n\tfloat blink = texture(iChannel2, localRay.xy + iTime * 0.03).x;\n\tfloat cluster = 0.3;// /*(localRay.x+0.5) */ (localRay.y+0.5) * 2.8 + 0.8;\n\tstar = pow(star, 60.0 + saturate(rand.z - 0.0) * 250.0 * cluster);\n\tstar *= blink;\n\t\n\tfloat milkyMask = saturate(0.25 - abs(localRay.x - 0.65));\n\tvec3 milkyway = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3)).yxz;\n\tvec3 milkyLOD = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3), 3.0).yxz;\n\tvec3 milkyDetail = texture(iChannel3, (-localRay.yx*8.0 )+vec2(0.65, 0.3)).yxz;\n\tmilkyway *= milkyDetail.xxx;\n\tmilkyway *= vec3(1.0, 0.8, 0.91)*1.5;\n\tmilkyway = pow(milkyway, vec3(2.0, 2.0, 2.0)*3.0);\n\tmilkyway += vec3(0.2, 0.0015, 1.001) * milkyLOD * 0.006;\n\t\n\tvec3 finalColor = milkyway /* milkyMask*/ * 10850.0;\n\tfinalColor += environmentSphereColor + sunCol * sunIntensity + starColor * star * 12000.0 * cluster;\n\treturn finalColor;\n\t//return environmentSphereColor + sunCol * sunIntensity + starColor * star * 12000.0 * cluster;\n\t//return vec3(1.0,1.0,1.0)*cluster*1000.0;\n}\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = 0.2 / sunIntensity;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn environmentSphereColor + sunCol * sunIntensity;\n}\n\nvec3 LensFlare(vec2 uv, vec2 lfPos)\n{\n\tvec2 delta = uv - lfPos;\n\tfloat dist = length(delta);\n\tfloat angle = atan(delta.x, delta.y);\n\tvec3 tex = texture(iChannel0, vec2(angle*5.0, dist*0.125) /*- iTime*0.1*/).xyz;\n\tfloat bump = sin(angle * 6.0) * 0.5 + 0.54;\n\tbump -= pow(dist, 0.0125);\n\tbump = saturate(bump);\n\n\treturn sunCol * tex.x * 0.1 * bump / (dist);\n}\n\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\nvec2 Spiral(vec2 uv)\n{\n\tfloat reps = 2.0;\n\tvec2 uv2 = fract(uv*reps);\n\tvec2 center = floor(fract(uv*reps)) + 0.5;\n\tvec2 delta = uv2 - center;\n\tfloat dist = length(delta);\n\tfloat angle = atan(delta.y, delta.x);\n\t//if (distance(center, uv2) < 0.02) return vec2(10,10);\n\tfloat nudge = dist * 4.0;\n\tvec2 offset = vec2(delta.y, -delta.x);// * 0.2 / dist ;// vec2(sin(angle+nudge), cos(angle+nudge));\n\tfloat blend = max(abs(delta.x), abs(delta.y))* 2.0;\n\tblend = clamp((0.5 - dist) * 2.0, 0.0, 1.0);\n\tblend = pow(blend, 1.5);\n\t//offset *= clamp(1.0 - blend, 0.0, 1.0);\n\toffset *= clamp(blend, 0.0, 1.0);\n\t//if (dist > 0.5) offset = vec2(0,0);\n\t//offset *= dist;\n\treturn uv + offset*vec2(1.0,1.0)*1.1*texBlurry.x ;//+ vec2(iTime*0.03, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.yy + vec2(-0.4,0.0);\n\t//vec3 worldPix = vec3(uv*2.0 - 1.0, 1.65);// + (iMouse.x - iResolution.x * 0.2)* 0.01);\n\t//vec3 camPos = vec3(0.0,0.1,0.0);\n\n    vec2 res = iResolution.xy;\n    float scaleFactor = min(iResolution.x / iResolution.y, 1.0);\n    res *= scaleFactor;\n\tvec2 uv = fragCoord.xy / res - (0.5 / scaleFactor);\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=-PI/2.0;//iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=0.0;//-iMouse.y/iResolution.y*10.0;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(2.5); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (res.x / res.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\n\tvec3 planetPos = vec3(0.0,0.0,0.0);\n\tvec3 iA, iB, iA2, iB2;\n\tfloat t = iTime * 0.1 + 0.7 - iMouse.x*0.01;\n\tfloat cloudT = iTime * 0.1;\n\tfloat distFromSphere2;\n\tvec3 normal2;\n\tfloat hit2 = IntersectSphereAndRay(planetPos, 1.05, camPos, worldPix, iA2, iB2);\n\tnormal2 = normal;\n\tdistFromSphere2 = distFromSphere;\n\tfloat hit = IntersectSphereAndRay(planetPos, 1.0, camPos, worldPix, iA, iB);\n\t//float hit = IntersectSphereAndRay(planetPos, 1.0, camPos, pixPos, iA, iB);\n\tnormal = normalize(iA - planetPos);\n\t//if (abs(normal.x) <= 0.001) normal.x += 0.001;\n\tvec2 polar = vec2(atan(normal.x, normal.z)/*0.955*/, acos(normal.y));\n\tpolar.x = (polar.x + PI) / (PI * 2.0);\n\tpolar.y = polar.y / PI;// + 0.5;\n\tif (abs(normal.x) <= 0.02)\n\t{\n\t\t//polar.x = 0.0;\n\t}\n\tpolar.x = (polar.x+2.03);\n\tpolar.xy = iA.xy;\n\t//polar.y = floor(polar.y * 32.0) / 32.0;\n/*\tif (abs(normal.x) < abs(normal.z))\n\t{\n\t\tpolar = vec2((atan(normal.z, normal.x))*0.955, acos(iA.y));\n\t\t//polar.x = 0.0;\n\t}*/\n\t//+ vec2(0.0,iTime * 0.01)\n\tvec4 texNoise = texture(iChannel2, (polar.xy+vec2(t,0)) * 2.0);\n\ttexNoise.y = texture(iChannel2, (polar.xy+vec2(t,0)) * 1.0).y;\n\ttexNoise.z = texture(iChannel2, (polar.xy+vec2(t,0)) * 4.0).z;\n\ttexBlurry = texture(iChannel0, (polar.xy+vec2(t,0))*0.03125*0.25 ).rgb;\n\n\tvec3 tex = texture(iChannel0, (polar.xy+vec2(t,0))*1.0).rgb;\n\t//vec3 tex = texture(iChannel0, polar.xy, 0.0).rgb;\n\ttex *= tex;\n\tvec3 texFlip = texture(iChannel0, (1.0 - (polar.xy+vec2(t,0))*0.5)).rgb;\n\ttexFlip *= texFlip;\n\n\tvec3 texS = texture(iChannel0, (Spiral(polar.xy+vec2(t,0))+vec2(cloudT*0.25,0))*1.0).rgb;\n\ttexS *= texS;\n\tvec3 texFlipS = texture(iChannel0, (1.0 - (Spiral(polar.xy+vec2(t,0))+vec2(cloudT*0.25,0))*0.5)).rgb;\n\ttexFlipS *= texFlipS;\n\n\tfloat atmosphereDensity = (1.45 + normal.z);\n\tvec3 atmosphereColor = vec3(0.075, 0.35, 0.99) * 0.45;\n\tfloat cloudDensity = max(0.0, (pow(texFlipS.x * texS.x, 0.7) * 3.0));\n\tvec3 finalAtmosphere = atmosphereColor * atmosphereDensity + cloudDensity;\n\tvec3 finalColor = finalAtmosphere;\n\n\tvec3 detailMap = min(texture(iChannel3, (polar.xy+vec2(t,0)) * 2.0).xyz, 0.25) * 4.0;\n\tfloat land = pow(max(0.0, texture(iChannel1, (polar.xy+vec2(t,0))* 0.25).z - 0.25), 0.4)*0.75;\n\tfloat land2 = land * texBlurry.x * 6.0;\n\tland *= detailMap.x;\n\t//land2 *= detailMap.x;\n\tland2 = max(0.0, land2);\n\tland -= tex.x*0.65;\n\tland = max(0.0, land);\n\tfloat iceFactor = abs(pow(normal.y,2.0));\n\tvec3 landColor = max(vec3(0.0,0.0,0.0), vec3(0.13,0.65,0.01) * land);// * (1.0 + iceFactor*2.0);\n\tvec3 landColor2 = max(vec3(0.0,0.0,0.0), vec3(0.8,0.4,0.01) * land2);\n\tvec3 mixedLand = (landColor + landColor2)* 0.5;\n\tmixedLand *= (detailMap.zyx + 2.0) * 0.333;\n\t//float hardBlur = saturate((texBlurry.x - 0.2)* 104.0 + 0.2)* 0.2 + 0.4;\n\t//vec3 finalLand = mix(landColor, landColor2, hardBlur);\n\tvec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land, iceFactor);\n\tfinalLand = mix(atmosphereColor * 0.05, finalLand, pow(min(1.0,max(0.0,-distFromSphere*1.0)), 0.2));\n\tfinalColor += finalLand;\n\tfinalColor *= hit;\n\n\tfloat refNoise = (texNoise.x + texNoise.y + texNoise.z)* 0.3333;\n\tvec3 noiseNormal = normal;\n\tnoiseNormal.x += refNoise*0.05*hit;\n\tnoiseNormal.y += tex.x*hit*0.1;\n\tnoiseNormal.z += texFlip.x*hit*0.1;\n\tnoiseNormal = normalize(noiseNormal);\n\tvec3 ref = reflect(normalize(worldPix - camPos), noiseNormal);\n\n\trefNoise = refNoise*0.25 + 0.75;\n\tfloat orbitSpeed = 0.125;\n\t//vec3 sunDir = normalize(vec3(-0.9 + sin(iTime*0.2)*0.5, -0.1, -0.9150));\n\tvec3 sunDir = normalize(vec3(-0.009 + sin(iTime*orbitSpeed), -0.13, -cos(iTime*orbitSpeed)));\n\tvec3 r = normalize(cross(sunDir, vec3(0.0,1.0,0.0)));\n\tvec3 up = normalize(cross(sunDir, r));\n\tfloat binarySpeed = 0.5;\n\tfloat binaryDist = 0.3;\n\tsunDir += r * sin(iTime*binarySpeed) * binaryDist + up * cos(iTime*binarySpeed) * binaryDist;\n\tsunDir = normalize(sunDir);\n\n\tvec3 sunDir2 = normalize(vec3(-0.009 + sin((iTime+0.2)*orbitSpeed), 0.13, -cos((iTime+0.2)*orbitSpeed)));\n\tr = normalize(cross(sunDir2, vec3(0.0,1.0,0.0)));\n\tup = normalize(cross(sunDir2, r));\n\tsunDir2 -= r * sin(iTime*binarySpeed) * binaryDist + up * cos(iTime*binarySpeed) * binaryDist;\n\tsunDir2 = normalize(sunDir2);\n\n\tvec3 refNorm = normalize(ref);\n\tfloat glance = saturate(dot(refNorm, sunDir) * saturate(sunDir.z - 0.65));\n\tfloat glance2 = saturate(dot(refNorm, sunDir2) * saturate(sunDir2.z - 0.65));\n\tfloat landMask = finalLand.x + finalLand.y * 1.5;\n\tvec3 sunRef = GetSunColorReflection(refNorm, sunDir)*0.005*hit * (1.0 - saturate(landMask*3.5)) * (1.0-texS.x) * refNoise;\n\tvec3 sunRef2 = GetSunColorReflection(refNorm, sunDir2)*0.005*hit * (1.0 - saturate(landMask*3.5)) * (1.0-texS.x) * refNoise;\n\t\n\t//sunRef = mix(sunRef, atmosphereColor * vec3(1.0, 0.2, 0.1)*3.0, saturate(atmosphereDensity - 0.35)) * hit;\n\t//sunRef *= atmosphereColor;\n\t// fade to sunset color at outer atmosphere\n\tsunRef = mix(sunRef, vec3(3.75, 0.8, 0.02)* hit, glance);\n\tsunRef2 = mix(sunRef2, vec3(3.75, 0.8, 0.02)* hit, glance2);\n\tfinalColor += sunRef;\n\tfinalColor += sunRef2;\n\n\tvec3 sunsColor = GetSunColor(normalize(ref), sunDir) *0.000096*(1.0-hit) +\n\t\t\t\t\t GetSunColor(normalize(ref), sunDir2)*0.000096*(1.0-hit);\n\n\tfloat outerGlow = 1.0 - clamp(distFromSphere * 20.0, 0.0, 1.0);\n\touterGlow = pow(outerGlow, 5.2);\n\tfinalColor += (atmosphereColor + vec3(0.2, 0.2, 0.2)) * outerGlow * (1.0 - hit);\n\t\n\tfloat light = saturate(dot(sunDir, noiseNormal));\n\tlight += saturate(dot(sunDir2, noiseNormal));\n\tfinalColor *= light * 0.75 + 0.001;\t// ambient light (from stars, of course)\n\tfinalColor += sunsColor;\n\n\tfloat scattering, scattering2;\n\tif (hit2 == 1.0) scattering = distance(iA2, iB2);\n\tscattering2 = scattering;\n\tscattering *= pow(saturate(dot(relVec, sunDir) - 0.96), 2.0);\n\tscattering2 *= pow(saturate(dot(relVec, sunDir2) - 0.96), 2.0);\n\tscattering *= hit2 * (1.0 - hit);\n\tscattering2 *= hit2 * (1.0 - hit);\n\tscattering *= outerGlow;\n\tscattering2 *= outerGlow;\n\tfinalColor += vec3(1.0, 0.25, 0.05) * scattering * 3060.0;\n\tfinalColor += vec3(1.0, 0.25, 0.05) * scattering2 * 3060.0;\n\n\t//vec3 sunUV = worldFacing + sunDir2.x * sideNorm * (iResolution.x/iResolution.y) + sunDir2.y * upNorm;\n\t//float lame = distance(sunUV, worldPix);\n\t//vec3 sunUV = sunDir2 / vec3(sideNorm  * (iResolution.x/iResolution.y) * 0.4 + upNorm * 0.999);\n\t//finalColor += LensFlare(uv * vec2((iResolution.x/iResolution.y), 1.0), vec2(sunUV.x, sunUV.y));\n\n\t//finalColor = vec3(1.0,1.0,1.0) * (finalLand.x + finalLand.y)*hit;\n\t//finalColor += vec3(1.0,1.0,1.0) * glance;\n\t//finalColor = vec3(0, polar.x, 0.0);\n\t//finalColor = GetSunColorReflection(normalize(ref), sunDir)*0.005*hit * (1.0 - clamp(finalLand.x*12.0, 0.0, 1.0)) * (1.0-texS.x) * refNoise;\n\t//if (abs(normal.x) <= 0.001) finalColor = vec3(1.0,0.0,0.0);\n\n\tfragColor = vec4(clamp(sqrt(finalColor), 0.0, 1.0), 1.0);\n    fragColor = mix(fragColor, vec4(0.1, 0.1, 0.1, 1.0), 0.7);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}