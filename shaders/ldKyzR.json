{
    "Shader": {
        "info": {
            "date": "1521590593",
            "description": "1-bounce Monte Carlo rendering in realtime, with depth of field, blurred reflections, radiosity, etc.\nOffline rendered video here: [url]https://www.youtube.com/watch?v=NT_27NTwpWU[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "ldKyzR",
            "likes": 37,
            "name": "Chairs",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "specular",
                "depthoffield",
                "radiosity",
                "stilllife"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1921
        },
        "renderpass": [
            {
                "code": "// Chairs\n// by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n/*\nCAMERA CONTROLS:\n\nSpace: switch between scripted cam and user cam\n\nRotate: Mouse Drag\nMove: WASDRF or cursors\nAdjust Focus: Page Up, Page Down\nAuto Focus: Home (toggle)\nAperture: []\nZoom: -+\nExposure: <>\n\nC: show/hide camera debug info\n*/\n\n/*\nABOUT:\n\nA continuation of my cylinder ray tracer project. The core ray tracer is fast enough\nto intersect the scene dozens of times per pixel, so I can run a simple implementation of\nMonte Carlo.\n\nEach ray runs through the list of cylinders that make up the scene to find the first\nobject the ray hits.\n\nFor each sample we:\n* Fire a ray from a random point on the camera aperture (for depth of field blur),\n\ttargetted toward a point on the focal plane (randomised to give anti-aliasing).\n* If we hit an object:\n\t* Fire a ray toward the light source, with a random offset to create soft shadows.\n\t* Compute diffuse & specular direct lighting, if the light source is visible.\n\t* Fire either a diffuse or reflection bounce, with a probability controlled by the\n\t\treflectivity. The reflection bounces are distributed on a Blinn-Phong curve, to\n\t\tmatch the specular highlight.\n\t* Compute a cheaper lighting model for object hit by the bounced ray, sampling the\n\t\tsky dome for diffuse and specular.\n\t* Sample the material to colour and combine the light samples.\n\nThe system also supports motion blur, but I'm not using that in this scene because my\ncamera movement is hidden from the renderer.\n*/\n\n\n// remove this if recording a gif\n// actually, I sort of feel like it looks better withs static noise, it's easier to ignore somehow\n// like watching it through distorted glass\n#define ANIMATE_NOISE 1\n\n// 0 = patterned, 1 = patterned + small rand, 2 = totally random\n// HQ - this doesn't make much visible difference any more, because I made the pixel seed more random - damn!\n#define PATTERN_RAND 1\n\n// comment this out to remove some lens curving effects\n#define LENSFX 1\n\n// high values can prevent aliasing even on bright colours, at the cost of detail. Feels quite photographic though\n#define AA_SOFTNESS 1.5\n\n// .1 = subtle\n#define CAMERA_SHAKE 0.0\n\nint camWraps;\n\n// return a colour for a given direction\nvec3 Sky( vec3 ray )\n{\n//    return 5.*abs(sin(ray*50.))*step(2.5,abs(dot(sin(ray*80.+ray.yzx*80.),vec3(1))));//vec3(.01);\n\n/*    ray.y += .1;\n//    ray.y = max(0.,ray.y);\n    float d = .1;\n    ray.y = sqrt(ray.y*ray.y + d*d)-d;\n//    return exp2(-ray.y/vec3(.1,.3,.6)); // blue\n    return exp2(-ray.y/vec3(.18,.2,.28))*vec3(1,.95,.8); // overcast\n//    return exp2(-ray.y/vec3(.1,.2,.8))*vec3(1,.75,.5); // dusk\n//    return exp2(-ray.y/vec3(.03,.2,.9)); // tropical blue\n//    return exp2(-ray.y/vec3(.4,.06,.01)); // orange-red\n//    return exp2(-ray.y/vec3(.1,.2,.01)); // green*/\n    \n    vec3 c = pow(textureLod(iChannel2,ray,0.).rgb,vec3(2.2));\n    c *= 3. + 3.*pow(Grey(c),2.);\n    return c;\n}\n\n\nvec4 Triplanar( sampler2D s, vec3 uvw, vec3 n )\n{\n    vec3 weights = smoothstep(.3,1.,abs(n));\n    weights /= dot(vec3(1),weights);\n    \n    return weights.x*textureLod(s,uvw.yz,-16.)\n        +  weights.y*textureLod(s,uvw.zx,-16.)\n        +  weights.z*textureLod(s,uvw.xy,-16.);\n}\n\n\nMaterial GetMaterial( in vec3 pos, in vec3 normal, in int index )\n{\n    // swap materials on successive play-throughs\n    // but keep 0 as 0, for the floor\n    int swizzle = camWraps;\n    if ( index > 0 )\n    {\n        index--; // easier to do maths on [0,3]\n\t\t//index = (index*((1<<(swizzle+1))-1)-swizzle)&3; // this is a nice sequence, but it repeats too soon\n        index = ((1-2*(swizzle&1))*index + (swizzle*5)/2)&3; // more variants\n        index++;\n\t}\n    \n    Material material = base[index];\n\n\tif ( index == 0 )\n    {\n        material.albedo *= pow(textureLod(iChannel1,pos.xz/2.,0.).rgb,vec3(2.2));\n        float noise = smoothstep( .05, .3, material.albedo.g );//smoothstep(-10.,10.,SinNoise(pos*30.-70.).x);\n        material.roughness = mix( .1, .5, noise );\n    }\n    if ( index != 0 )\n    {\n        // add imperfections, like it's been handled/wiped or something\n        float smudge = .04; // may want to tweak this based on roughness, but this seems to work well\n        vec4 t = Triplanar(iChannel1,pos.xyz/1.,normal);\n        //float a = smoothstep(.17,.78,t.r);//fract((t.r-.17)/(.78-.17));//pow(1.-t.r,5.);\n        //float a = pow(1.-smoothstep(.17,.78,t.r),5.);\n        float a = pow(1.-(t.r-.17)/(.78-.17),5.);\n        material.roughness = mix( material.roughness, smudge, a );\n        //material.albedo = vec3(a,0,1.-a);\n    }\n    \n    material.roughness = max(material.roughness,.0000001);\n    return material;\n}\n\nvec3 SphereRand( vec2 rand )\n{\n    rand += .5;\n    // use interference of 2 very large numbers, calibrated (by hand) to cover\n    // lots of different directions very early on, and to fill in the gaps eventually\n    float sina = rand.x*2. - 1.;\n    float b = 6.283*rand.y;\n    float cosa = sqrt(1.-sina*sina);\n    return vec3(cosa*cos(b),sina,cosa*sin(b));\n}\n\nvec3 PowRand( vec2 rand, vec3 axis, float fpow )\n{\n    vec3 r = SphereRand(rand);\n    \n    // redistribute samples\n\n    float d = dot(r,axis);\n\n    // map sphere to cylinder\n    r -= d*axis;\n    r = normalize(r); // hahaha! I'd forgotten this, very clever\n\n    // project onto a spike\n    // h = pow(1.-radius,m)*2-1\n    // radius = 1.-pow(h*.5+.5,1/m)\n    // ^ WRONG! That's radius squared, otherwise POW=1 gives a spike\n    float h = d*.5+.5;\n    //        r *= sqrt(1.-pow(h,1./POW));\n    // ^ wrong again! Need to solve the integral with that sqrt in,\n    // and needed a factor of /radius for sample density\n    r *= sqrt( 1. - pow( h, 2./(fpow+1.) ) ); // YES!!!!\n\n    // and down onto the hemisphere\n    r += axis*sqrt(1.-dot(r,r));\n\n    return r;\n}\n\n\nvec3 ShadeRay( vec3 pos, vec3 ray, float time, vec4 rand )\n{\n/*  we have to do animation here to get motion blur - which is a bit shit\n\twould be better if we stored cylinder list in a buffer, with previous frame's list on the next row\n\tbut that would limit us to linear interpolations (of end points - so rotation would shorten cylinders! eek)*/\n/*\t// animate moving objects\n    float r = -(time+sin(time))*10.;\n    float a = time/3.;\n    vec3 d = vec3(cos(r),0,sin(r))*cos(a)+vec3(0,sin(a),0);\n    vec3 cp = vec3(.8,.5,3);\n    Scene[0] = vec4(cp+d*.03,.5);\n    Scene[1] = vec4(cp-d*.03,5);\n    cp = vec3(-1.3,.5,0);\n    d.x = -d.x;\n    Scene[2] = vec4(cp+d*.3,.3);\n    Scene[3] = vec4(cp-d*.3,5);*/\n    \n    vec3 normal = vec3(0);\n    int material = 0;\n    float t = Trace(normal,material,pos,ray);\n    \n    vec3 col = Sky(ray);\n    if ( length(normal) > 0. )\n    {\n        pos += ray*t;\n\n        Material mat = GetMaterial(pos,normal,material);\n        \n        vec3 fresnel = mix( mat.specularColour, vec3(1), pow(1.-dot(-ray,normal),5.) );\n        if ( length(mat.specularColour) == 0. ) fresnel = vec3(0); // override fresnel if spec colour is 0 - e.g. for emissive shapes\n\n        float specPower = 1./(mat.roughness*mat.roughness);\n        float specStrength = (specPower+8.)/(4.*tau);\n\n        \n        // sample specular or diffuse bounced light\n        float proportionSpecular = Grey(fresnel)/(Grey(mat.albedo) + Grey(fresnel));\n        bool tapIsSpecular = ( rand.w+.5 < proportionSpecular );\n        \n        \n        // randomize reflection direction with Blinn-Phong probability distribution\n        vec3 microfacet = PowRand( rand.yz, normal, tapIsSpecular ? specPower : 1. );\n        \n        // sample reflection\n        vec3 diffuse = vec3(0);\n        vec3 reflection = vec3(0);\n        vec3 tapalb = vec3(0);\n        vec3 tapn = vec3(0);\n        vec3 tappos = pos;\n        float tapemi = 0.;\n        if ( dot(microfacet,ray) < 0. ) // cull microfacets pointing away from camera\n        {\n            vec3 tapray = tapIsSpecular ? reflect(ray,microfacet) : microfacet;\n            int tapmati = 0;\n            float tapt = Trace(tapn,tapmati,pos,tapray);\n\n            if ( length(tapn) > 0. )\n            {\n                tappos = pos+tapray*tapt;\n                Material tapmat = GetMaterial(tappos,tapn,tapmati);\n\n                // turn metallic surfaces into a sky-tinted diffuse surface, because we're doing no more bounces\n                vec3 bounce2 = Sky(reflect(tapray,tapn)); // would be good if I could blur this\n                tapalb = mix(tapmat.albedo,bounce2,tapmat.specularColour);\n                tapemi = tapmat.emissive;\n\n                vec3 ambient = Sky(tapn);\n                //vec3 ambient = mix(vec3(.1),vec3(.5),tapn.y*.5+.5);\n                vec3 bounceLight = mix( ambient, vec3(1), tapemi );\n                bounceLight = mix(tapmat.albedo*bounceLight,bounce2,tapmat.specularColour);\n                if ( tapIsSpecular )\n                    reflection += bounceLight / proportionSpecular;\n                else\n                    diffuse += bounceLight / (1.-proportionSpecular);\n            }\n            else\n            {\n                // reflected ray didn't hit an object\n                vec3 bounceLight = Sky(tapray);\n                if ( tapIsSpecular )\n                    reflection += bounceLight / proportionSpecular;\n                else\n                    diffuse += bounceLight / (1.-proportionSpecular);\n            }\n        }\n\n/* actually doing bounces now\n\t\t// ambient light\n        vec3 ambientColour = vec3(0);//.05,.065,.09);\n        vec3 diffuse = ambientColour*(normal.y*.3+1.);\n        if ( length(tapn) > 0. ) reflection += tapalb * ambientColour*(tapn.y*.3+1.);\n*/\n        for ( int i=0; i < lights.length(); i++ )\n        {\n/*\n\t>vec3 position;\n    >vec3 target; distance falloff\n    >vec3 colour;\n    float innerRadius; // at target\n    float outerRadius;\n    >float sourceRadius; // area lighting\n\nlights*/\n        \n\n            // sample light\n            vec3 sun = normalize(lights[i].position-pos);//normalize(lights[i].position-lights[i].target);\n\n            // soften shadow by sampling radius around sun\n            vec3 suntap = sun;\n            if ( lights[i].sourceRadius > 0. )\n            {\n                vec3 areaLight = PowRand( rand.zx, -sun, 1. );\n                suntap = normalize( lights[i].position + areaLight*lights[i].sourceRadius - pos );\n            }\n\n            float ndotl = max(0.,dot(normal,sun));\n            float ndoth = max(0.,dot(normal,normalize(-ray+sun)));\n\n            vec3 lightCol = lights[i].colour;\n            float lightStrength = 1./dot(pos-lights[i].position,pos-lights[i].position);\n            float cosa = dot(sun,normalize(lights[i].position-lights[i].target));\n            float angleFade = smoothstep( lights[i].outerRadius, lights[i].innerRadius, sqrt(1.-cosa*cosa) );\n            angleFade = angleFade*angleFade;\n            lightStrength *= angleFade;\n\n            if ( cosa > 0. && angleFade > .001 )//&& lightStrength > 0.001 ) this light strength test is ignoring base brightness, which is wrong\n            {\n                vec3 testn = vec3(0);\n                int ignore;\n                float st = Trace(testn,ignore,pos,suntap);\n                if ( length(testn) == 0. || st > length(lights[i].position-pos) ) // we didn't hit anything before the light\n                {\n                    vec3 lightC = lightCol*lightStrength;\n\n                    // diffuse\n                    diffuse += ndotl * lightC;\n\n                    // specular\n                    reflection += lightC * ndotl*pow(ndoth,specPower)*specStrength;\n                }\n\t\t\t}\n\t\t\telse\n            {\n                //if ( cosa > 0. && lightStrength > .0005 ) diffuse += lights[i].colour*.1; // show bounding volumes\n        \t}\n\n            if ( length(tapn) > 0. )\n            {\n                //lightCol = lights[i].colour / dot(refpos-lights[i].position,refpos-lights[i].position);\n                // just reuse the light on the reflector\n\n                sun = normalize(lights[i].position-tappos);\n\n// disabled this if it doesn't make a difference (e.g. sun-lit scenes)\n#if 0 \n\t\t\t\t// recompute light strength for the reflected position\n\t\t\t\t// not sure if this looks right\n                lightStrength = 1./dot(tappos-lights[i].position,tappos-lights[i].position);\n                cosa = dot(sun,normalize(lights[i].position-lights[i].target));\n                angleFade = 0.;\n                if ( cosa > 0. ) angleFade = smoothstep( lights[i].outerRadius, lights[i].innerRadius, sqrt(1.-cosa*cosa) );\n                lightStrength *= angleFade*angleFade;\n#endif\n                vec3 lightC = lightCol*lightStrength;\n\n                \n                // apply light to reflected object!\n                vec3 bounceLight = tapalb * mix( max(0.,dot(tapn,sun)) * lightC, vec3(0), tapemi );\n                if ( tapIsSpecular )\n\t                reflection += bounceLight / proportionSpecular;\n                else\n\t                diffuse += bounceLight / (1.-proportionSpecular);\n            }\n        }\n\n        col = mat.albedo * diffuse;\n\n        col = mix( col, reflection, fresnel );\n        \n        col = mix( col, mat.albedo, mat.emissive );\n    }\n    \n    return col;\n}\n\n\nvec4 PatternRand( uint seed )\n{\n    return vec4(\n        float((seed*0x73494U)&0xfffffU)/float(0x100000),\n    \tfloat((seed*0xAF71FU)&0xfffffU)/float(0x100000),\n        float((seed*0x67a42U)&0xfffffU)/float(0x100000), // a bit stripey against x and z, but evens out over time\n        float((seed*0x95a8cU)&0xfffffU)/float(0x100000) // good vs x or y, not good against z\n        );\n}\n\n\nuvec4 Hash( uint seed ) \n{\n    // integer hash from Hugo Elias\n\tseed = (seed << 13U) ^ seed;\n    seed = seed * (seed * seed * 15731U + 789221U) + 1376312589U;\n    return seed * uvec4(seed,seed*16807U,seed*48271U,seed*31713U);\n}\n\n\nvec4 Rand( uint seed )\n{\n    vec4 pattern = PatternRand(seed);\n    vec4 random = vec4(Hash(seed)&0x7fffffffU)/float(0x7fffffffU);\n#if ( PATTERN_RAND == 0 )\n    return pattern;\n#elif ( PATTERN_RAND == 1 )\n    // break up patterns in the bokeh by distorting the regular sample positions\n\treturn fract( pattern + random*sqrt(1./float(MAX_SAMPLES/2)) );\n    // OMG this fixes some really big artefacts that can occur when moire patterns phase!\n#elif ( PATTERN_RAND == 2 )\n    return random;\n#endif\n}\n\n// remap a value in [-.5,.5) to evenly distributed points in a circle of radius 1\nvec2 CircleRand( vec2 rand )\n{\n    return vec2(cos(rand.x*tau),sin(rand.x*tau)) * sqrt(rand.y+.5);\n}\n\n\nvoid DebugPrint( inout vec4 fragColour, in vec2 fragCoord )\n{\n    // print text showing current camera data\n    // actually, do this printing in BufA, to save a texture in the renderer!\n    \n    ivec2 uv = ivec2(fragCoord);\n    if ( uv.y < 2 ) return; // ignore the data stored in the first row\n    \n    vec4 t = texelFetch( iChannel0, uv, 0 );\n    \n//    fragColour.rgb = pow(fragColour.rgb,vec3(2.2));\n//    t.rgb = pow(t.rgb,vec3(2.2));\n    fragColour.rgb = fragColour.rgb*t.a + t.rgb; // premultiplied alpha, so I can do additive effects or whatever\n//    fragColour.rgb = pow(fragColour.rgb, vec3(1./2.2));\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // todo - put this in a get function!\n    vec4 camAnimState = texelFetch(iChannel0,ivec2(4,0),0);\n    camWraps = int(camAnimState.z);\n\n    float smoothTimeDelta = texelFetch(iChannel0,ivec2(5,0),0).z;\n    \n    Params parameters = GetParameters();\n    \n    //uint n = uint(NUM_SAMPLES); // it actually runs fine with higher numbers, but I want to see the noise!\n    uint n = uint(texelFetch(iChannel0,ivec2(5,0),0).x);\n    \n//    uint pseed = (uint(fragCoord.y)<<6U) + uint(fragCoord.x);\n    uint pseed = uint(fragCoord.y)*113U ^ uint(fragCoord.x)*23U;\n    \n#if defined(ANIMATE_NOISE) && ANIMATE_NOISE > 0\n    pseed ^= uint(iFrame)*17U;\n//    pseed = (pseed<<16U)|(pseed>>16U);\n#endif\n        \n        \n//    vec4 prand = Rand( pseed );\n//    float motionJitter = prand.y;\n\n    // pixel noise, but per-pixel samples and motion blur are still coherent\n//    pseed = uint(Rand(pseed).y*float(0x100000));\n    pseed = ((pseed*0xAF71FDU) + ((Hash(pseed).x&0x7ffU)/*/n*/))&0xffffffU;//((1U<<uint(exp2(ceil(log2(sqrt(float(n)))))))-1U));\n\n//    if ( n < 20U ) pseed *= n; // gives a more stable result for high n, but ugly for low n\n    \n    for ( uint i=0U; i < uint(MAX_SAMPLES); i++ )\n    {\n        if ( i >= n ) break;\n        \n        uint seed = pseed + i;\n\t    vec4 rand = Rand( seed );\n        \n        float f = rand.z;//(float(i)+motionJitter)/float(n);\n//rand.z is still interfering with the aperture => my non-phasing things are phasing!\n        \n        // with high time values and high number of samples precision can cause samples to coincide\n        // could improve this by frac'ing to period of any looped animations\n    \tfloat time = iTime+smoothTimeDelta*f;\n//time *= 20.; // lol!\n        \n\t\tCamera cam = GetCamera();\n        \n        // some camera shake\n        cam.pos += sin(vec3(1,1.618,.618).zxy*iTime)*.05*CAMERA_SHAKE;\n        cam.k += sin(vec3(1,1.618,.618).yzx*1.618*iTime)*.02*CAMERA_SHAKE;\n        cam.k = normalize(cam.k);\n        cam.i = normalize(cross(cam.j,cam.k));\n\t\tcam.j = cross(cam.k,cam.i);\n\n        rand -= .5;\n\n        vec3 ray = vec3( (fragCoord + .707*AA_SOFTNESS*CircleRand(rand.zw) - iResolution.xy*.5)/iResolution.y, parameters.zoom );\n        \n        // offset source for focal blur\n        vec3 pos = vec3( rand.xy, 0 ); // rand is in the range -.5 to .5\n\n\t\t// hexagonal bokeh: chop corners off the square and move them to make hexagon\n        /* ____         ____         ____\n         |/\\  /\\|      |\\  /\\ |     /\\  /\\a \n         |__\\/__|      |_\\/__\\|    /b_\\/__\\  \n         |  /\\  |      | /\\  /|    \\a /\\  /  \n         |\\/__\\/|      |/__\\/ |     \\/__\\/b\n            (1)           (2)         (3)      */\n        pos.x += .25/1.5; // (1) -> (2)\n        if ( pos.x > .5-abs(pos.y)*2./3. )\n        {\n\t        // (3)\n            pos.x -= 1.;\n            pos.y = fract(pos.y)-.5;\n        }\n\n        // scale vertically to make a regular hexagon\n        pos.y *= sqrt(3.)/1.5;\n        \n        // rotate (pyth 9^2+40^2=41^2)\n        pos.xy = pos.xy*40./41. + pos.yx*vec2(9,-9)/41.;\n        \n#if defined (LENSFX) && LENSFX > 0\n        // distort the bokeh a little near the screen edges\n        pos.xy -= 1.*(pos.xy-ray.xy)*dot(ray.xy,pos.xy); // AWESOME!\n\n        // and distort the lens a little\n        float distort = -.03;// -ve for barrel, +ve for pincushion distortion\n        ray.z *= 1.+distort*(dot(ray.xy,ray.xy)-.5);\n#endif\n        \n        pos *= parameters.aperture;\n        \n        ray /= ray.z;\n        \n        // start out of focus, to show off! :)\n//        float focus = mix( 2., length(target-cam.pos), .8*smoothstep(.5,1.,time) );\n        float focus = parameters.focus;\n        ray.xy -= pos.xy/focus; // focus rays at correct distance\n        \n        \n        ray = normalize(ray);\n\n        ray = ray.x*cam.i + ray.y*cam.j + ray.z*cam.k;\n        pos = pos.x*cam.i + pos.y*cam.j + cam.pos;\n        \n        \n        fragColour.rgb += ShadeRay(\n            \t\t\t\tpos, ray,\n                            time\n                            //+ 8.*sin(time/4.)*fragCoord.x/iResolution.x\n                            //+ exp2(sin(time)*4.)*fragCoord.y/iResolution.y\n            \t\t\t\t, rand\n                            );\n    }\n    fragColour.rgb /= float(n);\n    \n    // vignetting\n#if defined (LENSFX) && LENSFX > 0\n    {\n    \tvec3 ray = vec3( (fragCoord - iResolution.xy*.5)/iResolution.y, 50./36. );\n    \tfragColour.rgb *= 1.1*smoothstep(.6,1.,normalize(ray).z);\n\t}\n#endif\n    \n    fragColour.rgb *= parameters.exposure;\n\n    // amp up saturation to push colours beyond what we can display\n   \t// if we do this after the soft clamp we get more hue shift on overexposed colours\n    fragColour.rgb = mix( vec3(Grey(fragColour.rgb)), fragColour.rgb, parameters.saturation );\n    \n    // soft clamp to white (oh this is so good)\n    const float whiteSoftness = 0.1;\n    float w2 = whiteSoftness*whiteSoftness;\n    fragColour.rgb += w2;\n    fragColour.rgb = (1.-fragColour.rgb)*.5;\n    fragColour.rgb = 1. - (sqrt(fragColour.rgb*fragColour.rgb+w2) + fragColour.rgb);\n    // might be nnice to do this in grey, so colours don't shift, but looks quite photographic like this\n\n//    fragColour = vec4(pow(fragColour.rgb,vec3(1./2.2)),1.0); // approx sRGB\n    // sRGB\n\tfragColour = mix( 12.92 * fragColour,\n                     1.055 * pow(fragColour, vec4(1./2.4)) - 0.055,\n                     step(0.0031308,fragColour));\n    \n\t// signature\n\t#define L(m,n,u,v,l,f) min(f,max(abs(dot(fragCoord-vec2(m,n),vec2(u,v)))-l,abs(dot(fragCoord-vec2(m,n),vec2(-v,u)))-1.))\n\tfloat sig=L(3,7,0,1,3.5,L(7,7,0,1,3.5,L(5,7,1,0,2.,L(14.5,5,.7071,-.7071,2.5,abs(length(fragCoord-vec2(12.7,7))-3.)-1.))));\n\tfragColour.rgb = clamp(fragColour.rgb,0.,1.)*sig/(.1+abs(sig));\n\t\n#if defined(ANIMATE_NOISE)\n    // dither, so near-black colours don't band\n\tfragColour += (Rand( pseed ).x*-.5)*1./256.; // why does this need to be > /255?\n#endif\n    \n    DebugPrint( fragColour, fragCoord );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define MAX_SAMPLES 64\n\n\n\n// General Purpose things\n\nconst float tau = 6.283185;\n\nfloat Grey( vec3 a )\n{\n    return dot( a, vec3(0.299, 0.587, 0.114) );\n}\n\n\n\n\n// Scene\n\n// list of cylinders\n// Each cylinder is decribed by a pair of vec4's:\n// vec4( start position, radius ), vec4( end pos, material index )\nvec4 Scene[] = vec4[](\n    // floor\n     vec4(0,0,0,5), vec4(0,-1,0,0)\n    \n    // chair\n    #define cr .21\n    #define cr2 .23*.707\n    #define cr3 .26*.707\n    #define cbs .1\n    #define cbc sqrt(1.-cbs*cbs)\n// wrap this in a macro\n/*    ,vec4(0,-.01,.02,.3), vec4(0,.91,.02,-13) // bounding volume\n    \n    ,vec4(0,.44,0,cr), vec4(0,.45,0,2)\n    ,vec4(-cr3,0,cr3,.02), vec4(-cr2,.45,cr2,4)\n    ,vec4(cr3,0,cr3,.02), vec4(cr2,.45,cr2,4)\n    ,vec4(-cr3,0,-cr3,.02), vec4(-cr2,.45,-cr2,4)\n    ,vec4(cr3,0,-cr3,.02), vec4(cr2,.45,-cr2,4)\n    ,vec4(-cr2,.42,-cr2,.015), vec4(cr2,.42,cr2,4)\n    ,vec4(cr2,.42,-cr2,.015), vec4(-cr2,.42,cr2,4)\n\n    ,vec4(0,.7,.22,cr), vec4(0,.7-.01*cbs,.22+.01*cbc,2)\n    ,vec4(-.1,.7-.03*cbs-.3*cbc,.22+.03*cbc-.25*cbs,.02), vec4(-.1,.7-.03*cbs+cr*cbc,.22+.03*cbc+cr*cbs,4) \n    ,vec4(.1,.7-.03*cbs-.3*cbc,.22+.03*cbc-.25*cbs,.02), vec4(.1,.7-.03*cbs+cr*cbc,.22+.03*cbc+cr*cbs,4) \n    ,vec4(-.1,.42,.1,.015), vec4(-.1,.42,.22,4) \n    ,vec4(.1,.42,.1,.015), vec4(.1,.42,.22,4) */\n    \n#define Chair(p,i,j,k,m) \\\n    vec4(-.01*j+.02*k+p,.3), vec4(.91*j+.02*k+p,-13) \\\n    ,vec4(.44*j+p,cr), vec4(.45*j+p,m) \\\n    ,vec4(-cr3*i+cr3*k+p,.02), vec4(-cr2*i+.45*j+cr2*k+p,4) \\\n    ,vec4(cr3*i+cr3*k+p,.02), vec4(cr2*i+.45*j+cr2*k+p,4) \\\n    ,vec4(-cr3*i-cr3*k+p,.02), vec4(-cr2*i+.45*j-cr2*k+p,4) \\\n    ,vec4(cr3*i-cr3*k+p,.02), vec4(cr2*i+.45*j-cr2*k+p,4) \\\n    ,vec4(-cr2*i+.42*j-cr2*k+p,.015), vec4(cr2*i+.42*j+cr2*k+p,4) \\\n    ,vec4(cr2*i+.42*j-cr2*k+p,.015), vec4(-cr2*i+.42*j+cr2*k+p,4) \\\n    ,vec4(.7*j+.22*k+p,cr), vec4((.7-.01*cbs)*j+(.22+.01*cbc)*k+p,m) \\\n    ,vec4(-.1*i+(.7-.03*cbs-.3*cbc)*j+(.22+.03*cbc-.25*cbs)*k+p,.02), vec4(-.1*i+(.7-.03*cbs+cr*cbc)*j+(.22+.03*cbc+cr*cbs)*k+p,4) \\\n    ,vec4(.1*i+(.7-.03*cbs-.3*cbc)*j+(.22+.03*cbc-.25*cbs)*k+p,.02), vec4(.1*i+(.7-.03*cbs+cr*cbc)*j+(.22+.03*cbc+cr*cbs)*k+p,4) \\\n    ,vec4(-.1*i+.42*j+.1*k+p,.015), vec4(-.1*i+.42*j+.22*k+p,4) \\\n    ,vec4(.1*i+.42*j+.1*k+p,.015), vec4(.1*i+.42*j+.22*k+p,4)\n    \n    ,Chair(vec3(0),vec3(1,0,0),vec3(0,1,0),vec3(0,0,1),2)\n    ,Chair(vec3(-.5,0,-.75),vec3(-3./5.,0,4./5.),vec3(0,1,0),vec3(-4./5.,0,-3./5.),3)\n    \n    // light reflectors / abstract\n    ,vec4(-.51,0,.51,1),vec4(-.5,0,.5,3)\n    ,vec4(-1.264,0,-1.,1),vec4(-1.25,0,-1.,2)\n    );\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specularColour;\n    float roughness;\n    float emissive; // 0 to 1\n};\n    \n// adjust material values, to try to avoid physically implausible ones\n#define MATERIAL(c,s,r,e) Material(.9*c,s,r,e)\n    \n// base material parameters - can add some maths to modify this\nconst Material base[] = Material[](\n         MATERIAL(vec3(1),vec3(.004),.5,0.) // floor\n        ,MATERIAL(vec3(0,0,0),vec3(.7,.75,.8),.01,0.) // metal\n        ,MATERIAL(vec3(1),vec3(.05),.005,0.) // white plastic\n        ,MATERIAL(vec3(1,.14,0),vec3(.05),.005,0.) // bright orange\n        ,MATERIAL(vec3(.01),vec3(.05),.3,0.) // black\n    );\n\n\n    \nstruct Light\n{\n    vec3 position;\n    vec3 target;\n    vec3 colour; // at distance of 1 unit\n    float innerRadius; // at distance of 1 unit\n    float outerRadius;\n    float sourceRadius; // area lighting\n};\n\n// adjust colour so inverse square falloff hits desired colour at target position\n#define LIGHT(p,t,c,i,o,r) Light(p,t,c*dot(t-p,t-p),i/length(t-p),o/length(t-p),r)\n    \nconst Light lights[] = Light[](\n    \t LIGHT(vec3(5,3,-.5)*100.,vec3(0),vec3(6),10.,11.,100.*.05/*.005*/) // sun\n    );\n\n\n\n// Data-reading functions\n\nstruct Camera\n{\n    vec3 pos, i, j, k;\n    vec2 rot; // always corresponds to i,j,k but may be useful\n};\n\nstruct CamPosRot\n{\n    vec3 pos;\n    vec2 rot; // always corresponds to i,j,k but may be useful\n};\n\nCamera ToCamera( CamPosRot a )\n{\n    Camera b;\n    b.pos = a.pos;\n    b.rot = a.rot;\n    \n    vec4 pitch = vec4(cos(a.rot.x),sin(a.rot.x)*vec2(1,-1),0);\n    vec4 yaw = vec4(cos(a.rot.y),sin(a.rot.y)*vec2(1,-1),1);\n    b.i = vec3(yaw.x,0,yaw.z);\n    b.j = pitch.yxy*yaw.ywx;\n    b.k = pitch.xzx*yaw.ywx;\n    \n    return b;\n}\n\nCamera GetCameraInternal( sampler2D dataTex )\n{\n    CamPosRot cpr;\n    cpr.pos = texelFetch(dataTex,ivec2(0,0),0).xyz;\n    vec4 camrot = texelFetch(dataTex,ivec2(1,0),0);\n    cpr.rot = camrot.xy;\n    \n    Camera cam = ToCamera(cpr);\n    \n    return cam;\n}\n\n\nstruct Params\n{\n    float focalLength, zoom, focus, fStop, aperture, exposure, saturation, whiteBalance;\n};\n\n#define PARAMS(focalLength, focus, fStop, exposure, saturation, whiteBalance)\\\n    Params( focalLength, focalLength/24., focus, fStop, (focalLength/fStop)/1000., exposure, saturation, whiteBalance )\n    \n// x = zoom, y = focus, z = aperture, w = exposure\n// todo: white balance?\nParams GetParametersInternal( sampler2D dataTex )\n{\n    // these parameters want to be positive and exponential, so store their logs!\n    vec4 param0 = exp2(texelFetch(dataTex,ivec2(2,0),0));\n    // these parameters are linear\n    vec4 param1 = texelFetch(dataTex,ivec2(3,0),0);\n    \n    return PARAMS(param0.x,param0.y,param0.z,param0.w,param1.x,param1.y);\n}\n\n#define GetCamera() GetCameraInternal(iChannel0)\n#define GetParameters() GetParametersInternal(iChannel0)\n\n\n\n// Ray Tracing\n\n#define FLT_MAX 1e38\n\nfloat IntersectCylinder( out bool inside, out vec3 normal, vec4 a, vec4 b, vec3 pos, vec3 ray )\n{\n    vec3 m = (a.xyz+b.xyz)/2.;\n    \n    pos -= m; // centre all maths on the cylinder\n    \n    float radius = a.w;\n    vec3 n = (a.xyz-b.xyz)/2.;\n    float l = length(n);\n    n /= l;\n    \n    \n    // intersect infinite cylinder\n    // flatten everything along the axis\n    float rdn = dot(ray,n);\n    float pdn = dot(pos,n);\n    vec3 r = ray-rdn*n;\n    vec3 p = pos-pdn*n;\n    float rl = length(r);\n    r /= rl;;\n    float rdp = dot(r,p);\n    float pp = dot(p,p);\n\n    inside = (pp < radius*radius && abs(pdn) < l);\n    \n    float q = pp - rdp*rdp;\n    if ( q >= radius*radius ) return FLT_MAX;\n    \n    float d = sqrt(radius*radius-q);\n    float front = (-rdp - d)/rl;\n    float back = (-rdp + d)/rl;\n    normal = normalize(p+front*r*rl);\n    \n    \n    // intersect facing plane\n    if( rdn < 0. ) { n = -n; rdn = -rdn; pdn = -pdn; }\n    \n    float front2 = (-l-pdn)/rdn;\n    \n    if ( front2 > front )\n    {\n        front = front2;\n        normal = -n;\n    }\n\n    \n    // clip the back sides\n    if (\n        front > back || // clip to back of cylinder\n    \tpdn+rdn*front > l // clip to back plane\n        )\n        return FLT_MAX;\n    \n    return front;\n}\n\n\nfloat TraceInternal( out vec3 normal, out int matidx, vec3 pos, vec3 ray, sampler2D dataTex )\n{\n    matidx = -1;\n    normal = vec3(0);\n    float t = FLT_MAX;\n//    int skip = 0;\n    int i=0;\n    for ( int j=0; j < Scene.length(); j += 2 )\n    {\n        if ( i > Scene.length() ) break;\n#if (1)\n        vec4 scene0 = Scene[i];\n        vec4 scene1 = Scene[i+1];\n#else\n        // this is about 25% slower on a simple scene, but may be faster on more complex ones\n        vec4 scene0 = texelFetch(dataTex,ivec2(i,1),0);\n        vec4 scene1 = texelFetch(dataTex,ivec2(i+1,1),0);\n#endif\n//        skip--;\n//        if ( skip > 0 ) continue;\n        vec3 n;\n        bool inside = false;\n        float f = IntersectCylinder( inside, n, scene0, scene1, pos, ray );\n        int data = int(scene1.w);\n        if ( f > 0. && f < t )\n        {\n            if ( data >= 0 )\n            {\n                t = f;\n                normal = n;\n                matidx = data;\n            }\n        }\n        else if ( data < 0 && !inside )\n        {\n            //skip = -data;\n            i += 2*(-data-1);\n        }\n        i += 2;\n    }\n    return t;\n}\n\n#define Trace(a,b,c,d) TraceInternal(a,b,c,d,iChannel0)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Camera controls\n\n// Read Keyboard\nconst int // values from http://keycode.info/ - some might be browser/region dependent\nkReturn=13,kShift=16,kCtrl=17,kAlt=18,kSpace=32,kPgUp=33,kPgDn=34,kEnd=35,kHome=36,kLeft=37,kUp=38,kRight=39,kDown=40,kInsert=45,kDelete=46,\nk0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57,kPlusEq=61,kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,\nkL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90,kNum0=96,kNum1=97,kNum2=98,kNum3=99,kNum4=100,kNum5=101,\nkNum6=102,kNum7=103,kNum8=104,kNum9=105,kNumTimes=106,kNumPlus=107,kNumMinus=109,kNumPeriod=110,kNumDivide=111,kMinus=173,kSquareLeft=219,kSquareRight=221,\nkComma=188,kPeriod=190;\n#define Key(a) texelFetch(iChannel3,ivec2(a,0),0).x\n#define KeyToggle(a) texelFetch(iChannel3,ivec2(a,2),0).x\n\n\nbool reset = true; // first frame initialisation\n\n\n// Camera animation\nstruct CameraState\n{\n\tCamPosRot cam;\n\tvec4 param0, param1;\n};\n\n// a series of nice camera moves - each with 2 keyframes, lerping between 2 camera states\nstruct CameraMove\n{\n\tfloat duration, paramTime;\n\tCameraState start, finish;\n};\n\nCameraMove[] camanim = CameraMove[](\n            \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// focal length, focus, f-stop, exposure, saturation\n    \tCameraMove(\n            4.f, .5f,\n            CameraState( CamPosRot( vec3(2.683,.636,1.799), vec2(-.005,-2.198) ), vec4( 109., 3.1, 3.6, .2 ), vec4( 1.5, 0, 0, 0 ) ),\n            CameraState( CamPosRot( vec3(2.871,.571,1.185), vec2(-.0028,-2.035) ), vec4( 109., 4., 3.6, .2), vec4( 1.5, 0, 0, 0 ) )\n            )\n    \t, CameraMove(\n            7.f, .6f,\n            CameraState( CamPosRot( vec3(-.75,.066,-2.59), vec2(-.0049,.2473) ), vec4( 120., 3., 5.2, .25 ), vec4( 1.5, 0, 0, 0 ) ),\n            CameraState( CamPosRot( vec3(-1.065,.69,-1.95), vec2(.1376,.4735) ), vec4( 120., 1.16, 5.2, .25), vec4( 1.5, 0, 0, 0 ) )\n            )\n    \t, CameraMove(\n            6.f, .5f,\n            CameraState( CamPosRot( vec3(.55,.34,-1.2), vec2(.101,-.706) ), vec4( 94., 1.97, 2.8, .25 ), vec4( 1.5, 0, 0, 0 ) ),\n//            CameraState( CamPosRot( vec3(1.12,.51,.4), vec2(.045,-1.813) ), vec4( 120., .9, 2.8, .25 ), vec4( 1.5, 0, 0, 0 ) )\n            CameraState( CamPosRot( vec3(1.9,.7,-.71), vec2(.073,-1.193) ), vec4( 94., 2., 2.8, .25 ), vec4( 1.5, 0, 0, 0 ) )\n            )\n    \t, CameraMove(\n            8.f, .5f,\n            CameraState( CamPosRot( vec3(1.75,1.88,-.05), vec2(.485,-1.838) ), vec4( 150., 2.87, 4.0, .25), vec4( 1.5, 0, 0, 0 ) ),\n            CameraState( CamPosRot( vec3(2.3,.6,.26), vec2(.008,-1.853) ), vec4( 115., 2.87, 4.0, .18), vec4( 1.5, 0, 0, 0 ) )\n            )\n    \t/*, CameraMove(\n            10.f, .8f,\n            CameraState( CamPosRot( vec3(2.73,.90,1.09), vec2(.06,-2.054) ), vec4( 130., 3.77, 2.8, .2 ), vec4( 1.5, 0, 0, 0 ) ),\n            CameraState( CamPosRot( vec3(2.1,.91,-4.61), vec2(.045,-.522) ), vec4( 130., 5.1, 2.8, .35), vec4( 1.5, 0, 0, 0 ) )\n            )\n    \t, CameraMove(\n            5.f, .6f,\n            CameraState( CamPosRot( vec3(.36,.33,-3.09), vec2(-.042,-.270) ), vec4( 80., 3.5, 2.8, .25), vec4( 1.5, 0, 0, 0 ) ),\n            CameraState( CamPosRot( vec3(3.89,2.08,-7.65), vec2(.182,-.524) ), vec4( 181., 8.52, 2.8, .25 ), vec4( 1.5, 0, 0, 0 ) )\n            )*/\n    \t, CameraMove(\n            8.f, .7f,\n            CameraState( CamPosRot( vec3(2.12,.21,-4.78), vec2(-.059,-.558) ), vec4( 70., 4.5, 1.8, .35), vec4( 1.5, 0, 0, 0 ) ),\n            CameraState( CamPosRot( vec3(5.05,.16,-.41), vec2(-.081,-1.660) ), vec4( 70., 4.5, 5.6, .15), vec4( 1.5, 0, 0, 0 ) )\n            )\n    \t, CameraMove(\n            6.f, .7f,\n            CameraState( CamPosRot( vec3(-1.15,.52,-.77), vec2(.109,1.617) ), vec4( 120., .54, 8., .25), vec4( 1.5, 0, 0, 0 ) ),\n            CameraState( CamPosRot( vec3(-1.2,.81,-.59), vec2(.506,1.74) ), vec4( 120., .71, 8., .12), vec4( 1.5, 0, 0, 0 ) )\n            )\n    );\n\n// to make these params work => need a PARAMS function to convert human-readable ones into storable values\n\nvec4 UpdatePosition( vec3 resetValue )\n{\n    Camera cam = GetCamera();\n    \n    cam.pos += cam.i*1.*iTimeDelta*(Key(kD)-Key(kA)+Key(kRight)-Key(kLeft));\n    cam.pos += cam.j*1.*iTimeDelta*(Key(kR)-Key(kF));\n    cam.pos += cam.k*1.*iTimeDelta*(Key(kW)-Key(kS)+Key(kUp)-Key(kDown));\n    \n    return reset?vec4(resetValue,0):vec4( cam.pos, 0 );\n}\n\nvec4 UpdateRotation( vec2 resetValue )\n{\n    vec4 camrot = texelFetch(iChannel0,ivec2(1,0),0);\n    \n    // mouse drag stuff always sucks... hmm...\n    // SHOULD be able to just measure difference between xy (current) and zw (last click), if x != 0.\n    if ( iMouse.z > 0. )\n    {\n        if ( camrot.z <= 0. ) camrot.zw = iMouse.zw;\n        \n        // drag in progress\n        // total drag distance is iMouse.xy-iMouse.zw - but we want realtime feedback so remember where we were last frame\n        vec2 delta = vec2(-1,1) * (iMouse.xy-camrot.zw)/iResolution.x;\n        camrot.zw = iMouse.xy;\n        camrot.xy += delta.yx;\n    }\n    else\n    {\n        camrot.zw = vec2(-1);\n    }\n    \n    return reset?vec4(resetValue,-1,-1):camrot;\n}\n\n\n\nvoid AutoFocus( inout float logDist )\n{\n    Camera cam = GetCamera();\n\n    // measure distance in front of camera\n    vec3 ignorev;\n    int ignorei;\n    float t = Trace( ignorev, ignorei, cam.pos, cam.k );\n    \n    t = clamp(t,0.,65536.);\n    \n    t = log2( t );\n    \n    // animate focus moving toward t\n    logDist += (t-logDist)*.04;\n}\n\n\nvec4 UpdateParam0( vec4 resetValue )\n{\n    // x = zoom, y = focus, z = aperture, w = exposure\n    vec4 param0 = texelFetch(iChannel0,ivec2(2,0),0);//GetParameters();\n    \n    param0.x += 1.*iTimeDelta*(Key(kNumPlus)-Key(kNumMinus) + Key(kPlusEq)-Key(kMinus));\n    param0.y += 1.*iTimeDelta*(Key(kPgUp)-Key(kPgDn));\n    param0.z += 1.*iTimeDelta*(Key(kSquareRight)-Key(kSquareLeft));\n    param0.w += 1.*iTimeDelta*(Key(kPeriod)-Key(kComma));\n    \n    if ( KeyToggle(kHome) > 0. )\n    {\n        AutoFocus( param0.y );\n    }\n    \n    return reset?log2(resetValue):param0;\n}\n\n\nvec4 UpdateParam1( vec4 resetValue )\n{\n    // saturation, white balance\n    vec4 param1 = texelFetch(iChannel0,ivec2(3,0),0);\n    \n// todo adjust param1\n    \n    return reset?resetValue:param1;\n}\n\n\n// extract the nth digit from a number\nint GetDigit( float f, int digidx )\n{\n    // sign\n    if ( f < 0. ) { digidx -= 1; f = -f; }\n    if ( digidx < 0 ) return 0x2d;\n        \n    int fLog10 = int(log2(f)/log2(10.));\n    fLog10 = max(fLog10,0);\n    int log10 = fLog10;\n    log10 -= digidx;\n    if ( log10 == -1 )\n    {\n        return 0x2e; // decimal point\n    }\n    else\n    {\n        if ( log10 < 0 ) log10++; // leave space for decimal\n        //int digit = max( 0,int( floor( f / pow(10.,float(log10)) ) ))%10;\n        int digits = int(f*floor(pow(10.,float(6-fLog10))+.5)); // extract up to 6 digits (or maybe 7?)\n        const int[] exp10 = int[]( 1000000, 100000, 10000, 1000, 100, 10, 1 ); // corresponding to [0-6]\n        int digit = (digits/exp10[fLog10-log10])%10;\n        return digit + 0x30;\n    }\n}\n\n\nvec4 UpdateSampleCount( vec4 sampData )\n{\n    // adaptive frame rate\n/*  if there's a run of slow frames, reduce num samples by desired proportion of frame time\n    if there's a run of fast frames, creep num samples upwards, and step back when hit first slow frame (so stepping back hopefully hits ideal)\n    e.g. -ve => frame count of successive fast frames, +ve => frame count of slow frames\n    second value holds current number of samples\n*/\n    \n    if ( iFrame == 0 )\n    {\n        sampData = vec4(MAX_SAMPLES,0,1./60.,0);\n    }\n    \n    // time delta seems to be a bit unsteady, so create a stabilised version\n    sampData.z = mix(sampData.z,min(iTimeDelta,1./15.),.25);\n\n    // count how many frames we've been running under/over 60 fps\n    if ( sampData.z < 1./58. )\n    {\n        // faster than 60fps\n        sampData.y = min(0.,sampData.y);\n        sampData.y--;\n        if ( sampData.y < -120. )\n        {\n            sampData.x++; // creep up slowly\n            sampData.y = -90.; // next step up in 30 frames\n        }\n    }\n    else\n    {\n        // slow frame\n        if ( sampData.y < 0. && sampData.x > 3. ) // don't do this so quickly on really low sample counts\n        {\n            // first slow frame after some fast ones, undo our last creep up\n            sampData.x--;\n        }\n        sampData.y = max(0.,sampData.y);\n        sampData.y++;\n        if ( sampData.y > 10. )\n        {\n            sampData.x = floor(sampData.x*(1./60.)/sampData.z); // shoot for an exact target\n            sampData.y = 0.;\n        }\n    }\n    \n    sampData.x = clamp(sampData.x,1.,float(MAX_SAMPLES));\n    \n    return sampData;\n}\n\nvoid DebugPrint( inout vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour = vec4(0,0,0,1);\n\n    if ( KeyToggle(kC) != 0. )\n    {\n        // print debug info!\n        Params param = GetParameters();\n        Camera cam = GetCamera();\n\n        // cam.pos, cam.rot\n        // x = zoom, y = focus, z = aperture, w = exposure\n        // NO\\/ want to drive it all with \"which character am I on?\"\n        //\t\tfloat sdf = PrintString( uv-ivec2(10,10), Vec3ToString( cam.pos ) );\n        //\t\tsdf = min(sdf, PrintString( uv-ivec2(10,20), Vec2ToString( cam.rot ) );\n        // print zoom in mm (= zoom*24mm (height of standard film frame))\n        int numLines = 24;\n        int fontHeight = int(iResolution.y/float(numLines)); // round down, so we definitely fit all the lines\n        int fontWidth = fontHeight/2;\n\n        vec2 uv = fragCoord.xy - vec2(0,0);\n        uv.y = iResolution.y-uv.y;\n        int row = int(uv.y)/fontHeight;\n        int column = int(uv.x)/fontWidth;\n\n        uv = fract(uv/vec2(fontWidth,fontHeight))*vec2(fontWidth,fontHeight)/float(fontHeight);\n        uv.y = 1.-uv.y;\n\n        // add more columns of text\n        row += (column/24)*24;\n        column = column%24;\n\n        //need to flip lines...\n\n        int char = -1;\n        int line = 0;\n        vec3 textCol = vec3(0);\n        #define Print(col,_text) { int[] text=_text; if ( row == line && column < text.length() ) { textCol = col; char = text[column]; } line++; }\n        #define PrintFloat(col,f,_text) { int[] text=_text; if ( row == line && column >= 4 ) { textCol = col; if ( column < 10 ) { char = GetDigit(f,column-4); } else if ( column < 10+text.length() ) char = text[column-10]; } line++; }\n        #define PrintFloatPre(col,_text,f) { int[] text=_text; if ( row == line && column >= 4 ) { textCol = col; if ( column < 4+text.length() ) char = text[column-4]; else if ( column < 10+text.length() ) { char = GetDigit(f,column-4-text.length()); } } line++; }\n    \tPrint( vec3(1.5), int[](0x3d,0x43,0x41,0x4d,0x45,0x52,0x41,0x3d,0x50,0x41,0x52,0x41,0x4d,0x45,0x54,0x45,0x52,0x53,0x3d) ); // \"=CAMERA=PARAMETERS=\"\n    \tPrint( vec3(1,1,1), int[](0x43,0x61,0x6d,0x65,0x72,0x61,0x20,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x3a) ); // \"Camera Position:\"\n        PrintFloat( vec3(0,1,0), cam.pos.x, int[](0x6d) );\n        PrintFloat( vec3(0,1,0), cam.pos.y, int[](0x6d) );\n        PrintFloat( vec3(0,1,0), cam.pos.z, int[](0x6d) );\n        Print( vec3(1,1,1), int[](0x43,0x61,0x6d,0x65,0x72,0x61,0x20,0x52,0x6f,0x74,0x61,0x74,0x69,0x6f,0x6e,0x3a) ); // \"Camera Rotation:\"\n        PrintFloat( vec3(0,1,0), cam.rot.x, int[](0x72,0x61,0x64) );\n        PrintFloat( vec3(0,1,0), cam.rot.y, int[](0x72,0x61,0x64) );\n        Print( vec3(1,1,1), int[](0x46,0x6f,0x63,0x61,0x6c,0x20,0x4c,0x65,0x6e,0x67,0x74,0x68,0x3a) ); // \"Focal Length:\"\n        PrintFloat( vec3(0,1,0), param.focalLength, int[](0x6d,0x6d) );\n        Print( vec3(1,1,1), int[](0x46,0x6f,0x63,0x75,0x73,0x3a) ); // \"Focus:\"\n        if ( KeyToggle(kHome) > 0. )\n        {\n            Print( vec3(0,1,0), int[](0x20,0x20,0x20,0x20,0x61,0x75,0x74,0x6f) );\n        }\n        else\n        {\n            PrintFloat( vec3(0,1,0), param.focus, int[](0x6d) );\n        }\n        Print( vec3(1,1,1), int[](0x41,0x70,0x65,0x72,0x74,0x75,0x72,0x65,0x3a) ); // \"Aperture:\"\n        PrintFloatPre( vec3(0,1,0), int[](0x66,0x2f), param.fStop );\n        Print( vec3(1,1,1), int[](0x45,0x78,0x70,0x6f,0x73,0x75,0x72,0x65,0x3a) ); // \"Exposure:\"\n        PrintFloat( vec3(0,1,0), param.exposure, int[](0x20) );\n        Print( vec3(1,1,1), int[](0x53,0x61,0x74,0x75,0x72,0x61,0x74,0x69,0x6f,0x6e,0x3a) ); // \"Saturation:\"\n        PrintFloat( vec3(0,1,0), param.saturation, int[](0x20) );\n// todo:\n//        Print( vec3(1,1,1), int[](0x57,0x68,0x69,0x74,0x65,0x20,0x42,0x61,0x6c,0x61,0x6e,0x63,0x65,0x3a) ); // \"White Balance:\"\n//        PrintFloat( vec3(0,1,0), param.whiteBalance, int[](0x20) );\n        line += 6;\n    \tPrint( vec3(1.5), int[](0x3d,0x46,0x52,0x41,0x4d,0x45,0x3d,0x49,0x4e,0x46,0x4f,0x3d) ); // \"=FRAME=INFO=\"\n        Print( vec3(1,1,1), int[](0x52,0x65,0x73,0x6f,0x6c,0x75,0x74,0x69,0x6f,0x6e,0x3a) ); // \"Resolution:\"\n        PrintFloat( vec3(1,1,0), iResolution.x, int[](0x20) );\n        PrintFloat( vec3(1,1,0), iResolution.y, int[](0x20) );\n        Print( vec3(1,1,1), int[](0x46,0x72,0x61,0x6d,0x65,0x20,0x52,0x61,0x74,0x65,0x3a) ); // \"Frame Rate:\"\n        PrintFloat( vec3(1,1,0), 1./iTimeDelta, int[](0x66,0x70,0x73) );\n\t\tvec4 sampData = texelFetch(iChannel0,ivec2(5,0),0);\n\t\tPrintFloat( vec3(1,1,0), 1./sampData.z, int[](0x20,0x73,0x6d,0x6f,0x6f,0x74,0x68,0x65,0x64) );\n\t\tPrintFloat( vec3(1,1,0), sampData.y, int[](0x20) );\n        line++;\n        Print( vec3(1,1,1), int[](0x41,0x64,0x61,0x70,0x74,0x69,0x76,0x65,0x20,0x53,0x61,0x6d,0x70,0x6c,0x65,0x20,0x43,0x6f,0x75,0x6e,0x74,0x3a) ); // \"Adaptive Sample Count:\"\n\t\tPrintFloat( vec3(step(-15.,sampData.y),step(sampData.y,0.),0), sampData.x, int[](0x20) );\n    \n        if ( char >= 0 )\n        {\n            vec2 charuv = vec2( char&0xF, 0xF-(char>>4) );\n            vec4 t = textureLod( iChannel1, (uv+charuv)/16.+vec2(1./64.,0), 0. );\n            float s = .8/float(fontHeight);\n            fragColour = vec4( textCol*smoothstep(.5+s,.5-s,t.w), smoothstep(.5-s,.5+s*3.,t.w) );\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    reset = ( iFrame == 0 || KeyToggle(kSpace) == 0. );\n    \n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    fragColour = texelFetch(iChannel0,iFragCoord,0);\n\n    float smoothTimeDelta = texelFetch(iChannel0,ivec2(5,0),0).z;\n    \n    if ( iFragCoord.y == 0 )\n    {\n        // read controls and update values\n        int pixel = iFragCoord.x;\n\n        vec4 camAnimState = texelFetch(iChannel0,ivec2(4,0),0);\n        if ( iFrame == 0 ) camAnimState = vec4(0);\n        int camIdx = int(camAnimState.x);\n        float camTime = camAnimState.y;\n        int camWraps = int(camAnimState.z);\n        camTime += smoothTimeDelta;\n        if ( camTime > camanim[camIdx].duration )\n        {\n            camTime -= camanim[camIdx].duration;\n            camTime = min(camTime,1.); // sometimes when you switch focus Shadertoy gives a huge time delta!\n            camIdx++;\n            if ( camIdx >= camanim.length() )\n            {\n                camIdx = 0;\n                camWraps++;\n            }\n        }\n        CameraMove camMove = camanim[camIdx];\n        float lerp = smoothstep(0.f,camMove.duration,camTime);\n        float snap = .6/2.; // duration of focus pull\n        float prop = camMove.duration*camMove.paramTime; // timing of focus pull\n        float lerp2 = smoothstep(max(0.f,prop-snap),min(camMove.duration,prop+snap),camTime);\n        //UpdatePosition(mix(camMove.start.cam.pos,camMove.finish.cam.pos,lerp))\n\n        if ( pixel == 0 ) fragColour = UpdatePosition(mix(camMove.start.cam.pos,camMove.finish.cam.pos,lerp));//vec3(2.683,.636,1.799));\n        if ( pixel == 1 ) fragColour = UpdateRotation(mix(camMove.start.cam.rot,camMove.finish.cam.rot,lerp));//vec2(-.005,-2.198));\n        if ( pixel == 2 ) fragColour = UpdateParam0(mix(camMove.start.param0,camMove.finish.param0,lerp2));//vec4(109.55,4.,3.6,.2));\n        if ( pixel == 3 ) fragColour = UpdateParam1(mix(camMove.start.param1,camMove.finish.param1,lerp));//vec4(1.5,0,0,0));\n        if ( pixel == 4 ) fragColour = vec4(camIdx,camTime,camWraps,0);\n        if ( pixel == 5 ) fragColour = UpdateSampleCount(texelFetch(iChannel0,ivec2(5,0),0));\n    }\n    else if ( iFragCoord.y == 1 )\n    {\n        // store scene in a more indexable format\n        if ( /*reset &&*/ iFragCoord.x < Scene.length() ) fragColour = Scene[iFragCoord.x];\n    }\n    else\n    {\n        DebugPrint( fragColour, fragCoord );\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}