{
    "Shader": {
        "info": {
            "date": "1631520994",
            "description": "Animation of Okhsl, based on https://bottosson.github.io/posts/colorpicker/\n\nDesigned to be more uniform than regular HSL",
            "flags": 0,
            "hasliked": 0,
            "id": "7sK3D1",
            "likes": 15,
            "name": "Okhsl saturation animation",
            "published": 3,
            "tags": [
                "hsl",
                "colorspace",
                "oklab",
                "okhsl"
            ],
            "usePreview": 0,
            "username": "bjornornorn",
            "viewed": 1439
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = okhsl_to_srgb(vec3(uv.x, 0.5f+0.5f*sin(iTime), uv.y));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Copyright(c) 2021 BjÃ¶rn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 gamut_clip_preserve_chroma(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = clamp(L, 0.f, 1.f);\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = 0.5;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat L0 = cusp.x;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat Ld = L - 0.5f;\n\tfloat e1 = 0.5f + abs(Ld) + alpha * C;\n\tfloat L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat Ld = L - cusp.x;\n\tfloat k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);\n\n\tfloat e1 = 0.5f * k + abs(Ld) + alpha * C / k;\n\tfloat L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nfloat toe(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));\n}\n\nfloat toe_inv(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\n\nvec2 to_ST(vec2 cusp)\n{\n\tfloat L = cusp.x;\n\tfloat C = cusp.y;\n\treturn vec2( C / L, C / (1.f - L) );\n}\n\n// Returns a smooth approximation of the location of the cusp\n// This polynomial was created by an optimization process\n// It has been designed so that S_mid < S_max and T_mid < T_max\nvec2 get_ST_mid(float a_, float b_)\n{\n\tfloat S = 0.11516993f + 1.f / (\n\t\t+7.44778970f + 4.15901240f * b_\n\t\t+ a_ * (-2.19557347f + 1.75198401f * b_\n\t\t\t+ a_ * (-2.13704948f - 10.02301043f * b_\n\t\t\t\t+ a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\tfloat T = 0.11239642f + 1.f / (\n\t\t+1.61320320f - 0.68124379f * b_\n\t\t+ a_ * (+0.40370612f + 0.90148123f * b_\n\t\t\t+ a_ * (-0.27087943f + 0.61223990f * b_\n\t\t\t\t+ a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\treturn vec2( S, T );\n}\n\nvec3 get_Cs(float L, float a_, float b_)\n{\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);\n\tvec2 ST_max = to_ST(cusp);\n\t\n\t// Scale factor to compensate for the curved part of gamut shape:\n\tfloat k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);\n\n\tfloat C_mid;\n\t{\n\t\tvec2 ST_mid = get_ST_mid(a_, b_);\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tfloat C_a = L * ST_mid.x;\n\t\tfloat C_b = (1.f - L) * ST_mid.y;\n\t\tC_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));\n\t}\n\n\tfloat C_0;\n\t{\n\t\t// for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.\n\t\tfloat C_a = L * 0.4f;\n\t\tfloat C_b = (1.f - L) * 0.8f;\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tC_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));\n\t}\n\n\treturn vec3( C_0, C_mid, C_max );\n}\n\nvec3 okhsl_to_srgb(vec3 hsl)\n{\n\tfloat h = hsl.x;\n\tfloat s = hsl.y;\n\tfloat l = hsl.z;\n\n\tif (l == 1.0f)\n\t{\n\t\treturn vec3( 1.f, 1.f, 1.f );\n\t}\n\n\telse if (l == 0.f)\n\t{\n\t\treturn vec3( 0.f, 0.f, 0.f );\n\t}\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\tfloat L = toe_inv(l);\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat C, t, k_0, k_1, k_2;\n\n\tif (s < mid)\n\t{\n\t\tt = mid_inv * s;\n\n\t\tk_1 = mid * C_0;\n\t\tk_2 = (1.f - k_1 / C_mid);\n\n\t\tC = t * k_1 / (1.f - k_2 * t);\n\t}\n\telse\n\t{\n\t\tt = (s - mid)/ (1.f - mid);\n\n\t\tk_0 = C_mid;\n\t\tk_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tk_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tC = k_0 + t * k_1 / (1.f - k_2 * t);\n\t}\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsl(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\t// Inverse of the interpolation in okhsl_to_srgb:\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat s;\n\tif (C < C_mid)\n\t{\n\t\tfloat k_1 = mid * C_0;\n\t\tfloat k_2 = (1.f - k_1 / C_mid);\n\n\t\tfloat t = C / (k_1 + k_2 * C);\n\t\ts = t * mid;\n\t}\n\telse\n\t{\n\t\tfloat k_0 = C_mid;\n\t\tfloat k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tfloat k_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tfloat t = (C - k_0) / (k_1 + k_2 * (C - k_0));\n\t\ts = mid + (1.f - mid) * t;\n\t}\n\n\tfloat l = toe(L);\n\treturn vec3( h, s, l );\n}\n\n\nvec3 okhsv_to_srgb(vec3 hsv)\n{\n\tfloat h = hsv.x;\n\tfloat s = hsv.y;\n\tfloat v = hsv.z;\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\t\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f- S_0 / S_max;\n\n\t// first we compute L and V as if the gamut is a perfect triangle:\n\n\t// L, C when v==1:\n\tfloat L_v = 1.f   - s * S_0 / (S_0 + T_max - T_max * k * s);\n\tfloat C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);\n\n\tfloat L = v * L_v;\n\tfloat C = v * C_v;\n\n\t// then we compensate for both toe and the curved top part of the triangle:\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\tfloat L_new = toe_inv(L);\n\tC = C * L_new / L;\n\tL = L_new;\n\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L * scale_L;\n\tC = C * scale_L;\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsv(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f - S_0 / S_max;\n\n\t// first we find L_v, C_v, L_vt and C_vt\n\n\tfloat t = T_max / (C + L * T_max);\n\tfloat L_v = t * L;\n\tfloat C_v = t * C;\n\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\t// we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L / scale_L;\n\tC = C / scale_L;\n\n\tC = C * toe(L) / L;\n\tL = toe(L);\n\n\t// we can now compute v and s:\n\n\tfloat v = L / L_v;\n\tfloat s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);\n\n\treturn vec3 (h, s, v );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}