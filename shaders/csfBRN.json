{
    "Shader": {
        "info": {
            "date": "1688487405",
            "description": "Code is a bit messy as it was generated by my own engine, tried to adapt it a little but got lazy.\n\nWhat you see is essentialy the intersection of a sphere and a menger sponge where the size vary over time.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "csfBRN",
            "likes": 12,
            "name": "Menger sphere",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "Moumouke",
            "viewed": 260
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI (3.14159265359)\n\nfloat c01(float p) {\n  return clamp(p, 0.0, 1.0);\n}\n\nvoid fa(inout vec3 p) {\n  p.xyz = abs(p.xyz);\n}\n\nvoid fm(inout vec3 p) {\n  float a = min(p.x - p.y, 0.0);\n  p.x -= a;\n  p.y += a;\n  a = min(p.x - p.z, 0.0);\n  p.x -= a;\n  p.z += a;\n  a = min(p.y - p.z, 0.0);\n  p.y -= a;\n  p.z += a;\n}\n\nvoid fp(inout vec3 p, vec3 n, float d) {\n  p.xyz -= 2.0 * min(0.0, dot(p.xyz, n) - d) * n;\n}\n\nvoid scale(inout vec3 p, float f) {\n  p *= f;\n}\n\nvoid rotateX(inout vec3 p, float angle) {\n  p *= mat3(\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    cos(angle),\n    -sin(angle),\n    0.0,\n    sin(angle),\n    cos(angle)\n  );\n}\n\nvoid rotateY(inout vec3 p, float angle) {\n  p *= mat3(\n    cos(angle),\n    0.0,\n    sin(angle),\n    0.0,\n    1.0,\n    0.0,\n    -sin(angle),\n    0.0,\n    cos(angle)\n  );\n}\n\nvoid rotateZ(inout vec3 p, float angle) {\n  p *= mat3(\n    cos(angle),\n    -sin(angle),\n    0.0,\n    sin(angle),\n    cos(angle),\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  );\n}\n\nvoid inverseTranslate(inout vec3 p, vec3 t) {\n  p -= t;\n}\n\nvoid rotate(inout vec3 p, vec3 angles) {\n  rotateX(p, angles.x);\n  rotateY(p, angles.y);\n  rotateZ(p, angles.z);\n}\n\nvoid translate(inout vec3 p, vec3 t) {\n  p += t;\n}\n\nstruct hitData {\n  float distance;\n  vec3 hitColor;\n  bool canReflect;\n};\n\nhitData minhitData(hitData a, hitData b) {\n  if (a.distance < b.distance) return a;\n  return b;\n}\n\nfloat sdfBox(vec3 point, vec3 size) {\n  vec3 d = abs(point) - size;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdfPlane(vec3 p) {\n  return p.y;\n}\n\nfloat sdf_mengerb5c5e786_7b59_439b_9b77_49b133c6f47e(vec3 p) {\n    vec3 t = vec3(1.5 + cos(iTime * 1.0) * 0.8, 1.0, 1.0);\n\n    for (int i = 0; i < 3; i++) {\n        fa(p);\n        fm(p);\n        scale(p, 3.0);\n        translate(\n            p,\n            t * vec3(-2.0, -2.0, 0.0)\n        );\n        fp(\n            p,\n            vec3(0.0, 0.0, -1.0),\n            t.x * -1.0\n        );\n    }\n \n\n    return sdfBox(p, vec3(1.5 + cos(iTime * 1.0) * 0.8, 1.0, 1.0)) / 27.0;\n\n}\n\nhitData sdf_sphere_7064d573_52bb_4c0f_8c8f_9d1962bfa45d(vec3 p) {\n  vec3 o = p;\n\n  hitData res;\n  hitData res2;\n  res = hitData(sdfSphere(p, 1.4) / 1.0, vec3(0.0667, 0.5843, 0.7294), false);\n\n  return res;\n\n}\n\nhitData sdf_menger_78a3d364_8ac6_4348_b521_a04e36c86545(vec3 p) {\n  vec3 o = p;\n  rotate(p, vec3(0.0, 0.0, 0.0) + cos(iTime * 0.5) * vec3(2.0, 2.0, 2.0));\n\n  hitData res;\n  hitData res2;\n  res = hitData(\n    sdf_mengerb5c5e786_7b59_439b_9b77_49b133c6f47e(p) / 1.0,\n    vec3(0.4431, 0.6627, 0.7216),\n    false\n  );\n\n  res2 = sdf_sphere_7064d573_52bb_4c0f_8c8f_9d1962bfa45d(o);\n  if (res.distance < res2.distance) res = res2;\n\n  return res;\n\n}\n\nhitData sdf_plane_c72c613d_1c9b_408b_b88a_b63bfcc53acb(vec3 p) {\n  vec3 o = p;\n  inverseTranslate(p, vec3(0.0, 0.0, 0.0));\n  translate(p, vec3(0.0, 3.0, 0.0));\n\n  hitData res;\n  hitData res2;\n  res = hitData(\n    sdfPlane(p) / 1.0,\n    mod(p.x * 3.0, 2.0) <= 1.0 ^^ mod(p.z * 3.0, 2.0) >= 1.0\n      ? vec3(0.0667, 0.0588, 0.0588)\n      : vec3(0.5059, 0.4784, 0.4784),\n    false\n  );\n\n  return res;\n\n}\n\nhitData sdf(vec3 p) {\n  hitData res = sdf_menger_78a3d364_8ac6_4348_b521_a04e36c86545(p);\n\n  res = minhitData(res, sdf_plane_c72c613d_1c9b_408b_b88a_b63bfcc53acb(p));\n\n  return res;\n}\n\nvec3 calcNormal(vec3 pos) {\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n  return normalize(\n    e.xyy * sdf(pos + e.xyy).distance +\n      e.yyx * sdf(pos + e.yyx).distance +\n      e.yxy * sdf(pos + e.yxy).distance +\n      e.xxx * sdf(pos + e.xxx).distance\n  );\n}\n\nvec3 normal(vec3 point) {\n  const vec3 smallStep = vec3(0.00001, 0, 0);\n\n  return normalize(\n    vec3(\n      sdf(point + smallStep.xyy).distance - sdf(point - smallStep.xyy).distance,\n      sdf(point + smallStep.yxy).distance - sdf(point - smallStep.yxy).distance,\n      sdf(point + smallStep.yyx).distance - sdf(point - smallStep.yyx).distance\n    )\n  );\n}\n\nhitData raymarch(vec3 rayOrigin, vec3 rayDirection) {\n  float distance = 0.0;\n  float maxDistance = 50.0;\n  float minHitDistance = 0.001;\n\n  for (int i = 0; i < 256; i++) {\n    if (distance > maxDistance) break;\n\n    vec3 pos = rayOrigin + rayDirection * distance;\n\n    hitData res = sdf(pos);\n\n    if (res.distance < minHitDistance)\n      return hitData(distance + res.distance, res.hitColor, res.canReflect);\n\n    distance += res.distance;\n  }\n\n  return hitData(-1.0, vec3(0.0), false);\n}\n\nfloat ambientOcc(vec3 point, vec3 normal) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = sdf(point + h * normal).distance;\n    occ += (h - d) * sca;\n    sca *= 0.95;\n    if (occ > 0.35) break;\n  }\n  return c01(1.0 - 3.0 * occ) * (0.5 + 0.5 * normal.y);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n  for (int i = 0; i < 256; i++) {\n    float h = sdf(ro + rd * t).distance;\n\n    if (t > tmax) return res;\n    if (h < 0.001) return 0.0;\n    res = min(res, 18.0 * h / t);\n    t += h;\n  }\n  return res;\n}\n\nvec3 spotlight(\n  vec3 rayDirection,\n  vec3 normal,\n  vec3 point,\n  vec3 baseColor,\n  vec3 lightPos,\n  vec3 lightColor,\n  float shininess\n) {\n  vec3 lightDir = normalize(lightPos - point);\n  vec3 hal = normalize(lightDir - rayDirection);\n  float diffuse = dot(normal, lightDir);\n  diffuse = c01(diffuse);\n  diffuse *= ambientOcc(point, normal);\n  diffuse *= shadow(point, lightDir, 0.02, 2.5);\n\n  float pho = c01(pow(dot(normal, hal), shininess));\n  float spe = pho * diffuse * 0.3;\n\n  return baseColor * 2.2 * diffuse * lightColor + 5.0 * spe * lightColor * 0.4;\n}\n\nvec3 lightning(\n  float distance,\n  vec3 col,\n  vec3 point,\n  vec3 rayDirection,\n  vec3 rayOrigin,\n  vec3 normal\n) {\n  vec3 newColor = col;\n\n  newColor += spotlight(\n    rayDirection,\n    normal,\n    point,\n    col,\n    vec3(10.0, 10.0, 0.0),\n    vec3(0.4, 0.8314, 0.9294),\n    32.0\n  );\n\n  newColor += spotlight(\n    rayDirection,\n    normal,\n    point,\n    col,\n    vec3(0.0 + cos(iTime * 1.0) * 1.0, 13.0, 0.0 + sin(iTime * 1.0) * 1.0),\n    vec3(0.4, 0.8314, 0.9294),\n    32.0\n  );\n\n\n  newColor /= 3.;\n  vec3 distanceColor = vec3(0.0314, 0.1373, 0.4039);\n  float distanceColorIntensity =\n    1.0 - exp(-0.0001 * distance * distance * distance);\n  return mix(newColor, vec3(0.0314, 0.1373, 0.4039), distanceColorIntensity);\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection) {\n  vec3 col = vec3(0.);\n\n  hitData hit = raymarch(rayOrigin, rayDirection);\n\n  if (hit.distance > 0.0) {\n    vec3 point = rayOrigin + rayDirection * hit.distance;\n    vec3 normal = calcNormal(point);\n    col = hit.hitColor;\n    col = lightning(hit.distance, col, point, rayDirection, rayOrigin, normal);\n  }\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime / 25.0 * 1.5;\n\n    float camspeed = 7.0;\n    vec3 ta = vec3(0.);\n    vec3 ro = vec3(\n        4.9 * cos(time * camspeed),\n        3.0,\n        4.9 * sin(time * camspeed)\n    );\n\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(sin(.0), cos(.0), 0.0)));\n    vec3 cu = normalize(cross(cs, cf));\n\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(p.x * cs + p.y * cu  + 2.5 * cf);\n\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(1.0/2.2)) ;\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}