{
    "Shader": {
        "info": {
            "date": "1408490004",
            "description": "Experiment in marching emissive media, to try to get something fast enough to run full screen.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xs2SzR",
            "likes": 52,
            "name": "Nebula Flight",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 4777
        },
        "renderpass": [
            {
                "code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float tau = 6.28318530717958647692;\n\n#if ( 1 ) // is hash noise or texture noise faster?\n\n// texture noise\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n#else\n\n// hash noise adapted from IQ\nfloat hash( vec3 p )\n{\n\tfloat h = dot(p,vec3(127.1,311.7,201.3));\n\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix(mix( mix( hash( i + vec3(0,0,0) ), \n                         hash( i + vec3(1,0,0) ), u.x),\n                    mix( hash( i + vec3(0,1,0) ), \n                         hash( i + vec3(1,1,0) ), u.x), u.y),\n               mix( mix( hash( i + vec3(0,0,1) ), \n                         hash( i + vec3(1,0,1) ), u.x),\n                    mix( hash( i + vec3(0,1,1) ), \n                         hash( i + vec3(1,1,1) ), u.x), u.y), u.z );\n}\n\nvec2 Noise( in vec3 x )\n{\n    return vec2( noise(x), noise(x.zxy) );\n}\n\n#endif\n\n\nvec4 Density( vec3 pos )\n{\n    pos /= 30.0;\n    vec2 s = vec2(0);\n\ts += Noise(pos.xyz/1.0)/1.0;\n\ts += Noise(pos.zxy*2.0)/2.0;\n\ts += Noise(pos.yzx*4.0)/4.0;\n\ts += Noise(pos.xzy*8.0)/8.0;\n    \n    s /= 2.0-1.0/8.0;\n    \n    s.y = pow(s.y,5.0)*1.0;\n    \n    //s.y *= smoothstep( 2.5, .0, length(pos) );\n    \n    return vec4(pow(sin(vec3(1,2,5)+tau*s.x)*.5+.5,vec3(1.0))*16.0,s.y);\n}\n\n\nvec3 Path( float time )\n{\n    // sort of like a spirograph pattern, but more random\n    time *= .2;\n    vec2 a = vec2(1,.3)*time;\n    float r = sin(time*1.2)*.2+.8;\n    \n    return 100.0*r*vec3(cos(a.x),1,sin(a.x))*vec2(cos(a.y),sin(a.y)).xyx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime;\n    \n    // create a camera without constant \"up\", so we get more spacey feel and more variety\n    \n    // fly a \"plane\", with a free camera inside it\n    // i.e. \"up\" stays in the plane of the curve\n    \n    \n    vec3 pos = Path(T);\n    \n    float d = .5;\n    vec3 a=Path(T+d), b=Path(T-d);\n    vec3 sky = (a+b)/2.0-pos;\n\n    // alternate between looking forward and looking toward centre of nebula, for parallax\n    vec3 forward = normalize( mix( normalize(a-b), normalize(vec3(0)-pos), smoothstep( -.2, .2, sin(T*.2) ) ) );\n    vec3 right = normalize(cross(sky,forward));\n    vec3 up = normalize(cross(forward,right));\n    \n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    vec3 ray = forward*1.0 + right*uv.x + up*uv.y;\n    ray = normalize(ray);\n    \n    vec3 c = vec3(0,0,0);\n\tfloat t = 0.0;\n    float baseStride = 3.0; // small enough to detect the highest frequency details\n    float stride = baseStride;\n    float visibility = 1.0;\n    for ( int i=0; i < 30; i++ )\n    {\n        if ( visibility < .001 ) break; // causes \"ripples\" on things, but not bad.\n        \n        vec4 samplev = Density( pos + t*ray );\n        float visibilityAfterSpan = pow( 1.0-samplev.a, stride );\n\n\t\t// optional: don't allow any non-occluding glow\n        samplev.rgb *= samplev.a;\n\n        c += samplev.rgb*visibility*(1.0-visibilityAfterSpan); // this seems too easy!\n        visibility *= visibilityAfterSpan;\n\n//        float newStride = baseStride/visibility; // this is wrong, but looks amazing!\n        float newStride = baseStride/mix(1.0,visibility,.3); // step further when visibility is reduced (but not too much\n        t += (stride+newStride)*.5;\n        stride = newStride;\n    }\n    \n    c = pow(c,vec3(1.0/2.2));\n    \n    // dithering, because I can see banding\n    c += (texture(iChannel1,(fragCoord.xy+.5)/8.0,-100.0).x-.5)/256.0;\n    \n\tfragColor = vec4(c,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}