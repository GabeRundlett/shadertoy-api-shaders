{
    "Shader": {
        "info": {
            "date": "1695117384",
            "description": "Thoses are not voxels by any mean, but a bunchs of rounded boxes elongated along Y axis with domain repetition, its makes it able to have smooth heights variation while keeping a voxely feelings. Enjoy :)\nIqs voronoi: https://www.shadertoy.com/view/ldl3W8",
            "flags": 32,
            "hasliked": 0,
            "id": "csccW7",
            "likes": 49,
            "name": "Pixel Cavern",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 1,
            "username": "rcargou",
            "viewed": 642
        },
        "renderpass": [
            {
                "code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nvec2 guv;\nvec4 id = vec4(0.);\nvec2 map( in vec3 pos )\n{\n   \n //pos=abs(pos);\n// pos.xy*=rotate2d(iTime / 5.);\n //pos.xy=abs(pos.xy);\n     pos.x+=3.1;\n          \n     float sh = sin(pos.z / 12. + iTime) * 4.;\n     pos.y+= sh;\n\n\n     pos.xy *= rotate2d(-(pos.z) * .1 *   .02);\n vec3 p2 = pos;\n    vec2 res = vec2( 1e10, 0.0 ); pos.z+=iTime * 43.5;\n    vec2 uv = pos.xz;\n    uv.y += step(.0, pos.y) * 200.;\n    uv.x += step(.0, pos.y) * 200.;\n\n    guv = uv;\n     \n    //pos.y += pos.z / 3.;\n    pos.y+=.0;\n   \n    pos.y = abs(pos.y - .0);\n    id.x = pow((pos.y - sh), 1.) / 16.;\n   //pos.y*=-1.;\n    float d = 35.+ 5.*sin(iTime);;\n    float dd = 7.;\n id.z = 1.*smoothstep(d-dd,d, pos.y) * smoothstep(d+dd,d, pos.y);\n\n    pos.y-=0.5;\n    float r = 1.3;// + abs(sin(iTime ));\n    float s = r/2.;\n    id.y = hash22(floor(pos.xz / r)).x;\n   \n    float off = 0.;\n    if (mod(floor(id.y * 121.), 32.) == 1.)\n        off = 0.2; \n    pos.xz = mod(pos.xz, r) - r/ 2.;\n    float s2= 2.;\n\n    \n    pos.y -= 33.5 + 5.*sin(iTime);\n    //pos.xy /= 4.5;\n    //r = 1.;\n    float f = 1.;\n    float h = 5.*(texture(iChannel0, vec2(iTime / 64.,0.)+f*(floor((uv.xy) / r) * r)  / 522. - vec2(.5)).x + .0);\n    float h2 = 1.25*(texture(iChannel2, 1.5*f*(floor((uv.xy) / r) * r)  / 522. - vec2(.5)).x + .0);\n    float r2 = 11.;\n    vec2 pp = mod(guv, r2) - r2/2.;\n   // h += 2.*smoothstep(5., 1., .6*length(pp));\n    float quant = 15.;\n    //h2=pow(h2, 2.) / 4.;\n  \n    h = .5*(h+pow(h/2., 2.)) + off;\n    float beat = pow( abs(sin(iTime / 1.)), 3.);\n    h = .1+5.*floor(h * quant) / quant + (h2*2.) * beat;\n    // h = pow(h, 1.05);\n    //id.x =h / 8.;//\n    if ((res.x = box(pos, vec3(s, h, s), .2)) < .0f )\n        res.y = 1.0f;\n\n    return res;\n}\n\nconst float maxHei = 0.8;\nfloat hit = 0.;\nfloat hidist = .1;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 2000.0;\n    float lastid = -1.;\n   // float id;\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<100 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t);\n            \n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            } else if( abs(h.x)<(0.002*t) && id.y != lastid)\n            { \n            \n///                hit =1.;\n            }\n            t += h.x * .5;\n            lastid = id.y;\n        }\n    }\n\n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec3 getLight(vec3 p) {\n    float r = 30.;\n  //  return vec3(mod(p.x, 12.), 0., 90. + cos(iTime / 2.) * 172.);\n    return vec3(floor( (p.x +r/2.) / r) * r  + sin(iTime), 0., 120. + cos(iTime / 2.) * 122.);\n}\n\nvec3 light(vec3 p, vec3 rd, vec3 n, vec3 lightPos, vec3 lightCol) {\n    \n    float radius = .003;\n    float l = length(lightPos - p);\n    float ndotl = max(0., dot(n, normalize(lightPos - p)) );\n    return lightCol * ndotl / max(1., l*l*radius);\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n) {\n    return light(p, rd, n, getLight(p), 1.*vec3(.9, .1, .84));\n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    float bloom = 0.;\n    vec3 col = vec3(.0f);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 p = ro + res.x * rd;\n    vec3 n = calcNormal(p);\n    float ao = calcAO(p,n); \n    vec3 albedo = texture(iChannel2, guv/ 2. + p.y).xyz;\n    vec3 pminusl = normalize(-p-normalize(vec3(11.0f, 11.0f, 0.0f)));\n    vec3 bg = 1.*vec3(1.13, .54, 2.3);\n    float shadow = 1.;//.5+.5*calcSoftshadow(p, normalize(vec3(.0f, .0f, -1.0f)), .1, 5.);\n    vec3 ref = reflect(normalize(p-ro), n);\n    float spec = pow(max(0., dot(ref, vec3(.0f, .0f, -1.0f)) ), 5.) * .5;\n    albedo = vec3(.5);\n\n    float v = .8*voronoi(.01*guv.xy + vec2(0. + -iTime / 8., 0.), iTime / 2.).y * 1.1;\n    albedo = .5*pal( id.x+iTime/12. + guv.y / 200., vec3(0.5,0.5,.5),vec3(0.5,0.5,0.5),vec3(.5,.5,.5),vec3(0.0,0.33,0.67) );\n    vec3 albedo2 = .5*pal( id.x-iTime/6., vec3(0.5,0.51,0.5),vec3(0.1,0.5,0.2),vec3(.2,1.,.2),vec3(0.0,0.33,0.67) );\n   vec3 reff = reflect(rd, n);\n   \n   vec3 refcol = texture(iChannel1, reff.xz / 2.).xyz;\n\n   if (mod(floor(id.y * 121.), 32.) == 1.) {\n \n       albedo*=5.;\n       bloom = 10.;\n       \n       }\n\n   //ao=.1;\n   \n    col = bg;\n    if (res.x > .0f) {\n    \tcol = vec3(ao/5.) + 1.*shadow*albedo * max(.1, dot(pminusl, \n                             calcNormal(ro + rd*t)) );\n        col *= vec3(0.5);                         \n         //col += lights(p, rd,n);\n         col+=bg*spec;\n          col += albedo2*id.z / 1.2;\n        col*=1.5+(v*v*v/.01) * albedo;\n        //col=pow(refcol * vec3(.2,.2,.7),vec3(2.) ) * 2.;\n       // col += vec3(pow(id.w, .5)) * vec3(0., 1., 0.);\n        col = mix(col, bg, min(1., pow(res.x / 450., 1.5) ));\n        \n        bloom += id.z * 10.;\n        //col *= 1.+ smoothstep(1.2, 2.5, abs( p.y - .1) ) ;\n       \n                      }    \n    // return albedo;\n    //return vec3(id.w);\n   \treturn vec3(col);\n    return abs(n / 10.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, -sin(iTime) / 15., -0.0f);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0., 0.5, .5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = normalize( vec3(p.xy,.5) ) * ca;\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col / 1., vec3(.8545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\tvec2 q = fragCoord / iResolution.xy;\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 1.5 );\n   // tot = vec3(voronoi(p.xy*8., iTime));\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 hash22( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\nvec3 voronoi( in vec2 x , float time)\n{\n\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash22( n + g );\n\t\n        o = 0.5 + 0.5*sin( time + 6.2831*o );\n    \n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash22( n + g );\n\n        o = 0.5 + 0.5*sin( time + 6.2831*o );\n\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( 1.1-pow(md,.1));\n    return vec3( md, mr );\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat box(vec3 position, vec3 halfSize, float cornerRadius) {\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(max(position.x, position.y), position.z), 0.0) - cornerRadius;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvec3 helix(vec2 uv) {\n        // Normalized pixel coordinates (from 0 to 1)\n    float time = iTime *.4;\n    uv.x *= cos(uv.y*2.14f);\n    uv.x += sin(time * .9f) *.07f;\n    vec3 col = vec3(.0f);\n    uv *= 1.0f;\n    float i = .0f;\n      //float music = texture(iChannel0, vec2(.17f, .25f)).x;\n    float m = texture(iChannel1, vec2(.5f)).y;\n    float m1 = texture(iChannel1, vec2(.5f)).x;\n   \n    float l = mod(length(uv) + time /10.0f, 0.1f + 0.002f) +0.00f;\n    float k = floor(length(uv)*10.0f + + time / 0.7f) ;\n    \n       float a = atan(uv.y, uv.x) + sin(length(uv * 7.0f * sin(time) * sin(time))  * 1.0f);\n   // col = col * .5f + .41f * length(cos(a * 4.0f));\n    float level = 20.0f + floor(length(uv) * 10.0f);\n    level = 5.0f;\n    float h = 1.0f + cos(time*5.0f + a * level);\n    h = pow(h, 1.0f + 0.5f*m);\n    float b = length(l- 0.05f);\n   // b = pow(b, h/4.0f) / 50.0f;\n \n   col.xz +=  vec2(b*b*400.0f, b*b*200.0f);\n    col.gb +=  .5f * vec2(.5f*pow(b*b*400.0f, (1.0f + sin(time)) * 100.5f * h / (m*m)));\n    col.y +=  b*10.0f;\n    col.z += b*b*b*8000.0f*m*m*m;\n   //  col.y = l / 10.0f;\n    col.x *= h;\n    float beta = min(floor((1.0f - .5f*pow(h*h*b*b*400.0f, 10.5f * 1.0f))) * .1f * (2.5f +sin(time * 20.0f + 10.0f*length(uv))), 100.8f);\n   beta = max(beta , .0f);\n    beta *= beta * beta * m;\n    col.rgb +=2.0f *  vec3(0.8, .8f, .0f) * vec3(max(beta, .0f));\n//col.x += 1.0f / length();\n    col.g /= min(2.0f, 10.1f * (length(uv)));\n    return (col * 1.2f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(.0f);\n    for (float i = 0.0f; i < 1.0f; i += 1.0f) {\n\t\tvec2 uv = ((vec2(.0f * i) + fragCoord) - iResolution.xy /2.0f)/iResolution.yy;\n   \n    \t\tcol += helix(uv / (1.2f  + .5f + sin(0.0f / 2.0f)));\n    \n    }\n    \n    fragColor = vec4(col / 1.0f,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}