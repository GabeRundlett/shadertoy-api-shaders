{
    "Shader": {
        "info": {
            "date": "1636030842",
            "description": "make \"sdEllipticTorus\" by mixing iq's 2D ellipses.\nhttps://www.shadertoy.com/view/4sS3zz\nhttps://iquilezles.org/articles/ellipsoids/ellipsoids.htm\n",
            "flags": 48,
            "hasliked": 0,
            "id": "7tdGDr",
            "likes": 9,
            "name": "Maptoy - sdEllipticTorus",
            "published": 3,
            "tags": [
                "maptoy",
                "sdelliptictorus"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 1\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 1.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n#if 0\n// Ellipse - distance 2D\n// https://www.shadertoy.com/view/4sS3zz\nfloat msign(in float x) { return (x<0.0)?-1.0:1.0; }\n\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n    if( ab.x==ab.y ) return length(p)-ab.x;\n\tp = abs( p ); \n    if( p.x>p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2+n2-1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float d = c3 + m2*n2;\n    float q = d  + m2*n2;\n    float g = m  + m *n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h) + 2.0;\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt( m2-c*(s+t) );\n        float ry = sqrt( m2-c*(s-t) );\n        co = ry + sign(l)*rx + abs(g)/(rx*ry);\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt(d);\n        float s = msign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float t = msign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -(s+t) - c*4.0 + 2.0*m2;\n        float ry =  (s-t)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = ry/sqrt(rm-rx) + 2.0*g/rm;\n    }\n    co = (co-m)/2.0;\n\n    float si = sqrt( max(1.0-co*co,0.0) );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * msign(p.y-r.y);\n}\n#else\n// \"Apply General SDF to Ellipse\" by IWBTShyGuy:\n// https://www.shadertoy.com/view/fsSSzG\nconst int DIV = 50;\nconst int BISECTIONMAX = 10;\n\nconst float PARAM_MIN = -3.141592653;\nconst float PARAM_MAX = 3.141592653;\n\nvec2 curve(in float t, in vec2 ab) {\n    return vec2(ab.x * cos(t), ab.y * sin(t));\n}\n\nvec2 derive(in float t, in vec2 ab) {\n    return vec2(-ab.x * sin(t), ab.y * cos(t));\n}\n\n// Roughly find the parameter hint that minimizes the distance between p and curve(hint).\nfloat rough(in vec2 p, in vec2 ab) {\n    float hint = 0.0, mdist = 10.0;\n    for (int i = 0; i <= DIV; i++) {\n        float t = (PARAM_MAX - PARAM_MIN) * float(i) / float(DIV) + PARAM_MIN;\n        float dist = distance(curve(t, ab), p);\n        mdist = min(dist, mdist);\n        hint = t + sign(dist - mdist) * (hint - t);\n    }\n    return hint;\n}\n\n// Find the critical parameter t of the signed distance between p and curve(t) by the bisection method.\nfloat precise(in vec2 p, in vec2 ab) {\n    float hint = rough(p, ab);\n    float t0 = hint - (PARAM_MAX - PARAM_MIN) / float(DIV);\n    float t1 = hint + (PARAM_MAX - PARAM_MIN) / float(DIV);\n    for (int i = 0; i < BISECTIONMAX; i++) {\n        float f0 = dot(derive(t0, ab), curve(t0, ab) - p);\n        float t = (t0 + t1) / 2.0;\n        float f = dot(derive(t, ab), curve(t, ab) - p);\n        t0 = t0 + max(sign(f * f0), 0.0) * (t - t0);\n        t1 = t1 - min(sign(f * f0), 0.0) * (t - t1);\n    }\n    return (t0 + t1) / 2.0;\n}\n\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    float t = precise(p, ab);\n    vec2 c = curve(t, ab);\n    vec2 d = derive(t, ab);\n    float s = sign((p.x - c.x) * d.y - (p.y - c.y) * d.x);\n    return s * distance(p, c);\n}\n#endif\n\nfloat sdEllipticTorus( vec3 p, vec2 t1, vec2 t2 )\n{\n    vec2 r = vec2(sdEllipse(p.xz, t1), p.y);\n    float k0 = length(r/t2);\n    float k1 = length(r/(t2*t2));\n    return sdEllipse(r, t2);//k0*(k0-1.)/k1;\n}\n\n\nfloat sdEllipticTorus2( vec3 p, vec2 t1, vec2 t2 )\n{\n    float majorK0 = length(p.xz/t1);\n    float majorK1 = length(p.xz/(t1*t1));\n    vec2 r = vec2(majorK0*(majorK0-1.)/majorK1, p.y);\n    float minorK0 = length(r/t2);\n    float minorK1 = length(r/(t2*t2));\n    return minorK0*(minorK0-1.)/minorK1;\n}\n\nfloat map(vec3 p){\n    vec3 q = p;\n    vec2 anim = vec2(max(0.,sin(iTime)), max(0.,cos(iTime*2.))) * vec2(1., .25);\n    vec2 anim2 = vec2(max(0.,sin(iTime*.5)), max(0.,cos(iTime*1.))) * vec2(1., .25);\n    vec2 t1 = vec2(.3+anim2.x, .3+anim.x);\n    vec2 t2 = vec2(.1+anim2.y, .1+anim.y);\n    \n    //if(sin(iTime*2.*PI)>0.)\n        return sdEllipticTorus(q, t1, t2);\n    //else\n        //return sdEllipticTorus2(q, t1, t2);\n}\n\nrender();\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n// https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n// https://www.shadertoy.com/view/3dVXDc\n// Gradient noise by iq (modified to be tileable)\nfloat gnoise(vec3 x, float freq)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\nfloat voronoi(in vec2 st, in float scl, in float speed, inout vec2 id){\n\tfloat res=1.*scl;\n\tst = u2s(st)*scl;\n\tvec2 ist = floor(st);\n\tvec2 fst = fract(st);\n\tfor(float y=-1.; y<=1.; y+=1.){\n\t\tfor(float x=-1.; x<=1.; x+=1.){\n\t\t\tvec2 gridOffset = vec2(x,y);\n\t\t\tvec2 rnd = hash22(ist+gridOffset+speed*.5);\n\t\t\tfloat d = distance(st, ist+gridOffset+rnd);\n\t\t\tif(d<res){\n\t\t\t\tres = d;\n\t\t\t\tid = rnd;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nfloat voronoi(in vec3 st, in float scl, in float speed, inout vec3 id){\n\tfloat res=1.*scl;\n\tst = u2s(st)*scl;\n\tvec3 ist = floor(st);\n\tvec3 fst = fract(st);\n\tfor(float z=-1.; z<=1.; z+=1.){\n\t\tfor(float y=-1.; y<=1.; y+=1.){\n\t\t\tfor(float x=-1.; x<=1.; x+=1.){\n\t\t\t\tvec3 gridOffset = vec3(x,y,z);\n\t\t\t\tvec3 rnd = hash33(ist+gridOffset+speed*.5);\n\t\t\t\tfloat d = distance(st, ist+gridOffset+rnd);\n\t\t\t\tif(d<res){\n\t\t\t\t\tres = d;\n\t\t\t\t\tid = rnd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\nfloat gfbm(vec3 n, int rep, float pers){\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < rep; ++i)\n    {\n        noise += amp * gnoise(n * pers, pers);\n        pers *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat SMinC3(float a, float b, float r)\n{\n    float n = max(0.0, 1.0 - abs(a - b) / r);\n    \n    float o = (0.25 - n*0.1) * ((n*n)*(n*n));\n    \n    return min(a, b) - o*r;\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n\tvec2 u = max(vec2(r + b,r + -a), vec2(0));\n\treturn min(-r, max (b, -a)) + length(u);\n}\n\nfloat voronoiSmooth(vec2 p, float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float res = 8.;\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    {\n        vec2 b = vec2(j,k);\n        vec2 r = b-f+hash22(i+b);\n\n        float d = length( r );\n        res = SMinC3( res, d, s );\n    }\n    return res;\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}