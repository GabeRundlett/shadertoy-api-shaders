{
    "Shader": {
        "info": {
            "date": "1472964609",
            "description": "LSystem without a stack. Root to leave traversal plus pruning.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtyGR1",
            "likes": 100,
            "name": "L System",
            "published": 3,
            "tags": [
                "2d",
                "lsystem"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 4216
        },
        "renderpass": [
            {
                "code": "// Fixed and optimized version of sillsm's shader (https://www.shadertoy.com/view/XtyGzh)\n\n\n// Copyright Max Sills 2016, licensed under the MIT license.\n//\n// Inspired by Knighty's using base n encodings to explore\n// n-ary IFS. Bounding volumes are trash.\n\n\n// iq: I fixed and optimized the original shader. The idea of recursing a tree without a stack \n// is a really good one. In the context of raymarching, the pruning can be done also based on a \n// screen space pixel coverage threshold, but it's still too slow (tried a few months ago for \n// bushes). Still, I made this variation on sillsm's shader for bug fixing it and for further study.\n//\n// Enable the define below in order to see the true distance field (very slow).\n\n\n//#define TRUE_DISTANCE\n\n\n#define kDepth 7\n#define kBranches 3\n#define kMaxDepth 2187 // branches ^ depth\n\n//--------------------------------------------------------------------------\n\nmat3 matRotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3( c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 matTranslate( float x, float y )\n{\n    return mat3( 1, 0, 0, 0, 1, 0, -x, -y, 1 );\n}\n\nfloat sdBranch( vec2 p, float w1, float w2, float l )\n{\n    float h = clamp( p.y/l, 0.0, 1.0 );\n\tfloat d = length( p - vec2(0.0,l*h) );\n    return d - mix( w1, w2, h );\n}\n\n//--------------------------------------------------------------------------\n\nfloat map( vec2 pos )\n{\n    const float len = 3.2;\n    const float wid = 0.3;\n    const float lenf = 0.6;\n    const float widf = 0.4;\n    \n    float d = sdBranch( pos, wid, wid*widf, len );\n    \n    int c = 0;\n    for( int count=0; count < kMaxDepth; count++ )\n    {\n        int off = kMaxDepth;\n    \tvec2 pt_n = pos;\n        \n        float l = len;\n        float w = wid;\n        \n      \tfor( int i=1; i<=kDepth; i++ )\n      \t{\n            l *= lenf;\n            w *= widf;\n\n            off /= kBranches; \n            int dec = c / off;\n        \tint path = dec - kBranches*(dec/kBranches); //  dec % kBranches\n          \n            mat3 mx;\n\t    \tif( path == 0 )\n           \t{\n\t\t  \t\tmx = matRotate(0.75 + 0.25*sin(iTime-1.0)) * matTranslate( 0.0,0.4*l/lenf);\n\t    \t}\n        \telse if( path == 1 )\n            {\n          \t\tmx = matRotate(-0.6 + 0.21*sin(iTime)) * matTranslate(0.0,0.6*l/lenf);\n\t    \t}\n\t    \telse\n            {\n          \t\tmx = matRotate(0.23*sin(iTime+1.)) * matTranslate(0.0,1.0*l/lenf);\n\t    \t}\n            pt_n = (mx * vec3(pt_n,1)).xy;\n\n            \n        \n        \t// bounding sphere test\n            float y = length( pt_n - vec2(0.0, l) );\n            #ifdef TRUE_DISTANCE\n            if( y-1.4*l > d   ) { c += off-1; break; }\n            #else\n       \t\tif( y-1.4*l > 0.0 ) { c += off-1; break; }\n            #endif\n\n            \n            d = min( d, sdBranch( pt_n, w, w*widf, l ) );\n     \t}\n        \n    \tc++;\n    \tif( c > kMaxDepth ) break;\n\t}\n    \n   \treturn d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinate system\n    vec2  uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    // frame in screen\n    uv = uv*4.0 + vec2(0.0,3.5);\n    px = px*4.0;\n   \n    \n    // compute\n    float d = map( uv );\n    \n    \n    \n    // shape\n    vec3 cola = vec3( smoothstep( 0.0, 2.0*px, d ) );\n    \n    // distance field\n    vec3 colb = vec3( pow(abs(d),0.4)*0.5 + 0.015*sin( 40.0*d ) );\n    \n   \t// derivatives\n    #if 1\n        vec2 der = vec2( dFdx(d), dFdy(d) )/px;\n    #else\n        float eps = 0.1/iResolution.y;\n        vec2 der = vec2( map(uv+vec2(eps,0.0))-d,map(uv+vec2(0.0,eps))-d) /eps;\n    #endif\n    vec3 colc = vec3(0.5+0.5*der.x,0.5+0.5*der.y,0.0) * clamp(abs(d)*8.0+0.2,0.0,1.0);\n      \n\n    // final color\n    float t = fract( 0.2 + iTime/11.0 );    \n    \n    vec3 col = mix( colc, cola, smoothstep( 0.00, 0.05, t ) );\n         col = mix( col , colb, smoothstep( 0.30, 0.35, t ) );\n         col = mix( col , colc, smoothstep( 0.60, 0.65, t ) );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}