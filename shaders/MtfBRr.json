{
    "Shader": {
        "info": {
            "date": "1512088110",
            "description": "This is a generative 3d world using sdf function from iq",
            "flags": 0,
            "hasliked": 0,
            "id": "MtfBRr",
            "likes": 4,
            "name": "generative world",
            "published": 3,
            "tags": [
                "generativeart"
            ],
            "usePreview": 0,
            "username": "qq456cvb",
            "viewed": 610
        },
        "renderpass": [
            {
                "code": "const int NUM_STEPS = 40;\nconst float CELL_SIZE = 0.3;\nconst float RADIUS = 0.1;\nconst float EPSILON = 1e-3;\n\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.647, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 INDIGO = vec3(0.0, 0.5, 1.0);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\nconst vec3 PURPLE = vec3(0.45, 0.0, 1.0);\n\n\n// reference: https://www.shadertoy.com/view/Xds3zN\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ),  u.x), u.y);\n}\n\n// polynomial smooth min (k = 0.1) from iq;\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat opRepSphere( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q, RADIUS );\n}\n\nfloat opRepTorus( vec3 p, vec3 c, vec2 t )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdTorus( q, t );\n}\n\nfloat opRepEllipsoid( vec3 p, vec3 c, vec3 r )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdEllipsoid( q, r );\n}\n\nfloat opRepTriPrism( vec3 p, vec3 c, vec2 h )\n {\n    vec3 q = mod(p,c)-0.5*c;\n    return sdTriPrism( q, h );\n}   \n\nfloat hash3d( vec3 p ) {\n    float h = dot(p,vec3(1.127,3.117, 2.038));\t\n    return fract(sin(h)*71451.5453123);\n}\n\nmat2 rot( float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat noise3d( in vec3 p ) {\n    vec3 idx = vec3(fract(sin(dot(p / 0.3, vec3(2.5,3.46,1.29))) * 12394.426),\n                   fract(sin(dot(p / 0.17, vec3(3.987,2.567,3.76))) * 52422.82465),\n                   fract(sin(dot(p / 0.44, vec3(6.32,3.87,5.24))) * 34256.267));\n    //p.z *= p.z;\n    //p.y *= p.y;\n    //p.z = mix(p.y, p.z, idx.x * (1.0 - idx.y));\n    p.xz = mod(p.xz - 0.5 * CELL_SIZE, vec2(CELL_SIZE));\n    p.xz = rot(fract(sin(dot(idx.xz, vec2(3.124,1.75)))) * 312.2) * p.xz;\n    float s = hash3d(1e4 * p + idx);\n    return s;\n}\n\nvec3 colorLookup( in vec3 p ) {\n    float freq = 1e-7;\n    float f = noise3d(p * freq);\n    if (f < 1.0 / 7.0) return RED;\n    if (f < 2.0 / 7.0) return ORANGE;\n    if (f < 3.0 / 7.0) return YELLOW;\n    if (f < 4.0 / 7.0) return GREEN;\n    if (f < 5.0 / 7.0) return INDIGO;\n    if (f < 6.0 / 7.0) return BLUE;\n    return PURPLE;\n}\n\nfloat map (in vec3 p) {\n    float sdf = opRepSphere(p, vec3(0.3));\n    sdf = smin(sdf, opRepTorus(p, vec3(0.4), vec2(0.08, 0.05)), 0.02);\n    sdf = smin(sdf, opRepEllipsoid(p, vec3(0.26), vec3(0.03, 0.03, 0.08)), 0.02);\n    sdf = smin(sdf, opRepTriPrism(p, vec3(0.13), vec2(0.02, 0.02)), 0.04);\n    return sdf;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n                \nfloat sdf( in vec3 p, out vec3 norm ) {\n    vec3 f = mod(p, CELL_SIZE);\n    norm = normalize(f - vec3(CELL_SIZE / 2.0));\n    return distance(f, vec3(CELL_SIZE / 2.0)) - RADIUS;\n}\n\n\nbool interSect( vec3 ro, vec3 rd, out vec3 p ) {\n    float t = 0.0;\n    p = ro;\n    for (int i = 0; i < NUM_STEPS; i++) {\n        p = ro + t * rd;\n        float d = map(p);\n        if (abs(d) < EPSILON) {\n            return true;\n        }\n        t += d;\n    }\n    return false;\n}\n\n//bool rayTracing( vec3 ro, vec3 rd, out float t ) {\n//    t = 0.0;\n//    for (int i = 0; i < NUM_STEPS; i++) {\n//        float d = sdf(ro + t * rd);\n//        if (abs(d) < EPSILON) return true;\n//        t -= d / grad(ro, rd, t);\n//    }\n//    return false;\n//}\n\nvec3 path( float time )\n{\n\treturn vec3( 5.0*cos(0.2+0.1 * time*1.5), 0.0, 5.0*sin(0.1+0.1*time*1.5) );\n\t\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\tta.y = 0.1 + 0.4*sin(1.9*time);\n\tfloat cr = 0.5*sin(1.0+0.7*time);\n    oRo = ro;\n    oTa = ta;\n    oCr = cr;\n    oFl = 2.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light_dir = normalize(vec3(-0.3, 0.7, 0.5));\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro, ta; float cr, fl;\n    moveCamera( iTime / 3.0, ro, ta, cr, fl );\n    \n\t// camera2world transform\n    mat3 cam = setCamera( ro, ta, cr );\n    \n    vec3 rd = cam * normalize(vec3(uv, 1.0));\n    float t = 0.0;\n    vec3 p, norm;\n    if (interSect(ro, rd, p)) {\n        norm = calcNormal(p);\n        vec3 baseColor = colorLookup(p);\n        float ang = clamp(dot(light_dir, norm), 0.0, 0.1);\n        float reflex = clamp(dot(light_dir * vec3(-1.0, 0.0, -1.0), norm), 0.0, 1.0);\n        vec3 coeff = pow(ang, 1.7) * vec3(2.8);\n        coeff += pow(reflex, 1.7) * vec3(1.5);\n        //coeff = pow(reflex, 1.7) * vec3(0.5);\n        fragColor = vec4(baseColor * coeff, 1.0);\n    } else {\n        fragColor = vec4(0,0,0,1.0);\n    }\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0/2.2));\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}