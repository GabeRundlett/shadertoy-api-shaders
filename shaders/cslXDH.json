{
    "Shader": {
        "info": {
            "date": "1668816192",
            "description": "Comparing 3 distortion effects: radial shear (TR), twirl (BL) and spherize (BR) applied to a texture (TL).\nMouse controls the effect centering. Works on videos too.\n\nPorted from Unity's shader graph documentation",
            "flags": 0,
            "hasliked": 0,
            "id": "cslXDH",
            "likes": 9,
            "name": "Simple Distortion Effects",
            "published": 3,
            "tags": [
                "distortion",
                "sphere",
                "twirl",
                "spherize",
                "shear"
            ],
            "usePreview": 0,
            "username": "eo",
            "viewed": 367
        },
        "renderpass": [
            {
                "code": "/*\nSimple distortion effects, ported from Unity's shader graph documentation:\nhttps://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/UV-Nodes.html\n\nCode for effects is found in the common tab!\n\nEffect order:\n  ┌────────────────┬───────────────┐\n  │  Source image  │  Radial shear │\n  ├────────────────┼───────────────┤\n  │     Twirl      │    Spherize   │\n  └────────────────┴───────────────┘\n  \nThe mouse controls the effect centering\n*/\n\n\n\n// Uncomment to see how the effects distort uv-space\n//#define SHOW_UV\n\n// Controls the effect strengths\nvec2 radial_strength = vec2(5.0);\nvec2 spherize_strength = vec2(15.0);\nfloat twirl_strength = 10.0;\n\n// Set to 0 to turn off animations\nfloat ANIMATION = 1.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get 2x2 tiled uvs, centered on screen\n    // -> uv_n1p1 is 'uvs going from negative 1 to positive 1'\n    // -> uv_01_tile is 'uvs going from 0 to 1, tiled'\n    vec2 cen_coord = fragCoord - vec2(iResolution.x * 0.5, 0);\n    vec2 uv_n1p1 = 2.0 * (cen_coord / iResolution.y) - vec2(0.0, 1.0);\n    vec2 uv_01_tile = fract(uv_n1p1);\n    \n    // For helping to debug the uv mess\n    //fragColor = vec4(uv_n1p1,0,1); return;\n    //fragColor = vec4(uv_01_tile, 0, 1); return;\n    \n    // Knock out side bars\n    bool is_out_of_bounds = abs(uv_n1p1.x) > 1.0;\n    if(is_out_of_bounds) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    // Control the effect centering with the mouse\n    float is_mouse_down = clamp(iMouse.z, 0., 1.);\n    vec2 mouse_center_px = iMouse.xy - vec2(iResolution.x * 0.5, 0);\n    vec2 mouse_center_01 = fract(2.0 * (mouse_center_px / iResolution.y) - vec2(0.0, 1.0));\n    vec2 center = mix(vec2(0.5), mouse_center_01, is_mouse_down);\n    \n    // For clarity\n    bool is_top_left = (uv_n1p1.x < 0.0) && (uv_n1p1.y > 0.0);\n    bool is_top_right = (uv_n1p1.x > 0.0) && (uv_n1p1.y > 0.0);\n    bool is_bot_left = (uv_n1p1.x < 0.0) && (uv_n1p1.y < 0.0);\n    bool is_bot_right = (uv_n1p1.x > 0.0) && (uv_n1p1.y < 0.0);\n    vec2 warp_uv;\n    \n    // No warping    \n    if (is_top_left) {\n        warp_uv = uv_01_tile;\n    }\n    \n    // Radial shear (the flowing effect)\n    if (is_top_right) {\n        warp_uv = radial_shear(uv_01_tile, center, radial_strength);\n        warp_uv += vec2(iTime * 0.5, 0.0) * ANIMATION;\n        \n        // For nicer uv debug coloring, not needed for the effect (needed for videos!)\n        // -> Introduces a slight glitch at uv boundaries\n        warp_uv = fract(warp_uv);\n    }\n    \n    // Twirl\n    if (is_bot_left) {\n        twirl_strength *= cos(iTime * 0.25 * ANIMATION);\n        warp_uv = twirl(uv_01_tile, center, twirl_strength);\n    }\n    \n    // Spherize\n    if (is_bot_right) {\n        spherize_strength *= cos(iTime * 0.5 * ANIMATION);\n        warp_uv = spherize(uv_01_tile, center, spherize_strength);\n    }\n    \n    // Look up pixel values using distorted uvs\n    fragColor = texture(iChannel0, warp_uv);\n    \n    // Show uv coloring for debug\n    #ifdef SHOW_UV\n        fragColor = vec4(warp_uv, 0, 1);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec2 radial_shear(vec2 uv, vec2 center, vec2 strength)\n{\n    /*\n    Source:\n    https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/Radial-Shear-Node.html\n    */\n    vec2 uv_cen = uv - center;\n    vec2 scaled_dist_sq = strength * dot(uv_cen, uv_cen);\n    return uv + vec2(uv_cen.y, -uv_cen.x) * scaled_dist_sq;\n}\n\nvec2 twirl(vec2 uv, vec2 center, float strength)\n{\n    /*\n    Source:\n    https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/Twirl-Node.html\n    */\n\n    vec2 uv_cen = uv - center;\n    float scaled_dist = strength * length(uv_cen);\n    vec2 cs = vec2(cos(scaled_dist), sin(scaled_dist));\n    \n    float x_twirl = dot(cs * vec2(1.0, -1.0), uv_cen);\n    float y_twirl = dot(cs.yx, uv_cen);\n    \n    return vec2(x_twirl + center.x, y_twirl + center.y);\n}\n\nvec2 spherize(vec2 uv, vec2 center, vec2 strength)\n{\n    /*\n    Source:\n    https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/Spherize-Node.html\n    */\n    vec2 uv_cen = uv - center;\n    float dist_sq = dot(uv_cen, uv_cen);\n    float dist_to_4th = dist_sq * dist_sq;\n    vec2 sphere_offset = strength * dist_to_4th;\n    return uv + uv_cen * sphere_offset;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}