{
    "Shader": {
        "info": {
            "date": "1479312724",
            "description": "Couldn't find one through the search so I thought I'd give it a go.\nYou can input your own equation and tweak some parameters.",
            "flags": 0,
            "hasliked": 0,
            "id": "XttSW8",
            "likes": 25,
            "name": "Parametric Surface Plotter",
            "published": 3,
            "tags": [
                "surface",
                "plotter",
                "parametric"
            ],
            "usePreview": 0,
            "username": "lara",
            "viewed": 1066
        },
        "renderpass": [
            {
                "code": "//#define CROSSEYE 0.2\n\n#define STEPS 10.\n#define ORTHOGONAL\n#define SURFACE\n#define MESH vec4(vec3(0),0.01)\n\n#define PI  3.14159\n#define TAU 6.28318\n#define T   iTime\n\nconst float U_MIN = 0.0;\nconst float U_MAX = TAU;\nconst float V_MIN = 0.0;\nconst float V_MAX = TAU;\n\n// Your equation here\n\nvec3 fn(float u, float v)\n{\n    // Torus:  return vec3(cos(u)*(1.-cos(v)*0.5),sin(v)*0.5,sin(u)*(1.-cos(v)*0.5));\n    // Sphere: return vec3(sin(u)*cos(v),sin(v),cos(u)*cos(v) );\n    // Cone:   return vec3(sin(u),1,cos(u))*sin(v);\n\t// Plane:  return vec3(u-PI,1,v-PI)*0.5;\n    // Vase:   return vec3(cos(u),(v-PI)/TAU*3.,sin(u))*vec2((1.-cos(v-PI*1.5)*0.5)*step(0.01,v),1).xyx*0.7;\n    \n    // Klein Bottle:\n    // (from https://de.wikipedia.org/wiki/Kleinsche_Flasche#Beschreibung_im_3-dimensionalen_Raum)\n    \n    float r = 2.0-cos(u);\n\n    return vec3(\n        2.0*(1.0-sin(u))*cos(u)+r*cos(v)*(2.0*exp(-pow(u/2.0-PI,2.0))-1.0),\n        r*sin(v),\n        6.0*sin(u) + 0.5*r*sin(u)*cos(v)*exp(-pow(u-3.0*PI/2.0,2.0))\n    ).xzy*0.2;\n}\n\n/* -------------------------------------------------------------------------------------------------------- */\n\n\nconst float U_STP = (U_MAX-U_MIN)/STEPS;\nconst float V_STP = (V_MAX-V_MIN)/STEPS;\n\nstruct Ray    { vec3 o, d; };\nstruct Camera { vec3 p, t; };\nstruct Hit    { vec3 p, n; float t; int id; };\n    \nCamera _cam = Camera(vec3(0,0,-2.5), vec3(0));\nHit _miss   = Hit(vec3(0),vec3(0),-1e10, 0);\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nbool isNan(float val){return(val<=0.||0.<=val)?false:true;}\n\nHit triangle(Ray r, vec3 a, vec3 b, vec3 c, int id)\n{\n\tvec3 ab = b-a, bc = c-b, ac = c-a;\n\tvec3 n = cross(ab,ac);\n\n\tfloat nrd = dot(n,r.d);\n    if (abs(nrd) < 0.001 || isNan(nrd) == true) { return _miss; }\n\n\tfloat t = -dot(n,r.o-a)/nrd;\n    if (t < 0.0) { return _miss; }\n\n\tvec3 p = r.o+r.d*t;\n\n    if(dot(n,cross( ab,p-a)) < 0.0\n    || dot(n,cross( bc,p-b)) < 0.0\n    || dot(n,cross(-ac,p-c)) < 0.0) { return _miss; }\n    \n\treturn Hit(b+bc/2.,vec3(sign(nrd)),t,id);\n}\n\n// Can probably be simpilfied a lot\nHit line(Ray r, vec3 pa, vec3 pb, float sr, int id)\n{\n    vec3 ab = pb-pa;\n    vec3 oa = pa-r.o;\n    \n    float dabrd = dot(ab,r.d);\n    float drdrd = dot(r.d,r.d);\n    \n    float det = dot(ab,ab)*drdrd-dot(ab,r.d)*dabrd;\n    if (det == 0.) { return _miss; }\n\n\tvec3 sp = pa+ab*clamp((dot(oa,r.d)*dabrd-dot(oa,ab)*drdrd)/det,0.,1.);\n\n    r.o -= sp;\n\n    float a = drdrd;\n    float b = 2.0*dot(r.o,r.d);\n    float c = dot(r.o,r.o)-sr*sr;\n    float d = pow(b,2.0)-4.0*a*c;\n\n    if (d < 0.0) { return _miss; }\n    \n    float s = sqrt(d);\n    float t = min(-b+s,-b-s)/(2.*a);\n    \n    return Hit(vec3(0), vec3(0), t, id);\n\n    // vec3 p = r.o+sp+r.d*t;\n\t// vec3 n = normalize(p-sp);\n    \n    // return Hit(p, n, t, id);\n}\n\nfloat compare(inout Hit a, Hit b)\n{\n    if (a.t < 0.0 || b.t > 0.0 && b.t < a.t)\n    {\n        a = b;\n        return 1.0;\n    }\n    \n\treturn 0.0;\n}\n\nHit trace(Ray r)\n{\n    Hit h = _miss;\n    \n    for(float u = U_MIN; u < U_MAX; u += U_STP)\n    {          \n        for(float v = V_MIN; v < V_MAX; v += V_STP)\n        {        \n            vec3 a = fn(u,v);\n            vec3 b = fn(u,v+V_STP);\n            vec3 c = fn(u+U_STP,v);\n\n            #ifdef MESH\n            \n            \tcompare(h,line(r,a,b,MESH.w,0));\n            \tcompare(h,line(r,a,c,MESH.w,0));\n            \n            #endif\n\n            #ifdef SURFACE\n                \n                vec3 d = fn(u+U_STP,v+V_STP);\n            \n                float comp = max(\n                    compare(h,triangle(r,a,b,c,1)),\n                    compare(h,triangle(r,d,c,b,1))\n                );\n\n                if (comp > 0.0)\n                {\n                    h.n = normalize(cross(a-b,d-b))*h.n.x;\n                }\n\n            #endif\n        }\n    }\n\n    return h;\n}\n\nRay lookAt(Camera cam, vec2 uv)\n{\n    vec3 d = normalize(cam.t-cam.p);\n    vec3 r = normalize(cross(d,vec3(0,1,0)));\n    vec3 u = cross(r,d);\n\t\n    #ifndef ORTHOGONAL\n    return Ray(cam.p,normalize(r*uv.x + u*uv.y + d));\n    #else\n    return Ray(cam.p+(r*uv.x + u*uv.y)*2.0, d);\n    #endif\n}\n\nvec3 getColor(Hit h)\n{\n    if(h.t <= 0.0) { return vec3(0.2); }\n    \n    #ifdef MESH\n    if(h.id == 0) { return MESH.rgb; }\n    #endif\n    \n    // float diff = max(dot(normalize(_cam.p-h.p),h.n),0.5);\n    // float spec = pow(max(dot(reflect(normalize(h.p-_cam.p),h.n),normalize(_cam.p-h.p)),0.0),100.);\n    \n    return normalize(h.n+1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalized screen and mouse coordinates\n    vec2 uv  = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    vec2 uvm = (2.0 * iMouse.xy    - iResolution.xy) / iResolution.xy;\n    \n    if (iMouse.y < 10. && iMouse.x < 10.) { uvm = vec2(T*0.1+PI/2.1, 0.4); }\n    \n\t#ifdef CROSSEYE\n    _cam.p.x += sign(uv.x)*CROSSEYE;\n    uv.x = mod(uv.x,1.5)-1.5/2.;\n    #endif\n    \n    // cam rotation\n    _cam.p.yz *= rot(uvm.y*PI/2.);\n    _cam.p.xz *= rot(uvm.x*TAU);\n    \n    // vignette\n    float f = 1.-length((2.0*fragCoord.xy-iResolution.xy)/iResolution.xy)*0.25;\n    \n    fragColor = vec4(getColor(trace(lookAt(_cam,uv))),1)*f;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}