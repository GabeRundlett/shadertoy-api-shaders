{
    "Shader": {
        "info": {
            "date": "1501786310",
            "description": "This shader is part of my latest music visualization video:\nwww.youtube.com/watch?v=KKDOUHB9ovA\n\nYou can create your own styles using your shaders, i released Soundbild2 as freeware :)\nwww.weltfalt.de/soundbild2\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MsjfRd",
            "likes": 1,
            "name": "Dr. KrÃ¶mtgen's cell (music vis)",
            "published": 3,
            "tags": [
                "2d",
                "simple",
                "video",
                "musicvisualization",
                "luminescent"
            ],
            "usePreview": 0,
            "username": "vapoi",
            "viewed": 672
        },
        "renderpass": [
            {
                "code": "const float fPi = 3.14159;\nconst float fEu = 2.71828;\n\nconst vec3 colMain1 = vec3(1.2, 1.1, 0.15);\nconst vec3 colMain2 = vec3(0.1, 1.3, 1.2);\nconst vec3 colDetail1 = vec3(0.2, 0.05, 0.04);\nconst vec3 colDetail2 = vec3(0.2, 0.05, 0.04);\n\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\n// Noise-Functions, https://github.com/ashima/webgl-noise\n// \n// Copyright (C) 2011 by Ashima Arts (Simplex noise)\n// Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat heightNoise(vec2 poi)\n{\n\treturn \t  cnoise(poi) * 0.633\n\t\t\t+ cnoise(poi + vec2(4.7)) * 0.333\n\t\t\t+ cnoise(poi + vec2(9.4)) * 0.133;\n}\nfloat sNoise(vec2 poi)\n{\n\treturn \t  cnoise(poi) * 0.633\n\t\t\t+ cnoise(poi * vec2(2.2)) * 0.333\n\t\t\t+ cnoise(poi * vec2(4.7)) * 0.133;\n}\n\nfloat DistanceP(vec2 p, vec2 segA, vec2 segB)\n{\n    \tvec2 p2 = vec2(segB.x - segA.x,segB.y - segA.y);\n    \tfloat num = p2.x * p2.x + p2.y * p2.y;\n    \tfloat u = ((p.x - segA.x) * p2.x + (p.y - segA.y) * p2.y) / num;\n\n    \tif (u > 1.0 ) {\n    \t\tu = 1.0;\n    \t}\n    \telse if (u < 0.0) {\n    \t\tu = 0.0;\n    \t}\n\n    \tfloat x = segA.x + u * p2.x;\n    \tfloat y = segA.y + u * p2.y;\n\n    \tfloat dx = x - p.x;\n    \tfloat dy = y - p.y;\n\n    \treturn sqrt(dx*dx + dy*dy);\n}\n\n\nfloat GetNoiseP(vec2 poi, vec2 per)\n{\n\treturn \t1.5 + pnoise(poi, per) \n\t\t\t+ pnoise(poi * vec2(0.50), per)\n\t\t\t;\n}\nfloat GetNoiseD(vec2 poi, vec2 per)\n{\n\treturn \t0.7 * pnoise(poi, per) +\n\t\t\t0.3 * pnoise(poi + vec2(0.5, 3.0), per) +\n\t\t\t0.1 * pnoise(poi + vec2(1.0, 6.0), per)\n\t\t\t;\n}\n\nfloat GetNoise(vec2 poi)\n{\n\treturn \t0.7 * cnoise(poi) +\n\t\t\t0.3 * cnoise(poi * vec2(2.17))\n\t\t\t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 pMid = vec2(-1.0, -1.0) + 2.0 * uv;\n\t\n\tpMid.x *= iResolution.x / iResolution.y;\n\t\n    float fNumber = 5.0;\n    float vTime = iTime * 1.0;\n    float fSecondCore = clamp(sin(vTime * 1.3) + cos(vTime * 0.95), 0.0, 1.0);\n    float fSpec = clamp(sin(vTime * 0.93) + cos(vTime * 1.35), 0.0, 1.0);\n\t\n\tfloat distanceToMid = length(pMid);\n\tfloat fAngle = atan(pMid.y, pMid.x);\n\tfloat fGrain = 0.0 + GetNoise(pMid * 14.0 + vec2(fNumber * 4.0, fNumber * 3.0));\n\n\tfloat someNoise = GetNoiseD(vec2(((fAngle / fPi) + 0.5) * 7.0 + fNumber * 13.0,\n\t\t\t\t\t\t\t\t\t distanceToMid * 7.30 + fNumber * 3.1 - vTime * 0.93),\n\t\t\t\t\t\t\t\tvec2(7.0, 35.0));\n\tsomeNoise *= clamp((distanceToMid - 0.1) * 4.0, 0.0, 1.0);\n\tfloat modifyBorder = someNoise * (0.025 + fSpec * 0.025);\n\t\t\t\t\t\n\t// Cell-Core \n\tfloat rotateOnAction = sin(vTime * 0.61 + fNumber * 0.92);\n\tfloat rotateOnAction2 = sin(vTime * 0.41 + fNumber * 0.52);\n\tvec2 corePos = vec2(sin(vTime * 0.64 + fNumber * 0.71 + fSpec * rotateOnAction), \n\t\t\t\t\t    cos(vTime * 0.73 + fNumber * 1.2 + fSpec * rotateOnAction2)) * (0.2 + 0.8 * fSpec) * 0.18;\n\t\n\tfloat fCore = smoothstep(-0.1, -0.04, -length(pMid + corePos));\n\t\n\t\n\tvec2 corePos2 = corePos;\n\tfloat fSecCore = fSecondCore * 0.5 * (1.0 + cos(vTime * 0.43 + sin(vTime * 0.46 + fNumber * 0.42) + fNumber * 0.35));\n\t\n\tif (fSecCore > 0.0)\n\t{\n\t\tfloat secCoreDif1 = -0.6 * (1.0 + sin(vTime * 0.5 + sin(vTime * 0.6 + fSpec + fNumber * 0.3) + fNumber * 0.45));\n\t\tfloat secCoreDif2 = 0.7 * (1.0 + sin(vTime * 0.6 + sin(vTime * 0.4 + fSpec + fNumber * 0.35) + fNumber * 0.4));\n\t\tcorePos2 = mix(corePos, vec2(sin(secCoreDif1 + vTime * 0.64 + fNumber * 0.71 + fSpec * rotateOnAction), \n\t\t\t\t\t\t\t\t\t cos(secCoreDif2 + vTime * 0.73 + fNumber * 1.2 + fSpec * rotateOnAction2)) \n\t\t\t\t\t\t\t\t\t * (0.2 + 0.8 * fSpec) * 0.18 * clamp(secCoreDif1 + secCoreDif2, -0.5, 1.0),\n\t\t\t\t\t  0.5 * (1.0 + cos(fPi + fPi * fSecCore)));\n\t\tfCore = max(fCore, smoothstep(-0.1, -0.04, -length(pMid + corePos2)));\n\t\tcorePos = (corePos + corePos2) * 0.5;\n\t}\n\t\n\tfloat fOuterCore = smoothstep(-0.2, -0.05, -length(pMid + corePos * 0.75) + 2.0 * modifyBorder * fGrain);\n\t\n\t\n\t\n\t// Cell\n\tfloat fShapeVisible = 0.0;\n\tfShapeVisible = (0.6 + 0.45 * fSpec ) * (1.0 - 0.05 * someNoise - fGrain * 0.1)\n\t\t\t\t\t\t * smoothstep(-0.42, -0.30 - fSpec * 0.05, -distanceToMid + modifyBorder - min(0.0, fGrain * 0.05))\n\t\t\t\t\t\t * (1.0 - 0.35 * smoothstep(0.20 - fSpec * 0.0, 0.38, distanceToMid + modifyBorder - min(0.0, fGrain * 0.1))) ;\n\n\tfloat fModifiedDist = distanceToMid * (1.0 - 0.7 * modifyBorder);\n\tfShapeVisible += fOuterCore * (0.15 - fSpec * 0.45);\n\t\n\n\t// cell core structure\n\tif (fCore > 0.0)\n\t{\n\t\tfCore += 0.5 * fGrain;\n\t}\n\t\n\t// coloring\n\tvec3 colSpec = mix(vec3(0.45), mix(colMain1, colMain2, fNumber / 40.0), fSpec * 1.0);\n\t\n\tvec3 colSpec2 = mix(vec3(0.25), mix(colDetail1, colDetail2, fNumber / 40.0), fSpec * 1.1);\n\tcolSpec = mix(colSpec, colSpec2, min(1.0, max(0.0, -someNoise * 1.0) * fSpec * fShapeVisible * 1.5));\n\t\n\t// cell core is fading to grey on amplitude\n\tcolSpec = mix(colSpec, vec3(0.1) + vec3(0.25) * fSpec, fCore);\n\t\n\t\n\t\n\tvec3 colBorder = mix(colSpec * 0.5, vec3(0.2) + vec3(0.1) * fSpec, smoothstep(0.3, 0.6, fModifiedDist))\n\t\t\t\t\t* (0.2 + 0.2 * fSpec)\n\t\t\t\t\t* smoothstep(-0.9, -0.4, -fModifiedDist)\n\t\t\t\t\t* smoothstep(0.3, 0.4, fModifiedDist);\n\tvec3 colDot = mix(colBorder, colSpec * fShapeVisible, fShapeVisible);\n\t\n\t\n\t\n\t\n\t// 3D Light Effect Test\n\tfAngle = ((fAngle / fPi) + 0.5) * 3.0 - 0.25 * fSpec * (1.0 + rotateOnAction);\n\t\n\tfAngle *= 1.0 - fSpec * 0.3;\n\tfloat fLight = smoothstep(0.0, 1.0, fAngle)\n\t\t\t\t * smoothstep(-2.0, -1.0, -fAngle);\n\tfloat moveIn = 0.025 * fSpec;\n\tfLight *= smoothstep(-0.3 - moveIn, -0.2 - moveIn, -fModifiedDist)\n\t\t\t* smoothstep(0.1 + moveIn, 0.2 + moveIn, fModifiedDist);\n\tcolDot += vec3(0.3) * (1.0 - 2.0 * fSpec) * (1.0 - 2.0 * modifyBorder) * fLight;\n\t\n\n\t\n\tfragColor = vec4(colDot, smoothstep(-0.9, -0.38, -fModifiedDist));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}