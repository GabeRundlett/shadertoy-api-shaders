{
    "Shader": {
        "info": {
            "date": "1460628161",
            "description": "This shader computes the curvature of a given distance function with auto diff and eigenvalue decomposition. Instructions and more info at the top of the code",
            "flags": 48,
            "hasliked": 0,
            "id": "4stSRf",
            "likes": 22,
            "name": "Curvature visualization",
            "published": 3,
            "tags": [
                "curvature",
                "hessian",
                "autodiff",
                "eigenvalues",
                "eigenvectors"
            ],
            "usePreview": 1,
            "username": "sibaku",
            "viewed": 1553
        },
        "renderpass": [
            {
                "code": "//*************** INSTRUCTIONS **********************\n//\n// Move the camera by dragging the mouse with left button held down\n//\n// Change scenes by redifining SCENE with either TORUS, CYLINDER or CONE in Buf A\n//\n// Uncomment #define USE_SECOND_DIRECTION to show second principal direction.\n// This is only working for the torus though, since the other two objects have directions\n// of zero curvature. In that case, the fallback is to the first direction\n//\n//***************************************************\n\n//*************** INFO **********************\n//\n// This demo will visualize the curvature of an object\n// For a real distance function f, ||grad f|| = 1 \n// The hessian can then be used to compute principal curvatures and -directions\n// Principal curvatures are the non-zero eigenvalues and the directions the corresponding\n// eigenvectors\n//\n// Directions are then projected onto the screen yielding a 2D vector field\n// That is visualized with a simple version of a line integral convolution\n//\n// Outlines are done with the distance gained from the distance field, so no sobel edge filter\n//\n//***************************************************\n\n\n\nconst int steps = 30;\nconst float size = 30.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 samplePix =texture(iChannel0,uv);\n    \n    // Background\n    if(samplePix.w < 1.)\n    {\n        fragColor = vec4(1.)*float(samplePix.z>0.07);\n        return;\n    }\n    vec2 dir = normalize(samplePix.xy);\n    \n    vec2 texelSize = 1./iResolution.xy;\n    \n    // Simple line integral convolution\n    // Step along line for some length and accumulate random weights\n    dir *= size*texelSize;\n    vec2 start = uv - 0.5*dir;\n    float val = 0.;\n    float realSteps = 0.;\n    vec2 pos = start;\n    for(int i = 0; i < steps; i++)\n    {\n        pos = start + dir*float(i)/float(steps);\n        vec4 samplePos = texture(iChannel0,pos);\n        \n        val += texture(iChannel1,pos).r;\n    }\n    \n \n    float sat = float(val/float(steps) );\n    fragColor = vec4(sat < 0.5);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//*************** INSTRUCTIONS **********************\n//\n// Move the camera by dragging the mouse with left button held down\n//\n// Change scenes by redifining SCENE with either TORUS, CYLINDER or CONE in Buf A\n//\n// Uncomment #define USE_SECOND_DIRECTION to show second principal direction.\n// This is only working for the torus though, since the other two objects have directions\n// of zero curvature. In that case, the fallback is to the first direction\n//\n//***************************************************\n\n//*************** INFO **********************\n//\n// This demo will visualize the curvature of an object\n// For a real distance function f, ||grad f|| = 1 \n// The hessian can then be used to compute principal curvatures and -directions\n// Principal curvatures are the non-zero eigenvalues and the directions the corresponding\n// eigenvectors\n//\n// The hessian is calculated exactly with automatic differentiation \n//\n// Directions are then projected onto the screen yielding a 2D vector field\n// That is visualized with a simple version of a line integral convolution\n//\n// Outlines are done with the distance gained from the distance field, so no sobel edge filter\n// \n//\n//***************************************************\n\n\n\n\n//********************************************************************\n//\n// Global defines\n// \n//********************************************************************\n\n// Infinity\n#define AUTO_INFINITY 3.402823e+38\n\n//#define USE_SECOND_DIRECTION\n\n#define TORUS 0\n#define CYLINDER 1\n#define CONE 2\n\n#define SCENE TORUS\nconst float eps = 0.0001;\n\n// Eigenvalue stuff\nconst float epsEig = 0.000001;\nconst int maxStepsEig = 20;\n\nconst float pi = 3.14159265359;\n\n// Maximum number of sphere trace steps\nconst int maxSteps = 150;\n\nbool isPressed(int key)\n{\n    float val = texture( iChannel0, vec2( (float(key)+0.5)/256.0, 0.25 ) ).x;\n\treturn val > 0.5;\n}\n\nbool isToggled(int key)\n{\n    float val = texture( iChannel0, vec2( (float(key)+0.5)/256.0, 0.75 ) ).x;\n\treturn val > 0.5;\n}\n\n\n//********************************************************************\n//\n// Non autodiff code\n// \n//********************************************************************\n\n// Frobenius norm\nfloat frobenius(in mat3 m)\n{\n \treturn sqrt(dot(m[0],m[0]) + dot(m[1],m[1]) + dot(m[2],m[2]));   \n}\n\nfloat calcNorm(in mat3 m)\n{\n \n        return frobenius(m);\n}\n\n\n\n// Dist funcs taken from: \n// https://iquilezles.org/articles/distfunctions\nfloat DE_Sphere(in vec3 p, in vec3 center, in float r)\n{\n \treturn length(p-center)-r;   \n}\n\nfloat DE_Box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat DE_Torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat DE_Cylinder( vec3 p)\n{\n  return length(p.xz)-1.;\n}\n\nfloat DE_Cone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xz);\n    return dot(c,vec2(q,p.y));\n}\n\nfloat DE(vec3 p)\n{\n    #if SCENE == TORUS\n    \treturn DE_Torus(p,vec2(1.5,0.4));\n    #elif SCENE == CYLINDER\n    \treturn  DE_Cylinder( p);\n    #elif SCENE == CONE\n    \treturn DE_Cone(p,normalize(vec2(1.,1.)));\n    #else\n    \treturn min(DE_Torus(p,vec2(1.5,0.4)),DE_Sphere(p,vec3(0.),1.4));\n    #endif\n\t//return DE_Sphere(p, vec3(0.),1.);\n    //return  DE_Cylinder( p);\n    \n   // return DE_Torus(p,vec2(1.5,0.4));\n} \n\n\nHNum3 DE_Sphere_Hess(in HNum3 x, in HNum3 y, in HNum3 z)\n{\n    return sub(a_sqrt(add(add(mult(x,x),mult(y,y)),mult(z,z))),1.4);  \n}\nHNum3 DE_Torus_Hess( in HNum3 x, in HNum3 y, in HNum3 z)\n{\n  HNum3 x1 = sub(a_sqrt(add(mult(x,x),mult(z,z))),1.5);\n                \n  \n    \n  return sub(a_sqrt(add(mult(x1,x1),mult(y,y))),0.4);\n \n}\n\n\nHNum3 DE_Cylinder_Hess( in HNum3 x, in HNum3 y, in HNum3 z)\n{\n    \n  return sub(a_sqrt(add(mult(x,x),mult(z,z))),1.);\n \n}\n\nHNum3 DE_Cone_Hess( in HNum3 x, in HNum3 y, in HNum3 z)\n{\n  \n    HNum3 q = a_sqrt(add(mult(x,x),mult(z,z)));\n    vec2 c = normalize(vec2(1.,1.));\n    \n    return add(mult(q,c.x),mult(y,c.y));\n                       \n \n}\n\n\nHNum3 DE_Hess( in HNum3 x, in HNum3 y, in HNum3 z)\n{\n \t#if SCENE == TORUS\n    \treturn DE_Torus_Hess(x,y,z);\n    #elif SCENE == CYLINDER\n    \treturn a_max(DE_Cylinder_Hess(x,y,z),DE_Sphere_Hess(x,y,z));\n    #elif SCENE == CONE\n    \t return DE_Cone_Hess(x,y,z);\n    #else\n   \t\t return a_min(DE_Torus_Hess(x,y,z),DE_Sphere_Hess(x,y,z));\n    #endif\n    \n}\n\nbool trace(in vec3 p, in vec3 dir, out float t, out float dist, out int steps,\n           out vec3 pos, out float minDist)\n{\n   \n    \n    \n    steps = 0;\n    dist = 10000.0;\n    t = 0.;\n    \n    float lastT = 0.;\n    minDist = dist;\n    for(int i= 0; i < maxSteps;i++)\n    {\n        pos = p+t*dir;\n     \tfloat d = DE(pos);\n        \n        \n        if(d < 0.)\n        {\n         \tt += 2.*eps;   \n            continue;\n            \n        }\n        if(d < eps)\n        {\n            dist = 0.;\n            minDist = 0.;\n           // t = lastT;\n            return true;\n        }\n        \n        lastT = t;\n        t += d;\n        dist = d;\n        steps++;\n        minDist = min(minDist,dist);\n        if(t > 100.)\n            return false;\n    }\n  \n    \n    return false;\n}\n\nfloat det(in mat3 m)\n{\n\treturn dot(m[0],cross(m[1],m[2]));\n}\nmat3 inv(in mat3 m)\n{\n \tvec3 v0 = cross(m[1],m[2]);\n    vec3 v1 = cross(m[2],m[0]);\n    vec3 v2 = cross(m[0],m[1]);\n    mat3 r = mat3(v0[0],v1[0],v2[0],\n                  v0[1],v1[1],v2[1],\n                  v0[2],v1[2],v2[2]);\n    \n    return r/det(m);\n}\n\nfloat trace(in mat3 m)\n{\n    return m[0][0] + m[1][1] + m[2][2];   \n}\n\n\n\n//********************************************************************\n//\n// Givens Rotations\n//\n// Mutliple methods since non-const indexing doesn't work\n// \n//********************************************************************\n\n\n// p = 0\n// q = 1\nvoid givensAngle01(in mat3 m,out float c, out float s)\n{\n    float mpq = m[1][0];\n    \n    if(abs(mpq) < epsEig)\n    {\n\t\tc = 1.;\n        s = 0.;\n        return;\n    }\n    \n   \tfloat tau = (m[1][1]- m[0][0])/(2.*m[1][0]);\n    \n    float tsqr = sqrt(1. + tau*tau);\n    \n    float t1 = tsqr  -tau;\n    float t2 = -tau - tsqr;\n    \n    float t= abs(t1) < abs(t2) ? t1 : t2;\n    \n    \n    c = 1./sqrt(1.+t*t);\n    s = t*c;\n}\n\nmat3 givensMatrix01(in mat3 m)\n{\n \tfloat c,s;\n    givensAngle01(m,c,s);\n    \n    return mat3(c,-s,0.,\n               s,c,0.,\n               0.,0.,1.);\n    \n}\n\n\n// p = 0\n// q = 2\nvoid givensAngle02(in mat3 m,out float c, out float s)\n{\n    float mpq = m[2][0];\n    \n    if(abs(mpq) < epsEig)\n    {\n\t\tc = 1.;\n        s = 0.;\n        return;\n    }\n    \n    float tau = (m[2][2]- m[0][0])/(2.*m[2][0]);\n    \n    float tsqr = sqrt(1. + tau*tau);\n    \n    float t1 = tsqr  -tau;\n    float t2 = -tau - tsqr;\n    \n    float t= abs(t1) < abs(t2) ? t1 : t2;\n    \n    \n    c = 1./sqrt(1.+t*t);\n    s = t*c;\n}\n\nmat3 givensMatrix02(in mat3 m)\n{\n \tfloat c,s;\n    givensAngle02(m,c,s);\n    \n    return mat3(c,0.,-s,\n               0.,1.,0.,\n               s,0.,c);\n    \n}\n\n\n// p = 1\n// q = 2\nvoid givensAngle12(in mat3 m,out float c, out float s)\n{\n    float mpq = m[2][1];\n    \n    if(abs(mpq) < epsEig)\n    {\n\t\tc = 1.;\n        s = 0.;\n        return;\n    }\n    \n   \tfloat tau = (m[2][2]- m[1][1])/(2.*m[2][1]);\n    \n    float tsqr = sqrt(1. + tau*tau);\n    \n    float t1 = tsqr  -tau;\n    float t2 = -tau - tsqr;\n    \n    float t= abs(t1) < abs(t2) ? t1 : t2;\n    \n    \n    c = 1./sqrt(1.+t*t);\n    s = t*c;\n}\n\nmat3 givensMatrix12(in mat3 m)\n{\n \tfloat c,s;\n    givensAngle12(m,c,s);\n    \n    return mat3(1.,0.,0.,\n               0.,c,-s,\n               0.,s,c);\n    \n}\n\n\n/*mat3 transpose(in mat3 m)\n{\n      return mat3(m[0][0], m[1][0], m[2][0],\n                m[0][1], m[1][1], m[2][1],\n                m[0][2], m[1][2], m[2][2]);\n}\n*/\n// Difference between diagonal matrix and non diagonal one \nfloat offError(in mat3 m)\n{\n    return abs(m[1][0]) +abs(m[0][1]) + abs(m[0][2]) + abs(m[2][0]) + abs(m[1][2]) + abs(m[2][1]);  \n}\n\n\n\n//\n//\n//\n// Jacobi eigenvalue iteration using givens rotations\n// This will compute both eigenvalues and -vectors\n// Each givens rotation will zero an off diagonal element\n// Overall the off diagonals will tend to zero and the matrix\n// will become diagonal. \n//\n// D is a more or less diagonal matrix with eigenvalues on the diagonal\n// V contains the eigenvectors in its cols\n//\n//\nvoid jacobiIteration(in mat3 m, out mat3 D, out mat3 V)\n{\n \n    D = m;\n    V = mat3(1.);\n    \n   \tmat3 g01,g02,g12;\n    \n    \n    for(int i = 0; i < maxStepsEig; i++)\n    {\n        g01 = givensMatrix01(D);\n    \n    \tD = transpose(g01)*D*g01;\n    \tV = V*g01;\n        \n        g02 = givensMatrix02(D);\n    \tD = transpose(g02)*D*g02;\n     \tV = V*g02;\n        \n   \t \tg12 = givensMatrix12(D);\n    \tD = transpose(g12)*D*g12;\n   \t\tV = V*g12;\n    \n     \n        if(offError(D) < epsEig)\n            break;\n    }\n       \n    \n    \n    \n}\n\n// Compute symmetry error -> hessians will be symmetric, if not, something went wrong\nfloat symmetricError(in mat3 m)\n{\n \treturn abs(m[0][1] - m[1][0]) + abs(m[0][2] - m[2][0]) + abs(m[1][2] - m[2][1]);   \n}\n\n\n\n\n\n//\n//\n// Sort curvatures to get highest and lowest non zero one\n//\n//\n#define isZero(v) (abs(v) < 10.*eps)\n#define isEqual(a,b) (abs(a-b) < 10.*eps)\nvoid getPrincipalCurvatures(in mat3 D, in mat3 V, \n                 out float k1, out vec3 p1, \n                 out float k2, out vec3 p2)\n{\n \tfloat l1 = D[0][0];\n    float l2 = D[1][1];\n    float l3 = D[2][2];\n    \n    vec3 v1 = V[0];\n    vec3 v2 = V[1];\n    vec3 v3 = V[2];\n    \n \tif(isZero(l1))\n    {\n     \tif(l2 > (l3))\n        {\n         \tk1 = l2;\n            p1 = v2;\n            \n            k2 = l3;\n            p2 = v3;\n        }else\n        {\n         \tk1 = l3;\n            p1 = v3;\n            \n            k2 = l2;\n            p2 = v2;\n        }\n    }else if(isZero(l2))\n    {\n     \tif(l1 > (l3))\n        {\n         \tk1 = l1;\n            p1 = v1;\n            \n            k2 = l3;\n            p2 = v3;\n        }else\n        {\n         \tk1 = l3;\n            p1 = v3;\n            \n            k2 = l1;\n            p2 = v1;\n        }\n    }else if(isZero(l3))\n    {\n     \tif(l2 > ( l1))\n        {\n         \tk1 = l2;\n            p1 = v2;\n            \n            k2 = l1;\n            p2 = v1;\n        }else\n        {\n         \tk1 = l1;\n            p1 = v1;\n            \n            k2 = l2;\n            p2 = v2;\n        }\n    }\n    else\n    {\n        if(l2 > ( l1))\n        {\n            if(l2 > (l3))\n            {\n                k1 = l2;\n            \tp1 = v2;\n                \n                if(l1 > (l3))\n                {\n                    k2 = l1;\n            \t\tp2 = v1;\n                }else\n                {\n                    k2 = l3;\n            \t\tp2 = v3;\n                }\n            \n            \t\n            }else\n            {\n             \tk1 = l3;\n            \tp1 = v3;  \n                k2 = l2;\n                p2 = v2;\n               \n            }\n         \t\n        }else\n        {\n         \t if(l1 > (l3))\n            {\n                k1 = l1;\n            \tp1 = v1;\n                \n                if(l3 > (l2))\n                {\n                    k2 = l3;\n            \t\tp2 = v1;\n                }else\n                {\n                    k2 = l2;\n            \t\tp2 = v2;\n                }\n            \n            \t\n            }else\n            {\n             \tk1 = l3;\n            \tp1 = v3;  \n                k2 = l1;\n                p2 = v1;\n               \n            }\n        }\n    }\n   \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n\tvec2 camRes = vec2(2.,2.*iResolution.y/iResolution.x);\n    float focal = 1.;\n    \n    vec3 eye;\n    vec3 center;\n    eye = vec3(3.4,2.,0.);\n    center = vec3(0.);\n    \n    // Camera thanks to stb\n    vec2 relativeMouse = iMouse.z <= 0. ? vec2(.5/iResolution.xy) : iMouse.xy/iResolution.xy-.5;\n\teye += vec3(0.,relativeMouse.yx)*12.;\n    \n    \n    // Camera coordinate system\n    \n    vec3 dir = normalize(center-eye);\n    \n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 right = normalize(cross(dir,up));\n    \n   \n    up = normalize(cross(right,dir));\n    vec3 lowerleft =  eye + focal*dir - right*camRes.x/2.0 - up*camRes.y/2.0;\n    \n    // starting position\n    vec3 p = lowerleft + uv.x*camRes.x*right + uv.y*camRes.y*up;\n    \n    \n    vec3 rayDir = normalize(p-eye);\n    \n    // Light currently not used -> didn't look too nice\n    vec3 LPos = vec3(0.,sin(2.*pi/10.*iTime)*10.,cos(2.*pi/10.*iTime)*10.);\n    \n    \n   \tvec3 col;\n    float t;\n    int steps;\n    float d;\n    vec3 P;\n    float minDist;\n    \n    \n    bool hit = trace(p,rayDir,t,d,steps,P,minDist);\n\n   \n    // alternatively store t in z to use sobel edge detection\n    \n    if(!hit)\n    {\n        col = vec3(1.,0.,minDist);\n        fragColor = vec4( col,0.);\n        return;\n    }\n    \n    \n    // compute hessian matrix\n    HNum3 result;\n    \n    HESSIAN3(DE_Hess,P.x,P.y,P.z,result);\n  \n\n   \n    \n    \n    // D is diag with eigenvalues, V is eigenvector mat\n    mat3 D,V;\n    jacobiIteration(result.h,D,V);\n    \n    // eigenvalues of distancefield hessian are principal curvatures \n    // -> at most 2 non zero ones \n    // greatest one is max curvature, lowest is min \n    // eigenvectors correspond to directions of highest/lowest curvature\n   \tfloat k1,k2;\n\tvec3  p1,p2;\n    \n    // sort\n    getPrincipalCurvatures(D,V,k1,p1,k2,p2);\n    \n\t\n\n    // Project onto screen\n    #ifdef USE_SECOND_DIRECTION\n    \t// Still use p1 if second direction has no curvature\n    \tif(isZero(k2))\n            p2 = p1;\n    \tvec3 curve = p2;\n    #else\n    \tif(isZero(k1))\n            p1 = right;\n    \tvec3 curve = p1;\n    #endif\n    vec3 curvProj = curve - dot(curve,dir)*dir;\n \n    float cx = dot(right,curvProj);\n    float cy = dot(up,curvProj);\n    \n    vec2 c = normalize(vec2(cx,cy));\n   \n    fragColor = vec4(c,minDist,1.);\n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#ifndef HESSNUM_3_H_\n#define HESSNUM_3_H_\n\n// This file contains methods to compute the gradient and hessian \n// of a scalar valued 3 dimensional function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 3 dimensional function\n// These should be created by the constH3 (for constants) and varH3 (for variables) helpers\nstruct HNum3\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec3 g;\n    // The current hessian\n    mat3 h;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant HNum3\n* @param val The current value of the constant\n*/\nHNum3 constH3(in float val);\n/**\n* Creates a HNum3 corresponding to the variable with the given index\n* @param val The current value of the variable\n* @param index The variable's index\n*/\nHNum3 varH3(in float val, in int index);\n/**\n* Creates a HNum3 corresponding to the variable x (index = 0)\n* @param val The current value of the variable\n*/\nHNum3 varH3x(in float val);\n/**\n* Creates a HNum3 corresponding to the variable y (index = 1)\n* @param val The current value of the variable\n*/\nHNum3 varH3y(in float val);\n/**\n* Creates a HNum3 corresponding to the variable z (index = 2)\n* @param val The current value of the variable\n*/\nHNum3 varH3z(in float val);\nHNum3 add(in HNum3 a, in HNum3 b);\nHNum3 add(in HNum3 a, in float b);\nHNum3 add(in float a, in HNum3 b);\nHNum3 sub(in HNum3 a, in HNum3 b);\nHNum3 sub(in HNum3 a, in float b);\nHNum3 sub(in float a, in HNum3 b);\nHNum3 mult(in HNum3 a, in HNum3 b);\nHNum3 mult(in HNum3 a, in float b);\nHNum3 mult(in float a, in HNum3 b);\nHNum3 neg(in HNum3 a);\nHNum3 div(in HNum3 a, in HNum3 b);\nHNum3 div(in HNum3 a, in float b);\nHNum3 div(in float a, in HNum3 b);\nHNum3 inv(in HNum3 a);\nHNum3 a_pow(in HNum3 a, in HNum3 b);\nHNum3 a_pow(in HNum3 a, in float b);\nHNum3 a_pow(in float a, in HNum3 b);\nHNum3 a_min(in HNum3 a, in HNum3 b);\nHNum3 a_max(in HNum3 a, in HNum3 b);\nHNum3 a_exp2(in HNum3 a);\nHNum3 a_inversesqrt(in HNum3 a);\nHNum3 a_atan(in HNum3 a);\nHNum3 a_sqrt(in HNum3 a);\nHNum3 a_sinh(in HNum3 a);\nHNum3 a_ceil(in HNum3 a);\nHNum3 a_tan(in HNum3 a);\nHNum3 a_asinh(in HNum3 a);\nHNum3 a_asin(in HNum3 a);\nHNum3 a_acosh(in HNum3 a);\nHNum3 a_abs(in HNum3 a);\nHNum3 a_exp(in HNum3 a);\nHNum3 a_cosh(in HNum3 a);\nHNum3 a_floor(in HNum3 a);\nHNum3 a_log(in HNum3 a);\nHNum3 a_atanh(in HNum3 a);\nHNum3 a_log2(in HNum3 a);\nHNum3 a_acos(in HNum3 a);\nHNum3 a_tanh(in HNum3 a);\nHNum3 a_cos(in HNum3 a);\nHNum3 a_sin(in HNum3 a);\nHNum3 a_atan2(in HNum3 y, in HNum3 x);\nHNum3 a_atan2(in HNum3 y, in float x);\nHNum3 a_atan2(in float y, in HNum3 x);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t);\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in float b, in float t);\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in float a, in HNum3 b, in float t);\nHNum3 a_mix(in float a, in float b, in HNum3 t);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define HESSIAN3(f,x, y, z,result)  {     result = f(varH3x(x), varH3y(y), varH3z(z)); }\n\n//--------------------------------\n// Utilities prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b);\n\n//--------------------------------\n// Implementation\n//--------------------------------\n\nHNum3 constH3(in float val)\n{\n    return HNum3(val, vec3(0.0), mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3(in float val, in int index)\n{   \n    vec3 g = vec3(0.0);\n    g[index] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3x(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[0] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3y(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[1] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3z(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[2] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val + b.val , a.g + b.g, a.h + b.h);\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in float b)\n{\n    return HNum3(a.val + b , a.g, a.h);\n}\n//--------------------------------\nHNum3 add(in float a, in HNum3 b)\n{\n    return HNum3(a + b.val , b.g, b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val - b.val , a.g - b.g, a.h - b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in float b)\n{\n    return HNum3(a.val - b , a.g, a.h);\n}\n//--------------------------------\nHNum3 sub(in float a, in HNum3 b)\n{\n    return HNum3(a - b.val , - b.g, - b.h);\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val * b.val, \n        a.val*b.g + b.val*a.g, \n        a.val*b.h + b.val*a.h + a_outerProduct(b.g,a.g) + a_outerProduct(a.g,b.g)\n    );\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in float b)\n{\n    return HNum3(a.val * b, b*a.g, b*a.h);\n}\n//--------------------------------\nHNum3 mult(in float a, in HNum3 b)\n{\n    return HNum3(a * b.val, a*b.g, a*b.h);\n}\n//--------------------------------\nHNum3 neg(in HNum3 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2, \n        2.0*a.val/b3*a_outerProduct(b.g,b.g) \n        - a.val/b2*b.h\n        + a.h/b1 \n        - a_outerProduct(b.g/b2, a.g)\n        - a_outerProduct(a.g/b2, b.g)\n    );\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in float b)\n{\n    return HNum3(a.val / b, a.g/b, a.h/b);\n}\n//--------------------------------\nHNum3 div(in float a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a / b.val, \n        -a*b.g/b2, \n        2.0*a/b3*a_outerProduct(b.g,b.g) - a/b2*b.h\n    );\n}\n//--------------------------------\nHNum3 inv(in HNum3 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in HNum3 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    float dda = b*(b-1.0)*pow(a.val,b-2.0); // second derivative f''(a(x))\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_pow(in float a, in HNum3 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n//--------------------------------\nHNum3 a_min(in HNum3 a, in HNum3 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_max(in HNum3 a, in HNum3 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_exp2(in HNum3 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n    float dda = log(2.0)*log(2.0)*exp2(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_inversesqrt(in HNum3 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n    float dda = 0.75/pow(sqrt(a.val),5.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan(in HNum3 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -2.0*a.val/pow(1.0 + a.val * a.val, 2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sqrt(in HNum3 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n    float dda = -0.25/pow(sqrt(a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sinh(in HNum3 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n    float dda = sinh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_ceil(in HNum3 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tan(in HNum3 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n    float dda = 2.0*tan(a.val)*(1.0 + pow(tan(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asinh(in HNum3 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asin(in HNum3 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acosh(in HNum3 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(-1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_abs(in HNum3 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_exp(in HNum3 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n    float dda = exp(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cosh(in HNum3 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n    float dda = cosh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_floor(in HNum3 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log(in HNum3 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atanh(in HNum3 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = 2.0*a.val/pow(1.0 - a.val * a.val,2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log2(in HNum3 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val * log(2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acos(in HNum3 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tanh(in HNum3 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n    float dda = -2.0*tanh(a.val)*(1.0 - pow(tanh(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cos(in HNum3 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n    float dda = -cos(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sin(in HNum3 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n    float dda = -sin(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in HNum3 x)\n{\n    const float pi = 3.14159265; \n    // from https://en.wikipedia.org/wiki/Atan2\n    if(x.val > 0.0)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(y, add(n,x));\n        \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > 1E-6)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(sub(n,x),y);\n         return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= 1E-6)\n    {\n        return constH3(pi);\n    }\n    // return 0 for undefined\n    return constH3(0.0); \n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in float x)\n{\n    return a_atan2(y,constH3(x));\n}\n//--------------------------------\nHNum3 a_atan2(in float y, in HNum3 x)\n{\n    return a_atan2(constH3(y),x);\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n\n//--------------------------------\n// Implementation prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b)\n{\n    return mat3(a * b[0], a * b[1], a * b[2]);\n}\n\n\n#endif // HESSNUM_3_H_",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}