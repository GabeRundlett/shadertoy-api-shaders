{
    "Shader": {
        "info": {
            "date": "1485053089",
            "description": "[url=http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf]Trace source[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4tVXRV",
            "likes": 71,
            "name": "Enhanced Sphere Tracing",
            "published": 3,
            "tags": [
                "raymarching",
                "sky",
                "enchanced"
            ],
            "usePreview": 1,
            "username": "patu",
            "viewed": 6678
        },
        "renderpass": [
            {
                "code": "/* \n\n\t\n\thttp://bit.ly/shadertoy-plugin\n \n\n\n*/\n\n\n// getNormalHex or getNormalCube\n#define getNormal getNormalCube\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n\n#define FOV 80.0\n#define FOG 1.\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\nvec3 \n    light = vec3(0.0), \n    p,\n    lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> \nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec3 map(vec3 o) {\n  \n    p = o;\n\n    p.y += 30. ;\n    \n    vec3 floor = vec3(\n        fBox2Cheap(p.xy, vec2(1000., 1.)),\n        2.,\n        0.\n    );\n    \n    p.y -= 30.;\n    \n    vec3 sphereS = vec3(\n        fSphere(p, 20.),\n        2.,\n        0.\n    );\n\n    vec3 \n        obj = vec3(FAR, -1.0, 0.0),\n        obj2 = obj;\n\n    pModPolar(p.zy, 5.);\n    pModPolar(p.zx, 4.);\n\n    pMirrorOctant(p.zy, vec2(min(t, 22.), min(t, 16.) ));\n    pMirrorOctant(p.xz, vec2(min(t, 16.), min(t, 16.) ));\n    \n    pR(p.zy, 1.2 );\n    \n    float pmp = pModPolar(p.xz, 5.);\n    \n\tpMirrorOctant(p.zy, vec2(4.5, 5.));\n    pMirrorOctant(p.xy, vec2(6., 4.));\n    \n    p.zy += 2.;\n    \n    pModPolar(p.xy, 5.);\n\n    obj = vec3(\n        fBox2Cheap(p.xy, vec2(2.4, .5) + vec2(sin(t) * 2., .5 + cos(t * 2.2) / 4.)),\n        2.0,\n        0.\n    );\n    \n    p.z -= 2.;\n    \n    obj2 = vec3(\n        fSphere(p, 2.),\n        1.,\n        0.\n    );\n    \n    obj = opU2(obj, obj2);\n    obj = opU2(obj, floor);\n    obj = opS2(obj, sphereS);\n    \n    return obj;\n}\n\n\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 90;\n\nvec3 trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 0.001;\n    float functionSign = map(o).x < 0. ? -1. : 1.;\n    vec3 mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.x;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) return vec3(INFINITY, 0., 0.);\n    \n    return vec3(candidate_t, mp.yz);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 20;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = .9;\n    float dist = 0.25;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        shade = min(shade, k*h/dist);\n       \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.7), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   \treturn normalize(vec3( \n   \t\tmap( pos + delta.xyy ).x - map( pos - delta.xyy ).x,\n   \t\tmap( pos + delta.yxy ).x - map( pos - delta.yxy ).x,\n   \t\tmap( pos + delta.yyx ).x - map( pos - delta.yyx ).x\n   ));\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n\n    float sdist = map(hitp + normal * dist).x;\n    return clamp(sdist / dist, 0.1, 1.0);\n}\n\nvec3 clouds(vec3 rd) {\n    float ctime = t / 14.;\n    vec2 uv = rd.xz / (rd.y + 0.6);\n\n    vec3 clouds = vec3(\n        fbm(\n            vec3(\n                uv.yx * 1.4 + vec2(ctime, 0.), ctime\n            ) \n        ) * 1.5\n    );\n    \n \n    clouds = pow(clouds, vec3(4.));\n\n    return clamp(clouds * rd.y, 0., 1.);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \n    float sunSize = 3.;\n    float sunAmount = max(dot(rd, lightDir), .5);\n    float v = pow(1. - max(rd.y, .5), 4.);\n    vec3 sky = fromRGB(200,200,200) * v;\n    \n    sky += lightColour * sunAmount * sunAmount \n        + lightColour * min(pow(sunAmount, 12.0) * sunSize, sunSize);\n\n    return clamp(sky, 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, vec3 obj) {\n    vec3 col = vec3(1.0);\n    \n    if (obj.y == 2.0) \n        col = vec3(1., .5, 0.) + clamp(mod(-t + p.z, 1.) - .5, 0.0, 0.75 ) * mod(t * 4., 1.);\n              \n    return col;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec3 obj) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1.0 / (1.0 + lDist * 0.025 + lDist * lDist * 0.02);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), .1);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.2), 2.0);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * 1.) * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n    \n    float t2 = t;\n    float \n        sk = sin(-t2 * .1) * 82.0, \n        ck = cos(-t2 * .1) * 82.0,\n    \tsh,\n        ao,\n        fog;\n    \n    light = vec3(20., 4., -10.);        \n    \n    vec3 \n        vuv = vec3(0., 1., -0.), // up\n    \tro = vec3(ck, -20., sk) + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 1.), // pos\n    \tvrp =  vec3(0., 0., 0.),\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n    \tsceneColor = rd,\n    \ttr = trace(ro, rd),\n        p2,\n        sn,\n        sky;\n    \n    ro += rd * tr.x;\n    \n    p2 = p;\n    \n    sn = getNormal(ro);\t\n    \n\n    fog = smoothstep(FAR * FOG, 0., tr.x) * 1.,\n    sh = softShadow(ro, light, 12.),\n    ao = getAO(ro, sn, 1.2);\n\t\n    ao *= 1. + saturate(getAO(ro + sn * .2, sn, 0.5));\n    ao *= saturate(getAO(ro + sn * 1.03, sn, 14.05));\n    \n    ro = p2; \n    \n    sky = Sky(rd, true, normalize(light));\n    \n    if (tr.x < FAR) { \n        sceneColor = saturate(doColor(ro, rd, sn, light, tr));\n        sceneColor *= ao;\n        sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.x * 4.2 / FAR));\n    } else {\n        sceneColor = sky + clouds(rd);\n    }\n\n    fragColor = vec4(clamp(sceneColor, 0., 1.), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}