{
    "Shader": {
        "info": {
            "date": "1528053903",
            "description": "A collection of useful functions for audio synthesis, and a tune to demonstrate them.",
            "flags": 8,
            "hasliked": 0,
            "id": "4sGfRw",
            "likes": 18,
            "name": "Synthesis Primitives",
            "published": 3,
            "tags": [
                "oscilloscope",
                "sound",
                "music",
                "audio",
                "lib",
                "utilities"
            ],
            "usePreview": 0,
            "username": "stellartux",
            "viewed": 1099
        },
        "renderpass": [
            {
                "code": "// Graph functions taken from https://thebookofshaders.com/05/\n\nfloat plot(vec2 st, float pct) {\n\treturn smoothstep( pct-0.08, pct, st.y) -\n\t\t   smoothstep( pct, pct+0.08, st.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 C ) {\n    vec2 uv = C/iResolution.xy;\n    uv.y = uv.y * 2. - 1.;\n    float x = uv.x + iTime -.99;\n    float y = master(x);\n    \n    ///////////////\n    // Try uncommenting some of these to\n    // see different parts of the song.\n    \n    // y = synth(x);\n    // y = drums(x) * 3.;\n    // y = kick(x);\n    // y = snare(x);\n    // y = hihat(x);\n    \n    ////////////////\n    // Uncomment these to view the outputs\n    // of the various utility functions\n    \n    // y = sine(x);\n    // y = squa(x) * .7;\n    // y = pwm(x, .25) * .7;\n    // y = tria(x);\n    // y = sawt(x);\n    // y = mpls(x);\n    // y = mpls(fract(x));\n    // y = mpls(fract(x*4.));\n    // y = pv(sine(x));\n    // y = nv(sine(x));\n    // y = noiz(x);\n    \n    ////////////////\n    // See how the functions interact \n    \n    // y = pv(pwm(x, .25));\n    // y = sine(x) * pv(pwm(x, .25));\n    // y = sine(x) * abs(tria(x));\n    // y = sine(x) * abs(tria(2.*x));\n    // y = sine(x*15.) * pv(pwm(x, .25)) *.7;\n    // y = sine(x*15.) * pv(pwm(x-.5, .25)) *.7;\n    \n    vec3 c = vec3(0);\n    if (abs(uv.y) < abs(y)) c.r += abs(y);\n    float pct = plot(uv, y);\n    c = (1.0-pct)*c+pct*vec3(0., 1., 0.)+plot(uv,0.)*vec3(0.,0.,1.);\n    if (fract(x)<=0.005) c.b = 1.;  \n    O = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define VOL .33\n\nvec2 mainSound( in int samp, float t ) {\n    return vec2(master(t) * VOL);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "/*\nSynthesis Primitives\n\nstellartux 2018\nUnlicense\n*/\nconst float PI = acos(-1.);\nconst float TAU = PI + PI;\nfloat sine(float a) { return sin(TAU * a); }\nfloat pwm(float a, float w) { return 1. - 2. * step(w, fract(a)); }\nfloat squa(float a) { return pwm(a, .5); }\nfloat sawt(float a) { return mix(-1., 1., fract(a-.5)); }\nfloat tria(float a) { return sawt(a * 2.) * squa(a * 2.) * squa(a); }\nfloat pv(float a) { return clamp(a, 0., 1.); }\nfloat nv(float a) { return clamp(a, -1., 0.); }\nfloat mpls(float t, float k, float r) { return pv(exp(-t * (1000. / (r+k)) - exp(-t * (1000. / k)))); }\nfloat mpls(float t) { return mpls(t, 27., 370.); }\nfloat lim(float a, float b) {return clamp(a, -b, b);}\nfloat lim(float a) {return lim(a, 1.);}\nfloat noiz(float a, float b) {\n    uint n = uint(abs(a) * (exp2(32. - 24. * pv(b)) - 1.));\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1. - 2. * float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nfloat noiz(float a) { return noiz(a, TAU-6.); }\nfloat midi(float n) { return 13.75 * exp2((n - 9.) / 12.); }\n                    \n/* \nparams are floats, funcs return floats\nsine(a) - sine wave\nsqua(a) - square wave\ntria(a) - triangle wave\nsawt(a) - sawtooth wave\nwhere a is the phase angle measured in turns\ni.e. a single cycle goes from 0.0 to 1.0\n\npwm(a, b) - pulsewidth modulated square wave \nwhere a is the phase angle\nand b is the width of the positive section of the pulse\n\npv(a) - positive component of a clamped to 1.\nnv(a) - negative component of a clamped to -1.\nlim(a) - limit a between -1 and 1.\nlim(a, b) - limit a between -b and b.\n\nmpls(t, k, r) - impulse function\nwhere t is the time in seconds\nk is attack time and r is release time\nroughly approximated to milliseconds\n\nnoiz(a, b) - noise function \nwhere a is the seed value\nb is the bitcrush amount between 0.0 and 1.0\nto scale from 32-bit to 8-bit\n\nmpls(t) and noiz(a) are shorthand functions\npreset to nice sounding values\n\nmidi(n) - converts a midi note number to its frequency\n\nThe rest of the code makes the song and visuals\n*/\n\nfloat snare(float t) {\n    float s = noiz(t, .75) * mpls(fract((t) / 2.), 2.5, 25.);\n    s += noiz(t, .85) * mpls(fract(t / 2.), 2.5, 25.);\n    return lim(s) / 2.;\n}\nfloat kick(float t) {\n    if (t < 0.) return 0.;\n    float s = sine(midi(45.) * t / 1.5) + tria(midi(45.) * t / 2.);\n    s *= mpls(fract(t / 2.), 24., 38.);\n    s += sine(t * 55.) * mpls(fract(t / 2.), 24., 140.) * .4;\n    s += noiz(t, .9983) * mpls(fract(t / 2.), 24., 40.) * .15;\n    s = mix(s, clamp(s, -.75, .44), .5);\n\treturn s;\n}\nfloat crash(float t) {\n    if (t < 0.) return 0.;\n    return lim(noiz(t) * mpls(t, 123., 200.), .3) * .7;\n}\nfloat hihat(float t) {  \n    if (t > 114.) return 0.;\n    return noiz(t) * mpls(fract(t * 4.), 2.5, 83.);\n}\nfloat tom(float t, float f) {\n    float s = 0.;\n    s += tria(fract(t * midi(45.) * f * .995)) * mpls(t, 12., 180.);\n    s -= tria(fract(t * midi(45.) * f * 1.005)) * mpls(t, 23., 222.);\n    s += sine(fract(t * midi(57.) * f)) * mpls(t, 13., 102.);\n    s /= 2.;\n    s += noiz(t, 1. - f/10.) * mpls(t, 1., 20.) ;\n    s /= 2.;\n    return lim(s); \n}\nfloat tomfill (float t) {\n    t = mod(t, 64.);\n    float s = 0.;\n    s = tom(t-6.75, .799) *.7;\n    s += tom(t-7., .801);\n    s += tom(t-7.5, .608) * .9;\n    s += tom(t-62., .808);\n    s += tom(t-62.125, .796) *.8;\n    s += tom(t-62.25, .801);\n    s += tom(t-62.375, .798) *.8;\n    s += tom(t-62.5, .649);\n    s += tom(t-62.625, .641) * .8;\n    s += tom(t-62.75, .641);\n    s += tom(t-62.875, .640) * .8;\n    s += tom(t-63., .645);\n    s += tom(t-63.25, .640);\n    s += tom(t-63.5, .283) *.85;\n    s += tom(t-63.75, .290) *.9;\n    return lim(s*1.5);\t\n}\nfloat drums (float t) {\n    if (t > 129.) return 0.;\n    float s = hihat(t + .125) * abs(sawt(t / 4.)) * .8 * (1. - step(mod(t,64.), 16.));\n    s += hihat(t);\n    s *= .35 + sawt(t * 2.) * .1; \n    s *= 1. - step(t, 8.);\n    s += crash(mod(t, 64.))+snare(t+1.)+tomfill(t);\n    s *= .3;\n    s += kick(t) * .76;\n    return lim(s);\n}\nfloat synth (float t) {\t\n    if (t > 128.33) return 0.;\n    float s = 0.;\n    float shift = 1. + .25 * squa(t/8.) + .12 * nv(pwm(t/4., .875) * pwm(t/8., .875));\n    float root = fract(t * midi(45.) * shift);\n    float fifth = fract(t * midi(52.) * shift);\n    s += tria(root) * (mod(t, 32.) > 16. ? pv(sine(t*4.)) : mpls(fract(t * 4.), 55., 275.));\n    s += tria(fifth) * pv(sine(t*4.)) * pv(sawt(t / 4.));\n    s += tria(fifth + fract(t)) * pv(tria(t*3.5)) * pv(sawt(t / 4.));\n    s /= 2.7;\n    return lim(s);\n}\nfloat snippet (float t) {\n    float b = mod(t, 4.);\n    float s = 0.;\n    s += sawt(b * midi(61.)) * mpls(b, 4., 160.);\n    s += sawt(b * midi(68.)) * mpls(b - .25, 4., 160.);\n    s += sawt(b * midi(63.958)) * mpls(b - .5, 4., 160.);\n    s /= 5.;\n\treturn s;\n}\nfloat sniplink (float t) {\n \tif (mod(t,64.) > 48.) return 0.;\n    float b = mod(t, 8.);\n    float s = 0.;\n    s += sawt(b * midi(61.)) * mpls(b, 10., 120.);\n    s += sawt(b * midi(68.)) * mpls(b - .5, 20., 120.);\n    s += sawt(b * midi(59.)) * mpls(b - 1.01, 15., 130.);\n    s += sawt(b * midi(61.)) * mpls(b - 1.5, 10., 120.);\n    s /= 5.;\n\treturn s;\n}\nfloat melody (float t) {\n    if ((mod(t-1.,64.) < 16.)||(t>122.)) { return 0.; }\n    else {\n        float s = 0.;\n        s += snippet(t - 1.5);\n        s += sniplink(t - 14.5);\n        s *= .5;\n        s += snippet(t - 1.375);\n        s += sniplink(t - 14.375);\n        s *= .66;\n        s += snippet(t - 1.25);\n        s += sniplink(t - 14.25);\n        return lim(s);\n    }\n}\t\t       \nfloat master (float t) {\n    float m = 0.;\n    int reverb = 2 + (((t > 32.) && (t < 62.) || ((t > 96.)) && (t < 126.)) ? 2 : 0);   \n    for (int i = 0; i < reverb; i++) {\t\n        t -= .01011 * float(i);\n        if (t > 0.) {\n            float s= drums(t) + synth(t) + melody(t) * .475;\n            s *= 1.23 - float(i) / float(reverb+1);\n            m += lim(s); \n        }\n        else return 0.;\n    }\n    return lim(m);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}