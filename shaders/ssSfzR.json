{
    "Shader": {
        "info": {
            "date": "1645611467",
            "description": "metaballs colored by normal vector.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssSfzR",
            "likes": 7,
            "name": "odos|metaballs",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "ErinZ",
            "viewed": 416
        },
        "renderpass": [
            {
                "code": "#define TMIN 0.01\n#define TMAX 200.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.1415926\n\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v )\nfloat logo(vec2 uv);\n\n//========SDFunctions========\nfloat sdSphere(vec3 p, vec3 o, float r){\n    return length(p-o)-r;\n}\n//===============TRANSFORM=================\nmat2 rotate(float a){\nreturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nfloat smUni( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n//===============RENDER===================\n//Scene\nfloat f(vec3 p){\n    p.zx*=rotate(iTime);\n    p.yz*=rotate(iTime);\n    float k = .7;\n    float d1 = sdSphere(p,vec3(sin(iTime*.5)),1.3);//center sphere\n    float d2 = sdSphere(p,vec3(0,2.*sin(iTime),0.),.5);\n    float d = smUni(d1,d2,k);\n    \n    float d3 = sdSphere(p,vec3(sin(iTime+5.),0,2.*sin(iTime+5.)),.9);\n    d= smUni(d,d3,k);\n     \n    float d4 = sdSphere(p,vec3(-cos(iTime+.3),cos(iTime+.3),cos(iTime+.3)),.8);\n    d= smUni(d,d4,k);\n    \n    float d5 = sdSphere(p,vec3(3.*cos(iTime+.7),0.,.5),.3);\n    d= smUni(d,d5,k);\n    \n\n    return d;\n}\nfloat rayMarch(in vec3 ro, in vec3 rd) {\n    float t = TMIN;\n    for(int i = 0; i < RAYMARCH_TIME ; i++) {\n        vec3 p = ro + t * rd;\n        float d = f(p);\n        t += d;\n        if(d < PRECISION || t > TMAX)\n            break;\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * f(p + k.xyy * h) +\n        k.yyx * f(p + k.yyx * h) +\n        k.yxy * f(p + k.yxy * h) +\n        k.xxx * f(p + k.xxx * h));\n}\n\nmat3 setCamera(in vec3 camtar, in vec3 campos, in float camro){\n    vec3 z = normalize(camtar-campos);\n    vec3 cp = vec3(sin(camro),cos(camro),0.);\n    vec3 x = normalize(cross(cp,z));\n    vec3 y = cross(z,x);\n    return mat3(x,y,z);\n}\nvec3 render(vec2 uv){\n    vec3 lightPos = vec3(-5., 5.,-5);//light\n\n    //SET Camera\n    vec3 cam_tar = vec3(-1,3,2);//cam target\n    vec3 cam_pos = cam_tar +vec3(-3,8,5);//cam position\n\n\n    vec3 rd = vec3(uv,9.); //decide view width\n    rd = normalize(setCamera(cam_tar,cam_pos,0.)*rd);//viewing frustum\n\n    float t = rayMarch(cam_pos,rd);//raymarching\n    \n    vec3 color = vec3(0);//background\n    if(t > TMAX) return color; \n    \n    vec3 p = cam_pos + t*rd;\n    vec3 n = calcNormal(p);\n\n    color = n*.5+.5;\n    // fog\n    color *= exp( -0.0001*t*t*t );\n    \n    return color;\n}\nvec2 getuv(vec2 coord){\n    return (2.*coord-iResolution.xy)/iResolution.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    #if AA>1\n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 offset = 2. * (vec2(float(m), float(n)) / float(AA) - .5);\n            vec2 uv = getuv(fragCoord + offset);\n    #else\n            uv = getuv(fragCoord);\n    #endif\n            color += render(uv);\n    #if AA>1\n        }\n    }\n    color /= float(AA*AA);\n    #endif\n    \n\n \n    color = mix(color,vec3(1),logo(uv));\n    fragColor = vec4(color,1.0);\n}\n\n \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}