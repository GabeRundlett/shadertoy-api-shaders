{
    "Shader": {
        "info": {
            "date": "1472323316",
            "description": "(The obstacle placement is broken since some Shadertoy update, I may fix it when I get around to it)\n\nSee shader comment for description.",
            "flags": 112,
            "hasliked": 0,
            "id": "4lc3Ws",
            "likes": 25,
            "name": "HyperTunnel [Game]",
            "published": 3,
            "tags": [
                "tunnel",
                "game",
                "polygon",
                "hyper"
            ],
            "usePreview": 0,
            "username": "lara",
            "viewed": 1236
        },
        "renderpass": [
            {
                "code": "/*\n\t================\n\t=== Controls ===\n\t================\n\n    Arrows keys: move to avoid obstacles\n    Spacebar: restart\n\n\tYou can change the resolution in BufA to make it playable in fullscreen.\n\n\t=============\n\t=== Setup ===\n\t=============\n\n    BufA = Logic\n    BufB = Rendering\n    BufC = Font\n\n\t=================\n\t=== Changelog ===\n\t=================\n\n\t28.08.16\n\t- Switched BufB and BufC\n\t- Cleaned up and commented code\n\t- Improved transition timing\n\t- Obstacles are now placed on all edges and corners\n\t- obstacles now stretch along the full diameter of the tunnel\n\n    =============\n    == Credits ==\n    =============\n\n    Bit Packed Sprites by Flyguy (Font rendering)\n    https://www.shadertoy.com/view/XtsGRl\n\n\tMusic by the talented chip-musican chipzel\n\thttps://soundcloud.com/chipzel/to-the-sky\n\n*/\n\n#define load(a,b) texture(b,(a+0.5)/iResolution.xy)\nconst vec2 tex_state = vec2(1,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float res = load(tex_state, iChannel0).w;\n    fragColor = texture(iChannel1, fragCoord.xy/iResolution.xy*res);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n#define inside_range(a) (fragCoord.x >= a.x+0.5 && fragCoord.x <= (a.x+a.z)+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) texture(b,(a+0.5)/iResolution.xy)\n\n#define T iTime\n#define PI 3.14159\n#define TAU (PI*2.)\n\nconst float _resolution = 1.;\n\n// if you change these do the same in BufB\nconst int _num_obstacles = 5;\nconst int _num_edges = 6;\n\nconst vec2 tex_tunnel = vec2(0,0);\nconst vec2 tex_state = vec2(1,0);\nconst vec2 tex_animation = vec2(2,0);\nconst vec3 tex_obstacles = vec3(0,1,_num_obstacles);\n\nvec3 hash(float n)\n{\n    vec3 h = vec3(\n        dot(vec3(n),vec3(195,281,379)),\n        dot(vec3(n),vec3(464,575,643)),\n        dot(vec3(n),vec3(736,822,991))\n    );\n\n    return fract(sin(h)*5534.0);\n}\n\n// Smooth transition from -1 to 0 to 1 with a short sustain period for each integer\nfloat f(float k)\n{\n\treturn (smoothstep(0.,1.,k*(3.-k*2.))-.5)*(smoothstep(-.1,1.,abs(k*(2.5-k)*4.-2.)-1.))*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //_num_edges += floor((sin(T)+1.)+.5);\n    \n    if (inside(tex_tunnel))\n    {\n        // x = user's x/θ position on the plane\n        // y = undefined (used to be # of edges but decided to keep it constant)\n        // z = tunnel radius\n        // w = transition variable (1 = fully closed top, 0 = flat, -1 = fully closed bottom)\n        \n        vec4 s = load(tex_state,iChannel0);\n        vec4 t = load(tex_tunnel,iChannel0);\n        \n        // Game over, stop the logic update loop\n        if (s.x > 0.) { fragColor = t; return; }\n        \n        float key_left  = texture(iChannel3, vec2(37.5/256.,0)).x;\n        float key_right = texture(iChannel3, vec2(39.5/256.,0)).x;\n       \n        t.x += (key_left-key_right)/100.;\n        t.y = float(_num_edges);\n        t.z = 1.;\n        \n        // relative game time\n        float x = (s.y-s.z)*0.5+14.5;\n    \tt.w = f(clamp((cos(x*.1)+.95),0.,1.)); //(smoothstep(-1.25,.5,cos(x/2.))-.5)*smoothstep(-1.,.5,sin(x))*2.;\n\n        // don't allow jumping the gap when the tunnel is partially opened\n        if (fract(t.w) != 0. || t.w == 0.) t.x = clamp(t.x,-1., 1.);\n        // wrap the x coordinate to allow passing the gap\n        else if (t.x > 1.) t.x = -1.; else if (t.x < -1.) t.x = 1.;\n        \n        fragColor = t;\n    }\n    else if (inside_range(tex_obstacles))\n    {\n        // x = x/θ-position\n        // y = height\n        // z = z position\n        // w = hit indicator\n        \n        float i = fragCoord.x-.5;\n        \n        vec4 s = load(tex_state,iChannel0);\n        vec4 t = load(tex_tunnel,iChannel0);\n        vec4 o = load(tex_obstacles.xy+vec2(i,0),iChannel0);\n\t\tfloat key_space = texture(iChannel3, vec2(32.5/256.,0)).x;\n        \n        // adjust the obstacle's x coordinate to evenly spaced (floting) points\n        float x = floor(o.x*t.y)/t.y;\n        float z = o.z-s.y;\n        \n        if (abs(x) == floor(t.y/2.)) x = abs(x)*sign(t.x);\n        \n        // cheap collision detection\n        if (iFrame > 2 && z <.3 && z > 0. && (abs(t.x-x) < .1 || (t.w > .9 && abs(t.x-x+floor(t.y/2.)*sign(x)/t.y*2.) < .1))) { o.w = 1.; }\n        \n        if (((iFrame < 2 || o.z < s.y) && s.x < 1.) || (key_space > 0. && s.x > 0.))\n        {\n            vec3 h = hash(iDate.w+i);\n            o.x = (h.x-.5)*2.;\n            o.y = 1.;\n            o.z = s.y + 1. + i + h.z * 10. + (iFrame < 2 || s.x > 0. ? 0. : 10.);\n            o.w = 0.;\n        }        \n        \n        fragColor = o;\n    }\n    else if (inside(tex_state))\n    {\n        // x = game state (0 = running, .5 = reset, 1 = game over)\n        // y = time\n        // z = game over time\n        // w = resolution \n        \n        vec4 s = load(tex_state,iChannel0);\n        float key_space = texture(iChannel3, vec2(32.5/256.,0)).x;\n        \n        // Game over when any obstacle indicates that it has been hit (o.w = 1)\n        for(int i = 0; i < _num_obstacles; i++)\n        {\n            vec4 o = load(tex_obstacles.xy+vec2(i,0),iChannel0);\n            if (o.w > 0.) { s.x = 1.; break; }\n        }\n        \n        // Initialize time variable\n        if (iFrame <2) s.y = 0.;\n        \n        // \n        if (s.x < 1.) s.y += min(T/120.*.2,.2);\n        \n        if (s.x == .5) s.x = 0.;\n        \n        if (key_space > 0. && s.x > 0.)\n        {\n            s.x = 0.5;\n            s.z = s.y;\n        }\n        \n        s.w = _resolution;\n        \n        fragColor = s;\n    }\n    //else if (inside(tex_animation))\n    //{\n    //    vec4 s = load(tex_animation,iChannel0);\n    //    \n    //}\n    else\n    {\n        discard;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) texture(b,(a+0.5)/iResolution.xy)\n\nconst int _num_obstacles = 5;\nconst int _num_edges = 6;\nconst int _num_objects = 2;\n\n// number of iterations to generate one half of the tunnel\n// when the number of edges is even we need n+1 iterations\n// since the tunnel is mirrored vertically along the middle of top and bottom edge\nconst float _num_edges_h = floor(float(_num_edges)/2.+.5)+mod(float(_num_edges)+1.,2.);\n\nconst vec2 tex_tunnel = vec2(0,0);\nconst vec2 tex_state = vec2(1,0);\nconst vec3 tex_obstacles = vec3(0,1,1);\n\n// ------------------------------\n\n#define S 0.0 // # of extra samples for antialiasing\n#define I 2   // Reflections\n\n#define PI 3.14159\n#define TAU (PI*2.)\n\nstruct Cam\n{\n    vec3 u; // up vector\n    vec3 p; // position\n    vec3 t; // target\n};\n    \nstruct Ray\n{\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Hit\n{\n    vec3  p; // position of intersecition\n    vec3  n; // normal of intersecition\n    float t; // distance travelled\n    int  id; // object id\n};\n\nCam _cam = Cam(vec3(0,1,0),vec3(0,1,-2), vec3(0));\n\n// gloabl variables used by startObject(), join() and endObject()\nRay _r; vec3 _n; float _tmin,_tmax;\n\nvec2 _uv;\nvec4 _s, _t;  // game state and tunnel properties\nfloat _segId; // segment id gets set in tunnel() for texture mapping\n\nHit _miss = Hit(vec3(0),vec3(0),-1e10,0);\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\nfloat checkerPattern(vec2 p){return ceil(mod(p.x+ceil(mod(p.y,1.)-.5)*.5,1.)-.5);}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (a.t < 0.0 || b.t > 0.0 && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    \n    return false;\n}\n\nHit plane(Ray r, vec3 n, float s)\n{\n    float t = dot(n,n*s-r.o)/dot(n,r.d);\n    return Hit(r.o+r.d*t,n,t,0);\n}\n\nvoid startObject(Ray r)\n{\n    _r = r;\n    _tmax = -1e10;\n    _tmin = 1e10;\n}\n\nvoid join(vec3 n, float s)\n{    \n    float t = (-dot(n,_r.o)+s)/dot(n,_r.d);\n\n    if (dot(n,_r.d)<0.0)\n    {\n        if(_tmax < t)\n        {\n            _tmax = t;\n            _n = n;\n        }\n    }\n    else\n    {\n        _tmin = min(_tmin,t);\n    }\n}\n\nHit endObject()\n{\n    float t = _tmax < _tmin ? _tmax : -1e10;\n    return Hit(_r.o+_r.d*t,_n,t,0);\n}\n\n/*\nHit box(Ray r, vec3 p, vec3 s)\n{\n    r.o -= p;\n    \n    startObject(r);\n    \n    join(vec3( 0, 1, 0),s.y);\n    join(vec3( 0,-1, 0),s.y);\n    join(vec3( 1, 0, 0),s.x);\n    join(vec3(-1, 0, 0),s.x);\n    join(vec3( 0, 0, 1),s.z);\n    join(vec3( 0, 0,-1),s.z);\n    \n    _r.o += p;\n    \n    return endObject();\n}\n\nHit sphere(Ray r, vec3 sp, float sr)\n{\n    r.o -= sp;\n\n    float a = dot(r.d,r.d);\n    float b = 2.0*dot(r.o,r.d);\n    float c = dot(r.o,r.o)-sr*sr;\n    float d = pow(b,2.0)-4.0*a*c;\n\n    if (d < 0.0) { return _miss; }\n    \n    float s = sqrt(d);\n    float t = min(-b+s,-b-s)/(2.*a);\n\n    vec3 p = r.o+sp+r.d*t;\n\n    return Hit(p, normalize(p-sp), t,0);\n}\n\n*/\n    \nHit boxRotZ(Ray r, vec3 p, vec3 s, float a)\n{\n    r.o -= p;\n    \n    mat2 m = rot(a);\n    \n    startObject(r);\n    \n    join(vec3(vec2( 0, 1)*m, 0),s.y);\n    join(vec3(vec2( 0,-1)*m, 0),s.y);\n    join(vec3(vec2( 1, 0)*m, 0),s.x);\n    join(vec3(vec2(-1, 0)*m, 0),s.x);\n    join(vec3(vec2( 0, 0)*m, 1),s.z);\n    join(vec3(vec2( 0, 0)*m,-1),s.z);\n    \n    _r.o += p;\n    \n    return endObject();\n\n}\n\n// n*(r.o+r.d*t-p) = 0\nHit rect(Ray r, vec3 p, vec3 n, vec2 s)\n{\n    vec3 nu = normalize(cross(vec3(1,0,0),n));\n    vec3 nr = normalize(cross(n,nu));\n    \n    float t = (dot(n,p)-dot(n,r.o))/dot(n,r.d);\n    vec3 q = r.o+r.d*t;\n    \n    float x = dot(q-p,nr);\n    float y = dot(q-p,nu);\n    \n    float d = length(r.o-q);\n    if (abs(x)>s.x || abs(y)>s.y || t < 0.) { d = -1e10; }\n\n    return Hit(q, n, d,0);\n}\n\nHit tunnel(Ray r, float n, float rd, float k)\n{    \n    float s = TAU/n;\n    vec2 pa = vec2(0,-.5), pb;\n\n    _segId = 0.;\n    \n    Hit h = _miss;\n\t\n    for(float i = 0.; i < _num_edges_h; i++)\n    {        \n        float a = s*k*i;\n        pb = pa + vec2(cos(a),sin(a))*rd/n*TAU*(i==0.||i==floor(n/2.)+mod(n,2.)?.5:1.);\n        \n        vec2 pab = pb-pa;\n        vec3 p = vec3(pa + pab/2.,r.o.z);\n        vec3 n = vec3(normalize(vec2(-pab.y,pab.x)),0);\n        \n        Hit t1 = rect(r,p,n,vec2(length(pab)/2.,1e10));\n        p.x = -p.x; n.x = -n.x;\n        Hit t2 = rect(r,p,n,vec2(length(pab)/2.,1e10));\n        \n        \n        if(compare(h,t1) == true) _segId = i;\n        if(compare(h,t2) == true) _segId = i;\n        \n        pa = pb;\n    }\n\n    return h;\n}\n\n// (Not actually an intersection test function)\n// Returns the x/y position and normal of the tunnel in any state for a given x/θ value\nHit tunnelSegment(float x, float n, float rd, float k)\n{\n    float s = TAU/n;\n    vec2 pa = vec2(0,-.5), pb;\n    \n    vec3 m = vec3(float(sign(x)),1,1);\n    \n    x = abs(x);\n    \n    float f = fract(x);\n    float x1 = floor(x);\n    float x2 = ceil(x);\n\n    vec2 p1,n1,p2,n2;\n    \n    for(float i = 0.; i < _num_edges_h; i++)\n    {        \n        float a = s*k*i;\n        pb = pa + vec2(cos(a),sin(a))*rd/n*TAU*(i==0.||i==n/2.?.5:1.);\n        \n        vec2 pab = pb-pa;\n        \n        if(i == x1)\n        {\n            if (x1 == 0.) p1 = pa;\n            else if (x1 >= n/2.) p1 = pb;\n            else p1 = pa + pab/2.;\n            \n            n1 = normalize(vec2(-pab.y,pab.x));\n                       \n            if (f == 0.) return Hit(vec3(p1,0)*m,vec3(n1,0)*m,0.,0);\n            \n            // TODO optimize this\n            if (mod(n,2.)==1. && i == _num_edges_h-1.)\n            {\n                p2 = mix(pb,p1*vec2(-1,1),sign(_t.w)*pow(abs(_t.w),4.));\n                n2 = mix(n1,n1*vec2(-1,1),pow(abs(_t.w),4.));\n            }\n        }\n        else if(i == x2)\n        {\n            if (x2 == 0.) p2 = pa;\n            else if (x2 >= n/2.) p2 = pb;\n            else p2 = pa + pab/2.;\n                \n            n2 = normalize(vec2(-pab.y,pab.x));\n            break;\n        }\n        \n        pa = pb;\n    }\n\n    \n    return Hit(vec3(mix(p1,p2,f),0)*m,vec3(mix(n1,n2,f),0)*m,0.,0);\n}\n\nHit trace(Ray r)\n{\n    Hit h = _miss;\n    \n    Hit o1 = tunnel(r,_t.y,_t.z,_t.w); o1.id = 0;\n    Hit o2 = _miss;\n    \n    // Loop through all the obstacles and store the closest one in _objects[1]\n    for(int i = 0; i < _num_obstacles; i++)\n    {\n        vec4 v = load(tex_obstacles.xy+vec2(i,0),iChannel0);\n        float x = floor(v.x*_t.y)/2.;\n        \n        Hit t = tunnelSegment(x,_t.y,_t.z,_t.w);\n        \n        // if the obstacle lies on the cut, split it in half :D\n        if (abs(x) == floor(_t.y/2.))\n        {\n            vec3 tn = vec3(-sign(x)*t.n.y*.05,0,0);\n        \tcompare(o2, boxRotZ(r,t.p+t.n*v.y+tn+vec3(0,0,v.z),vec3(.05,v.y,.1),atan(t.n.x,t.n.y)));\n            t.p.x = -t.p.x;\n            t.n.x = -t.n.x;\n            compare(o2, boxRotZ(r,t.p+t.n*v.y-tn+vec3(0,0,v.z),vec3(.05,v.y,.1),atan(t.n.x,t.n.y)));    \n        }\n        else\n        {\n        \tcompare(o2, boxRotZ(r,t.p+t.n*(v.y-.3)+vec3(0,0,v.z),vec3(.1,v.y+.3,.1),atan(t.n.x,t.n.y)));\n        }\n    }\n    \n    o2.id = 1;\n    \n    compare(h, o1);\n    compare(h, o2);\n    \n    return h;\n}\n\nRay lookAt(Cam c, vec2 uv)\n{\n    vec3 d = normalize(c.t-c.p);\n    vec3 r = normalize(cross(d,c.u));\n    vec3 u = cross(r,d);\n\n    return Ray(c.p, normalize(uv.x*r + uv.y*u + d));\n}\n\nvec3 getMaterialColor(Hit h)\n{\n    vec3 c = vec3(0);\n    vec3 light = vec3(0,0,_cam.p.z);\n    \n    float diff = min(max(dot(normalize(light-h.p),h.n),0.0),1.0);\n    //float spec = pow(max(dot(reflect(normalize(h.p-light),h.n),normalize(_cam.p)),0.0),50.0);\n    float dist = 3./exp(length(h.p-light)*.5);\n    \n    if (h.id == 0)\n    {\n        float f = checkerPattern(vec2(mod(_segId,2.)==0.?0.1:0.6,h.p.z));  \n        \n        c = mix(vec3(1),vec3(1,.5,0),abs(_t.w))*f;\n    }\n    else if(h.id == 1)\n    {\n        \n        c = vec3(1)-diff;\n    }\n    \n    return mix(c,vec3(1),1.-dist);\n}\n\nvec3 getColor(Hit h)\n{\n    if (h.t <= 0.0)\n    {\n        float x = pow(floor((atan(_uv.y+.2,_uv.x))/TAU*50.)/50.,2.);\n        float y = 1.-length(_uv);\n        float f = texture(iChannel3,vec2(x,0.5)).x;\n        \n        return vec3(mix(vec3(1),vec3(2),step(f,y)));\n    }\n    \n    vec3 col = vec3(0), c;\n    float ref = 0., lastRef = 0.;\n    \n    for(int i = 0; i < I; i++)\n    {\n        c = getMaterialColor(h);\n        \n        if (h.id == 0)\n        {    \n            //if (_t.w <= 0.)\n            //c = mix(c,pow(texture(iChannel2,h.p.zy).rgb,vec3(10.)),0.2);\n            ref = .1;\n        }\n        \n\t\tcol = i == 0 ? c : mix(col,c,lastRef);\n        \n        if (ref > 0.)\n        {        \n\t\t\tRay r;\n\n            r.d = normalize(reflect(h.p-_cam.p,h.n));\n            r.o = h.p+r.d*.1;\n\n            h = trace(r);\n            lastRef = ref;\n            \n            continue;\n        }\n\n        break;\n    }\n\n    return col;\n}\n\nvec2 noise(vec2 p)\n{\n    return vec2(\n        fract(sin(dot(p, vec2(50159.91193,49681.51239))) * 73943.1699),\n        fract(sin(dot(p, vec2(90821.40973,2287.622010))) * 557.965570)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Apply resolution\n    float res = load(tex_state, iChannel0).w;   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    if (uv.x > res || uv.y > res) { discard; }\n    \n    // uv with preserved aspect ratio (used for tracing and music background)\n    _uv = (2.0*gl_FragCoord.xy/res-iResolution.xy)/iResolution.yy;\n    // uv with 1:1 aspect ratio (used for vignette)\n    vec2 uvc = (2.0*fragCoord.xy/res-iResolution.xy)/iResolution.xy;\n\n\t_t = load(tex_tunnel,iChannel0);\n    _s = load(tex_state,iChannel0);\n    \n    // Map position (-1 - 1) to (0 - _num_edges)\n    _t.x = (_t.x-.0001*sign(_t.x))*_t.y/2.;\n    \n    // Get tunnel position and normal for a given x/θ value\n    Hit h = tunnelSegment(_t.x,_t.y,_t.z,_t.w);\n    \n    _cam.p = h.p;\n    _cam.u = h.n;\n    _cam.p += h.n * _t.z/2.;\n    _cam.p.z += _s.y;\n    _cam.t = _cam.p + vec3(0,0,1);\n    \n    vec3 col = getColor(trace(lookAt(_cam,_uv)));\n    \n    // Multisampling\n    for (float i = 0.0; i < S; i++)\n    { col += getColor(trace(lookAt(_cam,_uv+noise(_uv*i)/(iResolution.xy*0.5)))); }\n\n    float f = 1.-length(uvc)*.5;\n    \n    // Fake beat visualization\n    //float ct = iChannelTime[3];    \n    //if (ct > 42.) f -= (sin(ct/60.*TAU*150.)+1.)/2. * .25;\n    \n    fragColor = vec4(col/(S+1.0),1)*f;\n    \n    // Game over\n    if (_s.x > 0.)\n    {\n        f = 1.-length(uvc);\n        fragColor.rgb += texture(iChannel1,fragCoord.xy/iResolution.xy).rgb*10.-f;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 4598,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/chipzel/to-the-sky"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/* ======================= */\n/* ====== Font Code ====== */\n/* ======================= */\n\n// Bit Packed Sprites by Flyguy\n// https://www.shadertoy.com/view/XtsGRl\n\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n █     010    \n█ █    101    \n█ █    101    \n███ -> 111 -> 010 101 101 111 101 101 101 -> 712557\n█ █    101    \n█ █    101    \n█ █    101    \n*/\n\n//Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 707050.0;//706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\nvec2 res;\nvec2 print_pos = vec2(2,2);\n\n//Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(float ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n//Returns the digit sprite for the given number.\nfloat get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return 0.0;\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= 0;i--)\n    {\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0); //Clip off leading zeros.\n        \n        float digit = mod(number / pow(10.0, float(i)),10.0);\n        \n        result += sprite(get_digit(digit),CHAR_SIZE, uv - dec_pos) * clip;\n        \n        dec_pos.x += CHAR_SPACING.x * clip;\n    }\n    \n    return result;\n}\n\n#define load(a,b) texture(b,(a+0.5)/iResolution.xy)\nconst vec2 tex_state = vec2(1,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = iResolution.xy / 4.0;\n    float r = load(tex_state, iChannel0).w;\n    \n    if (iFrame > 2) { discard; }\n        \n\tvec2 uv = fragCoord.xy / 8.0 / r;\n    uv =  floor(uv);\n    \n    float d = 0.0;\n    \n    print_pos = vec2(res.x/4.0 - STRWIDTH(9.0)/2.0,res.y/4.0 - STRHEIGHT(1.0)/4.0);\n    print_pos = floor(print_pos);\n       \n    d += char(ch_g,uv);\n    d += char(ch_a,uv);\n    d += char(ch_m,uv);\n    d += char(ch_e,uv);\n    d += char(ch_sp,uv);\n    d += char(ch_o,uv);\n    d += char(ch_v,uv);\n    d += char(ch_e,uv);\n    d += char(ch_r,uv);\n    \n\tfragColor = vec4(vec3(d), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}