{
    "Shader": {
        "info": {
            "date": "1438430675",
            "description": "Updates: Fixed reflection colors. Soft shadows. Cleaned up my main.  Improved the speed a bit. Added oversampling.\nUpdate 24-12-18: Fixed some camera issues. ",
            "flags": 0,
            "hasliked": 0,
            "id": "MtfSzX",
            "likes": 2,
            "name": "Raymarching First Attempt",
            "published": 3,
            "tags": [
                "raymarching",
                "distancefields"
            ],
            "usePreview": 0,
            "username": "Aspect",
            "viewed": 1512
        },
        "renderpass": [
            {
                "code": "//My first raymarching attempt. Shadow rays + 1 bounce reflection.\n// I tried to improvise as much as I could, and \"steal\" the minimum amount of code\n//References were iq's articles and the /r/twotriangles raymarching tutorial on reddit. \n\nfloat sphere(vec3 pos, float radius)\n{\n    \n    return length(pos) - radius ;\n}\n\n//https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float minid=(a.x<b.x)? a.y:b.y;\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h),minid);\n}\n\n//from iq's raymarching primitives\nvec2 box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return vec2(min(max(d.x,max(d.y,d.z)),1.2) + length(max(d,0.0)),-44.0);\n}\n\n\nvec2 boxx( vec3 p, vec3 b,float id)\n{\n  //  mat4 rotmat=rotationMatrix(p,10.1*cos(iTime));\n  //  p=(rotmat*vec4(p,1.0)).xyz;\n //   b=b*2.;\n //   p=p*1.0;\n return vec2(length(max(abs(p)-b,0.0))-0.0,id);\n}\n\n\nvec2 boxTwist( vec3 p,vec3 size )\n{\n    float c = cos(5.0*p.y);\n    float s = sin(5.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return box(q,size);\n}\nvec2 plane(vec3 pos)\n{\n return vec2(pos.y+90.0,-99.0);   \n}\n\n//https://iquilezles.org/articles/distfunctions\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//https://iquilezles.org/articles/distfunctions\nvec2 boxDisplace( vec3 p,vec3 size )\n{\n    vec2 d1 = box((abs(cos(0.25*iTime))*.25-0.7)*p,size);\n    float d2 =1.0;\n    \n    return vec2(d1.x+d2,d1.y);\n}\n\nvec2 spheremore(vec3 pos,float radius)\n{\n    float min = 10000.0;\n    int mindex=-1;\n\n    \n    for(int i=0;i<5;i++)\n    {\n     vec3 center=vec3(16.5*cos(float(i))*sin(iTime),0.0,float(i)*11.5*cos(iTime));\n     float distance = length(pos-center)-radius;\n     if((distance)<(min)) \n     {\n         min=distance;\n         mindex=i;\n     }\n\n    }\n    \n    return vec2(min,float(mindex));\n}\n\n\n//https://iquilezles.org/articles/distfunctions\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 distfunc(vec3 pos)\n{  \n    vec2 inter=smin(( spheremore(pos/1.0,2.0)),boxDisplace(pos-vec3(0.0-7.0*cos(iTime),2.0,-9.0),vec3(5.0,5.0,5.0)),3.0 );\n    vec2 ops=opU(plane(pos),inter );\n    return ops;\n\n}\nvec2 distfunc2(vec3 pos)\n{  \n  return boxx(pos,vec3(34.5,34.5,44.5),0.);\n//  return mandel(pos);\n //   return manDE(pos);\n\n}\n\n\n\nvec3 retcol(float identif)\n{\n vec3 color=vec3(0.0);\n    \n    if(identif==0.0)\n    {\n        color=vec3(0.7,0.7,0.9);\n    }\n    else if(identif==1.0)\n    {\n     \tcolor=vec3(0.0,0.0,0.00);   \n    }\n     else if(identif==2.0)\n    {\n     \tcolor=vec3(0.1,0.2,0.8);   \n    }\n     else if(identif==3.0)\n    {\n     \tcolor=vec3(0.1,0.6,0.9);   \n    }\n     else if(identif==4.0)\n    {\n     \tcolor=vec3(0.2,0.9,0.6);   \n    }\n     else if(identif==-44.0)\n    {\n     \tcolor=vec3(1.5,1.5,1.5);   \n    }\n     else if(identif==-99.0)\n    {\n     \tcolor=vec3(0.8,0.1,0.2);   \n    }\n    else\n    {\n        color=vec3(0.0,1.0,1.0);   \n    }\n    \n    return color;\n    \n}\n\n\nvec3 rayMarch2(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i <10; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist = distfunc2(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini)\n        {\n            mini=dist.x;\n            \n        }\n    }\n    return pos;\n}\n\n\n\n\nvec3 rayMarch(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 120; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist = distfunc(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\nvec3 shadowMarch(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 40; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist = distfunc(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n        dist.x=mini;\n    }\n    return pos;\n}\n\n\n\n//https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\nvec3 calculateNormal(float EPSILON, vec3 pos)\n{\n  \tvec2 eps = vec2(0.0, EPSILON);\n\tvec3 normal = normalize(vec3(\n    distfunc(pos + eps.yxx).x - distfunc(pos - eps.yxx).x,\n    distfunc(pos + eps.xyx).x - distfunc(pos - eps.xyx).x,\n    distfunc(pos + eps.xxy).x - distfunc(pos - eps.xxy).x));\n            \n    return normal;\n}\n\nvec3 tempNormal(vec3 pos,float id,float EPSILON)\n{\n    vec3 normal=vec3(0.0);\n    if(id>=0.0)\n    {\n         normal=normalize(pos-vec3(16.5*cos(float(id))*sin(iTime),0.0,float(id)*11.5*cos(iTime)));\n\n    }\n    else if(id==-99.0)\n    {\n        normal=normalize(vec3(0.0,pos.y+90.01,0.0));\n    }\n    else\n    {\n        normal=calculateNormal(EPSILON,pos);\n    }\n   return normal;\n    \n}\n\nvoid getRay(vec2 screenPos,out vec3 cameraOrigin,out vec3 rayDir)\n{\n    cameraOrigin = vec3(4.0+4.0*cos(iTime), 10.5+0.5*sin(iTime), 38.25+2.1*cos(iTime));  \n    vec3 cameraTarget = vec3(0.0, 0.0, 1.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(cameraDir,upDirection));\n\tvec3 cameraUp = normalize(cross(cameraRight,cameraDir));\n    rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n   \n\n}\n\n\nvec4 render(vec2 ScreenPos)\n{\n    vec3 rayDir=vec3(0.0);\n    vec3 pos=vec3(0.0);\n    getRay(ScreenPos,pos,rayDir);\n    \n \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 20.0; \n    float EPSILON = 0.01;\n    float totalDist = 0.0;\n    vec2 dist = vec2(EPSILON,0.0);\n    vec3 lightpos=vec3(25.0,85.0,70.0);\n    float colcheck=float(dist.y);\n    vec3 dummypos=pos;\n\n\npos=rayMarch2(dummypos,rayDir,EPSILON,dist);\n             if (dist.x <EPSILON)\n        {  \n               vec3 color=vec3(0.0);\n\n            vec2 dist = vec2(EPSILON,0.0);\n\n   \t\t\t pos=rayMarch(pos,rayDir,EPSILON,dist);\n   \t\t     colcheck=dist.y;\n\n            \n            if (dist.x <EPSILON)\n     \t\t\t{  \n\t\t\t\n\t\t\t\n    pos-=rayDir*2.*EPSILON;\n     vec3 normal=tempNormal(pos,dist.y,EPSILON);\n    \n   \n    vec3  lightdir=   normalize(lightpos-pos);  \n    vec3 halfvec= normalize(lightdir-rayDir);\n    vec3 reflected= normalize(reflect(rayDir,normal));\n    vec3 color=vec3(0.0);\n    \n    EPSILON=0.01;\n        \n    //shadow ray \n    vec2 shadowdist=vec2(EPSILON,dist.y);\n    vec3 shadowpos=shadowMarch(pos+2.0*lightdir,lightdir,EPSILON,shadowdist);\n    if((shadowdist.x<EPSILON)&&(shadowdist.y!=dist.y))\n    {\n        color=vec3(0.0,0.0,0.0);\n    }\n    else\n    {\n     \n        \n    float diffuse = max(0.0, dot(lightdir, normal));\n    float specular = pow(dot(normal,halfvec), 64.0);\n    color = vec3(retcol(dist.y)*(diffuse + specular));\n          \n     //soft shadows\n    float penumbra=85.0;\n    if(shadowdist.x<penumbra*EPSILON) color*=shadowdist.x/(penumbra*EPSILON);  \n            \n    //reflection rays  \n    EPSILON=0.0001;    \n        \n    vec2 reflectdist=vec2(EPSILON,dist.y);\n    vec3 reflecpos=shadowMarch(pos+0.1*reflected,reflected,EPSILON,reflectdist);\n      if((reflectdist.x<EPSILON)&&(reflectdist.y!=dist.y))\n      {\n              \n        vec3 lightdir2= normalize(lightpos-reflecpos);\n        vec3 halfvec2= normalize(lightdir2-reflected);\n        \n        //check if reflection point is in shadow\n        vec2 shadowrefdist=vec2(EPSILON,reflectdist);\n        vec3 shadowrefpos= shadowMarch(reflecpos+2.0*lightdir2,lightdir2,EPSILON,shadowrefdist);                      \n         \n      \n          if((shadowrefdist.x>=EPSILON))\n                 {                  \n                                          \n                vec3 reflecnormal=tempNormal(reflecpos,reflectdist.y,EPSILON);\n\n                float diffuseR = max(0.0, dot(lightdir2, reflecnormal));\n                float specularR =pow(dot(reflecnormal,halfvec2), 4.0);      \n                vec3 reflecolor= vec3(retcol(reflectdist.y)*(diffuseR+specularR));\n                color= color+0.5*reflecolor;\n                 }\n          \n        \n\n\n      }\n        \n    }    \n    \n\treturn vec4(color, 1.0);\n                    \n                }\n}\nelse\n{\n    return vec4(vec3(retcol(dist.y)),1.0);\n}\n  \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{         \n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n \n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy; \n\tscreenPos.x *= iResolution.x / iResolution.y; \n     vec2 mo = iMouse.xy/iResolution.xy;\n  \n    fragColor=render(screenPos);\n\n     vec2 fc2=fragCoord.xy + vec2(-0.125, -0.375); \n\tvec2 fc3=fragCoord.xy + vec2(+0.375, -0.125);\n\tvec2 fc4=fragCoord.xy + vec2(+0.125, +0.375);\n    vec2 fc5=fragCoord.xy + vec2(-0.375, +0.125);\n    \n     vec2 scpos2=-1.0 +2.0*fc2.xy/iResolution.xy;\n     vec2 scpos3=-1.0 +2.0*fc3.xy/iResolution.xy;\n     vec2 scpos4=-1.0 +2.0*fc4.xy/iResolution.xy;\n     vec2 scpos5=-1.0 +2.0*fc5.xy/iResolution.xy;\n    \n    scpos2.x*=iResolution.x / iResolution.y;\n    scpos3.x*=iResolution.x / iResolution.y;\n    scpos4.x*=iResolution.x / iResolution.y;\n    scpos5.x*=iResolution.x / iResolution.y;\n    \n    \n  \n    fragColor=render(screenPos);\n    fragColor+=render(scpos2)+render(scpos3)+render(scpos5);\n    fragColor/=4.;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}