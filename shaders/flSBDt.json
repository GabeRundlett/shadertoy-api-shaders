{
    "Shader": {
        "info": {
            "date": "1652901499",
            "description": "I'm pretty happy with this one\n\nCC0 if you want to use it in a game or anything",
            "flags": 0,
            "hasliked": 0,
            "id": "flSBDt",
            "likes": 13,
            "name": "Pixel Tiling",
            "published": 3,
            "tags": [
                "grid",
                "pixel",
                "pixelart",
                "cc0"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 255
        },
        "renderpass": [
            {
                "code": "#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n// Square length\nfloat mlength(vec2 p) {\n    return max(abs(p.x), abs(p.y));\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos( 6.28318*(t+d) );\n}\n\nfloat h21(vec2 a) {\n    a = mod(a, 301.); // Change 301. if you want\n    return fract(sin(dot(a, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nvec4 btlr(vec2 pos, float thr) {\n    return vec4( step( h21(pos - vec2(0,0.5)), thr ),\n                 step( h21(pos + vec2(0,0.5)), thr ),\n                 step( h21(pos - vec2(0.5,0)), thr ),\n                 step( h21(pos + vec2(0.5,0)), thr ) );\n}\n\nvec2 pattern(vec2 uv, float thr, float thk, vec4 bias) {\n    // Cut into a grid\n    vec2 ipos = floor(uv) + 0.5;\n    vec2 fpos = uv - ipos;\n    \n    // Cell edges (e.g. (1,0,0,1) => we have bottom and right edges)\n    vec4 ce = btlr(ipos, thr);\n  \n    // Draw the edges\n    float v =  ce.x * step(fpos.y, -thk);\n    v = max(v, ce.y * step(thk, fpos.y));\n    v = max(v, ce.z * step(fpos.x, -thk));\n    v = max(v, ce.w * step(thk, fpos.x));\n    \n    // (I'm only using 1.5 because thk = 0.25, 0.375 work well together)\n    thk *= 1.5;\n    \n    // Draw smaller edges (so we can keep v as an outline)\n    // bias determines which smaller edges get drawn/removed\n    float v2 =   bias.x * ce.x * step(fpos.y, -thk);\n    v2 = max(v2, bias.y * ce.y * step(thk, fpos.y));\n    v2 = max(v2, bias.z * ce.z * step(fpos.x, -thk));\n    v2 = max(v2, bias.w * ce.w * step(thk, fpos.x));\n\n    // Centre a grid at current grids corners, check edges attached to it        \n    // If there aren't any, don't draw a corner block\n    vec2 ipos2 = floor(uv - 0.5) + 0.5;\n    vec2 fpos2 = uv - 0.5 - ipos2;\n\n    // Shifted cell edges + number of edges in shifted cell\n    vec4 tle = btlr(ipos2 + 0.5, thr);\n    float sum = tle.x + tle.y + tle.z + tle.w;\n    \n    // Draw corner \"blocks\" if sum > 0\n    v = max(v, step(mlength(fpos2), 0.125) * (1. - step(sum,0.)));\n   \n    // Exterior, interior\n    return vec2(v, v2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float osc = thc(3., uv.x - 0.5 * iTime);\n\n    uv += vec2(2,-1) * iTime / 32.;\n    uv *= 12.;\n    uv.y += 0.5 * osc;\n    \n    //uv.x = mix(uv.x, uv.x -0.5 + 0. * h21(floor(uv)), 0.5 + 0.5 * thc(4., 1.25 * uv.y + iTime));  \n          \n    // Threshold + thickness + which sides are removed internally (bias)\n    float thr = 0.75 - 0.25 * osc;\n    float thk = 0.25;\n    vec4 bias = vec4(1,0,1,0); // vec4(1,1,0,0); //vec4(1,0.25,1,0.25);\n    \n    // Get layer stuff\n    vec2 p1 = pattern(uv, thr * 0.25,  thk, bias);\n    vec2 p2 = pattern(uv, thr * 0.5,   thk, bias);\n    vec2 p3 = pattern(uv, thr * 0.75,  thk, bias);\n    vec2 p4 = pattern(uv, thr * 0.875, thk, bias);\n   \n    // Remove interior from exterior + darken\n    float v1 = (p1.x - p1.y) * 0.75;\n    float v2 = (p2.x - p2.y) * 0.25;\n    float v3 = (p3.x - p3.y) * 0.125;\n    float v4 = (p4.x - p4.y) * 0.0625;\n    \n    // Mix layers (mix with exterior so layers don't overlap)\n    float v = mix(v2, v1, p1.x);\n          v = mix(v3, v,  p2.x);\n          v = mix(v4, v,  p3.x);\n   \n    // Invert\n    v = 1. - v;\n    \n    vec3 col = v * pal(-0.1 * osc, 0.25 * vec3(1,0,0)/3.);\n \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}