{
    "Shader": {
        "info": {
            "date": "1720107897",
            "description": "kilobyte raymarcher for genuary14 (997B)\nexpanded and commented\nclick to show grid: top row = separate components of SDF, bottom = combined components of SDF\nrelease to show grid component in full screen. bottom right cell shows the full combined scene",
            "flags": 0,
            "hasliked": 0,
            "id": "43KXzG",
            "likes": 1,
            "name": "kbmarcher genuary14 24 commented",
            "published": 3,
            "tags": [
                "raymarcher",
                "kilobyte"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 43
        },
        "renderpass": [
            {
                "code": "// KBMARCHER GENUARY14 EXPLAINED\n// kbmarcher was well received so i thought i'd break it down a bit\n\n// these are just shorthands to save characters, make coding easier\n#define T iTime \n#define R iResolution \n\nfloat nsin(float x){return sin(x)*0.5+0.5;}\n\n// DEBUGGING\n// this section is exclusive to the commented version and is used to add debug modes\n// i like using defines as a sort of enum to make the code readable further down\n#define DISPLAY_ANIM -1\n#define DISPLAY_GRID 0\n#define DISPLAY_IND1 1\n#define DISPLAY_IND2 2\n#define DISPLAY_IND3 3\n#define DISPLAY_IND4 4\n#define DISPLAY_IND5 5\n#define DISPLAY_SUM1 6\n#define DISPLAY_SUM2 7\n#define DISPLAY_SUM3 8\n#define DISPLAY_SUM4 9\n#define DISPLAY_SUM5 10\n\n// all of this is also new to this version and is used to \n// break the display into a grid for debugging/interactivity\n#define CLICK (iMouse.z>0.)\nint getCell(vec2 uv) {\n    int cell = 1;\n    if (uv.y < 0.5) cell += 5;\n    return cell + int(uv.x*5.);\n}\nint displayMode() {\n    if (iMouse.x == 0.) return DISPLAY_ANIM;\n    if (CLICK) return DISPLAY_GRID;\n    \n    vec2 muv = abs(iMouse.xy)/R.xy;\n    \n    return getCell(muv);\n}\n\n// UTILITY FUNCTIONS\n// we define a couple of functions up top that are reused many times below\n// to save space and help with codeing & readability\n\n// remap smoothstep to accept \"midpoint of gradient, width of gradient, value\"\n// instead of \"start of gradient, end of gradient, value\"\n// i find this a lot more intuitive and easier to adjust  \n#define SMOOTHSTEP_REMAP(midpoint, width, x) smoothstep(midpoint - width, midpoint + width, x) \n// normally i give this a shorter name like SS\n\n// a gyroid SDF: https://en.wikipedia.org/wiki/Gyroid\n// this scene is mostly just a bunch of these combined\n#define GYROID(p) dot(sin(p.xyz), cos(p.zxy))\n// you could also declare it like so:\n// float sdGyroid(vec3 p) {return dot(sin(p.xyz), cos(p.zxy));}\n// and probably should unless you really want to save 15 chars\n\n\n// This function designs the 3d scene.\n// for any input 'pos' it tells you how far away the nearest surface is\nfloat map(in vec3 pos, in vec2 uv) {\n    // starts with the base gyroid shape\n    float gyroidedGyroid = GYROID((pos * 10.0 + 0.8 * GYROID((pos * 8.0))));\n    // add a horizontal striping displacement effect\n    float horizontalLineEffect = (1.0 + 0.2 * sin(pos.y * 600.0)); \n    // add a tunnelish sine wave offset\n    float timeBasedEffect = (1.0 + sin(T + length(pos.xy) * 10.0));\n    // this has an occasional flattening effect at different depths\n    float revealLayers = 0.3 * sin(T * 0.15 + pos.z * 5.0 + pos.y);\n    // very high frequency gyroid adds the halftone effect\n    float gyroidModulation = (2.0 + GYROID((pos * (sin(T * 0.2 + pos.z * 3.0) * 350.0 + 250.0))));\n    \n    float a = gyroidedGyroid;\n    float b = horizontalLineEffect;\n    float c = timeBasedEffect;\n    float d = revealLayers;\n    float e = gyroidModulation;\n    float G = GYROID((pos*10.)); // used as a base shape to demonstrate the various modulations\n    \n    int display_mode = displayMode();\n    if (display_mode == DISPLAY_IND1) return a;\n    if (display_mode == DISPLAY_IND2) return G * b;\n    if (display_mode == DISPLAY_IND3) return G * c;\n    if (display_mode == DISPLAY_IND4) return G * d;\n    if (display_mode == DISPLAY_IND5) return G * e;\n    if (display_mode == DISPLAY_SUM1) return a;\n    if (display_mode == DISPLAY_SUM2) return a*b;\n    if (display_mode == DISPLAY_SUM3) return a*b*c;\n    if (display_mode == DISPLAY_SUM4) return a*b*c + d;\n    if (display_mode == DISPLAY_SUM5) return a*b*c + d*e;\n    if (display_mode == DISPLAY_GRID) {\n        int uvCell = getCell(uv);\n        if (uvCell==1) return a; // <-- this is the main shape \n        if (uvCell==2) return G*b;\n        if (uvCell==3) return G*c;\n        if (uvCell==4) return G*d;\n        if (uvCell==5) return G*e;\n        // bottom row\n        if (uvCell==6) return a;\n        if (uvCell==7) return a*b;\n        if (uvCell==8) return a*b*c;\n        if (uvCell==9) return a*b*c + d;\n        if (uvCell==10) return a*b*c + d*e;\n    }\n    \n    return gyroidedGyroid * horizontalLineEffect * timeBasedEffect + revealLayers * gyroidModulation;\n}\n\nfloat map(in vec3 pos) {return map(pos, vec2(0.));} \n\n// Function to compute the normal, or surface direction, at a given position\nvec3 computeNormal(in vec3 pos, in vec2 uv) {\n    // Map value at the given position\n    float mapValue = map(pos, uv); \n    // Adding a small displacement to compute gradient\n    vec2 displacement = vec2(0.06 + 0.06 * sin(pos.z), 0.0);\n    \n    // Compute gradients along x, y, and z axes\n    vec3 gradient = map(pos, uv) - vec3(\n        map(pos - displacement.xyy, uv), \n        map(pos - displacement.yxy, uv), \n        map(pos - displacement.yyx, uv)\n    );\n    \n    return gradient;\n}\n\n// Main function to set the fragment color\nvoid mainImage(out vec4 color, in vec2 pixelCoords) {\n    // Normalize pixel coordinates to the range [0, 1]\n    vec2 uv = pixelCoords / R.xy; \n    int uvCell = getCell(uv);\n    int muvCell = getCell(iMouse.xy/R.xy);\n    if (CLICK && uvCell==muvCell) { // clicked cell\n        float edgy = smoothstep(.1,.0,uv.y) + smoothstep(0.9,1.,uv.y);\n        bool isTop = uv.y > 0.5;\n        float flip = isTop ? 1. : -1.;\n        if (edgy > 0. && sin(uv.y*200. + flip*T*10.) > 0.5) {\n            color = vec4(edgy);\n            return;\n        }\n    }\n    \n    // Centered UV (from -0.5 to 0.5)\n    vec2 centeredUV = (pixelCoords - R.xy / 2.0) / R.y; \n    \n    // Initialize distance and step distance\n    float dist = 0.0;\n    float stepDistance = 1.0;\n    \n    // Initial position and ray direction\n    vec3 initialPosition = vec3(0.0, 0.0, T / 4.0); \n    vec3 rayDirection = normalize(vec3(centeredUV.xy, 1.0)); \n\n    // Iteratively trace the ray and accumulate the distance\n    for (float i = 0.0; i < 90.0 && stepDistance > 0.001 && dist < 2.0; i++) {\n        dist += stepDistance;\n        initialPosition += rayDirection * dist;\n        stepDistance = map(initialPosition, uv) * 0.02;\n    }\n    \n    // Compute normal at the final position\n    vec3 normal = computeNormal(initialPosition, uv); \n    \n    // Compute grayscale value based on the normal's X and Y components\n    float grayscale = normal.x + normal.y; \n    // Apply smoothstep for anti-aliasing effect\n    grayscale *= SMOOTHSTEP_REMAP(0.9, 0.15, 1.0 / dist); \n    \n    // Set the final color (grayscale) and alpha channel\n    color = vec4(vec3(grayscale), 1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}