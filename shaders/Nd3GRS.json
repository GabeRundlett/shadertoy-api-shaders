{
    "Shader": {
        "info": {
            "date": "1629998999",
            "description": "This shader shows the Gaussian curvature of a few implicit functions",
            "flags": 0,
            "hasliked": 0,
            "id": "Nd3GRS",
            "likes": 9,
            "name": "Gaussian curvature of implicit",
            "published": 3,
            "tags": [
                "raymarch",
                "gradient",
                "curvature",
                "implicitfunction",
                "hessian",
                "autodiff",
                "automaticdifferentiation",
                "gaussiancurvature"
            ],
            "usePreview": 0,
            "username": "sibaku",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "// This shader computes the exact gaussian curvature of implicit surfaces\n// For that the Hessian matrix and gradient of the implicit equation are found\n// by using automatic differentiation\n\n// Negative curvature is blue, positive red.\n\n// If you want, you can implement your own functions, a few helpers are already there\n\n// Note that for pure distance fields, this can be accomplished easier\n// as the determinant of the hessian matrix (which in that case equals the shape operator)\n// This is used here (https://www.shadertoy.com/view/4stSRf) to compute the principal curvatures\n\n// Tracing is done with a simple first order approximation. \n// See here (https://www.shadertoy.com/view/MdtXWM) for a second order showcase, which handles\n// higher distortions better without the need to introduce a scaling hyperparameter\n\nfloat curvature(HNum3 fx) {\n\n  // numerator of gaussian curvature for implicit surfaces\n  mat4 G = mat4(fx.h);\n  G[3].xyz = fx.g;\n  G[0][3] = fx.g[0];\n  G[1][3] = fx.g[1];\n  G[2][3] = fx.g[2];\n\n  G[3][3] = 0.0;\n\n  float gl2 = dot(fx.g, fx.g);\n\n  return -determinant(G) / (gl2 * gl2);\n}\n\nHNum3 a_length2(HNum3 x, HNum3 y, HNum3 z) {\n  return add(mult(x, x), add(mult(y, y), mult(z, z)));\n}\n\nHNum3 a_length2(HNum3 x, HNum3 y) { return add(mult(x, x), mult(y, y)); }\nHNum3 a_length(HNum3 x, HNum3 y) { return a_sqrt(a_length2(x, y)); }\n\nHNum3 a_length(HNum3 x, HNum3 y, HNum3 z) { return a_sqrt(a_length2(x, y, z)); }\n\nvoid timeblend(float showDuration, float blendDuration, int numEntries,\n               out int index, out float blend) {\n  float duration = showDuration + blendDuration;\n  // compute function offset for time\n  float timeGrid = floor(iTime / duration);\n  index = int(mod(timeGrid, float(numEntries)));\n  float inDur = iTime - timeGrid * duration;\n  // start blending to the next after show duration is over\n  blend = smoothstep(showDuration, duration, inDur);\n}\n\nHNum3 a_clamp(HNum3 a, float low, float high) {\n  return a_max(constH3(low), a_min(constH3(high), a));\n}\nHNum3 opIntersect(HNum3 d0, HNum3 d1) { return a_max(d0, d1); }\nHNum3 opUnion(HNum3 d0, HNum3 d1) { return a_min(d0, d1); }\nHNum3 opSubtract(HNum3 d0, HNum3 d1) { return a_max(d0, neg(d1)); }\n\nHNum3 opSmoothSubtraction(HNum3 d1, HNum3 d2, float k) {\n  HNum3 h = a_clamp(sub(0.5, mult(0.5 / k, add(d2, d1))), 0.0, 1.0);\n  return add(a_mix(d2, neg(d1), h), mult(k, mult(h, sub(1.0, h))));\n}\n\nHNum3 opSmoothIntersection(HNum3 d1, HNum3 d2, float k) {\n  HNum3 h = a_clamp(sub(0.5, mult(0.5 / k, sub(d2, d1))), 0.0, 1.0);\n  return add(a_mix(d2, d1, h), mult(k, mult(h, sub(1.0, h))));\n}\n\nHNum3 opSmoothUnion(HNum3 d1, HNum3 d2, float k) {\n  HNum3 h = a_clamp(add(0.5, mult(0.5 / k, (sub(d2, d1)))), 0.0, 1.0);\n\n  return sub(a_mix(d2, d1, h), mult(h, mult(k, sub(1.0, h))));\n}\n\nvoid tTwist(HNum3 x, HNum3 y, HNum3 z, float k, out HNum3 xp, out HNum3 yp,\n            out HNum3 zp) {\n  HNum3 c = a_cos(mult(k, y));\n  HNum3 s = a_sin(mult(k, y));\n\n  // rotate xz\n  xp = add(mult(c, x), mult(s, z));\n  yp = sub(mult(c, z), mult(s, x));\n  zp = y;\n}\n\nHNum3 sdSphere(HNum3 x, HNum3 y, HNum3 z, float r) {\n  HNum3 s = sub(a_length(x, y, z), r);\n  return s;\n}\n\nHNum3 sdTorus(HNum3 x, HNum3 y, HNum3 z, vec2 t) {\n\n  HNum3 qx = sub(a_length(x, z), t.x);\n  HNum3 qy = y;\n\n  return sub(a_length(qx, qy), t.y);\n}\n\nHNum3 f0(HNum3 x, HNum3 y, HNum3 z) {\n  HNum3 s = sdSphere(x, y, z, 2.0);\n  s = add(s, mult(0.2, a_sin(mult(10.0, mult(x, z)))));\n  return s;\n}\n\nHNum3 f1(HNum3 x, HNum3 y, HNum3 z) {\n\n  vec2 t = vec2(2, 0.4);\n\n  tTwist(x, y, z, 2.0, x, y, z);\n\n  HNum3 d = sdTorus(x, y, z, t);\n  return d;\n}\n\n// Combination of two spheres\n// Here you can see how, aside from the transition region, both spheres have constant curvature!\nHNum3 f2(HNum3 x, HNum3 y, HNum3 z) {\n\n  HNum3 s1 = sdSphere(x, y, z, 2.0);\n  HNum3 s2 = sdSphere(add(x, -3.0), y, add(z, 0.5), 1.5);\n\n  return opSmoothUnion(s1, s2, 0.4);\n}\n\nHNum3 f(vec3 p, int index) {\n\n  if(index == 0) {\n      return f0(varH3x(p.x), varH3y(p.y), varH3z(p.z));\n  }\n  else if(index == 1) {\n      return f1(varH3x(p.x), varH3y(p.y), varH3z(p.z));\n  }\n  else if(index == 2) {\n      return f2(varH3x(p.x), varH3y(p.y), varH3z(p.z));\n  }\n  else {\n      return constH3(0.0);\n  }\n\n}\n\nint modi(int i, int m) { return int(mod(float(i), float(m))); }\n\nHNum3 f(vec3 p) {\n  int index;\n  float blend;\n\n  const int NUM = 3;\n  timeblend(3.0, 1.0, NUM, index, blend);\n\n  HNum3 v0 = f(p, index);\n  HNum3 v1 = f(p, modi(index + 1, NUM));\n\n  return a_mix(v0, v1, blend);\n}\nmat3 rotx(float a) {\n  float ca = cos(a);\n  float sa = sin(a);\n\n  return mat3(1.0, 0.0, 0.0, 0.0, ca, sa, 0.0, -sa, ca);\n}\n\nmat3 roty(float a) {\n  float ca = cos(a);\n  float sa = sin(a);\n\n  return mat3(ca, 0.0, -sa, 0.0, 1.0, 0.0, sa, 0.0, ca);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aspect = iResolution.x / iResolution.y;\n\n  vec2 mousePx = iMouse.xy / iResolution.xy;\n\n  mousePx.y = 1.0 - mousePx.y;\n\n  mousePx -= 0.5;\n\n  const float pi = 3.14159265;\n  float theta = pi * mousePx.y;\n  float phi = -2.0 * pi * mousePx.x;\n\n  vec3 eye = vec3(0.0, 6.0, -10.0) * 0.6;\n  mat3 R = roty(phi) * rotx(theta);\n  eye = R * eye;\n  vec3 up = R * vec3(0.0, 1.0, 0.0);\n  vec3 center = vec3(0.0, 0.0, 0.0);\n  \n\n  // inverse projection and view matrices\n  mat4 PInv = perspectiveInv(radians(90.0), aspect, 0.1, 100.0);\n  mat4 VInv = lookAtInv(eye, center, up);\n\n  // normalization of screen coordinates\n  // already includes +0.5\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  vec3 rayDir = createRay(uv, PInv, VInv);\n\n  vec3 col = vec3(0.0);\n  float t = 0.0;\n  float tmax = 10.0;\n  const int max_it = 300;\n  int it = 0;\n  const float eps = 1E-2;\n\n  const vec3 bgCol = vec3(0.0);\n\n  // range in which to show the curvature values inbetween\n  const float krange = 1.0;\n\n  bool found = false;\n  // while (it < max_it && t < tmax && val.val > eps) {\n  while (it < max_it) {\n    // first order approximation with a scaling to account\n    vec3 p = eye + t * rayDir;\n    HNum3 d = f(p);\n    float dt = d.val / length(d.g);\n    t += dt * 0.25 ;\n\n    if (t > tmax) {\n      break;\n    }\n    if (dt < eps) {\n      found = true;\n      break;\n    }\n    it++;\n  }\n\n  if (found) {\n\n    vec3 p = eye + t * rayDir;\n    HNum3 d = f(p);\n\n    float K = curvature(d);\n    \n    // hopefully colorblind friendly color palette\n    // color for negative curvature\n    vec3 c0 = vec3(0.0, 66.0, 157.0) / 255.0;\n    // color for no curvature\n    vec3 c1 = vec3(255.0, 255.0, 224.0) / 255.0;\n    // color for positive curvature\n    vec3 c2 = vec3(147.0, 0.0, 58.0) / 255.0;\n\n    if (K < 0.0) {\n      col = mix(c0, c1, smoothstep(-krange, 0.0, K));\n    } else {\n      col = mix(c1, c2, smoothstep(0.0, krange, K));\n    }\n  } else {\n    col = bgCol;\n  }\n\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Part of my very simple forward-autodiff code from:\n// https://github.com/sibaku/glsl-autodiff\n// below are also functions for the camera and matrix transforms\n\n#ifndef HESSNUM_3_H_\n#define HESSNUM_3_H_\n\n// This file contains methods to compute the gradient and hessian \n// of a scalar valued 3 dimensional function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 3 dimensional function\n// These should be created by the constH3 (for constants) and varH3 (for variables) helpers\nstruct HNum3\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec3 g;\n    // The current hessian\n    mat3 h;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant HNum3\n* @param val The current value of the constant\n*/\nHNum3 constH3(in float val);\n/**\n* Creates a HNum3 corresponding to the variable with the given index\n* @param val The current value of the variable\n* @param index The variable's index\n*/\nHNum3 varH3(in float val, in int index);\n/**\n* Creates a HNum3 corresponding to the variable x (index = 0)\n* @param val The current value of the variable\n*/\nHNum3 varH3x(in float val);\n/**\n* Creates a HNum3 corresponding to the variable y (index = 1)\n* @param val The current value of the variable\n*/\nHNum3 varH3y(in float val);\n/**\n* Creates a HNum3 corresponding to the variable z (index = 2)\n* @param val The current value of the variable\n*/\nHNum3 varH3z(in float val);\nHNum3 add(in HNum3 a, in HNum3 b);\nHNum3 add(in HNum3 a, in float b);\nHNum3 add(in float a, in HNum3 b);\nHNum3 sub(in HNum3 a, in HNum3 b);\nHNum3 sub(in HNum3 a, in float b);\nHNum3 sub(in float a, in HNum3 b);\nHNum3 mult(in HNum3 a, in HNum3 b);\nHNum3 mult(in HNum3 a, in float b);\nHNum3 mult(in float a, in HNum3 b);\nHNum3 neg(in HNum3 a);\nHNum3 div(in HNum3 a, in HNum3 b);\nHNum3 div(in HNum3 a, in float b);\nHNum3 div(in float a, in HNum3 b);\nHNum3 inv(in HNum3 a);\nHNum3 a_pow(in HNum3 a, in HNum3 b);\nHNum3 a_pow(in HNum3 a, in float b);\nHNum3 a_pow(in float a, in HNum3 b);\nHNum3 a_ipow(in HNum3 x, in int n);\nHNum3 a_min(in HNum3 a, in HNum3 b);\nHNum3 a_max(in HNum3 a, in HNum3 b);\nHNum3 a_exp2(in HNum3 a);\nHNum3 a_inversesqrt(in HNum3 a);\nHNum3 a_atan(in HNum3 a);\nHNum3 a_sqrt(in HNum3 a);\nHNum3 a_sinh(in HNum3 a);\nHNum3 a_ceil(in HNum3 a);\nHNum3 a_tan(in HNum3 a);\nHNum3 a_asinh(in HNum3 a);\nHNum3 a_asin(in HNum3 a);\nHNum3 a_acosh(in HNum3 a);\nHNum3 a_abs(in HNum3 a);\nHNum3 a_exp(in HNum3 a);\nHNum3 a_cosh(in HNum3 a);\nHNum3 a_floor(in HNum3 a);\nHNum3 a_log(in HNum3 a);\nHNum3 a_atanh(in HNum3 a);\nHNum3 a_log2(in HNum3 a);\nHNum3 a_acos(in HNum3 a);\nHNum3 a_tanh(in HNum3 a);\nHNum3 a_cos(in HNum3 a);\nHNum3 a_sin(in HNum3 a);\nHNum3 a_atan2(in HNum3 y, in HNum3 x);\nHNum3 a_atan2(in HNum3 y, in float x);\nHNum3 a_atan2(in float y, in HNum3 x);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t);\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in float b, in float t);\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in float a, in HNum3 b, in float t);\nHNum3 a_mix(in float a, in float b, in HNum3 t);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define HESSIAN3(f,x, y, z,result)  {     result = f(varH3x(x), varH3y(y), varH3z(z)); }\n\n//--------------------------------\n// Utilities prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b);\n\n//--------------------------------\n// Implementation\n//--------------------------------\n\nHNum3 constH3(in float val)\n{\n    return HNum3(val, vec3(0.0), mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3(in float val, in int index)\n{   \n    vec3 g = vec3(0.0);\n    g[index] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3x(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[0] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3y(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[1] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3z(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[2] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val + b.val , a.g + b.g, a.h + b.h);\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in float b)\n{\n    return HNum3(a.val + b , a.g, a.h);\n}\n//--------------------------------\nHNum3 add(in float a, in HNum3 b)\n{\n    return HNum3(a + b.val , b.g, b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val - b.val , a.g - b.g, a.h - b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in float b)\n{\n    return HNum3(a.val - b , a.g, a.h);\n}\n//--------------------------------\nHNum3 sub(in float a, in HNum3 b)\n{\n    return HNum3(a - b.val , - b.g, - b.h);\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val * b.val, \n        a.val*b.g + b.val*a.g, \n        a.val*b.h + b.val*a.h + a_outerProduct(b.g,a.g) + a_outerProduct(a.g,b.g)\n    );\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in float b)\n{\n    return HNum3(a.val * b, b*a.g, b*a.h);\n}\n//--------------------------------\nHNum3 mult(in float a, in HNum3 b)\n{\n    return HNum3(a * b.val, a*b.g, a*b.h);\n}\n//--------------------------------\nHNum3 neg(in HNum3 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2, \n        2.0*a.val/b3*a_outerProduct(b.g,b.g) \n        - a.val/b2*b.h\n        + a.h/b1 \n        - a_outerProduct(b.g/b2, a.g)\n        - a_outerProduct(a.g/b2, b.g)\n    );\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in float b)\n{\n    return HNum3(a.val / b, a.g/b, a.h/b);\n}\n//--------------------------------\nHNum3 div(in float a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a / b.val, \n        -a*b.g/b2, \n        2.0*a/b3*a_outerProduct(b.g,b.g) - a/b2*b.h\n    );\n}\n//--------------------------------\nHNum3 inv(in HNum3 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in HNum3 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    float dda = b*(b-1.0)*pow(a.val,b-2.0); // second derivative f''(a(x))\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_pow(in float a, in HNum3 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n//--------------------------------\nHNum3 a_ipow(in HNum3 x, in int n)\n{\n    // based on https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    if (n < 0)\n    {   \n        x = div(1.0,x);\n        n = -n;\n    }\n    if (n == 0) \n    {\n        return constH3(1.0);\n    }\n    HNum3 y = constH3(1.0);\n    while (n > 1)\n    {\n        if (n % 2 == 0)\n        {   \n            x = mult(x,x);\n            \n        }\n        else\n        {    \n            y = mult(x, y);\n            x = mult(x, x);\n        }\n\n        n = n / 2;\n    }\n    \n    return mult(x, y);\n}\n\n//--------------------------------\nHNum3 a_min(in HNum3 a, in HNum3 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_max(in HNum3 a, in HNum3 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_exp2(in HNum3 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n    float dda = log(2.0)*log(2.0)*exp2(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_inversesqrt(in HNum3 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n    float dda = 0.75/pow(sqrt(a.val),5.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan(in HNum3 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -2.0*a.val/pow(1.0 + a.val * a.val, 2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sqrt(in HNum3 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n    float dda = -0.25/pow(sqrt(a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sinh(in HNum3 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n    float dda = sinh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_ceil(in HNum3 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tan(in HNum3 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n    float dda = 2.0*tan(a.val)*(1.0 + pow(tan(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asinh(in HNum3 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asin(in HNum3 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acosh(in HNum3 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(-1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_abs(in HNum3 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_exp(in HNum3 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n    float dda = exp(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cosh(in HNum3 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n    float dda = cosh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_floor(in HNum3 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log(in HNum3 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atanh(in HNum3 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = 2.0*a.val/pow(1.0 - a.val * a.val,2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log2(in HNum3 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val * log(2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acos(in HNum3 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tanh(in HNum3 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n    float dda = -2.0*tanh(a.val)*(1.0 - pow(tanh(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cos(in HNum3 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n    float dda = -cos(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sin(in HNum3 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n    float dda = -sin(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in HNum3 x)\n{\n    const float pi = 3.14159265; \n    // from https://en.wikipedia.org/wiki/Atan2\n    if(x.val > 0.0)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(y, add(n,x));\n        \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > 1E-6)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(sub(n,x),y);\n         return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= 1E-6)\n    {\n        return constH3(pi);\n    }\n    // return 0 for undefined\n    return constH3(0.0); \n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in float x)\n{\n    return a_atan2(y,constH3(x));\n}\n//--------------------------------\nHNum3 a_atan2(in float y, in HNum3 x)\n{\n    return a_atan2(constH3(y),x);\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n\n//--------------------------------\n// Implementation prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b)\n{\n    return mat3(a * b[0], a * b[1], a * b[2]);\n}\n\n\n#endif // HESSNUM_3_H_\n\n\n#ifndef MATRIX_OPS_H_\n#define MATRIX_OPS_H_\n\n// matrix operations\nmat4 translate(vec3 t)\n{\n \treturn mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(t,1.)\n        );\n}\nmat4 translateInv(vec3 t)\n{\n \treturn translate(-t);   \n}\n\nmat4 scale(vec3 s)\n{\n \treturn mat4(\n        vec4(s.x,0.,0.,0.),\n        vec4(0.,s.y,0.,0.),\n        vec4(0.,0.,s.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\nmat4 scaleInv(vec3 s)\n{\n \treturn scale(1./s);   \n}\n\nmat4 rightToLeft()\n{\n    // 1 0 0  0\n    // 0 1 0  0\n    // 0 0 -1 0\n    // 0 0 0  1\n \treturn scale(vec3(1.,1.,-1.));\n}\n\nmat4 rightToLeftInv()\n{\n    // same matrix\n    return rightToLeft();\n}\n\t\n#endif // MATRIX_OPS_H_\n\n\n\n#ifndef CAMERA_H_\n#define CAMERA_H_\n\n\n// This assumes the pixel position px to be in [0,1], \n// which can be done by (x+0.5)/w or (y+0.5)/h (or h-y +0.5 for screens\n// with top left origin) to sample pixel centers\nvec3 createRay(vec2 px, mat4 PInv, mat4 VInv)\n{\n\t \n\t// convert pixel to NDS\n\t// [0,1] -> [-1,1]\n\tvec2 pxNDS = px*2. - 1.;\n\n\t// choose an arbitrary point in the viewing volume\n\t// z = -1 equals a point on the near plane, i.e. the screen\n\tvec3 pointNDS = vec3(pxNDS, -1.);\n\n\t// as this is in homogenous space, add the last homogenous coordinate\n\tvec4 pointNDSH = vec4(pointNDS, 1.0);\n\t// transform by inverse projection to get the point in view space\n\tvec4 dirEye = PInv * pointNDSH;\n\n\t// since the camera is at the origin in view space by definition,\n\t// the current point is already the correct direction (dir(0,P) = P - 0 = P\n\t// as a direction, an infinite point, the homogenous component becomes 0\n\t// the scaling done by the w-division is not of interest, as the direction\n\t// in xyz will stay the same and we can just normalize it later\n\tdirEye.w = 0.;\n\n\t// compute world ray direction by multiplying the inverse view matrix\n\tvec3 dirWorld = (VInv * dirEye).xyz;\n\n\t// now normalize direction\n\treturn normalize(dirWorld); \n}\n\n\n\nmat4 ortho(float l, float r, float b, float t, float n, float f)\n{\n\n    \n       // translation and scale\n    return scale(vec3(2./(r-l),2./(t-b),2./(f-n))) * \n                 translate(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.));\n    \n}\n\nmat4 orthoInv(float l, float r, float b, float t, float n, float f)\n{\n    return translateInv(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.)) *\n        scaleInv(vec3(2./(r-l),2./(t-b),2./(f-n)));\n}\n\nmat4 projection(float n, float f)\n{\n \t// n 0 0 0\t0\n    // 0 n 0 0\t0\n    // 0 0 n+f\t-fn\n    // 0 0 1\t0\n    return mat4(\n        vec4(n,0.,0.,0.),\n        vec4(0.,n,0.,0.),\n        vec4(0.,0.,n+f,1.),\n        vec4(0.,0.,-f*n,0.)\n        );\n}\n\nmat4 projectionInv(float n, float f)\n{\n \t// 1/n \t0 \t0 \t\t0\n    // 0 \t1/n\t0 \t\t0\n    // 0\t0\t0 \t\t1\n    // 0\t0\t-1/fn\t(f+n)/fn\n    \n    return mat4(\n        vec4(1./n,0.,0.,0.),\n        vec4(0.,1./n,0.,0.),\n        vec4(0.,0.,0.,-1./(f*n)),\n        vec4(0.,0.,1.,(f+n)/(f*n))\n        );\n}\n\n\nmat4 perspective(float fov, float aspect, float n, float f)\n{\n \t   float l = tan(fov/2.)*n;\n       float b = l/aspect;\n    \n    \treturn ortho(-l,l,-b,b,n,f)*\n            projection(n,f)*rightToLeft();\n}\n\n\nmat4 perspectiveInv(float fov, float aspect,float n, float f)\n{\n     float l = tan(fov/2.)*n;\n       float b = l/aspect;\n    \n    return rightToLeftInv()*\n        projectionInv(n,f)*\n        orthoInv(-l,l,-b,b,n,f);\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n \t\n    vec3 z = normalize(eye-center);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = cross(z,x);\n    \n    mat4 v = mat4(\n        vec4(x.x,y.x,z.x,0.),\n        vec4(x.y,y.y,z.y,0.),\n        vec4(x.z,y.z,z.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n    \n    return v*translate(-eye);\n}\n\nmat4 lookAtInv(vec3 eye, vec3 center, vec3 up)\n{\n \tvec3 z = normalize(eye-center);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = cross(z,x);  \n    \n    return translateInv(-eye)*mat4(\n        vec4(x,0.),\n        vec4(y,0.),\n        vec4(z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\n\n\n\n#endif //CAMERA_H_",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}