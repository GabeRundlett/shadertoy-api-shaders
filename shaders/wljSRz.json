{
    "Shader": {
        "info": {
            "date": "1565705549",
            "description": "crystal exhibit, an old scene i fixed up and decided to publish\n\nControls:\nMouse to look\nArrow keys to move",
            "flags": 48,
            "hasliked": 0,
            "id": "wljSRz",
            "likes": 12,
            "name": "crystal exhibit(pathtraced)",
            "published": 3,
            "tags": [
                "raymarch",
                "raytraced",
                "crystal",
                "pathtraced",
                "exhibit"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 621
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2019\n//Image - Display pathtracing result in Buffer B with gamma correct\n\n//Controls - Mouse to look and arrow keys to move\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n    vec4 s = texelFetch(iChannel0,ivec2(u),0);\n    o = pow(s/s.w,vec4(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//camera settings\n#define CAM_POS vec3(0,-.2,-2.5)\n#define CAM_YAW 0.\n#define CAM_PITCH 0.\n#define CAM_FOV .6\n\n//control settings\n#define MOUSE_SENSITIVITY .005\n#define MOVE_SPEED .02\n\n//rendering settings\n#define VIEW_DISTANCE 10.\n#define BOUNCES 5\n#define EPSILON 2e-3\n\n//importance sampling settings\n//#define LIGHT_IMPORTANCE .1\n#define LIGHT_INTENSITY .1\n#define LIGHT_POS vec3(0,1,0)\n#define LIGHT_SIZE 0.\n#define LIGHT_COLOR vec3(1)\n\n//toggle r2 point sampling\n//#define R2_SAMPLING\n\n\n#define PI 3.141592653\n#define PI2 (PI*2.)\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Ethan Alexander Shulman 2019\n//Buffer B - Montecarlo path tracing\n\n\n//pseudo-random hash unclamped vec4 in, 0-1 vec4 out\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\n//outputs tangent and returns binormal from normal\nvec3 calculateUpRight(vec3 normal, out vec3 tangent) {\n    if (abs(normal.x) > abs(normal.y)) tangent = normalize(vec3(-normal.z, 0., normal.x));\n    else tangent = normalize(vec3(0., normal.z, -normal.y));    \n\treturn cross(normal, tangent);\n}\n\n\n//raytracing functions\nstruct rayhit {\n    vec4 diffuse,specular,//diffuse/specular.w = emission\n        normal;//normal.w = hit distance\n    float metallic,roughness,opacity,refrIndex;\n};\n\n//no ray hit\n#define NNO vec4(0,0,0,VIEW_DISTANCE)\n\n//ray marching function macros\n#define NEPS vec3(EPSILON*.1,0,0)\n#define rmarch(fname,distf,normf,iter) vec4 fname(vec3 rp, vec3 rd) {\\\nfloat s = 0.;\\\nfor (int i = 0; i < iter; i++) {\\\n    vec3 trp = rp+rd*s;\\\n    float d = distf(trp);\\\n    if (d < EPSILON) {\\\n        trp -= rd*EPSILON;\\\n        d = normf(trp);\\\n    \treturn vec4(normalize(vec3(normf(trp+NEPS)-d,\\\n                                   normf(trp+NEPS.yxz)-d,\\\n                                   normf(trp+NEPS.yzx)-d)),s-EPSILON);\\\n    }\\\n    s += d;\\\n}\\\nreturn NNO;\\\n}\n#define rmarchc(fname,distf,normf,iter,maxd) vec4 fname(vec3 rp, vec3 rd) {\\\nfloat s = 0.,ld = 1e8;\\\nfor (int i = 0; i < iter; i++) {\\\n    vec3 trp = rp+rd*s;\\\n    float d = distf(trp);\\\n    if (d < EPSILON) {\\\n        trp -= rd*EPSILON;\\\n        d = normf(trp);\\\n    \treturn vec4(normalize(vec3(normf(trp+NEPS)-d,\\\n                                   normf(trp+NEPS.yxz)-d,\\\n                                   normf(trp+NEPS.yzx)-d)),s-EPSILON);\\\n    }\\\n    s += d;\\\n    if (d > maxd && d > ld) {return NNO;}\\\n    ld = d;\\\n}\\\nreturn NNO;\\\n}\n\n//raymarching macros, only supports unsigned distance\n#define rayMarch(fname,distf,iter) rmarch(fname,distf,distf,iter)\n//limited version will stop tracing when distance above maxd for optimization\n#define rayMarchLimited(fname,distf,iter,maxd) rmarchc(fname,distf,distf,iter,maxd)\n\n//raymarching macros with seperate distance function for normal\n#define rayMarchDetailed(fname,distf,normf,iter) rmarch(fname,distf,normf,iter)\n#define rayMarchDetailedLimited(fname,distf,normf,iter,maxd) rmarchc(fname,distf,normf,iter,maxd)\n\n//volumetric distance dither, look at cloudDist function for an example\n#define VOLUME(density) step(density,fract(dot(abs(rp),vec3(.12,.23,.32)*100.)+float(iFrame)*.3183098861))*EPSILON*2.\n\n//chromatic seperation dither, look at triPrism part of rayScene function for an example\n#define CHRSC(s) h.diffuse.xyz *= s;h.specular.xyz *= s\n#define CHROMA(rc,gc,bc) int cifm = iFrame%3;\\\nif (cifm == 0) {CHRSC(vec3(3,0,0));rc}\\\nelse if (cifm == 1) {CHRSC(vec3(0,3,0));gc}\\\nelse {CHRSC(vec3(0,0,3));bc}\n\n\n//ray functions return vec4 where .w = distance to hit and .xyz is hit normal\nvec4 rayPlane(vec3 rp, vec3 rd, vec3 pos, vec3 normal) {\n    float dst = dot(rp-pos,normal)/dot(rd,normal);\n    if (dst < 0.) return vec4(normal,-dst);\n    return NNO;\n}\nvec4 rayBox(vec3 rp, vec3 rd, vec3 pos, vec3 ext) {\n    rp -= pos;\n    vec3 mind = (rp+ext)/rd, maxd = (rp-ext)/rd;\n\tmind = -(mind-step(vec3(-1e-6),mind)*(mind+VIEW_DISTANCE));\n\tmaxd = -(maxd-step(vec3(-1e-6),maxd)*(maxd+VIEW_DISTANCE));\n\tmind = min(mind,maxd);\n    \n    vec4 nrm;\n    nrm.w = VIEW_DISTANCE;\n    if (mind.x < VIEW_DISTANCE && mind.x < nrm.w) {\n        vec2 pd = abs(rp.zy+rd.zy*mind.x)-ext.zy;\n        if (max(pd.x,pd.y) < 0.) nrm = vec4(-sign(rd.x),0.,0.,mind.x);\n    }\n    if (mind.y < VIEW_DISTANCE && mind.y < nrm.w) {\n        vec2 pd = abs(rp.xz+rd.xz*mind.y)-ext.xz;\n        if (max(pd.x,pd.y) < 0.) nrm = vec4(0,-sign(rd.y),0.,mind.y);\n    }\n    if (mind.z < VIEW_DISTANCE && mind.z < nrm.w) {\n        vec2 pd = abs(rp.xy+rd.xy*mind.z)-ext.xy;\n        if (max(pd.x,pd.y) < 0.) nrm = vec4(0.,0.,-sign(rd.z),mind.z);\n    }\n    return nrm;\n}\nvec4 raySphere(vec3 rp, vec3 rd, vec3 pos, float radius) {\n    rp -= pos;\n    float c = dot(rp, rp)-radius*radius;\n    float b = dot(rd, rp), \n        d = b*b - c;\n\n    if (d >= 0.) {\n        b = -b;\n        float s = sqrt(d), t, n;\n        if (s < b) {\n            t = b-s;\n            n = 1.;\n        } else {\n            t = b+s;\n            n = -1.;\n            if (t < 0.) return vec4(0,0,0,VIEW_DISTANCE);\n        }\n        return vec4(normalize(rp+rd*t)*n,t);\n    }\n    return NNO;\n}\n\n//rotate rp,rd by yaw,pitch,roll\n#define ROTATE(yaw,pitch,roll) if (roll != 0.0) {\\\n    mat2 rm = r2(roll);\\\n\trp.xy *= rm;rd.xy *= rm;\\\n}\\\nif (pitch != 0.0) {\\\n    mat2 rm = r2(pitch);\\\n    rp.yz *= rm;rd.yz *= rm;\\\n}\\\nif (yaw != 0.0) {\\\n\tmat2 rm = r2(yaw);\\\n    rp.xz *= rm;rd.xz *= rm;\\\n}\n//inverse rotation on point p\n#define ROTATEP(p,yaw,pitch,roll) if (yaw != 0.0) {\\\n\tmat2 rm = r2(yaw);\\\n    p.xz *= rm;\\\n}\\\nif (pitch != 0.0) {\\\n    mat2 rm = r2(pitch);\\\n    p.yz *= rm;\\\n}\\\nif (roll != 0.0) {\\\n    mat2 rm = r2(roll);\\\n\tp.xy *= rm;\\\n}\n\n\n//procedural crystal distance function\nfloat crystald(vec3 p, int iter, vec3 phase, vec3 freq) {\n    float d = 1e8;\n    for (int i = 0; i < iter; i++) {\n        vec3 rot = phase+freq*float(i);\n        p = abs(p);\n        ROTATEP(p,rot.x,rot.y,rot.z);\n        vec3 cp = abs(p)-.2;\n        float cd = min(0.,max(cp.x,max(cp.y,cp.z)))+length(max(cp,0.));\n            length(max(abs(p)-.2,0.));\n        d = min(cd,d);\n    }\n    return d;\n}\n\n//crystals\n#define crystal1(p) crystald(p,1,vec3(.8,.8,0),vec3(1))\n#define crystal1u(p) abs(crystal1(p))\nrayMarchLimited(rayCrystal1B,crystal1u,16,.5)\n#define crystal1_pos vec3(1.,.1,1.)\nvec4 rayCrystal1(vec3 rp, vec3 rd) {\n    rp -= crystal1_pos;\n    return rayCrystal1B(rp,rd);\n}\n\n#define crystal2(p) crystald(p,2,vec3(0,.3,.4),vec3(1.9,.3,0))\n#define crystal2u(p) abs(crystal2(p))\nrayMarchLimited(rayCrystal2B,crystal2u,32,.5)\n#define crystal2_pos vec3(-1.,0.14,1.)\nvec4 rayCrystal2(vec3 rp, vec3 rd) {\n    rp -= crystal2_pos;\n    return rayCrystal2B(rp,rd);\n}\n\n#define crystal3(p) crystald(p,1,vec3(-.6,.5,1.4),vec3(0))\n#define crystal3u(p) abs(crystal3(p))\nrayMarchLimited(rayCrystal3B,crystal3u,16,.5)\n#define crystal3_pos vec3(-1.,0.1,-1.)\nvec4 rayCrystal3(vec3 rp, vec3 rd) {\n    rp -= crystal3_pos;\n    return rayCrystal3B(rp,rd);\n}\n\n#define crystal4(p) crystald(p,3,vec3(0),vec3(.9,2.,1.2))\n#define crystal4u(p) abs(crystal4(p))\nrayMarchLimited(rayCrystal4B,crystal4u,24,.5)\n#define crystal4_pos vec3(1.,0.1,-1.)\nvec4 rayCrystal4(vec3 rp, vec3 rd) {\n    rp -= crystal4_pos;\n    return rayCrystal4B(rp,rd);\n}\n\n\n\n//voronoi wall pattern\nfloat voronoi(vec2 u, float i) {\n\t#define l(i) length(fract(abs(u)*.011111+fract(i*vec2(1,8))+cos(u.yx*.03333+i*8.))-.5)\n\treturn l(i);\n    #undef l\n}\nfloat voronoiWall(vec2 tc) {\n    return min(voronoi(tc,.23333),voronoi(tc*1.777,.7777));\n}\n\n\n\n//ray traces function 'f' and if closest hit execute material code 'm'\n#define rt(f,m) {\\\n\tvec4 s = f;\\\n    if (s.w < h.normal.w) {\\\n        h.normal = s;\\\n        m\\\n    }\\\n}\n//rt with sphere bounds culling\n#define rtc(f,boundPos,boundRadius,m) {\\\nfloat boundDst = raySphere(rp,rd,boundPos,boundRadius).w;\\\nif ((boundDst < h.normal.w && boundDst < VIEW_DISTANCE) || length(rp-boundPos) < boundRadius) {\\\n    vec4 s = f;\\\n    if (s.w < h.normal.w) {\\\n        h.normal = s;\\\n    \tm\\\n\t}\\\n}\\\n}\n//raytrace scene\nrayhit rayScene(vec3 rp, vec3 rd) {\n    rayhit h;\n\th.normal.w = VIEW_DISTANCE;\n\n    //container, floor, ceiling and walls\n    rt(rayBox(rp,rd,vec3(0),vec3(4,1,4)),\n        h.diffuse = vec4(.8,.8,.8,0);\n    \th.metallic = 0.;\n        h.opacity = 1.;\n       \n        vec3 hp = rp+rd*s.w;\n        if (hp.y > .99) {\n       \t\t//light emission\n            hp.xz = abs(abs(hp.xz)-1.);\n       \t    h.diffuse.w = max(0.,(.5-max(hp.x,hp.z))*100.)*(.02+pow(max(0.,dot(rd,vec3(0,1,0))),10.)*.98);\n        } else if (max(abs(hp.x),abs(hp.z)) > 3.99) {\n         \t//normal mapped voronoi walls\n            vec2 tc = (vec2(dot(hp.zx,s.xz),hp.y)+10.)*70.;\n            float bdst = voronoiWall(tc);\n            tc = normalize(vec2(voronoiWall(tc+vec2(.01,0)),voronoiWall(tc+vec2(0,.01)))-bdst)*-.3;\n            h.normal.xyz = normalize(h.normal.xyz+vec3(tc.x*h.normal.z,tc.y,tc.x*h.normal.x));\n            h.diffuse = vec4(.3,.45,.52,0);\n            h.specular = vec4(.76,.82,.83,0);\n            h.metallic = .4;\n            h.roughness = .08;\n        }\n    );\n    \n    //crystal pedestals\n    #define pedestal(pos) rt(rayBox(rp,rd,pos,vec3(.2,.3,.2)),\\\n    h.diffuse = vec4(.1,.1,.1,0);\\\n    h.specular = vec4(.1,.1,.1,0);\\\n    h.metallic = .7;\\\n    h.roughness = .001;\\\n    h.opacity = 1.;);\n    \n    pedestal(vec3(1,-.5,1));\n    pedestal(vec3(-1,-.5,1));\n    pedestal(vec3(1,-.5,-1));\n    pedestal(vec3(-1,-.5,-1));\n\n    //flip refraction index inside crystal\n    #define RFLIP(df,cp) if (df(rp+rd*s.w-cp) < EPSILON) {h.refrIndex = 1./h.refrIndex;}\n    \n    //crystal 1 clear with little refraction\n    rtc(rayCrystal1(rp,rd),crystal1_pos,.4,\n       h.specular = vec4(.9,.99,.92,0);\n       h.roughness = 0.;\n       h.metallic = 1.;\n       h.opacity = 0.03;\n       h.refrIndex = .92;\n    );\n    \n    //crystal 2 rough bright green\n    rtc(rayCrystal2(rp,rd),crystal2_pos,.4,\n       h.specular = vec4(.1,.99,.1,0);\n       h.roughness = 0.02;\n       h.metallic = 1.;\n       h.opacity = .2;\n       h.refrIndex = .7;\n       RFLIP(crystal2,crystal2_pos);\n    );\n    \n    //crystal 3 blueish purple\n    rtc(rayCrystal3(rp,rd),crystal3_pos,.4,\n       h.specular = vec4(.6,.2,.99,0);\n       h.roughness = 0.005;\n       h.metallic = 1.;\n       h.opacity = .3;\n       h.refrIndex = .95;\n       RFLIP(crystal3,crystal3_pos);\n    );\n    \n    //crystal 4 yellow\n    rtc(rayCrystal4(rp,rd),crystal4_pos,.4,\n       h.specular = vec4(1,1,0.,0);\n       h.roughness = 0.;\n       h.metallic = 1.;\n       h.opacity = 0.1;\n       h.refrIndex = .6;\n       RFLIP(crystal4,crystal4_pos);\n    );\n    \n    return h;\n}\n\n//ray trace background, returns color\nvec3 rayBackground(vec3 rp, vec3 rd) {\n    return vec3(0);\n}\n\n//montecarlo path tracing\nvoid mainImage(out vec4 o, in vec2 u) {\n    //camera state control\n    if (u.x < 2. && u.y < 1.) {\n        if (iFrame == 0) {\n            if (u.x < 1.) o = vec4(CAM_POS,0);\n            else o = vec4(CAM_YAW,CAM_PITCH,-1,0);\n            return;   \n        }\n\n        vec4 s = texelFetch(iChannel0,ivec2(u),0);\n        if (u.x < 1.) {\n            //movement\n            s.w = 0.;\n            vec2 rot = texelFetch(iChannel0,ivec2(1,0),0).xy;\n            mat2 ym = r2(rot.x), pm = r2(rot.y);\n            vec3 fwd = vec3(0,0,MOVE_SPEED), right = vec3(MOVE_SPEED,0,0);\n            fwd.yz *= pm;fwd.xz *= ym;\n            right.yz *= pm;right.xz *= ym;\n            #define tk(kc,co) if (texelFetch(iChannel1,ivec2(kc,0),0).x > .5) {co;s.w = 1.;}\n            tk(38,s.xyz += fwd);\n            tk(40,s.xyz -= fwd);\n            tk(37,s.xyz -= right);\n            tk(39,s.xyz += right);\n            if (iMouse.w > 0.) s.w = 1.;\n        } else {\n            //rotation\n            if (iMouse.w > 0.) {\n                if (dot(s.zw,vec2(1)) >= 0.) s.xy -= (iMouse.xy-s.zw)*MOUSE_SENSITIVITY;\n                s.y = clamp(s.y,-PI*.48,PI*.48);\n                s.zw = iMouse.xy;\n            } else s.zw = vec2(-1.);\n        }\n        o = s;\n        return;\n    }\n    if (iFrame == 0) return;\n    \n    //initial screen rays based on camera\n\tvec3 rd = normalize(vec3((u*2.-iResolution.xy+(hash(u.xyxy+float(iFrame)*vec4(.132,.432,.342,.234)).xy*2.-1.)*1.5)/iResolution.y,1./CAM_FOV));\n\tvec2 camrot = texelFetch(iChannel0,ivec2(1,0),0).xy;\n    rd.yz *= r2(camrot.y);\n\trd.xz *= r2(camrot.x);\n\trd = normalize(rd);\n    vec4 campos = texelFetch(iChannel0,ivec2(0),0),\n        s = texelFetch(iChannel0,ivec2(u),0);\n    if (iFrame == 0 || campos.w > .5) s = vec4(0);\n\t\n    //path tracing light accumulation\n    #ifdef LIGHT_IMPORTANCE\n    bool important = false;\n    vec3 lastRp,lastRd;\n    #endif\n    vec3 rp = campos.xyz, c = vec3(1), l = vec3(0);\n    for (int b = 0; b < BOUNCES+1; b++) {\n        //raytrace\n        rayhit h = rayScene(rp,rd);\n        if (h.normal.w >= VIEW_DISTANCE) {\n         \t#ifdef LIGHT_IMPORTANCE\n            vec3 bgc = rayBackground(rp,rd);\n            if (important) {\n            \tif (dot(normalize(bgc),normalize(LIGHT_COLOR)) > .9999) l += c*bgc*LIGHT_INTENSITY;\n            } else l += c*bgc;\n            #else\n            l += c*rayBackground(rp,rd);\n            #endif\n            break;\n        }\n        rp += rd*h.normal.w;\n        \n        #ifdef UNLIT\n        o = vec4(mix(h.diffuse.xyz,h.specular.xyz,h.metallic),1);\n        return;\n        #endif\n        \n        vec4 rnd = hash(rp.xyzz+float(iFrame)*vec4(.222,.1111,PI*.1,PI*.13));\n        #ifdef R2_SAMPLING\n        //r2 random point sampling http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\t\t#define r2g 1.32471795724474602596\n        rnd.xy = fract(.5+float(iFrame)*(1.0/vec2(r2g,r2g*r2g))+rnd.xy*(.2+float(min(1,b)))*.5);\n        #endif\n                         \n        //apply hit material\n        bool specular = h.metallic > rnd.w;\n        if (specular) {\n         \tc *= h.specular.xyz;\n            #ifdef LIGHT_IMPORTANCE\n            if (important) {\n                if (dot(normalize(h.specular.xyz),normalize(LIGHT_COLOR))>.9999) l += c*h.specular.w*LIGHT_INTENSITY;\n                rp = lastRp;\n                rd = lastRd;\n                important = false;\n                continue;\n            }\n            #endif\n            l += c*h.specular.w;\n        } else {\n            c *= h.diffuse.xyz;\n            #ifdef LIGHT_IMPORTANCE\n            if (important) {\n                if (dot(normalize(h.diffuse.xyz),normalize(LIGHT_COLOR))>.9999) l += c*h.diffuse.w*LIGHT_INTENSITY;\n                rp = lastRp;\n                rd = lastRd;\n                important = false;\n                continue;\n            }\n            #endif\n            l += c*h.diffuse.w;\n            h.roughness = 1.;\n        }\n        \n        //simulate random micro surface bumps scaled by roughness\n        vec3 tang,binorm = calculateUpRight(h.normal.xyz,tang);\n        float cost = pow(rnd.x,h.roughness), sint = sqrt(1.-cost*cost), phi = rnd.y*PI2, cosp = cos(phi), sinp = sin(phi);\n        vec3 sr = vec3(sint*cosp, sint*sinp, cost);\n        sr = normalize(h.normal.xyz*sr.z+tang*sr.x+binorm*sr.y);\n        \n        //reflect off bumps for opaque and refract through bumps for translucent\n        if (h.opacity >= rnd.z) {\n            rp += h.normal.xyz*EPSILON*2.;\n            if (specular) rd = reflect(rd,sr);\n            else {\n            \trd = sr;  \n                #ifdef LIGHT_IMPORTANCE\n                //light importance sampling for very rough surfaces\n                vec3 ldir = normalize((LIGHT_POS+(rnd.zxy*2.-1.)*LIGHT_SIZE)-rp);\n                if (dot(ldir,h.normal.xyz) > 0. && LIGHT_IMPORTANCE> fract(rnd.z*100.)) {\n                    lastRp = rp;\n                    lastRd = rd;\n                    important = true;\n                    rd = ldir;\n                }\n                #endif\n            }\n        } else {\n            rd = refract(rd,sr,h.refrIndex);\n            rp -= h.normal.xyz*EPSILON*4.;\n        }\n    }\n    o = s+vec4(l,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}