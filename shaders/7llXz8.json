{
    "Shader": {
        "info": {
            "date": "1625185626",
            "description": "That rotation tracking took longer than I want to admit. I didn't really understand arcos until this moment lol.\nA good resource: https://pomax.github.io/bezierinfo/\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7llXz8",
            "likes": 4,
            "name": "Quadratic Axis Aligned BB",
            "published": 3,
            "tags": [
                "bezier",
                "quadratic",
                "casteljau"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "//black and light blue\n/*\n#define bgCol   vec3(244, 244, 248)/255.\n#define lineCol vec3(254, 215, 102)/255.*0.\n#define segCol vec3(42, 183, 202)/255.\n#define circleCol vec3(42, 183, 202)/255.\n#define segCircleCol vec3(210., 81., 224.)/255.\n#define magikCol vec3(142,142,246)/255.\n*/\n\n#define numSegments 20.\n#define showSeg\n//Cappacino pallet\n#define bgCol   vec3(60, 47, 47)/255.*0.5\n#define lineCol vec3(133, 68, 66)/255.\n#define segCol vec3(225, 244, 230)/255.\n#define circleCol vec3(255, 244, 230)/255.\n#define segCircleCol vec3(255, 244, 230)/255.\n#define magikCol vec3(60, 47, 47)/255.\n\n#define lineThickness 0.004\n#define gradLineThickness 0.004*3.\n#define segRingRadius 0.006\n#define gradRingRadius 0.03\n#define pointRingRadius 0.01\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, ringCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col, vec3 lineColor, float th){\n\n    //float dist = 1.0-smoothstep(0.004, 0.005, distToLine(A, B, p));\n    float dist = distToLine(A, B, p);\n    dist = 1.0-smoothstep(0., fwidth(dist), dist - th);\n    return mix(col, lineColor, dist);\n}\n\n\n//shorten version thx iapafoto, original version with notes is below\n//but then I went and added a matrix version to it\nvec3 drawSegments(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec3 col){\n    vec2 g, prev = p1;\n    float dt = 1./numSegments;  \n    \n    for(float t = 0.; t <= 1.+dt; t+=dt){   \n    \n\n        g = p3*(t*t) + p2*2.*(1.-t)*t + p1*(1.-t)*(1.-t);\n        \n        col = drawLine(prev,g,p,col,segCol*vec3(t, .7, .9),lineThickness);\n        col = drawRing(segRingRadius, .003, p, g, col, segCircleCol);\n        prev = g;\n    }\n    return col;\n}\n\n//calculate and draw bounding box, mix with color and return\nvec3 drawExtrema(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec3 boxCol, vec3 col){\n\n    vec2 g = vec2(0.0);\n    \n    float tx = clamp((p1.x - p2.x)/(p1.x - 2.*p2.x + p3.x),0.,1.);\n    float x = p3.x*(tx*tx) + p2.x*2.*(1.-tx)*tx + p1.x*(1.-tx)*(1.-tx);\n    \n    float ty = clamp((p1.y - p2.y)/(p1.y - 2.*p2.y + p3.y),0.,1.);\n    float y = p3.y*(ty*ty) + p2.y*2.*(1.-ty)*ty + p1.y*(1.-ty)*(1.-ty);\n    \n    //col = drawRing(segRingRadius, .003, p, vec2(x,y), col,vec3(1.,0.,0.));\n    \n    \n    float top = min(y, min(p1.y,p3.y));\n    float bottom = max(y, max(p1.y,p3.y));\n    float right = min(x, min(p1.x,p3.x));\n    float left = max(x, max(p1.x,p3.x));\n    \n    vec2 uv = p;\n    col = drawLine(vec2(right,top),vec2(left,top),uv,col,boxCol,lineThickness);\n    col = drawLine(vec2(right,top),vec2(right,bottom),uv,col,boxCol,lineThickness);\n    col = drawLine(vec2(right,bottom+0.01),vec2(left,bottom+0.01),uv,col,boxCol,lineThickness);\n    col = drawLine(vec2(left,top),vec2(left,bottom),uv,col,boxCol,lineThickness);\n    \n    \n    return col;\n}\n\n\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)*2./iResolution.y;\n    \n    float eps = 1./min(iResolution.x, iResolution.y);\n    \n    //calculating p1 as an offset that I'll apply to the other points\n    \n    //original points\n    vec2 p1 = vec2(-0.5, -0.3)+ vec2(sin(iTime+5.),cos(iTime+5.))/2.;\n    vec2 p2 = vec2(0.0, 0.3) + vec2(sin(iTime+5.),cos(iTime+6.))/5.;\n    vec2 p3 = vec2(0.5, -0.3) + vec2(sin(iTime+0.2),cos(iTime+0.2))/5.;\n     \n    //new points with offset so p1Prime is always 0,0\n    vec2 off = p1; \n    vec2 p1Prime = p1 - off;\n    vec2 p2Prime = p2 - off;\n    vec2 p3Prime = p3 - off;\n        \n    //x axis for alignment\n    vec2 xAxis = vec2(1.,0.);\n    //dot a*b = |a|*|b|*cos(a)\n    \n    //get the angle between p3 and x axis to put it right on the x line\n    float a = acos(dot(xAxis,p3Prime) /(length(xAxis)*length(p3Prime)));\n    \n    //save p3.y for reversing the process at the end\n    float p3y = p3Prime.y;\n    \n    \n    //This is is the arccos thing here:\n    //rotate the other points by the angle between p3 and x BUT if \n    //p3.y is already negative we have to rotate in the opposite direction\n    //because acos only gives an angle between 0 and pi as we move towards 180\n    //then from 180 to 360 the angle decreases again to 0.\n    //p2Prime=p2Prime*rot(a*sign(p3y));\n    //p3Prime=p3Prime*rot(a*sign(p3y));\n    \n    //an optimization of above two lines by Oneshade (no trig!)\n    float r = length(p3Prime);\n    vec2 cosi = p3Prime / r; // Force the point onto the unit circle to get sin/cos\n    p2Prime = p2Prime * mat2(cosi, -cosi.y, cosi.x); // Rotate\n    p3Prime = vec2(r, 0.0); // Because we are undoing the rotation of p3Prime\n\n    \n    vec2 line1 = p2-p1;\n    vec2 line2 = p3-p2;\n    float t = sin(iTime)*0.5+0.5;\n    \n    vec2 dLinePoint1 = p1*t + (1.0-t)*p2;\n    vec2 dLinePoint2 = p2*t + (1.0-t)*p3;\n    \n    vec2 magik = dLinePoint1*t + (1.0-t)*dLinePoint2;\n    \n    \n    vec3 col = bgCol;\n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float line1Dist = 1.0-smoothstep(0.004, 0.005, distToLine(p1, p2, uv));\n    float line2Dist = 1.0-smoothstep(0.004, 0.005, distToLine(p2, p3, uv));\n    float line3Dist = 1.0-smoothstep(0.004, 0.005,\n    distToLine(dLinePoint1, dLinePoint2, uv));\n    \n    //float line4Dist = 1.0-smoothstep(0.004, 0.005,\n    //distToLine(magik, p2, uv));\n    \n    \n    col = drawRing(0.01, 0.003, uv, p1, col, lineCol*1.2);\n    col = drawRing(0.01, 0.003, uv, p2, col, lineCol*1.2);\n    col = drawRing(0.01, 0.003, uv, p3, col, lineCol*1.2);\n    \n    col = mix(col, lineCol, line1Dist);\n    col = mix(col, lineCol, line2Dist);\n    col = mix(col, lineCol, line3Dist);\n    //col = mix(col, circleCol, line4Dist);\n    \n    col = drawRing(0.01, 0.003, uv, dLinePoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint2, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, magik, col, magikCol);\n    \n    col = drawSegments(uv, p1, p2, p3, col);\n    //AA segment\n    //col = drawSegments(uv, p1Prime, p2Prime, p3Prime, col);\n    \n    //Good bounding Box\n    col = drawExtrema(uv, p1, p2, p3, vec3(1.,0.,0.),col);\n    \n    //I reverse everything right here for the uv that goes into the second\n    //bounding box function\n    vec2 ruv = (uv-off)*rot(a*sign(p3y));\n    \n    //better Bounding box\n    col = drawExtrema(ruv, p1Prime, p2Prime, p3Prime, vec3(0.,0.,1.), col);\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}