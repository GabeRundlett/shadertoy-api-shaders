{
    "Shader": {
        "info": {
            "date": "1694161721",
            "description": "Inspired by Sebastian Lague's tutorial. sorry :(",
            "flags": 32,
            "hasliked": 0,
            "id": "mtSfzG",
            "likes": 7,
            "name": "Pathtracer thingy",
            "published": 3,
            "tags": [
                "pathtracer"
            ],
            "usePreview": 0,
            "username": "AArt1256",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv );    \n    vec3 col = data.xyz/data.w;\n    \n\tfragColor = vec4( pow(col, vec3(0.45)), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct HitInfo {\n    bool hit;\n    float dst;\n    vec3 point;\n    vec3 normal;\n    vec3 col;\n    vec3 mat;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nHitInfo RaySphere(Ray ray, vec3 center, float radius) {\n    HitInfo hitInfo;\n    hitInfo.hit = false;\n    vec3 offsetRayOrigin = ray.origin - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2. * dot(offsetRayOrigin, ray.dir);\n    float c = dot(offsetRayOrigin, offsetRayOrigin) - (radius * radius);\n    float disc = b*b-4.*a*c;\n    float  dst = (-b - sqrt(disc)) / (2. * a);\n    if (dst >= 0.) {\n        hitInfo.hit = true;\n        hitInfo.dst = dst;\n        hitInfo.point = ray.origin + ray.dir * dst;\n        hitInfo.normal = normalize(hitInfo.point - center);\n    }\n    return hitInfo;\n}\n\n#define sphere(pos,rad,Col,Mat) hitInfo = RaySphere(ray,pos,rad); if (hitInfo.hit && hitInfo.dst < closestHit.dst) { closestHit = hitInfo; closestHit.col = Col; closestHit.mat = Mat; }\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n    vec2 i = (-iResolution.xy + 2.0*fragCoord + hash2(g_seed))/iResolution.y;\n    vec3 viewPoint = vec3(i, 1);\n    Ray ray;\n    ray.origin = vec3(0,0,7.);\n    ray.dir = normalize(viewPoint - ray.origin);\n    vec3 lit = vec3(0.);\n    vec3 col = vec3(1.);\n    HitInfo closestHit;\n    HitInfo hitInfo;\n    for (int j = 0; j <= 8; j++) {\n        closestHit.dst = 1e3;\n        sphere(vec3(0,-100,-10),100.,vec3(1,0,0),vec3(0));\n        \n        sphere(vec3(-10,10,9),10.,vec3(1. ,1.,1),vec3(1,0,0));\n        sphere(vec3(6,10,9),3.,vec3(1. ,1.,1),vec3(0.2,0,0));\n\n        sphere(vec3(0,0,0),.5,vec3(1. ,1.,1),vec3(0,.7,0));\n        sphere(vec3(-1.1,0,0),.5,vec3(0,1,0),vec3(0));\n        sphere(vec3(1.1,0,0),.5,vec3(0,0,1),vec3(0));\n        if (closestHit.hit) {\n            ray.origin = closestHit.point;\n            vec3 dif = normalize(closestHit.normal + random_in_unit_sphere(g_seed));\n            vec3 spec = reflect(ray.dir, closestHit.normal);\n            ray.dir = mix(dif,spec,closestHit.mat.y);\n            lit += col * closestHit.mat.x;\n            col *= closestHit.col.xyz;\n        } else break;\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n    C = data;\n    if (iFrame == 0) C = vec4(0);\n    else C += vec4(lit,4.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}