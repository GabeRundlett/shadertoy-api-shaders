{
    "Shader": {
        "info": {
            "date": "1592828230",
            "description": "An easy raw mix of 2 shaders",
            "flags": 0,
            "hasliked": 0,
            "id": "3llyzs",
            "likes": 0,
            "name": "Disintegrating Holed Cylinder",
            "published": 3,
            "tags": [
                "noise",
                "cylinder"
            ],
            "usePreview": 0,
            "username": "Leria",
            "viewed": 332
        },
        "renderpass": [
            {
                "code": "//from https://www.shadertoy.com/view/lssSRn by FabriceNeyret2\n\n#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\n\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\n\nvec2 sphere1Pos = vec2(0.,0.);\nfloat sphere1Rad = .7;         // sphere radius\n\nfloat planePos = .1;\n\nvec2 sphere2Pos = vec2(1.,0.);\nfloat sphere2Rad = .2;         \n\n// cloud appearance (superseeded by mouse tuning)\n\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\nfloat sharp = 0.9;            // cloud sharpness (0= ultra sharp ).\n\n\n\n#define ANIM 1         // 1/0\n\n#define PI 3.14159\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )  // base rand in [0,1]; \n{\n    return fract(sin(n-765.36334)*43758.5453);\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\n}\n\nfloat noise( in vec3 x ) // base noise in [0,1]; \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#if NOISE==1\n\treturn res;\n#elif NOISE==2\n\treturn abs(2.*res-1.);\n#elif NOISE==3\n\treturn 1.-abs(2.*res-1.);\n#endif\n}\n\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\n\n\n\n// smooth distance to sphere = [-1,1] around radius +- thickness H\n\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\n{\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\n\tfloat d = (1.-length(p))/H;  \n\treturn clamp(d,-1.,1.);\n}\n\t\t\n// smooth distance to plane = [-1,1] around plane +- thickness H\n\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\n{\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\n\tfloat d = -p.x/(H*planeRad);  \n\treturn clamp(d,-1.,1.);\n}\n\t\n// smooth intersect operator\n\nfloat inter(float d0, float d1) {\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\n\td1 = (1.+d1)/2.;\n\treturn 2.*d0*d1 -1.;\n}\n\n// smooth union operator\n\nfloat add(float d0, float d1) {\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\n\td1 = (1.+d1)/2.;\n\treturn 2.*(d0+d1-d0*d1) -1.;\n}\n\n// jitter the distance around 0  and smoothclamp\n\nfloat perturb(vec2 p, float d, float H) {\n#if ANIM\n   float t = iTime;\n#else\n  float t = 0.; \n#endif\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\n\t\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\n}\n\n// convert [-1,1] distances into densities\n\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\n\treturn smoothstep(-sharp,sharp,d);\n}\n\n\n// user-define shape\n\t\nfloat shape(vec2 uv,float n) {\n\t\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\n\tfloat v;\n\n#define globalNoise false\n\t\n\tif (globalNoise || (n==0.)) {\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\n\t}\n\telse {\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\n\t}\n\t\n\treturn v;\n}\n\n// main loop\n\nvec2 polar_coord(vec3 p)\n{\n    float phi = atan(p.x, p.z); //angle\n    float d_rad = length(vec2(p.x, p.z)); //delta radius\n    return vec2(d_rad*cos(phi), d_rad*sin(phi));\n}\n\nconst vec3 cam = vec3(0., 0., 10.);\nfloat uniform_step = .5;\nvoid draw_disk(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)\n{\n    float antialiasing = 1.;\n    antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing\n    vec3 p = cam+dir*antialiasing;\n    float s = 0.;\n  \t\n    \n    for(s; s < 150.; s++)\n    {               \n        float k_step = uniform_step;\n        \n        float dist_dist = dot(p, p);\n        float dist_center = length(center-cam);\n        \n        vec2 nu = polar_coord(p-(center));\n\n        //if too far, then big step\n        \n        if(sqrt(dist_dist) < (dist_center-radius))\n        {\n        \tk_step = dist_center-radius;\n        }\n\n        //if in the shape, draw\n        else if( (length(nu) - 5. <= 0.) && (length(nu) - 2.5 >= 0.) && (distance(p.y, center.y) < 2.))\n        {\n        \tc += 0.2*vec3(0.4, 0.4, 0.6);\n        }   \n        \n        //if it will never be in the shape anymore, return;\n        if(length(p) > (dist_center+radius))\n        {\n         \tbreak;   \n        }\n        \n        p += dir*k_step;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    \n   \tif (iMouse.z>0.)\n    {       \t\t\t\t   // mouse tuning\n\t\tvec2 m = iMouse.xy / iResolution.xy;\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \n\t}\n\n\tfloat v = dist2dens( shape(uv,1.) ); \n\tvec3 col = vec3(v);\n    \n    draw_disk(normalize(vec3(uv, -1.)), vec3(0., 0., 0.), vec3(0., 1., 0.), 30., color);\n    \n    fragColor = vec4(min(color, max(vec3(0.), col)), 1.);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}