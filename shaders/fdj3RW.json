{
    "Shader": {
        "info": {
            "date": "1617077405",
            "description": "just looking at 45º reflections.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdj3RW",
            "likes": 8,
            "name": "reflection study",
            "published": 3,
            "tags": [
                "mirrors"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 305
        },
        "renderpass": [
            {
                "code": "// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-03-29 16:22:45\n\n// pixel epsilon for smoothstep\nfloat gSmoothEps;\n\n\n////////////////////////////////\n// Distance functions\n\nfloat sdDisk(in vec2 p, in vec2 c, in float r) {\n    return length(c - p) - r;\n}\n\nfloat sdCircle(in vec2 p, in vec2 c, in float r, in float w) {\n    return abs(sdDisk(p, c, r - w)) - w;\n}\n\n\n////////////////////////////////\n// Transformations\n\nvec2 rot45l(in vec2 p) {\n    return vec2((p.y + p.x) * INVSQRT2, (p.y - p.x) * INVSQRT2);\n}\n\nvec2 rot45r(in vec2 p) {\n    return vec2((p.x - p.y) * INVSQRT2, (p.y + p.x) * INVSQRT2);\n}\n\nvec2 mirrorX(in vec2 p) {\n    return vec2(abs(p.x), p.y);\n}\n\nvec2 mirrorY(in vec2 p) {\n    return vec2(p.x, abs(p.y));\n}\n\n// Is there a way to shortcut a 45° reflection ?\nvec2 mirror45l(in vec2 p) {\n    p = rot45l(p);\n    p = mirrorX(p);\n    p = rot45r(p);\n    return p;\n}\n\nvec2 mirror45r(in vec2 p) {\n    p = rot45r(p);\n    p = mirrorX(p);\n    p = rot45l(p);\n    return p;\n}\n\n\n////////////////////////////////\n// Miscellaneous\n\nfloat ss(in float d) {\n    return smoothstep(gSmoothEps, -gSmoothEps, d);\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    setupCoords(iResolution.xy, 0.78);\n    setupTime(iTime);\n    gSmoothEps = gWorldFromScreenFac * 1.0;\n    \n    // point and mouse\n    vec2 p = worldFromScreen(XY);\n    vec2 m = worldFromScreen(iMouse.xy);\n    \n    if (length(iMouse.xy) < 50.0) {\n        float t = float(iFrame) / 60.0;\n        m = vec2(cos(t * TAO * 0.1), sin(t * TAO * 0.1)) * 0.8;\n    }\n    \n    const vec3 colBG  = vec3(0.2, 0.3, 0.4);\n    const vec3 colFG1 = vec3(1.0, 0.9, 1.0);\n    const vec3 colFG2 = vec3(0.8, 0.9, 0.6);\n    const vec3 colFG3 = vec3(0.0, 0.8, 0.5);\n    const vec3 colFG4 = vec3(0.1, 0.6, 0.9);\n    const vec3 colFG5 = vec3(0.5, 0.4, 0.9);\n    const vec3 colBG2 = vec3(0.0);\n    const vec3 colBG3 = vec3(0.2);\n    \n    vec2 p45 = rot45l(p);\n    \n    vec3 col = colBG;\n    col.r   *= p  .x > 0.0 ? 1.3 : 1.0;\n    col.g   *= p  .y > 0.0 ? 1.1 : 1.0;\n    col.b   *= p45.y > 0.0 ? 1.1 : 1.0;\n    col.rgb *= p45.x > 0.0 ? 1.1 : 1.0;\n    col.rgb *= mix(1.0, 0.9, clamp(pow(length(p * 0.6), 2.2) / 2.0, 0.0, 1.0) * 2.0);\n    \n    float diskRad = 0.4;\n    float lineWid = 1.0 * gSmoothEps;\n    \n    // axes:  45° and regular\n    col = mix(col, colBG3, 0.5 * ss(min(abs(p45.x), abs(p45.y)) - lineWid * 0.5));\n    col = mix(col, colBG3, 0.5 * ss(min(abs(p  .x), abs(p  .y)) - lineWid * 0.5));\n\n    // dark tint inside main circle\n    col = mix(col, colFG1, -0.1 * ss(sdDisk(p, m, diskRad)));\n    \n    // reflections\n    col = mix(col, colFG5, ss(sdCircle(mirror45l(p), m, diskRad * 0.40, lineWid)));\n    col = mix(col, colFG2, ss(sdCircle(mirror45r(p), m, diskRad * 0.55, lineWid)));\n    col = mix(col, colFG4, ss(sdCircle(mirrorX  (p), m, diskRad * 0.70, lineWid)));\n    col = mix(col, colFG3, ss(sdCircle(mirrorY  (p), m, diskRad * 0.85, lineWid)));\n    \n    // main circle\n    col = mix(col, colFG1, ss(sdCircle(          p , m, diskRad * 1.00, lineWid)));\n    \n    RGBA = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI       = 3.14159265359;\nconst float TAO      = PI * 2.0;\nconst float SQRT2    = 1.41421356237;\nconst float INVSQRT2 = 1.0 / SQRT2;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}