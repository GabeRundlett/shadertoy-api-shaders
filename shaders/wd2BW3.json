{
    "Shader": {
        "info": {
            "date": "1591020040",
            "description": "Some fun with sinus random function you can adjust the blur of the image and the number of ray",
            "flags": 0,
            "hasliked": 0,
            "id": "wd2BW3",
            "likes": 2,
            "name": "Light glow",
            "published": 3,
            "tags": [
                "light",
                "glow"
            ],
            "usePreview": 0,
            "username": "Paltoquet",
            "viewed": 442
        },
        "renderpass": [
            {
                "code": "#define PI 3.142\n#define ANIMATION_DURATION 120.0\n#define ANIMATION_SPEED 15.0\n#define BLUR_RADIUS 6\n\nfloat random (float theta) {\n    float period = 230.000;\n    return fract(sin(dot(theta, period * period))* 2.856);\n}\n\nfloat getCurrentTime() {\n    float coef = mod(iTime * ANIMATION_SPEED, ANIMATION_DURATION);\n    coef = coef / ANIMATION_DURATION;\n    coef = max(0.0, coef);\n    return coef;\n}\n\nfloat period(float theta, float nbCroissant) {\n    float period = 2.0 * PI;\n\tperiod = period * nbCroissant;\n    return sin(theta * period);\n}\n\nfloat square(vec2 position, vec2 dim) {\n    if(abs(position.x) < dim.x && abs(position.y) < dim.y) {\n        return 1.0;\n    } \n    return 0.0;\n}\n\nfloat sphere(vec2 position, vec2 center, float radius) {\n    if(length(position - center) <= radius) {\n        return 1.0;\n    } \n    return 0.0;\n}\n\nfloat circle(vec2 position, float radius, float width){\n    float dist = abs(length(position) - radius);\n    if(dist < width) {\n        return width;\n    }\n    return 0.0;\n}\n\nfloat easingIn(float val) {\n    return pow(val, 3.0);\n}\n\nfloat easingOut(float val) {\n    return 1.0 - pow(1.0 - val, 5.0);\n}\n\nfloat generateSphere(vec2 position) {\n    vec2 centers[8];\n    float radius[8];\n    centers[0] = vec2(0.580,0.230);\n    centers[1] = vec2(0.320,0.630);\n    centers[2] = vec2(-0.340,0.260);\n    centers[3] = vec2(-0.750,0.240);\n\tcenters[4] = vec2(-0.630,-0.430);    \n\tcenters[5] = vec2(-0.120,0.770);   \n    centers[6] = vec2(0.330,-0.630);\n    centers[7] = vec2(0.440,-0.240);\n    \n    radius[0] = 0.028;\n    radius[1] = 0.037;\n    radius[2] = 0.049;\n\tradius[3] = 0.032;\n    radius[4] = 0.024;\n    radius[5] = 0.042;\n    radius[6] = 0.062;\n    radius[7] = 0.080;\n    \n    float result = 0.0;\n    float theta = atan(position.y, position.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    float coef = getCurrentTime();\n    coef = coef * 0.68;\n    for(int i = 0; i < 8; i++){\n        vec2 center = centers[i];\n        float radius = radius[i];\n        center = mix(vec2(0), center, coef);\n        radius = mix(0.001, radius, coef);\n        result = max(result, sphere(position, center, radius));\n    }\n    return result;\n}\n\nfloat generateCroissant(vec2 position, float nbCroissant) {\n    float theta = atan(position.y, position.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    float coef = getCurrentTime();\n    \n    //coef = 1.0;\n    \n    float currentCroissant = floor(current * nbCroissant);\n    \n    float amplitude = random(currentCroissant);\n    \n    float range = period(current, nbCroissant);\n    float dist = length(position);\n    range = range * amplitude * coef;\n    dist = dist < range ? range : 0.0;\n    return dist;\n}\n\n/*float glow(vec2 pos) {\n    float theta = atan(pos.y, pos.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); \n    float firstPeriod = PI;\n    float secondPeriod = 5.0;\n    float soft = 0.436;\n    float constant = 0.552;\n    float curve = (sin(current * firstPeriod) + sin(current * secondPeriod * firstPeriod) * soft) * 0.2 + constant;\n    float dist = length(pos);\n    return max(0.0, curve - dist);\n}*/\n        \n\nvec4 getColor(vec2 pos){\n    float nbCroissant = 120.0;\n    float currentTime = getCurrentTime();\n    //nbCroissant = mix(0.0, 200.0, currentTime);\n    \n    float theta = atan(pos.y, pos.x);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n    \n    vec4 firstRedColor = vec4(0.995,0.364,0.162,1.000);\n    vec4 firstYellowColor = vec4(0.412,0.639,0.995,1.000);\n    vec4 firstColor = mix(firstYellowColor, firstRedColor, easingIn(1.0 - abs((current - 0.5)) * 1.0));\n    vec4 secondColor = vec4(0.995,0.924,0.362,1.000);\n    vec4 backGroundColor = vec4(0.001,0.000,0.005,1.000);\n    \n    float circleRadius = mix(0.0, 0.065, currentTime);\n    float circleWidth = mix(0.01, 0.065, currentTime);\n    \n    float dist = generateCroissant(pos, nbCroissant);\n    dist = max(dist, generateCroissant(pos, nbCroissant / 6.0)); // play with thoose\n    //dist = max(dist, generateCroissant(pos, nbCroissant / 8.0)); // play with thoose\n    //dist = max(dist, square(pos, vec2(0.22, 0.22)));\n    dist = max(dist, generateSphere(pos));\n    dist = max(dist, easingIn(circle(pos, circleRadius, circleWidth)));\n    //st = max(dist, glow(pos));\n    vec4 color = dist != 0.0 ? mix(firstColor, secondColor, easingIn(dist)) : backGroundColor;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st * vec2(2.0) - vec2(1.0);\n    vec2 pixelOffset = vec2(1.0) / iResolution.xy;\n\tint blurRadius = 5;\n    vec4 color = getColor(st);\n    \n    for(int i = -1 * BLUR_RADIUS; i < BLUR_RADIUS; i++) {\n        for(int j = -1 * BLUR_RADIUS; j < BLUR_RADIUS; j++) {\n            vec2 offset = vec2(i, j) * pixelOffset;\n            color += getColor(st + offset);\n        }\n    }\n    \n    color = color / vec4(BLUR_RADIUS * BLUR_RADIUS);\n\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}