{
    "Shader": {
        "info": {
            "date": "1700353798",
            "description": "Approximations of Ci(x) [red], Cin(x) [green], Si(x) [blue], and their error plots.\nThe plot is log-log: x is in [1e-7;1e+2], y is in [1e-8;1e-1].\nClick at the top to select a function (leftmost=time-reel).\nHold LMB to show plot of the relative error.",
            "flags": 0,
            "hasliked": 0,
            "id": "DtVczG",
            "likes": 4,
            "name": "Approx. Si(x), Ci(x), Cin(x)",
            "published": 3,
            "tags": [
                "sine",
                "cosine",
                "integral",
                "si",
                "ci",
                "specialfunction",
                "cin"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 213
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Several approximations of sine and cosine integrals, and their\n// accuracy measurements in float32.\n\n// Functions are tested exhaustively on [-inf,+inf] range of float32 values,\n// using a C++ test program on x86, in IEEE-754 binary32 (-mfpmath=sse),\n// in the default (round-nearest-ties-even) rounding direction, without FMA,\n// using \"glibc 2.31-9\" versions of math functions, and double precision\n// GSL (https://www.gnu.org/software/gsl/) versions of Si and Ci (with \n// some bugfixes) as a reference.\n//\n// NOTE: the results do depend on the floating-point environment,\n// and library math functions, so e.g. the plots here may look different\n// in different GLSL implementations (see e.g. https://www.shadertoy.com/view/dttczs).\n//\n// Both absolute (Eabs) and relative (Erel) errors (maximum, i.e. inf-norm) are\n// reported. For some of the more accurate functions, errors in ULPs\n// (units in the last place) are also presented.\n//\n// The plot is log-log: x is in [1e-7;1e+2], y is in [1e-8;1e-1].\n// Plot colors:\n//     Ci(x)  - red\n//     Cin(x) - green\n//     Si(x)  - blue\n\n// For sine integral, a function si(x)=pi/2-Si(x) is sometimes also\n// defined.\n// For cosine integral there are 2 related functions Ci(x) and Cin(x) with\n//     Cin(x)=gamma+ln(x)-Ci(x)\n// where gamma=0.57721566490153286060651209... is Euler-Mascheroni constant.\n// Real-valued Ci(x) is defined on (0;+inf) (with Ci(-x)=Ci(x)+pi*i being complex),\n// while Cin(x) is defined on (-inf;+inf) (with Cin(-x)=Cin(x)).\n//     Ci (0)=-inf, Ci (inf)= 0,\n//     Cin(0)= 0  , Cin(inf)=+inf.\n// Numerically, Ci and Cin approximations based on the same formula have\n// about the same worst absolute error, but the worst relative error of Ci\n// is basically infinite, due to Ci(x) passing through 0, unlike Cin\n// for |x|>0.\n\n// NOTE: the only open-source single precision implementation of Si(x)\n// I'm aware of (sicif.c from Cephes, https://www.netlib.org/cephes/)\n// has a bug, where it returns +pi/2 for x<-1e-9, but once you fix that,\n// it has accuracy ~4.3 ulp on the entire range.\n\n// NOTE: the GSL (double-precision) version of Ci(x) (gsl_sf_Ci) appears\n// to have a bug, returning large values for large arguments.\n// NOTE: scipi versions seem to be fine.\n\n//==============================================================================\n// Auxiliary functions (also sometimes denoted f() and g()):\n//     fi(x)=(pi/2-Si(x))*cos(x)+Ci(x)*sin(x)\n//     gi(x)=(pi/2-Si(x))*sin(x)-Ci(x)*cos(x)\n// Several approximations of these on 1<=x<inf from\n//     Hastings C.: Approximations for Digital Computers. Princeton University Press, 1955.\n// (where they are called P(x) and Q(x) respectively), which also made it into\n// Abramowitz and Stegun.\n\n// NOTE: these approximations suffer numerical problems for large arguments.\n// The safe ranges are noted below.\n\n// On [1; 50859008]\n// Eabs<1.6e-4\n// Erel<1.1e-3\nfloat fi4(float x)\n{\n    float x2=x*x;\n    return (2.463936+7.241163*x2+x2*x2)/(x*(7.157433+9.068580*x2+x2*x2));\n}\n\n// On [1; 319557]\n// Eabs<8.0e-6\n// Erel<8.6e-5\nfloat fi6(float x)\n{\n    float x2=x*x;\n    return ( 8.493336+x2*(47.411538+19.394119*x2+x2*x2))/\n        (x*(30.038277+x2*(70.376496+21.361055*x2+x2*x2)));\n}\n\n// On [1; 19112]\n// Eabs<6.8e-7\n// Erel<8.0e-6\n// Eulp<132.5\nfloat fi8(float x)\n{\n    float x2=x*x;\n    return ( 38.102495+x2*(335.677320+x2*(265.187033+38.027264*x2+x2*x2)))/\n        (x*(157.105423+x2*(570.236280+x2*(322.624911+40.021433*x2+x2*x2))));\n}\n\n// On [1; 2642245]\n// Eabs: 0.000116066195\n// Erel: 0.0048635339\n// Eulp: 81392.2198\nfloat gi4(float x)\n{\n    float x2=x*x;\n    return (1.564072+7.547478*x2+x2*x2)/(x2*(15.723606+12.723684*x2+x2*x2));\n}\n\n// On [1; 65535]\n// Eabs: 5.60678695e-06\n// Erel: 0.000540943856\n// Eulp: 9043.08217\nfloat gi6(float x)\n{\n    float x2=x*x;\n    return  ( 5.089504+x2*( 49.719775+21.383724*x2+x2*x2))/\n        (x2*(76.707878+x2*(119.918932+27.177958*x2+x2*x2)));\n}\n\n// On [1; 7131]\n// Eabs: 4.37074273e-07\n// Erel: 6.44829123e-05\n// Eulp: 1080.53846\nfloat gi8(float x)\n{\n    float x2=x*x;\n    return  ( 21.821899+x2*( 352.018498+x2*(302.757865+42.242855*x2+x2*x2)))/\n        (x2*(449.690326+x2*(1114.978885+x2*(482.485984+48.196927*x2+x2*x2))));\n}\n\n//==============================================================================\n// Asymptotic of Si and Ci for x->inf.\n\n// Approximates Si(x) for |x|>1e4.\nfloat Si_asymp(float x)\n{\n    return abs(x)>1e10?\n        sign(x)*1.5707963268:\n        sign(x)*1.5707963268-cos(x)/x-sin(x)/(x*x);\n}\n\n// Approximates Ci(|x|) for |x|>1e4.\nfloat Ci_asymp(float x)\n{\n    return abs(x)>1e10?\n        0.0:\n        sin(x)/x-cos(x)/(x*x);\n}\n\n//==============================================================================\n// Crude but concise approximation, using the observation that\n//     atan(x)<Si(x)<pi-atan(x) for x>0\n// and Si(x) comes pretty close to these bounds at extrema.\n// For the proof see:\n//     https://www.maths.lancs.ac.uk/jameson/siineqnotes.pdf\n//     https://math.stackexchange.com/questions/2879015/prove-that-int-0x-frac-sin-tt-dt-arctan-x-for-x0\n\n// NOTE: pi/2=1.5707963268...\n\n// Eabs<1.5e-2\n// Erel<2.7e-2\nfloat Si_atan(float x)\n{\n    x=clamp(x,-1e10,+1e10);\n    // NOTE: using a simpler weight of cos(x-x/(2+x^2)) yields Eabs ~1.7e-2.\n    return mix(sign(x)*1.5707963268,atan(x),cos(x-1.105832486*x/(2.166470873+x*x)));\n}\n\n// Ci/Cin versions of the above, less simple.\n// NOTE: pi/2-atan(x)=atan(1/x) is approximated by\n// 1/x, as |atan(1/x)-1/x|<5.1e-3 for |x|>4. Using\n// atan(1/x) improves Eabs to ~6.8e-3.\n\n// Eabs<9.3e-3\nfloat Ci_rcp(float x)\n{\n    float x2=x*x;\n    return x<4.0?0.57721566490153286+log(x)-\n        x2*( 0.25+\n        x2*(-0.01041655488769817+\n        x2*( 0.00022988894178267946+\n        x2*(-2.6015522824519235e-06)))):\n        (x>1e10?0.0:sin(x-1.105832486*x/(2.166470873+x2))/x);\n}\n\n// Eabs<9.3e-3\n// Erel<4.0e-3\nfloat Cin_rcp(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    return x<4.0?\n        x2*( 0.25+\n        x2*(-0.01041655488769817+\n        x2*( 0.00022988894178267946+\n        x2*(-2.6015522824519235e-06)))):\n        0.57721566490153286+log(x)-(x>1e10?0.0:sin(x-1.105832486*x/(2.166470873+x2))/x);\n}\n\n//==============================================================================\n// Approximations based on the auxiliary functions above.\n// NOTE: approximations for |x|<4 may differ from those in\n// Abramowitz and Stegun.\n\n// Eabs<1.8e-4\n// Erel<1.1e-3\nfloat Si_v1(float x)\n{\n    if(abs(x)<1.0) return x*(0.999490755-x*x*0.053506832);\n    else if(abs(x)>1e4) return Si_asymp(x);\n    else return sign(x)*1.5707963268-fi4(x)*cos(x)-gi4(x)*sin(x);\n}\n\n// Eabs<1.9e-4\nfloat Ci_v1(float x)\n{\n    float x2=x*x;\n    if(x<4.0) return 0.57721566490153286+log(x)-\n        x2*( 0.25+\n        x2*(-0.010416665998427955+\n        x2*( 0.00023145206084389179+\n        x2*(-3.0754638542558933e-06+\n        x2*( 2.3540666047900717e-08)))));\n    else if(x>1e4) return Ci_asymp(x);\n    else return fi4(x)*sin(x)-gi4(x)*cos(x);\n}\n\n// Eabs<1.9e-4\n// Erel=1 (<3.0e-4 for |x|>1e-17)\nfloat Cin_v1(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    if(x<4.0) return\n        x2*( 0.25+\n        x2*(-0.010416665998427955+\n        x2*( 0.00023145206084389179+\n        x2*(-3.0754638542558933e-06+\n        x2*( 2.3540666047900717e-08)))));\n    else if(x>1e4) return 0.57721566490153286+log(x)-Ci_asymp(x);\n    else return 0.57721566490153286+log(x)-(fi4(x)*sin(x)-gi4(x)*cos(x));\n}\n\n// Eabs<9.4e-6\n// Erel<9.0e-6\n// Eulp<148.9\nfloat Si_v2(float x)\n{\n    float y=abs(x),x2=x*x;\n    if(y<1.0) return x*(0.999996951+x2*(-0.055531133+x2*0.001617667));\n    else if(y>1e4) return Si_asymp(x);\n    else return sign(x)*(1.5707963268-fi6(y)*cos(y)-gi6(y)*sin(y));\n}\n\n// Eabs<8.9e-6\nfloat Ci_v2(float x)\n{\n    float x2=x*x;\n    if(x<4.0) return 0.57721566490153286+log(x)-\n        x2*(0.25+\n        x2*(-0.010416666665566218+\n        x2*( 0.00023148115790180699+\n        x2*(-3.0995911179634464e-06+\n        x2*( 2.7345266653265783e-08+\n        x2*(-1.506340081607385e-10))))));\n    else if(x>1e4) return Ci_asymp(x);\n    else return fi6(x)*sin(x)-gi6(x)*cos(x);\n}\n\n// Eabs<9.1e-6\n// Erel=1 (1.7e-7 for |x|>1e-17)\n// Eulp<216.0\nfloat Cin_v2(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    if(x<4.0) return\n        x2*(0.25+\n        x2*(-0.010416666665566218+\n        x2*( 0.00023148115790180699+\n        x2*(-3.0995911179634464e-06+\n        x2*( 2.7345266653265783e-08+\n        x2*(-1.506340081607385e-10))))));\n    else if(x>1e4) return 0.57721566490153286+log(x)-Ci_asymp(x);\n    else return 0.57721566490153286+log(x)-(fi6(x)*sin(x)-gi6(x)*cos(x));\n}\n\n// Eabs<7.9e-7\n// Erel<8.2e-7\n// Eulp<13.3\nfloat Si_v3(float x)\n{\n    float y=abs(x),x2=x*x;\n    if(y<1.0) return x+x*x2*(-0.055555480+x2*(0.001666271+x2*-0.000027723));\n    else if(y>1e4) return Si_asymp(x);\n    else return sign(x)*(1.5707963268-fi8(y)*cos(y)-gi8(y)*sin(y));\n}\n\n// Eabs<5.3e-6\nfloat Ci_v3(float x)\n{\n    float x2=x*x;\n    if(x<4.0) return 0.57721566490153286+log(x)-\n        x2*( 0.25+\n        x2*(-0.01041666668062171+\n        x2*( 0.00023148153037431092+\n        x2*(-3.1002228983145375e-06+\n        x2*( 2.7558604375373243e-08+\n        x2*(-1.7332136767183762e-10+\n        x2*( 7.331836209074408e-13)))))));\n    else if(x>1e4) Ci_asymp(x);\n    else return fi8(x)*sin(x)-gi8(x)*cos(x);\n}\n\n// Eabs<5.3e-6\n// Erel=1 (<1.9e-6 for |x|>1e-17)\n// Eulp<27.3\nfloat Cin_v3(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    if(x<4.0) return\n        x2*( 0.25+\n        x2*(-0.01041666668062171+\n        x2*( 0.00023148153037431092+\n        x2*(-3.1002228983145375e-06+\n        x2*( 2.7558604375373243e-08+\n        x2*(-1.7332136767183762e-10+\n        x2*( 7.331836209074408e-13)))))));\n    else if(x>1e4) return 0.57721566490153286+log(x)-Ci_asymp(x);\n    else return 0.57721566490153286f+log(x)-(fi8(x)*sin(x)-gi8(x)*cos(x));\n}\n\n//==============================================================================\n// What we will be using as a reference implementation.\n// Kind of lame, but it'll serve. Still, should be more accurate than Cephes.\n// Public domain.\n\nfloat fi_ref(float x)\n{\n    float x2=x*x;\n    return (1157.2813301581532\n        +x2*(918.37073823706487\n        +x2*72.91109984325341\n        +x2*x2))\n            /(x*(2136.431584513592\n        +x2*(1044.2655890141539\n        +x2*74.911060095355765\n        +x2*x2)));\n}\n\nfloat gi_ref(float x)\n{\n    float x2=x*x;\n    return (350.71198766665168\n        +x2*(52.53658071509102\n        +x2*0.99999424154191419))\n            /(677.48284555096393\n        +x2*(586.07925873667034\n        +x2*58.526231344858282\n        +x2*x2));\n}\n\n// Eabs<1.9e-7\n// Erel<1.3e-7\n// Eulp<1.6\nfloat Si_ref(float x)\n{\n    float y=abs(x),x2=x*x;\n    if(y<1.0) return x+x*x2*(-0.055555480+x2*(0.001666271+x2*-0.000027723));\n    else if(y<2.0) return x+x*(\n        x2*(-0.05555556134806966+\n        x2*( 0.00050737034650927932+\n        x2*(-5.0471110048495199e-06))))/(1.0+\n        x2*(0.020867419021527198+\n        x2*(0.00020663380200154814+\n        x2*1.0703429794815947e-06)));\n    else if(y<4.0)\n    {\n        float t=y-2.0;\n        return sign(x)*(1.605412976802699\n            +t*(+0.45464935792421\n            +t*(-0.21770668761788\n            +t*(-0.0031753140004621\n            +t*(+0.0098042389141398\n            +t*(-8.2411630085075919e-5\n            +t*(-2.7256837238253323e-4\n            +t*  2.2925266735283385e-5)))))));\n    }\n    else if(y>1e4) return Si_asymp(x);\n    else return sign(x)*1.5707963268-fi_ref(x)*cos(x)-gi_ref(x)*sin(x);\n}\n\nfloat Ci_ref(float x)\n{\n    float x2=x*x;\n    if(x<1.0) return 0.57721566490153286+log(x)-\n        x2*( 0.25+\n        x2*(-0.010416666651501689+\n        x2*( 0.00023147457042302654+\n        x2*(-3.0659183566839455e-06))));\n    else if(x<2.0)\n    {\n        float t=x-1.0;\n        return 0.3374039229+log(x)-\n            t*( 0.45969795522813789+\n            t*( 0.19088189878507705+\n            t*(-0.037177909249922987+\n            t*(-0.0072406378705534256+\n            t*( 0.0013455939055330316+\n            t*( 6.3373887776489737e-05))))));\n    }\n    else if(x<4.0)\n    {\n        float t=x-2.0;\n        return -0.27016635178+log(x)-\n            t*( 0.70807442478691229+\n            t*( 0.050294041743019074+\n            t*(-0.05139839828731807+\n            t*( 0.00025284978209454736+\n            t*( 0.0016943264375937806+\n            t*(-8.8289289884377998e-05+\n            t*(-1.2825398355628786e-05)))))));\n    }\n    else if(x>1e4) return Ci_asymp(x);\n    else return fi_ref(x)*sin(x)-gi_ref(x)*cos(x);\n}\n\n// Eabs<5.26e-6\n// Erel=1 (<1.68e-7 for |x|>1e-17)\n// Eulp<1.98\nfloat Cin_ref(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    if(x<1.0) return\n        x2*( 0.25+\n        x2*(-0.010416666651501689+\n        x2*( 0.00023147457042302654+\n        x2*(-3.0659183566839455e-06))));\n    else if(x<2.0)\n    {\n        float t=x-1.0;\n        return 0.23981174200056465+\n            t*( 0.45969795522813789+\n            t*( 0.19088189878507705+\n            t*(-0.037177909249922987+\n            t*(-0.0072406378705534256+\n            t*( 0.0013455939055330316+\n            t*( 6.3373887776489737e-05))))));\n    }\n    else if(x<4.0)\n    {\n        float t=x-2.0;\n        return 0.84738201668661306+\n            t*( 0.70807442478691229+\n            t*( 0.050294041743019074+\n            t*(-0.05139839828731807+\n            t*( 0.00025284978209454736+\n            t*( 0.0016943264375937806+\n            t*(-8.8289289884377998e-05+\n            t*(-1.2825398355628786e-05)))))));\n    }\n    else if(x>1e4) return 0.57721566490153286+log(x)-Ci_asymp(x);\n    else return 0.57721566490153286+log(x)-(fi_ref(x)*sin(x)-gi_ref(x)*cos(x));\n}\n\n//==============================================================================\n// Dispatcher.\n\nfloat f(int id,float x)\n{\n    switch(id)\n    {\n        case  0: return 0.0;\n\n        case  1: return Si_atan(x);\n\n        case  2: return Si_v1(x);\n        case  3: return Si_v2(x);\n        case  4: return Si_v3(x);\n#define T_SI 5\n        case  5: return Ci_rcp(x);\n        case  6: return Ci_v1(x);\n        case  7: return Ci_v2(x);\n        case  8: return Ci_v3(x);\n#define T_CI 9\n        case  9: return Cin_rcp(x);\n        case 10: return Cin_v1(x);\n        case 11: return Cin_v2(x);\n        case 12: return Cin_v3(x);\n#define NUM_FUNCTIONS 13\n    }\n    return 0.0;\n}\n\nfloat error(int id,float x,int rel)\n{\n    float y=f(id,x),z=(id<T_SI?Si_ref(x):(id<T_CI?Ci_ref(x):Cin_ref(x)));\n    return rel==0?y-z:(y-z)/z;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 R=iResolution.xy;\n    vec2 xy=fragCoord/R;\n    vec3 col=vec3(0.8,0.75,0.7);\n    int id=int(floor(abs(iMouse.z/R.x)*float(NUM_FUNCTIONS)));\n    int rel=(iMouse.z>=0.0?1:0);\n    if(id==0) id=int(iTime)%(NUM_FUNCTIONS-1)+1;\n    vec3 c=(id<T_SI?vec3(0.25,0.5,0.75):(id<T_CI?0.75*vec3(0.75,0.25,0.5):0.5*vec3(0.5,0.75,0.25)));\n    float lx=mix(-7.0,+2.0,xy.x),x=pow(10.0,lx);\n    float ly=mix(-7.0,-1.0,xy.y),y=pow(10.0,ly);\n    float t,p;\n    // Render grid.\n    t=fract(lx);\n    col=mix(col,vec3(0.0),0.5*exp(-50.0*t*(1.0-t)));\n    p=t;t=fract(pow(10.0,p));\n    col=mix(col,vec3(0.0),0.25*exp(-10.0/p*t*(1.0-t)));\n    t=fract(ly);\n    col=mix(col,vec3(0.0),0.5*exp(-50.0*t*(1.0-t)));\n    p=t;t=fract(pow(10.0,p));\n    col=mix(col,vec3(0.0),0.25*exp(-10.0/p*t*(1.0-t)));\n    col=mix(col,vec3(0.0,1.0,0.0),0.5*exp(-1e4*lx*lx));\n    // Function selector.\n    if(xy.y>1.0-14.0/R.y) col=mix(col,vec3(0.25)+0.5*mod(floor(xy.x*float(NUM_FUNCTIONS)),2.0),0.5);\n    // Render error plot.\n    col=mix(\n        col,\n        c,\n        0.75*smoothstep(\n            -0.02*y,\n            +0.02*y,\n            abs(error(id,x,rel))-y));\n    // Print the function id.\n    int font[]=int[](0x01C0,0x4000,0x7B6F,0x4924,0x73E7,0x79E7,0x49ED,0x79CF,0x7BCF,0x4927,0x7BEF,0x79EF);\n    uint ix=uint(int(floor(0.25*(fragCoord.x-16.0))));\n    uint iy=uint(int(floor(0.25*(fragCoord.y-iResolution.y*0.875))));\n    if(ix<3u&&iy<5u) {if((font[uint(id)/10u%10u+2u]>>((4u-iy)*3u+ix)&1)==1) col=mix(col,vec3(0.125,0.25,0.125),0.75);}\n    if(ix>=4u&&ix<7u&&iy<5u) {if((font[uint(id)%10u+2u]>>((4u-iy)*3u+ix-4u)&1)==1) col=mix(col,vec3(0.125,0.25,0.125),0.75);}\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}