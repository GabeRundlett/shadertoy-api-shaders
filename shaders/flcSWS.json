{
    "Shader": {
        "info": {
            "date": "1639669536",
            "description": "Just playing while waiting for Blender to render out trying to reproduce what I rendered out. Of course its marching so the materials are not as good as blender - need to up my PBR game.\n    \nhttps://twitter.com/byt3m3chanic/status/1471029268994043907",
            "flags": 0,
            "hasliked": 0,
            "id": "flcSWS",
            "likes": 19,
            "name": "Cubic Blender V2",
            "published": 3,
            "tags": [
                "cubeblendercopy2"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 431
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Cubic Blender V2\n    12/15/21 - byt3_m3chanic\n    Just playing while waiting for Blender to render out.\n \n    https://twitter.com/byt3m3chanic/status/1471029268994043907\n    \n    also tidbits from @blackle for domain rep/refraction.\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\nfloat lsp(float b,float e,float t) { return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t=t-1.)*t*t+1.; }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    return (p2.x > p2.y) ? vec2((p.x<0.)?-1.:1.,0.) : vec2(0.,(p.y<0.)?-1.:1.);\n}\n\n// globals & const\nvec3 hit,hitPoint;\nvec4 gtile,stile;\nfloat glow=0.,ftime=0.,ga1,ga2,ga3,ga4;\nmat2 rxt;\n\nconst float size = .85;\nconst float hlf = size/2.;\nconst vec3 bs = vec3(hlf*.96);\n\nconst float zoom = 5.;\nconst float cp = 3.;\n\nvec2 map(vec3 p, float sg){\n    vec2 res = vec2(1e5,0.);\n\n    float zp = p.z+(ga4*16.);\n    float zd = floor((zp+8.)/16.);\n    p.z+=(ga1*16.);\n    p.z=mod(p.z+8.,16.)-8.;\n    \n    vec3 q = p;\n    //domain rep by @blackle https://www.shadertoy.com/view/3lcBD2\n    vec2 center = floor(q.xz) + .5;\n    vec2 nghbor = center + edge(q.xz - center);\n    \n    float dist = mod(zd,3.)==0.?center.x+center.y:mod(zd,2.)==0.?center.x:length(center);\n    float ht = 1.5*sin((dist*.55)+ftime);\n    ht=clamp(ht,0.,3.);\n    float oyf = .25;\n    \n    float me   = box(p - vec3(center.x,ht-oyf,center.y),vec3(bs*.35));\n    float next = box(p - vec3(nghbor.x,ht-oyf,nghbor.y),vec3(bs.x*.35,bs.y*2.,bs.z*.35));\n\n    float bx = (abs(q.x)>cp||abs(q.z)>cp) ? next : min(me, next);\n    if(sg>0.&&ht>.5) glow += mix(0.,.0001/(.001+bx*bx),clamp(ht-.55,0.,1.)*1.5);\n    if(bx<res.x) {\n       res = vec2(bx,3.);\n       gtile.xyz = vec3(center,zd);\n       gtile.w=3.;\n       hit = p;\n    } \n\n    float distortion = 28.;\n    float dsn = sin(distortion * p.x*.7) * sin(distortion * p.y-oyf) * sin(distortion * p.z*.7) * 0.01;\n    float dst = .01;\n    float blx = box(p-vec3(center.x,-oyf,center.y),vec3(bs.x*.65,bs.y*.65,bs.z*.65));\n    next = box(p-vec3(nghbor.x,-oyf,nghbor.y),vec3(bs.x*.65,bs.y*.65,bs.z*.65));\n    blx = max(blx,-box(p-vec3(center.x,-oyf,center.y),vec3(bs.x*.45,bs.y*.85,bs.z*.45)));\n    blx-=dsn;\n\n    float ice = (abs(q.x)>cp||abs(q.z)>cp) ? next : min(blx, next);\n    if(ice<res.x) {\n       res = vec2(ice,5.);\n       gtile.xyz = vec3(center,dist);\n       hit = p;\n    } \n    \n    float flr = box(p-vec3(center.x,-.5-oyf,center.y),vec3(bs.x,.075,bs.z));\n    next = box(p-vec3(nghbor.x,-.5-oyf,nghbor.y),vec3(bs.x,5.,bs.z));\n    \n    float gnd = (abs(q.x)>cp||abs(q.z)>cp) ? next : min(flr, next);\n    if(gnd<res.x) {\n       res = vec2(gnd,7.);\n       gtile.xyz = vec3(center,dist);\n       hit = p;\n    } \n\n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t, float md) {\n    float e = md*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e,0. ).x + \n        h.yyx*map( p + h.yyx*e,0. ).x + \n        h.yxy*map( p + h.yxy*e,0. ).x + \n        h.xxx*map( p + h.xxx*e,0. ).x );\n}\n\nfloat ptn_d(vec3 p){\n    vec2 uv = p.xz;\n    uv*=rot(.785);\n    vec2 ff = floor(uv);\n    float f = clamp(mod(ff.x,2.)*1.-.5,0.,1.);\n    float h = mix(1.,.0,f);\n    return h;\n}\nvec3 hue(float t) { \n    vec3 d = vec3(0.220,0.576,0.961);\n    return .45 + .375*cos(PI2*t*(vec3(.985,.98,.95)*d)); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, inout vec3 ref) {\n    n = normal(p,d,.1);\n\n    vec3 l = normalize(vec3(-15.,25,15)-p);\n    float diff = clamp(dot(n,l),.1,.8);\n    float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.75;\n\n    vec3 h = vec3(.01);\n\n    if(m==1.) {h=vec3(.5);ref=h;}\n\n    if(m==3.) {h = hue(stile.z*1.5);ref=h*.5;}\n    \n    if(m==5.) {h = vec3(0.718,0.843,0.816);ref=vec3(.65);}\n\n    if(m==7.) {h=vec3(.01);ref=vec3(.2);}\n    \n    h*=diff+spec; \n    return h;\n}\n\nvec3 renderAll( vec2 PX )\n{\n\n    ftime = (T*2.35);\n    float tmod = mod(T,10.);\n    float t3 = lsp(5.0, 10.0, tmod);\n    ga1 = eoc(t3);\n    ga1 = ga1*ga1*ga1;\n\n    ga4 = (t3)+floor(T*.1);\n    \n    vec2 uv = (2.*PX.xy-R.xy)/max(R.x,R.y);\n    vec3 C=vec3(.001);\n\n    vec3 ro = vec3(uv*zoom,-zoom-10.);\n    vec3 rd = vec3(0,0,1.);\n\n    float x = M.z > 0. ? (M.x/R.x * 2. - 1.) * PI : -.48;\n\n    mat2 rx =rot(.62);\n    mat2 ry =rot(x);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    float atten=1.,k=1.,alpha=1.;\n    vec3 p = ro + rd * .1;\n    vec3 fill=vec3(1), ref=vec3(0);\n    \n    float bt =2.,ct =6.;\n\n    float fA = 0.;\n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p,bt>1.?1.:0.);\n        float d = ray.x;\n        float m = ray.y;\n\n        p += rd * d *k;\n\n        if (d*d < 1e-6) {\n            hitPoint=hit;\n            stile=gtile;\n            \n            alpha *=1e-1;\n            \n            vec3 h=vec3(0);\n            vec3 n=vec3(0);\n            \n            C+=shade(p,rd,d,ray.y,n,ref)*fill;\n            if(bt<1.&&ct<1.)break;\n\n            p += rd*.015;\n            k = sign(map(p,0.).x);\n\n            if(m!=5.&&m!=3.){\n                fill *= ref;\n                rd=reflect(-rd,n);\n                p+=n*.02;\n                ct--;\n            }else if (bt>0.){\n                fill *= ref;\n                rd=refract(rd,n,.79);\n                bt--;\n            }\n        }  \n        if(distance(p,rd)>25.) { break; }\n    }\n\n    float mask = smoothstep(.1,.6,length(uv)-.4);\n    vec3 clr = mix(vec3(0.282,0.349,0.557),vec3(0.012,0.086,0.310)*.05 ,mask );\n    C+=clamp(max(glow,-mask),0.,.95);\n    uv*=rot(.785);\n    vec2 ff = floor(uv*45.);\n    float f = clamp(mod(ff.x,1.5)*1.-.15,0.,1.);\n    clr = mix(clr,clr*.7,f);\n    C = mix(C,clr,alpha);\n  \n    return C;\n}\n\n// baby AA - make 2 for some kind of smoothness\n#define AA 1\nvoid mainImage( out vec4 O, in vec2 F ){   \n    \n    vec3 C = renderAll(F);\n    #if AA>1\n        C +=renderAll(F+vec2(.5,.5));\n        C /= 2.;    \n    #endif\n    C = clamp(C,vec3(0),vec3(1));\n    C = pow(C, vec3(.4545));  \n    O = vec4(C,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}