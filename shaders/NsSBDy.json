{
    "Shader": {
        "info": {
            "date": "1713748228",
            "description": "smaller core",
            "flags": 0,
            "hasliked": 0,
            "id": "NsSBDy",
            "likes": 15,
            "name": "Flowing Trefoil",
            "published": 3,
            "tags": [
                "flow",
                "trefoil"
            ],
            "usePreview": 0,
            "username": "SwagLordLancalot",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 70.\n#define MAX_DIST 15.\n#define DIFF_EPS 0.0002\n\n#define SPEED 0.1\n#define POINTS 20.\n#define LENGTH 2.\n#define RADIUS 0.1\n#define FADING 0.5\n#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(2.*sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\n\n// optimized quadratic bezier https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec3 pos, vec3 A, vec3 B, vec3 C) {    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    \n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/4.0));\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.);\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec3 trefoil(float t) {\n\n    return vec3(sin(t) + 2. * sin(2. * t), cos(t) - 2. * cos(2. * t), -1.1*sin(3. * t));\n}\n\nfloat map(vec3 pos) {\n    float t = fract(SPEED * iTime);\n    float dl = LENGTH / POINTS;\n    //vec3 p1 = trefoil(t * M_2_PI);\n    vec3 p1 = vec3(sin((t * M_2_PI)) + 2. * sin(2. * (t * M_2_PI)), cos((t * M_2_PI)) - 2. * cos(2. * (t * M_2_PI)), -1.1*sin(3. * (t * M_2_PI)));\n    //vec3 p2 = trefoil((dl + t) * M_2_PI);\n    vec3 p2 = vec3(sin((dl + t) * M_2_PI) + 2. * sin(2. * (dl + t) * M_2_PI), cos((dl + t) * M_2_PI) - 2. * cos(2. * (dl + t) * M_2_PI), -1.1*sin(3. * (dl + t) * M_2_PI));\n    vec3 c = (p1 - p2) / 2.0;\n    float d = 1000000000.;\n    \n    for(float i = 2.0; i < POINTS; i++){\n        p1 = p2;\n        p2 = trefoil((i * dl + t) * M_2_PI);\n        vec3 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (1. - (f.y + i) / POINTS));\n    }\n    return d - RADIUS;\n}\n\nvec3 normal(vec3 pos) {\n    const vec2 e = vec2(DIFF_EPS, 0.);\n    return normalize(vec3(  \tmap(pos - 2.*e.xyy) + map(pos + 2.*e.xyy),\n              \t\t\t\t  \tmap(pos + e.yxy) + map(pos + e.yxy),\n              \t\t\t\t\tmap(pos - e.yyx) + map(pos + e.yyx)));\n}\n\n// fast glow https://www.shadertoy.com/view/3dcXWX \nvec2 marchTrefoil(vec3 camera, vec3 dir) {\n    float I, dt, t = 0.;\n    vec3 pos = camera + t * dir;\n    for(float i = 0.; i < MAX_STEPS; i++) {\n      \tpos = camera + t * dir;\n        dt = 0.8 * map(pos);\n        t += dt;\n        I = i;\n        if(dt < DIFF_EPS || t > MAX_DIST) break;\n    }\n    float outer = step(MAX_DIST, t);  \n    float k = 1. + dot(normal(pos), dir);\n    I -= mix(clamp((0.5 + 1. * k) * log2(DIFF_EPS/dt), .0, 1.), 1.2 * log2(dt) - 2.8, outer);\n    return vec2(I/23., outer);\n}\n\nvec2 sphereCubemap(vec3 camera, vec3 dir, float radius) {\n    float k = dot(camera, dir);\n    float c = dot(camera, camera) - radius * radius;\n    float D = k * k - c; \n    float s = k + sqrt(D);\n    vec3 d = normalize(camera + s * dir);\n    \n    vec3 n = abs(d);\n    vec3 v = (n.x>n.y && n.x>n.z) ? d.xyz: (n.y>n.x && n.y>n.z) ? d.yzx: d.zxy;\n    vec2 q = v.yz*v.x;\n    q *= 1.25 - 0.25*q*q;\n    return 0.5 + 0.5 * q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;    \n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 camera = vec3(0., -0.2, 6.);\n    \n    //vec4 mouse = qmouse(iMouse, iResolution, 0.666*iTime+5., 0.02);\n    //camera = rotate(camera, mouse);\n    //dir = rotate(dir, mouse);\n        \n    vec2 glow = marchTrefoil(camera, dir);\n    vec2 suv = sphereCubemap(camera, dir, 10.);\n    \n    vec3 noize = step(0.1, texture(iChannel0, suv).x) + texture(iChannel1, suv).xyz ;\n    vec3 space = vec3(step(3.046, length(noize - vec3(0.5)))) * (noize - 1.);\n    \n    vec3 col =  (vec3(.0, .0, .015) + 0.03 * max(space, 0.)) * glow.y;\n    col = col + mix(vec3(0., 0.25, 0.6), col, length(2.*uv)) * glow.y;\n    col += mix(vec3(.0, 0., .35), vec3(0.87, 0.0, 0.69), glow.x);\n    col += vec3(0.1, 0.2, .1) * glow.x*(1.-glow.x);\n    \n    fragColor = vec4(pow(col, vec3(2.5)), 0.30);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}