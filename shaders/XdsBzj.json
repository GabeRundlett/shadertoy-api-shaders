{
    "Shader": {
        "info": {
            "date": "1497005559",
            "description": "this shader has a special place for me, because it intelligently utilizes #define to swivel a lot,to reuse utility functions among multiple domains|dimensions.\nAnd it uses #define as a bridge for namespace compatibility,while rendering a swiveling bridge.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdsBzj",
            "likes": 25,
            "name": "#define swiveling bridge pattern",
            "published": 3,
            "tags": [
                "utility",
                "symmetry",
                "define",
                "seivel",
                "swiveling",
                "utilities"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1042
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY\n\n//parent: https://www.shadertoy.com/view/llBGzm\n//next to no changes, very minor clean ups.\n\n/*\nThis shader has a special place for me, \nbecause it intelligently utilizes #define to swivel a lot,\nto reuse utility functions, boolean \"patterns\",\namong multiple domains|dimensions to define geometry efficiently.\n\nIt demonstrates a method of \nexcellent implicit (analytic informal geometric) struture,\nwithout using any struct{}s,\n(that more easily avoids informal fallacies (by having sufficient structure))\n\nIt uses #define as a bridge for namespace compatibility,\nwhile rendering a swiveling bridge.\n*/\n\n\n#define INFINITY 10000.0\n#define FRAGCOORD gl_FragCoord.xy\n#define RESOLUTION iResolution.xy\n#define TIME iTime\n#define gl_FragColor fragColor\n\n//--utilities:----\n///position relative to screen center, range[-0.5,0.5] for both dimensions\n#define PixelCoord ((FRAGCOORD - (RESOLUTION / 2.0)) / min(RESOLUTION.x, RESOLUTION.y))\n///simplistic inaccurate or \"true\" lens; FieldOfView>0;\n#define SimpleLens(fieldOfView){rayStart=vec3(0.0);vec2 coord=PixelCoord;rayNormal=normalize(vec3(coord.x/ fieldOfView,1.0,coord.y/fieldOfView));}\n// Raytraceable surfaces, reading from rayStart and rayNormal to find the\n// distance along that ray to the surface.  (calling ApplySurface to store it in \"nearest\") \n// When rendering lights, this position is used instead of the closest point on the ray\n// to the light origin if it is closer to the start of the ray.\n// Write to \"nearest\" if you are closer than the value already there.\n// Given the distance to a surface, first checks it is not behind the camera, \n// then that it is closer than what is already stored in \"nearest\" and overwrites it if so.\n#define ApplySurface(dist, pattern){float _dist = dist; vec3 intersection=rayStart+rayNormal*_dist;if(_dist>0.0 && _dist<nearest&&pattern)nearest=_dist;}\n///infinite plane by lower case axis (x/y/z) and a (float) location on that axis;\n#define AxisSurface(axis,location,pattern)ApplySurface((location-rayStart.axis)/rayNormal.axis,pattern)\n//sphere at position with radius.\n#define SphereSurface(location, radius, pattern){vec3 _location=location;float along=dot(_location-rayStart, rayNormal); float dist = distance(_location, rayStart + rayNormal * along); float _radius = radius;if(dist < _radius){ApplySurface(along-(_radius*sin(acos(dist/_radius))),pattern)}}\n\n//return point on one line that is closest to another line.\nvec3 ClosestTimeOfApproach(vec3 pos1,vec3 vel1,vec3 pos2,vec3 vel2){\n //There's probably much better ways to calculate this, but I'm not very good at maths, so here's my approach:\n //Slice of the target line is a point, so if we project the start/end as though we're looking right down the ray,\n //we can clearly see where the closest point is.\n //yes, there is, the \"second life wiki\" has a page about \"geometry\" with some nice 3d line (segment) code.\n vec3 projStart=pos2-(vel1*dot(pos2-pos1,vel1));\n vec3 projEnd  =vel2 - (vel1*dot(vel2-pos1,vel1));\n vec3 projNorm =normalize(projEnd-projStart);\n float a=dot(pos1-projStart,projNorm);\n vec3 closest = mix(pos2,vel2,clamp(a/distance(projStart,projEnd),0.0,1.0));return closest;}\n//capsule defined by radius and 2 sphere centers.\n#define CapsuleSurface(start, end, radius, pattern) { SphereSurface( ClosestTimeOfApproach(rayStart, rayNormal, start, end), radius, pattern ) }\n// [Patterns] are functions which define where on a surface is solid, and where is not.\n// They typically take the intersected point (intersection) and return true to make the surface solid.\n// Always solid.\n#define SolidPattern true\n// Never solid.\n#define NonSolidPattern false\n// Given a lowercase axis (x/y/z), a (float) location on that axis and two patterns, one pattern is shown \n// on one side of a plane on that axis at that location, and on the other side, the other pattern.\n#define AxisPattern(axis,location,negativePattern,positivePattern)(intersection.axis>location?positivePattern : negativePattern)\n// Given a spacing between each circle, a radius for each circle and two patterns, one pattern is shown\n// inside a repeating grid of circles while the other is shown outside the circles.\n#define CirclePattern(spacing,radius,insidePattern,outsidePattern)\n// Given a (float) spacing between each stripe, a (float) width for the stripes and two patterns, \n// diagonal stripes are drawn with one pattern used on the stripes and the other used off the stripes.\n#define StripePattern(spacing, width, onPattern, offPattern)\n// False volumetric lights computed by taking the closest point to the origin along the ray\n// and then computing the distance/etc. to the origin.  This gives a nice misty looking light.\n// Each light is built in the following steps:\n// - An Origin function.  This determines the distance along the ray to the nearest point to the \n//   light (stored in \"origin\"), storing it in \"originAlong\".  These call common code to reset \n//   \"intensity\" to 1.0 and compute \"originNearest\", the closest point on the ray to the light origin.\n// - One or more Falloff functions.  These use the origin data to determine a coefficient (rolloff\n//   over distance, etc.) and multiply \"intensity\" by it.\n// - A call to Shade to color the light and store it in an accumulator.\n//Applies the current light, multiplying it by a color and saving it to the display.\n#define Shade(color) { acc += intensity * color; }\n//Resets the intensity of the light so its origin can be reused.\n#define ResetFalloff { intensity = 1.0; }\n//Called by every origin to setup common data.\n#define SetupOrigin { intensity = 1.0; if(originAlong < 0.0 || originAlong > nearest) { originAlong = nearest; } originNearest = rayStart + rayNormal * originAlong; }\n\n//Given a location, creates a radial light from that location.\n#define RadialOrigin(location) { origin = location; originAlong = dot(origin - rayStart, rayNormal); SetupOrigin }\n//Given a lowercase axis (x/y/z) and a (float) location on that axis, creates a light emitted from\n//an infinite plane there.\n#define AxisOrigin(axis, location)\n//Light gets darker the further we are from the origin.  Larger rates fall off quicker.\n//Linearity is the power of the falloff; 1.0 is linear, 2.0 is inverse square, 3.0 is inverse cube, etc.\n#define DistanceFalloff(rate, linearity){ intensity /= pow(1.0 + distance(origin, originNearest) * rate, linearity);}\n\n// The light gets darker the further off a (vec3) normal we are from the origin.\n// Linearity is the power of the falloff; 1.0 is linear, 2.0 is inverse square, 3.0 is inverse cube, etc.\n// Note that because we sample the closest point to the origin of the light, on point lights\n// pointing at or away from the camera the spot is infinitely small so the light disappears.\n#define DirectionalFalloff(normal, linearity) { intensity *= pow(max(0.0, dot(normal, normalize(originNearest - origin))), linearity); }\n\nvec3 rotateX(vec3 t, float a){return t*mat3(1.0   ,0.0    ,0.0    ,0.0   ,cos(a),-sin(a),0.0   ,sin(a),cos(a));}\nvec3 rotateY(vec3 t, float a){return t*mat3(cos(a),0.0    ,-sin(a),0.0   ,1.0   ,0.0    ,sin(a),0.0   ,cos(a));}\nvec3 rotateZ(vec3 t, float a){return t*mat3(cos(a),-sin(a),0.0    ,sin(a),cos(a),0.0    ,0.0   ,0.0   ,1.0   );}\n\n//Post-process modify the color stored in \"accumulator\", This where main() should be.\n//However, some GLSL sandboxes don't allow you to define main() yourself.\n#ifdef SHADERTOY\n void mainImage(out vec4 fragColor,in vec2 fragCoord){\n#else\n void main(){\n#endif\n vec3 rayStart,rayNormal;\n float nearest=INFINITY;\n vec3 origin,originNearest;\n float originAlong;\n vec3 acc = vec3(0.0);\n float intensity;\n SimpleLens(1.0)\n rayStart.x += 5.9;\n rayStart.y -= 14.4;\n rayStart.z += 1.6;  \n rayNormal=rotateZ(rotateX(rayNormal,sin(TIME*0.314)*0.2),0.5+sin(TIME*0.5)*0.3);\n AxisSurface(z, 0.0, SolidPattern)// Road\n // Sidewalk top.\n AxisSurface(z, 0.1,  // Sidewalk top.\n  AxisPattern(x, -3.0, SolidPattern, // Left.\n  AxisPattern(x, 3.0, NonSolidPattern, SolidPattern)))// Right  \n AxisSurface(x, -3.0, AxisPattern(z, 0.1, SolidPattern, NonSolidPattern))// Sidewalk left curb\n AxisSurface(x, 3.0, AxisPattern(z, 0.1, SolidPattern, NonSolidPattern)) // Sidewalk right curb.\n //Streelights are triplets of CapsuleSurface()\n CapsuleSurface(vec3(-4.425,  8.0,0.1  ),vec3(-4.425,  8.0,1.0  ),0.25 ,SolidPattern)\n CapsuleSurface(vec3(-4.425,  8.0,1.0  ),vec3(-4.425,  8.0,5.255),0.125,SolidPattern)\n CapsuleSurface(vec3(-2.8  ,  8.0,5.225),vec3(-4.425,  8.0,5.225),0.125,SolidPattern)\n CapsuleSurface(vec3( 4.425, -2.0,0.1  ),vec3( 4.425, -2.0,1.0  ),0.25 ,SolidPattern)\n CapsuleSurface(vec3( 4.425, -2.0,1.0  ),vec3( 4.425, -2.0,5.255),0.125,SolidPattern)\n CapsuleSurface(vec3( 2.8  , -2.0,5.225),vec3( 4.425, -2.0,5.225),0.125,SolidPattern)\n CapsuleSurface(vec3( 4.425, 18.0,0.1  ),vec3( 4.425, 18.0,1.0  ),0.25 ,SolidPattern)\n CapsuleSurface(vec3( 4.425, 18.0,1.0  ),vec3( 4.425, 18.0,5.255),0.125,SolidPattern)\n CapsuleSurface(vec3( 2.8  , 18.0,5.225),vec3( 4.425, 18.0,5.225),0.125,SolidPattern)\n CapsuleSurface(vec3(-4.425,-12.0,0.1  ),vec3(-4.425,-12.0,1.0  ),0.25 ,SolidPattern)\n CapsuleSurface(vec3(-4.425,-12.0,1.0  ),vec3(-4.425,-12.0,5.255),0.125,SolidPattern)\n CapsuleSurface(vec3(-2.8  ,-12.0,5.225),vec3(-4.425,-12.0,5.225),0.125,SolidPattern)\n CapsuleSurface(vec3(-4.425, 28.0,0.1  ),vec3(-4.425, 28.0,1.0  ),0.25 ,SolidPattern)\n CapsuleSurface(vec3(-4.425, 28.0,1.0  ),vec3(-4.425, 28.0,5.255),0.125,SolidPattern)\n CapsuleSurface(vec3(-2.8  , 28.0,5.225),vec3(-4.425, 28.0,5.225),0.125,SolidPattern)\n // Bridge only shows 2 faces in 2 dimensions\n AxisSurface(z,5.5,AxisPattern(y,3.4,NonSolidPattern,AxisPattern(y,28.2,SolidPattern,NonSolidPattern)));\n AxisSurface(y,3.4,AxisPattern(z,5.5,NonSolidPattern,AxisPattern(z, 8.4,SolidPattern,NonSolidPattern)))\n // Bridge lights are duples\n CapsuleSurface(vec3(22.5,10.0,13.175),vec3(22.5,5.6, 12.175), 0.125, SolidPattern)\n CapsuleSurface(vec3(22.5, 5.6, 7.3  ),vec3(22.5,5.6, 12.0), 0.25, SolidPattern)\n CapsuleSurface(vec3(-7.5, 10.0, 13.175), vec3(-7.5, 5.6, 12.175), 0.125, SolidPattern)\n CapsuleSurface(vec3(-7.5, 5.6, 7.3), vec3(-7.5, 5.6, 12.0), 0.25, SolidPattern)\n // Bridge supports are duples\n CapsuleSurface(vec3(12.5, 9.2, 4.8), vec3(12.5, 9.2, -1.75), 2.0, SolidPattern)\n CapsuleSurface(vec3(12.5, 22.40618, 4.8), vec3(12.5, 22.40618, -1.75), 2.0, SolidPattern)\n CapsuleSurface(vec3(-17.5, 9.2, 4.8), vec3(-17.5, 9.2, -1.75), 2.0, SolidPattern)\n CapsuleSurface(vec3(-17.5, 22.40618, 4.8), vec3(-17.5, 22.40618, -1.75), 2.0, SolidPattern)\n CapsuleSurface(vec3(-47.5, 9.2, 4.8), vec3(-47.5, 9.2, -1.75), 2.0, SolidPattern)\n CapsuleSurface(vec3(-47.5, 22.40618, 4.8), vec3(-47.5, 22.40618, -1.75), 2.0, SolidPattern)\n CapsuleSurface(vec3(-77.5, 9.2, 4.8), vec3(-77.5, 9.2, -1.75), 2.0, SolidPattern)\n CapsuleSurface(vec3(-77.5, 22.40618, 4.8), vec3(-77.5, 22.40618, -1.75), 2.0, SolidPattern)\n // Distant buildings are duples like he bridge, but other dimensions.\n AxisSurface(y, 115.0, AxisPattern(x, -58.7668, NonSolidPattern, AxisPattern(x, -37.55514, SolidPattern, NonSolidPattern)))\n AxisSurface(x,-37.55514,AxisPattern(y,115.0    ,NonSolidPattern,SolidPattern))\n AxisSurface(y,123.14195,AxisPattern(x,-30.41511,NonSolidPattern,AxisPattern(x,-9.20345,SolidPattern,NonSolidPattern)))\n AxisSurface(x,-30.41511,AxisPattern(y,123.14195,NonSolidPattern,SolidPattern))//Render lights.\n #define Rain(size,speed,strength){intensity*=dot(mix(vec3(strength),vec3(1.0),sin(sin(size*originNearest+TIME*speed)+TIME)),vec3(1.0));}\n #define StreetLight DistanceFalloff(1.2,2.0)DirectionalFalloff(vec3(0.0,0.0,-1.0),2.0)Rain(0.5, vec3(1.0, 5.0, 8.0),0.7)Shade(vec3(1.0, 1.0,0.6))   \n RadialOrigin(vec3(-2.8,-12.0,5.225))StreetLight    \n RadialOrigin(vec3( 2.8, -2.0,5.225))StreetLight    \n RadialOrigin(vec3(-2.8,  8.0,5.225))StreetLight    \n RadialOrigin(vec3( 2.8, 18.0,5.225))StreetLight    \n RadialOrigin(vec3(-2.8, 28.0,5.225))StreetLight   \n ///Closest side of overpass.\n #define OverpassLight DistanceFalloff(1.2,2.0)Rain(0.5,vec3(1.0,5.0, 8.0),0.7)Shade(vec3(0.8,0.4,0.1))   \n RadialOrigin(vec3( 22.5,10.0,13.05))OverpassLight              \n RadialOrigin(vec3( -7.5,10.0,13.05))OverpassLight              \n RadialOrigin(vec3(-47.5,10.0,13.05))OverpassLight              \n ///Furthest side of overpass.\n RadialOrigin(vec3( 37.5,21.6,13.05))OverpassLight    \n RadialOrigin(vec3(  7.5,21.6,13.05))OverpassLight    \n RadialOrigin(vec3(-22.5,21.6,13.05))OverpassLight    \n RadialOrigin(vec3(-52.5,21.6,13.05))OverpassLight    \n //Lights between the distant buildings.\n #define DistantLight(color)DistanceFalloff(1.0,2.0)Shade(color)\n RadialOrigin(vec3(-64.3834, 115.0, 1.0)) DistantLight(vec3(0.4, 0.3, 0.0))\n RadialOrigin(vec3(-35.0, 135.0, 4.0)) DistantLight(vec3(0.5, 0.3, 0.0))\n RadialOrigin(vec3(-8.0, 150.0, 3.0)) DistantLight(vec3(0.2, 0.1, 0.05))\n // A big dim light to help separate things a little.\n RadialOrigin(vec3(-38.96571, 58.15232, 20.55807)) DistanceFalloff(2.0, 1.0) Shade(vec3(0.0, 0.0, 1.0))\n if(nearest==INFINITY){acc+=vec3(0.02,0.018,0.005);}// Sky\n acc*=2.0;\n#ifdef SHADERTOY\n fragColor=vec4(acc,1);} \n#else  \n gl_fragColor=vec4(acc,1);} //is reserved namespace that is in conflict with shadertoy's wrapper in some cases.   \n #endif",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}