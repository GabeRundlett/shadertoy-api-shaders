{
    "Shader": {
        "info": {
            "date": "1532084905",
            "description": "barely improved variant of its parent",
            "flags": 0,
            "hasliked": 0,
            "id": "MltczM",
            "likes": 2,
            "name": "skewing intersecting portals",
            "published": 3,
            "tags": [
                "portals",
                "skew"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "//self : https://www.shadertoy.com/view/MltczM\n\n\n//sign 3d portals rotating doubly linked shadows B\n//parent self  : https://www.shadertoy.com/view/Mt2czK\n//parent: https://www.shadertoy.com/view/XtjcRV\n\n//use buffers,here only for \"space\" keyboard input.\n#define doBuffer\n#define KEY_SPACE (vec2(32.5,.5)/256.)\n\n//ichannel0 is for keyboard input\n//,while space,move camera to center fror hall of pirrots position.\n\n//max view distance.(loses its meaning where portals make space noneuclidean)\n#define maxdist 100.\n//iterations trough space between portals\n#define iterRm 200.\n//iterations trough portals(max number of portals trough portals)\n#define iterTp 20\n\n//ollj made all 3 epsilons smaller by *=.1\n//this,fits the small scale of the set better.\n//this also required more [iterRm]\n//epsilon raymarch\n#define epsRm .001\n//epsilon for normal,derivative\n#define epsDx .001\n//epsilon shadows\n#define epsShad .01\n\n//simple lazy fov;1=parallel projection ;0=180deg;\n#define fov .5\n\n//Do intro where the camera drops down,+1exp()to camera movement.\n//#define doCameraDrop\n\n#define portalThickness (cos(iTime)*.1+.1)\n\n//glossyness\n#define scalePhong .2\n\n//background color,sky color or microwave background(scatter max)\n#define cCMB vec4(.3,.5,1,1)\n\n#define lightdir normalize(vec3(-1,1,.5))\n#define lightintensity 1.5\n#define dark vec3(.2,.4,.4)\n#define floorheight -1.5\n\n/*\ni stretched portal scale to test the coonstrains of:\n-more obvious portal scaling distortion \n--portals are still lipschitz continuous,just not classically euclidean.\n-portals intersecting each other\n-one portal intersecting a solid(the floor)\n-hit space and have the camera be inside the object with the portal on it.\n--camera close to portal should tepeport the camera RAYS instantly.\n--even though the camera is static,only its rays are not.\n\ntodo\n,needs quaternion rotation\n,and all the stuff you can extend portals with\n,including a movable camera that gets teleported.\n*/\n\n//material g-buffer enum\n#define background 0.\n#define mPortal1 1.\n#define mPortal2 2.\n#define mFrame 3.\n#define mFloor 4.\n#define mGeometry 5.\n\n#define pi0 6.28318530718\n#define pi  acos(-1.)\n#define pi2 acos(0.)\n\n\nfloat suv(vec2 a){return a.x+a.y;}\nfloat suv(vec3 a){return dot(a,vec3(1));}//dot()can be faster than 2add.\nfloat mav(vec2 a){return max(a.x,a.y);}\nfloat mav(vec3 a){return max(max(a.x,a.y),a.z);}\n\n//dir and up should be a vec4 quaternion instead!\n//not just for performance,but aslso to avoid gimbal locking\nstruct PortalFrame{\n vec3 c;\n vec3 dir;\n vec3 up;\n vec2 dims;\n}p1,p2;//i am not a fan of global structs here.\n//but portals\n//,that make space noneuclidean are a reasonable exception for nor\n\nfloat boxsdf(vec3 u,vec3 e,out vec3 o){\n e*=.5;o=u/mav(e);return mav(vec3(abs(u)-e));}\n\nfloat cylindersdf(vec3 u,float r,float h,out vec3 o){\n o=u/max(r,h);return max(length(u.xz)-r,max(-u.y,u.y-h));}\n\nvec2 portalsdf(vec3 u,PortalFrame p,out vec3 a){\n vec3 r=u-p.c;\n vec3 w=normalize(cross(p.dir,p.up));\n vec3 v=cross(w,p.dir);\n //above dual crossproduct rotation is slower than quaternion rotation.\n //but for small angles,this is the fallback of quaternion rotation anyways.\n a=vec3(dot(r,w),dot(r,v),dot(r,p.dir));\n p.dims=p.dims/2.;\n float d=mav(vec3(abs(a.z)-portalThickness*.5,abs(a.xy)-p.dims.xy-portalThickness));\n // float y=all(lessThan(abs(a.xy),p.dims.xy))?portalmat1:mFrame;\n return vec2(d,all(lessThan(abs(a.xy),p.dims.xy))?mPortal1:mFrame);}\n\n//if(distance is smaller than previous)also write textureID\nvoid bgw(inout vec2 d,inout vec3 p,vec3 q,float h,float m){\n if(h<d.x){d=vec2(h,m);p=q;}}\nvoid bgw(inout vec2 d,inout vec3 p,vec3 q,float h){\n bgw(d,p,q,h,mGeometry);}//bgw==buffer-g-write ==write objectID.\n\n//p* and q* are \"portal target bijectuive-switcheroo coordinates.\n//distance field gradient\nvec2 dg(vec3 u,out vec3 p){\n vec3 q1,q2;//potals are structs that will tell you their \"exit coordinates\"\n vec2 d,d1=portalsdf(u,p1,q1),d2=portalsdf(u,p2,q2);\n if(d1.x<d2.x){d=d1;p=q1;\n }else    {p=q2;d=vec2(d2.x,d2.y<2.5?mPortal2:mFrame);}\n bgw(d,p,u,max(u.y-floorheight,length(u.xz)-10.),mFloor);//floor\n bgw(d,p,u,length(u-vec3(2,0,0))-.8);//sphere,radius of 8\n bgw(d,p,u,cylindersdf(u-vec3(-0.3,-1.5,0.),0.1,1.5,q1));//cylinder\n bgw(d,p,u,boxsdf(u-vec3(0,-.5,-3),vec3(.4,1.7,.4),q1));//box\n bgw(d,p,u,boxsdf(u-vec3(0,-1,3),vec3(5.,.5,.9),q1));//box\n return d;}//.y is a materialID g-buffer\n\n//sphere tracking,raymarching,linear gradient descent\n//i guess for portals you need it to be this explicit\nvec2 gd(vec3 u,vec3 t,out vec3 o){\n float a=0.;//accumulated distance traveled\n vec2 g=dg(u,o);//gradient at u,save travel sphere.\n for(float i=.0;i<iterRm;i++){\n  a+=g.x;\n  g=dg(u+a*t,o);\n  if(abs(g.x)<epsRm){return vec2(a,g.y);//hit a surface\n  }else if(g.x>maxdist)break;//too far from camera\n }return vec2(maxdist,background);}//not hit anything\n//having o store the position along the ray is infficient.\n//it accumulates more precision loss than it gains.\n\nvec3 normal(vec3 u){vec3 c;vec2 e=vec2(epsDx,0);return normalize(vec3\n(dg(u+e.xyy,c).x-dg(u-e.xyy,c).x\n,dg(u+e.yxy,c).x-dg(u-e.yxy,c).x\n,dg(u+e.yyx,c).x-dg(u-e.yyx,c).x));}\n\nvec2 shaderay(vec3 u,vec3 t,float h){//origin,dirction,hardness\n vec3 c,n=normal(u);\n vec2 ds=gd(u+epsShad*lightdir,lightdir,c);\n float l=max(0.,dot(n,lightdir))*lightintensity;//lambert\n l*=sign(.5-ds.y)*.5+.5;//l=ds.y<.5?l:0.;\n float p=pow(max(0.,dot(normalize(lightdir-t),n)),h);//phong\n return vec2(l,p*scalePhong);}\n\n\n//for abstraction and development\n//,texturing patterns are their own functions\nvec3 portalBorderColor(vec3 c){c=step(mod(c,.5),vec3(.25));\n return mix(vec3(.2),vec3(.2,.7,.6),abs(abs(\n #if 0\n  c.x+c.y)+c.z));}//pattern ollj\n #else\n  c.x-c.y)-c.z));}//pattern original\n #endif\n//return checkerboard pattern of point c\nvec3 yellowObjects(vec3 c){c=step(mod(c,.5),vec3(.25));return mix//pattern scaling\n(vec3(1.,.7,.2)//sun-yellow(scatter low)\n,vec3(.4,.8,.4)//leaf-green(scatter medium)\n,abs(abs(c.x-c.z)-c.y));}//3d checkerboard pattern\nvec3 ground(vec3 c){c=step(mod(c,1.),vec3(.25));return mix\n(vec3(.6)\n,vec3(.7)\n//,abs(c.x-c.z));}//2d ground pattern original\n,abs(c.x)-c.z);}//2d ground pattern ollj\n\n//teleport th point trough a portal\nvec4 tp(inout vec3 e,inout vec3 t,inout vec3 c,vec4 o,inout PortalFrame p1,inout PortalFrame p2){\n   vec3 u=normalize(cross(p1.dir,p1.up));\n   vec3 v=cross(u,p1.dir);\n   float x=dot(t,u),y=dot(t,v),z=dot(t,p1.dir);\n   u=normalize(cross(p2.dir,p2.up));\n   v=cross(u,p2.dir);\n   vec2 s=p2.dims/p1.dims;//portal scaling\n   t=normalize(x*u*s.x \n     +y*v*s.y\n     +z*p2.dir);//teleport ray direction\n //above and below doesnt simplify,because u and v are vec3,.\n   e=p2.c\n +c.x*u*s.x \n +c.y*v*s.y \n -c.z*p2.dir \n +2.*epsRm*t;//teleport camera position\n return o;}//debug error output color\n//for [max portal levels] or for [disabled portal entrance]\n//given that this calculates the differential between 2 rotations\n//,tp() begs for quaternions.\n\n#define sc(a)vec2(sin(a),cos(a))\n\nvoid mainImage(out vec4 o,in vec2 fragCoord){o=vec4(1);\n #ifdef doBuffer\n  float s=.5;//texture(iChannel0,KEY_SPACE).r;\n #else\n  float s=0.;\n #endif\n          \n vec2 aa=sc(clamp(iMouse.y/iResolution.y-.5,-.15,1.)*pi2);\n vec2 cph=sc((iMouse.x/iResolution.x-.35)*pi0)*aa.y;\n vec3 e=(.01+5.*(1.-s))*vec3(cph.x,aa.x\n    #ifdef doCameraDrop\n  +2.*exp(-iTime)\n    #endif\n    ,cph.y);//camera rotation\n vec3 w=normalize(-e);\n e+=vec3(-.3,.05,0);//eye position,relevant for \"distance to eye\"\n vec3 u=normalize(cross(w,vec3(0,1,0)));\n vec3 v=cross(u,w);\n vec3 t=normalize(fov*w\n     +(fragCoord.x/iResolution.x-.5)*u\n      +(fragCoord.y/iResolution.x-.5*iResolution.y/iResolution.x)*v);\n //I have seen worse [camera to ray] functions.\n       \n float ts=(sin(iTime*.2)+1.)*pi;\n p1=PortalFrame(vec3(0)//center\n      ,normalize(vec3(1,.1*cos(iTime*2.)*sin(ts),.0))//forward\n      ,vec3(0,1,.2*sin(iTime*2.)*cos(ts))//up\n      ,vec2(2,3.+cos(ts*.5)));//scale\n p2=PortalFrame(vec3(-1.5,0,0)//center\n      ,vec3(sc(ts),0).yzx//forward\n      ,vec3(0,1,0)//up\n      ,vec2(3,2));//scale\n //above swivels the parameters of 2 \"portals\"\n // That would mbe much simpler with a quaternion. \n            \n for(int i=0;i<iterTp;i++){\n  vec3 c;//stores position along ray\n  vec2 d=gd(e,t,c);\n  if(d.y<.5){o=cCMB;break;//cBackground\n  }else if(d.y<1.5){o=tp(e,t,c,vec4(.2,.8,1,1),p1,p2);//cPortal1\n  //break;//disable cyan-blue portal entrance\n }else if(d.y<2.5){o=tp(e,t,c,vec4(.8,.2,1,1),p2,p1);//cPortal2   \n  //break;//disable magenta-pink portal entrance \n }else if(d.y<3.5){//cPortalBorder\n  float s=shaderay(e+d.x*t,t,1.).x;\n  o.xyz=max(dark.b,s)*portalBorderColor(c);\n  break;//hit surface\n }else if(d.y<4.5){//floor\n   vec2 s=shaderay(e+d.x*t,t,10.);\n   o=vec4(max(dark.b,s.x)*ground(c)+s.y,1);\n   break;//hit surface\n  }else{//yellow checkered objects    \n  vec2 s=shaderay(e+d.x*t,t,5.4);\n   o.xyz=max(dark.b,s.x)*yellowObjects(c)+s.y;\n  }\n }}\n ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}