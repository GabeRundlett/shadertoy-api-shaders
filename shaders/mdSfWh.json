{
    "Shader": {
        "info": {
            "date": "1689746779",
            "description": "Inspired by this video by Nils Berglund:\n\nhttps://www.youtube.com/watch?v=pN-gi_omIVE\n\nIn honor of Richard Courant, a pioneer of CFD. The wave speed is modulated by simplex noise.\n\n* mouse: emit wave\n* space: reset\n* shift: disable shadows\n* b: blur off",
            "flags": 48,
            "hasliked": 0,
            "id": "mdSfWh",
            "likes": 26,
            "name": "Branching Flow Slime Mold",
            "published": 3,
            "tags": [
                "2d",
                "reflection",
                "wave",
                "simulation"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 374
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this video by Nils Berglund:\n//\n//      https://www.youtube.com/watch?v=pN-gi_omIVE\n//\n//  The simulation is pretty much the same as its fork parent, where I'm sending waves\n//  through a field with varying wave speed (Courant number) by position. In the video,\n//  Mr. Berglund shows a simulation with a baroque thread-like structure. I wanted to see\n//  these, and I think I found them. The \"trick\" is to visualize the derivative of the\n//  wave. It's necessasry to blur that over time to hide the wave motion (press B to disable\n//  the blurring, to see why it's necessary).\n//\n//  The lighting is also substantially the same as its predecessor, with screen-space\n//  shadows really helping to highlight the tendrils. The \"slime mold\" in the name is because\n//  these tendrils remind me of the \"slime mold\" simulations I've tried before, like:\n//\n//      Slime Mold Terrain     https://shadertoy.com/view/Dd23z3\n//\n//  The idea of those is to have particles lay trails that the particles prefer to\n//  follow. There's probably some reason why this wave simulation produces similar\n//  results, but I'm not at all sure that happens mathematically.\n// ---------------------------------------------------------------------------------------\n\nfloat map(vec2 p)\n{\n    float d = texture(iChannel0, p / iResolution.xy).w;\n    return pow(d * 5e4, .3);\n}\n\nvec2 gradient(vec2 p)\n{\n    if (p.y == iResolution.y - .5) return vec2(0);\n    \n    vec2 delta = vec2(1, 0);\n    float xGrad = map(p + delta.xy) - map(p - delta.xy);\n    float yGrad = map(p + delta.yx) - map(p - delta.yx);\n\n    return vec2(xGrad, yGrad);\n}\n\nvec4 getColor(float d)\n{\n    vec4 c = sin(d * vec4(3, 4, 1, 0));\n    return c * c * c + vec4(.02,.02,.3,0);\n}\n\nfloat computeShadow(vec2 u, float pd)\n{\n    if (keyDown(KEY_SHIFT)) return 1.;\n    \n    vec2 del = vec2(-1, 1);\n    float sh = 1.;\n    for (float i = 0.; i < 12.; ++i)\n    {\n        u += del;\n        float nd = map(u);\n        sh *= smoothstep(nd  - float(i) * 2e-3, nd - float(i) * 1e-4, pd);\n    }\n    \n    return sh;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 g = -gradient(u);\n    \n    const vec3 ld = normalize(vec3(-1, 1, 1)); // light dir\n    const vec3 vd = vec3(0, 0, 1); // view dir\n    \n    vec4 v = texelFetch(iChannel0, ivec2(u), 0); // wave height;\n    float wh = map(u);\n    float sh = computeShadow(u, wh); // shadow\n    vec3 n = normalize(vec3(g, .1)); // normal\n    O = .3 + max(vec4(0.), vec4(dot(n, ld))) * (sh * .5 + .5); // diffuse\n\n    O *= getColor(wh); // colorize\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, true); // true for last parameter => update state, emit waves\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define U(u) texelFetch(prevBuffer, ivec2(u), 0) //\nconst float FOCUS_DIST = .45;\n\n// From iq's 3d simplex noise: https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c)\n{\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n#define KEY_B 66\n\nconst float BOUND_GAMMA = .01; // damping factor for boundary\n\nvec2 initWave(vec2 u, vec2 c, vec2 R)\n{\n    vec2 delta = u - c;\n    float d2 = dot(delta, delta);\n\n    float df = sqrt(d2);\n    return 5. * R.x * vec2(sin(df), cos(df)) / (1. + d2 * 1e6);\n}\n\nvoid updateBuffer(out vec4 O, vec2 u, vec2 R, int iFrame, vec4 iMouse, sampler2D prevBuffer, sampler2D iChannel3, bool bufferA)\n{\n    vec2 o = vec2(1, 0),\n         p = (u - .5 * R) / R.y;\n\n    vec4 state = texelFetch(prevBuffer, ivec2(0), 0);\n    \n    // handle persistent state\n    if (ivec2(u) == ivec2(0))\n    {\n        if (iFrame == 0 ||\n            state.w != R.x * R.y ||\n            keyClick(KEY_SPACE))\n        {\n            O = vec4(0);\n            O.w = R.x * R.y;\n            return;\n        }\n        \n        O = state;\n        \n        if (bufferA && ++O.z > 10.)\n            O.z = 0.;\n        \n        return;\n    }\n    \n    if (iFrame == 0 ||\n        state.w != R.x * R.y ||\n        keyClick(KEY_SPACE))\n    {\n        // init\n        O = vec4(0);\n        return;\n    }\n    else\n    {\n        float C = simplex3d_fractal(vec3(p * 10., float(iFrame) * .0005)); // Courant, modulated by scrolling 3D simplex noise\n        C = .5 * pow(C * .5 + .5, 4.);\n\n        O = U(u).xxyw; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n                \n        float md = abs(O.x - O.z); // derivative mag\n        float blur = keyDown(KEY_B) ? 1. : .001;\n        O.w = mix(O.w, md, blur); // apply blur\n        \n        if (int(u.y) < 5)\n            O.x = O.x - C * (O.x - U(u + o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing bottom boundary\n        else if (int(u.y) == int(R.y) - 1)\n            O.x = O.x - C * (O.x - U(u - o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing top boundary\n        else if (int(u.x) == 0)\n            O.x = O.x - C * (O - U(u + o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing left boundary\n        else if (int(u.x) == int(R.x) - 1)\n            O.x = O.x - C * (O - U(u - o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing right boundary\n        else\n            O.x = -O.z + 2.*O.x + C*(U(u + o) + U(u - o) + U(u + o.yx) + U(u - o.yx) - 4. * O).x; // apply wave equation\n    }\n\n    if (bufferA)\n    {\n        vec2 h = vec2(.5);\n        \n        // add disturbance at the center\n        if (state.z < 1. || iFrame == 0)\n            O.xy += initWave(u, h * R.xy, R);\n\n        // add disturbance for mouse click\n        if (iMouse.z > 0. && (state.z < 1. || iMouse.w > 0.))\n            O.xy += initWave(u, iMouse.xy, R);\n    }\n    \n    O *= .9990;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}