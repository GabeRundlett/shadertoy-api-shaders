{
    "Shader": {
        "info": {
            "date": "1604723044",
            "description": "Refer to the great tutorial: https://www.youtube.com/watch?v=Ff0jJyyiVyw&pbjreload=101\n\nI organized the codes from the above tutorial and made a little extension.",
            "flags": 0,
            "hasliked": 0,
            "id": "tstBR7",
            "likes": 1,
            "name": "Ray Marching Primitive Shapes",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "yonng",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "\n\n//make sure avoid negative components -> obtain the distance\nfloat sdfBox(vec3 p, vec3 center,vec3 len )  //center of the box\n{\n     return length(max(abs(p-center)-len,0.));   //3 components of len are identical. For example, vec3(0.5)\n      \n}\n\n\n// cylidner with two cap, trick is to define the y component\n// to make caps, consider the interior points\nfloat sdfCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab,ap) /dot(ab,ab);\n    \n    vec3 c = a+t*ab;\n    float x = length(p-c) - r;   // for the side part -> x\n    float y = (abs(t- 0.5) -0.5) * length (ab);\n    float e = length(max(vec2(x,y),0.));\n    \n    float i = min(max(x,y),0.);  //to make is a little smooth appearance\n    \n    return e+i;\n    \n}\n\n// torus on the xz plane\nfloat sdfTorus(vec3 p, vec3 center, vec2 r)   //r is for the two radiuses\n{\n     p -=center;  //remap the center from the (0,0,0)\n     float x = length(p.xz) - r.x;\n     return length(vec2(x, p.y)) - r.y;    //r.y is \n    \t\n}\n\nfloat sdfCapsule(vec3 p, vec3 a, vec3 b, float radius)\n{\n      vec3 ab = b-a;\n      vec3 ap = p -a;\n      \n      float t = dot(ab, ap) / dot(ab, ab);   //use dot to find the segment index for the capsule\n      t = clamp (t,0., 1.);\n      \n      vec3 c = a+t*ab;\n      float d = length(p-c) - radius;\n      return d;\n}\n\n\nfloat sdfSphere(vec3 p, vec4 center)\n{\n      return length(p - center.xyz) - center.w;   //w is the radius   \n}\n\nfloat sdfScene(vec3 p)  // simple way calculate the distance using ray marching\n{\n     vec4 s = vec4(0,3,6,1);   //the last 1 is for radius, the first three are the coordinates of the circle\n     float spheresdf = sdfSphere(p,s);\n    \n     float capsulesdf = sdfCapsule(p,vec3(0,.3,6),vec3(0,2,6),.2);\n     \n     float planesdf = p.y;   //for the plane, plane's height is at 1 \n     float torussdf = sdfTorus(p,vec3(0,0.5,7), vec2(1.58,.2));\n     float boxsdf = sdfBox(p,vec3(-3,0.5,6),vec3(0.5));  //0.5 above the ground, and 6 depth\n     boxsdf = min(boxsdf, sdfBox(p,vec3(-3,0.5,4.9),vec3(0.5)));\n     boxsdf = min(boxsdf, sdfBox(p,vec3(-3,1.5,5.5),vec3(0.5)));\n    \n     float cysdf = sdfCylinder(p, vec3(2,.5,4),vec3(2,.5,6),.2);\n     cysdf =min(cysdf,sdfCylinder(p, vec3(2.5,.5,4),vec3(2.5,.5,6),.2));\n         \n     float d = min(capsulesdf, planesdf);\n     d = min(d,torussdf);\n     d = min(d, boxsdf);\n     d = min(d, cysdf);\n     return d;\n    \n}\n\n#define MAX_STEPS 100    \n#define MAX_DIST 100.   \n#define SURF_DIST .01\n\n//float and int\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat d0=0.;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n       vec3 p = ro + rd*d0;\n       float ds = sdfScene(p);   \n       d0+=ds;\n       // to long or to small -> break\n       if(d0>MAX_DIST||ds<SURF_DIST) break;\n        \n    }\n    \n    return d0;\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = sdfScene(p);\n    vec2 e = vec2(.001,0);  //delta e\n    vec3 n= d - vec3(sdfScene(p-e.xyy),\n                   sdfScene(p-e.yxy),\n                   sdfScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));  //light moves aro  und\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l)*0.5+0.5,0.,1.);\n    \n    //utilize the idea of shadowmap to generate the light\n    //if the distance can't reach the light then in shadow\n    float d = RayMarch(p+n*SURF_DIST*2.,l); //from the plane a little bit\n    if(d<length(lightPos - p)&& p.y<0.1) dif*=.2;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,3,0);\n    //-.2 make the camera looks down a little bit\n    vec3 rd= normalize(vec3(uv.x,uv.y-.4,1));  //rd equals every point on the screen\n    \n    float d = RayMarch(ro, rd);\n    //d /=6.;\n    vec3 p = ro+rd*d;\n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    //col = GetNormal(p);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}