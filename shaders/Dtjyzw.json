{
    "Shader": {
        "info": {
            "date": "1691594023",
            "description": "A small shader to experiment with circle area distribution functions to visually check for uniformity. Doubles as a way to test performance of functions.",
            "flags": 32,
            "hasliked": 0,
            "id": "Dtjyzw",
            "likes": 5,
            "name": "circle distribution test",
            "published": 3,
            "tags": [
                "utility",
                "tool"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 177
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 O, vec2 U){\n    vec2 u = U/iResolution.xy;\n    O = texture(iChannel0, u);   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define DoGoofyStuff\n\n\n\nconst float pi = 3.14159;\nconst float tau = pi*2.;\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\n\n//https://www.youtube.com/watch?v=p8u_k2LIZyo\nfloat fisqrt(float x)\n{\n    uint i;\n    float x2, y;\n    \n    x2 = x*.5;\n    y = x;\n    i = floatBitsToUint(x);              // evil floating point bit hack\n    i = uint(0x5f3759df) - ( i >> 1);    // wut\n    y = uintBitsToFloat(i);\n    \n\n    y = y*(1.5 - (x2 * y * y));           //newton iteration\n//  y = y*(1.5 - (x2 * y * y));           //newton iteration (optional)\n    \n\n    return y;\n}\n\n\nvec2 uvtc(vec2 u){ return (2.*u - iResolution.xy)/iResolution.y; }\n\n/*\n// Good : Rejection sampling\n#ifdef DoGoofyStuff\nvec2 circleSample(uvec3 x){\n    vec2 v = hash(x).xy;\n    return sin(v.x*0.5+iTime*5. + vec2(0,11))*sqrt(sqrt(v.y));\n}\n#else\nvec2 circleSample(uvec3 x){\n    if (x.x == 0u && x.y == 0u && x.z == 0u) x=uvec3(iTimeDelta*1000.); // Optional safety check... which doesn't work.\n    // Use safer version below pls\n    // not necessary if you make sure the input is never all zero otherwise the function can hang forever and WILL crash\n    vec2 v,z;\n    for(;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., length(z) > 1.;);\n    return z;\n}\n#endif\n//*/\n\n//* // Safer version with limited loop\n\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && dot(z,z) > 1.;);\n    return z;\n}\n\n//*/\n\n\n/*\n//Bad non uniform - Demo to show how easily you can evaluate the quality of hash functions\nvec2 circleSample(uvec3 x){\n    vec2 v = hash(x).xy;\n    return vec2(sin(v.x*tau),cos(v.x*tau))*v.y;\n}\n\n//*/\n\n\n/*\n// Also good, uniform analytical but not as fast as rejection sampling\nvec2 circleSample(uvec3 x){\n    vec2 v = hash(x).xy;\n    return vec2(sin(v.x*tau),cos(v.x*tau))*sqrt(v.y);\n    // (1./fisqrt(v.y)) is slower. I tried.\n}\n//*/\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = uvtc(U);\n    fragColor = texture(iChannel0, uv)*0.995;\n    for(int s = 2<<7;s-->0;)\n    {\n        vec2 p = circleSample(uvec3(iFrame+s, -iFrame+s, iFrame-s));\n        fragColor += smoothstep(2./r.y, 0., length(cuv-p))*(.4 + .6*exp(-iTime*.5));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Want to quickly copy a circle distribution function into your project? Just grab these two\n/*\n\n\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n} //hash by IQ https://www.shadertoy.com/view/XlXcW4\n\n\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && dot(z,z) > 1.;);\n    return z;\n}\n\n\n\n\n\n\n\n\nOld version which seems to be just a convoluted if statement with an uninitialized return ðŸ˜­\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(v=hash(x+uint(v*1e9)).xy*2.-1.;\n        dot(v,v)<1.;)\n    return v;\n}\n\nlemme try rewriting that...\n\nvec2 circleSample(uvec3 x){\n    vec2 v = hash(x).xy*2.-1.;\n    return dot(v,v)<1.?v:normalize(v);\n}\n\n\nThis is incredibly bad but at least not as bad as the other one, which just hides its\nhorrible issues by hiding them all in a single point at the centre...\n\nHistory: \n\n// Golf contest with beans_please\n\nOriginal:\nvec2 circleSample(uvec3 x){\n    vec2 v=vec2(1);\n    for (int i;dot(v,v)>1.;i++)\n        v = hash(x + uint(i)).xy*2.-1.;\n    return v;\n}\n\nbeans_please\nvec2 circleSample(uvec3 x){\n    uint i=1u;\n    while(i++>0u){\n        vec2 v=hash(x+i).xy*2.-1.;\n        if(dot(v,v)<1.)return v;\n    }\n}\n\n\nmine attempt 2\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(\n        v=hash(x+uint(v.x*1e9)).xy*2.-1.;\n        dot(v,v)<1.;\n    )\n    return v;\n}\n\n\nmine attempt 3: This one saves one character from\nthe 1e9 version. This limits the number of possible unique\niterations to just 9 instead of 1e9. This means there is a \nprobability of 0.0000009654 that a given input x will cause\nall 9 possible samples to fall outside the circle, which \nwould lead to the function running forever and crashing the\nprogram. That's why I chose not to use it.\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(\n        v=hash(x+uint(v.x*9.)).xy*2.-1.;\n        dot(v,v)<1.;\n    )\n    return v;\n}\n\n\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}