{
    "Shader": {
        "info": {
            "date": "1546984156",
            "description": "Cartoon thought bubble with help from iq.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsf3RX",
            "likes": 0,
            "name": "Thought Bubble",
            "published": 3,
            "tags": [
                "cartoon"
            ],
            "usePreview": 0,
            "username": "kubiak",
            "viewed": 736
        },
        "renderpass": [
            {
                "code": "float mainBubbleSize = 70.0;\nfloat bubbleOutline = 5.0;\nfloat curlHeight = 9.0;\nfloat curlFrequency = 10.0;\nfloat curlNoisePower = 25.0;\n\nvec2 leadBubble = vec2(120.0, 20.0);\nfloat startBabyBubbleSize = 7.0;\nfloat babyBubbleWidth = 2.0;\n\nconst int babyBubbles = 4;\n\nfloat horizontalStretch = 0.6;\nfloat swimPower = 40.0;\nfloat babySwimPower = 10.0;\n\n// Uses Inigo Quilez Simpex Noise\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat n_noise(in vec2 p)\n{\n    return 0.5 + 0.5 * noise(p);\n}\n\n\n// https://www.shadertoy.com/view/XsfGzn\nvec4 videoColor(vec2 center, vec2 coord, float size) {\n    vec4 bg = vec4(1.0, 1.0, 1.0, 1.0);\n    vec2 q = (coord - center) / size;\n    q.x += 0.5;\n    q.y += 0.5;\n    \n    if(q.x <= 0.0)\n        return bg;\n    if(q.x >= 1.0)\n        return bg;\n    if(q.y <= 0.0)\n        return bg;\n    if(q.y >= 1.0)\n        return bg;\n    \n\tvec3 fg = texture( iChannel0, q ).xyz;\n\t\n    \n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n    \n    float uvDist = distance(vec2(0.5, 0.5), q);\n    uvDist = pow(uvDist, 1.0/1.6) / 0.7071;\n    \n    float dg = fg.g; \n    fg.g = min( fg.g, maxrb*0.8 ); \n    fg += dg - fg.g;\n    fg = mix(fg, bg.xyz, uvDist);\n    \n    \n\n    return vec4( mix(fg, bg.xyz, k), uvDist );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float outsideBubble= mainBubbleSize + bubbleOutline;\n    vec2 center = vec2(320, 190);\n    float bubbleSwimX = noise(vec2(iTime * 0.1, 0.0)) * swimPower;\n    float bubbleSwimY = noise(vec2(iTime * 0.06, 0.0)) * swimPower;\n    center.x += bubbleSwimX;\n    center.y += bubbleSwimY;\n    \n    \n    vec2 pt = fragCoord - center;\n    pt.x *= horizontalStretch;\n    \n    float angle = atan(pt.y / pt.x);\n    float d = length(pt);\n    \n    d -= abs(cos(angle * curlFrequency)) * curlHeight;\n    d -= n_noise(fragCoord * 0.01) * curlNoisePower;\n    \n    \n    vec4 c = vec4(1.0, 1.0, 1.0, 1.0);\n    \n\n    if(d < mainBubbleSize) {        \n        c = videoColor(center, fragCoord, mainBubbleSize * 2.0);\n    }\n    else if(d < outsideBubble) {\n        c = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else {\n        for(int i = 0; i < babyBubbles; i++) {\n            float fi = float(i);\n            vec2 babyBubble = leadBubble;\n     \t\tfloat babySwimX = noise(vec2(iTime * 0.1 * fi, 0.0)) * babySwimPower;\n    \t\tfloat babySwimY = noise(vec2(iTime * 0.06 * fi, 0.0)) * babySwimPower;           \n            babyBubble.x += babySwimX;\n            babyBubble.y += babySwimY;\n            babyBubble.x += fi * 35.0;\n            babyBubble.y += pow(fi * 2.5, 2.0);\n            \n            float babyBubbleSize = startBabyBubbleSize * (fi*0.4 + 1.0);\n            pt = fragCoord - babyBubble;\n            pt.x *= horizontalStretch;\n            d = length(pt);\n            if(d > babyBubbleSize && d < babyBubbleSize + babyBubbleWidth) {\n                c = vec4(0.0, 0.0, 0.0, 1.0);\n            }\n        }\n    }\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}