{
    "Shader": {
        "info": {
            "date": "1634083730",
            "description": "Testing how to determine tangents to a line segment.",
            "flags": 0,
            "hasliked": 0,
            "id": "fddSWf",
            "likes": 1,
            "name": "Testing line segment tangents",
            "published": 3,
            "tags": [
                "raymarching",
                "line",
                "tangents"
            ],
            "usePreview": 0,
            "username": "liamegan",
            "viewed": 231
        },
        "renderpass": [
            {
                "code": " \n#define PI 3.14159265359\n#define TAU 3.14159265359*2.\n\nconst vec3 a = vec3(1.4, .9, 1.);\nconst vec3 b = vec3(-.3, -.3, .2);\n\nvec2 mouse;\n\n/* Raymarching constants */\n/* --------------------- */\nconst float MAX_TRACE_DISTANCE = 5.;             // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;       // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 64;               // max number of trace steps\nconst float STEP_MULTIPLIER = 1.;                 // the step mutliplier - ie, how much further to progress on each step\n\n  \n/* Structures */\n/* ---------- */\nstruct Camera {\n    vec3 ro;\n    vec3 rd;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    float FOV;\n};\nstruct Surface {\n    float len;\n    vec3 position;\n    vec3 colour;\n    float id;\n    float steps;\n    float AO;\n};\nstruct Model {\n    float dist;\n    vec3 colour;\n    float id;\n};\n\nvec2 getScreenSpace(vec2 from) {\n    vec2 uv = (from - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    return uv;\n}\n\nmat3 makeRotationDir(vec3 direction) {\n    vec3 up = vec3(0,1,0);\n    vec3 xaxis = cross(up, direction);\n    normalize(xaxis);\n\n    vec3 yaxis = cross(direction, xaxis);\n    normalize(yaxis);\n    \n    return mat3(\n      xaxis.x,\n      yaxis.x,\n      direction.x,\n      \n      xaxis.y,\n      yaxis.y,\n      direction.y,\n      \n      xaxis.z,\n      yaxis.z,\n      direction.z\n    );\n}\n\n//--------------------------------\n// Modelling\n//--------------------------------\n// Line segment code curtesy of IQ\nfloat sdfLine(vec3 p, vec3 a, vec3 b) {\n    float h = min(1.,\n                 max(0., \n                    dot(p-a, b-a) /\n                    dot(b-a, b-a)));\n    return length(p-a-(b-a)*h);\n}\n// Ugly modelling code, but it gets the point across\nModel model(vec3 p) {\n    \n    vec3 colour = vec3(1,0,0);\n    float d = length(p-a) - .03;\n    d = min(d, length(p-b) - .03);\n    float oldd = d;\n    d = min(d, sdfLine(p, a, b) - .01);\n    if(d < oldd) colour = vec3(0,.6,.8);\n    \n    float ds = clamp(mouse.y+.5, 0., 1.);\n    vec3 diff = a-b;\n    vec3 norm = normalize(diff);\n    vec3 ps = b + diff * ds;\n    oldd = d;\n    d = min(d, length(p-ps) - .05);\n    if(d < oldd) colour = vec3(0,1.,.4);\n    \n    mat3 rot = makeRotationDir(norm);\n    \n    oldd = d;\n    const float n = 10.;\n    for(float i = 0.; i < n; i++) {\n      float a = TAU / n * i;\n      vec3 op = normalize(vec3(cos(a), sin(a),0)) * rot;\n      d = min(d, length(p-ps+op * .2) - .02);\n      if(d < oldd) colour = vec3(1,1.,0);\n    }\n    \n    return Model(d, colour, 1.);\n}\nModel map( vec3 p ){\n    return model(p);\n}\n\nSurface calcIntersection( in Camera cam ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float rayDepth = 0.0;\n    float hitDepth = -1.0;\n    float id = -1.;\n    float steps = 0.;\n    float ao = 0.;\n    vec3 position;\n    vec3 colour;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ) {\n      if( abs(h) < INTERSECTION_PRECISION || rayDepth > MAX_TRACE_DISTANCE ) break;\n      position = cam.ro+cam.rd*rayDepth;\n      Model m = map( position );\n      h = m.dist;\n      rayDepth += h * STEP_MULTIPLIER;\n      id = m.id;\n      steps += 1.;\n      ao += max(h, 0.);\n      colour = m.colour;\n    }\n\n    if( rayDepth < MAX_TRACE_DISTANCE ) hitDepth = rayDepth;\n    if( rayDepth >= MAX_TRACE_DISTANCE ) id = -1.0;\n\n    return Surface( hitDepth, position, colour, id, steps, ao );\n}\nCamera getCamera(in vec2 uv, in vec3 pos, in vec3 target) {\n    vec3 forward = normalize(target - pos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = normalize(cross(forward, right));\n    \n    float FOV = .6;\n    \n    return Camera(\n      pos,\n      normalize(forward + FOV * uv.x * right + FOV * uv.y * up),\n      forward,\n      right,\n      up,\n      FOV\n    );\n}\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n      map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n      map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n      map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = getScreenSpace(gl_FragCoord.xy);\n    \n    mouse = getScreenSpace(iMouse.xy);\n    \n    vec3 diff = a-b;\n    vec3 norm = normalize(diff);\n    \n    vec3 ro = vec3(0,0,-1.8);\n    vec3 la = vec3(.25, .1, 0);\n    \n    // ro = b - norm * 1.;\n    // la = b;\n    \n    Camera cam = getCamera(uv, ro, la);\n    \n    Surface surface = calcIntersection(cam);\n    fragColor = vec4((calcNormal(surface.position)+.5) * step(1., surface.id), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}