{
    "Shader": {
        "info": {
            "date": "1696547663",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nNote* I'm so ready to do something new - just two more months left - finish what you start and learn something along the way!",
            "flags": 0,
            "hasliked": 0,
            "id": "ctdSDX",
            "likes": 17,
            "name": "Year of Truchets #055",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "cylinder",
                "uvmap"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #055\n    10/05/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n    \n*/\n\n\n#define ZERO (min(iFrame,0))\n#define AA 2\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define P9          1.57078\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-5\n#define MAX_DIST    50.\n\n// globals\nvec3 hit=vec3(0),hitpoint=vec3(0);\nvec4 FC=vec4(vec3(.05),0);\n\nmat2 turn,spin;\nfloat glow,px,stime,gid=0.,sid=0.;\n\n// standard bag of tricks\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n\n//@iq cylinder & hsv2rgb\nfloat cylinder(vec3 p,float h,float r){vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);return min(max(d.x,d.y),0.) + length(max(d,0.));}\nvec3 hsv2rgb(in vec3 c){vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);return c.z * mix(vec3(1),rgb,c.y);}\n\nfloat tile(vec3 hp, float type){\n    //@Fabrice - based off https://www.shadertoy.com/view/sdtGRn\n    vec2 uv   = vec2(atan(hp.z,hp.x)/PI2,hp.y);\n \n    vec2 scale = vec2(26.,1);\n    float px = fwidth(uv.x); \n\n    vec2 id = floor(uv*scale);\n    vec2 q = fract(uv*scale)-.5;\n    float hs = hash21(id);\n\n    float m = floor(mod(id.y,3.)+1.);\n    float n = floor(mod(id.x,5.)+1.);\n    \n    float ck = mod(id.x+id.y,m)*2.-1.;\n    float rk = mod(id.x+id.y,n)*2.-1.;\n    \n    float wd = .075;\n    \n    if(rk>.5) q *= rot(1.5707);\n\n    vec2 p = length(q-.5)<length(q+.5)? q-.5 : q+.5;\n\n    // main pattern\n    float d = abs(length(p)-.5)-wd;\n\n    if (ck>.85) d = min(length(q.x)-wd,length(q.y)-wd);\n    hs = fract(hs*415.372);\n \n    // accents\n    float b = length(abs(q)-.5)-.325;\n    d=min(d,b);\n \n    return d;\n}\n\nvec2 map(vec3 p, float sg) {\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p;\n\n    gid=1.;\n    q.zy*=spin;\n    q.zx*=turn;\n    float d1 = cylinder(q,4.5,2.1);\n    float dx = cylinder(q,3.5,2.2);\n    float d2=max(d1,-dx);\n    \n    float t1 = tile(q,1.);\n    \n    d2=max(d2,-t1);\n    \n    if(d2<res.x) {\n        res=vec2(d2,d1<d2?3.:1.);\n        hit=q;\n    }\n    \n\n    float d3 = cylinder(q,.1,3.55)-.2;\n    if(sg==1.) { glow += .0025/(.001+d3*d3);}\n    if(d3<res.x) {\n        res=vec2(d3,4.);\n        hit=q;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<100;i++){\n        vec2 ray = map(ro + rd * d,1.);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd);\n    float m =ray.y; d=ray.x;\n    \n    hitpoint=hit;\n    sid=gid;\n    float aph = 0.;\n    if(d<MAX_DIST)\n    {\n        aph=1.;\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        // light\n        vec3 lpos =vec3(-25.,15.,10.);\n        vec3 l = normalize(lpos-p);\n        // difused\n        float diff = clamp(dot(n,l),.09,.99);\n\n        // color\n        vec3 h = vec3(.0);\n        vec3 hp = hitpoint;\n        \n        if(m==1.) {\n            float d = tile(hp,1.);\n            d=smoothstep(px,-px,abs(abs(d-.16)-.0725)-.025);\n            h = mix(vec3(.45),vec3(.85),d);\n            ref = h*.1;\n        }\n        if(m==2.) {\n            float d = tile(hp*.5,2.);\n            d=smoothstep(px,-px,abs(abs(d)-.05)-.025);\n            vec3 clr = hsv2rgb(vec3((hp.x-hp.z)*.1,1.,.5));\n            h = mix(vec3(.01),clr,d);\n            ref = vec3(d*.9);\n        }\n        if(m==3.) {\n            h = hsv2rgb(vec3((p.y*.65+T*.25+sid)*.2,.9,.4));\n            ref = h*.5;\n        }\n        if(m==4.) {h = vec3(1);ref=vec3(.5);}\n  \n        C = diff*h;\n        ref=h;\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    if(last>0.) C = mix(FC.rgb,C,exp(-.0008*d*d*d));\n    return vec4(C,aph);\n}\n\nvec3 renderALL( in vec2 uv, in vec2 F )\n{   \n\n    // standard setup uv/ro/rd\n    //vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,8.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse\n    float x = M.xy==vec2(0) || M.z <1. ? 0. :  (M.y/R.y*1.-.5)*PI;\n    float y = M.xy==vec2(0) || M.z <1. ? 0. : -(M.x/R.x*1.-.5)*PI;\n\n    mat2 rx = rot(x), ry = rot(y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(0), ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n  \n    // reflection loop (@BigWings)\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.&&pass.w>0.)a=1.;\n    }\n  \n    float mask = smoothstep(.1,.75,length(uv)-.45);\n    vec3 clr = mix(vec3(.5),vec3(.0),mask);\n    \n    uv += vec2(T*.25,0);\n    uv *= rot(.785);\n  \n    float f = clamp(mod(floor(uv*8.).x,2.)*1.-.5,0.,1.);\n    C = mix(mix(clr*.5,clr*.2,f),C,a);\n    C = mix(C,vec3(.89),clamp(glow*.5,0.,1.));\n\n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    spin = rot(.1*sin(T*.5));\n    turn = rot(T*.075);\n    px  = 10./R.x;\n    stime=T*.1;\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n        glow=0.;\n        vec3 color = renderALL(uv,F);\n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        color = pow( color, vec3(0.4545) );\n\n        C += color;\n       \n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}