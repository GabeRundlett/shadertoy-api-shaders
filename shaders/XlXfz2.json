{
    "Shader": {
        "info": {
            "date": "1512447985",
            "description": "A smoothly anti aliased yin yang without super sampling\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XlXfz2",
            "likes": 3,
            "name": "Smooth Yin Yang",
            "published": 3,
            "tags": [
                "antialias",
                "yang",
                "yin"
            ],
            "usePreview": 0,
            "username": "KilledByAPixel",
            "viewed": 639
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////\n// Smooth Yin Yang - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat Blur = 8.0;\nfloat DotSize = 0.3;\nfloat OutlineThickness = 0.03;\n\nfloat YinYang( float co, vec2 p, float scale, float blur, float outline, float dotSize )\n{\n   \tfloat b = blur*scale/min(iResolution.y,iResolution.x);\n    float d = dotSize;\n    float o = outline;\n    float c;\n    \n    float r = length(p);\n    float r1 = length(2.0*p + vec2(0, 1));\n    float r2 = length(2.0*p - vec2(0, 1));\n    \n    // curves\n    if (p.x < 0.0)\n\t\tc = mix(1.0, 0.0, smoothstep(1.0-b, 1.0+b, r1));\n    else\n\t\tc = mix(0.0, 1.0, smoothstep(1.0-b, 1.0+b, r2));\n    \n    // dots\n    c = mix(0.0, c, smoothstep(d-b, d+b, r1));\n    c = mix(1.0, c, smoothstep(d-b, d+b, r2));\n\n    // outline\n    c = mix(c, 0.0, smoothstep(1.0-b, 1.0, r));\n    c = mix(c, co, smoothstep(1.0+o, 1.0+o+b, r));\n\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zoom\n    float z =  mix(1.1, 5.0, pow(smoothstep(-1.0, 1.0, sin(20.0 + 0.5*iTime)), 2.0));\n\tvec2 p = z * (2.0*fragCoord-iResolution.xy)/min(iResolution.y, iResolution.x);\n   \n    // rotate\n    float theta = -0.2*iTime;\n\tfloat ct = cos(theta);\n\tfloat st = sin(theta);\n    p *= mat2(-st, ct, ct, st);\n    \n    // use mouse to pick center line\n    float centerLine = (iMouse.x > 0.0)? iMouse.x : iResolution.x/2.0;\n    \n    // yin yang (no blur on right side)\n   \tfloat c = 0.5;\n    if (fragCoord.x < centerLine)\n\t    c = YinYang(c, p, z, Blur, OutlineThickness, DotSize);\n    else\n\t    c = YinYang(c, p, z, 0.0, OutlineThickness + .005*pow(z, 0.9), DotSize);\n    \n    // center line\n    if (fragCoord.x > centerLine - 1.0 && fragCoord.x < centerLine + 1.0)\n        c = mix(c, 0.0, 0.5);\n    \n    fragColor = vec4(c);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}