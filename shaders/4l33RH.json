{
    "Shader": {
        "info": {
            "date": "1467831544",
            "description": "Shader inspired by iq's Hell https://www.shadertoy.com/view/MdfGRX.  This is my first attempt at playing around with a volumetric shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "4l33RH",
            "likes": 62,
            "name": "Purple Vortex",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "noise",
                "clouds",
                "volumetric",
                "purple"
            ],
            "usePreview": 1,
            "username": "FTL",
            "viewed": 3177
        },
        "renderpass": [
            {
                "code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Shader inspired by iq's Hell https://www.shadertoy.com/view/MdfGRX\n// Noise functions by iq: https://www.shadertoy.com/view/4sfGzS\n#define USE_PROCEDURAL \n// Comment out the above line to use a faster LUT for noise and dithering\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat dither(in vec2 pixel)\n{\n   return .05*noise( vec3(1000.*pixel.xy/iChannelResolution[0].x,0.) ); \n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat dither(in vec2 pixel)\n{\n    return 0.05*texture( iChannel0, pixel.xy/iChannelResolution[0].x ).x;\n}\n#endif\n\n// Cloud noise by iq: https://www.shadertoy.com/view/XslGRr\n// takes a input position + and offset vector and returns a density amount\n// derived by summing multiple layers of noise at varying strengths and scales\nfloat cloudNoise(in vec3 p, in vec3 dir)\n{\n\tvec3 q = p + dir; \n    float f;\n\tf  = 0.50000*noise( q ); q = q*2.02 + dir;\n    f += 0.25000*noise( q ); q = q*2.03 + dir;\n    f += 0.12500*noise( q ); q = q*2.01 + dir;\n    f += 0.06250*noise( q ); q = q*2.02 + dir;\n    f += 0.03125*noise( q );\n    return f;\n}\n\n\nvec3 invertSpace(in vec3 p,float s)\n{\n   \treturn s*p/dot(p,p); \n}\n\n//Twist function from  https://iquilezles.org/articles/distfunctions\nvec3 twist(in vec3 p,float twistAmount)\n{\n   \tfloat t = p.y*twistAmount;\n    float c = cos(t);\n    float s = sin(t);\n    mat2  m = mat2(c,-s,s,c);\n    p = vec3(m*p.xz,p.y);\n    return p.xzy; \n}\n    \n\n\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 pixel )\n{\n\tvec4 sum = vec4( 0.0 );\n\tfloat t=dither(pixel);\n\n\tfor( int i=0; i<200; i++ )\n\t{\n\t\tif( sum.a > 0.99 ) break;\n\t\t\n\t\tvec3 p = ro + t*rd;\n\t\tfloat height = p.y;\n\t\tfloat den = -0.2 - p.y; \n\n\t\tp = invertSpace(p,6.0);\n\t\tp = twist(p,3.0);\n  \n\t\tfloat f = cloudNoise(p,-vec3(0.0,0.5,.25)*iTime);\n\t\tfloat d = clamp( den + 4.0*f, 0.0, 1.0 );\n        vec4 col=vec4(d);\n\t\tcol.xyz *= mix( 4.1*vec3(.750,0.15,0.75), vec3(0.32,.2,.52), clamp( height-.5, 0.0, 1.0 ) ); // pink to purple coloring on Y axis\n\t\t\n\t\tcol.a *= 0.6;\n\t\tcol.rgb *= d;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += 0.025;\n\t}\n\n\treturn clamp( sum.xyz, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n  \n\t\n    // camera\n\tvec3 ro = 4.0*normalize(vec3(cos(3.0*mo.x), 1.4 - 1.0*(mo.y-.1), sin(3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n\t\n\t\n\t// build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n    // raymarch\t\n\tvec3 col = raymarch( ro, rd, fragCoord );\n\t\n\t// contrast and vignetting\t\n\tcol = col*0.5 + 0.5*col*col*(3.0-2.0*col);\n\tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}