{
    "Shader": {
        "info": {
            "date": "1725287164",
            "description": "A rounded multi-tile square grid Truchet pattern,.",
            "flags": 0,
            "hasliked": 0,
            "id": "4f2fWw",
            "likes": 30,
            "name": "Multi-tile Rounded Truchet",
            "published": 3,
            "tags": [
                "grid",
                "template"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 210
        },
        "renderpass": [
            {
                "code": "/*\n\n    Multi-tile Rounded Truchet\n    --------------------------\n    \n    This is a very simple variation on the standard one-tile Truchet\n    patterns. I wouldn't say this particular arrangement is common, but \n    I've seen it around in various places. I haven't seen a square grid \n    based one on Shadertoy, but it wouldn't surprise me if there was one \n    hidden on here somewhere. I've posted an extruded ocatagon-square \n    version before, so I'll link to that below.\n    \n    I'd say the most common Truchet tiling for graphics programmers would\n    be the rotated double arcs, since they require the least amount of\n    work. The blobby equivalent -- where you cut out holes in opposite \n    corners and invert in a checkered fashion -- are pretty common also.\n    \n    A lot of people tend to stop there, but with very little extra work,\n    you can add some extra tiles to create more interesting patterns. This\n    particular one consists of a mixture of arcs, dots, and straight\n    edges. All tiles are created with basic CSG operations, and are pretty \n    easy to make out on an individual basis by looking at the square cells. \n    The individual tile construction details are below, but I doubt anyone \n    will need them.\n    \n    Anyway, I have a hexagon, and even a pentagon version that I'll clean\n    up and post at a later date.\n \n \n \n    // Other examples.\n    \n    // A basic extruded square grid-based blobby Truchet pattern.\n    Extruded Truchet Pattern - Shane\n    https://www.shadertoy.com/view/ttVBzd\n    \n    // An extruded octagon diamond grid-based blobby Truchet pattern.\n    Extruded Octagon Diamond Truchet - Shane\n    https://www.shadertoy.com/view/3tGBWV\n\n*/\n\n\n// We can already see the cell walls, but this will make them a little \n// more apparent.\n//#define SHOW_GRID\n\n// Scene color - Red: 0, Green: 1, Blue: 2.\n#define COLOR 0\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831859) )*43758.5453); \n}\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Signed distance to a line passing through \"a\" and \"b\".\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n/*\n// IQ's box distance field formula.\nfloat sBox(in vec2 p, in vec2 b){\n \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n*/\n\n\nfloat distField(vec2 p){   \n     \n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    \n    // A couple of random cell numbers.\n    float rnd = hash21(ip + .13), rnd2 = hash21(ip + .17);\n      \n    \n    // Random rotation.\n    p = rot2(floor(rnd*128.)*6.2831/4.)*p;\n\n    \n \n    // Overall distance field value.   \n    float d = 1e5;\n    \n    \n    // Square vertices and midpoints... There'd be faster ways to do this, but\n    // it can be handy having them written out.\n    //\n    // Clockwise from the bottom left vertex.\n    mat4x2 vID = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5));\n    // Clockwise from the left mid-point.\n    mat4x2 eID = mat4x2(vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n\n    // Vertex and mid-point distances.\n    vec4 vert, mid;\n    //    \n    for(int i = 0; i<4; i++){  \n    \n        vert[i] = length(p - vID[i]);\n        mid[i] = length(p - eID[i]);    \n    }\n    \n    // Constructing the tiles. There are six here, but you could\n    // use fewer, or conjure up some extra ones.\n    if(rnd2<1./6.){\n    \n        // Two arcs.\n        d = min(vert[0], vert[2]) - 1./2.;\n        \n        d = abs(d); \n        \n    }\n    else if(rnd2<2./6.){\n    \n        // One arc, two mid points.\n        float arc = vert[0];\n        arc = abs(arc - 1./2.);\n        \n        float endPnt = min(mid[1], mid[2]);\n        \n        d = min(arc, endPnt);\n    \n    }\n    else if(rnd2<3./6.){\n    \n        // Four dots.\n        float endPnt = min(min(mid[0], mid[1]), min(mid[2], mid[3]));\n        \n        d = endPnt;\n        \n    }\n    else if(rnd2<4./6.){\n    \n        // Dot, line, two holes.\n        float endPnt = min(mid[1], mid[3]);\n        \n        float ln = distLine(p, eID[0], eID[2]);\n        \n        d = min(ln, endPnt);\n        \n    }\n    else if(rnd2<5./6.){\n    \n        // Cut the cell in half.\n        float hlfLn = distLineS(p, eID[0], eID[2]);\n        \n        // Chop out two holes.\n        hlfLn = max(hlfLn, -(min(vert[0], vert[3]) - 1./2.));\n        \n        // Add an end point.\n        float endPnt = mid[1];\n        \n        d = min(hlfLn, endPnt);    \n    \n    }\n    else {\n    \n        // Four holes, to make the rounded cross tile.\n        float holes = min(min(vert[0], vert[1]), min(vert[2], vert[3])) - 1./2.;\n        \n        d = -holes;    \n    }\n    \n    // Thicken the lines up.\n    float lw = 1./6.;\n    // Variable width... A bit much here.\n    //lw += 1./32.*dot(sin(oP*4. - cos(oP.yx*8. + iTime*2.)), vec2(.5));\n    d -= lw;\n\n    \n    // Debug. Including this line will give it a bit of a tech look.\n    //d = max(d, sBox(p, vec2(.475)));\n    \n    \n    // Return the distance.\n    return d;\n}\n\n// The square cell grid.\nfloat gridField(vec2 p){\n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // The outer grid lines.\n    p = abs(p);\n    return abs(max(p.x, p.y) - .5) - .01;\n  \n}\n\n// A very simple random line routine. It was made up on the\n// spot, so there would certainly be better ways to do it.\nfloat randLines(vec2 p){\n    \n    // Scaling.\n    float sc = 12.;\n    p *= sc;\n    \n    // Offset the rows for a more random look.\n    p.x += hash21(vec2(floor(p.y), 7) + .2)*sc;\n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Distance field value and random cell number.\n    float d;\n    float rnd = hash21(ip + .34);\n    \n    // Randomly, but not allowing for single dots.\n    if(rnd<.333 && mod(ip.x, 2.)==0.){\n    \n       // Dots on either side of the cell wall mid-points, to create a space.\n       d = min(length(p - vec2(-.5, 0)), length(p - vec2(.5, 0)));\n        \n    }\n    else {\n        // Otherwise, just render a line that extends beyond the cell wall\n        // mid-points.\n        d =  distLine(p, vec2(-1, 0), vec2(1, 0));\n    }\n    \n    // Applying some width.\n    d -= 1./6.;\n    \n    // Scaling down the distance value to match scaling up\n    // the coordinates.\n    return d/sc;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    float gSc = 8.;\n    //rot2(3.14159/4.)*\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = rot2(3.14159/12.)*uv*gSc - vec2(-.5, -.25)*iTime;\n    \n    // Two samples of the Truchet value distance field. One is for \n    // highlights and shadowing.\n    float dSh = distField(p - vec2(-.15, -.1));\n    float d = distField(p);\n   \n    // Smoothing value.\n    float sf = 1./iResolution.y*gSc;\n    \n    // Background color.\n    vec3 bg = vec3(1, .8, .6);\n    // Overall color, set to the background.\n    vec3 col = bg;\n\n    // Adding a random line pattern to the background.\n    float pat = randLines(rot2(3.14159/6.)*p);\n    col = mix(col*1.25, col*.75, (1. - smoothstep(0., sf, max(pat, -(d - .082)))));\n\n   \n    // Appling a part of the grid wall boundaries to the background pattern.\n    float grid = gridField(p);\n    col = mix(col, col*.05, (1. - smoothstep(0., sf, max(grid, -(d - .2)))));\n    \n    // Adding in an outer line.\n    col = mix(col, col*.05, (1. - smoothstep(0., sf, abs(d - .08) - .02)));\n    // Applying the shadow layer.\n    col = mix(col, col*.35, (1. - smoothstep(0., sf*8.*iResolution.y/450., dSh)));\n    // The distance field itself.\n    col = mix(col, col*.05, (1. - smoothstep(0., sf, d)));\n    \n    // Layer color.\n    vec3 sCol = bg*(vec3(1, .5, .1) + .1);\n    // Patchy color... I wasn't feeling it. :)\n    //sCol = bg*(.5 + .5*cos(6.2831*hash21(floor(p*3.) + .02)/6. + vec3(0, 1, 2)) + .1);\n   \n    // Distance field-based highlighting.\n    sCol = mix(sCol, sCol.yxz, clamp(-d, 0., 1.));\n    // Adding the line pattern to the layer color.\n    sCol = mix(sCol, sCol*.75, (1. - smoothstep(0., sf, pat)));\n    \n    // You can already see the grid lines, but this makes the cell boundaries\n    // more apparent.\n    #ifdef SHOW_GRID\n    sCol = mix(sCol, sCol*.05, (1. - smoothstep(0., sf, grid - .005)));\n    #endif\n    \n    // A cute highlighting trick.\n    // Darker colors.\n    col = mix(col, sCol*(.5 + bg*2.), (1. - smoothstep(0., sf, d + .07)));\n    // Lighter highlighted colors.\n    col = mix(col, sCol, (1. - smoothstep(0., sf*3., max(d, dSh - .04) + .07)));\n\n    // Adding a gradient can jazz up a bland 2D scene. I'm not sure what the \n    // psychology is behind it... I guess humans like color changes, or something. :)\n    float uvx = fragCoord.x/iResolution.x*800./450. - .5;\n    col = mix(col.xzy, col, clamp(uv.y + uvx/2. + .5, 0., 1.)*.5 + .5); \n    \n    #if COLOR == 1\n    col = col.yxz*2./(1.5 + col.yxz);\n    #elif COLOR == 2\n    col = col.zyx;\n    #endif\n    \n    // Rough gamma correction and screen presentation.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}