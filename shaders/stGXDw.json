{
    "Shader": {
        "info": {
            "date": "1641193816",
            "description": "Here is a rotating hexagonal pyramid consisting of capsules and triangles. \n",
            "flags": 0,
            "hasliked": 0,
            "id": "stGXDw",
            "likes": 2,
            "name": "RM Rubin",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "hexagonal",
                "pyramid"
            ],
            "usePreview": 0,
            "username": "ersteller",
            "viewed": 239
        },
        "renderpass": [
            {
                "code": "\n// https://iquilezles.org/articles/distfunctions\n// and \n// https://www.shadertoy.com/view/wdf3zl\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n\n#define MAX_STEPS 100 \n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a; \n    vec3 ap = p-a;   // vec from a to p\n    float t = dot(ab,ap) /dot(ab,ab);   \n    t = clamp (t, 0.,1.);\n    vec3 c = a + t*ab;\n    return length (p-c)-r;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdFace (vec3 p, vec3 a, vec3 b, vec3 c)\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec3 rotateY(vec3 center, vec3 p, float rot ){\n    vec3 cp = p - center;\n    return vec3(\n            cp.x*cos(rot)-cp.z*sin(rot),\n            cp.y*1.,\n            cp.x*sin(rot)+cp.z*cos(rot)\n        ) + center;\n}\n\nvec4 minD(vec4 rgbdA, vec4 rgbdB){\n    return rgbdA.w < rgbdB.w ? rgbdA : rgbdB;\n}\n\nvec4 GetDist (vec3 p){\n    \n    float d=MAX_DIST;\n    vec4 colD= vec4(0,0,0,d);\n    \n    float thic =0.06;                  // capsul thicknes\n    float rot = iTime*0.5;             // rotation offset\n    float scale = 1.5;\n    vec3 tr = vec3(0,1, 6.);\n     \n    // scale and translate\n    vec3 A = vec3(1,0,0)*scale+tr;       \n    vec3 B = vec3(0,-1.2,0)*scale+tr;    // bottom point\n    vec3 C = vec3(0,1.2,0)*scale+tr;     // top point\n    vec3 D = vec3(0.5,0,0.866)*scale+tr;\n    \n    for (float i = rot; i <= 2.*3.1415+rot; i+=3.1415/3.){\n        // faces \n        float ADC = sdFace(p, rotateY(tr,A,i),rotateY(tr,D,i),C);;\n        colD = minD(colD, vec4(1,0.7,0.7,ADC));\n        float ADB = sdFace(p, rotateY(tr,A,i),rotateY(tr,D,i),B);;\n        colD = minD(colD, vec4(0.7,0.7,1,ADB));\n        \n        float AB = sdCapsule(p, rotateY(tr,A,i),rotateY(tr,B,i), thic);\n        colD = minD(colD,vec4(0.,0.9,0.7,AB));\n        float AC = sdCapsule(p, rotateY(tr,A,i),rotateY(tr,C,i), thic);\n        colD = minD(colD,vec4(0.,0.7,1,AC));\n        float AD = sdCapsule(p, rotateY(tr,A,i),rotateY(tr,D,i), thic);\n        colD = minD(colD,vec4(1,1,0.,AD));\n    }   \n    return colD;   \n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p).w;             // d is distance to next surface from p and < SURF_DIST on surfaces \n    if (d > SURF_DIST) return vec3(0);  // if we have not hit a surface dont bother searching normals in the sky\n    vec2 e = vec2(.01,0);\n    vec3 n = d - vec3(   \n        GetDist(p-e.xyy).w,   \n        GetDist(p-e.yxy).w,   \n        GetDist(p-e.yyx).w);\n    return normalize(n);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd){\n    float dO=0.;  \n    vec4 colD= vec4(0);;\n    \n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;  // move p to origin and then distance to origin in ray direction \n        colD  = GetDist(p);     // get new distance from the new point p to closest body\n        float dS = colD.w;\n        dO += dS;               // advance by the new distance\n        \n        if (dO > MAX_DIST){\n            dO = MAX_DIST;\n            break;\n        }        \n        if ( dS < SURF_DIST) {\n            break;\n        }\n    }\n    colD.w = dO;\n    return colD;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    vec3 cam = vec3(0,2,0);\n    vec3 ro = cam;\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.2, 1));\n \n    vec4 resRM = RayMarch(ro, rd);\n    float d = resRM.w;      // there are color components in the result\n      \n    if(d > 10.1 ) d= 20.;   // d = MAX_DIST;\n    d /= 4.;                // normalize 1 to 0\n    d = 2.-d;               // improve highlights\n    \n    // create a color \n    col = vec3(resRM.r*d, resRM.g*d, resRM.b*d);\n    \n    // background colorgradient\n    if (col.x <= 0.01 && col.y <= 0.01 && col.z <= 0.01 ) col=vec3(0.25,uv.y*0.4+.3,uv.y*0.8+.3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}