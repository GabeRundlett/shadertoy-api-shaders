{
    "Shader": {
        "info": {
            "date": "1715819415",
            "description": "Fade In/Out code for sound. Set curve to 1.0 for linear fade. Check desmos link for interactive graph. https://www.desmos.com/calculator/y5emgnffeg",
            "flags": 8,
            "hasliked": 0,
            "id": "lcGSDy",
            "likes": 2,
            "name": "Sound: Fade Types",
            "published": 3,
            "tags": [
                "sound",
                "fade",
                "linear",
                "quadratic",
                "root",
                "scurve"
            ],
            "usePreview": 0,
            "username": "taylormatson",
            "viewed": 120
        },
        "renderpass": [
            {
                "code": "// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// https://creativecommons.org/licenses/by-nc/4.0/\n\n// https://www.desmos.com/calculator/y5emgnffeg\n\nvec2 mainSound( int samp, float time )\n{\n    \n    float i_length = 20.; // fade in length in seconds\n    \n    float t_FOST = 4. + i_length; // Fade out start time after i_length is over in seconds\n    \n    float o_length = 2.; // fade out length in seconds\n    \n    float c_curve = 4.; // Curve of fade | 0.1 to 100. | 1.0 for linear\n    \n    // Quad Fade\n    //float fadeAmp = linquaFadeInOut(\n    //samp,time,iSampleRate,i_length,t_FOST,o_length,c_curve);\n    \n    // S-Curve Fade\n    //float fadeAmp = scurvyFadeInOut(\n    //samp,time,iSampleRate,i_length,t_FOST,o_length);\n    \n    // Root Fade\n    float fadeAmp = linquaFadeInOut(\n    samp,time,iSampleRate,i_length,t_FOST,o_length,c_curve);\n                          \n    float oscillator = sin(6.2831*200.0*time);\n    \n    return vec2( fadeAmp*oscillator );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define PI 3.1415\n\n// This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// https://creativecommons.org/licenses/by-nc/4.0/\n\n// https://www.desmos.com/calculator/y5emgnffeg\n\n// variable that have _s on the tail end are conversions from float time to sample integer\n\n// Quadratic fade function. Linear when c_curve == 1.\nfloat linquaFadeInOut(int samp, float time, float iSampleRate,\n                      float i_length, float t_FOST, float o_length,\n                      float c_curve){\n\n    // Variable Conversions for sample number comparison\n    int i_length_s = int(iSampleRate * i_length);\n    \n    int t_FOST_s = int(iSampleRate * t_FOST);\n    \n    int o_length_s = int(iSampleRate * o_length);\n    \n    // Fade values from 0 to 1 and 1 to 0 over time accounting for\n    // fade lengths, fade out start time, and fade out length.\n        \n      float fadeInAmp  = 1. - pow( (1. - (1. / i_length) * time) , c_curve);\n    \n      float fadeOutAmp = 1. - pow( (time - t_FOST) / o_length , c_curve);\n      \n    //// Inverted Versions\n    //float fadeInAmp  = pow((( 1. / i_length ) * time), curve);\n    //float fadeOutAmp = pow((( -(time - t_FOST) / o_length ) + 1.), curve);\n    \n    // Logic for when to apply which amp\n    if (samp > (o_length_s + t_FOST_s) )\n    {\n        return 0.;\n        \n    } else if (samp > i_length_s && samp < t_FOST_s){\n        \n        return 1.;\n        \n    } else if (samp > t_FOST_s && samp < (t_FOST_s + o_length_s)){\n    \n        return fadeOutAmp;\n    \n    } else if (samp < i_length_s){\n        \n        return fadeInAmp;\n        \n    }\n\n}\n\n// S-Curve fade function\nfloat scurvyFadeInOut(int samp, float time, float iSampleRate,\n                      float i_length, float t_FOST, float o_length)\n                      {\n                      \n    // Variable Conversions for sample number comparison\n    int i_length_s = int(iSampleRate * i_length);\n    \n    int t_FOST_s = int(iSampleRate * t_FOST);\n    \n    int o_length_s = int(iSampleRate * o_length);\n    \n    // Fade values from 0 to 1 and 1 to 0 over time accounting for\n    // fade lengths, fade out start time, and fade out length.\n    \n    float fadeInAmp  = .5*sin(( PI*( 1. / i_length ) * time) - (PI/2.))+.5;\n    \n    float fadeOutAmp = .5*sin(( -PI*(time - t_FOST) / o_length ) + (PI/2.))+.5;\n    \n    // Logic for when to apply which amp\n    if (samp > (o_length_s + t_FOST_s) )\n    {\n        return 0.;\n        \n    } else if (samp > i_length_s && samp < t_FOST_s){\n        \n        return 1.;\n        \n    } else if (samp > t_FOST_s && samp < (t_FOST_s + o_length_s)){\n    \n        return fadeOutAmp;\n    \n    } else if (samp < i_length_s){\n        \n        return fadeInAmp;\n        \n    }\n\n}\n\n// C_Curve Root fade function. Linear when c_curve == 1.\nfloat rootFadeInOut(int samp, float time, float iSampleRate,\n                      float i_length, float t_FOST, float o_length,\n                      float c_curve){\n                      \n    // Variable Conversions for sample number comparison\n    int i_length_s = int(iSampleRate * i_length);\n    \n    int t_FOST_s = int(iSampleRate * t_FOST);\n    \n    int o_length_s = int(iSampleRate * o_length);\n    \n    // Fade values from 0 to 1 and 1 to 0 over time accounting for\n    // fade lengths, fade out start time, and fade out length.\n    \n    float fadeInAmp  = pow((1. / i_length) * time , (1./c_curve));\n    \n    float fadeOutAmp = pow((1. - (time-t_FOST) / o_length) , (1./c_curve));\n    \n    // Logic for when to apply which amp\n    // If sample num is more than the length of fades\n    if (samp > (o_length_s + t_FOST_s) )\n    {\n        return 0.;\n        \n    } else if (samp > i_length_s && samp < t_FOST_s){\n        \n        return 1.;\n        \n    } else if (samp > t_FOST_s && samp < (t_FOST_s + o_length_s)){\n    \n        return fadeOutAmp;\n    \n    } else if (samp < i_length_s){\n        \n        return fadeInAmp;\n        \n    }\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}