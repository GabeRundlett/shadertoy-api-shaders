{
    "Shader": {
        "info": {
            "date": "1509561760",
            "description": "\"Do you like sushi ?\"\nI love this guy.\n\nMouse enable.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ljyRc",
            "likes": 80,
            "name": "Graffiti night",
            "published": 3,
            "tags": [
                "reflection",
                "shadow",
                "light",
                "imageprocessing",
                "raytrace",
                "rain",
                "sushi"
            ],
            "usePreview": 0,
            "username": "ocb",
            "viewed": 5041
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: Graffiti night\n\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n\n#define SKY 0\n#define ROAD 1\n#define SIDE 2\n#define WALL 3\n#define SHOP 4\n#define DOOR 5\n#define SUSHI 6\n#define PYL1 7\n#define LIT1 8\n#define PYL2 9\n#define LIT2 10\n#define PYL3 11\n#define LIT3 12\n\n#define OUTSIDE true\n#define INSIDE false\n\nint hitObj= SKY;\n\nvec3 sideDim = vec3(258.,.6,160.);\nvec3 sideCtr = vec3(240.,0.,-150.);\nvec3 wallDim = vec3(250.,40.,150.);\nvec3 wallCtr = vec3(250.,40.,-149.);\nvec3 shopDim = vec3(5.,40.,50.);\nvec3 shopCtr = vec3(-5.,40.,-48.);\nvec3 doorDim = vec3(1.2,5.,5.);\nvec3 doorCtr = vec3(-3.,5.8,-3.);\nvec3 sushiCtr = vec3(-6.,17.,3.);\n\nvec3 tagCtr = vec3(18.,10.,.8);\n\nvec3 pylBox = vec3(.3,12.,.3);\nfloat pylDim = .2;\nfloat litDim = .7;\nvec3 pylCtr1 = vec3(12.,12.,9.);\nvec3 litCtr1 = vec3(12.,22.5,8.3);\n\nvec3 pylCtr2 = vec3(100.,12.,9.);\nvec3 litCtr2 = vec3(100.,22.5,8.3);\nvec3 pylCtr3 = vec3(-63.,12.,20.);\nvec3 litCtr3 = vec3(-63.7,22.5,20.);\n\nvec3 aDim = vec3(250.,40.,250.);\nvec3 aCtr = vec3(-320.,40.,-149.);\nvec3 asDim = vec3(258.,0.6,260.);\nvec3 asCtr = vec3(-320.,0.,-150.);\n\n//Hash functions\nfloat H1 (in float v) {return fract(sin(v) * 437585.);}\n\nfloat H2 (in vec2 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123 + time);\n}\n\n// damping funct used for drop impact\nfloat plic(float x, float d ){\n    x /= d;\n    return clamp(1. - x*x*(3.-2.*x),0.,1.);\n}\n\n// Primitives\nfloat sfcImpact(in float p, in float ray, in float h){\n    float t = (h-p)/ray;\n    if (t <= 0.001) t = INFINI;\n    return t;\n}\n\nvec4 boxImpact( in vec3 pos, in vec3 ray, in vec3 ctr, in vec3 dim, bool outside) \n{\n    vec3 m = 1.0/ray;\n    vec3 n = m*(ctr-pos);\n    vec3 k = abs(m)*dim;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tmax = max( max( t1.x, t1.y ), t1.z );\n\tfloat tmin = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tmax > tmin || tmin < 0.0) return vec4(vec3(0.),INFINI);\n\n    if(outside){\n        vec3 norm = -sign(ray)*step(vec3(tmax),t1);\n        return vec4(norm, tmax);\n    }\n    else{\n        vec3 norm = -sign(ray)*step(t2, vec3(tmin));\n        return vec4(norm, tmin);\n    }\n}\n\nvec3 cylinderImpact(in vec2 pos, in vec2 ray, in vec2 cylO, in float cylR){\n    float t = INFINI;\n    vec2 delta = pos - cylO;\n    \n    float a = dot(ray,ray);\n    float b = dot(delta, ray);\n    float c = dot(delta,delta) - cylR*cylR;\n    float d = b*b - a*c;\n    \n    if (d >= 0.){\n        float sd = sqrt(d);\n        t = (-b - sd)/a;\n        if (t < 0.001) t = INFINI;\n    }\n    \n    vec2 norm = pos + t*ray - cylO;\n\treturn vec3(norm,t);\n}\n\nvec4 hemisphereImpact(in vec3 pos, in vec3 ray, in vec3 sphO, in float sphR){\n    vec2 t = vec2(INFINI);\n    vec3 d = sphO - pos;\n    float b = dot(d, ray);\n    \n    if (b >= 0.){\t// check if object in frontside first (not behind screen)\n        float c = dot(d,d) - sphR*sphR;\n    \tfloat disc = b*b - c;\n    \tif (disc >= 0.){\n        \tfloat sqdisc = sqrt(disc);\n            t.x = b + sqdisc;\n            t.y = b - sqdisc;\n        \t\n            t += step(t,vec2(0.))*INFINI;\t\t// eliminate negative value\n            vec2 h = pos.y + t*ray.y;\n            \n        \tt += (1.-step(vec2(sphO.y), h))*INFINI;\t\t// eliminate if intersection is below sphO\n        }\n    }\n    float tt = min(t.x, t.y);\n    float s = 1. - 2.*step(t.x,t.y);\n\n    return vec4(s*normalize(pos + tt*ray - sphO), tt);\n}\n\n// GRAFFITI\nvec3 graffiti(in vec2 uv, in sampler2D chan, in vec2 lit, float dist){\n    vec3 col = vec3(0.);\n    vec3 texUV = texture(chan,uv).rgb;\n    vec2 dShad = lit*vec2(dist);\n    vec3 greenRef = texture(chan,vec2(.999,.999)).rgb;\n    \n    float gr = .7-texUV.g;\t\t// red patches\n    col.gb -= vec2(.4,.4)*smoothstep(.1,.4,gr);\n    \n    gr = texture(chan,uv - vec2(.003,.003)).r - texUV.r;\t//Black sketch\n    col -= smoothstep(.0,.5,gr);\n    gr = texture(chan,uv + vec2(.003,.003)).r - texUV.r;\n    col -= smoothstep(.0,.5,gr);\n    \n    float shad = float(any(bvec3(step(.25,abs(texture(chan,uv + dShad*(1.-float(any(bvec2(step(1.-dShad,uv)))))).rgb - greenRef)))));\n    float mask = float(any(bvec3(step(.25,abs(texUV - greenRef)))));\n    col -= shad*(1.-mask);\n    \n    return col;\n}\n\n// Raytrace function\nvec4 trace(in vec3 pos, in vec3 ray, bool shadow){\n    float t = INFINI;\n    vec3 norm = vec3(0.);\n    \n    // ROAD\n\tt = sfcImpact(pos.y, ray.y, 0.);\n    if(t<INFINI){\n        hitObj = ROAD;\n        norm = vec3(0.,1.,0.);\n    }\n    \n    // Far WALL\n    vec4 info = boxImpact(pos,ray, aCtr, aDim, OUTSIDE);\n    if(info.w < t){\n        hitObj = WALL;\n        t = info.w;\n        norm = info.xyz;\n    }\n    \n    // Far Sidewalk\n    info = boxImpact(pos,ray, asCtr, asDim, OUTSIDE);\n    if(info.w < t){\n        hitObj = SIDE;\n        t = info.w;\n        norm = info.xyz;\n    }\n    \n    // Pylon and light cover 1, 2, 3\n    if(!shadow){\n        if(boxImpact(pos,ray, pylCtr1, pylBox, OUTSIDE).w < INFINI){\n            vec3 cinfo = cylinderImpact(pos.xz, ray.xz, pylCtr1.xz, pylDim);\n            if(cinfo.z < t){\n                hitObj = PYL1;\n                t = cinfo.z;\n                norm = vec3(cinfo.x,0.,cinfo.y);\n            }\n        }\n\n        info = hemisphereImpact(pos, ray, litCtr1, litDim);\n        if(info.w < t){\n            hitObj = LIT1;\n            t = info.w;\n            norm = info.xyz;\n        }\n        \n        if(boxImpact(pos,ray, pylCtr2, pylBox, OUTSIDE).w < INFINI){\n            vec3 cinfo = cylinderImpact(pos.xz, ray.xz, pylCtr2.xz, pylDim);\n            if(cinfo.z < t){\n                hitObj = PYL2;\n                t = cinfo.z;\n                norm = vec3(cinfo.x,0.,cinfo.y);\n            }\n        }\n\n        info = hemisphereImpact(pos, ray, litCtr2, litDim);\n        if(info.w < t){\n            hitObj = LIT2;\n            t = info.w;\n            norm = info.xyz;\n        }\n        \n        if(boxImpact(pos,ray, pylCtr3, pylBox, OUTSIDE).w < INFINI){\n            vec3 cinfo = cylinderImpact(pos.xz, ray.xz, pylCtr3.xz, pylDim);\n            if(cinfo.z < t){\n                hitObj = PYL3;\n                t = cinfo.z;\n                norm = vec3(cinfo.x,0.,cinfo.y);\n            }\n        }\n\n        info = hemisphereImpact(pos, ray, litCtr3, litDim);\n        if(info.w < t){\n            hitObj = LIT3;\n            t = info.w;\n            norm = info.xyz;\n        }\n    }\n    \n    // Main Wall\n    info = boxImpact(pos,ray, wallCtr, wallDim, OUTSIDE);\n    if(info.w < t){\n        hitObj = WALL;\n        vec2 tp = pos.xy + info.w*ray.xy;\n        if( abs(fract(tp.x/12.)*12.-6.) < 5. && abs(fract(tp.y/30.)*30.-10.) < 5.){\n        \tvec4 info2 = boxImpact(pos,ray, vec3(floor(tp.xy/vec2(12.,30.))*vec2(12.,30.)+vec2(6.,10.),.8), vec3(5.0001,5.0001,.2), INSIDE);\n            t = info2.w;\n        \tnorm = info2.xyz;\n        }\n        else{\n            t = info.w;\n            norm = info.xyz;\n        }\n    }\n    \n    // Sushi shop volume\n    info = boxImpact(pos,ray, shopCtr, shopDim, OUTSIDE);\n    if(info.w < t){\n        vec2 tp = pos.xy + info.w*ray.xy;\n        if( all(bvec2(step(abs(tp - doorCtr.xy) , doorDim.xy))) ){\n            t = info.w;\n            norm = info.xyz;\n            hitObj = DOOR;\n        }\n        else{\n            t = info.w;\n            norm = info.xyz;\n            hitObj = SHOP;\n        }\n    }\n    \n    // main Sidewalk\n    info = boxImpact(pos,ray, sideCtr, sideDim, OUTSIDE);\n    if(info.w < t){\n        hitObj = SIDE;\n        t = info.w;\n        norm = info.xyz;\n    }\n    \n    return vec4(norm,t);\n}\n\n\n// Function drawing letters\nfloat S(in vec3 sp,in float y,in float z){\n    vec2 f = vec2(clamp(sp.y-y, -.5,.5) , 2.*(sp.z-z));\n    float s = .5*sin(TwoPI*f.x)-.5*f.x;\n    return max(0.,.2/abs(f.y-s) -.4)*step(abs(sp.y-y),.5);\n}\nfloat U(in vec3 sp,in float y,in float z){\n    vec2 f = vec2(clamp(sp.y-y+.5, 0.,1.) , 2.*(sp.z-z));\n    float u = .4*sqrt(sqrt(f.x));\n    return (max(0.,.14/abs(f.y-u) -.4) + max(0.,.14/abs(f.y+u) -.4))*step(abs(sp.y-y+.03),.5);\n}\nfloat H(in vec3 sp,in float y,in float z){\n    vec2 f = vec2(clamp(sp.y-y, -1.,1.) , sp.z-z);\n    float hc = max(0.,.08/abs(f.x) -.4)*step(abs(f.y),.2);\n    float u = .2*sqrt(abs(f.x-1.));\n   \tfloat hr = (max(0.,.06/abs(f.y-u) -.4) + max(0.,.06/abs(f.y+u) -.4))*step(abs(sp.y-y),.5);\n\treturn hc+hr;\n}\nfloat I(in vec3 sp,in float y,in float z){\n\tvec2 f = vec2(clamp(sp.y-y, -1.,1.) , sp.z-z);\n    float i = .2*sqrt(abs(f.x+.8));\n   \tfloat hr = max(0.,.06/abs(f.y-i+.2) -.4)*step(abs(sp.y-y),.5);\n\treturn hr;\n}\n\n// Lights Halo used for street light and sushi sign\nfloat bulbHalo(in vec3 lit,in vec3 pos, in vec3 p, in vec3 ray, in vec3 norm, float intensity, float size){\n    float d = dot(lit-pos,ray);\n    float e = dot(lit-p,norm);\n    if( d>0. && e>=0.) return min(1.,max(0.,intensity/(length(cross(lit-pos, ray)) + size) - .1));\t// Light halo\n\telse return 0.;\n}\n\n// Cam set functions\nvec3 getCamPos(in vec3 camTarget){\n    float \trau = 40.,\n    \t\talpha = iMouse.x/iResolution.x*1.1*PI+1.6,\n    \t\ttheta = iMouse.y/iResolution.y*1.+2.35;\n    \t\tif (iMouse.xy == vec2(0.)){\n                alpha = 2.95;\n                theta = 3.2;\n            }\n    \n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.;\n    vec3 ww = normalize( camTarget - pos );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    vec2 ratio = vec2(1.,iResolution.y/iResolution.x);\n    \n    vec3 color = vec3(0.);\n    vec3 lightColor = vec3(1.,.9,.7);\t// street light color\n    vec3 advColor = vec3(.9,.4,.1);\t\t// sushi sign color\n    \n    vec3 camTarget = vec3(6.,10.,0.);\t// cam target is JCVD\n    vec3 pos = getCamPos(camTarget);\n    vec3 ray = getRay(uv, pos ,camTarget);\n    \n    \n    vec4 info = trace(pos, ray, false);\t\t// false: do not trace for shadow calculation\n    float t = info.w;\n    vec3 norm = info.xyz;\n    \n    vec3 p = pos + t*ray;\n    \n    // Lights computation\n    vec3 lightVec1 = litCtr1-p;\n    vec3 ambiLight1 = normalize(lightVec1);\n    float shad1 = .5*dot(ambiLight1,norm)+.5;\n    float len = length(lightVec1);\n    float light1 = 270./(len*len)\n                *(.7*dot(ambiLight1,vec3(0.,1.,0.))+.3);\t// to avoid propagation above the source light\n\n    vec3 lightVec2 = litCtr2-p;\n    vec3 ambiLight2 = normalize(lightVec2);\n    float shad2 = .5*dot(ambiLight2,norm)+.5;\n    len = length(lightVec2);\n    float light2 = 270./(len*len)\n                *(.7*dot(ambiLight2,vec3(0.,1.,0.))+.3);\t// to avoid propagation above the source light\n\n    vec3 lightVec3 = litCtr3-p;\n    vec3 ambiLight3 = normalize(lightVec3);\n    float shad3 = .5*dot(ambiLight3,norm)+.5;\n    len = length(lightVec3);\n    float light3 = 270./(len*len)\n                *(.7*dot(ambiLight3,vec3(0.,1.,0.))+.3);\t// to avoid propagation above the source light\n    \n    // ambiLight is the light direction\n    // light is the intensity received due to distance\n    // shad is the intensity due to surface orientation\n    \n    // color and render\n    if(hitObj == ROAD)\n        color += lightColor*.6*texture(iChannel1,p.xz*.03).rrr*(light1+light2+light3);\n    \n    else if(hitObj == SIDE){\n        color += 1.5*lightColor*texture(iChannel1,(p.xz*norm.y+p.xy*norm.z)*.05).rrr;\n        color -= 2.*fract(9.5+p.z)*step(9.5,p.z)*step(-20.,p.x)*step(fract(p.x*.2),.97)*texture(iChannel1,p.xz*.05).rrr;\n        color -= fract(-63.+p.x)*step(-63.,p.x)*step(p.x,-20.)*step(fract(p.z*.2),.97)*texture(iChannel1,p.xz*.05).rrr;\n        color *= 1.-step(p.x,-20.)*norm.x;\n        color -= step(-20.,p.x)*texture(iChannel1,p.xz*.2).b/(abs(p.z)+.00001);\n        color *= shad1*light1+shad2*light2+shad3*light3;\n    }\n    else if(hitObj == WALL || hitObj == SHOP){\n        color += lightColor*(.5*texture(iChannel1,(p.xz*norm.y+p.xy*norm.z+p.yz*norm.x)*.02).rrr+.5);\t// concret wall\n\t\tcolor *= (.8*texture(iChannel1,(p.xz*norm.y+p.xy*norm.z+p.yz*norm.x)*.03).b +.2);\t// dirts on wall\n        color -= texture(iChannel1,p.xy*.05).b/p.y;\n        color *= (light1*shad1 + light2*shad2 + light3*shad3);\n        \n        // JCVD graffiti\n        float dist;\n        float ti = iChannelTime[2];\n\t\t// Shadow of graffiti is moving away depending on graffiti movement\n        if(ti < 12.5) dist = .15;\n        else if(ti < 14.5) dist = .15+(ti-12.5)*.15;\n        else if(ti < 33.5) dist = .25;\n        else if(ti < 57.5) dist = .15;\n        else if(ti < 61.) dist = .15+(ti-57.5)*.15;\n        else if(ti < 76.) dist = .15;\n        else if(ti < 78.5) dist = .35;\n        else if(ti < 98.5) dist = .15;\n        else if(ti < 100.8) dist = .30-(ti-98.5)*.10;\n        else if(ti < 108.) dist = .15;\n        else if(ti < 110.8) dist = .15+(ti-108.)*.15;\n        else dist = .15;\n            \n        vec2 lp = p.xy*.1-vec2(.1,.5);\n        if(floor(lp.x)==0. && floor(lp.y)==0.) color += graffiti(lp, iChannel2, ambiLight1.xy, dist);\n        \n        // NyanCat Graffiti\n        float mv = 8.*fract(iTime*.1)-4.;\n        lp = p.zy*vec2(.05,.2)-vec2(mv,1.7);\n    \tif(floor(lp.x)==0. && floor(lp.y)==0.) color += step(p.x,-20.)*graffiti(lp, iChannel0, ambiLight3.zy,.1);\n\n    }\n    \n    else if(hitObj == DOOR){\n        info = boxImpact(pos,ray, doorCtr, doorDim, INSIDE);\n        t = info.w;\n        norm = info.xyz; \n        vec3 tp = pos + t*ray;\n        color += vec3(.7,.6,.4)*2./length(doorCtr + vec3(0.,doorDim.y,3.) - tp); // light inside\n\t\tfloat wind = .03*sin(p.y+3.*p.x)*sin(iTime+p.x)*(10.-p.y);\t// little bending mvt to simulate wind on curtain\n        vec3 curtCol = vec3(.7,.7,.7) + vec3(.0,-.5,-.5)*step(length((doorCtr.xy+vec2(wind,2.)-p.xy)*ratio), .9);   // white color strip curtain + japan red flag\n        color +=curtCol*light1*(1.-smoothstep(.35+wind, .45+wind ,abs(fract((p.x )*1.666667)-.5))) * smoothstep(.39,.4,fract((p.y-.6)/10.));\t// curtain with mvt due to wind\n        color -= vec3(1.)*smoothstep(.97,.98,fract((p.y-.6)/10.));\t// holding bar for curtain\n    }\n    else if(hitObj == PYL1) color += lightColor*vec3(.5)*light1*dot(norm,vec3(0.,0.,-1.))*max(0.,dot(ambiLight1,vec3(0.,1.,0.)));\t// street light pylon\n    else if(hitObj == PYL2) color += lightColor*vec3(.5)*light2*dot(norm,vec3(0.,0.,-1.))*max(0.,dot(ambiLight2,vec3(0.,1.,0.)));\n    else if(hitObj == PYL3) color += lightColor*vec3(.5)*light3*dot(norm,vec3(0.,0.,-1.))*max(0.,dot(ambiLight3,vec3(0.,1.,0.)));\n\n    else if(hitObj == LIT1) color += lightColor*vec3(.5)*shad1;\t\t// steet light cover\n    else if(hitObj == LIT2) color += lightColor*vec3(.5)*shad2;\n\telse if(hitObj == LIT3) color += lightColor*vec3(.5)*shad3;\n \t// else SKY\n        \n    \n    // hard shadow\n    // only calculated localy with main street light 1\n    if(abs(p.x) < 60.){\n        vec3 v = normalize(p - litCtr1);\n        info = trace(litCtr1 , v, true);\t\t// true: trace for shadow\n        if(info.w<INFINI && length(litCtr1 + info.w*v - p) > .1) color *= .2;\n    }   \n    \n    // street light bulb halo\n    color += lightColor*bulbHalo(litCtr1,pos,p, ray, norm,.6,.15);\n    color += lightColor*bulbHalo(litCtr2,pos,p, ray, norm,.6,.15);\n    color += lightColor*bulbHalo(litCtr3,pos,p, ray, norm,.6,.15);\n    \n    \n    // SUSHI AD LIGHTS\n    \n    // light vibration - short circuit\n    float vibe = 1.-.7*H1(iTime)*step(.8,H1(floor(iTime*5.)*.345632));\n    // letters position\n    vec3 Sc1 = sushiCtr,\t\t\t\t\t\n         Uc = sushiCtr-vec3(0.,1.5,0.),\n         Sc2 = sushiCtr-vec3(0.,3.,0.),\n         Hc = sushiCtr-vec3(0.,4.5,0.),\n         Ic = sushiCtr-vec3(0.,6.,0.);\n    \n    float st = sfcImpact(pos.x, ray.x, sushiCtr.x);\t//sushi sign surface\n    \n    if(st<t){\n        vec3 sp = pos + st*ray;\n        // Draw sign rectangle\n        float dz = abs(sp.z-sushiCtr.z), dy = abs(sp.y-sushiCtr.y+3.);\n        color += .5*vibe*advColor*smoothstep(.45,.55,dz)*(1.-smoothstep(.55,.65,dz))*step(dy,4.);\n\t\tcolor += .5*vibe*advColor*smoothstep(3.9,4.,dy)*(1.-smoothstep(4.,4.1,dy))*step(dz,.55);\n        color -= smoothstep(1.9,2.,dy)*(1.-smoothstep(2.,2.1,dy))*step(abs(sp.z-sushiCtr.z+1.1),.55);\n\t\t\n        // Draw letters\n        float d = sushiCtr.y-sp.y;\n        if(d<0.6) \t\tcolor += advColor * S(sp,Sc1.y,Sc1.z) * vibe;\t\t// Draw S letter\n        else if(d<2.1) \tcolor += advColor * U(sp,Uc.y,Uc.z) * vibe;\t\t\t// vibe = twinkle effect\n        else if(d<3.6) \tcolor += advColor * S(sp,Sc2.y,Sc2.z) * vibe;\n        else if(d<5.1) \tcolor += advColor * H(sp,Hc.y,Hc.z) * vibe;\n        else \t\t\tcolor += advColor * I(sp,Ic.y,Ic.z) * vibe;\n\t}\n    \n    // letters Halo\n    color += advColor * bulbHalo(Sc1,pos,p, ray, norm,.4,.35) * vibe;\n    color += advColor * bulbHalo(Uc,pos,p, ray, norm,.4,.35);\n    color += advColor * bulbHalo(Sc2,pos,p, ray, norm,.4,.35) * vibe;\n    color += advColor * bulbHalo(Hc,pos,p, ray, norm,.4,.35);\n    color += advColor * bulbHalo(Ic,pos,p, ray, norm,.4,.35) * vibe;\n\n    // Wall surface highlighted by ad\n    if(norm.z ==1. || norm.y == 1.){\n        float sl = .3/length(Sc1-p)+.3/length(Sc2-p)+.3/length(Ic-p);\t// taking into account\n        color += advColor*min(.5, sl);\t\t\t\t\t\t\t\t\t// only 3 letters (enough for rendering)\n    }\n    \n    if(hitObj == SHOP && norm.x == 1.) color*= .8;\t// shop corner shadow\n    \n    // Water patches reflection and drops impact\n    if(hitObj == SIDE || hitObj == ROAD){\n        float tex = texture(iChannel1,p.xz*.025+.3).b;\n        // drops impact\n        float dt = 1.-fract(iTime+H2(floor(p.xz*10.),0.));\n        float rainPlic = dt*plic(2.*abs(fract(p.x*2.)-.5),dt)*dt*plic(2.*abs(fract(p.z*2.)-.5),dt)*step(.5,H2(floor(p.xz*2.),iTime*.05));\n        \n        // Water patches + drops impact\n        float waterPatch = smoothstep(.45,.55,tex)+.5*rainPlic;\n        \n        vec3 refl = reflect(ray,norm);\n        vec3 reflight = step(p.y,.8)*waterPatch*lightColor; //step(p.y,.8) consider only\n        vec3 refletter = step(p.y,.8)*waterPatch*advColor;  //road and sidewalk\n        vec3 nul = vec3(0.);\n        // Street light reflection\n        color += reflight * bulbHalo(litCtr1,p,nul, refl, nul,3.,1.); \n    \tcolor += reflight * bulbHalo(litCtr2,p,nul, refl, nul,3.,5.);\n        color += reflight * bulbHalo(litCtr3,p,nul, refl, nul,3.,5.);\n        // letters reflection\n        color += refletter * bulbHalo(Sc1,p,nul, refl, nul,1.,1.8)*vibe;\n        color += refletter * bulbHalo(Uc,p,nul, refl, nul,1.,1.8);\n        color += refletter * bulbHalo(Sc2,p,nul, refl, nul,1.,1.8)*vibe;\n        color += refletter * bulbHalo(Hc,p,nul, refl, nul,1.,1.8);\n        color += refletter * bulbHalo(Ic,p,nul, refl, nul,1.,1.8)*vibe;\n    }\n    \n    // Rain\n    t = sfcImpact(pos.z, ray.z, camTarget.z);\n    vec3 rp = pos + t*ray;\n    vec2 sc = vec2(rp.x*.1,rp.y*.002 + iTime*.1);\n    color *= 1. + .5*max(0.,2.*(texture(iChannel3,sc).r-.8));    // -.8 change rain intensity\n    \n    t = sfcImpact(pos.x, ray.x, camTarget.x);\n    rp = pos + t*ray;\n    sc = vec2(rp.z*.1,rp.y*.002 + iTime*.1);\n    color *= 1. + .5*max(0.,2.*(texture(iChannel3,sc).r-.8));\n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}