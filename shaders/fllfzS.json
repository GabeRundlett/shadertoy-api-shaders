{
    "Shader": {
        "info": {
            "date": "1651052109",
            "description": "I recreated again my perlin noise to create Ridged Multifractal, after my old one had some sharp conners squarish.",
            "flags": 0,
            "hasliked": 0,
            "id": "fllfzS",
            "likes": 3,
            "name": "Perlin noise Ridged Multifratal",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "multifractal",
                "ridged"
            ],
            "usePreview": 0,
            "username": "MrNissenDK",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= 10.;\n    \n    float time = iTime * 0.5;\n    \n    float r = 1. - abs(perlin(vec3(-uv - vec2(time      + 058., time *  0.5), time), 1, .5) * 2. - 1.);\n    float g = 1. - abs(perlin(vec3( uv + vec2(time      + 255., time *  0.2), time), 1, .5) * 2. - 1.);\n    float b = 1. - abs(perlin(vec3( uv + vec2(time      + 954., time *  0.1), time), 1, .5) * 2. - 1.);\n    vec3 col = vec3(r,g,b);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "uint seed = 455245u;\n\nfloat modF(float x, float y)\n{\n    return x -  y * floor( x / y );\n}\n\nvec3 modF(vec3 a, float y)\n{\n    a = a;\n    return a -  y * floor( a / y );\n}\n\nint modI(int x, int y)\n{\n    return x -  y * (x / y);\n}\n\nvec3 modI(vec3 a, int y)\n{\n    a = floor(a);\n    return a -  float(y) * floor( a / float(y) );\n}\n\nuint modU(uint x, uint y)\n{\n    return x - ( x / y ) * y;\n}\n\nint random(uint i)\n{\n    uint si = i + seed;\n    si *= i;\n    si += seed;\n    si *= si;\n    si ^= seed;\n    si += i + seed;\n    si *= si;\n    si *= si;\n    si *= si;\n    si ^= seed;\n    return abs( modI( int(si), 255) );\n}\nint random(float i)\n{\n    return random(uint(i));\n}\nint random(int i)\n{\n    return random(uint(i));\n}\nint random(vec3 i)\n{\n    return random(\n        uint(random(\n            uint(random(\n                uint(i.x)\n            )) + uint(i.y)\n        )) + uint(i.z)\n    );\n}\n\nfloat fade(float t)\n{\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 fade(vec3 t)\n{\n    return vec3(fade(t.x), fade(t.y), fade(t.z));\n}\n\n\n\nint inc(int num)\n{\n    num++;\n    return num;\n}\n\nint inc(float num)\n{\n    return inc(int(num));\n}\n\nfloat grad(int hash, vec3 pos)\n{\n    int h = hash & 15;\n    float u = (h < 8) ? pos.x : pos.y;\n    \n    float v;\n    \n    if(h < 4)\n    {\n        v = pos.y;\n    }else if( h == 12 || h == 14 )\n    {\n        v = pos.x;\n    }else\n    {\n        v = pos.z;\n    }\n    \n    return (((h&1) == 0) ? u : -u)+((h&2) == 0 ? v : -v);\n}\n\nfloat lerp(float a, float b, float x)\n{\n    return a + x * (b - a);\n}\n\nfloat noise(vec3 pos)\n{\n    vec3 posI = floor(pos);\n    vec3 posF = pos - posI;\n    \n    posI.x = float(int(posI.x) & 255);\n    posI.y = float(int(posI.y) & 255);\n    posI.z = float(int(posI.z) & 255);\n    \n    vec3 uvw = fade(posF);\n    \n    int aaa = random(vec3(     posI.x ,     posI.y ,     posI.z  ));\n    int aba = random(vec3(     posI.x , inc(posI.y),     posI.z  ));\n    int aab = random(vec3(     posI.x ,     posI.y , inc(posI.z) ));\n    int abb = random(vec3(     posI.x , inc(posI.y), inc(posI.z) ));\n    int baa = random(vec3( inc(posI.x),     posI.y ,     posI.z  ));\n    int bba = random(vec3( inc(posI.x), inc(posI.y),     posI.z  ));\n    int bab = random(vec3( inc(posI.x),     posI.y , inc(posI.z) ));\n    int bbb = random(vec3( inc(posI.x), inc(posI.y), inc(posI.z) ));\n    \n    float x1, x2, y1, y2;\n    \n    x1 = lerp(\n        grad(aaa, posF), \n        grad(baa, vec3(posF.x - 1., posF.y     , posF.z     )),\n        uvw.x\n    );\n    x2 = lerp(\n        grad(aba, vec3(posF.x     , posF.y - 1., posF.z     )), \n        grad(bba, vec3(posF.x - 1., posF.y - 1., posF.z     )),\n        uvw.x\n    );\n    y1 = lerp(x1,x2, uvw.y);\n    \n    x1 = lerp(\n        grad(aab, vec3(posF.x     , posF.y     , posF.z - 1.)), \n        grad(bab, vec3(posF.x - 1., posF.y     , posF.z - 1.)),\n        uvw.x\n    );\n    x2 = lerp(\n        grad(abb, vec3(posF.x     , posF.y - 1., posF.z - 1.)), \n        grad(bbb, vec3(posF.x - 1., posF.y - 1., posF.z - 1.)),\n        uvw.x\n    );\n    y2 = lerp(x1,x2, uvw.y);\n    \n    return (lerp (y1, y2, uvw.z) + 1.) / 2.;\n}\n\nfloat perlin(vec3 pos, int octaves, float persistence)\n{\n    float total = 0.;\n    float frequency = 1.;\n    float amplitude = 1.;\n    float maxValue = 0.;\n    \n    for(int i=0;i<octaves;i++) {\n        total += noise(pos * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    \n    return total/maxValue;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}