{
    "Shader": {
        "info": {
            "date": "1571236763",
            "description": "Training some post effect pass with kernel. Not convincing with the technique but still do something good !",
            "flags": 96,
            "hasliked": 0,
            "id": "tdV3Wt",
            "likes": 9,
            "name": "Shadertober 16 Wild",
            "published": 3,
            "tags": [
                "raymarching",
                "kernel",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 615
        },
        "renderpass": [
            {
                "code": "\nmat3 blurkernel = mat3(\n .11, .11, .11,\n .11, .11, .11, \n .11, .11, .11 \n);\n\nvec3 renderSample(const int x, const int y, vec2 fragCoor)\n{\n    vec2 uv = fragCoor.xy;\n    uv = (uv + vec2(x, y)) / iResolution.xy;\n    return texture(iChannel0, uv).xyz;\n}\n\nvec3 aFilter(vec2 fragCoord, mat3 kernel)\n{\n    vec3 sum = vec3 (0.0,0.0,0.0);\n    \n    for (int first = 0; first < 3; first++)\n    {\n        for(int second = 0; second < 3; second++)\n        {\n        \tsum += renderSample(first-1,second-1, iResolution.xy) * kernel[first][second] / (.1 + sin(iTime*2.));\n        }\n }\n        \n return sum;\n}\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    suv.x *= iResolution.x / iResolution.y;\n    vec3 base = texture(iChannel0,uv).xyz;\n    \n    // was trying some glow effect and it looked closest to some sort of AA\n    vec3 effect = aFilter(fragCoord.xy * iResolution.xy, blurkernel);\n    \n    base += effect;\n\n    base = sqrt(clamp(base, 0.0, 1.0));\n    base *= 1.5;\n    base -= vec3(pow(length(suv), 2.0))*.1;\n    base -= random(suv)*.1* length(suv) * .4;\n    \n    fragColor = vec4(base, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// SHADERTOBER 16 Wild\n// Poulet Vert 16-10-2019\n// Thanks to iq, leon, flopine, Michael Zheng\n\n#define PI 3.14159\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\n\nfloat sdBox( vec3 p, float s )\n{\n  vec3 q = abs(p) - vec3(s);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCross( vec3 p )\n{\n  float da = sdBox(p.xyz, vec3(3.,1.0,1.0));\n  float db = sdBox(p.yzx, vec3(1.0,3.,1.0));\n  float dc = sdBox(p.zxy, vec3(1.0,1.0,3.));\n  return min(da,min(db,dc));\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nfloat sdCross( vec3 p, vec3 s, float l)\n{\n    vec3 r = vec3(1.0,0.0,0.0)*l;\n    vec3 f = vec3(0.0,0.0,1.0)*l;\n    vec3 u = vec3(0.0,1.0,0.0)*l;\n    float b1 = sdBox(p, s+r);\n    float b2 = sdBox(p, s+f);\n    float b3 = sdBox(p, s+u);\n    return min(min(b1,b2),b3);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Scene setup\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0, 0.0);\n    \n    float motion = iTime * 4.0;\n    \n    vec3 baseCubeP = pos + vec3(0.0, 0.0, motion);\n    baseCubeP = opRep(baseCubeP, vec3(5.0));\n    float bc = sdBox(baseCubeP, vec3(1.0));\n    bc = max(bc, -sdCross(baseCubeP, vec3(.5), 1.));\n    \n    vec3 lcrosP = pos + vec3(0.0, 0.0, motion);\n    lcrosP = opRep(lcrosP, vec3(0.75, 5.0, 0.75));\n    float lc = sdBox(lcrosP, vec3(.1, .1, 5.));\n    bc = max(bc, -lc);\n    \n    vec3 lineP = pos + vec3(0.0, 0.0, motion+0.0);\n    lineP = opRep(lineP, vec3(0.0, 0.0, 1.));\n    float line = sdBox(lineP, vec3(.5, 0.5, 0.01));\n    \n    vec3 lineSubP = pos + vec3(0.0, 0.0, motion);\n    lineSubP = opRep(lineSubP, vec3(1.));\n    float lineSub = sdBox(lineSubP, vec3(.49, .49, .3));\n    line = max(line, -lineSub);\n    \n    vec2 bcmat = vec2(bc, 0.0);\n    vec2 lmat = vec2(line, 1.0);\n    \n    \n    t = bcmat;\n    t = opU2(t, lmat);\n    \n    return t;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/128., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(t.x+fract(iTime), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    \n    if(t.x == -1.0)\n    {\n        \n        col = polyCol; \n        \n    }\n    else\n    {\n        float depth = 1.0 - t.x;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(pow(depth, 16.0)*.05);\n        }\n        else if(t.y == 1.0)\n        {\n            col = polyCol;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime), cos(iTime), 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime * .5;\n    \n    vec3 cp = vec3(0.0, 0.0, -5.0);\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 20002,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/jose-alejandro-garcia-beltran/progressive-psytrance-2013-the"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}