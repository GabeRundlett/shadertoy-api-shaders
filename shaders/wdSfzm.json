{
    "Shader": {
        "info": {
            "date": "1589723112",
            "description": "This is a fork of https://www.shadertoy.com/view/tdBfRw (Simulating the Colors of the Sky) by jamelouis\nNice things to add would be rotating the sun around a viewpoint, e.g. using a geographic calculation based on different locations on Earth + a 3D scene",
            "flags": 32,
            "hasliked": 0,
            "id": "wdSfzm",
            "likes": 17,
            "name": "Simulating the Sunrise/Sunset",
            "published": 3,
            "tags": [
                "sun",
                "colors",
                "sky",
                "fork",
                "sunrise",
                "simulating"
            ],
            "usePreview": 0,
            "username": "Yambam",
            "viewed": 1211
        },
        "renderpass": [
            {
                "code": "const float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926f;\nconst float DURATION = 12.;\n\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6f);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5f;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 8u;\n    uint numSamplesLight = 8u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3.f / (16.f * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    vec3 betaRt = betaR*(1. + vec3(0.,2.,3.)*(iMouse.x/iResolution.x-.1));\n    vec3 betaMt = betaM*(1. + 16.*iMouse.y/iResolution.y);\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaRt * (opticalDepthR + opticalDepthLightR) + betaMt * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaRt * phaseR + sumM * betaMt * phaseM) * 20.;\n}\n\n#define T(p, lod) textureLod(iChannel0, p, lod).rgb\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float angle = M_PI * (fract((float(iFrame)/DURATION+40.)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy  * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    float z2 = x*x + y*y;\n    \n    vec3 col = vec3(0.0);\n    float scale = .3;\n    //if(z2 <= 1.){\n        float phi = (x/2. - 10./3. * iMouse.x / iResolution.x)*2.*M_PI*scale;\n        float theta;\n        if (fract((float(iFrame)/DURATION+40.)/180.) < .5) {\n            theta = y*M_PI*scale-1.5;\n        } else {\n            theta = -(y*M_PI*scale-1.5);\n        }\n        vec3 dir = vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi));\n        col = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir, 0., INFINITY, sunDirection);\n    //}\n    \n\n    // Output to screen\n    col = pow(col, vec3(1.0/2.5));\n    fragColor = vec4(col,1.0);\n    \n    if (uv.y < -.065) {\n        fragColor = vec4(T(fragCoord/iResolution.xy, 0.), 1.); //vec4(vec3(.3), 1.);\n    }\n}\n#undef T",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926f;\nconst float DURATION = 12.;\n\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6f);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5f;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 8u;\n    uint numSamplesLight = 8u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3.f / (16.f * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    vec3 betaRt = betaR*(1. + vec3(0.,2.,3.)*(iMouse.x/iResolution.x-.1));\n    vec3 betaMt = betaM*(1. + 16.*iMouse.y/iResolution.y);\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaRt * (opticalDepthR + opticalDepthLightR) + betaMt * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaRt * phaseR + sumM * betaMt * phaseM) * 20.;\n}\n\n\n\nconst float waveHeight = .125; // average surface height\n\nfloat spow(float x, float e)\n{\n    return pow(abs(x), e) * sign(x);\n}\n\n// 3 scrolling textures on a plane\nfloat wave(vec3 p)\n{\n//    return p.y - waveHeight + .2*spow(sin(p.x)*sin(p.z), 4.); // test bumps\n\tfloat t = iTime * .33; //0.; // scroll or don't\n    // disliked how original fudged with the texcoords\n    #define T(x,y) texture(iChannel2, (p.xz + vec2(x,y)*t) / 20.).rgb\n\tvec3 c1 = T(2., 2.);\n\tvec3 c2 = T(2.52, 5.);\n\tvec3 c3 = T(3.32, 9.);\n    #undef T\n\tc1 += c2 - c3;\n\tfloat z = (c1.x + c1.y + c1.z) / 12.;\n\treturn p.y + z;\n}\n\n// no ray marching required, just cast directly to plane\nfloat intersectWave(vec3 ro, vec3 rd) \n{\n    return (ro.y - waveHeight) / -rd.y;\n}\n\n// even fwd diff seems fine for normal\nvec3 normWave(vec3 p) \n{\n\tconst vec2 e = vec2(.25,0);\n\treturn normalize(vec3(\n\t\twave(p + e.xyy),\n\t\twave(p + e.yxy),\n\t\twave(p + e.yyx))\n      - wave(p)\n\t);\n}\n\nvec3 lightWave(vec3 ro, vec3 rd, float d)\n{\n    vec3 p = ro + rd * d; // hit point on plane\n    float sh = wave(p) - .5*waveHeight; //.25; // wave height variation\n    p.xz += 2. * sh * rd.xz; // bump offset, parallax mapping - subtle\n    sh = wave(p) - .5*waveHeight; //.25; // reeval height after bump offset\n\tvec3 n = normWave(p) // surface normal\n\t, l1 = normalize(vec3(1)); // main parallel light ('sun')\n\tfloat nv = dot(rd, n)\n\t, spc = pow(max(0., dot(reflect(l1, n), rd)), 30.) // sun specular\n    , eta = 1.003/1.3 // air vs. water\n    , waterdepth = 4.; //+ sh\n    vec3 rfd = refract(rd, n, eta);  // refract view direction\n    float depthest = -waterdepth / rfd.y; // water depth estimate along refracted path\n    \n    \n    float angle = M_PI * (fract((float(iFrame)/DURATION+40.)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n    \n    float phi = .4;\n    vec2 theta = vec2(-.35, .35);\n    vec3 dir0 = vec3(sin(theta[0])*cos(phi), cos(theta[0]), sin(theta[0])*sin(phi));\n    vec3 dir1 = vec3(sin(theta[1])*cos(phi), cos(theta[1]), sin(theta[1])*sin(phi));\n\t\n    vec3 col0 = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir0, 0., INFINITY, sunDirection).rgb;\n    vec3 col1 = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir1, 0., INFINITY, sunDirection).rgb;\n    \n    vec3 ref = texture(iChannel0, reflect(rd, n)*.667).rgb // reflection environment cubemap\n    , rfa = mix(\n        col0\n        ,\n        texture(iChannel1, (p + rfd*depthest).xz / 4.).rgb\n        ,\n        .3\n    ); // regular refraction\n    // HACK the original just did everything in srgb gamma\n    // which is not correct, but it's really hard to match\n    // the look without doing basically the same thing.\n\t// gave up on good gamma correction until I can\n    // match the look better somehow.\n     //   ref = pow(ref, vec3(2.2));\n     //   rfa = pow(rfa, vec3(2.2));\n    ref *= .5;\n    rfa *= exp2(-.125 * depthest); // extinct by water depth estimate\n    vec3 c;\n//    c = n * .5 + .5; // DEBUG normal\n//    c = vec3(sh * 1.5 + .5); // DEBUG height\n//    c = vec3(exp2(-.2*d)); // DEBUG depth\n//    c = vec3(spc); // DEBUG spec only\n//    c = ref; // DEBUG just envmap reflection\n//    c = rfa; // DEBUG just refraction\n//    c = spc + rfa; // DEBUG just spec + refraction\n//    c = pow(c, vec3(1./2.2)); // HACK fix gamma - temp - for debugging\n\tc = rfa + ref + spc*col1; // sum all light - in wrong gamma\n    return mix(mix(c, col0, .0), vec3(0.), pow(2., -.125 * depthest) - .65);\n}\n\n// e^(-i*angleRadians) I guess\nvec2 cossin(float angleRadians)\n{\n\treturn sin(angleRadians + vec2(1.5708,0));\n}\n\nvoid cameraRay(vec2 p, vec2 r, out vec3 ro, out vec3 rd)\n{\n\tvec2 q = (p + p - r) * .5/r.y; // signed aspect-correct uv\n\tfloat mx = (.35 + 2.5*(iMouse.x/iResolution.x)); // mouse lookaround\n    vec3 rc = vec3(500.*cos(mx), 6, 500.*sin(mx)); // look at point, spins around\n    //if (dot(iMouse.xy, vec2(1)) < 1.5) mx = iTime * -1.; // slowly spin if unattended\n\tro = vec3(0, 0, 3).xzy; // camera rotate\n\tvec3 ww = normalize(rc - ro)\n\t, uu = normalize(cross(vec3(0,1,0), ww))\n\t, vv = normalize(cross(ww, uu));\n\trd = normalize(uu * q.x + vv * q.y + ww);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 ro, rd, c = vec3(0);\n    cameraRay(fragCoord, iResolution.xy, ro, rd);\n\tfloat d = intersectWave(ro, rd);\n\tif (d >= 0.) // didn't miss? can't, really, with this camera\n        c = lightWave(ro, rd, d); // draw water\n\t//c = pow(c, vec3(1./2.2)); // to srgb gamma for storage in display buffer\n\tfragColor = vec4(c, 1);\n}\n\n\t\t//vec3 rfa = texture(iChannel1, (p+n).xz / 6.).rgb; // extreme HACK refraction\n     //   rfa *= 1.0; // HACK brighten riverbed rocks\n        //rfa *= 8./d; // HACK fade in distance to emulate missing fresnel and water extinction\n     //   rfa *= mix(1.-pow(max(0., 1.-abs(nv)), 5.), 1., .04); // fakie fresnel\n\t    //c = (c - .5) * 1.5 + .5; // HACK increase contrast\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}