{
    "Shader": {
        "info": {
            "date": "1682886426",
            "description": "Old shader I made to learn about TAA\nImplements temporal reprojection and variance clipping\n\nMouse drag to move\nDefines in Common",
            "flags": 32,
            "hasliked": 0,
            "id": "DsfGWX",
            "likes": 24,
            "name": "Temporal AA Study",
            "published": 3,
            "tags": [
                "3d",
                "taa"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 782
        },
        "renderpass": [
            {
                "code": "\n// Temporal AA Study by gelami\n// https://www.shadertoy.com/view/DsfGWX\n\n/*\n * Old shader I made to learn about TAA\n * Implements temporal reprojection and variance clipping\n *\n * Mouse drag to move\n * Defines in Common\n * \n * Resources:\n * Marco Salvi - Temporal Supersampling (Variance Clipping)\n *  - https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf\n * A Survey of Temporal Antialiasing Techniques\n *  - http://behindthepixels.io/assets/files/TemporalAA.pdf\n * Temporal AA and the quest for the Holy Trail\n *  - https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n * High Quality Temporal Supersampling\n *  - https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf\n * Temporal Reprojection Anti-Aliasing in INSIDE\n *  - https://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in\n *  - https://github.com/playdeadgames/temporal/blob/master/Assets/Shaders/TemporalReprojection.shader\n *\n * Shaders:\n * Enscape Cube - ThomasSchander (TAA Implementation)\n *  - https://www.shadertoy.com/view/4dSBDt\n * Temporal AA + Variance Clipping - Vil\n *  - https://www.shadertoy.com/view/MscSD7\n * Temporal Reprojection - Raxvan\n *  - https://www.shadertoy.com/view/ldtGWl\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_COMPARISON\n    if (fragCoord.x - iResolution.x / 2. < 0.)\n        fragColor.rgb = linearTosRGB(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb);\n    else\n#endif\n        fragColor.rgb = linearTosRGB(texelFetch(iChannel1, ivec2(fragCoord), 0).rgb);\n    \n    vec2 s = vec2(240, 160);\n    float sc = 4.0;\n    if (fragCoord.x < s.x && fragCoord.y < s.y)\n    {\n        vec2 p = ((fragCoord - s * .5) / s.y) * s.x / sc;\n        vec2 s = p + iResolution.xy * .5;\n        \n    #ifdef SHOW_COMPARISON\n        if (p.x < 0.)\n            fragColor.rgb = linearTosRGB(texelFetch(iChannel0, ivec2(s), 0).rgb);\n        else\n    #endif\n            fragColor.rgb = linearTosRGB(texelFetch(iChannel1, ivec2(s), 0).rgb);\n        \n    #ifdef SHOW_COMPARISON\n        if (int(floor(p.x)) == 0)\n            fragColor.rgb = vec3(1, 0, 0);\n    #endif\n    }\n    \n#ifdef SHOW_COMPARISON\n    if (int(floor(fragCoord.x - iResolution.x / 2.)) == 0)\n        fragColor.rgb = vec3(1, 0.1, 0.1);\n#endif\n    fragColor.a = 1.0;\n    fragColor.rgb += hash13(vec3(fragCoord, iTime)) / 256.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Defines\n\n#define CAMERA_MOVEMENT\n//#define OBJECT_MOVEMENT\n\n#define CHECKERS\n//#define FILTERED_CHECKERS\n\n// TAA Settings\n#define ENABLE_TAA\n\n#define JITTER\n#define UNJITTER\n\n#define TEMPORAL_REPROJECT\n//#define REJECT_DISOCCLUSION\n\n#define VARIANCE_CLIPPING\n\n//#define SHOW_DISOCCLUSION\n//#define SHOW_MOTION\n\n#define SHOW_COMPARISON\n\n////////////////\n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nvec4 getTextureSmooth(sampler2D tex, vec2 size, vec2 p)\n{\n    p = p * size + .5;\n    \n    vec2 i = floor(p);\n    vec2 f = p - i;\n    \n    // Smoothstep\n    //f = f * f * (3. - 2. * f);\n    \n    // Smootherstep\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    // Smootheststep\n    f = f*f*f*f * (f * (f * (f * -20. + 70.) - 84.) + 35.);\n    \n    // Fast Smootheststep\n    //f = max(min((f - .2) / .6, 1.), 0.);\n    //f = f * f * (3. - 2. * f);\n    \n    p = i + f;\n    \n    p = (p - .5) / size;\n    return texture(tex, p);\n}\n\n// Taken from https://www.shadertoy.com/view/MtVGWz\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += texture(tex, vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += texture(tex, vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += texture(tex, vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += texture(tex, vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n\n// Adapted from https://vec3.ca/bicubic-filtering-in-fewer-taps/\nvec4 SampleTextureBSpline(sampler2D tex, vec2 size, vec2 uv)\n{\n    vec2 sp = uv * size;\n    vec2 fc = floor(sp - 0.5) + 0.5;\n    \n    vec2 f = sp - fc;\n    vec2 f2 = f * f;\n    vec2 f3 = f2 * f;\n    \n    vec2 w0 = f2 - 0.5 * (f3 + f);\n    vec2 w1 = 1.5 * f3 - 2.5 * f2 + 1.0;\n    vec2 w3 = 0.5 * (f3 - f2);\n    vec2 w2 = 1.0 - w0 - w1 - w3;\n    \n    vec2 s0 = w0 + w1;\n    vec2 s1 = w2 + w3;\n    \n    vec2 f0 = w1 / (w0 + w1);\n    vec2 f1 = w3 / (w2 + w3);\n    \n    vec2 t0 = fc - 1.0 + f0;\n    vec2 t1 = fc + 1.0 + f1;\n    \n    t0 /= size;\n    t1 /= size;\n    \n    return texture(tex, vec2(t0.x, t0.y)) * s0.x * s0.y +\n           texture(tex, vec2(t1.x, t0.y)) * s1.x * s0.y +\n           texture(tex, vec2(t0.x, t1.y)) * s0.x * s1.y +\n           texture(tex, vec2(t1.x, t1.y)) * s1.x * s1.y;\n}\n\n// https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\nfloat IGN(vec2 p, int frame)\n{\n    frame = frame % 64; // need to periodically reset frame to avoid numerical issues\n    float x = p.x + 5.588238 * float(frame);\n    float y = p.y + 5.588238 * float(frame);\n    return fract(52.9829189 * fract(0.06711056 * x + 0.00583715 * y));\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n  vec4 a = vec4(1,1,0,0);\n  while (s.x > 0. && s.y > 0.)\n  {\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(vec2(s),coprimes);\n    s = floor(s/coprimes);\n  }\n  return a.zw;\n}\n\n\nvoid getCameraPosition(out vec3 ro, out vec3 lo, float time )\n{\n\n}\n\nvec2 getJitter(sampler2D ch, vec2 pos, int frame)\n{\n#ifdef JITTER\n    pos = floor(pos);\n    return halton(vec2(frame%8+1)) - .5;\n    //return vec2(IGN(pos, frame), IGN(pos, frame+33));\n    //return texelFetch(ch, (ivec2(pos) + ivec2(13, 27) * frame) % ivec2(1024), 0).xy;\n#else\n    return vec2(0);\n#endif\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec2 saturate(vec2 x)\n{\n    return clamp(x, vec2(0), vec2(0));\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0), vec3(1));\n}\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nvec2 sqr(vec2 x)\n{\n    return x*x;\n}\n\nvec3 sqr(vec3 x)\n{\n    return x*x;\n}\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Camera\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 sp = ivec2(fragCoord);\n\n    vec3 ro = vec3(0, 0, 3.75);\n    vec3 lo = vec3(0, 1, 0);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    bool mdx = iMouse.z < 0. || iMouse.x == 0.;\n    bool mdy = iMouse.z < 0. || iMouse.y == 0.;\n    \n    float ax = 0.+PI, ay = 0.;\n    \n    if (!mdx)\n        ax = -m.x * TAU;\n    else\n#ifdef CAMERA_MOVEMENT\n        ax = -0.75 * PI - iTime * 0.1 * TAU;\n#else\n        ax = -0.75 * PI;\n#endif\n    if (!mdy)\n        ay = m.y * PI * .5;\n    else\n        ay = 0.2 * PI;\n        \n    ro -= lo;\n    //ro *= mdy ? 1. : mix(.25, 1., m.y);\n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n    \n    if (sp.y != 0) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    if (sp.x == 0)\n        fragColor = vec4(ro, 1);\n    else if (sp.x == 1)\n        fragColor = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Scene rendering\n\nfloat checkers(vec2 p)\n{\n    vec2 id = floor(p);\n    return mod(id.x + id.y, 2.);\n}\n\n// From iq https://www.shadertoy.com/view/XlcSz2\nfloat checkersFiltered( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n\nfloat gyroid(vec3 p)\n{\n    return dot(sin(p), cos(p.yzx));\n}\n\nfloat map(vec3 p)\n{\n    float d = MAX_DIST;\n    d = abs(p.y-.01) - .01;\n    vec3 q = p - vec3(0, 1, 0);\n    vec3 o = vec3(0);\n#ifdef OBJECT_MOVEMENT\n    q -= vec3(0, sin(iTime*.5)*.5, 0);\n    o += vec3(.5) * iTime;\n#endif\n    vec2 s = vec2(4);\n    q.xz = mod(q.xz + s*0.5, s) - s*0.5;\n    \n    float g = (abs(gyroid(q * TAU + o)) - 0.3) / (TAU * 2.);\n    \n    d = smin(d, smax(g, (length(q) - 1.), .01), .5);\n\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    const vec2 e = vec2(0, EPS);\n    return normalize(\n        vec3(\n            map(p + e.yxx),\n            map(p + e.xyx),\n            map(p + e.xxy)) - map(p)\n        );\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        float d = map(ro + rd * t);\n        \n        t += d;\n    \n        if (abs(d) < EPS || t > MAX_DIST)\n            return t;    \n    }\n    return t;\n}\n\nvec2 texCoords(vec3 p)\n{\n    return p.xz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 o = getJitter(iChannel1, fragCoord, iFrame);\n    \n    #ifdef SHOW_COMPARISON\n    if (uv.x < 0.5)\n        o = vec2(0);\n    #endif\n    \n    vec2 pv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = texelFetch(iChannel3, ivec2(0, 0), 0).rgb;\n    vec3 lo = vec3(0, 1, 0);\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    \n    float t = trace(ro, rd);\n    \n    vec3 p = ro + rd * t;\n    \n    vec3 n = normal(p);\n    \n    vec3 col = vec3((n*.5+.5));\n    //col = palette(pow(dot(-rd, n), 1.))*.8+.2;\n    \n#ifdef CHECKERS\n    float sc = 2.5;\n    \n    // From iq https://www.shadertoy.com/view/XlcSz2\n#ifdef FILTERED_CHECKERS\n    vec2 dx_pv = (2. * (fragCoord + o + vec2(1, 0)) - iResolution.xy) / iResolution.y;\n    vec2 dy_pv = (2. * (fragCoord + o + vec2(0, 1)) - iResolution.xy) / iResolution.y;\n    \n    vec3 ddx_rd = normalize(cmat * vec3(dx_pv, 2));\n    vec3 ddy_rd = normalize(cmat * vec3(dy_pv, 2));\n    // compute ray differentials\n\tvec3 ddx_pos = ro - ddx_rd*dot(ro-p,n)/dot(ddx_rd,n);\n\tvec3 ddy_pos = ro - ddy_rd*dot(ro-p,n)/dot(ddy_rd,n);\n    \n\t// calc texture sampling footprint\t\t\n\tvec2 uv  = texCoords(     p*sc );\n\tvec2 ddx_uv = texCoords( ddx_pos*sc ) - uv;\n\tvec2 ddy_uv = texCoords( ddy_pos*sc ) - uv;\n    \n    float c = checkersFiltered(uv, ddx_uv, ddy_uv);\n#else\n    float c = checkers(p.xz * sc);\n#endif\n    vec3 ch = mix(vec3(.05), vec3(1), c);\n\n    col *= ch;\n#else\n    //col *= sRGBToLinear(texture(iChannel2, p.xz).rgb);\n#endif\n    \n    t = clamp(t, EPS, MAX_DIST);\n    \n    if (t >= MAX_DIST)\n        col = vec3(0.1);\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    fragColor = vec4(col, t);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// TAA\n\n#if 0\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n\n#else\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n#endif\n\nvec3 rgb2ycocg(in vec3 rgb)\n{\n    float co = rgb.r - rgb.b;\n    float t = rgb.b + co / 2.0;\n    float cg = rgb.g - t;\n    float y = t + cg / 2.0;\n    return vec3(y, co, cg);\n}\n\n\nvec3 ycocg2rgb(in vec3 ycocg)\n{\n    float t = ycocg.r - ycocg.b / 2.0;\n    float g = ycocg.b + t;\n    float b = t - ycocg.g / 2.0;\n    float r = ycocg.g + b;\n    return vec3(r, g, b);\n}\n\nvec3 RGBtoYCoCg(vec3 c)\n{\n    //return rgb2ycocg(c);\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\n    //return ycocg2rgb(c);\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\n#if 0\n// Based on https://www.shadertoy.com/view/MscSD7\n// https://github.com/GameTechDev/TAA/blob/main/MiniEngine/Core/Shaders/TAAResolve.hlsl\nvec3 clipToAABB(in vec3 cOld, in vec3 cNew, in vec3 center, in vec3 halfSize)\n{\n    vec3 dir = (cNew - cOld);\n    \n    vec3 near = (center - cOld) - sign(dir) * halfSize;\n    vec3 tAll = near / dir;\n    tAll = mix(tAll, vec3(1e5), step(tAll, vec3(0)));\n    float t = min(min(tAll.x, tAll.y), tAll.z);\n    \n    if (t >= 1e5)\n        return cOld;\n    \n    t = saturate(t);\n    return cOld + dir * t;\n}\n#else\n// From https://github.com/playdeadgames/temporal/blob/master/Assets/Shaders/TemporalReprojection.shader\nvec3 clipToAABB(in vec3 cOld, in vec3 cNew, in vec3 center, in vec3 halfSize)\n{\n// Clip towards AABB center\n#if 0\n    vec3 o = cOld - center;\n    vec3 v = o / halfSize;\n    vec3 a = abs(v);\n    float t = max(a.x, max(a.y, a.z));\n    \n    if (t > 1.)\n        return cNew + o / t;\n    else\n        return cOld;\n#else\n    vec3 r = cOld - cNew;\n    vec3 m = (center + halfSize) - cNew;\n    vec3 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n\n\treturn cNew + r;\n#endif\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1;\n    \n    ivec2 sp = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 o = getJitter(iChannel2, fragCoord, iFrame);\n\n#ifdef UNJITTER\n    vec4 curr = texture(iChannel0, (fragCoord - o) / iResolution.xy);\n#else\n    vec4 curr = texture(iChannel0, fragCoord / iResolution.xy);\n#endif\n\n    vec3 new = RGBtoYCoCg(curr.rgb);\n\n#ifdef TEMPORAL_REPROJECT\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = texelFetch(iChannel3, ivec2(0, 0), 0).rgb;\n    vec3 pro = texelFetch(iChannel3, ivec2(1, 0), 0).rgb;\n    \n    vec3 lo = vec3(0, 1, 0);\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    mat3 pmat = getCameraMatrix(pro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    \n    vec3 p = ro + rd * curr.a;\n    \n    vec3 cp = (p - pro) * pmat;\n    vec2 np = 2. * cp.xy / cp.z;\n    vec2 puv = np * vec2(iResolution.y / iResolution.x, 1) * .5 + .5;\n    \n    vec2 o2 = getJitter(iChannel2, puv * iResolution.xy, iFrame) / iResolution.xy;\n    \n    vec3 prd = normalize(pmat * vec3(np, 2));\n    \n    //vec4 hist = texture(iChannel1, puv);\n    //vec4 hist = getTextureSmooth(iChannel1, iResolution.xy, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel1, iResolution.xy, puv);\n    \n    vec3 pp = pro + prd * hist.a;\n    \n#ifdef REJECT_DISOCCLUSION\n    if (puv.x < 0. || puv.x >= 1. || puv.y < 0. || puv.y >= 1.)\n        a = 1.;\n    if (distance(p, pp) > 0.1*curr.a)\n        a = 1.;\n#endif\n\n    vec3 old = RGBtoYCoCg(hist.rgb);\n#else\n    vec3 old = RGBtoYCoCg(texelFetch(iChannel1, sp, 0).rgb);\n#endif\n\n#ifdef VARIANCE_CLIPPING\n    vec3 avg = new;\n    vec3 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec3 tex = RGBtoYCoCg(texelFetch(iChannel0, sp + off[i], 0).rgb);\n    \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec3 sig = sqrt(max(var - avg * avg, vec3(0)));\n    \n    const float g = 1.;\n    vec3 cmin = avg - sig * g;\n    vec3 cmax = avg + sig * g;\n    \n    #if 0\n    vec3 clip = clamp(old, cmin, cmax);\n    #else\n    vec3 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    #endif\n    \n    old = mix(old, clip, 1.);\n#endif\n    \n    vec3 col = iFrame != 0 ? mix(old, new, a) : new;\n#ifdef ENABLE_TAA\n    fragColor = vec4(YCoCgToRGB(col), curr.a);\n#else\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, curr.a);\n#endif\n\n#ifdef SHOW_DISOCCLUSION\n    if (puv.x < 0. || puv.x >= 1. || puv.y < 0. || puv.y >= 1. ||\n        distance(p, pp) > 0.1*curr.a)\n    {\n        fragColor = vec4(1, 0, 0, curr.a);\n    }\n#endif\n\n#ifdef SHOW_MOTION\n    fragColor = vec4((uv - puv) * 10., 0, curr.a);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}