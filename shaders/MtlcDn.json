{
    "Shader": {
        "info": {
            "date": "1504431747",
            "description": "Clubberized port of https://www.shadertoy.com/view/Md3SDB by revers",
            "flags": 0,
            "hasliked": 0,
            "id": "MtlcDn",
            "likes": 12,
            "name": "Re Platonic solids",
            "published": 3,
            "tags": [
                "platonic",
                "solids"
            ],
            "usePreview": 0,
            "username": "wizgrav",
            "viewed": 731
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader uses geometry (except tetrahedron) and camera path from \"Spherical polyhedra\" \n * by nimitz. [ https://www.shadertoy.com/view/4dBXWD ]\n * I must admit that you have used very clever way of modeling platonic solids, mr nimitz :]\n * \n * The rendering is based on \"Transparent Cube Field\" by Shane. \n * [ https://www.shadertoy.com/view/Xds3zN ]\n * Code clear and very well documented (as always), mr Shane :]\n *\n * Thanks for sharing your work, guys!\n *\n * From my side: added glow, tetrahedron and normalized size of the solids to be enclosed inside\n * a fixed size sphere (see \"Circumradius\" parameter).\n * \n * This shader was created and exported from Synthclipse [ http://synthclipse.sourceforge.net/ ].\n */\n\n\n// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R abs(sin(iTime * 1.33))\n#define CLUBBER_G abs(cos(iTime * 0.66))\n#define CLUBBER_B abs(cos(iTime))\n#define CLUBBER_A min(abs(cos(iTime * 0.33)),abs(sin(iTime * 0.66)))\n#endif\n// Clubber end\n\nconst bool GlowEnabled = true;\nfloat Circumradius;\nconst float WallDistance = 0.01;\nconst float GlowDistance = 0.26974;\n\nconst bool Jitter = false;\nconst float MarchDumping = 0.658;\nconst float Far = 5.0;\nconst int MaxSteps = 156;\n\n#define PI 3.141592\n#define RADIANS(x) ((x) * (PI / 180.0))\n\n// https://en.wikipedia.org/wiki/Platonic_solid\n\n#define TETRAHEDRON_DIHEDRAL_ANGLE RADIANS(70.53)\n#define HEXAHEDRON_DIHEDRAL_ANGLE RADIANS(90.0)\n#define OCTAHEDRON_DIHEDRAL_ANGLE RADIANS(109.47)\n#define DODECAHEDRON_DIHEDRAL_ANGLE RADIANS(116.57)\n#define ICOSAHEDRON_DIHEDRAL_ANGLE RADIANS(138.19)\n\n#define TETRAHEDRON_SCHLAFLI_SYMBOL vec2(3.0, 3.0)\n#define HEXAHEDRON_SCHLAFLI_SYMBOL vec2(4.0, 3.0)\n#define OCTAHEDRON_SCHLAFLI_SYMBOL vec2(3.0, 4.0)\n#define DODECAHEDRON_SCHLAFLI_SYMBOL vec2(5.0, 3.0)\n#define ICOSAHEDRON_SCHLAFLI_SYMBOL vec2(3.0, 5.0)\n\n// Hash by iq\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nvec3 rotx(vec3 p, float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\nvec3 roty(vec3 p, float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\nvec3 rotz(vec3 p, float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nfloat cot(float x) {\n\treturn 1.0 / tan(x);\n}\n\nfloat getInradius(vec2 pq, float diha) {\n\tfloat tn = tan(diha * 0.5);\n\tfloat a = 2.0 * Circumradius / (tan(PI / pq.y) * tn);\n\tfloat r = 0.5 * a * cot(PI / pq.x) * tn;\n\n\treturn r;\n}\n\nfloat tetrahedron(vec3 p) {\n\tfloat diha = -RADIANS(180.0 - 70.53); // 180 - \"Dihedral angle\"\n\tfloat tria = -RADIANS(60.0); // triangle angle\n\tfloat inra = getInradius(TETRAHEDRON_SCHLAFLI_SYMBOL, TETRAHEDRON_DIHEDRAL_ANGLE);\n\n\tfloat d = p.x - inra;\n\n\tp = rotz(p, diha);\n\td = max(d, p.x - inra);\n\n\tp = rotx(p, tria);\n\tp = rotz(p, diha);\n\n\td = max(d, p.x - inra);\n\n\tp = rotx(p, -tria);\n\tp = rotz(p, diha);\n\td = max(d, p.x - inra);\n\n\treturn d;\n}\n\n// cube\nfloat hexahedron(vec3 p) {\n\tfloat inra = getInradius(HEXAHEDRON_SCHLAFLI_SYMBOL, HEXAHEDRON_DIHEDRAL_ANGLE);\n\n\tfloat d = abs(p.x) - inra;\n\n\tp = rotz(p, 1.5708); // 90 degrees\n\td = max(d, abs(p.x) - inra);\n\n\tp = roty(p, 1.5708); // 90 degrees\n\td = max(d, abs(p.x) - inra);\n\n\treturn d;\n}\n\nfloat octahedron(vec3 p) {\n\tfloat d = -1e5;\n\n\tfloat inra = getInradius(OCTAHEDRON_SCHLAFLI_SYMBOL, OCTAHEDRON_DIHEDRAL_ANGLE);\n\n\tfor (float i = 0.0; i < 4.0; i++) {\n\t\tp = rotz(p, 1.231); // 70.53110 degrees\n\t\tp = rotx(p, 1.047); // 60 degrees\n\n\t\td = max(d, max(p.x - inra, -p.x - inra));\n\t}\n\treturn d;\n}\n\nfloat dodecahedron(vec3 p) {\n\tfloat d = -1e5;\n\n\tfloat inra = getInradius(DODECAHEDRON_SCHLAFLI_SYMBOL, DODECAHEDRON_DIHEDRAL_ANGLE);\n\n\tfor (float i = 0.0; i <= 4.0; i++) {\n\t\tp = roty(p, 0.81); // 46.40958 degrees\n\t\tp = rotx(p, 0.759); // 43.48750 degrees\n\t\tp = rotz(p, 0.3915); // 22.43130 degrees\n\n\t\td = max(d, max(p.x - inra, -p.x - inra));\n\t}\n\n\tp = roty(p, 0.577); // 33.05966 degrees\n\tp = rotx(p, -0.266); // -15.24068 degrees\n\tp = rotz(p, -0.848); // -48.58682 degrees\n\n\td = max(d, max(p.x - inra, -p.x - inra));\n\n\treturn d;\n}\n\nfloat icosahedron(vec3 p) {\n\tfloat d = -1e5;\n\n\t//center band\n\tconst float n1 = 0.7297; // 41.80873 degrees\n\tconst float n2 = 1.0472; // 60 degrees\n\n\tfloat inra = getInradius(ICOSAHEDRON_SCHLAFLI_SYMBOL, ICOSAHEDRON_DIHEDRAL_ANGLE);\n\n\tfor (float i = 0.0; i < 5.0; i++) {\n\n\t\tif (mod(i, 2.0) == 0.0) {\n\t\t\tp = rotz(p, n1);\n\t\t\tp = rotx(p, n2);\n\t\t} else {\n\t\t\tp = rotz(p, n1);\n\t\t\tp = rotx(p, -n2);\n\t\t}\n\t\td = max(d, max(p.x - inra, -p.x - inra));\n\t}\n\n\tp = roty(p, 1.048); // 60.04598 degrees\n\tp = rotz(p, 0.8416); // 48.22013 degrees\n\tp = rotx(p, 0.7772); // 44.53028 degrees\n\n\t//top caps\n\tfor (float i = 0.0; i < 5.0; i++) {\n\t\tp = rotz(p, n1);\n\t\tp = rotx(p, n2);\n\n\t\td = max(d, max(p.x - inra, -p.x - inra));\n\t}\n\treturn d;\n}\n\nfloat mapShape(vec3 p, float x) {\n    x = CLUBBER_G;\n    return mix(octahedron(p), icosahedron(p), smoothstep(0.33, 0.66,x));\n}\n\nfloat shapeProgress(float t) {\n\treturn 0.;\n}\n\nfloat map(vec3 p) {\n\treturn mapShape(p, shapeProgress(iTime));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\n\tvec3 accu = vec3(0.0);\n\tfloat steps = 0.0;\n\tfloat glowFactor = 0.0;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tsteps = float(i);\n\t\tfloat d = map(ro + rd * t);\n\t\tfloat absd = abs(d);\n\n\t\tif (Jitter) {\n\t\t\tabsd *= 0.8 + hash(absd) * 0.2;\n\t\t}\n\t\tif (t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tglowFactor += pow(1.0 - smoothstep(0.0, GlowDistance, d), 14.0)\n\t\t\t\t* step(0.0, d);\n\t\tfloat f = absd * (1.0 - smoothstep(0.0, WallDistance, absd));\n\t\taccu += vec3(f);\n\n\t\tt += max(0.0002, absd * MarchDumping);\n\t}\n\tglowFactor /= steps * (mix(6.66, 0.66, CLUBBER_B)) ;\n\n\tif (GlowEnabled) {\n\t\taccu += 0.7 * pow(glowFactor, 1.2) * vec3(0.0, 1.0, 1.0);\n\t}\n\treturn accu;\n}\n\nmat2 mm2(in float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n     Circumradius = 0.12 + 0.16 * min(1.0, CLUBBER_R);\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = 2.0 * p - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.0, -1.0);\n\tvec3 rd = normalize(vec3(uv, 3.5));\n\n\tvec2 um = iMouse.xy / iResolution.xy - 0.5;\n\tum.x *= iResolution.x / iResolution.y;\n\n\tmat2 mx = mm2(iTime * 0.75 + um.x * 6.0);\n\tmat2 my = mm2(iTime * 0.77 + um.y * 6.0);\n\tro.xz *= mx;\n\trd.xz *= mx;\n\tro.xy *= my;\n\trd.xy *= my;\n\n\tvec3 col = render(ro, rd);\n\tcol = pow(col, vec3(0.4545));\n\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}