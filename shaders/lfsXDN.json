{
    "Shader": {
        "info": {
            "date": "1705307770",
            "description": "boxSphere normal shade",
            "flags": 0,
            "hasliked": 0,
            "id": "lfsXDN",
            "likes": 1,
            "name": "boxSphere normal shade",
            "published": 3,
            "tags": [
                "boxspherenormalshade"
            ],
            "usePreview": 0,
            "username": "kenshin",
            "viewed": 143
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 150\n#define MIN_DIST  .001\n#define MAX_DIST  100.\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nmat2 rotate2D(float radian)\n{\n    float c = cos(radian);\n    float s = sin(radian);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p)\n{\n    return length(p) - .5;\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y + .5;\n}\n\nfloat sdScene(vec3 p)\n{\n    float s1 = sdSphere(p);\n    p *= .5;\n    float box = sdBox(p, vec3(.15)) / .5;\n    \n    return smin(s1, box, .5);\n}\n\nfloat rayMarching(vec3 ro, vec3 rd)\n{\n    float totalDist = .0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + totalDist * rd;\n        float ds = sdScene(p);\n        totalDist += ds;\n        if(totalDist > MAX_DIST || ds < MIN_DIST) break;\n    }\n    return totalDist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = vec3(sdScene(p));\n    vec2 offset = vec2(.001, .0);\n    n = n - vec3(\n     sdScene(p - offset.xyy),\n     sdScene(p - offset.yxy),\n     sdScene(p - offset.yyx)\n    );\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //mouse\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.;\n    mouse.x *= iResolution.x / iResolution.y;\n    \n    //rotate Camera\n    mat2 rotY = rotate2D(mouse.x * 2.);\n    mat2 rotX = rotate2D(mouse.y * 2.);\n    vec3 ro = vec3(0, 0, -1.2);\n    vec3 rd = normalize(vec3(uv, 1.));\n    ro.xz = rotY * ro.xz;\n    ro.yz = rotX * ro.yz;\n    rd.xz = rotY * rd.xz;\n    rd.yz = rotX * rd.yz; \n    float d = rayMarching(ro, rd);\n    vec3 col = vec3(.0);\n    if(d < MAX_DIST)\n    {\n        vec3 p = ro + d * rd;\n        vec3 n = getNormal(p);\n        col = (n + 1.) / 2.;\n        col = pow(col, vec3(2.2));\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}