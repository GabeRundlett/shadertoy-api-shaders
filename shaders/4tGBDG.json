{
    "Shader": {
        "info": {
            "date": "1543745948",
            "description": "TokyoDemoFest 2018 GLSL Graphics Compo 1st place.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tGBDG",
            "likes": 75,
            "name": "[TDF2018]Traveler 2",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "tdf"
            ],
            "usePreview": 1,
            "username": "kaneta",
            "viewed": 6795
        },
        "renderpass": [
            {
                "code": "#define TAU 6.283185307\n#define PI 3.141592654\n#define HALF_PI 1.5707963267948966\n#define U(z,w) (mix(z,w,step(w.x,z.x)))\n\n#define MAT_WING  1.0\n#define MAT_BODY  2.0\n#define MAT_STAGE 3.0\n\n#define saturate(x) (clamp(x, 0.0, 1.0))\n\n#define BPM (130.)\n\nconst int Iterations = 3;\n\nfloat orgBeat, beat, sceneBeat, kick, hihat, snare;\nfloat stageScale;\nfloat edgeOnly;\nvec3 fogColor;\nmat3 sphereRot, stageRot, stageRot2;\nvec3 ray;\nvec3 ro, ta, sp;\nvec3 cameraLight, stageLight, travelerLight;\nvec3 stageFlareCol, travelerFlareCol;\nfloat stageFlareIntensity, travelerFlareIntensity, stageFlareExp, travelerFlareExp;\nfloat shadeIntensity, glowIntensity, particleIntensity;\nfloat stageFold, stageRotateZ;\nfloat particle1Intensity, particle2Intensity;\nfloat switchTraveler;\nfloat glitchIntensity;\nvec3 glitchColor;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sm(float start, float end, float t, float smo)\n{\n    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);\n}\n\nfloat sm2(float start, float end, float t, float bs, float es)\n{\n    return smoothstep(start, start + bs, t) - smoothstep(end - es, end, t);\n}\n\nvec3 hash3( vec3 p ){\n    vec3 q = vec3(dot(p,vec3(127.1,311.7, 114.5)), dot(p,vec3(269.5,183.3, 191.9)), dot(p,vec3(419.2,371.9, 514.1)));\n    return fract(sin(q)*43758.5453);\n}\n\nmat3 rotateMat(float roll, float pitch, float yaw)\n{\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n\n    return mat3(cp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n                cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n                -sp, sr * cp, cr * cp);\n}\n\nfloat stepUp(float t, float len, float smo)\n{\n    float tt = mod(t += smo, len);\n    float stp = floor(t / len) - 1.0;\n    return smoothstep(0.0, smo, tt) + stp;\n}\n\nfloat pingPong(float t, float len, float smo)\n{\n    t = mod(t + smo, len * 2.);\n    return 1.0 - (smoothstep(0., smo, t) - smoothstep(len, len + smo, t));\n}\n\nfloat glowTime(vec3 p)\n{\n    float t = mix(beat, beat - 45.0, step(44.0, beat));\n    t = mix(t, mod(beat - 53.0, 8.), step(108.0, beat));\n    t = mix(t, beat - 177.0, step(176.0, beat) * step(beat, 184.0));\n    t = mix(t, mod(beat - 177.0, 8.), step(184.0, beat) * step(beat, 224.0));\n    t = mix(t, -1.0, saturate(step(beat, 44.0) + (step(52.0, beat) * step(beat, 108.0)) + step(224.0, beat)));\n    return t;\n}\n\nfloat patternIntensity(vec3 p)\n{\n    float t = beat - 28.0;\n    if (t < 0.0) {\n        return 0.0;\n    }\n    t -= 2.5;\n    float len = distance(sp, p);\n    return sm(0.0, 2.5, mod(len - t * 1.5, 6.0), .5);\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat de(vec3 p, mat3 rot, float scale) {\n    vec3 offset = vec3(1,1,1);\n\n    float freq = 64.0;\n    for (int i=0; i<Iterations; i++) {\n        if (i != 0) {\n            p*=rot;\n        }\n        p = abs(p);\n\n        // 全->横->全->縦->前->縦->ループ\n        float b = mix(beat - 44., beat - 192.0, step(176.0, beat));\n        b = mix(b, 0.0, step(beat, 44.0));\n        b = mix(b, mod(beat, 8.0) + 64.0, step(108.0, beat) * step(beat, 176.0));\n        p.yx = mix(p.yx, p.xy, (1.0 - pingPong(b, freq * 0.25, 1.0)) * step(p.x, p.y));\n        p.xz = mix(p.xz, p.zx, (1.0 - pingPong(b, freq * 0.75, 1.0)) * step(p.x, p.z));\n        p.yz = mix(p.yz, p.zy, (1.0 - saturate(pingPong(mod(b, freq * 0.75), freq * 0.25, 1.0) - step(freq * 0.75 - 1.0, mod(b, freq*0.75)))) * step(p.y, p.z));\n\n        p.z -= 0.5*offset.z*(scale-1.)/scale;\n        p.z = -abs(-p.z);\n        p.z += 0.5*offset.z*(scale-1.)/scale;\n\n        p.xy = scale*p.xy - offset.xy*(scale-1.);\n        p.z = scale*p.z;\n    }\n\n    vec3 d = abs(p) - vec3(1.,1.,1.);\n    float distance = length(vec3(max(d, vec3(0.0))));\n    distance *= pow(scale, -float(Iterations));\n    \n    return distance;\n}\n\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = TAU / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\nvec2 distStage(vec3 p, mat3 rot, float scale)\n{\n    p.xy = (p.xy - 0.75) * rotate(p.z * stageRotateZ) + 0.75;\n    p.xy = foldRotate(p.xy - 0.75, stageFold) + 0.75;\n    p = mod(p, 1.5) - 0.75;\n    float d = de(p, rot, scale);\n    d = mix(d, 100., step(144.0, beat) * step(beat, 176.0));\n    return vec2(d, MAT_STAGE);\n}\n\nvec2 distSphere(vec3 p)\n{\n    float wing = sphere(p, 0.1);\n    float b1 = sdBox(p, vec3(10.0, 0.02, 10.0));\n    float b2 = sdBox(p, vec3(0.02, 10.0, 10.0));\n    float b3 = sdBox(p, vec3(10.0, 10.0, 0.02));\n    float s = sphere(p, 0.098);\n    wing = max(-b1, wing);\n    wing = max(-b2, wing);\n    wing = max(-b3, wing);\n    wing = max(-s, wing);\n\n    vec2 w = vec2(wing, MAT_WING);\n    vec2 body = vec2(sphere(p, 0.08), MAT_BODY);\n    return U(w, body);\n}\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n/*float ifs(vec3 p) {\n    p *= 15.;\n\tfor(int i = 0; i < 3; i++) {\n        p.xy *= rot(0.8 + .8*stepUp(beat + 1.0, 2.0, 0.5));\n        p.xz *= rot(0.4 + .4*stepUp(beat, 2.0, 0.5));\n\t\tp = abs(p);\n\t\tp = 2.0*p - 1.0;\n\t}\n\treturn sdBox(p, vec3(.9))*pow(2.0, -3.0) / 15.0;\n}*/\n\nvec2 distMetaBall(vec3 p)\n{\n    float s1 = sphere((p + vec3(sin(beat) * 0.1, sin(beat) * 0.1, 0.)), 0.05);\n    float s2 = sphere((p + vec3(0., sin(beat * 0.5) * 0.1, sin(beat * 0.5) * 0.1)) , 0.04);\n    float s3 = sphere((p + vec3(sin(beat * 0.25) * 0.1, 0., sin(beat * 0.25) * 0.1)), 0.03);\n    float d = smin(s3, smin(s1, s2, .1), .1);\n    return vec2(d, MAT_WING);\n}\n\nvec2 distTorus(vec3 p)\n{\n    mat3 m1 = rotateMat(beat * 0.1, beat, beat * 0.7);\n    mat3 m2 = rotateMat(beat, beat * 0.5, beat * 0.25);\n    mat3 m3 = rotateMat(beat * 0.3, beat, beat * 0.8);\n    float t1 = sdTorus(p * m1, vec2(0.1, 0.01));\n    float t2 = sdTorus(p * m2, vec2(0.08, 0.005));\n    float t3 = sdTorus(p * m3, vec2(0.06, 0.004));\n    return vec2(min(t3, min(t1, t2)), MAT_WING);\n}\n\nvec2 distBox(vec3 p)\n{\n    float i = sdBox(p, vec3(.06));\n    return vec2(i, MAT_WING);\n}\n\nvec2 distTraveler(vec3 p)\n{\n    return distSphere(p);\n}\n\nvec2 distTraveler2(vec3 p)\n{\n    vec2 d1 = distMetaBall(p);\n    vec2 d3 = distTorus(p);\n    vec2 d2 = distBox(p);\n    float s = mod(stepUp(beat, 6.0, 3.0), 3.0);\n    vec2 d = d1;\n    d.x = mix(d.x, d2.x, saturate(s));\n    d.x = mix(d.x, d3.x, saturate(s - 1.0));\n    d.x = mix(d.x, d1.x, saturate(s - 2.0));\n    return d;\n}\n\nvec2 distAll(vec3 p)\n{\n    vec2 st1 = distStage(p, stageRot, stageScale);\n    vec2 st2 = distStage(p, stageRot2 * stageRot, stageScale);\n    vec2 tr = distTraveler((p - sp) * sphereRot);\n    vec2 tr2 = distTraveler2((p - sp) * sphereRot);\n\n    vec2 trd = tr;\n    trd = mix(trd, tr2, step(0.75 + switchTraveler* 0.1, p.y));\n    trd.x = mix(trd.x, tr2.x, saturate(beat - 208.));\n    trd.x = mix(trd.x, tr.x, saturate(beat - 224.));\n    trd.x *= 0.9;\n\n    float visibleStage = step(176.0, beat) * step(max(beat - 177.0, 0.0) * 1.7, distance(p, sp));\n    st1.x = mix(st1.x, 100.0, visibleStage);\n    st2.x = mix(st2.x, 100.0, visibleStage);\n    return U(trd, U(st1, st2));\n}\n\nvec2 distGlow(vec3 p)\n{\n    vec2 st1 = distStage(p, stageRot, stageScale);\n    vec2 st2 = distStage(p, stageRot2 * stageRot, stageScale);\n\n    float gt = glowTime(p);\n\n    float frontSp = sphere(p - sp, gt + 1.);\n    float backSp = sphere(p - sp, gt);\n    float cut = max(frontSp, -backSp);\n    vec2 st = U(st1, st2);\n    st.x = max(st.x, cut);\n    return st;\n}\n\nfloat distCubeParticle(vec3 pos)\n{\n    pos.y -= beat * 0.25;\n    vec3 id = floor(pos / 1.);\n    pos = mod(pos, 1.) - 0.5;\n    vec3 rnd = hash3(id) * 2.0 - 1.0;\n    mat3 rot = rotateMat(rnd.x * beat * 2.0, rnd.y * beat * 2.0, rnd.z * beat * 2.0);\n    float d = sdBox((pos + rnd * 0.25) * rot, vec3(.025));\n    d = mix(d, .5, step(rnd.x, -0.7));\n    return d;\n}\n\nfloat distSphereParticle(vec3 pos)\n{\n    pos.y -= beat * 0.4;\n    vec3 id = floor(pos / 0.4);\n    pos = mod(pos, 0.4) - 0.2;\n    vec3 rnd = hash3(id) * 2.0 - 1.0;\n    mat3 rot = rotateMat(rnd.x * beat * 2.0, rnd.y * beat * 2.0, rnd.z * beat * 2.0);\n    float d = sphere((pos * rot + rnd * 0.1), 0.01);\n    d = mix(d, .1, step(rnd.x, 0.0));\n    return d;\n}\n\n/*\nvec3 normal(vec3 pos, float e)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize( vec3(\n           distAll(pos+eps.xyy).x - distAll(pos-eps.xyy).x,\n           distAll(pos+eps.yxy).x - distAll(pos-eps.yxy).x,\n           distAll(pos+eps.yyx).x - distAll(pos-eps.yyx).x ) );\n}\n*/\n\nvec3 normal( in vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*distAll( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*distAll( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*distAll( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*distAll( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<8; i++ )\n    {\n        float h = distAll( ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.05, 0.2 );\n        if( res<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat sdRect( vec2 p, vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y),0.0) + length(max(d,0.0));\n}\n\nfloat tex(vec2 p, float z)\n{\n    vec2 q = (fract(p / 10.0) - 0.5) * 10.0;\n    float d = 9999.0;\n    for (int i = 0; i < 3; ++i) {\n        q = abs(q) - 0.5;\n        q *= rot(0.785398);\n        q = abs(q) - 0.5;\n        q *= rot(z * 0.5);\n        float k = sdRect(q, vec2(1.0, 0.55 + q.x));\n        d = min(d, k);\n    }\n    float f = 1.0 / (1.0 + abs(d));\n    return pow(f, 16.0) + smoothstep(0.95, 1.0, f);\n}\n\nvec3 light(vec3 pos, vec3 normal, vec3 ray, vec3 col, vec3 lpos, vec3 diffuse, vec3 specular, float smoothness)\n{\n    vec3 lvec = normalize(lpos - pos);\n    vec3 hvec = normalize(lvec - ray);\n    float llen = length(lpos - pos);\n    vec3 diff = diffuse * col * (dot(normal, lvec) * 0.5 + 0.5)  * (1.0 / PI);\n\n    float bpnorm = ( smoothness + 2.0 ) / ( 2.0 * PI );\n    vec3 spec = specular * col * bpnorm * pow( max( 0.0, dot( normal, hvec ) ), smoothness );\n\n    return vec3(diff + spec) / (llen * llen);\n}\n\nvec3 shade(vec3 pos, vec3 normal, vec3 ray, vec3 diffuse, vec3 specular, float smoothness)\n{\n    vec3 col = light(pos, normal, ray, cameraLight * 2.0, ro, diffuse, specular, smoothness);\n    col += light(pos, normal, ray, stageLight, ro + vec3(0.0, 0.0, 2.0), diffuse, specular, smoothness);\n    return col;\n}\n\nvec3 rgb2hsv(vec3 hsv)\n{\n\tvec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(vec3(hsv.x) + t.xyz) * 6.0 - vec3(t.w));\n\treturn hsv.z * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), hsv.y);\n}\n\nvec3 materialize(vec3 ro, vec3 ray, float depth, vec2 mat)\n{\n    vec3 pos = ro + ray * depth;\n    vec3 nor = normal(pos, 0.0025);\n    vec3 spLocalNormal = normalize((pos - sp) * sphereRot);\n    vec3 col = vec3(0.);\n\n    vec3 coord = mix(19.3602379925 * spLocalNormal, pos * 9.3602379925, step(MAT_BODY, mat.y));\n    vec3 pattern = vec3(tex(coord.zy, 113.09),  tex(coord.xz, 113.09),  tex(coord.xy, 113.09));\n\n    if (mat.y == MAT_WING) {\n        float wing_pattern = saturate(pattern.x + pattern.y + pattern.z);\n        vec3 cameraLightCol = light(pos, nor, ray, cameraLight * 2.0, ro, vec3(.1), vec3(.1), mix(5.0, 100.0, wing_pattern));\n        vec3 stageLightCol = light(pos, nor, ray, stageLight, ro + vec3(0.0, 0.0, 2.0), vec3(.1), vec3(.1), mix(5.0, 100.0, wing_pattern));\n        col += cameraLightCol + stageLightCol;\n\n        col += vec3(1.0, 0.25, 0.35) * 1.3 * wing_pattern * (cos(beat * 0.5) * 0.5 + 1.0);\n    } else if (mat.y == MAT_BODY) {\n        col += vec3(1.0, 0.25, 0.35) * 1. * saturate(cos(beat * 0.5) * 0.5 + 1.0);\n    } else if (mat.y == MAT_STAGE) {\n        vec3 lpos = ro + vec3(0.0, 0.0, 2.0);\n        vec3 lvec = normalize(lpos - pos);\n\n        vec3 cameraLightCol = light(pos, nor, ray, cameraLight * 2.0, ro, vec3(1.), vec3(1.), 25.);\n        vec3 stageLightCol = light(pos, nor, ray, stageLight, ro + vec3(0.0, 0.0, 2.0), vec3(1.), vec3(1.), 25.);\n        float sha = (softshadow(pos, lvec, 0.01, length(lpos - pos), 4.0) + mix(.2, .4, step(160.0, beat)));\n\n        // ステージが出現する演出\n        float noShade = 0.0;\n        noShade = step(distance(pos, sp), sceneBeat) * step(45.0, beat);\n\n        float wing_pattern = pow(saturate(pattern.x + pattern.y + pattern.z), 1.5) * 1.2;\n        col += ((cameraLightCol + stageLightCol * sha + light(pos, nor, ray, travelerLight, sp, vec3(1.), vec3(1.), mix(25., 100., step(176.0, beat)))) * edgeOnly * noShade + max(wing_pattern, 0.0) * (mix(vec3(0.1,0.2,0.4), rgb2hsv(vec3(pos.z * 1.0 + beat * 0.1, .85, 1.5)), step(160.0, beat))) * 4.0 * patternIntensity(pos)) * glowIntensity;\n    }\n\n    return mix(col, fogColor, pow(depth * 0.018, 2.1));\n}\n\nvec3 glowTrace(vec3 ro, vec3 ray, float maxDepth)\n{\n    float t = 0.0;\n    vec3 col = vec3(0.);\n    for (int i = 0; i < 16; i++) {\n        vec3 p = ro+ray*t;\n        float len = distance(sp, p);\n        float gt = glowTime(p);\n\n        // 光らせたくないときは-1.0を返してる\n        if (gt < 0.0) {\n            break;\n        }\n\n        vec3 h = hash3(floor(p * 30.0) / 30.0) * 2.0 - 1.0;\n        float val = 1.0 - sm(gt, gt + 2.0, len, .25);\n        // TODO: smでバラバラ感を制御しているが思った挙動じゃないので調査する\n        vec2 res = distGlow(p + h * 0.15 * val);\n        col += saturate(0.002 / res.x) * rgb2hsv(vec3(p.x * 1., 0.8, 1.0));\n        t += res.x;\n        if (maxDepth < t) {\n            break;\n        }\n    }\n    return col;\n}\n\n\nvec4 particleTrace(vec3 ro, vec3 ray, float maxDepth)\n{\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n\tfor (int i = 0; i < 48; i++)\n\t{\n        vec3 p = ro+ray*t;\n        float d = distSphereParticle(p);\n        col += max(vec3(0.0), particle1Intensity / d * vec3(1.0, 0.5, 0.5));\n        t += d * 0.5;\n        if (maxDepth < t) {\n            break;\n        }\n\t}\n\treturn vec4(saturate(col), t);\n}\n\nvec4 particle2Trace(vec3 ro, vec3 ray, float maxDepth)\n{\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n\tfor (int i = 0; i < 48; i++)\n\t{\n        vec3 p = ro+ray*t;\n        float d = distCubeParticle(p);\n        col += max(vec3(0.0), particle2Intensity / d * vec3(0.0, 0.5, 1.0));\n        t += d * 0.25;\n        if (maxDepth < t) {\n            break;\n        }\n\t}\n\treturn vec4(saturate(col), t);\n}\n\nvec4 trace(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    float stepIntensity = 0.0;\n    vec2 res;\n    for (int i = 0; i < 80; i++) {\n        vec3 p = ro+ray*t;\n        res = distAll(p);\n        if( res.x < 0.0001 || t > 100.0) {\n            stepIntensity = float(i) / 64.0;\n            break;\n        }\n        t += res.x;\n    }\n    vec3 p = ro + ray * t;\n    float val = patternIntensity(p);\n    vec3 sg1 = pow(stepIntensity * 1.0, 5.0) * vec3(.2, .4, .8) * val * 5.;\n    vec3 sg2 = pow(stepIntensity * 1.0, 1.0) * vec3(1., 0., 0.) - pow(stepIntensity * 1.0, 2.0) * vec3(0., 1., 1.);\n    vec3 sg3 = pow(stepIntensity * 1.0, 1.0) * vec3(0., 0.5, .75);\n    float v = saturate((beat - 236.0) / 4.0);\n    float v2 = 1.0 - saturate((beat - 239.5) / 1.5);\n    float v3 = saturate((beat - 232.0) / 8.0);\n    return vec4(saturate(materialize(ro, ray, t, res) + sg1 * shadeIntensity - mix(vec3(0.), sg3 * 2.0 * v2, v3) + mix(vec3(0.), sg2 * 2.0 * v2, v)), t);\n}\n\nvoid initBeat(float b)\n{\n    sceneBeat = b;\n\n    kick = mod(sceneBeat, 1.);\n    hihat = sceneBeat < 16.0 ? 0.0 : pingPong(sceneBeat + 0.5, 1.0, 0.1) * 0.1;\n    snare = sceneBeat < 32.0 ? 0.0 : stepUp(sceneBeat - 32.5, 2.0, 0.5);\n}\n\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*43758.5453) * 2.0 - 1.0;\n}\n\nvec2 fbm_hash( vec2 x )\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( fbm_hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( fbm_hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( fbm_hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( fbm_hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 uv, float s)\n{\n    uv *= s;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    return f * 0.5 + 0.5;\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat elasticOut(float t) {\n\treturn sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat exponentialInOut(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat exponentialIn(float t) {\n\treturn t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialOut(float t) {\n\treturn t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvec3 scene(vec2 p)\n{\n\n    float cameraF = sin(beat * 0.25);\n    float scene0Beat = beat;\n    float scene1Beat = beat - 12.;\n    float scene2Beat = beat - 44.;\n    float scene3Beat = beat - 124.;\n    float scene4Beat = beat - 176.;\n\n    float cscene0to1 = step(12.0, beat);\n    float cscene1to2 = exponentialOut(saturate(beat - 44.));\n    float cscene2_1to2_2 = saturate((beat - 108.0) / 16.0);\n    cscene2_1to2_2 = quadraticInOut(cscene2_1to2_2 * cscene2_1to2_2);\n    float cscene3to4 = quadraticInOut(saturate((beat - 172.0) / 4.0));\n    float cscene3to4_2 = exponentialOut(saturate((beat - 176.0) / 1.0));\n\n    float scene2to3FadeOut = saturate((beat - 140.0) / 4.0 );\n\n    ////// Traveler //////\n    float toffset = max(0.0, beat - 239.5) * 0.7;\n    sp = mix(vec3(0.75, 0.75, mix(-20.0, 20.0, beat / 16.0)), vec3(0.75, 0.75, 0.2 + beat * 0.25 + toffset), cscene0to1);\n    //travelerInit(vec3(0.75, 0.75, 0.2 + beat * 0.25 + toffset));\n    //////////////////////\n\n    ////// Camera //////\n    vec3 scene0CameraPos = vec3(0.9, 0.8, 0.0);\n    vec3 scene1CameraPos = sp + vec3(sin(scene1Beat * 0.475) * 0.3 + cameraF * 0.05, .15 + cameraF * 0.05, cos(scene1Beat * 0.475) * 0.3 + cameraF * 0.05);\n    vec3 scene2CameraPos = sp + vec3(sin(scene2Beat * 0.2) * 0.15, cos(scene2Beat * 0.4) * 0.05 + 0.05, cos(scene2Beat * 0.15 + PI) * 0.05 - 0.2);\n    vec3 scene3CameraPos = sp + vec3(cos(scene1Beat * 0.25) * 0.7 + cameraF * 0.05, .15 + cameraF * 0.05, sin(scene1Beat * 0.25) * 0.5 + cameraF * 0.05);\n\n    float cb = scene1Beat - 4.0;\n    vec3 scene4CameraPos = sp + vec3(sin(cb * 0.2) * 0.15, cos(cb * 0.4) * 0.05 + 0.05, cos(cb * 0.15 + PI) * 0.05 - 0.2);\n\n    vec3 scene0CameraTarget = vec3(0.75, 0.75, 1.0);\n    vec3 scene1CameraTarget = sp;\n    vec3 scene2CameraTarget = sp + vec3(0.0, 0.0, (sin(scene2Beat * 0.05) * 0.5 + 0.5) * 3.0);\n    vec3 scene3CameraTarget = sp;\n    vec3 scene4CameraTarget = sp + vec3(0.0, 0.0, (sin(scene2Beat * 0.05) * 0.5 + 0.5) * 3.0);\n\n    float scene0CameraAngle = 0.0;\n    float scene1CameraAngle = sin(beat * 0.5) * 0.1;\n\n    float scene0CameraFov = 3.0;\n    float scene1CameraFov = 2.5;\n    float scene2_1CameraFov = 1.0;\n    float scene2_2CameraFov = 3.5;\n    float scene3_1CameraFov = 1.0;\n    float scene3_2CameraFov = 3.5;\n    float scene3_3CameraFov = 3.5;\n    float scene3_4CameraFov = 1.5;\n    float scene4CameraFov = 0.45;\n\n    vec2 rnd = hash(vec2(beat * 0.5)) * 0.05;\n    rnd *= saturate(max(0.0, 1.0 - distance(scene0CameraPos, sp) / 3.0) * (1.0 - cscene0to1) +\n                     saturate((beat - 234.0) / 6.0) * (1.0 - saturate(beat - 240.0)));\n\n    ro = mix(scene0CameraPos + vec3(rnd, 0.0), scene1CameraPos, cscene0to1);\n    ro = mix(ro, scene2CameraPos, cscene1to2);\n\n    // scene2 side camera\n    float cscene2to2_1 = exponentialInOut(saturate((beat - 61.0) / 4.0));\n    float cscene2to2_2 = exponentialInOut(saturate((beat - 65.0) / 9.0));\n    float cscene2to2_3 = exponentialInOut(saturate((beat - 67.0) / 8.0));\n    float cscene2to2_3_2 = exponentialInOut(saturate((beat - 67.0) / 12.0));\n    vec3 scene2_1SidePos = sp + mix(vec3(30.0, 1.0, -10.0), vec3(1.0, .0, 1.0), cscene2to2_1);\n    vec3 scene2_2SidePos = sp + mix(vec3(1.0, 0.0, 1.0), vec3(sin(-beat * 3. + 0.8) * 1.25, 0.0, cos(-beat * 3. + 0.8)), cscene2to2_2);\n    ro = mix(ro, scene2_1SidePos, cscene2to2_1);\n    ro = mix(ro, scene2_2SidePos, cscene2to2_2);\n    ro = mix(ro, scene2CameraPos, cscene2to2_3);\n    ////\n\n    // scene2 vertical camera\n    float cscene2to2_4 = exponentialInOut(saturate((beat - 96.0) / 4.0));\n    float cscene2to2_5 = exponentialInOut(saturate((beat - 100.0) / 8.0));\n    vec3 scene2VerticalPos = sp + mix(vec3(1.0, 30.0, -10.0), vec3(0.1, sin(-beat * 0.5) * 2., cos(-beat * 0.5)) * 2., cscene2to2_4);\n    ////\n\n    ro = mix(ro, scene2VerticalPos, cscene2to2_4);\n    ro = mix(ro, scene2CameraPos, cscene2to2_5);\n\n    ro = mix(ro, scene3CameraPos, cscene2_1to2_2);\n    ro = mix(ro, scene4CameraPos + vec3(rnd * 2.0, 0.0) - vec3(0., 0., toffset), cscene3to4);\n\n    ta = mix(scene0CameraTarget + vec3(rnd * 2.0, 0.0), scene1CameraTarget, cscene0to1);\n    ta = mix(ta, scene2CameraTarget, cscene1to2);\n\n    // scene2 side camera\n    ta = mix(ta, sp, cscene2to2_1);\n    ta = mix(ta, scene2CameraTarget, cscene2to2_3_2);\n    ////\n\n    // scene2 vertical camera\n    ta = mix(ta, sp, cscene2to2_4);\n    ta = mix(ta, scene2CameraTarget, cscene2to2_5);\n    ////\n\n    ta = mix(ta, scene3CameraTarget, cscene2_1to2_2);\n    ta = mix(ta, scene4CameraTarget + vec3(rnd, 0.0), cscene3to4_2);\n\n    float fov = mix(scene0CameraFov, scene1CameraFov, cscene0to1);\n    fov = mix(fov, scene2_1CameraFov, cscene1to2);\n\n    // scene2 vertical camera\n    fov = mix(fov, 1.0, cscene2to2_4);\n    fov = mix(fov, scene2_1CameraFov, cscene2to2_5);\n    ////\n\n    fov = mix(fov, scene2_2CameraFov, cscene2_1to2_2);\n\n    float scene2_2to3_1FovAnim = elasticOut(quadraticInOut(saturate((beat - 144.0) / 1.0)));\n    fov = mix(fov, scene3_1CameraFov, scene2_2to3_1FovAnim);\n\n    float scene3_1to3_2FovAnim = exponentialInOut(saturate((beat - 148.0) / 12.0));\n    fov = mix(fov, scene3_2CameraFov, scene3_1to3_2FovAnim);\n    fov = mix(fov, scene3_3CameraFov, cscene3to4);\n    fov = mix(fov, scene3_4CameraFov, cscene3to4);\n    fov = mix(fov, scene4CameraFov, cscene3to4_2);\n\n    float cameraAng = mix(scene0CameraAngle, scene1CameraAngle, cscene0to1);\n\n    mat3 cm = createCamera(ro, ta, cameraAng);\n    ray = cm * normalize(vec3(p, fov));\n    ////////////////////\n\n    ////// Fog //////\n    vec3 scene0Fog = vec3(0.0);\n    vec3 scene2Fog = vec3(8., 16., 32.);\n    vec3 scene3Fog = vec3(0.0);\n    vec3 scene4Fog = vec3(8., 16., 32.);\n\n    float scene0to1Fog = saturate((beat - 46.0) * 0.5);\n    float scene3to4Fog = saturate((beat - 184.0) * 0.5);\n    fogColor = mix(scene0Fog, scene2Fog, scene0to1Fog);\n    fogColor = mix(fogColor, scene3Fog, scene2to3FadeOut);\n    fogColor = mix(fogColor, scene4Fog, scene3to4Fog);\n    /////////////////\n\n    ////// Flare //////\n    float scene0StageFlareIntensity = 0.0;\n    float scene2StageFlareIntensity = 0.5;\n    float scene3StageFlareIntensity = 0.0;\n    float scene4StageFlareIntensity = 0.45;\n\n    float scene0StageFlareExp = 1.0;\n    float scene2StageFlareExp = 7.5;\n    float scene4StageFlareExp = 2.0;\n\n    float scene0TravelerFlareIntensity = max(0.2, cos(sceneBeat * 0.5) * 0.5 + 0.5);\n    float scene1TravelerFlareIntensity = max(0.2, cos(beat * 0.5) * 0.5 + 0.5);\n\n    float scene0TravelerFlareExp = mix(1.0, 800.0, distance(ro, sp) / 10.0);\n    float scene1TravelerFlareExp = 8.0;\n\n    stageFlareCol = vec3(.3, .6, 1.2);\n    travelerFlareCol = vec3(1., .25, .35);\n\n    float scene3to4Flare = saturate((beat - 176.0) / 4.0);\n\n    stageFlareIntensity = mix(scene0StageFlareIntensity, scene2StageFlareIntensity, scene0to1Fog);\n    stageFlareIntensity = mix(stageFlareIntensity, scene3StageFlareIntensity, scene2to3FadeOut);\n    stageFlareIntensity = mix(stageFlareIntensity, scene4StageFlareIntensity, scene3to4Flare);\n\n    stageFlareExp = mix(scene0StageFlareExp, scene2StageFlareExp, cscene0to1);\n    stageFlareExp = mix(stageFlareExp, scene4StageFlareExp, scene3to4Flare);\n\n    travelerFlareIntensity = mix(scene0TravelerFlareIntensity, scene1TravelerFlareIntensity, cscene0to1);\n\n    travelerFlareExp = mix(scene0TravelerFlareExp, scene1TravelerFlareExp, cscene0to1);\n    ///////////////////\n\n    ////// Light //////\n    vec3 scene0CameraLight = vec3(.005);\n    vec3 scene4CameraLight = vec3(0.04, 0.06, 0.08) * 0.2;\n\n    vec3 scene0StageLight = vec3(.0);\n    vec3 scene2StageLight = vec3(0.2, 0.4, 0.8);\n    vec3 scene3StageLight = vec3(0.);\n    vec3 scene4StageLight = vec3(0.4, 0.8, 1.6) * 2.;\n\n    cameraLight = mix(scene0CameraLight, scene4CameraLight, cscene3to4_2);\n\n    stageLight = mix(scene0StageLight, scene2StageLight, cscene1to2);\n    stageLight = mix(stageLight, scene3StageLight, scene2to3FadeOut);\n    stageLight = mix(stageLight, scene4StageLight, cscene3to4_2);\n    ///////////////////\n\n    ////// Edge //////\n    edgeOnly = mix(0.0, 1.0, cscene1to2);\n    //////////////////\n\n    ////// Particle //////\n    particleIntensity = mix(0.0, 1.0, saturate((beat - 145.0) * 10.0));\n\n    float particleAnim = saturate((beat - 145.0) / 4.0 );\n    particle1Intensity = mix(0.003, 0.0002, particleAnim);\n    particle2Intensity = mix(0.016, 0.0007, particleAnim);\n    //////////////////////\n\n    ////// Shade //////\n    shadeIntensity = mix(1.0, 0.0, scene2to3FadeOut);\n    shadeIntensity = mix(shadeIntensity, 1.0, cscene3to4);\n    ///////////////////\n\n    ////// Glow //////\n    glowIntensity = mix(1.0, 0.0, scene2to3FadeOut);\n    glowIntensity = mix(glowIntensity, 1.0, cscene3to4);\n    //////////////////\n\n    ////// Last Stage //////\n    stageFold = mix(1.0, stepUp(scene4Beat, 64. * 0.25, 1.0) * 4.0 + 5.0 + stepUp(max(0.0, beat - 244.0), 1.0, 0.2) * 10.0, cscene3to4_2);\n    stageRotateZ = mix(0.0, 1.0 - pingPong(scene4Beat, 64. * 0.25, 1.0), cscene3to4_2);\n    ////////////////////////\n\n    ////// Traveler Light //////\n    travelerLight = mix(vec3(.02, 0.004, 0.004) * 0.8, vec3(.02, .004, .004) * 1.5, cscene3to4_2);\n    ////////////////////////////\n\n    ////// Beat //////\n    float bb = mix(scene1Beat, scene2Beat, cscene1to2);\n    initBeat(bb);\n    /////////////////\n\n    ////// stage //////\n    stageScale = 3.4 - mix(0.00, 0.25, clamp(kick, 0.0, 1.0));\n    stageRot = rotateMat(0.1-hihat,-hihat, 0.4-hihat);\n    vec3 angle = mod(vec3(snare * 1.3, snare * 0.27, snare * 0.69), vec3(TAU) * 0.5);\n    stageRot2 = rotateMat(angle.x, angle.y, angle.z);\n    sphereRot = rotateMat(sin(beat * 0.5),cos(beat * 0.5), sin(beat * 0.5 * .33));\n    ///////////////////\n\n    vec4 c = trace(ro, ray);\n    c.rgb += glowTrace(ro, ray, c.w + 0.01) * glowIntensity;\n    vec4 p1 = particleTrace(ro, ray, c.w);\n    vec4 p2 = particle2Trace(ro, ray, c.w);\n    c.rgb += p1.rgb * particleIntensity;\n    c.rgb = mix(c.rgb + p2.rgb * particleIntensity, mix(p2.rgb, fogColor, pow(p2.w * 0.04, 2.1)), saturate(p2.g) * particleIntensity);\n    return c.rgb;\n}\n\n// https://www.shadertoy.com/view/MdfBRX\nfloat Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)\n{\n    float d = length(p - sp);\n    float c = smoothstep(size, size*(1.-blur), d);\n    c *= mix(mi, 1., smoothstep(size*.8, size, d));\n    return c;\n}\n\nvec3 dirt(vec2 uv, float n)\n{\n    vec2 p = fract(uv * n);\n    vec2 st = (floor(uv * n) + 0.5) / n;\n    vec2 rnd = hash(st);\n    float c = Bokeh(p, vec2(0.5, 0.5) + vec2(0.3) * rnd, 0.2, abs(rnd.y * 0.4) + 0.3, 0.25 + rnd.x * rnd.y * 0.2);\n    \n    return vec3(c) * exp(rnd.x * 4.0);\n}\n\nvec3 postProcess(vec2 uv, vec3 col)\n{   \n    uv *= 0.5;\n    \n    vec3 di = dirt(uv, 3.5);\n    di += dirt(uv - vec2(0.17), 3.0);\n    di += dirt(uv- vec2(0.41), 2.75);\n    di += dirt(uv- vec2(0.3), 2.5);\n    di += dirt(uv - vec2(0.47), 3.5);\n    di += dirt(uv- vec2(0.21), 4.0);\n    di += dirt(uv- vec2(0.6), 4.5);\n\n    float flare = pow(max(0.0, dot(vec3(0.0, 0.0, 1.0), ray)), stageFlareExp * 1.25);\n    float flare2 = pow(max(0.0, dot(vec3(0.0, 0.0, 1.0), ray)), stageFlareExp);\n    vec3 f = flare * stageFlareCol + flare2 * di * stageFlareCol * 0.05;\n    \n    float sflare = pow(max(0.0, dot(normalize(sp - ro), ray)), travelerFlareExp * 1.25);\n    float sflare2 = pow(max(0.0, dot(normalize(sp - ro), ray)), travelerFlareExp);\n    vec3 s = sflare * travelerFlareCol + sflare2 * di * travelerFlareCol * 0.05;\n    \n    return col + f * stageFlareIntensity + s * travelerFlareIntensity;\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat Logo1(vec3 p)\n{\n    float d = 99999.9;\n    d = min(d, triPrism((p + vec3(2.75, -8.0, 0.0)) * vec3(0.76, 1.0, 1.0), vec2(11.45, 0.0)));\n    d = min(d, triPrism((p + vec3(-11.6, -13.8, 0.0)) * vec3(0.76, -1.0, 1.0), vec2(11.45, 0.0)));\n    d = min(d, triPrism((p + vec3(16.9, -13.8, 0.0)) * vec3(0.76, -1.0, 1.0), vec2(11.45, 0.0)));\n    return d;\n}\n\n\nfloat Logo2(vec3 p)\n{\n    float d = 99999.9;\n    d = min(d, triPrism((p + vec3(5.7, -10.05, 0.0)) * vec3(0.76, 1.0, 1.0), vec2(6.85, 0.0)));\n    d = min(d, triPrism((p + vec3(-17.0, -10.8, 0.0)) * vec3(0.76, -1.0, 1.0), vec2(8.45, 0.0)));\n    return d;\n}\n\nfloat gage(vec2 p)\n{\n    float d = 99999.9;\n    p.x += 2.8;\n    p.y += 0.1;\n    d = min(d, sdRect(p, vec2(14.0, 1.0)));\n\n    float t = clamp((iTime + 30.) / 30.0 * 13.8, 0.0, 13.8);\n    p.x -= t;\n    d = max(d, -sdRect(p, vec2(13.8 - t, 0.8)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float t = iTime - 0.;\n    orgBeat = t * BPM / 60.0;\n    \n    float b = orgBeat;\n    b = mix(b, 226.0 + mod(orgBeat * 2.0, 0.5), step(228.0, orgBeat) * step(orgBeat, 228.5));\n    b = mix(b, 229.0 + mod(orgBeat * 2.0, 0.5), step(231.0, orgBeat) * step(orgBeat, 231.5));\n    b = mix(b, 227.0 + mod(orgBeat * 2.0, 0.5), step(232.0, orgBeat) * step(orgBeat, 232.5));\n    b = mix(b, 238.3 + mod(orgBeat * 4.0, 1.0), step(238.0, orgBeat) * step(orgBeat, 244.0));\n    t = b * 60.0 / BPM;\n    \n    beat = (t + hash(p).x * 0.0065 * (1.0 - saturate((orgBeat - 230.0) / 4.0)) * step(12., orgBeat)) * BPM / 60.0;\n\n    switchTraveler = mix(2.0, -2.0, saturate(sm(126.0, 172.0, orgBeat, 8.0)));\n    glitchIntensity = step(44.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 44.0)) +\n                                 step(144.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 144.0)) +\n                                 step(176.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 176.0)) +\n                                 step(228.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 228.0)) +\n                                 step(231.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 231.0)) +\n                                 step(232.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 232.0)) +\n                                 sm2(234.0, 242.65, orgBeat, 4.0, 0.5);\n    glitchColor = vec3(1.0);\n\n    //// Glitch ////\n\n    vec2 block = floor((p * vec2(100, 400.0)) / vec2(16));\n    vec2 uv_noise = block / vec2(64);\n    uv_noise += floor(vec2(t) * vec2(1234.0, 3543.0)) / vec2(64);\n\n    float block_thresh = pow(fract(t * 1236.0453), 2.0) * .5;\n    float line_thresh = pow(fract(t * 2236.0453), 3.0) * .6;\n\n    vec2 noise1 = hash(uv_noise) * 0.5 + 0.5;\n    vec2 noise2 = hash(vec2(uv_noise.y, 0.0)) * 0.5 + 0.5;\n\n    if  (noise1.r < block_thresh ||\n        noise2.g < line_thresh) {\n        float intensity = 1.0 - smoothstep(0.3, 1.0, length(p));\n        intensity *= sm(-0.4 + switchTraveler, 0.4 + switchTraveler, p.y, 0.1);\n        intensity = saturate(intensity + glitchIntensity);\n        vec2 dist = (fract(uv_noise) - 0.5) * intensity;\n        fragCoord.x -= dist.x * 350.1 * intensity;\n        fragCoord.y -= dist.y * 350.2 * intensity;\n        vec3 h = hash3(vec3(fract(uv_noise) - 0.5, 0.0)) * 2.0;\n        glitchColor = mix(vec3(1.0), h, intensity);\n    }\n    ////////////////\n\n    p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //// shutdown effect ////\n    float ttt = (orgBeat - 242.0) * 4.;\n    float val = min(150.0, mix(mix(mix(1.0, 5.0, saturate(exponentialIn(ttt))), 1.1, saturate(exponentialOut(ttt - 1.0))), 2000.0, saturate(exponentialIn(ttt - 2.0))));\n    val = mix(val, 2000.0, saturate(ttt - 3.00));\n    p.y *= val;\n    p.x *= mix(mix(1.0, 3.0, saturate(exponentialOut(ttt - 1.0))), 0.1, saturate(exponentialOut(ttt - 2.0)));\n    ////////////////////////\n\n    vec2 size = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 pp = p + (vec2(fbm(vec2(beat * 0.1), 1.0), fbm(vec2(beat * 0.1 + 114.514), 1.0)) * 2.0 - 1.0) * .65;\n    vec3 col =  scene(pp) * glitchColor;\n\n    col = postProcess(p, col);\n    col = saturate(col);\n    \n    //// Nega-Posi ////\n    col = mix(col, 1.0 - col, step(228.0, orgBeat) * step(orgBeat, 228.5));\n    col = mix(col, 1.0 - col, step(231.0, orgBeat) * step(orgBeat, 231.5));\n    col = mix(col, 1.0 - col, step(232.0, orgBeat) * step(orgBeat, 232.5));\n    col = mix(col, 1.0 - col, step(242.0, orgBeat) * step(orgBeat, 244.0));\n    ///////////////////\n\n    //// vignet ////\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 200.0;\n    vig = pow(vig, 0.1);\n    col = saturate(pow(col, vec3(1.0 / 2.2))) * vig;\n    ///////////////\n\n    col = mix(col, vec3(1.), saturate((beat - 251.0) / 4.0));\n    col = mix(col, vec3(0.), saturate((beat - 256.0) / 2.0));\n\n    //// loading screen ////\n    vec2 ppp = p;\n    p *= 12.5 * 1.33333333;\n    p+= vec2(-1.55, 9.5);\n\n    float logo1 = 1.0 - smoothstep(0.0, 0.1, Logo1(vec3(p, 0.0)));\n    float logo2 = 1.0 - smoothstep(0.0, 0.1, Logo2(vec3(p, 0.0)));\n    float g = 1.0 - smoothstep(0.0, 0.1, gage(p));\n\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(1.0, 1.5, t));\n    col = mix(col, vec3(0.23), logo1 * (1.0 - smoothstep(2.0, 3.3, t)));\n    col = mix(col, vec3(0.85, 0.35, 0.35), logo2 * (1.0 - smoothstep(2.0, 3.3, t)));\n    col = mix(col, vec3(0.85, 0.35, 0.35), g * (1.0 - smoothstep(1.0, 1.5, t)));\n    ///////////////////////\n\n    col = mix(col, vec3(1.), smoothstep(1.9, 2.0, ttt));\n    col = mix(col, vec3(0.), saturate(step(size.y, ppp.y) + step(ppp.y, -size.y) + step(size.x, ppp.x) + step(ppp.x, -size.x) + step(3.3, ttt)));\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}