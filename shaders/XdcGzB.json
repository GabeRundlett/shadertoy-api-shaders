{
    "Shader": {
        "info": {
            "date": "1450361697",
            "description": "Using a numerical gradient to produce smooth \"fract\" contours on 2D simplex-based noise... I'm having difficulty describing this one. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "XdcGzB",
            "likes": 29,
            "name": "2D Noise Contours",
            "published": 3,
            "tags": [
                "gradient",
                "simplex",
                "fract",
                "smooth"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 3328
        },
        "renderpass": [
            {
                "code": "/*\n\n\t2D Noise Contours\n\t-----------------\n\n\tUsing a numerical gradient to produce smooth \"fract\" contours on 2D simplex-based noise.\n\n\tTaking a regular function value (noise, Voronoi, plasma, etc), then appying something like \n\t\"fract(value*5.)\" can give it some interesting contour-like variance. The problem, of \n\tcourse, is pretty severe antialising. Here's an attempt to rectify that without resorting \n\tto expensive methods.\t\n\n\tThe contour lines are relatively smooth and concise, regardless of the shape of the curve. \n\tThere are probably better ways to go about it (I'd be happy to hear about any), but this \n\tmethod works pretty well.\n\n\tIn addition, I've written a reasonaly simple 2D simplex-related noise algorithm to accompany\n\tthis. It probably doesn't adhere to strict simplex noise standards, but it looks the part, \n\tand is artifact\tfree -- as far as I can tell, so it's good enough for me. :) It also provides \n\ta good basis for cheap 3D simplex related noise.\n\n\tI wrote the simplex-like algorithm off the top of my head ages ago, so I wouldn't take it \n\ttoo seriously. For what I'm assuming is more reliable, concisely written, 2D simplex noise, \n\trefer to this example:\n\n\tSimplified Simplex Noise - Makio64\n\thttps://www.shadertoy.com/view/4sdGD8\n\n    See IQ's distance estimation example for a good explanation regarding the gradient related\n\tcontour snippet:\n\n    Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    There's an accompanying articles, which is really insightful here:\n    https://iquilezles.org/articles/distance\n\n\tAnother, more simple, example, concentrating more on the contours.\n\tSmooth, Defined Contours - Shane\n\thttps://www.shadertoy.com/view/Md33RB\n\n*/\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) { \n    \n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(2097152, 262144)*n);\n    return cos(p*6.283 + iTime*2.);\n    //return abs(fract(p+ iTime*.5)-.5)*4.-1.; // Snooker.\n    //return abs(cos(p*6.283 + iTime*2.))*2.-1.; // Bounce.\n\n}\n\n\n// For all intents and purposes, this is low quality, 2D simplex noise. I've skipped a few steps, \n// so don't want to give people the impression that this is a computer science quality algorithm.\n// Therefore, I've named it simplesque2D... Terrible name, I know. :)\n//\n// Essentially, you're taking a square grid, converting it to a skewed triangular grid, assigning \n// random values to the vertices via some random gradient vectors, then shading the triangles in \n// using a falloff factor. It's a very simple - not to mention, clever - concept (Ken Perlin's a \n// clever guy), but a little fiddly to code first time around.\n//\n// By the way, the 3D version follows virtually the same concept, just with a few extra steps.\n//\n// Credits: Ken Perlin, the creator of simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified.\" IQ, other \"ShaderToy.com\" people, Brian Sharpe (does interesting \n// work), etc.\n//\n// My favorite simplex-related write up: \"Simplex Noise, keeping it simple.\" - Jasper Flick?\n// http://catlikecoding.com/unity/tutorials/simplex-noise/\n//\nfloat simplesque2D(vec2 p){\n    \n    vec2 s = floor(p + (p.x + p.y)*.3660254); // Skew the current point.\n    p -= s - (s.x + s.y)*.2113249; // Vector to unskewed base vertice.\n    \n    // Clever way to perform an \"if\" statement to determine which of two triangles we need.\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: step(p.x, p.y);\n    \n    vec2 ioffs = vec2(1. - i, i); // Vertice offset, based on above.\n    \n    // Vectors to the other two triangle vertices.\n    vec2 p1 = p - ioffs + .2113249, p2 = p - .5773502; \n    \n    // Vector to hold the falloff value of the current pixel with respect to each vertice.\n    vec3 d = max(.5 - vec3(dot(p, p), dot(p1, p1), dot(p2, p2)), 0.); // Range [0, 0.5]\n    \n    d *= d*d*12.; //(2*2*2*1.5) \n    //d *= d*d*d*36.;\n    \n    // I've seen it done this way before, and it gives a good range, but gradients look a \n    // little strange to me... I guess it's down to aesthetic opinion.\n    //d = d*d*d*(6.*d*d - 15.*d + 10.); // Quintic smoothing.\n    //d /= dot(d, vec3(1));\n    \n    // Determining the weighted contribution of each random gradient vector for each point...\n    // Something to that effect, anyway.\n    vec3 w = vec3(dot(hash22(s), p), dot(hash22(s +  ioffs), p1), dot(hash22(s + 1.), p2)); \n    \n    // Combining the vectors above to produce a simplex noise value. Explaining why the vector \"d\" \n    // needs to be cubed (at least) could take a while, but it's falloff related and ties in with \n    // differentiation. If you take out one of the \"d\"s, you'll see that it needs to be cubed to work.\n    return .5 + dot(w, d); // Range [0, 1]... Hopefully. Needs more attention.\n\n}\n\n/* \n// Short smooth value noise version, to keep Fabrice happy. ;-)\nfloat n(vec2 p) {\n    vec2 ip = fract(p); p -= ip; p *= p*(3.- p - p); \n    vec4 h = fract(sin(vec4(0, 7, 27, 34) + ip.x*7. + ip.y*27.)*5e5);\n\t//h = sin(h*6.283 + iTime)*.5 + .5;\n\treturn dot(vec2(1. - p.y, p.y), vec2(1. - p.x, p.x)*mat2(h));\n}\n*/\n \n\n// Standard smooth 2D value noise. Based on IQ's original.\n// This one is self contained, so there's no need for an outside hash function.\nfloat valueNoise2D(vec2 p) {\n\t\n\tvec2 f = fract(p); // Fractional cell position.\n    \n    f *= f*(3. -2.*f);// Smooth step\n    //f = f*f*f*(10. + f*(6.*f - 15.)); // Smoother smooth step.\n    //f = (1. - cos(f*3.14159265))*.5; // Cos smooth step\n\t\n    // Random values for all four cell corners.\n\tvec4 h = fract(sin(vec4(0, 41, 289, 330) + dot(floor(p), vec2(41, 289)))*43758.5453);\n\th = sin(h*6.283 + iTime)*.5 + .5; // Animation.\n\t//h = abs(fract(h+iTime*.125) - .5)*2.; // More linear animation.\n\t\n    // Interpolating the random values to produce the final value.\n\treturn dot(vec2(1. - f.y, f.y), vec2(1. - f.x, f.x)*mat2(h));\n    \n}\n\n// 2D function we'll be producing the contours for. \nfloat func2D(vec2 p){\n    \n    //return valueNoise2D(p*6.)*.66 + valueNoise2D(p*12.)*0.34;\n    \n    return simplesque2D(p*4.)*.66 + simplesque2D(p*8.)*0.34;\n    \n}\n\n// Smooth fract function. A bit hacky, but it works. Handy for all kinds of things.\n// The final value controls the smoothing, so to speak. Common sense dictates that \n// tighter curves, require more blur, and straighter curves require less. The way \n// you do that is by passing in the function's curve-related value, which in this case\n// will be the function value divided by the length of the function's gradient.\n//\n// IQ's distance estimation example will give you more details:\n// Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n// There's an accompanying article, which is really insightful, here:\n// https://iquilezles.org/articles/distance\nfloat smoothFract(float x, float sf){\n \n    x = fract(x);\n    \n    return min(x, x*(1.-x)*sf);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n\n    // Standard epsilon, used to determine the numerical gradient. \n    vec2 e = vec2(0.001, 0); \n\n    // The 2D function value. In this case, it's a couple of layers of 2D simplex-like noise.\n    // In theory, any function should work.\n    float f = func2D(uv); // Range [0, 1]\n    \n    // Length of the numerical gradient of the function above. Pretty standard. Requires two extra function\n    // calls, which isn't too bad.\n    float g = length( vec2(f - func2D(uv-e.xy), f - func2D(uv-e.yx)) )/(e.x);\n   \n    // Dividing the function by the length of its gradient. Related to IQ's distance estimation example:\n    // Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    g = f/max(g, 0.001);\n    //g = 0.5/max(g, 0.001); // A constant numerator seems to work, too, but I'll stick to the formula.\n    \n    // This is the crux of the shader. Taking a function value and producing some contours. In this case,\n    // there are six. If you don't care about aliasing, it's as simple as: c = fract(f*6.);\n    // If you do, and who wouldn't, you can use the following method. For a quick explanation, refer to the \n    // \"smoothFract\" function.\n    //\n    // For a very good explanation, see IQ's distance estimation example:\n    // Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    //\n    // There's an accompanying articles, which is really insightful, here:\n\t// https://iquilezles.org/articles/distance\n    float c = smoothFract(f*6., g*iResolution.y/4.); // Range [0, 1]\n    //float c = fract(f*6.); // Aliased version, for comparison.\n    \n    // Convert \"c\" above to the greyscale color.\n    vec3 col = vec3(c);\n    \n    // Color in a couple of the 6 contours above. Not mandatory, but it's pretty simple, and an interesting \n    // way to pretty up functions. I use it all the time.\n    f *= 6.;\n    \n    // You could almost ignore the \"tx\" business. It's just a subtle, higher frequency pattern to overlay \n    // the two colors with. Made up on the spot.\n    float tx = smoothstep(0.0, 0.8, (func2D((uv + (1. - c)*.01)*vec2(12., 48.)))); // Range: [0, 1]\n    if(f>2. && f<3.) col *= vec3(1., 0.0, 0.02)*(tx); // Red.\n    else if(f>4. && f<5.) col *= vec3(0.15, 0.05, 1)*(tx); // Blue.\n    else col *= abs(tx - .5)*.4 + .8; // White.\n   \n    /*\n    // Other things to try. Each require textures. Be sure to comment out the four line block above too.\n    // Organic 1 texture.\n    vec3 tx3 = texture(iChannel0, uv*4. + (1.-c)*.05).xyz; tx3 *= tx3;\n    if(f>2. && f<3.) col *= tx3;\n    if(f>4. && f<5.) col *= tx3.zyx;\n\t*/\n   \n    /*\n    // Organic 1 texture.\n    vec3 tx3 = texture(iChannel0, uv*4. + (1.-c)*.05).xyz; tx3 *= tx3;\n    float tx = dot(tx3, vec3(.299, .587, .114));\n    if(f>2. && f<3.) col *= pow(min(vec3(1.5, 1, 1)*tx, 1.), vec3(1, 3, 8.))*1.3;\n    if(f>4. && f<5.) col *= vec3(tx*tx*tx, tx*tx, tx)*1.3; \n    */\n     \n    \n\t// Since we have the gradient related value, we may as well use it for something. In this case, we're \n    // adding a bit of highlighting. It's calculated for the contourless noise, so doesn't match up perfectly,\n    // but it's good enough. Comment it out to see the texture on its own. \n    col += min(g*g*g*g*.1, 1.)*(1.-col);\n    \n    //col = vec3(g/1.5); // Just the gradient. Looks like plastic wrap.\n\t\n    // Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.0 );\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}