{
    "Shader": {
        "info": {
            "date": "1579293967",
            "description": "When you need stable world space noise. Paper link in the comments.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlG3zK",
            "likes": 15,
            "name": "Hashed Alpha Test",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 749
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\n// uncomment to use procedural noise\n//#define PROCEDURAL\n// uncomment to use screen-space derivatives\n//#define SCREENSPACE\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// anti-aliased and mipmapped nearest neighbor sampling\nvec4 myTexture(vec3 uv, vec3 dpdx, vec3 dpdy) {\n    vec3 res = vec3(32);\n    uv = uv*res + 0.5;\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    vec3 aa = (abs(dpdx)+abs(dpdy))*res*0.5;\n    fr = smoothstep( vec3(0.5)-aa, vec3(0.5)+aa, fr);\n    uv = (fl+fr-0.5) / res;\n    return textureGrad(iChannel0, uv, dpdx, dpdy);\n}\n\n// https://research.nvidia.com/sites/default/files/pubs/2017-02_Hashed-Alpha-Testing/Wyman2017Hashed.pdf\nconst float hashScale = 1.0;\nfloat hashedNoise(vec3 p, vec3 dpdx, vec3 dpdy) {\n    float maxDeriv = max(length(dpdx), length(dpdy));\n    float pixScale = 1.0 / (hashScale*maxDeriv);\n    vec2 pixScales = exp2(floor(log2(pixScale))) * vec2(1,2);\n    \n    #ifdef PROCEDURAL\n    vec2 alpha = vec2(hash33(floor(pixScales.x*p.xyz)).r, hash33(floor(pixScales.y*p.xyz)).r);\n    #else\n    float aa = myTexture(pixScales.x*p.xyz/32.0, pixScales.x*dpdx/32.0, pixScales.x*dpdy/32.0).r;\n    float bb = myTexture(pixScales.y*p.xyz/32.0, pixScales.y*dpdx/32.0, pixScales.y*dpdy/32.0).r;\n    vec2 alpha = vec2(aa, bb);\n    #endif\n    \n    float lerpFactor = fract( log2(pixScale) );\n    float x = mix( alpha.x, alpha.y, lerpFactor );\n    float a = min( lerpFactor, 1.0-lerpFactor );\n    vec3 cases = vec3( x*x/(2.0*a*(1.0-a)),(x-0.5*a)/(1.0-a),1.0-((1.0-x)*(1.0-x)/(2.0*a*(1.0-a))) );\n    float alphaRes = (x < (1.0-a)) ? ((x < a) ? cases.x : cases.y) :cases.z;\n    alphaRes = clamp(alphaRes, 0.0, 1.0);\n    return alphaRes;\n}\n\n// https://iquilezles.org/articles/filteringrm\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, \n                out vec3 dpdx, out vec3 dpdy ) {\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\nfloat noise( in vec3 x ) {\n    return textureLod(iChannel0, x/32.0, 0.0).r;\n}\n\nfloat height(vec2 p) {\n   \treturn (\n        noise(vec3(p, 0))*4.0 +\n        noise(vec3(p*4.124, 10))*0.5 +\n        noise(vec3(p*8.124, 100))*0.25)*0.3;\n}\n\nfloat de(vec3 p) {\n    vec2 inPill = mod(p.xz, 3.0)-1.5;\n    float pill = length(inPill)-0.1;\n    return min(pill, p.y - height(p.xz));\n}\n\nvec3 getNormal(vec3 p) {\n\tvec3 e = vec3(0.0, 0.03, 0.0);\n\treturn normalize(vec3(\n\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\tde(p+e.xxy)-de(p-e.xxy)));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\t\n\tvec3 from = vec3(0, 1, -5);\n\tvec3 dir = normalize(vec3(uv*0.4, 1.0));\n    \n\tvec2 mouse=(iMouse.xy - iResolution.xy*0.5) / iResolution.y * 2.5;\n    if (iMouse.z < 0.5) mouse = vec2(0, -0.4);\n\tmat2 rotxz = rot(-mouse.x+iTime*0.2);\n\tmat2 rotxy = rot(mouse.y);\n\tdir.zy  *= rotxy;\n\tdir.xz  *= rotxz;\n    from.zy *= rotxy;\n\tfrom.xz *= rotxz;\n\n\tfloat totdist = 0.0;\n\tfor (int steps = min(iFrame, 0) ; steps < 200 ; steps++) {\n\t\tvec3 p = from + totdist * dir;\n        float dist = de(p);\n\t\ttotdist += dist*0.5;\n        if (totdist < 0.0001 || totdist > 20.0) {\n        \tbreak;   \n        }\n\t}\n    \n    vec3 p = from + totdist * dir;\n    vec3 n = getNormal(p);\n    n += (hash33(vec3(fragCoord, iFrame))-0.5)*0.1;\n    n = normalize(n);\n    vec3 dpdx = vec3(0);\n    vec3 dpdy = vec3(0);\n    #ifndef SCREENSPACE\n    calcDpDxy(from, dir, dir+dFdx(dir), dir+dFdy(dir), totdist, n, dpdx, dpdy);\n    #else\n    dpdx = dFdx(p);\n    dpdy = dFdy(p);\n    #endif\n    \n    \n    \n    fragColor = vec4(hashedNoise(p, dpdx, dpdy));\n    return;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}