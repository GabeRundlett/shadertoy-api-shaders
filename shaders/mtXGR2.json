{
    "Shader": {
        "info": {
            "date": "1672474034",
            "description": "▶️Demo Video:\nhttps://youtu.be/r4oCbazujmY\n\nReferences:\n[1]Cloudy Shapes by kaneta\n[2]Heartfelt by BigWIngs\n[3]Heart SDF Base Code by gracegi",
            "flags": 32,
            "hasliked": 0,
            "id": "mtXGR2",
            "likes": 45,
            "name": "JenKai Liu “The Reversal”",
            "published": 3,
            "tags": [
                "raymarching",
                "volumetriccloud"
            ],
            "usePreview": 0,
            "username": "JenKaiLiu",
            "viewed": 749
        },
        "renderpass": [
            {
                "code": "// 【Raindrop amount】0. ~ 1.\n#define RAINAMOUNT 0.25\n\n\n\n\n// [2]Raindrop filter\n// https://www.shadertoy.com/view/ltffzl\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define USE_POST_PROCESSING\n\nfloat weight(float x){\n\treturn 1.0-x*x*x*x;\n}\n\nvoid mainBlur( out vec4 fragColor, in vec2 fragCoord ,float focus)\n{\n    float thresh = 1.;//depth threshold\n    vec2 dir = vec2(0.1,-0.1);//blur direction\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n\n    float dist = focus;\n    float totalw = .0;\n    \n    vec3 color = vec3(0,0,0);\n    for (int i=0; i<=20; i++){\n        vec2 p = uv;\n        float fi = float(i-10)/10.0;\n        p.xy+=dir*fi*dist;\n        \n        float w = weight(fi);\n        \n    \tvec4 c = texture(iChannel0,p);\n        if (dist>=c.a){\n            w*=max(.0,1.0-(dist-c.a)/thresh);\n        }\n        color += c.xyz*w;\n        totalw+=w;\n    }\n    color/=totalw;\n\tfragColor = vec4(color,dist);\n}\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\nvec2 DropLayer2(vec2 uv, float t) {\n    vec2 UV = uv;\n    \n    uv.y += t*0.75;\n    vec2 a = vec2(6., 1.);\n    vec2 grid = a*2.;\n    vec2 id = floor(uv*grid);\n    \n    float colShift = N(id.x); \n    uv.y += colShift;\n    \n    id = floor(uv*grid);\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n    float x = n.x-.5;\n    \n    float y = UV.y*20.;\n    float wiggle = sin(y+sin(y));\n    x += wiggle*(.5-abs(x))*(n.z-.5);\n    x *= .7;\n    float ti = fract(t+n.z);\n    y = (Saw(.85, ti)-.5)*.9+.5;\n    vec2 p = vec2(x, y);\n    \n    float d = length((st-p)*a.yx);\n    \n    float mainDrop = S(.4, .0, d);\n    \n    float r = sqrt(S(1., y, st.y));\n    float cd = abs(st.x-x);\n    float trail = S(.23*r, .15*r*r, cd);\n    float trailFront = S(-.02, .02, st.y-y);\n    trail *= trailFront*r*r;\n    \n    y = UV.y;\n    float trail2 = S(.2*r, .0, cd);\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n    y = fract(y*10.)+(st.y-.5);\n    float dd = length(st-vec2(x, y));\n    droplets = S(.3, 0., dd);\n    float m = mainDrop+droplets*r*trailFront;\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.;\n    return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\n    vec2 p = (n.xy-.5)*.7;\n    float d = length(uv-p);\n    \n    float fade = Saw(.025, fract(t+n.z));\n    float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n    return c;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = StaticDrops(uv, t)*l0; \n    vec2 m1 = DropLayer2(uv, t)*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t)*l2;\n    \n    float c = s+m1.x+m2.x;\n    c = S(.3, 1., c);\n    \n    return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    vec3 M = iMouse.xyz/iResolution.xyz;\n    float T = iTime+M.x*2.;  \n    float t = T*.2;\n    \n    float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7; // 雨水濃度\n    rainAmount = RAINAMOUNT;\n    \n    float maxBlur = mix(3., 6., rainAmount);\n    float minBlur = 2.;   \n    float story = 0.;\n  \n    float staticDrops = S(-.5, 1., rainAmount)*2.;\n    float layer1 = S(.25, .75, rainAmount);\n    float layer2 = S(.0, .5, rainAmount);\n       \n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n\n    vec2 e = vec2(.001, 0.);\n    float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n    float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n    vec2 n = vec2(cx-c.x, cy-c.x);\t\t// expensive normals\n   \n    float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n    focus = 1.-clamp(pow(focus,1.5)/15.,0.,1.); // 模糊程度，clamp到0~1\n    vec3 col = textureLod(iChannel0, UV+n, focus).rgb;\n    vec4 fragcol = vec4(col,1.);\n    mainBlur(fragcol,fragCoord, focus*rainAmount);\n    //col *= fragcol.rgb; 模糊\n    //col =  vec3(focus*rainAmount);\n    \n    #ifdef USE_POST_PROCESSING\n    //t = (T+3.)*.5;\t\t\t\t\t\t\t\t\t\t// make time sync with first lightnoing\n    //float colFade = sin(t*.2)*.5+.5+story;\n    //col *= mix(vec3(1.), vec3(.8, .9, 1.3), colFade);\t// subtle color shift\n    float fade = S(0., 10., T);\t\t\t\t\t\t\t// fade in at the start\n    \n    //float lightning = sin(t*sin(t*10.));\t\t\t\t// lighting flicker\n    //lightning *= pow(max(0., sin(t+sin(t))), 10.);\t\t// lightning flash\n    //col *= 1.+lightning*fade*mix(1., .1, story*story);\t// composite lightning\n    //col *= fade*mix(1., .1, story*story);\t// composite lightning\n    \n    //col *= 1.-dot(UV-=.5, UV);\t\t\t\t\t\t\t// vignette    \t\t\t\t\t\t\t\t\t\t\t   \n    //col *= fade;\t\t\t\t\t\t\t\t\t\t// composite start and end fade\n    #endif\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 【How the sky looks】\n// 0: Cloudy\n// 1: Rainy\n// 2: Sunny\n#define LOOK 2\n\n\n\n\n// [1]\n// Cloud simulation  \n// https://www.shadertoy.com/view/WdXGRj\n\n// noise\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n/////////////////////////////////////\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// [3]Heart SDF\n// https://www.shadertoy.com/view/3ldXD7\nfloat sdHeart( vec3 p, float t )\n{\n    float y = 1.3 * p.y - abs(p.x) * sqrt(1.0 - abs(p.x));\n    vec3 p2 = vec3(p.x, y, p.z);\n    return length(p2) - t;\n}\n\n\nfloat map( in vec3 p )\n{\n    float n_speed = 0.5; // 雲霧noise變化速度 _________ default: 1., Bad Wheather: 0.5,\n\tvec3 q = p - vec3(0.0,0.5,1.0)*iTime*n_speed;\n    float f = fbm(q);\n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n    \n    vec3 cp = p;\n    cp.yz *= Rot(0.25);\n    float cloud = 1.0 - length(cp * vec3(0., 5., 0.12)+ vec3(0.0, -2.5, 0.7)) + f * 3.5;\n    cloud = 1.0 - length(p * vec3(0.1, 1., 0.2)) + f * 2.2;\n    //float cloud = 1.0 - length(cp * vec3(0., 5., 0.12)+ vec3(0.0, -2.5, 0.7)) + f * 3.5;\n    \n    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\n    float s3 = 1.0 - smin(smin(\n                           length(p * 1.0 - vec3(cos(iTime * 3.0) * 6.0, sin(iTime * 2.0) * 5.0, 0.0)),\n                           length(p * 2.0 - vec3(0.0, sin(iTime) * 4.0, cos(iTime * 2.0) * 3.0)), 4.0),\n                           length(p * 3.0 - vec3(cos(iTime * 2.0) * 3.0, 0.0, sin(iTime * 3.3) * 7.0)), 4.0) + f * 2.5;\n    \n    // Heart SDF function:\n    vec3 hp = p/3.5;\n    float sadHeart = 1. - sdHeart(hp, 0.7)*8.+ f * 4.5;\n    \n    \n    vec3 smp = hp;\n    smp.xy *= Rot(0.3+sin(iTime+2.)*0.05);\n    smp.xz *= Rot(0.2);\n    smp.zy *= Rot(0.5);\n    float smilehHeart = 1. - sdHeart(smp, 0.7)*8.+ f *1.5;\n    smp = hp;\n    smp.xy *= Rot(-0.2+sin(iTime)*0.05);\n    float smilehHeart2 = 1. - sdHeart(smp-vec3(-0.6,-0.1,0.8), 0.15)*8.+ f *1.;    \n    smp = hp;\n    smp.xy *= Rot(0.9);\n    smp.xz *= Rot(iTime);\n    float smilehHeart3 = 1. - sdHeart(smp-vec3(-0.9,0.5,0.5), 0.02)*15.+ f *2.;\n    smp = hp;\n    smp.xy *= Rot(-1.);\n    smp.yz *= Rot(-0.5);\n    smp.xz *= Rot(-iTime-1.);\n    float smilehHeart4 = 1. - sdHeart(smp-vec3(-0.9,0.5,0.2), 0.02)*15.+ f *2.;\n    \n    vec3 fp = p;\n    fp.yz *= Rot(-0.2);\n    s1 = 1.0 - length(fp * vec3(0.4, 8.0, 1.1)+vec3(0.,23.,-2.8)) + f * 5.5;\n    float smile = max(max(max(max(smilehHeart,smilehHeart2),smilehHeart3),smilehHeart4),s1);\n    \n    \n    float t = mod(stepUp(iTime, 3.0, 1.0), 3.0);\n    \n\tfloat d = mix(smile, sadHeart, clamp(t, 0.0, 1.0));\n    d = mix(d, cloud, clamp(t - 1.0, 0.0, 1.0));\n    d = mix(d, smile, clamp(t - 2.0, 0.0, 1.0));\n    \n    // A to B\n\t//d = mix(sadHeart, cloud, clamp(t, 0.0, 1.0));\n    //d= cloud;\n    //d = smilehHeart;\n    //d= cloud;\n\treturn min(max(0.0, d), 1.0);\n}\n\nfloat jitter;\n\n#if LOOK==2\n#define MAX_STEPS 48  // marching步數，越大噪點越少 _________ default: 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 2. // 越小雲霧明暗對比越大 _________ default: 2.\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n    \n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n            sum.a *= 1.-density;\n\n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n#endif  \n\n#if LOOK==1\n#define MAX_STEPS 128  // marching步數，越大噪點越少 _________ default: 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 1.25 // 越小雲霧明暗對比越大 _________ default: 2.\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n            \n            float DensityStrength = 100.; // 雲霧密度，數值越大立體感越明顯 _________ default: 20.\n            density = clamp((d / float(MAX_STEPS)) * DensityStrength, 0.0, 1.0);\n            \n            \n            vec3 HighlightColor = vec3(0.946,0.980,1.000) *1.1; // 雲霧高光顏色 _________ default: vec3(1.1, 0.9, .5)         \n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.5);\n            sum.rgb += vec3(s * density) * HighlightColor * sum.a;\n            sum.a *= 1.-density;\n            \n            vec3 DiffuseColor = vec3(-0.01); // 雲霧底色 _________ default: vec3(0.15, 0.45, 1.1)       \n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * DiffuseColor * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n#endif  \n\n#if LOOK==0\n#define MAX_STEPS 128  // marching步數，越大噪點越少 _________ default: 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 1.25 // 越小雲霧明暗對比越大 _________ default: 2.\n\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n            \n            float DensityStrength = 100.; // 雲霧密度，數值越大立體感越明顯 _________ default: 20.\n            density = clamp((d / float(MAX_STEPS)) * DensityStrength, 0.0, 1.0);\n            \n            \n            vec3 HighlightColor = vec3(1.); // 雲霧高光顏色 _________ default: vec3(1.1, 0.9, .5)         \n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            sum.rgb += vec3(s * density) * HighlightColor * sum.a;\n            sum.a *= 1.-density;\n            \n            vec3 DiffuseColor = vec3(0.0); // 雲霧底色 _________ default: vec3(0.15, 0.45, 1.1)       \n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * DiffuseColor * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n#endif  \n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n#if LOOK==2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(476.45 * .333) * 8.0, -2.5, sin(476.45 * .333) * 8.0);\n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    vec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y + 0.75) * (col.a);\n    vec3 sunPos = vec3(2., 3.5, -2.); // 太陽光位置 _________\n    float sundot = clamp(dot(ray,normalize(sunPos)),0.0,1.0);\n    result += 1.7*vec3(0.9,0.624,0.)*pow( sundot, 14.0 ); // 太陽光顏色 _________\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);\n}\n#endif  \n#if LOOK==1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(476.45 * .333) * 8.0, -2.5, sin(476.45 * .333) * 8.0); // 相機位置 _________ default: vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0)  \n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    \n    vec3 lowerSkyColor = vec3(0.1,0.140,0.15); // 下半天空顏色 _________ default: vec3(0.3, 0.6, 1.0) Logo: vec3(0.98,0.98,1.0)\n    vec3 upperSkyColor = vec3(0.2,0.240,0.25); // 上半天空顏色 _________ default: vec3(0.05, 0.35, 1.0) Logo:vec3(0.73,0.81,0.81)\n    \n    vec3 result = col.rgb + mix(lowerSkyColor, upperSkyColor, p.y + 0.75) * (col.a);\n    \n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);  \n}\n#endif  \n#if LOOK==0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(476.45 * .333) * 8.0, -2.5, sin(476.45 * .333) * 8.0); // 相機位置 _________ default: vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0)  \n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    \n    vec3 lowerSkyColor = vec3(0.98,0.98,1.0); // 下半天空顏色 _________ default: vec3(0.3, 0.6, 1.0)\n    vec3 upperSkyColor = vec3(0.73,0.81,0.81); // 上半天空顏色 _________ default: vec3(0.05, 0.35, 1.0)\n    \n    vec3 result = col.rgb + mix(lowerSkyColor, upperSkyColor, p.y + 0.75) * (col.a);\n    \n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);\n}\n#endif  ",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}