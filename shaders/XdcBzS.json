{
    "Shader": {
        "info": {
            "date": "1525568958",
            "description": "Ray Tracing in 2D",
            "flags": 0,
            "hasliked": 0,
            "id": "XdcBzS",
            "likes": 10,
            "name": "Ray Tracing 2D",
            "published": 3,
            "tags": [
                "raymarching",
                "raytrace",
                "spheretracing"
            ],
            "usePreview": 0,
            "username": "alijaya",
            "viewed": 988
        },
        "renderpass": [
            {
                "code": "#define u_resolution iResolution\n#define u_mouse iMouse.xy\n#define u_time iTime\n\nconst int MAX_ITER = 100;\nconst float MAX_DIST = 1000.;\nconst float EPS = .1;\n\nconst float TAU = 2. * acos(-1.);\n\nvec2 camera_pos = vec2(-100., -100.);\nvec2 camera_target = vec2(20., 20.);\nfloat camera_fov = TAU / 5.;\nconst int camera_ray = 10;\nfloat camera_gamma = 4.;\n\nmat3 world;\nvec2 mouse_gl;\n\nvec2 ori;\nvec2 dir;\n\nfloat h_fov;\nvec2 fov1;\nvec2 fov2;\n\nvec2 dir_left;\nvec2 plane1;\nvec2 plane2;\n\nfloat sdf_u(float a, float b) {\n    return min(a, b);\n}\n\nfloat sdf_i(float a, float b) {\n    return max(a, b);\n}\n\nfloat sdf_s(float a, float b) {\n    return max(a, -b);\n}\n\nfloat sdf_circle(vec2 coord, float r) {\n    return length(coord) - r;\n}\n\nfloat sdf_rect(vec2 coord, vec2 s) {\n    vec2 d = abs(coord) - s/2.;\n    return sdf_i(d.x, d.y);\n}\n\nfloat sdf_grid(vec2 coord, vec2 s, float w) {\n    vec2 f = mod(coord, s);\n    return -sdf_rect(f - s/2., s - w);\n}\n\nfloat sdf_line(vec2 coord, vec2 a, vec2 b, float w) {\n    vec2 v = b - a;\n    vec2 nv = normalize(v);\n    float proj = dot(nv, coord - a);\n    proj = min(length(v), max(0., proj));\n    vec2 p = proj * nv + a;\n    return distance(coord, p) - w/2.;\n}\n\nfloat sdf_ray(vec2 coord, vec2 ori, vec2 dir, float w) {\n    vec2 nv = normalize(dir);\n    float proj = dot(nv, coord - ori);\n    proj = max(0., proj);\n    vec2 p = proj * nv + ori;\n    return distance(coord, p) - w/2.;\n}\n\nmat3 inv_t(vec2 t) {\n    t = -t;\n    return mat3(\n        1., 0., 0.,\n        0., 1., 0.,\n        t.x, t.y, 1.\n    );\n}\n\nmat3 inv_r(float r) {\n    r = -r;\n    return mat3(\n        cos(r), sin(r), 0.,\n        -sin(r), cos(r), 0.,\n        0., 0., 1.\n    );\n}\n\nmat3 inv_s(vec2 s) {\n    s = 1./s;\n    return mat3(\n        s.x, 0., 0.,\n        0., s.y, 0.,\n        0., 0., 1.\n    );\n}\n\nmat3 inv_mat(vec2 t, float r, vec2 s) {\n    return inv_s(s) * inv_r(r) * inv_t(t);\n}\n\nvec2 mult(mat3 mat, vec2 pos) {\n    return vec2(mat * vec3(pos, 1.));\n}\n\nvec2 ray2ray(vec2 ori1, vec2 dir1, vec2 ori2, vec2 dir2) {\n    vec2 d = ori2 - ori1;\n    float det = dir2.x * dir1.y - dir2.y * dir1.x;\n    float u = (d.y * dir2.x - d.x * dir2.y) / det;\n\tfloat v = (d.y * dir1.x - d.x * dir1.y) / det;\n    return vec2(u, v);\n}\n\nfloat scene(vec2 coord) {\n    // float obj = sdf_rect(coord, vec2(100., 50.));\n    float obj = sdf_grid(coord, vec2(20.), 2.);\n    vec2 circle = mult(inv_mat(vec2(50., 100. + sin(u_time) * 100.), 0., vec2(1.)), coord);\n    obj = sdf_circle(circle, 20.);\n    vec2 rect = mult(inv_mat(vec2(-50., 100.), u_time, vec2(1.)), coord);\n    obj = sdf_u(obj, sdf_rect(rect, vec2(20., 50.)));\n    return obj;\n}\n\nvec4 debug(float scene) {\n    return vec4(fract(scene/20.));\n}\n\nfloat toSolid(float scene) {\n    return smoothstep(-1., 1., -scene);\n}\n\nvec4 solid(float scene) {\n    return vec4(toSolid(scene));\n}\n\nvoid update(vec2 res, vec2 mouse) {\n    world = inv_mat(res/2., 0., vec2(1.));\n    mouse_gl = mult(world, mouse);\n    \n    camera_target = mouse_gl;\n    ori = camera_pos;\n    dir = normalize(camera_target - camera_pos);\n    \n    h_fov = camera_fov / 2.;\n    fov1 = mult(inv_mat(vec2(0.), h_fov, vec2(1.)), dir);\n    fov2 = mult(inv_mat(vec2(0.), -h_fov, vec2(1.)), dir);\n    \n    dir_left = vec2(-dir.y, dir.x);\n    plane1 = dir_left * ray2ray(camera_target, dir_left, ori, fov1).x + camera_target;\n    plane2 = dir_left * ray2ray(camera_target, dir_left, ori, fov2).x + camera_target;\n}\n\nvoid left(vec2 res, vec2 mouse, in vec2 coord, out vec4 color) {\n    vec2 st = coord / res;\n    \n    coord = mult(world, coord);\n    \n    // scene\n    float s = scene(coord);\n    \n    // background\n    vec3 c = vec3(.1, .1, .1);\n    \n    // draw scene\n    c = mix(c, vec3(1.), toSolid(s));\n    \n    // draw grid\n    float grid = toSolid(sdf_grid(coord, vec2(20.), 1.));\n    c = mix(c, vec3(0.182,0.345,0.332), grid);\n    \n    // draw center\n    float center = toSolid(sdf_circle(coord, 5.));\n    c = mix(c, vec3(0.585,0.263,0.274), center);\n    \n    // draw camera\n    vec2 camera_c = mult(inv_mat(camera_pos, 0., vec2(1.)), coord);\n    float camera = toSolid(sdf_circle(camera_c, 5.));\n    c = mix(c, vec3(0.449,0.810,0.555), camera);\n    \n    // draw camera target\n    vec2 target_c = mult(inv_mat(camera_target, 0., vec2(1.)), coord);\n    float target = toSolid(sdf_circle(target_c, 5.));\n    c = mix(c, vec3(0.736,0.810,0.362), target);\n    \n    // draw fov\n    float fov = toSolid(sdf_u(sdf_ray(coord, ori, fov1, 5.), sdf_ray(coord, ori, fov2, 5.)));\n    c = mix(c, vec3(0.510,0.116,0.150), fov);\n    \n    // draw plane\n    float plane = toSolid(sdf_line(coord, plane1, plane2, 2.));\n    c = mix(c, vec3(0.650,0.460,0.479), plane);\n    \n    // additional ray\n    for (int j=-camera_ray; j<=camera_ray; j++) {\n        vec2 p = mix(camera_target, plane1, float(j) / float(camera_ray));\n        vec2 dir = normalize(p - ori);\n        float d = 0.;\n        bool found = false;\n        \n        // ray marching\n        for (int i=0; i<MAX_ITER; i++) {\n            vec2 p = ori + d * dir;\n            float r = scene(p);\n            \n            // draw bubble\n            if (j == 0) {\n                vec2 bubble_c = mult(inv_mat(p, 0., vec2(1.)), coord);\n                float bubble = toSolid(sdf_s(sdf_circle(bubble_c, r), sdf_circle(bubble_c, r-1.)));\n                c = mix(c, vec3(0.425,0.462,0.555), bubble);\n            }\n            \n            d += r;\n            if (r < EPS) {\n                found = true;\n                break;\n            }\n            if (d > MAX_DIST) {\n                break;\n            }\n      \t}\n        \n        // draw ray\n        float ray = toSolid(sdf_ray(coord, ori, dir, 1.));\n        c = mix(c, vec3(0.960,0.895,0.363), ray);\n        \n        // draw contact\n        if (found) {\n            vec2 p = ori + d * dir;\n            // draw line\n            float line = toSolid(sdf_line(coord, ori, p, 2.));\n            c = mix(c, vec3(0.940,0.380,0.086), line);\n\n            // draw point\n            vec2 contact_c = mult(inv_mat(p, 0., vec2(1.)), coord);\n            float contact = toSolid(sdf_circle(contact_c, 5.));\n            c = mix(c, vec3(0.940,0.095,0.005), contact);\n        }\n    }\n    \n    color = vec4(c, 1.);\n}\n\nvoid right(vec2 res, vec2 mouse, in vec2 coord, out vec4 color) {\n    vec2 st = coord / res;\n    \n    mat3 i = inv_mat(res/2., 0., vec2(1.));\n    coord = mult(i,coord);\n    float s = scene(coord);\n    color = debug(s);\n}\n\n\nvoid top(vec2 res, vec2 mouse, in vec2 coord, out vec4 color) {\n    vec2 st = coord / res;\n    \n    float brightness = length(camera_target - camera_pos);\n    vec2 p = mix(camera_target, plane1, st.x * 2. - 1.);\n    vec2 dir = normalize(p - ori);\n    float d = 0.;\n    bool found = false;\n\n    // ray marching\n    for (int i=0; i<MAX_ITER; i++) {\n        vec2 p = ori + d * dir;\n        float r = scene(p);\n        d += r;\n        if (r < EPS) {\n            found = true;\n            break;\n        }\n        if (d > MAX_DIST) {\n            break;\n        }\n    }\n    \n    if (found) {\n        color = vec4(pow(brightness/d, camera_gamma));\n        //color = vec4(1. - exp(-d * brightness / 100000.));\n    } else {\n        color = vec4(0.);\n    }\n    \n    //color = vec4(st, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 halfres = vec2(u_resolution.x/2., u_resolution.y * .9);\n    \n    update(halfres, u_mouse);\n    if (fragCoord.y > halfres.y) {\n        vec2 offset = vec2(0., -halfres.y);\n        top(vec2(u_resolution.x, u_resolution.y * .1), u_mouse + offset, fragCoord.xy + offset, fragColor);\n    } else {\n        if (fragCoord.x < halfres.x) {\n            left(halfres, u_mouse, fragCoord.xy, fragColor);\n        } else {\n            vec2 offset = vec2(-halfres.x, 0.);\n            right(halfres, u_mouse + offset, fragCoord.xy + offset, fragColor);\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}