{
    "Shader": {
        "info": {
            "date": "1523190196",
            "description": "A hypercube lattice section.\n\nConcept derived from:  [url]https://www.shadertoy.com/view/Mts3Wl[/url] by TekF\n\nMouse controls section\n<UP> and <DOWN> to zoom\n'i' to apply inversion",
            "flags": 48,
            "hasliked": 0,
            "id": "4sVcDG",
            "likes": 12,
            "name": "Hypercubic Honeycomb Section",
            "published": 3,
            "tags": [
                "4d",
                "honeycomb",
                "section",
                "hypercubic"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 1115
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created 2018 by Matthew Arcus\n//\n// Display a section through a hypercubic lattice in R4.\n// Inspired by: https://www.shadertoy.com/view/Mts3Wl by TekF\n//\n// To display a slice through a scene in R4, we can just use the R4 distances\n// and carry them over to R3 (since the R4 distance is an upper bound).\n//\n// To fit an infinite lattice onto the screen, we can also apply an inversion (in R3)\n//\n// <mouse>: change section\n// <UP>,<DOWN>: zoom in/out\n// i: apply inversion\n// j: apply inversion in R4 before projection\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define NOKEYS (__VERSION__ < 300)\n//#define NOKEYS 1\n\nbool doinvert = true;\nbool doinvert4 = false;\n\nconst vec3 Face0Color = vec3(1,0,0);\nconst vec3 Face1Color = vec3(0,1,0);\nconst vec3 Face2Color = vec3(0,0,1);\nconst vec3 Face3Color = vec3(1,1,0);\nconst vec3 Face4Color = vec3(0.25,0,0.5);\nconst vec3 Face5Color = vec3(0,1,1);\nconst vec3 EdgeColor = vec3(0.1,0.1,0.1);\n\nconst float PI\t= 3.14159265359;\nconst float TWOPI = 2.0 * PI;\n\n#define DEBUG\n#if !defined DEBUG\n#define assert(x) 0\n#else\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n// Approximate equality. Used for assertion checks.\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\n#endif\n\n// Quaternion multiplication\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec4 lquat, rquat;\n\nvoid qinit() {\n  vec3 laxis = vec3(1,0.5,1);\n  vec3 raxis = vec3(1,1,0.5);\n  float t = iTime + 1.0;\n  float ltheta = 0.1*t;\n  float rtheta = 0.123*t;\n  lquat = normalize(vec4(sin(ltheta)*laxis,cos(ltheta)));\n  rquat = normalize(vec4(sin(rtheta)*raxis,cos(rtheta)));\n}\n\n// Apply mouse rotation\nvec3 transform(in vec3 p);\n\nvec4 iproject(vec3 pos) {\n  float t = iTime + 0.5;\n  float k = 0.7*sin(0.2*t);\n  vec4 pos4 = vec4(pos,k);\n  pos4.xyw = transform(pos4.xyw);\n  // Two sided quaternion multiplication\n  // All R4 rotations can be constructed from\n  // a quaternion pair.\n  return qmul(lquat,qmul(pos4,rquat));\n  // One sided quaternion multiplication\n  //return qmul(pos4,rquat);\n}\n\nfloat scene(vec4 pos4) {\n  float d = 1e8;\n  float fwidth = 0.04;\n  float ewidth = 0.08;\n  pos4 = fract(pos4);\n  pos4 = min(pos4,1.0-pos4);\n  // Distance from edges - these appear as points, usually\n  d = min(d,length(pos4.xyz) - ewidth);\n  d = min(d,length(pos4.yzw) - ewidth);\n  d = min(d,length(pos4.zwx) - ewidth);\n  d = min(d,length(pos4.wxy) - ewidth);\n  // Distance from faces - these appear as lines, usually\n  d = min(d,length(pos4.xy) - fwidth);\n  d = min(d,length(pos4.yz) - fwidth);\n  d = min(d,length(pos4.zx) - fwidth);\n  d = min(d,length(pos4.xw) - fwidth);\n  d = min(d,length(pos4.yw) - fwidth);\n  d = min(d,length(pos4.zw) - fwidth);\n  return d;\n}\n\nvec3 color(vec4 pos4) {\n  float k, d = 1e8;\n  float fwidth = 0.04;\n  float ewidth = 0.08;\n  pos4 = fract(pos4);\n  pos4 = min(pos4,1.0-pos4);\n  d = min(d,length(pos4.xyz) - ewidth);\n  d = min(d,length(pos4.yzw) - ewidth);\n  d = min(d,length(pos4.zwx) - ewidth);\n  d = min(d,length(pos4.wxy) - ewidth);\n  vec3 col = EdgeColor;\n  k = length(pos4.xy) - fwidth;\n  if (k < d) { d = k; col = Face0Color; }\n  k = length(pos4.yz) - fwidth;\n  if (k < d) { d = k; col = Face1Color; }\n  k = length(pos4.zx) - fwidth;\n  if (k < d) { d = k; col = Face2Color; }\n  k = length(pos4.xw) - fwidth;\n  if (k < d) { d = k; col = Face3Color; }\n  k = length(pos4.yw) - fwidth;\n  if (k < d) { d = k; col = Face4Color; }\n  k = length(pos4.zw) - fwidth;\n  if (k < d) { d = k; col = Face5Color; }\n  return col;\n}\n\nvec4 map(vec3 pos, out float k) {\n  k = 1.0;\n  if (doinvert) {\n    float c = cos(0.25*iTime);\n    float r = 1.0/c;\n    float r2 = r*r;\n    pos.x -= r-c;\n    k = dot(pos,pos)/r2;\n    pos /= k;\n    pos.x += r-c;\n  }\n  vec4 pos4 = iproject(pos);\n  if (doinvert4) {\n    float k4 = dot(pos4,pos4);\n    pos4 /= k4;\n    k *= k4;\n  }\n  return pos4;\n}\n\nfloat de(vec3 pos) {\n  float k;\n  vec4 pos4 = map(pos,k);\n  float d = scene(pos4);\n  return k*d;\n}\n\nvec3 getColor(vec3 pos){\n  float k;\n  vec4 pos4 = map(pos,k);\n  return 0.8*color(pos4)+0.2;\n}\n\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 20.0;\n  const float precis = 0.001;\n  float h = precis * 2.0;\n  float t = 0.0;\n  float res = -1.0;\n  for(int i = 0; i < 256; i++) {\n      if (h < precis || t > maxd) break;\n      h = de(ro + rd * t);\n      if (doinvert || doinvert4) h *= 0.5;\n      t += h;\n    }\n  if (t < maxd) res = t;\n  return res;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  //p.yz = rotate(p.yz,iTime * 0.125);\n  //p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n#if NOKEYS\nbool keypress(int code) {\n  return false;\n}\n\nint keycount(int key) {\n  return 0;\n}\n#else\nbool keypress(int code) {\n    return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if (!NOKEYS) doinvert = keypress(CHAR_I);\n  if (!NOKEYS) doinvert4 = keypress(CHAR_J);\n  qinit();\n  \n  vec2 p = fragCoord.xy / iResolution.xy;\n  //p.y = 1.0-p.y;\n  // Now both coords are in (0,1)\n  p = 2.0*p-1.0;\n  p *= iResolution.xy/iResolution.y;\n  p *= 3.0;\n  vec3 bgcol = vec3(0.3 + p.y * 0.1);\n  vec3 col = bgcol;\n  vec3 ro = vec3(0.0, 0.0, -2.5);\n  vec3 rd = vec3(p, 6.0);\n  vec3 li = vec3(0.5, 3.0, -2);\n  ro.z *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n\n#if 0\n  ro = transform(ro);\n  rd = transform(rd);\n  li = transform(li);\n#endif\n  rd = normalize(rd);\n  li = normalize(li);\n  float t = march(ro, rd);\n  if (t > 0.0) {\n    vec3 pos = ro + t * rd;\n    vec3 n = calcNormal(pos);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col = getColor(pos) * (0.2+0.7*diffuse);\n    col = mix(col,bgcol,clamp(t/20.0,0.0,1.0)); // Fog\n  }\n  col = pow(col, vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}