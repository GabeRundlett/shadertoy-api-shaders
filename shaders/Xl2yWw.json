{
    "Shader": {
        "info": {
            "date": "1508814798",
            "description": "bulding a brush ID voronoi diagram in the depth buffer from a seed of 1000 spherical brush ids. drag mouse to see: right: bruteforced ground truth, left: computed with jump flooding",
            "flags": 32,
            "hasliked": 0,
            "id": "Xl2yWw",
            "likes": 10,
            "name": "JFA Raytracing",
            "published": 3,
            "tags": [
                "raytracing",
                "spheres",
                "jump",
                "flooding",
                "jfa",
                "brushes"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1655
        },
        "renderpass": [
            {
                "code": "/*\nsome words on how this works:\n\na ping pong buffer is initialized with each pixel randomized to one of 1000\nbrush ids, each of which resolves to a sphere origin and radius.\n\nthen JFA is performed, with the distance metric being the ray scalar t. if there\nis no hit, t can either be infinity or moved behind the far plane to permit\nbuilding a diagram in otherwise empty space.\n\nthe seeding is randomized to illustrate how init conditions can have a huge\neffect on outcome; what happens here is that some seeds get culled permanently\nbefore they can jump to the spatial position where they belong. splatting the seeds\nin the vicinity of where they are supposed to be in the end improves this; \nincreasing the resolution is also effective.\n\nwhat we are effectively doing is trading depth complexity for pixels; unused\npixels can store possible outcomes of a depth test shootout until a winner is found.\n\nobviously there's lots to optimize and expand on here. this is the very first\ntest i did to see if jump flooding applies to projected 3D, and it does!\n\nthe cost of this example is 11 steps * at least 5 lookups per pixel,\nwhich is 5.5% of the cost of bruteforcing 1000 objects per pixel.\n\n*/\n\n// presentation\n\nvec4 load0(ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);\n}\n\nvec4 load1(ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / iChannelResolution[1].xy;\n    return texture(iChannel1, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = int(mod(iTime,15.0));\n    vec2 aspect = vec2(iResolution.x / iResolution.y,1.0); \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0) * aspect;    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m = (m * 2.0 - 1.0) * aspect;    \n    ray_rd = get_rd(uv);\n    \n    vec3 col;\n    if ((uv.x < m.x)||(iMouse.z < 0.5)) {\n        int id = int(load1(ivec2(fragCoord + 0.5)).x);\n        float d = 0.0;\n        if (id != 0) {\n            Brush brush = getbrush(id, iFrame);\n            d = brushdist(brush, uv);\n\n            float t = iSphere(vec3(0.0), ray_rd, brush.sph);\n            d = t;\n        }\n\n        col = hash31(float(id)) * 0.5;\n        col += 0.5*(sin(d*40.0)*0.5+0.5);\n        if (d < 0.0) {\n            col *= 0.25;\n        }\n    } else {\n        float bestt = 1.0/0.0;\n        col = vec3(0.0,0.0,0.1);\n        for (int i = 0; i < NUMBRUSHES; ++i) {\n            Brush brush = getbrush(i, iFrame);\n            float t = iSphere(vec3(0.0), ray_rd, brush.sph);\n            if ((t > 0.0) && (t < bestt)) {\n                bestt = t;\n                col = hash31(float(i)) * 0.5;\n                col += vec3(0.5*(sin(t*40.0)*0.5+0.5));\n            }\n        }\n    }\n    /*\n    if (frame < 12) {\n        col = hash31(float(id)) * 0.5;\n    } else {\n        col = hash31(float(id));\n    }\n\t*/\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// channel 1: JFA steps\n\n\n\nvec4 load0(ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / iChannelResolution[0].xy;\n    uv = mod(uv, vec2(1.0));\n    return texture(iChannel0, uv);\n}\n\nvoid store(out vec4 t, vec4 v) {\n    t = v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = int(mod(iTime,15.0));\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = uv*2.0 - 1.0;\n    p.x *= aspect;\n    ray_rd = get_rd(p);\n    \n    float iter = mod(float(iFrame),13.0);\n    if (iter < 0.5) {\n        float p = mod(hash31((fragCoord.x * 1920.0 + fragCoord.y)*0.01).x*float(NUMBRUSHES) + mod(iTime*13.0,1.0), float(NUMBRUSHES));\n        //float p = mod(fragCoord.x + fragCoord.y + iTime*13.0, float(NUMBRUSHES));\n        \n        int id = int(p);\n        store(fragColor, vec4(float(id),0.0,0.0,0.0));        \n        \n    } else {\n        // JFA step (for up to 4096x4096)\n        float level = clamp(iter-1.0,0.0,11.0);\n        int stepwidth = int(exp2(11.0 - level)+0.5);\n        \n        ivec2 tc = ivec2(fragCoord + 0.5);\n        \n        float best_dist = 999999.0;\n        int best_id = 0;\n        vec2 center = vec2(tc);\n        // both moore and von neumann neighborhoods work\n#if 1\n        for (int y = -1; y <= 1; ++y) {\n            for (int x = -1; x <= 1; ++x) {\n                ivec2 fc = tc + ivec2(x,y)*stepwidth;\n\t\t        int id = int(load0(fc).x + 0.5);\n                if (id != 0) {\n                    Brush brush = getbrush(id, iFrame);\n                    float d = brushdist(brush, p);\n\n                    if (d < best_dist) {\n                        best_dist = d;\n                        best_id = id;\n                    }\n                }\n            }\n        }        \n#else\n        for (int k = -1; k <= 1; ++k) {\n            {\n                ivec2 fc = tc + ivec2(k,0)*stepwidth;\n\t\t        int id = int(load0(fc).x + 0.5);\n                if (id != 0) {\n                    Brush brush = getbrush(id);\n                    float d = brushdist(brush, p);\n\n                    if (d < best_dist) {\n                        best_dist = d;\n                        best_id = id;\n                    }\n                }\n            }\n            {\n                ivec2 fc = tc + ivec2(0,k)*stepwidth;\n\t\t        int id = int(load0(fc).x + 0.5);\n                if (id != 0) {\n                    Brush brush = getbrush(id);\n                    float d = brushdist(brush, p);\n\n                    if (d < best_dist) {\n                        best_dist = d;\n                        best_id = id;\n                    }\n                }\n            }            \n        }        \n#endif\n        store(fragColor,vec4(float(best_id),0.0,0.0,0.0));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// channel 2: take snapshot of stage\n\nvec4 load0(ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);\n}\n\nvec4 load1(ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / iChannelResolution[1].xy;\n    return texture(iChannel1, uv);\n}\n\nvoid store(out vec4 t, vec4 v) {\n    t = v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n    ivec2 tc = ivec2(fragCoord + 0.5);\n    int iter = int(mod(float(iFrame),13.0));\n    int frame = int(mod(iTime,15.0));\n    //frame = 13;\n    if ((iter == frame) || ((frame > 12) && (iter == 12))) {\n        // snapshot\n        store(fragColor,load0(tc));\n    } else {\n        // copy\n        store(fragColor,load1(tc));\n    }\n#else\n    ivec2 tc = ivec2(fragCoord + 0.5);\n    int iter = int(mod(float(iFrame),13.0));\n    // final image = 12\n    if (iter == 12) {\n        // snapshot\n        store(fragColor,load0(tc));\n    } else {\n        // copy\n        store(fragColor,load1(tc));\n    }\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float iSphere(in vec3 ro, in vec3 rd, in vec4 sph) {\n    ro -= sph.xyz;\n\tfloat k = dot(ro, rd);\n    float D = k*k - dot(ro, ro) + sph.w*sph.w;\n    float q = sqrt(D);\n    if (D < 0.0) {\n        return D;\n    } else {\n    \treturn (vec2(-q,q) - k).x;\n    }\n}\n\n\nstruct Brush {\n    vec4 sph;\n};\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   p *= 3.1459;\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n#define NUMBRUSHES 1000\nBrush getbrush(int x, int time) {\n    float T = float(time - time % 180);\n    float a = float(x)/float(NUMBRUSHES);\n    vec3 q = hash31(a + T);\n#if 0\n    float r = radians(a*360.0*6.0);    \n    float w = 2.0 + cos(radians(a*360.0*13.0));    \n    return Brush(vec4(cos(r)*w,sin(r)*w,a*8.0+1.0, 0.1));\n#else\n    return Brush(vec4(q*2.0-1.0 + vec3(0.0,0.0,1.0), 0.1 - 0.09 * mod(q.x+q.y+q.z, 1.0)));\n#endif\n}\n\nvec3 ray_rd;\nvec3 get_rd(in vec2 p) {\n\treturn normalize(vec3(p, 1.0)); \n}\n\nfloat brushdist(Brush brush, vec2 p) {\n    float t = iSphere(vec3(0.0), ray_rd, brush.sph);\n    if (t < 0.0) {\n    \treturn 1000.0 - t;\n    } else {\n        return t;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}