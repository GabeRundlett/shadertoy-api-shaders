{
    "Shader": {
        "info": {
            "date": "1681094653",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!",
            "flags": 0,
            "hasliked": 0,
            "id": "cdySDW",
            "likes": 18,
            "name": "Year of Truchets #008",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles",
                "truchetcore"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #008\n    04/09/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(26.37,45.93)))*4374.23); }\nfloat lsp(float b, float e, float t) { return clamp((t - b) / (e - b), 0.0, 1.0); }\n\n//@iq shapes\nfloat box( vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.025;\n}\nfloat box( vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat cap( vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat floorspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.;\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0),speed=vec3(0);\nmat2 r45,r25;\n\nconst float size = 4.;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\nconst float spce = size;\nconst vec3  grid = vec3(1,1,1);\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    float id;\n    vec3 q=vec3(0), sp=p;\n    \n    for(int i = 0; i<2; i++)\n    {\n        // based on @Shanes multi-tap stuff\n        // though cut down to two taps\n        float cnt = i==0 ? size : dbl;\n        q = vec3(p.x-cnt,p.yz);\n        id = floor(q.x/dbl) + .5;\n        q.x -= (id)*dbl;\n        float qf = (id)*dbl + cnt;\n        vec3 r= q;\n   \n        float intspace = 50.;//start space\n        float ff = qf-size;  //id pluse obj space\n        float fp = floorspeed-1.; //offsets to start and pause\n        float fs = floorspeed+2.; //begin area\n        //if past start ent = 0 ? if greater hold at start else move into space to 0\n        float ent= ff<fp ? 0. : ff>fs ? intspace : clamp(1.-ga3,0.,1.)*intspace;\n        if(i==0) ent = -ent;//flip direction\n        r-=vec3(0,0,ent);\n         \n        // making ids for the new clamp domains \n        float nf = floor((r.z + hlf)/size);\n        float hs = hash21(vec2(nf,qf));\n        // clamp domains for truchet\n        r.z = r.z-size*clamp(round(r.z/size),-3.,3.);\n     \n        // standard truchet stuff\n        if(hs>.5) r.x*=-1.;\n        \n        vec2 d2 = vec2(length(r.xz-hlf), length(r.xz+hlf));\n        vec2 gx = d2.x<d2.y ? vec2(r.xz-hlf) : vec2(r.xz+hlf);\n        vec3 tq = vec3(gx.x,r.y,gx.y);\n    \n        float d3=box(r,vec3(1.9));\n        float d4=trs(tq,vec2(2.,.5));\n\n        if(hs>.6) d4 = min(length(r.yz)-.5,length(r.yx)-.5);\n   \n        if(hs>.075&&hs<.15) d4 = min(length(r.yz)-.5, length(vec3(r.yx,abs(r.z)-hlf))-.5);\n    \n        if(hs<.075) d4 = min(length(r.yx)-.5, length(vec3(abs(r.x)-hlf,r.yz))-.5);\n        d3=max(d3,d4);\n        \n        if(d3<res.x){\n            hs=fract(hs*432.32);\n            res = vec2(d3,hs<.5?4.:3.);\n            hit= r;\n            gid = vec3(qf,nf,1);\n        }\n    }\n    \n    float fl = p.y+4.;\n    if(fl<res.x){\n        res=vec2(fl,2.);\n        hit=p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 hue(float t) {\n    return .45 + .35*cos(PI2*t*(vec3(.12,.47,.92)+vec3(0.88,.97,.85))); \n}\n\nvec4 FC = vec4(0.647,0.753,0.753,0.);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,100);\n    hitPoint = hit;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(15.,35.,35.);\n        vec3 l = normalize(lpos);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint*vec3(-1.,1,1);\n \n        float diff = clamp(dot(n,l),.1,.95);\n\n        float clr;\n        \n        // materials\n        if(m==2.){\n            h=vec3(.05);\n            \n            float px = 4./R.x;\n            float sc = .18;\n            \n            vec2 id= floor(hp.xz*sc);\n            vec2 f = fract(hp.xz*sc)-.5;\n            float ck = mod(id.x+id.y,2.)*2.-1.;\n\n            float hs = hash21(id);\n            if(hs>.5) f.x*=-1.;\n\n            vec2 d2 = vec2(length(f-.5),length(f+.5));\n            vec2 gx = d2.x<d2.y ? vec2(f-.5):vec2(f+.5);\n\n            float p = length(gx)-.5;\n            float d = abs(p)-.05;\n\n            p = (ck>.5^^hs>.5) ? smoothstep(px,-px,p):smoothstep(-px,px,p);\n            d = smoothstep(px,-px,d);\n\n            h = mix(h,hue(hp.x*.0085)*.2,p);\n            h = mix(h,hue(hp.x*.0085)*.4,d);\n             \n            ref=vec3(max(p,d)*h);\n\n        }\n        if(m==3.){\n            h = hue(sid.x*.0085);\n            ref = h*.5;\n        }\n        if(m==4.){\n            h = vec3(.5);\n            ref = vec3(.2);\n        }\n        C = (diff*h);\n        \n        C = mix(FC.rgb,C,exp(-.0000005*d*d*d));\n        ro = p+n*.0001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // var names are so off now\n    // but too lazy to change\n   // r45=rot(-.585);\n    r25=rot(-.785);\n\n    float time = (T+40.)*4.;\n    tmod = mod(time, 10.);\n    float t3 = lsp(5.0, 10.0, tmod);\n    ga1 = (time*.1);\n    ga3 = tmod<5.?t3+1.:t3;\n    speed = vec3(abs(ga1*spce),0,0);\n    floorspeed=floor(speed.x);\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*20.,-25.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    mat2 turn = rot(time*.01);\n    ro.yz*=r25,ro.xz*=turn;\n    rd.yz*=r25,rd.xz*=turn;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n    C = clamp(C,vec3(.01),vec3(1));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}