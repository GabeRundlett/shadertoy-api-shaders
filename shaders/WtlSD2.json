{
    "Shader": {
        "info": {
            "date": "1566035476",
            "description": "Tribute to Julio Le Parc's \"Continuel mobile\".\n\nWatch in full screen. Take your time and enjoy.",
            "flags": 32,
            "hasliked": 0,
            "id": "WtlSD2",
            "likes": 45,
            "name": "Hommage à Le Parc II",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "reflection",
                "gi",
                "global",
                "illumination",
                "pathtracing",
                "art",
                "opart",
                "cineticart"
            ],
            "usePreview": 0,
            "username": "sschmidtix",
            "viewed": 1048
        },
        "renderpass": [
            {
                "code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Copyright © 2019 Stefan Schmidt\n//\n// Hommage à Le Parc II\n// Tribute to Julio Le Parc's \"Continuel mobile\".\n//\n// Watch in full screen. Take your time and enjoy.\n// ---------------------------------------------------------------------\n\n// Parameters\n#define BRIGHTNESS          8.\n\n// Also play with the parameters in Buffer A!\n    \n\n// ACES\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 mapACES(vec3 col)\n{\n    col = col * ACESInputMat;\n    vec3 a = col * (col + 0.0245786) - 0.000090537;\n    vec3 b = col * (0.983729 * col + 0.4329510) + 0.238081;\n    col = a / b;\n    col = col * ACESOutputMat;\n    col = clamp(col, 0.0, 1.0);\n\n    return col;\n}\n\n// Shader entry point\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n    \n    col = texture(iChannel0, uv).rgb;\n    \n    // Post-processing\n    col = pow(col, vec3(0.8, 0.85, 0.9));\n    \n    col *= BRIGHTNESS;\n    col = mapACES(col);\n    \n    col *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y *\n                           (1.0 - uv.x) * (1.0 - uv.y), 0.2);\n    \n    col = pow(col, vec3(1. / 2.2));\n    \n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Copyright © 2019 Stefan Schmidt\n//\n// Hommage à Le Parc II\n// Tribute to Julio Le Parc's \"Continuel mobile\".\n//\n// Watch in full screen. Take your time and enjoy.\n// ---------------------------------------------------------------------\n\n// Parameters\n#define NUM_SAMPLES         10              // Number of samples per pixel\n#define MAX_RAY_DEPTH       5               // Max ray depth\n#define MAX_SHADOW_DEPTH    2               // Max shadow depth\n#define MAX_REFLECT_DEPTH   2               // Max reflection depth\n\n#define LIGHT_POSITION      vec3(1.8, 3.5, .5)\n#define LIGHT_DIRECTION     getDirection(-128., 10.)\n#define LIGHT_BEAMWIDTH     25.             // In degrees\n#define LIGHT_RADIUS        0.03\n\n#define MIRRORS_POSITION    vec3(0., 1.8, 0.)\n#define MIRRORS_SIZE        2.\n#define MIRRORS_N           10.\n#define MIRRORS_REFLECTANCE 0.7\n#define MIRRORS_SPEED       0.002\n// #define MIRRORS_ALIGN\n// #define MIRRORS_SELFOCCLUSION\n\n#define CAMERA_POS          vec3(0., 1.8, -2.5)\n#define CAMERA_LOOKAT       vec3(0., 0.9, 0.)\n#define CAMERA_FOCALLENGTH  0.019           // Camera focal length (f/2.8)\n#define CAMERA_FRAMEWIDTH   0.036           // Camera sensor width (35 mm sensor)\n\n// #define SHOW_ACCELSTRUCT\n\n\n// Constants\n#define M_PI                radians(180.)\n#define SHADOW_EPSILON      1e-5\n#define FAR_PLANE           1e3\n\n#define MIRRORS_CELLSIZE    (MIRRORS_SIZE / MIRRORS_N)\n#define MIRRORS_CELLMIN     (MIRRORS_POSITION - 0.5 * vec3(0., MIRRORS_SIZE - MIRRORS_CELLSIZE, MIRRORS_SIZE - MIRRORS_CELLSIZE))\n#define MIRRORS_CELLMAX     (MIRRORS_POSITION + 0.5 * vec3(0., MIRRORS_SIZE - MIRRORS_CELLSIZE, MIRRORS_SIZE - MIRRORS_CELLSIZE))\n#define MIRRORS_MIN         (MIRRORS_POSITION - 0.5 * vec3(MIRRORS_CELLSIZE, MIRRORS_SIZE, MIRRORS_SIZE))\n#define MIRRORS_MAX         (MIRRORS_POSITION + 0.5 * vec3(MIRRORS_CELLSIZE, MIRRORS_SIZE, MIRRORS_SIZE))\n#define MIRROR_SIZE         (0.9 * MIRRORS_CELLSIZE)\n\n#define getDirection(inc, az) normalize(vec3(\\\n    sin(radians(inc)) * cos(radians(az)),\\\n    cos(radians(inc)),\\\n    sin(radians(inc)) * sin(radians(az))))\n\n\n// Rays\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\n\n// PRNG\nvec3 seed;\n\nvoid initRandom(vec2 fragCoord) {\n    seed = vec3(fragCoord, iFrame);\n}\n\nfloat getRandom() {\n    seed = clamp(fract(sin(cross(seed, vec3(12.9898, 78.233, 43.1931))) * 43758.5453), 0., 1.);\n    \n    return seed.x;\n}\n\n\n// Sampling\nvec3 getHemisphereCosineSample(vec3 n, out float weight) {\n    float cosTheta2 = getRandom();\n    float cosTheta = sqrt(cosTheta2);\n    float sinTheta = sqrt(1. - cosTheta2);\n    \n    float phi = 2. * M_PI * getRandom();\n    \n    vec3 t = normalize(cross(n.yzx, n));\n    vec3 b = cross(n, t);\n    \n    vec3 l = n * cosTheta + (t * cos(phi) + b * sin(phi)) * sinTheta;\n    \n    float pdf = (1. / M_PI) * cosTheta;\n    weight = (.5 / M_PI) / (pdf + 1e-6);\n    \n    return l;\n}\n\nvec3 getDiskSample(vec3 p, vec3 n, float r) {\n    float rho = r * sqrt(getRandom());\n    float theta = 2. * M_PI * getRandom();\n    \n    vec3 t = normalize(cross(n.yzx, n));\n    vec3 b = cross(n, t);\n    \n\treturn p + rho * (t * cos(theta) + b * sin(theta));\n}\n\n\n// Intersections\nstruct RayIntersection {\n    float t;\n    vec3 p;\n    vec3 n;\n    bool isMirror;\n};\n\nvoid intersectPlane(vec3 o, vec3 n, Ray ray, inout RayIntersection ri) {\n    // Plane\n    float den = dot(ray.d, n);\n    if (den > -1e-5)\n        return;\n    \n    float t = dot(o - ray.o, n) / den;\n    if ((t < SHADOW_EPSILON) || (t > ri.t))\n    \treturn;\n    \n    ri = RayIntersection(t, ray.o + t * ray.d, n, false);\n}\n\nvec3 getMirrorNormal(vec3 o) {\n#ifdef MIRRORS_ALIGN\n    return getDirection(90., 180. / 60. * iTime);\n#else\n    float p = 51.55 * sin(cross(o, vec3(12.9898, 78.233, 43.1931)).x);\n    \n    return getDirection(90., 180. * cos(2. * M_PI * (MIRRORS_SPEED * iTime + p)));\n#endif\n}\n\nbool intersectMirror(vec3 o, Ray ray, inout RayIntersection ri) {\n    mat3 m;\n    m[0] = getMirrorNormal(o);\n    m[1] = normalize(cross(vec3(0., 1., 0.), m[0]));\n    m[2] = cross(m[0], m[1]);\n    \n    // Plane\n    float den = dot(ray.d, m[0]);\n    if (abs(den) < 1e-5)\n        return false;\n    \n    float t = dot(o - ray.o, m[0]) / den;\n    if ((t < SHADOW_EPSILON) || (t > ri.t))\n    \treturn false;\n    \n    // Border\n    vec3 p = ray.o + t * ray.d;\n    vec3 d = abs((p - o) * m);\n    \n    if (any(greaterThan(d, vec3(0.5 * MIRROR_SIZE))))\n        return false;\n    \n    ri = RayIntersection(t, p, (den < 0.) ? m[0] : -m[0], true);\n    \n    return true;\n}\n\n\n// Grid acceleration structure for mirrors\nstruct GridIntersection {\n    bool hit;\n    vec3 deltaT;\n    vec3 nextT;\n    vec3 o;\n};\n\nvoid gridInit(Ray ray, out GridIntersection gi) {\n    // AABB test\n    vec3 di = 1. / ray.d;\n    vec3 v1 = (MIRRORS_MIN - ray.o) * di;\n    vec3 v2 = (MIRRORS_MAX - ray.o) * di;\n    vec3 near = min(v1, v2);\n    vec3 far = max(v1, v2);\n    float tNear = max(near.x, max(near.y, near.z));\n    float tFar = min(far.x, min(far.y, far.z));\n    \n    gi.hit = (tFar > 0.) && (tNear < tFar);\n    if (gi.hit) {\n        // Setup grid traversal\n        float t = max(tNear, 0.);\n        \n        vec3 p = ray.o + t * ray.d - MIRRORS_MIN;\n        \n        vec3 index = clamp(floor(p / MIRRORS_CELLSIZE),\n                           vec3(0.),\n                           vec3(0., MIRRORS_N - 1., MIRRORS_N - 1.));\n        \n        gi.deltaT = MIRRORS_CELLSIZE * di;\n        gi.nextT = t + ((index + step(0., di)) * MIRRORS_CELLSIZE - p) * di;\n        gi.o = MIRRORS_MIN + MIRRORS_CELLSIZE * (index + 0.5);\n    }\n}\n\nbool gridHit(GridIntersection gi) {\n    return gi.hit;\n}\n\nvoid gridNext(inout GridIntersection gi) {\n    // Traverse grid\n    if ((gi.nextT.x < gi.nextT.y) && (gi.nextT.x < gi.nextT.z))\n        gi.hit = false;\n    else if ((gi.nextT.y < gi.nextT.x) && (gi.nextT.y < gi.nextT.z)) {\n        gi.o.y += MIRRORS_CELLSIZE * sign(gi.deltaT.y);\n        if ((gi.o.y >= MIRRORS_MIN.y) && (gi.o.y < MIRRORS_MAX.y))\n            gi.nextT.y += abs(gi.deltaT.y);\n        else\n            gi.hit = false;\n    } else {\n        gi.o.z += MIRRORS_CELLSIZE * sign(gi.deltaT.z);\n        if ((gi.o.z >= MIRRORS_MIN.z) && (gi.o.z < MIRRORS_MAX.z))\n            gi.nextT.z += abs(gi.deltaT.z);\n        else\n            gi.hit = false;\n    }\n}\n\n\n// Analytical light\nfloat light(float cosTheta) {\n    float b = acos(cosTheta) / radians(LIGHT_BEAMWIDTH);\n    \n    if (b >= 1.)\n        return 0.;\n    \n    // Circle/circle\n    // return (2. / M_PI) * (acos(b) - b * sqrt(1. - b * b));\n    \n    // Circle/circle approximation\n    return pow(1. - b, 1.39);\n    \n    // Linear\n    // return 1. - b;\n}\n\n\n// Render scene\nvec3 render(Ray ray) {\n    vec3 acc = vec3(0.);    // Cumulative radiance\n    vec3 att = vec3(1.);    // Attenuation\n    \n    // Path tracing\n    for (int depth = 0; depth < MAX_RAY_DEPTH; depth++) {\n        RayIntersection ri;\n\t    ri.t = FAR_PLANE;\n        \n        // Scene\n        intersectPlane(vec3(0., 0., 0.), getDirection(0., 0.), ray, ri);\n        intersectPlane(vec3(0., 0., 3.), getDirection(90., -90.), ray, ri);\n        intersectPlane(vec3(0., 0., -3.), getDirection(90., 90.), ray, ri);\n        \n        GridIntersection gi;\n        for (gridInit(ray, gi); gridHit(gi); gridNext(gi)) {\n#ifdef SHOW_ACCELSTRUCT\n            if (depth == 0)\n                acc += vec3(0.02, 0., 0.);\n#endif\n            if (intersectMirror(gi.o, ray, ri))\n                break;\n        }\n        \n        if (ri.t == FAR_PLANE)\n            break;\n        \n        // Lambert material\n        if (!ri.isMirror) {\n            Ray lRay = Ray(ri.p, normalize(getDiskSample(LIGHT_POSITION,\n                                                         LIGHT_DIRECTION,\n                                                         LIGHT_RADIUS) - ri.p));\n            \n            // Analytical Light\n            float l = light(dot(lRay.d, -LIGHT_DIRECTION)) * dot(ri.n, lRay.d);\n            \n            // Monte Carlo shadows\n            if (l > 0.) {\n                if (depth < MAX_SHADOW_DEPTH) {\n                    RayIntersection li;\n                    li.t = FAR_PLANE;\n                    \n                    GridIntersection gi;\n                    for (gridInit(lRay, gi); gridHit(gi); gridNext(gi)) {\n#ifdef SHOW_ACCELSTRUCT\n                        if (depth == 0)\n                            acc += vec3(0., 0.02, 0.);\n#endif\n                        if (intersectMirror(gi.o, lRay, li)) {\n                            l = 0.;\n                            \n                            break;\n                        }\n                    }\n                }\n            }\n            \n            // Monte Carlo direct reflections\n            if (depth < MAX_REFLECT_DEPTH) {\n                float lRefl = 0.;\n                \n                vec3 ls = getDiskSample(LIGHT_POSITION,\n                                        LIGHT_DIRECTION,\n                                        LIGHT_RADIUS);\n                \n                for (float z = MIRRORS_CELLMIN.z; z < MIRRORS_MAX.z; z += MIRRORS_CELLSIZE) {\n                    vec2 o_xz = vec2(MIRRORS_POSITION.x, z);\n                    \n                    float dpo = distance(ri.p.xz, o_xz);\n                    float dpl = dpo + distance(o_xz, ls.xz);                    \n                    float oy = (ls.y - ri.p.y) * dpo / dpl + ri.p.y;\n                    \n                    float yy = (oy - MIRRORS_MIN.y) / MIRRORS_CELLSIZE;\n                    \n                    float y0 = MIRRORS_CELLMIN.y + MIRRORS_CELLSIZE * clamp(floor(yy - .5), 0., MIRRORS_N);\n                    float y1 = MIRRORS_CELLMIN.y + MIRRORS_CELLSIZE * clamp(ceil(yy + .5), 0., MIRRORS_N);\n                    \n                    for (float y = y0; y < y1; y += MIRRORS_CELLSIZE) {\n#ifdef SHOW_ACCELSTRUCT\n                        if (depth == 0)\n                            acc += vec3(0., 0., 0.001);\n#endif\n                        vec3 o = vec3(MIRRORS_POSITION.x, y, z);\n                        vec3 n = getMirrorNormal(o);\n                        \n                        vec3 lr = reflect(ls - o, n) + o;\n                        \n                        RayIntersection li;\n                        li.t = FAR_PLANE;\n                        \n                        Ray lRay = Ray(ri.p, normalize(lr - ri.p));\n#ifdef MIRRORS_SELFOCCLUSION\n                        float lReflCurr = 0.;\n                        \n                        // Point-to-mirror occlusion\n                        GridIntersection gi;\n                        for (gridInit(lRay, gi); gridHit(gi); gridNext(gi)) {\n                            if (intersectMirror(gi.o, lRay, li)) {\n                                if (distance(gi.o, o) < 0.01) {\n                                    vec3 nr = reflect(LIGHT_DIRECTION, n);\n                                    \n                                    lReflCurr = light(dot(lRay.d, -nr)) * dot(ri.n, lRay.d);\n                                    \n                                    // Mirror-to-light occlusion\n                                    RayIntersection li2;\n                                    li2.t = FAR_PLANE;\n                                    \n                                    Ray lRay2 = Ray(li.p, normalize(ls - li.p));\n                                    \n                                    GridIntersection gi2;\n                                    for (gridInit(lRay2, gi2); gridHit(gi2); gridNext(gi2)) {\n                                        if (intersectMirror(gi2.o, lRay2, li2)) {\n                                            lReflCurr = 0.;\n                                            \n                                        \tbreak;\n                                        }\n                                    }\n                                }\n                                \n                                break;\n                            }\n                        }\n                                \n                        lRefl += lReflCurr;\n#else\n                        if (intersectMirror(o, lRay, li)) {\n\t                        vec3 nr = reflect(LIGHT_DIRECTION, n);\n                            \n                            lRefl += light(dot(lRay.d, -nr)) * dot(ri.n, lRay.d);\n                        }\n#endif\n                    }\n                }\n                \n                l += MIRRORS_REFLECTANCE * lRefl;\n            }\n            \n            // Emission\n            vec3 emissive = vec3(1., 0.65, 0.4);\n            \n            acc += att * l * emissive;\n            \n            // Sampled ambiance\n            float weight;\n            vec3 reflected = getHemisphereCosineSample(ri.n, weight);\n            \n            vec3 albedo = vec3(.9);\n            \n            att *= weight * albedo * dot(ri.n, reflected);\n            \n            ray = Ray(ri.p, reflected);\n        }\n        // Specular material\n        else {\n            vec3 reflected = reflect(ray.d, ri.n);\n            \n            vec3 albedo = vec3(MIRRORS_REFLECTANCE);\n            \n            att *= albedo;\n            \n            ray = Ray(ri.p, reflected);\n        }\n    }\n    \n    return acc;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    initRandom(fragCoord);\n    \n    // Camera\n    vec2 mousePos = all(equal(iMouse.zw, vec2(0.))) ? vec2(0.85, 0.2) : \n        clamp(2. * iMouse.xy / iResolution.xy - vec2(1.), vec2(-1.), vec2(1.));\n    \n    vec3 cameraPos = CAMERA_POS + vec3(mousePos, 0.) * vec3(3.8, 0.99, 0.);\n    vec3 cameraLookAt = CAMERA_LOOKAT;\n    \n    vec3 cz = normalize(cameraLookAt - cameraPos);\n    vec3 cx = normalize(cross(vec3(0., 1., 0.), cz));\n    vec3 cy = cross(cz, cx);\n    \n    mat3 cameraTransform = mat3(cx, cy, cz);\n    \n    // Render frame\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        vec2 ssaa = vec2(getRandom(), getRandom());\n        vec2 screenCoord = vec2(2. / iResolution.x) * (fragCoord + ssaa) -\n            vec2(1., iResolution.y / iResolution.x);\n        \n        vec3 projCoord = vec3(vec2(.5 * CAMERA_FRAMEWIDTH) * screenCoord, CAMERA_FOCALLENGTH);\n        \n        vec3 rayDirection = cameraTransform * normalize(projCoord);\n        \n        Ray ray = Ray(cameraPos, rayDirection);\n        col += render(ray);\n    }\n    col /= vec3(NUM_SAMPLES);\n    \n    // Frame average\n    float timeDelta = 60. * iTimeDelta;\n    float beta = (iMouse.z > 0.) ? 0.2 : 0.1;\n    float alpha = 1. / (1. + ((1. - beta) / beta) / timeDelta);\n    col = mix(texture(iChannel0, fragCoord / iResolution.xy).rgb, col, alpha);\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}