{
    "Shader": {
        "info": {
            "date": "1533764352",
            "description": "Inspired by the tattoo work of [url=https://www.instagram.com/p/Bl6G0v_gh4d]Cassady Bell[/url].\n\nI remember reading that it was possible to use fwidth to create isolines, turns out it's true!",
            "flags": 0,
            "hasliked": 0,
            "id": "Xt3yDS",
            "likes": 197,
            "name": "Isoline triangle",
            "published": 3,
            "tags": [
                "noise",
                "triangle",
                "lines",
                "perlin",
                "simplex",
                "contour",
                "fwidth",
                "isoline"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 5817
        },
        "renderpass": [
            {
                "code": "// White on black, best fullscreen\n//#define ALTERNATE_VERSION\n\n\n// --------------------------------------------------------\n// Simplex(ish) Noise\n// Shane https://www.shadertoy.com/view/ldscWH\n// --------------------------------------------------------\n\nvec3 hash33(vec3 p) { \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;\n}\n\nfloat tetraNoise(in vec3 p)\n{\n    vec3 i = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec4 v = max(0.5 - vec4(dot(p,p), dot(p1,p1), dot(p2,p2), dot(p3,p3)), 0.0);\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.\n}\n\n// --------------------------------------------------------\n// Triangle distance\n// The corners aren't a correct distance, normally they'd\n// be rounded, but here they're pointy to keep them sharp\n// when drawn with the isolines\n// --------------------------------------------------------\n\nfloat sTri(vec2 p, float radius) {\n    radius /= 2.;\n    vec2 a = normalize(vec2(1.6,1.));\n    return max(\n        dot(p, vec2(0,-1)) - radius,\n        max(\n        \tdot(p, a) - radius,\n        \tdot(p, a * vec2(-1,1)) - radius\n        )\n    );\n}\n\n// --------------------------------------------------------\n// Repeat space and blend the edges\n//\n// Imagine we have the following domain:\n// 0 1 2 3 4 5 6 7 8 9 ...\n//\n// If you repeat with a size of 3, you get hard edges\n// between 2 and 0:\n// 0 1 2 0 1 2 0 1 2 ...\n//\n// You could flip each repetition, but you'd see a visible\n// mirror effect:\n// 0 1 2 2 1 0 0 1 2 ...\n// \n// So instead, take two samples out of phase:\n// 0 1 2 0 1 2 0 1 2 ...\n// 2 0 1 2 0 1 2 0 1 ...\n//\n// And then blend the samples at these points in such a way\n// that the visible joins of one sample are masked by the \n// continuous part of the other sample.\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvec2 smoothRepeatStart(float x, float size) {\n  return vec2(\n      mod(x - size / 2., size),\n      mod(x, size)\n  );\n}\n\nfloat smoothRepeatEnd(float a, float b, float x, float size) {\n  return mix(a, b,\n      smoothstep(\n          0., 1.,\n          sin((x / size) * PI * 2. - PI * .5) * .5 + .5\n      )\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Square uv centered and sclead to the screen height\n    vec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    // Zoom in a bit\n    uv /= 2.;\n\n    #ifdef ALTERNATE_VERSION\n   \t\tuv *= 1.8;\n   \t#endif\n    \n    float repeatSize = 4.;\n    float x = uv.x - mod(iTime, repeatSize / 2.);\n    float y = uv.y;\n\n    vec2 ab; // two sample points on one axis\n\n    float noise;\n    float noiseA, noiseB;\n    \n    // Blend noise at different frequencies, moving in\n    // different directions\n    \n    ab = smoothRepeatStart(x, repeatSize);\n    noiseA = tetraNoise(16.+vec3(vec2(ab.x, uv.y) * 1.2, 0)) * .5;\n    noiseB = tetraNoise(16.+vec3(vec2(ab.y, uv.y) * 1.2, 0)) * .5;\n    noise = smoothRepeatEnd(noiseA, noiseB, x, repeatSize);\n\n    ab = smoothRepeatStart(y, repeatSize / 2.);\n    noiseA = tetraNoise(vec3(vec2(uv.x, ab.x) * .5, 0)) * 2.;\n    noiseB = tetraNoise(vec3(vec2(uv.x, ab.y) * .5, 0)) * 2.;\n    noise *= smoothRepeatEnd(noiseA, noiseB, y, repeatSize / 2.);\n\n    ab = smoothRepeatStart(x, repeatSize);\n    noiseA = tetraNoise(9.+vec3(vec2(ab.x, uv.y) * .05, 0)) * 5.;\n    noiseB = tetraNoise(9.+vec3(vec2(ab.y, uv.y) * .05, 0)) * 5.;\n    noise *= smoothRepeatEnd(noiseA, noiseB, x, repeatSize);\n\n    noise *= .75;\n\n    // Blend with a linear gradient, this gives the isolines a\n    // common orientation (try changing .6 to 1.)\n    noise = mix(noise, dot(uv, vec2(-.66,1.)*.4), .6);\n    \n    // Create anti-aliased even weight isolines from the noise...\n\n    // Break the continuous noise into steps\n    float spacing = 1./50.;\n    float lines = mod(noise, spacing) / spacing;\n\n    // Convert each step into a bump, or, the sawtooth wave\n    // into a triangle wave:\n    //\n    //     /|    /|\n    //   /  |  /  |\n    // /    |/    |\n    //       \n    // to:   \n    //       \n    //   /\\    /\\\n    //  /  \\  /  \\ \n    // /    \\/    \\ \n\n    lines = min(lines * 2., 1.) - max(lines * 2. - 1., 0.);\n    \n    // Scale it by the amount the noise varies over a pixel,\n    // factoring in the spacing scaling that was applied.\n    // noise is used because it's continuous, if we use lines we'd\n    // see stepping artefacts.\n    lines /= fwidth(noise / spacing);\n\t\n    // Double to occupy two pixels and appear smoother\n    lines /= 2.;\n    \n    // Triangle distance\n    float d = sTri(uv + vec2(0,.1), .3);\n    \n    // Create a fuzzy border from 0 - 1 around the triangle, this\n    // controls the pointy shape where lines transition from thick\n    // to thin\n    float weight = smoothstep(.0, .05, d);\n\n    // Adjust to the desired inner and outer weight\n    #ifndef ALTERNATE_VERSION\n    \tweight = mix(4.2, 1.2, weight);\n    #else\n    \tweight = mix(.5, .33, weight);\n    #endif\n    \n    // Scale the weight when fullscreen\n    weight *= iResolution.y / 287.;\n\n    // Offset the line by the weight\n    lines -= weight - 1.;\n    \n    #ifdef ALTERNATE_VERSION\n    \tlines = 1. - lines;\n   \t#endif\n    \n\tfragColor = vec4(vec3(lines),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}