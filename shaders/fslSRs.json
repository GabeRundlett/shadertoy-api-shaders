{
    "Shader": {
        "info": {
            "date": "1621561863",
            "description": "Tennis ball sections.",
            "flags": 0,
            "hasliked": 0,
            "id": "fslSRs",
            "likes": 10,
            "name": "Tennis Ball Sections",
            "published": 3,
            "tags": [
                "sphere",
                "intersection",
                "sections",
                "tennisball"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 144
        },
        "renderpass": [
            {
                "code": "// Settings\n#define AA 3.0 // Subsamples for antialiasing\n#define hc 0.5 // Curve slope\n#define rb 2.0 // Ball radius\n\n// Intersection info\nstruct Intersect {\n    float dist;\n    vec3 pos;\n    vec3 nor;\n};\n\n// Hyperbolic-parabola intersection\nvec3 iHyperParab(in vec3 ro, in vec3 rd, in float h) {\n    float a = rd.y * rd.y - rd.z * rd.z;\n    float b = h * rd.x + ro.y * rd.y - ro.z * rd.z;\n    float c = 2.0 * h * ro.x + ro.y * ro.y - ro.z * ro.z;\n    float discr = b * b - a * c;\n    if (discr < 0.0) return vec3(-1.0, -1.0, 0.0);\n    return vec3((vec2(-1.0, 1.0) * sqrt(discr) - b) / a, 2.0);\n}\n\n// Hyperbolic-parabola normal\nvec3 nHyperParab(in vec3 p, in float h) {\n    return normalize(vec3(h, p.y, -p.z));\n}\n\n// Hyperbolic-parabola implicit equation\nfloat hyperParabImplicit(in vec3 p, in float h) {\n    return 2.0 * h * p.x + p.y * p.y - p.z * p.z;\n}\n\n// Sphere intersection (rd must be normalized)\nvec3 iSphere(in vec3 ro, in vec3 rd, in float r) {\n    float b = dot(ro, rd), c = dot(ro, ro) - r * r;\n    float discr = b * b - c;\n    if (discr < 0.0) return vec3(-1.0, -1.0, 0.0);\n    return vec3(vec2(-1.0, 1.0) * sqrt(discr) - b, 2.0);\n}\n\n// Sphere normal\nvec3 nSphere(in vec3 p, in float r) {\n    return p / r;\n}\n\n// Sphere implicit equation\nfloat sphereImplicit(in vec3 p, in float r) {\n    return dot(p, p) - r * r;\n}\n\n// Map of half of the shape\nIntersect mapHalf(in vec3 ro, in vec3 rd) {\n    float t = -1.0;\n    vec3 tSphere = iSphere(ro, rd, rb), hitPos, n;\n    for (int i=0; i < int(tSphere[2]); i++) {\n        vec3 hitCandid = ro + rd * tSphere[i];\n        if (tSphere[i] > 0.0 && hyperParabImplicit(hitCandid, hc) > 0.0 && (t < 0.0 ? true : (tSphere[i] < t))) {\n            t = tSphere[i];\n            hitPos = hitCandid;\n            n = nSphere(hitPos, rb);\n        }\n    }\n\n    vec3 tCurve = iHyperParab(ro, rd, hc);\n    for (int i=0; i < int(tCurve[2]); i++) {\n        vec3 hitCandid = ro + rd * tCurve[i];\n        if (tCurve[i] > 0.0 && sphereImplicit(hitCandid, rb) < 0.0 && (t < 0.0 ? true : (tCurve[i] < t))) {\n            t = tCurve[i];\n            hitPos = hitCandid;\n            n = nHyperParab(hitPos, hc);\n        }\n    }\n\n    return Intersect(t, hitPos, n);\n}\n\n// Combined\nIntersect mapScene(in vec3 ro, in vec3 rd) {\n    float offs = 0.5 + 0.5 * sin(iTime);\n\n    Intersect h1 = mapHalf(vec3(ro.x - offs, ro.y, ro.z), rd);\n    Intersect h2 = mapHalf(vec3(-ro.x - offs, ro.z, ro.y), vec3(-rd.x, rd.z, rd.y));\n    h2.nor.yz = -h2.nor.zy;\n\n    Intersect whole = h1;\n    if (whole.dist < 0.0 && h2.dist > 0.0 ? true : (h2.dist < 0.0 ? false : (h2.dist < whole.dist))) whole = h2;\n    return whole;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat noise(in vec3 p3) {\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Tricubic noise interpolation\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p), local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise(cell + 1.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x), mix(ldf, rdf, local.x), local.z),\n               mix(mix(lub, rub, local.x), mix(luf, ruf, local.x), local.z),\n               local.y);\n}\n\n// FBM\nfloat fnoise(in vec3 p, in float scale, in int octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int octave=0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvec4 render(in vec2 pixel) {\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 3.14;\n    vec2 uv = (pixel - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0, 0.25, 0.0);\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Render the shape if hitting\n    Intersect scene = mapScene(ro, rd);\n    if (scene.dist > 0.0) {\n        float diff = abs(dot(scene.nor, -rd));\n        color = vec3(0.5, 1.0, 0.0) * (0.75 + 0.5 * fnoise(scene.pos, 5.0, 5));\n        color += 10.0 * max(0.0, 1.0 - max(max(hyperParabImplicit(scene.pos, hc), sphereImplicit(scene.pos, rb)) + 0.75, -sphereImplicit(scene.pos, rb + 0.15)));\n        color *= diff;\n    }\n\n    color = pow(color, vec3(0.75));\n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float aaStep = 1.0 / AA;\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            fragColor += render(fragCoord + vec2(xOffs, yOffs));\n        }\n    }\n\n    fragColor /= AA * AA;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}