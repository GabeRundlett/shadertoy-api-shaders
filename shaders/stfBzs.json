{
    "Shader": {
        "info": {
            "date": "1651310426",
            "description": "Wrote this quite some time ago. at the moment things don't look good that i will ever finish or polish this peace as it deserves, so i let it free.\nEnjoy!",
            "flags": 8,
            "hasliked": 0,
            "id": "stfBzs",
            "likes": 29,
            "name": "pt. III",
            "published": 3,
            "tags": [
                "sound",
                "reverberation",
                "fnd"
            ],
            "usePreview": 0,
            "username": "nabr",
            "viewed": 673
        },
        "renderpass": [
            {
                "code": "\n#define Z iTime\n#define T (Z<7.8?1.:.9*Z+exp(min(1.-Z+8.,1.)))*max(1.-(Z-2.),1.)*min(2.,max(1.,Z))+(1.-Z)\n#define dmin(a,b)((a.x<b.x)?a:b)\n#define Rt(p,a)(p=cos(a)*p+sin(a)*vec2(p.y,-p.x))\n\n#define S smoothstep\n#define R iResolution.xy\n\nvoid scene0(out vec4, in vec2);\n// https://www.shadertoy.com/view/MscSDB by Shane\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvoid path(inout vec2 p, inout float z){float s = sin(z/24.) * cos(z/16.); p += vec2(s*9.,1e-5);}\n\nvoid L(in vec3 lp,in float lpd, inout float sp)\n{\n    vec2 sn = vec2(1);\n    \n    Rt(sn, 6.*T);\n    lp = vec3(lp.xy+.5*sn,  lp.z-lpd);\n    sp = length(lp)-.2;\n}\n\nvec2 f(in vec3 p) \n{\n  float dl0 = 1e8, dl1 = 1e8;\n  float zp = cos(T)*2.*p.z;\n  path(p.xy, zp );\n  vec3 lp = p;\n  L(lp,7., dl0);\n  L(vec3(-lp.xy, lp.z), 8., dl1);\n  p.z+=8.*T;\n  #define repM(_x,_y)(_y*.5-mod(_x,_y))\n  vec3 gls =p,krs = p,kln = p;\n  \n  // -------- klingen\n  kln.x = atan(p.y, p.x) * 2.86478;\n  kln.xy = repM(vec2(kln.x, p.z), vec2(3));\n  kln.z = length(vec2(p.x, p.y)) - (Z < 8.2 ? (1.4 + (sin(Z) * .5 + .5)) : 2.7);\n  kln = abs(kln) - vec3(1., .125, .4);\n  float fkln = length(max(vec3(.1001, -.1001, -.1), kln)) + min(max(kln.x, max(kln.y, kln.z)), 0.) - .125;\n  \n  // -------- kreise\n  krs.xz = repM(vec2(0, p.z + 1.5), vec2(3));\n  krs.y = length(p.xy) - 2. + (cos(T) * .2 + .2);\n  krs = abs(krs) - vec3(.25, .25, .25);\n  float fkrs = length(vec2(krs.y, krs.z)) - .125;\n  \n  // -------- gleise\n  gls.x = T + atan(p.y, p.x) * 3.81971;\n  gls.xz = repM(gls.xz, vec2(3., 1.125));\n  gls.y = length(p.xy) - 2.;\n  gls = abs(gls) - vec3(1, .125, .45);\n  float fgls = length(max(vec3(-.124, .095, .05), gls)) + min(max(gls.x, max(gls.y, gls.z)), 0.) - .125;\n\n  if(Z>15.&&Z<19.)\n  {\n  float tb = float(mod(Z, 4.)>1.);\n  fgls = max(fgls,tb);\n  fkrs = max(fkrs,tb);\n  }\n  if(Z>20.)fkln = 1000.;\n  return dmin(vec2(min(dl1,dl0),7.),dmin(vec2(min(fkrs,fgls), 3.),vec2(fkln,5.)));\n}\n\n// https://www.shadertoy.com/view/4tdfDH\nfloat ps(in vec3 p, in vec3 light_p)\n{\n    vec3 l = normalize(light_p - p);\n    float t = 0.15;\n    float t_max = distance(light_p, p);\n    float res = 1.0;\n    for (int i = 0; i < 64; ++i)\n    {\n        if (t > t_max)\n            break;\n        float d = f(p + t * l).x;\n        if (d < 0.01)\n            return 0.0;\n        t += d;\n        res = min(res, 8.0 * d / t);\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec4 col = vec4(0.), bg = col;\n    scene0(bg, fragCoord);\n    \n    vec2 RR = iResolution.xy;\n    vec2 st = (2. * fragCoord.xy - RR.xy) / min(RR.x, RR.y);\n   \n    vec3 ro = vec3(0, 0, 0)+1e-4, rd = vec3(0);\n    rd = normalize(vec3(st, 2.));\n     \n \n\t// -------- raymarch\n\tconst vec2 e = vec2(.0001,0);\n\tconst float MAX_DIST =  20.;\n\tfloat h = 0.;\n\tvec3 p = ro;\n    vec2 d = vec2(-1);\n\tfor (uint i = 0u; i < 64u ; ++i)\n\t{\n\t\td = f((ro + rd * h));\n        if(abs(d.x) <( e.x*h) && h < MAX_DIST)break;\n        h += d.x;\n\t\t\n\t} \n  \n\tif(h<MAX_DIST)\n\t{\n    p = (ro + rd * h) ;\n\tvec3 N = normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x,f(p+e.yxy).x-f(p-e.yxy).x,f(p+e.yyx).x-f(p-e.yyx).x));\n    \n    vec3 lp0 = vec3(p.xy*.5+.5, 6.);\n    vec3 lp1 = vec3(p.xy*.5+.5, 12.);\n    \n    float dmy = 1.;\n    L(lp0, dmy, dmy);\n    L(vec3(-lp1.xy, lp1.z), dmy,dmy);\n    \n    float lr0 =  8. / pow(max(0., dot(lp0 - p, lp0 - p)), 2.);\n    float lr1 = 15. / pow(max(0., dot(lp1 - p, lp1 - p)), 2.);\n\n    float dl = ps(p, lp0) * max(0.0, dot(N, normalize(lp0 - p)))  *  lr0 \n               + ps(p, lp1) * max(0.0, dot(N, normalize(lp1 - p)) ) * lr1 ;\n\n    float spc = pow(max(dot(N, -rd), 0.), 2.)+1e-5;\n    \n\n    col.xyz = vec3(0.745,0.729,0.953);\n    \n    col.xyz = mix(col.xyz*spc*h*.01, col.xyz*dl*spc, 1.0);\n    \n    if(d.y==7.)col.xyz = vec3(1);\n\t}\n  \n\tfragColor =  vec4(pow(col.xyz, vec3(.454545)), 1.);\n    \n    (Z>8.&&Z<11.05)?\n    fragColor = mix(col,bg, step(fract(2.65*T), .5)):\n    (Z>24.)?\n    fragColor = mix(col,bg, .1):fragColor;\n}\nfloat pvalnoise(in vec2 uv) \n{\n        const float k = 212.;\n        vec4 l = vec4(floor(uv), fract(uv));\n        float u = l.x + l.y * k;\n        vec4 v = vec4(u, u + 1.,u + k, u + k + 1.);\n        v = fract(fract(1.23456789 * v) * v / .987654321);\n        l.zw = l.zw * l.zw * (3. - 2. * l.zw);\n        l.x = mix(v.x, v.y, l.z);\n        l.y = mix(v.z, v.w, l.z);\n        return mix(l.x, l.y, l.w);\n}\nfloat glw = 0.;\nfloat f0(in vec3 p) \n{    \n     Rt(p.xy, T);Rt(p.yz, T);\n     float h = 0.1, w = .98, m = 12.8;\n     vec3 v = vec3(.5+atan(p.z, p.x)/6.28, p.y, acos(p.y/length(p))/3.14159);\n     for(int i = 1; i < 7; i++)\n     h += S(-1.6, 2.7, ((w *=.5)*pvalnoise((v.xy*(m*=2.)))));\n     float d = length(p)-1.5+.45*h;\n     glw = 1. / ( 1.0 + pow(abs(d*.2),.5));\n     return d;\n}\nvec3 N1(in vec3 p){\nfloat d=f0(p);\nvec2 e=vec2(.001,0);vec3 n=d-vec3(f0(p-e.xyy),f0(p-e.yxy),f0(p-e.yyx));return normalize(n);\n}\nvoid scene0( out vec4 O, in vec2 U )\n{\n   vec2 st = (U-.5*R)/max(R.y, R.x);\n   vec4 c = vec4(0);\n   #define repM(_x,_y)(_y*.5-mod(_x,_y))\n   // tile screen\n   st = repM(abs(st)-vec2(0., 0.), vec2(1., 1.));\n    \n  \n    vec3 ro = vec3(-1.25, -1.75, 10.), //\n         rd = normalize(vec3(st, -2.)),\n         lp = vec3(1., 4., 5);\n    float d = 0.;\n    for(int i=0; i<18; i++) \n    {  \n     float h = (f0((ro + rd * d)));\n     if(abs(h)<.001) h=.42;\n     c.w+=(.5+h)*.05;\n     d += h;\n    }\n    vec3 p = ro + rd * d, \n         n = N1(p),\n         ld = normalize(lp-p);\n    c.xyz = vec3(0.502,0.251,0.251) * max(0., dot(n, ld))+pow(max(dot(n, -rd), 0.), 3.)+1e-5;\n    c.xyz = mix(c.xyz, vec3(0.318,0.635,0.635)*glw, clamp(.5*c.w, 0., 1.));\n    c.xyz = pow(c.xyz, vec3(.4545));\n    O = c;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define _f(_x)(fract(_x))\n#define S smoothstep\n#define pi (4.*atan(1.))\n#define pih (2.*atan(1.))\n\n\nfloat flt(in float rt, in float y)\n{\n    float yy = 0.;\n    yy = (sin(.5 * rt) * .5 + .5) + 1.29 - cos(2.71 * y) / tan(1.33 + sin(y));\n    yy = mix(abs(y), cos(-2.71 * y) / (-1.39 + sin(y)), .5);\n    return yy;\n}\n\nfloat drm_cl(float t, float ml, float mx)\n{\n    float ft = _f( mx * t );\n    return sin(ml * 4084.015 * ft )  * exp( -100.* ft ) ;\n}\n\nfloat synth(in float rt, in float t, int ch)\n{\n\n    float yes = 0., yes1 = 0.;\n    float yba = 0.;\n    float yma = 0.;\n\n    // float emx = 3.;\n    float emx = 6.;\n    if (rt > 8.)\n        emx = 12.;\n    if (rt > 20.)\n        emx = 3.;\n\n    float ft1 = _f(2.0 * t), ft2 = _f(emx * t), ft3 = _f(0.5 * t);\n    float x = sin(ft1 * 0.04 + .5);\n    float ph = x * 17152.863;\n    vec4 vp = x + vec4(.81, .95, .63, 1.9);\n    float p0 = ph * vp[int(emx * t) % 4];\n    float p1 = ph * vp[int(.5 * t) % 4];\n\n    float xb = ft3 * 0.02 + .5;\n    vec4 vb = xb * vec4(1.89, 1., 2.01, 1.87);\n    float p2 = 1.11 * 17152.863 * vb[int(.5 * t) % 4];\n\n    yma = sin(p1); //soft with accents\n   \n    \n    yes = atan(sin(p0), cos(p0)); //\n    \n    if (rt > 12. && rt < 24.) //====================INTRO electro synth\n        yes = mix(atan(sin(p0), sin(.5 * p0)), atan(sin(p0), cos(p0)), (sin(2. * rt) * .5 + .5));\n\n    yba = atan(sin(p2), cos(p2));//bass\n\n    yma = flt(rt, yma);\n\n    if (rt > 24.)//apply filter for smoother sound \n        yes = flt(rt, yes) * S(0., 5., (rt - 24.));\n\n    yba = flt(rt, yba);\n    \n    \n    yma *= min(1., 41.1 * ft1) * max(0., 1. - ft1);\n    /*yma = clamp(yes, -1., 1.);\n    \n    return yma;\n    */\n    yes *= min(1., 44.1 * ft2) * max(0., 1. - ft2);\n    yes = clamp(yes, -1., 1.);\n    \n    yba *= min(1., 44.1 * ft3) * max(0., 1. - ft3);\n\n\n    //========================= SUPPORT INSTRUMENS\n    \n    float n = t * 8238.1;\n    n = _f(n * _f(t + n)); //noise\n    \n    // claves\n    float bft = mod(rt, 8.) > 2. ? 2. : 6.;\n    bool dclkbol = mod(rt, 10.) > 8.;\n    float one = 1.;\n    float clk = dclkbol ? sin(8545.42955 * t + .7 * dot(one, n)) * exp(-5. * _f(bft * t)) : 0.;\n    \n    // weird sound\n    float en = ft1; //_f(2. * t);\n    bool ebol = mod(rt, 4.) > 1.;\n    float efx = .5 * sin(t * vec3(13, 5, 17)[int(t) % 3]) + cos(13. * exp(1. - pow(1. - en, 100.)));\n    float e = ebol ? 1e-1 :efx;\n    float fxx = drm_cl(e + .5 * t, .125, 6.);\n    \n    if(mod(rt,102.)>92.)//====================OUTRO ?\n    return 0.08*drm_cl(efx + .5 * t, .5, 1.)*S(1., 0., (mod(rt, 102.) - 95.)/4.);\n    \n    // bongos\n    float ftbng = _f(6. * t);\n    float g = 0.;\n    g = mix(1.11, 1.48, smoothstep(0., 1., float(int(rt) % 3)));\n    float bng = sin(1191.2549 * g * t) * exp(-5.5 * ftbng);\n    bng *= float[](1., 0., 1., 0., 0., 1., 0., 1., 0., 1.)[int(3. * t) % 10];\n    bng *= min(1., 188.2 * ftbng) * max(0., 1. - ftbng);\n    \n    //=================INTRO\n    if(rt > 20.){\n        #define I_ S(0.,\n        #define _I rt-20.);\n\n        yba *= I_ 2., _I \n        bng *= I_ 6., _I \n        clk *= I_ 1., _I \n        yma *= I_ 5., _I \n        fxx *= I_ 12., .9 * _I\n    }\n    else {\n        fxx = 0.;clk = 0.;bng = 0.;yma = 0.;yba = 0.;\n    }\n\n    yes *= (rt < 24.) ? (1./2.) : 1.;\n\n    \n    if(mod(rt, 92.) < 50.)\n    //if (rt < 50.)\n    {\n        //return ((yes + .5 * yma + .1 * clk) + ((.4 * yba + .5 * bng) + .4 * fxx)) *\n        //       S(1., 0., (mod(rt, 92.) - 47.)/4.);//fade out\n               \n        return \n        (.3 * fxx + .3 * yes + .1 * clk  + .4 * yba + .6 * yma + .6 * bng) ;\n             //  S(1., 0., (mod(rt, 92.) - 47.)/4.));//fade out\n    }\n    else{//====================BRIDGE    \n        \n        yba = atan(sin(4. * p2), cos(2.1 * p2));\n        yba = clamp(yba, -1., 1.);\n        yba *= min(1., 44.1 * ft3) * max(0., 1. - ft3);\n        yba *= max(0., .35 * n + 1. - dot(_f(8. * t), _f(8. * t)));\n        yba = mod(t, 6.) > 2. ? .25 * (yba) : 0.;\n\n        float hht = clamp((1. - n * exp(-4. * _f(8. * t))), -1., 1.) * exp(-5. * _f(8. * t));\n        float xe = pow(max(_f(2. * t), .004), .13);\n        float kft = _f(3. * t);\n        float kck = sin(250.5 * xe) * min(1., 44.1 * kft) * max(0., 1. - kft);\n        //e = (.5 * sin(t * vec3(13, 5, 17)[int(t) % 3]) + cos(13. * exp(1. - pow(1. - en, 100.))));\n        fxx = drm_cl(efx + .5 * t, (cos(rt) * .4 + .4) + .1, 2.);\n        fxx *= (sin(rt) * .5 + .5);\n\n        yma = .5 * sin(.1 + p1) + abs(.5 * sin(p1));\n        yma *= S(0., 1., (mod(rt, 92.) - 58.) / 4.);\n        return .7*(.7 * kck + .3 * hht + yba + .3 * yma + .2 * fxx);\n    }\n\n}\n\nvec2 mainSound(in int samp, float t)\n{\n   \n    float xx = 6.;\n    float islVal2 = 2.8031;\n    float islVal3 = 3.5301;\n    \n    if(t > 3.)\n       xx = max(6. - (t - 3.), min(1.22, 6.));\n\n    if(t > 7.7)\n       islVal3 = min(4.7, islVal3 + (t - 7.3));\n\n    if(t > 15.2)\n       islVal2 = min(8.9841, islVal2 + (t - 9.));\n\n    if(t > 24.)\n    {\n       islVal2 = 5.166;\n       islVal3 = 3.1292893;\n    }\n    if(t > 32.)\n    {\n       islVal2 = min(5.707106, islVal2 + (t - 32.));\n    }\n    if(t > 40. && t < 46.)\n    {\n       islVal2 = 4.66;\n       islVal3 = 4.78;\n    }\n    if(mod(t, 92.) > 50.)\n    {\n        islVal2 = 2.8031;\n        islVal3 = 3.5301;\n\n        if(mod(t, 6.) > 4.)\n        {\n            islVal2 = 6.8;\n            islVal3 = 3.2;\n        }\n    }\n\n    vec2 y = vec2(1e-6);\n    vec4 v = vec4(0., 0., 0., 0.);\n\n    float mt = 0.;\n    (t < 16.) ? (mt = mod(t, 16.)):(mt = t);\n\n    float dlt = mt;\n\n    const vec4 dt = vec4(577, 601, 641, 661);\n    \n    /*\n    wrote this comment while back, i have no idea what i means... hahaha\n    \n    the improvement here: the same gain coefficient, it makes it easier to control\n    in this case a hole number on the smoothstep makes the reverberation stable  e.g 7.2 + 3.7\n    */\n    \n    const float g = 1. / 1200.;\n    \n    const vec4 A = vec4(0, -1, 1, 0) * g;\n\n    for(uint j = 0u; j < 4u; ++j)\n        for(uint i = 0u; i < 12u; ++i)\n        {\n            float fdn = 0.;\n            fdn += smoothstep(-islVal3, islVal2, dot(A, dt) * g);\n            dlt += fdn;\n\n            v.xw = vec2(.7) * synth(mt, dlt, 0) * exp(-xx * fdn);\n            v.yz = vec2(.2) * synth((mt + 1e-5 * (11. * sin(mt) + 15. * cos(mt))), mt, 0);\n            (i % 2u == 0u) ? (y.x += v[i % 4u]) : (y.y += v[i % 4u]);\n        }\n        \n    (y*=(1./6.));  \n    return y;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}