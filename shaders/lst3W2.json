{
    "Shader": {
        "info": {
            "date": "1452574056",
            "description": "A proof of concept. Still needs some work (pretty rough visually, no score, additional code clean up).\n\nControls\narrow keys: move\nrotate: a/d/space/up",
            "flags": 48,
            "hasliked": 0,
            "id": "lst3W2",
            "likes": 15,
            "name": "Shadertris",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "interactive",
                "multipass"
            ],
            "usePreview": 0,
            "username": "AxleMike",
            "viewed": 1330
        },
        "renderpass": [
            {
                "code": "// Based on iq's brick game: https://www.shadertoy.com/view/MddGzf\n\n// Modified has unique colors per block and some 5-pieces\n#define MODIFIED 1\n#define CLASSIC 2\n#define MODE MODIFIED\n\n#if (MODE == MODIFIED)\nconst int CELLS_WIDE = 13;\nconst float NUM_BLOCK_TYPES = 8.0;\n#else\nconst int CELLS_WIDE = 10;\nconst float NUM_BLOCK_TYPES = 7.0;\n#endif\nconst int CELLS_TALL = 20; // hide the top four cells so we don't see shapes spawning\n\nconst float fCELLS_WIDE = float(CELLS_WIDE);\nconst float fCELLS_TALL = float(CELLS_TALL);\nconst int HALF_CELLS_WIDE = CELLS_WIDE / 2;\nconst int HALF_CELLS_TALL = CELLS_TALL / 2;\nconst float fHALF_CELLS_WIDE = float(HALF_CELLS_WIDE);\nconst float fHALF_CELLS_TALL = float(HALF_CELLS_TALL);\n\nconst float PI = 3.14159265359;\n\n// Block Types\nconst float I_BLOCK = 1.0;\nconst float J_BLOCK = 2.0;\nconst float L_BLOCK = 3.0;\nconst float O_BLOCK = 4.0;\nconst float S_BLOCK = 5.0;\nconst float T_BLOCK = 6.0;\nconst float Z_BLOCK = 7.0;\nconst float PLUS_BLOCK = 8.0;\nconst float MAX_BLOCK = 9.0;\n\n// storage register/texel addresses\nconst vec2 txGameInfo0      \t\t= vec2(0.0, 0.0); // x = game state, y = time in current state, z = time till next spin, time till next move\nconst vec2 txGameInfo1 \t    \t\t= vec2(1.0, 0.0); // x = score, y = total lines cleared, z = highScore, w = drop speed\nconst vec2 txGameInfo2 \t    \t\t= vec2(2.0, 0.0); // x = current test row, y = kill/copy row, z = next block type, w = current multipler\nconst vec2 txControlledBlockInfo0 \t= vec2(3.0, 0.0); // xy = position, z = rotation, w = block type\nconst vec2 txControlledBlockInfo1 \t= vec2(4.0, 0.0); // x = time till drop, y = next block type, z = space released\nconst vec4 txBlocks \t\t\t\t= vec4(0.0, 1.0, float(CELLS_WIDE), 1.0 + float(CELLS_TALL));  // x = taken, y = color, z = destory, w = time till death\n\n// Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvec3 GetColor(in float colorType, in vec2 textCoord)\n{\n    vec3 color = vec3(0.0);\n    \n    if(colorType == I_BLOCK)\n    \tcolor = vec3(0.5, 1.0, 1.0); // cyan\n    else if(colorType == J_BLOCK)    \n        color = vec3(0.0, 0.0, 1.0); // blue\n    else if(colorType == L_BLOCK)    \n        color = vec3(1.0, 0.5, 0.0); // orange\n    else if(colorType == O_BLOCK)    \n        color = vec3(1.0, 1.0, 0.0); // yellow\n    else if(colorType == S_BLOCK)    \n        color = vec3(0.0, 1.0, 0.5); // lime green\n    else if(colorType == T_BLOCK)    \n        color = vec3(0.5, 0.0, 1.0); // purple\n    else if(colorType == Z_BLOCK)    \n        color = vec3(1.0, 0.0, 0.0); // red\n    else if(colorType == PLUS_BLOCK)    \n        color = vec3(1.0, 0.7, 0.8); // pink\n\telse if(colorType == MAX_BLOCK)\n        color = vec3(1.0);\n\n    vec2 q = abs(textCoord);   \n    vec2 t = step(vec2(0.9), q);\n    return mix(color * 0.0, + color, vec3(1.0 - length(q * q)));\n}\n\nvec4 GetCollisionSetA(in float blockType)\n{\n    if(blockType == I_BLOCK)\n   \t\treturn vec4(0.0, 0.0, 0.0, 1.0);    \n    else if(blockType == J_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);     \n    else if(blockType == L_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(0.0, 0.0, 0.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);     \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);    \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0); \n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetB(in float blockType)\n{\n    if(blockType == I_BLOCK)\n    \treturn vec4(0.0, 2.0, 0.0, 3.0);     \n    else if(blockType == J_BLOCK)\n        return vec4(-1.0, 0.0, 1.0, 1.0);    \n    else if(blockType == L_BLOCK)\n        return vec4(-1.0, 0.0, -1.0, 1.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(1.0, 0.0, 1.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, -1.0, 1.0, -1.0);    \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);      \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, -1.0, -1.0, -1.0);\n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);\n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetC(in float blockType)\n{\n    if(blockType == I_BLOCK)\n        return vec4(0.0);\n    else if(blockType == J_BLOCK)\n        return vec4(0.0);\n    else if(blockType == L_BLOCK)\n         return vec4(0.0);\n    else if(blockType == O_BLOCK)\n        return vec4(0.0); \n    else if(blockType == S_BLOCK)\n\t\treturn vec4(0.0);\n    else if(blockType == T_BLOCK)\n        return vec4(-2.0, 0.0, 0.0, 0.0);\n    else if(blockType == Z_BLOCK)\n        vec4(0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);\n\treturn vec4(0.0);  \n}\n\nvec3 CheckForUserBlockColor(in vec4 controlledBlockInfo, in vec2 blockInfoCoords, in vec2 localBlockCoords, in float colorType)\n{\n    vec2 position = controlledBlockInfo.xy;\n    float rotation = controlledBlockInfo.z;\n    float blockType = controlledBlockInfo.w;\n    \n    vec4 collisionSetA = GetCollisionSetA(blockType);\n    vec4 collisionSetB = GetCollisionSetB(blockType);\n    vec4 collisionSetC = GetCollisionSetC(blockType);\n    \n    float theta = rotation * PI * 0.5;\n    \n    // floor calls added to fix issues on IE\n    mat2 rotationMatrix = mat2(floor(cos(theta) + 0.05), -floor(sin(theta) + 0.05), floor(sin(theta) + 0.05), floor(cos(theta) + 0.05)); \n    \n    if(blockType != O_BLOCK)\n    {\n    \tcollisionSetA.xy *= rotationMatrix;\n    \tcollisionSetA.zw *= rotationMatrix;\n    \tcollisionSetB.xy *= rotationMatrix;\n    \tcollisionSetB.zw *= rotationMatrix;\n    \tcollisionSetC.xy *= rotationMatrix;\n    \tcollisionSetC.zw *= rotationMatrix;\n    }\n    \n    vec2 c0 = floor(position + collisionSetA.xy);\n    vec2 c1 = floor(position + collisionSetA.zw);\n    vec2 c2 = floor(position + collisionSetB.xy);\n    vec2 c3 = floor(position + collisionSetB.zw);\n    vec2 c4 = floor(position + collisionSetC.xy);\n    vec2 c5 = floor(position + collisionSetC.zw);\n       \n    vec2 blockIndex = floor(vec2((blockInfoCoords.x * fCELLS_WIDE), (blockInfoCoords.y * fCELLS_TALL)));\n    \n#if (MODE == MODIFIED)\n    if((blockIndex == c0) || (blockIndex == c1) || (blockIndex == c2) || (blockIndex == c3) || (blockIndex == c4) || (blockIndex == c5))\n#else\n    if((blockIndex == c0) || (blockIndex == c1) || (blockIndex == c2) || (blockIndex == c3))   \n#endif\n    {\n        return GetColor(colorType, localBlockCoords);\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float fieldAspectRatio = float(CELLS_WIDE) / float(CELLS_TALL);\n    const float inverseFieldAspectRatio = 1.0 / fieldAspectRatio;\n   \n    float aspectRatio = (iResolution.x / iResolution.y);\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 uv =  2.0 * screenCoord - 1.0; \n\n    // load game state\n    vec4 gameInfo0 = LoadValue(txGameInfo0);\n    vec4 gameInfo1 = LoadValue(txGameInfo1);\n    vec4 gameInfo2 = LoadValue(txGameInfo2);\n    vec4 controlledBlockInfo0 = LoadValue(txControlledBlockInfo0);\n    vec4 controlledBlockInfo1 = LoadValue(txControlledBlockInfo1);\n    \n    vec3 finalColor = vec3(0.0);\n    \n\t// Blocks\n    vec2 blockInfoCoords = vec2(uv.x * inverseFieldAspectRatio + 0.5, (1.0 - (screenCoord.y - 0.1979)));\n    vec2 localBlockCoords = vec2(blockInfoCoords.x * fCELLS_WIDE, blockInfoCoords.y * fCELLS_TALL);\n    localBlockCoords = (localBlockCoords - floor(localBlockCoords)) * 2.0 - 1.0;\n\n    if((blockInfoCoords.x > 0.0) && (blockInfoCoords.x < 1.0))\n    {   \n        vec2 blockIndex = floor(vec2((blockInfoCoords.x * fCELLS_WIDE), (blockInfoCoords.y * fCELLS_TALL)));\n        vec4 blockInfo = texture(iChannel0, (0.5 + txBlocks.xy + blockIndex) / iChannelResolution[0].xy, -100.0);\n        \n        if(blockInfo.x == 2.0) // hack for a clear block flash\n            finalColor.rgb = GetColor(MAX_BLOCK, localBlockCoords);\n        else if(blockInfo.x == 1.0)\n            finalColor.rgb = GetColor(blockInfo.y + ((blockInfo.x - 1.0) * MAX_BLOCK), localBlockCoords);\n        \n         if(controlledBlockInfo0.w != 0.0) // Player Block\n            finalColor.rgb += CheckForUserBlockColor(controlledBlockInfo0, blockInfoCoords, localBlockCoords, controlledBlockInfo1.w);\n    }\n    else if((blockInfoCoords.x > -0.1) && (blockInfoCoords.x < 1.1))\n    {\n        float gradient = (cos(abs(uv.x) * 110.0));\n        finalColor.rgb = vec3(gradient * gradient * 0.5 + 0.2);\n    }\n    else\n    {\n        finalColor = vec3(screenCoord, 0.5 + 0.5 * sin(iTime)) * 0.33334;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Alexander Lemke, 2016\n// Based on iq's brick game: https://www.shadertoy.com/view/MddGzf\n\n// Modified has unique colors per block and some 5-pieces\n#define MODIFIED 1\n#define CLASSIC 2\n#define MODE MODIFIED\n\n#define RANDOM_COLOR_BLOCKS 1\n\n#if (MODE == MODIFIED)\nconst int CELLS_WIDE = 13;\nconst float NUM_BLOCK_TYPES = 8.0;\n#else\nconst int CELLS_WIDE = 10;\nconst float NUM_BLOCK_TYPES = 7.0;\n#endif\nconst int CELLS_TALL = 24;\n\nconst float fCELLS_WIDE = float(CELLS_WIDE);\nconst float fCELLS_TALL = float(CELLS_TALL);\nconst int HALF_CELLS_WIDE = CELLS_WIDE / 2;\nconst int HALF_CELLS_TALL = CELLS_TALL / 2;\nconst float fHALF_CELLS_WIDE = float(HALF_CELLS_WIDE);\nconst float fHALF_CELLS_TALL = float(HALF_CELLS_TALL);\n\nconst float PI = 3.14159265359;\n\n// Block Types (empty is 0.0)\nconst float I_BLOCK = 1.0;\nconst float J_BLOCK = 2.0;\nconst float L_BLOCK = 3.0;\nconst float O_BLOCK = 4.0;\nconst float S_BLOCK = 5.0;\nconst float T_BLOCK = 6.0;\nconst float Z_BLOCK = 7.0;\nconst float PLUS_BLOCK = 8.0;\n\n// storage register/texel addresses\nconst vec2 txGameInfo0      \t\t= vec2(0.0, 0.0); // x = game state, y = time in current state, z = time till next spin, time till next move\nconst vec2 txGameInfo1 \t    \t\t= vec2(1.0, 0.0); // x = score, y = lines cleared, z = highScore, w = drop speed\nconst vec2 txGameInfo2 \t    \t\t= vec2(2.0, 0.0); // x = current test row, y = destory/copy row, z = next block type, w = current multipler\nconst vec2 txControlledBlockInfo0 \t= vec2(3.0, 0.0); // xy = position, z = rotation, w = block type\nconst vec2 txControlledBlockInfo1 \t= vec2(4.0, 0.0); // x = time till drop, y = next block type, z = space released, w = block color\nconst vec4 txBlocks \t\t\t\t= vec4(0.0, 1.0, float(CELLS_WIDE), 1.0 + float(CELLS_TALL));  // x = taken, y = color, z = destory, w = time till death\n\n// Keys\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_E     = 69.5/256.0;\n\n// IsInside/Saving/Loading code is from IQ's shader: https://www.shadertoy.com/view/MddGzf\nfloat IsInside(in vec2 p, in vec2 c) { vec2 d = abs(p - 0.5 - c) - 0.5; return -max(d.x, d.y); }\nfloat IsInside(in vec2 p, in vec4 c) { vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; return -max(d.x, d.y); }\n\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvoid StoreValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid StoreValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nfloat GetRandomBlock(in float seed)\n{\n    vec3 value = texture(iChannel2, seed * iTime * vec2(12.9898, 78.233 + iTime)).rgb;\n    return floor(mod((value.x + value.y * 7.13 + value.z * 131.0), NUM_BLOCK_TYPES) + 1.0);\n}\n\nvec4 GetBlockInfo(in vec2 blockPosition)\n{  \n    return LoadValue(txBlocks.xy + blockPosition);\n}\n\nbool IsCellValid(in vec2 blockPosition)\n{\n\tbool blockOutOfBounds = (blockPosition.x < 0.0 || blockPosition.x >= (fCELLS_WIDE - 0.1) \n                            || blockPosition.y < 0.0 || blockPosition.y >= (fCELLS_TALL - 0.1)); \n                             \n    return blockOutOfBounds || (GetBlockInfo(blockPosition).x != 0.0) || (GetBlockInfo(blockPosition).y != 0.0);    \n}\n\nvec4 GetCollisionSetA(in float blockType)\n{\n    if(blockType == I_BLOCK)\n   \t\treturn vec4(0.0, 0.0, 0.0, 1.0);    \n    else if(blockType == J_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);     \n    else if(blockType == L_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(0.0, 0.0, 0.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);     \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0);    \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, 0.0, 1.0, 0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 0.0, -1.0, 0.0); \n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetB(in float blockType)\n{\n    if(blockType == I_BLOCK)\n    \treturn vec4(0.0, 2.0, 0.0, 3.0);     \n    else if(blockType == J_BLOCK)\n        return vec4(-1.0, 0.0, 1.0, 1.0);    \n    else if(blockType == L_BLOCK)\n        return vec4(-1.0, 0.0, -1.0, 1.0);    \n    else if(blockType == O_BLOCK)\n        return vec4(1.0, 0.0, 1.0, 1.0); \n    else if(blockType == S_BLOCK)\n        return vec4(0.0, -1.0, 1.0, -1.0);    \n    else if(blockType == T_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);      \n    else if(blockType == Z_BLOCK)\n        return vec4(0.0, -1.0, -1.0, -1.0);\n    else if(blockType == PLUS_BLOCK)\n        return vec4(0.0, 1.0, 0.0, -1.0);\n\treturn vec4(0.0);    \n}\n\nvec4 GetCollisionSetC(in float blockType)\n{\n    if(blockType == I_BLOCK)\n        return vec4(0.0);\n    else if(blockType == J_BLOCK)\n        return vec4(0.0);\n    else if(blockType == L_BLOCK)\n         return vec4(0.0);\n    else if(blockType == O_BLOCK)\n        return vec4(0.0); \n    else if(blockType == S_BLOCK)\n\t\treturn vec4(0.0);\n    else if(blockType == T_BLOCK)\n        return vec4(-2.0, 0.0, 0.0, 0.0);\n    else if(blockType == Z_BLOCK)\n        vec4(0.0);   \n    else if(blockType == PLUS_BLOCK)\n        return vec4(1.0, 0.0, 0.0, 0.0);\n\treturn vec4(0.0);  \n}\n\nbool CheckForBlockCollisions(in vec4 blockInfo)\n{\n    // Get the collision offsets for whatever the blocktype is \n    bool hasCollided = false;\n    \n    vec2 position = blockInfo.xy;\n    float rotation = blockInfo.z;\n    float blockType = blockInfo.w;\n    \n    vec4 collisionSetA = GetCollisionSetA(blockType);\n    vec4 collisionSetB = GetCollisionSetB(blockType);\n    vec4 collisionSetC = GetCollisionSetC(blockType);\n    \n    float theta = rotation * PI * 0.5;\n    // floor calls added to fix issues on IE\n    mat2 rotationMatrix = mat2(floor(cos(theta) + 0.05), -floor(sin(theta) + 0.05), floor(sin(theta) + 0.05), floor(cos(theta) + 0.05)); \n    \n    // O_BLOCK doesn't need to rotate\n    if(blockType != O_BLOCK)\n    {\n    \tcollisionSetA.xy *= rotationMatrix;\n    \tcollisionSetA.zw *= rotationMatrix;\n    \tcollisionSetB.xy *= rotationMatrix;\n    \tcollisionSetB.zw *= rotationMatrix;\n    \tcollisionSetC.xy *= rotationMatrix;\n    \tcollisionSetC.zw *= rotationMatrix;\n    }\n    vec2 c0 = position + collisionSetA.xy;\n    vec2 c1 = position + collisionSetA.zw;\n    vec2 c2 = position + collisionSetB.xy;\n    vec2 c3 = position + collisionSetB.zw;\n    vec2 c4 = position + collisionSetC.xy;\n    vec2 c5 = position + collisionSetC.zw;\n    \n#if (MODE == MODIFIED)\n    hasCollided = IsCellValid(c0) || IsCellValid(c1) || IsCellValid(c2) || IsCellValid(c3) || IsCellValid(c4) || IsCellValid(c5);\n#else\n    hasCollided = IsCellValid(c0) || IsCellValid(c1) || IsCellValid(c2) || IsCellValid(c3);\n#endif\n    \n    return hasCollided;\n}\n\nvoid PlaceBlock(in vec4 playerBlockInfo, in vec2 targetCellIndex, inout vec4 targetCellInfo, in float colorType)\n{\n    // Very similar to the CheckForBlockCollisions function except we need to update some user data and update block info of the target cells\n    vec2 position = playerBlockInfo.xy;\n    float rotation = playerBlockInfo.z;\n    float blockType = playerBlockInfo.w;\n    \n    vec4 collisionSetA = GetCollisionSetA(blockType);\n    vec4 collisionSetB = GetCollisionSetB(blockType);\n    vec4 collisionSetC = GetCollisionSetC(blockType);\n    \n    float theta = rotation * PI * 0.5;\n    // floor calls added to fix issues on IE\n    mat2 rotationMatrix = mat2(floor(cos(theta) + 0.05), -floor(sin(theta) + 0.05), floor(sin(theta) + 0.05), floor(cos(theta) + 0.05)); \n    \n    // O_BLOCK doesn't need to rotate\n    if(blockType != O_BLOCK)\n    {\n    \tcollisionSetA.xy *= rotationMatrix;\n    \tcollisionSetA.zw *= rotationMatrix;\n    \tcollisionSetB.xy *= rotationMatrix;\n    \tcollisionSetB.zw *= rotationMatrix;\n    \tcollisionSetC.xy *= rotationMatrix;\n    \tcollisionSetC.zw *= rotationMatrix;\n    }\n     \n    vec2 c0 = position + collisionSetA.xy;\n    vec2 c1 = position + collisionSetA.zw;\n    vec2 c2 = position + collisionSetB.xy;\n    vec2 c3 = position + collisionSetB.zw;\n    vec2 c4 = position + collisionSetC.xy;\n    vec2 c5 = position + collisionSetC.zw;\n    \n#if (MODE == MODIFIED)\n    if((c0 == targetCellIndex) || (c1 == targetCellIndex) || (c2 == targetCellIndex) || (c3 == targetCellIndex) || (c4 == targetCellIndex) || (c5 == targetCellIndex))\n#else\n    if((c0 == targetCellIndex) || (c1 == targetCellIndex) || (c2 == targetCellIndex) || (c3 == targetCellIndex))   \n#endif\n    {\n        targetCellInfo = vec4(1.0, colorType, 0.0, 0.0);\n    }\n}\n\n// Each block type spawns at a different height, this is so it only takes a single drop update\n// for the block to appear in the playing field\nfloat GetStartingHeight(in float blockType)\n{\n    if(blockType == I_BLOCK)\n        return 0.0;\n    else if(blockType == J_BLOCK)\n   \t\treturn 2.0;\n    else if(blockType == L_BLOCK)\n    \treturn 2.0;\n    else if(blockType == O_BLOCK)\n   \t\treturn 2.0;\n    else if(blockType == S_BLOCK)\n    \treturn 3.0;\n    else if(blockType == T_BLOCK)\n   \t\treturn 2.0;\n    else if(blockType == Z_BLOCK)\n    \treturn 3.0;\n    else if(blockType == PLUS_BLOCK)\n    \treturn 2.0;\n    return 0.0;\n}\n\nfloat CalculateDropSpeed(in float linesCleared)\n{\n\treturn max(0.5 - min(floor((linesCleared) * 0.2) * 0.09, 1.9), 0.005);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // don't compute gameplay outside of the data area\n    if(fragCoord.x > fCELLS_WIDE || fragCoord.y > (1.0 + fCELLS_TALL)) discard;\n\n    // load game state\n    vec4 gameInfo0 = LoadValue(txGameInfo0);\n    vec4 gameInfo1 = LoadValue(txGameInfo1);\n    vec4 gameInfo2 = LoadValue(txGameInfo2);\n    vec4 controlledBlockInfo0 = LoadValue(txControlledBlockInfo0);\n    vec4 controlledBlockInfo1 = LoadValue(txControlledBlockInfo1);\n    vec4 blockInfo = LoadValue(fragCoord.xy - 0.5);\n    vec2 blockIndex = floor(vec2(fragCoord.x, fragCoord.y - 1.0));\n\n    // reset buffer A on frame 0\n\tif(iFrame == 0) gameInfo0 = vec4(-1.0, 0.0, 0.0, 0.0);\n    \n    if(gameInfo0.x == -1.0) // reset state\n    { \n        gameInfo0 = vec4(0.0, 0.0, 0.0, 0.0);\n        gameInfo1 = vec4(0.0, 0.0, 10000.0, CalculateDropSpeed(0.0));\n #if (MODE == MODIFIED)\n        gameInfo2 = vec4(0.0, 0.0, GetRandomBlock(1.0), 0.0);\n #else\n        gameInfo2 = vec4(0.0, 0.0, GetRandomBlock(1.0), 0.0);\n #endif\n        controlledBlockInfo0 = vec4(0.0);\n        controlledBlockInfo1 = vec4(0.0, 0.0, 0.0, gameInfo2.z);\n        blockInfo = vec4(0.0);\n    }\n    else if(gameInfo0.x == 0.0) // title state\n    {\n    \tgameInfo0 = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n    else if(gameInfo0.x == 1.0) // normal gameplay state\n    {\n        if(controlledBlockInfo0.w == 0.0) // current block type is invalid so get a new block\n        {\n            controlledBlockInfo0 = vec4(fHALF_CELLS_WIDE, GetStartingHeight(gameInfo2.z), 0.0, gameInfo2.z);        \n            controlledBlockInfo1.x = gameInfo1.w;\n#if (MODE == MODIFIED) && RANDOM_COLOR_BLOCKS\n        \tcontrolledBlockInfo1.w = GetRandomBlock(2.0);\n#else \n            controlledBlockInfo1.w =  gameInfo2.z;\n#endif\n            gameInfo2.z = GetRandomBlock(1.0);\n        }\n        else\n        {\n            if(controlledBlockInfo1.x <= 0.0) // Drop block and check for collisions\n            {\n                vec4 futureControlledBlockInfo0 = controlledBlockInfo0;\n                futureControlledBlockInfo0.y += 1.0;\n\n                bool blockCollided = CheckForBlockCollisions(futureControlledBlockInfo0);\n                if(blockCollided)\n                {\n                    PlaceBlock(controlledBlockInfo0, blockIndex, blockInfo, controlledBlockInfo1.w);\n                    controlledBlockInfo0.w = 0.0; // set user control block type to invalid\n\n                    // Move to row completion check\n                    gameInfo0.x = 2.0;\n                    gameInfo2.xy = vec2(fCELLS_TALL, -1.0);\n                }\n                else\n                {\n                    controlledBlockInfo0.y += 1.0;\n                    controlledBlockInfo1.x = gameInfo1.w;\n                }\n            }\n            else\n            {\n                bool moveWasMade = false;\n                vec4 potentialMoveData = controlledBlockInfo0;\n\n                if(gameInfo0.z <= 0.0) // Rotation\n                {\n                    float rotateCW = texture(iChannel1, vec2(KEY_SPACE, 0.25)).x + texture(iChannel1, vec2(KEY_Q, 0.25)).x;\n                    if(rotateCW > 0.5)\n                    {\n                        potentialMoveData.z -= 1.0;\n                        if(potentialMoveData.z <= -1.0)\n                            potentialMoveData.z = 3.0;    \n                        moveWasMade = true;\n                    }\n                    float rotateCCW = texture(iChannel1, vec2(KEY_UP, 0.25)).x + texture(iChannel1, vec2(KEY_E, 0.25)).x;\n                    if(rotateCCW > 0.5)\n                    {\n                        potentialMoveData.z += 1.0;\n                        if(potentialMoveData.z >= 4.0)\n                            potentialMoveData.z = 0.0;    \n                        moveWasMade = true;\n                    }\n                    gameInfo0.z = 0.1;\n                }\n\n                if(gameInfo0.w <= 0.0) // Movement\n                {\n                    float pressLeft = texture(iChannel1, vec2(KEY_LEFT, 0.25)).x;\n                    float pressRight = texture(iChannel1, vec2(KEY_RIGHT, 0.25)).x;\n                    float pressDown = texture(iChannel1, vec2(KEY_DOWN, 0.25)).x;\n                    \n                    if(pressLeft > 0.5)\n                    {\n                        potentialMoveData.x -= 1.0;\n                        moveWasMade = true;\n                    }\n                    if(pressRight > 0.5)\n                    {\n                        potentialMoveData.x += 1.0;\n                        moveWasMade = true;\n                    }\n                    \n                    if(pressDown > 0.5)\n                    {\n                        potentialMoveData.y += 1.0;\n                        moveWasMade = true;\n                    }\n                    gameInfo0.w = 0.05;\n                }\n                \n                if(CheckForBlockCollisions(potentialMoveData) == false) // Determine if the move was valid\n                {\n                    if(potentialMoveData.y > controlledBlockInfo0.y) // if it was a downwards move reset the drop timer\n                        controlledBlockInfo1.x = gameInfo1.w;\n                    controlledBlockInfo0 = potentialMoveData;             \n                }\n\n                controlledBlockInfo1.x -= iTimeDelta; // time till next drop\n                gameInfo0.z -= iTimeDelta; // time till next rotation available\n                gameInfo0.w -= iTimeDelta; // time till next movement available\n            }\n        }\n\t} \n    else if(gameInfo0.x == 2.0) // check for completed rows\n    {\n        bool completedRow = true;\n        \n        for(int i = 0; i < CELLS_WIDE; ++i)\n        {\n            vec2 testCoords = vec2(float(i), gameInfo2.x);\n            if(LoadValue(testCoords).x == 0.0)\n            {\n                completedRow = false;\n                break;\n            }\n        }\n        \n        if(completedRow)\n        {        \n           \tgameInfo2.w++; // increase multipler\n            gameInfo0.x = 3.0; // delete row phase\n            gameInfo2.y = gameInfo2.x; // set the delete row to the test row\n            \n            if(blockIndex.y == floor(gameInfo2.x - 1.0))\n                blockInfo.x = 2.0;\n        }\n        else\n        {  \n            // advance to next row\n            gameInfo2.x--;\n            if(gameInfo2.x < 1.0) // no rows completed\n            {\n                // calculate score\n                float stage = floor(gameInfo1.y * 0.2);\n                gameInfo1.x += min((gameInfo2.w * gameInfo2.w * 100.0) - 100.0, 100.0) * (stage);\n                gameInfo1.y += gameInfo2.w; // increase completed row count\n                \n                // Do a quick check for a game over state\n                bool isGameOver = false;\n                for(int i = 0; i < CELLS_WIDE; ++i)\n                {\n                    vec2 testCoords = vec2(float(i), 3.0);\n                    if(LoadValue(testCoords).x == 1.0)\n                    {\n                        isGameOver = true;\n                        break;\n                    }\n                }\n                \n                if(isGameOver)\n                {\n                    gameInfo0.x = 5.0;\t\n                }\n                else\n                {\n                    // reset back to normal gameplay\n                    gameInfo2.w = 0.0;\n                    gameInfo0.x = 1.0;\t\n                    gameInfo2.x = 0.0;\n                    gameInfo1.w = CalculateDropSpeed(gameInfo1.y);\n                    controlledBlockInfo1.x = gameInfo1.w;\n                }\n            }\n        }\n    }\n    else if(gameInfo0.x == 3.0) // delete rows\n    {\n\t\tif(blockIndex.y == (gameInfo2.x - 1.0))\n        {\n            blockInfo = vec4(0.0); // clear this block\n            gameInfo2.x = clamp(gameInfo2.x + 1.0, -1.0, fCELLS_TALL); // go back down a row      \n        }\n        gameInfo0.x = 4.0; // move down rows\n    }\n    else if(gameInfo0.x == 4.0) // move down rows\n    {\n        if(blockIndex.y < gameInfo2.x && blockIndex.y != 0.0)\n        {\n        \t// copy the value of the block above it\n            vec4 aboveBlockInfo = LoadValue(vec2(fragCoord.x - 0.5, fragCoord.y - 0.5 - 1.0));\n            blockInfo = aboveBlockInfo;          \n        }\n        gameInfo0.x = 2.0; // go back to checking rows\n    }\n    else if(gameInfo0.x == 5.0) // game over state\n    {\n    \t// Add a reset?\n       \tfloat anyKeyPressed = texture(iChannel1, vec2(KEY_SPACE, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_Q, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_UP, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_E, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_LEFT, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_RIGHT, 0.25)).x;\n       \tanyKeyPressed += texture(iChannel1, vec2(KEY_DOWN, 0.25)).x;\n        \n       \tif(anyKeyPressed > 0.5)\n       \t{\n       \t\tgameInfo0 = vec4(-1.0, 0.0, 0.0, 0.0);\n       \t}    \n    }\n    gameInfo0.y += iTimeDelta;\n    \n\t// store game state\n    fragColor = vec4(0.0);\n \n    StoreValue(txGameInfo0, gameInfo0, fragColor, fragCoord);\n    StoreValue(txGameInfo1, gameInfo1, fragColor, fragCoord);\n    StoreValue(txGameInfo2, gameInfo2, fragColor, fragCoord); \n    StoreValue(txControlledBlockInfo0, controlledBlockInfo0, fragColor, fragCoord);\n    StoreValue(txControlledBlockInfo1, controlledBlockInfo1, fragColor, fragCoord);\n   \tStoreValue(txBlocks, blockInfo, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}