{
    "Shader": {
        "info": {
            "date": "1672925516",
            "description": " Partitioning a sphere into subdivided icosahedral cells then mapping an animated asymmetric jigsaw pattern onto it.",
            "flags": 32,
            "hasliked": 0,
            "id": "7ldfzS",
            "likes": 56,
            "name": "Asymmetric Spherical Jigsaw Map",
            "published": 3,
            "tags": [
                "sphere",
                "map",
                "hexagon",
                "icosahedron",
                "polyhedron",
                "jigsaw"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1075
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    //\n    // See Buffer A for an explanation.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Asymmetric Spherical Jigsaw Map\n    -------------------------------\n    \n    Partitioning a sphere into subdivided icosahedral cells then mapping an \n    animated asymmetric jigsaw pattern onto it. \n    \n    I've been meaning to post one of these for ages. This particular version\n    has been sitting in my account for a while. I have a proper 3D version as\n    well, but that needs some work before I can release it.\n    \n    The pattern isn't unique, but there aren't a lot of these around, and I'm \n    pretty confident that no one has bothered to put together a pixelshader \n    version. There are many reasons why, but in essence, working with \n    neighboring cells on a subdivided icosahedron isn't a fun task. :) There \n    was also the matter of figuring out how to produce an assymetric hexagon\n    pattern that was fast enough to construct and render in realtime.\n    \n    Anyway, I just wanted to release one of these in any form. I'll work on \n    some more interesting versions later. And in case anyone was wondering, \n    this provides and interesting means with which to render almost pixel \n    perfect extruded Voronoi looking cells onto the surface of a sphere, \n    amongst other things.\n    \n    In regard to future improvements, there are too many to name. The one I'll \n    mention is that I used actual vertex locations as ID points, which is not \n    accurate at all, so I had to snap each ID point to an integer prior to \n    hashing. This is not ideal. However comming up with an ID system on a \n    subdivided icosahedron would require some forthought... Maybe next time. :)\n    \n    By the way, I tidied this and commented it up in a hurry, but I'll clean \n    it up properly when I get a chance. I'll attempt to get the compile time \n    down on systems that rely on ANGLE also. This example relies a lot on arrays, \n    but from what I understand, ANGLE doesn't deal well with them. This is \n    unfortunate, because I hear that arrays can be useful to coders. :)\n    \n    \n\n\tSimialr examples:\n    \n    // Using a triangle grid to create and raymarch an animated \n    // extruded rounded asymmetric hexagon jigsaw pattern in realtime.\n    Extruded Asymmetric Jigsaw - Shane\n    https://www.shadertoy.com/view/NlKfWt\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n \n\n\n// Attempting not to unroll loops.\n#define ZERO min(0, iFrame)\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3./2.);\n    p.yz *= rot2(iTime/6./4.*2.); \n\n    return p;\n    \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    //float wall = -(length(p - sphPos - vec3(0, 0, -(16. - 2.5))) - 16.);\n     // Flat plane back wall.\n    float wall = -p.z + 2.5;// - (length(p.xy) - .5)*.125;\n    //float wall = -p.z + 2.5 + dot(sin(p.xy*2. - cos(p.yx*4.)*1.57), vec2(1./2.))*.1;\n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(q) - .5;\n    \n \n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, 1e5, 1e5);\n    \n    // Shortest distance.\n    return  min(sph, wall);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\n// It's been rewritten based on Spalmer's suggestion.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n \n\n/*\n// Spalmer's normal function. It's definitely better, but I'd like\n// to tinker with a bit first before using it. :)\nvec3 getNormal(vec3 q, float h){\n\n    vec3 e = vec3(1, 0, 0), g = e.zzz;\n    for (int i = ZERO + 6; \n            i-- > 0;\n            g += map(q + h * e)*e, e = e.zxy)\n        if (i == 2) e = -e;\n    return normalize(g);\n}\n*/\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the \n    // lowest number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: \n        // dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n\n/////////\n// Normalizing and scaling.\nmat3x3 nrmSclMat(mat3x3 m, float rad){\n    \n    return mat3x3(normalize(m[0]), normalize(m[1]), normalize(m[2]))*rad;\n}\n\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n//#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define PI TAU*.5 // To avoid numerical wrapping problems... Sigh! :)\n#define PHI  1.6180339887498948482 // (1. + sqrt(5.))/2.\n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n// Direction vector.\nvec3 dir;\nint sID;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 q, inout mat3x3 gVertID, const float rad){\n       \n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems. The bottom section is \n    // rotated by PI/5 about the equator.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    const float scX = 5.; // Longitudinal scale.\n    vec4 sph = atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.);\n    sph = fract((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX)*TAU;\n    //sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    const vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    const vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Skip the top or bottom strip, depending on whether we're in the\n    // northern or southern hemisphere.\n    ivec3 iR = q.y<0.? ivec3(1, 2, 3) : ivec3(0, 1, 3);\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point. Usually, only one\n    // two strips are normally checked, but three are checked here on account \n    // of faux shadow rendering.\n    for(int k = ZERO; k<3; k++){ \n\n        int i = iR[k];\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i&1], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n    \n    // X - coordinates for all three vertices.\n    vec3 ax = mod(vec3(0, -PI/5.*baseFlip, PI/5.*baseFlip) + TAU + sph[id], TAU);\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID = mat3x3(vec3(ax.x, ayT, rad), vec3(ax.y, ayB, rad), vec3(ax.z, ayB, rad));\n    \n   \n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if ((id&1)==0) gVertID[0].x = 0.;\n\n    \n    dir = vec3(1);\n    if(id == 1 || id == 2) dir *= -1.;\n    if(id == 0 || id == 2) dir.x *= -1.;\n    \n    sID = id;\n    \n    \n    return q;\n}\n\n\n/////////\n  \n// Incircle of a 3D triangle: Basically the 3D extension of\n// the 2D version... I was in a hurry, but it seems about right.\n// Let me know if the logic doesn't follow.\n// \nvec3 inCircle(in vec3 v0, in vec3 v1, in vec3 v2){\n    \n    // Side lengths.\n    vec3 len = vec3(length(v2 - v1), length(v0 - v2), length(v1 - v0));\n    return mat3(v0, v1, v2)*len/dot(len, vec3(1));\n}\n\n// Sphere line, capped at \"b\".\nfloat sphereLineCapB(vec3 p, vec3 a, vec3 b, float rad){\n \n     \n     p /= rad; // Normalize p.\n     float ln = dot(p, cross(a, b))/length(a - b);\n     \n     vec3 perpB = b + cross((a - b), b);\n     float endB = dot(p, cross(perpB, b))/length(perpB - b);\n     \n     \n     return max(abs(ln), endB);\n      \n}\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n// Swap functions.\nvoid swap(inout int a, inout int b){\n    int tmp = a; a = b; b = tmp;\n}\n\nvoid swap(inout float a, inout float b){\n    float tmp = a; a = b; b = tmp;\n}\n\n// Color palette.\nvec3 getColor(float x){\n\n    vec3 col = .5 + .45*cos(6.2831*x/3. + vec3(0, 1, 2)*1.5 + 3.5);\n    if(hash11(x)>.5) col = vec3(x*.75 + .15)*vec3(.95, .95, 1.1);\n    \n    return col;\n}\n\n// Color palette.\nvec3 getColor2(float x){\n\n    vec3 col = .5 + .45*cos(6.2831*x/3. + vec3(0, 1, 2)*1.5 + 3.5);\n    if(hash11(x)>.3) col = vec3(x*.75 + .15)*vec3(.95, .95, 1.1);\n    \n    return col;\n}\n\nfloat getGrey(vec3 x){ return dot(x, vec3(.299, .587, .114)); }\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .5, -1.75);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n        //vec3 h = normalize(ld - rd); \n        //float spec = pow(max(dot(h, sn), 0.), 32.); \n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.   \n        \n         \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0);  \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n        // Global time for the common tab.\n        setTime(iTime);\n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n             // Smoothing factor.\n            float sf = .003; \n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            mat3x3 v, vID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, vID, rad);\n    \n            v[0] = sphericalToWorld(vID[0]); \n            v[1] = sphericalToWorld(vID[1]);\n            v[2] = sphericalToWorld(vID[2]);\n            \n             \n             \n            // Edge mid points, edge tangents, etc.\n            mat3x3 vE;//, vN;\n            \n            // Edge mid points.\n            vE[0] = mix(v[0], v[1], .5);\n            vE[1] = mix(v[1], v[2], .5);\n            vE[2] = mix(v[2], v[0], .5);\n            vE = nrmSclMat(vE, rad); // Normalize and scale.\n           \n           \n            // Large triangle neighbors.\n            mat3x3 vNgbr;\n                       \n            for(int i = 0; i<3; i++){\n \n                vec3 vEU = vE[i];\n                vec3 v2N = reflect((vEU - v[(i + 2)%3]), (-vEU/rad)); \n                vNgbr[i] = vEU + v2N;//normalize(vEU + v2N)*rad;\n                \n            }\n \n            \n \n            /////\n            #if SCHEME > 0\n            // Triangle subdivision, if desired.\n            //\n            // Number of subdivisions.\n            #if SCHEME == 1\n            const int subDivNum = 1;\n            #else\n            const int subDivNum = 2;\n            #endif\n            \n            // Subdivided triangle neighbors.\n            //vec3[3] vNgbr2 = vec3[3](vec3(0), vec3(0), vec3(0));\n            \n            float midTri = 0.;\n            int subTriID = 0;\n            //\n            // There'd be faster ways to do this, but this is\n            // relatively cheap, and it works well enough.\n            for(int i = ZERO; i<subDivNum; i++){\n            \n                // Create three line boundaries within the triangle to \n                // partition into four triangles. Pretty standard stuff.\n                // By the way, there are other partitionings, but this \n                // is the most common. At some stage, I'll include some\n                // others, like the three triangle version connecting the \n                // center to the vertices.\n                //\n                if(dot(lq, cross(vE[0], vE[1]))>0.){\n                    // Upright large triangle, bottom left.\n                    vNgbr[0] = mix(vNgbr[0], v[1], .5); // Left.\n                    vNgbr[1] = mix(vNgbr[1], v[1], .5); // Bottom.\n                    vNgbr[2] = mix(v[2], v[0], .5); // Right.\n                    v[0] = vE[0]; v[2] = vE[1];\n                    subTriID = 0;\n                    midTri = 0.;\n                    \n                }\n                else if(dot(lq, cross(vE[1], vE[2]))>0.){\n                    // Upright large triangle, bottom right.\n                    vNgbr[0] = mix(v[0], v[1], .5); // Left.\n                    vNgbr[1] = mix(vNgbr[1], v[2], .5); // Bottom.\n                    vNgbr[2] = mix(vNgbr[2], v[2], .5); // Right.\n                    v[0] = vE[2]; v[1] = vE[1];\n                    subTriID = 1;\n                    midTri = 0.;\n                }\n                else if(dot(lq, cross(vE[2], vE[0]))>0.){\n                    // Upright large triangle, top.\n                    vNgbr[0] = mix(vNgbr[0], v[0], .5); // Left.\n                    vNgbr[1] = mix(v[1], v[2], .5); // Bottom.\n                    vNgbr[2] = mix(vNgbr[2], v[0], .5); // Right.\n                    v[1] = vE[0]; v[2] = vE[2];\n                    subTriID = 2;\n                    midTri = 0.;\n                }\n                else {\n                \n                    // Neighboring v2 point is the original point.\n                    vNgbr = v;\n                    \n                    v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n           \n                    if(sID%2==1) dir = -dir;\n                    else dir *= vec3(1, -1, 1);\n           \n                    \n                    if(midTri == 1. && sID%2==0){\n                       dir *= vec3(-1, -1, 1);\n                    }\n              \n                    midTri = 1.;\n                    subTriID = 3;\n                    \n                }\n \n                // Recalculating the edge mid-vectors for the next iteration.\n                vE[0] = mix(v[0], v[1], .5);\n                vE[1] = mix(v[1], v[2], .5);\n                vE[2] = mix(v[2], v[0], .5);\n                vE = nrmSclMat(vE, rad); // Normalize and scale.\n                \n                vNgbr = nrmSclMat(vNgbr, rad);\n                \n                \n                \n            }\n            #endif\n            /////  \n            \n           \n            \n  \n            // The unique cell ID, which is used for randomness, etc.\n            vec3 id = v[0] + v[1] + v[2];\n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness.\n            //vec3 ctr = normalize(id)*rad;\n            vec3 ctr = normalize(inCircle(v[0], v[1], v[2]))*rad;;\n  \n \n \n\n \n           \n            vec3 mp = vec3(1e5), mp2 = vec3(1e5);\n            vec3 rc = vec3(1e5);\n            \n            vec3 vOffs; \n            \n            \n            vec3 ctrRnd = ctr + (hash31A(ctr) - .5)*.15/7.*1.;\n            ctrRnd = normalize(ctrRnd)*rad;\n \n            // Lines connecting the offset centers between neighboring edges.\n            vec3 ln = vec3(1e5);\n            for(int i = ZERO; i<3; i++){\n                \n                // Two random indices pointing to random entry and exit points.\n                int ip1 = (i + 1)%3;\n                //int ip2 = (i + 2)%3;\n                \n                vec3 v2N = vNgbr[i];\n                 \n                // Center point in the neighboring cell.\n                vec3 ctrNgbr = normalize(inCircle(v[i], v[ip1], v2N))*rad;\n               \n                // Neighboring cell center with random offset.\n                vec3 ctrNgbrRnd = ctrNgbr + (hash31A(ctrNgbr) - .5)*.15/7.*1.;\n                ctrNgbrRnd = normalize(ctrNgbrRnd)*rad;\n                \n                // Mid point between cells.\n                vec3 midRnd = mix(ctr, ctrNgbr, .5);\n                rc[i] = hash31(midRnd);\n                float mRnd = dir[i]*(rc[i]*2. - 1.);\n                float d = mRnd<0.? -1. : 1.;\n                // Point between the random center and random neighbor points.\n                vec3 vER = normalize(mix(ctrRnd, ctrNgbrRnd, .5))*rad;\n\n\n                // Tangent.\n                vec3 tn = normalize(cross(ctrRnd - vER, vER));\n                \n                // Jigsaw nodule offset.\n                #if SCHEME == 0\n                const float noduleOffset = .02;\n                #elif SCHEME == 1\n                const float noduleOffset = .012;\n                #else\n                const float noduleOffset = .004;\n                #endif\n                \n                // The nodule point and distance field.\n                vER = normalize(vER - d*tn*noduleOffset)*rad;\n                mp[i] = length(lq - vER);\n                \n                \n                // Offset hexagon line partitioning.\n                vec3 lnCntr = ctrNgbrRnd - ctrRnd; // Vector connecting centers.\n                float ed = (dot((lq/rad), cross(ctrRnd, ctrNgbrRnd))/length(lnCntr)); // Center line.\n                ln[i] = ed;\n                \n                \n                // Offset vertex point -- Technically not correct, but it looks the part.\n                vec3 vOffsI = normalize(v[i] + (hash31A(v[i]) - .5)*.15/7./1.5)*rad;\n                vOffs[i] = length(lq - vOffsI);\n            }\n            \n            // Smoothing factor.\n            float smF = .005;\n            // Segmenting the face triangle into three polygon boundaries.\n            //\n            // Each line connnects the offset center to its edge neighbor offset. Therefore,\n            // the polygon boundary we're after will be a combination of two of those lines.\n            // Each triangle consists of three partial polygons, which are gouped into the\n            // following expression.\n            //\n            //ln = max(ln, min(-ln.yzx, ln.zxy));\n            ln = smax(ln, -ln.yzx, smF);\n           \n            \n         \n          \n            //Offset center point distance field.\n            float cp = length(lq - ctrRnd);\n\n            // Give the edges and center points some thickness.\n            #if SCHEME == 0\n            mp -= .05;\n            cp -= .05;\n            #elif SCHEME == 1\n            mp -= .03;\n            cp -= .03;\n            #else\n            mp -= .017;\n            cp -= .018;\n            #endif\n            \n            \n            // Initial background color.\n            texCol = vec3(.05); \n\n\n            /*         \n            // Icosahedral cell boundary.\n            //\n            // Rendering lines on a sphere is a little different to those on a plane.\n            // Lines between points translate to great arcs between points. This is\n            // just three triangle edge borders. I normally do these individually, but\n            // discovered this matrix short cut in on of Mattz's examples. Quite obvious...\n            // once someone else did it. :)\n            mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n            vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            float line = min(min(ep.x, ep.y), ep.z) -  .0035;\n            \n            // Cell border lines.\n            texCol = mix(texCol, vec3(.2), (1. - smoothstep(0., sf*2., line))*.35);\n            texCol = mix(texCol, vec3(.0), (1. - smoothstep(0., sf, line))*.9);\n            */\n\n            /*\n            // Offset cell boundaries.\n            mat3 mEdge2 = mat3(cross(ctrRnd, v[0]), cross(ctrRnd, v[1]), cross(ctrRnd, v[2]));\n            vec3 ep2 = (normalize(lq)*mEdge2)/\n                        vec3(length(ctrRnd - v[0]), length(ctrRnd - v[1]), length(ctrRnd - v[2]));  \n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            ep2 = max(ep2, -ep2.yzx);\n            ep2 = abs(ep2);\n            float line2 = min(min(ep2.x, ep2.y), ep2.z) -  .0035;\n            \n            // Cell border lines.\n            texCol = mix(texCol, vec3(.2), (1. - smoothstep(0., sf*2., line2))*.35);\n            texCol = mix(texCol, vec3(.0), (1. - smoothstep(0., sf, line2))*.9);\n            */\n            \n          \n      \n            // Disk version... Needs work.\n            //ln = abs(ln + .02) - .02;\n \n            \n            //ln += .005;\n            //mp += .005;\n            \n            // Performing CSG to combine the jigsaw nodules with the polygons\n            // to creat the jigsaw pieces.\n            for(int i = 0; i<3; i++){\n                float mRnd = dir[i]*(rc[i]*2. - 1.);\n                if(mRnd<0.) ln[i] = smin(ln[i], mp[i], smF);\n                else ln[i] = smax(ln[i], -mp[i], smF);\n                \n                int ip1 = (i + 1)%3;\n                mRnd = dir[ip1]*(rc[ip1]*2. - 1.);\n                if(mRnd<0.) ln[i] = smax(ln[i], -mp[ip1], smF);\n                else ln[i] = smin(ln[i], mp[ip1], smF);\n            }\n\n            \n            // Sorting in order of random height. In this way, the faux\n            // shadows will render in the correct order. I was hoping this \n            // would magically sort (pun intended) itself out, but it didn't. :)\n            int index[3] = int[3](0, 1, 2);\n            vec3 rnd3 = vec3(hash31(v[1]), hash31(v[2]), hash31(v[0]));\n            vec3 r3 = rnd3;\n            rnd3 = vec3(getGrey(getColor(rnd3.x)), getGrey(getColor(rnd3.y)), getGrey(getColor(rnd3.z)));\n            if (rnd3[0] > rnd3[1]){ swap(rnd3[0], rnd3[1]); swap(index[0], index[1]); }\n            if (rnd3[0] > rnd3[2]){ swap(rnd3[0], rnd3[2]); swap(index[0], index[2]); }\n            if (rnd3[1] > rnd3[2]){ swap(rnd3[1], rnd3[2]); swap(index[1], index[2]); }\n            \n            \n            // Rendering the jigsaw pieces in order of ascending height.\n            // Laying down shadows, edges, color, etc.\n            for(int j = ZERO; j<3; j++){ \n               \n                int i = index[j];\n                int ip1 = index[(j + 1)%3];\n \n                float rnd = r3[i];\n                vec3 pCol = getColor(rnd);\n               \n                float sL = length(v[i] - v[ip1]);\n                float sh = clamp(.5 - ln[i]/sL*3., 0., 1.);\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*12., ln[i]))*.5);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, ln[i]));\n                texCol = mix(texCol, pCol, 1. - smoothstep(0., sf, ln[i] + .005));\n                   \n            }\n            \n            /*\n            // Inner lines and shading.\n            for(int j = ZERO; j<3; j++){ \n            \n               int i = index[j];\n               float rnd = r3[i];\n               vec3 pCol = getColor(rnd);\n               texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, ln[i] + .02))*.9);\n               texCol = mix(texCol, pCol*.5, (1. - smoothstep(0., sf, ln[i] + .027)));\n     \n            }\n            */\n\n             \n             \n            // Cell vertices.\n            //vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            //float vert = min(min(v3.x, v3.y), v3.z) - .01;\n            \n            // Offset central vertices.\n            float vert = min(min(vOffs[index[0]], vOffs[index[1]]), vOffs[index[2]]) - .01;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert - .005))*.5);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .005));\n            texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .005));\n    \n            \n        }\n        else { \n        \n            // Back wall.\n\n            // Rotating the pattern.\n            vec2 p = rot2(3.14159/18.)*sp.xy;\n            \n            // Cell coordinate, ID and triangle orientation id.\n            // Cell vertices and vertex ID.\n            vec2[3] v, vID;\n\n            // Returns the local coordinates (centered on zero), cellID, the \n            // triangle vertex ID and relative coordinates.\n            //scale = 1./2.5; //1./2.\n            vec4 p4 = getTriVerts(p, vID, v);\n            p = p4.xy;\n            vec2 triID = p4.zw; \n            \n            // Vertices and corresponding highlight.\n            vec3 vert;\n            float sL = length(v[0] - v[1]);\n            \n            // Center ID, random offset, etc.\n            vec2 ctrID = triID;\n            vec2 ctr = vec2(0);\n            vec2 ctrRnd = ctr - (hash21A(ctrID) - .5)*.07;\n           \n            // Polygon lines, random values, point distance and height.\n            vec3 ln, rc, rc2, mp, hexHgt;\n            \n             // Nearest vertex, and edge mid-points and offsets on either side.\n            for(int i = ZERO; i<3; i++){\n\n                int ip1 = (i + 1)%3;\n                int ip2 = (i + 2)%3;\n\n                // Nearest offset vertex point.\n                vert[i] = length(p - v[i] + (hash21A(ctrID + vID[i]) - .5)*.07);\n                // Nearest vertex point.\n                //vert[i] = length(p - v[i]);\n                \n                // Random number associated with the triangle vertex, which is \n                // also the center of the hexagon. The extra \".1\" isn't necessary, \n                // but it random number disperses the jigsaw pieces in a way that\n                // feels more appealing.\n                rc[i] = hash21(triID + vID[i] + .1);\n             \n                hexHgt[i] = (triID + vID[i]).y;\n\n                // Mid edge point and ID.\n                vec2 midID = mix(vID[i], vID[ip1], .5);\n                vec2 mid = mix(v[i], v[ip1], .5);\n                \n                // Random number associated with the triangle edge midpoint.\n                rc2[i] = hash21(triID + midID);\n                \n                \n                // Neighbor central ID and position.\n                vec2 ctrNgbrID = ctrID + midID*2.;\n                vec2 ctrNgbr = ctr + mid*2.;\n                // Offset central neighbor ID and position.\n                vec2 ctrNgbrRnd = ctrNgbr - (hash21A(ctrNgbrID) - .5)*.07;\n                vec2 midRnd = mix(ctrRnd, ctrNgbrRnd, .5);\n                \n                // Perpendicular vector and random based direction.\n                vec2 tn = normalize((ctrNgbrRnd - ctrRnd).yx*vec2(1, -1)); \n                float dir = gTri*(rc2[i] - .5<0.? -1. : 1.);\n                \n                // Nodule points.\n                mp[i] = length(p - midRnd - dir*tn*.02);\n                \n                \n                // Partitioning lines to construct the polygons.\n                //ln[i] = distLineS(p, vec2(0), mid);\n                ln[i] = distLineS(p, ctrRnd, ctrNgbrRnd);\n\n\n            } \n            \n            // Vertex and midpoint size.\n            mp -= .0535;\n            vert -= .035;\n            \n            // Smoothing factor and polygon calculation.\n            float smF = .015;\n            // Constructing three polygons for the cell. And if you're thinking\n            // that it's not a lot of code, you'd be correct. :)\n            ln = smax(ln, -ln.zxy, smF);\n            //ln = abs(ln) - .01;\n\n\n            // The two cell objects (top and bottom). Each consist of curved \n            // spiral arms attached to a central shape.\n            vec2 obj = vec2(1e5);  \n            \n            // Smoothing factor and triangle distance.\n            float sf = .005;\n            float tri = sdEqTri(p*vec2(1, gTri), sL/2.);\n            \n            // Intial background color.\n            texCol = vec3(.1);\n            // Triangle grid lines.\n            //texCol = mix(texCol, vec3(.15), (1. - smoothstep(0., sf*3., abs(tri) - .014)));\n            //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(tri) - .007)));\n            \n            \n            \n            // Sorting in order of random height. In this way, the faux\n            // shadows will render in the correct order. I was hoping this \n            // would magically sort (pun intended) itself out, but it didn't. :)\n            int index[3] = int[3](0, 1, 2);\n            vec3 rnd3 = vec3(hash21(triID + vID[0]), hash21(triID + vID[1]), hash21(triID + vID[2]));\n            rnd3 = vec3(getGrey(getColor2(rnd3.x)), getGrey(getColor2(rnd3.y)), getGrey(getColor2(rnd3.z)));\n            //vec3 r3 = rnd3;\n            if (rnd3[0] > rnd3[1]){ swap(rnd3[0], rnd3[1]); swap(index[0], index[1]); }\n            if (rnd3[0] > rnd3[2]){ swap(rnd3[0], rnd3[2]); swap(index[0], index[2]); }\n            if (rnd3[1] > rnd3[2]){ swap(rnd3[1], rnd3[2]); swap(index[1], index[2]); }\n            \n            // Performing CSG to combine the jigsas nodules with the polygons\n            // to creat the jigsaw pieces.\n            for(int i = 0; i<3; i++){ \n                \n                float rnd2 = gTri*(rc2[i] - .5);//hash2((triID + mid2ID))*2. - 1.;\n                if(rnd2<0.) ln[i] = smin(ln[i], mp[i], smF);\n                else ln[i] = smax(ln[i], -mp[i], smF);\n\n                int ip2 = (i + 2)%3;\n                rnd2 = gTri*(rc2[ip2] - .5);//hash2((triID + mid2ID))*2. - 1.;\n                if(rnd2<0.) ln[i] = smax(ln[i], -mp[ip2], smF);     \n                else ln[i] = smin(ln[i], mp[ip2], smF);        \n            }\n            \n            //ln = abs(ln + .06) - .06;\n            \n            // Lay down the ground tiles first.\n            for(int i = 0; i<3; i++){ \n            \n                // Jigsaw piece placement boundaries.\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, ln[i])));\n                texCol = mix(texCol, vec3(.15), (1. - smoothstep(0., sf*3., ln[i] + .016)));\n                texCol = mix(texCol, vec3(.1), (1. - smoothstep(0., sf*2., ln[i] + .035)));\n                \n                //texCol = mix(texCol, vec3(.15), (1. - smoothstep(0., sf*3., abs(ln[i]) - .024)));\n                //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(ln[i]) - .012)));\n\n            }        \n            \n            \n            // Rendering the polygon shadows, colors, etc, in order of ascending height.\n            for(int j = ZERO; j<3; j++){ \n               \n                int i = index[j];\n  \n                float rnd = rc[i];\n                vec3 pCol = getColor2(rnd);\n            \n                 // Randomly render some of the jigsaw pieces.\n                 if(abs(hexHgt[i] + 8.)<15. && hash11(rc[i] + .01)<.5){\n                     \n                     // Jigsaw pieces.\n                     texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*20., ln[i]))*.5);\n                     texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, ln[i])));\n                     texCol = mix(texCol, pCol, (1. - smoothstep(0., sf, ln[i] + .012)));\n                     //texCol = mix(texCol, pCol, (1. - smoothstep(0., sf, ln[i] + .05)));\n                     \n                     // Inner edges and shading.\n                     //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, ln[i] + .055))*.9);\n                     //texCol = mix(texCol, pCol*.5, (1. - smoothstep(0., sf, ln[i] + .075)));\n                     \n                     // Offset vertices.\n                     texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., vert[i] - .02))*.5);\n                     texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert[i] - .02));\n                     texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert[i]));\n                     texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert[i] + .02));\n                    \n\n                 }\n\n            }\n            \n        \n        }       \n        \n         \n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(1, 2, 4), fBlend);\n  \n    \t\n        \n        // Combining the above terms to procude the final color.//*freS\n        col = texCol*(diff*sh + .3 + vec3(1, .97, .92)*spec*sh*1. + vec3(.2, .4, 1)*fre*sh*.7);\n \n\n\n        // Shading.\n        col *= ao*atten;\n       \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Subtle colored vignette. It's purpose is to pretend there's some environmental\n    // conditions causing a bluish glow in order to match the Fresnel sphere corona. \n    uv = fragCoord/iResolution.xy;\n    col = mix(col*vec3(.2, .4, 1)*5., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(col, 0.), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// I've called it a scheme because I plan to expand on it, but for now\n// it's just a representation of the amount of subdisions, which is \n// one, two or none at all. The latter looks pretty boring, but allows\n// you to study the pattern and joins more closely.\n//\n// No subdivsions: 0, One subdivision: 1, Two subdivisions: 2.\n#define SCHEME 2\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./2.5;\n \nfloat gTri;\n\nvec4 getTriVerts(vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    // Rectangle scale.\n    vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = vec2[3](vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = vec2[3](vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = vID[2]; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat sdEqTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nvec3 smax(vec3 a, vec3 b, float k){\n    \n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// The time variable isn't recognized inside the \"Common\" tab, so this\n// hack gets around it.\nfloat gTime = 0.;\nvoid setTime(float t){ gTime = t; }\n\n// Hastily modified \"uint\" based hash functions. They're a mixture\n// of IQ and Fabrice's versions... I'll tidy these up and add more \n// references soon.\n//\n// IQ's hash function here: https://www.shadertoy.com/view/XlXcW4 \n\n//const uint k = 1664525U; // Numerical Recipes.\nconst uint k = 20170906U; // Today's date -- Use three days ago's date if you want a prime.\n\n// I recognize this particular function from Hugo Elias's now defunct site.\n// In turn, it was based on even older code.\nfloat hash(uint n){ \n\n    // Integer hash copied from Hugo Elias.\n\tn = (n << 13U)^n;\n    n = n * (n*n*15731U + 789221U) + k;//1376312589U;\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash11(float f){ return hash(floatBitsToUint(f)); }\n \n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash3(uvec3 p){\n\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n// There are a few ways to use a normal range float with these functions, and\n// this isn't the best one. However, it works, so it'll do.\nfloat hash31(vec3 f){\n    \n    f = floor(f*16384. + .01); \n    return hash3(floatBitsToUint(f)); \n\n}\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    f = floor(f*16384. + .01);\n    uvec2 p = floatBitsToUint(f);\n    p = 1103515245U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\nfloat hash21A(vec2 f){    \n\n    uvec2 x = floatBitsToUint(f), q = 1103515245U*(x>>1U^x.yx);\n    float xf = float(1103515245U*(q.x^q.y>>3U))/float(0xffffffffU);\n    return sin(xf*6.2831 + gTime*(xf - .5)*3.)*.5 + .5;\n}\n \n// IQ's uvec3 to vec3 hash.\nvec3 hash33(uvec3 x){\n\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1./float(0xffffffffU));\n}\n\nvec3 hash31A(vec3 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    f = floor(f*16384. + .01);\n    vec3 x = hash33(floatBitsToUint(f)); \n    return sin(x*6.2831 + gTime*(x - .5)*3.)*.5 + .5;\n\n}\n \n ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}