{
    "Shader": {
        "info": {
            "date": "1562351779",
            "description": "{4, 5} Truchet tiling of the hyperbolic plane in the Poincar√© disk model. Click left of circle to auto-rotate, inside circle to scroll, right of circle to center. LMB down = B&W coloring",
            "flags": 0,
            "hasliked": 0,
            "id": "3llXR4",
            "likes": 52,
            "name": "Hyperbolic Truchet tiles",
            "published": 3,
            "tags": [
                "truchet",
                "hyperbolic"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 1490
        },
        "renderpass": [
            {
                "code": "// \"Hyperbolic Truchet tiles\" by mattz\n// Licence https://creativecommons.org/licenses/by-nc/3.0/us/\n//\n// Combining my love of Truchet tiling with my newfound \n// interest in hyperbolic geometry.\n\n#define RED vec3(0.8, 0, 0)\n#define BLUE vec3(0, 0, 0.8)\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define LIGHTGRAY vec3(.8)\n#define LIGHTRED vec3(0.9, 0.5, 0.5)\n#define LIGHTBLUE vec3(0.5, 0.5, 0.9)\n\n#define PI 3.141592653589793\n\nconst vec4 NO_INTERSECT = vec4(-1e5);\n\nconst float TOL = 1e-5;\nconst float TOL_SQR = TOL*TOL;\n\n//////////////////////////////////////////////////\n// geometric utility functions\n\n// are two points on the same diameter of the unit circle?\nbool alongDiameter(vec2 p, vec2 q) {\n   \n    vec4 pq = abs(vec4(p, q));\n    float m = max(max(pq.x, pq.y), max(pq.z, pq.w));\n    \n    float k = abs(p.x*q.y - p.y*q.x);\n    \n    return k < TOL*m;\n    \n}\n\n// are two points the same length?\nbool sameLength(float pp, float qq) {\n    return abs(pp - qq) < TOL*max(pp, qq);\n}\n\n// rotate by 90 degrees\nvec2 perp(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\n// circle centered at center containing point p\nvec3 compass2D(vec2 ctr, vec2 p) {\n    vec2 diff = p - ctr;\n    return vec3(ctr, dot(diff, diff));\n}\n\n// Construction 1.2: invert a point through a circle\nvec2 invertPC(vec2 p, vec3 c) {\n    vec2 po = p - c.xy;    \n    return c.xy + po * c.z / dot(po, po);\n}\n\n//////////////////////////////////////////////////\n// hyperbolic geometry functions\n\n// distance from a point to a line or circle\nfloat geodesicDist(vec3 l, vec2 p) {\n\tif (l.z > 0.0) {\n\t\treturn length(p-l.xy) - sqrt(l.z);\n\t} else {\n\t\treturn dot(normalize(l.xy), p);\n\t}\n}\n\n// special case of Construction 1.6 for unit circle\nvec3 geodesicFromPole(vec2 p) {\n    float h2 = dot(p, p);\n    float r2 = (h2 - 1.);\n    return vec3(p, r2);\n}\n\n// Polar of a point p about the unit circle\n// 2D line passing thru the midpoint of p and its inverse, perp. to p.\nvec3 polarFromPoint(vec2 p) {\n    return vec3(p, -0.5*dot(p, p) - 0.5);\n}\n\n// invert point about geodesic (either arc or line)\nvec2 reflectPG(vec2 p, vec3 c) {\n    if (c.z == 0.) {\n        return p - (2.*dot(p, c.xy))*c.xy;\n    } else {\n        return invertPC(p, c);\n    }\n}\n\n// Construction 2.2: geodesic from polars of points\nvec3 geodesicFromPoints(vec2 p, vec2 q) {\n    \n    if (alongDiameter(p, q)) {\n        vec2 n = normalize(perp(p - q));\n        return vec3(n, 0);\n    }\n\n    vec3 ppolar = polarFromPoint(p);\n    vec3 qpolar = polarFromPoint(q);\n    vec3 inter = cross(ppolar, qpolar);\n\n    return compass2D(inter.xy/inter.z, p);\n    \n}\n\n\n// return a geodesic passing thru p perpendicular to the diameter\n// through p - undefined if p == (0, 0)\nvec3 geodesicPerpTo(vec2 p) {\n    \n    float a2 = dot(p, p);\n    float x = a2 + 1.;\n    \n    float h_over_a = x / (2.*a2);\n    float h2 = 0.5*x*h_over_a;\n    \n    vec2 c = p * h_over_a;\n    \n    return vec3(c, (h2 - 1.));\n    \n}\n\n// Construction 2.3: hyperbolic compass. \n// construct hyperbolic circle with center p that passes thru q\nvec3 hyperbolicCompass(vec2 p, vec2 q) {\n    \n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) {\n        return vec3(p, (qq));\n    } \n    \n    if (alongDiameter(p, q)) {\n        vec3 pperp = geodesicPerpTo(p);\n        vec2 qp = invertPC(q, pperp);\n        vec2 qmid = 0.5*(q + qp);\n        return compass2D(qmid, q);\n    }\n    \n    // get polars of p and q\n    vec3 ppolar = vec3(p, -0.5*pp - 0.5);\n    vec3 qpolar = vec3(q, -0.5*qq - 0.5);\n    \n    // homogeneous coords of pole of geodesic pq\n    vec3 pole = cross(ppolar, qpolar);\n    \n    // this is the direction from point q to the pole\n    vec2 dqpole = pole.xy - pole.z*q; \n    \n    // 2D line tangent to geodesic pq at q\n    vec3 lq = vec3(dqpole, -dot(dqpole, q));\n    \n    // 2D line containing p and the origin\n    vec3 lp = vec3(perp(p), 0);\n    \n    // homogeneous coords of intersection of these lines\n    vec3 rval = cross(lq, lp);\n    \n    // return circle\n    return compass2D(rval.xy/rval.z, q);\n    \n}\n\n\n// Construction 3.1: Perpendicular bisector\nvec3 hyperbolicBisector(vec2 p, vec2 q) {\n\n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) { \n        \n        // p is at origin\n        float h2 = 1.0/qq;\n        return vec3(q*h2, (h2 - 1.));\n       \n    } else if (qq < TOL_SQR) { \n        \n        // q is at origin                \n        float h2 = 1.0/pp;\n        return vec3(p*h2, (h2 - 1.));\n        \n    } else if (sameLength(pp, qq)) {\n        \n        // p and q are same length, return the diameter\n        return vec3(normalize(p - q), 0);\n        \n    }\n    \n    // this remarkably small piece of code reflects the following algebra:\n    //\n    // let d = q - p be the difference between p & q\n    // let x be the pole of the bisector\n    //\n    // since the pole of the bisector is on the line from p to q, we know\n    //\n    //   x = p + k*d\n    //\n    // for some unknown k with abs(k) > 1 (because the pole isn't between p & q)\n    //\n    // now let's try to solve for k.\n    //\n    // we know that since the pole x is orthogonal to the unit circle, \n    // the radius of the bisector circle is governed by\n    //\n    //   r^2 = ||x||^2 - 1\n    //       = ||p + k*d ||^2 - 1\n    //       = p.p + 2k*p.d + k^2*d.d\n    //\n    // also since p and q are inverted through the bisector circle with radius\n    // r we know\n    //\n    //   r^2 = || x-p || * || x-q || = ||d|| * || k*d - d ||\n    //       = k*(k-1)*d.d \n    //\n    // now we can set the two equations equal and solve for k\n\n    vec2 d = q - p;\n    float k = (1.0 - dot(p,p))/(dot(d,d) + 2.0*dot(p,d));\n    \n    return geodesicFromPole( p + k*d );\n    \n}\n\n// hyperbolic translation to move the origin to point m\nvec2 hyperTranslate(vec2 uv, vec2 m) {\n\n    float mm = dot(m, m);\n    if (mm < TOL_SQR || mm >= 1.) { return uv; }\n\n    vec3 g1 = hyperbolicBisector(vec2(0), m);\n\n    vec2 diff = uv.xy - g1.xy;\n    float k = g1.z / dot(diff, diff);\n    uv.xy = g1.xy + k*diff; \n\n    vec2 n = m / sqrt(mm);\n    uv.xy -= 2.*dot(uv.xy, n)*n;\n    \n    return uv;\n    \n}\n\n// return scalar whose sign indicates side of g that p is on\nfloat sidePG(vec2 p, vec3 g) {\n    if (g.z == 0.) {\n        return dot(p, g.xy);\n    } else {\n        p -= g.xy;\n        return dot(p, p) - g.z;\n    }\n}\n\n// return true if p & q both on the same side of l \nbool sameSide(vec2 p, vec2 q, vec3 l) {\n    return sidePG(p, l) * sidePG(q, l) >= 0.;    \n}\n\n\n\n///////////////////////////////////////////////////\n// utility functions for drawing:\n\n// mix src into dst by smoothstepping k with threshold d\nvoid ink(inout vec3 colorOut, vec3 src, float inkDist) {\n    \n    colorOut = mix(src, colorOut, smoothstep(0.0, 1.0, inkDist));\n    inkDist = 1e5;\n    \n}\n\n// draw either line or circle (using geodesicDist above)\nfloat drawLine(vec3 l, vec2 p, float lineWidth) {\n    return (abs(geodesicDist(l, p.xy))-lineWidth);\n}\n\nfloat drawPoint(vec2 x, vec2 p, float pointSize) {\n    return (length(p - x)-pointSize);\n}\n\n\n// From Dave Hoskins' \"Hash without sine\"\n// https://www.shadertoy.com/view/4djSRW \nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 colorOut = WHITE;\n    \n    const float diam = 2.0;\n        \n    float kAlt = step(0.1, max(iMouse.z, iMouse.w));\n\n    float rmax = max(iResolution.x, iResolution.y);\n    float rmin = min(iResolution.x, iResolution.y);\n\n    float csize = (rmin * 0.98);\n            \n    float px = diam / csize;\n    float invPx = csize / diam;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy) * px;\n    \n    const vec3 unitCircle = vec3(0, 0, 1);\n    \n    if (dot(uv, uv) < 1.) {\n\n        // setup 4, 5, 2 triangle\n\n        vec2 verts[3];\n        vec3 edges[3];\n\n        const float cospi5 = 0.8090169943749475; // cos(pi/5)\n        const float sinpi5 = 0.5877852522924731; // sin(pi/5)\n        const float sqrt22 = 0.7071067811865476; // sqrt(2)/2\n\n        float f = sqrt(2./(cospi5*cospi5 - sinpi5*sinpi5));\n\n        float k = (sqrt22*cospi5 - sqrt22*sinpi5)*f;\n\n        float bsz = (cospi5 - sqrt22)*f;\n\n        verts[0] = vec2(0);\n        verts[1] = vec2(k, 0);\n        verts[2] = vec2(0, k);\n        \n        vec2 mid = bsz*vec2(sqrt22, sqrt22);\n        \n        edges[0] = geodesicFromPoints(verts[1], verts[2]);\n        edges[1] = vec3(1, 0, 0);\n        edges[2] = vec3(0, 1, 0);\n\n        vec2 m = (iMouse.xy - 0.5*iResolution.xy) * px;\n        bool scroll = false;\n\n\n        if (dot(m, m) < 0.95) {\n            scroll = true;\n        } else if (m.x < 0.) {\n            float t = iTime*PI/10.0;\n            float r = 0.5*smoothstep(0.0, 4.0, iTime);\n            m = r*vec2(cos(t), sin(t));\n            scroll = true;\n        } else {\n            m = vec2(0);\n        }\n        \n        if (scroll) {\n            for (int i=0; i<3; ++i) {\n                verts[i] = hyperTranslate(verts[i], -m);\n            }\n            for (int i=0; i<3; ++i) {\n                int j = (i+1)%3;\n                int k = 3-i-j;\n                edges[i] = geodesicFromPoints(verts[j], verts[k]);\n            }\n            mid = hyperTranslate(mid, -m);\n        }\n        \n        bool done = false;\n\n        for (int iter=0; iter<32; ++iter) {\n\n            if (done) { continue; }\n\n            int i = 0;\n\n            if (!sameSide(uv, verts[0], edges[0])) {\n                i = 0;\n            } else if (!sameSide(uv, verts[1], edges[1])) {\n                i = 1;\n            } else if (!sameSide(uv, verts[2], edges[2])) {\n                i = 2;\n            } else {\n                done = true;\n                continue;\n            }\n\n            int j = (i+1)%3;\n            int k = 3-i-j;\n\n            mid = reflectPG(mid, edges[i]);\n            verts[i] = reflectPG(verts[i], edges[i]);\n            edges[j] = geodesicFromPoints(verts[i], verts[k]);\n            edges[k] = geodesicFromPoints(verts[i], verts[j]);\n            \n        }\n        \n        float ds = 1.0 - dot(uv, uv);\n\n        vec2 ctr = hyperTranslate(verts[0], m);\n        vec2 seed = floor(12.*ctr + 0.5) + 19.;\n                \n        float r = hash12(seed);\n        \n        float lw = 0.02*ds;\n        float cw = 0.05*ds;\n        float pw = 0.08*ds;\n        \n        float bdist = drawLine(edges[2], uv, lw);\n        float rdist = drawLine(edges[1], uv, lw);\n        \n        float cdist;\n        \n        vec3 altColor;\n                \n        if (r > 0.5) {\n            \n            vec3 c = hyperbolicCompass(verts[1], mid);\n            \n            float d = geodesicDist(c, uv);\n            \n            altColor = mix(BLACK, WHITE, smoothstep(-0.5*px, 0.5*px, d));\n            \n            \n            cdist = drawLine(c, uv, cw);\n            ink(colorOut, LIGHTBLUE, bdist*invPx);\n            ink(colorOut, LIGHTRED, rdist*invPx);\n            \n            \n        } else {\n            \n                        \n            vec3 c = hyperbolicCompass(verts[2], mid);\n            \n            float d = geodesicDist(c, uv);\n            \n            altColor = mix(WHITE, BLACK, smoothstep(-0.5*px, 0.5*px, d));\n            \n            cdist = drawLine(c, uv, cw);\n            ink(colorOut, LIGHTRED, rdist*invPx);\n            ink(colorOut, LIGHTBLUE, bdist*invPx);\n            \n        }\n        \n        ink(colorOut, BLACK, cdist*invPx);\n        ink(colorOut, BLUE, drawPoint(verts[1], uv, pw)*invPx);\n        ink(colorOut, RED, drawPoint(verts[2], uv, pw)*invPx);\n        \n        colorOut = mix(colorOut, altColor, kAlt);\n\n    }\n    \n    ink(colorOut, BLACK, drawLine(unitCircle, uv, 0.5*px)*invPx);\n    \n    colorOut = sqrt(colorOut);\n    \n    fragColor = vec4(colorOut, 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}