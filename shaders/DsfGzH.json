{
    "Shader": {
        "info": {
            "date": "1665618771",
            "description": "copy of https://www.shadertoy.com/view/llySRh\nexcept things that skia doesnt support have been removed\nadded date year,month, day display\nimproved keyboard report to show toggle, down and initial click\nallow ifdef'ing out sound and lod info",
            "flags": 16,
            "hasliked": 0,
            "id": "DsfGzH",
            "likes": 4,
            "name": "flutter test iResolution, iMouse",
            "published": 3,
            "tags": [
                "test",
                "imouse",
                "itime",
                "iresolution"
            ],
            "usePreview": 1,
            "username": "timmaffett",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "//=== original link for citation: https://www.shadertoy.com/view/llySRh\n//find many other tricks here: https://shadertoyunofficial.wordpress.com/\n\n// --- content:\n// - 2D and 3D rotations\n// - hue\n// - printing chars, text, ints, floats\n// - key togggles ( + main special codes )\n// - events ( mouse just clicked, texture loaded )textureS\n// - antialiased line drawing \n// - hash ( 1D, 2D, 3D, etc ).\n\n// defines to (mostly) reduce functionality\n#define USE_TEXELFETCH 1\n#define SOUND_INFO   1\n#define LOD_INFO     1\n#define TEXTUREGRAD  0   // enable to remove boxes around letters, and slow fps down by x3..\n\n#define SMALL_KEY_BLOCK  0         // must be 1 for sksl\n#define BETTERNOISE 1              // must be 0 for sksl\n\n#if SMALL_KEY_BLOCK   \n#define LOWKEY 32    // space-letters only for keys for skia (sksl loop unrolling hits size limits otherwise)\n#define HIGHKEY 97\n#else\n#define LOWKEY  0\n#define HIGHKEY 255\n#endif\n\n// --- rotations -----------------------------------------------------\n\n// 2D, or one axis after the other:\n#define rot2(a)      mat2(cos(a),-sin(a),sin(a),cos(a)) // V.xy *= rot2(a.z)\n\n// 3D rot around an arbitrary axis\n#define rot(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n\n\n// --- short approx hue -------------- https://www.shadertoy.com/view/ll2cDc\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define hsv(h,s,v)    (v) * ( 1. + (s)* ( .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) - .4 ) )\n// short exact:\n//#define hsv(h,s,v)  (v) * ( 1. + (s)* clamp(  abs( fract( h + vec3(3,2,1)/3. ) * 6. - 3. ) - 2., -1.,0.) )\n\n\n// --- printing chars, integers and floats ---------------------------\n\n// --- access to the image of ascii code c\n\n// Deferred draw (call draw_char() ). Run and compiles faster.\n//     First only determine the valid char id at cur pixel \n//     then call the draw char once at the end.\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc O+=char((U),(64+CAPS+c));\n\n#if TEXTUREGRAD\nvec2 dfdx, dfdy;\n#endif\n\nint char_id = -1;\nvec2 char_pos; \nvec4 char(vec2 p, int c) {\n#if TEXTUREGRAD\n    vec2 dfdx = dFdx(p/16.), dfdy = dFdy(p/16.);\n#endif\n    //if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. ) {  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) {// thighly y-clamped to allow dense text\n        char_id = c;\n        char_pos = p;\n    }\n    return vec4(0);\n}\nvec4 draw_char() {\n    if(char_id < 0) {\n      return vec4(0,0,1.0,1e5);\n    } else {\n#if TEXTUREGRAD\n      return textureGrad( iChannel0, char_pos/16. + fract( vec2(char_id, 15-char_id/16) / 16. ), dfdx, dfdy );\n#else\n       return texture( iChannel0, (char_pos + vec2(char_id, 15-char_id/16)) / 16. );\n#endif\n    }\n}\n\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ mod(i,10) );\n    return v;\n}\n#else\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#endif\n\nvec4 pKeyState(vec2 U, bool kDown, bool kClick, bool kToggle ) {\n    vec4 O = vec4(0);\n    caps\n    if(kDown) { C(4); }  // D for down\n    if(kClick) { C(16); } // P for pressed C(3);  // C for click\n    if(kToggle){ C(20); } // T for toggle\n    return O;\n}\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += pInt(p,upper); p.x -= 2.;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\n// printing full IEEE floats (right or left justified): see https://www.shadertoy.com/view/7dfyRH , https://www.shadertoy.com/view/7sscz7\n\n// NB: use either char.x ( pixel mask ) or char.w ( distance field + 0.5 )\n \n\n// --- key toggles -----------------------------------------------------\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n// Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n// Advice:  Mode: keyToggle(key)  Action: keydown(key)+keyclick(modifier)\n\n\n#if USE_TEXELFETCH\n\n// texelFetch to read keys\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0. )\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0. )\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0. )\n\n#define shift             ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0. )\n#define ctrl              ( texelFetch(iChannel3,ivec2(17,0),0).x  > 0. )\n#define alt               ( texelFetch(iChannel3,ivec2(18,0),0).x  > 0. )\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n#else\n\n// Use texture() which skia supports\n#define keyDown(ascii)    ( texture(iChannel3,vec2((float(ascii)+.05)/256., 0.05/3.)).x > 0. )\n#define keyClick(ascii)   ( texture(iChannel3,vec2((float(ascii)+.05)/256., 1.05/3.)).x > 0. )\n#define keyToggle(ascii)  ( texture(iChannel3,vec2((float(ascii)+.05)/256., 2.05/3.)).x > 0. )\n\n#define shift             ( texture(iChannel3,vec2((float(16)+.05)/256., 0.05/3.)).x  > 0. )\n#define ctrl              ( texture(iChannel3,vec2((float(17)+.05)/256., 0.05/3.)).x  > 0. )\n#define alt               ( texture(iChannel3,vec2((float(18)+.05)/256., 0.05/3.)).x  > 0. )\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n#endif\n\n\n\n\n// --- events ----------------------------------------------------------\n\n// --- mouse side events https://www.shadertoy.com/view/3dcBRS\n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame)\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.w < 0. )                  // mouse clicked:   mouse button currently clicked\n\n// --- texture loaded\n#define textureLoaded(i) ( iChannelResolution[i].x > 0. ) \n\n// --- (re)init at resolution change or at texture (delayed) load:\n// in buffX, store iResolution.x or iChannelResolution[i] somewhere. e.g. (0,0).w\n// if ( currentVal != storedVal ) init; storeVal.\n\n\n// --- antialiased line drawing ------ https://www.shadertoy.com/view/4dcfW8\n\n#define S(d,r,pix) smoothstep( .75, -.75, (d)/(pix)-(r))   // antialiased draw. r >= 1.\n// segment with disc ends: seamless distance to segment\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n// line segment without disc ends ( sometime useful with semi-transparency )\nfloat line0(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),                  // proj coord on line\n          c = clamp(h, 0., 1.);\n    return h==c ? length(p - b * h) : 1e5;            // dist to strict segment\n}\n    // You might directly return smoothstep( 3./R.y, 0., dist),\n    //     but more efficient to factor all lines.\n    // Indeed we can even return dot(,) and take sqrt at the end of polyline:\n    // p -= b*h; return dot(p,p);\n\n\n// for polylines with acute angles, see: https://www.shadertoy.com/view/fdVXRh\n\n\n// --- old fashioned float-based hash. Might give user-dependant results --------------------\n\n// nowadays integer noise is safer. see especially: https://www.shadertoy.com/results?query=integer+hash+-\n//                         my variants:  vec3→vec3: https://www.shadertoy.com/view/NtjyWw\n//                                      vec2→float: https://www.shadertoy.com/view/fsKBzw\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n#define hash2x3(p) fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n// attention: on windows, it is better to use sin(mod(... , 2pi))\n\n#define SMALL_FONT_SIZE 1.5\n#define SMALLER_FONT_SIZE 2.0  // higher numbers == smaller fonts\n\n#define KEY_COLUMN_START 1.15  // was 1.45\nvoid mainImage( out vec4 O,  vec2 uv ) // === demos it all ==================================\n{\n    O -= O;\n    vec2 R = iResolution.xy, U;\n    uv *= 1.03; // overall font size adjustment (high number == smaller fonts)\n    uv /= R.y;    \n    int lod = int(mod(iTime,10.));\n    \n    U = ( uv - vec2(.0,.9) ) * 16.;  caps C(18) low C(5)C(19)C(15)C(12) caps C(-6)  // \"Resol\"\n                             U.x-=1.; low C(19)C(3)C(18)C(5)C(5)C(14)               // \"screen\"\n    U = ( uv - vec2(.6,.9) ) * 16.;   low C(20)C(5)C(24)C(20)                       // \"text\"\n#if LOD_INFO\n    U = ( uv - vec2(.85,.9) ) * 16.;  low C(12)C(15)C(4) spc C(-48+lod)             // \"lod\"\n#endif\n#if SOUND_INFO\n    U = ( uv - vec2(1.15,.9) ) * 16.;  low C(19)C(15)C(21)C(14)C(4)                 // \"sound\"\n#endif\n    U = ( uv - vec2(.0,.5) ) * 16.;  caps C(13) low C(15)C(21)C(19)C(5) caps C(-6)  // \"mouse\"\n    U = ( uv - vec2(.5,.6) ) * 16.;  caps C(20) low C(9)C(13)C(5) caps C(-6)        // \"Time\"\n    U = ( uv - vec2(KEY_COLUMN_START,.55) ) * 16.;  caps C(11) low C(5)C(25)C(19) caps C(-6)         // \"Keys\"\n\n    \n    U = ( uv - vec2(.1,.8) ) * 8.;        // --- column 1\n    O += pInt(U, R.x);  U.y += .8;   // window resolution\n    O += pInt(U, R.y);  U.y += .8;\n    O += pFloat((U-vec2(-1,.35))*SMALL_FONT_SIZE, R.x/R.y);  U.y += .8;\n  //O += pInt(U, iResolution.z);  U.y += .8;\n    U.y += .8;\n    low\n    O += pInt(U, iMouse.x);  U.y += .8;        // mouse location\n    O += pInt(U, iMouse.y);  U.y += .8;\n    U.y += .4;\n    O += pInt(U, iMouse.z);  U.y += .8;      // last mouse-click location \n    O += pInt(U, iMouse.w);  U.y += .8;\n    \n    //mouse x,y,z,w\n    U = ( uv - vec2(.35,.4) ) * 16.;  \n    C(24) U.y += 1.6; U.x+=0.5;  //x\n    C(25) U.y += 2.2; U.x+=0.5;  //y\n    C(26) U.y += 1.6; U.x+=0.5;  //z\n    C(23) U.y += 1.6; U.x+=0.5;  //w\n \n    \n    \n    U = ( uv - vec2(.5,.8) ) * 8.;        // --- column 2\n\n    if ( !textureLoaded(1) )                   // texture not loaded yet\n        if (U.x>0. && U.y>-1.5 && U.x<2.5 && U.y<1.5) O.r+= .5;\n    O += pInt(U, iChannelResolution[1].x);  U.y += .8; // texture ( video )\n    O += pInt(U, iChannelResolution[1].y);  U.y += .8; // see LOD in column 2b\n    //O += pInt(U, iChannelResolution[1].z);  U.y += .8;\n    U.y += .8;\n\n    O += pFloat(U, iTime);         U.y += .8;  // time\n    O += pInt(U, float(iFrame));   U.y += .8;  // iFrame\n    O += pFloat(U, 1./iTimeDelta); U.y += .8;  // FPS\n\n    // hour, min, second\n    U.y += .8;\n    O += pInt(U, iDate.w/3600.);          U.x -= 2.5;\n    O += pInt(U, mod(iDate.w/60.,60.));   U.x -= 2.5;\n    O += pFloat(U, mod(iDate.w,60.));  \n\n\n    //date year, month, day\n    U.y += .8;\n    U.x += 5.0;\n    O += pInt(U, iDate.x);   U.x -= 2.5; \n    O += pInt(U, iDate.y);   U.x -= 2.5;\n    O += pInt(U, iDate.z);  \n\n#if LOD_INFO\n    U = ( uv - vec2(.8,.8) ) * 8.;        // --- column 2b\n    if (iChannelResolution[1].x==1. &&  iChannelResolution[1].x > 1.) // video/sound lock by stupid new web media policy.\n        if (U.x>0. && U.y>-1.5 && U.x<2.5 && U.y<1.5) O.r+= .5; // Colored bg on fonts turned BW later: in immediate mode, should be defered.\n                                                                // Or transform char/draw_char for they directly return BW.\n    ivec2 S = ivec2(iChannelResolution[1].xy);\n    O += pInt(U, float(S.x));  U.y += .8; // texture LOD\n    O += pInt(U, float(S.y));  U.y += .4;\n    U *= SMALLER_FONT_SIZE; O += pFloat(U, iChannelTime[1]);      // iChannelTime\n#endif\n\n    // time heading\n    U = ( uv - vec2(.6,.2) ) * 16.;  caps C(8) low C(15)C(21)C(18)  // \"Hour\"\n    U = ( uv - vec2(.95,.2) ) * 16.;  caps C(13) low C(9)C(14)      // \"Min\"\n    U = ( uv - vec2(1.25,.2) ) * 16.;  caps C(19) low C(5)C(3)      // \"Sec\"\n\n#if SOUND_INFO\n    U = ( uv - vec2(1.1,.8) ) * 8.;        // --- column 3\n    O += pInt(U, iChannelResolution[2].x);  U.y += .8; // sound texture\n    O += pInt(U, iChannelResolution[2].y);  U.y += .8;\n    // O += pInt(U, iChannelResolution[2].z);  U.y += .8;\n\n    O += pInt(U, iSampleRate/1e4);          U.x -= 2.; // iSampleRate\n    O += pInt(U, mod(iSampleRate,1e4)); \n#endif\n//    U = ( uv - vec2(1.4,.45) ) * 8.;       // --- column 4\n    U = ( uv - vec2(KEY_COLUMN_START,.5) ) * 16.;       // --- column 4\n    \n#define STATE_SPACING 1.7\n#define KEY_COLUMN_SPACING  1.9\n    bool b = false;\n    int numKeysReported = 0;\n    // split key checks into two loops that check all keys and don't waist too much\n    // time checking slots that have no corresponding key\n    for (int i=LOWKEY; i<=HIGHKEY; i++) {\n        bool kToggle = keyToggle(i);\n        bool kDown = keyDown(i);\n        bool kClick = keyClick(i);\n        if (kToggle || kDown || kClick) {\n            O += pInt(U, float(i)); U.x -= STATE_SPACING;  // keypressed ascii\n            //float state = int(kToggle)*100. + int(kDown)*10. + int(kClick);\n            //O += pInt(U, float(state));  \n            O += pKeyState(U, kDown, kClick, kToggle );\n            b=true;\n            numKeysReported++;\n            if(numKeysReported==6||numKeysReported==12) { //if(mod(float(numKeysReported),6.)==0.) {\n                // next column\n                U.x -= KEY_COLUMN_SPACING;\n                U.y -= (0.1*8.) * 5.;\n            } else {\n                U.x += STATE_SPACING; // go back to column start\n                U.y += .1 *8.;  // next line\n            }\n        }\n    }\n/*    for (int i=173; i<=220; i++) { // punctuation keys\n        if (keyDown(i)) {\n            O += pInt(U, float(i));  // keypressed ascii \n            b=true;\n            U.y += .1 *8.;\n         }\n    }\n*/\n    if (b==false) O += pInt(U, -1.);\n        \n    O += draw_char().xxxx;\n\n   //O*=9.;\n    \n    // --- non-fonts stuff\n    \n    U = (uv*R.y/R-.9)/.1; \n    if (min(U.x,U.y)>0.) O = hue(U.x),  // --- hue (already in sRGB final space)\n                             O*=O;      // just to fight the final sRGB convertion\n    \n    U = (uv -vec2(.9*R.x/R.y,.8))*10.;              // --- line drawing\n    float pix = 10./R.y;               // pixel size\n    O+= S( line( U,vec2(0,0),vec2(1.1,.85)), 3., pix);\n    O+= S( line0(U,vec2(0.5,0),vec2(1.6,.85)), 3., pix);\n\n    U = (uv -.8*R/R.y)*10.;                        // --- circle, discs, transp and blend\n    O += S( abs(length(U-vec2(.2,1)) -.5), 1., pix); // disc. -.5: relative units. 1: pixel units\n    O += S( length(U-vec2(1.1,1)) -.5, 0., pix) * vec4(1,0,0,1)*.5; // vec4(pureCol)*opacity\n    O += (1.-O.a)*S( length(U-vec2(1.1,.3)) -.5, 0., pix) * vec4(0,1,0,1); // blend below prevs\n    vec4 C = S( length(U-vec2(1.1,-.3)) -.5, 0., pix) * vec4(0,0,1,1)*.5;  // blend above prevs\n    O = C + (1.-C.a)*O;\n    \n    U = uv -vec2(.9*R.x/R.y,.7);        // --- random numbers\n    if ( U.x > 0. && U.y > 0. && U.y < .08 ) \n        U.x > .05*R.x/R.y ? O.rgb += hash(U*iTime) :\n#if BETTERNOISE\n        O.rgb += hash2x3(U*((iTime)));\n#else\n        O.rgb += hash3(vec3(U,U.x)*(iTime));  // no mat2x3 in sksl\n#endif\n    // --- color space corrections\n    O = pow(O, vec4(1./2.2) ); // shader result must be in sRGB colorspace -> gamma correction\n                               // note that it is very close to sqrt(O).\n    // similarly, color operations must be done in flat space, while textures are sRGB-encoded: pow(texture(),vec4(2.2)) or ~square.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}