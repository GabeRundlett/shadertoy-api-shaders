{
    "Shader": {
        "info": {
            "date": "1567592804",
            "description": "Click on a thumbnail of a creatures to select, then click the green button to crossbreed the last two. Crossbreeding mixes genes randomly resulting in different hybrids each time. Red button will delete the selected creature to make space. (1GAM)",
            "flags": 32,
            "hasliked": 0,
            "id": "3dc3Rr",
            "likes": 34,
            "name": "Crossbreeder",
            "published": 3,
            "tags": [
                "cat",
                "dog",
                "humanoid",
                "gui",
                "alchemy",
                "geneticprogramming",
                "genetics"
            ],
            "usePreview": 1,
            "username": "archee",
            "viewed": 1220
        },
        "renderpass": [
            {
                "code": "// Originally made for the One Game a Month challenge in Hungary\n\n\n// this function adds some extra volume between adjascent  objects\n// From IQ's smin function\nfloat minfade( float a, float b )\n{\n//    return min(a,b);  // uncomment to see composing primitives\n    float k = 0.24;\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// my solution wasn't that good.\n// unfortunately it breaks the distance function linerity\nfloat minfade2(float a,float b)\n{\n//    return min(a,b);  // uncomment to see composing primitives\n    return (min( (a+0.1)*(b+0.1)*4.2-0.14, min(a,b)));\n}\n\nfloat gdist;\n\n// a rounded cone like cylinder shape\nvoid thickknot(vec3 p,vec3 p0,float r0,vec3 p1,float r1)\n{\n    float x0 = dot(normalize(p1-p0),p0-p);\n    float x1 = dot(normalize(p1-p0),p1-p);\n    float y = length(cross(normalize(p1-p0),p-p0));\n    float rrd = (atan(x1/y)/y-atan(x0/y)/y)/length(p1-p0);\n    float rad = dot(p1-p0,p0-p)/dot(p1-p0,p1-p0)*-(r1-r0)+r0;\n    gdist = minfade(gdist,(1.0/sqrt(rrd)-rad));\n}\n\nvoid sphere(vec3 p,vec3 p0,float r0)\n{\n    gdist = minfade(gdist,length(p-p0)-r0);\n}\n    \nvoid ellipse(vec3 p,vec3 p0,float r0,vec3 p1,float r1)     //unused\n{\n    gdist = minfade(gdist,(length(p-p0)+length(p-p1)-length(p1-p0)-r0)*0.5);\n}    \n\nvec3 c,up,right;\n\nmat2 rotate(float angle)\n{\n    return mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\n\nvoid rotx(float angle)\n{\n    up.yz *= rotate(angle);\n    right.yz *= rotate(angle);\n}\n\nvoid rotz(float angle)\n{\n    up.xy *= rotate(angle);\n    right.xy *= rotate(angle);\n}\n\nint dnaindex = 1;\n\nfloat gen(int i)\n{\n    vec4 v = texture(iChannel0,vec2(float(i/4)+0.1,float(dnaindex)+0.1)/(iResolution.xy));\n    int j = i%4;\n    return j==0?v.x:(j==1?v.y:(j==2?v.z:v.w));\n}\n\nvec2 distfunc(vec3 p)\n{\n    p.x = abs(p.x);\n    vec2 res;\n    gdist = 1e30;\n    \n    \n    c = vec3(0.,0.5,0.);\n    up = vec3(0.,1.,0.);\n    right = vec3(1.0,0.,0.);\n\n    rotx(gen(11)*0.6);\n    \n    c -= up*1.0;\n    \n    vec3 lastc = c; \n    vec3 hipc =c ;\n    vec3 hipup = up;\n    vec3 hipright = right;\n    \n    \n    // spine\n    lastc =c;\n    c += up*gen(35);\n    vec3 hiptop = c;\n    thickknot(p,lastc,gen(36),c,gen(39));\n    \n    rotx(gen(37));\n    lastc =c;\n    c += up*gen(38);\n    thickknot(p,lastc,gen(39),c,gen(42));\n    \n    vec3 torsobottomc = c;\n    rotx(gen(40));\n    lastc =c;\n    c += up*gen(41);\n    thickknot(p,lastc,gen(42),c,gen(43));\n    \n    if (true) { // simplify for fast compilation\n    \n    vec3 torsoc = c;\n    vec3 torsoup = up;\n    vec3 torsoright = right;\n    \n    // neck\n    lastc =c;\n    rotx(gen(44));\n    c += up*gen(27);\n    thickknot(p,lastc,gen(28),c,gen(28));\n    // head\n    sphere(p,c+cross(up,right)*gen(30),gen(29));\n    \n    \n    c=hipc;\n    up = hipup;\n    right = hipright;\n    \n    c+=right * gen(7); \n    // hip\n    thickknot(p,c,gen(8),c*vec3(-1.,1.,1.),gen(8));\n    thickknot(p,c,gen(8),hiptop,gen(8));\n    \n    \n    // thy\n    rotz(-gen(10));\n    rotx(-gen(11));\n    vec3 forward = cross(up,right);\n    c += forward * 0.1;\n    lastc =c;\n    c += up*-gen(12);\n    thickknot(p,lastc,gen(13),c,gen(13));\n    sphere(p,c+forward*0.1,gen(13)*0.2); // knee\n    \n    // shin\n    rotx(-gen(14));\n    lastc =c;\n    c += up*-gen(15);\n    thickknot(p,lastc,gen(16),c,gen(16));\n    \n    // foot\n    rotx(-gen(31));\n    lastc =c;\n    c += up*-gen(32);\n    thickknot(p,lastc,gen(33),c,gen(33));\n    \n    // torso   \n    c = torsoc;\n    up = torsoup;\n    forward = cross(up,right);\n    right = torsoright;\n    vec3 shoulder = c + right* gen(17) + forward*-0.1;\n    thickknot(p,torsobottomc,gen(42),shoulder,gen(18));\n    thickknot(p,shoulder*vec3(-1.,1,1),gen(18),shoulder,gen(18));\n    \n    // arms\n    c = shoulder + right*gen(17)*0.3;\n    rotx(gen(19));\n    rotz(-gen(20));\n    lastc =c;\n    c += up*-gen(21);\n    thickknot(p,lastc,gen(22),c,gen(22));\n    \n    rotx(-gen(23));\n    lastc =c;\n    c += up*-gen(24);\n    thickknot(p,lastc,gen(25),c,gen(25));\n    sphere(p,c,gen(26));\n    \n    // tail\n    c=hipc;\n    up = hipup;\n    right = hipright;\n\n    rotx(gen(45)+sin(iTime)*0.0);\n    lastc =c;\n    c += -up*gen(46);\n    thickknot(p,lastc,gen(47)*1.5,c,gen(47));\n\n    rotx(gen(48)+sin(iTime+1.3)*0.0);\n    lastc =c;\n    c += -up*gen(46);\n    thickknot(p,lastc,gen(47),c,gen(47)*0.7);\n}\n    \n    res.x = gdist*1.0; // underestimating the distance is necessary, \n    // because the distance function is wrong\n    res.y = 1.0; // material\n    return res;\n}\n\nvec3 getnormal(vec3 p)\n{\n    float d= distfunc(p).x;\n    float dd = 0.0001;\n    return normalize(vec3(distfunc(p+vec3(dd,0.,0.)).x-d,\n                          distfunc(p+vec3(0.,dd,0.)).x-d,\n                          distfunc(p+vec3(0.,0.,dd)).x-d));\n}\n\nvec3 backGround(vec3 raydir)\n{\n    vec3 ambientcolor = vec3(0.4,0.5,0.55);\n    return ambientcolor*(raydir.y*-0.5+0.5);    \n}\n\n#define read(x,y) texture(iChannel0,vec2(float(x)+0.1,float(y)+0.1)/(iResolution.xy))\nbool alive(int j)\n{\n    return read(1,j).w!=0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screencoord = fragCoord/iResolution.xy;\n    float aspect = 9./16.;\n    screencoord.x/=aspect;\n\n    int viewindex=0;\n    vec3 bordercolor = vec3(0.,0.,0.);\n    dnaindex = int(read(0.,0.).x);\n    int previous_dnaindex = int(read(0.,0.).y);\n    if (screencoord.x<0.75) // small views\n    {\n        viewindex = int(floor(screencoord.x*4.0)+floor((1.0-screencoord.y)*4.0)*3.)+1;\n        screencoord.xy = fract(screencoord.xy*4.0);\n        \n        vec3 buttonColor = vec3(0.,0.,0.);\n        \n       \n        \n        if (viewindex>=11)\n        {\n            if (viewindex==12) // mix button\n            {\n                if (dnaindex*previous_dnaindex!=0)\n                {\n                    buttonColor = vec3(0.,0.6,0.0);\n                }\n            }\n            if (viewindex==11) // delete button\n            {\n                if (dnaindex!=0)\n                {\n                    buttonColor = vec3(0.6,0.0,0.0);\n                }\n            }\n/*            if (viewindex==10) // mutate button\n            {\n                if (dnaindex!=0)\n                {\n                    buttonColor = vec3(0.6,0.5,0.0);\n                }\n            }*/\n            \n            fragColor = vec4(0.,0.0,0.0,0.0);\n           \tif (length(screencoord.xy-0.5)<0.4) fragColor = vec4(buttonColor,0.0);\n            return;\n        }\n        \n        \n       \n        if (dnaindex == viewindex) bordercolor = vec3(0.9,0.8,0.2);\n        if (previous_dnaindex == viewindex) bordercolor = vec3(0.9,0.8,0.0)*0.6;\n        dnaindex = viewindex;\n        \n    }\n    else  // main view window\n    {\n        screencoord.x-=(0.7777+0.75)/2.0;\n    }\n    \n    fragColor = vec4(0.,0.,0.,0.);\n    if (!alive(dnaindex)) return;\n    \n    vec2 pixel = (screencoord-0.5)*1.2;\n    \n    if (false)\n    {   // debug distnace field\n        pixel.y*=-iResolution.y/iResolution.x;\n        vec3 p = vec3(pixel.xy*8.,0.0);\n        float d = distfunc(p).x;\n        fragColor = vec4(fract(d*4.0),fract(d*0.0001),0.,1.0);\n        return;\n    }\n    \n    vec3 camTarget = vec3(0.,0.,0.);\n    vec3 camPos = vec3(0.,0.,-6.);\n    camPos.xz *= rotate(iTime+0.6);\n    \n    \n    vec3 camZ = normalize(camTarget-camPos);\n    vec3 camX = normalize(cross(camZ,vec3(0.,-1.,0.)));\n    vec3 camY = cross(camZ,camX);\n    \n    vec3 raydir = normalize(camZ + camX*pixel.x + camY*pixel.y);\n\n    \n    vec3 p = camPos;\n    \n    int i; // raymarching main loop\n    for(i=0;i<200;i++)\n    {\n        float d = distfunc(p).x;\n        if (d<0.0001) break; // hit the object\n        p += raydir*d;\n        if (length(p)>10.) break; // passed far away -> display background\n        \n    }\n\n    vec3 col;\n\tif (length(p)>10.)    \n    {\n        col = backGround(raydir);\n    }\n    else\n    {\n        float travel = length(p-camPos); // can be used for depth display\n        float material = distfunc(p).y;\n        vec3 norm = getnormal(p);\n        vec3 diff = vec3(0.8,0.8,0.8);\n        \n        float zoom = 0.8;\n        vec3 t3d = texture(iChannel1,p.xy*zoom).xyz*abs(norm.z)+\n         texture(iChannel1,p.xz*zoom).xyz*abs(norm.y)+\n         texture(iChannel1,p.yz*zoom).xyz*abs(norm.x);\n\n        t3d /= abs(norm.x)+abs(norm.y)+abs(norm.z);\n\n        diff = t3d*0.55+0.7;\n        vec3 ambientcolor = vec3(0.4,0.5,0.55);\n        vec3 suncolor = vec3(0.55,0.5,0.4)*1.2;\n        vec3 sundir = normalize(camX+camY+camZ*-1.);\n\n        col = diff*(ambientcolor*(norm.y*-0.5+0.5)+suncolor*max(0.,dot(norm,sundir)));\n    }\n    \n    // vignette\n    float f = pow(max(max(abs(screencoord.x-0.5)*2.0,abs(screencoord.y-0.5)*2.0)*5.0-4.0,0.),4.0);\n    fragColor = vec4(mix(col,bordercolor,f),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// most genes specify the length of bones angle between bones and thickness.\nconst float dnaMan[] =  float[](\n    0.,0.,0.,0.,0.,0.,0.,// reserved\n    0.3,0.4,   0.1, // hip width,thickness // 7\n    0.1,0.15,1.2,0.45,    -0.25,1.2, 0.35,  // thy (angle,angle length,thickness),   shin\n    0.6,0.34,  // torso\n    0.25,0.2,1.1,0.34,          0.6,0.9,0.25,0.1,// arm 19-\n    0.9,0.28,0.37,0.03, // neck 27-  neck len, neck thickness, head radius, head forward\n    1.7,0.7,0.22, // foot 31\n    0.0,0.7,0.3,   -0.1,0.6,0.50,   -0.1,0.6,0.51,0.3, 0.2,  //34 spine angle,len,thickness...neck angle\n    0.1,0.0,0.0,0.1 // tail\n    );\n\n\nconst float dnaMan2[] =  float[](\n    0.,0.,0.,0.,0.,0.,0.,// reserved\n    0.45,0.5,   0.1, // hip width,thickness // 7\n    0.0,0.25,1.0,0.45,    -0.25,1.0, 0.4,  // thy (angle,angle length,thickness),   shin\n    0.7,0.5,  // torso\n    0.1,0.3,0.95,0.38,          0.7,0.8,0.32,0.1,// arm 19-\n    0.8,0.3,0.43,0.2, // neck 27-  neck len, neck thickness, head radius, head forward\n    1.8,0.7,0.3, // foot 31\n    0.0,0.6,0.4,   -0.2,0.55,0.7,   -0.1,0.5,0.51,0.3, 0.0,  //34 spine angle,len,thickness...neck angle\n    0.1,0.0,0.0,0.1 // tail\n    );\n\n\nconst float dnaCat[] =  float[](\n    0.,0.,0.,0.,0.,0.,0.,// reserved\n    0.2,0.2,   0.0, // hip width,thickness // 7\n    0.2,2.1,0.5,0.3,    -1.6,0.8, 0.3,  // thy (angle,angle length,thickness),   shin\n    0.25,0.4,  // torso\n    -1.4,0.1,0.8,0.25,          1.6,0.8,0.18,0.03,// arm 19-\n    0.85,0.17,0.35,0.25, // neck 27-  neck len, neck thickness, head radius, head forward\n    1.5,0.9,0.2, // foot 31\n    0.3,0.8,0.3,   0.6,0.9,0.5,   0.7,0.9,0.6,0.3,   -1.2,   //34 spine angle,len,thickness...neck angle\n    0.8,1.0,0.2,   0.6 // tail\n    \n    );\n\nconst float dnaDog[] =  float[](\n    0.,0.,0.,0.,0.,0.,0.,// reserved\n    0.25,0.3,   0.0, // hip width,thickness // 7\n    0.25,1.9,0.8,0.3,    -1.2,0.8, 0.3,  // thy (angle,angle length,thickness),   shin\n    0.25,0.4,  // torso\n    -1.2,0.1,0.8,0.3,          1.0,1.0,0.25,0.08,// arm 19-\n    1.5,0.46,0.26,0.4, // neck 27-  neck len, neck thickness, head radius, head forward\n    1.1,0.7,0.2, // foot 31\n    0.0,0.7,0.4,   0.2,0.8,0.5,   -0.0,0.9,0.6,0.65,   -1.4,   //34 spine angle,len,thickness...neck angle\n    -0.4,1.0,0.2,   -0.4 // tail\n    \n    );\n\n\n\n\nfloat getdna(int j,int i)\n{\n    if (j==1) return dnaMan[i];\n    if (j==2) return dnaMan2[i];\n    if (j==3) return dnaCat[i];\n    if (j==4) return dnaDog[i];\n    return 0.0;\n}\n\n#define read(x,y) texture(iChannel0,vec2(float(x)+0.1,float(y)+0.1)/(iResolution.xy))\n#define write(xa,ya,aa) {if (t.y==ya && t.x==xa) ou = aa;}\n\nbool alive(int j)\n{\n    return read(1,j).w!=0.0;\n}\n\nvoid mainImage( out vec4 ou, in vec2 fragCoord )\n{\n    ivec2 t = ivec2((fragCoord.xy+0.1));\n    \n    if (t.y>13 || t.x >80) discard;\n\n    if (iFrame==0)\n    { // init\n\t    ou  = vec4(0.0,0.0,0.0,0.0);\n    \n        \n        if (t.y>=1 && t.y<=4)\n        {\n            int j=t.y;\n            ou  = vec4(getdna(j,t.x*4),getdna(j,t.x*4+1),getdna(j,t.x*4+2),getdna(j,t.x*4+3));\n        }\n    \n        write(0,0,vec4(1.0, 0.0, 0.0, 0.0));\n    }\n    else\n    {\n        ou = read(t.x,t.y);\n        ivec4 selector = ivec4(read(0,0));\n        \n        if (iMouse.z>0.0)\n        {\n            vec2 screencoord = iMouse.xy/iResolution.xy;\n            float aspect = 9./16.;\n            screencoord.x/=aspect;\n\n            int viewindex = -1;\n            if (screencoord.x<0.75) // small views\n            {\n                viewindex = int(floor(screencoord.x*4.0)+floor((1.0-screencoord.y)*4.0)*3.)+1;\n\n                if (viewindex==12 && selector.x*selector.y!=0) // crossbreed button\n                {\n                    int newindex = 1;\n                    while(alive(newindex) && newindex<11) newindex++;\n                    if (newindex<11)\n                    {\n                        if (t.y==newindex)\n                        {\n                            float randomseed = iTime+(iMouse.x+iMouse.y*1.4)/255.0;\n                            ou = mix(read(t.x,selector.x),read(t.x,selector.y),texture(iChannel1,vec2(float(t.x)/256.0+randomseed*0.2,randomseed)).xyzw);\n                        }\n                        selector.x = newindex;\n                        selector.y = 0;\n                    }\n                }\n\n                if (viewindex==11) // delete button\n                {\n                    if (selector.x>0)\n                    {\n                        write(1,selector.x,vec4(0.,0.,0.,0.));\n                        selector.x=0;\n                        selector.y=0;\n                    }\n                }\n                \n/*                \n// TODO: Mutation isn't easy, because have to set acceptable ranges for all gens\n                if (viewindex==10) // mutate button\n                {\n                    if (selector.x!=0)\n                    {\n                        // mutate\n                        if (t.y==selector.x)\n                        {\n                            \n                            float randomseed = iTime+(iMouse.x+iMouse.y*1.4)/255.0;\n//                            ou = max(vec4(0.,0.,0.,0.),ou+(texture(iChannel1,vec2(float(t.x)/256.0+randomseed*0.2,randomseed)).xyzw*2.0-1.0)*0.01);\n                        }\n                    }\n                }\n*/\n\n                if (alive(viewindex))\n                {\n                    if (selector.x != (viewindex))\n                    {\n                        selector.y = selector.x;\n                    }\n                    selector.x = (viewindex);\n                }\n            }\n        }\n        \n        write(0,0,vec4(selector));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}