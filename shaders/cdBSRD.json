{
    "Shader": {
        "info": {
            "date": "1669947405",
            "description": "ChatGPT (2022-12-02) for \"make a shader that does a perlin noise with octaves in shadertoy\"",
            "flags": 0,
            "hasliked": 0,
            "id": "cdBSRD",
            "likes": 5,
            "name": "ChatGPT PerlinNoise",
            "published": 3,
            "tags": [
                "chatgpt"
            ],
            "usePreview": 0,
            "username": "PauloFalcao",
            "viewed": 276
        },
        "renderpass": [
            {
                "code": "// ChatGPT (2022-12-02) for\n\n// \"make a shader that does a perlin noise with octaves in shadertoy\"\n\n// The original shader had a function called cnoise(vec2)\n// \"please detail the function cnoise\"\n// \"cnoise is a built-in function in Shadertoy that generates Perlin noise\" LOL\n// \"show a glsl implementation of cnoise\"\n// It worked! But used a function called random(vec2)\n// \"please provide a random(i) function implementation\"\n// And the shader was complete\n// I only added two lines of code with the comments \"Human code\" :)\n\n\n// Generates a random value at the specified position.\n//\n// The \"position\" parameter is a two-dimensional vector that specifies the position\n// at which the random value should be calculated. The return value is a\n// floating-point number in the range [0, 1] that represents the random value at\n// the input position.\nfloat random(vec2 position)\n{\n    // Calculate a random number for each coordinate of the input position.\n    float x = fract(sin(dot(position, vec2(12.9898, 78.233))) * 43758.5453);\n    float y = fract(sin(dot(position, vec2(56.9898, 23.233))) * 43758.5453);\n\n    // Return the random number as the result of the function.\n    return x * y;\n}\n\n\n// Generates Perlin noise at the specified position.\n//\n// The \"position\" parameter is a two-dimensional vector that specifies the position\n// at which the Perlin noise value should be calculated. The return value is a\n// floating-point number in the range [-1, 1] that represents the Perlin noise\n// value at the input position.\nfloat cnoise(vec2 position)\n{\n    // Calculate the integer and fractional parts of the input position.\n    vec2 i = floor(position);\n    vec2 f = fract(position);\n\n    // Calculate the four corner values of the unit square that contains the\n    // input position. These values are used as the \"random\" values that are\n    // interpolated to generate the final noise value.\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Interpolate the four corner values using a smooth Hermite curve. This\n    // produces a smooth, natural-looking noise pattern.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    float v = mix(a, b, u.x);\n    float w = mix(c, d, u.x);\n    float noise = mix(v, w, u.y);\n\n    // Return the noise value, scaled to the range [-1, 1].\n    return noise * 2.0 - 1.0;\n}\n\n\n\n// This is a Shadertoy shader that generates a 2D image using Perlin noise with\n// multiple octaves.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the position of the current pixel in the range [0, 1].\n    vec2 uv = fragCoord / iResolution.xy;\n    \n//Human code start\nuv-=0.5;\nuv*=sin(iTime)*10.0+15.0;\n//Human code end\n\n    // Initialize the Perlin noise value to 0.0.\n    float noise = 0.0;\n\n    // Calculate Perlin noise with 4 octaves. Each octave adds additional detail\n    // to the noise pattern, increasing the overall complexity of the pattern.\n    for (int i = 0; i < 4; i++)\n    {\n        // Scale the position by a factor of 2 for each octave. This causes the\n        // noise pattern to appear at a higher frequency for each octave.\n        vec2 position = uv * pow(2.0, float(i));\n\n        // Calculate the Perlin noise value at the current position.\n        float value = cnoise(position);\n\n        // Add the noise value to the total noise value, scaled by a factor of 1/2\n        // for each octave. This reduces the contribution of each octave, which\n        // produces a more natural-looking noise pattern.\n        noise += value / pow(2.0, float(i));\n    }\n\n    // Map the Perlin noise value from the range [-1, 1] to the range [0, 1]\n    // by adding 1.0 and dividing by 2.0.\n    float value = (noise + 1.0) / 2.0;\n\n    // Set the color of the pixel based on the Perlin noise value.\n    fragColor = vec4(value, value, value, 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}