{
    "Shader": {
        "info": {
            "date": "1557318456",
            "description": "My first attempt at raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsGzl",
            "likes": 3,
            "name": "Reflective Spheres",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "inv41idu53rn4m3",
            "viewed": 373
        },
        "renderpass": [
            {
                "code": "#define SURFACE_TRESHOLD 0.01\n#define MAX_STEPS 100\n\nstruct traceResult {\n    int steps;\n    float field;\n    float dist;\n    vec3 pos;\n};\n\nvec3 translate(vec3 pos, vec3 offset) {\n    return pos - offset;\n}\n\nfloat sphere(float radius, vec3 pos) {\n    return length(pos) - radius;\n}\n\nfloat planeY(vec3 pos) {\n\treturn pos.y;\n}\n\nfloat field(vec3 pos) {\n    float s1 = sphere(1.0, translate(pos, vec3(0.0, 0.0, 4.0)));\n    float s2 = sphere(0.5, translate(pos, vec3(2.0, 0.0, 4.0)));\n    float s3 = sphere(2.0, translate(pos, vec3(1.0, 1.0, 6.0)));\n    float s4 = sphere(3.0, translate(pos, vec3(-3.0, 1.0, 5.5)));\n    float p1 = planeY(translate(pos, vec3(0.0, -1.0, 0.0)));\n    return min(min(s1, p1), min(s2, min(s3, s4))) - 0.1;\n}\n\nvec3 fnormal(vec3 pos) {\n    const float c = SURFACE_TRESHOLD;\n    float f0 = field(pos);\n    float x = field(pos + vec3(c, 0.0, 0.0));\n    float y = field(pos + vec3(0.0, c, 0.0));\n    float z = field(pos + vec3(0.0, 0.0, c));\n    return normalize(vec3(x - f0, y - f0, z - f0));\n}\n\nvec3 normal2colour(vec3 n) {\n    float top = max(0.0, sign(n.y));\n    float bot = max(0.0, -sign(n.y));\n    const vec3 topcol = vec3(0.7, 0.6, 0.1);\n    const vec3 botcol = vec3(0.3, 0.4, 0.6);\n    return top * topcol + bot * botcol;\n}\n\ntraceResult trace(vec3 start, vec3 dir) {\n\tvec3 tpos = start;\n    int steps = 0;\n    \n    float fieldlocal = field(tpos);\n    while (abs(fieldlocal) > SURFACE_TRESHOLD && steps < MAX_STEPS) {\n        tpos += dir * fieldlocal;\n        fieldlocal = field(tpos);\n        steps++;\n    }\n    return traceResult(steps, fieldlocal, length(tpos - start), tpos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sensible viewport\n    uv -= vec2(0.5);\n    uv *= vec2(iResolution.x / iResolution.y, 1.0) * 2.0;\n    \n    // Pixel pos to ray\n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    vec3 col = vec3(1.0);\n    \n    traceResult result = trace(vec3(0.0), ray);\n    int bounces = 0;\n    while (result.field < SURFACE_TRESHOLD && bounces < 20) {\n        bounces++;\n        vec3 normal = fnormal(result.pos);\n        ray = reflect(ray, normal);\n        col *= normal2colour(normal);\n        result = trace(result.pos + normal * SURFACE_TRESHOLD, ray);\n    }\n    col *= smoothstep(-1.0, 1.0, normalize(ray).y) * vec3(1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}