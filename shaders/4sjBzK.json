{
    "Shader": {
        "info": {
            "date": "1501170735",
            "description": "Forked from zeletochoy's https://www.shadertoy.com/view/lstGRS. Hopf fibers with iq's better color scheme https://www.shadertoy.com/view/ll2GD3.\nmouse.x corresponds to ",
            "flags": 0,
            "hasliked": 0,
            "id": "4sjBzK",
            "likes": 4,
            "name": "Hopf Fibration",
            "published": 3,
            "tags": [
                "4d",
                "hypersphere",
                "hopf",
                "fibration"
            ],
            "usePreview": 0,
            "username": "starea",
            "viewed": 809
        },
        "renderpass": [
            {
                "code": "// Hopf Fibration\n// https://en.wikipedia.org/wiki/Hopf_fibration\n// https://www.shadertoy.com/view/4sjBzK\n#define PI 3.141592653589793\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 fiber_at(vec3 pt, float ph)\n{\n  float th = atan(-pt.x, pt.y) - ph;\n  float al = sqrt((1.0 + pt.z) / 2.0);\n  float be = sqrt((1.0 - pt.z) / 2.0);\n  float w = al * cos(th);\n  float x = -be * cos(ph);\n  float y = -be * sin(ph);\n  float z = al * sin(th);\n  float r = acos(w) / PI;\n  float f = r / (1.0 - w * w);\n  return f * vec3(x, y, z);\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec3 opTurn(vec3 p, vec3 rot)\n{\n  float a = -rot.x, b = -rot.y, c = -rot.z;\n  float ca = cos(a), cb = cos(b), cc = cos(c);\n  float sa = sin(a), sb = sin(b), sc = sin(c);\n  mat3 m = mat3(ca*cb*cc-sa*sc, -ca*cb*sc-sa*cc, ca*sb,\n                sa*cb*cc+ca*sc, -sa*cb*sc+ca*cc, sa*sb,\n                -sb*cc,         sb*sc,           cb);\n  return m * p;\n}\n\nvec3 calc_rot(vec3 norm)\n{\n  float x = atan(norm.y, norm.z);\n  float y = atan(norm.x, norm.y);\n  float z = atan(norm.y, norm.x);\n  return vec3(x, y, z);\n}\n\nfloat fiber(vec3 p, vec3 pt)\n{\n  vec3 a = fiber_at(pt, 0.0);\n  vec3 b = fiber_at(pt, PI);\n  vec3 c = fiber_at(pt, 0.5 * PI);\n  vec3 center = (a + b) / 2.0;\n  vec3 norm = normalize(cross(c - center, b - center));\n  norm = normalize(cross(b - center, norm));\n  vec3 rot = calc_rot(norm);\n  vec2 torus_params = vec2(1.0, 0.01);\n  return sdTorus(opTurn(p, rot) + center, torus_params);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{       \n  float len = length(p);\n  p = normalize(p);\n\n  float delta = PI / 8.;\n\n  vec3 pol = vec3(fract(len),\n                  mod(atan(p.y, p.x), delta) - delta / 2.,\n                  atan(p.z, length(p.xy)));\n\n  return vec3(pol.x * cos(pol.y)* cos(pol.z),\n              pol.x * sin(pol.y) * cos(pol.z),\n              pol.x * sin(pol.z));\n}\n\nfloat equator_fibers(vec3 p)\n{\n  float d = 9999999999999.0;\n  for (float th = 0.1; th < 2.0 * PI; th += PI / 32.0)\n    d = min(d, fiber(p, normalize(vec3(cos(th), sin(th), 2.0 * iMouse.x / iResolution.x))));\n  return d;\n}\n\n//----------------------------------------------------------------------\n\nvec2 map(in vec3 pos)\n{\n  return vec2(equator_fibers(pos), 1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n  float tmin = 1.0;\n  float tmax = 20.0;\n\n  float precis = 0.002;\n  float t = tmin;\n  float m = -1.0;\n  int count = 0;\n  for(int i=0; i < 50; i++)\n  {\n    count++;\n    vec2 res = map( ro+rd*t );\n    if( res.x<precis || t>tmax ) break;\n    t += res.x;\n    m = res.y;\n  }\n\n  if( t>tmax ) m=-1.0;\n  return vec2( t, count);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n  float t = mint;\n  for( int i=0; i<16; i++ )\n  {\n    float h = map( ro + rd*t ).x;\n    res = min( res, 8.0*h/t );\n    t += clamp( h, 0.02, 0.10 );\n    if( h<0.001 || t>tmax ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n                  map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n                  map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n  return normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n  vec3 col = pal( 0.0, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n  vec2 res = castRay(ro,rd);\n  float t = res.x;\n  float m = res.y;\n  if( m>-0.5 )\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    // material        \n    //col = pal( 0.5 * log(m), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    col = pal( 0.3 * log(m), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n      //col = 0.35 + 0.3 * cos(vec3(0.05,0.08,0.10) * 42. * log(m));\n\n    // lighitng        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    //col = mix( col, vec3(1.0, 0.0, 0.0), 1.0-exp( -0.0005*t*t ) );\n  }\n\n  return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 q = fragCoord / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n\n  float time = iTime;\n\n  // camera     \n  vec3 ro = 3.0 * vec3(cos(time), 0.5, sin(time));\n  vec3 ta = vec3(0.);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy,2.0));\n\n  // render   \n  vec3 col = render(ro, rd);\n\n  fragColor = vec4(pow(col, vec3(0.4545)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}