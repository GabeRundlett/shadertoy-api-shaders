{
    "Shader": {
        "info": {
            "date": "1710041557",
            "description": "extrudes an sdf box\ninner sdf is innaccurate",
            "flags": 48,
            "hasliked": 0,
            "id": "l3sSzB",
            "likes": 1,
            "name": "extruded box sdf",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 118
        },
        "renderpass": [
            {
                "code": "float sdbox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//https://www.shadertoy.com/view/4sXXRN by iq\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat tridist3d(vec3 p, vec3 a, vec3 b, vec3 c){\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n//https://www.shadertoy.com/view/XsXSz4 by iq\nfloat sdtri2d(vec2 p, vec2 p0, vec2 p1, vec2 p2){\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n//by fad\nmat3x2 get_plane_projection_matrix(vec3 normal) {\n  vec3 x = cross(normal,vec3(0,0,1));\n  vec3 z = normal;\n  vec3 y = cross(z, x);\n  return transpose(mat2x3(x, y));\n}\n\n//n is extrusion direction\nfloat sdextrudedtri(vec3 p, vec3 n, vec3 a, vec3 b, vec3 c){\n    //1: project to plane defined by normal\n    //2: get 2d sdf\n    //3: add caps\n    vec3 normal = normalize(cross(b-a,c-a));\n    normal = faceforward(normal,n,normal);\n    if (dot(p,normal) > dot(a,normal)){\n        return tridist3d(p,a,b,c);\n    }\n    if (dot(p,normal) < dot(a+n,normal)){\n        return tridist3d(p,a+n,b+n,c+n);\n    }\n    mat3x2 m = get_plane_projection_matrix(normalize(n));\n    float inner_dist = sdtri2d(m*p,m*a,m*b,m*c);\n    float s = sign(inner_dist);\n    return min(tridist3d(p,a,b,c), min(inner_dist,tridist3d(p,a+n,b+n,c+n)));\n}\n\n//non-exact (excess inner geometry)\nfloat sdextrudedbox(vec3 p, vec3 b, vec3 d){\n    vec3 v1 = vec3(b.x,b.y,b.z);\n    vec3 v2 = vec3(-b.x,b.y,b.z);\n    vec3 v3 = vec3(b.x,-b.y,b.z);\n    vec3 v4 = vec3(-b.x,-b.y,b.z);\n    vec3 v5 = vec3(b.x,b.y,-b.z);\n    vec3 v6 = vec3(-b.x,b.y,-b.z);\n    vec3 v7 = vec3(b.x,-b.y,-b.z);\n    vec3 v8 = vec3(-b.x,-b.y,-b.z);\n    float dist = 1e20;\n    dist = min(dist,sdextrudedtri(p,d,v1,v3,v5));\n    dist = min(dist,sdextrudedtri(p,d,v7,v3,v5));\n    dist = min(dist,sdextrudedtri(p,d,v2,v4,v6));\n    dist = min(dist,sdextrudedtri(p,d,v8,v4,v6));\n    \n    dist = min(dist,sdextrudedtri(p,d,v1,v2,v5));\n    dist = min(dist,sdextrudedtri(p,d,v6,v2,v5));\n    dist = min(dist,sdextrudedtri(p,d,v3,v4,v7));\n    dist = min(dist,sdextrudedtri(p,d,v8,v4,v7));\n    \n    dist = min(dist,sdextrudedtri(p,d,v1,v2,v3));\n    dist = min(dist,sdextrudedtri(p,d,v4,v2,v3));\n    dist = min(dist,sdextrudedtri(p,d,v5,v6,v7));\n    dist = min(dist,sdextrudedtri(p,d,v8,v6,v7));\n    //return dist;\n    return min(dist,sdbox(p,b));\n}\n\nfloat scene(vec3 p){\n    //return sdbox(p,vec3(0.5,1,1.5));\n    return sdextrudedbox(p,vec3(0.5,1,1.5),vec3(1,1.5,1));\n}\n\nfloat castRay(Ray ray){\n    float t = 0.0;\n    for (int i = 0; i < maxsteps; i++){\n        float d = abs(scene(ray.origin));\n        ray.origin += d*ray.direction;\n        t += d;\n        if (d < 0.0001 || t > far) break;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //cam setup\n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, iResolution.xy, position, rotation, cameraFrustum);\n\n    vec4 col = vec4(castRay(cam.ray)/100.0);\n\n    // gamma correction\n    fragColor = pow(col,vec4(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define maxsteps 256\n#define maxlightsteps 4\n#define far 500.0\n#define cameraFrustum 0.7\n\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.1;\nconst float moveDamping = 0.7;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n    vec2 uv;\n};\n\nstruct Hit {\n    bool hit;\n    float dist;\n    vec3 point;\n};\n\n//fakes x^n for various effects\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nmat3 rotationMatrix(vec3 a){\n    //calculate consts\n    float cx = cos(a.x);\n    float sx = sin(a.x);\n    float cy = cos(a.y);\n    float sy = sin(a.y);\n    float cz = cos(a.z);\n    float sz = sin(a.z);\n    //return matrix\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= rotationMatrix(angle); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, frustumLength);\n    vec3 uvd = normalize(uv);\n    mat3 rotmat = rotationMatrix(camRot);\n    vec3 ro = uv*rotmat + cameraPos;\n    vec3 rd = uvd*rotmat;\n    return Camera(cameraPos, Ray(ro, rd), uv.xy);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0.35,0.09).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //velocity\n    if (floor(fragCoord) == vec2(3,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        vec2 forward = rotate3d(vec3(1,0,0),vec3(0,texelFetch(iChannel0, ivec2(1,0),0).x*sensitivity,0), vec3(0)).xz;\n        vec2 right = vec2(-forward.y,forward.x);\n        vec3 relative = vec3(keyPressed(_d)-keyPressed(_a), 0, keyPressed(_w)-keyPressed(_s));\n        float up = keyPressed(_space) - keyPressed(_shift);\n        vec3 move = vec3(relative.x*forward.x + relative.z*right.x, up, relative.x*forward.y + relative.z*right.y);\n        velocity = move != vec3(0) ? velocity*moveDamping + normalize(move)*moveSpeed : velocity*moveDamping;\n        \n        if (position.y < -1000.0){\n            velocity = vec3(0);\n        }\n        col.xyz = velocity;\n    }\n    \n    //position\n    if (floor(fragCoord) == vec2(4,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        position += velocity*iTimeDelta*60.0;\n        \n        if (position.y < -500.0){\n            position = vec3(0,24,0);\n        }\n        \n        if (iFrame == 0){\n            position = vec3(-5,0,-2);\n        }\n        col.xyz = position;\n    }\n    \n    //resolution\n    if (floor(fragCoord) == vec2(5,0)){\n        col.xy = iResolution.xy;\n    }\n    //light direction\n    if (floor(fragCoord) == vec2(6,0)){\n        float t = texelFetch(iChannel0,ivec2(6,0),0).w;\n        if (iFrame == 0){\n            t = 0.5;\n        }\n        col.xyz = vec3(sin(t*PI*2.0),cos(t*PI*2.0),0);\n        col.w = t + (keyPressed(_c) - keyPressed(_v))*0.01;\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}