{
    "Shader": {
        "info": {
            "date": "1563384443",
            "description": "Distance approximation to a cubic bezier curve by an iteration in parameter space.\nBasically a special Newton's (or Halley's) method.\nHybrid mode uses segmentation for points farther away.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsSzS",
            "likes": 21,
            "name": "Cubic bezier approx distance 2",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "cubic",
                "iteration",
                "newton",
                "parametric",
                "cubicbezier",
                "halley"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 1475
        },
        "renderpass": [
            {
                "code": "/*\nCopyright (c) <2024> <Felix Potthast>\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software\nand associated documentation files (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies\nor substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n\n/*\nSee also:\n\nOld distance approximation (which is inferior):\nhttps://www.shadertoy.com/view/lsByRG\n\nExact distance computation:\nhttps://www.shadertoy.com/view/4sKyzW\n\nMaximum norm distance:\nhttps://www.shadertoy.com/view/4sKyRm\n\n\nThis approach applied to more complex parametric curves:\nhttps://www.shadertoy.com/view/3tsXDB\n*/\n\n//#define SECOND_ORDER\n//#define HYBRID\n//#define SEGMENTS\n\nconst float dot_size=.005;\n\nconst vec3 point_col=vec3(1,1,0);\n\nconst float zoom=1.;\n\nconst float pi=3.1415926535;\n\nconst int num_segments=5;\n\nconst int num_iterations=3;\nconst int num_start_params=3;\n\n//factor should be positive\n//it decreases the step size when lowered.\n//Lowering the factor and increasing iterations increases the area in which\n//the iteration converges, but this is quite costly\nconst float factor=1.;\n\nconst float eps=.005;\n\nfloat newton_iteration3(vec3 coeffs, float x){\n\tfloat a2=coeffs[2]+x;\n\tfloat a1=coeffs[1]+x*a2;\n\n\tfloat f=coeffs[0]+x*a1;\n\tfloat f1=((x+a2)*x)+a1;\n\n\treturn x-f/f1;\n}\n\nfloat halley_iteration3(vec3 coeffs, float x){\n\tfloat a2=coeffs[2]+x;\n\tfloat a1=coeffs[1]+x*a2;\n\n\tfloat f=coeffs[0]+x*a1;\n\n\tfloat b2=a2+x;\n\n\tfloat f1=a1+x*b2;\n\tfloat f2=2.*(b2+x);\n\n\treturn x-(2.*f*f1)/(2.*f1*f1-f*f2);\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(float a, float b, float c, out vec3 r){\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n//Sign computation is pretty straightforward:\n//I'm solving a cubic equation to get the intersection count\n//of a ray from the current point to infinity and parallel to the x axis\n//Also i'm computing the intersection count with the tangent in the end points of the curve\nfloat cubic_bezier_sign(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu=(-p0.y+3.*p1.y-3.*p2.y+p3.y);\n\tfloat qu=(3.*p0.y-6.*p1.y+3.*p2.y);\n\tfloat li=(-3.*p0.y+3.*p1.y);\n\tfloat co=p0.y-uv.y;\n\n\tvec3 roots;\n\tint n_roots=solve_cubic(qu/cu,li/cu,co/cu,roots);\n\n\tint n_ints=0;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n_roots){\n\t\t\tif(roots[i]>=0. && roots[i]<=1.){\n\t\t\t\tfloat x_pos=((((-p0.x+3.*p1.x-3.*p2.x+p3.x)*roots[i]+(3.*p0.x-6.*p1.x+3.*p2.x))*roots[i])+(-3.*p0.x+3.*p1.x))*roots[i]+p0.x;\n\t\t\t\tif(x_pos<uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvec2 tang1=p0.xy-p1.xy;\n\tvec2 tang2=p2.xy-p3.xy;\n\n\tvec2 nor1=vec2(tang1.y,-tang1.x);\n\tvec2 nor2=vec2(tang2.y,-tang2.x);\n\n\tif(p0.y<p1.y){\n\t\tif((uv.y<=p0.y) && (dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif(!(uv.y<=p0.y) && !(dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(p2.y<p3.y){\n\t\tif(!(uv.y<=p3.y) && dot(uv-p3.xy,nor2)<0.){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif((uv.y<=p3.y) && !(dot(uv-p3.xy,nor2)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(n_ints==0 || n_ints==2 || n_ints==4){\n\t\treturn 1.;\n\t}\n\telse{\n\t\treturn -1.;\n\t}\n}\n\n//cubic bezier distance by segmentation based on the one by iq\n//see https://www.shadertoy.com/view/XdVBWd\n\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat cubic_bezier_segments_dis_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){   \n    float d0 = 1e38;\n    vec2 a = p0;\n    for( int i=1; i<num_segments; i++ )\n    {\n        float t = float(i)/float(num_segments-1);\n        float s = 1.0-t;\n        vec2 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n        d0 = min(d0,segment_dis_sq(uv, a, b ));\n        a = b;\n    }\n    \n    return d0;\n}\n\nfloat cubic_bezier_segments_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\treturn sqrt(cubic_bezier_segments_dis_sq(uv,p0,p1,p2,p3));\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-factor*dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_normal_iteration2(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\tvec2 snd_drv=2.*(b_2+t*a3);\n\n\tfloat l_tang=dot(tang,tang);\n\n\tfloat fac=dot(tang,snd_drv)/(2.*l_tang);\n\tfloat d=-dot(tang,uv_to_p);\n\n\tfloat t2=d/(l_tang+fac*d);\n\n\treturn t+factor*t2;\n}\n\nfloat cubic_bezier_normal_iteration3(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\tvec2 tang=(3.*a3*t+2.*a2)*t+a1;\n\tvec3 poly=vec3(dot(a0,tang),dot(a1,tang),dot(a2,tang))/dot(a3,tang);\n\n\t/* newton iteration on this polynomial is equivalent to cubic_bezier_normal_iteration */\n\treturn newton_iteration3(poly,t);\n\n\t/* halley iteration on this polynomial is equivalent to cubic_bezier_normal_iteration2 */\n\t//return halley_iteration3(poly,t);\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t0=0.;\n\tfloat t;\n\n\tfor(int i=0;i<num_start_params;i++){\n\t\tt=t0;\n\t\tfor(int j=0;j<num_iterations;j++){\n\t\t\t#ifdef SECOND_ORDER\n\t\t\tt=cubic_bezier_normal_iteration2(t,a0,a1,a2,a3);\n\t\t\t#else\n\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t\t#endif\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\n\t\tt0+=1./float(num_start_params-1);\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\treturn sqrt(cubic_bezier_dis_approx_sq(uv,p0,p1,p2,p3));\n}\n\nfloat cubic_bezier_dis_approx_hybrid(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tfloat d0=cubic_bezier_dis_approx_sq(uv,p0,p1,p2,p3);\n\n\tif(d0>eps){\n\t\td0=min(d0,cubic_bezier_segments_dis_sq(uv,p0,p1,p2,p3));\n\t}\n\n\treturn sqrt(d0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\tmouse*=zoom;\n\n\tvec2 p0=vec2(-.3,-.1);\n\tvec2 p1=mouse;\n\tvec2 p2=vec2(.1,-.2);\n\tvec2 p3=vec2(.2,.15);\n\n\t#ifdef HYBRID\n\tfloat dis=cubic_bezier_dis_approx_hybrid(uv,p0,p1,p2,p3);\n\t#else\n\t#ifdef SEGMENTS\n\tfloat dis=cubic_bezier_segments_dis(uv,p0,p1,p2,p3);\n\t#else\n\tfloat dis=cubic_bezier_dis_approx(uv,p0,p1,p2,p3);\n\t#endif\n\t#endif\n\n\tfloat sgn=cubic_bezier_sign(uv,p0,p1,p2,p3);\n\n\t//iq's sd color scheme\n\tvec3 color = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.005,dis) );\n\n\tdis=1e38;\n\n\tdis=min(dis,distance(p0,uv)-dot_size);\n\tdis=min(dis,distance(p1,uv)-dot_size);\n\tdis=min(dis,distance(p2,uv)-dot_size);\n\tdis=min(dis,distance(p3,uv)-dot_size);\n\n\tcolor=mix(point_col,color,smoothstep(0.,border,dis));\n\n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}