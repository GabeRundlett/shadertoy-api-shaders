{
    "Shader": {
        "info": {
            "date": "1635789601",
            "description": "...them damn neons",
            "flags": 32,
            "hasliked": 0,
            "id": "sl3GR4",
            "likes": 15,
            "name": "Neon Run",
            "published": 3,
            "tags": [
                "truchet",
                "neon",
                "rollercoaster",
                "octtree"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 678
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Neon Run\n//\n// 3D-generalization of multi-scale-truchets (Octtree truchet)\n// golfed down monochrome version: https://www.shadertoy.com/view/st3GRr\n\n\n#define Res vec2(iResolution.xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=texture(iChannel0,fragCoord/Res);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Neon Run\n//\n// 3D-generalization of multi-scale-truchets (Octtree truchet)\n// golfed down monochrome version: https://www.shadertoy.com/view/st3GRr\n\n#define SIM_CAM\n#define COLOR\n#define FLICKER\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n#define SQH sqrt(.5)\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang, vec3 p) { return vec3(ROTM(ang)*p.xy,p.z); }\nvec3 rotX(float ang, vec3 p) { return rotZ(ang,p.yzx).zxy; }\n\nvec4 getRand(int i) { return texelFetch(iChannel1,ivec2(i,i%256)%256,0); }\nvec4 getRand(float f) { return mix(getRand(int(floor(f))),getRand(int(ceil(f))),fract(f)); }\n\nfloat distCell01(vec3 p, float n)\n{\n    float d=1000.;\n    p-=.5;\n    for(int i=0;i<3;i++) {\n        vec3 p2=p;\n        p2.z=(fract((p2.z+.5)*n)-.5)/n;\n        float l=length(p2.xy-(-.5));\n        float l0=(min(floor(l*n),n-1.)+.5)/n;\n        d=min(d,length(vec2(l-l0,p2.z)));\n        p=(p*vec3(-1,-1,1)).yzx;\n    }\n    return d;\n}\n\nvec3 getR(vec3 p)\n{\n    return cos((p+p.zxy*1.1+p.yzx*1.3)*10.)*.5+.5;\n}\n\nvec3 g_r=vec3(0);\nvec3 g_p0=vec3(0);\nfloat g_radius=0.002;\n\nfloat dist(vec3 p)\n{\n    p+=(getR(p*.3)-.5)*.1;\n    float sc=1.;\n    vec3 p0=floor(p/sc)*sc;\n    if (getR(p0).x>.75) { sc*=.5; p0=floor(p/sc)*sc; }\n    if (getR(p0).x>.75) { sc*=.5; p0=floor(p/sc)*sc; }\n    if (getR(p0).x>.75) { sc*=.5; p0=floor(p/sc)*sc; }\n    g_r=getR(p0);\n    g_p0=p0;\n    vec3 s=sign(getR(p0)*2.-1.);\n    return distCell01(((p-p0)/sc-.5)*s+.5,2.*2.*2.*sc)*sc-g_radius;\n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\n// HSV <-> RGB from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 neonCol(vec3 p)\n{\n    float sc=3.;\n    vec4 c=texelFetch(iChannel1,(ivec2(p.xy*sc)+ivec2(17,13)*int(p.z*sc))%256,0);\n    c=g_r.xyzx;\n    float onoff=1.;\n    #ifdef FLICKER\n    onoff=(c.x<.5 && c.w<.5 && abs(c.w-getRand(iFrame/7).x)<.1?0.:1.);\n    float s=sin(iTime*.2-length(g_p0.x*.3));\n    onoff=min(onoff,1.-clamp(exp(-s*s/.1/.1)*10.,0.,1.3+.4*getRand(iFrame/2).x));\n    onoff=mix(1.-onoff,onoff,step(.7,fract(iTime/27.)));\n    onoff=max(onoff,0.);\n    #endif\n    vec3 col=vec3(1);\n    #ifdef COLOR\n    col=hsv2rgb(vec3(c.y*1.5,.3,1));\n    #endif\n    return col*onoff;\n}\n\nvec3 g_glow;\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    g_glow=vec3(0);\n    float eps=.001;\n    int i2=0;\n    float dall=0.;\n    for(int i=0;i<150;i++)\n    {\n        float d=dist(pos);\n        dall+=d;\n        pos+=dir*d*.7;\n        g_glow+=neonCol(pos)*.02*exp(-d/.07)*exp(-dall/3.);\n        if (d<eps*max(dall/2.,1.)) { i2=i; return 1.; }\n    }\n    return 0.;\n}\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(sc,-.75));\n    pos=vec3(0,0,.0125);\n    #ifdef SHADEROO\n    pos*=exp(-iMouseData.z/3000.);\n    #endif\n    float ph = iMouse.x/Res.x*10.;\n    float th = iMouse.y/Res.y*10.;\n    ph+=iTime*.2;\n    th+=iTime*.1;\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n    pos+=vec3(.0)+vec3(1,.3,.2)*iTime*.1;\n}\n\nvoid camPhys(inout vec3 cpos, inout vec3 cdir, inout vec3 cup, inout vec3 cpos_old)\n{\n    vec3 cdir0=cdir;\n    float eps=.001;\n    vec3 g =getGrad(cpos,eps);\n    vec3 dg=getGrad(cpos+cdir*eps,eps)-g;\n    for(int i=0;i<10;i++){\n        vec3 ddir=(getRand(iFrame+i*13).xyz-.5)*.01;\n        vec3 dg2=getGrad(cpos+normalize(cdir+ddir)*eps,eps)-g;\n        if(length(dg2)<length(dg)) { cdir=normalize(cdir+ddir); dg=dg2; }\n    }\n    cpos+=cdir*.002;\n    vec3 up=normalize(getGrad(cpos,eps));\n    cpos-=dist(cpos)*up*.7;\n    cdir=normalize(cross(up,cross(cdir,up)));\n    cup=up;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos,dir;\n#ifdef SIM_CAM\n    vec3 cpos,cpos_old,cdir,cup;\n    cpos     = texelFetch(iChannel0,ivec2(0,0),0).xyz;\n    cdir     = texelFetch(iChannel0,ivec2(1,0),0).xyz;\n    cpos_old = texelFetch(iChannel0,ivec2(2,0),0).xyz;\n    camPhys(cpos,cdir,cup,cpos_old);\n    vec2 sc=(fragCoord-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(sc.xy,-.75));\n    float ph = (iMouse.x<1.)?0.:(iMouse.xy-Res*.5).x/Res.x*10.;\n    float th = (iMouse.x<1.)?-.3:(iMouse.xy-Res*.5).y/Res.y*10.;\n    dir.yz=ROTM(th)*dir.yz;\n    dir.xz=ROTM(ph)*dir.xz;\n    dir=-dir.z*cdir+cup*dir.y+cross(cdir,cup)*dir.x;\n    vec3 shake=.005*vec3(sin(iTime*1.5),sin(iTime*1.),0)+(getRand(iTime*10.).xyz-.5)*.00;\n    pos=cpos+cup*(.01+shake.z)+cross(cup,dir)*shake.x+cup*shake.y;\n#else\n    getTrafo(pos,dir,fragCoord);\n#endif\n    vec3 pos0=pos;\n    g_radius=.002;\n    float hit=march(pos,dir);\n    vec3 neonColo=neonCol(pos)-.2;\n    vec3 posi=pos; g_radius=.001;\n    vec3 glow=g_glow;\n    g_radius*=.5;\n    float hiti=march(posi,dir);\n    vec3 neonColi=neonCol(posi)+.2;\n    float d=dist(pos);\n    vec3 col=g_r;\n    vec3 n=normalize(getGrad(pos,.001));\n    vec3 ni=normalize(getGrad(posi,.001));\n    fragColor.xyz=(n*.5+.5)*1.3;\n    vec3 eye=normalize(pos0-pos);\n    float x=1.-dot(n,eye);\n    fragColor.xyz=vec3(1);\n    vec3 c1=mix(vec3(0),vec3(dot(n,-dir)*.1+1.),exp(-length((pos-pos0)/3.)));\n    vec3 c2=mix(vec3(0),vec3(-dot(ni,-dir)*.0+1.),exp(-length((posi-pos0)/5.)));\n    fragColor.xyz=vec3(0)+exp(-length((pos-posi)-dot(pos-posi,dir)*dir)/.15);\n    fragColor.xyz=vec3(0)+length((pos-posi)-dot(pos-posi,dir)*dir)*200000.;\n    \n    fragColor.xyz=hit*(1.-neonColo)*.45*(dot(n,-dir)*.5+.5)*exp(-length(pos-pos0)/3.);\n    fragColor.xyz=fragColor.xyz+.3*max(c1*c1*c1*c1*.8*neonColo,c2*c2*c2*c2*1.1*neonColi)*vec3(1.05,1,.95);\n    fragColor.xyz+=.7*c1*c1*c1*c1*1.3*neonColo*vec3(1.05,1,.95);\n    fragColor.xyz+=vec3(.9,1,1.2)*(sqrt(glow)*.15+glow*.3)*1.35;\n    fragColor.xyz=pow(fragColor.xyz,vec3(2));\n    fragColor.w=1.;\n#ifdef SIM_CAM\n    if (iTime<=1.) { cpos=vec3(-2.3); cdir=normalize(vec3(1,1,1)); }\n    cdir+=.01;\n    if (ivec2(fragCoord)==ivec2(0,0)) fragColor.xyz=cpos;\n    if (ivec2(fragCoord)==ivec2(1,0)) fragColor.xyz=cdir;\n    if (ivec2(fragCoord)==ivec2(2,0)) fragColor.xyz=cpos_old;\n#endif\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}