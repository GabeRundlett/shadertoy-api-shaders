{
    "Shader": {
        "info": {
            "date": "1598826265",
            "description": "Source : https://www.youtube.com/watch?v=KGJUl8Teipk\ny Game :  https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect",
            "flags": 0,
            "hasliked": 0,
            "id": "tlSBRD",
            "likes": 12,
            "name": "25. The Universe 2",
            "published": 3,
            "tags": [
                "theuniverse"
            ],
            "usePreview": 0,
            "username": "altera0",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "#define S(a, b, t) smoothstep( a, b, t )  \n\nfloat DistLine( vec2 p , vec2 a , vec2 b ) {\n\n    // Line ba에 Pa를 직교 투영한다.\n    \n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float t = clamp( dot( pa , ba ) / dot ( ba , ba ) , 0.0 , 1.0 );\n    \n    return length( pa - ba * t );\n        \n}\n\nfloat N21( vec2 p ) {\n\n    p = fract( p * vec2( 233.34 , 851.73));\n    p += dot( p, p+23.45);\n    return fract(p.x * p.y );\n}\n\nvec2 N22( vec2 p ) {\n\tfloat n = N21( p );\n    return vec2( n , N21( p + n ) );\n}\n\n\n\nvec2 GetPos( vec2 id , vec2 offset ) {\t// from id\n    \n    //vec2 n = N22( id + offset ) * iTime ;\n    vec2 n = N22( id + offset ) * iTime ;\n    \n    //float x = sin ( iTime * n.x );\n    //float y = cos ( iTime * n.y );\n    \n    return offset + sin( vec2(n) ) * 0.4;\t\t// 0.4, it is Important that balls is in grid cell.\n    \n}\n\nfloat Line( vec2 p , vec2 a , vec2 b ) {\n\tfloat d = DistLine( p , a, b );\t\t\t// distance (a - b ) from p.\n   \tfloat m = S( 0.03, 0.01 , d );\n    \n    // 이게 오묘한 식이다, p와의 거리가 아니라, ( a - b )의 거리를 말한다.\n    float d2 = length( a - b );\n    m *= S( 1.2, 0.8 , d2 ) * 0.5 + S( 0.05, 0.03, abs( d2 -0.75 ) );\n    \n    return m;\n}\n\n\nfloat  Layer( vec2 uv ) {\n\tfloat m = 0.0;\n    vec2 gv = fract(uv) - 0.5f;\t// center point to ( 0 , 0 ) local uv\n    vec2 id = floor(uv);\n    \n    \n    //vec2 p = N22( id ) - 0.5;\t// Random point based on each grid center.\n    \n    //vec2 p = GetPos( id );\n    //float d = length( p - gv );\n    \n\t\n    int i = 0;\t\t// index\n    vec2 p[9];\t\t// 9 cell\n    \n    for (float y = -1.0 ; y <= 1.0 ; y++ ) {\n        for ( float x = -1.0 ; x <= 1.0 ; x++ ) {\n        \tp[i++] = GetPos( id , vec2( x , y ));\n        }\n    }\n    \n    \n    float t = iTime * 10.0;\n    for ( int i = 0 ; i < 9 ; i++ ) {\n    \tm += Line( gv, p[4] , p[i] );\t// p[4] is mine\n        \n        vec2 j = ( p[i] - gv ) * 20.0;\n        float sparkle = 1.0 / dot(j,j);\n        \n        \n        \n        m += sparkle * ( sin(t + fract(p[i].x ) * 10.0 ) * 0.5 + 0.5 ) ;\n    }\n    \n    m += Line( gv, p[1] , p[3] );\t// p[4] is mine\n    m += Line( gv, p[1] , p[5] );\t// p[4] is mine\n    m += Line( gv, p[7] , p[3] );\t// p[4] is mine\n    m += Line( gv, p[7] , p[5] );\t// p[4] is mine\n    \n\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n    \n    //float d = DistLine( uv , vec2(0) , vec2(1) );\n    //float m = S( 0.1, 0.05 , d );\n    \n    //m = N22( uv ).x;\n\n    float m = 0.0;\n    float t = iTime * 0.1;\n\n\t// rotation\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2( c , -s , s , c );\n    uv *= rot;\n    \n    mouse *= 5.0;\n    mouse *= rot;\n    \n    for ( float i = 0.0 ; i <= 1.0 ; i += 1.0/4.0) {\n        float z = fract(i + t );\n        float size = mix( 10.0 , 0.5 , z );\n        \n        float fadeIn = S( 0.0 , 0.5 , z );\n        float fadeOut = S( 1.0 , 0.8 , z );\n        float fade = fadeIn * fadeOut;\t\t\t// 이것도 오묘한 식이다. fade In과 Fade Out을 어떻게 적용하는지 잘 볼 것.\n        \n    \tm += Layer( uv * size +i * 20.0 - mouse ) * fade;\n    }\n    \n    \n\tvec3 baseColor = sin( t * 5.0 * vec3( 0.345, 0.456 , 0.657) ) * 0.4 + 0.6 ; // Important technic.\n    vec3 col = m * baseColor;\n    \n    //col.rg = gv;\n    //if ( gv.x > 0.49 || gv.y > 0.49) col = vec3(1.0 , 0.0 , 0.0 );\n    fragColor = vec4(col,1.0);\n}\n\n// 1. 라인과 점과의 거리 구하기\n// 2. Noise 함수의 정의\n//\t\t* N21( vec2 p ) : Sin() 대신에 Dot() 사용하는 노이즈\n// 3. 그리드 만들기 (  id , localuv )\n// 4. 그리드 안에서 랜덤 포인트 만들기\n//\t\t* local uv 와 Random Point를 조합하여 만든다.\n//\t\t* \n// 5. 랜덤 포인트 애니메이팅 시키기.\n//\t\t* GetPos( p )\n//\t\t* 이동 시키기 위해서는 sin() cos()을 이용한다.\n// 6. 움직이는 포인트들 사이에 선 그리기\n// \t\t* for문을 돌면서 인접한 9개의 셀에 있는 포인트와 각각 비교한다.\n// 7. 라인을 그린후 9개의 셀에서 서로 연결되지 않는 대각선 셀까리의 계산을 해준다.\n//\t\t* 1번 => 3,5번, 7번 => 3,5번 셀을 직접 연결해준다.\n\n// 8. 라인의 길이에 따라서 페이드 해준다. ( 가장 가까운 것만 연결된 것처럼 보이게 )\n//\t\tm *= S( 1.2, 0.8 , length( a - b ) );\n\n// 9. 스파클 시키기\n\n// 문제 : 잘보면 중간에 The 옆에 움직이지 않고 고정된 하나의 점이 있다.\n\n\n\n/// --------------------- 여기까지가 1부 -------- //////////////\n\n\n\n// 10. 라인 플레쉬 시키기\n//\t\t* m 값에 대한 조절\n//     // 이게 오묘한 식이다, p와의 거리가 아니라, ( a - b )의 거리를 말한다.\n//\t    float d2 = length( a - b );\n//\t    m *= S( 1.2, 0.8 , d2 ) * 0.5 + S( 0.05, 0.03, abs( d2 -0.75 ) );\n\n// 11. 레이어 만들기\n//\t\tfloat m = Layer( uv * 5 )\n\n// 12. Fade 적용하기\n//\t\t* fade = fadeIn * fadeOut;\n\n// 13. Twist 적용하기\n//\t\t* UV 를 로테이션 시킨다.\n//\t\t* mat2 행렬식의 사용법 보기.\n\n// 14. 마우스에 의한 UV 무브 정의해주기\n//\t\t* 마우스도 로테이션 시켜주어야 한다.\n\n\n// 15. 컬러 넣기\n//\tvec3 baseColor = sin( t * 5.0 * vec3( 0.345, 0.456 , 0.657) ) * 0.4 + 0.6 ;\n//    vec3 col = m * baseColor;\n//\t* 여기에서 0.4를 곱하고 0.6을 더해서, 최소 0.2 ~ 1.0 이상의 값이 되도록 만들어 준 수식을 유의 할 것.\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}