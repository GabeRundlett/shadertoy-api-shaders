{
    "Shader": {
        "info": {
            "date": "1540738672",
            "description": "Importance sampled romanesco broccoli with depth of field and global illumination. The shape is a sphere deformed into a rounded cone, then repeated around it with inverse spherical Fibonacci mapping. Click the screen to reset the rendering.",
            "flags": 32,
            "hasliked": 0,
            "id": "XlcfRs",
            "likes": 101,
            "name": "Romanesco Broccoli",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "raymarch",
                "dof",
                "nature"
            ],
            "usePreview": 1,
            "username": "Klems",
            "viewed": 4948
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    // number of samples is stored in the alpha channel\n    fragColor.rgb /= max(1.0, fragColor.a);\n    // exposition\n    fragColor.rgb *= 0.05;\n    // clamp\n    fragColor.rgb = min(fragColor.rgb, vec3(1));\n    // gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n\t// vigneting\n    vec2 p = uv * 2.0 - 1.0;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(p, p)*0.2);\n    \n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n#define PHI 1.61803398875\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n#define Z min(0, iFrame)\n\n// fab's polar mod\nvec2 polarRep( in vec2 p, in float n ) {\n    n = PI*0.5/n;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    a = mod(a + n/2.0, n) - n/2.0;\n    p = r * vec2(cos(a), sin(a));\n    return 0.5 * (p+p-vec2(1,0));\n}\n\n// iq's integer hash https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x ) {\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// iq's box distance function\nfloat sdBox( in vec2 p, in vec2 b ) {\n\tvec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// iq's smooth minimum\nfloat smin( in float a, in float b, const in float s ) {\n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0.0, 1.0 );\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// iq's version of Keinert et al's inverse Spherical Fibonacci Mapping code\n// https://www.shadertoy.com/view/lllXz4\nvec3 inverseSF( in vec3 p, const in float n ) {\n    float m = 1.0-1.0/n;\n    float phi = min(atan(p.y,p.x),PI);\n    float k = max(2.,floor(log(n*PI*sqrt(5.)*(1.-p.z*p.z))/log(PHI+1.)));\n    float Fk = pow(PHI,k)/sqrt(5.0);\n    vec2 F = vec2(round(Fk),round(Fk*PHI));\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    mat2 iB = mat2(ka.y,-ka.x,kb.y,-kb.x)/(ka.y*kb.x-ka.x*kb.y);\n    vec2 c = floor(iB*vec2(phi,p.z-m));\n    float d = 8.0;\n    vec3 res = vec3(0);\n    for(int s = Z ; s < 4 ; s++) {\n        vec2 uv = vec2(float(s-2*(s/2)),float(s/2));\n        float i = dot(F,uv+c);\n        float phi = 2.0*PI*fract(i*PHI);\n        float cT = m-2.0*i/n;\n        float sT = sqrt(1.0-cT*cT);\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\n        float sqDist = dot(q-p,q-p);\n        if (sqDist < d) {\n            d = sqDist;\n            res = q;\n        }\n    }\n    return res;\n}\n\n// parameters of the rounded cone\n#define CONE_THETA 0.7\n#define CONE_RADIUS 0.3\n\n// sub-parameters defined from above\n#define CONE_LBOT (PI*0.5+CONE_THETA)\n#define CONE_LFLAT ((tan(PI*0.5-CONE_THETA))*(1.0-CONE_RADIUS))\n#define CONE_LTOP ((PI*0.5-CONE_THETA)*CONE_RADIUS)\n#define CONE_L (CONE_LBOT+CONE_LFLAT+CONE_LTOP)\n#define CONE_SLOPE vec2(cos(CONE_THETA), sin(CONE_THETA))\n#define CONE_CSLOPE (CONE_SLOPE.yx*vec2(-1, 1))\n#define CONE_HEIGHT length(vec2(1.0-CONE_RADIUS, CONE_LFLAT))\n\n// remap a 2D rounded cone to a circle\nvec2 remap( in vec2 p ) {\n    // flip coordinates so they're easier to work with\n    // we'll flip them back before returning it\n    float sig = p.x > 0.0 ? +1.0: -1.0;\n    p.x = abs(p.x);\n    // go to polar coordinates\n    float theta = 0.0;\n    float radius = 0.0;\n    // do the bottom part\n    float botPos = atan(p.x, -p.y) / (PI*0.5+CONE_THETA);\n    if (botPos < 1.0) {\n        theta = (botPos * CONE_LBOT) / CONE_L;\n        radius = length(p);\n    } else {\n        // do the flat part\n        float pos = dot(p, CONE_CSLOPE);\n        float flatPos = pos / CONE_LFLAT;\n        if (flatPos < 1.0) {\n            theta = (CONE_LBOT + flatPos*CONE_LFLAT) / CONE_L;\n            radius = dot(p, CONE_SLOPE);\n        } else {\n            // do the top part\n            p.y -= CONE_HEIGHT;\n            float topPos = (atan(p.y, p.x) - CONE_THETA) / (PI*0.5-CONE_THETA);\n            theta = (CONE_LBOT + CONE_LFLAT + topPos*CONE_LTOP) / CONE_L;\n            radius = length(p) + (1.0 - CONE_RADIUS);\n        }\n    }\n    // squeeze the angle toward the top of the broccoli\n    theta *= theta;\n    // go back to cartesian, flip the sign and return\n    theta = theta * sig * PI;\n    return vec2(sin(theta), -cos(theta))*radius;\n}\n\n// deform a 3D sphere to match a cone\nvec3 deform( in vec3 p ) {\n    // go to cylindrical coordinates\n    vec2 dir = p.xy;\n    float dirLen = length(dir);\n    vec2 cyl = vec2(dirLen, -p.z);\n    // remap a circle here to a rounded cone\n    cyl = remap(cyl);\n    // then go back to 3D coordinates\n    return vec3(dir/dirLen*cyl.x, cyl.y);\n}\n\n// remap a sphere to a plane\nvec3 deformLeaf( in vec3 p ) {\n    vec2 dir = p.xy;\n    float len = length(dir);\n    float theta = atan(len, p.z);\n    return vec3(dir/len*theta, length(p)-1.0);\n}\n\n// leaf distance function\nfloat leaf( in vec3 p, out float c, const in bool doColor ) {\n    p.z += 0.3;\n    float noise = smoothstep(-1.0, 1.0, p.x);\n    // deform the leaf around a sphere\n    p = deformLeaf(p);\n    // repeat the leaf 5 times\n    p.xy = polarRep(p.xy, 1.25);\n    // add a stem\n    vec2 stemDim = vec2(0.85+noise*0.4, 0.0);\n    float stem = sdBox( vec2(p.x, length(p.yz)), stemDim ) - 0.01;\n    // twist the leaf a bit\n    p.z += (1.0-cos(p.y*6.0))*0.06;\n    // change its shape\n    vec2 dim = vec2(0.6+noise*0.5, 0.1);\n    dim.y += sin(p.x*14.0)*0.05;\n    dim.y += cos(p.x*61.0)*0.02;\n\t// add the leaf\n    float d = sdBox(p.xy, dim)-0.2;\n    // flatten it\n    d = max(d, abs(p.z)-0.001);\n    // then smooth the stem in\n    d = smin(d, stem, 0.05);\n    // add veins when coloring\n    if (doColor) {\n        c = smoothstep(0.05, -0.02, stem);\n        float tex = 1.0-textureLod(iChannel2, p.xy*vec2(1.4, 0.7), 0.0).r;\n        tex *= tex; tex *= tex;\n        c = min(c+tex, 1.0);\n    }\n    return d;\n}\n\n// parameters of the fractal formula\n#define FRACTAL_LEVELS 2\n#define FIBO_COUNT 100.0\n\n// main distance function\nfloat de( in vec3 p, out vec3 color, const in bool doColor ) {\n\t\n    p.z = -p.z;\n    vec3 pp = p;\n    p = deform(p);\n    float c = 1.0;\n    float de = length(p)-1.0;\n    float s = 1.0;\n    \n    for (int i = Z ; i < FRACTAL_LEVELS ; i++) {\n        float f = smoothstep(-1.0, 1.5, p.z);\n        vec3 onSurf = inverseSF(normalize(p), FIBO_COUNT);\n        p -= onSurf;\n        \n        // re-orient p to aim toward the normal\n        vec3 t = normalize(cross(onSurf, vec3(0, 0, 1)));\n        vec3 ct = cross(onSurf, t);\n        p = vec3(dot(p, t), dot(p, ct), -dot(p, onSurf));\n        \n        // change scale with height\n        float scale = mix(3.0, 7.0, f);\n        p *= scale;\n        p.xy *= mix(1.5, 1.0, f);\n        p = deform(p);\n        \n        // accumulate distance\n        s *= scale;\n        float deNew = (length(p)-1.0)/s;\n        \n        // add some fake ass AO\n        if (doColor) {\n            c *= mix(c, 0.5, smoothstep(0.1, 0.0, de-deNew));\n        }\n        \n        // then accumulate distance and continue to next level\n        de = smin(de, deNew, 0.1);\n    }\n    \n    // add the leaf\n    float cLeaf = 0.0;\n    float deLeaf = leaf(pp*0.5, cLeaf, doColor)/0.5;\n    if (de > deLeaf) {\n        de = deLeaf;\n        c = cLeaf;\n    }\n    \n    // set color\n    if (doColor) {\n        color = mix(vec3(0.2, 0.4, 0.05), vec3(0.7, 0.8, 0.2), c);\n    }\n    \n    // add the floor\n    float deFloor = 1.4-pp.z;\n    if (de > deFloor) {\n        de = deFloor;\n        if (doColor) {\n            color = textureLod(iChannel1, pp.xy*0.1, 0.0).rgb;\n            color *= color;\n        }\n    }\n    \n    return de;\n}\n\n// don't return color while raymarching or retrieving the normal\nfloat de( in vec3 p ) {\n    vec3 dummy = vec3(0);\n    return de(p, dummy, false);\n}\n\n// normal function, call de() in a for loop for faster compile times.\nvec3 getNormal( in vec3 p ) {\n    vec4 n = vec4(0);\n    for (int i = Z ; i < 4 ; i++) {\n        vec4 s = vec4(p, 0);\n        s[i] += 0.0001;\n        n[i] = de(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n}\n\n// trace function, return true if we hit the sky\nbool trace(in vec3 from, in vec3 dir, const in bool doNormal,\n           out vec3 pos, out vec3 norm, out vec3 diff ) {\n    \n    float totdist = 0.0;\n    bool set = false;\n\tfor (int steps = Z ; steps < 200 ; steps++) {\n\t\tvec3 p = from + totdist * dir;\n        float dist = de(p)*0.5;\n\t\ttotdist += dist;\n\t\tif (dist < 0.0001) {\n            set = true;\n            break;\n\t\t}\n\t}\n    \n    // we've hit the sky\n    if (!set) return true;\n    \n    // we've hit a surface\n    pos = from + totdist * dir;\n    if (doNormal) norm = getNormal(pos);\n    de(pos, diff, true);\n    return false;\n}\n\n// background color\n#define colorSun vec4(1.0, 1.0, 0.8, 100000.0)\n#define colorAmbient vec4(0.6, 0.7, 0.9, 1.0)\n#define sunDir normalize(vec3(-3, 2, -3))\n#define sunAngle 0.01\n#define sunCosAngle cos(sunAngle)\nvec3 getBackground( in vec3 dir ) {\n    float d = dot(dir, -sunDir);\n    vec3 base = colorAmbient.rgb;\n    base.rgb = mix(base.rgb, colorSun.rgb, smoothstep(0.5, 1.0, d)*0.5);\n    base = mix(base, colorSun.rgb, smoothstep(sunCosAngle,\n                                              sunCosAngle+0.001, d));\n    base = mix(base, vec3(0), step(dir.z, 0.0));\n    return base.rgb;\n}\n\n// trace to a random light source\nvec3 traceLight( in vec3 from, in vec3 norm, in uvec3 seed ) {\n    vec3 pos = vec3(0);\n    vec3 diff = vec3(0);\n    vec3 dummyNorm = vec3(0);\n    \n    // create a random dir in a hemisphere\n    vec3 rand = hash(seed);\n    float dirTemp1 = 2.0*PI*rand.x;\n    float dirTemp2 = sqrt(1.0-rand.y*rand.y);\n    vec3 dir = vec3(\n        cos(dirTemp1)*dirTemp2,\n        sin(dirTemp1)*dirTemp2,\n        rand.y);\n    dir.z = abs(dir.z);\n    \n    // pick the sun more often (importance sampling)\n    const float sunContrib = colorSun.a*2.0*PI*(1.0 - sunCosAngle);\n    const float ambientContrib = colorAmbient.a*2.0*PI;\n    const float sumContrib = sunContrib+ambientContrib;\n    \n    float a = sunContrib / sumContrib;\n    float b = a + ambientContrib / sumContrib;\n    \n    if (rand.z < a) {\n        const vec3 sunDirTan = normalize(cross(sunDir, vec3(0, 0, 1)));\n        const vec3 sunDirCoTan = cross(sunDir, sunDirTan);\n        float rot = 2.0*PI*rand.x;\n        float the = acos(1.0 - rand.y*(1.0 - cos(sunAngle)));\n        float sinThe = sin(the);\n        dir = sunDirTan*sinThe*cos(rot) +\n            sunDirCoTan*sinThe*sin(rot) - sunDir*cos(the);\n    }\n    \n    if (trace(from, dir, false, pos, dummyNorm, diff)) {\n        vec3 back = getBackground(dir);\n        float l = max(0.0, dot(dir, norm));\n        return back*l*sumContrib;\n    } else {\n        return vec3(0);\n    }\n}\n\n// util function to get a different seed\nuvec3 getSeed( in uvec3 seed, const in int i ) {\n    seed.z = seed.z * 10U + uint(i);\n    return seed;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // initialize color from the previous frame\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    // reinitialize rendering when needed\n    bool loaded = iChannelResolution[1].x > 0.0 && iChannelResolution[2].x > 0.0;\n    if (iFrame == 0 || !loaded || iMouse.z > 0.0) fragColor = vec4(0);\n    \n    // decouple rendering, it can get a bit unresponsive\n  \tvec2 gridSize = vec2(128, 128); // increase these for good GPUs\n    vec2 gridCount = floor(iResolution.xy / gridSize) + 1.0;\n    vec2 inGrid = floor(fragCoord.xy / gridSize);\n    float gridPos = inGrid.x + inGrid.y * gridCount.x;\n    float gridPosMax = gridCount.x*gridCount.y;\n    if ( mod(float(iFrame), gridPosMax) != gridPos ) return;\n\n    // random stuff\n    uvec3 seed = uvec3(fragCoord, iFrame);\n    \n    // apply depth of field by changing the forward vector randomly\n    const float dof = 0.02;\n    const vec3 up = normalize(vec3(0, 0.3, 1));\n    const vec3 forwardVector = normalize(vec3(4, 2, -2));\n    const vec3 forwardTan = normalize(cross(forwardVector, up));\n    const vec3 forwardCoTan = cross(forwardVector, forwardTan);\n    vec3 rand1 = hash(getSeed(seed, 0));\n    float dofRot = 2.0*PI*rand1.x;\n    float dofThe = acos(1.0 - rand1.y*(1.0 - cos(dof)));\n    vec3 forward = forwardTan*sin(dofThe)*cos(dofRot) +\n        forwardCoTan*sin(dofThe)*sin(dofRot) + forwardVector*cos(dofThe);\n    \n    // get camera\n    vec3 right = normalize(cross(forward, up));\n    vec3 top = cross(right, forward);\n    vec3 focus = vec3(-0.55, -0.6, 1.07);\n    // do antialiasing\n    vec3 alias = hash(getSeed(seed, 1));\n    vec2 pixelCoord = fragCoord + alias.xy - 0.5;\n    vec2 uv = (pixelCoord - iResolution.xy*0.5) / iResolution.y;\n    vec3 dir = normalize(forward*3.5 + right*uv.x + top*uv.y);\n    vec3 from = focus - forward*7.0;\n\t\n    // find the first position\n    vec3 pos = vec3(0);\n    vec3 norm = vec3(0);\n    vec3 diff = vec3(0);\n    vec3 color = vec3(0);\n    trace(from, dir, true, pos, norm, diff);\n    \n    // add light from the sun/sky\n    pos += norm*0.001;\n    vec3 sunLight = traceLight(pos, norm, getSeed(seed, 2));\n\tcolor += diff.rgb * sunLight.rgb;\n\n    // do bounces (increase this loop if you have a good GPU)\n    vec3 acc = diff.rgb;\n    for (int i = Z ; i < 2 ; i++) {\n        vec3 normTan = normalize(cross(norm, vec3(1, PI, PHI)));\n        vec3 normCoTan = cross(norm, normTan);\n        vec3 rand = hash(getSeed(seed, 3+i*2));\n        float rot = 2.0*PI*rand.x;\n        float the = acos(sqrt(rand.y));\n        float sinThe = sin(the);\n        vec3 bounceDir = normTan*sinThe*cos(rot) +\n            normCoTan*sinThe*sin(rot) + norm*cos(the);\n        trace(pos, bounceDir, true, pos, norm, diff);\n        vec3 bounceLight = traceLight(pos + norm*0.001, norm,\n                                      getSeed(seed, 3+i*2+1));\n        acc *= diff.rgb; // color keep getting absorbed\n        color += acc * bounceLight;\n    }\n    \n    // accumulate samples\n    fragColor.rgb += color;\n    fragColor.a += 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}