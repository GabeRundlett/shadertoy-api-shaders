{
    "Shader": {
        "info": {
            "date": "1623133725",
            "description": "A very basic example of rasterized graphics drawing, with the addition of perspective correct texture mapping. It works on the same essential principles as OpenGL and all other graphics APIs (see comments).\n\nUse mouse to free rotate the pyramid.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftl3Ds",
            "likes": 15,
            "name": "Simple Rasterizer",
            "published": 3,
            "tags": [
                "rasterizer",
                "triangles",
                "raster",
                "geometry",
                "coordinates",
                "perspectivecorrect"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 812
        },
        "renderpass": [
            {
                "code": "#define VERTEX_COUNT 18\nconst vec3 vertices[VERTEX_COUNT] = vec3[VERTEX_COUNT] (\n    vec3(-0.5, 0.0, -0.5),\n    vec3( 0.5, 0.0, -0.5),\n    vec3(-0.5, 0.0,  0.5),\n    \n    vec3(-0.5, 0.0,  0.5),\n    vec3( 0.5, 0.0, -0.5),\n    vec3( 0.5, 0.0,  0.5),\n    \n    vec3(-0.5, 0.0, -0.5),\n    vec3( 0.5, 0.0, -0.5),\n    vec3( 0.0, 1.0,  0.0),\n    \n    vec3(-0.5, 0.0,  0.5),\n    vec3( 0.5, 0.0,  0.5),\n    vec3( 0.0, 1.0,  0.0),\n    \n    vec3(-0.5, 0.0, -0.5),\n    vec3(-0.5, 0.0,  0.5),\n    vec3( 0.0, 1.0,  0.0),\n    \n    vec3( 0.5, 0.0, -0.5),\n    vec3( 0.5, 0.0,  0.5),\n    vec3( 0.0, 1.0,  0.0)\n);\n\nconst vec2 texCoords[VERTEX_COUNT] = vec2[VERTEX_COUNT] (\n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(0., 0.),\n    \n    vec2(0., 0.),\n    vec2(1., 1.),\n    vec2(1., 0.),\n    \n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(.5, 0.),\n    \n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(.5, 0.),\n    \n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(.5, 0.),\n    \n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(.5, 0.)\n);\n\n//-------- shaders -------/\n\nvec4 vertexShader(in vec3 vertex, in mat4 transform) {\n    // converts position into NDC\n    return transform * vec4(vertex, 1.);\n}\n\nvec4 fragmentShader(in vec2 uv) {\n    return texture(iChannel0, uv);\n}\n\n//-------- rasterizing -------//\n\nconst float fov  = 70.0;\nconst float near = 0.1;\nconst float far  = 10.;\n\nconst vec3 cameraPos = vec3(0., 0.3, 2.);\n\nvec4 pixel(in vec2 ndc, in float aspect, inout float depth, in int vertexIndex) {\n\n    float rotX = -25.;\n    float rotY = 45. + iTime * 20.;\n    \n    if(iMouse.xy != vec2(0.)) {\n        rotX = -100. + (iMouse.y * 150. / iResolution.y);\n        rotY = iMouse.x * 360. / iResolution.x;\n    }\n    \n\n    // step 0: calculate projection matrix\n    mat4 proj  = perspective(fov, aspect, near, far);\n    mat4 view  = translate(-cameraPos);\n    mat4 model = rotateX(rotX) * rotateY(rotY);\n    \n    mat4 mvp  = proj * view * model;\n\n    // step 1: run vertex shader and get ndc of each vertex\n    vec4 v0 = vertexShader(vertices[vertexIndex  ], mvp);\n    vec4 v1 = vertexShader(vertices[vertexIndex+1], mvp);\n    vec4 v2 = vertexShader(vertices[vertexIndex+2], mvp);\n    \n    // divide tex coords by w for perspective correctness\n    vec2 t0 = texCoords[vertexIndex  ] / v0.w; float oow0 = 1. / v0.w;\n    vec2 t1 = texCoords[vertexIndex+1] / v1.w; float oow1 = 1. / v1.w;\n    vec2 t2 = texCoords[vertexIndex+2] / v2.w; float oow2 = 1. / v2.w;\n    \n    // step 2: do perspective division and calculate barycentric coordinates\n    //         (and determine if we're even on the triangle)\n    v0 /= v0.w;\n    v1 /= v1.w;\n    v2 /= v2.w;\n    \n    vec3 tri = bary(v0.xy, v1.xy, v2.xy, ndc);\n    \n    // if any of the coordinates aren't within [0,1], we're outside the triangle\n    if(tri.x < 0. || tri.x > 1. || tri.y < 0. || tri.y > 1. || tri.z < 0. || tri.z > 1.) {\n        return vec4(0.);\n    }\n    \n    // step 3: perform depth testing and cull pixels outside the camera's Z range\n    float triDepth = baryLerp(v0.z, v1.z, v2.z, tri);\n    if(triDepth > depth || triDepth < -1. || triDepth > 1.) {\n        return vec4(0.);\n    }\n    \n    depth = triDepth; // write to depth buffer\n    \n    // step 3: run fragment shader to get pixel colour (and correct UVs)\n    float oneOverW = baryLerp(oow0, oow1, oow2, tri);\n    vec2 uv        = uvLerp(t0, t1, t2, tri) / oneOverW;\n    return fragmentShader(uv);\n\n}\n\n//-------- main ---------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = ((fragCoord.xy * 2.) / iResolution.xy) - vec2(1.);\n    float aspect = iResolution.x / iResolution.y;\n    vec3 outColor = vec3(.4,.6,.9);\n    \n    float depth = 1.0;\n    for(int i = 0; i < VERTEX_COUNT; i += 3) {\n        vec4 tri = pixel(ndc, aspect, depth, i);\n        outColor = mix(outColor.rgb, tri.rgb, tri.a);\n    }\n    \n    fragColor = vec4(outColor, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Source: http://gamedev.stackexchange.com/questions/23743/whats-the-most-efficient-way-to-find-barycentric-coordinates\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) {\n    vec2 v0 = b-a, v1 = c-a, v2 = p-a;\n    float d00 = dot(v0,v0);\n    float d01 = dot(v0,v1);\n    float d11 = dot(v1,v1);\n    float d20 = dot(v2,v0);\n    float d21 = dot(v2,v1);\n    float d = 1./(d00*d11-d01*d01);\n    float v = (d11*d20-d01*d21)*d;\n    float w = (d00*d21-d01*d20)*d;\n    float u = 1.-v-w;\n    return vec3(u,v,w);\n}\n\n//------------- interpolation ----------------//\n\nfloat baryLerp(float a, float b, float c, vec3 x) {\n    return a * x.x + b * x.y + c * x.z;\n}\n\nvec2 uvLerp(vec2 a, vec2 b, vec2 c, vec3 x) {\n    return a * x.x + b * x.y + c * x.z;\n}\n\n//------------- transformations --------------//\n\nmat4 perspective(float fovy, float aspect, float near, float far) {\n    float thf = 1./tan(radians(fovy)*.5);\n    float rng = far-near;\n    mat4 m = mat4(1.);\n    m[0][0] = thf/aspect;\n    m[1][1] = thf;\n    m[2][2] = -((far+near)/rng);\n    m[2][3] = -1.;\n    m[3][2] = -((2.*far*near)/rng);\n    m[3][3] = 0.;\n    return m;\n}\n\nmat4 translate(vec3 v) {\n    mat4 m = mat4(1.);\n    m[3][0] = v.x;\n    m[3][1] = v.y;\n    m[3][2] = v.z;\n    return m;\n}\n\nmat4 rotateX(float angle) {\n    float r = radians(angle), s = sin(r), c = cos(r);\n    mat4 m = mat4(1.);\n    float m10 = m[1][0], m20 = m[2][0];\n    float m11 = m[1][1], m21 = m[2][1];\n    float m12 = m[1][2], m22 = m[2][2];\n    float m13 = m[1][3], m23 = m[2][3];\n    m[1][0] = m10 * c - m20 * s;\n\tm[1][1] = m11 * c - m21 * s;\n\tm[1][2] = m12 * c - m22 * s;\n\tm[1][3] = m13 * c - m23 * s;\n\tm[2][0] = m10 * s + m20 * c;\n\tm[2][1] = m11 * s + m21 * c;\n\tm[2][2] = m12 * s + m22 * c;\n\tm[2][3] = m13 * s + m23 * c;\n    return m;\n}\n\nmat4 rotateY(float angle) {\n    float r = radians(angle), s = sin(r), c = cos(r);\n    mat4 m = mat4(1.);\n    float m00 = m[0][0], m20 = m[2][0];\n    float m01 = m[0][1], m21 = m[2][1];\n    float m02 = m[0][2], m22 = m[2][2];\n    float m03 = m[0][3], m23 = m[2][3];\n    m[0][0] = m00 * c - m20 * s;\n\tm[0][1] = m01 * c - m21 * s;\n\tm[0][2] = m02 * c - m22 * s;\n\tm[0][3] = m03 * c - m23 * s;\n\tm[2][0] = m00 * s + m20 * c;\n\tm[2][1] = m01 * s + m21 * c;\n\tm[2][2] = m02 * s + m22 * c;\n\tm[2][3] = m03 * s + m23 * c;\n    return m;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}