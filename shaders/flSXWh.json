{
    "Shader": {
        "info": {
            "date": "1627488941",
            "description": "my private stuff. I just wanted to do this from scratch.",
            "flags": 0,
            "hasliked": 0,
            "id": "flSXWh",
            "likes": 5,
            "name": "minimum implementation of d2d",
            "published": 3,
            "tags": [
                "distance2d"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 310
        },
        "renderpass": [
            {
                "code": "// The minimum implementation of the distance 2D utilities for private use.\n// I guess most of the stuff is similar implementation someone has done.\n// The following distance functions can not use the round shape technique and etc...\n#define USE_MOUSE 0\n#define S(p,d,b) smoothstep(fwidth(p.y),b,d)\n#define M() (iMouse.xy-0.5*iResolution.xy)/iResolution.y\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n\n#define SliceB(p,a,b,s) max(-dot(p-a,vec2(cos(b),sin(b))),max(abs(p).x-s,abs(p).y-s))\nfloat customTri(vec2 p, vec2 a, vec2 b, vec2 c){\n    float s = 1.0;\n    float d = max(SliceB(p,b,-atan(b.x-a.x,b.y-a.y),s),SliceB(p,b,-atan(c.x-b.x,c.y-b.y),s));\n    return max(SliceB(p,c,-atan(a.x-c.x,a.y-c.y),s),d);\n}\n\nfloat bevelCornerBox(vec2 p, vec2 s, float k, float deg){\n    float d = max(abs(p).x-s.x,abs(p).y-s.y);\n    float a = radians(deg);\n    p = abs(p);\n    p-=s/k;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    return d;\n}\n\n// taper box\nfloat taperBox(vec2 p, vec2 s, float l, float r){\n    float d = max(abs(p).x-s.x,abs(p).y-s.y);\n    float al = radians(-l);\n    float ar = radians(r);\n    d = max(-dot(p-vec2(-s.x*0.5,0.0),vec2(cos(al),sin(al))),d);\n    d = max(dot(p-vec2(s.x*0.5,0.0),vec2(cos(ar),sin(ar))),d);\n    return d;\n}\n\n// I won't recommend using the following distance 2d line. This implementation is straight foward. Please use the Iq's sdLine is the best one.\n// This one is for me to use. I just wanted to create a distance line by myself.\nfloat dLine(vec2 p, vec2 a, vec2 b, float w){\n    vec2 v = normalize(b-a);\n    vec2 right = normalize(cross(vec3(v,0.0),vec3(0.0,0.0,1.0)).xy);\n    vec2 newRightVec = right*(w*0.5);\n    vec2 a1 = a+newRightVec, a2 = a-newRightVec, b1 = b+newRightVec, b2 = b-newRightVec;\n    vec2 mida = vec2((a1.x + b1.x) * 0.5, (a1.y + b1.y) * 0.5);\n    vec2 midb = vec2((a2.x + b2.x) * 0.5, (a2.y + b2.y) * 0.5);\n    \n    float rad1 = -atan(b1.x-a1.x,b1.y-a1.y);\n    float rad2 = -atan(a2.x-a1.x,a2.y-a1.y);\n    \n    float mad = Slice(p-mida,rad1);\n    float mbd = Slice(p-midb,rad1);\n    \n    float ad = Slice(p-a,rad2);\n    float bd = Slice(p-b,rad2);\n    float d = max(max(mad,-mbd),max(-ad,bd));\n    return d;\n}\n\nfloat drawExample(vec2 p){\n    // i.e. draw circle\n    float d = length(p-vec2(-0.75,0.0))-0.1;\n    \n    // i.e. draw box\n    float d2 = B(p-vec2(-0.5,0.0),vec2(0.1));\n    d = min(d,d2);\n    d2 = B(p-vec2(-0.3,0.0),vec2(0.05,0.1));\n    d = min(d,d2);\n    \n    // i.e. draw triangle\n    d2 = Tri(p-vec2(-0.09,0.1),vec2(0.2),radians(30.0));\n    d = min(d,d2);\n    \n    d2 = customTri(p,vec2(0.15,0.1),vec2(0.3,0.0),vec2(0.08,-0.1));\n    d = min(d,d2);\n    \n    // i.e. draw bevel corner box\n    d2 = bevelCornerBox(p-vec2(0.45,0.0),vec2(0.1,0.1),1.3,45.0);\n    d = min(d,d2);\n    \n    // i.e. draw taper box\n    d2 = taperBox(p-vec2(0.72,0.0),vec2(0.2,0.1),-10.0,-10.0);\n    d = min(d,d2);\n    return d;\n}\n\nfloat demo(vec2 uv){\n    vec2 prevUV = uv;\n    float d = 100.0;\n    uv+=(uv/length(uv*1.6))*sin(length(uv*1.6)*5.0-iTime*2.0)*0.05+cos(length(uv*1.6)*5.0-iTime*2.0)*0.05; \n    uv.x+=sin(uv.y+iTime*0.3)*0.8*cos(uv.x+iTime*0.6)*0.7;\n    for(float i = 0.0; i<2.0; i+=0.05){\n        d = min(abs(length(uv)-i)-0.0001,d);\n    }\n    \n    uv.y = mod(uv.y,0.05)-0.025;\n    float d2 = dLine(uv,vec2(-2.0,0.0),vec2(2.0,0.0),0.001);\n    \n    float t = mod(iTime,20.0);\n    float morph = 0.0;\n    if(t>=7.0 && t<10.0){\n        float now = t-7.0;\n        morph = (now/3.0)*1.0; \n    } else if(t>=10.0 && t<17.0){\n        morph = 1.0;\n    } else if(t>=17.0 && t<20.0){\n        float now = t-17.0;\n        morph = 1.0-(now/3.0)*1.0;\n    }\n    \n    return mix(d,d2,morph);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec2 m = M();\n\n    // xy axis\n    float d = dLine(uv,vec2(0.0,0.5),vec2(0.0,-0.5),0.001);\n    d = min(d,dLine(uv,vec2(-1.0,0.0),vec2(1.0,0.0),0.001));\n    col = mix(col,vec3(0.6,0.0,0.0),S(uv,d,0.0));\n\n    // test demo\n    d = demo(uv);\n    col = mix(col,vec3(0.9),S(uv,d,0.0));\n    \n    // draw example shape\n    d = drawExample(uv-vec2(0.0,0.35));\n    col = mix(col,vec3(1.0),S(uv,d,0.0));\n    \n    // i.e. outline\n    d = drawExample(uv-vec2(0.0,-0.35));\n    col = mix(col,vec3(1.0),S(uv,abs(d)-0.001,0.0));\n    \n    #if USE_MOUSE\n    // i.e. draw line\n    vec2 a = vec2(0.0), b = m;\n    float w = 0.05+abs(sin(iTime)*0.1); // for test\n    d = dLine(uv,a,b,w);\n    col = mix(col,vec3(0.9),S(uv,d,0.0));\n    \n    // draw points\n    d = min(B(uv-a,vec2(0.01)),B(uv-b,vec2(0.01)));\n    col = mix(col,vec3(1.0,0.0,0.0),S(uv,d,0.0));    \n    #endif\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}