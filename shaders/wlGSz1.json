{
    "Shader": {
        "info": {
            "date": "1582176382",
            "description": "Experimenting with some concepts I'm learning",
            "flags": 0,
            "hasliked": 0,
            "id": "wlGSz1",
            "likes": 1,
            "name": "Imprisoned",
            "published": 3,
            "tags": [
                "raymarched"
            ],
            "usePreview": 0,
            "username": "haptix",
            "viewed": 248
        },
        "renderpass": [
            {
                "code": "float glow = 0.;  //GLOW baby\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nvec3 twist(vec3 pos)\n{\n    float c = sin(.1 * pos.x + iTime * cos(iTime*.001));\n    float s = cos(.1 * pos.x + iTime * cos(iTime*.001));\n    mat2  m = mat2(c, -s, s, c);\n    return vec3(m * pos.zy, pos.x);\n}\n\nfloat unionSDF(float distA, float distB)\n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB)\n{\n    return max(distA, -distB);\n}\n\nfloat hollowBox(vec3 pos, float radius)\n{\n    return differenceSDF(box(pos, vec3(radius)), sphere(pos, radius*1.3));\n}\n\nfloat distfunc(vec3 pos, float radius)\n{\n    float hollowB = hollowBox(twist(pos), radius);\n    float sphereB = sphere(pos, radius*0.8);\n    float shape = unionSDF(hollowB, sphereB);\n    glow += 0.1 / (0.1 + shape*shape);\n    return shape;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 cameraOrigin = vec3(20. * sin(iTime*.5), 20. * cos(iTime*.5), 14.);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    const int MAX_ITER = 128;\n    const float MAX_DIST = 100.0;\n    const float EPSILON = 0.002;\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    \n    float radius = 10.;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n\n        dist = distfunc(pos, radius);\n        totalDist += dist;\n        pos += dist * rayDir*.5;\n    }\n    \n    if (dist < EPSILON)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx, radius) - distfunc(pos - eps.yxx, radius),\n            distfunc(pos + eps.xyx, radius) - distfunc(pos - eps.xyx, radius),\n            distfunc(pos + eps.xxy, radius) - distfunc(pos - eps.xxy, radius)));\n\n        float diffuse = max(0.0, dot(-rayDir, normal * 0.9));\n        float specular = pow(diffuse, 100.0);\n\t\t\n        vec3 color = vec3(.2*sin(iTime*0.2) + 0.45,\n                          .2*cos(iTime*0.3) + 0.45,\n                          .2*sin(iTime*0.7) + 0.45) * (diffuse + specular) / (1. + totalDist * 0.05);\n\n\n        fragColor = vec4(color + glow*.015, 1.0);\n    }\n    else\n        fragColor = vec4(0.) + glow*.02;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}