{
    "Shader": {
        "info": {
            "date": "1592694282",
            "description": "Exercise from https://thebookofshaders.com/07/: use boxes to make a composition that resembles a Mondrian painting.\n\nReference: https://upload.wikimedia.org/wikipedia/commons/a/a4/Piet_Mondriaan%2C_1930_-_Mondrian_Composition_II_in_Red%2C_Blue%2C_and_Yell",
            "flags": 0,
            "hasliked": 0,
            "id": "wtlyzf",
            "likes": 8,
            "name": "BoS - Mondrian on the Wall",
            "published": 3,
            "tags": [
                "2d",
                "painting",
                "art",
                "mondrian",
                "thebookofshaders"
            ],
            "usePreview": 0,
            "username": "zeta",
            "viewed": 411
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926538\n\n#define put(shape, color, bg) mix(bg, color, shape)\n\n\nconst vec3 white = vec3(1),\n           black = vec3(0),\n           wall_c = vec3(0.9),\n           shadow_c = vec3(0.6),\n           frame_c = white,\n           paint_black = vec3(14, 16, 15) / 255.0,\n           paint_white = vec3(231, 232, 226) / 255.0,\n           paint_red = vec3(214, 34, 19) / 255.0,\n           paint_red2 = vec3(231, 63, 54) / 255.0,\n           paint_blue = vec3(0, 90, 160) / 255.0,\n           paint_yellow = vec3(230, 208, 97) / 255.0;\n\n\nfloat box_smooth(vec2 uv, vec4 bounds, vec4 smth)\n{\n\treturn smoothstep(bounds.x, bounds.x + smth.x, uv.x) *\n\t       smoothstep(bounds.y, bounds.y + smth.y, 1.0 - uv.x) *\n\t       smoothstep(bounds.z, bounds.z + smth.z, 1.0 - uv.y) *\n\t       smoothstep(bounds.w, bounds.w + smth.w, uv.y);\n}\n\n\nfloat box(vec2 uv, vec4 bounds)\n{\n\treturn step(bounds.x, uv.x) *\n\t       step(bounds.y, 1.0 - uv.x) *\n\t       step(bounds.z, 1.0 - uv.y) *\n\t       step(bounds.w, uv.y);\n}\n\n\nfloat box_border(vec2 uv, vec4 bounds, vec4 border_size)\n{\n    return box(uv, bounds) *\n\t       (\n               step(bounds.x, uv.x) * (1.0 - step(bounds.x + border_size.x, uv.x)) + \n               step(bounds.y, 1.0 - uv.x) * (1.0 - step(bounds.x + border_size.y, 1.0 - uv.x)) +\n               step(bounds.z, 1.0 - uv.y) * (1.0 - step(bounds.z + border_size.z, 1.0 - uv.y)) +\n               step(bounds.w, uv.y) * (1.0 - step(bounds.w + border_size.w, uv.y))\n           );\n}\n\n\n// Compute bounds relative to other bounds.\nvec4 brel(vec4 bounds, vec4 rel_to)\n{\n\treturn rel_to + vec4(\n\t\t(1.0 - rel_to.x - rel_to.y) * bounds.x,\n\t\t(1.0 - rel_to.x - rel_to.y) * bounds.y,\n\t\t(1.0 - rel_to.z - rel_to.w) * bounds.z,\n\t\t(1.0 - rel_to.z - rel_to.w) * bounds.w\n\t);\n}\n\n\n// https://easings.net/\nfloat easeOutExpo(float x)\n{\n\treturn x >= 1.0 ? 1.0 : 1.0 - pow(2.0, - 10.0 * x);\n}\nfloat easeOutBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return x >= 1.0 ? 1.0 : 1.0 - c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);\n}\nfloat easeOutElastic(float x)\n{\n    const float c4 = (2.0 * PI) / 3.0;\n\n    return x <= 0.0\n      ? 0.0\n      : x >= 1.0\n      ? 1.0\n      : 0.0, 1.0, pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc = fragCoord;\n\n\tfloat _min = min(iResolution.x, iResolution.y);\n\tfloat _max = max(iResolution.x, iResolution.y);\n\n\tfloat off = (_max - _min) * 0.5;\n\tif (iResolution.x > iResolution.y) {\n\t\tfc.x -= off;\n\t} else {\n\t\tfc.y -= off;\n\t}\n\n\tvec2 uv = fc.xy / _min;\n\n    vec4 frame_border_size = vec4(0.1);\n\tvec4 frame_b = vec4(0.15, 0.15, 0.05, 0.25);\n\tvec4 shadow_b = frame_b + vec4(0.02, 0.02, 0.02, -0.02);\n\tvec4 paint_b = frame_b + frame_border_size;\n    \n    float speed = iTime*0.5;\n    vec4 lnv  = mix(vec4(1, 0, 0, 0), vec4(0.25, 0.78, 0   , 0   ), easeOutElastic(speed)),\n\t     lnh  = mix(vec4(0, 0, 0, 1), vec4(0   , 0   , 0.75, 0.28), easeOutElastic(speed)),\n\t     ln13 = mix(vec4(0, 0, 0, 1), vec4(0   , 0   , 0.36, 0.7 ), easeOutElastic(speed)),\n\t     ln56 = mix(vec4(1, 0, 0, 0), vec4(0.93, 0.1 , 0   , 0   ), easeOutElastic(speed)),\n\t     ln67 = mix(vec4(0, 0, 0, 1), vec4(0   , 0   , 0.89, 0.15), easeOutElastic(speed));\n\n\tvec4 s1 = brel(vec4(0.0, lnv.y, 0.0, ln13.w), paint_b);\n\tvec4 s2 = brel(vec4(lnv.x, 0.0, 0.0, lnh.w), paint_b);\n\tvec4 s3 = brel(vec4(0.0, lnv.y, ln13.z, lnh.w), paint_b);\n\tvec4 s4 = brel(vec4(0.0, lnv.y, lnh.z, 0.0), paint_b);\n\tvec4 s5 = brel(vec4(lnv.x, ln56.y, lnh.z, 0.0), paint_b);\n\tvec4 s6 = brel(vec4(ln56.x, 0.0, lnh.z, ln67.w), paint_b);\n\tvec4 s7 = brel(vec4(ln56.x, 0.0, ln67.z, 0.0), paint_b);\n\n\tvec3 col = wall_c;\n\tcol = put(box_smooth(uv, shadow_b, vec4(0.01)), shadow_c, col);\n\tcol = put(box(uv, paint_b), paint_black, col);\n\tcol = put(box(uv, s1), paint_white, col);\n\tcol = put(box(uv, s2), mix(paint_red, paint_red2, uv.x), col);\n\tcol = put(box(uv, s3), paint_white, col);\n\tcol = put(box(uv, s4), paint_blue, col);\n\tcol = put(box(uv, s5), paint_white, col);\n\tcol = put(box(uv, s6), paint_white, col);\n\tcol = put(box(uv, s7), paint_yellow, col);\n    col = put(box_border(uv, frame_b, frame_border_size), frame_c, col);\n\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}