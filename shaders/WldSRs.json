{
    "Shader": {
        "info": {
            "date": "1581543480",
            "description": "Composition using a randomly generated function mapping x, y, and time to color values. Here also a noise function and simple lighting is implemented, as shown here: https://www.shadertoy.com/view/lsl3RH",
            "flags": 0,
            "hasliked": 0,
            "id": "WldSRs",
            "likes": 6,
            "name": "fn psych 2",
            "published": 3,
            "tags": [
                "2d",
                "abstract"
            ],
            "usePreview": 0,
            "username": "anttikan",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat noise( float x, float y )\n{\n    \n    vec2 p = vec2(x,y);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat pixelfunc(float x, float y, float iTime) {\n    return (sqrt(pow(sin(((((y)-(log(abs((sqrt(abs(((((y)*(x))-pow((x),2.0))-(noise((x),(y))+((y)*(x))))))*sin(pow(exp((y)),3.0))))+0.0001)-noise(abs((sqrt(pow(pow(pow(pow((y),2.0),2.0),2.0),2.0)+pow((y),2.0)))) - floor(abs((sqrt(pow(pow(pow(pow((y),2.0),2.0),2.0),2.0)+pow((y),2.0))))),(sin(iTime/0.9034435963811109 + 0.20637479410149906)))))/ (abs(exp((sin(iTime/0.8529278085443219 + 0.8213404700193889))))+0.0001))*(sqrt(abs((sqrt(pow(pow(abs(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.9995009860820951 + 0.6881438036038101)),3.0))))) - floor(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.26979193952694613 + 0.3785319489160377)),3.0))))))) - floor(abs(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.22226978701805833 + 0.24191002823528662)),3.0))))) - floor(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.5739308110903445 + 0.45896373432699944)),3.0)))))))),2.0),2.0)+pow((sin(iTime/0.7264469109570366 + 0.08679412060619152)),2.0)))))/ (abs((sqrt(pow(sin((y)),2.0)+pow(sin(cos((sqrt(pow((sign((sin((x))*log(abs((sin(iTime/0.9613027990997718 + 0.6659919369591429)))+0.0001)))/ (abs(noise((sin(iTime/0.6989492096617616 + 0.36615005376399967)),pow(((sin(iTime/0.71852557018322 + 0.1619393542530836))+(x)),2.0)))+0.0001)),2.0)+pow((sin(iTime/0.6209043266540595 + 0.8417751048573665)),2.0))))),2.0))))+0.0001)))),2.0)+pow(sin(pow(noise((sqrt(abs((sqrt(pow(pow(((sin(iTime/0.3462935766066413 + 0.3097821178771951))*sin(pow(((y)+(y)),2.0))),2.0),2.0)+pow((log(abs(noise((sqrt(pow(abs((x)) - floor(abs((x))),2.0)+pow(((x)*(y)),2.0))),(x)))+0.0001)/ (abs(((y)/ (abs(noise((((sin(iTime/0.7866078460146608 + 0.2681747389535367))*(y))/ (abs(abs((sin(iTime/0.3774955185871607 + 0.7938241880557342))) - floor(abs((sin(iTime/0.6122868317852803 + 0.6912683134142241)))))+0.0001)),sqrt(abs(abs((x)) - floor(abs((x)))))))+0.0001)))+0.0001)),2.0)))))/ (abs(pow((sqrt(pow((sign((x))/ (abs(cos(cos(abs(cos((x))) - floor(abs(cos((x)))))))+0.0001)),2.0)+pow(noise(sqrt(abs(exp(sin(sign((x)))))),sqrt(abs(exp(pow(sin((y)),2.0))))),2.0))),3.0))+0.0001)),((sin((pow((sqrt(pow((sin(iTime/0.6991922402347979 + 0.21404984070124788)),2.0)+pow(abs(((x)/ (abs((x))+0.0001))) - floor(abs(((x)/ (abs((x))+0.0001)))),2.0))),3.0)/ (abs(sqrt(abs(log(abs((y))+0.0001))))+0.0001)))/ (abs((((sqrt(pow(((sin(iTime/0.26754650486706133 + 0.12570778401332916))-abs(((sin(iTime/0.12503305278658794 + 0.01130819450429632))/ (abs((x))+0.0001))) - floor(abs(((sin(iTime/0.2653499101486092 + 0.00871470719699241))/ (abs((x))+0.0001))))),2.0)+pow(sin(sin(((x)-(sin(iTime/0.10483245318883472 + 0.600138486042491))))),2.0)))+sign(abs((y)) - floor(abs((y)))))-(sin(sin(sin(exp((sin(iTime/0.9940380440346446 + 0.5464411881844877))))))/ (abs(sign(((sqrt(pow((sin(iTime/0.6341745666062364 + 0.8531862440589704)),2.0)+pow(exp((y)),2.0)))-(x))))+0.0001))))+0.0001))*sin(pow((sqrt(pow(sin(sin(cos(((y)+(x))))),2.0)+pow((y),2.0))),3.0)))),2.0)),2.0)));\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1),min2, max2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    \n        \n    float x = p.x*(0.4 + 0.2*cos(iTime*0.1 + 10.0)) + sin(iTime*0.12 + 10.0);\n    float y = (0.4+0.2*cos(iTime*0.1 + 10.0))*p.y; // p.y*0.2; //\n    float t = iTime*0.2;\n    \n    float shade = pixelfunc(x, y, t);\n    float mapped_shade = map(shade,-3.0, 3.0, 0.0, 1.0);\n    \n    \n    vec3 col = mix( vec3(0.1,0.6,0.8), vec3(0.2,0.3,0.5), mapped_shade );\n    col = vec3(mapped_shade) - vec3(0.1, 0.1, 0.2);\n    \n    \n    \n    \n \tvec3 nor = normalize( vec3( pixelfunc(x+e,y,t)-shade, \n                                2.0*e,\n                                pixelfunc(x,y+e,t)-shade ) );\n\n    vec3 lig = normalize( vec3( 0.8, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.65,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.65,0.30,0.2)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n\n    \n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}