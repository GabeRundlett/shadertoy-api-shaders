{
    "Shader": {
        "info": {
            "date": "1518051368",
            "description": "Experiment of using AO in different way.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sdyz4",
            "likes": 14,
            "name": "Formation from p7120A",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 3717
        },
        "renderpass": [
            {
                "code": "// https://github.com/patuwwy/ShaderToy-Chrome-Plugin\n// https://github.com/patuwwy/ShaderToy-Notifier\n\n#define FAR 30.\n#define t iTime\n\n#define FOV 130.0\n#define FOG .4\n\nvec3 opRep( vec3 p, vec3 c ) {\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// \t3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvec3 map(vec3 p) {\n    \n    p.y += noise(p * 6.1 + vec3(10, -iTime * .3, 0).xyy) * 0.175 - 1.;   \t\n    //p.y += noise(p * 2. + iTime * .2) * .1;\n    p = opRep(p, vec3(1., 3., 1.));\n    \n    vec3 obj2 = vec3(\n        fBox(p, vec3(1.3)), \n        0, \n        0\n    );\n    \n    return obj2;\n}\n\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 t = vec3(0., 0., 0.0);\n    for (int i = 0; i < 78; i++) {\n        vec3 d = map(ro + rd * t.x);\n        if (abs(d.x) < 0.001 || t.x > FAR) break;\n        t.x += d.x * .6;\n        t.yz = d.yz;\n    }\n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 28;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = .01;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.1), 1.0);\n}\n\n#define E .1\nvec3 getNormal(vec3 pos) {\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(E,0,0)).x-d,\n                map(pos+vec3(0,E,0)).x-d,\n                map(pos+vec3(0,0,E)).x-d \n        \t)\n    \t);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal) {\n    float \n        dist = 0.1;\n    \n    return clamp(map(hitp + normal * dist).x / dist, 0.0, .6);\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec2 mat) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp - sp; \n    float lDist = max(length(ld), 0.001);\n    ld /= lDist; \n\n    float diff = max(dot(sn, ld), .1);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.0), 2.);\n\n    vec3 objCol =  vec3(0.0);\n\n    sceneCol += (objCol * (diff + 0.15) + vec3(.6, .6, .6) * spec * 2.);// * atten;\n\n    return sceneCol;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n \n    uv *= tan(radians (FOV) / 2.0);          \n    \n    vec3 \n        vuv = vec3(0., 1., 0.), // up\n    \tro = vec3(-t, .0 - cos(2.+iTime * .05) * .4, sin(iTime * .1)),//-vec3(iMouse.x / 100. - 1.,iMouse.y / 100. - 1., 1.), // pos\n    \tvrp =  vec3(cos(iTime * .21), -5., 1.) + ro, // lookat    \n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        \n        light = vec3(0, 1.2, 0),  \n\n        lp = light + ro,\n        sceneColor = vec3(0.),\n        tr = trace(ro, rd);\n    \n    float \n        fog = smoothstep(FAR * FOG, 0., tr.x * 3.), \n        sh,\n        ao;        \n    \n    if (fog > .8) {\n        ro += rd * tr.x;\n\n        vec3 sn = getNormal(ro);\t\n        \n        ao = getAO(ro + vec3(300., 0., t) * noise(ro) * 0.1, sn);\n\n        sceneColor += doColor(ro, rd, sn, lp, tr.yz) * .3;\n        \n        sh = softShadow(ro, lp, 1.);\n\n        rd = reflect(rd, sn);\n\n        tr = trace(ro + rd * .01, rd);\n\n        ro += rd * tr.x;\n\n        sn = getNormal(ro);\n\n        sceneColor += doColor(ro, rd, sn, lp, tr.yz) * .7;\n\n        ao *= pow(getAO(ro, sn) * 9., .3);\n\n        sceneColor *= sh * fog;\n        sceneColor = mix(sceneColor, vec3(0., .9, 1.), pow((1.-ao) * fog, 2. - fog));\n    }\n    sceneColor = pow(sceneColor, vec3(.6));\n    fragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}