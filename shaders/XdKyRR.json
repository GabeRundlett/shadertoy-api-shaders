{
    "Shader": {
        "info": {
            "date": "1520892012",
            "description": "Nearby & multiple roots are a torture test when working with limited precision! Red dots are known roots; blue circles are successfully detected roots returned by the root finder. Watch them go nuts when the quartic just barely kisses the x-axis.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdKyRR",
            "likes": 34,
            "name": "analytic quartic solver",
            "published": 3,
            "tags": [
                "test",
                "solver",
                "quartic",
                "polynomial"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 1258
        },
        "renderpass": [
            {
                "code": "/* \"analytic quartic solver\", by mattz\n\n   License: Creative Commons Attribution ShareAlike 4.0\n   https://creativecommons.org/licenses/by-sa/4.0/\n       \n   I hunted around a little bit on Shadertoy but couldn't find any\n   examples of a standalone, single-function quartic solver \n   capable of returning all real roots of a 4th-degree polynomial.\n\n   The result is the solve_quartic function below, feel free to \n   use it in your own projects under the license linked above.\n\n   With respect to testing, I wanted to make sure to test\n   all eight cases of root distribution (see generate_roots below).\n\n*/\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a quartic polynomial whose first coefficient is 1.\n\nfloat poly4(vec4 p, float x) {\n    return (((x + p[0])*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// follows notes in http://web.cs.iastate.edu/~cs577/handouts/polyroots.pdf\n// with some special-case code (because triple & quadruple roots are \n// really numerically unstable)\n//\n// the four quartic polynomial coefficients supplied are assumed to follow\n// a leading 1 coefficient.\n//\n// returned boolean should have 0, 2, or 4 true's corresponding to # of real\n// quartic roots.\n\nbvec4 solve_quartic(in vec4 coeffs,\n                    out vec4 roots) {\n        \n    const float TOL = 1e-4;\n\n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n\n    ////////////////////////////////////////////////////////////\n    // check for quadruple root\n    \n    float x = -p/4.;\n    \n    if (abs(poly4(coeffs, x)) < TOL &&\n        abs(q - 6.*x*x) < TOL) {\n        roots = vec4(x);\n        return bvec4(true);\n    }\n\n    ////////////////////////////////////////////////////////////\n    // check for triple root\n    \n    float d = 9.*p*p - 24.*q;\n    \n    if (d >= 0.) {\n\n        float x1 = -p/4. - sqrt(d)/12.;\n        float x2 = -p/4. + sqrt(d)/12.;\n        \n        float px1 = abs(poly4(coeffs, x1));\n        float px2 = abs(poly4(coeffs, x2));\n        \n        x = px1 < px2 ? x1 : x2;\n\n        float y = -p - 3.*x;\n        \n        roots = vec4(max(x,y),x,x,min(x,y));\n        \n        if (min(px1, px2) < TOL &&\n            abs(poly4(coeffs, y)) < TOL &&\n            abs(r + x*x*x + 3.*x*x*y) < TOL) {\n            \n            return bvec4(true);\n\n        }\n\n    }\n    \n    ////////////////////////////////////////////////////////////\n\t// form resolvent cubic and solve it to obtain one real root\n        \n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    \n    // coefficients of normal form\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    \n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    \n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= -TOL) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n\t// now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= -TOL);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= -TOL);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= -TOL);\n    bool E_ok = R_ok && (foo - bar >= -TOL);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a cubic polynomial with given coefficients\n\nfloat poly3(vec4 p, float x) {\n    return ((p[0]*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// from Dave Hoskins' \"Hash without sine\"\n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat noise(vec2 xc) {\n    \n    float x0 = floor(xc.x);\n    float t = fract(xc.x);\n    \n    float a = hash12(vec2(x0-1., xc.y));\n    float b = hash12(vec2(x0, xc.y));\n    float c = hash12(vec2(x0+1., xc.y));\n    float d = hash12(vec2(x0+2., xc.y));\n    \n    float t2 = t*t;\n    float t3 = t2*t;\n    \n    float h00 = (2.*t3 - 3.*t2 + 1.);\n    float h01 = (t3 - 2.*t2 + t);\n    float h10 = (-2.*t3 + 3.*t2);\n    float h11 = (t3 - t2);\n    \n    return (h00*b + h01*(c-a) + h10*c + h11*(d-b))*2. - 1.;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// generate coefficients for 4th degree quartic from roots\n// note that c is the complex part of roots 0 & 1 and 2 & 3\n// if c[0] != 0, then we expect r[0] == r[1] and similarly\n// if c[1] != 0\n\nvec4 poly_from_roots(vec4 r, vec2 c) {\n    \n    float s01 = r[0] + r[1];\n    float p01 = r[0] * r[1] + c[0] * c[0];\n    float s23 = r[2] + r[3];\n    float p23 = r[2] * r[3] + c[1] * c[1];\n    \n    return vec4(-s01 - s23,\n                p01 + s01*s23 + p23,\n                -p01*s23 - s01*p23,\n                p01*p23);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// for a quartic with real coefficients, there are eight different\n// cases for roots, which we cycle through over time:\n//               \n//   case timestep #real multiplicity\n//     A  0-0.99       4   4 single           \n//     B  1-1.99       4   1 double, 2 single \n//     C  2-2.99       4   2 double\n//     D  3-3.99       4   1 triple, 1 single \n//     E  4-4.99       4   1 quad\n//     F  5-5.99       2   2 single\n//     G  6-6.99       2   1 double\n//     H  7-7.99       0   no real roots\n//\n//        8-8.99   repeat case C to move smoothly back to A\n//\n\nvoid generate_roots(out vec4 r, out vec2 c) {\n    \n    float t = 0.1*iTime;\n    float d = 2.2;\n\n    r = vec4(noise(vec2(t, 10.)),\n                  noise(vec2(t, 1.)),\n                  noise(vec2(t, 12.)),\n                  noise(vec2(t, 3.)))*d;\n    \n    vec3 cc = vec3(noise(vec2(t, 14.))+0.2*d,\n                   noise(vec2(t, 5.))+0.2*d,\n                   0);\n    \n    t = 0.05*iTime;\n    \n    float rep = floor(t/9.);\n    \n    float phase = mod(t, 9.);\n    float u = smoothstep(0.8, 1.0, fract(phase));\n    \n    c = vec2(0);\n            \n    if (phase < 1.) { \n        r = mix(r, r.xxzw, u); // A -> B\n    } else if (phase < 2.) {\n        r = mix(r.xxzw, r.xxzz, u); // B -> C\n    } else if (phase < 3.) {\n        r = mix(r.xxzz, r.xxxz, u); // C -> D\n    } else if (phase < 4.) {\n        r = mix(r.xxxz, r.xxxx, u); // D -> E\n    } else if (phase < 5.) {\n        r = mix(r.xxxx, r.xxzw, u); // E -> F\n        c = mix(cc.zz, cc.xz, u);\n    } else if (phase < 6.) {\n        r = mix(r.xxzw, r.xxzz, u); // F -> G\n        c = cc.xz;\n    } else if (phase < 7.) {\n        r = r.xxzz; // G -> H\n        c = mix(cc.xz, cc.xy, u);\n    } else if (phase < 8.) {\n        r = r.xxzz; // H -> C\n        c = mix(cc.xy, cc.zz, u);\n    } else {\n        r = mix(r.xxzz, r, u); // C -> A\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given point p, function value at p.x and function derivative at\n// p.x, determine estimated distance to curve of function plot.\n\nfloat dist_to_plot(vec2 p, vec2 fdf) {\n    \n    vec2 p0 = vec2(p.x, fdf.x);\n    vec2 n = normalize(vec2(-fdf.y, 1));\n    return abs(dot(p - p0, n));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float scl = 6. / iResolution.x;\n    \n    vec2 p = (fragCoord - 0.5 - vec2(0.5, 0.28)*iResolution.xy)*scl;\n    \n    vec4 r; vec2 c;\n    generate_roots(r, c);\n    \n    vec4 poly = poly_from_roots(r, c);\n    \n    vec4 solved_roots; \n    bvec4 is_root = solve_quartic(poly, solved_roots);\n    \n    vec4 pder = vec4(4,3,2,1) * vec4(1, poly.xyz);\n    \n    const float Y_ZOOM = 0.5;\n\n    vec2 fdf = Y_ZOOM*vec2(poly4(poly, p.x), \n                           poly3(pder, p.x));\n\n    vec3 color = vec3(1, 0.97, .87);\n\n    // grid lines\n    vec2 gp0 = .5*floor(2.*p + 0.5);\n    vec2 gp = fract(abs(p - gp0));\n    color = mix(color, vec3(0.6, 0.75, 0.6), smoothstep(scl, 0., min(gp.x, gp.y)));\n    \n    // axis line\n    vec2 ap = abs(p);\n    color = mix(color, vec3(0.37, 0.55, 0.37)*.9, 0.8*smoothstep(scl, 0., min(ap.x, ap.y)-.75*scl));      \n    \n    // plot line\n    float dline = dist_to_plot(p, fdf);\n    color = mix(color, vec3(.5, .03, .03), smoothstep(scl, 0., dline-.5*scl));\n    \n    // known roots\n    for (int i=0; i<4; ++i){\n        int j = i/2;\n        if (c[j] == 0.) {\n            float dc = length(p - vec2(r[i], 0));\n            color = mix(color, vec3(.25, .02, .02), smoothstep(scl, 0., dc-3.*scl));\n        }\n    }\n    \n    // solved roots\n    for (int i=0; i<4; ++i){\n        if (is_root[i]) {\n            float dc = length(p - vec2(solved_roots[i], 0));\n            color = mix(color, vec3(0, 0, 0.4), smoothstep(scl, 0., abs(dc-8.*scl)-.25*scl));\n        }\n    }\n    \n    // stole iq's vingette code\n    vec2 q = fragCoord.xy / iResolution.xy;\n    color *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );       \n    color *= 0.9 + 0.1*texture(iChannel0, fragCoord.xy/256.).x;\n\n    color = pow(color, vec3(1.0/2.2));\n    \n    fragColor = vec4(color, 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}