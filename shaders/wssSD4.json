{
    "Shader": {
        "info": {
            "date": "1551312724",
            "description": "TKGJ2019 entry https://spolsh.itch.io/bgr\nIn 24h Mixed two briliant retro shaders and created Racer game from Brick Game toys\nCredits to original authors are next to parts of code, thank you guys for sharing it. I have learned a lot making this game :)",
            "flags": 112,
            "hasliked": 0,
            "id": "wssSD4",
            "likes": 82,
            "name": "Brick Driver",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "game",
                "retro",
                "text",
                "sprite",
                "keyboard",
                "ui",
                "80",
                "multipass",
                "synthwave",
                "klos"
            ],
            "usePreview": 0,
            "username": "spolsh",
            "viewed": 4472
        },
        "renderpass": [
            {
                "code": "// Copyright © 2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Brick Driver\n//  Entry for TK Game Jam 2019\n//  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n// Awarded by the Jury\n//  and 4th place based on audience votes against 55 other entries\n//  https://spolsh.itch.io/bgr\n\n// TK Game Jam 2019 is Game development challange\n//  about creating game in 48h in Poland, Wrocław 22-24.02.2019\n//  https://itch.io/jam/tk-game-jam-2019\n//  https://web.facebook.com/events/185669952375258/250811702527749/\n\n// Game aimed for Retro category\n//  Themes used in game are synt(h)etic and development, \n//  because graphics is inspired by synthwave and car gets faster the longer you play\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU?t=67\n//  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"Cloth Shading\" by knarkowicz. https://shadertoy.com/view/4tfBzn\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Uses also snippets from:\n// - Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n// - Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\n// Thnak you guys for sharing it, hope you like the game :)\n\n// Music: Laserhawk - King of the streets\n//  https://soundcloud.com/lazerhawk/king-of-the-streets\n\n\n// Fork of \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// 2019-02-24 00:16:15\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    // chromatic abberation\n    float caStrength\t= 0.002;\n    vec2 caOffset \t\t= screenUV - 0.5;\n\tvec2 caUVG\t\t\t= screenUV + caOffset * caStrength;\n\tvec2 caUVB\t\t\t= screenUV + caOffset * caStrength * 2.0;\n\n    vec3 color;\n    color.x = texture( iChannel0, screenUV ).x;\n    color.y = texture( iChannel0, caUVG ).y;\n    color.z = texture( iChannel0, caUVB ).z;    \n    \n    fragColor = vec4( color, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 17937,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/lazerhawk/king-of-the-streets"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Copyright © 2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Brick Driver\n//  Entry for TK Game Jam 2019\n//  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n// Awarded by the Jury\n//  and 4th place based on audience votes against 55 other entries\n//  https://spolsh.itch.io/bgr\n\n// TK Game Jam 2019 is Game development challange\n//  about creating game in 48h in Poland, Wrocław 22-24.02.2019\n//  https://itch.io/jam/tk-game-jam-2019\n//  https://web.facebook.com/events/185669952375258/250811702527749/\n\n// Game aimed for Retro category\n//  Themes used in game are synt(h)etic and development, \n//  because graphics is inspired by synthwave and car gets faster the longer you play\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU?t=67\n//  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"Cloth Shading\" by knarkowicz. https://shadertoy.com/view/4tfBzn\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Uses also snippets from:\n// - Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n// - Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\n// Thnak you guys for sharing it, hope you like the game :)\n\n// Music: Laserhawk - King of the streets\n//  https://soundcloud.com/lazerhawk/king-of-the-streets\n\n\n\n// Brick Game Racer in shader by Michal Klos\n\n// control loop\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 3. || fragCoord.y >= 1.) \n    {\n        discard;    \n    }\n\n    AppState s;\n    LoadState(iChannel0, s); \n\t\n\t// read keys that people usually press instead of space    \n    float key = 0.0;\n    for (int i = 0; i < keys.length(); ++i)\n        key = max( key, step( 0.1, texture( iChannel1, vec2( keys[i] / 256.0, 0.5 ) ).x ) );\n\n\ts.isSpacePressed = key;\n    \n    if (s.stateID == GS_SPLASH) // splash\n    {        \n        if (s.isSpacePressed > 0.5)\n        {\n            s.stateID = GS_GAME;\n\t\t\ts.isFailed = 0.0;\n            s.timeFailed = 0.0;\n\t\t\ts.timeAccumulated = 0.0;\n            s.score = 0.0;\n\t\t\ts.paceScale = 0.0;\n            s.timeStarted = iTime;\n        }\n    }\n    else if (s.stateID == GS_GAME) // game\n    {       \n        if (s.isFailed < 0.5)\n        {\n            if (s.isSpacePressed > 0.5)\n                s.isLeftLine = mod(s.isLeftLine + 1.0, 2.0);\n        \n            // game logic\n            s.paceScale = clamp((s.playerCell - 10.0) / 100.0, 0.0, 1.0);\n            float timeMultiplier = mix(1.0, 3.0, pow(s.paceScale, 1.0) );\n            \n            float timeStep = timeMultiplier * iTimeDelta;\n            s.timeAccumulated += timeStep;\n            s.playerCell = floor( 2.0 * s.timeAccumulated );\n            \n#ifdef AI\n            {\n\t\t\t\tfloat playerCellState = GetCellState(s.playerCell + 1.0, s.seed);\n                if (playerCellState < CS_EMPTY_LANE\n                    && s.isLeftLine == playerCellState)\n                {\n                    s.isLeftLine = mod(s.isLeftLine + 1.0, 2.0);\n                }\n            }\n#endif\n            \n            float playerCellState = GetCellState(s.playerCell, s.seed);\n\n            if (playerCellState < CS_EMPTY_LANE\n                && s.isLeftLine == playerCellState)\n            {\n                s.isFailed = 1.0;\n                s.timeFailed = iTime;\n\t\t\t\ts.stateID = GS_SPLASH;\n            }\n            else\n            {\n                s.score = s.playerCell - CELLS_HEADSTART;\n                s.highscore = max(s.score, s.highscore);\n            }\n    \t}\n    }\n  \n    fragColor = SaveState(s, fragCoord, iFrame);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Copyright © 2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Brick Driver\n//  Entry for TK Game Jam 2019\n//  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n// Awarded by the Jury\n//  and 4th place based on audience votes against 55 other entries\n//  https://spolsh.itch.io/bgr\n\n// TK Game Jam 2019 is Game development challange\n//  about creating game in 48h in Poland, Wrocław 22-24.02.2019\n//  https://itch.io/jam/tk-game-jam-2019\n//  https://web.facebook.com/events/185669952375258/250811702527749/\n\n// Game aimed for Retro category\n//  Themes used in game are synt(h)etic and development, \n//  because graphics is inspired by synthwave and car gets faster the longer you play\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU?t=67\n//  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"Cloth Shading\" by knarkowicz. https://shadertoy.com/view/4tfBzn\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Uses also snippets from:\n// - Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n// - Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\n// Thnak you guys for sharing it, hope you like the game :)\n\n// Music: Laserhawk - King of the streets\n//  https://soundcloud.com/lazerhawk/king-of-the-streets\n\n\n// from Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\n\n\n// #define DEBUG\t// enables camera rotation with mouse and draws 2d game on left side of screen\n// #define AI\t\t// makes car avoid obstacles on its own\n#define ZERO (min(iFrame,0))\n\nconst float keys[] = float[] ( \n     32.0, // space\n\t 37.0, // Arrow left\n\t 38.0, // Arrow up\n\t 39.0, // Arrow right\n\t 40.0, // Arrow down\n\t 65.0, // A\n\t 68.0, // D\n\t 87.0, // W\n\t 83.0, // S\n\t100.0, // d\n\t115.0, // s\n\t119.0, // w\n\t197.0  // a \n);\n\n// Game State\nconst float GS_SPLASH = 0.0;\nconst float GS_GAME   = 1.0;\n\n// Cell State\nconst float CS_RIGHT_LANE = 0.0;\nconst float CS_LEFT_LANE  = 1.0;\nconst float CS_EMPTY_LANE = 2.0;\n\nconst float CELLS_HEADSTART = 4.0;\n\n// Based on \"Cloth Shading\" by knarkowicz. https://shadertoy.com/view/4tfBzn\nstruct AppState\n{\n\tfloat stateID;    \n\tfloat isSpacePressed;    \n    float timeFailed;\n\tfloat isLeftLine;\n    \n\tfloat isFailed;\n    float playerCell;\n    float score;\n    float highscore;\n    \n    float timeAccumulated;\n    float paceScale;    \n    float seed;\n    float timeStarted;\n};\n\nvec4 LoadValue(sampler2D tex, int x, int y)\n{\n    return texelFetch(tex, ivec2(x, y), 0);\n}\n\nvoid LoadState(sampler2D tex, out AppState s)\n{\n    vec4 data;\n\n\tdata = LoadValue(tex, 0, 0);\n\ts.isSpacePressed = data.x;\n    s.stateID      = data.y;\n\ts.timeFailed   = data.z;\n    s.isLeftLine   = data.w;\n    \n    data = LoadValue(tex, 1, 0);\n    s.isFailed   = data.x;\n    s.playerCell = data.y;\n    s.score\t\t = data.z;\n    s.highscore\t = data.w;\n    \n    data = LoadValue(tex, 2, 0);\n    s.timeAccumulated = data.x;\n    s.paceScale       = data.y;    \n\ts.seed            = data.z;\n    s.timeStarted     = data.w;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragCoord = floor(fragCoord);\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nvec4 SaveState(in AppState s, in vec2 fragCoord, int iFrame)\n{\n    if (iFrame <= 0)\n    {\n\t\ts.stateID = GS_SPLASH;\n\t\ts.isSpacePressed  = 0.0;\n\t\ts.timeFailed      = 0.0;\n        s.isLeftLine      = 0.0;\n        \n        s.isFailed        = 0.0;\n        s.playerCell      = 0.0;\n        s.score           = 0.0;\n        s.highscore       = 0.0;\n        \n        s.paceScale       = 0.0;\n        s.timeAccumulated = 0.0;\n        s.seed            = fbm3(iDate.yzw);\n        s.timeStarted     = 0.0;\n    }\n    \n    vec4 ret = vec4(0.);\n\tStoreValue(vec2(0., 0.), vec4(s.isSpacePressed,  s.stateID,    s.timeFailed,   s.isLeftLine),   ret, fragCoord);\n\tStoreValue(vec2(1., 0.), vec4(s.isFailed,        s.playerCell, s.score,        s.highscore),    ret, fragCoord);\n    StoreValue(vec2(2., 0.), vec4(s.timeAccumulated, s.paceScale,  s.seed,         s.timeStarted),  ret, fragCoord);\n    return ret;\n}\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat GetCellRandomValue(float cellID, float seed)\n{\n    return step(0.5, hash11( cellID + seed ));\n}\n\nfloat GetCellState(float cellID, float seed)\n{\n    float rndState = GetCellRandomValue( cellID, seed );\n    rndState = mix(rndState, CS_EMPTY_LANE, step(cellID, CELLS_HEADSTART));\n\n    float cellState = CS_EMPTY_LANE;\n    return mix( cellState, rndState, step(0.5, mod(cellID, 2.0)) );\n}\n\n///////////////////////////////////////////////////////////////////////////\n// Utils\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvoid Rotate(inout vec2 p, float a) \n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n// from http://mercury.sexy/hg_sdf/\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n// based on https://www.shadertoy.com/view/ll2BWz\nvoid SpriteLeft(inout vec3 color, vec2 p)\n{\n    uint v = 0u;\n\tv = p.y == 31. ? 0u : v;\n\tv = p.y == 30. ? 0u : v;\n\tv = p.y == 29. ? 0u : v;\n\tv = p.y == 28. ? 0u : v;\n\tv = p.y == 27. ? (p.x < 8. ? 0u : (p.x < 16. ? 2004317952u : (p.x < 24. ? 2003828855u : 489335u))) : v;\n\tv = p.y == 26. ? (p.x < 8. ? 0u : (p.x < 16. ? 2004317952u : (p.x < 24. ? 2003830647u : 7829367u))) : v;\n\tv = p.y == 25. ? (p.x < 8. ? 0u : (p.x < 16. ? 30464u : (p.x < 24. ? 124782448u : 7798784u))) : v;\n\tv = p.y == 24. ? (p.x < 8. ? 0u : (p.x < 16. ? 2004317952u : (p.x < 24. ? 2003830647u : 7829367u))) : v;\n\tv = p.y == 23. ? (p.x < 8. ? 0u : (p.x < 16. ? 489216u : (p.x < 24. ? 2003830647u : 7829367u))) : v;\n\tv = p.y == 22. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 139537u : (p.x < 24. ? 124782448u : 7798784u))) : v;\n\tv = p.y == 21. ? (p.x < 8. ? 286330880u : (p.x < 16. ? 1981878545u : (p.x < 24. ? 122685303u : 34672896u))) : v;\n\tv = p.y == 20. ? (p.x < 8. ? 286330880u : (p.x < 16. ? 1628508433u : (p.x < 24. ? 319815799u : 18088209u))) : v;\n\tv = p.y == 19. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 286261248u : (p.x < 24. ? 286326784u : 286326801u))) : v;\n\tv = p.y == 18. ? (p.x < 8. ? 286261248u : (p.x < 16. ? 268435456u : (p.x < 24. ? 286326784u : 286330880u))) : v;\n\tv = p.y == 17. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 268435456u : (p.x < 24. ? 17895425u : 286331136u))) : v;\n\tv = p.y == 16. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 268435456u : (p.x < 24. ? 17895681u : 286331152u))) : v;\n\tv = p.y == 15. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 285212672u : (p.x < 24. ? 286331137u : 285282577u))) : v;\n\tv = p.y == 14. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 286261248u : (p.x < 24. ? 286331137u : 286265617u))) : v;\n\tv = p.y == 13. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 286326784u : (p.x < 24. ? 286330881u : 286261265u))) : v;\n\tv = p.y == 12. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 286330880u : (p.x < 24. ? 286330880u : 286261248u))) : v;\n\tv = p.y == 11. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 17895696u : (p.x < 24. ? 17895680u : 285212672u))) : v;\n\tv = p.y == 10. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 1118481u : (p.x < 24. ? 286331136u : 286261249u))) : v;\n\tv = p.y == 9. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 4369u : (p.x < 24. ? 285282560u : 286261265u))) : v;\n\tv = p.y == 8. ? (p.x < 8. ? 286331136u : (p.x < 16. ? 17u : (p.x < 24. ? 268505344u : 286261521u))) : v;\n\tv = p.y == 7. ? (p.x < 8. ? 286331153u : (p.x < 16. ? 0u : (p.x < 24. ? 69888u : 17830161u))) : v;\n\tv = p.y == 6. ? (p.x < 8. ? 17895697u : (p.x < 16. ? 0u : (p.x < 24. ? 4352u : 17826064u))) : v;\n\tv = p.y == 5. ? (p.x < 8. ? 17895696u : (p.x < 16. ? 0u : (p.x < 24. ? 4368u : 17825792u))) : v;\n\tv = p.y == 4. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 0u : (p.x < 24. ? 4352u : 0u))) : v;\n\tv = p.y == 3. ? 0u : v;\n\tv = p.y == 2. ? 0u : v;\n\tv = p.y == 1. ? 0u : v;\n\tv = p.y == 0. ? 0u : v;\n    v = p.x >= 0. && p.x < 32. ? v : 0u;\n\n    float i = float((v >> uint(4. * p.x)) & 15u);\n    color = i == 1. ? vec3(1, 0, 0.8) : color;\n    color = i == 2. ? vec3(1, 0.2, 0.8) : color;\n    color = i == 3. ? vec3(1, 0.4, 0.8) : color;\n    color = i == 4. ? vec3(1, 0.4, 1) : color;\n    color = i == 5. ? vec3(1, 0.6, 1) : color;\n    color = i == 6. ? vec3(1, 0.8, 1) : color;\n    color = i == 7. ? vec3(1) : color;\n}\n\nvoid SpriteRight(inout vec3 color, vec2 p)\n{\n    uint v = 0u;\n\tv = p.y == 31. ? 0u : v;\n\tv = p.y == 30. ? 0u : v;\n\tv = p.y == 29. ? 0u : v;\n\tv = p.y == 28. ? 0u : v;\n\tv = p.y == 27. ? (p.x < 8. ? 2415919248u : (p.x < 16. ? 629145u : (p.x < 24. ? 2576351241u : 0u))) : v;\n\tv = p.y == 26. ? (p.x < 8. ? 2566914192u : (p.x < 16. ? 629145u : (p.x < 24. ? 10027017u : 0u))) : v;\n\tv = p.y == 25. ? (p.x < 8. ? 160432272u : (p.x < 16. ? 0u : (p.x < 24. ? 626697u : 0u))) : v;\n\tv = p.y == 24. ? (p.x < 8. ? 160432272u : (p.x < 16. ? 0u : (p.x < 24. ? 39321u : 0u))) : v;\n\tv = p.y == 23. ? (p.x < 8. ? 160432272u : (p.x < 16. ? 0u : (p.x < 24. ? 629145u : 0u))) : v;\n\tv = p.y == 22. ? (p.x < 8. ? 2566914192u : (p.x < 16. ? 0u : (p.x < 24. ? 10063881u : 0u))) : v;\n\tv = p.y == 21. ? (p.x < 8. ? 2566914192u : (p.x < 16. ? 629145u : (p.x < 24. ? 142606345u : 17895424u))) : v;\n\tv = p.y == 20. ? (p.x < 8. ? 144u : (p.x < 16. ? 620185u : (p.x < 24. ? 355467273u : 286265636u))) : v;\n\tv = p.y == 19. ? (p.x < 8. ? 272u : (p.x < 16. ? 256u : (p.x < 24. ? 286261248u : 17825809u))) : v;\n\tv = p.y == 18. ? (p.x < 8. ? 272u : (p.x < 16. ? 16u : (p.x < 24. ? 286261248u : 286326784u))) : v;\n\tv = p.y == 17. ? (p.x < 8. ? 273u : (p.x < 16. ? 286326801u : (p.x < 24. ? 17891328u : 17895424u))) : v;\n\tv = p.y == 16. ? (p.x < 8. ? 268435729u : (p.x < 16. ? 286330881u : (p.x < 24. ? 17895425u : 1118464u))) : v;\n\tv = p.y == 15. ? (p.x < 8. ? 285212945u : (p.x < 16. ? 1118465u : (p.x < 24. ? 17895424u : 69905u))) : v;\n\tv = p.y == 14. ? (p.x < 8. ? 285212945u : (p.x < 16. ? 1118464u : (p.x < 24. ? 286330880u : 4369u))) : v;\n\tv = p.y == 13. ? (p.x < 8. ? 17826065u : (p.x < 16. ? 69904u : (p.x < 24. ? 286326784u : 17u))) : v;\n\tv = p.y == 12. ? (p.x < 8. ? 17895696u : (p.x < 16. ? 69904u : (p.x < 24. ? 286330880u : 0u))) : v;\n\tv = p.y == 11. ? (p.x < 8. ? 1118464u : (p.x < 16. ? 17895696u : (p.x < 24. ? 286330880u : 0u))) : v;\n\tv = p.y == 10. ? (p.x < 8. ? 1118464u : (p.x < 16. ? 4368u : (p.x < 24. ? 286330880u : 1u))) : v;\n\tv = p.y == 9. ? (p.x < 8. ? 1118464u : (p.x < 16. ? 272u : (p.x < 24. ? 268505088u : 17u))) : v;\n\tv = p.y == 8. ? (p.x < 8. ? 69888u : (p.x < 16. ? 272u : (p.x < 24. ? 69632u : 273u))) : v;\n\tv = p.y == 7. ? (p.x < 8. ? 69632u : (p.x < 16. ? 268435728u : (p.x < 24. ? 69888u : 4368u))) : v;\n\tv = p.y == 6. ? (p.x < 8. ? 69632u : (p.x < 16. ? 16777488u : (p.x < 24. ? 4352u : 256u))) : v;\n\tv = p.y == 5. ? (p.x < 8. ? 0u : (p.x < 16. ? 69888u : (p.x < 24. ? 4352u : 0u))) : v;\n\tv = p.y == 4. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 256u : 0u))) : v;\n\tv = p.y == 3. ? 0u : v;\n\tv = p.y == 2. ? 0u : v;\n\tv = p.y == 1. ? 0u : v;\n\tv = p.y == 0. ? 0u : v;\n    v = p.x >= 0. && p.x < 32. ? v : 0u;\n\n    float i = float((v >> uint(4. * p.x)) & 15u);\n    color = i == 1. ? vec3(1, 0, 0.73) : color;\n    color = i == 2. ? vec3(1, 0.0039, 0.73) : color;\n    color = i == 3. ? vec3(1, 0.063, 0.75) : color;\n    color = i == 4. ? vec3(1, 0.12, 0.76) : color;\n    color = i == 5. ? vec3(1, 0.41, 0.84) : color;\n    color = i == 6. ? vec3(1, 0.64, 0.9) : color;\n    color = i == 7. ? vec3(1, 0.72, 0.93) : color;\n    color = i == 8. ? vec3(1, 0.81, 0.95) : color;\n    color = i == 9. ? vec3(1) : color;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Copyright © 2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Brick Driver\n//  Entry for TK Game Jam 2019\n//  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n// Awarded by the Jury\n//  and 4th place based on audience votes against 55 other entries\n//  https://spolsh.itch.io/bgr\n\n// TK Game Jam 2019 is Game development challange\n//  about creating game in 48h in Poland, Wrocław 22-24.02.2019\n//  https://itch.io/jam/tk-game-jam-2019\n//  https://web.facebook.com/events/185669952375258/250811702527749/\n\n// Game aimed for Retro category\n//  Themes used in game are synt(h)etic and development, \n//  because graphics is inspired by synthwave and car gets faster the longer you play\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU?t=67\n//  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"Cloth Shading\" by knarkowicz. https://shadertoy.com/view/4tfBzn\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Uses also snippets from:\n// - Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n// - Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\n// Thnak you guys for sharing it, hope you like the game :)\n\n// Music: Laserhawk - King of the streets\n//  https://soundcloud.com/lazerhawk/king-of-the-streets\n\n\n\n// Fork of \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// 2019-02-24 01:09:41\n\n\nvec3 gBoxPos; \nfloat gCarLampDist = 1000000.0;\nAppState gS;\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid HighscoreText(inout vec3 color, vec2 p, in AppState s)\n{        \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 4. ? 1751607624u : ( t.x < 8. ? 1919902579u : 14949u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    // vec3 textColor = vec3(.3);\n\tvec3 textColor = vec3(0.75);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid CreditText(inout vec3 color, vec2 p, in AppState s)\n{        \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 4. ? 1246186324u : ( t.x < 8. ? 959524914u : ( t.x < 12. ? 2037588026u : ( t.x < 16. ? 1747481710u : ( t.x < 20. ? 1769235753u : ( t.x < 24. ? 539369571u : ( t.x < 28. ? 1702258020u : ( t.x < 32. ? 1836085100u : ( t.x < 36. ? 544501349u : ( t.x < 40. ? 1293973858u : ( t.x < 44. ? 1634231145u : ( t.x < 48. ? 1816862828u : 29551u ) ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 52. ? v : 0u;    \n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    // vec3 textColor = vec3(.3);\n\tvec3 textColor = vec3(0.75);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid SpaceText(inout vec3 color, vec2 p, in AppState s)\n{        \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;    \n    v = t.y == 0. ? ( t.x < 4. ? 1936028240u : ( t.x < 8. ? 1935351923u : ( t.x < 12. ? 1701011824u : ( t.x < 16. ? 1869881437u : ( t.x < 20. ? 1635021600u : 29810u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    // vec3 textColor = vec3(.3);\n\tvec3 textColor = vec3(1.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid DrawGame(inout vec3 color, AppState s, vec2 p)\n{\n    {              \n#ifdef DEBUG\n        // game\n        vec2 p2 = p;\n        p2 += vec2(1.5, 0.7);\n        p2 *= vec2(7.0, 4.5);\n        p2.y += s.playerCell;\n\n        float cellID = floor(p2.y);\n        float rndState = step( 0.5, hash11(cellID) );\n        if (cellID < CELLS_HEADSTART)\n        {\n            rndState = CS_EMPTY_LANE;\n        }\n\n        float cellState = CS_EMPTY_LANE;\n        cellState = mix( cellState, rndState, step(0.5, mod(cellID, 2.0)) );\n\n        // draw obstacles\n        if (cellState == CS_RIGHT_LANE)\n        {\n            vec2 p3 = (p2 -vec2(0.5) -vec2(0.0, cellID));\n            color = mix(mix(color, vec3(1.0, 0.0, 0.0), 0.2), color, smoothstep(0.0, 0.01, Circle(p3, 0.5) ));\n        }\n\n        if (cellState == CS_LEFT_LANE)\n        {\n            vec2 p3 = (p2 -vec2(0.5) -vec2(0.0, cellID));\n            p3.x += 1.0;\n            color = mix(mix(color, vec3(1.0, 0.0, 0.0), 0.2), color, smoothstep(0.0, 0.01, Circle(p3, 0.5) ));\n        }\n\n        // draw player\n        if (cellID == s.playerCell)\n        {\n            vec2 p3 = (p2 -vec2(0.5) -vec2(0.0, cellID));\n            if (s.isLeftLine == CS_LEFT_LANE)\n            {\n                p3.x += 1.0;\n            }\n            color = mix(mix(color, vec3(0.0, 1.0, 0.0), 0.2), color, smoothstep(0.0, 0.01, Circle(p3, 0.45) ));\n        }\n#endif\n    }\n}\n\n/* \nMADE BY MORGAN VILLEDIEU\nTW : https://twitter.com/VilledieuMorgan\nClick and drag to rotate the camera\n*/\n\n//Raymarch settings\n\n#define MAX_MOVEMENT_SPEED 0.9\n#define MIN_RADIUS 0.01\n#define MAX_RADIUS 0.3\n#define STAR_COUNT 30\n#define PI 3.14159265358979323\n#define TWOPI 6.283185307\n\n#define EPSILON 0.1\n\n#define RADIUS_SEED 1337.0\n#define START_POS_SEED 2468.0\n#define THETA_SEED 1675.0\n\n#define MIN_DIST 0.001\n#define MAX_DIST 32.0\n#define MAX_STEPS 96\n#define STEP_MULT 0.9\n#define FOCAL_LENGTH 0.9\n\n//Scene settings\n\n//#define SHOW_RAY_COST\n\n//Colors\n#define SKY_COLOR_1 vec3(49., 33., 66.)/255.\n#define SKY_COLOR_2 vec3(0.00,0.05,0.20)\n\n#define SUN_COLOR_2 vec3(87., 33., 73.)/255.\n#define SUN_COLOR_1 vec3(1.00, 0.20, 0.60)/2.\n\n#define CAR_COLOR_1 vec3(0.01, 0.2, 0.2)\n#define CAR2_COLOR_1 vec3(1.00, 0.0, 0.0)\n\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(26.00, 14.0, 122.0)/255.\n#define FOG_COLOR vec3(193.00, 24.0, 123.0)/255.\n\n//Parameters\n#define GRID_SIZE 0.50\n#define GRID_LINE_SIZE 1.25\n\n#define SUN_DIRECTION vec3( 0.10,0.0,0.)\n\n#define CLOUD_SCROLL vec2(0.002, 0.001)\n#define CLOUD_BLUR 2.0\n#define CLOUD_SCALE vec2(0.04, 0.10)\n\n#define MOUNTAIN_SCALE 6.0\n#define MOUNTAIN_SHIFT 5.3\n\n#define SPEED 11.\n\nconst vec3 starColor = vec3(1.0, 1.0, 1.0);\n\n//Color modes\n//vec3(#,#,#) Number of bits per channel\n\n//24 bit color\n#define RGB888 vec3(8,8,8)\n//16 bit color\n#define RGB565 vec3(5,6,5)\n#define RGB664 vec3(6,6,4)\n//8 bit color\n#define RGB332 vec3(3,3,2)\n#define RGB242 vec3(2,4,2)\n#define RGB222 vec3(2,2,2) //+2 unused\n\n#define COLOR_MODE RGB242\n\n//Object IDs\n#define SKYDOME 0.\n#define FLOOR 1.\n#define CAR 2.\n#define CAR2 3.\n\nstruct MC\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n//==== Distance field operators/functions by iq. ====\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n\n\nvec2 sdBox(vec3 pos, vec3 size, float id)\n{\n    return vec2(length(max(abs(pos) - size, 0.0)), id);\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nvec2 sdOct( vec3 p, float r, float id )\n{\n\tvec2 s = vec2(1,-1)/sqrt(1.0);\n\treturn vec2(max(max(max(\n\t\t\tabs(dot(p,s.xxx)),abs(dot(p,s.yyx))),\n\t\t\tabs(dot(p,s.yxy))),abs(dot(p,s.xyy))) - r*mix(1.0,1.0/sqrt(3.0),.5), id);\n}\n\nvec2 sdSphere(vec3 p, float s, float id)\n{\n  return vec2(length(p) - s, id);\n}\n\n\nfloat displace(vec3 p) {\n\tfloat height = 10.;\n\treturn ((cos(1.*p.y+0.5)*clamp(sin(1.1*p.x), 0.5, 1.)*sin(0.+2.4)*height*clamp(texture(iChannel0, p.xy/10.).r*0.4, 0.0, 0.5)));\n}\n\n//float displace(vec3 p) {\n//return ((cos(1.*p.x)*sin(1.1*p.y)/2.*sin(4.*p.z+1.)))*texture(iChannel2, p.xy/10.).r+0.1;\n//}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat Intersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat Plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nvec2 sdPlane(vec3 p, vec4 n, float id)\n{\n  // n must be normalized\n float bounce = (1.0 - gS.isFailed) * 0.05 * abs(sin(6.5*iTime));\n  return vec2( dot(vec3(p.x,p.y, max(p.z + bounce + displace(vec3(p.x, p.y-10., p.z)), p.z)), vec3(n.x, n.y, n.z)) + n.y, id);\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nvec2 sdColumn(vec3 p, float r, float id)\n{\n    return vec2(((abs(p.x)+abs(p.y))-r)/sqrt(2.0), id);\n}\n\n// From \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\nfloat Car( vec3 p, float id )\n{        \n    p *= 3.5;\n    \n    p.x = -p.x;     \n    p.y -= 0.3;\n    \n    float a = Box( p, vec3( 4.2, 0.9, 1.8 ) );   \n    \n    vec3 t = p + vec3( -6.0, 0.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float b = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -5.0, 0.0, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float c = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 2.0, -0.2, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float d = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 2.0, -0.3, 0.0 );\n    Rotate( t.yx, -0.05 );\n    float e = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 2.0, 1.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float f = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );     \n    \n    t = p;\n    t.z = abs( t.z );\n    t += vec3( -3.9, -0.6, 0.0 );\n    float spoiler = Box( t, vec3( 0.2, 0.05, 1.7 ) );\n    spoiler = Union( spoiler, Box( t - vec3( 0.0, -0.25, 1.4 ), vec3( 0.2, 0.3, 0.15 ) ) );\n    \n    float bloom = Box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\t\n    if (id == CAR)\n      gCarLampDist = min( gCarLampDist, bloom );\n        \n    t = p + vec3( 1.0, -0.6, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float frontWindow = Box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float backWindow = Box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = Union( Substract( a, Union( Union( Union( b, c ), Intersect( d, e ) ), f ) ), spoiler );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    Rotate( t.yz, -0.9 );\n    float sideCutPlanes = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = SubstractChamfer( body, Union( backWindow, frontWindow ), 0.1 );\n    body = SubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.7 );\n    float wheel = Cylinder( t, 0.7, 1.0 );\n    body = Substract( body, wheel );\n    \n    wheel = Substract( Cylinder( t, 0.55, 0.3 ), Sphere( t + vec3( 0.0, -0.15, 0.0 ), 0.35 ) );\n    \n    body = Union( body, wheel );\n    \n    body /= 3.5;\n    \n    return body;\n}\n\n//Distance to the scene\nvec2 Scene(vec3 p)\n{\t\n    p = vec3(p.x, p.z, -p.y); // Coord fix\n    \n    vec2 d = vec2(MAX_DIST, SKYDOME);    \n\tvec3 pEnv = p;\n    d = opU(d, sdPlane(pEnv, vec4(0, 0,-1, 0), FLOOR));\n                  \n\tvec3 boxSize = vec3(0.6*vec2(0.9, 0.6), 0.2);\n    vec3 boxSizeObs = boxSize;\n    boxSizeObs.z *= 5.0;\n\n    { // obstacles \n        vec3 pObs = p - gBoxPos;\t\t\n        float c = pModInterval1(pObs.x, 8.0*boxSize.x, -5.0, 10.0);   \n        float cellID = gS.playerCell + c;        \n\t\tfloat cellState = GetCellState(cellID, gS.seed);                \n\n        if (cellState == CS_EMPTY_LANE)\n\t\t\tpObs.y = -1.0;\n        else\n\t\t\tpObs.y -= mix( -1.0, 1.0, step(cellState, CS_LEFT_LANE - 0.1));\n\n        pObs.y += fbm3(vec3(100000.0*cellID)) * 0.5;       \n        d = opU(d, vec2( Car(vec3(pObs.x, -pObs.z, pObs.y) -vec3(0.0, 0.3, 0.0), CAR2), CAR2 )); \n    }   \n\t\n    { // player        \n        vec3 pBox = p - gBoxPos - vec3(0.0, gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5, 0.0);\n        pBox.y += fbm3(vec3(100000.0*gS.playerCell)) * 0.2;\n    \td = opU(d, vec2( Car(vec3(pBox.x, -pBox.z, pBox.y) -vec3(0.0, 0.3, 0.0), CAR), CAR )); \n    }\n    \n\treturn d;\n}\n\n//Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Scene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n//Raymarch the scene with the given ray\nMC MR(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec2 object = Scene(orig + dir * dist);\n        \n        //Add the sky dome and have it follow the camera.\n        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));        \n        dist += object.x * STEP_MULT;        \n        id = object.y;\n        \n        steps++;\n        \n        if(abs(object.x) < MIN_DIST * dist)\n        {\n            break;\n        }\n    }\n    \n    MC result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    result.id = id;\n    \n    return result;\n}\n\n//Scene texturing/shading\nvec3 Shade(MC hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.0);\n    vec3 rd = color;\n    vec3 skydomeColor = color;\n    \n    if(hit.id == SKYDOME)\n    {\n    \tcolor = mix(SKY_COLOR_1*1.4, SKY_COLOR_2, hit.position.y/9.0);\n       \n        vec3 sunDir = normalize(SUN_DIRECTION);       \n\t\tfloat sun = smoothstep(0.987, 0.99, dot(direction, sunDir));\n        sun -= smoothstep(0.1, 0.9, 0.5);\t\t\t        \n\t\tfloat sunStripesPos = 2.0*pow(0.6*hit.position.y-0.1, 1.5);\n        float stripes = clamp( smoothstep(0.5, 0.51, abs(-1.0+2.0*fract(sunStripesPos))), 0.0, 1.0);\t\t        \n\t\tvec3 sunCol = mix(SUN_COLOR_1, SUN_COLOR_2*1.2, -hit.position.y/2.5);        \n        color = mix(color, sunCol, min(sun, stripes)) + texture(iChannel2, vec2(2.) * 0.1).rgb * 0.07;\t\t        \n    }      \n\n    if(hit.id == FLOOR)\n    {\n        vec2 uv = abs(mod(hit.position.xz + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); \n        \n        uv /= fwidth(hit.position.xz);\n                                                       \n        float gln = min(min(uv.x, uv.y), 1.) / GRID_SIZE;\n    \tcolor = mix(GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n        \n\t\tvec3 normal = vec3(0.,0.0,-0.5);\n        vec3 rfld = reflect( direction, normal );\n        float reflectstrength = 1.-abs(dot( direction, normal ));\n        color *= reflectstrength;\n        \n        vec3 spotColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 spotPos    = gBoxPos + vec3( 0.5, -0.75, 0.0 ) + vec3(0.0, 0.0, gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5);\n        vec3 spotDir    = normalize( spotPos.xzy - hit.position.xzy );\n        float spotAtt = 1.0 / pow( length( spotPos - hit.position ), 2.0 );\n        spotAtt *= saturate( -spotDir.x * 6.0 - 4.0 );\n        color += color * spotColor * spotAtt * saturate( dot( normal, spotDir ) );  \t\n\n        // red trail      \n        float trailX = hit.position.x - gBoxPos.x -2.0;\n        color += 0.9 * vec3( 1.0, 0.0, 0.0 ) \n            * saturate( exp( -5.2 * abs( hit.position.z -(gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5)) ) )\n            * saturate(  1.0 + trailX * 0.02 )\n            * saturate( -0.6 - trailX * 0.3 );\n    } \n    \n\tif(hit.id == CAR)\n    {\n        vec2 uv = abs(mod(hit.position.xz + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); \n        \n        uv /= fwidth(hit.position.xz);\n                                                       \n        float gln = min(min(uv.x, uv.y), 1.) / GRID_SIZE;\n    \tcolor = mix((0.5*CAR_COLOR_1), (2.0*GRID_COLOR_2), 0.8 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n        \n\t\tvec3 normal = vec3(0.,0.0,-0.5);\n        vec3 rfld = reflect( direction, normal );\n        float reflectstrength = 2.-abs(dot( direction, normal ));\n        color *= reflectstrength;\n        \n        vec3 spotColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 spotPos    = gBoxPos + vec3( 0.5, -0.75, 0.0 ) + vec3(0.0, 0.0, gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5);\n        vec3 spotDir    = normalize( spotPos.xzy - hit.position.xzy );\n        float spotAtt = 1.0 / pow( length( spotPos - hit.position ), 2.0 );\n        spotAtt *= saturate( -spotDir.x * 6.0 - 4.0 );\n        color += color * spotColor * spotAtt * saturate( dot( normal, spotDir ) );         \n    } \n\n\tif(hit.id == CAR2)\n    {\n        vec2 uv = abs(mod(hit.position.xz + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0);         \n        uv /= fwidth(hit.position.xz);                                                       \n        float gln = min(min(uv.x, uv.y), 1.) / GRID_SIZE;\n    \tcolor = mix((0.5*CAR2_COLOR_1), (2.0*GRID_COLOR_2), 0.8 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n    } \n    \n    //Distance fog\n    color += mix(GRID_COLOR_2, FOG_COLOR, pow(hit.dist, 1.01) )/70.;\n    \n    return color;\n}\n\n// Based on \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\nvec3 SceneBloom()\n{\n    return vec3( 1.0, 0.2, 0.1 ) * 1.0 * vec3( exp( -gCarLampDist * 0.5 ) );\n}\n    \nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid DrawScene(inout vec3 color, AppState s, vec2 p)\n{\n    vec2 mo = iMouse.xy/iResolution.xy;    \n\t   \n    gBoxPos = vec3(8.0 * (s.playerCell + fract(2.0 * s.timeAccumulated)), 0.0, 0.0);\n    \n    float arm = mix(4.0, 8.0, s.paceScale );\n    \n\tvec3 gOrig = gBoxPos;\n   \n#ifdef DEBUG\n    gOrig += vec3(\n        arm*cos(6.0*mo.x),\n        0.0 + 4.0*mo.y,\n        arm*sin(6.0*mo.x)\n    );\n#else\n\tvec3 gameOffset = vec3(\n        arm*cos(1.0*3.14 + 0.1 * sin(0.5*iTime)),\n        1.5 + 0.5 * s.paceScale,\n        arm*sin(1.0*3.14 + 0.1 * sin(0.5*iTime))\n    );\n    vec3 failOffset = vec3(\n        4.0*cos(0.1*iTime),\n        1.5,\n        4.0*sin(0.1*iTime)\n    );\n    \n    gOrig += mix(\n        gameOffset,\n        mix(\n            gameOffset,\n            failOffset,\n            smoothstep(0.0, 2.0, iTime - s.timeFailed)\n        ),\n        step(s.stateID, GS_SPLASH - 0.1)\n    );\n\n#endif\n    \n    gOrig.y += fbm3(100.0*gOrig) * 0.1 * s.paceScale;\n    \n    vec3 gLookat = gBoxPos + vec3( 0.0, 0.1, 0.0 );\t\n     \n    mat3 ca = setCamera( gOrig, gLookat, 0.0);\n    float fov = mix(2.2, 4.0, s.paceScale );\n    vec3 dir = ca * normalize( vec3(vec2(p.x, p.y), fov) );\n        \n    MC hit = MR(gOrig, dir);\n    \n    vec3 shade = Shade(hit, dir, gOrig );\n    vec3 bloom = SceneBloom();                \n    color = 2.5 * shade + bloom;\n    \n    //particles\n    float angle = atan(dir.z, dir.y)/(atan(iTime)-1.*1.*PI);\n    angle -= floor(angle);\n    float rad = length(vec2(dir.x * 0.02, dir.z));\n \n    if (s.isFailed < 0.5)\n    {\n        float timeScale = mix(20.0, 50.0, s.paceScale);\n        float dist3Scale = mix(100.0, 25.0, s.paceScale);\n        float opacityScale = mix(0.2, 1.0, s.paceScale);\n\n        float angleFract = fract(angle*10.5);\n        float angleRnd = floor(angle*180.);\n        float angleRnd1 = fract(angleRnd*fract(angleRnd*.72035)*1.1);\n        float angleRnd2 = fract(angleRnd*fract(angleRnd*.82657)*1.724);\n        float t = iTime*timeScale+angleRnd1*1000.;\n        float radDist = sqrt(angleRnd2+.1);\n        float adist = radDist/rad*.2;\n        float dist = (t*.2+adist);\n        dist = abs(fract(dist/20.)-.5);\n\n        color += opacityScale * max(0.0,.7-dist*dist3Scale/adist)*(0.5-abs(angleFract-.5))*1./adist/radDist;        \n    }\n    \n    // score counter text    \n    if (s.isFailed < 0.5)\n    {\n        vec2 p1 = p;\n        p1 *= 7.0;\n        p1 -= vec2(-1.0, 5.5);\n        p1 -= vec2(-0.5 * ceil(log2(s.score)/log2(10.0)), 0.0);\n        p1 *= mix( 0.9, 1.0, abs(sin(2.0 * 3.14 * iTime)) * step(s.isFailed, 0.5) );\n        color += PrintInt(p1, s.score);\n    }\n}\n\nvoid DrawSplash(inout vec3 color, AppState s, vec2 p)\n{\n    vec2 resMult = floor(iResolution.xy / 64.);\n    float resRcp = 1. / max(min(resMult.x, resMult.y), 1.);\n    vec2 screenSize = floor(iResolution.xy * resRcp);\n    vec2 pixel      = floor(gl_FragCoord.xy * resRcp - screenSize * .5);\n    SpriteLeft(color, pixel  + vec2(32,8));\n    SpriteRight(color, pixel + vec2(0,8));\n\n    vec2 p2 = p;\n    p2 *= 55. + 5. * abs(sin(2.0*iTime));\n    p2 -= vec2(-40, -25.0);\n    SpaceText(color, p2, s);\n\n    vec2 p4 = p;\n    p4 *= 90.;\n    p4 -= vec2(-100, -80.0);\n    CreditText(color, p4, s);\n\n    if (s.highscore > 0.0)\n    {\n        vec2 p5 = p;\n        p5 *= 50.;\n        p5 -= vec2(-28, -38.0);\n        HighscoreText(color, p5, s);\n    }\n\n    vec2 p3 = p;\n    p3 *= 10.0;\n    p3 -= vec2( 3.5, -7.3);\n    p3 -= vec2(-0.5 * ceil(log2(s.score)/log2(10.0)), 0.0);\n    float scoreColor = PrintInt(p3, s.highscore);\n    color = mix(color, vec3(1.0), scoreColor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x / iResolution.y;\n       \n    AppState s;\n    LoadState(iChannel2, s);\n    \n    gS = s;\n    \n    vec3 color = vec3(0.0);\n        \n    DrawScene(color, s, p);\n    DrawGame(color, s, p);    \n     \n    if ( s.stateID == GS_SPLASH )\n\t \tDrawSplash(color, s, p);\n\n\tfragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Copyright © 2019 Michal Klos\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Brick Driver\n//  Entry for TK Game Jam 2019\n//  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n// Awarded by the Jury\n//  and 4th place based on audience votes against 55 other entries\n//  https://spolsh.itch.io/bgr\n\n// TK Game Jam 2019 is Game development challange\n//  about creating game in 48h in Poland, Wrocław 22-24.02.2019\n//  https://itch.io/jam/tk-game-jam-2019\n//  https://web.facebook.com/events/185669952375258/250811702527749/\n\n// Game aimed for Retro category\n//  Themes used in game are synt(h)etic and development, \n//  because graphics is inspired by synthwave and car gets faster the longer you play\n\n// Gameplay is based on Brick Game Racing,\n//  https://youtu.be/EdMyKRC8qyU?t=67\n//  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n// Based on:\n// - \"80's raymarching\" by villedieumorgan. https://shadertoy.com/view/lsVSRt\n// - \"Cloth Shading\" by knarkowicz. https://shadertoy.com/view/4tfBzn\n// - \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// Uses also snippets from:\n// - Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n// - Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\n// Thnak you guys for sharing it, hope you like the game :)\n\n// Music: Laserhawk - King of the streets\n//  https://soundcloud.com/lazerhawk/king-of-the-streets\n\n\n// Fork of \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n// 2019-02-24 00:16:15\n\n// Post processing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    // radial blur\n    vec4 mainSample = texture( iChannel0, screenUV );    \n    vec2 blurOffset = ( screenUV - vec2( 0.5 ) ) * 0.001;;\n    vec3 color = mainSample.xyz;\n\tfor ( int iSample = 1; iSample < 16; ++iSample )\n\t{\n\t\tcolor += texture( iChannel0, screenUV - blurOffset * float( iSample ) ).xyz;\n\t}    \n    color /= 16.0;\n    \n    // vignette\n    float vignette = screenUV.x * screenUV.y * ( 1.0 - screenUV.x ) * ( 1.0 - screenUV.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n    \n    float scanline   = clamp( 0.95 + 0.05 * cos( 3.14 * ( screenUV.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille  \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * screenUV.x * 640.0 * 1.0 ), 0.0, 1.0 );\n    color *= scanline * grille * 1.2;    \n        \n    fragColor = vec4( color, 1.0 );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}