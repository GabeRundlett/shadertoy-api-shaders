{
    "Shader": {
        "info": {
            "date": "1655326503",
            "description": "Recoloured version of ice and fire by mattz (https://www.shadertoy.com/view/MdfBzl)\nI would have forked but didn't see the option at the time.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssKyzc",
            "likes": 7,
            "name": "Purple-Black LowPoly",
            "published": 3,
            "tags": [
                "purple",
                "lowpoly"
            ],
            "usePreview": 0,
            "username": "adamrichardlimb",
            "viewed": 370
        },
        "renderpass": [
            {
                "code": "/* \n   This is just a recoloured version of:\n\n   ice and fire, by mattz (https://www.shadertoy.com/view/MdfBzl)\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Demonstrate triangulation of jittered triangular lattice.\n\n   Really nice effect - idk if its actually delauney or not but I like it just the same.\n   (I would have forked )\n\n*/\nconst float s3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n\n//////////////////////////////////////////////////////////////////////\n// cosine based palette \n// adapted from https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t,\n          float distance,\n          in vec4 t0, in vec4 t1, in vec4 t2,\n          in vec2 p) {\n    \n    const vec3 a = vec3(0.25);\n    const vec3 b = vec3(0.5);\n    const vec3 c = vec3(0.3, 0.3, 0.3);\n    const vec3 d = vec3(0.0, 0.25, 0.0);\n    \n    float dots = 0.0;\n    \n    //If point intersects with line between two vertices - set to white\n    if (distance > -0.01)\n        dots = 0.0;\n       \n    if (p == t0.xy)\n        dots = 0.5;\n    \n    return clamp(a + b*cos( 6.28318*(c*t+d) ), dots, 1.0);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);   \n}\n\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute barycentric coordinates from point differences\n// adapted from https://www.shadertoy.com/view/lslXDf\n\nvec3 bary(vec2 v0, vec2 v1, vec2 v2) {\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    return vec3(u,v,w);\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to line segment from point differences\n\nfloat dseg(vec2 xa, vec2 ba) {\n    return length(xa - ba*clamp(dot(xa, ba)/dot(ba, ba), 0.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// generate a random point on a circle from 3 integer coords (x, y, t)\n\nvec2 randCircle(vec3 p) {\n    \n    vec2 rt = hash23(p);\n    \n    float r = sqrt(rt.x);\n    float theta = 6.283185307179586 * rt.y;\n    \n    return r*vec2(cos(theta), sin(theta));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// make a time-varying cubic spline at integer coords p that stays\n// inside a unit circle\n\nvec2 randCircleSpline(vec2 p, float t) {\n\n    // standard catmull-rom spline implementation\n    float t1 = floor(t);\n    t -= t1;\n    \n    vec2 pa = randCircle(vec3(p, t1-1.0));\n    vec2 p0 = randCircle(vec3(p, t1));\n    vec2 p1 = randCircle(vec3(p, t1+1.0));\n    vec2 pb = randCircle(vec3(p, t1+2.0));\n    \n    vec2 m0 = 0.5*(p1 - pa);\n    vec2 m1 = 0.5*(pb - p0);\n    \n    vec2 c3 = 2.0*p0 - 2.0*p1 + m0 + m1;\n    vec2 c2 = -3.0*p0 + 3.0*p1 - 2.0*m0 - m1;\n    vec2 c1 = m0;\n    vec2 c0 = p0;\n    \n    return (((c3*t + c2)*t + c1)*t + c0) * 0.8;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// perturbed point from index\n\nvec2 triPoint(vec2 p) {\n    float t0 = hash12(p);\n    return tri2cart*p + 0.45*randCircleSpline(p, 0.15*iTime + t0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// main shading function. inputs:\n// \n//   p - current pixel location in scene\n//\n//   tfloor - integer grid coordinates of bottom-left triangle vertex\n//\n//   t0, t1, t2 - displaced cartesian coordinates (xy) and integer\n//                grid offsets (zw) of triangle vertices, relative\n//                to tfloor\n//\n//   scl - pixel size in scene units\n//\n//   cw - pixel accumulator. xyz are rgb color pre-multiplied by\n//        weights, and w is total weight.\n//\n\nvoid tri_color(in vec2 p, \n               in vec4 t0, in vec4 t1, in vec4 t2, \n               in float scl, \n               inout vec4 cw) {\n               \n    // get differences relative to vertex 0\n    vec2 p0 = p - t0.xy;\n    vec2 p10 = t1.xy - t0.xy;\n    vec2 p20 = t2.xy - t0.xy;\n    \n    // get barycentric coords\n    vec3 b = bary(p10, p20, p0);\n    \n    // distances to line segments\n    float d10 = dseg(p0, p10);\n    float d20 = dseg(p0, p20);\n    float d21 = dseg(p - t1.xy, t2.xy - t1.xy);\n    \n    // unsigned distance to triangle boundary\n    float d = min(min(d10, d20), d21);\n\n    // now signed distance (negative inside, positive outside)\n    d *= -sign(min(b.x, min(b.y, b.z))); \n\n    // only wory about coloring if close enough\n    if (d < 0.5*scl) {\n\n        //////////////////////////////////////////////////\n        // generate per-vertex palette entries\n    \n        // sum of all integer grid indices\n        vec2 tsum = t0.zw + t1.zw + t2.zw;\n\n        // generate unique random number in [0, 1] for each vertex of\n        // this triangle\n        vec3 h_tri = vec3(hash12(tsum + t0.zw),\n                          hash12(tsum + t1.zw),\n                          hash12(tsum + t2.zw));\n\n        //////////////////////////////////////////////////\n        // now set up the \"main\" triangle color:\n        \n        // get the cartesian centroid of this triangle\n        vec2 pctr = (t0.xy + t1.xy + t2.xy) / 3.0;\n\n        // angle of scene-wide color gradient\n        float theta = 1.0 + 0.01*iTime;\n        vec2 dir = vec2(cos(theta), sin(theta));\n\n        // how far are we along gradient?\n        float grad_input = dot(pctr, dir) - sin(0.05*iTime);\n\n        // h0 varies smoothly from 0 to 1\n        float h0 = sin(0.7*grad_input)*0.5 + 0.5;\n\n        // now the per-vertex random numbers are all biased towards h\n        // (still in [0, 1] range tho)\n        h_tri = mix(vec3(h0), h_tri, 0.4);\n\n        //////////////////////////////////////////////////\n        // final color accumulation\n        \n        // barycentric interpolation of per-vertex palette indices\n        float h = dot(h_tri, b);\n\n        // color lookup\n        vec3 c = pal(h, d, t0, t1, t2, p);\n        \n        // weight for anti-aliasing is 0.5 at border, 0 just outside,\n        // 1 just inside\n        float w = smoothstep(0.5*scl, -0.5*scl, d);\n\n        // add to accumulator\n        cw += vec4(w*c, w);\n        \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    float scl = 4.1 / iResolution.y;\n    \n    // get 2D scene coords\n    vec2 p = (fragCoord - 0.5 - 0.5*iResolution.xy) * scl;\n    \n    // get triangular base coords\n    vec2 tfloor = floor(cart2tri * p + 0.5);\n\n    // precompute 9 neighboring points\n    vec2 pts[9];\n\n    for (int i=0; i<3; ++i) {\n        for (int j=0; j<3; ++j) {\n            pts[3*i+j] = triPoint(tfloor + vec2(i-1, j-1));\n        }\n    }\n    \n    // color accumulator\n    vec4 cw = vec4(0);\n\n    // for each of the 4 quads:\n    for (int i=0; i<2; ++i) {\n        for (int j=0; j<2; ++j) {\n    \n            // look at lower and upper triangle in this quad\n            vec4 t00 = vec4(pts[3*i+j  ], tfloor + vec2(i-1, j-1));\n            vec4 t10 = vec4(pts[3*i+j+3], tfloor + vec2(i,   j-1));\n            vec4 t01 = vec4(pts[3*i+j+1], tfloor + vec2(i-1, j));\n            vec4 t11 = vec4(pts[3*i+j+4], tfloor + vec2(i,   j));\n          \n            // lower\n            tri_color(p, t00, t10, t11, scl, cw);\n\n            // upper\n            tri_color(p, t00, t11, t01, scl, cw);\n           \n        }\n    }    \n        \n    \n    // final pixel color\n    fragColor = cw / cw.w;\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}