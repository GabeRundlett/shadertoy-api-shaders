{
    "Shader": {
        "info": {
            "date": "1719035659",
            "description": "This is the iteration 2.\n\nI encountered a problem related to float precision (I think) as you can observe here https://www.shadertoy.com/view/lX3XW8\n\nThe only way I found to solve it was to use a texture and avoid uv manipulation altogether.",
            "flags": 32,
            "hasliked": 0,
            "id": "lXcXWN",
            "likes": 3,
            "name": "020.2 - Cafe Floor With Texture",
            "published": 3,
            "tags": [
                "sdf",
                "antialias",
                "pattern",
                "floor",
                "beautiful"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 74
        },
        "renderpass": [
            {
                "code": "// 2024.06.16 rev 1\n// 2024.06.18 rev 2 fix tearing and add final noise output\n// 2024.06.18 rev 3 fix a bug related to tearing when iTime variable is too large\n// 2024.06.22 rev 4 see https://www.shadertoy.com/view/lXcXWN use texture instead of uv space rotation to avoid float precision errors\n// 2024.06.22 rev 5 see https://www.shadertoy.com/view/l3dSDN use supersampling to avoid imprecision patterns\n\n#define time fract((iTime+iTimeDelta)/100.)\n\n// Returns a range of vec2(-1) to vec2(1) based on mouse and screen size\n// Deals with first frame and returns vec2(0) if so\nvec2 uvMouse() {\n    if (length(iMouse.xy) == 0.) {\n        return vec2(0, 0);\n    }\n    return ((iMouse.xy / iResolution.xy) - 0.5) * 2.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse = uvMouse();\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalize to [-1, 1] rotate and scale\n    // This enables zoom from the center\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv*= 2. * (mouse.x + 1.);\n    uv = rotate(uv, PI2*time) + time*17.;\n    // Go back to 0.0 to 1.0 coordinate\n    uv = uv * 0.5 + 0.5;\n    uv = fract(uv);\n\n    fragColor = texture(iChannel0, uv);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DEBUG 0\n#define AA 1\n#define NOISE 1\n\n// Returns a range of vec2(-1) to vec2(1) based on mouse and screen size\n// Deals with first frame and returns vec2(0) if so\nvec2 uvMouse() {\n    if (length(iMouse.xy) == 0.) {\n        return vec2(0, 0);\n    }\n    return ((iMouse.xy / iResolution.xy) - 0.5) * 2.;\n}\n\n// From https://gist.github.com/tylerdurrett/d492d8aa08f4c3968602a14a4cbe44c9\nmat2 skewUV(vec2 s) {\n    return mat2(1., tan(s.x),\n                tan(s.y), 1.);\n}\n\nfloat antiAlias = 1.5;\nfloat stepaa(float x, float y) {\n    #if AA\n    float w = antiAlias;\n    return smoothstep(x - w, x + w, y);\n    #endif\n    return step(x, y);\n}\n\n// (v.x, v.y) -> (v.y, v.x)\nvec2 swap(vec2 v) {\n    return vec2(v.y, v.x);\n}\n\n// Returns -size to size cycle\nfloat rangeCycle(float size, float perSec) {\n    return mod(iTime*perSec - size, size) - .5*size;\n}\n\n// Returns alpha value of a circle with antiAlias\nfloat circle(vec2 uv, vec2 origin, float size) {\n    return stepaa(length(uv - origin), size+antiAlias);\n}\n\n// Returns alpha value of a square with antiAlias\nfloat square(vec2 uv, vec2 origin, vec2 size) {\n    vec2 o = abs(uv - origin);\n    size += antiAlias;\n    return stepaa(o.x, size.x) * stepaa(o.y, size.y);\n}\n\n// Returns alpha value of a paralelogram with antiAlias\nfloat paralelogram(vec2 uv, vec2 origin, vec2 size, vec2 skew) {\n    vec2 o = uv - origin;\n    mat2 s = skewUV(skew);\n    o *= s;\n    size *= s;\n    float leftEdge = stepaa(o.x, size.x);\n    float rightEdge = stepaa(-o.x, size.x);\n    float topEdge = stepaa(o.y, size.y);\n    float bottomEdge = stepaa(-o.y, size.y);\n    return leftEdge * rightEdge * topEdge * bottomEdge;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = uvMouse();\n    antiAlias = (antiAlias + ((mouse.x + 1.) * 5.))/iResolution.y;\n#if !AA\n    antiAlias *= 0.;\n#endif\n    vec3 color = vec3(1.);\n#if DEBUG\n    vec3 red = vec3(1, 0, 0);\n    vec3 green = vec3(0, 1, 0);\n    vec3 blue = vec3(0, 0, 1);\n    vec3 magenta = vec3(1, 0, 1);\n#endif    \n\n    // Screen space setup\n    vec2 uv = fragCoord / iResolution.xy;\n\n    uv *= 2.;\n    float index = 0.0;\n    index += step(1., mod(uv.x, 2.));\n    index += step(1., mod(uv.y, 2.)) * 2.;\n    //\n    // 2 | 3\n    // - | -\n    // 0 | 1\n    if (index == 1.) {\n        uv = rotate(uv, 0.5 * PI);\n    } else if (index == 2.) {\n        uv = rotate(uv, -0.5 * PI);\n    } else if (index == 0.) {\n        uv = rotate(uv, -PI);\n    }\n    uv = (fract(uv) - 0.5) * 2.;\n    \n    // Colors\n    vec2 coord = mod(mod(uv*300., 300.), 256.);\n    float noise = texelFetch(iChannel0, ivec2(coord), 0).x/10.;\n#if !NOISE\n    noise = 0.;\n#endif\n    vec3 white = mix(vec3(0.93), vec3(0.031), noise);\n    vec3 black = mix(vec3(0.02), vec3(0.98), noise);\n    vec3 grey = mix(vec3(0.51f, 0.47f, 0.44f), vec3(0.0444), noise);\n#if !DEBUG\n    color = grey * 0.65;\n#endif\n    \n    // Size for circles\n    float s1 = 0.61;\n#if DEBUG\n    s1 += abs(sin(iTime)) / 75.;\n#endif\n    float s2 = s1 * 0.75;\n    // Size for grey background square\n    float thick = (s1 - s2);\n    \n    // White background\n    color = mix(color, white, square(uv, vec2(0), vec2(1.)));\n    \n    // Bottom left background square\n    color = mix(color, grey, square(uv, vec2(-thick/2.), vec2(1. - thick/2.)));\n\n    // Corners black semicircles\n    vec2 cbq = vec2(s2 * 0.65);\n    color = mix(color, black, square(uv, vec2(-1. + cbq.x, 1. - cbq.y), cbq));\n    color = mix(color, black, square(uv, vec2(1. - cbq.x, -1. + cbq.y), cbq));\n    \n    // Corners pattern circles\n    vec2 cpc1 = vec2(-1. + s1, 1. - s1);\n    vec2 cpc2 = vec2(1. - s1, -1. + s1);\n    color = mix(color, white, circle(uv, cpc1, s1));\n    color = mix(color, white, circle(uv, cpc2, s1));\n    \n    // Squares to mask circles\n    vec2 maskSize = vec2(1. - thick - s2/2., s2 * 0.7);\n    vec2 maskCoord = 1. - thick - maskSize;\n    color = mix(color, grey, square(uv, maskCoord, maskSize));\n    color = mix(color, grey, square(uv, swap(maskCoord), swap(maskSize)));\n    \n    // Corners small circles\n    vec2 csc1 = vec2(-1. + s1, 1. - s1);\n    vec2 csc2 = vec2(1. - s1, -1. + s1);\n    color = mix(color, grey, circle(uv, csc1, s2));\n    color = mix(color, grey, circle(uv, csc2, s2));\n        \n    // Small white square to mask circle discontinuity\n    vec2 cdist = cpc2 - cpc1;\n    vec2 sqp = (cpc1 + normalize(cdist) * length(cdist)/2.) + s2/3.;\n    color = mix(color, white, square(uv, sqp, vec2(thick)));\n\n    // Center leafs\n    float l1 = s2 * 0.4;\n    float l2 = l1 * 0.80;\n    float ang = radians(105.);\n    color = mix(color, white, circle(uv, csc1 + vec2(sin(ang), cos(ang))*s2, l2));\n    color = mix(color, white, circle(uv, csc2 + vec2(cos(ang), sin(ang))*s2, l2));\n    color = mix(color, white, circle(uv, sqp + thick, l1));\n    \n    // Bottom left leafs\n    vec2 sbl = vec2(1.-(s1), (1. - s1)/2.);\n    float slbang = radians(45.);\n    color = mix(color, white, paralelogram(uv, vec2(-1.) + sbl, sbl, vec2(-slbang, 0.)));\n    color = mix(color, black, paralelogram(uv, vec2(-1.) + swap(sbl), swap(sbl), vec2(0., -slbang)));\n\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.14159265358979323846\n#define PI2 6.28318530717958647692\n\n// From https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}