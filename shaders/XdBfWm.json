{
    "Shader": {
        "info": {
            "date": "1501360608",
            "description": "Because mama told me I can.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdBfWm",
            "likes": 0,
            "name": "Vorodiff",
            "published": 3,
            "tags": [
                "raymarching",
                "voronoi",
                "sphere",
                "reactiondiffusion"
            ],
            "usePreview": 0,
            "username": "Palliaci",
            "viewed": 709
        },
        "renderpass": [
            {
                "code": "/* By Palliaci\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Sphere mapping of a reaction diffusion which varies with a voronoi pattern.\n */\n#define I_MAX\t50\n#define FAR\t\t5.\n#define E\t\t.01\n#define LIGHTS\n#define REFL_I\t.5\n#define MARCH\t\t// Disable if you wanna see only the output of the reaction\n\nfloat st;\nmat3\trotX( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( 1, 0, 0, 0, c, -s, 0, s, c );\n}\nmat3\trotY( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n}\nmat3\trotZ(float a) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat3( c, s, 0, -s, c, 0, 0, 0, 1.0 );\n}\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\n// Sphere uv mapping from aiekick : https://www.shadertoy.com/view/MtS3DD\nvec3\treaction_sphere_map(vec3 p)\n{\n    vec2 uv;\n    uv.x = 0.5 + atan(p.z, p.x) / (2.*3.14159);\n    uv.y = 0.5 - asin(p.y) / 3.14159;\n    vec3 col = texture(iChannel0, uv).xyz;\n    return col;\n}\n\n// by iq. https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nfloat\tmap(vec3 p)\n{\n    vec3 ret = reaction_sphere_map(normalize(p));\n//    return length(p) - .5;\n    float d = length(p) -.6;\n    float scale = .15;\n    float isoline = .75;\n    \n    p = p / scale;\n\td = smax(d, d-(2.*clamp(-ret.x*ret.y, -1., 1.) - isoline)*scale, .3);\n    return d;\n//    return length(p) - .5-.05*ret.x*ret.y*ret.z;\n}\n\nfloat\tmarch(vec3 pos, vec3 dir)\n{\n    float d = 0.;\n    float prec = E;\n    for (int i = -1; i < I_MAX; i++)\n    {\n        prec = map(pos + dir * d);\n        d += prec;\n        if (d < E || d > FAR)\n            break;\n    }\n    return d;\n}\n\nvec3\tcamera(vec2 uv) {\n    float fov = 1.;\n    vec3 forw = vec3( 0.0, 0.0, 1.0 );\n    vec3 right = vec3( 1.0, 0.0, 0.0) ;\n    vec3 up = vec3( 0.0, 1.0, 0.0) ;\n    return ( normalize((uv.x-1.)*right + (uv.y-.5)*up + fov*forw) );\n}\n\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    st = sin(iTime);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n#ifdef MARCH\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 mickey = ((iMouse.xy) / iResolution.xy )*3.14;\n    mickey.x *= iResolution.x / iResolution.y;\n    vec3 pos = vec3(.2, .0, -.5*(mickey.x+mickey.y))*rotX(mickey.y+.15)*rotY(mickey.x-.12);\n    vec3 dir = camera(uv.xy)*rotX(mickey.y+.15)*rotY(mickey.x-.12);\n    vec3 col = vec3(.1);//, .3, .2);\n    \n\tfloat d = march(pos, dir);\n    if (d < FAR)\n    {\n\t\tvec3 p = pos + dir * d;\n        vec3 diff = reaction_sphere_map(normalize(p));\n        diff.x = pow(diff.x, .4545);\n    \tdiff.y = pow(diff.y, 2.4545);\n    \tdiff = blackbody(diff.x*diff.y*10000.).xyz;\n        col += diff;\n# ifdef LIGHTS\n        vec2 e = vec2(-1., 1.)*0.005;\n        vec3 n = normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n\t\tvec3 ev = normalize( p - pos );\n\t\tvec3 ref_ev = reflect( ev, n );\n        vec3 refl_cube = texture(iChannel1, ref_ev).rgb * REFL_I;\n        col *= clamp(refl_cube, .15, 1.);\n        vec3 light_pos = pos + vec3(st, 0., -.1);\n\n        vec3 vl = normalize( light_pos - p );\n\t\tfloat diffuse  = max( 0.001, dot( vl, n ) );\n\t\tfloat specular = pow( max( 0.001, dot( vl, ref_ev ) ), 1. );\n        float\tbrdf = (diffuse + specular) * .5 + .5;\n        col *= brdf;\n# endif\n    }\n    else\n        col = texture(iChannel1, dir).rgb*vec3(.2, .3, .5);\n    col = pow(col, vec3(.75));\n    fragColor = vec4(col,1.0);\n#else\n    //\n    vec3 col = texture(iChannel0, uv).xyz;\n    col.x = pow(col.x, .4545);\n    col.y = pow(col.y, .64545);\n    col = blackbody(col.x*col.y*10000.);\n\tfragColor = vec4(col.xy, .0, 1.0);\n#endif\t//\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2 Diffusion = vec2(0.08,0.03);\nconst float dt = 2.;\n\n// nine point stencil\nvec2 laplacian1(vec2 position) {\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec4 P = vec4(pixelSize, 0.0, -pixelSize.x);\n\treturn  \n\t0.5* texture( iChannel0,  position - P.xy ).xy // first row\n\t+ texture( iChannel0,  position - P.zy ).xy\n\t+  0.5* texture( iChannel0,  position - P.wy ).xy\n\t+  texture( iChannel0,  position - P.xz).xy // seond row\n\t- 6.0* texture( iChannel0,  position ).xy\n\t+   texture( iChannel0,  position + P.xz ).xy\n\t+  0.5*texture( iChannel0,  position +P.wy).xy  // third row\n\t+ texture( iChannel0,  position +P.zy ).xy\n\t+   0.5*texture( iChannel0,  position + P.xy   ).xy;\t\n}\n// nine point stencil\nvec2 laplacian2(vec2 position) {\n    vec2 pixelSize = 5. / iResolution.xy;\n    vec4 P = vec4(pixelSize, 0.0, -pixelSize.x);\n\treturn  \n\t0.5* texture( iChannel0,  position - P.xy ).xy // first row\n\t+ texture( iChannel0,  position - P.zy ).xy\n\t+  0.5* texture( iChannel0,  position - P.wy ).xy\n\t+  texture( iChannel0,  position - P.xz).xy // seond row\n\t- 6.0* texture( iChannel0,  position ).xy\n\t+   texture( iChannel0,  position + P.xz ).xy\n\t+  0.5*texture( iChannel0,  position +P.wy).xy  // third row\n\t+ texture( iChannel0,  position +P.zy ).xy\n\t+   0.5*texture( iChannel0,  position + P.xy   ).xy;\t\n}\n// nine point stencil\nvec2 laplacian3(vec2 position) {\n    vec2 pixelSize = 7. / iResolution.xy;\n    vec4 P = vec4(pixelSize, 0.0, -pixelSize.x);\n\treturn  \n\t0.5* texture( iChannel0,  position - P.xy ).xy // first row\n\t+ texture( iChannel0,  position - P.zy ).xy\n\t+  0.5* texture( iChannel0,  position - P.wy ).xy\n\t+  texture( iChannel0,  position - P.xz).xy // seond row\n\t- 6.0* texture( iChannel0,  position ).xy\n\t+   texture( iChannel0,  position + P.xz ).xy\n\t+  0.5*texture( iChannel0,  position +P.wy).xy  // third row\n\t+ texture( iChannel0,  position +P.zy ).xy\n\t+   0.5*texture( iChannel0,  position + P.xy   ).xy;\t\n}\nvec2\tlaplacian_convolution(vec2 uv)\n{\n\tvec2\tret = vec2(0.);\n    vec2\ttexel = (1.)/iResolution.xy;\n    vec2\ttexel2 = (1.)/iResolution.xy;\n    \n    if (uv.x == 0.)\n    {\n        ret += texture(iChannel0, vec2(uv.x , uv.y) ).xy * 4.;\n    \n        ret += texture(iChannel0, vec2(uv.x +1., uv.y) ).xy * 2.;\n        ret += texture(iChannel0, vec2(uv.x +texel.x, uv.y) ).xy * 2.;\n        ret += texture(iChannel0, vec2(uv.x , uv.y -texel.y) ).xy * 2.;\n        ret += texture(iChannel0, vec2(uv.x , uv.y +texel.y) ).xy * 2.;\n    \n        ret += texture(iChannel0, vec2(uv.x +1., uv.y -texel.y) ).xy;\n        ret += texture(iChannel0, vec2(uv.x +texel.x, uv.y -texel.y) ).xy;\n        ret += texture(iChannel0, vec2(uv.x +texel.x, uv.y +texel.y) ).xy;\n        ret += texture(iChannel0, vec2(uv.x +1., uv.y +texel.y) ).xy;\n    }\n    else if (uv.x == 1.)\n    {\n        ret += texture(iChannel0, vec2(uv.x , uv.y) ).xy * 4.;\n    \n        ret += texture(iChannel0, vec2(uv.x -texel.x, uv.y) ).xy * 2.;\n        ret += texture(iChannel0, vec2(uv.x -1., uv.y) ).xy * 2.;\n        ret += texture(iChannel0, vec2(uv.x , uv.y -texel.y) ).xy * 2.;\n        ret += texture(iChannel0, vec2(uv.x , uv.y +texel.y) ).xy * 2.;\n    \n        ret += texture(iChannel0, vec2(uv.x -texel.x, uv.y -texel.y) ).xy;\n        ret += texture(iChannel0, vec2(uv.x -1., uv.y -texel.y) ).xy;\n        ret += texture(iChannel0, vec2(uv.x -1., uv.y +texel.y) ).xy;\n        ret += texture(iChannel0, vec2(uv.x -texel.x, uv.y +texel.y) ).xy;\n    }\n    else\n    {\n        ret += texture(iChannel0, vec2(uv.x , uv.y) ).xy * 4.;\n    \n        ret += texture(iChannel0, vec2(uv.x -texel.x, uv.y) ).xy * 2.;\n        ret += texture(iChannel0, vec2(uv.x +texel.x, uv.y) ).xy * 2.;\n        ret += texture(iChannel0, vec2(uv.x , uv.y -texel.y) ).xy * 2.;\n        ret += texture(iChannel0, vec2(uv.x , uv.y +texel.y) ).xy * 2.;\n    \n        ret += texture(iChannel0, vec2(uv.x -texel.x, uv.y -texel.y) ).xy;\n        ret += texture(iChannel0, vec2(uv.x +texel.x, uv.y -texel.y) ).xy;\n        ret += texture(iChannel0, vec2(uv.x +texel.x, uv.y +texel.y) ).xy;\n        ret += texture(iChannel0, vec2(uv.x -texel.x, uv.y +texel.y) ).xy;   \n    }\n    /*else if (uv.y == 0.)\n        texel2.y = ;\n    else if (uv.y ==1.)\n        texel2.y = ;*/\n    return (ret/16.);\n}\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nvec3\tvoronoi(vec2 uv)\n{\n    // Scaling\n    uv *= 14.;\n    // Space tiling\n    vec2 i_uv = floor(uv);\n    uv = fract(uv);\n\n    float mdist = 1.;\n    vec2 mpt;\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 pt = random2(i_uv + neighbor);\n            pt = .5 + .5 * sin(iTime + 6.28*pt);\n            vec2 diff = neighbor + pt - uv;\n            float dist = length(diff);//smoothstep(.4, .5, length(diff));\n            if (dist < mdist)\n            {\n\t            mdist = dist;\n                mpt = pt;\n            }\n        }\n    }\n    return vec3(mdist, mpt);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    if(iFrame < 128) {\n        float rnd= texture(iChannel1, uv).x;//rand(uv)+(sin(50.*uv.x)+sin(50.*uv.y))*0.;\n        if(rnd>0.5) fragColor.x=.5;\n        else fragColor.y=.5;\n        return;\n    }\n    /*\n     fragColor.x = clamp(ab.x + (1. * (laplacian_convolution(uv).x) - ab.x * ab.y * ab.y \n                                 + FEED_DEFAULT * (1. - ab.x)) ,-1.,1.);\n     fragColor.y = clamp(ab.y + (.5 * (laplacian_convolution(uv).y*uv.y) + ab.x * ab.y * ab.y \n                                 - (FEED_DEFAULT + KILL_DEFAULT) * ab.y ),-1.,1.);\n    */\n    //float F = uv.y *0.0042+0.014;//* .005  + .015;\n    //float k = (length(uv-.5)) *0.021+0.082;//* .02 + .028;\n    float F = voronoi(uv).x *0.0042+0.014;//* .005  + .015;\n    float k = (length(uv-.5)) *0.021+0.084;//* .02 + .028;\n    vec4 data = texture(iChannel0, uv);\n    float u = data.x;\n    float v = data.y;\n    vec2 Duv = (1.*laplacian_convolution(uv))*Diffusion;//+0.*laplacian2(uv)+0.*laplacian3(uv))*Diffusion;\n    float du = Duv.x - u*v*v + F*(1.-u);\n    float dv = Duv.y + u*v*v - (F+k)*v;\n    fragColor.xy = clamp(vec2(u+du*dt,v+dv*dt), 0., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define A22 0.0030\n#define A21 0.0133\n#define A20 0.0219\n#define A11 0.0596\n#define A10 0.0983\n#define A00 0.1621\nvec2\ttexel;\n\nvec2 gaussian_blur(vec2 uv)\n{\n    vec2\tblur;\n    \n\tblur =\tA00 *\ttexture( iChannel0, uv ).rg;\n\n\tblur +=\tA10 *\ttexture( iChannel0, uv + vec2(-texel.x, 0.) ).rg;\n\tblur +=\tA10 *\ttexture( iChannel0, uv + vec2(texel.x, 0.) ).rg;\n\tblur +=\tA10 *\ttexture( iChannel0, uv + vec2(0., -texel.y) ).rg;\n\tblur +=\tA10 *\ttexture( iChannel0, uv + vec2(0., texel.y) ).rg;\n\n\tblur +=\tA11 *\ttexture( iChannel0, uv + vec2(-texel.x, -texel.y) ).rg;\n\tblur +=\tA11 *\ttexture( iChannel0, uv + vec2(texel.x, -texel.y) ).rg;\n\tblur +=\tA11 *\ttexture( iChannel0, uv + vec2(-texel.x, texel.y) ).rg;\n\tblur +=\tA11 *\ttexture( iChannel0, uv + vec2(texel.x, texel.y) ).rg;\n\n\tblur +=\tA20 *\ttexture( iChannel0, uv + vec2(-texel.x*2., 0.) ).rg;\n\tblur +=\tA20 *\ttexture( iChannel0, uv + vec2(texel.x*2., 0.) ).rg;\n\tblur +=\tA20 *\ttexture( iChannel0, uv + vec2(0., -texel.y*2.) ).rg;\n\tblur +=\tA20 *\ttexture( iChannel0, uv + vec2(0., texel.y*2.) ).rg;\n\n\tblur +=\tA21 *\ttexture( iChannel0, uv + vec2(-texel.x, -texel.y*2.) ).rb;\n\tblur +=\tA21 *\ttexture( iChannel0, uv + vec2(texel.x, -texel.y*2.) ).rg;\n\tblur +=\tA21 *\ttexture( iChannel0, uv + vec2(-texel.x, texel.y*2.) ).rg;\n\tblur +=\tA21 *\ttexture( iChannel0, uv + vec2(texel.x, texel.y*2.) ).rg;\n\n\tblur +=\tA21 *\ttexture( iChannel0, uv + vec2(-texel.x*2., -texel.y) ).rg;\n\tblur +=\tA21 *\ttexture( iChannel0, uv + vec2(texel.x*2., -texel.y) ).rg;\n\tblur +=\tA21 *\ttexture( iChannel0, uv + vec2(-texel.x*2., texel.y) ).rg;\n\tblur +=\tA21 *\ttexture( iChannel0, uv + vec2(texel.x*2., texel.y) ).rg;\n\n\tblur +=\tA22 *\ttexture( iChannel0, uv + vec2(-texel.x*2., -texel.y*2.) ).rg;\n\tblur +=\tA22 *\ttexture( iChannel0, uv + vec2(texel.x*2., -texel.y*2.) ).rg;\n\tblur +=\tA22 *\ttexture( iChannel0, uv + vec2(-texel.x*2., texel.y*2.) ).rg;\n\tblur +=\tA22 *\ttexture( iChannel0, uv + vec2(texel.x*2., texel.y*2.) ).rg;\n\treturn blur;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    texel = (1.)/iResolution.xy;\n    vec2 uv = (fragCoord.xy) / iResolution.xy;\n    \n    fragColor = vec4( gaussian_blur(uv), .0, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define FEED_DEFAULT .0067\n#define KILL_DEFAULT .2949\n\nvec2\ttexel;\nfloat\tt;\n\nvec2\tlaplacian_convolution(vec2 uv)\n{\n\tvec2\tret = vec2(0.);\n    \n    if (uv.x == 0. || uv.y == 0. || uv.x== 1. || uv.y ==1.)\n        return (ret);\n    ret += texture(iChannel0, vec2(uv.x , uv.y) ).xy * 4.;\n    \n    ret += texture(iChannel0, vec2(uv.x -texel.x, uv.y) ).xy * 2.;\n    ret += texture(iChannel0, vec2(uv.x +texel.x, uv.y) ).xy * 2.;\n    ret += texture(iChannel0, vec2(uv.x , uv.y -texel.y) ).xy * 2.;\n    ret += texture(iChannel0, vec2(uv.x , uv.y +texel.y) ).xy * 2.;\n    \n    ret += texture(iChannel0, vec2(uv.x -texel.x, uv.y -texel.y) ).xy;\n    ret += texture(iChannel0, vec2(uv.x +texel.x, uv.y -texel.y) ).xy;\n    ret += texture(iChannel0, vec2(uv.x +texel.x, uv.y +texel.y) ).xy;\n    ret += texture(iChannel0, vec2(uv.x -texel.x, uv.y +texel.y) ).xy;\n    return (ret/16.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    texel = (1.)/iResolution.xy;\n    vec2 uv = (fragCoord.xy) / iResolution.xy;\n    \n    vec4\tret = texture(iChannel0, uv);\n    vec2\tab = ret.xy;\n\n     fragColor.x = clamp(ab.x - (1. * (laplacian_convolution(uv).x) - ab.x * ab.y * ab.y \n                                 + FEED_DEFAULT * (1. - ab.x)) ,-1.,1.);\n     fragColor.y = clamp(ab.y + (.5 * (laplacian_convolution(uv).y) + ab.x * ab.y * ab.y \n                                 - (FEED_DEFAULT + KILL_DEFAULT) * ab.y ),-1.,1.);\n\n    fragColor.z = 0.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}