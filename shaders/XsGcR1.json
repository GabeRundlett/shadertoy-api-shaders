{
    "Shader": {
        "info": {
            "date": "1528384542",
            "description": "I used this shadertoy to generate some of the diagrams for my Digital Dragons 2018 talk.\nWASD and mouse to move camera.\nChange #define CINEMA and TV in Buf C to change scene",
            "flags": 48,
            "hasliked": 0,
            "id": "XsGcR1",
            "likes": 4,
            "name": "Slide Path Trace TV",
            "published": 3,
            "tags": [
                "pathtrace"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 938
        },
        "renderpass": [
            {
                "code": "// Slide Path Trace TV\n// @P_Malin\n// https://www.shadertoy.com/view/XsGcR1\n\n// I used this shadertoy to generate some of the diagrams for my Digital Dragons 2018 talk.\n// https://www.youtube.com/watch?v=EN1Uk6vJqRw\n// https://research.activision.com/t5/Publications/HDR-in-Call-of-Duty/ba-p/10744846\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvec3 ApplyGrain( vec2 vPos, vec3 col, float amount )\n{\n    uint seed = uint( iTime * 213.456 ) * 12345u + uint(vPos.x) * 1256u + uint(vPos.y) * 432u;\n    seed = HashWang( seed );    \n    \n    float h = FRand( seed );\n    \n    col *= (h * 2.0 - 1.0) * amount + (1.0f -amount);\n    \n    return col;\n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 1.5;\n    \n    float fMaxLum = 100.0;\n    vColor /= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;\n    return vColor;\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy / iResolution.xy;\n    vec4 vSample = texelFetch( iChannel0, ivec2(vFragCoord), 0 );\n    vec3 vColor = vSample.rgb / vSample.a;\n    \n    //vFragColor = sqrt( 1.0 - exp2( vFragColor * -0.2 ) );\n    \n#if 1\n    float fShade = GetVignetting( vUV, 0.7, 2.0, 0.5 );\n    \n    vColor *= fShade;\n    \n    //if ( vUV.x > sin(iTime)*0.5+0.5 )\n    {\n    \tvColor = ColorGrade( vColor );\n    }\n    \n\tvColor = ApplyGrain( vFragCoord.xy, vColor, 0.15 );          \n#endif\n    \n    vColor = Tonemap( vColor * .5 );\n    \n    vFragColor = vec4( vColor, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.141592654f\n#define TAU (2.0 * PI)\n\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\n\n//  _   _           _       _____                 _   _                 \n// | | | | __ _ ___| |__   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ \n// | |_| |/ _` / __| '_ \\  | |_ | | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\n// |  _  | (_| \\__ \\ | | | |  _|| |_| | | | | (__| |_| | (_) | | | \\__ \\\n// |_| |_|\\__,_|___/_| |_| |_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/\n//                                                                      \n\nuint HashWang( uint a )\n{\n\ta = (a ^ 61u) ^ (a >> 16u);\n\ta = a + (a << 3u);\n\ta = a ^ (a >> 4u);\n\ta = a * 0x27d4eb2du;\n\ta = a ^ (a >> 15u);\n\treturn a;\n}\n\nuint HashHugo( uint n )\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;    \n    \n    return n;\n}\n\nuint Rand( inout uint seed )\n{\n    seed += 13u;\n    return HashWang( seed );\n}\n\nfloat FRand( inout uint seed )\n{\n    uint urand = Rand( seed );    \n    const uint mantissaMask = (0xffffffffu) >> ( 32u - 23u );\n    return fract(float(urand & mantissaMask) / float(mantissaMask)); \n    //return uintBitsToFloat( (urand & mantissaMask) | (127u << 23u) );\n}\n\nvec2 FRand2( inout uint seed )\n{\n    return vec2( FRand( seed ), FRand( seed ) );\n}\n\nvec3 FRand3( inout uint seed )\n{\n    return vec3( FRand( seed ), FRand( seed ), FRand( seed ) );\n}\n\nfloat SRand( inout uint seed )\n{\n    return FRand( seed ) * 2.0 - 1.0;\n}\n\nvec2 SRand2( inout uint seed )\n{\n    return FRand2( seed ) * 2.0 - 1.0;\n}\n\nvec3 SRand3( inout uint seed )\n{\n    return FRand3( seed ) * 2.0 - 1.0;\n}\n\n// From: Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\t//float n = p.x + p.y*57.0;\n\n\tfloat a = hash12(p);\n\tfloat b = hash12(p+vec2(1,0));\n\tfloat c = hash12(p+vec2(0,1));\n\tfloat d = hash12(p+vec2(1,1));\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n\n//  ____        _          ____  _                             \n// |  _ \\  __ _| |_ __ _  / ___|| |_ ___  _ __ __ _  __ _  ___ \n// | | | |/ _` | __/ _` | \\___ \\| __/ _ \\| '__/ _` |/ _` |/ _ \\\n// | |_| | (_| | || (_| |  ___) | || (_) | | | (_| | (_| |  __/\n// |____/ \\__,_|\\__\\__,_| |____/ \\__\\___/|_|  \\__,_|\\__, |\\___|\n//                                                  |___/      \n//\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n//\n//  ____       _        _   _             \n// |  _ \\ ___ | |_ __ _| |_(_) ___  _ __  \n// | |_) / _ \\| __/ _` | __| |/ _ \\| '_ \\ \n// |  _ < (_) | || (_| | |_| | (_) | | | |\n// |_| \\_\\___/ \\__\\__,_|\\__|_|\\___/|_| |_|\n//                                        \n//\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\n\n//   ___              _                  _             \n//  / _ \\ _   _  __ _| |_ ___ _ __ _ __ (_) ___  _ __  \n// | | | | | | |/ _` | __/ _ \\ '__| '_ \\| |/ _ \\| '_ \\ \n// | |_| | |_| | (_| | ||  __/ |  | | | | | (_) | | | |\n//  \\__\\_\\\\__,_|\\__,_|\\__\\___|_|  |_| |_|_|\\___/|_| |_|\n//                                                     \n//\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n//\n//  _  __          _                         _ \n// | |/ /___ _   _| |__   ___   __ _ _ __ __| |\n// | ' // _ \\ | | | '_ \\ / _ \\ / _` | '__/ _` |\n// | . \\  __/ |_| | |_) | (_) | (_| | | | (_| |\n// |_|\\_\\___|\\__, |_.__/ \\___/ \\__,_|_|  \\__,_|\n//           |___/                             \n//\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nconst int KEY_1 = \t49;\nconst int KEY_2 = \t50;\nconst int KEY_3 = \t51;\nconst int KEY_ENTER = 13;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_TAB\t= 9;\n\nbool Key_IsPressed( sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 0), 0 ).x > 0.0;    \n}\n\nbool Key_IsToggled(sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 2), 0 ).x > 0.0;    \n}\n\n\n//\n//   ____                               \n//  / ___|__ _ _ __ ___   ___ _ __ __ _ \n// | |   / _` | '_ ` _ \\ / _ \\ '__/ _` |\n// | |__| (_| | | | | | |  __/ | | (_| |\n//  \\____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n//                                      \n\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    vec3 vUp;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n    bool bStationary;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n    vec4 vUp = LoadVec4( sampler, addr + ivec2(2,0) );\n    cam.vUp = vUp.xyz;\n    \n    vec4 jitterDof = LoadVec4( sampler, addr + ivec2(3,0) );\n    cam.vJitter = jitterDof.xy;\n    cam.fPlaneInFocus = jitterDof.z;\n    cam.bStationary = jitterDof.w > 0.0;\n}\n\nvoid Cam_StoreState( ivec2 addr, const in CameraState cam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(2,0), vec4( cam.vUp, 0 ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(3,0), vec4( cam.vJitter, cam.fPlaneInFocus, cam.bStationary ? 1.0f : 0.0f ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross( cameraState.vUp, vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, float fAspectRatio )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= fAspectRatio;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const float fAspectRatio, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, fAspectRatio );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\n// fAspectRatio = iResolution.x / iResolution.y;\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow, float fAspectRatio )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x /= fAspectRatio;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\nfloat EncodeDepthAndObject( float depth, int objectId )\n{\n    //depth = max( 0.0, depth );\n    //objectId = max( 0, objectId + 1 );\n    //return exp2(-depth) + float(objectId);\n    return depth;\n}\n\nfloat DecodeDepthAndObjectId( float value, out int objectId )\n{\n    objectId = 0;\n    return max(0.0, value);\n    //objectId = int( floor( value ) ) - 1; \n    //return abs( -log2(fract(value)) );\n}\n\n\n// Misc\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t//return min(a,b);\n\t\n\t\n    //float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\n// http://www.cie.co.at/technical-work/technical-resources\nvec3 standardObserver1931[] =\n    vec3[] (\n    vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n    vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n    vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n    vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n    vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n    vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n    vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n    vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n    vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n    vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n    vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n    vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n    vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n    vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n    vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n    vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n    vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n    vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n    vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n    vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n    vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n    vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n    vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n    vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n    vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n    vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n    vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n    vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n    vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n    vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n    vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n    vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n    vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n    vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n    vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n    vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n    vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n    vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n    vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n    vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n    vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n    vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n    vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n    vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n    vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n    vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n    vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n    vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n    vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n    vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n    vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n    vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n    vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n    vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n    vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n    vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n    vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n    vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n    vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n    vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n    vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n    vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n    vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n    vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n    vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n    vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n    vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n    vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n    vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n    vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n    vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n    vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n    vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n    vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n    vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n    vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n    vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n    vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n    vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n    vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n    vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n);\nfloat standardObserver1931_w_min = 380.0f;\nfloat standardObserver1931_w_max = 780.0f;\nint standardObserver1931_length = 81;\n\nvec3 WavelengthToXYZLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);\n\n    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );\n}\n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 sRGBtoXYZ( vec3 RGB )\n{\n   // sRGB to XYZ\n   // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n   mat3 m = mat3(  \t0.4124564,  0.3575761, 0.1804375,\n \t\t\t\t\t0.2126729,  0.7151522, 0.0721750,\n \t\t\t\t\t0.0193339,  0.1191920, 0.9503041 );\n    \n    \n    return RGB * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    //return xyzFit_1931( f ) * mXYZtoSRGB;\n    \n    return WavelengthToXYZLinear( f );\n}\n\n\nstruct Chromaticities\n{\n    vec2 R, G, B, W;\n};\n    \nvec3 CIE_xy_to_xyz( vec2 xy )\n{\n    return vec3( xy, 1.0f - xy.x - xy.y );\n}\n\nvec3 CIE_xyY_to_XYZ( vec3 CIE_xyY )\n{\n    float x = CIE_xyY[0];\n    float y = CIE_xyY[1];\n    float Y = CIE_xyY[2];\n    \n    float X = (Y / y) * x;\n    float Z = (Y / y) * (1.0 - x - y);\n        \n\treturn vec3( X, Y, Z );        \n}\n\nvec3 CIE_XYZ_to_xyY( vec3 CIE_XYZ )\n{\n    float X = CIE_XYZ[0];\n    float Y = CIE_XYZ[1];\n    float Z = CIE_XYZ[2];\n    \n    float N = X + Y + Z;\n    \n    float x = X / N;\n    float y = Y / N;\n    float z = Z / N;\n    \n    return vec3(x,y,z);\n}\n\nChromaticities Primaries_Rec709 =\nChromaticities(\n        vec2( 0.6400, 0.3300 ),\t// R\n        vec2( 0.3000, 0.6000 ),\t// G\n        vec2( 0.1500, 0.0600 ), \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_Rec2020 =\nChromaticities(\n        vec2( 0.708,  0.292 ),\t// R\n        vec2( 0.170,  0.797 ),\t// G\n        vec2( 0.131,  0.046 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nChromaticities Primaries_DCI_P3_D65 =\nChromaticities(\n        vec2( 0.680,  0.320 ),\t// R\n        vec2( 0.265,  0.690 ),\t// G\n        vec2( 0.150,  0.060 ),  \t// B\n        vec2( 0.3127, 0.3290 ) );\t// W\n\nmat3 RGBtoXYZ( Chromaticities chroma )\n{\n    // xyz is a projection of XYZ co-ordinates onto to the plane x+y+z = 1\n    // so we can reconstruct 'z' from x and y\n    \n    vec3 R = CIE_xy_to_xyz( chroma.R );\n    vec3 G = CIE_xy_to_xyz( chroma.G );\n    vec3 B = CIE_xy_to_xyz( chroma.B );\n    vec3 W = CIE_xy_to_xyz( chroma.W );\n    \n    // We want vectors in the directions R, G and B to form the basis of\n    // our matrix...\n    \n\tmat3 mPrimaries = mat3 ( R, G, B );\n    \n    // but we want to scale R,G and B so they result in the\n    // direction W when the matrix is multiplied by (1,1,1)\n    \n    vec3 W_XYZ = W / W.y;\n\tvec3 vScale = inverse( mPrimaries ) * W_XYZ;\n    \n    return transpose( mat3( R * vScale.x, G * vScale.y, B * vScale.z ) );\n}\n\nmat3 XYZtoRGB( Chromaticities chroma )\n{\n    return inverse( RGBtoXYZ(chroma) );\n}\n\nfloat BlackBody( float t, float w_nm )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}\n\n\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n#if 1\n    // distance bound\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n#else\n    // correct distance\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n#endif\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nvec3 DomainRotateSymmetry( vec3 vPos, const in float fSteps )\n{\n\tfloat angle = atan( vPos.x, vPos.z );\n\t\n\tfloat fScale = fSteps / (PI * 2.0);\n\tfloat steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\t\n\tfloat s = sin(-steppedAngle);\n\tfloat c = cos(-steppedAngle);\n\t\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, \n\t\t\t     vPos.y,\n\t\t\t     -s * vPos.x + c * vPos.z);\n\t\n\treturn vResult;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define iChannelKeyboard iChannel1\n\n#define FLY_CAM_INVERT_Y 1\n\n//    _____ _          ____                \n//   |  ___| |_   _   / ___|__ _ _ __ ___  \n//   | |_  | | | | | | |   / _` | '_ ` _ \\ \n//   |  _| | | |_| | | |__| (_| | | | | | |\n//   |_|   |_|\\__, |  \\____\\__,_|_| |_| |_|\n//            |___/                        \n//\n\nstruct FlyCamState\n{\n    vec3 vPos;\n    vec3 vAngles;\n    vec4 vPrevMouse;\n};\n\nvoid FlyCam_LoadState( out FlyCamState flyCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    flyCam.vPos = vPos.xyz;\n    vec4 vAngles = LoadVec4( sampler, addr + ivec2(1,0) );\n    flyCam.vAngles = vAngles.xyz;\n    vec4 vPrevMouse = LoadVec4( sampler, addr + ivec2(2,0) );    \n    flyCam.vPrevMouse = vPrevMouse;\n}\n\nvoid FlyCam_StoreState( ivec2 addr, const in FlyCamState flyCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( flyCam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( flyCam.vAngles, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( iMouse ), fragColor, fragCoord );\n}\n\nvoid FlyCam_GetAxes( FlyCamState flyCam, out vec3 vRight, out vec3 vUp, out vec3 vForwards )\n{\n    vec3 vAngles = flyCam.vAngles;\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(vAngles.x), sin(vAngles.x), \n                     0.0, -sin(vAngles.x), cos(vAngles.x));\n    \n    mat3 rotY = mat3(cos(vAngles.y), 0.0, -sin(vAngles.y), \n                     0.0, 1.0, 0.0, \n                     sin(vAngles.y), 0.0, cos(vAngles.y));    \n\n    mat3 rotZ = mat3(cos(vAngles.z), sin(vAngles.z), 0.0,\n                     -sin(vAngles.z), cos(vAngles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    mat3 m = rotY * rotX * rotZ;\n    \n    vRight = m[0];\n    vUp = m[1];\n    vForwards = m[2];\n}\n\nbool FlyCam_Update( inout FlyCamState flyCam, vec3 vStartPos, vec3 vStartAngles )\n{   \n    bool bMoving = false;\n    //float fMoveSpeed = 0.01;\n    float fMoveSpeed = iTimeDelta * 0.5;\n    float fRotateSpeed = 3.0;\n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_SHIFT ) )\n    {\n        fMoveSpeed *= 4.0;\n    }\n    \n    if ( iFrame == 0 )\n    {\n        flyCam.vPos = vStartPos;\n        flyCam.vAngles = vStartAngles;\n        flyCam.vPrevMouse = iMouse;\n    }\n      \n    vec3 vMove = vec3(0.0);\n        \n    if ( Key_IsPressed( iChannelKeyboard, KEY_W ) )\n    {\n        vMove.z += fMoveSpeed;\n        bMoving = true;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_S ) )\n    {\n        vMove.z -= fMoveSpeed;\n        bMoving = true;\n    }\n\n    if ( Key_IsPressed( iChannelKeyboard, KEY_A ) )\n    {\n        vMove.x -= fMoveSpeed;\n        bMoving = true;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_D ) )\n    {\n        vMove.x += fMoveSpeed;\n        bMoving = true;\n    }\n    \n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n        \n    flyCam.vPos += vRight * vMove.x + vForwards * vMove.z;\n    \n    vec3 vRotate = vec3(0);\n    \n    bool bMouseDown = iMouse.z > 0.0;\n    bool bMouseWasDown = flyCam.vPrevMouse.z > 0.0;\n    \n    if ( bMouseDown && bMouseWasDown )\n    {\n    \tvRotate.yx += ((iMouse.xy - flyCam.vPrevMouse.xy) / iResolution.xy) * fRotateSpeed;\n        \n        if( length(vRotate.yx) > 0.0 )\n        {\n        \tbMoving = true;\n        }\n    }\n    \n#if FLY_CAM_INVERT_Y    \n    vRotate.x *= -1.0;\n#endif    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_E ) )\n    {\n        vRotate.z -= fRotateSpeed * 0.01;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_Q ) )\n    {\n        vRotate.z += fRotateSpeed * 0.01;\n    }\n        \n\tflyCam.vAngles += vRotate;\n    \n    flyCam.vAngles.x = clamp( flyCam.vAngles.x, -PI * .5, PI * .5 );\n    \n    return bMoving;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    FlyCamState flyCam;\n    FlyCam_LoadState( flyCam, iChannel0, ivec2(4, 0));\n    \n    vec4 vPrevResolution = texelFetch( iChannel0, ivec2(7,0), 0);\n\n    float fPathCount = vPrevResolution.z;\n    if ( iTimeDelta < 1.0 / 40.0 )\n    {\n        fPathCount += 1.0;\n    }\n\telse\n    if ( iTimeDelta > 1.0 / 50.0 )\n\t{\n        fPathCount -= 1.0;\n\t}\n    \n    fPathCount = clamp( fPathCount, 1.0, 30.0 );\n\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n\n    if ( fragCoord.x > 8.0 || fragCoord.y > 2.0 )\n    {\n        discard;\n    }\n    \n    vec3 vStartPos = vec3(4,0.1,3);\n    vec3 vStartAngles = vec3(-0.1, PI + 0.5, -0.05);\n    \n    bool bMoving = FlyCam_Update( flyCam, vStartPos, vStartAngles );\n    \n    CameraState cam;\n\tCam_LoadState( cam, iChannel0, ivec2(0) );\n    \n#if 0\n    {\n        float fDist = 0.01 + 3.0 * (iMouse.y / iResolution.y);\n\n        float fAngle = (iMouse.x / iResolution.x) * radians(360.0);\n    \t//float fElevation = (iMouse.y / iResolution.y) * radians(90.0);\n    \tfloat fElevation = 0.15f * radians(90.0);    \n\n        if ( iMouse.z <= 0.0 )\n        {\n            fDist = 2.0;\n            fAngle = 3.5f;\n            fElevation = 0.2f;\n        }\n        \n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0,0.05,0.0);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 20.0 / (1.0 + fDist * 0.5);\n        cam.vUp = vec3(0,1,0);\n    \tvec3 vFocus = vec3(0,0.05,0.0);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif    \n    \n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n    \n    cam.vPos = flyCam.vPos;\n    cam.vTarget = flyCam.vPos + vForwards;\n    cam.vUp = vUp;\n    cam.fFov = 30.0;\n    cam.fPlaneInFocus = 5.0;    \n    \n    cam.bStationary = !bMoving;\n    \n    if ( any(notEqual(iResolution.xy, vPrevResolution.xy)))\n    {\n        cam.bStationary = false;\n    }\n    \n    if ( Key_IsToggled( iChannel1, KEY_SPACE ) )\n    {\n        cam.bStationary = true;\n    }\n    \n    Cam_StoreState( ivec2(0), cam, fragColor, ivec2(fragCoord.xy) );   \n    FlyCam_StoreState( ivec2(4,0), flyCam, fragColor, ivec2(fragCoord));    \n    if ( all(equal(ivec2(fragCoord.xy), ivec2(7,0))))\n    {\n        fragColor.xyz = vec3(iResolution.xy, fPathCount);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"generic scene\"\n\n\n\n\n//     _____                       _____                _           _             \n//    / ____|                     |  __ \\              | |         (_)            \n//   | (___   ___ ___ _ __   ___  | |__) |___ _ __   __| | ___ _ __ _ _ __   __ _ \n//    \\___ \\ / __/ _ \\ '_ \\ / _ \\ |  _  // _ \\ '_ \\ / _` |/ _ \\ '__| | '_ \\ / _` |\n//    ____) | (_|  __/ | | |  __/ | | \\ \\  __/ | | | (_| |  __/ |  | | | | | (_| |\n//   |_____/ \\___\\___|_| |_|\\___| |_|  \\_\\___|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |\n//                                                                           __/ |\n//                                                                          |___/ \n\n#define FLY_CAM_INVERT_Y 1\n\n#define ENABLE_TAA_JITTER 1\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define iChannelCurr \t\tiChannel0\n#define iChannelKeyboard \tiChannel3\n\n#define CAMERA_B\n\n//    _____ _          ____                \n//   |  ___| |_   _   / ___|__ _ _ __ ___  \n//   | |_  | | | | | | |   / _` | '_ ` _ \\ \n//   |  _| | | |_| | | |__| (_| | | | | | |\n//   |_|   |_|\\__, |  \\____\\__,_|_| |_| |_|\n//            |___/                        \n//\n\nstruct FlyCamState\n{\n    vec3 vPos;\n    vec3 vAngles;\n    vec4 vPrevMouse;\n};\n\nvoid FlyCam_LoadState( out FlyCamState flyCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    flyCam.vPos = vPos.xyz;\n    vec4 vAngles = LoadVec4( sampler, addr + ivec2(1,0) );\n    flyCam.vAngles = vAngles.xyz;\n    vec4 vPrevMouse = LoadVec4( sampler, addr + ivec2(2,0) );    \n    flyCam.vPrevMouse = vPrevMouse;\n}\n\nvoid FlyCam_StoreState( ivec2 addr, const in FlyCamState flyCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( flyCam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( flyCam.vAngles, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( iMouse ), fragColor, fragCoord );\n}\n\nvoid FlyCam_GetAxes( FlyCamState flyCam, out vec3 vRight, out vec3 vUp, out vec3 vForwards )\n{\n    vec3 vAngles = flyCam.vAngles;\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(vAngles.x), sin(vAngles.x), \n                     0.0, -sin(vAngles.x), cos(vAngles.x));\n    \n    mat3 rotY = mat3(cos(vAngles.y), 0.0, -sin(vAngles.y), \n                     0.0, 1.0, 0.0, \n                     sin(vAngles.y), 0.0, cos(vAngles.y));    \n\n    mat3 rotZ = mat3(cos(vAngles.z), sin(vAngles.z), 0.0,\n                     -sin(vAngles.z), cos(vAngles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    mat3 m = rotY * rotX * rotZ;\n    \n    vRight = m[0];\n    vUp = m[1];\n    vForwards = m[2];\n}\n\nbool FlyCam_Update( inout FlyCamState flyCam, vec3 vStartPos, vec3 vStartAngles )\n{    \n    //if ( iFrame == 0 )\n    {\n        flyCam.vPos = vStartPos;\n        flyCam.vAngles = vStartAngles;\n        flyCam.vPrevMouse = iMouse;\n        return ( iFrame < 200 );\n    }\n    \n    //float fMoveSpeed = 0.01;\n    float fMoveSpeed = iTimeDelta * 0.5;\n    float fRotateSpeed = 3.0;\n    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_SHIFT ) )\n    {\n        fMoveSpeed *= 4.0;\n    }\n    \n      \n    vec3 vMove = vec3(0.0);\n        \n    if ( Key_IsPressed( iChannelKeyboard, KEY_W ) )\n    {\n        vMove.z += fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_S ) )\n    {\n        vMove.z -= fMoveSpeed;\n    }\n\n    if ( Key_IsPressed( iChannelKeyboard, KEY_A ) )\n    {\n        vMove.x -= fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_D ) )\n    {\n        vMove.x += fMoveSpeed;\n    }\n    \n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n        \n    flyCam.vPos += vRight * vMove.x + vForwards * vMove.z;\n    \n    vec3 vRotate = vec3(0);\n    \n    bool bMouseDown = iMouse.z > 0.0;\n    bool bMouseWasDown = flyCam.vPrevMouse.z > 0.0;\n    \n    if ( bMouseDown && bMouseWasDown )\n    {\n    \tvRotate.yx += ((iMouse.xy - flyCam.vPrevMouse.xy) / iResolution.xy) * fRotateSpeed;\n    }\n    \n#if FLY_CAM_INVERT_Y    \n    vRotate.x *= -1.0;\n#endif    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_E ) )\n    {\n        vRotate.z -= fRotateSpeed * 0.01;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_Q ) )\n    {\n        vRotate.z += fRotateSpeed * 0.01;\n    }\n        \n\tflyCam.vAngles += vRotate;\n    \n    flyCam.vAngles.x = clamp( flyCam.vAngles.x, -PI * .5, PI * .5 );\n    \n    if ( iFrame < 5 || length(vMove) > 0.0 || length( vRotate ) > 0.0 )\n    {\n        return true;\n    }\n\n    return false;\n}\n\n// PDF\n\nfloat SpecParamFromGloss( float gloss )\n{\n    float PB_GGX_MAX_SPEC_POWER=32.0;\n\tfloat exponent = pow( 2.0f, gloss * PB_GGX_MAX_SPEC_POWER );\n\treturn 2.0f  / ( 2.0f + exponent ); // matches alpha^2 for GGX physically-based shader\n}\n\n\nfloat GGX_D( float NdotH , float alpha2 )\n{\n\tfloat denom = ( NdotH * NdotH ) * ( alpha2 - 1.0f ) + 1.0f;\n\treturn alpha2 / ( denom * denom );\t\n}\n\n\nfloat GGX_PDF( const float NdotH, const in float alpha2 )\n{\n\t//const float LdotH = NdotH;\n\t//return GGX_D( NdotH, alpha2 ) * NdotH  / (4.0f * PI * LdotH);\n\n\t// simplified as NdotH == LdotH\n\treturn GGX_D( NdotH, alpha2 ) / (4.0f * PI);\n}\n\n// Z is preserved, Y may be modified to make matrix orthogonal\nmat3 OrthoNormalMatrixFromZY( vec3 zDirIn, vec3 yHintDir )\n{\n\tvec3 xDir = normalize( cross( zDirIn, yHintDir ) );\n\tvec3 yDir = normalize( cross( xDir, zDirIn ) );\n\tvec3 zDir = normalize( zDirIn );\n\n\tmat3 result = mat3( xDir, yDir, zDir );\n\t\t\n\treturn result;\n}\n\n\nmat3 OrthoNormalMatrixFromZ( vec3 zDir )\n{\n\tif ( abs( zDir.y ) < 0.999f )\n\t{\n\t\tvec3 yAxis = vec3( 0.0f, 1.0f, 0.0f );\n\t\treturn OrthoNormalMatrixFromZY( zDir, yAxis );\n\t}\n\telse\n\t{\n\t\tvec3 xAxis = vec3( 1.0f, 0.0f, 0.0f );\n\t\treturn OrthoNormalMatrixFromZY( zDir, xAxis );\n\t}\n}\n\nvec3 SphericalToCartesianDirection( vec2 spherical )\n{\n\tfloat theta = spherical.x;\n\tfloat phi = spherical.y;\n\tfloat sinTheta = sin( theta );\n\n\treturn vec3( cos( phi ) * sinTheta, sin( phi ) * sinTheta, cos( theta ) );\n}\n\n// Transform from a uniform 2D 0->1 sample space to a spherical co-ordiante with a probability distribution that represents important GGX half-angle vector locations\nvec2 ImportanceSampleGGXTransform( const vec2 uniformSamplePos, const in float alpha2 )\n{\n\t// [Karis2013]  Real Shading in Unreal Engine 4\n\t// http://blog.tobias-franke.eu/2014/03/30/notes_on_importance_sampling.html\n\n\tfloat theta = acos( sqrt( (1.0f - uniformSamplePos.y) /\n\t\t\t\t\t\t\t( (alpha2 - 1.0f) * uniformSamplePos.y + 1.0f )\n\t\t\t\t\t\t\t) );\n\n\tfloat phi = 2.0f * PI * uniformSamplePos.x;\n\n\treturn vec2( theta, phi );\n}\n\n// Transform from a uniform 2D 0->1 sample space to a direction vector with a probability distribution that represents important GGX half-angle vector locations\nvec3 ImportanceSampleGGX( vec2 uniformSamplePos, vec3 N, float alpha2 )\n{\n\tvec2 sphereSamplePos = ImportanceSampleGGXTransform( uniformSamplePos, alpha2 );\n\n\tvec3 specSpaceH = SphericalToCartesianDirection( sphereSamplePos );\n\t\n\tmat3 specToCubeMat = OrthoNormalMatrixFromZ( N );\n\n\treturn specToCubeMat * specSpaceH;\n}\n\n\n\n//    ____                      \n//   / ___|  ___ ___ _ __   ___ \n//   \\___ \\ / __/ _ \\ '_ \\ / _ \\\n//    ___) | (_|  __/ | | |  __/\n//   |____/ \\___\\___|_| |_|\\___|\n//                              \n\nfloat GetSceneTime()\n{\n    //return iTime;\n    return 1.0;\n}\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nSceneResult Scene_Union( SceneResult a, SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        return b;\n    }\n    return a;\n}\n\n    \nSceneResult Scene_Subtract( SceneResult a, SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        b.fDist = -b.fDist;\n        return b;\n    }\n    \n    return a;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nSceneResult Scene_SmoothSubtract( SceneResult a, SceneResult b, float k )\n{    \n    float fA = a.fDist;\n    float fB = -b.fDist;        \n    \n    float fC = -smin( -fA, -fB, k );\n    \n    a.fDist = fC;\n    b.fDist = fC;\n    \n    if ( fA < (fB + k) )\n    {        \n        return b;\n    }\n    \n    return a;\n}\n\nSceneResult Scene_GetDistance( vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 256;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    //return 1.0;\n    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.1*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );\n}\n\n//    _     _       _     _   _             \n//   | |   (_) __ _| |__ | |_(_)_ __   __ _ \n//   | |   | |/ _` | '_ \\| __| | '_ \\ / _` |\n//   | |___| | (_| | | | | |_| | | | | (_| |\n//   |_____|_|\\__, |_| |_|\\__|_|_| |_|\\__, |\n//            |___/                   |___/ \n//                                          \n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fGloss;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat AlphaSqrFromGloss( const in float gloss )\n{\n\tfloat MAX_SPEC = 10.0;\n\treturn 2.0f  / ( 2.0f + exp2( gloss * MAX_SPEC) );\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\t// D\n\n\tfloat alphaSqr = AlphaSqrFromGloss( surface.fGloss );\n    float alpha = sqrt( alphaSqr );\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (PI * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat Light_SpotFactor( vec3 vLightDir, vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle )   \n{\n    float fSpotDot = dot( vLightDir, -vSpotDir );\n    \n    float fTheta = acos(fSpotDot);\n\n    float fAngularAttenuation = clamp( (fTheta - fSpotOuterAngle) / (fSpotInnerAngle - fSpotOuterAngle), 0.0, 1.0 );\n    \n    float fShapeT = fTheta / fSpotOuterAngle;\n    fShapeT = fShapeT * fShapeT * fShapeT;\n    float fShape = (sin( (1.0 - fShapeT) * 10.0));\n    fShape = fShape * fShape * (fShapeT) + (1.0 - fShapeT);\n    \n    //return fShape;\n    return fAngularAttenuation * fShape;\n}\n    \n\nvoid Light_AddSpot( inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const vec3 vLightPos, const vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle, vec3 vLightColour )\n{\n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n    \n    fShadowFactor *= Light_SpotFactor( vLightDir, vSpotDir, fSpotInnerAngle, fSpotOuterAngle );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);    \n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvec3 Env_GetDirectionalLightFlare(const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\t//float kSpreadPower = 5.0;\n\t//return vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n    \n    return exp2( vLightColour * fDirDot * 0.1);\n}\n\n//    ____                _           _             \n//   |  _ \\ ___ _ __   __| | ___ _ __(_)_ __   __ _ \n//   | |_) / _ \\ '_ \\ / _` |/ _ \\ '__| | '_ \\ / _` |\n//   |  _ <  __/ | | | (_| |  __/ |  | | | | | (_| |\n//   |_| \\_\\___|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |\n//                                            |___/ \n//                                                  \n\nvec4 Env_GetSkyColor( vec3 vViewPos, vec3 vViewDir, bool bDrawSun );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    float fStartDist = 0.0f;\n    float fMaxDist = kMaxTraceDist;\n    \n    vec3 vRemaining = vec3(1.0);\n    \n\tfor( int iPassIndex=0; iPassIndex < 3; iPassIndex++ )\n    {\n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );\n\n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 vColor = vec3(0);\n        vec3 vReflectAmount = vec3(0);\n        \n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            bool bDrawSun = (iPassIndex == 0);\n            vColor = Env_GetSkyColor( vRayOrigin, vRayDir, bDrawSun ).rgb;\n            float fDist = abs(length(vRayDir.xz) * 20.0 / vRayDir.y);\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, fDist );\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n\t\t\tvReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fGloss );\n\t\t\t\n\t\t\tvColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); \n            \n            vec3 vReflectRayOrigin = surfaceInfo.vPos;\n                        \n            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n\n            /*\n            vec3 vReflectRayDir;\n            {\n                float alpha2 = SpecParamFromGloss(surfaceInfo.fGloss);\n                \n                vec2 vRand = hash23( vRayOrigin + vRayDir + iTime );\n\n                vec3 N = surfaceInfo.vBumpNormal;\n                vec3 V = -vRayDir;\n                vec3 H = ImportanceSampleGGX( vRand, N, alpha2 );        \n\n\t\t\t\tvReflectRayDir = reflect( -V, H );                \n            }\n\t\t\t*/\n            \n            \n            fStartDist = 0.001 / max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); \n\n            vColor += surfaceLighting.vSpecular * vReflectAmount;            \n\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n\t\t\tvColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            vRayOrigin = vReflectRayOrigin;\n            vRayDir = vReflectRayDir;\n        }\n        \n        vResultColor += vColor * vRemaining;\n        vRemaining *= vReflectAmount;        \n    }\n \n    return vec4( vResultColor, EncodeDepthAndObject( firstTraceResult.fDist, firstTraceResult.iObjectId ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n//    ____                        ____                      _       _   _             \n//   / ___|  ___ ___ _ __   ___  |  _ \\  ___  ___  ___ _ __(_)_ __ | |_(_) ___  _ __  \n//   \\___ \\ / __/ _ \\ '_ \\ / _ \\ | | | |/ _ \\/ __|/ __| '__| | '_ \\| __| |/ _ \\| '_ \\ \n//    ___) | (_|  __/ | | |  __/ | |_| |  __/\\__ \\ (__| |  | | |_) | |_| | (_) | | | |\n//   |____/ \\___\\___|_| |_|\\___| |____/ \\___||___/\\___|_|  |_| .__/ \\__|_|\\___/|_| |_|\n//                                                           |_|                      \n//\n\n// Materials\n\nint MAT_DEFAULT = 0,\n    MAT_GRASS = 1,\n    MAT_CAMERA_BODY = 2,\n    MAT_CAMERA_LENS = 3,\n    MAT_CAMERA_BARREL = 4,\n    MAT_CHROME = 5;\n    \n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.02 );\n    surfaceInfo.fGloss = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n        \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n        surfaceInfo.vAlbedo = vec3(0.75, 0.75, 0.75); \n\t    surfaceInfo.fGloss = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n    }\n\n    if ( traceResult.iObjectId == MAT_GRASS )\n    {\n        surfaceInfo.vAlbedo = vec3(0.15, 0.3, 0.02); \n        \n        //float fShade = textureLod( iChannel1, traceResult.vUVW.zx * 0.5, 0.0 ).r;\n        float fShade = FBM( traceResult.vUVW.zx * 4.0, 0.9 );\n                \n        fShade = sqrt( 1.0 - fShade ) * 0.5 + 0.5;\n        \n        float fPattern = FBM( traceResult.vUVW.zx * vec2(.1,3) * 4.0, 0.8 );\n        //float fPattern = textureLod( iChannel1, traceResult.vUVW.zx * vec2(.1,3), 0.0 ).r;\n        \n        fShade *= 0.5 + 0.5 * fPattern;\n                \n        surfaceInfo.vAlbedo *= fShade;\n\t    surfaceInfo.fGloss = 0.7 * fShade;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n    }\n    \n    if ( traceResult.iObjectId == MAT_CAMERA_BODY )\n    {        \n        surfaceInfo.vAlbedo = vec3( 0.03 );                \n        \n#ifdef CAMERA_B\n        surfaceInfo.vAlbedo = vec3( 0.05 ); \n#endif        \n\t\tsurfaceInfo.fGloss = 0.8;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );        \n    }\n    \n    if ( traceResult.iObjectId == MAT_CAMERA_LENS )\n    {\n        surfaceInfo.vAlbedo = vec3( 0.05 ); \n\t    surfaceInfo.fGloss = 0.95;\n    \tsurfaceInfo.vR0 = vec3( 0.1 );        \n    }    \n\n    if ( traceResult.iObjectId == MAT_CAMERA_BARREL )\n    {\n        surfaceInfo.vAlbedo = vec3( 0.02 ); \n\t    surfaceInfo.fGloss = 0.1;\n    \tsurfaceInfo.vR0 = vec3( 0.02 );        \n    }    \n\n    if ( traceResult.iObjectId == MAT_CHROME )\n    {\n        surfaceInfo.vAlbedo = vec3( 0.02 ); \n\t    surfaceInfo.fGloss = 0.5;\n    \tsurfaceInfo.vR0 = vec3( 0.9 );        \n    }   \n    \n    /*\n    if ( traceResult.iObjectId == MAT_CAMERA_BODY )\n    {        \n        LayoutStyle style = LayoutStyle_Default();\n        RenderStyle renderStyle = RenderStyle_Default( vec3(0.2, 0.2, 0.5) );\n\n        vec2 vPrintUV = traceResult.vUVW.zy;//traceResult.vUVW.yz;\n        vPrintUV.x = 1.0f - vPrintUV.x;\n        vPrintUV.y = 1.0f - vPrintUV.y;\n        PrintState state = PrintState_InitCanvas( vPrintUV, vec2(0.001f) );\n        \n        //style.vSize = vec2(0.03, 0.05);\n        style.vSize = vec2(0.08, 0.08);\n\n        vec2 vPos = vec2(0.895, -0.025 );\n        MoveTo( state, vec2(vPos.x, 1.0 - vPos.y ) );\n\n#ifdef CAMERA_B        \n        uint str[] = uint[] ( _C, _a, _m, _SP, _B );\n#else\n        uint str[] = uint[] ( _C, _a, _m, _SP, _A );\n#endif\n        \n        ARRAY_PRINT( state, style, iChannel2, str );   \n        RenderFont( state, style, renderStyle, surfaceInfo.vAlbedo );\n        \n        \n    }\n*/\n    \n        \n    return surfaceInfo;\n}\n\n// Scene Description\n\n\n\nSceneResult Scene_GetDistanceCamera( vec3 vPos )\n{\n    SceneResult result;\n    \n    vec3 vBodySize = vec3(0.08, 0.1, 0.2);\n    float fBevel = 0.01;\n#ifdef CAMERA_B\n    vBodySize.z *= 0.8;\n    fBevel = 0.002;\n#endif\n    \n    \n    \n    float fD1 = udRoundBox( vPos, vBodySize, fBevel);\n\n    \n    vec3 vEyePiecePos = vec3(0,0.05, - vBodySize.z -0.03);\n    float fD2 = udRoundBox( vPos - vEyePiecePos, vec3(0.04, 0.02, 0.02), 0.01);\n    float fD3 = udRoundBox( vPos - vEyePiecePos - vec3(0,0,-0.03), vec3(0.04, 0.02, 0.02) - 0.005, 0.01);\n    \n    SceneResult lensResult;\n    lensResult.fDist = fD3;\n    lensResult.iObjectId = MAT_CAMERA_LENS;\n    lensResult.vUVW = vPos;\n    \n    \n    result.fDist = min( fD1, fD2 );\n\n    // side bit\n    \n    vec3 vSideBitSize = vec3(0.01, 0.07, 0.1);\n    vec3 vTopBitSize = vec3(0.05, 0.025, 0.025);\n    vec3 vTopBitOffset = vec3(0.0,0,0.1);\n    \n#ifdef CAMERA_B\n    vSideBitSize.y *= 0.7;\n    vSideBitSize.z *= 1.1;\n\n    vTopBitSize = vec3(0.05, 0.025, 0.05);\n    vTopBitOffset = vec3(0.0,0,-0.1);    \n#endif    \n    float fD4 = udRoundBox( vPos - vec3(vBodySize.x,0,0), vSideBitSize, fBevel * 2.0);    \n    result.fDist = min( result.fDist, fD4 );\n\n    // top bit\n    float fTop = udRoundBox( vPos - vec3(0,vBodySize.y,0)-vTopBitOffset, vTopBitSize, fBevel * 2.0);    \n    result.fDist = min( result.fDist, fTop );\n    \n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_CAMERA_BODY;\n\n    vec3 vBarrelDomain = (vPos - vec3(0,0,vBodySize.z)).xzy;\n    float fD5 = sdCylinder( vBarrelDomain, vec2(0.06, 0.1) );\n    result.fDist = min( result.fDist, fD5 );\n    float fD6 = sdCylinder( vBarrelDomain - vec3(0,0.1,0), vec2(0.08, 0.05) );\n    \n#ifndef CAMERA_B\n    fD6 = sdConeSection( vBarrelDomain - vec3(0,0.1,0), 0.05, 0.07, 0.09 );\n#endif\n    \n    result.fDist = min( result.fDist, fD6 );\n\n    // tripod etc.\n    float fT1 = sdCylinder( vPos - vec3(0,-0.1,0), vec2(0.03, 0.2) );\n    result.fDist = min( result.fDist, fT1 );\n\n    float fT2 = sdCylinder( vPos - vec3(0,-0.2,0), vec2(0.05, 0.01) );\n    result.fDist = min( result.fDist, fT2 );\n\n    vec3 vLegDomain = vPos - vec3(0,-0.25,0 );\n    vLegDomain = DomainRotateSymmetry( vLegDomain, 3.0 );\n    float fL1 = sdCapsule( vLegDomain, vec3(0), vec3(0, -1, 0.4), 0.01 );            \n    result.fDist = min( result.fDist, fL1 );\n    \n    result = Scene_Subtract( result, lensResult );\n    \n#ifndef CAMERA_B    \n    if ( vPos.z >= 0.249 )\n    {\n        result.iObjectId = MAT_CAMERA_BARREL;\n    }\n#endif\n    \n    if ( vPos.y < -0.3 )\n    {\n         result.iObjectId = MAT_CHROME;\n    }\n    \n    \n    return result;\n}\n\n    \nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n\n    float fFloorDist = vPos.y;\n    \n    vec2 vUV = vPos.xz - 100.0;\n    vUV.x *= 0.8;\n    \n    float fFreq = 0.125;\n    float fAmp = 2.0;\n    for ( int i=0; i<3; i++ )\n    {\n    \tfFloorDist += (sin( vUV.x * fFreq ) + sin( vUV.y * fFreq)) * fAmp;\n        fFreq *= 2.0;\n        fAmp *= 0.25;\n    }\n    \n    result.fDist = fFloorDist; \n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_GRASS;\n    \n    \n    SceneResult resultCamera = Scene_GetDistanceCamera( vec3( -vPos.z, vPos.y, -vPos.x) );\n    \n    result = Scene_Union( result, resultCamera );\n    \n    return result;\n}\n\n\n// Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, -0.5));\nvec3 g_vSunColor = vec3(1, 0.95, 0.8) * 10.0;\nvec3 g_vAmbientColor = vec3(0.5, 0.6, 1.0) * 1.0;\n\nfloat Env_GetCloudCover( vec2 vCloudUV );\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    float fCloudCover = Env_GetCloudCover( -surfaceInfo.vPos.xz * 0.0003 );\n    \n    fCloudCover = clamp( 1.0 - fCloudCover / 2.0, 0.0, 1.0);\n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor * fCloudCover );\n    \n    //vec3 vSpotPos, vSpotTarget;\n    //GetSpotState(vSpotPos, vSpotTarget);\n    //vec3 vSpotDir = normalize( vSpotTarget - vSpotPos );\n    \n    //vec3 vLightCol = GetSpotColor();\n    \n    //Light_AddSpot( surfaceLighting, surfaceInfo, vViewDir, vSpotPos, vSpotDir, radians(10.0), radians(60.0), vLightCol * 0.02 );\n    //Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vSpotPos, vLightCol * 0.001 );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec3 Env_GetSkyGradient( vec3 vViewPos, vec3 vViewDir )\n{\n    vec3 vSkyA = vec3(0.001,0.2,1);\n    vec3 vSkyB = vec3(0.01,0.2,1);\n    \n    float fSkyBlend = clamp( vViewDir.y, 0.0, 1.0 );\n    \n    return mix( vSkyA, vSkyB, fSkyBlend ) * 1.5;\n}\n\nfloat Env_GetCloudCover( vec2 vCloudUV )\n{\n\tvCloudUV += GetSceneTime() * 0.01;\n    \n\tvec3 vCloud = 1.0 - textureLod(iChannel1, vCloudUV, 0.0).rgb;    \n\t\n\tfloat fBlend = vCloud.r;\n    \n    float fCover = 0.2;\n    \n    fBlend = clamp( (fBlend - fCover) / (1.0 - fCover), 0.0, 1.0);\n    \n    fBlend = fBlend * fBlend * 3.0;\n    \n    return fBlend;\n}\n\nvec4 Env_GetSkyColor( vec3 vViewPos, vec3 vViewDir, bool drawSun )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n   \n    vResult.rgb = Env_GetSkyGradient( vViewPos, vViewDir );\n    \n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\n#endif\n    \n    // Sun\n    if ( drawSun )\n    {\n    \tfloat NdotV = dot( g_vSunDir, vViewDir );\n    \tvResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n    }\n\n\t// Cloud\n\tvec2 vCloudUV = 0.02 * vViewDir.xz / -vViewDir.y;\n\tfloat fBlend = Env_GetCloudCover( vCloudUV );\n\tvResult.rgb = vResult.rgb * clamp(1.0 - fBlend, 0.0, 1.0) + fBlend;\n    \n    return vResult;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.0001;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor( vec3 vPos, vec3 vDir)\n{    \n\treturn Env_GetSkyGradient( vPos, vDir );//vec3(0.5, 0.45, 0.4) * 2.0;\t\t\n}\n\nfloat Env_GetSunFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.01;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{\n    //return vColor;\n    vec3 vResult = vColor;\n    \n    \n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayOrigin, vRayDir );\t\n    vResult = mix( vFogColor, vResult, fFogFactor );\n\n    vec3 vSunFlare = Env_GetDirectionalLightFlare( vRayDir, g_vSunDir, g_vSunColor );\n    \n    float fSunFogFactor = Env_GetSunFogFactor( vRayOrigin, vRayDir, fDist );\n    \n    vResult += vSunFlare * (1.0 -  fSunFogFactor);\n\t//Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 1.0);    \n    \n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec4 vColorLinAndDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAndDepth.rgb = max( vColorLinAndDepth.rgb, vec3(0.0) );\n    \n    vec4 vFragColor = vColorLinAndDepth;\n    \n    float fExposure = 2.0f;\n    \n    vFragColor.rgb *= fExposure;\n    \n    vFragColor.a = vColorLinAndDepth.w;\n    \n    return vFragColor;\n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy / iResolution.xy; \n\n    FlyCamState flyCam;\n    \n    FlyCam_LoadState( flyCam, iChannelCurr, ivec2(4,0) );\n        \n\tbool bMoved = FlyCam_Update( flyCam, vec3(0.0, 0.2, 0.0), vec3(-0.1, 4.5, 0.1) );\n    \n    CameraState cam;\n\n#if 1\n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n    \n    cam.vPos = flyCam.vPos;\n    cam.vTarget = flyCam.vPos + vForwards;\n    cam.vUp = vUp;\n    cam.fFov = 25.0;\n    cam.fPlaneInFocus = 1.0;\n    \n    SceneResult focusTrace = Scene_Trace( flyCam.vPos, vForwards, 0.0, 100.0 );\n    cam.fPlaneInFocus = min( focusTrace.fDist, 3.0);\n#endif\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif\n    \n    float fAspectRatio = iResolution.x / iResolution.y;            \n    \n    vec3 vRayOrigin, vRayDir;\n    vec2 vJitterUV = vUV + cam.vJitter / iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, fAspectRatio, cam, vRayOrigin, vRayDir );\n \n    float fHitDist = 0.0f;\n    vFragColor = MainCommon( vRayOrigin, vRayDir );    \n    \n    if ( !bMoved )\n    {\n\t    vec3 vPrev = texelFetch( iChannel0, ivec2( vFragCoord.xy ), 0 ).rgb;\n\t    vFragColor.rgb = mix( vPrev, vFragColor.rgb, 0.01 );\n    }\n        \n    FlyCam_StoreState( ivec2(4,0), flyCam, vFragColor, ivec2(vFragCoord.xy) );\n\tCam_StoreState( ivec2(0), cam, vFragColor, ivec2(vFragCoord.xy) );    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TV 1\n#define CINEMA 0\n\n#define MAX_PATH_LENGTH 50.0\n#define ABSORPTION 1\n#define SCATTERING 1\n#define TRANSPARENCY 1\n\n#define SPECTRAL 0\n#define RGB 1\n\nstruct WaveInfo\n{\n#if SPECTRAL    \n    float wavelength;\n    vec3 rgb;\n#endif\n\n#if RGB    \n    int unused;\n#endif    \n};\n    \nstruct PathColor\n{\n#if SPECTRAL    \n    float fIntensity;\n#endif    \n\n#if RGB\n\tvec3 vRGB;\n#endif    \n};\n    \nPathColor PathColor_Zero()\n{\n#if SPECTRAL    \n    return PathColor( 0.0 );\n#endif    \n    \n#if RGB\n\treturn PathColor( vec3(0) );\n#endif    \n    \n}\n\nPathColor PathColor_One()\n{\n#if SPECTRAL    \n    return PathColor( 1.0 );\n#endif    \n#if RGB\n\treturn PathColor( vec3(1) );\n#endif    \n}\n\nfloat FFalloff( float f1, float f2, float range )\n{\n    return smoothstep( range, 0.0, abs( f1 - f2 ) );\n}\n\nPathColor ColorScale_sRGB( WaveInfo wave, vec3 sRGB )\n{\n#if SPECTRAL    \n    \n#if 1\n    vec3 sRGBRanges = vec3( 40, 50, 70.0 );\n\tvec3 sRGBApproxWavelengths = vec3( 610.0, 549.0, 468.0 );\n    float x = FFalloff( wave.wavelength, sRGBApproxWavelengths.x, sRGBRanges.x) * sRGB.x\n        + FFalloff( wave.wavelength, sRGBApproxWavelengths.y, sRGBRanges.y) * sRGB.y\n        + FFalloff( wave.wavelength, sRGBApproxWavelengths.z, sRGBRanges.z) * sRGB.z;\n\treturn  PathColor( x * 1.5 ); \n#else    \n    return  PathColor( dot( sRGB, wave.rgb));\n#endif    \n    \n#endif\n    \n    \n#if RGB\n    return PathColor( sRGB );\n#endif\n}\n\nPathColor ColorScale( PathColor a, PathColor b )\n{\n#if SPECTRAL    \n    return PathColor( a.fIntensity * b.fIntensity );\n#endif    \n#if RGB\n    return PathColor( a.vRGB * b.vRGB );\n#endif    \n}\n\nPathColor ColorScale( PathColor a, float s )\n{\n#if SPECTRAL    \n    return PathColor( a.fIntensity * s );\n#endif    \n#if RGB\n    return PathColor( a.vRGB * s );\n#endif    \n}\n\nPathColor ColorAdd( PathColor a, PathColor b )\n{\n#if SPECTRAL    \n    return PathColor( a.fIntensity + b.fIntensity );\n#endif    \n#if RGB\n    return PathColor( a.vRGB + b.vRGB );\n#endif    \n}\n\nPathColor ColorSub( PathColor a, PathColor b )\n{\n#if SPECTRAL    \n    return PathColor( a.fIntensity - b.fIntensity );\n#endif    \n#if RGB\n    return PathColor( a.vRGB - b.vRGB );\n#endif    \n}\n\nfloat ColorIntensity( PathColor a )\n{\n#if SPECTRAL    \n    return a.fIntensity;\n#endif    \n#if RGB\n    return dot( a.vRGB, vec3(1.0 / 3.0 ) );    \n#endif        \n}\n\nfloat SpecParamFromGloss( float gloss )\n{\n    float PB_GGX_MAX_SPEC_POWER=32.0;\n\tfloat exponent = pow( 2.0f, gloss * PB_GGX_MAX_SPEC_POWER );\n\treturn 2.0f  / ( 2.0f + exponent ); // matches alpha^2 for GGX physically-based shader\n}\n\n\n\n\nfloat GGX_D( float NdotH , float alpha2 )\n{\n\tfloat denom = ( NdotH * NdotH ) * ( alpha2 - 1.0f ) + 1.0f;\n\treturn alpha2 / ( denom * denom );\t\n}\n\n\nfloat GGX_PDF( const float NdotH, const in float alpha2 )\n{\n\t//const float LdotH = NdotH;\n\t//return GGX_D( NdotH, alpha2 ) * NdotH  / (4.0f * PI * LdotH);\n\n\t// simplified as NdotH == LdotH\n\treturn GGX_D( NdotH, alpha2 ) / (4.0f * PI);\n}\n\n// Z is preserved, Y may be modified to make matrix orthogonal\nmat3 OrthoNormalMatrixFromZY( vec3 zDirIn, vec3 yHintDir )\n{\n\tvec3 xDir = normalize( cross( zDirIn, yHintDir ) );\n\tvec3 yDir = normalize( cross( xDir, zDirIn ) );\n\tvec3 zDir = normalize( zDirIn );\n\n\tmat3 result = mat3( xDir, yDir, zDir );\n\t\t\n\treturn result;\n}\n\n\nmat3 OrthoNormalMatrixFromZ( vec3 zDir )\n{\n\tif ( abs( zDir.y ) < 0.999f )\n\t{\n\t\tvec3 yAxis = vec3( 0.0f, 1.0f, 0.0f );\n\t\treturn OrthoNormalMatrixFromZY( zDir, yAxis );\n\t}\n\telse\n\t{\n\t\tvec3 xAxis = vec3( 1.0f, 0.0f, 0.0f );\n\t\treturn OrthoNormalMatrixFromZY( zDir, xAxis );\n\t}\n}\n\nvec3 SphericalToCartesianDirection( vec2 spherical )\n{\n\tfloat theta = spherical.x;\n\tfloat phi = spherical.y;\n\tfloat sinTheta = sin( theta );\n\n\treturn vec3( cos( phi ) * sinTheta, sin( phi ) * sinTheta, cos( theta ) );\n}\n\n// Transform from a uniform 2D 0->1 sample space to a spherical co-ordiante with a probability distribution that represents important GGX half-angle vector locations\nvec2 ImportanceSampleGGXTransform( const vec2 uniformSamplePos, const in float alpha2 )\n{\n\t// [Karis2013]  Real Shading in Unreal Engine 4\n\t// http://blog.tobias-franke.eu/2014/03/30/notes_on_importance_sampling.html\n\n\tfloat theta = acos( sqrt( (1.0f - uniformSamplePos.y) /\n\t\t\t\t\t\t\t( (alpha2 - 1.0f) * uniformSamplePos.y + 1.0f )\n\t\t\t\t\t\t\t) );\n\n\tfloat phi = 2.0f * PI * uniformSamplePos.x;\n\n\treturn vec2( theta, phi );\n}\n\n// Transform from a uniform 2D 0->1 sample space to a direction vector with a probability distribution that represents important GGX half-angle vector locations\nvec3 ImportanceSampleGGX( vec2 uniformSamplePos, vec3 N, float alpha2 )\n{\n\tvec2 sphereSamplePos = ImportanceSampleGGXTransform( uniformSamplePos, alpha2 );\n\n\tvec3 specSpaceH = SphericalToCartesianDirection( sphereSamplePos );\n\t\n\tmat3 specToCubeMat = OrthoNormalMatrixFromZ( N );\n\n\treturn specToCubeMat * specSpaceH;\n}\n\nvec3 PointOnHemisphereCosine( inout uint seed, vec3 n )\n{\n    // from smallpt: http://www.kevinbeason.com/smallpt/\n\n    vec2 uv = FRand2( seed );\n\n    float r1 = 2.0f * PI * uv.x;\n    float r2 = uv.y;\n    float r2s = sqrt(r2);\n\n    vec3 w = n;\n    vec3 u;\n    if (abs(w.x) > 0.1f)\n        u = cross(vec3( 0.0f, 1.0f, 0.0f ), w);\n    else\n        u = cross(vec3( 1.0f, 0.0f, 0.0f ), w);\n\n    u = normalize(u);\n    vec3 v = cross(w, u);\n    vec3 d = (u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1.0 - r2));\n    d = normalize(d);\n\n    return d;\n}\n\n\nvec3 PointOnSphereUniform( inout uint seed )\n{\n    vec2 uv = FRand2( seed );\n    \n    float theta = 2.0f * PI * uv.x;\n    float phi = acos( 2.0 * uv.y - 1.0f );\n    \n    return SphericalToCartesianDirection( vec2( theta, phi ) );    \n}\n\n\nvec3 PointOnHemisphereUniform( inout uint seed, vec3 n )\n{\n    vec3 dir = PointOnSphereUniform( seed );\n    if ( dot( dir, n ) < 0.0 )\n    {\n        dir = -dir;\n    }\n    return dir;\n}\n\n\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n\nSceneResult SceneResult_Default()\n{\n    return SceneResult( MAX_PATH_LENGTH, -1, vec3(0) );\n}\n    \nSceneResult SceneResult_Union( SceneResult a, SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        return b;\n    }\n    return a;\n}\n    \nSceneResult SceneResult_Subtract( SceneResult a, SceneResult b )\n{\n    b.fDist = -b.fDist;\n    if ( a.fDist < b.fDist )\n    {\n        return b;\n    }\n    \n    return a;\n}\n\nvoid SceneResult_Combine( inout SceneResult inside, inout SceneResult outside, SceneResult newObject, int insideObj )\n{\n    if ( newObject.iObjectId == insideObj )\n    {\n\t    outside = SceneResult_Subtract( outside, newObject );\n    }\n    else\n    {\n\t    inside = SceneResult_Union( inside, newObject );\n    }    \n}\n\nSceneResult Scene_GetDistance( vec3 vPos, int insideObjId );    \n\nvec3 Scene_GetNormal( const in vec3 vPos, int insideObjId )\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos, insideObjId ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos, insideObjId ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos, insideObjId ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos, insideObjId ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}   \n\nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist, int insideObjId )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<NO_UNROLL(kRaymarchMaxIter); i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t, insideObjId );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n    return result;\n}    \n\nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    PathColor cR0;\n    float fGloss;\n    PathColor cEmissive;\n    float fTransparency;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, WaveInfo wave, SceneResult traceResult, int insideObjectId );\n\nPathColor Light_GetFresnel( vec3 vView, vec3 vNormal, PathColor cR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n    \n    float f = pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n\n    return ColorAdd( cR0, ColorScale( ColorSub( PathColor_One(), cR0), f ) );   \n}\n\nint\n    MAT_SCREEN = 1,\n    MAT_COLORED_GLASS_2 = 2,\n    MAT_COLORLESS_GLASS = 3,\n    MAT_TEXTURED_FLOOR = 4,\n    MAT_EMISSIVE_LIGHT = 5,\n    MAT_CHROME = 6,\n    MAT_GOLD = 7,\n    MAT_WHITE_GLOSS = 8,\n    MAT_WHITE_MATT = 9,\n    MAT_WINE = 10,\n    MAT_TABLE = 11;\n\nfloat DistanceCapsule( vec3 vPos, vec3 vP0, vec3 vP1, float r )\n{\n\tvec3 pa = vPos - vP0;\n\tvec3 ba = vP1 - vP0;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h ) - r;    \n}\n\nfloat GetDistanceMug( const in vec3 vPos )\n{\n\tfloat fDistCylinderOutside = length(vPos.xz) - 1.0;\n\tfloat fDistCylinderInterior = length(vPos.xz) - 0.9;\n\tfloat fTop = vPos.y - 1.0;\n       \n\tfloat r1 = 0.6;\n\tfloat r2 = 0.15;\n\tvec2 q = vec2(length(vPos.xy + vec2(1.2, -0.1))-r1,vPos.z);\n\tfloat fDistHandle = length(q)-r2;\n       \n\tfloat fDistMug = max(max(min(fDistCylinderOutside, fDistHandle), fTop), -fDistCylinderInterior);\n\treturn fDistMug;\n}\n\nfloat GetDistanceWine( vec3 vPos )\n{\n    vec3 vLocalPos = vPos;\n    vLocalPos.y -= 2.0;\n    \n    vec2 vPos2 = vec2(length(vLocalPos.xz), vLocalPos.y);\n    \n    vec2 vSphOrigin = vec2(0);\n    vec2 vSphPos = vPos2 - vSphOrigin;   \n    \n    float fBowlDistance = length( vSphPos ) -  0.6 + 0.01;\n    \n    vec3 vWaterNormal = vec3(0,1,0);\n    \n    float fTime = 0.0;\n    \n    vWaterNormal.x = sin( fTime * 5.0) * 0.01;\n    vWaterNormal.z = cos( fTime * 5.0) * 0.01;\n    \n    vWaterNormal = normalize( vWaterNormal );\n    float fWaterLevel = dot(vLocalPos, vWaterNormal) - 0.1;\n        \n    return max( fBowlDistance, fWaterLevel );\n}\n\nfloat GetDistanceWineGlass( vec3 vPos )\n{\n    vec2 vPos2 = vec2(length(vPos.xz), vPos.y);\n    \n    vec2 vSphOrigin = vec2(0,2.0);\n    vec2 vSphPos = vPos2 - vSphOrigin;\n    \n    vec2 vClosest = vSphPos;\n    \n    if ( vClosest.y > 0.3 ) vClosest.y = 0.3;\n    vClosest = normalize(vClosest) * 0.6;\n    \n    float fBowlDistance = distance( vClosest, vSphPos ) - 0.015;\n    \n    vec2 vStemClosest = vPos2;\n    vStemClosest.x = 0.0;    \n    vStemClosest.y = clamp(vStemClosest.y, 0.0, 1.35);\n    \n    float fStemRadius = vStemClosest.y - 0.5;\n    fStemRadius = fStemRadius * fStemRadius * 0.02 + 0.03;\n    \n    float fStemDistance = distance( vPos2, vStemClosest ) - fStemRadius;\n        \n    vec2 norm = normalize( vec2( 0.4, 1.0 ) );\n    vec2 vBaseClosest = vPos2;\n    float fBaseDistance = dot( vPos2 - vec2(0.0, 0.025), norm ) - 0.2;\n    fBaseDistance = max( fBaseDistance, vPos2.x - 0.5 ); \n\n    float fDistance = SmoothMin(fBowlDistance, fStemDistance, 0.2);\n    fDistance = SmoothMin(fDistance, fBaseDistance, 0.2);\n    \n    fDistance = max( fDistance, vSphPos.y - 0.5 );\n        \n    return fDistance;\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat BulbGlassDist( vec3 vPos )\n{\n    float fSphereDist = length( vPos ) - 1.0;\n    float fCylinderDist = length( vPos.xz ) - 0.5;\n    fCylinderDist = max( fCylinderDist, -vPos.y );\n    float fGlassDist = smin( fSphereDist, fCylinderDist, 0.5 );\n    fGlassDist = max( fGlassDist, vPos.y - 1.5);\n    return fGlassDist;\n}\n\nSceneResult Scene_GetDistanceBulb( vec3 vPos )\n{\n    SceneResult result;\n    \n    result.fDist = BulbGlassDist( vPos );\n    \n    float fGlassThickness = 0.005;\n    \n    result.fDist = abs( result.fDist + fGlassThickness ) - fGlassThickness;\n    \n    result.vUVW = vec3(vPos);\n    result.iObjectId = MAT_COLORLESS_GLASS;            \n\n    return result;\n}\n\nSceneResult Scene_GetDistanceTripod( vec3 vPos )\n{\n    SceneResult result;\n    \n    result.fDist = 1000.0;\n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_WHITE_MATT;    \n    \n    // tripod etc.\n    float fT1 = sdCylinder( vPos - vec3(0,-0.1,0), vec2(0.03, 0.2) );\n    result.fDist = min( result.fDist, fT1 );\n\n    float fT2 = sdCylinder( vPos - vec3(0,-0.2,0), vec2(0.05, 0.01) );\n    result.fDist = min( result.fDist, fT2 );\n\n    vec3 vLegDomain = vPos - vec3(0,-0.25,0 );\n    vLegDomain = DomainRotateSymmetry( vLegDomain, 3.0 );\n    float fL1 = sdCapsule( vLegDomain, vec3(0), vec3(0, -1, 0.4), 0.01 );            \n    result.fDist = min( result.fDist, fL1 );\n        \n    \n    return result;\n}\n\n#if TV\n\nSceneResult Scene_GetDistance( vec3 vPos, int insideObjId )\n{    \n    SceneResult resultInside = SceneResult_Default();\n    SceneResult resultOutside = SceneResult_Default();\n    if ( insideObjId != -1 )\n    {\n    \tresultOutside.fDist = -10000.0;\n    }\n    \n\n    SceneResult resultWall;\n    \n\n    resultWall.fDist = vPos.z + 0.752;\n    \n    resultWall.fDist = min( resultWall.fDist, 10.0 - vPos.z );\n    resultWall.fDist = min( resultWall.fDist, 10.0 + vPos.x );\n    resultWall.fDist = min( resultWall.fDist, 10.0 - vPos.x );\n    resultWall.fDist = min( resultWall.fDist, 5.3 - vPos.y );\n    resultWall.vUVW = vPos;\n    resultWall.iObjectId = MAT_WHITE_MATT;\n\n    SceneResult_Combine( resultInside, resultOutside, resultWall, insideObjId );\n    \n    \n    \n    \n    SceneResult resultScreen;\n    \n    vec3 vSize = vec3(1.6,1,0.0);\n    vec3 vScreenDomain = vPos - vec3(0,2.2,0.1);\n    float fScreenDist = sdBox( vScreenDomain, vSize + 0.05 );\n    resultScreen.fDist = fScreenDist;\n    resultScreen.vUVW = vec3( (vScreenDomain / vSize) * 0.5 + 0.5 );\n    resultScreen.iObjectId = MAT_SCREEN;\n\n    SceneResult_Combine( resultInside, resultOutside, resultScreen, insideObjId );\n    \n    \n\n    \n    SceneResult resultFloor;\n    \n    resultFloor.fDist = vPos.y;\n    \n    resultFloor.vUVW = vec3(vPos);\n    resultFloor.iObjectId = MAT_TEXTURED_FLOOR;\n\n    SceneResult_Combine( resultInside, resultOutside, resultFloor, insideObjId );\n\n    \n    \n    SceneResult resultTable;\n    \n    resultTable.fDist = sdBox( vPos, vec3(2, 1, 0.75) );\n    \n    resultTable.vUVW = vec3(vPos);\n    resultTable.iObjectId = MAT_TABLE;\n\n    SceneResult_Combine( resultInside, resultOutside, resultTable, insideObjId );    \n    vec2 vOffset = vec2(5.0, 5.0);\n    vec3 vPosRepeat = vPos;\n    vPosRepeat.xz = fract((vPos.xz + vOffset) / 15.0) * 15.0 - vOffset;\n    \n    \n    SceneResult lightResult;\n    \n    vec3 vPosRepeat2 = vPos - vec3(0,0,5.0);\n    vec2 vOffset2 = vec2(5.0);\n    vPosRepeat2.xz = fract((vPosRepeat2.xz + vOffset2) / 10.0) * 10.0 - vOffset2;\n    \n    lightResult.fDist = DistanceCapsule( vPosRepeat2, vec3(0.0,5.0,-1.5), vec3(0.0,5.0,1.5), 0.25);\n    lightResult.vUVW = vec3(vPosRepeat2);\n    lightResult.iObjectId = MAT_EMISSIVE_LIGHT;\n\n    SceneResult_Combine( resultInside, resultOutside, lightResult, insideObjId );    \n    \n    \n    return SceneResult_Union( resultInside, resultOutside );\n}\n#endif\n\n#if CINEMA\n\nSceneResult Scene_GetDistance( vec3 vPos, int insideObjId )\n{    \n    SceneResult resultInside = SceneResult_Default();\n    SceneResult resultOutside = SceneResult_Default();\n    if ( insideObjId != -1 )\n    {\n    \tresultOutside.fDist = -10000.0;\n    }\n    \n\n    SceneResult resultWall;\n    \n\n    resultWall.fDist = 1000.0;\n    resultWall.fDist = min( resultWall.fDist, 10.0 - vPos.z );\n    \n    resultWall.fDist = min( resultWall.fDist, 10.0 + vPos.x );\n    resultWall.fDist = min( resultWall.fDist, 10.0 - vPos.x );\n    resultWall.fDist = min( resultWall.fDist, 8.0 - vPos.y );\n    resultWall.vUVW = vPos;\n    resultWall.iObjectId = MAT_WHITE_MATT;\n\n    SceneResult_Combine( resultInside, resultOutside, resultWall, insideObjId );          \n    \n    SceneResult resultScreen;\n\n    resultScreen.fDist = vPos.z + 6.0;\n    vec3 vSize = vec3(1.6,1,0.0) * 2.3;\n    vec3 vScreenDomain = vPos - vec3(0,4.0,0);\n    resultScreen.vUVW = vec3( (vScreenDomain / vSize) * 0.5 + 0.5 );\n    \n    resultScreen.iObjectId = MAT_SCREEN;\n\n    SceneResult_Combine( resultInside, resultOutside, resultScreen, insideObjId );\n    \n    \n\n    \n    SceneResult resultFloor;\n    \n    resultFloor.fDist = vPos.y;\n    \n    resultFloor.vUVW = vec3(vPos);\n    resultFloor.iObjectId = MAT_WHITE_MATT;\n\n    SceneResult_Combine( resultInside, resultOutside, resultFloor, insideObjId );\n\n    \n    \n    SceneResult resultTable;\n    \n    resultTable.fDist = sdBox( vPos - vec3(0,0,-5.0), vec3(20, 1, 2) );\n    resultTable.fDist = min( resultTable.fDist, sdBox( vPos - vec3(0,7.5,-5.0), vec3(20, 1, 0.5) ));\n    \n    resultTable.vUVW = vec3(vPos);\n    resultTable.iObjectId = MAT_WHITE_MATT;\n\n    SceneResult_Combine( resultInside, resultOutside, resultTable, insideObjId );    \n    vec2 vOffset = vec2(5.0, 5.0);\n    vec3 vPosRepeat = vPos;\n    vPosRepeat.xz = fract((vPos.xz + vOffset) / 15.0) * 15.0 - vOffset;\n    \n    /*\n    SceneResult lightResult;\n    \n    vec3 vPosRepeat2 = vPos - vec3(0,0,5.0);\n    vec2 vOffset2 = vec2(5.0);\n    vPosRepeat2.xz = fract((vPosRepeat2.xz + vOffset2) / 10.0) * 10.0 - vOffset2;\n    \n    lightResult.fDist = DistanceCapsule( vPosRepeat2, vec3(0.0,5.0,-1.5), vec3(0.0,5.0,1.5), 0.25);\n    lightResult.vUVW = vec3(vPosRepeat2);\n    lightResult.iObjectId = MAT_EMISSIVE_LIGHT;\n\n    SceneResult_Combine( resultInside, resultOutside, lightResult, insideObjId );    \n    */\n    \n    \n    SceneResult resultCurtain;\n    \n    resultCurtain.fDist = abs(vPos.z + 5.5) - 0.1;\n    resultCurtain.fDist += sin( vPos.x * 20.0) * 0.1;\n    \n    float fMidDist = abs( vPos.x ) - 4.0;\n    resultCurtain.fDist = max( resultCurtain.fDist, -fMidDist );\n    \n    resultCurtain.vUVW = vec3(vPos);\n    resultCurtain.iObjectId = MAT_TEXTURED_FLOOR;\n\n    SceneResult_Combine( resultInside, resultOutside, resultCurtain, insideObjId );\n    \n    \n    return SceneResult_Union( resultInside, resultOutside );\n}\n#endif\n\n///////////////////////////////////////////////\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\n\nvec3 ApplyGrain( vec2 vUV, vec3 col, float amount )\n{\n    float fTime = 0.0;//iTime;\n    float h = hash13( vec3(vUV, fTime) );\n    \n    col *= (h * 2.0 - 1.0) * amount + (1.0f -amount);\n    \n    return col;\n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 1.5;\n    \n    float fMaxLum = 100.0;\n    vColor /= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;  \n    return vColor;\n}\n\nvec3 Process( vec3 vResult, vec2 vUV )\n{    \n    vResult = max( vec3(0), vResult );\n    float fShade = GetVignetting( vUV, 0.7, 2.0, 0.7 );\n    \n    vResult *= fShade;\n    \n    //if ( vUV.x > sin(iTime)*0.5+0.5 )\n    {\n    \tvResult = ColorGrade( vResult );\n    }\n    \n\tvResult = ApplyGrain( vUV, vResult, 0.15 );             \n        \n    vResult = vResult * 0.75;\n    vResult = Tonemap( vResult );\n\treturn vResult;\n}\n\nPathColor BlackBody( WaveInfo wave, float t, float i )\n{\n#if SPECTRAL\n\treturn PathColor( BlackBody( t, wave.wavelength ) * i );\n#endif        \n#if RGB\n    vec3 wl = vec3( 610.0, 549.0, 468.0 );\n    vec3 vEmissive = vec3(0.0);\n    vEmissive.r = BlackBody( t, wl.r );\n    vEmissive.g = BlackBody( t, wl.g );\n    vEmissive.b = BlackBody( t, wl.b );\n    return PathColor( vEmissive * i );\n#endif        \n    \n}\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, WaveInfo wave, SceneResult traceResult, int insideObjId )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos, insideObjId ); \n    \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n#if SPECTRAL    \n    surfaceInfo.cR0 = PathColor( 0.02 );\n#endif\n#if RGB\n    surfaceInfo.cR0 = PathColor( vec3( 0.02 ) );\n#endif\n    \n    surfaceInfo.fGloss = 1.0;\n    surfaceInfo.cEmissive = PathColor_Zero();\n    surfaceInfo.fTransparency = 0.0;\n    \n\n    \n    if ( traceResult.iObjectId == MAT_WINE )\n    {\n        surfaceInfo.fTransparency = 1.0;\n        surfaceInfo.fGloss = 1.0;\n    }\n    \n    if ( traceResult.iObjectId == MAT_COLORLESS_GLASS )\n    {\n        surfaceInfo.fGloss = 1.0;\n\n        if ( surfaceInfo.vPos.z > -1.5 && surfaceInfo.vPos.y > 3.0 )\n        {\n\t        surfaceInfo.fGloss = 0.3;\n        }\n        surfaceInfo.vAlbedo = vec3(0.01);\n        surfaceInfo.fTransparency = 1.0;\n    }\n\n    if ( traceResult.iObjectId == MAT_COLORED_GLASS_2 )\n    {\n        surfaceInfo.fGloss = 1.0;\n        surfaceInfo.fTransparency = 1.0;\n    }    \n    \n    if ( traceResult.iObjectId == MAT_SCREEN )\n    {\n        vec2 vUV = traceResult.vUVW.xy;\n        //vUV = clamp( vUV, vec2(0), vec2(1));\n    \tsurfaceInfo.vAlbedo = textureLod(iChannel2, vUV, 0.0 ).rgb;\n        \n        vec3 vEmissive = Process( surfaceInfo.vAlbedo, vUV );\n        vEmissive = vEmissive * vEmissive * 20.0;\n        \n        if ( any( greaterThan( vUV, vec2(1) ) ) || any( lessThanEqual( vUV, vec2(0) ) ) )\n        {\n            vEmissive = vec3(0.0);\n        }\n        \n        if ( surfaceInfo.vNormal.z < 0.0 )\n        {\n            vEmissive = vec3(0.0);\n        }\n\n        surfaceInfo.cEmissive = ColorScale_sRGB( wave, vEmissive );\n        \n        #if CINEMA\n        \tsurfaceInfo.fGloss = 0.3;\n        \tsurfaceInfo.vAlbedo = vec3(0.9);\n        #endif\n        \n        #if TV\n        \tsurfaceInfo.fGloss = 0.9;\n        \tsurfaceInfo.vAlbedo = vec3(0.1);\n        #endif\n        \n        \n        //surfaceInfo.vAlbedo = vec3(0.25);\n        \n        \n        /*\n        // The floor is lava\n        float t = 1.0 - surfaceInfo.vAlbedo.r;\n        surfaceInfo.cEmissive = BlackBody(wave, 2200.0 * t * t, 3e-9);\n        surfaceInfo.vAlbedo *= 1.0 - t;\n        */\n    }\n    \n    if ( traceResult.iObjectId == MAT_EMISSIVE_LIGHT )\n    {\n        float t = 6500.0 - 3000.0;\n        float i = 3e-11;\n\n        if ( traceResult.vUVW.z > 1.5 || traceResult.vUVW.z < -1.5 || traceResult.vUVW.y > 5.0 )\n        {\n            i = 0.0;\n            surfaceInfo.fGloss = 1.0f;\n\t\t    surfaceInfo.cR0 = PathColor_One();\n        }\n        \n        surfaceInfo.cEmissive = BlackBody( wave, t, i );\n    }\n\n    if ( traceResult.iObjectId == MAT_CHROME )\n    {\n    \tsurfaceInfo.vAlbedo = vec3(0.9, 0.5, 0.05) * 0.1;\n        surfaceInfo.fGloss = 1.0;        \n\t\tsurfaceInfo.cR0 = PathColor_One();\n    }\n\n\n    if ( traceResult.iObjectId == MAT_GOLD )\n    {\n    \tsurfaceInfo.vAlbedo = vec3(0.9, 0.5, 0.05) * 0.1;\n        surfaceInfo.fGloss = 1.0;        \n\t\tsurfaceInfo.cR0 = PathColor_One();\n        \n        surfaceInfo.cR0 = ColorScale_sRGB( wave, vec3( 0.9, 0.5, 0.05 ) );\n    }    \n    if ( traceResult.iObjectId == MAT_WHITE_GLOSS )\n    {\n    \tsurfaceInfo.vAlbedo = vec3(0.9, 0.9, 0.9);\n        surfaceInfo.fGloss = 1.0;\n        \n        if ( traceResult.vUVW.y > 2.0 && traceResult.vUVW.y < 2.1 )\n        {\n\t    \tsurfaceInfo.vAlbedo = vec3(0.3);\n        }\n    }    \n    \n    if ( traceResult.iObjectId == MAT_WHITE_MATT )\n    {\n    \tsurfaceInfo.vAlbedo = vec3(1.0, 1.0, 1.0);\n        surfaceInfo.fGloss = 0.0;        \n    }    \n    \n    if ( traceResult.iObjectId == MAT_TEXTURED_FLOOR || traceResult.iObjectId == MAT_TABLE )\n    {\n        float f = FBM( traceResult.vUVW.xz * vec2(1,3), 0.8 );\n    \tsurfaceInfo.vAlbedo = mix( vec3(0.9, 0.5, 0.4), vec3( 0.2, 0.1, 0.05), f );\n        surfaceInfo.fGloss = 0.0;        \n        \n        if ( traceResult.iObjectId == MAT_TABLE )\n        {\n\t        surfaceInfo.fGloss = f * f; \n        }\n    }      \n    return surfaceInfo;\n}\n\nstruct Medium\n{\n    float fScatteringDensity;\n    float fRefractiveIndex;\n    PathColor cAbsorb;\n};\n\n\n// https://en.m.wikipedia.org/wiki/Cauchy%27s_equation\nfloat Cauchy(float w_nm, float B, float C)\n{\n    float w_um = w_nm / 1000.0;\n    \n    float w2 = w_um * w_um;\n    \n    return B + C / w2;\n}\n\n// https://en.wikipedia.org/wiki/Sellmeier_equation\nfloat Sellmeier( float w_nm, vec3 B, vec3 C )\n{\n    float w_um = w_nm / 1000.0;\n    \n    float w2 = w_um * w_um;\n\n    vec3 t = (B * w2) / (vec3(w2) - C);\n    return 1.0f + t.x + t.y + t.z;\n}\n\nMedium Scene_GetMedium( WaveInfo wave, int iObjectId )\n{\n    Medium medium;\n    \n    medium.fScatteringDensity = 0.0005; //0.005;//0.0015;\n    medium.fRefractiveIndex = 1.0;\n        \n    bool bGlass = false;\n    vec3 vAbsorb = vec3(1.0);\n        \n    if ( iObjectId == MAT_WINE )\n    {\n    \tvAbsorb = vec3(0.9, 0.9, 0.3);\n        medium.fRefractiveIndex = 1.330;\n    }\n    \n    if ( iObjectId == MAT_COLORLESS_GLASS )\n    {\n    \tvAbsorb = vec3(1.0);\n        bGlass = true;\n    }\n    \n    if ( iObjectId == MAT_COLORED_GLASS_2 )\n    {\n    \tvAbsorb = vec3(0.1, 0.3, 0.9 );\n        medium.fScatteringDensity = 0.3;\n        bGlass = true;\n    }\n    \n    if ( bGlass )\n    {\n#if SPECTRAL\n\t\tfloat fRefractionWavelength_nm = wave.wavelength;\n#else    \n    \tfloat fRefractionWavelength_nm = 540.0;        \n#endif           \n        \n#if 1\n        medium.fRefractiveIndex = Cauchy( fRefractionWavelength_nm, 1.5220, 0.00459 );\n#else\n        \n        vec3 B = vec3(1.03961212, 0.231792344, 1.01046945);\n        vec3 C = vec3(6.00069867e-3, 2.00179144e-2, 1.03560653e2);\n        medium.fRefractiveIndex = Sellmeier( fRefractionWavelength_nm, B, C );\n        \n#endif        \n    }\n    \n    medium.cAbsorb = ColorScale_sRGB( wave, vec3(1.0)  - vAbsorb );\n    return medium;\n}\n\n\nPathColor SampleEnvironment( WaveInfo wave, vec3 vDir )\n{\n    return PathColor_Zero();\n    vec3 vEnvMap = textureLod(iChannel1, vDir, 0.0).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 20.0;\n    float fExposureFactor = 1.0 - pow(2.0, -kEnvmapExposure);\n    vEnvMap = -log2(1.0 - vEnvMap * fExposureFactor);           \n    return ColorScale_sRGB( wave, vEnvMap );    \n}\n\nfloat ScatteringRayLifetime( float pDensity, float fRand )\n{\n    // avoid log(0) and divide by 0\n    pDensity = clamp( pDensity, 0.000001, 0.999999 );\n    \n    // avoid log(0)\n    fRand = max( 0.000001, fRand );\n    \n    // logn(X) / logn(X) is the same for all bases\n    float g = log2( fRand ) / log2( 1.0f - pDensity );\n    return g;\n}\n\n\nPathColor TraceScene( vec3 vRayOrigin, vec3 vRayDir, WaveInfo wave, inout uint seed )\n{\n    float fPathLength = MAX_PATH_LENGTH;\n    float fStartDist = 0.0;\n    \n    int MAX_PATH_ITER = 20;\n    \n    PathColor cResult = PathColor_Zero();    \n    PathColor cRemaining = PathColor_One();\n        \n    int insideObjId = -1;\n    Medium medium;\n    \n    SceneResult initResult = Scene_GetDistance( vRayOrigin, -1 );\n    if ( initResult.fDist <= 0.0 )\n    {\n    \tinsideObjId = initResult.iObjectId;\n    }\n\t\n    medium = Scene_GetMedium( wave, insideObjId );\n    \n\n    for( int pathIter = 0; pathIter < NO_UNROLL(MAX_PATH_ITER); pathIter++ )\n    {\n        SceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fPathLength, insideObjId );\n                \n#if SCATTERING        \n        // scattering \n        float fRandomScatter = FRand( seed );\n        \n        // probability of scattering per unit distance\n        float pDensity = medium.fScatteringDensity;\n\n        float fLifeTime = ScatteringRayLifetime( pDensity, fRandomScatter );\n        if ( traceResult.fDist > fLifeTime )\n        {\n            traceResult.fDist = fLifeTime;\n\t        fPathLength -= traceResult.fDist;\n            \n            // Scattering\n            \n            // Todo - phase function...\n            vRayOrigin = vRayOrigin + vRayDir * fLifeTime;\n            //vRayDir = normalize( vRayDir + 0.1 * PointOnSphereUniform( seed ));\n            vRayDir = PointOnSphereUniform( seed );\n            //vRemaining *= vec3(0.5, 0.8, 0.9);  \n            \n            continue;\n        }\n#endif        \n      \n#if ABSORPTION\n        // absorption\n\t\tPathColor cAbsorbAmount = medium.cAbsorb;\n#if SPECTRAL\n        float fTemp = exp( cAbsorbAmount.fIntensity * -max(0.0, traceResult.fDist) );\n        PathColor cExtinction = PathColor( fTemp );\n#endif      \n#if RGB\n        vec3 vTemp = exp( cAbsorbAmount.vRGB * -max(0.0, traceResult.fDist) );\n        PathColor cExtinction = PathColor( vTemp );\n#endif\n        cRemaining = ColorScale( cRemaining, cExtinction );\n        \n#endif        \n        fPathLength -= traceResult.fDist;\n        \n        if ( traceResult.iObjectId < 0 )\n        {\n            PathColor cEnv = SampleEnvironment( wave, vRayDir );\n            cResult = ColorAdd( cResult, ColorScale( cEnv, cRemaining ) );\n                        \n            break;\n        }\n        \n        int newInsideObjId = insideObjId;\n        \n        int from = insideObjId;\n        int to = traceResult.iObjectId;                \n        if ( insideObjId == traceResult.iObjectId )\n        {\n            to = -1;\n        }        \n        \n        SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, wave, traceResult, insideObjId );        \n\n        float fFromRefractiveIndex = medium.fRefractiveIndex;\n        \n\t    medium = Scene_GetMedium( wave, to );\n        \n        // hit something\n        vRayOrigin = surfaceInfo.vPos;\n\n\t\tPathColor cFresnel = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.cR0, surfaceInfo.fGloss );\n\n        bool bFresnel = false;\n        {\n\t        float fRand = FRand(seed);\n            #if SPECTRAL    \n            bFresnel = cFresnel.fIntensity > fRand;\n        #endif\n\n        #if RGB\n            \n\t\tif ( cFresnel.vRGB.x == cFresnel.vRGB.y && cFresnel.vRGB.x == cFresnel.vRGB.z && cFresnel.vRGB.y == cFresnel.vRGB.z )\n        {\n            bFresnel = cFresnel.vRGB[0] > fRand;\n        }\n        else\n        {\n            float fBase = fRand * 2.9999;\n            int iChannel = int( floor( fBase ) );\n            float fRand2 = fBase - float(iChannel);\n            bFresnel = cFresnel.vRGB[iChannel] > fRand2;\n            \n            vec3 scale = vec3(0);\n            scale[iChannel] = 3.0f;\n            cRemaining.vRGB *= scale;\n        }\n        #endif             \n        }\n\n        vec2 uniformSamplePos = FRand2( seed );        \n\n        float alpha2 = SpecParamFromGloss(surfaceInfo.fGloss);\n\n        vec3 N = surfaceInfo.vBumpNormal;\n        vec3 V = -vRayDir;\n        vec3 H = ImportanceSampleGGX( uniformSamplePos, N, alpha2 );        \n        \n        float fToRefractiveIndex = medium.fRefractiveIndex;\n\n       \t// Hack - use GGX for refraction \"gloss\"\n        vec3 vRefract = refract( -V, H, fFromRefractiveIndex / fToRefractiveIndex );\n        \n        if ( length( vRefract ) == 0.0 )\n        {\n            bFresnel = false;\n        }\n        \n        if ( bFresnel )\n        {\n            vRayDir = reflect( -V, H );\n        }\n        else\n        {\n            cResult = ColorAdd( cResult, ColorScale( surfaceInfo.cEmissive, cRemaining ) );\n            \n#if TRANSPARENCY            \n            // transparency\n            float fTransparency = surfaceInfo.fTransparency;\n            if ( FRand( seed ) < fTransparency )\n            {                                \n\t\t\t\tvRayDir = vRefract;\n                newInsideObjId = to;                \n            }\n\t\t\telse\n#endif                \n            {\n                // diffuse...                \n                vRayDir = PointOnHemisphereCosine( seed, surfaceInfo.vNormal );\n                cRemaining = ColorScale( cRemaining, ColorScale_sRGB( wave, surfaceInfo.vAlbedo ) );\n            }\n        }\n        \n        insideObjId = newInsideObjId;\n        \n        fStartDist = 0.1 / abs(dot( vRayDir, surfaceInfo.vNormal )); \n        \n        if ( ColorIntensity( cRemaining ) < 0.005 )\n        {\n            break;\n        }\n    }\n    \n    return cResult;\n}\n\n\nvec2 BokehShapeCircle( float fRand )\n{\n    fRand *= PI * 2.0;\n    return vec2( sin( fRand ), cos( fRand ) );\n}\n\nvec2 BokehShapePoly( float fSides, float fRand )\n{\n    vec2 A, B;\n    \n    float t = fRand * fSides;\n    float t0 = floor(t);\n    float t1 = t0 + 1.0;\n    float b = fract(t);\n    \n    t0 = t0 * PI * 2.0 / fSides;\n    t1 = t1 * PI * 2.0 / fSides;\n    \n    A = vec2( sin(t0), cos(t0) );\n    B = vec2( sin(t1), cos(t1) );\n    \n    return mix( A, B, b );\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord/iResolution.xy;\n    \n    vec2 vWindow = (vUV - 0.5) * 2.0;\n    vWindow.x *= iResolution.x / iResolution.y;\n\n    vec3 vColor = vec3(0);\n    \n    CameraState cam;\n\tCam_LoadState( cam, iChannel3, ivec2(0) );\n    \n    \n    //vec3 vRayOrigin = vec3(0, 0, -3);\n    //vec3 vRayDir = normalize( vec3(vWindow, 2.0) );\n    \n    //vec3 vRayOrigin = cam.vPos;\n    //vec3 vRayDir = normalize(cam.vTarget - cam.vPos);\n    \n    float fAspectRatio = iResolution.x / iResolution.y;\n    \n    vec3 vRayOrigin, vRayDir;\n    Cam_GetCameraRay( vUV, fAspectRatio, cam, vRayOrigin, vRayDir );    \n    \n    vec3 vCamDir = cam.vTarget - cam.vPos;\n    \n    const float fBladeAngle = TAU / 6.0;    \n    const float fBladeAngleOffset = 0.3 * fBladeAngle;\n    const vec2 vBladeArray[] = vec2[](\n        vec2( sin(fBladeAngle * 0.0 + fBladeAngleOffset), cos( fBladeAngle * 0.0 + fBladeAngleOffset) ),\n        vec2( sin(fBladeAngle * 1.0 + fBladeAngleOffset), cos( fBladeAngle * 1.0 + fBladeAngleOffset) ),\n        vec2( sin(fBladeAngle * 2.0 + fBladeAngleOffset), cos( fBladeAngle * 2.0 + fBladeAngleOffset) ),\n        vec2( sin(fBladeAngle * 3.0 + fBladeAngleOffset), cos( fBladeAngle * 3.0 + fBladeAngleOffset) ),\n        vec2( sin(fBladeAngle * 4.0 + fBladeAngleOffset), cos( fBladeAngle * 4.0 + fBladeAngleOffset) ),\n        vec2( sin(fBladeAngle * 5.0 + fBladeAngleOffset), cos( fBladeAngle * 5.0 + fBladeAngleOffset) )\n        );\n\n    uint seed = uint( iTime * 23.456 ) + uint(vFragCoord.x *23.45f) * 12326u + uint(vFragCoord.y * 36.43) * 42332u;\n    \n    int PATH_COUNT = 30;\n    \n    float fPathCount = texelFetch( iChannel3, ivec2(7,0), 0).z;\n\n    int iPathsTraced = 0;\n    \n    for ( int pathIndex = 0; pathIndex < NO_UNROLL(PATH_COUNT); pathIndex++ )\n    {\n        if ( pathIndex > int(fPathCount) )\n        {\n            break;\n        }\n        \n        iPathsTraced++;\n        seed = HashWang( seed );\n        \n        vec3 vRayOrigin2 = vRayOrigin;\n        vec3 vRayDir2 = vRayDir;\n\n#if SPECTRAL        \n        WaveInfo wave;\n        wave.wavelength = mix( 380.0, 780.0, FRand( seed ) );\n        \n        mat3 m = mat3(\n            0.9415037, -0.0321240,  0.0584672,\n\t\t\t-0.0428238,  1.0250998,  0.0203309,\n \t\t\t0.0101511, -0.0161170,  1.2847354 );\n        \n        vec3 XYZ = WavelengthToXYZ(wave.wavelength);\n        wave.rgb = XYZtosRGB( XYZ  );\n        //wave.rgb = XYZ * XYZtoRGB( Primaries_Rec709 );\n        //wave.rgb = clamp( wave.rgb, vec3(0.0), vec3(1.0));\n#endif        \n\n#if RGB\n        WaveInfo wave = WaveInfo(0);\n#endif\n        \n#if SPECTRAL        \n        //vRayDir2 = mix( vRayDir, vCamDir, 0.025 * (wave.wavelength / 780.0) );\n        \n\t\tfloat fRefractiveIndex = Cauchy( wave.wavelength, 1.5220, 0.00459 );        \n        vRayDir2 = refract( vRayDir, -normalize(vRayDir + vCamDir * 0.2), fRefractiveIndex ); \n        //vRayDir2 = vRayDir;\n        \n        \n#endif        \n        \n        vec2 vBloomUV  = vec2(0);\n        mat3 perpMat = OrthoNormalMatrixFromZ( vCamDir );\n#if 0        \n        // Depth of field                \n\t\tfloat fBokehShapeRand = FRand( seed );\n\t\tfloat fBokehDistRand = FRand( seed );\n        \n        vec2 vBokehShape = BokehShapePoly( 6.0, fBokehShapeRand + fBladeAngleOffset / TAU );\n        \n        vec2 vBokehUV = vBokehShape * (pow( fBokehDistRand, 0.4 ) ) * 0.1;//* 0.03;\n                \n\n        vec3 vBokehOffset = vec3( vBokehUV, 0.0 ) * perpMat;\n        \n        vRayDir2 += vBokehOffset / cam.fPlaneInFocus;\n        vRayOrigin2 -= vBokehOffset;\n        \n        // bloom\n        uint iBlade = Rand(seed) % 6u;\n        vec2 vBlade = vBladeArray[iBlade];\n        //vBloomUV *= 0.0;\n        vBloomUV += vBlade * pow( FRand(seed), 200.0 );        \n\n        vec2 vBloomShape = BokehShapeCircle( FRand(seed) );\n        vBloomUV += vBloomShape * pow( smoothstep(0.0, 1.0, FRand(seed)), 100.0 );\n\n#endif        \n        vec2 vAAUV = FRand2( seed ) / iResolution.xy;\n        \n        \n        vec3 vRayJitter = vec3( vBloomUV + vAAUV, 0.0 ) * perpMat;        \n        \n        vRayDir2 += vRayJitter;\n        \n        PathColor colResult = TraceScene( vRayOrigin2, vRayDir2, wave, seed );\n                \n#if SPECTRAL      \n        \n        //colResult.fIntensity = 4.0;\n        \n    \tvColor += colResult.fIntensity * wave.rgb;\n#endif        \n\n#if RGB\n    \tvColor += colResult.vRGB;\n#endif        \n        \n        // noise\n\t    //vColor.rgb += SRand(seed) * 0.5;        \n        \n        Rand( seed );        \n    }\n    \n    //vColor = XYZtoRGB( vColor );\n#if SPECTRAL\n    \n#if 0\n    //hacking around...\n    Chromaticities Primaries_Rec709_SampleAvg =\n\tChromaticities(\n        vec2( 0.6400, 0.3300 ),\t// R\n        vec2( 0.3000, 0.6000 ),\t// G\n        vec2( 0.1500, 0.0600 ), \t// B\n        vec2( 1.0 / 3.0 ) );\t// W\n    \n    mat3 m = RGBtoXYZ(Primaries_Rec709_SampleAvg) * XYZtoRGB( Primaries_Rec709 );\n    vColor = vColor * m;\n#endif    \n    \n    vColor *= 3.0;\n#endif \n        \n    vFragColor = vec4( vColor, iPathsTraced );\n    vFragColor = max( vFragColor, vec4(0) );\n    \n    vec4 vLast = texelFetch( iChannel0, ivec2(vFragCoord), 0 );\n    \n    vLast = max( vLast, vec4(0) );\n\n    if ( cam.bStationary )\n    {\n\t    vFragColor += vLast;\n    }\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}