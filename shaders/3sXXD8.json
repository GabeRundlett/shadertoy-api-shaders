{
    "Shader": {
        "info": {
            "date": "1551748349",
            "description": "Álex Gómez Cortés\n",
            "flags": 32,
            "hasliked": 0,
            "id": "3sXXD8",
            "likes": 1,
            "name": "Metaballs - SDF",
            "published": 3,
            "tags": [
                "light"
            ],
            "usePreview": 0,
            "username": "Elgoms",
            "viewed": 322
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv);\n    \n    float strength = 32.0;\n    \n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 10.0);\n\tvec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n    \n    #ifdef FILM_GRAIN\n    \n\tfragColor += color + grain;\n    \n    #else\n     fragColor =  texture(iChannel0, fragCoord.xy/iResolution.xy);\n\n    \n    #endif //FILM_GRAIN\n    \n    #ifdef PIXELATE_EDGE\n    \n    #ifdef FILM_GRAIN\n      vec4 c = vec4 ( fwidth( texture( iChannel0, fragCoord.xy / iResolution.xy ).x *64.0) );\n    c= floor(c);\n    fragColor += 1.0-c;\n    #else\n    vec4 c = vec4 ( fwidth( texture( iChannel0, fragCoord.xy / iResolution.xy ).x *64.0) );\n    c= floor(c);\n    fragColor = 1.0-c;\n    \n    #endif // FILM_GRAIN\n    \n    #else\n    \n    #ifdef FILM_GRAIN\n     fragColor +=  texture(iChannel0, fragCoord.xy/iResolution.xy);\n    #else\n     fragColor =  texture(iChannel0, fragCoord.xy/iResolution.xy);\n    #endif //FILM_GRAIN\n    #endif //PIXELATE_EDGE\n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat sdPlaneY(vec3 p) { return p.y; }\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\nfloat sdBox   (vec3 p, vec3  b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat opUnion       (float d1, float d2) { return min( d1, d2); }\nfloat opIntersection(float d1, float d2) { return max( d1, d2); }\nfloat opSubstraction(float d1, float d2) { return max(-d1, d2); }\nvec3  opRepetition  (vec3 pos, vec3 frq) { return mod(pos, frq) - 0.5 * frq; } \n\n\nfloat opBlend(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n\n#define MIN(dst, src) dst = mix(src, dst, step(dst.x, src.x))\nvec2 mapScene(vec3 pos)\n{\n    float t = iTime * 2.;\n    vec2  a = vec2(kFarPlaneDist, 0), b = a;\n    \n    b = vec2(opSubstraction(sdBox(pos, vec3(10)), sdBox(pos, vec3(100))), 0); MIN(a, b);\n    \n\n\tfloat p0= opBlend(sdSphere(pos, 1.), sdSphere(pos + 2. * vec3(sin(t*.11), cos(t*.24), cos(t*.33)), 1.), 0.5);\n    p0 = opBlend(p0, sdSphere(pos + 1.5 * vec3(cos(t*.21), cos(t*.23), sin(t*.45)), 1.), 0.5);\n\n   \n    float p1= sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(5, 5, .015));\n    p1 = opUnion(p1, sdBox(opRepetition(pos, vec3(.25,0,.25)), vec3(.015, 5, 5)));\n\tb  = vec2(opIntersection(p0, p1), 1); MIN(a, b);\n    \n\treturn a;\n}\n\n//\tEntradas:\tro - Origen del rayo.\n//\t\t\t\trd - Dirección del rayo.\n//\tSalida:\t\tvec4(totalDistance, lastStepDistance, materialID, steps). \n#ifndef CFG_USING_ENHANCED_RAYMARCHING\nvec4 castRay(vec3 ro, vec3 rd)\n{\n    float  t   = kNearPlaneDist;\n    vec2   res = vec2(kFarPlaneDist, 0);\n    int    i   = 0;\n    for (; i < kMaxSteps; ++i)\n    {\n\t    res    = mapScene(ro + rd * t);\n        if ((res.x < kEpsilon) || (t > kFarPlaneDist))\n            break;\n        t += res.x;\n    }\n    return vec4(t, res.xy, i);\n}\n#else// CFG_USING_ENHANCED_RAYMARCHING\nvec2  gTexelSize  ; // Pixel size   (screen domain).\nfloat gTexelRadius; // Pixel radius (screen domain).\n\nvec4 castRay(vec3 ro, vec3 rd)\n{\n\tgTexelSize    = 1. / iResolution.xy;\n\tgTexelRadius  = length(gTexelSize) ;\n    \n    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;\n    vec2  res = vec2(kFarPlaneDist, 0);\n\tint   i   = kMaxSteps;\n    for (; (i >= 0) && (t < kFarPlaneDist); --i)\n    {\n        res = mapScene(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {//\tError detectado, deja de aplicar la optimización \"over-relaxation raymarching\".\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {// Actualiza el error.\n            if (err < prevErr     ) { res.x = t; prevErr = err; }\n            if (err < gTexelRadius) break; // Aplica \"screen-space aware intersection point selection\".\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, kMaxSteps - i);\n}\n#endif//CFG_USING_ENHANCED_RAYMARCHING\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(kEpsilon, 0, 0);\n\treturn normalize(vec3(mapScene(pos + epsilon.xyy).x - mapScene(pos - epsilon.xyy).x, mapScene(pos + epsilon.yxy).x - mapScene(pos - epsilon.yxy).x, \n        mapScene(pos + epsilon.yyx).x - mapScene(pos - epsilon.yyx).x));\n}\n\nmat3 computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvec4 deferredCompression(mat3 ca, vec3 pos, vec3 ro, vec3 nor, mat3 viewMat, vec4 res)\n{\n        \n     float a = (kFarPlaneDist + kNearPlaneDist) / (kFarPlaneDist - kNearPlaneDist);\n     float b = 2.0 * kFarPlaneDist * kNearPlaneDist / (kFarPlaneDist - kNearPlaneDist);\n     float depth = a + b/ -length(ro - pos);\n    \n    vec3 viewSpaceNormal = inverse(viewMat) * nor;\n    //compactamos la normal en un vec2\n    vec2 compactedNormal= viewSpaceNormal.xy * 0.5 + 0.5;\n    \n    return vec4(compactedNormal, depth, res.z);\n}\n\n\n//  Función principal.\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // Coordenadas UV en el rango [0,1].\n\tvec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // Coordenadas UV en el rango [0,1] con Aspect Ratio aplicado.\n    \n    vec3 pos, nor, col; // Posición, normal, color.\n    vec4 res; // Resultados del trazado de rayos.\n    \n    \n\t// Configura la cámara.\n    vec3 ro = vec3(sin(iTime * .35) * (4. + sin(iTime)), 1, cos(iTime * .35) * (3. + cos(iTime)));\n    vec3 ta = vec3(0);\n    mat3 ca = computeCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.0));\n    vec3 lightVec;\n    vec3 halfVec;\n    \n    // Traza el rayo y calcula la posición en mundo de la superficie impactada.\n    res = castRay(ro, rd); //cast ray te devuekve un vec 4 que en x tiene la longitud del rayo\n    pos = ro + rd * res.x;    \n    nor = computeNormal(pos);\n\n     vec2 compactedNormal= nor.xy * 0.5 + 0.5;\n    \n    fragColor = deferredCompression(ca, pos, ro, nor, ca, res);\n\n    //fragColor = vec4(pos, 1);\n \n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\t#define CFG_USING_ENHANCED_RAYMARCHING\n\n  \t#define CFG_USING_DISCONTINUITY_REDUCTION\n\n\nconst float kNearPlaneDist =   0.1;\t// Distancia al plano cercano.\nconst float kFarPlaneDist  =  50.0;\t// Distancia al plano lejano.\nconst float kEpsilon       = 0.001;\t// Valor de epsilon para comparaciones de distancia.\nconst float kPi\t\t\t   = 3.14159265359;\nconst int   kMaxSteps      =    64;\t// Número máximo de pasos del trazado de rayos.\nconst int   kMaxLightSteps =    16; // Número máximo de pasos del trazado de rayos de iluminación. \nconst float goldRefractiveIndex = 0.27732;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvec3[] gMaterials  = vec3[](vec3(1, 0, 0), vec3( 1, 1,.9));\nvec3[] gLightPos   = vec3[](vec3(4, 4, 4), vec3(-4, 4,-4));\nvec3[] gLightCol   = vec3[](vec3(1,.9,.5), vec3(.5,.9, 1));\nvec3   gAmbientCol = vec3(.1,.2,.3);\n\nfloat Fresnel(float R_0, vec3 lightVec, vec3 halfVec)\n{\n\treturn pow((R_0 + (1.f-R_0)*(1.f-(dot(halfVec,lightVec)))), 5.f);\n}\n\nfloat Distribution(vec3 nor, vec3 halfVec, float roughness)\n{\n    return (pow(roughness, 2.f)/(kPi * pow((pow(dot(nor, halfVec),2.f) * (pow(roughness, 2.f) - 1.f) + 1.f), 2.f)));\n}\n\nfloat Geometry(vec3 lightVec, vec3 halfVec, vec3 viewVec, vec3 nor)\n{\n    return ((dot(nor, lightVec) * dot(nor, viewVec)) / (pow(dot(viewVec, halfVec), 2.f)));\n}\n\nfloat BRDF(vec3 halfVec, vec3 viewVec, vec3 lightVec, vec3 nor)\n{\n    float temp = goldRefractiveIndex - 1.f; // 0.27732 indice de refraccion del oro\n    float R_0 = ((pow(temp, 2.f)) / (goldRefractiveIndex + 1.f));\n    return ((Fresnel(R_0, lightVec, halfVec) * Geometry(lightVec, halfVec, viewVec, nor)\n             * Distribution(nor, halfVec, 0.2f)) / (4.f*(dot(nor, lightVec) * dot(nor, viewVec))));\n}\n\nmat3 computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n\n\n\n\n\n\n//\tcomputeShading() calcula la iluminación con difusa de Lambert y especular de Blinn-Phong.\n//\tEntradas:\tpos - Posición en mundo de la superficie.\n//\t\t\t\tnor - Normal de la superficie.\n//\t\t\t\tviewVector - Vector vista.\n//\t\t\t\tmatID      - Índice de material en gMaterials.\n//\t\t\t\tlightID    - Índice de luz en gLightPos y gLightCol.\n//  Salida:\t\tColor resultante.\n\nvec3 computeShading(vec3 pos, vec3 nor, vec3 viewVector, int matID, int lightID)\n{\n    vec3 lightVec = normalize(pos - gLightPos[lightID]);\n\tvec3  col = vec3(0), halfVec  = normalize(-lightVec - viewVector);\n\t//col = col + gLightCol[lightID] * gMaterials[matID] * clamp(dot(nor, -viewVector), 0., 1.); // Cálculo de difusa.\n    col = col + gLightCol[lightID] * gMaterials[matID]* pow(clamp(dot(nor, halfVec), 0., 1.), 5.); // Cálculo de especular.\n\t//col = col + gLightCol[lightID] * BRDF(halfVec, viewVector, lightVec, nor) * 0.628281; // Cálculo de especular.\n\treturn \tcol;\n}\n\nvec3 uncompactedNormal(vec4 compactedVec4, mat3 viewMat)\n{\n    vec3 uncompactedNormal = vec3(compactedVec4.xy * 2.0 - 1.0, 0.);\n    uncompactedNormal.z = -sqrt(1.0 -dot(uncompactedNormal.xy, uncompactedNormal.xy));\n    vec3 worldSpaceNormal = viewMat * uncompactedNormal;\n\n    return worldSpaceNormal;\n    \n}\n\nvec3 uncompactedPos(vec4 compactedVec4, vec3 ro, vec3 rd)\n{   \n   \n    const float a = (kFarPlaneDist + kNearPlaneDist) / (kFarPlaneDist - kNearPlaneDist);\n    const float b = 2.0 * kFarPlaneDist * kNearPlaneDist / (kFarPlaneDist - kNearPlaneDist);\n    vec3 surfaceWorldPos = ro + rd *(b / (a - compactedVec4.z));\n    return surfaceWorldPos;\n \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor =  texture(iChannel0, fragCoord.xy/iResolution.xy);\n   \n    \n    \n    vec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // Coordenadas UV en el rango [0,1] con Aspect Ratio aplicado.\n    vec3 ro = vec3(sin(iTime * .35) * (4. + sin(iTime)), 1, cos(iTime * .35) * (3. + cos(iTime)));\n    vec3 ta = vec3(0);\n    mat3 ca = computeCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.0));\n    \n    vec3 normal = uncompactedNormal(fragColor, ca);\n    vec3 pos = uncompactedPos(fragColor, ro, rd);\n    \n    vec3 col;\n    \n    \n    for(int i=0; i<2; i++)\n    {\n        col+=computeShading(pos, normal, rd, int(fragColor.w), i);\n    }\n   \n    fragColor = vec4(col,1);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}