{
    "Shader": {
        "info": {
            "date": "1511913177",
            "description": "ray marching experiments",
            "flags": 0,
            "hasliked": 0,
            "id": "XlsfD4",
            "likes": 0,
            "name": "AV Ray Marching",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "AVitt",
            "viewed": 585
        },
        "renderpass": [
            {
                "code": "\nint raySteps = 33;\n\nvec3 sunColour = vec3(1.0,0.9,0.75);\nvec3 sunDirection = vec3(0.4,1.0,-0.3);\n\nvec3 fogColour = vec3(0.85,0.85,0.9);\n\nfloat plane(vec3 p)\n{\n    \treturn p.y;\n}\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat cube(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat fractalBox( vec3 p, vec3 b )\n{\n    vec3 q = fract(p)*1.0-0.5;\n    vec3 d =  abs(vec3(q.x,p.y-0.5,q.z))-b;\n    //vec3 d = abs(fract(p)*2.0-1.0)-b; \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(d1,-d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n//------------------------------------\nfloat map(vec3 p)\n{\n    float result = opU( plane(p), cube(p+vec3(0.0,-1.0,-4.0) , vec3(1.0,5.6,1.0))  );\n          result = opU( result  , cube(p+vec3(4.0,-1.0,-4.0) , vec3(1.0,4.6,1.0))  );\n    \t  result = opU( result  , cube(p+vec3(-4.0,-1.0,-4.0), vec3(1.0,3.8,1.0)) );\n \n    \t  result = opU( result  , cube(p+vec3(0.0,-1.0,4.0) , vec3(1.0,6.6,1.0))  );\n          result = opU( result  , cube(p+vec3(4.0,-1.0,4.0) , vec3(1.0,4.2,1.0))  );\n    \t  result = opU( result  , cube(p+vec3(-4.0,-1.0,4.0), vec3(1.0,5.2,1.0)) );\n              \t  \n    \t  result = opU( result  ,    fractalBox( p+vec3(0.0,0.5,0.0), vec3(0.480,0.015,0.480) ) );\n    \n    \t  result = opS( result  , sphere(p+vec3(-sin(iTime*1.25)*4.0,-1.0,4.0), 1.0*-sin(iTime*5.+5.)+0.5) );\n          result = opS( result  , sphere(p+vec3(sin(iTime*1.25)*4.0,-1.0,-4.0), 1.25) );\n           \n\treturn result;\n}\n\nfloat rayMarch(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for(int i = 0; i<raySteps; i++)\n    {\n        float precis = 0.00001*t;\n        vec3 p = o+r*t;\n        float d  = map(p);\n        //float d1 = map(p+vec3(0.0,0.0,4.0));\n        //float f = opU(d,d1);\n        if( d < precis || t>1000. ) break;\n        t += d;\n    }\n    return t;\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.5, 0.5, 0.5);\n    float res = rayMarch(ro,rd);\n    \n    vec3 pos = ro + res*rd;\n    vec3 nor = calcNormal( pos );\n    \n    vec3  lig = normalize( sunDirection );\n\tfloat amb = clamp( 1.0*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, dif );\n    \n    vec3 lin = vec3(0.0);\n         lin += 1.00*dif*sunColour;\n    \t lin += 0.50*amb;\n         lin += 0.50*dom;\n         lin += 0.50*bac;\n    \t col = col*lin;\n\n    \tcol = mix( col, fogColour, 1.0-exp( -0.001*res*res*res ));\n    \n    return vec3( clamp(col,0.0,1.0) );\n}\n//------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y; \n    \n    float the = iTime * 0.1;\n    \n    vec3 r = normalize(vec3(uv,1.2));\n    vec3 o = vec3(0.0,3.0,-8.0);\n        \n    o.xz *= mat2(cos(the),-sin(the),sin(the),cos(the));\n    r.xz *= mat2(cos(the),-sin(the),sin(the),cos(the));\n    \n    vec3 col = render(o,r);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}