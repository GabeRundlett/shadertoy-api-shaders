{
    "Shader": {
        "info": {
            "date": "1653233091",
            "description": "My flower experiments from 2021, part I\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "7ddyz7",
            "likes": 21,
            "name": "Marmalade Flower I",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "flower",
                "scattering",
                "ss",
                "fxaa",
                "salute"
            ],
            "usePreview": 0,
            "username": "luckyballa",
            "viewed": 384
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n\n    fragColor = texture(iChannel0, uv);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_STEPS 60\n#define MAX_DIST 60.\n#define SURF_DIST .001\n#define PI 3.1415926535\n#define PHI 1.57079632679 // pi / 2\n#define TAU 6.28318530718 // 2 * pi\n#define tex(p) texture(iChannel0, p).rgb\n//#define MOUSE_CONTROL\n\n\nconst float DEG_TO_RAD = PI / 180.0;\n\n\nfloat hash(float x) {\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\n\nvec3 hash3( float n ) {\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat smax( float a, float b, float k ) {\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat sdSegment(vec3 p, float L, float r) {\n    p.y -= min(L,max(0.0,p.y));\n    return length(p)-r;\n}\n\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec3 rot(vec3 P, float a, vec3 A) {\n    vec3 O = dot(P, A) * A;\n    return O + (P-O) * cos(a) -  cross(A,P) * sin(a);\n}\n\n\nvec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb ) {\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    return dif;\n}\n\nfloat G1V ( float dotNV, float k ) {\n    return 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n        float alpha = roughness*roughness;\n    vec3 H = normalize (V + L);\n\n    float dotNL = clamp (dot (N, L), 0.0, 1.0);\n    float dotNV = clamp (dot (N, V), 0.0, 1.0);\n    float dotNH = clamp (dot (N, H), 0.0, 1.0);\n    float dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n    float D, vis;\n    float F;\n\n    float alphaSqr = alpha*alpha;\n    float pi = 3.1415926535;\n    float denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n    D = alphaSqr / (pi * denom * denom);\n\n    float dotLH5 = pow (1.0 - dotLH, 5.0);\n    F = F0 + (1.0 - F0)*(dotLH5);\n\n    float k = alpha / 0.1;\n    vis = G1V (dotNL, k) * G1V (dotNV, k);\n\n    return D * F * vis;\n}\n\nfloat specular(vec3 p, vec3 rd, vec3 n, vec3 lp) {\n    vec3 ld = normalize(lp - p);\n    float roughness = 0.375;\n    return GGX(n,-rd, ld,roughness, 0.2);\n}\n\nvec3 rayDir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nfloat flowerSDF(vec3 p, float size) {\n    p.y += p.y * 1.1;\n    vec3 q = p;\n\n    float n = 12.;\n    float a = TAU / n, ha = 0.5 * a;\n    p.xz = sin(mod(atan(p.z, p.x) - ha, a) - ha + vec2(PHI, 0.0)) * length(p.xz);\n    p = rot(p, 0.9, vec3(0., 0., 1.));\n\n    p = opRepLim(p, 0.3, vec3(0., -2., 0.), vec3(0., 4., 0.));\n    p.x -= p.x * .55;\n    p.z -= length(p.xz) * .5 * sign(p.z);\n    p.y += sin(dot(q.xz, q.xz) * 5.) * 0.05;\n    p = p - vec3(0.2 + q.y * 0.3, 0., 0.0);\n    p.xy -= fbm(p.zy * 15.) * 0.075;\n    \n    return  length(p) - size;\n   }\n\n\nvec2 getDist(vec3 p) {\n    float matId;\n\tvec3 hp = p;\n    hp = rot(hp, PHI / 3., vec3(0.,0., 1.));\n\n    float flower = flowerSDF(hp - vec3(0.0, 0.75, 0.), 0.2);\n    \n    vec3 sp = hp;\n    sp.x = 0.25 * atan( hp.x, hp.z );\n    sp.z = acos( hp.y/length(hp) );\n    sp.xz = (mod(20.0*(sp.xz+0.5),1.0) - 0.5)/20.;\n    sp.y -= 1.;\n\n    float c = sdSphere(hp - vec3(0. ,1., 0.), 0.4);\n    float c2 = sdSphere(hp - vec3(0. ,0.75, 0.), 0.4);\n    float s = smax(sdSegment(sp, 0.5, 0.01), c, 0.1);\n    \n    vec3 lp = hp;\n    lp.y -= 0.5;\n    lp.z -= 0.1;\n    lp.xz -= exp(lp.y) * sign(hp.xz) * 0.1;\n    lp = opRepLim(lp, 0.2,  vec3(-1., 0., -1.), vec3(0., 0., 0.));\n    lp.xz += sin(exp(lp.y * 2.) - iTime) * 0.02;\n    float cr = mod(atan(hp.x, hp.z), 3.) * 0.05;\n    s = min(s, sdSegment(lp, 1.1 - cr, 0.02));\n    \n    vec3 stp = rot(hp, 0.3, vec3(0., 0., 1.));\n    stp.x -= 0.1;\n    stp.y += 3.5;\n    stp.z += sin(smoothstep(1., -5., hp.y) * 4.) * 0.4;\n    \n    float stem = sdSegment(stp, 4.5, 0.075);\n    flower = smin(flower, s, 0.01);\n    flower = smin(flower, stem, 0.01);\n    flower = smin(flower, c2, 0.1);\n    \n    vec3 cp = rot(hp, 0.75, vec3(0., 0., 1.));\n    cp.y *= 0.8; cp.x -= 0.3; cp.z += 0.2; cp.y -= 0.3;\n    flower = smin(flower, sdSphere(cp, 0.1), 0.4);\n    float fin = flower;\n    \n    vec3 fxp = hp;\n    fxp = abs(fxp);\n    fxp.xz -= 1.;\n    fxp = rot(fxp, sin(iTime / 4.), vec3(1., 0., 1.));\n    fxp = abs(fxp);\n    float ft = abs(sin((iTime - 2.) / 8.));\n    float fx = sdSphere(fxp - 1., 0.04);\n    fx = smin(fx,  sdSphere(fxp  - ft * 3., 0.04), 0.2);\n    fxp = rot(fxp, cos(iTime / 4.), vec3(0., 0., 1.));\n    fx = smin(fx,  sdSphere(fxp - 0.75, 0.04), 0.3);\n\n    fin = min(fx, fin);\n    matId = 1.;\n    if (fx < flower) {\n      matId = 2.;\n    }\n    \n    return vec2(fin, matId);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 res = getDist(p);\n        float dS = res.x;\n        dO += dS;\n        matId = res.y;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec3 normals(vec3 p, float of ) {\n\tfloat d = getDist(p).x;\n    vec2 e = vec2(of, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).x,\n        getDist(p-e.yxy).x,\n        getDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n//https://www.shadertoy.com/view/lllBDM\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd, vec3 lp,vec3 ld) {\t\t\n\tfloat latt = pow(length(lp-p)*.15, 3.) * 4.;\n\tvec3 diff = vec3(.0,.5,1.) * (max(dot(n, ld),0.) ) / latt;\n    vec3 col =  diff * 0.1;\n\tfloat trans =  pow( clamp( dot(-rd, -ld+n), 0., 1.), 1.) + 1.;\n\tcol += vec3(1.,.2,.35) * (trans / latt ) ;\n    col += vec3(specular(p, rd, n, lp)) * 0.25;\n    col += smoothstep(1., 0.6, dot(-rd, n)) * 0.1;\n\n\treturn col;\n}\n\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mo = vec2(0.5, -0.3) * vec2(sin(iTime / 2.), max(cos(iTime / 2.), 0.)) * 0.4;\n    #if defined(MOUSE_CONTROL) \n    mo = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    #endif\n    \n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 2.;\n\n\tvec3 ro =  vec3( 0.0, 0.5, 7.);\n    vec3 rd = rayDir(45.0 , iResolution.xy, fragCoord.xy);\n\n\tmat3 rot = rotationXY(mo.yx  * PI);\n\trd = rot * rd;\n\tro = rot * ro;\n    \n    vec2 d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d.x;\n    vec3 n = normals(p, 0.003);\n    vec3 lp =  vec3(-3. , -1., 5.);\n\n    if (d.y == 1. || d.y == 2.) {\n        col = shade(p, n, ro, rd, lp, lp - p);\n    }\n    \n    if (d.y == 2.) {\n        float dif = diffuse(p, n, lp);\n        float spec = specular(p, rd, n, lp);\n        vec3 bc = vec3(10., 14., 19.) / 255.;\n        col += mix(bc, vec3(0.5, 0.5, 1.) * (dif + spec), smoothstep(0., 1., dot(-rd, n)));\n     }\n   \n   if (d.y == 0. || d.x > MAX_DIST) {  \n        col = vec3(0.);\n    }  \n    \n    \n    fragColor = vec4(vec3(col),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// FXAA implementation from\n// https://www.shadertoy.com/view/4tf3D8\n#define RES iResolution.xy\n\nvec3 fxaa(vec2 p) {\n\tconst float FXAA_SPAN_MAX   = 16.0;\n    const float FXAA_REDUCE_MUL = 1.0 / 16.0;\n    const float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    vec3 rgbNW = tex(p + (vec2(-1.,-1.) / RES));\n    vec3 rgbNE = tex(p + (vec2( 1.,-1.) / RES));\n    vec3 rgbSW = tex(p + (vec2(-1., 1.) / RES));\n    vec3 rgbSE = tex(p + (vec2( 1., 1.) / RES));\n    vec3 rgbM  = tex(p);\n\n    const vec3 luma = vec3(1.0/3.0);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    vec3 rgbA = .5 * (tex(p + dir * (1./3. - .5)) +\n        \t\t\t  tex(p + dir * (2./3. - .5)));\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  tex(p + dir * (0./3. - .5)) +\n        \t\t\t  tex(p + dir * (3./3. - .5)));\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n    vec3 col = fxaa(uv);\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}