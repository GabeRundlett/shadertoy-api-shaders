{
    "Shader": {
        "info": {
            "date": "1544690374",
            "description": "perlinNoise2D",
            "flags": 0,
            "hasliked": 0,
            "id": "wdfGzn",
            "likes": 7,
            "name": "perlinNoise2D",
            "published": 3,
            "tags": [
                "perlinnoise2d"
            ],
            "usePreview": 0,
            "username": "SLTfbb",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "#define Use_Perlin\n//#define Use_Value\n//#define Use_Simplex\n\n// ========= Noise ===========\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    \n    //return normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat hash21(vec2 p)\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0 * fract(sin(h)*43758.5453123);\n}\n\nfloat perlin_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n                   dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n                   dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nfloat value_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return mix(mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x),\n               mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor(p + (p.x + p.y) * K1);\n    \n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - (o - K2);\n    vec2 c = a - (1.0 - 2.0 * K2);\n    \n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n    \n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\nfloat noise(vec2 p) {\n#ifdef Use_Perlin\n    return perlin_noise(p);\n#elif defined Use_Value\n    return value_noise(p);\n#elif defined Use_Simplex\n    return simplex_noise(p);\n#endif\n    \n    return 0.0;\n}\n\n// ========== Different function ==========\nfloat noise_itself(vec2 p)\n{\n    return noise(p * 8.0);\n}\n\nfloat noise_sum(vec2 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n\tf += 0.2500 * noise(p); p = 2.0 * p;\n\tf += 0.1250 * noise(p); p = 2.0 * p;\n\tf += 0.0625 * noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.2500 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.1250 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.0625 * abs(noise(p)); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs_sin(vec2 p)\n{\n    float f = noise_sum_abs(p);\n    f = sin(f * 1.5 + p.x * 7.0);\n    \n    return f * f;\n}\n\n// ========== Draw ==========\nvec3 draw_simple(float f)\n{\n    f = f * 0.5 + 0.5;\n    return f * vec3(25.0/255.0, 161.0/255.0, 245.0/255.0);\n}\n\nvec3 draw_cloud(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(8.0/255.0, 65.0/255.0, 82.0/255.0),\n              \tvec3(178.0/255.0, 161.0/255.0, 205.0/255.0),\n               \tf*f);\n}\n\nvec3 draw_fire(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(131.0/255.0, 8.0/255.0, 0.0/255.0),\n              \tvec3(204.0/255.0, 194.0/255.0, 56.0/255.0),\n               \tpow(f, 3.));\n}\n\nvec3 draw_marble(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(31.0/255.0, 14.0/255.0, 4.0/255.0),\n              \tvec3(172.0/255.0, 153.0/255.0, 138.0/255.0),\n               \t1.0 - pow(f, 5.));\n}\n\nvec3 draw_circle(vec2 p, float radius, vec3 col, vec3 back)\n{\n    p = 2.0 * p - vec2(iResolution.x/iResolution.y, 1.0);\n    return \tmix(col, back, smoothstep(0.0, 0.01, length(p) - radius)) *\n        \tsmoothstep(0.0, 0.02, abs(length(p) - radius));\n        \t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 uv = p * vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 split = vec2(0.5, 0.5);\n    if (iMouse.z > 0.0) {\n        split += 2.0 * iMouse.xy/iResolution.xy - 1.0;\n    }\n    \n    float f = 0.0;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    if (p.x < split.x && p.y > split.y) {\n        f = noise_itself(uv);\n        col = draw_simple(f);\n    } else if (p.x < split.x && p.y <= split.y) {\n        f = noise_sum(uv);\n        col = draw_cloud(f);\n    } else if (p.x >= split.x && p.y < split.y) {\n        f = noise_sum_abs(uv);\n        col = draw_fire(f);\n    } else {\n        f = noise_sum_abs_sin(uv);\n        col = draw_marble(f);\n    }\n    \n    f = f * 0.5 + 0.5;\n    col = draw_circle(uv, 0.9, col, vec3(f));\n    col = mix(vec3(0.3, 0.0, 0.0), col, smoothstep(0.0, 0.005, abs(p.x - split.x)));\n    col = mix(vec3(0.3, 0.0, 0.0), col, smoothstep(0.0, 0.005*iResolution.x/iResolution.y, abs(p.y - split.y)));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}