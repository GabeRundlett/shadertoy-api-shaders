{
    "Shader": {
        "info": {
            "date": "1649941017",
            "description": "I take 2 rectangles, rotate one of them 45 degrees then remove the overlapping part to make what i think is pretty efficient star of triangles.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt2cRV",
            "likes": 1,
            "name": "Triangle drama.",
            "published": 3,
            "tags": [
                "triangles",
                "hue",
                "trippy",
                "tiling"
            ],
            "usePreview": 0,
            "username": "fyisic123",
            "viewed": 249
        },
        "renderpass": [
            {
                "code": "// Settings\n#define Side_Distortion 27.\n#define Zoom_Distortion_Frequency 8.\n#define Zoom_Distortion_Amount 0.5\n#define Zoom_Distortion_Speed 0.7\n#define Tile_Count 5.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy)/iResolution.y;\n    \n    \n    float screenLength = length(uv);\n    float uvDotP = dot(uv.x, uv.y);\n\n    \n    \n\n\n    uv *=Rot(iTime *.025); // camera rotation\n    uv *= Tile_Count;     \n    uv+= vec2(sin(iTime*.03), cos(iTime*.02)) * 5.;  // camera drift\n    \n    vec2 gv = fract(uv) -.5;\n    \n    vec2 ID = floor(uv);\n    \n    if (mod(ID.x, 2.) == 0.) // flip uv for mirrored effect\n        gv.x *= -1.;\n        \n    if (mod(ID.y, 2.) == 0.)\n        gv.y *= -1.;\n\n       \n    \n    \n    gv *= (Rot(uvDotP *  pow(screenLength, 3.) *  Side_Distortion)); //  side distortion\n    gv *= 1.0 + (Zoom_Distortion_Amount * sin(Zoom_Distortion_Frequency * screenLength + (iTime * Zoom_Distortion_Speed))); // zoom distortion\n\n    vec2 offs = vec2(cos(iTime * 0.123) * cos( iTime), sin(iTime * 0.5))*(0.6*abs(sin(iTime * 0.2))); // Some movement\n    \n    float p = 0.;\n    \n        \n    for(float i=1.; i > 0.; i -= 0.1)  // Get triangles\n    {                        \n        vec2 pos= gv + offs;\n        p = XOR(p,(getStar(pos *Rot (i + iTime * 0.23), i )* pow(smoothstep(0.0, 1., length(pos)), 1.2)));        \n         gv *= Rot( 0.4448 * sin( iTime * 0.1));//RM;  // rotates 25 degrees\n        \n    }\n     \n    \n    \n    \n    fragColor = vec4(hue(atan(gv.x, gv.y)*p)  * p,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat getRect(vec2 uv, float size)\n{\n    return sign(length(max(abs(uv)-size,0.0)));\n}\n\n\nfloat getStar(vec2 uv, float size)\n{    \n    float s = 0.5 * size;\n    return (mod(getRect(uv, s ) + getRect(uv * Rot(radians(45.)), s), 2.)) ;\n}\n\n\nfloat XOR(float a, float b)\n{\n   return a*(1.-b) + b*(1. -a);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}