{
    "Shader": {
        "info": {
            "date": "1590412231",
            "description": "Hexagon pylon sound data visualization experiment.",
            "flags": 64,
            "hasliked": 0,
            "id": "3d2fzK",
            "likes": 40,
            "name": "Hexagon Sound Visualization",
            "published": 3,
            "tags": [
                "sound",
                "hexagon",
                "pylon"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1333
        },
        "renderpass": [
            {
                "code": "/*\n\n    Hexagon Sound Visualization\n    ---------------------------\n\n\tThis is just a sound data visualization experiment... It works well enough, but\n\tI'd call it a work in progress. I put it together in 2D form a while back and\n\tnever got around to the conversion, basically because I thought it'd require lots \n    of thinking. However, it wasn't as bad as I'd imagined.\n\n\tHaving said that, converting sound data to something presentable on a 2D plane \n\twasn't as straight forward as I expected it to be. I decided on a kind of quasi \n    polar representation. Wanting to put this into a single pass complicated things, \n    but it was doable. By far, the best way to do this would be to produce the sound \n    image data in a seperate buffer, then render and color it with a single texture \n    lookup. The downside to taking that route would be having to keep the texture \n    ranges within the camera's field of view.\n\n    Packed hexagons usually require four taps per pass, which can add to the amount\n\tof work the GPU has to perform... Technically, you could render just three \n    hexagons at the triangle vertices of a simplex grid. However, after setup, and so \n\tforth, it'd be a case of diminishing returns. Either way, packing 2D data\n\tinformation into the four channels of a buffer could speed things up also.\n\n\tAnyway, this was patched together pretty quickly, so I wouldn't pay it too much\n\tattention. I'll tidy up the code and comments a little later. By the way, the\n\tsound file comes from FL Studio's SoundCloud collection.\n\n\n\n*/\n\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Grayscale, for that artsy look.\n//#define GRAYSCALE\n\n// Sparkles: Left over from a previous example. They don't really work \n// here, but it's there anyway. :)\n//#define SPARKLES \n\n\n// Apply some glow. It only really looks right on larger objects, so \n// \"HEX_SCALE\" is set to 6 when this is turned on.\n#define GLOW\n\n\n// Hexagonal scale: It's based on hexagons per unit area, so larger numbers\n// give more detail. Detail allows the sound pattern to emerge, but doesn't\n// look as interesting from a 3D perspective. The default attempts to give\n// the best of both worlds.\n#ifdef GLOW\n#define HEX_SCALE 6. // Glow looks better with larger objects.\n#else\n#define HEX_SCALE 12. // No glow, so give it more definition.\n#endif\n\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Camera's XY movement. \nvec2 camXY;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// 2D texture read.\nvec3 getTex(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, fract(p/4. + .5)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n)*2. - 1.;\n    return sin(p*6.2831853 + iTime*2.); \n    \n}\n\n// vec3 to float.\nfloat hash31(vec3 p){\n    return fract(sin(dot(p, vec3(12.989, 78.233, 57.263)))*43758.5453);\n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n\n// Height map value, which is just some sound data converted to 2D and \n// a texture read.\nfloat hm(in vec2 p){ \n    \n     \n    float sndSc = 2.;\n    vec2 hPos = p/sndSc;\n    \n    // Test height, for debugging purposes.\n    //float ns2 = n2D3G(hPos*2. + iTime/2.)*.57 + n2D3G(hPos*4. + iTime)*.34;\n    //ns2 = ns2*.5 + .5;\n    //return ns2;\n    \n    \n    // Surface position.\n    vec2 sHPos = hPos - camXY/sndSc;\n    \n\n    // The sound texture has dimensions 512x2, with the first row containing\n    // frequency data.\n    int ci = int(length(sHPos)*256.);\n    float fft  = texelFetch(iChannel1, ivec2(ci, 0), 0).x;\n\n    // The second row is the sound wave.\n    int sTx = int(sHPos.x*280. + 256.);\n    float wave = texelFetch(iChannel1, ivec2(sTx, 1), 0 ).x;   \n\n\n    float layer = fft;\n    float intensity = fft; //mix(wave, fft, .5);\n\n    // The sound data alone has a lot of inactive periods, so we add in some \n    // background noise just to keep things visually interesting.\n    float ns = n2D3G(hPos*2.5)*.57 + n2D3G(hPos*5.)*.34;\n    ns = ns*.5 + .5;\n\n    // Blinking lights function.\n    float blink = smoothstep(0., .1, mix(ns - .5, intensity - .5, .35));\n    \n    // Mix the texture with the blink height and return.\n    return dot(getTex(p), vec3(.299, .587, .114))*1.5 + blink; \n\n\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2. );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n\n// This is a bound. Technically, it's not a proper distance field, but for\n// this example, no one will notice. :)\nfloat sHexS(in vec2 p, in vec2 b){\n    \n    p = abs(p);\n    return max(p.x*.8660254 + p.y*.5 - b.x, p.y - b.y);\n    //return max(p.y*.8660254 + p.x*.5, p.x) - b.x;;\n}\n*/\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method, which is here:\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n    \n      const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n\n      r -= sf;\n      // Polygon side.\n      return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n    \n}\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method, which is here:\nfloat sCylS(in vec2 p, float r){\n  \n  return length(p) - r;\n    \n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    // Scale.\n    //#define STRETCH\n    #ifdef STRETCH\n\tconst vec2 scale = vec2(1./HEX_SCALE, 1./HEX_SCALE);\n     // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale.x*1.732/2., scale.y);\n    #else\n    const float scale = 1./HEX_SCALE;\n     // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale*1.732/2., scale);\n    #endif\n    \n   \n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // For block corner postions.\n    //const vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, -l, vec2(l.x, -l.y));\n    // Pointed top.\n    //const vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, -l + vec2(l.x, 0), vec2(l.x, -l.y) + vec2(l.x, 0));\n    // Flat top.\n    const vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l + vec2(0., l.y), -l, vec2(l.x, -l.y) + vec2(0., l.y));\n    \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n\n\n        // Local coordinates.\n        p = q3.xy - cntr;\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= (ip)*s; // New local position.\n\n       \n        // Correct positional individual tile ID.\n        vec2 idi = (ip)*s + cntr;\n \n        // The extruded block height. See the height map function, above.\n        float h = hm(idi);\n        \n        // Or just, \"h *= .1,\" for nondiscreet heights.\n        //h = floor(h*15.999)/15.*.1; \n        h *= .1;\n        \n            \n        // The hexagonal cross section. The corners are slightly rounded on this\n        // version, but they don't have to be.\n        #ifdef STRETCH\n        vec2 lu = l/vec2(1.732/2., 1);\n        vec2 pStretch = lu.x<lu.y? vec2(1, lu.x/lu.y) : vec2(lu.y/lu.x, 1);\n        float r = min(lu.x, lu.y)/2.;\n        float di2D = sHexS(p*pStretch, r - .035*r, .2*r);\n        #else\n        float di2D = sHexS(p, scale/2. + .035*scale, .2*scale);\n        //float di2D = sCylS(p, scale/2.);\n        #endif\n\n        // Boring out some of the lower boxes. I like it, but thought it\n        // confused matters.\n        //if(h<1./15.*.15 + .001) di2D = max(di2D, -(di2D + .3*scale));\n\n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h), h);\n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Not used in this example, so we're saving the calulation.\n            //boxID = float(i);\n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec2 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .1;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yz; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n// Glow.\nvec3 gGlow;\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    gGlow = vec3(0);\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        \n        float ad = abs(d + (hash31(rd) - .5)*.05);\n        if(ad<1.){\n            float l2D = ad;//1./(1. + abs(ad));// t; //\n            //if(objID == 0.) \n            \tgGlow += .25*(1. - l2D)/(1. + l2D)/(1. + t);\n        }\n\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(d*d<1e-6 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7;\n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n    \n\t// Camera Setup.\n    camXY = vec2(1.732, 1)*iTime/4.;\n\tvec3 ro = vec3(camXY.x, camXY.y - 1., -2.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .07, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positionin. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.5, 1.5, 1.5);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.33; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec2 svGID = gID;\n    \n    float svObjID = objID;\n    \n    vec3 svGlow = gGlow;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd)*.5), 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID, then using it in conjunction\n            // with sound files to color a height map.\n            \n            // Sound visual scale, ID, surface position.\n            const float sndSc = 2.;\n            vec2 hPos = svGID/sndSc;\n            vec2 sHPos = (hPos - camXY/sndSc);\n            vec2 hPos2 = (sp.xy - svGID)/sndSc;\n            \n            //    float eDist = hex(hPos2.xy); // Edge distance.\n            float cDist = dot(hPos2.xy, hPos2.xy); // Relative squared distance from the center.\n  \n\n\n            // The sound texture has dimensions 512x2, with the first row containing\n            // frequency data.\n            int ci = int(length(sHPos)*256.);\n            float fft  = texelFetch(iChannel1, ivec2(ci, 0), 0).x;\n\n            // The second row is the sound wave.\n            int sTx = int(sHPos.x*280. + 256.);\n            float wave = texelFetch(iChannel1, ivec2(sTx, 1), 0 ).x;   \n\n\n            float layer = fft;\n            float intensity = fft; //mix(wave, fft, .5);\n\n            // The sound data alone has a lot of inactive periods, so we add in some \n            // background noise just to keep things visually interesting.\n            float ns = n2D3G(hPos*2.5)*.57 + n2D3G(hPos*5.)*.34;\n            ns = ns*.5 + .5;\n\n            // Blinking lights function.\n            float blink = smoothstep(0., .1, mix(ns - .5, intensity - .5, .35));\n\n            // Blending.\n            float blend = n2D3G(hPos*4. + intensity*1.)*.5 + .5;\n \n \n            // Texture reads.\n            //vec3 tx = getTex(svGID);\n            // vec3 tx = getTex(sp.xz);\n            vec3 tx = tex3D(iChannel0, sp/4. - .5, sn);\n            tx = smoothstep(0., .5, tx);\n            vec3 tx2 = texture(iChannel0, hPos*1.).xyz; tx2 *= tx2;\n            tx = smoothstep(-.05, .8, tx)*vec3(1, .8, .6);\n            tx2 = smoothstep(-.05, .8, tx2)*vec3(1, .8, .6);\n            \n            // Using the information above to mix in some color.\n            // All of this is made up, so I wouldn't pay it too much attention.\n            vec3 hCol = mix(tx, tx2, .65);\n            float sh = max(1. - cDist*2., 0.);\n            //vec3 colMix = pow(vec3(1.5, 1, 1)*blend, vec3(1, 2.5, 16))*5.;//\n            vec3 colMix = mix(vec3(1, .1, .2), vec3(1, .7, .35), blend)*5.;\n            //vec3 colMix = .5 + .25*cos(6.2831*mix(.0, 1., blend) + vec3(0, 1, 2))*5.;\n            //colMix = mix(colMix.zyx, colMix.xzy*2., sin(intensity*3.14159*2.5 + 3.14159/4.)*.8 + .6);\n            colMix = mix(colMix.zyx, colMix.xzy*2., smoothstep(0., 1., n2D3G(hPos*(3. - layer/8.)))*1.25 - .125);\n            colMix = mix(colMix.zyx, colMix.xzy*2., smoothstep(.5, 1.5, sin(mix(ns - .5, intensity - .475, .5)*3.14159*5.))*1.25 - .125);\n            colMix = mix(colMix, colMix.zyx, .1);\n\n            hCol = mix(hCol/4., hCol*colMix, blink); // Blended, blinking orange.\n            hCol *= sh*.8 + .4;\n\n\n            // Putting little black borders on the hexagon faces.\n            vec2 q = hPos2;\n            float sf = .002;\n            const float sc = 1./HEX_SCALE/sndSc;\n            const float lw = sc*.1;\n            float eDist = sHexS(q, sc/2. + .035*sc, .2*sc);\n            eDist = abs(eDist) - lw;\n            float ht = hm(svGID);\n            \n            // Darker sides with a black rim.\n            //hCol = mix(hCol, vec3(0), (1. - smoothstep(0., sf, eDist))*.9);\n            //eDist = max(eDist, abs(sp.z + ht*.1*2.) - lw/1.); // No black sides.\n            hCol = mix(hCol, vec3(0), (1. - smoothstep(0., sf, eDist))); // Just the rim.\n            //float cDist2 = dot(hPos2.xy - .07, hPos2.xy - .07);\n            //hCol = mix(hCol, hCol*2., (1. - smoothstep(0., sf*2., cDist2 - max(-dot(rd, ld), 0.)*.01)));\n\n\t\t\t// A simple lined pattern along the top.\n            float pat = abs(fract((sp.y*.8860254 + sp.x*.5)*42.) - .5)*2. - .25;  \n            hCol = mix(hCol, vec3(0), (1. - smoothstep(0., .25, pat))*.5);\n                 \n            \n            texCol = hCol;\n             \n            // Greyscale value, just in case people switch to the Britney video, etc.\n            // Stylistically, the example works better with color. The Britney video\n            // looks OK, but I'm more of a Shirley Jones kind of guy. :)\n            #ifdef GRAYSCALE\n            texCol = vec3(1)*dot(texCol, vec3(.299, .587, .114));\n            #endif   \n           \n            \n\n            #ifdef SPARKLES\n            \n            // Putting some blinking colored dots in the background. I did this to liven\n            // things up a bit. It's a little quirky, but looks... interesting, I guess. :D\n            float rnd = fract(sin(dot((svGID), vec2(141.13, 289.97)))*43758.5453);\n            float rnd2 = fract(sin(dot((svGID + .037), vec2(141.13, 289.97)))*43758.5453);\n            rnd = smoothstep(.95, .97, cos(rnd*6.283 + iTime*1.)*.5 + .5);\n            vec3 rndCol = (.5 + .45*cos(6.2831*mix(0., .3, rnd2) + vec3(0, 1, 2)/1.1));\n            rndCol = mix(rndCol, rndCol.xzy, uv.y*.75 + .5);\n            rndCol = mix(vec3(1), rndCol.zyx*20., rnd);\n            \n            texCol *= rndCol;\n            \n            #endif\n            \n\n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n\n        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff + ao*.3 + vec3(.2, .4, 1)*fre*0. + vec3(1, .5, .2)*spec*2.);\n        \n\n    \n        // Shading.\n        col *= ao*sh*atten;\n        \n        \n        //if(objID == 1.) svGlow *= texCol;\n        svGlow *= (ao*sh*atten*.65 + .35);\n      \n        \n\t\n\t}\n    \n\n    \n    // Applying the glow.\n    #ifdef GLOW    \n    // Applying a fiery palatte to the glow\n    vec3 glowCol = pow(vec3(1.5, 1, 1)*svGlow, vec3(1, 2, 3).zyx*2.);\n    \n    // The fiery red is a little overwhelming, so this tones it down a bit.\n    //glowCol = mix(glowCol, glowCol.zyx, max(-rd.y*.25 + .1, 0.));\n\n    // Adding the glow to the scene. Not that it's applied outsite the the object coloring\n    // block because we need to add the glow to the empty spaces as well. When I haven't applied\n    // glow for a while, I tend to forget this. :)\n    col = mix(col, glowCol, glowCol);// + glowCol*glowCol*1.5;\n    \n    #endif\n\n\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 22918,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/fl-studio/saif-sameer-fulcrum-emotion-vs-energy"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}