{
    "Shader": {
        "info": {
            "date": "1648293402",
            "description": "cel shader with webcam",
            "flags": 34,
            "hasliked": 0,
            "id": "slXyzj",
            "likes": 2,
            "name": "Webcam cel shader",
            "published": 3,
            "tags": [
                "celshader"
            ],
            "usePreview": 0,
            "username": "aviii",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "#define SHADES 3.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float Pi = 6.283185307187; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS \n    // applying gaussian blur is important as otherwise the output\n    // will be extremly pixelated{{{\n    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 8.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 6.0; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel colour\n    vec4 Color = texture(iChannel1, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel1, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    \n \n\tfragColor = Color;\n    float intensity = (fragColor.r + fragColor.g + fragColor.b) / 3.;   //Maybe use dot(dirOfLight, surfaceNormal)\n\tfloat shade = floor(intensity * float(SHADES));\n\tfloat brightnessOfShade = shade / float(SHADES);\n\tfloat factor = intensity / brightnessOfShade;\n\tfragColor.rgb /= vec3(factor);\n    vec3 edgeColor = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(((1.0 - edgeColor) * fragColor.rgb),1.0);\n    //fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define emboss mat3(-2, -1, 0, -1, 1, 1, 0, 1, 2)\n#define sobelX mat3(-1, -2, -1, 0, 0, 0, 1, 2, 1)\n#define sobelY mat3(-1, 0, 1, -2, 0, 2, -1, 0, 1)\n#define gaussian mat3(0.0625,0.125,0.0625,0.125,0.25,0.125,0.0625,0.125,0.0625)\nvec2 kpos(int index)\n{\n    return vec2[9] (\n    \tvec2(-1, -1),    \n        vec2(0, -1),\n        vec2(1, -1),\n        vec2(-1, 0),\n        vec2(0, 0),\n        vec2(1, 0),\n        vec2(-1, 1),\n        vec2(0, 1),\n        vec2(1, 1)\n    )[index] / iResolution.xy;\n}\n\nmat3[3] region3x3(sampler2D sampler, vec2 uv)\n{\n    // Create each pixels for region\n    vec4[9] region;\n    \n    //\n    for (int i = 0; i < 9; i++)\n        region[i] = texture(sampler, uv + kpos(i));\n\n    // Create 3x3 region with 3 color channels (red, green, blue)\n    mat3[3] mRegion;\n    \n    for (int i = 0; i < 3; i++)\n        mRegion[i] = mat3(\n        \tregion[0][i], region[1][i], region[2][i],\n        \tregion[3][i], region[4][i], region[5][i],\n        \tregion[6][i], region[7][i], region[8][i]\n    \t);\n    \n    return mRegion;\n\n}\n\nvec3 convolution(mat3 kernel, sampler2D sampler, vec2 uv)\n{\n    vec3 fragment;\n    \n    // Extract a 3x3 region centered in uv\n    mat3[3] region = region3x3(sampler, uv);\n    \n    // for each color channel of region\n    for (int i = 0; i < 3; i++)\n    {\n        // get region channel\n        mat3 rc = region[i];\n        \n        // component wise multiplication of kernel by region channel\n        mat3 c = matrixCompMult(kernel, rc);\n        \n        // add each component of matrix\n        float r = c[0][0] + c[1][0] + c[2][0]\n                + c[0][1] + c[1][1] + c[2][1]\n                + c[0][2] + c[1][2] + c[2][2];\n        \n        // for fragment at channel i, set result\n        fragment[i] = r;\n    }\n    \n    return fragment;    \n\n}\n\nvec3 postConvulsion(mat3 kernel, mat3 picture)\n{\n    vec3 fragment;\n    mat3 c = matrixCompMult(kernel, picture);\n    float r = c[0][0] + c[1][0] + c[2][0]\n                + c[0][1] + c[1][1] + c[2][1]\n                + c[0][2] + c[1][2] + c[2][2];\n    return vec3(r);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    \n    vec3 colX = convolution(sobelX, iChannel0,uv);\n    vec3 colY = convolution(sobelY, iChannel0,uv);\n    \n    vec3 col=vec3(dot(colX,colX)+dot(colY,colY));\n    \n    //vec3 col = convolution(gaussian, iChannel0, uv);\n    \n    //vec4 color = texture(iChannel0,uv);\n    //col = vec3(color.r,color.g,color.b);\n    fragColor = vec4(col,1.0f);\n    \n    //fragColor = texture(iChannel1,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}