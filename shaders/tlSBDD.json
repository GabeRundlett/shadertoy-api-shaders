{
    "Shader": {
        "info": {
            "date": "1598945352",
            "description": " ",
            "flags": 0,
            "hasliked": 0,
            "id": "tlSBDD",
            "likes": 2,
            "name": " copy",
            "published": 3,
            "tags": [],
            "usePreview": 0,
            "username": "RippleZou",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "const int MAX_ITER = 100;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\n\nbool HIT_HOLE = false;\nbool HIT_BARREL = false;\n\nvec3 rotateX(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    1., 0., 0.,\n    0., cos(ang), -sin(ang),\n    0., sin(ang), cos(ang));\n  return rmat * p;\n}\nvec3 rotateY(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), 0., sin(ang),\n    0., 1., 0.,\n    -sin(ang), 0., cos(ang));\n  return rmat * p;\n}\nvec3 rotateZ(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), -sin(ang), 0.,\n    sin(ang), cos(ang), 0.,\n    0., 0., 1.);\n  return rmat * p;\n}\n\nfloat sphere(vec3 pos, float r) {\n  return length(pos) - r;   \n}\n\nfloat barrel(vec3 pos) {\n  float d = sphere(pos, 0.5);\n  pos.y += 0.5;\n  float holed = -sphere(pos, .25);\n  d = max(d, holed);\n  HIT_HOLE = (holed == d) ? true : HIT_HOLE;\n  return d;\n}\n\nfloat placedBarrel(vec3 pos, float rx, float ry) {\n  pos = rotateY(pos, ry);\n  pos = rotateX(pos, rx);\n  pos.y += 2.0;\n  return barrel(pos);\n}\n\nfloat distfunc(vec3 pos) {\n  pos += vec3(iTime);\n  vec3 c = vec3(10.);\n  pos = mod(pos,c)-0.5*c;\n    \n  pos = rotateX(pos, iTime);\n\n  HIT_HOLE = false;\n  HIT_BARREL = false;\n  \n  // Any of you smart people have a domain transformation way to\n  // do a rotational tiling effect instead of this? :)\n  float sphered = sphere(pos, 2.0);\n  float d = sphered;\n  d = min(d, placedBarrel(pos, 0., 0.));\n  d = min(d, placedBarrel(pos, 0.8, 0.));\n  d = min(d, placedBarrel(pos, 1.6, 0.));\n  d = min(d, placedBarrel(pos, 2.4, 0.));\n  d = min(d, placedBarrel(pos, 3.2, 0.));\n  d = min(d, placedBarrel(pos, 4.0, 0.));\n  d = min(d, placedBarrel(pos, 4.8, 0.));\n  d = min(d, placedBarrel(pos, 5.6, 0.));\n  d = min(d, placedBarrel(pos, 0.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 2.4, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.0, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 5.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.2, PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 7.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 7.0 * PI / 4.0));\n  HIT_BARREL = d != sphered;\n\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float m_x = (iMouse.x / iResolution.x) - 0.5;\n    float m_y = (iMouse.y / iResolution.y) - 0.5;\n    vec3 cameraOrigin = vec3(5.0 * sin(m_x * PI * 2.), m_y * 15.0, 5.0 * cos(m_x * PI * 2.));\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    for (int i = 0; i < MAX_ITER; i++) {\n        if (dist < EPSILON || totalDist > MAX_DIST) { break; }\n        dist = distfunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n\n    if (dist < EPSILON) {\n      vec2 eps = vec2(0.0, EPSILON);\n      vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n      vec3 lightdir = normalize(vec3(1., -1., 0.));\n      float diffuse = max(0.2, dot(lightdir, normal));\n      vec2 tc = vec2(pos.x, pos.z);\n      vec3 texcol = texture(iChannel0, tc).rgb;\n\n      vec3 lightcol = vec3(1.);\n      vec3 darkcol = vec3(.4, .8, .9);\n      float sma = 0.4;\n      float smb = 0.6;\n        \n      if (HIT_HOLE) { \n          lightcol = vec3(1., 1., 0.8);\n      } else if (HIT_BARREL) {\n        lightcol.r = 0.95;   \n      } else {\n          sma = 0.2;\n          smb = 0.3;\n      }\n      float facingRatio = smoothstep(sma, smb, \n                                     abs(dot(normal, rayDir)));\n\n      vec3 illumcol = mix(lightcol, darkcol, 1. - facingRatio);\n      fragColor = vec4(illumcol, 1.0);        \n    } else {\n      float strp = smoothstep(.8, .9, mod(screenPos.y * 10. + iTime, 1.));\n      fragColor = vec4(mix(vec3(1., 1., 1.), vec3(.4, .8, .9), strp), 1.);\n    }\n    \n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}