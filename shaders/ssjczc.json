{
    "Shader": {
        "info": {
            "date": "1661629721",
            "description": "I tried making a pattern such that it looks like a spherical force field seen from above, for a 2D game. I'm not very satisfied, because I made part of some shapes inside another shape's coordinates. I've yet to learn how to do this better.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssjczc",
            "likes": 7,
            "name": "2D Sphere Shield",
            "published": 3,
            "tags": [
                "sphere"
            ],
            "usePreview": 0,
            "username": "W_Master",
            "viewed": 347
        },
        "renderpass": [
            {
                "code": "#define PI 3.1416\n\nfloat center(float a, float b, float c)\n{\n    return min(max(a,b),min(max(a,c),max(b,c)));\n}\n\nfloat segDist(vec2 a, vec2 b, vec2 point)\n{\n    vec2 ab = b - a;\n    vec2 ap = point - a;\n    vec2 segp = a + dot(ap, ab) / dot(ab, ab) * ab;\n    \n    segp.x = center(segp.x, a.x, b.x);\n    segp.y = center(segp.y, a.y, b.y);\n    \n    vec2 toSeg = point - segp;\n    \n    return length(toSeg);\n}\n\nfloat shapeDist(vec2 uv, float top)\n{\n    uv.x = .5-abs(0.5-uv.x);\n    float slope = 1./1.5;\n    float pos = 5./8.;\n    float line = max(0., (uv.y-pos)*slope);\n    float area = uv.x - line;\n    area = 1.-step(0., area);\n    \n    //dis = smoothstep(0.05,0.,dis);\n    \n    float dis = segDist(vec2(0,0), vec2(0,5./8.), uv);\n    dis = min(dis, segDist(vec2(0,5./8.), vec2(0.25, 1.), uv));\n    dis = min(dis, segDist(vec2(0.25,1.), vec2(0.5, 1.), uv));\n    dis = min(dis, segDist(vec2(0,0), vec2(0.5, (1.-top)*-0.65), uv));\n    dis *= (1.0 + area * 0.9);\n    return dis;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x /= iResolution.y/iResolution.x;\n    uv *= 3.0;\n    \n    float t = iTime * 0.4;\n    \n    vec3 col = vec3(0);\n    \n    float r = 1.3;\n    float l = length(uv);\n    float v = asin(l/r) / PI * 2.0; // 0 - 1\n    \n    float bandSize = 0.2;\n    float divisions = 4.0;\n    float p = fract(t);\n    float band = 1.-smoothstep(0., bandSize, abs(fract(v*divisions)-p));\n    band += 1.-smoothstep(0., bandSize, abs(fract(v*divisions)-p-1.));\n    band += 1.-smoothstep(0., bandSize, abs(fract(v*divisions)-p+1.));\n    \n    \n    float divs = 5.0;\n    float u = fract(v*divs);\n    float x1 = atan(uv.x, uv.y)/2./PI+0.5;\n    \n    float level = floor(v*divs);\n    float sections = 4.0 * pow(2.,level);\n    float sector = floor(fract(x1 + .5/sections) *sections);\n    sector += fract(level*0.5)*2.;\n    sector += max(2., level);\n    float x = fract(x1*sections);\n    \n    if (level > 0.0)\n        x = fract(x + 0.5);\n    \n    vec2 cellUV = vec2(x,u);\n    float top = 1.-fract(sector * 0.5)*2.;\n    float dist = shapeDist(cellUV, top);\n    \n    float thickness = 0.01 * (2.0+level*0.3);\n    float outline = smoothstep(thickness,0.,abs(dist-0.07));\n    float inner = smoothstep(thickness,0., 0.07-dist);\n    float a = min(1., outline + inner);\n    \n    float shieldOutline = smoothstep(0.01,0.,abs(l/r-1.));\n    float shieldCenter = smoothstep(0.05,0.04,l/r);\n    outline = mix(outline, 1., shieldCenter);\n    \n    float innerPhase = smoothstep(0.25, 0.75, abs(0.5-fract(0.5 * iTime)));\n    //inner *= (0.5 + 0.4 * innerPhase);\n    inner *= 0.5;\n    col = vec3(0);\n    col.z = outline + inner * 0.3;\n    col.y = outline * band + inner * 0.2;\n    col.y = col.y * 0.5 + 0.5 * outline;\n    \n    col = mix(col, vec3(0.1,0.4,0.9), shieldOutline);\n    \n    fragColor = vec4(col,a);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}