{
    "Shader": {
        "info": {
            "date": "1501419088",
            "description": "Simulates a N bits adder. \nTop: the 2 numbers to add ( Mouse.x and y ).  Try 11111111 + 1 :-)  \nResult at bottom.\nEach adder is made of 2 half-adders consisting of and/xor gates: A,B -> AND,XOR",
            "flags": 32,
            "hasliked": 0,
            "id": "lsSfz3",
            "likes": 8,
            "name": "[SH17C] adder",
            "published": 3,
            "tags": [
                "simulation",
                "boolean",
                "computer",
                "logic",
                "electronic",
                "computing"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 820
        },
        "renderpass": [
            {
                "code": "// Simulation of a N bits adder. \n// Multibuffer improved version of https://www.shadertoy.com/view/MlXXDf\n\n#define N 8                   // number of bits. change in all buffers\n\n// --- saved states ----------------------------------------------\n\n#define B(i,j)  bool( T( ivec2(i,j) ).x )\n#define a0(i)   B(i,0)        // bits of the number #1 to be added\n#define b0(i)   B(i,1)        // bits of the number #2 to be added\n#define  s(i)   B(i,2)        // bits of the result number\n#define  a(i)   B(i,3)        // a,b,c: input of binary half-adders\n#define  b(i)   B(i,4)\n#define  c(i)   B(i,5)\n#define  X(i)   B(i,6)        // X,A: output of binary half-adders \n#define  A(i)   B(i,7)\n\n\n// --- utilities -------------------------------------------------\n\n#define T(U)    texelFetch(iChannel0,ivec2(U),0)\n\nvec2 mymin(vec2 l,float l2,bool p) { return l.x < l2 ? l : vec2(l2,p); }\n\n// --- draw line   ( indeed, distance to line. -> l = min(l, line() ). )\nfloat line(vec2 U, vec2 a, vec2 b) \n{\n    U -= a; b -= a;\n    float l = clamp( dot( U,b) / dot(b,b) , 0.,1.);\n    return length(U - l*b);\n}\n // --- draw numbers\nvec4 char(vec2 p, int c) { // access to the image of ascii code c. https://www.shadertoy.com/view/llySRh\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.),dFdy(p/16.) );\n}\nvec4 pInt(vec2 p, float n) { // --- display int3\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n    for (float i = 2.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - vec2(.5*i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// --- display the registers and wires ---------------------------\n\nvoid mainImage( out vec4 O, vec2 U ) \n{     \n    vec2 R = iResolution.xy; \n    U /= R;\n   \n    U *= float(N) + 2.2;\n    int  ix = int(U.x),  iy = int(U.y), j;\n    float x = fract(U.x), y = fract(U.y);\n    float v=0.;\n\n    // --- display registers (adders and general inputs and outputs)\n\n#define col(b) ( b ? 1. : .2 )     // registers aspect \n#define disk(a,b,r) smoothstep(r,r-.01,length(vec2((x-a)*R.x/R.y,y-b)))\n\n     int i = N+1-ix; if (i>=0 && i<N+1) {\n  // for (int i=0; i<N+1; i++)\n  //     if (N+1-ix==i) {\n    \t\tif (iy==N+1 && i<N) // top row: input numbers\n                v = y>.6       ? (x>.1 && x<.6 ? col(a0(i)): 0.) \n                  : y>.1&&y<.5 ? (x>.4 && x<.9 ? col(b0(i)): 0.)\n                  : 0. ;\n\n    \t    else if (iy==0) // bottom row: output numbers\n                v = y>.25 && y<.75 && x<.9 ? col(s(i)): 0.;\n                                 \n            else if (iy==N-i) { // registers a,b,A,X of all half-adders\n                if (y>.5) { x=2.*x;      y = 2.*y-1.; j = 2*i;   }\n                else      { x = 2.*x-1.; y = 2.*y;    j = 2*i+1; }\n                v =  y>.5&&y<.9 ? ( disk(.325,.7,.2)* col(a(j)) +disk(.675,.7,.2)*col(b(j)) )\n                   : y>.0&&y<.4 ? ( x>.2&&x<.45 ? col(A(j)) : x>.55&&x<.8 ? col(X(j)) : 0. )\n                   : 0.;\n               }\n       \n         }\n    \n    // --- display connections\n\n    vec2 l=vec2(1e8,0.); float y0;\n \n    i = N+1-int(U.x); \n    x = float(N+1-i), y = float(N-i), y0=float(N+1); \n    bool c2i=c(2*i+2)&&!c(2*i+1);\n    if (i>=0 && i<N) {\n // for (int i=0; i<N; i++) { x= y= y0= c2i=\n        x = float(N+1-i), y = float(N-i), y0=float(N+1); bool c2i=c(2*i+2)&&!c(2*i+1);\n        l = mymin(l,line(U, vec2(x+.25, y0+.7), vec2(x+.15, y+.9)   ), a(2*i));  // a0 -> a2i\n        l = mymin(l,line(U, vec2(x+.65, y0+.2), vec2(x+.35, y+.9)   ), b(2*i));  // b0 -> b2i\n        l = mymin(l,line(U, vec2(x+.5, .75  ),  vec2(x+.85, y+0.)   ), s(i)  );  // A2i+1-> si\n        l = mymin(l,line(U, vec2(x+.35, y+.6),  vec2(x+.65, y+.4)   ), a(2*i+1));// X2i -> a2i+1\n        l = mymin(l,line(U, vec2(x+.15, y+.5),  vec2(x+.15, y+.7-1.)), c2i);     // carry1\n        l = mymin(l,line(U, vec2(x+.65, y   ),  vec2(x+.15, y+.7-1.)), c(2*i+1));// carry2\n        l = mymin(l,line(U, vec2(x+.15, y+.7-1.),vec2(x+.85-1., y+.4-1.)),c(2*i+2));// carryT\n    }\n    if (i>0) { // segment part covering the left column\n        x++, y++, i--;\n        l = mymin(l,line(U, vec2(x+.15, y+.7-1.),vec2(x+.85-1., y+.4-1.)),c(2*i+2));// carryT\n    }\n    \n    // --- combine registers and connections\n\tO = mix(vec4(v), vec4(0,.75*l.y,1,1), smoothstep(20.,5.,l.x*R.x));\n    \n    // --- display decimal counters \n    \n    O.g += pInt((U-vec2(.5,float(N)+1.5))*2., T(0).y).x; // a0\n    O.g += pInt((U-vec2(.5,float(N)+1. ))*2., T(0).z).x; // b0\n    v=0.;\n    for (int i=0; i<=N; i++) if( s(i) )\n        v += exp2(float(i));\n    O.g += pInt((U-vec2(.5,0))*2.,v).x;                  // s\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Simulation of a N bits adder. \n// Multibuffer version of https://www.shadertoy.com/view/MlXXDf\n\n#define N 8                   // number of bits. change in all buffers\n\n// --- saved states\n\nbool a0[N],b0[N],             // bits of the two numbers to be added\n      s[N+1],                 // bits of the result\n      a[2*N],b[2*N],c[2*N+1], // input of binary half-adders\n      X[2*N],A[2*N];          // output of binary half-adders \n\n#define B(i,j)  bool( T( ivec2(i,j) ).x )\n#define a0(i)   B(i,0)        // bits of the number #1 to be added\n#define b0(i)   B(i,1)        // bits of the number #2 to be added\n#define  s(i)   B(i,2)        // bits of the result number\n#define  a(i)   B(i,3)        // a,b,c: input of binary half-adders\n#define  b(i)   B(i,4)\n#define  c(i)   B(i,5)\n#define  X(i)   B(i,6)        // X,A: output of binary half-adders \n#define  A(i)   B(i,7)\n\n// --- utilities\n\n#define T(U)    texelFetch(iChannel0,ivec2(U),0)\n\n#define rnd(x) fract(4e4*sin((x)*7654.23+17.34))\n\n\nvoid mainImage( out vec4 O, vec2 U ) \n{    \n    int  i = int(U.x), j = int(U.y);\n    if ( i > 2*N+1 || j > 7 ) return;   // out of simulation grid\n\n    float  t = iTime *1.,\n          it = T(vec2(1,0)).w,          // time step\n           T = float(N+4);              // delay to auto-reset\n    \n    // --- init \n    \n    if (iFrame==0 || it >= T || iMouse.z>0. ) {\n         O -= O ;              // reset all registers to false + timer to 0\n                    // the two numbers to be added (from mouse.xy or rnd)\n\t    vec2 m = length(iMouse.xy) > 10.\n                     ? iMouse.xy/iResolution.xy\n                     : rnd(floor(t/T)+vec2(0,.5)); \n\t    if (i+j==0) O.yz = m * exp2(float(N)); // save them in (0,0)\n        \n        for (int i=N-1; i>=0; i--) { // a0,b0 = float2bin(inputs)\n            float b; // vec2 b=floor(m*=2); m -= b; \n            m *= 2.;\n            a0[i] = bool(b=floor(m.x)); m.x -=b;\n            b0[i] = bool(b=floor(m.y)); m.y -=b;\n        }\n        if (j==0) O.x = float( a0[i] );    // save a0 array\n        if (j==1) O.x = float( b0[i] );    // save b0 array\n        \n        return;\n    }\n\n     O = T(U);\n    \n    // --- simulation steps (finite state automata)\n    \n    bool tick = floor(t) > T(0).w;      // clock tick\n    \n    if ( ! tick ) return;               // acts only every dT\n    if (i+j==0) O.w = floor(t);         // save clock step\n    if (i==1&&j==0) O.w++;              // inc time step\n        \n\t// process connections\n    for (int i=0; i<N; i++) {\n         a[2*i]   = a0(i);  b[2*i]   = b0(i);  // input(even adder) = entry\n         a[2*i+1] = X(2*i); b[2*i+1] = c[2*i]; // input(odd adder) = XOR(even),carry\n         c[2*i+2] = A(2*i+1)||A(2*i);          // carry(i+1) = OR(AND(even),AND(odd))\n         c[2*i+1] = A(2*i+1);                  // (for display wire)\n         s[i]     = X(2*i+1);                  // XOR(odd) -> result \n       }\n    s[N] = c[2*N]; // last carry provide an extra bit to the sum.\n        \n    // process gates xor/and\n    for (int i=0; i<2*N; i++)  \n       { X[i] = a[i]^^b[i]; A[i] = a[i]&&b[i]; }\n  \n    \n    \n    // save states\n    O.x = float(  j==0 ? a0(i) // NB: unmodified\n                : j==1 ? b0(i) // NB: unmodified\n                : j==2 ?  s[i]\n                : j==3 ?  a[i]\n                : j==4 ?  b[i]\n                : j==5 ?  c[i]\n                : j==6 ?  X[i]\n                : j==7 ?  A[i]\n                : false );\n}\n   ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}