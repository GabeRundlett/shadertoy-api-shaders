{
    "Shader": {
        "info": {
            "date": "1471312754",
            "description": "A checkerboarded wall, with a small deformed sphere in the middle.",
            "flags": 0,
            "hasliked": 0,
            "id": "4td3WS",
            "likes": 9,
            "name": "Checkered Wall",
            "published": 3,
            "tags": [
                "displacement",
                "lighting",
                "wall",
                "ball",
                "checker",
                "trig"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 800
        },
        "renderpass": [
            {
                "code": "#define MAX_ITERATIONS 256\n#define MAX_DISTANCE 256.\n\n#define EPSILON .001\n#define SHADOW_BIAS .01\n#define PI 3.1415926535897932384626433832795028841971\n\n#define LIGHT_COL vec3(1.,1.,1.)\n#define LIGHT_AMB .15\n#define LIGHT_DIR normalize(vec3(45.,30.,-45.))\n\n#define POINT_COL vec3(1.,1.,0.)\n\n// Distance functions and smooth minimum by the incredible iq\n// Source: https://iquilezles.org/articles/distfunctions\n// Source: https://iquilezles.org/articles/smin\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rot2D(vec2 p, float angle) {\n    angle = radians(angle);\n    float s = sin(angle), c = cos(angle);\n    return mat2(c,s,-s,c) * p;\n}\n\nfloat dstScene(vec3 p) {\n    \n    float disp = sin(p.x*10.+iTime*3.)*.1;\n    disp += cos(p.y*5.-iTime*5.)*.1;    \n    \n    float dst = length(p) - 1. + disp;\n    dst = smin(dst, sdPlane(p, vec4(0.,0.,-1.,1.)), 1.);\n    \n    return dst;\n    \n}\n\nfloat raymarch(vec3 ori, vec3 dir) {\n \n    float t = 0.;\n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n    \tvec3  p = ori + dir * t;\n        float d = dstScene(p);\n        if(d < EPSILON || t > MAX_DISTANCE) {\n            break;\n        }\n        t += d * .75;\n    }\n    return t;\n    \n}\n\nvec3 calcNormal(vec3 p) {\n\tvec2 e = vec2(EPSILON,0.);\n    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),\n                  dstScene(p+e.yxy)-dstScene(p-e.yxy),\n                  dstScene(p+e.yyx)-dstScene(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 getPointLightVector(vec3 p) {\n\t\n    float a = iTime * 2.5;\n    vec3 lp = vec3(cos(a),sin(a),.015)*4.5;\n    \n    return lp - p;\n   \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float hardness )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = dstScene( ro + rd*t );\n        res = min( res, hardness*h/t );\n        t += clamp( h, 0.06, 0.30 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n// Shadows by the incredible iq\n// Source: https://www.shadertoy.com/view/Xds3zN\nvec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sp) {\n \n    vec3 d = vec3(0.);\n    vec3 s = vec3(0.);\n    \n    for(int i = 0; i < 2; i++) {\n\n        vec3 lv = i == 0 ? LIGHT_DIR : getPointLightVector(p);\n        vec3 ld = normalize(lv);\n        \n        float diff = max(dot(ld,n),0.);\n    \tfloat spec = 0.;\n    \n    \tdiff *= softshadow(p, ld, SHADOW_BIAS, MAX_DISTANCE, 128.);\n    \tif(i == 1)\n            diff *= 1.-smoothstep(2.,10.,length(lv));\n            \n    \tif(diff > 0. && sp > 0.)\n        \tspec = pow(max(dot(ld,r),0.), sp);\n    \n        vec3 lc = i == 0 ? LIGHT_COL : POINT_COL;\n    \td += (col*lc*(LIGHT_AMB+diff));\n        s += (lc*spec);\n        \n    }\n    \n    return (col*d)+s;\n    \n}\n\nvec3 shadeObjects(vec3 p, vec3 n, vec3 r) {\n    \n    vec3 col = vec3(0.);\n    vec2  uv = mod(asin(n.xy) / PI + .5, 1.);\n        \n    if(p.z > .9)\n    \tuv = mod(p.xy / 3.5, 1.);\n        \n    col = vec3(1.,0.,0.);\n    float sp = 3.;\n    vec2 ch = mod(uv * 5., 1.);\n    if((ch.x > .5 || ch.y > .5) && !(ch.x > .5 && ch.y > .5)) {\n    \tcol *= .5;\n    \tsp = 60.;\n    }\n     \n    col = calcLighting(col, p, n, r, sp);\n    \n    return col;\n    \n}\n\nvec3 shade(vec3 ori, vec3 dir) {\n \n    float  t = raymarch(ori, dir);\n    vec3 col = vec3(0.);\n    \n    if(t < MAX_DISTANCE) {\n\n        vec3  p = ori + dir * t;\n        vec3  n = calcNormal(p);\n        vec3  r = normalize(reflect(dir, n));\n        col = shadeObjects(p,n,r);\n        \n        vec3  rc = vec3(0.);\n        float rt = raymarch(p+r*SHADOW_BIAS,r);\n        if(rt < MAX_DISTANCE) {\n            vec3 rp = p + r * rt;\n            vec3 rn = calcNormal(rp);\n            vec3 rr = normalize(reflect(r,rn));\n            rc = shadeObjects(rp,rn,rr);\n        }\n        \n        float f = 1. - pow(max(-dot(dir, n), 0.), .25);\n        col = mix(col, rc, f);\n        \n    }\n    \n    vec3 lv = getPointLightVector(ori);\n    vec3 ld = normalize(lv);\n    float f = pow(max(dot(dir,ld), 0.), 30.);\n    f   *= softshadow(ori, ld, 0., length(lv), 64.);\n    col += POINT_COL * f;\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,-4.);\n    vec3 dir = vec3(uv, 1.);\n    \n    vec2 m = ((iMouse.xy - iResolution.xy * .5) / iResolution.y) * -vec2(2.,-2.);\n    if(iMouse.xy == vec2(0.)) m = vec2(0.);\n    ori.xy += m;\n    \n    vec3 f = normalize(-ori);\n    vec3 u = normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 v = normalize(cross(u,f));\n    dir = mat3(u,v,f) * dir;\n    \n\tfragColor = vec4(shade(ori,normalize(dir)),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}