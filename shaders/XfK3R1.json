{
    "Shader": {
        "info": {
            "date": "1712419667",
            "description": "An approach with free entities of variable sizes. Intersections are calculated using Apollonius circles. Performance is highly dependent on the number of circles. Optimizations may be possible. Please let me know in the comments.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfK3R1",
            "likes": 2,
            "name": "Vorono√Ø influence",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "Umbre",
            "viewed": 148
        },
        "renderpass": [
            {
                "code": "//Returns a random real number between -1 and 1.\nfloat random1(vec2 co)\n{\n    return 2.*(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453)-0.5);\n}\nfloat random2(vec2 co)\n{\n    return 2.*(fract(sin(dot(co.xy, vec2(143.9898, 99.233))) * 5453.43758)-0.5);\n}\nvec2 randomVec(vec2 co)\n{\n    return vec2(random1(co), random2(co));\n}\n\n//distance between M and the bisector of [AB].\nfloat dist_mediatrice(vec2 A, vec2 B, vec2 M)\n{\n    vec2 dir = B-A;\n    dir = vec2(dir.y,-dir.x);\n    vec2 O = (B+A)/2.;\n    vec2 OM = M-O;\n    float pvect = OM.x*dir.y - OM.y*dir.x;\n    return abs(pvect)/length(dir);\n}\n\n//colors \nvec3 pal( in float t)\n{\n    return vec3(0.358, 0.028, -2.222)+ vec3(0.488, 0.585, 0.585)*sin(6.28318*(vec3(2.000, 1.000, 1.000)*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    //Number of circles\n    int n = 40;\n    //Random seed :\n    vec2 seed = vec2(-0.362,0.11);\n    \n    //Search for the center with the most influence\n    float d1 = 999.;\n    float r1;\n    vec2 p1;\n    vec2 randVec = seed;\n    \n    for(int i = 0; i < n; ++i)\n    {\n        //Construction of the circle\n        vec2 mvt_centre = randomVec(randVec);\n        float mvt_dist = 3.*random1(mvt_centre);\n        float radius = max(random2(randVec)/ 2.0,0.05);\n        vec2 point = mvt_centre + mvt_dist * vec2(cos(iTime*random1(randVec)),sin(iTime*random2(mvt_centre)));\n        \n        float delta = distance(uv, point)/radius;\n        if(delta < d1)\n        {\n            d1 = delta;\n            p1 = point;\n            r1 = radius;\n        }\n        //New random vector\n        randVec = randomVec(randVec);\n    }\n    \n    //Search for the nearest boundary\n    randVec = seed;\n    float d2 = abs(r1 - distance(uv,p1));\n    \n    for(int i = 0; i < n; ++i)\n    {\n        //Construction of the circle\n        vec2 mvt_centre = randomVec(randVec);\n        float mvt_dist = 3.*random1(mvt_centre);\n        float radius = max(random2(randVec)/ 2.0,0.05);\n        vec2 point = mvt_centre + mvt_dist * vec2(cos(iTime*random1(randVec)),sin(iTime*random2(mvt_centre)));\n        \n        //Distance to the Apollonius circle:\n        float k = r1/radius;\n        vec2 centerApollonius = vec2(p1.x-k*k*point.x,p1.y-k*k*point.y)/(1.-k*k);\n        float radiusApollonius = distance(p1,point)*k/abs(k*k-1.);\n        float ApolloniusDelta = abs(radiusApollonius - distance(uv,centerApollonius));\n        \n        //We handle a special case: if the two radii are equal,\n        //the Apollonius circle has an infinite radius (a line).\n        if(abs(r1-radius) <0.001)\n        {\n            ApolloniusDelta = dist_mediatrice(p1,point,uv);\n        }\n        \n        if(ApolloniusDelta < d2)\n        {\n           d2 = ApolloniusDelta;\n        }\n        //New random vector\n        randVec = randomVec(randVec);\n    }\n    \n    float grad;\n    if(distance(uv,p1)< r1)\n    {\n        grad = clamp(d2/r1,0.,1.);\n    }\n    vec3 col = pal(grad);\n    \n    //Filter for the black background\n    if(distance(col, vec3(0.358, 0.028, -2.222)) < 0.0001)\n    {\n        col = vec3(0.);\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}