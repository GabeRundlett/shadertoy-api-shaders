{
    "Shader": {
        "info": {
            "date": "1457308908",
            "description": "A cheap, classic Catmull-Rom. Useful for object property animation (camera path, etc). The distance field itself is not the point here, although it is a nice way to visualize the resulting spline.",
            "flags": 0,
            "hasliked": 0,
            "id": "ls3SRr",
            "likes": 44,
            "name": "LoopingSpline",
            "published": 3,
            "tags": [
                "catmullrom",
                "looping"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 1582
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : Oct 2014\n// Modified : Jan 2016\n//\n// A quick & simple spline implementation to use in ShaderToy.\n// The spline end folds on the start, making a cyclic path.\n// Computation is reasonably cheap (<.5 ms to solve a value at time=t on my old laptop).\n// The distance field, however, is more expensive to compute (iterative process).\n//\n// Useful for object property animation (camera path, speed, position, size, color, roughness, etc).\n// The distance field itself is not the point here, albeit a nice way to visualize the resulting spline.\n//\n// Note 1 : There is no support for random array index access (only textures/resources), therefore the function\n// \"PointArray()\" was coded.\n//\n// Note 2 : Works with float, vec2, vec3, vec4. Just replace the type. Packaging multiple properties to animate into\n//          a vec4 is most probably more efficient than calling the vec2 function twice with different control points.\n//\n// License : Creative Commons Non-commercial (NC) license\n//\nconst int POINT_COUNT = 8;\nstruct CtrlPts\n{\n    vec2 p[POINT_COUNT];\n};\nvec2 PointArray(int i, CtrlPts ctrlPts)\n{\n    if(i==0 || i==POINT_COUNT  ) return ctrlPts.p[0];\n    if(i==1 || i==POINT_COUNT+1) return ctrlPts.p[1];\n    if(i==2 || i==POINT_COUNT+2) return ctrlPts.p[2];\n    if(i==3) return ctrlPts.p[3];\n    if(i==4) return ctrlPts.p[4];\n    if(i==5) return ctrlPts.p[5];\n    if(i==6) return ctrlPts.p[6];\n    if(i==7) return ctrlPts.p[7];\n    return vec2(0);\n}\n\nvec2 catmullRom(float fTime, CtrlPts ctrlPts)\n{\n    float t = fTime;\n    const float n = float(POINT_COUNT);\n    \n    int idxOffset = int(t*n);\n    vec2 p1 = PointArray(idxOffset,ctrlPts);\n    vec2 p2 = PointArray(idxOffset+1,ctrlPts);\n    vec2 p3 = PointArray(idxOffset+2,ctrlPts);\n    vec2 p4 = PointArray(idxOffset+3,ctrlPts);\n    \n    //For some reason, fract(t*n) returns garbage on my machine with small values of t.\n    //return fract(n*t);\n    //Using this below yields the same results, minus the glitches.\n    t *= n;\n    t = (t-float(int(t)));\n    \n    //A classic catmull-rom\n    //e.g.\n    //http://steve.hollasch.net/cgindex/curves/catmull-rom.html\n    //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n    vec2 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n               + (-p1+p3)*t\n               + 2.*p2);\n    return val;\n}\n\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nvec2 debugDistanceField(vec2 uv, CtrlPts ctrlPts)\n{\n    //This is just to illustrate the resulting spline. A Spline distance field should not be computed this way.\n    //If the real intent was to show a distance field, something like this perhaps should be used:\n    //https://www.shadertoy.com/view/XsX3zf\n    const float MAX_DIST = 10000.0;\n    float bestX = 0.0;\n    \n    //Primary (rough) estimate : decent results with 2 lines per control point (faint blue lines)\n    const int iter = POINT_COUNT*2+1;\n    //const int iter = POINT_COUNT*1+1; //<-Faster\n    //const int iter = POINT_COUNT*3+1; //<-Nicer\n    float primarySegLength = 1.0/float(iter-1);\n    vec2 pA = catmullRom(0., ctrlPts);\n    float minRoughDist = MAX_DIST;\n    float x = 0.0;\n    for(int i=0; i < iter; ++i)\n    {\n        vec2 pB = catmullRom(x, ctrlPts);\n        \n        float d = distanceToLineSeg(uv, pA, pB);\n        pA = pB;\n        if(d<minRoughDist)\n        {\n            bestX = x;\n            minRoughDist = d;\n        }\n         \n        x += primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    //Secondary (smooth) estimate : refine (red curve)\n    const int iter2 = 14;\n    x = max(bestX-1.25*primarySegLength,0.0); //Starting 25% back on previous seg (50% overlap total)\n    float minDist = MAX_DIST;\n    pA = catmullRom(x, ctrlPts);\n    for(int i=0; i < iter2; ++i)\n    {\n        vec2 pB = catmullRom(x, ctrlPts);\n        float d = distanceToLineSeg(uv, pA, pB);\n        pA = pB;\n        \n        if(d<minDist)\n        {\n            bestX = x;\n            minDist = d;\n        }\n         \n        //Covering 1.5x primarySegLength (50% overlap with prev, next seg)\n        x += 1.5/float(iter2-1)*primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    \n    return vec2(minDist,minRoughDist);\n}\n\n//Recenters and scales in the [0-1] range.\nvec2 getUV(vec2 px)\n{\n    vec2 uv = px / iResolution.xx;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CtrlPts ctrlPts;\n\tctrlPts.p[0] = vec2(0.10,0.25);\n    ctrlPts.p[1] = vec2(0.2,0.1);\n    ctrlPts.p[2] = vec2(0.6,0.35);\n    ctrlPts.p[3] = vec2(0.4,0.1);\n    ctrlPts.p[4] = vec2(0.8,0.35);\n    ctrlPts.p[5] = vec2(0.6,0.55);\n    ctrlPts.p[6] = vec2(0.5,0.45);\n    ctrlPts.p[7] = vec2(0.3,0.49);\n    \n    if(iMouse.z > 0.1)\n        ctrlPts.p[2] = getUV(iMouse.xy);\n    vec2 uv = getUV(fragCoord.xy);\n    \n    float fTime = iTime*0.15;\n    vec2 pA = catmullRom(fract(fTime), ctrlPts);\n    vec2 pB = catmullRom(fract(fTime+0.02), ctrlPts);\n    \n    //Compute Distance field\n    vec2 dSeg = debugDistanceField(uv, ctrlPts);\n    \n    //Draw distance field background\n    vec3 c = vec3(dSeg.x*7.0+smoothstep(0.20,0.3,abs(fract(dSeg.x*20.0)-0.5)));\n    \n    //Draw the spline\n    c = mix(vec3(0,0.8,0.9),c,smoothstep(-0.005,0.0035,dSeg.y));\n    c = mix(vec3(1,0  ,0.0),c,smoothstep(0.0,0.0025,dSeg.x));\n    \n    //Draw each control point\n    float minDistP = 10000.0;\n    for(int i=0; i < POINT_COUNT; ++i)\n    {\n        vec2 ctrl_pt = PointArray(i,ctrlPts);\n        minDistP = min(length(uv-ctrl_pt),minDistP);\n    }\n    c = mix(vec3(0,0,1),c,smoothstep(0.008,0.011,minDistP));\n    \n    //Draw moving points\n    c = mix(vec3(0,0.7,0),c,smoothstep(0.008,0.011,length(uv-pA)));\n    c = mix(vec3(0,0.7,0),c,smoothstep(0.008,0.011,length(uv-pB)));\n    c = mix(vec3(1,1,1),c,smoothstep(0.004,0.006,length(uv-pB)));\n\t\n    fragColor = vec4(c,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}