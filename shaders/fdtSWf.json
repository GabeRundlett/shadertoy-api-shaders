{
    "Shader": {
        "info": {
            "date": "1634081469",
            "description": "An analog clock, where the ends of the hands are the roots of the cubic in a Newton fractal",
            "flags": 0,
            "hasliked": 0,
            "id": "fdtSWf",
            "likes": 11,
            "name": "Newton's Clock",
            "published": 3,
            "tags": [
                "2d",
                "fractal"
            ],
            "usePreview": 0,
            "username": "been_jamming",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "//Newton's Clock\n//An analog clock, where the ends of the hands are the roots\n//of the cubic in a Newton fractal\n//\n//Ben Jones - 10/12/2021\n\n#define TOLERANCE 0.0001\n#define PI 3.1415927\n\n//Complex numbers are in the form (a, b) := a + bi\n\nvec2 complex_mult(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 complex_div(vec2 a, vec2 b){\n    return vec2(dot(a, b), a.y*b.x - a.x*b.y)/dot(b, b);\n}\n\n//Credit to @iq: https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment(in vec2 p, in vec2 b){\n    float h = clamp(dot(p,b)/dot(b,b), 0.0, 1.0);\n    return length(p - b*h);\n}\n\n//Used to draw the hands on the clock\n//Anti-aliasing with sdfs is luckily pretty easy\nvec3 clock_hands(vec2 coord, vec2 root0, vec2 root1, vec2 root2){\n    float dist0;\n    float dist1;\n    float dist2;\n    vec3 color = vec3(0.0);\n    float i;\n    float weight;\n    \n    dist0 = sdSegment(coord, root0);\n    dist1 = sdSegment(coord, root1);\n    dist2 = sdSegment(coord, root2);\n    \n    color += vec3(1.0)*clamp(0.25*(0.05 - dist0)*min(iResolution.x, iResolution.y), 0.0, 1.0); \n    color += vec3(1.0)*clamp(0.25*(0.05 - dist2)*min(iResolution.x, iResolution.y), 0.0, 1.0);\n    \n    for(i = 0.0; i < 12.0; i++){\n        dist0 = length(vec2(cos(2.0*PI*i/12.0), sin(2.0*PI*i/12.0)) - coord);\n        color += vec3(1.0)*clamp(0.25*(0.025 - dist0)*min(iResolution.x, iResolution.y), 0.0, 1.0);\n    }\n    \n    weight = clamp(0.25*(0.025 - dist1)*min(iResolution.x, iResolution.y), 0.0, 1.0);\n    color = weight*vec3(1.0, 0.0, 0.0) + (1.0 - weight)*color;\n    \n    return clamp(color, vec3(0.0), vec3(1.0));\n}\n\n//Iterate Newton's method to produce the fractal\nvec3 newtons_iterations(vec2 coord, vec2 root0, vec2 root1, vec2 root2, int iters){\n    int i;\n    //These are the coefficients to the polynomial with the 3 roots\n    vec2 sum;\n    vec2 double_prod;\n    vec2 prod;\n    vec2 coord_cubed;\n    vec2 sum_coord;\n    vec2 val;\n    vec2 deriv;\n    vec3 color = vec3(0.0);\n    float dist0;\n    float dist1;\n    float dist2;\n    float factor;\n    \n    sum = root0 + root1 + root2;\n    double_prod = complex_mult(root0, root1) + complex_mult(root0, root2) + complex_mult(root1, root2);\n    prod = complex_mult(complex_mult(root0, root1), root2);\n    \n    //Here is where we do the actual iteration\n    for(i = 0; i < iters; i++){\n        sum_coord = complex_mult(sum, coord);\n        coord_cubed = complex_mult(coord, complex_mult(coord, coord));\n        val = coord_cubed - complex_mult(sum_coord, coord) + complex_mult(double_prod, coord) - prod;\n        deriv = 3.0*complex_mult(coord, coord) - 2.0*sum_coord + double_prod;\n        coord -= 1.0*complex_div(val, deriv);\n        dist0 = dot(coord - root0, coord - root0);\n        dist1 = dot(coord - root1, coord - root1);\n        dist2 = dot(coord - root2, coord - root2);\n        if(min(dist0, min(dist1, dist2)) < TOLERANCE){\n            break;\n        }\n    }\n    \n    factor = max(TOLERANCE - dist0, 0.0)/TOLERANCE;\n    color += dist0 < TOLERANCE ? vec3(1.0, 0.0, 0.0)*((float(iters - i - 2) + factor)/float(iters)) : vec3(0.0);\n    factor = max(TOLERANCE - dist1, 0.0)/TOLERANCE;\n    color += dist1 < TOLERANCE ? vec3(0.0, 1.0, 0.0)*((float(iters - i - 2) + factor)/float(iters)) : vec3(0.0);\n    factor = max(TOLERANCE - dist2, 0.0)/TOLERANCE;\n    color += dist2 < TOLERANCE ? vec3(0.0, 0.0, 1.0)*((float(iters - i - 2) + factor)/float(iters)) : vec3(0.0);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 coord;\n    vec3 color;\n    float sec_angle;\n    float min_angle;\n    float hr_angle;\n    vec2 root0;\n    vec2 root1;\n    vec2 root2;\n    float lighting;\n    \n    //Get the angle of the sec, min, and hr hands\n    sec_angle = PI/2.0 - mod(2.0*PI*iDate.w/60.0, 2.0*PI);\n    min_angle = PI/2.0 - mod(2.0*PI*iDate.w/3600.0, 2.0*PI);\n    hr_angle = PI/2.0 - mod(2.0*PI*iDate.w/43200.0, 2.0*PI);\n    \n    //Normalized coordinates, center (0, 0)\n    coord.x = fragCoord.x/iResolution.y - iResolution.x/(2.0*iResolution.y);\n    coord.y = fragCoord.y/iResolution.y - 0.5;\n    coord *= 3.0;\n    \n    root0 = 0.85*vec2(cos(min_angle), sin(min_angle));\n    root1 = 0.7*vec2(cos(sec_angle), sin(sec_angle));\n    root2 = 0.4*vec2(cos(hr_angle), sin(hr_angle));\n    \n    lighting = 0.3333/(1.0 + dot(coord - root0, coord - root0)) + 0.3333/(1.0 + dot(coord - root1, coord - root1)) + 0.3333/(1.0 + dot(coord - root2, coord - root2));\n    \n    color = (0.75*clock_hands(coord, root0, root1, root2) + newtons_iterations(coord, root0, root1, root2, 15))*lighting;\n    \n    fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}