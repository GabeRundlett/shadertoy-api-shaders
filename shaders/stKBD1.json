{
    "Shader": {
        "info": {
            "date": "1664470395",
            "description": "I found an interesting CA on this website, and played with it here :)\nhttps://neuralpatterns.io/  <-- strobe/flashing warning",
            "flags": 48,
            "hasliked": 0,
            "id": "stKBD1",
            "likes": 14,
            "name": "Pixel Art Alien Structures",
            "published": 3,
            "tags": [
                "feedback",
                "cellularautomata"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "vec4 cell(ivec2 f) {\n    return texelFetch(iChannel0, f, 0);\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    int frame = iFrame % 120;\n    \n    // Translate and zoom\n    f -= 0.5 * iResolution.xy;\n    f *= 1.1 * dim.y/iResolution.y; \n    f += 0.5 * dim;\n    // s = 1. if right side, 0. if left\n    float s = step(floor(f.x), 0.5 * dim.x);   \n    \n    // Mirrored coords \n    ivec2 ff = ivec2(s * dim.x + (1. - f.x) * (2. * s - 1.), f.y);\n    col = cell(ff);\n    vec4 col2 = cell(ff + ivec2(0,1));\n    vec4 col3 = cell(ff + ivec2(0,2));\n    \n    float g = col.g;\n    float g2 = col2.g;\n    \n    if (frame > 60)\n        col.rgb = col.rrr;\n    if (f.x <= 0. || f.x > dim.x + 2. || f.y > dim.y)\n           col *= 0.;            \n    \n    float v = step(floor(0.5 * dim.x) + 1., f.x);\n    float o = 2. * h21(vec2(floor(float(iFrame) / 120.), 132.));  \n    o += 0.1 * v;\n    float y = f.y / dim.y;\n    col *= 0.5 + 0.5 * v;\n    col *= 0.75 + 0.5 * y;\n    col.rgb *= pal(0.5 * col3.r + 0.1 * y + o + 0.25 * h21(vec2(ff)), vec3(0,1,2)/3.);       \n    if (length(col.rgb) < 0.05)\n        col.rgb += g2 * col2.r * pal(-0.5 + 0.1 * y + o + 0.25 * h21(vec2(ff.x, ff.y - 1)), vec3(0,1,2)/3.);\n    else\n        col *= g;\n  \n    col.rgb = sqrt(col.rgb);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    col = vec4(0.0);\n    ivec2 px = ivec2(f);\n    int frame = iFrame % 120;\n    \n    ivec2 g = ivec2(f + vec2(100.,151.) * iTime * 60.) & 1023;\n    float rand = texelFetch(iChannel2, g, 0).r;\n           \n    if (frame == 0 || key_down(KEY_RESET)) {\n        col.g = rand;\n        return;\n    }\n           \n    // Center cell\n    vec4 e = cell(px);\n    col = e;\n    \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bl = cell(px + ivec2(-1,-1));\n    vec4 br = cell(px + ivec2(1, -1));\n    vec4 tl = cell(px + ivec2(-1, 1));\n    vec4 tr = cell(px + ivec2(1,  1));   \n    \n    vec4 bb = cell(px - ivec2(0,2));\n    vec4 tt = cell(px + ivec2(0,2));\n    vec4 ll = cell(px - ivec2(2,0));\n    vec4 rr = cell(px + ivec2(2,0));  \n    \n    vec4 sum = b + t + l + r;\n    vec4 diag = bl + br + tl + tr;\n    vec4 dif = abs(b-t) * abs(l-r);\n    vec4 dif2 = (t + b) * (l + r);\n    vec4 diDif = (tl + br) * (tr + bl);\n    \n    if (frame < 10) { // run CA\n        col.g = 0.5 * diag.g + 0.2 * sum.g - e.g;\n    } else if (frame == 10) { // invert and map to 0 or 1\n        col.g = 1. - step(0.1, e.g);\n    } else if (frame == 11 && diag.g == 0.) { // connect lines\n       if (b.g+t.g==2. && l.g+r.g==0. && bb.g+tt.g>=1.)  \n           col.g = 1.;\n       else if (l.g+r.g==2. && b.g+t.g==0. && ll.g+rr.g>=1.)  \n           col.g = 1.;         \n    } else if (frame <= 13) { // remove corners\n       if (e.g == 1. && dif2.g == 1.)\n           col.g = 0.;\n    } else if (frame == 14) { \n       if (f.x > dim.x + 1. || f.y > dim.y) // restrict to bounds (slightly wrong)\n           col *= 0.;\n       else if (f.x < 0.5 * dim.x + 1.) // make centre line red\n           col.r = 1.;\n    } else { // traverse greens when adjacent to reds\n        if (e.g == 1. && (sum+diag).r > 0.) \n            col.r = 1.;\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define pi 3.14159\n#define dim vec2(48, 96)\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}