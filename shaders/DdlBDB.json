{
    "Shader": {
        "info": {
            "date": "1689136238",
            "description": "Borrowed from one of IQs shaders.\nAttempts to match the \"gradients\" of the source image (in oklab space) while clamping the colors to the target gamut (RGB).\nGradients are multi-scale finite differences biased towards high frequency details.",
            "flags": 32,
            "hasliked": 0,
            "id": "DdlBDB",
            "likes": 5,
            "name": "Video Contrast Enhancement Test",
            "published": 3,
            "tags": [
                "tonemapping"
            ],
            "usePreview": 0,
            "username": "Hatchling",
            "viewed": 258
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = uv.x > 0.25 ? texture(iChannel0, uv) :  texture(iChannel1, uv);\n    fragColor.rgb = Srgb3(oklab_to_rgb(fragColor.rgb));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n\tfragColor.rgb = rgb_to_oklab(fragColor.rgb);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    //if(labResult.x != 0.)\n    //    labResult.yz /= labResult.x;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    //c.yz *= c.x;\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 targetC = texture(iChannel0, uv).xyz;\n    vec3 currentC = texture(iChannel1, uv).xyz;\n    \n    if(iFrame == 0)\n        currentC = targetC;\n    \n    \n    vec4 noise = texture(iChannel2, fragCoord/iChannelResolution[2].xy) \n    + float(iFrame) * (vec4(0,1,2,3) + 0.61803398874989484820);\n    noise -= floor(noise);\n    \n    vec3 total = vec3(0);\n    float offsetScale = 0. + pow\n    (\n        2.0,\n        noise.y * (log2(iResolution.y) - 1.0)//1.0 / (noise.y*noise.y+0.125)\n    );\n    \n    float angle = noise.x * 3.1415927 * 2.;\n    float sinAng = sin(angle);\n    float cosAng = cos(angle);\n    \n    \n    mat2x2 rotationMatrix = mat2x2\n    (\n        vec2(cosAng, -sinAng),\n        vec2(sinAng, cosAng)\n    );\n    \n    \n    \n\n    int count = 0;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            if(x == 0 && y == 0) continue;\n            vec2 offset2D = vec2(x,y)*offsetScale;\n            \n            vec2 offset2DRotated = rotationMatrix * offset2D;\n            \n            vec2 coord = (fragCoord+offset2DRotated)/iResolution.xy;\n            \n            if(coord.x < 0. || coord.x > 1. || coord.y < 0. || coord.y > 1.)\n                continue;\n                \n                count++;\n                \n            vec3 target = texture\n            (\n                iChannel0, \n                coord\n            ).xyz;  \n            \n            vec3 current = texture\n            (\n                iChannel1, \n                coord\n            ).xyz;\n            \n            if(iFrame == 0)\n                current = target;\n            \n            vec3 targetDiff = (targetC - target);\n            \n            // Saturation boost.\n            targetDiff.yz *= 2.0;\n            \n            // Boost and limit gradient magnitudes.\n            targetDiff /= (length(targetDiff) + 0.0625) * 1.5;\n            \n            total += current + targetDiff - currentC;\n        }    \n    }\n    \n    if(count > 0)\n        currentC += total / float(count);\n    \n    // Hue correction, prevents hue drift when there is room in the gamut for it\n    // to drift around.\n    // Also helps preserve skin tones.\n    vec2 targetHueDir = normalize(targetC.yz);\n    if(!any(isnan(targetHueDir)) && !any(isinf(targetHueDir)))\n        currentC.yz = mix(currentC.yz, (dot(targetHueDir, currentC.yz)) * targetHueDir, 0.5);\n    \n    //currentC.y *= 0.1;\n    \n    fragColor.rgb = oklab_to_rgb(currentC.rgb);\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n    fragColor.rgb = rgb_to_oklab(fragColor.rgb);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}