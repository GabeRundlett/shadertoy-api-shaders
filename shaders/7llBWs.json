{
    "Shader": {
        "info": {
            "date": "1651679683",
            "description": "Playing around with DDA raymarching.",
            "flags": 0,
            "hasliked": 0,
            "id": "7llBWs",
            "likes": 11,
            "name": "Golden Hour",
            "published": 3,
            "tags": [
                "raymarch",
                "sky",
                "city",
                "scene",
                "dusk"
            ],
            "usePreview": 0,
            "username": "zesterer",
            "viewed": 446
        },
        "renderpass": [
            {
                "code": "vec3 ray_dir(vec3 z_up, vec3 dir, float fov, float aspect, vec2 uv) {\n    vec3 right = normalize(cross(z_up, dir));\n    vec3 up = cross(dir, right);\n    return normalize(dir + right * uv.x * aspect * fov + up * uv.y * fov);\n}\n\nfloat hash(ivec2 p) {\n    ivec2 q = p * ivec2(1317301, 1712759);\n    return fract(float((q.x ^ q.y)) * 0.0001);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat base_at(vec2 p) {\n    return (sin(p.x * 0.1) + sin(p.y * 0.1) - 1.0) * 2.0;\n}\n\nconst float WATER_LEVEL = -5.0;\n\n// 0 = building\n// 1 = park\n// 2 = crossroad\n// 3 = hroad\n// 4 = vroad\n// 5 = water\nfloat height_at(vec2 p, out int kind) {\n    float base = base_at(floor(p));\n    if (base < WATER_LEVEL) {\n        kind = 5;\n        return WATER_LEVEL;\n    } else if (base < WATER_LEVEL + 0.5) {\n        kind = 1;\n        return WATER_LEVEL + 0.05;\n    }\n    ivec2 grid = ivec2(p);\n    if (grid.x % 4 == 0) {\n        if (grid.y % 4 == 0) {\n            kind = 2;\n            return base + 0.1;\n        } else {\n            kind = 4;\n            return base;\n        }\n    } else if (grid.y % 4 == 0) {\n        kind = 3;\n        return base;\n    }\n    float grass = hash(ivec2(floor(p) * 0.2));\n    if (grass > 0.85) {\n        kind = 1;\n        return base;\n    }\n    kind = 0;\n    return floor(base + 1.0 + pow(hash(ivec2(p)), 8.0) * 5.0);\n}\n\nconst float PLANCK = 0.01;\nconst vec3 SKY_COLOR = vec3(0.1, 0.1, 0.3);\nconst vec3 SUN_DIR = normalize(vec3(-1, 0.5, -0.5));\n\nvec3 grass_at(vec2 pos) {\n    pos += sin(pos.yx * 3.0) * 0.3;\n    if (fract(pos.x * 0.3) < 0.03 || fract(pos.y * 0.3) < 0.03) return vec3(1, 0.8, 0);\n    return vec3(0.5, 1, 0) * (0.5 + hash(ivec2(floor(pos * 40.0))) * 0.5);\n}\n\nfloat wheight(vec2 pos) {\n    return dot(sin(pos.yx * 30.0 + iTime * 3.0 + sin(pos.xy * 10.0 + iTime) * 2.0), vec2(1))\n        + dot(sin(pos.yx * 30.0 - iTime * 3.0 + sin(pos.xy * 10.0 - iTime) * 2.0), vec2(1));\n}\n\nvec4 roof_col(vec2 p, vec2 pos, float h, int kind, inout vec3 norm, inout float spec) {\n    float base = base_at(floor(pos));\n    if (kind == 5) {\n        float h00 = wheight(pos + vec2(0.0, 0.0) * 0.001);\n        float h10 = wheight(pos + vec2(1.0, 0.0) * 0.001);\n        float h01 = wheight(pos + vec2(0.0, 1.0) * 0.001);\n        \n        norm = normalize(vec3(\n            (h10 - h00) / 0.3,\n            (h01 - h00) / 0.3,\n            1.0\n        ));\n        spec = 100.0;\n        return vec4(vec3(0.1, 0.6, 1), 0.0);\n    }\n    if (kind == 1) {\n        return vec4(grass_at(pos), 0.0);\n    }\n    if ((kind == 2 || kind == 4)) {\n        float car = fract(p.y + iTime * 0.6 * -sign(p.x - 0.5));\n        if (abs(fract(p.x * 2.0) - 0.5) < 0.15 && car < 0.2) {\n            float c = sign(p.x - 0.5) < 0.0 ? (car / 0.2) : (1.0 - car / 0.2);\n            if (c < 0.1 && abs(fract(p.x * 2.0) - 0.5) > 0.05) return vec4(vec3(1, 1, 0.5), 4.0);\n            if (c > 0.9 && abs(fract(p.x * 2.0) - 0.5) > 0.05) return vec4(vec3(1, 0, 0), 4.0);\n            return vec4(vec3(1, 0.2, 0.2), 0.0);\n        };\n        if (abs(fract(p.x * 2.0) - 0.5) < 0.05) {\n            if (fract(p.y * 6.0) < 0.5) return vec4(vec3(1), 0.0);\n        }\n        if (abs(fract(p.x * 2.0) - 0.5) < 0.35) {\n            return vec4(vec3(0.2), 0.0);\n        }\n    }\n    if ((kind == 2 || kind == 3)) {\n        float car = fract(p.x + iTime * 0.6 * -sign(p.y - 0.5));\n        if (abs(fract(p.y * 2.0) - 0.5) < 0.15 && car < 0.2) {\n            float c = sign(p.y - 0.5) < 0.0 ? (car / 0.2) : (1.0 - car / 0.2);\n            if (c < 0.1 && abs(fract(p.y * 2.0) - 0.5) > 0.05) return vec4(vec3(1, 1, 0.5), 4.0);\n            if (c > 0.9 && abs(fract(p.y * 2.0) - 0.5) > 0.05) return vec4(vec3(1, 0, 0), 4.0);\n            return vec4(vec3(1, 0.2, 0.2), 0.0);\n        };\n        if (abs(fract(p.y * 2.0) - 0.5) < 0.05) {\n            if (fract(p.x * 6.0) < 0.5) return vec4(vec3(1), 0.0);\n        }\n        if (abs(fract(p.y * 2.0) - 0.5) < 0.35) {\n            return vec4(vec3(0.2), 0.0);\n        }\n    }\n    if (h - base > 2.5) {\n        p -= 0.5;\n        p = abs(p);\n        if ((length(p) > 0.3 && length(p) < 0.35) || (p.x < 0.15 && p.y < 0.05) || (p.x < 0.15 && p.x > 0.1 && p.y < 0.2)) {\n            return vec4(vec3(2), 0.0);\n        }\n    }\n    \n    return vec4(vec3(0.5) * (0.4 + hash(ivec2(floor(p * 10.0))) * 0.6), 0.0);\n}\n\nvec4 wall_col(vec2 p, vec3 pos, float h, int kind, inout vec3 norm) {\n    if (kind == 1) {\n        norm = vec3(0, 0, 1);\n        return vec4(grass_at(pos.xy), 0.0);\n    }\n    if (kind == 2 || kind == 3 || kind == 4) {\n        norm = vec3(0, 0, 1);\n        return vec4(vec3(0.3), 0.0);\n    }\n    //if (kind != 0) {\n    //    return vec4(roof_col(fract(pos.xy), pos.xy, h, kind), 0.0);\n    //}\n    if (fract(p.x * 7.5) > 0.5) {\n        vec2 wpos = p * vec2(7.5, 6.0) + floor(vec2(0.0, h * 50.0 + pos.x + pos.y));\n        if (abs(fract(wpos.x) - 0.75) < 0.15 && abs(fract(wpos.y) - 0.5) < 0.2) {\n            return vec4(vec3(1, 0.9, 0.4), max(0.0, hash(ivec2(wpos)) * 2.0) - 0.5);\n        }\n        return vec4(vec3(0.5), 0.0);\n    }\n    return vec4(vec3(0.3), 0.0);\n}\n\n// (color, t)\nvec4 march(vec3 dir, int iter, inout vec3 pos, out bool hit, out vec3 norm, out float t, inout float spec) {\n    spec = 20.0;\n    vec2 dir2d = normalize(dir.xy);\n    float invlen = 1.0 / length(dir.xy);\n    t = 0.0;\n    for (int i = 0; i < iter; i ++) {\n        vec2 deltas = (step(vec2(0), dir2d.xy) - fract(pos.xy)) / dir2d.xy;\n        float jmp = max(min(deltas.x, deltas.y) * invlen, PLANCK);\n        \n        int kind;\n        float h = height_at(pos.xy, kind);\n        float col_dist = (pos.z - h) / -dir.z;\n        vec3 col_pos = pos + dir * col_dist;\n        if (ivec2(floor(col_pos.xy)) == ivec2(floor(pos.xy)) && col_dist > 0.0 && dir.z < 0.0) {\n            hit = true;\n            norm = vec3(0, 0, 1);\n            t += col_dist;\n            pos = col_pos;\n            return roof_col(fract(col_pos.xy), col_pos.xy, h, kind, norm, spec);\n        } else if (pos.z < h) {\n            hit = true;\n            if (abs(round(pos).x - pos.x) < PLANCK) {\n                norm = vec3(-sign(dir.x), 0.0, 0.0);\n                return wall_col(vec2(fract(pos.y), pos.z - h), pos, h, kind, norm);\n            } else {\n                norm = vec3(0.0, -sign(dir.y), 0.0);\n                return wall_col(vec2(fract(pos.x), pos.z - h), pos, h, kind, norm);\n            }\n        }\n        \n        t += jmp;\n        pos += dir * jmp;\n    }\n    hit = false;\n    return vec4(vec3(0.0), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    \n    vec3 cam_dir = vec3(0, 1, 0);\n    vec3 cam_pos = vec3(0, 1.0 + iTime, 5);\n    \n    cam_dir.xy = vec2(sin(iTime * 0.2), cos(iTime * 0.15)) * 40.0 + 20.5;\n    cam_dir.z = sin(iTime * 0.53) * 20.0 - 16.0;\n    cam_dir = normalize(cam_dir);\n    cam_pos.xy = vec2(sin(iTime * 0.05), cos(iTime * 0.1)) * 50.0 + 100.0;\n    cam_pos.z = max(5.0 + base_at(cam_pos.xy), WATER_LEVEL + 0.1);\n\n    vec3 dir = ray_dir(vec3(0, 0, 1), cam_dir, 0.8, 1.5, uv);\n    \n    bool hit;\n    vec3 norm;\n    float t;\n    float spec;\n    vec4 surf = march(dir, 250, cam_pos, hit, norm, t, spec);\n    \n    vec3 sky_color = mix(\n        vec3(0.7, 0.3, 0.0),\n        vec3(0, 0.1, 0.3),\n        pow(max(dir.z + 0.2, 0.0), 0.9)\n    );\n    vec3 sun_col = vec3(0.7, 0.5, 0.5);\n    \n    vec3 col;\n    if (hit) {\n        float shadow_t;\n        vec3 _norm;\n        float _spec;\n        cam_pos += norm * 0.1;\n        march(-SUN_DIR, 50, cam_pos, hit, _norm, shadow_t, _spec);\n    \n        float unmist = min(1.0 / exp(t * 0.03), 1.0);\n        float lambert = max(dot(-SUN_DIR, norm), 0.0);\n        float shadow = shadow_t > 25.0 ? 1.0 : 0.0;\n        float specular = pow(max(dot(-SUN_DIR, reflect(norm, -dir)), 0.0), spec) * spec * 0.05;\n        vec3 light = surf.rgb * (((lambert + specular) * shadow + 0.1) * sun_col + surf.w * unmist);\n        col = mix(sky_color, light, unmist);\n    } else {\n        col = sky_color\n            + max(0.0, 1.0 - dot(abs(fract(normalize(dir + sin(dir.zxy * 5.0) * 0.1) * 30.0) - 0.5), vec3(1)) * 8.0)\n            + sun_col * pow(max(dot(dir, -SUN_DIR), 0.0), 300.0) * 2.0;\n    }\n\n    // Output to screen\n    fragColor = vec4(col * min(iTime * 0.3, 1.0),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}