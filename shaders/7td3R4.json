{
    "Shader": {
        "info": {
            "date": "1635881810",
            "description": "3D Voronoi particle tracking with a weird depth blur and color scheme that I thought turned out kinda cool.\nThe code is a mess and is a fork of something else I'm doing.\n'r' to restart in full-screen",
            "flags": 48,
            "hasliked": 0,
            "id": "7td3R4",
            "likes": 36,
            "name": "chaoticParticles",
            "published": 3,
            "tags": [
                "particles"
            ],
            "usePreview": 0,
            "username": "stephenl7797",
            "viewed": 1656
        },
        "renderpass": [
            {
                "code": "\n\nvec4 compute_color(vec2 fragCoord) {\n    vec4 a = IC1(ivec2(fragCoord));\n    vec2 q[4];\n    q[0] = proj(IC0(unhashXY(int(a.x), IR)).xyz, R,iTime);\n    q[1] = proj(IC0(unhashXY(int(a.y), IR)).xyz, R,iTime);\n    q[2] = proj(IC0(unhashXY(int(a.z), IR)).xyz, R,iTime);\n    q[3] = proj(IC0(unhashXY(int(a.w), IR)).xyz, R,iTime);\n    vec4 d = vec4(length(fragCoord - q[0]),\n              length(fragCoord - q[1]),\n              length(fragCoord - q[2]),\n              length(fragCoord - q[3]));\n    \n    \n    d.rgb += .1;\n    d.a   =  1. / (.1 + d.a);\n    //d.a   =  exp(d.a*.1 - d.r*.3);\n    vec4 c;\n    c.rgb = vec3(1. / d[2], 1. / d[1], 1. / d[0]) * d[3];\n    c.a = 1.;\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 c = vec4(0.);\n    \n    // TODO: All distances should be in normalized uv coords...\n    // TODO: Should apply view xform if done in proj() func.\n    \n    // The blur gives very ugly artifacts when too large.\n    \n    #if 0\n    float d = length(uv - vec2(.5,.5)) * 1.;\n    #else\n    vec4 a = IC1(ivec2(fragCoord));\n    vec4 q0 = IC0(unhashXY(int(a.x), IR));\n    \n    float z = q0.z;\n    // Uncomment these two lines for a noisy effect that extends far from particles.\n    // I actually quite like it, except that you can see voronoi cells from 0/1 blending.\n    //float dd = abs((z + R.x)  - R.x * + .2 + .0*(sin(iTime+q0.x*.0001)+1.)); // The focus distance [0-1]\n    //float d = exp(dd / R.x * 16.) * .00016; // The blur radius\n    float dd = abs((z + R.x)  - R.x * .3*(sin(iTime+q0.x*.0001)+1.)); // The focus distance [0-1]\n    float d = exp(dd / R.x * 5.72) * .0006; // The blur radius\n    #endif\n    \n    int K = 2;\n    float _t = .01;\n    for (int j=-K; j<=K; j++) {\n    for (int i=-K; i<=K; i++) {\n        //float w = 3.;\n        float w = 1. / (.7 + length(vec2(i,j)));\n        \n        //vec2 fc = fragCoord + vec2(j,i) * d * 1.;\n        vec2 fc = fragCoord + vec2(sin(_t),cos(_t)) * d * 1. * (_t+.5);\n        c += compute_color(fc) * w;\n        _t += 1.1/float(K*K);\n    }\n    }\n    c.rgb /= c.a;\n    \n    c.rgb += length(uv-.5) * vec3(.1,.01,.5)*.15 + .01*rand11(fragCoord.x*100. + fragCoord.y);\n\n    fragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define IR ivec2(iResolution.xy)\n#define C0(uv) texture(iChannel0, (uv))\n#define C1(uv) texture(iChannel1, (uv))\n#define IC0(p) texelFetch(iChannel0, (p), 0)\n#define IC1(p) texelFetch(iChannel1, (p), 0)\n\nfloat hashXY(ivec2 xy, ivec2 ir) {\n    return float(xy.y * ir.x + xy.x);\n}\nivec2 unhashXY(int h, ivec2 ir) {\n    return ivec2(h%ir.x, h/ir.x);\n}\n\n#if 0\n// With rotation\nvec2 proj(vec3 p, vec2 RR, float tt) {\n    //p.z += 1.;\n    float t = tt * .015;\n    //t = tt;\n    \n    p.xz = mat2(cos(t),sin(t),-sin(t),cos(t)) * p.xz;\n    p.z += RR.x * 3.8;\n    \n    p.z /= RR.x * 2.6;\n\n    if (p.z < .0) return vec2(9999.,9999.);\n    \n    return p.xy / p.z + RR * .5;\n}\n#else\nvec2 proj(vec3 p, vec2 RR, float tt) {  \n    p.z += RR.x * 3.8;\n    p.z /= RR.x * 2.6;\n\n    if (p.z < .0) return vec2(9999.,9999.);\n\n    return p.xy / p.z + RR * .5;\n}\n#endif\n\n\n\nfloat rand11(float x) { return fract(337.1*sin(x*22.13+11.2)); }\nvec2 rand22(vec2 p) { return fract(vec2(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13) )); }\nvec3 rand23(vec2 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13) )); }\nvec3 rand33(vec3 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13+p.z*19.2),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13+p.z*10.3),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13+p.z*8.2) )); }\n    \n//float smoo(float v) { return v*v*(3.-2.*v); }\nfloat smoo(float v) { return v; }\nvec3 noise33(vec3 x) {\n    vec3 o = vec3(0.);\n    vec3 fx = floor(x);\n    vec3 lx = fract(x);\n    for (int i=0; i<8; i++) {\n        float dx = (i  ) % 2 == 0 ? 1. : 0.;\n        float dy = (i/2) % 2 == 0 ? 1. : 0.;\n        float dz = (i/4) % 2 == 0 ? 1. : 0.;\n        vec3 v  = rand33(fx + vec3(dx,dy,dz));\n        vec3 d = vec3(dx,dy,dz) * 2. * lx + 1. - lx - vec3(dx,dy,dz);\n        o += smoo(d.x)*smoo(d.y)*smoo(d.z)*v;\n    }\n    return o;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Particle sim\n\n// Store xyz and age.\n\nconst float zSpread = .2;\n    \nvec4 initParticle(vec2 fragCoord) {\n    // Random\n    #if 0\n        vec4 o;\n        o = vec4((rand23(fragCoord)) * vec3(R,zSpread), 0.);\n        o.xy -= R * .5;\n        o.xy *= 2.0;\n        vec2 uv = o.xy / R.xy;\n        o.z += R.x * .1 / (length(uv - vec2(.4,.1)) + .2);\n        o.z += R.x * .3 / (length(uv - vec2(.1,.2)) + .3);\n        o.z -= R.x * .2 / (length(uv - vec2(-.4,-.4)) + .6);\n        o.w = 0.;\n        return o;\n    // Spherical\n    #elif 1\n        vec4 o = vec4(0.);\n        fragCoord.x += rand11(fragCoord.y * .1 + fragCoord.x * .07);\n        fragCoord.y += rand11(fragCoord.x * .188 + fragCoord.y * .07);\n        float u = 6.28318 * fragCoord.x / R.x, v = 6.28318 * 1. * fragCoord.y / R.y;\n        o.xyz = vec3(\n            sin(v) * cos(u) * (1.+R.x/R.y)/2.,\n            cos(v),\n            -sin(v) * sin(u)) * vec3(R.x,R.x,R.x) * .4 + vec3(0., 0., .0);\n         \n        //return o * vec4(sin(5.*v), cos(4.*u), 1., 1.);\n         \n        return o;\n    #endif\n        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    if (iFrame == 0 || texelFetch(iChannel3, ivec2(82, 0), 0).r > .5) {\n        fragColor = initParticle(fragCoord);\n    } else {\n        ivec2 fc = ivec2(fragCoord);\n        vec4 old = IC0(fc);\n        \n        float tt = sin(iTime);\n        float dispersion = .03;\n        float ttt = iTime * .31;\n        float freq = .13;\n        vec3 vel = noise33(fragCoord.xyx*dispersion + old.xyz * freq * vec3(1.,1.,1./2.) * .1 + 5.*vec3(0.,0.,ttt)) - .5;\n        vel += noise33(fragCoord.xyx*dispersion + old.xyz * freq*.5 * vec3(1.,1.,1./2.) * .1 + 5.*vec3(0.,0.,ttt*.5)) *2.- 1.;\n        vel.xy *= 2.51;\n        vel.z *= .001;\n        \n        fragColor.xyz = old.xyz + vel;\n        fragColor.w += .001;\n        \n        // TODO: Should project to check...\n        if (fragColor.x < -R.x*.9995 || fragColor.x > R.x*.9995 || fragColor.y < -R.y*.9995 || fragColor.y > R.y*.9995) {\n        //if (fragColor.z < 0.6 || fragColor.x < -R.x*.5 || fragColor.x > R.x*.5 || fragColor.y < -R.y*.5 || fragColor.y > R.y*.5) {\n        //if (fragColor.z < -2000.0 || fragColor.x < -R.x*.5 || fragColor.x > R.x*.5 || fragColor.y < -R.x*.5 || fragColor.y > R.x*.5) {\n          fragColor = initParticle(fragCoord);\n        }\n        fragColor = fragColor * .995 + .005 * initParticle(fragCoord);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Particle tracking.\n\n// Track closest 4 particles projected from buffer A.\n// Sample a few new ones each frame and inspect neighbors best results\n// to keep the list updated.\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    \n    vec4 old = IC1(ivec2(fragCoord));\n    \n    vec4 new = old;\n    vec2 q[4];\n    q[0] = proj(IC0(unhashXY(int(old.x), IR)).xyz, R,iTime);\n    q[1] = proj(IC0(unhashXY(int(old.y), IR)).xyz, R,iTime);\n    q[2] = proj(IC0(unhashXY(int(old.z), IR)).xyz, R,iTime);\n    q[3] = proj(IC0(unhashXY(int(old.w), IR)).xyz, R,iTime);\n    vec4 d = vec4(length(fragCoord - q[0]),\n                  length(fragCoord - q[1]),\n                  length(fragCoord - q[2]),\n                  length(fragCoord - q[3]));\n    \n    //q0.xy = q0.xy / q0.z + R*.5;\n    //float d0 = length(fragCoord - q0.xy);\n    \n    // Random.\n    //int randomSamples = iFrame < 100 ? 30 : 40;\n    int randomSamples = 10;\n    for (int i=0; i<randomSamples; i++) {\n        // You can get some cool animated swiping effects with the second branch\n        #if 1\n        int ry = (int(R.y * rand11(fragCoord.x*90.+fragCoord.y + iTime*1.77 + 8.7*float(i))) * 2) % IR.x;\n        int rx = (int(R.x * rand11(fragCoord.x*113.+fragCoord.y + iTime*2.77 + 10.93 + 13.99*float(i))) * 2) % IR.y;\n        #else\n        int rr = int(iFrame*randomSamples*37 + i*2 + int(fragCoord.x*.5 + fragCoord.y*27.));\n        int ry = (rr / IR.x) % IR.y;\n        int rx = rr % IR.x;\n        #endif\n        \n        vec4 q1 = IC0(ivec2(rx,ry));\n        q1.xy = proj(q1.xyz, R,iTime);\n        float d1 = length(fragCoord - q1.xy);\n        \n        #define SL \n        \n        if (d1 <= d[0]) {\n            if (d1<d[0]) {\n            SL new[3] = new[2], d[3] = d[2];\n            SL new[2] = new[1], d[2] = d[1];\n            SL new[1] = new[0], d[1] = d[0];\n            }\n            new[0] = hashXY(ivec2(rx,ry), IR); d[0] = d1;\n        } else if (d1 <= d[1]) {\n            if (d1<d[1]) {\n            SL new[3] = new[2], d[3] = d[2];\n            SL new[2] = new[1], d[2] = d[1];\n            }\n            new[1] = hashXY(ivec2(rx,ry), IR); d[1] = d1;\n        } else if (d1 <= d[2]) {\n            if (d1<d[2])\n            SL new[3] = new[2], d[3] = d[2];\n            new[2] = hashXY(ivec2(rx,ry), IR); d[2] = d1;\n        } else if (d1 <= d[3]) {\n            new[3] = hashXY(ivec2(rx,ry), IR); d[3] = d1;\n        }\n    }\n    \n    // Neighbors.     \n    ivec2 fc = ivec2(fragCoord);\n    for (int i = 0; i < 4; i++) {\n        ivec2 fc1 = fc+ivec2(i==0?-1:i==1?1:0, i==2?-1:i==3?1:0);\n        if (fc1.x < 0 || fc1.y < 0 || fc1.x >= IR.x || fc1.y >= IR.y) continue;\n        vec4 neigh = IC1(fc1); \n        \n        for (int j=0; j<4; j++) {\n            ivec2 ixy = unhashXY(int(neigh[j]), IR);\n            vec4 qnew = IC0(ixy);\n            qnew.xy = proj(qnew.xyz, R,iTime);\n\n            float d1 = length(qnew.xy - fragCoord);\n\n            if (d1 <= d[0]) {\n            if (d1<d[0]) {\n                SL new[3] = new[2], d[3] = d[2];\n                SL new[2] = new[1], d[2] = d[1];\n                SL new[1] = new[0], d[1] = d[0];\n                }\n                new[0] = neigh[j], d[0] = d1;\n\n            } else if (d1 <= d[1]) {\n            if (d1<d[1]) {\n                SL new[3] = new[2], d[3] = d[2];\n                SL new[2] = new[1], d[2] = d[1];\n                }\n                new[1] = neigh[j]; d[1] = d1;\n            } else if (d1 <= d[2]) {\n            if (d1<d[2])\n                SL new[3] = new[2], d[3] = d[2];\n                new[2] = neigh[j]; d[2] = d1;\n            } else if (d1 <= d[3]) {\n                new[3] = neigh[j], d[3] = d1;\n            }\n        }\n    }\n    \n    fragColor = new;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}