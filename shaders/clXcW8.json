{
    "Shader": {
        "info": {
            "date": "1690643011",
            "description": "This is just a variation on Florian Berger's (flockaroo's) single pass CFD method, with (possibly) some optimizations and time- and resolution-dependent stability fixes, a randomized simplex gradient seed for initial color, and mouse interaction.",
            "flags": 48,
            "hasliked": 0,
            "id": "clXcW8",
            "likes": 13,
            "name": "Shivershade slime",
            "published": 3,
            "tags": [
                "fluid",
                "flow",
                "dynamics",
                "pass",
                "cfd",
                "single"
            ],
            "usePreview": 0,
            "username": "xenn",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "\n\n// Based on \"spilled\" by florian berger (flockaroo) https://www.shadertoy.com/view/MsGSRd\n// Click and drag to inject color\n// Press I to pick a different start seed\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Based on \"spilled\" by florian berger (flockaroo) https://www.shadertoy.com/view/MsGSRd\n// Click and drag to inject color\n// Press I to pick a different start seed\n\n// RotNum has to be an odd integer\n#define RotNum 9\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel1\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float third = 1.0 / 3.0;\nconst float sixth = 1.0 / 6.0;\nconst float rotFloat = float(RotNum);\nconst float iRotFloat = 1.0 / rotFloat;\nconst float imf = 1.0 / float(0xFFFFFFFFU);\nconst float ang = 2.0 * 3.1415926535 / float(RotNum);\nmat2 m2 = mat2( cos(ang), sin(ang),\n              -sin(ang), cos(ang));\n\nvec4 permute(vec4 x) {\n    vec4 xm = mod(x, 289.0);\n    return mod(((xm * 34.0) + 10.0) * xm, 289.0);\n}\n\n// Stefan Gustavson's and Ian McEwan's implementation of simplex noise (patent is now expired)\n// https://github.com/stegu/psrdnoise\nvec3 psrdnoise(vec3 x) {\n    vec3 uvw = x + dot(x, vec3(third));\n    vec3 i0 = floor(uvw);\n    vec3 f0 = fract(uvw);\n    vec3 g_ = step(f0.xyx, f0.yzz);\n    vec3 l_ = 1.0 - g_;\n    vec3 g = vec3(l_.z, g_.xy);\n    vec3 l = vec3(l_.xy, g_.z);\n    vec3 o1 = min(g, l);\n    vec3 o2 = max(g, l);\n    vec3 i1 = i0 + o1;\n    vec3 i2 = i0 + o2;\n    vec3 i3 = i0 + 1.0;\n    vec3 v0 = i0 - dot(i0, vec3(sixth));\n    vec3 v1 = i1 - dot(i1, vec3(sixth));\n    vec3 v2 = i2 - dot(i2, vec3(sixth));\n    vec3 v3 = i3 - dot(i3, vec3(sixth));\n    vec3 x0 = x - v0;\n    vec3 x1 = x - v1;\n    vec3 x2 = x - v2;\n    vec3 x3 = x - v3;\n    vec4 hash = permute(permute(permute(\n                  vec4(i0.z, i1.z, i2.z, i3.z))\n                + vec4(i0.y, i1.y, i2.y, i3.y))\n                + vec4(i0.x, i1.x, i2.x, i3.x));\n    vec4 theta = hash * 3.883222077;\n    vec4 sz = hash * -0.006920415 + 0.996539792;\n    vec4 psi = hash * 0.108705628;\n    vec4 Ct = cos(theta);\n    vec4 St = sin(theta);\n    vec4 sz_prime = sqrt(1.0 - sz * sz);\n    vec4 gx = Ct * sz_prime;\n    vec4 gy = St * sz_prime;\n    vec3 g0 = vec3(gx.x, gy.x, sz.x);\n    vec3 g1 = vec3(gx.y, gy.y, sz.y);\n    vec3 g2 = vec3(gx.z, gy.z, sz.z);\n    vec3 g3 = vec3(gx.w, gy.w, sz.w);\n    vec4 w = 0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3));\n    w = max(w, 0.0);\n    vec4 w2 = w * w;\n    vec4 w3 = w2 * w;\n    vec4 gdotx = vec4(dot(g0, x0), dot(g1, x1), dot(g2, x2), dot(g3, x3));\n    vec4 dw = -6.0 * w2 * gdotx;\n    vec3 dn0 = w3.x * g0 + dw.x * x0;\n    vec3 dn1 = w3.y * g1 + dw.y * x1;\n    vec3 dn2 = w3.z * g2 + dw.z * x2;\n    vec3 dn3 = w3.w * g3 + dw.w * x3;\n    return 39.5 * (dn0 + dn1 + dn2 + dn3);\n}\n\n// Chris Wellons' and TheIronBorn's best 32-bit two-round integer hash\n// https://github.com/skeeto/hash-prospector\n// flockaroo used 2D noise, but it was only sampled along one dimension\n// and only used one output value, so I replaced it with 1D noise\nfloat hash32(int x) {\n    // since the frame number is an int seed, convert to uint for bitwise ops\n    uint p = uint(x);\n    p ^= p >> 16;\n    p *= 0x21F0AAADU;\n    p ^= p >> 15;\n    p *= 0xD35A2D97U;\n    p ^= p >> 15;\n    // normalize float and shift range to -0.5, 0.5 to cover whole period with ang\n    return float(p) * imf - 0.5;\n}\n\nfloat circleSDF(vec2 p, vec2 c, float r) {\n    return length(p + c) - r;\n}\n\n// basically tried to eliminate as many dot products and divisions as possible\nfloat getRot(vec2 invRes, vec2 pos, vec2 b, float idb) {\n    vec2 p = b;\n    float rot = 0.0;\n    for(int i = 0; i < RotNum; i++) {\n        rot += dot(texture(iChannel0, fract((pos + p) * invRes)).xy - 0.5,\n                   vec2(p.y, -p.x));\n        p = m2 * p;\n    }\n    return rot * iRotFloat * idb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // use screen resolution in all calculations\n    // since buffer and image resolution are the same\n    \n    // eliminate division where possible\n    vec2 invRes = 1.0 / iResolution.xy;\n    \n    // proportionally squared and zero-centered uvs\n    // to keep simplex seed color grid coords from stretching\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) * invRes.y;\n    float rnd = hash32(iFrame);\n    \n    // do ang * rnd once instead of twice\n    float angrnd = ang * rnd;\n    vec2 b = vec2(cos(angrnd), sin(angrnd));\n    \n    // calculate dot product and its inverse only once\n    float db = dot(b, b);\n    float idb = 1.0 / db;\n    vec2 v = vec2(0.0);\n    \n    // abort loop later for bigger vortices (for long-term stability)\n    // this makes it less dependent on certain resolutions for stability\n    float bbMax = iResolution.y;\n    bbMax *= bbMax;\n    \n    // reduced the number of rounds the velocity is summed over\n    for(int l = 0; l < 9; l++) {\n        if(db > bbMax) break;\n        vec2 p = b;\n        for(int i = 0; i < RotNum; i++) {\n            v += p.yx * getRot(invRes, fragCoord.xy + p, b, idb);\n            p = m2 * p;\n        }\n        b *= 2.0;\n        // do multiplications for dot product optimizations\n        db *= 4.0;\n        idb *= 0.25;\n    }\n    \n    fragColor=texture(iChannel0,fract((fragCoord.xy + v * vec2(-1, 1) * 2.0) / Res.xy));\n\n    vec2 scr = fragCoord.xy * invRes - 0.75;\n    // added an extra blue color \"fountain\"\n    // since velocity is driven by red and green channels, blue is initially stationary (like black)\n    // but starts moving when red and green accumulate in the blue pixels\n    // slowed down color accumulation a bit to accomodate for an extra channel being used\n //   fragColor.xyz += (0.009 * vec3(scr.xy, -0.5 * (scr.x + scr.y)) / (dot(scr, scr) * 10.0 + 0.3));\n    \n    if(iFrame < 1 || KEY_I > 0.5) {\n        float srv = iDate.x + iDate.y + iDate.z + iDate.w; \n        vec3 n = psrdnoise(vec3(uv * 4.0, srv));\n        n = normalize(n) * 0.5 + 0.5;\n        fragColor = vec4(n, 1.0);\n    }\n    \n    if(iMouse.z > 0.0) {\n        float t = iTime;\n        vec2 ppos = -(iMouse.xy - 0.5 * iResolution.xy) * invRes.y;\n        vec3 pcol = 0.5 * (sin(vec3(t, t + 2.1, t + 4.2)) + 1.0);\n        float dist = circleSDF(uv, ppos, 0.1);\n        if(dist < 0.0) fragColor = vec4(pcol, 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define HEIGHT 20.0*(5.*(sin(iTime/4.333)))\n#define BRIGHTNESS .95\n\n/**\n\tUse Buffer A in iChannel0 for 3D letters. Read description!\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Texel Size\n    vec2 texel = vec2(1.) / iResolution.xy;\n\n    vec3 normal = bump2Normal(uv, iChannel0, HEIGHT, texel);\n   \tvec3 normalRGB = normal2rgb(normal);\n    \n    vec3 lightDir = normalize(vec3((sin(iTime/8.)), -abs(sin(iTime/7.)), (sin(iTime/6.))));\n    \n    vec3 toLightDir = vec3(0.0) - lightDir;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n\tif (mouseX < 01.99) {\n        fragColor = vec4(BRIGHTNESS*dot(toLightDir, normalize(normal)));\n        fragColor*=texture(iChannel1, uv);\n                fragColor = clamp(fragColor, 0., 1.);\n\n    } else {\n        fragColor = vec4(normalRGB, 1.0);\n    }  \n    \n//    if(abs(toLightDir.x *.5 + .5 - uv.x) < 0.005 && abs(toLightDir.z *.5 + .5 - uv.y) < 0.005) {\n//    \tfragColor = vec4(1.,abs(toLightDir.y*2.),vec2(0.));  \n//    }\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// shortcut to sample texture\n#define TEX(uv) texture(iChannel0, uv).r\n\n\n// Fork of \" expansive reaction-diffusion\" by Flexi. https://shadertoy.com/view/4dcGW2\n// 2022-07-28 10:46:34\n\n// and\n\n// Brush toy by Leon Denise 2022-05-17\n\n// I wanted to play further with shading and lighting from 2D heightmap.\n// I started by generating a heightmap from noise, then shape and curves.\n// Once the curve was drawing nice brush strokes, I wanted to add motion.\n// Also wanted to add droplets of paints falling, but that will be\n// for another sketch.\n\n// This is the color pass\n// Click on left edge to see layers\n\n// The painting pass (Buffer A) is using FBM noise to simulate brush strokes\n// The curve was generated with a discrete Fourier Transform,\n// from https://www.shadertoy.com/view/3ljXWK\n\n// Frame buffer sampling get offset from brush motion,\n// and the mouse also interact with the buffer.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(.0);\n    \n    // coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 dither = texture(iChannel1, fragCoord.xy / 124.).rgb;\n    \n    // value from noise buffer A\n    vec3 noise = texture(iChannel0, uv).rgb;\n    float gray = noise.x;\n    \n    // gradient normal from gray value\n    vec3 unit = vec3(3./iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        gray*gray));\n    \n    \n    // specular light\n    vec3 dir = normalize(vec3(0,1,2.));\n    float specular = pow(dot(normal, dir)*.5+.5,10.);\n    color += vec3(.5)*specular;\n    \n    // rainbow palette\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*(2.5+(2.45*sin(iTime/3.)+1.))+gray*5.+uv.x*5.);\n    dir = normalize(vec3(uv-.5, 0.));\n    color += tint*pow(dot(normal, -dir)*.5+.5, 0.5);\n    \n    // background blend\n    vec3 background = vec3(.0)*smoothstep(1.5,0.,length(uv-.5));\n    color = mix(background, clamp(color, 0., 1.), smoothstep(.2,.5,noise.x));\n    \n    // display layers when clic\n    if (iMouse.z > 0.5 && iMouse.x/iResolution.x < .1)\n    {\n        if (uv.x < .33) color = vec3(gray);\n        else if (uv.x < .66) color = normal*.5+.5;\n        else color = vec3(.2+specular)*gray;\n    }\n\n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Fork of \"Loverlamp DUB TEK\" by xenn. https://shadertoy.com/view/Nt33Wf\n// 2021-11-13 13:32:45\n\n// Fork of \"Loverlamp Minus 2\" by xenn. https://shadertoy.com/view/Nl33WX\n// 2021-11-13 13:08:30\n\n// Fork of \"Loverlamp Minus\" by xenn. https://shadertoy.com/view/Nlt3Dj\n// 2021-11-13 09:45:13\n\n// Fork of \"Loverlamp\" by xenn. https://shadertoy.com/view/7tdGWS\n// 2021-11-12 18:46:48\n\n//Chromamargins 0.tic aberration, film grain and tone mapping\n//#define Margins 0.\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .015;\n      vec3 color = vec3(texture(iChannel0, uv - 0.250 * d).r,\n                      texture(iChannel0, uv - .0 * d).g,\n                      texture(iChannel0, uv + 0.250 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.250  * d).r,\n                      texture(iChannel1, uv - .0 * d).g,\n                      texture(iChannel1, uv - 0.250 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv -0.250  * d).r,\n                      texture(iChannel2, uv - .0 * d).g,\n                      texture(iChannel2, uv - 0.250  * d).b);\n                      \n                       vec3 col3 = vec3(texture(iChannel3, uv - 0.250 * d).r,\n                      texture(iChannel3, uv - 0.0 * d).g,\n                      texture(iChannel3, uv - 0.250 * d).b);\n                      \n                      \n                      color = min(col2,color);\n                      col = min(col,col3);\n                //     col = mix(col,color,col2);\n                 //    color = mix(col,color,col2)*(color+color);\n                 col3 *= max (color, col3)-(col2*col3);\n                      \n        vec3 blend = (min(col3,col2)*col);               \n      col = ((max(color,col),col3)*(col3));\n      color = (mix(color,col,col2)*(col2));\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm((blend+(mix(color,blend,col)))*noise), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}