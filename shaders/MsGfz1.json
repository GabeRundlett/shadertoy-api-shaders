{
    "Shader": {
        "info": {
            "date": "1527602161",
            "description": "Unfinished, unpolished (that's an understatement!), and still very buggy.\n\nImproved version\nhttps://www.shadertoy.com/view/4sKfWz",
            "flags": 48,
            "hasliked": 0,
            "id": "MsGfz1",
            "likes": 1,
            "name": "River Surface Simulation",
            "published": 3,
            "tags": [
                "shockwave",
                "river",
                "froude"
            ],
            "usePreview": 0,
            "username": "philip_s",
            "viewed": 662
        },
        "renderpass": [
            {
                "code": "/*\n### READMEEE ###\n-> KEYS\n    Up / down: \t\t\tadjust Froude number\n    Mouse click: \t\tposition and move light source\n    W / S : \t\t\tadjust light height\n\n-> What Am I looking at?!?\n\twith SP, HEIGHT, NORMALS, and LIGHTING defined:\n\tGrey: \t\t\tthe most conical rock you'll ever see\n\tBlue: \t\t\treally?  I know it's ugly but can't you tell it's water?\n\tOrange blob: \tthe light\n\tMagenta pixels: shockwave start points\n\n-> Your crappy shader is killing my GPU!\n\tyou can try playing around with nbSeg and SQRT_NBR... sorry :(\n*/\n\n// === Per-Fragment\n//\t\tfinal render\n\n#define RL(a,b) O.x+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\n#define GL(a,b) O.y+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\n#define BL(a,b) O.z+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\n#define WL(a,b) O  += 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(0.);\n    vec2 R = iResolution.xy,\n\t     U = toNormalized(u, R);\n\t//fetch data  \n    vec4 C1 = texelFetch(iChannel1,ivec2(u),0);\n    vec2 V = C1.xy; float fr = C1.z, W = C1.w;\n\n    vec4 C2 = texelFetch(iChannel2,ivec2(u),0);\n    vec2 grad = C2.xy; float sp = C2.z;\n    \n    vec4 C3 = texelFetch(iChannel3,ivec2(u),0);\n    float z = C3.x; vec2 sWTang = C3.yz;\n  \n    // Line drawing\n    vec2 p, v;\n    p = floor(U*20.+0.5)/20.;\n\n   \n#ifdef SP\n    // Visualize start points\n    if (sp == 1.) {\n        O = vec4(1., 0., 1. ,0.);\n        return;\n    }\n#endif //SP\n    \n#ifdef FR\n    if (abs(fr - 1.0) < frEpsilon) O += vec4(fr, 0, 0, 1.0); // fr = 1\n#endif //FR\n  \n    \n#ifdef VEL\n    float gc = 600000.0;\n    float gxc = gc + 1.;\n    float gyc = gc + 1.;\n    //O += vec4(length(V)*600., 0.0, 0.0, 1.0);\t\t\t //V from here\n    //O += vec4(C2.w*600., 0.0, 0.0, 1.0); \t\t\t\t // V from gradCalc\n    O += vec4(-V.y*600.0, V.y*600.0, V.x*600.0, 1.0);  //color vx vy\n    //O += vec4(sin(100000.*C2.w), 0, 0, 1.0);\t\t\t // ISO-V\n    //O += vec4(sin(100000.*length(V)), 0, 0, 1.0);\n    \n    //O += vec4(0, -C2.x*gxc,+C2.x*gxc, 1.0); \t\t\t //gradX\n    //O += vec4(0, -C2.y*gyc,C2.y*gyc, 1.0); \t\t\t //gradY\n    //O += vec4(0, 0, length(grad)*gc/10., 1.0); \t\t //gradY  \n#endif //VEL\n    \n\n#ifdef HEIGHT\n    O = vec4(C3.x/(WAVE_WIDTH/2.), -C3.x/(WAVE_WIDTH/2.), 0, 1.);\n#endif //HEIGHT\n \n#ifdef NORMALS    \n    vec2 dir = vec2(sWTang.y, -sWTang.x);\n    vec2 off = discretizeDir(dir);\n    vec4 upstreamC3 = texelFetch(iChannel3, ivec2(u+off),0);\n    vec4 downstreamC3 = texelFetch(iChannel3, ivec2(u-off),0);\n\tvec3 slope = normalize(vec3(u+off, upstreamC3.x) - vec3(u-off, downstreamC3.x));\n    vec3 normal = normalize(cross(slope, vec3(normalize(sWTang),0)));\n    O = vec4(normal.x*1., normal.y*1., normal.z*1., 1.);\n#endif //NORMALS\n   \n#ifdef LIGHTING\n    //TODO: check light distance / angles... something might be wrong\n    vec3 lightColor = vec3(1,1,1);\n    vec3 ka = vec3(.1, .1, .1);\n    vec3 ks = vec3 (1,1,1);    \n    vec3 kd = vec3(.0,.7,.9);\n    if (W > 0.) //rock\n        kd = vec3(0.4);\n \n    vec4 lInfo = texelFetch(iChannel0, ivec2(3,1), 0);\n    //light marker\n    if (length(u-lInfo.xy) < 7.) { \n        O = vec4(.9, .5, .0, 1.);\n        return;\n    }\n    vec3 l = lInfo.xyz - vec3(u, C3.x);\n    float lDist = length(l);\n    l = normalize(l);\n    float lightIntens = 1000. / (pow(lDist, 1.1)); \n\n    vec3 camPosition = vec3(R.x/2., R.y/2., CAM_HEIGHT);\n    vec3 camVector = normalize(camPosition - vec3(u, C3.x));\n    vec3 reflection = normalize(reflect(-l, normal));\n    float specularCoeff = pow(max(0.0, dot(reflection, camVector)), 16.5);\n\n    O = vec4(ka,1) + lightIntens * vec4(kd * lightColor * max(0.0, dot(normal, l)), 1.0)\n      + vec4(ks * specularCoeff, 1.0);\n#endif //LIGHTING\n    \n    \n#ifdef REGIONS\n    ivec2 coord = ivec2(u);\n    int width = int(R.x) / SQRT_NBR;\n    int height = int(R.y) / SQRT_NBR;\n    if (coord.x % (width) == 0 || coord.y % (height) == 0) {\n        \tO = vec4(1.0, 1.0, 0.0, 0.0);\n    }\n#endif\n   \n    \n#ifdef STREAM                                        // --- display velocity & stream\n   \tO += vec4(0.0, 50.*length(V), sin(500.*w),0);   // draw |V| and iso-streams\n    // draw line\n#endif //STREAM\n    \n    \n#ifdef FIELD\n    BL ( p-V*30., p+V*30.);\n    GL (p+grad*50000., p-grad*50000.);\n#endif\n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\tIMAGE \n#define SP\n//#define FR\n//#define VEL\n\n#define HEIGHT\n#define NORMALS\n#define LIGHTING\n\n//#define REGIONS\n//#define STREAM //broken for now\n//#define FIELD\n\n\n//\tSCENE GEOMETRY\n#define N 3             // number of objects (rocks + walls)\n#define nbRocks N-2\t\t// number of rocks\n#define obsRadius 0.32 \t// rock radius\n#define rockX 0.\n#define rockY 0.\n\n\n//\tPHYSICS\n#define DYNAMIC //add some time-varying offset to stream values\n#define r0 5.5 // influence distance   for efficiency, as small as it keep covering influencials river sides \n#define c0 .4 // boundary condition   < 1: slip condition   > 1 : no-slip condition   \n//for c0 = 0.4 sqgh = 0.0009 \n//for c0 = 1.5 sqgh = 0.00009\n#define sqgh  0.0009\n\n\n//\tDATA STRUCTURES\n#define linesArrayX 0\t// first element of shockwave Lines Array (actually matrix...)\n#define linesArrayY 6\t// must start on an EVEN coord (lines grouped 2by2 with modulo 2!)\n#define regionMatX\t0\n#define regionMatY  linesArrayY+nbShock*2\n#define SQRT_NBR 2 // square root of number of regions searching for Start Points\n\n\n\n//\tFEATURE PARAMS\n//#define REGION_DBG\t//active: put StartPoints at middle of each region\n#define nbSeg 50\t// number of line segments per shockwave (must be < R.x)\n#define segLength 10.\t// length of a line segment\n#define nbShock SQRT_NBR*SQRT_NBR \t\t// number of shockwaves\n#define WAVE_WIDTH 70.\n\n\n//\tRENDER PARAMS\n#define frEpsilon 0.05 \t//VERY approximative interval to draw where fr~1.0\n#define CAM_HEIGHT 10000.\n#define LIGHT_HEIGHT 500.\n\n\n\n//\tHelper Functions\nvec2 toScreen(vec2 coord, vec2 R) {\n    return (coord*R.y + R) /2.;\n}\n\nvec2 toNormalized(vec2 coord, vec2 R) {\n    return (coord + coord - R) / R.y;\n}\n\n\n//return closest of eight directions\nvec2 discretizeDir (vec2 dir) {\n    vec2 outDir = vec2(100., 100.);\n    dir = normalize(dir);\n    float dotDiff, m = 1e9;\n\n    for (int i = -1; i < 2; i++) {\n        for (int j = -1; j < 2; j++) {\n            dotDiff = abs(dot(normalize(vec2(i,j)), dir)-1.0);\n            if (dotDiff < m) {\n                m = dotDiff;\n                outDir = vec2(i,j);\n            }\n        }\n    }\n    return outDir;\n}\n\nivec2 getRegionBl (ivec2 gridPos, vec2 R) {\n    int width = int(R.x) / SQRT_NBR;\n    int height = int(R.y) / SQRT_NBR;\n    return ivec2(gridPos.x * width, gridPos.y * height);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// === Multi-purpose Buffer\n//\t\tcreate (and edit) river bed\n//\t\tuser interaction\n//\t\tdetermine + store feature positions\n\n\n#define keyClick(ascii)  texelFetch(iChannel3,ivec2(ascii,0),0).x\n\n//globals\nfloat sqghKey;\nvec2 R;\nvec4 pinListener;\nvec4 lightInfo;\n\n//helper funcs\n\n//look for a startPoint within the region defined by bottom left corner\nbool findStartPoint(ivec2 botleft, out vec4 data) {\n    vec4 frag;\n    vec2 pos;\n    for (int i = 0; i < int(R.x)/SQRT_NBR; i++) {\n        for (int j = 0; j < int(R.y)/SQRT_NBR; j++) {\n    \t\tfrag = texelFetch(iChannel2, ivec2(botleft + ivec2(i,j)), 0);\n            if (frag.z == 1.) {\n                pos = vec2(botleft) + vec2(i,j);\n                vec2 v = texelFetch(iChannel1, ivec2(pos), 0).xy;\n                vec2 gradV = texelFetch(iChannel2, ivec2(pos), 0).xy;\n                //get V to move the startpoint ahead of froude line\n                pos += 2.*discretizeDir(gradV);\n                data.xy = v;\n                data.zw = pos;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\n/*\n * true if that frag handles a child segment of a shockwave line, false otherwise\n */\nbool isChildShockFrag (vec2 fragCoord) {\n    fragCoord -= vec2(.5);\n\treturn ((fragCoord.x > float(linesArrayX) && fragCoord.x < float(linesArrayX+nbSeg/2)\n            && (fragCoord.y >= float(linesArrayY) && fragCoord.y < float(linesArrayY + 2*nbShock))));\n}\n\n/*\n * true if that frag handles first(parent) shockwave Line, false otherwise\n */\nbool isParentShockFrag (vec2 fragCoord) {\n    fragCoord -= vec2(.5);\n\treturn ((fragCoord.x == float(linesArrayX))\n            && (fragCoord.y >= float(linesArrayY) && fragCoord.y < float(linesArrayY + 2*nbShock)));\n}\n\n/*\n * true if that frag handles first(parent) shockwave Line, false otherwise\n */\nbool isRegionFrag (vec2 fragCoord) {\n    fragCoord -= vec2(.5);\n\treturn ((fragCoord.x >= float(regionMatX) && fragCoord.x < float(regionMatX+SQRT_NBR+1)\n            && (fragCoord.y >= float(regionMatY) && fragCoord.y < float(regionMatY + SQRT_NBR+1))));\n}\n\n/*\n * return next point of the shockwave (in screenCoords)\n */\nvec2 getNextShockPoint (vec2 ptA, bool left) {\n    if (ptA == vec2(-1)) //line needs to die \n        return vec2(-1);\n    \n    vec2 vecAB, ptB;            \n    vec4 fragA = texelFetch(iChannel1, ivec2(ptA), 0);\n    vec2 vA = fragA.xy;\n    vec2 vAOrth = vec2(vA.y, -vA.x);\n    if (left) \n        vAOrth = -vAOrth;\n    float alpha = asin(sqghKey / length(vA));\n    vecAB = cos(alpha) * (cos(alpha) * vA + (sqghKey/length(vA)) * vAOrth);\n    vecAB = normalize(vecAB);\n    ptB = ptA + segLength*R*length(vA)*vecAB;\n    vec4 fragB = texelFetch(iChannel1, ivec2(ptB), 0);\n    if (fragB.w >= 0.) //in rock, kill rest of line\n    \treturn vec2(-1);\n    return ptB;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    R = iResolution.xy;\n    vec2 U = toNormalized(u, R);\n    \n\t//init: create river bed and return\n    if (iFrame==0) {\n        //initialize sqgh term for froude\n        if (u.x-0.5 == 1.0 && u.y-0.5 == 1.0) {\n            O = vec4(0, 0, 0, sqgh);\n        }\n        // Initialize light information\n        if (u.x-0.5 == 3.0 && u.y-0.5 == 1.0) {\n            O = vec4(R.x/2., R.y/2., LIGHT_HEIGHT, 0.);\n        }\n        \n        if (isChildShockFrag(u) || isParentShockFrag(u) || isRegionFrag(u)) \n            O = vec4(-1);\n\n        // Initialize geometry\n    \tif (u.y>1.) return;\n        switch( int(u.x)%3 ) {                       \n            case 0: O.xy = vec2(0, -1.0);  O.z = 0.0;   O.w = 1.0; break; // top wall\n            case 1: O.xy = vec2(0, 1.0);  O.z = 0.0;   O.w = 0.0; break;   // bot wall\n            case 2: O.xy = vec2(rockX,rockY); O.z = obsRadius;   O.w = .5; break;  //middle rock\n        }\n        return;\n    }\n    \n    O = texelFetch(iChannel0,ivec2(u),0);\n\tsqghKey = texelFetch(iChannel0,ivec2(1,1),0).w;\n    pinListener = texelFetch(iChannel0, ivec2(2,1), 0); // mouse input\n    vec4 rock = texelFetch(iChannel0, ivec2(u.x-0.5+2., 0), 0);\n\n    \n    // adjust sqgh term for froude\n    if (u.x-0.5 == 1.0 && u.y-0.5 == 1.0) {\n    \tsqghKey *= 1. + 0.00365 * (keyClick(38)-keyClick(40));\n        O = vec4(0, 0, 0, sqghKey);\n    }\n    \n    // Update light information\n    if (u.x-0.5 == 3.0 && u.y-0.5 == 1.0) {\n        lightInfo = O;\n        if (iMouse.z>0.)      // mouse clicked\n            lightInfo.xy = iMouse.xy;\n        lightInfo.z  = max(0., lightInfo.z + 5.* (keyClick(83)-keyClick(87)));\n        O = lightInfo;\n    }\n    \n\n    //is this fragment processing a left-hand side shockwave point?\n    bool left = (int(u.y -.5)) % 2 != 0;\n    \n    if (isRegionFrag(u)) {\n        vec2 ptA;\n\t\tivec2 gridPos = ivec2(u)-ivec2(regionMatX, regionMatY);\n        ivec2 bl = getRegionBl(gridPos, R);\n        if (!findStartPoint(bl,O)) // no SP, kill line\n            O = vec4(-1);\n    }\n    //frags at x = lineArrayX + 2n and x = lAX+1 handle left and right shockwave lines of wave \n    if (isParentShockFrag(u)) {\n        int parentY = int(floor(u.y));\n        int index = (parentY - linesArrayY)/2;\n        ivec2 gridPos = ivec2(index - SQRT_NBR*(index/SQRT_NBR), index/(SQRT_NBR));\n\t\tvec4 regionFrag = texelFetch(iChannel0, ivec2(regionMatX, regionMatY) + gridPos, 0);\n\n    \t// - getNextShockPoint but with other point's V\n        vec2 vecAB, ptA, ptB;            \n        vec4 fragA = regionFrag;\n        ptA = regionFrag.zw;\n        vec2 vA = fragA.xy;\n        vec2 vAOrth = vec2(vA.y, -vA.x);\n        if (left) \n            vAOrth = -vAOrth;\n        float alpha = asin(sqghKey / length(vA));\n        vecAB = cos(alpha) * (cos(alpha) * vA + (sqghKey/length(vA)) * vAOrth);\n        vecAB = normalize(vecAB);\n        ptB = ptA + segLength*R*length(vA)*vecAB;\n        vec4 fragB = texelFetch(iChannel1, ivec2(ptB), 0);\n        if (fragB.w >= 0.) //in rock, kill rest of line\n            ptB = vec2(-1);\n        if (regionFrag == vec4(-1)) //line needs to die \n            ptB = vec2(-1);\n\t\t// - end\n        O = vec4(ptA, ptB);\n    } \n    if (isChildShockFrag(u)) {\n        vec4 prevFrag = texelFetch(iChannel0, ivec2(u.x-.5-1., u.y-.5), 0);\n        vec2 ptA = getNextShockPoint(prevFrag.zw, left);\n        vec2 ptB = getNextShockPoint(ptA, left);\n        O = vec4(ptA, ptB);\n    } \n            \n}                   ",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// === Per-Fragment:\n//\t\t\tCalculate velocity\n//\t\t\tCalculate Froude num (disposable if more buf space needed)\n//\t\t\tdetermine if in Rock\n\n// Taken from\n//https://www.shadertoy.com/view/ls3cR4\n\n// interpolate stream function : add(distance to border, stream at border)\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\n\n/*\n *\tInterpolation\n */\nfloat f(float d) {\n    float t = 1. - d/r0;  // if further than influence (r0) then disregard (t < 0)\n    return t < 0. ? 0. :pow(d,-c0) * (6.*t*t-15.*t+10.)*t*t*t;\n}\n\nvec4 velocity(vec2 U, sampler2D ch) {\n    float wf=0., wT=0., w, W=-1., fr; \n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\n    for (int i=0; i<N; i++) {\n        vec4 T = texelFetch(ch, ivec2(i,0), 0);\n        if (T.z < 0.001) {  \t\t\t\t   // walls have z = 0\n        \tadd( length(U.y-T.y), T.w );  \t   // add wall i in stream\n        }\n        else {\n        \tadd( length(U-T.xy) - T.z, T.w );  // add rock i in stream\n        }\n        if (w!=w) W = T.w;                     // NaN: in rock. \n    }\n\n    w = wf / wT;                               // stream field\n    if (w!=w) w = W;                           // in rock\n    #ifdef DYNAMIC\n    w += .001 * sin(4.28*(U.x - iTime ));\n    #endif\n    vec2 v = vec2(-dFdy(w), dFdx(w));\n    \n    if (w!=w) {\n        fr = 50.;\n    }\n    else {\n        float sqghKey = texelFetch(iChannel0,ivec2(1, 1),0).w;\n    \tfr = length(v)/sqghKey;\n    }\n    return vec4(v, fr, W );     // xy = velocity field\n}\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    O = texelFetch(iChannel1, ivec2(u), 0);\n    vec2 R = iResolution.xy,\n         U = toNormalized(u, R);\n    O = velocity(U, iChannel0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// === Per-Fragment:\n//\t\t\tCalculate Gradient of V\n//\t\t\tDetermine if is ShockWave start point\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 R = iResolution.xy,\n    \t U = toNormalized(u, R);\n        \n\tvec4 C1 = texelFetch(iChannel1,ivec2(u),0);\n    vec2 VSelf = C1.xy; float wSelf = C1.z, WSelf=C1.w;\n    vec2 gradV = vec2(0.), V;\n    float w, W;\n    \n    if ( WSelf >= 0.) {\t\t\t\t//In rock\n        O = vec4(0., 0., 0, 5.);\n        return;\n    }\n    \n    \n    //4 point finite diff\n    float vt, vb, vl, vr;    \n    \n    ivec2 off_u = ivec2(u)+ivec2(0,1);\n    U = toNormalized(vec2(off_u), R);\n    C1 = texelFetch(iChannel1, off_u, 0);\n    V = C1.xy; w = C1.z; W = C1.w;\n    if ( W >= 0.) //neighbour is in rock\n        vt = length(VSelf);\n    else\n        vt = length(V);\n    \n    off_u = ivec2(u)+ivec2(0,-1);\n    U = toNormalized(vec2(off_u), R);\n    C1 = texelFetch(iChannel1, off_u, 0);\n    V = C1.xy; w = C1.z; W = C1.w;\n    if ( W >= 0.) //neighbour is in rock\n        vb = length(VSelf);\n    else\n        vb = length(V);\n    \n    off_u = ivec2(u)+ivec2(-1,0);\n    U = toNormalized(vec2(off_u), R);\n    C1 = texelFetch(iChannel1, off_u, 0);\n    V = C1.xy; w = C1.z; W = C1.w;\n    if ( W >= 0.) //neighbour is in rock\n        vl = length(VSelf);\n    else\n        vl = length(V);\n    \n    off_u = ivec2(u)+ivec2(1,0);\n    U = toNormalized(vec2(off_u), R);\n    C1 = texelFetch(iChannel1, off_u, 0);\n    V = C1.xy; w = C1.z; W = C1.w;\n    if ( W >= 0.) //neighbour is in rock\n        vr = length(VSelf);\n    else\n        vr = length(V);\n    \n   \n    gradV = 0.5 * vec2(vr-vl, vt-vb);\n    O = vec4(gradV, 0., WSelf);\n    \n    //   -----------------\n    vec2 grad = gradV;\n    float sp = 0.;\n    \n    //(using next and prev point, not self)\n    //compute and display tangent to ISO-V\n    vec2 tang = vec2(grad.y, -grad.x);\n    tang = normalize(tang);\n    VSelf = normalize(VSelf);\n    grad = normalize(grad);\n    vec2 off = discretizeDir(tang);\n\n    // check points along ISO-V\n    vec4 nextC2 = texelFetch(iChannel2,ivec2(u+off),0);\n    vec4 prevC2 = texelFetch(iChannel2,ivec2(u-off),0);\n\n    vec2 nextCoord = u+off;\n    vec2 prevCoord = u-off;\n\n    // get tangents to ISO-V from gradient in both dirs\n    vec2 nextTang = -normalize(vec2(nextC2.y, -nextC2.x));\n    vec2 prevTang = normalize(vec2(prevC2.y, -prevC2.x));\n\n    // get neighbour pixel's V, fr, W\n    //TODO: change this bad naming\n    vec4 nextC1 = texelFetch(iChannel1,ivec2(nextCoord),0);\n    vec4 prevC1 = texelFetch(iChannel1,ivec2(prevCoord),0);\n\n    float nextDot = dot(nextC1.xy, nextTang);\n    float prevDot = dot(prevC1.xy, prevTang);\n\n    //handle rock cases\n    if (nextC1.w >= 0. || prevC1.w >= 0.) {\n        return;\n    }\n\n\n    //get froude number of neighbour points\n    off = discretizeDir(grad);\n    vec4 upStreamC2 = texelFetch(iChannel1,ivec2(u-off),0);\n    vec4 dnStreamC2 = texelFetch(iChannel1,ivec2(u+off),0);\n    \n    //handle rock cases\n    if (upStreamC2.w >= 0.|| dnStreamC2.w >= 0.) {\n        return;\n    }\n\n    // mark shockwave start Points\n    if ((nextDot < 0. && prevDot < 0.)) {\n        if (upStreamC2.z < 1.0 && dnStreamC2.z >= 1.0) {\n            sp = 1.;\n        }\n    }\n    \n#ifdef REGION_DBG\n    sp = 0.;\n    // if i am middle pixel of a region, set as startpoint\n    ivec2 offset = (ivec2(R) / (SQRT_NBR))/2;\n    if (SQRT_NBR == 1)\n        offset = ivec2(R/2.);\n    ivec2 coord = ivec2(u);\n    coord.x -= offset.x;\n    coord.y -= offset.y;\n    int width = int(R.x) / SQRT_NBR;\n    int height = int(R.y) / SQRT_NBR;\n    if (coord.x >= 0 && coord.y >= 0) {\n        if (coord.x % (width) == 0 && coord.y % (height) == 0) {\n        \tsp = 1.0;\n        }\n    }\n#endif    \n    \n    O = vec4(gradV, sp, WSelf);\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// === Per-Fragment:\n//\t\t\tConstruct shockwave profile using distance to shockwave segments\n\n#define SQRT2 1.41421356237\n#define PI 3.14159265359\n#define nbEndPts 2\n\n\n//to cut off red rounded bit at end maybe just make z change really small on last seg?\nfloat getDist(vec2 p, vec2 a, vec2 b, bool last)  {\n    if (a == vec2(-1) || b == vec2(-1)) \n        return 90000000.; \n    vec2 pa = p - a, ba = b - a, pb = p - b;\n    float u = dot(pa, ba)/dot(ba, ba), cu = clamp(u , 0., 1.);\n    vec2 d = pa - ba * cu; \n    vec2 tangAB = vec2(ba.y, -ba.x);\n    float dist = length(d)*-sign(dot(tangAB, pa));\n \treturn dist;\n}\n\n\n//curve should only go up to 0.8, down to -0.8\n//to plot: 2.*(3.*x+1./1.41)*exp(-1.*((3.*x+1./1.41)*(3.*x+1./1.41)))+0.045*(exp(-2.*x)*cos(24.*3.14*x)-1.-x*(exp(-2.)*cos(24.*3.14)-1.))\nfloat getWaveHeight(float d) {\n    float tmp = (3.*d+1./SQRT2);\n    float zg = 2.*tmp*exp(-1.*(tmp*tmp));\n    float zc = 0.045*(exp(-2.*d)*cos(24.*PI*d)-1.-d*(exp(-2.)*cos(24.*PI)-1.));\n\tif (d < -0.) \n        zc = 0.0239; //yay, magical height correction :D\n    return zg + zc ;\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(0.);\n    vec2 R = iResolution.xy,\n\t     U = toNormalized(u, R);\n\n    vec4 C0 = texelFetch(iChannel0,ivec2(u),0);\n  \n    vec4 C1 = texelFetch(iChannel1,ivec2(u),0);\n    vec2 V = C1.xy; float fr = C1.z, W = C1.w;       // velocity xy, stream, in rock\n\n    vec4 C2 = texelFetch(iChannel2,ivec2(u),0);\n    vec2 grad = C2.xy; float sp = C2.z;\n    \n    vec2 tang;\n    \n    if ( W >= 0.) { //in rock\n        vec2 rad = u - toScreen(vec2(rockX, rockY), R);\n        tang = vec2(rad.y, -rad.x);\n        O = vec4((60.-length(rad)), tang, 0);\n        return;\n    } \n    \n    \n    vec4 endPoints[nbEndPts];\n    vec2 ptA, ptB, ptC, ptD, closestA, closestB;\n    float z = 90000000.;\n    float d;\n    for (int i = int(linesArrayY); i < int(linesArrayY)+2*nbShock; i++) {\n        for (int k = 1; k < nbEndPts; k++) {\n        \tendPoints[k] = texelFetch(iChannel0,ivec2(linesArrayX+(k-1),i),0);\n        }\n        //if (i%2 != 0) continue;\n        for (int j = int(linesArrayX)+1; j < int(linesArrayX)+nbSeg/2; j++) {\n            // have AB, get CD, draw AB and BC\n            // draw 3 line segments AB BC CD\n            for (int k = 0; k < nbEndPts-1; k++) {\n            \tendPoints[k] = endPoints[k+1];\n            }\n            endPoints[nbEndPts-1] = texelFetch(iChannel0,ivec2(j,i),0);\n            ptA = endPoints[0].xy; ptB = endPoints[0].zw;\n            ptC = endPoints[1].xy; ptD = endPoints[1].zw;\n            if (i%2 == 0) {\n                d = getDist(u, ptA,ptB, false);\n                if (abs(d) < abs(z)) { \n                    z = d;\n                    closestA = ptA; closestB = ptB;\n                }\n                d = getDist(u, ptB, ptC, false);\n                if (abs(d) < abs(z)) { \n                    z = d;\n                    closestA = ptB; closestB = ptC;\n                }\n            }\n            else {\n                d = getDist(u, ptB, ptA, false);\n                if (abs(d) < abs(z)) { \n                    z = d;\n                    closestA = ptB; closestB = ptA;\n                }\n                d = getDist(u, ptC, ptB, false);\n                if (abs(d) < abs(z)) { \n                    z = d;\n                    closestA = ptC; closestB = ptB;\n                }\n            }\n        }\n        \n        if (i%2 == 0) {\n            d = getDist(u, ptC, ptD, true);\n            if (abs(d) < abs(z)) { \n                z = d;\n                closestA = ptC; closestB = ptD;\n            }    \n        }\n        else {\n            d = getDist(u, ptD, ptC, true);\n            if (abs(d) < abs(z)) { \n                z = d;\n                closestA = ptD; closestB = ptC;\n            }    \n        }      \n    }\n    //if got a positive z and a negative z, choose \n    \n    if (z == 90000000. || z > WAVE_WIDTH/2. || z < -WAVE_WIDTH/2.) {\n    \tz = 0.;\n    }\n    else {\n        z = 2.*smoothstep(WAVE_WIDTH/2., -WAVE_WIDTH/2., z)-1.;\n    \tz = getWaveHeight(z)*WAVE_WIDTH/2.;\n\n    } \n    tang = closestB-closestA;\n    O = vec4(z, tang, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}