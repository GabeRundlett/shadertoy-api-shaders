{
    "Shader": {
        "info": {
            "date": "1600291136",
            "description": "Lorenz attractor.\nmulti-trajectory variant of [url]https://shadertoy.com/view/3ddyRr[/url]\nR,G,B rectangle = area where 96 steps attractor simulation + 96 lines drawing are calculated.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "3dtcRr",
            "likes": 17,
            "name": "lorenz11 - Fabrice3",
            "published": 3,
            "tags": [
                "math",
                "attractor",
                "lorenz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 542
        },
        "renderpass": [
            {
                "code": "// multi-trajectory variant of https://shadertoy.com/view/3ddyRr\n// optimization of https://shadertoy.com/view/Wscyzr\n// simplification + comments of \"lorenz11\" by mrtkp9993. https://shadertoy.com/view/3tBfWd\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{    \n\tO = T(u);\n    \n    for (int y = 0; y < N; y++) { // for demo, draw color rectangle for calulating aread\n      vec2 R = iResolution.xy, \n         Min = T(vec2(2,y)).xy,\n         Max = T(vec2(2,y)).zw,\n           U = ( u - .5*R ) / R.y; U.y += Y_OFFSET;\n      U /= VIEW_SCALE;\n    \n      if (U.x>Min.x && U.y>Min.y && U.x<Max.x && U.y<Max.y) O[y]++; \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//https://en.wikipedia.org/wiki/Lorenz_system\n\n                                      // --- graphics settings\n#define MODE xz                       // choose which 2D projection to draw\n\nfloat STEPS = 96.,                    // number of iteration per frame\n      SPEED = .05,                    // dt = SPEED/60\n  INTENSITY = .2,\n       FADE = .99,\n      FOCUS = 1.,\n     O = 10., P = 28., B = 8./3.;     // --- System Parameters\n\nvec4 COL[] = vec4[]( vec4(.93, .36, .36, 1),\n                     vec4(.36, .93, .36, 1),\n                     vec4(.36, .36, .93, 1) );\n\nvec3 Integrate(vec3 cur, float dt)    // --- Calculate the next position \n{\n\treturn cur + dt * vec3(    O  * (cur.y - cur.x)       ,\n                            cur.x * (P - cur.z) - cur.y   ,\n                            cur.x *   cur.y     - B*cur.z   );\n}\n\nfloat Line(vec2 a, vec2 b, vec2 U)    // --- Distance to a line segment https://www.shadertoy.com/view/llySRh\n{   \n    U -= a, b -= a;\n\tfloat h = dot( U, b ) / dot(b,b),\n          c = clamp(h, 0., 1.);\n    return h==c ? length( U - b * c ) : 1e5;   // dist to strict segment\n  //return        length( U - b * c );         // dist to segment with round ends\n}\n\nvoid mainImage( out vec4 O, vec2 u ) // === simulate particles and cumulate-draw images\n{    \n    vec2 R = iResolution.xy, Min,Max,\n         U = ( u - .5*R ) / R.y; U.y += Y_OFFSET;\n    U /= VIEW_SCALE;\n    float pix = 1. / R.y / VIEW_SCALE;\n    u = floor(u);\n\n    O = vec4(0);\n    vec3 last, next;\n    \n    int y = int(u.y);\n    if (y<N && u.x<3. ) {          // --- simulation zone. particle #y in line y\n       vec3 start = vec3( .1, .001, 0 )+vec3(y,-y,y);     // Initial Position\n       next = last = T(vec2(0,y)).xyz,              // pixel (0,y) saves the current position.\n       Max = Min = last.MODE;\n        for(float i = 0.; i < STEPS; i++ )    // simulates for 1 frame range\n    \t    next = Integrate( next, .016 * SPEED ),\n            Min  = min(Min, next.MODE),\n            Max  = max(Max, next.MODE);\n        \n        O =   u == vec2(0,y)                  // pixel (0,y) saves the current position.\n            ? iFrame < 1 ? vec4( start, 0 )          // Setup initial conditions.\n                         : vec4( next , 0 )          // Save current position.\n            : u == vec2(1,y)                  // pixel (1,y) saves the previous position.\n            ? iFrame < 1 ? vec4( start, 0 )          // Setup initial conditions.\n                         : vec4( last , 0 )   // pixel (2,y) saves the segment bbox     \n            :  /* (2,0) */ vec4( Min-pix , Max+pix );\n    } else {                           // --- drawing zone\n      for (int y = 0; y < N; y++) {\n        Min = T(vec2(2,y)).xy,\n        Max = T(vec2(2,y)).zw;\n        float c = 0.;\n        if (U.x>Min.x && U.y>Min.y && U.x<Max.x && U.y<Max.y) {\n\n            last = T(vec2(1,y)).xyz;          // pixel (1,y) saves the previous position.\n            float d = 1e6;\n\n            for(float i = 0.; i < STEPS; i++ )// simulates & draws for 1 frame range\n                next = Integrate( last, .016 * SPEED ),\n                d = min(d, Line(last.MODE , next.MODE, U) ),        \n                last = next;\n                   \n            d *=  VIEW_SCALE;\n            c  =  INTENSITY / SPEED * smoothstep( FOCUS / R.y, 0., d )\n                + INTENSITY / 8.5   * exp(- 1e3 * d*d );\n        }\n        O +=  c*COL[y];    // accumulates draw...\n      }\n      O   +=  T(u) * FADE; // ... fading over time. \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nfloat VIEW_SCALE = .025,     // scene scaling\n        Y_OFFSET = .6;       // scene offset\nint            N = 3;        // number of trajectories\n\n#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}