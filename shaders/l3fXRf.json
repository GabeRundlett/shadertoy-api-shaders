{
    "Shader": {
        "info": {
            "date": "1709769000",
            "description": "A test to see how feasible (and cool) GPU-based particles are. You can pan around with the mouse and zoom using the arrow keys. Hold space to temporarily disable gravity and slow time.",
            "flags": 48,
            "hasliked": 0,
            "id": "l3fXRf",
            "likes": 0,
            "name": "Particles, Planets, and Gravity",
            "published": 3,
            "tags": [
                "particles",
                "gravity"
            ],
            "usePreview": 0,
            "username": "Bingle",
            "viewed": 81
        },
        "renderpass": [
            {
                "code": "// Rendering\n\n// See \"Common\" tab for various constants.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 cam = texelFetch(iChannel0,idxToTexel(particles),0);\n    \n    float zoom = cam.z;\n    \n    fragCoord += cam.xy; // This might be bad practice but it works\n    \n    vec2 centerCoord = (fragCoord-0.5*iResolution.xy);\n    vec2 uv = zoom*centerCoord/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    // Draw planets\n    for (int i=0;i<PLANETCOUNT;i++){\n        float len = length(planets[i]-uv);\n        if (len<2.0){\n            col = vec3(1.0); // Solid body\n        }\n        col += (0.8/len); // Glow\n    }\n    \n    // Draw particles\n    for (int i=0;i<particles;i++){\n        ivec2 texel = idxToTexel(i);\n        vec4 particle = canvasSize*(texelFetch(iChannel0,texel,0)-0.5);\n        if (length(particle.xy - uv)<0.5){\n            col = hsv2rgb(vec3(float(i)/float(particles)*360.0,1.0,max(length(particle.zw)*0.1,0.25)));\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Data and processing buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    ivec2 iCoord = ivec2(fragCoord);\n    vec4 particle = canvasSize*(texelFetch(iChannel0,iCoord,0)-0.5);\n    \n    int idx = iCoord.x+iCoord.y*dataWidth;\n    \n    \n    if (idx<particles){ // This pixel stores a particle\n        \n        \n        if (texelFetch(iChannel1,ivec2(32,0),0).r>0.5){ // Space bar pressed?\n            particle.xy += particle.zw*TIMESTEP*timescale*0.25; // Move, but in slow motion\n        }else{\n            particle.xy += particle.zw*TIMESTEP*timescale; // Move\n            \n            for (int i=0;i<PLANETCOUNT;i++){ // Gravity\n                vec2 to = normalize(planets[i]-particle.xy);\n                float r = length(particle.xy-planets[i]);\n                float F = g*mass/(r*r);\n                \n                particle.zw += to*F*TIMESTEP*timescale;\n            }\n        }\n        \n        if (iFrame==0){ // Time to initialize our particles!!\n            particle = vec4(0.0);\n            float theta = float(idx)*(PI*0.1);\n            particle.xy = (15.0+0.05*theta)*vec2(cos(theta),sin(theta)); // Pos\n            particle.zw = vec2(particle.y,-particle.x)*0.5*(1.0-0.006*theta); // Velocity\n        }\n    }\n    \n    if (idx==particles){ // This pixel stores the camera info.\n        if (iFrame==0){\n            particle = canvasSize*(vec4(0.0,0.0,50.0,0.0)-0.5); // X,Y,Unused, Unused\n        }\n        \n        vec4 prevMouse = texelFetch(iChannel0,idxToTexel(particles+1),0);\n        \n        if (prevMouse.z>0.0 && iMouse.z>0.0){ // Mouse is pressed\n            particle.xy += -400.0*(iMouse.xy-prevMouse.xy);\n        }\n        if (texelFetch(iChannel1,ivec2(38,0),0).r>0.5){ // Up arrow pressed?\n            particle.z = max((30.0*canvasSize)-0.5,particle.z*0.98);\n        }\n        if (texelFetch(iChannel1,ivec2(40,0),0).r>0.5){ // Down arrow pressed?\n            particle.z *= 1.02;\n        }\n    }\n    \n    if (idx==particles+1){ // This pixel stores mouse info from last frame.\n        particle = (iMouse-0.5)*canvasSize;\n    }\n    \n    fragColor = (particle/canvasSize)+0.5;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "int particles = 300; // Number of particles to simulate\nint dataWidth = 400; // Maximum width just incase (because Buffer A stores all the data, but its resolution is variable)\nfloat canvasSize = 500.0; // Width and height of the area that particles can move through (because color channels are clamped to 0 - 1)\n//float zoom = 50.0; // Viewport height. Increase to zoom out.\n\n#define PLANETCOUNT 1\nvec2[PLANETCOUNT] planets = vec2[] (vec2(0.0));\n\nfloat mass = 100.0; // Planet mass x particle mass\nfloat g = 9.8; // Gravitational constant\nfloat timescale = 5.0; // Multiplied by timestep\nfloat PI = 3.14159265359; // Pi\n\n// The time between frames, in seconds\n#define TIMESTEP 0.01666666\n\n// You can replace 0.016... with iTimeDelta to support varying framerates, but this\n// seems to cause issues on Chrome when you switch tabs and then hover over this one,\n// I'm not sure why. Something with the tab preview? Dunno.\n\n\n\n//FUNCTIONS\n\n\n// Convert an index to a texel for accessing in Buffer A\nivec2 idxToTexel(int i){\n    return ivec2(mod(float(i),float(dataWidth)),floor(float(i)/float(dataWidth)));\n}\n\n// Convert an HSV vec3 to an RGB vec3\nvec3 hsv2rgb(vec3 hsv){\n    \n    hsv.x = mod(hsv.x,360.0);\n    hsv.yz = clamp(hsv.yz,0.0,1.0);\n    \n    float C = hsv.z*hsv.y;\n    float X = C*(1.0-abs(mod(hsv.x/60.0,2.0)-1.0));\n    float m = hsv.z - C;\n    \n    vec3 rgb;\n    \n    if (hsv.x < 60.0){\n        rgb = vec3(C,X,0);\n    }else if (hsv.x < 120.0){\n        rgb = vec3(X,C,0);\n    }else if (hsv.x < 180.0){\n        rgb = vec3(0,C,X);\n    }else if (hsv.x < 240.0){\n        rgb = vec3(0,X,C);\n    }else if (hsv.x < 300.0){\n        rgb = vec3(X,0,C);\n    }else{\n        rgb = vec3(C,0,X);\n    }\n    \n    return (rgb+m);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}