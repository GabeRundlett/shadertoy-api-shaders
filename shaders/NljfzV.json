{
    "Shader": {
        "info": {
            "date": "1652456120",
            "description": "Randomly made this SDF fractal.\nSingle function with different parameters.\n[b]Loop is eight different shapes.[/b]\n\nCineshader support [url]https://cineshader.com/view/NljfzV[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "NljfzV",
            "likes": 82,
            "name": "Single Fractal",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "volumetric",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "morimea",
            "viewed": 5226
        },
        "renderpass": [
            {
                "code": "\n// Created by Danil (2022+) https://github.com/danilw\n// License - CC0 or use as you wish\n\n\n// main point of this shader is - fractal that generate different image depends of parameters\n// look map function\n\n\n\n// to play with parameters and use Mouse control, 5 is index in arrays below that size of psz\n//#define use_func 5\n\n\n// to test animation loop with mouse\n//#define mouse_loop\n\n\n#define cam_orbit 2.05\n\n// params\n#define psz 8\n\n// scale\nfloat p0[psz] = float[]( 0.7, 0.7, 0.7, 0.7, 0.57, 0.697, .09, 2.57);\n\n\n// biggest visual impact \nfloat p1[psz] = float[]( 0.07,  0.07, -0.107, -0.07, -0.69,  -0.69,   -0.1069,  -0.69);\n\nfloat p2[psz] = float[](-0.15, -0.15,  1.84,  -0.15, -0.015,  0.015,  -0.02015, -0.015);\n\nfloat p3[psz] = float[]( 0.465, 0.184, 0.465,  0.465, 0.2465, 0.1465,  1.465,    0.2465);\n\n\n// number of loops, keep low (clamped to 1 to 30 to not kill your GPU)\nint p5[psz] = int[](5,5,10,5,5,5,10,5);\n\n\n\n// main fractal func\nfloat map(in vec3 p, int idx) {\n\t\n\tfloat res = 0.;\n    vec3 c = p;\n\tfor (int i = 0; i < clamp(p5[idx],1,30); ++i) {    \n        p =p0[idx]*abs(p)/max(dot(p,p+p2[idx]*p/(p+0.0001*(1.-abs(sign(p))))),0.0001) + p1[idx];\n        p=p.zxy;\n        res += exp(-33. * abs(dot(p,p3[idx]*c)));        \n\t}\n\treturn res;\n}\n\n\nvec3 postProcess(vec3 col, float ct);\nvec3 march(vec3 ro, vec3 rd, int idx, float c_timer, float ct2) {\n  float t   = 0.;\n  float dt  = 0.152;\n  vec3 col  = vec3(0.0);\n  float c   = 0.;\n  const int max_iter = 48;\n  for(int i = 0; i < max_iter; ++i) {\n      t += dt*exp(-1.50*c);\n      vec3 pos = ro+t*rd;\n      c = map(pos,idx); \n      \n      //c *= 0.025+2.*iMouse.y/iResolution.y; //test color with mouse\n      c *= 0.025+2.*c_timer;\n      float center = -0.35; // center of color shift\n      float dist = (abs(pos.x + pos.y + center))*2.5;\n      vec3 dcol = vec3(c*c+0.5*c*c-c*dist, c*c-c, c); // color func\n      col = col + dcol*1./float(max_iter);\n  }\n  col *= 0.18;\n  col=clamp(col,0.,1.);\n  return postProcess(col, ct2);\n}\n\nvec3 postProcess(vec3 col, float ct) {\n  col = col*0.85+0.85*col*col.brb;\n  col = col*0.6+0.64*col*col*(3.0-2.0*col)+0.5*col*col;\n  col = col+0.4*(col.rrb-vec3(dot(col, vec3(0.33))));\n  vec3 c1=col-0.344*(col.brb-vec3(dot(col, vec3(0.33))));\n  vec3 c2=col+0.64*(col.ggr-vec3(dot(col, vec3(0.33))));\n  col=mix(col,c1,min(ct*2.,1.));\n  col=mix(col,c2,-clamp(ct*2.-1.,0.,1.));\n  //col*=1.5;\n  col=col*01.5+0.5*col*col;\n  return col;\n}\n\n\n\n// fractal color function\n\n#define PI 3.14159265\nvec4 get_color(vec2 p , int idx, float timer, float c_timer)\n{\n    idx = idx%psz;\n    vec4 fragColor;\n\tfloat time = iTime;\n    vec3 ret_col = vec3(0.0);\n    float mouseY = 0.15 * PI;\n    mouseY = (1.0 - 0.5*1.15 * (1.83-timer)) * 0.5 * PI;\n#ifdef use_func\n    mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI; //test MOUSE\n#endif\n#ifndef mouse_loop\n    if(iMouse.z>0.&&iMouse.w<iResolution.y)mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI;\n#endif\n    float mouseX = -1.25*PI;\n    mouseX+=-(timer*1.5+0.25) * .5 * PI;\n#ifdef use_func\n    mouseX=-1.25*PI-(iMouse.x / iResolution.x) * 3. * PI; //test MOUSE\n#endif\n#ifndef mouse_loop\n    if(iMouse.z>0.&&iMouse.z<iResolution.x)mouseX=-1.25*PI-(iMouse.x / iResolution.x) * 3. * PI;\n#endif\n    vec3 eye = cam_orbit*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    eye = eye+0.0001*(1.-abs(sign(eye)));\n    vec3 ro = eye;\n\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n\n    vec3 rd = normalize(w + p.x * u + p.y * v);\n    \n    vec3 col =  march(ro, rd, idx, timer*0.30+0.15*timer*timer+0.25, c_timer);\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n    return fragColor;\n}\n\n\n\n// everything else is just Shadertoy presentation, not related to fractal\n// mainImage has godrays + image slider logic\n\nvec2 plane(vec2 uv, float timer);\nfloat GetBayerFromCoordLevel(vec2 pixelpos);\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d );\nfloat hash(vec2 p);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.);\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n\n#ifdef use_func\n    fragColor = get_color((uv-res*0.5)*2., use_func, 0.65, 0.);\n    return;\n#endif\n\n    const float grn = 7.; // number of tiles for slider\n\n    float sx = 0.5*(1./grn)+0.5*0.25*(floor(res.x/(1./grn))-0.5*res.x/(1./grn));\n    uv.x += sx;\n    vec2 gid = floor(uv*grn);\n    uv = fract(uv*grn)-0.5;\n    \n    // timers\n    float gtime = iTime*.645;\n    // gtime=float(psz)*6. sec loop\n    \n#ifdef mouse_loop\n    gtime=float(psz)*6.*iMouse.x/iResolution.x; //test MOUSE\n#endif\n\n    // timer logic\n    float tt = mod(gtime,12.);\n    float tt2 = mod(gtime+6.,12.);\n    float i1 = smoothstep(3.,6.,tt);float i2 = smoothstep(9.,12.,tt);\n    float ltime = (i1+i2)*3.+floor(gtime/12.)*6.;\n    float s_timer = (smoothstep(3.,12.,tt2));\n    float s_timer2 = (smoothstep(3.,12.,tt));\n    int itdx = int(ltime+3.)/6;\n    int itdx2 = int(ltime)/6;\n    \n    float gmix1 = 0.5-0.5*cos(gtime/6.*0.35);\n    float gmix2 = 0.5-0.5*cos(gtime/6.*0.25);\n\n    // godrays \n    vec3 occ_col=vec3(0.);\n    {\n        #define DECAY .974\n        #define EXPOSURE .116907\n        #define SAMPLES\t32\n        #define DENSITY\t.595\n        #define WEIGHT .25\n        vec2 coord = fragCoord.xy/iResolution.xy;\n        float cd = 1.75*length(coord-0.5);\n        float occ=0.;\n        vec2 lightpos = vec2(0.51,0.503);\n        float dither = GetBayerFromCoordLevel(fragCoord);    \n        vec2 dtc = (coord - lightpos) * (1. / float(SAMPLES) * DENSITY);\n        float illumdecay = 1.;\n        for(int i=0; i<SAMPLES; i++)\n        {\n            coord -= dtc;\n            vec2 otuv = coord+(dtc*dither);\n            vec2 tuv = otuv*res;\n            tuv.x += sx; vec2 lgid = floor(tuv*grn); tuv = fract(tuv*grn)-0.5;\n            float lctimer = 0.0;\n            float lctime = ltime - (lgid.y/grn - lgid.x/(grn*res.x))*1.-grn/16.+2.;\n            lctime = mod(lctime, 6.);\n            lctimer += smoothstep(0.0, 1.0, lctime);\n            lctimer += 1. - smoothstep(3.0, 4.0, lctime);\n            lctimer = abs(lctimer-1.0);\n            vec2 tuv_pl = plane(tuv,lctimer);\n            float noplx = float(abs(tuv_pl.x)>0.5||abs(tuv_pl.y)>0.5);\n            float s = (noplx)*(1.-smoothstep(-0.03,0.75,.5*length(otuv-0.5)));\n            s *= illumdecay * WEIGHT;\n            occ += s;\n            illumdecay *= DECAY;\n        }\n        occ=1.5*occ*EXPOSURE;\n        occ_col = occ*(1./max(cd,0.0001))*\n            pal( mix(cd*occ*0.35,cd+occ*0.35,gmix1), \n            vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) ).gbr;\n        occ_col=clamp(occ_col,0.,1.);\n    }\n    //----\n\n    float timer = 0.0;\n    float time = ltime - (gid.y/grn - gid.x/(grn*res.x))*1.-grn/16.+2.;\n    time = mod(time, 6.);\n    timer += smoothstep(0.0, 1.0, time);\n    timer += 1. - smoothstep(3.0, 4.0, time);\n    timer = abs(timer-1.0);\n    float side = step(0.5, timer);\n    vec2 uv_pl = plane(uv,timer);\n    \n    vec2 tp = (fragCoord.xy/iResolution.xy-0.5)*2.;\n    tp = pow(abs(tp), vec2(2.0)); \n    float tcd = 0.5+0.5*clamp(1.0 - dot(tp, tp),0.,1.);\n    float cineshader_alpha = smoothstep(0.,1.,(timer))*0.5*tcd;\n    //float cineshader_alpha = smoothstep(0.,1.,2.*abs(timer-.5))*0.5*tcd;\n    \n    bool nopl = abs(uv_pl.x)>0.5||abs(uv_pl.y)>0.5;\n    uv_pl += 0.5;\n    if(side<0.5)uv_pl.x=1.-uv_pl.x;\n    \n    if (nopl)\n    {\n        fragColor = vec4(occ_col,cineshader_alpha);\n        return;\n    }\n    vec2 tuv = ((uv_pl*1./res)*1./grn+((gid*1./grn)+vec2(-sx,0.))*1./res);\n    if(side>0.5)fragColor = get_color((tuv-0.5)*res*2.,0+itdx*2,s_timer, gmix2);\n    else fragColor = get_color((tuv-0.5)*res*2.,1+itdx2*2,s_timer2, gmix2);\n    \n    //fragColor.rgb*=smoothstep(0.,1.,2.*abs(timer-.5));\n    \n    fragColor = vec4(fragColor.rgb+occ_col,cineshader_alpha);\n    fragColor.rgb = clamp(fragColor.rgb,0.,1.);\n}\n\n\nvec2 plane(vec2 uv, float timer)\n{\n    timer = radians(timer*180.0);\n    vec4 n = vec4(cos(timer),0,sin(timer),-sin(timer));\n    vec3 d = vec3(1.0,uv.y,uv.x);\n    vec3 p = vec3(-1.0+n.w/4.0,0.,0.);\n    \n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = cross(up, n.xyz);\n    float dn = dot(d, n.xyz);dn+=0.00001*(1.-abs(sign(dn)));\n    float pn = dot(p, n.xyz);\n    vec3 hit = p - d / dn * pn;\n    return vec2(dot(hit, right), dot(hit, up));\n}\n\n\nfloat GetBayerFromCoordLevel(vec2 pixelpos)\n{\n    ivec2 ppos = ivec2(pixelpos);\n    int sum = 0; const int MAX_LEVEL = 3;\n    for(int i=0; i<MAX_LEVEL; i++)\n    {\n        ivec2 tv = ppos>>(MAX_LEVEL-1-i)&1;\n        sum += ((4-(tv).x-((tv).y<<1))%4)<<(2*i);\n    }\n    return float(sum) / float(2<<(MAX_LEVEL*2-1));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}