{
    "Shader": {
        "info": {
            "date": "1584143660",
            "description": "Visualizes the time it took for the 2nd pendulum to flip with varying initial conditions & system parameters.\nClick a region to show it's physical state, press space to reset.\nChange the \"SWEEP_MODE\" for different visualizations (or make your own).",
            "flags": 48,
            "hasliked": 0,
            "id": "WlKSRt",
            "likes": 22,
            "name": "Chaotic Double Pendulum",
            "published": 3,
            "tags": [
                "math",
                "visualization",
                "attractor",
                "chaos",
                "physics",
                "pendulum",
                "chaotic"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 970
        },
        "renderpass": [
            {
                "code": "vec4 Grad(float x)\n{ \n    float rx = log(x+1.0)/log(30.0) - 0.05;\n    vec4 col = vec4(0.5 + 0.5 * cos(vec3(rx*tau - tau*vec3(0,1,2)/3.0)), 1);//Rainbow\n    col.rgb *= smoothstep(30.0,0.0,x);//Fade to black\n    col.a = smoothstep(3600.0,0.0,x);//Fade to transparent\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.y;\n    \n    //Checkerboard background\n    vec4 col = mix(checkCol1, \n                   checkCol2, \n                   sign(sin(uv.x*tau*checkDens)*sin(uv.y*tau*checkDens)));\n\t\n    //Time-to-flip visualization\n    vec4 vis = Grad(texelFetch(iChannel0,ivec2(fragCoord),0).w);\n    col = mix(col, vis, vis.a);\n\n    //Physical pendulum visualization of selected region\n    SweepParams(iMouse.xy/iResolution.xy);\n    vec4 state = texelFetch(iChannel1,ivec2(iMouse.xy),0);\n    vec2 p0 = vec2(res.x/2.0,0.8);\n    vec2 p1 = p0 + l1*cossin(state.x-tau/4.0);\n    vec2 p2 = p1 + l2*cossin(state.y-tau/4.0);\n    vec2 msize = mSizeMax*vec2(m1,m2)/(m1+m2);\n    \n    StartCanvas(uv, 1.0/iResolution.y);\n    {\n        Color(1);\n        Line(p0, p1, l1Size);//Linkage 1\n        Line(p1, p2, l2Size);//Linkage 2\n        \n        Color(vec3(0,0,1));\n        Circle(p0, ancSize);//Anchor\n        Color(vec3(1,0,0));\n        Circle(p1, msize.x);//Mass 1\n        Circle(p2, msize.y);//Mass 2\n        \n\t\tColor(1);\n        Ring(mouse, curSize, curThk);//Cursor\n    }\n    EndCanvas(col);\n\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 curState = vec4(0);\n\n/*\nEquations of motion taken from:\nhttps://www.myphysicslab.com/pendulum/double-pendulum-en.html\nReturns:\nx -> Angular velocity of pendulum 1 (dA1/dt)\ny -> Angular velocity of pendulum 2 (dA2/dt)\nz -> Angular acceleration of pendulum 1 (dV1/dt)\nw -> Angular acceleration of pendulum 1 (dV2/dt)\n*/\nvec4 dAdt_dVdt(vec4 state)\n{\n    float a1 = state.x, //x = a1, Angle of pendulum 1\n          a2 = state.y, //y = a2, Angle of pendulum 2\n          v1 = state.z, //z = v1, Angular velocity of pendulum 1\n          v2 = state.w; //w = v2, Angular velocity of pendulum 2\n    \n    vec2 dvdt = vec2(0);\n    dvdt.x = -g*(2.0*m1 + m2)*sin(a1)-m2*g*sin(a1-2.0*a2)-2.0*sin(a1-a2)*m2*(v2*v2*l2 + v1*v1*l1*cos(a1-a2));\n    dvdt.x /= l1*(2.0*m1+m2-m2*cos(2.0*a1-2.0*a2));\n    \n    dvdt.y = 2.0*sin(a1-a2)*(v1*v1*l1*(m1+m2)+g*(m1+m2)*cos(a1) + v2*v2*l2*m2*cos(a1-a2));\n    dvdt.y /= l2*(2.0*m1+m2-m2*cos(2.0*a1-2.0*a2));\n    \n    return vec4(v1,v2,dvdt);\n}\n\nvec4 IntegrateRK4(vec4 state, float h)\n{         \n    vec4 k1 = h*dAdt_dVdt( state );\n    vec4 k2 = h*dAdt_dVdt( state + k1/2.0 );\n    vec4 k3 = h*dAdt_dVdt( state + k2/2.0 );\n    vec4 k4 = h*dAdt_dVdt( state + k3 );\n\n    state += (k1 + 2.0*k2 + 2.0*k3 + k4)/6.0;\n    \n    return state;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    curState = texelFetch(iChannel0,ivec2(fragCoord),0);\n    bool reset = texelFetch(iChannel2,ivec2(0x20,0),0).x!=0.0; //Space = reset\n    vec4 initState = SweepParams(uv);\n    \n    if(iFrame == 0 || reset)\n    {\n    \tcurState = initState;\n    }\n    \n    for(int i=0;i<steps;i++)\n    {\n    \tcurState = IntegrateRK4(curState, dt / float(steps));\n    }\n    \n    //Keep a1/a2 between -pi & +pi\n    curState.x = mod(curState.x+tau/2.0,tau)-tau/2.0;\n    curState.y = mod(curState.y+tau/2.0,tau)-tau/2.0;\n    \n    fragColor = vec4(curState);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define A1_VS_A2 0 \n#define A1A2_VS_V1 1\n#define A1A2_VS_V2 2\n#define A1A2_VS_M1M2 3\n#define A1A2_VS_L1L2 4\n#define CUSTOM 5\n\n#define SWEEP_MODE A1_VS_A2\n\n//Constants\nconst float tau = atan(1.0)*8.0;\nconst float pi = atan(1.0)*4.0;\n\n//System Parameters\nfloat g = 1.0; //Gravity\nfloat m1 = 1.0, m2 = 1.0; //Mass on pendulum 1/2\nfloat l1 = 0.3, l2 = 0.3; //Length of pendulum 1/2\nfloat dt = 0.0167; //Time step per frame\nconst int steps = 10; //Steps per frame\n\n//Visualization Parameters\nconst float flipThres = pi*0.5;\n\nvec4 checkCol1 = vec4(0.17,0.17,0.17,1);\nvec4 checkCol2 = vec4(0.20,0.20,0.20,1);\nfloat checkDens = 8.0;\n\nfloat ancSize = 0.03;\nfloat mSizeMax = 0.1; //Actual mass size is a ratio of the mass to the total mass.\nfloat l1Size = 0.005;\nfloat l2Size = 0.005;\nfloat curSize = 0.02;\nfloat curThk = 0.004;\n\n//Global Functions\n\n//Sweeps the system paramters/initial conditions with uv coords.\n//uv from 0.0 to 1.0\nvec4 SweepParams(vec2 uv)\n{\n    float a1 = 0.0, a2 = 0.0, v1 = 0.0, v2 = 0.0;\n    vec4 initState = vec4(0);\n\t\n    #if(SWEEP_MODE == A1_VS_A2)\n\ta1 = tau*(uv.x-0.5);\n\ta2 = tau*(uv.y-0.5);\n    #endif\n    \n    #if(SWEEP_MODE == A1A2_VS_V1)\n\ta1 = a2 = tau*(uv.x-0.5);\n\tv1 = tau*(uv.y-0.5);\n    #endif\n    \n    #if(SWEEP_MODE == A1A2_VS_V2)\n\ta1 = a2 = tau*(uv.x-0.5);\n\tv2 = tau*(uv.y-0.5);\n    #endif\n    \n    #if(SWEEP_MODE == A1A2_VS_M1M2)\n\ta1 = a2 = pi*uv.x;\n\tm1 = uv.y+0.1;\n    m2 = (1.0-uv.y)+0.1;\n    #endif\n    \n    #if(SWEEP_MODE == A1A2_VS_L1L2)\n\ta1 = a2 = pi*(uv.x);\n\tl1 = 0.3*uv.y;\n    l2 = 0.3*(1.0-uv.y);\n    #endif\n    \n    #if(SWEEP_MODE == CUSTOM)\n\t/* your code here */\n    #endif\n    \n    return vec4(a1,a2,v1,v2);\n}\n\nvec2 cossin(float x)\n{\n\treturn vec2(cos(x),sin(x));   \n}\n\nfloat dfCircle(float d, vec2 uv)\n{\n    return length(uv)-d/2.0;\n}\n\nfloat dfRing(float d, float w, vec2 uv)\n{\n    return abs(length(uv)-d/2.0)-w/2.0;\n}\n\nfloat dfLine(vec2 start, vec2 end, float w, vec2 uv)\n{\n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv)-w/2.0;\n}\n\n#define StartCanvas(p, s) {vec2 uv=p; float ps=s; vec4 c=vec4(0); vec4 oc=vec4(0,0,0,1);\n#define Color(v) oc.rgb = vec3(v);\n#define Alpha(v) oc.a = float(v);\n#define Circle(p,d) c=mix(c,oc,smoothstep(ps,0.,dfCircle(d,uv-(p))));\n#define Ring(p,d,w) c=mix(c,oc,smoothstep(ps,0.,dfRing(d,w,uv-(p))));\n#define Line(a,b,w) c=mix(c,oc,smoothstep(ps,0.,dfLine(a,b,w,uv)));\n#define EndCanvas(o) o=mix(o,c,c.w);}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 last = texelFetch(iChannel1,ivec2(fragCoord),0);\n    vec4 cur = texelFetch(iChannel0,ivec2(fragCoord),0);\n    float resetTime = last.z;\n    float flipTime = last.w;\n\tbool reset = texelFetch(iChannel2,ivec2(0x20,0),0).x!=0.0; //Space = reset\n    \n    if(iFrame == 0 || reset)\n    {\n        last.xy = cur.xy;\n        last.zw = vec2(0);\n        resetTime = float(iFrame)*dt;\n        flipTime = 3600.0; //Start with a large time where the gradient is transparent.\n    }\n\t\n    //Detect flip and set flipTime to the current time (relative to last reset).\n    //Detects the discontinuity as the angle goes from +pi to -pi (or vise-versa).\n    if(abs(last.y-cur.y) > flipThres)\n    {\n        flipTime = min(float(iFrame)*dt - resetTime, flipTime);\n    }\n    \n    fragColor = vec4(cur.xy,resetTime,flipTime);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}