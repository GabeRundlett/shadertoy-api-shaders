{
    "Shader": {
        "info": {
            "date": "1647239162",
            "description": "A super cheap and exact Menger that only calls the box sdf once no matter how many iterations are applied.  The sdf is also exact so it works perfectly with rounding or smin or other functions that require precise distances. Its all at lines 26 and 42. ",
            "flags": 48,
            "hasliked": 0,
            "id": "sdSBWc",
            "likes": 4,
            "name": "Ultra cheap exact Menger sponge",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fast",
                "exact"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 518
        },
        "renderpass": [
            {
                "code": "//Use mouse to look and wasd to move\n//Free cam by  glk7\n//https://www.shadertoy.com/view/4lVXRm\n\n\n//#define rotations\n\n//Heavy performance impact \n#define AA 2\n#define raymarchSteps 100\n//\n#define ZERO min(iFrame, 0)\n\n\nconst float pi = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdSphere(vec3 p, float r){\n    return length(p) -r;\n}\n\nmat2 rotate(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s,\n                -s, c);\n}\nvec3 trans(vec3 p, float s){\n        //Mirror\n        p = abs(p)-1.*s;\n        p *= -1.;\n        //Reflect column\n        p.xy = ((p.x - p.y > 0.) ? p.yx : p.xy);  \n        p.zy = ((p.z - p.y > 0.) ? p.yz : p.zy);  \n\n        //construct column\n        p.y = (abs(p.y-0.5*s)-0.5*s);\n        \n        return p;\n}\n\n\n// I don't know why but putting the calls to trans in a loop caused some weid behavioirs\nvec4 map(vec3 p) {\n\n    const float scale = 260.;\n\n    p*= scale;\n    \n    #ifdef rotations\n    p = trans(p, 27.*9.);\n    p.xy *= rotate(13.2);\n    p = trans(p, 27.*3.);\n    p.zy *= rotate(1.2);\n    p = trans(p, 27.);\n    p.xz *= rotate(13.12);\n    p = trans(p, 9.);\n    p.yz *= rotate(1.12);\n    p = trans(p, 3.);\n    p.yz *= rotate(6.12);\n    p = trans(p, 1.);\n    #else\n    p = trans(p, 27.*9.);\n    p = trans(p, 27.*3.);\n    p = trans(p, 27.);\n    p = trans(p, 9.);\n    p = trans(p, 3.);\n    p = trans(p, 1.);\n    \n    #endif\n\n    return vec4(sdBox(p, vec3(.5))/scale - 0.0005, p);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=ZERO; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\nvec3 intersection(vec3 ro, vec3 rd){\n    float dist;\n    for (int i = 0; i < raymarchSteps; i++){\n        dist = map(ro).x;\n        ro += dist*rd;\n        if (dist < 0.00001 || dist > 20.)\n            break;\n    }\n    \n    return ro;\n\n}\n\nvec4 render(vec3 ro, vec3 rd){\n    vec3 p = intersection(ro,rd);\n    vec3 t = map(p).yzw;\n    \n    //Shading\n     vec3 sun = normalize(vec3(1., 1., 1.9));\n     \n     //Most of the lag is from shadows\n    float sha = softshadow(p, sun, .005, 10., 10.);\n     vec3 nor = calcNormal(p);\n    float occ = calcAO(p, nor);\n    float bou = pow(dot(sun*-1.,nor)*0.5+0.5, 1.);\n\n    //Colors\n    vec3 col = vec3(0.);\n    vec3 bcl = vec3(0.929,0.027,0.027);//vec3(distance(t,p)/40.1);\n    vec3 scl = vec3(1., 0.86 ,.7);\n    vec3 amb = vec3(0.7, 0.85, 1.);\n    vec3 hvc = normalize(sun - rd);\n    //\n    if (map(p).x < 0.1) {\n        col += 2.2*scl*bcl*sha;\n        col += .6*scl*bcl*bou*pow(occ, .23);\n        col += 0.8*bcl*amb*occ*(dot(nor, vec3(0,1,0))*.4+.6);\n        col += sha*max(0.,pow(dot(nor,hvc), 5.));\n        \n    } else\n        col = vec3((rd.y+.5)*.5+0.9)*amb;\n    return vec4(col, 1);\n}\n\n\nconst float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\n\n//Free cam by  glk7\n//https://www.shadertoy.com/view/4lVXRm\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) \n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    \n    rd = CameraRotation(m) * rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3   ro = vec3(0, 0, -12.5);\n    \n\n    vec4 tot = vec4(0);\n    \n    //Super sampling\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 u = ((fragCoord+o) / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n        vec3 rd = normalize(vec3(u, 1));\n        Camera(fragCoord+o, ro, rd);\n\n        tot += render(ro, rd) / float(AA*AA);\n    }}\n\n    \n    tot = smoothstep(-0.,1.2, tot);\n    // Output to screen\n    fragColor = sqrt(tot);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Free cam by  glk7\n//https://www.shadertoy.com/view/4lVXRm\n\n\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    return CameraRotation(m) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    \n    position += (target - position) * iTimeDelta * 5.0;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "mat3 CameraRotation( vec2 m )\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}