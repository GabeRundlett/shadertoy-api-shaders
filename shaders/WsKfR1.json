{
    "Shader": {
        "info": {
            "date": "1606588128",
            "description": "If you drag the mouse on the screen, the object will be rotated.",
            "flags": 32,
            "hasliked": 0,
            "id": "WsKfR1",
            "likes": 3,
            "name": "Rotation by Dragging",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 466
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 du = vec2(1.0, 0.0) / iResolution.xy;\n    vec2 dv = vec2(0.0, 1.0) / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    col += texture(iChannel0, uv + du + dv).xyz;\n    col += texture(iChannel0, uv + du).xyz;\n    col += texture(iChannel0, uv + du - dv).xyz;\n    col += texture(iChannel0, uv + dv).xyz;\n    col += texture(iChannel0, uv - dv).xyz;\n    col += texture(iChannel0, uv - du + dv).xyz;\n    col += texture(iChannel0, uv - du).xyz;\n    col += texture(iChannel0, uv - du - dv).xyz;\n    col /= 8.0;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The MIT License\n// Copyright Â© 2020 IWBTShyGuy\n\nconst float EPSILON = 1.0e-3;\nconst float PRADIUS = 0.01;\nconst vec3 CYLINDER_COLOR = vec3(220.0, 214.0, 231.0) / 255.0;\nconst vec3 CYLINDER_REFLECT_RATIO = vec3(0.2, 0.6, 0.2);\nconst vec3 FLOOR_COLOR = vec3(117.0, 109.0, 145.0) / 255.0;\n\n// a[0]i + a[1]j + a[2]k + a[3]\nvec4 qmult(vec4 a, vec4 b) {\n    return vec4(\n        a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0],\n        -a[0] * b[2] + a[1] * b[3] + a[2] * b[0] + a[3] * b[1],\n        a[0] * b[1] - a[1] * b[0] + a[2] * b[3] + a[3] * b[2],\n        - a[0] * b[0] - a[1] * b[1] - a[2] * b[2] + a[3] * b[3]\n    );\n}\n\n// rotation by quaternion\nvec3 qrot(vec4 q, vec3 x) {\n    vec4 x_prime = vec4(x, 0.0);\n    vec4 q_bar = vec4(-q.xyz, q.w);\n    return qmult(qmult(q, x_prime), q_bar).xyz;\n}\n\nbool mouse_dragging(out vec2 disp) {\n    vec2 du = vec2(1.0, 1.0) / iResolution.xy;\n    vec4 p_mouse = 2.0 * texture(iChannel0, du) - 1.0;\n    vec4 mouse = iMouse / iResolution.xyxy;\n    disp = mouse.xy - p_mouse.xy;\n    return p_mouse.z > 0.0 && mouse.z > 0.0;\n}\n\n// --------------------- cylinder --------------------- //\nstruct Cylinder {\n    vec3 origin;\n    vec3 direction; // have to be normalized\n    float radius;\n    float height;\n};\n\n// Returns positive value if a point is in a cylinde.\nfloat in_cylinder(\n    in vec3 point,\n    in Cylinder cylinder\n) {\n    float dist2 = distance2_point_line(point, cylinder.origin, cylinder.direction);\n    return cylinder.radius * cylinder.radius - dist2;\n}\n\n// Creats an orthogonal matrix whose z_axis is dir.\nmat3 create_matrix(in vec3 dir) {\n    int tmp = abs(dir[0]) < abs(dir[1]) ? 0 : 1;\n    int midx = abs(dir[tmp]) < abs(dir[2]) ? tmp : 2;\n    vec3 axis0 = vec3(0.0);\n    axis0[(midx + 1) % 3] = dir[(midx + 2) % 3];\n    axis0[(midx + 2) % 3] = -dir[(midx + 1) % 3];\n    vec3 axis1 = cross(dir, axis0);\n    return mat3(axis0, axis1, dir);\n}\n\n// Find the intersection of a ray of light with a cylinder extending infinitely around the z-axis.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return radius^2 - (the distance between the ray and the z-axis)^2\nfloat regular_infinite_cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in float radius,\n    out vec3 position,\n    out vec3 normal\n) {\n    vec2 p_ray = normalize(ray.xy);\n    vec2 p_org = origin.xy;\n    vec2 p_h = dot(p_ray, p_org) * p_ray - p_org;\n    float res = radius * radius - dot(p_h, p_h);\n    if (res < 0.0) {\n        return res;\n    }\n    float t = dot(p_ray, -p_org) - sqrt(res);\n    t *= 1.0 / length(ray.xy);\n    position = origin + t * ray;\n    normal = vec3(position.xy, 0.0);\n    return res;\n}\n\n// Find the intersection of a ray of light with a cylinder around the z-axis.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[in] height the height of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return Returns a positive value if the ray and the cylinder have a intersection.\nfloat regular_cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in float radius,\n    in float height,\n    out vec3 position,\n    out vec3 normal\n) {\n    float res = regular_infinite_cylinder_intersection(\n        origin,\n        ray,\n        radius,\n        position,\n        normal\n    );\n    if (position.z < 0.0) {\n        position = origin - origin.z / ray.z * ray;\n        res = radius * radius - dot(position.xy, position.xy);\n    } else if (position.z > height) {\n        position = origin + (height - origin.z) / ray.z * ray;\n        res = radius * radius - dot(position.xy, position.xy);\n    }\n    return res;\n}\n\n// Find the intersection of a ray of light with a cylinder.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return radius^2 - (the distance between the ray and the z-axis)^2\nfloat cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in Cylinder cylinder,\n    out vec3 position,\n    out vec3 normal\n) {\n    mat3 mat = create_matrix(cylinder.direction);\n    if (abs(det(mat)) < 1.0e-3) {\n        return -1.0;\n    }\n    float res = regular_cylinder_intersection(\n        solve(mat, origin - cylinder.origin),\n        solve(mat, ray),\n        cylinder.radius,\n        cylinder.height,\n        position,\n        normal\n    );\n    position = mat * position + cylinder.origin;\n    normal = mat * normal;\n    return res;\n}\n\n// Renders the intersection of two cylinders\nfloat render_core(\n    in vec2 uv,\n    in Camera camera,\n    in SpotLight light,\n    in Cylinder cylinder[2],\n    out vec3 col\n) {\n    vec3 ray = camera_ray(camera, uv);\n    vec3 position0, normal0, position1, normal1;\n    float res0 = cylinder_intersection(camera.position, ray, cylinder[0], position0, normal0);\n    float res1 = cylinder_intersection(camera.position, ray, cylinder[1], position1, normal1);\n    float res = min(res0, res1);\n    if (res < 0.0) {\n        return res;\n    }\n    vec3 position, normal;\n    float res01 = in_cylinder(position0, cylinder[1]);\n    float res10 = in_cylinder(position1, cylinder[0]);\n    if (res01 < 0.0 && res10 < 0.0) {\n        return -1.0;\n    } else if (res01 < 0.0) {\n        position = position1;\n        normal = normal1;\n    } else if (res10 < 0.0) {\n        position = position0;\n        normal = normal0;\n    } else {\n        float depth0 = length(position0 - camera.position);\n        float depth1 = length(position1 - camera.position);\n        position = depth0 < depth1 ? position0 : position1;\n        normal = depth0 < depth1 ? normal0 : normal1;\n    }\n    vec3 phong_vector = phong_vector(position, normal, light, camera, 5.0);\n    col = CYLINDER_COLOR * dot(phong_vector, CYLINDER_REFLECT_RATIO);\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n  \n    // the (0, 0) pixel is the buffer for mouse\n    if (length(uv) < PRADIUS) {\n        fragColor = (iMouse / iResolution.xyxy + 1.0) / 2.0;\n        return;\n    }\n    \n    // First Frame\n    if (iFrame == 0) {\n        fragColor = vec4(0.40, 0.70, 0.5, 1.0);\n        return;\n    }\n\n    vec2 du = vec2(1.0, 1.0) / iResolution.xy;\n    vec4 rot = 2.0 * texture(iChannel0, vec2(1.0, 1.0) - du) - 1.0;\n    \n    vec2 dm;\n    bool drag = mouse_dragging(dm);\n    if (drag && length(dm) > EPSILON) {\n        vec3 axis = normalize(vec3(dm.y, -dm.x, 0.0));\n        float angle = length(dm) * 3.0;\n        vec4 frot = vec4(axis * sin(angle / 2.0), cos(angle / 2.0));\n        rot = qmult(rot, frot);\n    }\n\n    if (length(uv - vec2(1.0, 1.0)) < PRADIUS) {\n        fragColor = (rot + 1.0) / 2.0;\n        return;\n    }\n\n    vec3 pos = qrot(rot, vec3(0.0, 0.0, 1.0));\n    vec3 up = qrot(rot, vec3(0.0, 1.0, 0.0));\n    float asp = iResolution.x / iResolution.y;\n    Camera camera = new_camera(5.0 * pos, -pos, up, PI / 4.0, asp);\n    SpotLight light = new_light(5.0 * pos, -pos, PI / 2.0);\n\n    Cylinder cylinder[2];\n    cylinder[0].origin = vec3(-2.0, 0.0, 0.0);\n    cylinder[0].direction = vec3(1.0, 0.0, 0.0);\n    cylinder[0].radius = 1.0;\n    cylinder[0].height = 4.0;\n    cylinder[1].origin = vec3(0.0, -2.0, 0.0);\n    cylinder[1].direction = vec3(0.0, 1.0, 0.0);\n    cylinder[1].radius = 1.0;\n    cylinder[1].height = 4.0;\n\n    vec3 col;\n    render_core(uv, camera, light, cylinder, col);\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float PI = 3.141592653;\n\n// ----------------------- Light ----------------------- //\nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    float angle;\n};\n\nSpotLight new_light(vec3 position, vec3 direction, float angle) {\n    SpotLight light;\n    light.position = position;\n    light.direction = direction;\n    light.angle = angle;\n    return light;\n}\n\n// ----------------------- Camera ----------------------- //\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction;\n    float fov;\n    float aspect; // x / y\n};\n\nCamera new_camera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nvec3 camera_ray(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    return normalize(right * w * uv.x + up * h * uv.y + camera.direction);  \n}\n\n// ----------------------- Basic Math ----------------------- //\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\n// determinant of a 3x3 matrix\nfloat det(in mat3 a) {\n    return a[0][0] * a[1][1] * a[2][2]\n        + a[0][1] * a[1][2] * a[2][0]\n        + a[0][2] * a[1][0] * a[2][1]\n        - a[0][1] * a[1][0] * a[2][2]\n        - a[0][2] * a[1][1] * a[2][0]\n        - a[0][0] * a[1][2] * a[2][1];\n}\n\n// Solves the equation Ax = b.\nvec3 solve(in mat3 a, in vec3 b) {\n    return vec3(\n        det(mat3(b, a[1], a[2])),\n        det(mat3(a[0], b, a[2])),\n        det(mat3(a[0], a[1], b))\n    ) / det(a);\n}\n\n// the square of the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance2_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    vec3 a = point - origin;\n    vec3 h = a - dot(a, direction) * direction;\n    return dot(h, h);\n}\n\n// the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    return sqrt(distance2_point_line(point, origin, direction));\n}\n\n// ------------------- good old Phong model ------------------- //\nfloat phong_ambient() {\n    return 1.0;\n}\n\nfloat phong_diffuse(vec3 position, vec3 normal, SpotLight light) {\n    vec3 dir = normalize(light.position - position);\n    return dot(dir, normal);\n}\n\nfloat phong_specular(vec3 position, vec3 normal, SpotLight light, Camera camera, float alpha) {\n    vec3 light_dir = normalize(light.position - position);\n    if (dot(light_dir, normal) < 0.0) return 0.0;\n    vec3 camera_dir = normalize(camera.position - position);\n    vec3 reflect_dir = reflect(-light_dir, normal);\n    float cos_alpha = clamp(dot(camera_dir, reflect_dir), 0.0, 1.0);\n    return pow(cos_alpha, alpha);\n}\n\nvec3 phong_vector(\n    vec3 position,\n    vec3 normal,\n    SpotLight light,\n    Camera camera,\n    float specular_alpha\n) {\n    return vec3(\n        phong_ambient(),\n        phong_diffuse(position, normal, light),\n        phong_specular(position, normal, light, camera, specular_alpha)\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}