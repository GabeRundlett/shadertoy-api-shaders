{
    "Shader": {
        "info": {
            "date": "1600177198",
            "description": "raytracing2d",
            "flags": 0,
            "hasliked": 0,
            "id": "WdK3zd",
            "likes": 1,
            "name": "raytracing2d",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "Stefano_Liu",
            "viewed": 307
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col=sampleRay(uv,iTime);\n\n    // Output to screen\n    fragColor = vec4(powVec3(col,0.67),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Defines\n#define PI 3.1415926535898\n#define N 512.0\n#define DEPTH 15.0\n\n#define Light 0\n#define Metal 1\n#define Dielect 2\n\n#define IOR 1.3326\n\n#define White vec3(1.52,1.79,1.68)\n#define Black vec3(0.0,0.0,0.0)\n//Structs\n\nstruct ray2d{\n    vec2 o;\n    vec2 d;\n};\n    \nstruct interaction{\n    float t;\n    vec2 p;\n    vec2 n;\n    vec2 wo;\n    vec3 col;\n    int mat;\n};\nfloat rand(vec2 n)\n{\n    return fract(sin(dot(n.yx, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat absrand(vec2 n)\n{\n    return fract(abs(sin(dot(n.yx, vec2(12.9898, 78.233)))) * 43758.5453);\n}\n\nvec2 uniformSampleCircle(vec2 st)\n{\n    float r=sqrt(rand(st.xy));\n    float theta=rand(st.yx)*2.0*PI;\n    return vec2(r*cos(theta),r*sin(theta));\n}\nvec2 uniformSampleCircleFromSquare(vec2 st)\n{\n    vec2 v;\n    do\n    {\n    \tv=vec2(rand(st.xy),rand(st.yx));\n        \n    } while(length(v)>=1.0);\n        \n    return v;\n}\nvec2 uniformSamlpleCircleJitter(vec2 st)\n{\n    float x=cos(PI * 2.0 * (rand(st.xy)));\n    float y=sin(PI * 2.0 * (rand(st.yx)));\n    return vec2(x,y);\n}\n\n\nvec2 rayAtT(ray2d ray,float t)\n{ \n    return ray.o + ray.d * t;\n}\n\n\nbool diskHit(ray2d ray,vec2 cen,float r,int material,inout interaction rec)\n{\n\n    rec.mat=material;\n    vec2 oc = ray.o - cen;\n\tfloat a = dot(ray.d, ray.d);\n\tfloat b = dot(ray.d, oc);\n\tfloat c = dot(oc, oc) - r * r;\n\n\tfloat discriminant = (b * b - a * c);\n\tif (discriminant >= 0.0)\n    {\n    \tfloat t = (-b - sqrt(discriminant)) / a;\n\t\tif ( t >= 0.0)\n\t\t{\n\t\t\trec.t = t;\n\t\t\trec.p = rayAtT(ray,t);\n\t\t\trec.n = normalize((rec.p - cen) / r);\n\t\t\trec.wo = vec2(-ray.d);\n            \n\t\t\treturn true;\n\t\t}\n\t\tt = (-b + sqrt(discriminant)) / a;\n\t\tif (t >= 0.0)\n\t\t{\n\t\t\trec.t = t;\n\t\t\trec.p = rayAtT(ray,t);\n\t\t\trec.n = normalize((rec.p - cen) / r);\n\t\t\trec.wo = vec2(-ray.d);\n\t\t\treturn true;\n\t\t}\n\t}\n\n}\nfloat shlick(float cosine, float ior)\n{\n\tfloat r0 = (1.0 - ior) / (1.0 + ior);\n\tr0 = r0 * r0;\n\treturn r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\nray2d refractRay(ray2d r,interaction inte)\n{\n    if (dot(r.d, inte.n) > 0.0)\n    {\n        vec2 normal=-inte.n;\n        return ray2d(inte.p,refract(r.d,normal,IOR));\n    }\n    else\n    {\n        vec2 normal=-inte.n;\n        ray2d result=ray2d(inte.p,refract(r.d,-normal,1.0/IOR));\n        return result;\n\n        float cosine = -dot(result.d, inte.n) / length(r.d);\n        float reflQuan = shlick(cosine, IOR);\n       // return refract(r.d,normal,IOR);\n        \n\n        \n        if (absrand(r.d) >= reflQuan)\n\t\t{\n\t\t\tresult.d = normalize(reflect(r.d,normal));\n\t\t\tresult.o = inte.p - 0.01 * normal;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.d = normalize(reflect(normal, r.d));\n\t\t\tresult.o = inte.p + 0.01 * normal;\n\t\t}\n\n        return result;\n    }\n}\n\nvec3 traceRay(ray2d ray,inout interaction inte,float depth)\n{    \n    ray2d scattered=ray;\n    vec3 sums=vec3(0.0,0.0,0.0);\n    int material;\n    for(depth;depth<DEPTH;depth++)\n    {\n    \t//objects hit\n        if(diskHit(scattered,vec2(0.45,0.35),0.1,Metal,inte))\n        {\n            if(distance(scattered.o, vec2(0.45,0.35)) <= 0.1)\n            {\n                break;\n            }\n            scattered.o=inte.p;\n            scattered.d=reflect(ray.d,inte.n);\n            continue;\n        }\n        else if(diskHit(scattered,vec2(0.7,0.45),0.1,Dielect,inte))\n        {\n            //scattered.o=inte.p;\n            //scattered.d=reflect(ray.d,inte.n);\n            scattered=refractRay(scattered,inte);\n            continue;\n        }\n        else if(diskHit(scattered,vec2(0.5,0.6),0.1,Light,inte))\n        {\n            sums+=White;\n            break;\n        }\n        else \n          \treturn sums;\n\n    }\n   return sums;\n}\n\nvec3 powVec3(vec3 v,float n)\n{\n    return vec3(pow(v.x,n),pow(v.y,n),pow(v.z,n));\n}\n\nvec3 sampleRay(vec2 pos,float time)\n{\n    vec3 sums=vec3(0.0,0.0,0.0);\n    interaction inte;\n    \n    vec2 distPos=pos;\n    \n    for(float n=0.0;n<N;n++)\n    {\n        distPos=pos+n+time;\n        sums+=traceRay(ray2d(pos,normalize(uniformSampleCircle(distPos))),inte,0.0);\n    }\n    return sums/N;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}