{
    "Shader": {
        "info": {
            "date": "1624233457",
            "description": "A handy tool\n\nReplace the return value at line 194 with your own distance function to see it visualized\n\nThis is my first attempt at 3D in shadertoy, so the camera is distorted since I used polar coordinates rather than figuring out how to do it properly.",
            "flags": 0,
            "hasliked": 0,
            "id": "flB3zV",
            "likes": 6,
            "name": "3D Distance Function Visualizer",
            "published": 3,
            "tags": [
                "raymarching",
                "tool"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 221
        },
        "renderpass": [
            {
                "code": "//Input Variables\nconst float pi = 3.14159;\nfloat minDistance = 0.0001;\nfloat cameraFarPlane = 200.0;\nvec3 cameraCoords = vec3(0, 0, -15.0);\nconst float maxSteps = 255.0;\nfloat fieldOfView = 45.0;\nfloat mouseSensitivity = 1.0;\n\nconst float glow = 1.0;\nconst float light = 0.7;\nvec3 glowColor = vec3(0.0, 0.6, 1.0);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n#define SHOW_MANDELBULB false\n\nstruct vec5 {\n    vec4 a;\n    float v;   \n};\n\nvec3 debugCol( float v )\n{\n    return vec3(v, v, v);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat mengerSpongeDF(int n, vec3 pos) { //by recursively digging a box\n\tfloat x=pos.x, y=pos.y, z=pos.z;\n\tx=x*0.5+0.5;y=y*0.5+0.5;z=z*0.5+0.5; //center it by changing position and scale\n\n\tfloat xx=abs(x-0.5)-0.5, yy=abs(y-0.5)-0.5, zz=abs(z-0.5)-0.5;\n\tfloat d1=max(xx,max(yy,zz)); //distance to the box\n\tfloat d=d1; //current computed distance\n\tfloat p=1.0;\n\tfor (int i=1; i<=n; ++i) {\n\t\tfloat xa = mod(3.0*x*p,3.0);\n\t\tfloat ya = mod(3.0*y*p,3.0);\n\t\tfloat za = mod(3.0*z*p,3.0);\n\t\tp*=3.0;\n\n\t\t//we can also translate/rotate (xa,ya,za) without affecting the DE estimate\n\n\t\tfloat xx=0.5-abs(xa-1.5), yy=0.5-abs(ya-1.5), zz=0.5-abs(za-1.5);\n\t\td1=min(max(xx,zz),min(max(xx,yy),max(yy,zz))) / p; //distance inside the 3 axis-aligned square tubes\n\n\t\td=max(d,d1); //intersection\n\t}\n\t//return d*2.0; //the distance estimate. The *2 is because of the scaling we did at the beginning of the function\n\treturn d;\n}\n\nfloat boxDF( vec3 p, vec3 b, vec3 s, vec3 o )\n{\n  vec3 q = s + abs(p - o) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat boxFrameDF( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sphereDF(vec3 spherePos, float radius, vec3 point)\n{\n    return length(point - spherePos) - radius;\n}\n\nfloat torusDF( vec3 p, vec2 t, vec3 o )\n{\n  p -= o;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat octahedronDF( vec3 p, float s, vec3 o )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d2, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float size = 2.5;\n    return boxFrameDF( q , vec3(size, size, size), 0.025);\n}\n\nfloat sdf_blend(float d1, float d2, float a)\n{\n    return a * d1 + (1.0 - a) * d2;\n}\n\nmat3x3 rotationAlign( const vec3 d, const vec3 z )\n{\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0f/(1.0f+c);\n\n    return mat3x3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                   v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                   v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      \n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nfloat yourDistanceFunctionHere( vec3 p )\n{\n    mat3x3 matrix = rotationAlign(vec3(0, 1, 0), normalize(vec3(sin(iTime), cos(iTime), cos(iTime))));\n    float minDist = cameraFarPlane;\n    minDist = min(minDist, mengerSpongeDF(5, (p*0.5 - vec3(0, 1, -4))*matrix));\n    /*float t = 0.3;\n    minDist = min(minDist, \n    \n        (1.0-t)*(boxDF((p-vec3(0, 3, -4))*matrix, vec3(2), vec3(0), vec3(0, 0, 0))-2.0)\n        + (length(p-vec3(0, 3, -4))-5.0)*t\n    \n    );*/\n\n    if (SHOW_MANDELBULB)\n    {\n        vec4 o;\n        p*=0.2;\n        minDist = min(minDist,  map((p-vec3(-2, 0.5, -5))*matrix, o));\n    }\n    \n    return minDist;\n    //sphereDF(vec3(sin(iTime*0.2)*10.0, 2, 0.0+cos(iTime*0.2)*10.0), (sin(iTime)+1.0)*2.5, p);\n}\n\nvec2 DF(vec3 point)\n{\n    float minDist = cameraFarPlane;\n    \n    float distance1 = yourDistanceFunctionHere(point);\n    minDist = min(minDist, distance1);\n    minDist = min(minDist, point.y +  3.0);\n    \n    \n    \n    //final  = smin(partial, distance3, 3.0);\n\n    \n    return vec2(minDist, distance1);\n}\n\n//*\nfloat evaluateLight( vec3 origin)\n{\n    return (1.0+cos(DF(origin).y-pi/2.0))/2.0;\n    //return sin(DF(origin).y);\n\n}//*/\n\n\nvec5 depth( vec3 origin, vec3 direction )\n{\n    float depth = 0.0;\n    float light = 0.0;\n    float iterations = 0.0;\n    vec2 closestPoint = vec2(cameraFarPlane, 0);\n    \n    \n    vec3 b = direction/length(direction);//b = normalized direction\n    vec3 p = origin; //point or direction vector times depth\n    \n    float d = cameraFarPlane; //Distance\n    \n    float didCollide = 1.0;\n    \n    for(float i=0.;i<maxSteps;i++)\n    {\n        p = origin + (b*depth);\n        d = DF(p).x;\n        \n        iterations++;\n        \n        if (d < closestPoint.x) closestPoint.x = d;\n        \n        if (d < minDistance || depth > cameraFarPlane)\n        {\n            if ((d > minDistance))\n            {\n                didCollide = 0.0;\n            }\n            \n            break;\n        }\n        \n        depth += d;\n\n    }\n    \n    if (depth < cameraFarPlane)\n    {\n        light = evaluateLight(p);\n    }\n    \n    \n    depth /= cameraFarPlane;\n    \n    \n    return vec5(vec4(depth, light, iterations/maxSteps, closestPoint.x), didCollide);\n}\n\nvec2 circle( vec2 centrePos, float radius, float deg)\n{\n  float x = centrePos.x + radius * cos(deg * pi / 180.0);\n  float y = centrePos.y + radius * sin(deg * pi / 180.0);\n  return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.z>0.?(iMouse.xy/iResolution.xy) * 2.0 - 1.0:vec2(0);\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= mouseSensitivity*fieldOfView;    \n    \n\n    vec2 dirY = circle(vec2(0, 0), 1.0, mouse.y + uv.y *fieldOfView);\n    vec2 dirXY = circle(vec2(0, 0), dirY.x, mouse.x*5.0 + uv.x*fieldOfView);\n    vec3 dirV = vec3(dirXY.y, dirY.y, dirXY.x);//Polar Coordinate Spherical Projection \n    //I know this introduces distortion but I came up with this technique right when I was getting into shaders\n    //so I'm rather fond of it and decided to keep it :)\n\n    \n    vec4 pixelInfo =depth(cameraCoords, dirV).a;\n    \n    vec3 lightCol = /*debugCol(0.0);*/lightColor * pixelInfo.y * light;\n    vec3 glowCol = glowColor * pixelInfo.z * glow;\n    vec3 col = lightCol + glowCol;\n\n    \n    fragColor = vec4(col.xyz, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}