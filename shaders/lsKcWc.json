{
    "Shader": {
        "info": {
            "date": "1524141110",
            "description": "Linearizing spiral to observe galaxy dust clouds, in a research context. No aestheticism intended :)\n\nSee comments for galaxy texture !\n\nBetter in fullscreen :)\n\n[b]L[/b]inearize\n[b]Z[/b]oom\n[b]F[/b]reeze & use ruler\n[b]T[/b]humbnail",
            "flags": 48,
            "hasliked": 0,
            "id": "lsKcWc",
            "likes": 7,
            "name": "Spiral galaxy linearization",
            "published": 3,
            "tags": [
                "spiral",
                "galaxy",
                "linearize",
                "logspiral"
            ],
            "usePreview": 0,
            "username": "ABizard",
            "viewed": 892
        },
        "renderpass": [
            {
                "code": "\n#define galaxyTexChannel iChannel0\n#define bufAChannel iChannel1\n#define bufBChannel iChannel2\n#define fontTexChannel iChannel3\n\n/*/\n/*\n/* This shader purpose is to linearize spirals to observe galaxy dust clouds,\n/* in a research context. No particular aestheticism intended :)\n/*\n/*/\n\n/*\nGalaxy textures (set GALAXY in Common)\n\nGalaxy textures can be obtained by add-on on browser for custom textures :\nFirefox : https://addons.mozilla.org/en-US/firefox/addon/shadertoy-custom-texures/\nChrome : https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n\nor by using js console (press F12) :\n\n######\n# M51\n\n# Low Res :\ngShaderToy.SetTexture(0, {mSrc:'https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Messier51_sRGB.jpg/1280px-Messier51_sRGB.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\n\n# High Res :\n\ngShaderToy.SetTexture(0, {mSrc:'https://upload.wikimedia.org/wikipedia/commons/d/db/Messier51_sRGB.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\n\n#\n######\n\n######\n# M101\n\n# Low Res :\n\ngShaderToy.SetTexture(0, {mSrc:'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/M101_hires_STScI-PRC2006-10a.jpg/1280px-M101_hires_STScI-PRC2006-10a.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\n\n# High Res :\n\ngShaderToy.SetTexture(0, {mSrc:'https://upload.wikimedia.org/wikipedia/commons/c/c5/M101_hires_STScI-PRC2006-10a.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\n\n#\n######\n*/\n\n#define keyState(K) texture(bufBChannel,vec2(float(K)/256.))\n#define keyToggle(K) (keyState(K).x > .5)\n#define keyPress(K) (keyState(K).y > .5)\n#define frozenMousePos (texture(bufBChannel,vec2(0)).zw)\n\n/////////////////////////////////////////////////////\n// Keyboard controls\n\n// 'L' : switch display : normal / linearized\n#define LINEARIZE\t\t\t keyToggle(_L)\n// 'Z' : zoom\n#define ZOOM\t\t\t\t!keyToggle(_Z)\n#define ZOOM_FACTOR\t(ZOOM ? 1. : 3.)\n// 'F' : freeze image, display ruler\n#define DISP_RULER\t\t\t keyToggle(_F)\n// 'R' : switch ruler type\n#define CUSTOM_RULER_MODE\t!keyToggle(_R)\n// 'T' : display thumbnail\n#define DISP_THUMBNAIL\t\t!keyToggle(_T)\n// 'I' : invert colors\n#define INVERT_COLORS\t\t keyToggle(_I)\n\n// Debug :\n// 'D' : debug display\n#define DISP_PARAMS\t\t\t keyToggle(_D)\n// 'M' : toggle mesh\n#define DRAW_MESH\t\t\t!keyToggle(_M)\n\n\n// Contrast increase (0 : no contrast increase)\n#define CONTRAST 1\n#define INCR_CONTRAST(COL) smoothstep(0.,1.,COL)\n\n\n// Access the texture of the galaxy at galaxyTexChannel\n// Distort it according to GALAXY_DISTORTION\n// Result a-channel is set to 0 if out of texture, 1 otherwise\nvec4 galaxyTexture(vec2 uv){\n    \n    // Cut if original uv is not in [0,1]\n    bool out_of_tex = abs(uv.x-.5)>.5 || abs(uv.y-.5)>.5;\n    \n    // Spiral mesh\n    vec4 mesh = texture(bufAChannel,uv);\n    \n    // Galaxy photo distortion to get a nice, not distorted spiral\n    vec2 screen_ratio = vec2((R.x/R.y)/(640./360.),1);\n    vec2 img_compr = GALAXY_DISTORTION*screen_ratio;\n    uv = (uv-.5)*img_compr + GALAXY_CENTER;\n    \n    vec3 color = mix(texture(galaxyTexChannel,uv).rgb,\n                     mesh.rgb,\n                     DRAW_MESH ? mesh.a : 0.);\n    \n    out_of_tex = out_of_tex\n          || abs(uv.x-.5)>.5 || abs(uv.y-.5)>.5 // Cut if new uv is not in [0,1]\n          || (GALAXY==M51 && uv.x>.700); // Cut the satellite galaxy on M51\n    \n    return vec4(color, !out_of_tex);\n}\n\n//////////////////////////////////////////////\n///////////////////  MAIN  ///////////////////\n//////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec3 color = BLACK;\n    \n    // Normalized coordinates in [0,1]\n    vec2 pixel = fragCoord/R.xy;\n    \n    // Parameters of the spiral\n    float beta=BETA,    // warp\n    \t  gamma=GAMMA;  // rotation\n    int   n=N_GALAXY;   // number of arms\n\n    ///////////////////////\n    // Parameter for the orthogonal spirals\n    float beta_orth = exp(-1./log(beta));\n    \n    // Number of spirals in the orthogonal mesh\n    int n_orth = int(round(float(n)*1./log(beta)));\n    \n    vec2 uv_tex;\n    \n    if(LINEARIZE){\n       // Linearize the texture in the logarithmic spiral space\n       // => Find the inverse parametrization to access the texture\n        vec2 mouse_offset = \n            (DISP_RULER ? frozenMousePos : iMouse.xy/R.y)*(ZOOM ? 2. : 1.)\n             + vec2(0,-.7)*(ZOOM ? 4. : 1.);\n        \n        vec2 xy = (fragCoord/R.y - mouse_offset) *float(n)*ZOOM_FACTOR;\n        \n        float theta = (2.*PI)/float(n_orth) * (xy.x*log(beta_orth) - xy.y)\n                      /(log(beta/beta_orth));\n        float rho = pow(beta,theta+2.*PI*xy.y/float(n));\n        if(CLOCKWISE)\n            theta = -theta;\n        \n        uv_tex = polToCart(rho,theta);\n        uv_tex = uv_tex/R.xy+.5;\n    }\n    else{\n        // Access directly the texture\n        uv_tex = pixel;\n    }\n    \n    // Retrieve the galaxy texture\n    vec4 galaxy_tex = galaxyTexture(uv_tex);\n    \n    // Display grey outside of the texture\n    color = mix(GREY(.5),galaxy_tex.rgb,galaxy_tex.a);\n    \n    // Thumbnail\n    if(LINEARIZE && DISP_THUMBNAIL){\n        float thb_size = .42;\n        vec2 thb_pos = vec2(-.8,.7);\n        vec2 uv_tex_thb = (pixel-.5)/thb_size+.5 - thb_pos;\n        vec4 thumbnail = galaxyTexture(uv_tex_thb);\n        color = mix(color,thumbnail.rgb,thumbnail.a);\n    }\n    \n    // Increase contrast\n    for(int i=0; i<CONTRAST; i++)\n    \tcolor = INCR_CONTRAST(color);\n    \n    \n    \n    //////////////////////////////////////\n    //////////////////////////////////////\n    //////// Additionnal displays ////////\n    //////////////////////////////////////\n    //////////////////////////////////////\n    \n    #define tex fontTexChannel\n    \n    // Shortcuts for printing\n    #define NextLine nextLine(pp)\n    #define WriteWord(word,style) writeWord(word,style,pp,tex,color)\n    #define WriteNumber(number,d1,d2,style) writeNumber(number,d1,d2,style,pp,tex,color)\n    #define WriteStandardChar(char,style) writeStandardChar(char,style,pp,tex,color)\n    \n    PrintStyle style = DefaultPrintStyle;\n    \n    // Rulers\n    if(DISP_RULER){\n        \n        #define S(a) smoothstep(1.,-1.,a)\n        \n        vec3 ruler_color = WHITE;\n        \n        // Dynamic ruler by click & drag\n        // Display distance and angle\n        if(CUSTOM_RULER_MODE){\n            \n            vec2 pos = vec2(400,335)/vec2(640,360);\n            float scale = 1./30.;\n            PrintPosition pp = getDisplayPos(pos,scale);\n            \n            WriteWord(int[](_DELTA,_EQ),style);\n            \n            vec2 p = fragCoord;  // Current pixel\n            vec2 p1 = iMouse.zw; // Mouse click position\n            vec2 p2 = iMouse.xy; // Mouse drag position\n            float dist_p_p1 = length(p - p1);\n            float dist_p_p2 = length(p - p2);\n            float dist_p1_p2 = length(p1 - p2);\n            \n            #define DRAW_SEG(P,P1,P2,WIDTH)\\\n                        color = mix(color,ruler_color,\\\n                                    S(distPointToSegment(P,P1,P2)-WIDTH));\n            \n            bool mouse_pressed = (p1.x >= 0.);\n            \n            if(mouse_pressed){\n                // Mouse is pressed, draw the segment between p1 and p2\n                DRAW_SEG(p,p1,p2,1.);\n                // Display the distance\n                WriteNumber(dist_p1_p2/R.y*100.*ZOOM_FACTOR,1,1,style);\n        \t}\n            \n            NextLine;\n            WriteWord(int[](_theta,_EQ),style);\n            \n            if(mouse_pressed){\n                // Mouse is pressed, draw the angle\n                \n                // Absolute angle in [0,PI/2.] between (P1,P2) and the x-axis\n                #define ANGLE(P1,P2,DIST)\\\n                           (DIST==0. ? 0. : atan(abs(P1.y-P2.y),abs(P1.x-P2.x)))\n                \n                float angle_p1_p2 = ANGLE(p1,p2,dist_p1_p2);\n                \n                // Angle draw size\n                float angle_size = .06*R.y;\n                if(dist_p1_p2>angle_size){\n                    // The distance is long enough to draw the angle\n                    float line_width = .6;\n                    vec2 p2_side = sign(p2-p1);\n                    vec2 p_side = sign(p-p1);\n                    \n                    // Draw the horizontal segment\n                    DRAW_SEG(p,\n                              p1+vec2(angle_size*max(p2_side.x-1.,-1.),0),\n                              p1+vec2(angle_size*min(p2_side.x+1.,1.),0),\n                              line_width);\n                    \n                    // Draw the angle curve\n                    float angle_p1_p = ANGLE(p1,p,dist_p_p1);\n                    if(angle_p1_p<=angle_p1_p2 && p2_side == p_side)\n                        color = mix(color,ruler_color,\n                                    S(abs(dist_p_p1-angle_size*.8)-line_width));\n                }\n                \n                // Display the angle value\n                WriteNumber(degrees(angle_p1_p2),1,1,style);\n        \t\tWriteStandardChar(_DEG,style);\n                \n                // Draw the dots at p1 and p2\n                #define DRAW_DOT(C,D)\\\n                            color = mix(color,C,S(D-4.));\n                DRAW_DOT(TURQUOISE,dist_p_p1);\n                DRAW_DOT(LAGOON,dist_p_p2);\n            }\n        }\n        // Static ruler, along x and y axis\n        else{\n            vec2 p = fragCoord - iMouse.xy; // mouse-centered coords\n            vec2 dist_p_axis = abs(p.yx);\n            #define DRAW_RULER(XY)\\\n                    if(dist_p_axis.XY< (mod(p.XY,.1*R.y/ZOOM_FACTOR)<1. ? 5. : 1.))\\\n                         color = ruler_color;\n            DRAW_RULER(x);\n            DRAW_RULER(y);\n        }\n    }\n    \n    \n    // Debug display (beta & gamma & n)\n    if(DISP_PARAMS){\n        \n        vec2 pos = vec2(320,335)/vec2(640,360);\n        float scale = 1./30.;\n        PrintPosition pp = getDisplayPos(pos,scale);\n\n        WriteWord(int[](_beta,_EQ),style);\n        WriteNumber(beta,1,2,style);\n        NextLine;\n\n        WriteWord(int[](_gamma,_EQ),style);\n        WriteNumber(gamma,1,2,style);\n        NextLine;\n\n        WriteWord(int[](_n,_EQ),style);\n        WriteNumber(float(n),1,0,style);\n    }\n    \n    /* Calibrating tool *\n    if(any(lessThan(abs(fragCoord-R.xy/2.),vec2(1))))\n        color = WHITE;\n    /**/\n    \n    if(INVERT_COLORS)\n    \tcolor = 1.-color;\n    \n    fragColor = vec4(color,1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n///////////////////////////////////\n// Parameters presets for galaxies :\n#define M51    \t51\n#define M101   \t101\n#define M74_1  \t741\n#define M74_2  \t742\n#define NGC3344\t3344\n#define M83     83\n#define MWay    0\n#define MWay2   1\n\n#define GALAXY M51\n\n/////////\n// M51 //\n/////////\n#if GALAXY==M51\n    // Warp\n    #define BETA_GALAXY 1.38\n    // Rotation\n    #define GAMMA_GALAXY 1.95\n    // Number of spiral arms\n    #define N_GALAXY 2\n    \n    // Position of the center\n\t#define GALAXY_CENTER (vec2(250,185)/vec2(640,360))\n    // Perspective distortion\n\t#define GALAXY_DISTORTION vec2(1.3,1)\n    \n    // Arms direction\n\t#define CLOCKWISE true\n//////////\n// M101 //\n//////////\n#elif GALAXY==M101\n    #define BETA_GALAXY 1.52\n    #define GAMMA_GALAXY 1.54\n    #define N_GALAXY 4\n\n\t#define GALAXY_CENTER (vec2(315,177)/vec2(640,360))\n\t#define GALAXY_DISTORTION vec2(1.4,1)\n\n\t#define CLOCKWISE true\n/////////\n// M74 //\n/////////\n#elif GALAXY==M74_1\n    #define BETA_GALAXY 1.32\n    #define GAMMA_GALAXY 1.63\n    #define N_GALAXY 2\n\n\t#define GALAXY_CENTER (vec2(310,183)/vec2(640,360))\n\t#define GALAXY_DISTORTION vec2(1.6,1)\n\n\t#define CLOCKWISE false\n/////////\n// M74 //\n/////////\n#elif GALAXY==M74_2\n    #define BETA_GALAXY 1.32\n    #define GAMMA_GALAXY 1.97\n    #define N_GALAXY 2\n\n\t#define GALAXY_CENTER (vec2(205,205)/vec2(640,360))\n\t#define GALAXY_DISTORTION vec2(1.6,1)\n\n\t#define CLOCKWISE false\n/////////////\n// NGC3344 //\n/////////////\n#elif GALAXY==NGC3344\n    #define BETA_GALAXY 1.22\n    #define GAMMA_GALAXY 1.59\n    #define N_GALAXY 2\n\n\t#define RMat(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n\n\t#define GALAXY_CENTER (vec2(333,195)/vec2(640,360))\n\t#define GALAXY_DISTORTION vec2(1.5,1)\n\n\t#define CLOCKWISE false\n/////////\n// M83 //\n/////////\n#elif GALAXY==M83\n    #define BETA_GALAXY 1.41\n    #define GAMMA_GALAXY 0.62\n    #define N_GALAXY 2\n\n\t#define GALAXY_CENTER (vec2(310,185)/vec2(640,360))\n\t#define GALAXY_DISTORTION vec2(1.8,1)\n\n\t#define CLOCKWISE false\n///////////////\n// Milky Way //\n///////////////\n#elif GALAXY==MWay\n    #define BETA_GALAXY 1.25\n    #define GAMMA_GALAXY 3.07\n    #define N_GALAXY 2\n\n\t#define GALAXY_CENTER (vec2(320,185)/vec2(640,360))\n\t#define GALAXY_DISTORTION vec2(1.3,1)\n\n\t#define CLOCKWISE false\n///////////////\n// Milky Way //\n///////////////\n#elif GALAXY==MWay2\n    #define BETA_GALAXY 1.25\n    #define GAMMA_GALAXY 3.07\n    #define N_GALAXY 2\n\n\t#define GALAXY_CENTER (vec2(325,173)/vec2(640,360))\n\t#define GALAXY_DISTORTION vec2(.87,.67)\n\n\t#define CLOCKWISE false\n#endif\n\n////////////////////////////////\n// Final parameters\n\n#define MANUAL false\n\n#define BETA (MANUAL ? BETA_FROM_MOUSE : BETA_GALAXY)\n#define GAMMA (MANUAL ? GAMMA_FROM_MOUSE : GAMMA_GALAXY)\n\n////////////////////////////////\n// Debug : Spiral parameters from mouse\n\n#define BETA_FROM_MOUSE exp(POW3(iMouse.y/R.y)+.08)\n#define GAMMA_FROM_MOUSE ((iMouse.x/R.x)*2.*PI)\n\n\n///////////////////////////////////\n// Various utils\n\n#define POW2(A) ((A)*(A))\n#define POW3(A) ((A)*(A)*(A))\n\n#define PI 3.141593\n\n#define BLACK\t\tvec3(0)\n#define WHITE\t\tvec3(1)\n#define GREY(A)\t\tvec3(A)\n#define RED  \t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE \t\tvec3(0,0,1)\n#define TURQUOISE \tvec3(0,1,1)\n#define YELLOW \t\tvec3(1,1,0)\n#define LIGHT_BLUE\tvec3(0,.5,1)\n#define LAGOON\t\tvec3(0,1,.5)\n#define ORANGE\t\tvec3(1,.5,0)\n\n#define R iResolution\n\nfloat logBase(float base, float x){\n    return log(x)/log(base);\n}\n\nvec2 polToCart(float rho, float theta){\n    return rho*vec2(cos(theta),sin(theta));\n}\n\n// Periodic function __|__|__|__|__\n// s : dirac compression\nfloat periodicDirac(float x, float period, float s){\n\treturn pow(abs(cos(x*(PI/period))),s);\n}\n\n// Distance between a point p and a segment [p1,p2]\nfloat distPointToSegment(vec2 p, vec2 p1, vec2 p2){\n    float l = length(p2-p1);\n    if(l==0.)\n        return length(p-p1);\n    else{\n        // Segment unitary vector\n        vec2 v = (p2-p1)/l;\n        // Compute the projection of pos on the segment (clamped at segment edges)\n        vec2 proj = p1 + v*clamp(dot(p-p1,v),0.,l);\n        return length(p-proj);\n    }\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\n////////////////////// Font printing lib //////////////////////\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\n\nconst int\t_=32,\n\t\t\t_MINUS=45,\t\t// -\n\t\t\t_DOT=46,\t\t// .\n\t\t\t_0=48,\n    \t\t_EQ=61,\t\t\t// =\n\t\t\t_A=65,\t_B=66,\t_C=67,\t_D=68,\t_E=69,\n\t\t\t_F=70,\t_G=71,\t_H=72,\t_I=73,\t_J=74,\n\t\t\t_K=75,\t_L=76,\t_M=77,\t_N=78,\t_O=79,\n\t\t\t_P=80,\t_Q=81,\t_R=82,\t_S=83,\t_T=84,\n\t\t\t_U=85,\t_V=86,\t_W=87,\t_X=88,\t_Y=89,\n\t\t\t_Z=90,\n\t\t\t_a=97,\t_b=98,\t_c=99,\t_d=100,\t_e=101,\n\t\t\t_f=102,\t_g=103,\t_h=104,\t_i=105,\t_j=106,\n\t\t\t_k=107,\t_l=108,\t_m=109,\t_n=110,\t_o=111,\n\t\t\t_p=112,\t_q=113,\t_r=114,\t_s=115,\t_t=116,\n\t\t\t_u=117,\t_v=118,\t_w=119,\t_x=120,\t_y=121,\n\t\t\t_z=122,\n    \t\t_beta=129,\t_gamma=130, _theta=133,\n            _DELTA=145,\n    \t\t_DEG=176;\n\nstruct PrintPosition{\n    vec2 uv,\n         pos;\n    float scale;\n};\n\nstruct PrintStyle{\n    vec3 char_color,\n         outline_color;\n    float outline_size;\n};\n\nPrintStyle NewPrintStyle(vec3 col1, vec3 col2){\n\treturn PrintStyle(col1,col2,.05);\n}\n#define DefaultPrintStyle NewPrintStyle(TURQUOISE,BLACK)\n\n#define getDisplayPos(pos,scale) PrintPosition((fragCoord-pos*R.xy)/(scale*R.x),pos,scale);\n#define nextLine(p)\tp.pos.y -= scale*1.5,\\\n\t\t\t\t\tp = getDisplayPos(p.pos,p.scale);\n\nvoid writeChar(int char, PrintStyle style,\n               float w, float x_offset, // Dimensions of the bbox of the char\n               inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    \t#define getFont(uv,char) texture(font_tex, (uv+vec2(char%16,15-char/16))/16.)\n\t\tvec2 uv = p.uv;\n    \tuv.x += x_offset;\n    \tfloat outline_size = style.outline_size;\n    \tif(uv.x>0. && uv.x<w && uv.y>0. && uv.y<1.){\n            // We are inside the bbox, display the char\n            color = mix(color,style.outline_color,smoothstep(outline_size+.51,outline_size+.48,getFont(uv,char).a));\n            color = mix(color,style.char_color, getFont(uv,char).r);\n        }\n\t\tuv.x -= w; // move uv for next char\n    \tp.uv = uv;\n}\n\nconst float default_ch_w = .8,\n            default_ch_off = .3;\n\nvoid writeStandardChar(int char, PrintStyle style,\n                     inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    writeChar(char,style,\n              default_ch_w,default_ch_off,\n              p,font_tex,color);\n}\n\n#define writeWord(word, style, p, font_tex, color)\\\n\tfor(int i_=0;i_<word.length();i_++)\\\n        writeStandardChar(word[i_],style,p,font_tex,color);\n\n\n\nint powInt(int a, int b){\n    int r = 1;\n    for(int i=0;i++<b;r*=a);\n    return r;\n}\n\nint intLog(int x, int base){\n    if(x<1) return 0;\n    int res = 0;\n    for(;x>=base;res++)\n        x /= base;\n    return res;\n}\n\nvoid writeNumber(float number, int min_int_digits, int dec_digits,\n                 PrintStyle style,\n                 inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n\t\n    if(isnan(number)){\n    \tPrintStyle NaN_style = PrintStyle(BLACK,RED,.05);\n        writeWord(int[](_N,_a,_N),NaN_style,p,font_tex,color);\n    }\n    else if(isinf(number)){\n        PrintStyle Inf_style = PrintStyle(BLACK,LIGHT_BLUE,.05);\n        writeWord(int[](_I,_n,_f),Inf_style,p,font_tex,color);\n    }\n    else{\n        // Display the minus if number is negative\n        if(number<0.)\n            writeStandardChar(_MINUS,style,p,font_tex,color);\n        \n        // Round the number according to the number of decimal digits\n        float decimal_digits_factor = float(powInt(10,dec_digits));\n        int rounded_number = int(round(abs(number)*decimal_digits_factor));\n        \n        int int_part = rounded_number/int(decimal_digits_factor);\n        int int_digits = 1 + intLog(int_part,10);\n        // Fill with zeros to match min digits\n        for(int i=0;i++< min_int_digits - int_digits ;)\n            writeStandardChar(_0,style,\n                              p,font_tex,color);\n        \n        \n        int digits = int_digits+dec_digits;\n        for(int x = powInt(10,digits);digits>0;digits--){\n            if(digits==dec_digits)\n                // Dot\n                writeChar(_DOT,style,\n                      .65,.45,\n                      p,font_tex,color);\n            writeStandardChar(_0+rounded_number/(x/=10),style,\n                              p,font_tex,color);\n            rounded_number%=x;\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define selfChannel iChannel0\n#define keyboardChannel iChannel1\n\n#define keyToggleRaw(K) (texture(keyboardChannel,vec2((.5 + float(K))/256.,0.75)).x > 0.)\n#define keyPressRaw(K) (texelFetch(keyboardChannel, ivec2(K, 0), 0).x > 0.)\n\n/*\n    Utils buffer :\n- o.x is keyToggle\n- o.y is keyPressed\n- o.zw is mouse.xy when F was toggled (for ruler)\n*/\nvoid mainImage( out vec4 o, vec2 fragCoord )\n{\n    float u = fragCoord.x/R.x;\n    bool key_toggled = keyToggleRaw(u*256.);\n    bool key_pressed = keyPressRaw(u*256.);\n    bool f_toggled = keyToggleRaw(_F);\n    o = vec4(key_toggled,\n             key_pressed,\n             f_toggled ? texture(selfChannel,vec2(0)).zw : iMouse.xy/R.y\n            );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*/\n/*\n/*  Spiral mesh display buffer\n/*\n/*/\n\n// Display a spiral centered on (0,0)\nfloat Spiral( vec2 xy, float beta, float gamma, int n)\n{\n    float rho = length(xy),\n          theta = atan(xy.y,xy.x);\n    \n    // Find the parametrization\n    float u = (logBase(beta,rho)-(theta+gamma))*float(n)/(2.*PI);\n    return periodicDirac(u,1.,1e3 * rho / sqrt(float(n)));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec3 color = BLACK;\n    \n    // Centered normalized coordinates in [-1,1]\n    vec2 pixel = (2.*fragCoord-R.xy) / R.y;\n    \n    if(CLOCKWISE)\n        pixel.y *= -1.;\n    \n    // Parameters of the spiral\n    float beta=BETA,    // warp\n    \t  gamma=GAMMA;  // rotation\n    int   n=N_GALAXY;   // number of arms\n    \n    ///////////////////////\n    // Parameter for the orthogonal spirals\n    float beta_orth = exp(-1./log(beta));\n    \n    // Number of spirals in the orthogonal mesh\n    int n_orth = int(round(float(n)*1./log(beta)));\n    \n    float a;\n    \n    // White mesh\n    float mesh = Spiral(pixel,beta_orth,0.,n_orth);\n    color = mix(color,WHITE,mesh);\n    \n    a = mesh;\n    \n    // Colored spiral arms\n    vec3[] colors = vec3[](RED,ORANGE,YELLOW,GREEN,TURQUOISE,BLUE);\n    \n    for(int arm=0; arm<n; arm++){\n        float spiral = Spiral(pixel,beta,\n                              gamma+float(arm)/float(n)*2.*PI,\n                              1);\n    \tcolor = mix(color,colors[arm%colors.length()],spiral);\n        a = max(a,spiral);\n    }\n    \n    // Sharpen a and cut the center of the spiral\n    a = POW3(a)*min(length(pixel)*10.,1.);\n    \n    fragColor = vec4(color,a);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}