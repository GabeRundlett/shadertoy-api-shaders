{
    "Shader": {
        "info": {
            "date": "1618081018",
            "description": "Experimenting generating terrain and simple clouds with noise, and some color grading tools.",
            "flags": 0,
            "hasliked": 0,
            "id": "NsS3Dt",
            "likes": 52,
            "name": "Red Landscape",
            "published": 3,
            "tags": [
                "procedural",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "edubart",
            "viewed": 8798
        },
        "renderpass": [
            {
                "code": "/* Generated by Nelua 0.2.0-dev */\n/* Compile command: clang \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/redlandscape.c\" -o \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/redlandscape\" -Wall -fwrapv -g -lm */\n/* Compile hash: 3wm5WeyBu2gJj7S5c3vNMfx1ovQd */\n/* ------------------------------ DECLARATIONS ------------------------------ */\nvec3 vec_tovec3(vec3 a);\nvec3 noise_vec2_xyx(vec2 self);\nvec2 demos_redlandscape_vec4_xy(vec4 self);\nvec2 demos_redlandscape_vec3_xz(vec3 self);\nfloat vec_smootherstep(float edge0, float edge1, float x);\nfloat vec_fastmix(float a, float b, float t);\nvec3 vec_fastmix_1(vec3 a, vec3 b, float t);\nvec2 sincos(float x);\nvec2 demos_redlandscape_vec3_xy(vec3 self);\nvec3 noise_vec3_yzx(vec3 self);\nvec2 noise_vec3_xx(vec3 self);\nvec2 noise_vec3_yz(vec3 self);\nvec2 noise_vec3_zy(vec3 self);\nfloat noise_hash1_2(vec2 v);\nvec2 noise_hash2_1(vec2 v);\nfloat noise_noisemix2(float a, float b, float c, float d, vec2 f);\nfloat noise_noise_white_1(vec2 p);\nfloat noise_noise_value_1(vec2 p);\nfloat noise_noise_gradient_1(vec2 p);\nvec3 colorgrade_colorgrade_tonemap_aces(vec3 col);\nvec3 colorgrade_colorgrade_saturate(vec3 col, float sat);\nvec3 colorgrade_colorgrade_tone_1(vec3 col, vec3 gain, vec3 lift, vec3 invgamma);\nvec3 colorgrade_colorgrade_gamma_correction(vec3 col);\nvec3 colorgrade_colorgrade_vignette(vec3 col, vec2 coord, float strength, float amount);\nvec3 colorgrade_colorgrade_dither(vec3 col, vec2 coord, float amount);\nvec3 camera_camera_perspective(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv);\nfloat demos_redlandscape_fbm_terrain(vec2 p);\nfloat demos_redlandscape_map(vec3 p);\nfloat demos_redlandscape_ray_march(vec3 ro, vec3 rd);\n/* ------------------------------ DEFINITIONS ------------------------------- */\nvec3 vec_tovec3(vec3 a) {\n  return vec3(a.x, a.y, a.z);\n}\nvec3 noise_vec2_xyx(vec2 self) {\n  return vec3(self.x, self.y, self.x);\n}\nvec2 demos_redlandscape_vec4_xy(vec4 self) {\n  return vec2(self.x, self.y);\n}\nvec2 demos_redlandscape_vec3_xz(vec3 self) {\n  return vec2(self.x, self.z);\n}\nfloat vec_smootherstep(float edge0, float edge1, float x) {\n  float t = clamp(((x - edge0) / (edge1 - edge0)), 0.0, 1.0);\n  return (((t * t) * t) * ((t * ((t * 6.0) - 15.0)) + 10.0));\n}\nfloat vec_fastmix(float a, float b, float t) {\n  return (a + ((b - a) * t));\n}\nvec3 vec_fastmix_1(vec3 a, vec3 b, float t) {\n  return (a + ((b - a) * t));\n}\nvec2 sincos(float x) {\n  return vec2(sin(x), cos(x));\n}\nvec2 demos_redlandscape_vec3_xy(vec3 self) {\n  return vec2(self.x, self.y);\n}\nvec3 noise_vec3_yzx(vec3 self) {\n  return vec3(self.y, self.z, self.x);\n}\nvec2 noise_vec3_xx(vec3 self) {\n  return vec2(self.x, self.x);\n}\nvec2 noise_vec3_yz(vec3 self) {\n  return vec2(self.y, self.z);\n}\nvec2 noise_vec3_zy(vec3 self) {\n  return vec2(self.z, self.y);\n}\nfloat noise_hash1_2(vec2 v) {\n  vec3 v3 = noise_vec2_xyx(v);\n  v3 = fract((v3 * 0.1031));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((v3.x + v3.y) * v3.z));\n}\nvec2 noise_hash2_1(vec2 v) {\n  vec3 v3 = noise_vec2_xyx(v);\n  v3 = (v3 * vec3(0.1031, 0.103, 0.0973));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((noise_vec3_xx(v3) + noise_vec3_yz(v3)) * noise_vec3_zy(v3)));\n}\nfloat noise_noisemix2(float a, float b, float c, float d, vec2 f) {\n  vec2 u = ((f * f) * (3.0 - (2.0 * f)));\n  return vec_fastmix(vec_fastmix(a, b, u.x), vec_fastmix(c, d, u.x), u.y);\n}\nfloat noise_noise_white_1(vec2 p) {\n  return noise_hash1_2(p);\n}\nfloat noise_noise_value_1(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 I = floor((i + 1.0));\n  float a = noise_hash1_2(i);\n  float b = noise_hash1_2(vec2(I.x, i.y));\n  float c = noise_hash1_2(vec2(i.x, I.y));\n  float d = noise_hash1_2(I);\n  return noise_noisemix2(a, b, c, d, f);\n}\nfloat noise_noise_gradient_1(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 I = floor((i + 1.0));\n  vec2 F = (f - 1.0);\n  float a = dot((-0.5 + noise_hash2_1(i)), f);\n  float b = dot((-0.5 + noise_hash2_1(vec2(I.x, i.y))), vec2(F.x, f.y));\n  float c = dot((-0.5 + noise_hash2_1(vec2(i.x, I.y))), vec2(f.x, F.y));\n  float d = dot((-0.5 + noise_hash2_1(I)), F);\n  return (0.5 + noise_noisemix2(a, b, c, d, f));\n}\nvec3 colorgrade_colorgrade_tonemap_aces(vec3 col) {\n  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);\n}\nvec3 colorgrade_colorgrade_saturate(vec3 col, float sat) {\n  float grey = dot(col, vec3(0.2125, 0.7154, 0.0721));\n  return (grey + (sat * (col - grey)));\n}\nvec3 colorgrade_colorgrade_tone_1(vec3 col, vec3 gain, vec3 lift, vec3 invgamma) {\n  col = pow(col, vec_tovec3(invgamma));\n  return (((gain - lift) * col) + lift);\n}\nvec3 colorgrade_colorgrade_gamma_correction(vec3 col) {\n  return ((1.12661 * sqrt(col)) - (0.12661 * col));\n}\nvec3 colorgrade_colorgrade_vignette(vec3 col, vec2 coord, float strength, float amount) {\n  return (col * ((1.0 - amount) + (amount * pow(((((16.0 * coord.x) * coord.y) * (1.0 - coord.x)) * (1.0 - coord.y)), strength))));\n}\nvec3 colorgrade_colorgrade_dither(vec3 col, vec2 coord, float amount) {\n  return clamp((col + (noise_noise_white_1(coord) * amount)), 0.0, 1.0);\n}\nvec3 camera_camera_perspective(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n  vec2 sc = sincos(tilt);\n  vec3 vup = vec3(sc.x, sc.y, 0.0);\n  vec3 w = normalize((lookat - lookfrom));\n  vec3 u = normalize(cross(w, vup));\n  vec3 v = cross(u, w);\n  float wf = (1.0 / tan((vfov * 0.00872664626)));\n  return normalize((((uv.x * u) + (uv.y * v)) + (wf * w)));\n}\nfloat demos_redlandscape_fbm_terrain(vec2 p) {\n  float a = 1.0;\n  float t = 0.0;\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  return t;\n}\nfloat demos_redlandscape_map(vec3 p) {\n  vec2 q = demos_redlandscape_vec3_xz(p);\n  float h = (demos_redlandscape_fbm_terrain(q) * 0.5);\n  float d = ((p.y + (h * 0.75)) + 0.0);\n  return (d * 0.5);\n}\nfloat demos_redlandscape_ray_march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for(int i = 1; i <= 256; i = i + 1) {\n    vec3 p = (ro + (t * rd));\n    float d = demos_redlandscape_map(p);\n    if((d < (0.003 * t)) || (t >= 25.0)) {\n      break;\n    }\n    t = (t + d);\n  }\n  return t;\n}\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord) {\n  vec2 res = demos_redlandscape_vec3_xy(iResolution);\n  vec2 mouse = (demos_redlandscape_vec4_xy(iMouse) / res);\n  vec2 uv = (frag_coord / res);\n  vec2 coord = ((2.0 * (frag_coord - (res * 0.5))) / res.y);\n  float z = (iTime * 1.0);\n  vec2 sc = sincos((iTime * 0.5));\n  float y = 0.0;\n  vec3 lookat = vec3((sc.x * 0.5), y, z);\n  vec3 ro = vec3(((-sc.x) * 0.5), y, (z - 2.0));\n  vec3 rd = camera_camera_perspective(ro, lookat, 0.0, 45.0, coord);\n  vec3 col = vec3(0.0, 0.0, 0.0);\n  vec3 sun_dir = normalize(vec3(0.3, 0.07, 1.0));\n  vec3 hor_col = vec3(0.7, 0.05, 0.01);\n  vec3 sun_col = vec3(0.9, 0.8, 0.7);\n  vec3 bou_col = vec3(0.8, 0.3, 0.1);\n  float t = demos_redlandscape_ray_march(ro, rd);\n  vec3 p = (ro + (rd * t));\n  vec3 back_col;\n  {\n    back_col = vec_fastmix_1(hor_col, (hor_col * 0.3), vec_smootherstep(0.0, 0.25, rd.y));\n    back_col = vec_fastmix_1(back_col, bou_col, max((0.1 - rd.y), 0.0));\n    float sun_lightness = max(dot(rd, sun_dir), 0.0);\n    back_col = (back_col + (sun_col * pow(sun_lightness, 2000.0)));\n    back_col = (back_col + ((0.3 * sun_col) * pow(sun_lightness, 100.0)));\n    back_col = (back_col + (vec3(0.3, 0.2, 0.1) * pow(sun_lightness, 4.0)));\n  }\n  if(abs(coord.y) > 0.75) {\n    col = vec3(0.0, 0.0, 0.0);\n  } else if(t < 25.0) {\n    float decay = (1.0 - exp((-0.12 * t)));\n    col = mix(col, back_col, decay);\n  } else {\n    col = back_col;\n    float clouds_altitude = 1000.0;\n    float clouds_dist = ((1.0 - (ro.y / clouds_altitude)) / rd.y);\n    if(clouds_dist > 0.0) {\n      float clouds_zoom = 1.0;\n      vec2 clouds_pos = (demos_redlandscape_vec3_xz(ro) + ((demos_redlandscape_vec3_xz(rd) * clouds_dist) * clouds_zoom));\n      float clouds_lightness = max((noise_noise_gradient_1(clouds_pos) - 0.3), 0.0);\n      float clouds_decay = vec_smootherstep(0.0, 0.3, rd.y);\n      vec3 clouds_col = (2.0 * col);\n      col = vec_fastmix_1(col, clouds_col, (clouds_lightness * clouds_decay));\n    }\n    col = clamp(col, 0.0, 1.0);\n  }\n  col = colorgrade_colorgrade_tonemap_aces(col);\n  col = colorgrade_colorgrade_gamma_correction(col);\n  col = colorgrade_colorgrade_tone_1(col, vec3(1.3, 0.9, 0.7), (vec3(0.5, 0.1, 0.1) * 0.1), vec3(3.0, 2.0, 1.2));\n  col = colorgrade_colorgrade_saturate(col, 0.7);\n  col = colorgrade_colorgrade_vignette(col, uv, 0.25, 0.7);\n  col = colorgrade_colorgrade_dither(col, frag_coord, 0.01);\n  frag_col = vec4(col.x, col.y, col.z, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}