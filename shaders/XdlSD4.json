{
    "Shader": {
        "info": {
            "date": "1401530999",
            "description": "mandelbox, see http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/",
            "flags": 0,
            "hasliked": 0,
            "id": "XdlSD4",
            "likes": 39,
            "name": "mandelbox_ryu",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbox"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 2478
        },
        "renderpass": [
            {
                "code": "\nfloat stime, ctime, time;\nvoid ry(inout vec3 p, float a){  \n\tfloat c,s;vec3 q=p;  \n\tc = cos(a); s = sin(a);  \n\tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n}  \n\nfloat fixed_radius2 = 1.9;\nfloat min_radius2 = 0.1;\nfloat folding_limit = 1.0;\nfloat scale = -2.8;\nvec3 mtl = vec3(1.0, 1.3, 1.23)*0.8;\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    }else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    for(int n = 0; n < 15; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;\n\t\t//scale = -2.8 - 0.2 * stime;\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\nfloat f(vec3 p){ \n\try(p, stime);\n    return mb(p); \n} \n\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t); \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n} \n\n\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float res;\n    float t = 0.01;\n    for(int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = f(p);\n        if(res < 0.001 * t || res > 20.)\n            break;\n        t += res;\n    }\n    \n    if(res > 20.) t = -1.;\n    return t;\n}\n\n\nvec3 lighting(vec3 p,vec3 rd, float ps) {\n\t\n\tvec3 l1_dir = normalize(vec3(0.8, 0.8, 0.4)); \n    vec3 l1_col = 0.3*vec3(1.5, 1.69, 0.79);\n\tvec3 l2_dir = normalize(vec3(-0.8, 0.5, 0.3));\n    vec3 l2_col = vec3(0.89, 0.99, 1.3); \n    \n    vec3 e=vec3(0.5 * ps,0.0,0.0); \n \tvec3 n = normalize(vec3(f(p+e.xyy)-f(p-e.xyy), \n \t\t\t\t\t\t  f(p+e.yxy)-f(p-e.yxy), \n \t\t\t\t\t\t  f(p+e.yyx)-f(p-e.yyx)));\n\t\n\tfloat shadow = softshadow(p, l1_dir, 10.0 );\n\n    float dif1 = max(0.0, dot(n, l1_dir));\n\tfloat dif2 = max(0.0, dot(n, l2_dir));\n\tfloat bac1 = max(0.3 + 0.7 * dot(vec3(-l1_dir.x, -1.0, -l1_dir.z), n), 0.0);\n\tfloat bac2 = max(0.2 + 0.8 * dot(vec3(-l2_dir.x, -1.0, -l2_dir.z), n), 0.0);\n    float spe = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n    vec3 col = 5.5 * l1_col * dif1 * shadow;\n\tcol += 1.1 * l2_col * dif2;\n\tcol += 0.3 * bac1 * l1_col;\n\tcol += 0.3 * bac2 * l2_col; \n    col += 1.0 * spe; \n\t\n    float t=mod(p.y+0.1*texture(iChannel0,p.xz).x-time*150.0, 5.0);\n    col = mix(col, vec3(6.0, 6.0, 8.0), \n              pow(smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t), 15.0));;\n\treturn col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n\t // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\treturn col;\n}\n\n\nvec3 get_background_color(vec2 uv, vec3 ro, vec3 rd) {\n\tvec3 bg = vec3(1.0); \n\treturn bg;\n}\nvec3 camera(float t){\n\tvec3 p=vec3(3.0*stime,2.0*ctime,5.0+1.0*stime);\n    return p;\n} \n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\t// camera\n \tstime=sin(iTime*0.1); \n \tctime=cos(iTime*0.1); \n    time=iTime*0.01;\n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\t//vec3 ro = vec3(0.0, 2.0, 5.9);\n    vec3 ro=camera(time);\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    \n\tvec3 bg = get_background_color(uv, ro, rd); \n    vec3 col = bg;\n\n    vec3 p=ro; \n\t \n\tfloat t = intersect(ro, rd);\n\tif(t > -0.5){\n\t\tp = ro + t * rd;\n        col = lighting(p, rd, 0.004)*mtl*0.2; \n        col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n    } \n\n   \tcol=post(col, q);\n \tfragColor=vec4(col.x,col.y,col.z,1.0); \n }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}