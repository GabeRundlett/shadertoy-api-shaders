{
    "Shader": {
        "info": {
            "date": "1708032431",
            "description": "My old shader, simplified",
            "flags": 0,
            "hasliked": 0,
            "id": "M3fGDl",
            "likes": 63,
            "name": "Water subsurface scattering",
            "published": 3,
            "tags": [
                "water",
                "ocean",
                "scattering",
                "subsurface"
            ],
            "usePreview": 0,
            "username": "afl_ext",
            "viewed": 962
        },
        "renderpass": [
            {
                "code": "// afl_ext 2024\n// This shader is 100% public domain (uses glsl-atmosphere, which is also public domain)\n\n// For explanation about the wave function see my other shader here: https://www.shadertoy.com/view/MdXyzX\n \n#define time iTime\n#define resolution iResolution.xy\n\n#define DRAG_MULT 0.058\n#define ITERATIONS_RAYMARCH 24\n#define ITERATIONS_NORMAL 37\n#define WATER_DEPTH 2.1\n\n// returns vec2 with wave height in X and its derivative in Y\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations){\n    position *= 0.1;\n\tposition += time * 0.1;\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, iTime);\n        position += p * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return (w / ws);\n}\n\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n    vec3 pos = start;\n    float h = 0.0;\n    float hupper = depth;\n    float hlower = 0.0;\n    vec2 zer = vec2(0.0);\n    vec3 dir = normalize(end - start);\n    for(int i=0;i<318;i++){\n        h = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;\n        if(h + 0.001 > pos.y) {\n            return distance(pos, camera);\n        }\n        pos += dir * (pos.y - h);\n    }\n    return -1.0;\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth){\n    vec2 ex = vec2(e, 0);\n    H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;\n    vec3 a = vec3(pos.x, H, pos.y);\n    return normalize(cross((a-vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y)), \n                           (a-vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e))));\n}\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nvec3 getRay(vec2 uv){\n   uv = (uv * 2.0 - 1.0)* vec2(resolution.x / resolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\t\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.1415/2.0) * rotmat(vec3(1.0, 0.0, 0.0), -0.2) * proj;\n    return ray;\n}\n\nfloat rand2sTime(vec2 co){\n    co *= time;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n#define PI 3.141592\n#define iSteps 16\n#define jSteps 8\n\nvec2 rsi(vec3 r0, vec3 rd, float sr) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, r0);\n    float c = dot(r0, r0) - (sr * sr);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n#define MieScattCoeff 2.0\n\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\n\nfloat planetradius = 6378000.1;\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat rsi2(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    return mix(ex.y, ex.x, step(0.0, ex.x));\n}\nvec3 atmosphere(vec3 r, vec3 r0, vec3 pSun, float iSun, float rPlanet, float rAtmos, vec3 kRlh, float kMie, float shRlh, float shMie, float g) {\n    // Normalize the sun and view directions.\n    pSun = normalize(pSun);\n    r = normalize(r);\n    r.y = max(0.08, r.y);\n\n    // Calculate the step size of the primary ray.\n    vec2 p = rsi(r0, r, rAtmos);\n    if (p.x > p.y) return vec3(0,0,0);\n    p.y = min(p.y, rsi(r0, r, rPlanet).x);\n    float iStepSize = (p.y - p.x) / float(iSteps);\n\tfloat rs = rsi2(Ray(r0, r), Sphere(vec3(0), rAtmos));\n\tvec3 px = r0 + r * rs;\n//shMie *= ( (pow(fbmHI(px  ) * (supernoise3dX(px* 0.00000669 + time * 0.001)*0.5 + 0.5) * 1.3, 3.0) * 0.8 + 0.5));\n    \n    // Initialize the primary ray time.\n    float iTime = 0.0;\n\n    // Initialize accumulators for Rayleigh and Mie scattering.\n    vec3 totalRlh = vec3(0,0,0);\n    vec3 totalMie = vec3(0,0,0);\n\n    // Initialize optical depth accumulators for the primary ray.\n    float iOdRlh = 0.0;\n    float iOdMie = 0.0;\n\n    // Calculate the Rayleigh and Mie phases.\n    float mu = dot(r, pSun);\n    float mumu = mu * mu;\n    float gg = g * g;\n    float pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);\n    float pMie = 3.0 / (8.0 * PI) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));\n\n    // Sample the primary ray.\n    for (int i = 0; i < iSteps; i++) {\n\n        // Calculate the primary ray sample position.\n        vec3 iPos = r0 + r * (iTime + iStepSize * 0.5);\n\n        // Calculate the height of the sample.\n        float iHeight = length(iPos) - rPlanet;\n\n        // Calculate the optical depth of the Rayleigh and Mie scattering for this step.\n        float odStepRlh = exp(-iHeight / shRlh) * iStepSize;\n        float odStepMie = exp(-iHeight / shMie) * iStepSize;\n\n        // Accumulate optical depth.\n        iOdRlh += odStepRlh;\n        iOdMie += odStepMie;\n\n        // Calculate the step size of the secondary ray.\n        float jStepSize = rsi(iPos, pSun, rAtmos).y / float(jSteps);\n\n        // Initialize the secondary ray time.\n        float jTime = 0.0;\n\n        // Initialize optical depth accumulators for the secondary ray.\n        float jOdRlh = 0.0;\n        float jOdMie = 0.0;\n\n        // Sample the secondary ray.\n        for (int j = 0; j < jSteps; j++) {\n\n            // Calculate the secondary ray sample position.\n            vec3 jPos = iPos + pSun * (jTime + jStepSize * 0.5);\n\n            // Calculate the height of the sample.\n            float jHeight = length(jPos) - rPlanet;\n\n            // Accumulate the optical depth.\n            jOdRlh += exp(-jHeight / shRlh) * jStepSize;\n            jOdMie += exp(-jHeight / shMie) * jStepSize;\n\n            // Increment the secondary ray time.\n            jTime += jStepSize;\n        }\n\n        // Calculate attenuation.\n        vec3 attn = exp(-(kMie * (iOdMie + jOdMie) + kRlh * (iOdRlh + jOdRlh)));\n\n        // Accumulate scattering.\n        totalRlh += odStepRlh * attn;\n        totalMie += odStepMie * attn;\n\n        // Increment the primary ray time.\n        iTime += iStepSize;\n\n    }\n\n    // Calculate and return the final color.\n    return iSun * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie);\n}\nvec3 sd = normalize(vec3(1.0, 0.05, 0.0)); \nvec3 getatm(vec3 ray){\n    vec3 color = atmosphere(\n        ray,           // normalized ray direction\n        vec3(0,6372e3,0),               // ray origin\n        sd,                        // position of the sun\n        22.0,                           // intensity of the sun\n        6371e3,                         // radius of the planet in meters\n        6471e3,                         // radius of the atmosphere in meters\n        vec3(5.5e-6, 13.0e-6, 22.4e-6), // Rayleigh scattering coefficient\n        21e-6,                          // Mie scattering coefficient\n        8e3,                            // Rayleigh scale height\n        1.2e3 * MieScattCoeff,                          // Mie scale height\n        0.758                           // Mie preferred scattering direction\n    );\t\t\n \treturn color;\n    \n}\n\nfloat sun(vec3 ray){\n\n    return pow(max(0.0, dot(ray, sd)), 1228.0) * 110.0;\n}\nfloat smart_inverse_dot(float dt, float coeff){\n    return 1.0 - (1.0 / (1.0 + dt * coeff));\n}\n#define VECTOR_UP vec3(0.0,1.0,0.0)\nvec3 getSunColorDirectly(float roughness){\n    vec3 sunBase = vec3(15.0);\n\n    float dt = max(0.0, (dot(sd, VECTOR_UP)));\n    float dtx = smoothstep(-0.0, 0.1, dt);\n    float dt2 = 0.9 + 0.1 * (1.0 - dt);\n    float st = max(0.0, 1.0 - smart_inverse_dot(dt, 11.0));\n    vec3 supersundir = max(vec3(0.0),   vec3(1.0) - st * 4.0 * pow(vec3(50.0/255.0, 111.0/255.0, 153.0/255.0), vec3(2.4)));\n//    supersundir /= length(supersundir) * 1.0 + 1.0;\n    return supersundir * 4.0 ;\n    //return mix(supersundir * 1.0, sunBase, st);\n    //return  max(vec3(0.3, 0.3, 0.0), (  sunBase - vec3(5.5, 18.0, 20.4) *  pow(1.0 - dt, 8.0)));\n}\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / resolution.xy;\n\tfloat waterdepth = 2.1;\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\n\tvec3 ray = getRay(uv);\n\t\n\tfloat spherehit = rsi2(Ray(orig, ray), Sphere(vec3(-2.0, 3.0, 0.0), 1.0));\n\tfloat fff = 1.0;\n\t\n\t\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n    \n    vec3 rrayX = vec3(ray.x, ray.y, ray.z);\n    vec3 atmX = getatm(rrayX);\n    vec3 SKY = atmX * 2.0 + sun(rrayX);\n    if(ray.y >= 0.0){\n        \n     \tfragColor = vec4(aces_tonemap(SKY),1.0);   \n        return;\n    }\n    vec3 fullcolor = vec3(0.0);\n    vec2 pixel = 1.0 / iResolution.xy;\n    ray = getRay(uv);\n\n\n    fff = 1.0;\n\n\n    hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n\n    float lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n    float dist = raymarchwater(orig, hipos, lopos, waterdepth);\n    vec3 pos = orig + ray * dist;\n\n    vec3 N = normal(pos.xz, 0.01, waterdepth);\n    N = mix(N, VECTOR_UP, 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));\n    vec2 velocity = N.xz * (1.0 - N.y);\n    vec3 R = normalize(reflect(ray, N));\n    vec3 RF = normalize(refract(ray, N, 0.66)); \n    R.y = abs(R.y);\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\n    vec3 atm = getatm(R);\n    vec3 reflection = atm + sun(R);\n\n    vec3 C = fresnel * (reflection) * 2.0;\n\n    float superscat = pow(max(0.0, dot(RF, sd)), 16.0) ;\n    C += vec3(0.5,0.9,0.8) * superscat * getSunColorDirectly(0.0) * 81.0* (1.0 - 1.0 / (1.0 + 5.0 * max(0.0, dot(sd, VECTOR_UP))));\n    vec3 waterSSScolor =  vec3(0.01, 0.33, 0.55)*  0.171 ;\n    C += waterSSScolor * getSunColorDirectly(0.0) * (0.3 + getwaves(pos.xz, ITERATIONS_RAYMARCH)) * waterdepth * 0.3 * max(0.0, dot(sd, VECTOR_UP));\n    //tonemapping\n    \n    C *= fff * 0.5;\n    C = mix(SKY, C, max(0.0, 1.0 - (1.0 / (abs(ray.y) * 200.0))));\n    C = aces_tonemap(C);\n    //fullcolor += C;\n    \n\tfragColor = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}