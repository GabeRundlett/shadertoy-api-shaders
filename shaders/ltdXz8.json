{
    "Shader": {
        "info": {
            "date": "1532713935",
            "description": "Mandelbulb order 8",
            "flags": 32,
            "hasliked": 0,
            "id": "ltdXz8",
            "likes": 10,
            "name": "Mandelbulb order 8",
            "published": 3,
            "tags": [
                "mandelbulb",
                "mandelbulb"
            ],
            "usePreview": 0,
            "username": "Mrfixit13",
            "viewed": 759
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t \n    vec2 uv = (fragCoord.xy / iResolution.xy);\n      \n\tfragColor = texture(iChannel0,uv);\n }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\n\nfloat prec = 2.0/4096.0;\n\nfloat cons = 1.0;\nfloat lin = 0.14;\nfloat quad = 0.07;\n\nfloat fogAmount = 100.0;\n    \nvec3 W = vec3(11.2);\n\nvec3 lp = vec3(0.0,0.0,1.0);\nvec3 lc = vec3(1.0,0.9,0.8)*24.0;\nvec3 bg = vec3(0.5,0.8,1.0)*0.5;\n\nvec2 mouse;\n\nstruct mat{\nvec3 col;\nvec3 rcol;\nfloat frc;\nfloat frm; \n};\n\nmat getMat(float n)\n{\n  \tmat m;   \n    \n    m.col = vec3(0.8);\n    m.rcol= vec3(0.0);\n    m.frm = 0.5;\n    m.frc = 0.05*m.frm;\n    \n    m.col = vec3(0.9,0.9,0.9)*(0.5*n+0.5);\n\n    return m;\n}\n\n\nvec3 uncharted2ToneMapping(vec3 x)\n{\t\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec2 calcMadelbrot(vec3 p0){\n    \n    float n = 8.0;    \n    float t0 = 1.0;\n    float dr = 1.0;\n        \n    float r,phi,theta,l;\n    \n    vec3 z = p0+vec3(0.0);\n    \n    for(int i = 0; i < 8;i++)\n    {    \t    \n        r = length(z);\n           \n        if(r > 2.0)continue; \n          \t\t\n    \tphi = atan(z.y/z.x);\n    \ttheta = asin(z.z/r);\n           \n        dr = pow(r,n-1.0)*dr *n +1.0;\n    \t\n    \tz = pow(r,n)*vec3(sin(n*theta)*cos(n*phi),sin(n*theta)*sin(n*phi),cos(n*theta))+p0;\n        t0=min(r,t0);\n    }        \n    return vec2(r*log(r)/dr/2.0,t0);        \n   \n}\n\nvec2 comp(vec2 a,vec2 b){\n    \n    return (a.x < b.x) ? a : b;\n}\n\n/*vec2 comp(vec2 a,vec2 b){\n    \n    return vec2(smin(a.x , b.x,32.0),(a.x < b.x) ? a.y : b.y);\n}*/\n\nvec2 map(vec3 rp)\n{ \n    return vec2(calcMadelbrot(rp-vec3(0,0,0.0)));\n}\n\n\nfloat calcShadow(vec3 sp,float imax){\n   \tvec3 dp = normalize(lp-sp);\n    float i2 = 0.1;\n    \n    for(int n =0; n < 100;n++)\n    {      \n        i2 += max(abs(map(sp+dp*i2).x/1.0) , prec);\n        \n        if(map(sp+dp*i2).x < prec)\n        {\n                \n            return 0.0;         \n        }\n        else if( i2 > imax) return 1.0;\n            \n    }  \n    return 1.0;\n}\n\n\nvec3 castRay(vec3 ro , vec3 rd,float imax)\n{    \n    float i = prec;\n    vec2 dat;\n    \n    for(int n = 0; n < 200; n++)\n    {       \n        dat.xy = map(ro+rd*i);\n        \n        if(dat.x < prec)return vec3(dat,i);\n        \n        if(i > imax)return vec3(dat.x,-0.1,-0.1);\n        i+=max(abs(dat.x),prec);\n    } \n    return vec3(dat.x,-1.0,-1.0);\n}\n\n//from iq's raytracer \nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.1, 1.0 );    \n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 off = vec2(prec,0.0);\n    \n   \tvec3 normal = normalize(vec3(\n    map(pos+off.xyy).x - map(pos-off.xyy).x,\n    map(pos+off.yxy).x - map(pos-off.yxy).x,\n    map(pos+off.yyx).x - map(pos-off.yyx).x )); \n    \n    return normal;\n}\n\nvec3 render(vec3 ro,vec3 rd)\n{\n    vec3 pos = vec3(0,0,0),normal = vec3(0.0,0.0,0.0),color = vec3(0.0,0.0,0.0),ref = vec3(1.0);;\n    mat mate; \n   \t\n\n    float dist = 0.0;\n\n    \n\tfor(int j = 1; j<=1; j++)\n    {\n     \tvec3 dat = castRay(ro,rd,15.0/float(j));\n     \tvec3 pos = ro+rd*dat.z;\n \t\n     \tif( dat.x < 0.001)\n        {\n            \n            dist+=length(ro-pos);\n            float dist1 = dist+length(lp-pos);\n           \tfloat atten = 1.0/(cons + lin*dist1 + quad * (dist1 * dist1));\n       \n     \t    mate = getMat(dat.y);\n            vec3 c = pow(mate.col,vec3(2.2));   \n     \t    vec3 rc = pow(mate.rcol,vec3(2.2));\n            \n     \t    normal = calcNormal(pos);\n     \t    vec3 ld = normalize(lp-pos);\n            \n     \t    float fren = pow(1.0 - max(dot(-rd,normal),0.0),5.0);\n     \t    fren = mix(mate.frc,mate.frm,fren);\n            \n     \t    vec3 lit = (clamp(dot(ld,normal),0.0,1.0))*lc/12.0;\n            lit*=calcShadow(pos,15.0/float(j));\n            \n     \t    vec3 dif = lit;\n            vec3 amb = bg/6.28*calcAO(pos,normal);\n            \n            \n            dif*=atten;\n            \n     \t    color+= (dif + amb)*c*ref;\n            \n     \t    ref*=fren*rc;          \n            \n     \t    ro=pos;\n     \t\trd=reflect(rd,normal);\n     \t}  \t  \t\n    }\n   \tdist+=length(ro-pos);\n \tcolor+=ref*bg;\n   \treturn color;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (vec2(-1.0)+2.0*(fragCoord.xy / iResolution.xy)) * vec2(iResolution.x/iResolution.y,1.0);\n      \n    mouse = (iMouse.xy/iResolution.xy*2.0-vec2(1.0))*vec2(iResolution.x/iResolution.y,1.0)*2.0;\n    mouse.y = max(mouse.y,0.5);\n\n    \n    mat3 rot = mat3(vec3(sin(mouse.x+3.14159/2.0),0,sin(mouse.x)),\n                    vec3(0,1,0),\n                    vec3(sin(mouse.x+3.14159),0,sin(mouse.x+3.14159/2.0)));\n    \n    lp=rot*vec3(0.0,5.0,5.0);\n    \n    vec3 or = vec3(-sin(mouse.x),0.0,sin(mouse.x+3.14159/2.0))*3.0;\n    \n    vec3 color = vec3(0.0);\n    \n   \n    for(float i = -0.5;i< 0.6;i+=1.0)\n        for(float j = -0.5;j<0.6;j+=1.0)\n        {\n    \t\tvec3 ro = rot*vec3(0.0,0.0,0.0)+or;\n    \t\tvec3 rd = rot*normalize(vec3(uv+vec2(i,j)*0.5/iResolution.xy,-2.5));\n    \t\tcolor+= render(ro,rd);\n        }\n\t\t\n    \n    vec3 ro = rot*vec3(0.0,0.0,0.0)+or;\n   \tvec3 rd = rot*normalize(vec3(uv,-2.5));\n    color+= render(ro,rd);\n\n    vec3 curr = uncharted2ToneMapping(color.xyz*10.0);\n\tvec3 whiteScale = 1.0/uncharted2ToneMapping(W); \n\tvec3 mapped = curr*whiteScale;\n\t\n\tmapped = pow(color, vec3(1.0 / 2.2));\n\t\n\tfragColor =  vec4(mapped,1.0) ;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}