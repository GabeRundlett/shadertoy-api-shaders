{
    "Shader": {
        "info": {
            "date": "1480370870",
            "description": "tinkering some noise that might work for clouds etc.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltdXRS",
            "likes": 73,
            "name": "CloudyNoise",
            "published": 3,
            "tags": [
                "noise",
                "clouds"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 3772
        },
        "renderpass": [
            {
                "code": "/**\n Trying to whip up some noise that might work on clouds and such. \n Well I guess almost any noise works with clouds. But still :)\n*/\n\nfloat cloudyNoise(vec2 uv)\n{\n    float sx = cos(500. * uv.x);\n    float sy = sin(500. * uv.y);\n    sx = mix(sx, cos(uv.y * 1000.), .5);\n    sy = mix(sy, sin(uv.x * 1000.), .5);\n    \n    vec2 b = (vec2(sx, sy));\n    vec2 bn = normalize(b);\n\n    vec2 _b = b;\n\tb.x = _b.x * bn.x - _b.y * bn.y;\n    b.y = _b.x * bn.y + _b.y * bn.x; \n    vec2 l = uv - vec2(sin(b.x), cos(b.y));\n    return length(l - b) - 0.5;\n}\n\nfloat cloudyFbm(vec2 uv)\n{\n    float f = 0.0;\n    vec2 _uv = uv;\n    vec2 rotator = (vec2(.91, 1.5));\n    \n    for (int i = 0; i < 5; ++i)\n    {\n        vec2 tmp = uv;\n        uv.x = tmp.x * rotator.x - tmp.y * rotator.y; \n        uv.y = tmp.x * rotator.y + tmp.y * rotator.x; \n        f += .5 * cloudyNoise(uv) * pow(0.5, float(i + 1));\n    }\n    return f;\n}\n\nfloat clouds (vec2 uv)\n{\n    float T = iTime * .001;\n\n\tfloat x = 0.0;\n    x += cloudyFbm( 0.5 * uv + vec2(.1,  -.01) * T) * 0.5;\n    x += cloudyFbm( 1.0 * uv + vec2(.12,  .03) * T) * 0.5 * 0.5;\n \tx += cloudyFbm( 2.0 * uv + vec2(.15, -.02) * T) * 0.5 * 0.5 * 0.5;\n \tx += cloudyFbm( 4.0 * uv + vec2(.2,   .01) * T) * 0.5 * 0.5 * 0.5 * 0.5;\n \tx += cloudyFbm( 8.0 * uv + vec2(.15, -.01) * T) * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n\t\n    x = smoothstep(0.0, .6, x);\n    float f = 0.6;\n\tx = (x - f) / (1.0 - f);\n    float _x = x;    \n    x = smoothstep(0.4, 0.55, x);\n\treturn x * _x;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ouv = uv;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    vec2 _uv = uv * 0.007;\n    \n    // clouds \n\tfloat x = clouds(_uv);\n    // sky colors\n    vec4 top = vec4(0.1, 0.45, 0.9, 0.0) * .6;\n    vec4 bottom = vec4(0., 0.45, .7, 0.0) * 1.2;\n    fragColor = mix(bottom, top, smoothstep(0., .7, ouv.y));\n    \n    // clouds color\n    fragColor += x;\n    fragColor = mix(vec4(x), fragColor, 1. - x);\n\t\n    // some fake lighting\n    vec2 ld = .005 * normalize(vec2(1.0, 1.)) * fwidth(uv);\n    float f = .0;\n    const int steps = 4;\n    for (int i = 1; i <= steps; ++i)\n    {\n    \tfloat c = clouds(_uv - float(i * i) * ld) * pow(0.55, float(i));\n        f += max(c, 0.0);\n    }\n    f = clamp(f, 0.0, 1.0);\n    f = 1.0 - f;\n    f = pow(f, 1.2);\n    fragColor += vec4(f) * x * .5;   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}