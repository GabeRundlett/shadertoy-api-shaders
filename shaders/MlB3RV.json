{
    "Shader": {
        "info": {
            "date": "1430344705",
            "description": "Continuing with same algo as \"Psyche Nimix II\" but this time to produce tiles of wood marquetry. There is 20 differents patterns generated (not equally nice though :) )\nUpdated: Add Lighting and bumpmap",
            "flags": 0,
            "hasliked": 0,
            "id": "MlB3RV",
            "likes": 7,
            "name": "Marquetry",
            "published": 3,
            "tags": [
                "2d",
                "cheap",
                "bump",
                "wood",
                "tile"
            ],
            "usePreview": 0,
            "username": "xbe",
            "viewed": 1941
        },
        "renderpass": [
            {
                "code": "// Xavier Benech\n// Marquetry\n//\n// Updated with bumpmap and lighting\n//\n// Adapted bump map from: \"Basic Bump Mapping\" by Hamneggs\n// https://www.shadertoy.com/view/ld2GRh\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265\n#define NUM 10.\n\nmat2 rotate(in float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-.5);\n}\n\nvec2 tri2(in vec2 p)\n{\n    return vec2(tri(p.x+tri(p.y*2.)),tri(p.y+tri(p.x*2.)));\n}\n\nmat2 trinoisemat = mat2( 0.970,  0.242, -0.242,  0.970 );\n\nfloat triangleNoise(in vec2 p)\n{\n    float z=1.5;\n    float z2=1.5;\n\tfloat rz = 0.;\n    vec2 bp = 2.*p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec2 dg = tri2(bp*2.)*.8;\n        dg *= rotate(0.314);\n        p += dg/z2;\n\n        bp *= 1.6;\n        z2 *= .6;\n\t\tz *= 1.8;\n\t\tp *= 1.2;\n        p*= trinoisemat;\n        \n        rz+= (tri(p.x+tri(p.y)))/z;\n\t}\n\treturn rz;\n}\n\nfloat arc(in vec2 plr, in float radius, in float thickness, in float la, in float ha, float delta)\n{\n    // clamp arc start/end\n    float res = step(la, plr.y) * step(plr.y, ha);\n    // smooth outside\n    res *= smoothstep(plr.x, plr.x+delta,radius+thickness);\n    // smooth inside\n    float f = radius - thickness;\n    res *= smoothstep( f, f+delta, plr.x);\n    // smooth start\n    res *= smoothstep( la, la+delta, plr.y);\n    // smooth end\n    res *= 1. - smoothstep( ha-delta, ha, plr.y);\n    return res;\n}\n\nvec3 marquetry(vec2 uv, float delta)\n{\n    vec2 p = uv;\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p = 2.*abs(fract(p)-0.5);\n    \n    float k = clamp(fract(iTime/(10.*PI)), 0.,1.);    \n    float sum = 0.;\n    float s = 1./10.;\n    float ss = s;\n    for (int i=0; i<10; i++)\n    {\n        sum += step(k, ss);\n        ss += s;\n    }\n    float k0 = 4.*36.+36.*sum;\n    k = clamp(fract(iTime/(20.*PI)), 0.,1.);\n    float k2 = 1. - 2.*step(k, 0.5);\n    p *= rotate(PI*(k0)/180.);\n    p.y = 2. - ( 0.2 + k2 )*(1.-exp(-abs(p.y)));\n    \n    float lp = length(p);\n    float id = floor(lp*NUM+.5)/NUM;\n    vec4 n = texture( iChannel0, vec2(id, 0.0025*iTime));\n    \n    //polar coords\n    vec2 plr = vec2(lp, atan(p.y, p.x));\n    \n    //Draw concentric arcs\n    float rz = arc(plr, id, 0.425/NUM+delta, 0., PI, delta);\n    \n    float m = rz;\n    rz *= (triangleNoise(p)*0.5+0.5);\n    vec4 nn = texture(iChannel0, vec2(0.123, id));\n\tvec3 col = (texture(iChannel1, uv+nn.xy).rgb*nn.z+0.25) * rz;\n\tcol *= 1.25;\n    col = smoothstep(0., 1., col);\n   \tcol = exp(col) - 1.;\n    col = clamp(col, 0., 1.);\n    \n    return col;\n}\n\n////////////////////////////////////////////////////////////////////////\n// Adapted bump map from: \"Basic Bump Mapping\" by Hamneggs\n// https://www.shadertoy.com/view/ld2GRh\n\n#define diff .001\n#define timeScale 0.5\n#define lightPathRadius 1.25\n#define lightPathCenter vec3(0, 0, 1.725)\n#define lightColor vec3(1.0, 1.0, 1.0)\n#define lightStrength 2.0\n#define specularFactor 8.0\n#define specularRatio 5.0\n#define specularMapRatio 8.0\n\nvec3 genLightCoords()\n{\n\tvec3 lightCoords = vec3(lightPathCenter.x + (sin(iTime*timeScale)*lightPathRadius), \n\t\t\t\tlightPathCenter.y + (cos(iTime*timeScale)*lightPathRadius),\n\t\t\t\tlightPathCenter.z);\n\treturn lightCoords;\n}\n\nvec3 surfaceNormal(vec2 coord, float delta)\n{\n\tfloat diffX = marquetry(vec2(coord.x+diff, coord.y), delta).r - marquetry(vec2(coord.x-diff, coord.y), delta).r;\n\tfloat diffY = marquetry(vec2(coord.x, coord.y+diff), delta).r - marquetry(vec2(coord.x, coord.y-diff), delta).r;\n\tvec2 localDiff = vec2(diffX, diffY);\n\tlocalDiff *= -1.0;\n\tlocalDiff = (localDiff/2.0)+.5;\n\tfloat localDiffMag = length(localDiff);\n\tfloat z = sqrt(max(0.,1.0-pow(localDiffMag, 2.0)));\n\treturn vec3(localDiff, z);\n}\n\nfloat incidenceCosine(vec3 lightIncidence, vec3 normal)\n{\n\tnormal.xy -= .5;\n\tnormal.xy *= 2.0;\n\tnormal = normalize(normal);\n\tlightIncidence = normalize(lightIncidence);\n\treturn dot(lightIncidence, normal);\n}\n\nvec3 lighting(vec2 coord, float delta)\n{\n\tvec3 lightPos = genLightCoords();\n\tfloat cosine = incidenceCosine(lightPos - vec3(coord, 0.), surfaceNormal(coord, delta));\n\t\n\tfloat dist = distance(lightPos, vec3(coord, 0.0));\n\tfloat att = exp(-dist);\n    \n\tvec3 ambient = vec3(0.75);\n\tvec3 diffuse = vec3(1.0);\n\tdiffuse *= att*lightStrength*cosine*lightColor;\n\t\n\tvec3 specular = vec3(1.0);\n\tspecular *= pow(abs(cosine), specularFactor*specularRatio);\n\tspecular *= att*lightStrength*lightColor;\n\tspecular *= specularMapRatio;\n\t\n\treturn ambient+diffuse+specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x/iResolution.y;\n\tfloat delta = 0.005 + 0.0425*(1.-exp(-0.00025*iResolution.x));\n    \n \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = uv*2.-1.;\n\tq.x *= aspect;\n\n    // shutter\n    float k = clamp(exp(1.-abs(sin(iTime)))-exp(0.5), 0., 1.);\n    float shutter = 1.0 - smoothstep( 0., 1., 10.*(k-0.75) );\n    \n    vec3 col = marquetry(q, delta);\n    col *= lighting(q, delta);\n    \n    // Vignetting\n\tvec2 r = -1.0 + 2.0*(uv);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n    \n    col *= shutter;\n\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}