{
    "Shader": {
        "info": {
            "date": "1711996852",
            "description": "I wanted to make a space station that feels big. This is spinning at a rate that would make for 1 G of gravity if the diameter is 8 km. I was trying really hard for cinema-quality.",
            "flags": 16,
            "hasliked": 0,
            "id": "WlKXzm",
            "likes": 282,
            "name": "Orbital Megastructure",
            "published": 3,
            "tags": [
                "earth",
                "space",
                "spacestation"
            ],
            "usePreview": 1,
            "username": "otaviogood",
            "viewed": 17684
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// Space station rotation rate\n#define ROT_SPEED -0.05\n// I approximated this one based on watching videos from the ISS.\n#define EARTH_ROT_SPEED 0.002\nconst float earthRad = 6371.0; // 6371 km\n// Low earth orbit - approximate ISS altitude in km. ISS isn't constant altitude, so...\nconst vec3 earthPos = normalize(vec3(-6500,-6400,-3400)) * (earthRad + 408.0);\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n} \nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n// -------------------------\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir, vec3 sunCol)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    //sunIntensity += exp(-dist*150.0)*7000.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.01;\n}\n\nvec4 tex3d(vec3 pos, vec3 normal)\n{\n\t// loook up texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel2, pos.yz*4.0);\n\tvec4 texY = texture(iChannel2, pos.xz*4.0);\n\tvec4 texZ = texture(iChannel2, pos.xy*4.0);\n\t//vec4 texX = cubicTex(pos.yz);\n\t//vec4 texY = cubicTex(pos.xz);\n\t//vec4 texZ = cubicTex(pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z*normal.z));\n\ttex = mix(tex, texY, abs(normal.y*normal.y));//.zxyw;\n\treturn tex*tex;\n}\nstruct RayHit\n{\n    vec3 normMin, normMax;\n    float tMin, tMax;\n    vec3 hitMin, hitMax;\n};\nconst float bignum = 256.0*256.0*256.0;\nRayHit NewRayHit()\n{\n    RayHit rh;\n    rh.tMin = bignum;\n    rh.tMax = bignum;\n    rh.hitMin = vec3(0.0);\n    rh.hitMax = vec3(0.0);\n    rh.normMin = vec3(0.0);\n    rh.normMax = vec3(0.0);\n    return rh;\n}\n// note: There are faster ways to intersect a sphere.\nRayHit SphereIntersect2(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    RayHit rh = NewRayHit();\n    vec3 delta = spherePos - pos;\n    float projdist = dot(delta, dirVecPLZNormalizeMeFirst);\n    vec3 proj = dirVecPLZNormalizeMeFirst * projdist;\n    vec3 bv = proj - delta;\n    float b = length(bv);\n    if (b > rad) {\n        //rh.tMin = bignum;\n        //rh.tMax = bignum;\n        return rh;\n    }\n    float x = sqrt(rad*rad - b*b);\n    rh.tMin = projdist - x;\n    if (rh.tMin < 0.0) {\n        rh.tMin = bignum;\n        return rh;\n    }\n    rh.tMax = projdist + x;\n    rh.hitMin = pos + dirVecPLZNormalizeMeFirst * rh.tMin;\n    rh.hitMax = pos + dirVecPLZNormalizeMeFirst * rh.tMax;\n    rh.normMin = normalize(rh.hitMin - spherePos);\n    rh.normMax = normalize(spherePos - rh.hitMax);\n    return rh;\n}\n\n// This function renders the earth.\nvec3 GetEnvMapSpace(vec3 camPos, vec3 rayDir, vec3 sunDir, vec3 sunCol, float sunShadow)\n{\n    vec3 finalColor;\n    vec3 atmosphereColor = vec3(70.0, 150.0, 240.0)/400.0;\n    //float hit = SphereIntersect(camPos, normalize(rayVec), earthPos, earthRad);\n    RayHit rh = SphereIntersect2(camPos, normalize(rayDir), earthPos, earthRad);\n    RayHit rh2 = SphereIntersect2(camPos, normalize(rayDir), earthPos, earthRad + 77.0);\n    if (rh.tMin < rh.tMax)\n    {\n        vec3 intersection = rh.hitMin;// camPos + rayVec * hit;\n        vec3 normal = rh.normMin;// normalize(intersection - earthPos);\n        vec3 rotNormal = RotateX(normal, iTime*EARTH_ROT_SPEED+0.05); // This is the \"right way\" if I'm using 3d textures.\n//        vec3 rotNormal = (normal + iTime*EARTH_ROT_SPEED).yzz; // This is the hacky 2d texture way.\n\n        //finalColor = texture(iChannel2, vec2(normal.z, normal.y)).xyz;\n        vec3 surface = vec3(0.01, 0.03, 0.081);\n        vec3 landTex = texture(iChannel2, rotNormal.xy * 0.25 + vec2(0.0, sin(rotNormal.z*2.0)*.25)).xyz;\n        vec3 land = landTex*vec3(0.19,0.22,0.16)*0.4;\n        vec3 landDry = landTex.yzx*vec3(0.31,0.26,0.22)*0.33;\n        land = mix(land, landDry, saturate(pow(landTex.y+.4,20.0)));\n        float landMask = landTex.y*1.3;\n        landMask += texture(iChannel2, rotNormal.yz * vec2(0.25,0.333)).y*1.3;\n        landMask = saturate(pow(landMask-0.1, 60.0));\n        surface=mix(surface,land,landMask);\n\n        //float clouds = texture(iChannel2, normal.xz*4.0*0.75).y * texture(iChannel2, -normal.xz*3.75*4.0).z*4.5;\n        //surface += clouds*clouds*0.125;\n//        surface += tex3d(normal * 0.75 /*+ vec3(0, sin(normal.x), 0)*/, normal).yyy * tex3d(-normal.xyz * 3.75, normal).zzz*4.5;\n        float clouds = tex3d(rotNormal * 0.5, rotNormal).y *\n                   tex3d((-rotNormal.xyz    + vec3(sin(rotNormal.y*15.0)*.02)    ) * 3.75, rotNormal).z *\n                   4.5;\n        surface += clouds;\n\n//        surface += tex3d(rotNormal * 0.5, rotNormal).yyy *\n//                   tex3d((-rotNormal.xyz    + vec3(sin(rotNormal.y*15.0)*.02)    ) * 3.75, rotNormal).zzz *\n//                   4.5;\n//        surface += texture(iChannel2, Rotate(rotNormal.xz,1.0) * 2.5).yyy *\n  //                 texture(iChannel2, (rotNormal.zx     + vec2(0.0, sin(rotNormal.z*60.0)*.005)     ) * vec2(13.75,11.0)).zzz *\n    //               (0.2+texture(iChannel2, rotNormal.yz * vec2(37.75,39.0)).xxx*0.8) *\n      //             1.5;\n        //surface = texture(iChannel2, (rotNormal.zx     + vec2(0.0, sin(rotNormal.z*80.0)*0.005)     )).xyz*0.5;\n        float d = dot(normal, normalize(camPos - intersection));\n\n        float atmosphere = 1.0 - d;\n        atmosphere = pow(atmosphere, 3.0);\n        atmosphere = atmosphere * 0.9 + 0.1;\n        surface = mix(surface, atmosphereColor, atmosphere);\n        finalColor = surface;\n        //finalColor = vec3(1.0) * d;\n        //finalColor = normal * 0.5 + 0.5;\n    }\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        finalColor = GetSunColorSmall(rayDir, sunDir, sunCol) * sunShadow;\n    }\n    if ((rh2.tMin < rh2.tMax)) {\n        vec3 a = rh2.hitMin;\n        vec3 b = rh2.hitMax;\n        if (rh.tMin < rh.tMax) {\n            b = rh.hitMin;\n        }\n        //finalColor = mix(fogColor, finalColor, exp(-t*0.02));\n        finalColor += pow(saturate(0.044 * atmosphereColor * exp(distance(a,b)*0.0018)), vec3(2.0));\n    }\n    return finalColor;\n}\nvec3 GetEnvMapSpaceGlossy(vec3 camPos, vec3 rayDir, vec3 sunDir, vec3 sunCol, float sunShadow)\n{\n    vec3 finalColor;\n    vec3 atmosphereColor = vec3(70.0, 130.0, 240.0)/355.0;\n\n    float dSun = max(0.0, dot(rayDir, sunDir));\n    dSun = pow(dSun,7.0);\n    float dEarth = dot(rayDir, normalize(earthPos)) * 0.5 + 0.5;\n    dEarth = pow(dEarth,3.0)*0.6;\n    \n    //d1 = pow(d1,7.0)*2.0;\n    finalColor = sunCol * dSun * sunShadow + atmosphereColor * dEarth;\n    return finalColor;\n}\n\n\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\nvoid matmin(inout float distA, inout uint matA, float distB, uint matB) {\n    if (distA > distB) {\n        distA = distB;\n        matA = matB;\n    }\n}\nvoid matmax(inout float distA, inout uint matA, float distB, uint matB) {\n    if (distA < distB) {\n        distA = distB;\n        matA = matB;\n    }\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// https://iquilezles.org/articles/distfunctions\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// capped cylinder distance field\nfloat cylCap(vec3 p, float r, float lenRad)\n{\n    float a = length(p.xy) - r;\n    a = max(a, abs(p.z) - lenRad);\n    return a;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\n// k should be negative. -4.0 works nicely.\n// smooth blending function\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\n#define Repeat(a, len) (mod(a, len) - 0.5 * len)\nvec3 RepeatX(vec3 a, float len) {\n    return vec3(mod(a.x, len) - 0.5 * len, a.yz);\n}\nvec2 RepeatX(vec2 a, float len) {\n    return vec2(mod(a.x, len) - 0.5 * len, a.y);\n}\nvec3 RepeatY(vec3 a, float len) {\n    return vec3(a.x, mod(a.y, len) - 0.5 * len, a.z);\n}\nvec2 RepeatY(vec2 a, float len) {\n    return vec2(a.x, mod(a.y, len) - 0.5 * len);\n}\nvec3 RepeatZ(vec3 a, float len) {\n    return vec3(a.xy, mod(a.z, len) - 0.5 * len);\n}\n\nvec3 FlipX(vec3 a, float rad) {\n    return vec3(abs(a.x) - rad, a.yz);\n}\nvec3 FlipY(vec3 a, float rad) {\n    return vec3(a.x, abs(a.y) - rad, a.z);\n}\nvec3 FlipZ(vec3 a, float rad) {\n    return vec3(a.xy, abs(a.z) - rad);\n}\nvec2 FlipX(vec2 a, float rad) {\n    return vec2(abs(a.x) - rad, a.y);\n}\nvec2 FlipY(vec2 a, float rad) {\n    return vec2(a.x, abs(a.y) - rad);\n}\nfloat Flip(float a, float rad) {\n    return abs(a) - rad;\n}\n\nvec3 Symmetric4X(vec3 p, float rad) {\n    return vec3(p.x, max(abs(p.yz), abs(p.zy)) - rad);\n}\nvec3 Symmetric4Y(vec3 p, float rad) {\n    return vec3(max(abs(p.x), abs(p.z)) - rad, p.y, max(abs(p.z), abs(p.x)) - rad);\n}\nvec3 Symmetric4Z(vec3 p, float rad) {\n    return vec3(max(abs(p.xy), abs(p.yx)) - rad, p.z);\n}\n\nvec3 cylTransform(vec3 p) {\n    vec3 result = p;\n    result.x = 26.0*(atan(p.z, p.x)/ PI);\n    result.z = length(p.xz);\n    return result;\n}\n\nfloat repsDouble(float a)\n{\n    return abs(a * 2.0 - 1.0);\n}\nvec2 repsDouble(vec2 a)\n{\n    return abs(a * 2.0 - 1.0);\n}\nvec2 mapSpiral(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    //dist += sin(at*32.0)*0.05;\n    // at is [-1..1]\n    // dist is [-1..1]\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(dist, at);\n}\n\nfloat length8( vec3 p ) { p=p*p; p=p*p; p=p*p; return pow(p.x+p.y+p.z,1.0/8.0); }\nfloat length8( vec2 p ) { p=p*p; p=p*p; p=p*p; return pow(p.x+p.y,1.0/8.0); }\nfloat lengthM( vec3 p ) {\n    float temp = abs(p.x) + abs(p.y) + abs(p.z);\n    temp *= 0.5773;\n    return temp;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdTorusHard( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return lengthM(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat Truss(vec3 p, float bigRad, float smallRad, float rungRad, float size) {\n    // Bounding box for faster marching when far away\n    float bound = sdBox(p, vec3(size, size, rungRad) + bigRad);\n    if (bound > size*0.5) return bound;\n\n    float d = length(FlipY(FlipX(p.xy, size), size)) - bigRad;\n    // 4-way symmetric\n    vec3 rep4 = vec3( max(abs(p.xy), abs(p.yx)) - size, Repeat(p.z, size*2.0));\n    float d2 = length(rep4.xz) - smallRad;\n    d = min(d, d2);\n\n    vec3 rot = RotateX(p, PI*0.25);\n    rot = FlipX(rot, size);\n    rot.z += 1.414*0.5*size;\n    rot = RepeatZ(rot, 1.414*size);\n    d2 = length(rot.xz) - smallRad;\n    d2 = max(d2, Flip(p.y, size));\n    d = min(d, d2);\n\n    rot = RotateY(p, PI*0.25);\n    rot = FlipY(rot, size);\n    rot.z += 1.414*0.5*size;\n    rot = RepeatZ(rot, 1.414*size);\n    d2 = length(rot.yz) - smallRad;\n    d2 = max(d2, Flip(p.x, size));\n    d = min(d, d2);\n    d = max(d, Flip(p.z, rungRad));\n    return d;\n}\n\n// Low numbers are assumed to be in the cylinder inner or outer transform.\nconst uint matFloor = 1u;\nconst uint matWall = 2u;\nconst uint matPipe = 3u;\nconst uint matChrome = 4u;\nconst uint matGlossyRough = 5u;\nconst uint matSideWindows = 6u;\nconst uint matYellow = 7u;\nconst uint matBoring = 8u;\nconst uint matDome = 9u;\n\n// High numbers should be in world space transform.\nconst uint matSolarPanel = 100u;\nconst uint matSpoke = 101u;\n\nconst uint matRGB = 202u;\n\nuint SetMatRGB(uint r, uint g, uint b) {\n    return matRGB | (r << 24) | (g << 16) | (b << 8);\n}\nbool IsMatRGB(uint m) {\n    return (m & 0xffu) == matRGB;\n}\nvec3 GetMatRGB(uint m) {\n    return vec3(float((m >> 24) & 0xffu), float((m >> 16) & 0xffu), float((m >> 8) & 0xffu));\n}\n// A collection of nice colors for the long landing bay looking things on the ring.\n// Is this slowing my framerate?\nconst uint niceColors[4] = uint[](\n    matRGB | (76u << 24) | (67u << 16) | (8u << 8),\n    matRGB | (76u << 24) | (10u << 16) | (4u << 8),\n    matRGB | (50u << 24) | (96u << 16) | (86u << 8),\n    matRGB | (10u << 24) | (7u << 16) | (3u << 8)\n);\n\nvoid Dish(vec3 p, out float dist, out uint mat) {\n    //dist = length(p + vec3(0.125,0,0)) - 0.3;\n    //if (dist > 0.1) return;\n    float d = sdTorusHard(FlipY(p, 0.03), vec2(0.1, 0.01));\n    dist = d;\n    mat = matGlossyRough;\n    d = length(p + vec3(0.32,0,0)) - 0.22;\n    d = max(d, -(length(p + vec3(0.43,0,0)) - 0.25));\n    d = max(d, -p.x-0.25);\n    float d2 = length(p.yz) - 0.15;\n    d = max(d, d2)*0.7; // This multiplier is a total hack because the distance field is breaking down.\n    matmin(dist, mat, d, SetMatRGB(90u,90u,90u));\n\n    vec3 pr = RotateZ(p + vec3(0.37, 0, 0), PI * 0.25);\n    d = length(pr.xz) - 0.01;\n    d = max(d, Flip(pr.y+0.107, 0.11));\n    matmin(dist, mat, d, SetMatRGB(128u,128u,128u));\n    d2 = cylCap(p.yzx + vec3(0,0,0.38), .035, .005);\n    matmin(dist, mat, d2, matGlossyRough);\n}\n\n// How much space between voxel borders and geometry for voxel ray march optimization\nfloat voxelPad = 0.005;\n// p should be in [0..1] range on xz plane\n// pint is an integer pair saying which city block you are on\nvoid CityBlock(vec3 p, ivec2 pint, out float dist, out uint mat)\n{\n    // Get random numbers for this block by hashing the city block variable\n    vec4 rand;\n    rand = HashVec4I2(pint);\n    vec4 rand2 = HashVec4I2(ivec2(rand.zw*8192.0)+pint*127);\n    vec4 rand3 = HashVec4I2(pint + 8192);\n    vec4 randBig = HashVec4I2((ivec2(pint.x >> 1, pint.y >> 3)) + 1024);\n    vec4 randBigger = HashVec4I2((pint >> 2) + 2048);\n\n    float downtown = saturate(40.0 / length(vec2(pint.x,(    (pint.y+50)%100-50    )*8)));\n    //vec2 distAndMat;\n    if (randBigger.w < 0.97) {\n        if (randBig.w > 0.15) {\n            // Radius of the building\n            float baseRad;// = 0.02 + (rand.x) * 0.1;\n            //baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\n            baseRad=0.48 * max(0.1,1.0-rand.x);\n\n            // make position relative to the middle of the block\n            vec3 baseCenter = p - vec3(0.5 + (0.5-baseRad)*(rand.y*2.0-1.0)*0.7, 0.0, 0.5 + (0.5-baseRad)*(rand.z*2.0-1.0)*0.7);\n            float height = rand.w*0.5 + 0.1; // height of first building block\n            // Make the city skyline higher in the middle of the city.\n            //downtown = texture(iChannel2,vec2(pint)*0.01).x;\n            height *= downtown*1.8;\n            //height += 0.25;\t// minimum building height\n            //height *= rand.x*1.93;// baseRad-0.15;\n            //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\n            height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\n            float d = sdBox(baseCenter, vec3(baseRad, height, baseRad)-0.02) - 0.02; // large building piece\n            //d /= max(1.0, height*2.0);\n\n            // floor\n            d = min(d, p.y);\n\n            //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\n\n            // height of second building section\n            float height2 = rand.y * 0.3;\n            height2 = floor(height2*20.0)*0.05;\t// floor units\n            rand2 = floor(rand2*20.0)*0.05;\t// floor units\n            // side pieces of building\n            d = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)-0.02)-0.02);\n            d = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)-0.02)-0.02);\n            // second building section\n            if (rand2.y > 0.5)\n            {\n                d = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8*(rand2.y+.1), height2, baseRad*0.8*(rand2.z+.1))));\n                // subtract off piece from top so it looks like there's a wall around the roof.\n                //float topWidth = baseRad;\n                //if (height2 > 0.0) topWidth = baseRad * 0.8;\n                //d = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.5*rand.w, 0.01, topWidth-0.5*rand.x)));\n            }\n            else\n            {\n                // Pointy top section of building\n                if (rand2.z > 0.5) d = min(d, sdHexPrism((baseCenter - vec3(0.0, height, 0.0)).xzy, vec2(baseRad*0.7, height2))-0.05);\n            }\n            // mini elevator shaft boxes on top of building\n            //d = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\n            //                 vec3(baseRad*0.3*rand.z, 0.01*rand2.y, baseRad*0.3*rand2.x+0.025)));\n            // mirror another box (and scale it) so we get 2 boxes for the price of 1.\n            //vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\n            //float big = sign(boxPos.x);\n            //boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\n            //d = min(d, sdBox(boxPos, vec3(baseRad*0.4*rand.w, 0.02*rand.y, baseRad*0.5*rand.x + big*0.025)));\n\n            //if (rand2.x > 0.75) {\n                //float tor = sdTorus(\n                //    (baseCenter - vec3(0.0, height+height2 + 0.05 - baseRad, baseRad * (rand2.z*2.0-1.0))).xzy,\n                //                    vec2(0.9 * baseRad, 0.01));\n                //d = min(d, tor);\n            //}\n\n            //d = max(d, p.y);  // flatten the city for debugging cars\n\n            // Need to make a material variable.\n            dist = d, mat = matFloor;//rand2.x);\n            vec3 litf = rand2.xxx*.8+.2;\n            litf += randBig.x*.25-.15;\n            litf -= randBigger.x*.2-0.05;\n            //litf.x += rand2.y*0.5-0.25;\n            //litf.y += rand2.z*0.5-0.25;\n            litf.z -= rand2.w*0.05-0.025;\n            litf += vec3(0.0, 0.025, 0.04);\n//            litf -= texture(iChannel2,vec2(pint)*0.01).x;\n            litf= max(vec3(0.05), litf);\n            uvec3 lit = uvec3(saturate(litf)*140.0);\n            mat = SetMatRGB(lit.x,lit.y,lit.z);\n            if (p.y < 0.01) mat = matFloor;\n            if (rand2.w < 0.25) {\n                float dtemp = sdRoundBox((baseCenter - vec3(0.0, height, 0.0)).xzy, vec3(baseRad,baseRad,baseRad)*rand.xyz*0.5, baseRad*0.45*rand.w );\n                matmin(dist, mat, dtemp, matBoring);\n            }\n\n        } else {\n            // Long and big segment\n            p.xz += vec2(pint.x&0x1,(pint.y&0x7)-3);\n            dist = p.y, mat = matFloor;\n            vec3 baseCenter = p - vec3(1.0, 0.0, 1.0);\n            float d = length(baseCenter.xz) - 0.75 + sin(baseCenter.y*164.0)*0.002;\n            d = max(d, abs(baseCenter.y)-0.25);\n            float d2 = length(baseCenter +vec3(0.0, 0.6, 0.0)) - 0.995;// + sin(baseCenter.z*128.0)*0.005;\n            d2 = max(d2, length(baseCenter.xz) - 0.75);\n            //d = min(d, d2);\n            d = sdBox(abs(baseCenter)-vec3(.5,0,0), vec3(0.3, 0.1, 3.3))-.1;\n            //matmin(dist, mat, d2, matGlossyRough);\n            //matmin(dist, mat, d, matGlossyRough);\n            matmax(dist, mat, -d, SetMatRGB(50u,51u,53u));\n            d = sdBox((baseCenter)-vec3(.5,0,(randBig.z-.5)*4.), vec3(0.5*randBig.x, 0.74, 2.0*randBig.y));\n            matmax(dist, mat, -d, niceColors[int(randBig.x*3.99)]);\n            d = sdBox((baseCenter)-vec3(-.5,0,(randBig.w-.5)*4.), vec3(0.5*randBig.y, 0.74, 2.0*randBig.x));\n            matmax(dist, mat, -d, niceColors[int(randBig.y*3.99)]);\n        }\n    } else {\n        // big dome\n        p.xz += vec2(pint&0x3);\n        dist = p.y, mat = matFloor;\n        vec3 baseCenter = p - vec3(2.0, 0.5*randBigger.y, 2.0);\n        //float d = length(baseCenter.xz) - 1.75*randBigger.z;\n        float waveRoof = min(0.015, abs(   (sin(p.x*4.0)+sin(p.z*16.0))   *0.015));\n        //d = sdHexPrism((baseCenter - vec3(0, waveRoof -.1, 0.0)).xzy, vec2(1.75-randBigger.z*1.2, .2))-.1;\n        //d = max(d, abs(baseCenter.y)-0.25);\n        float d2 = sdRoundBox(baseCenter*vec3(1,1.-waveRoof,1) + vec3(0,0.75,0), vec3(1.1-randBigger.w*0.2), 0.65-randBigger.x*0.3);\n        float d = sdRoundBox(RotateY(baseCenter,.785)*vec3(1,1.-waveRoof,1) + vec3(0,0.75,0), vec3(1.1-randBigger.w*0.2), 0.65-randBigger.x*0.3);\n        d = min(d,d2);\n        d*=1.25; // Distance field on these shapes is a little bad, so sun shadows are getting messed up. nudge it.\n        uint m =matDome;// SetMatRGB(65u,72u,78u);\n        if (p.y < 0.2) m = SetMatRGB(60u,112u,120u);\n        matmin(dist, mat, d, m);\n    }\n    // Pipes everywhere!\n    vec3 rep = p - vec3(0.0, 0.1, 0.5);\n    rep.x = Repeat(rep.x, 0.5);\n    float d = length(rep.xy) - 0.0625 * rand2.x;\n    //d = max(d, abs(rep.z) - 0.5);\n    if (rand.z > 0.7) matmin(dist, mat, d, matPipe);\n\n    // Vertical pipes too. So sci-fi!\n    rep = p - vec3(0.0, 0.13 * rand.z, 0.5);\n    rep.z = Repeat(rep.z, 0.5);\n    d = length(rep.yz) - 0.025;\n    //d = max(d, abs(rep.z) - 0.5);\n    if (randBigger.y > 0.6) {\n        matmin(dist, mat, d, matWall);\n        rep = p - vec3(0.0, 0.5 * rand2.z, 0.5);\n        rep.x = Repeat(rep.x, 1.0);\n        d = length(rep.xy) - 0.05;\n        if (randBig.y > 0.5) {\n            uint m = matPipe;\n            if (randBig.x > 0.95) m =matYellow;// SetMatRGB(100u,52u,40u);\n            matmin(dist, mat, d, m);\n        }\n    }\n\n    //return distAndMat;\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material index.\nvoid DistanceToObject(vec3 p, out float dist, out uint mat)\n{\n/*    mat = matFloor;\n    dist = length(p+ vec3(4.0,2.0,2.0 + sin((p.y + iTime)*8.0)*0.04)) - 4.0;\n    float dist2 = length(p) - 1.0;\n    dist = min(dist, dist2);\n    \n    return;*/\n    p = RotateY(p,ROT_SPEED*iTime);\n\n    float density = 8.0;\n    vec3 cyl = cylTransform(p);\n    cyl.x *= density;\n\n    dist = -100000000.0;\n    mat = 0u;\n    //distAndMat.x = length(p.z) - 4.0;\n\n    const float scale = 1.0;\n    float scaleDen = scale / density;\n    cyl = cyl.yzx/scaleDen;\n    cyl.z *=scaleDen;\n    cyl.y = cyl.y - 8.0*density;\n    vec3 cylBasic = cyl;\n    cyl.y = abs(cyl.y) - 1.0; // make it a ring instead of solid cylinder\n    vec3 rep = cyl.xyz;\n    rep.xz = fract(cyl.xz); // [0..1] for representing the position in the city block\n    float dTemp;\n    uint mTemp;\n    CityBlock(rep, ivec2(floor(cyl.xz)), dTemp, mTemp);\n    dTemp *= scaleDen;\n    matmax(dist, mat, dTemp, mTemp);\n\n    // Side windows\n    matmax(dist, mat, abs(p.y) - 1.0, matSideWindows);\n    \n    float ringRad = 0.05;\n    // Edge rings\n    float d = length(abs(cyl.xy) + vec2(-8.0, 0)) - ringRad;\n    d *= scaleDen;\n    matmin(dist, mat, d, matYellow);\n    d = length(vec2(abs(cyl.x), cyl.y) + vec2(-8.0, 1)) - ringRad;\n    d *= scaleDen;\n    matmin(dist, mat, d, matSpoke);\n\n    // Edge ring cross-beams\n    vec3 prot = FlipX(RotateX(cyl, PI*0.25), 0.0);\n    float prep = Repeat(prot.y, 1.414);\n\n    d = length(vec2(prot.x, prep) + vec2(-8.0, 0 )) - ringRad;\n\tprep = Repeat(prot.z, 1.414);\n    float d2 = length(vec2(prot.x, prep) + vec2(-8.0, 0)) - ringRad;\n    d = min(d, d2) * scaleDen;\n    d = max(d, abs(length(p) - 8.0625) - 0.125);\n    matmin(dist, mat, d, matSpoke);\n\n    // Edge ring cross-beam joints\n/*    prep = Repeat(cyl.z, 2.);\n    d = length(vec3(cyl.xy - vec2(8.0,0), prep)) - ringRad * 1.75;\n    d *= scaleDen;\n    matmin(dist, mat, d, matGlossyRough);*/\n\n    // Hub Edge rings\n    d = length(RepeatX(cylBasic.xy + vec2(-7.25, 59.2), 0.4)) - 0.05;\n    d = max(d, abs(p.y) - 0.91);\n    d *= scaleDen;\n    matmin(dist, mat, d, matPipe);\n\n    d  = sdBox(FlipZ(p + vec3(0,-.57,0.0), 0.58), vec3(0.25, 0.29, 0.03)) - 0.008;\n    d2 = sdBox(FlipX(p + vec3(0,-.57,0.0), 0.58), vec3(0.03, 0.29, 0.25)) - 0.008;\n    matmin(dist, mat, min(d, d2), matFloor);\n\n    //vec3 sym = Symmetric4Y(p.xyz + vec3(0,-0.78,0), 0.4);\n    //d = Truss((sym.xyz) - vec3(0.25,0.18,0.24), 0.005, 0.0025, 0.175, 0.025);\n    //matmin(dist, mat, d, matPipe);\n    d = Truss(abs(p.xyz + vec3(0,-0.78,0)) - vec3(0.25,0.08,0.4), 0.005, 0.0025, 0.175, 0.025);\n    matmin(dist, mat, d, matPipe);\n    d = Truss(abs(p.zyx + vec3(0,-0.78,0)) - vec3(0.25,0.08,0.4), 0.005, 0.0025, 0.175, 0.025);\n    matmin(dist, mat, d, matPipe);\n\n    // Main Spokes\n    float ridge = clamp(abs(fract(p.z*4.0)-0.5), 0.05, 0.1)*0.125;\n    float spoke = cylCap(abs(p.xyz) - vec3(0.25,0,0), 0.125, 8.0*scale) + ridge;\n    matmin(dist, mat, spoke, ridge > .01249 ? matSpoke : matGlossyRough);\n    ridge = clamp(abs(fract(p.x*4.0)-0.5), 0.05, 0.1)*0.125;\n    spoke = cylCap(abs(p.zyx) - vec3(0.25,0,0), 0.125, 8.0*scale) + ridge;\n    matmin(dist, mat, spoke, ridge > .01249 ? matSpoke : matGlossyRough);\n\n    // Hub\n    ridge = clamp(abs(fract(p.y*1.44+0.5)-0.5), 0.25, 0.3)*0.75;\n    d = length(p.xz) - saturate(1.09-abs(p.y*0.2)) + ridge;\n    //d = min(d, sbox(abs(p) - vec3(1.0/1.414, 1.0/1.414, 0.0), vec3(0.1, 0.1, len)));\n    d = max(d, abs(p.y) - 0.9);\n    float dsub = length(p.xz) - 0.6;\n    dsub = max(dsub, abs(abs(p.y-1.0) - 0.0) - 0.6);\n    d = max(d, -dsub);\n    matmin(dist, mat, d, matFloor);\n\n    // Garage area in hub\n    d  = sdBox(FlipZ(p + vec3(0,-.5,0.0), 0.59), vec3(0.25, 0.1, 0.05)) - 0.001;\n    d2 = sdBox(FlipX(p + vec3(0,-.5,0.0), 0.59), vec3(0.05, 0.1, 0.25)) - 0.001;\n    matmax(dist, mat, -min(d, d2), matPipe);\n\n    // Bay doors - looks bad.\n    /*d = length(abs(p.xz) - vec2(0.8)) - 0.5;\n    d2 = sdBox(p + vec3(0,-0.9,0), vec3(.8, .01, .8));\n    d = max(d, d2);\n    matmin(dist, mat, d, matFloor);*/\n\n    // Rocket - looks bad.\n    /*vec3 rocketPos = p + vec3(0,-0.75,0.35);\n    d = cylCap(rocketPos, 0.046, 0.12);\n    d2 = sdCone(rocketPos.yzx, vec2(.08, 0.02), .2 );\n    d = min(d,d2);\n    d2 = sdCone(rocketPos.yzx + vec3(0,-.22,0), vec2(.1, 0.04), .1 );\n    d = min(d,d2);\n    matmin(dist, mat, d, matBoring);*/\n    \n\n\n    // Wires\n    const float len = 8.0 * scale;\n    float wireThick = 0.001;\n    prot = RotateY(p, PI*0.3333);\n    float wire = length(prot - vec3(0,0,clamp(prot.z, -len, len))) - wireThick;\n    float wire2 = length(prot - vec3(clamp(prot.x, -len, len),0,0)) - wireThick;\n    //distAndMat = matmin(distAndMat, vec2(min(wire, wire2), matPipe));\n\n    prot = RotateY(p, PI*0.6666);\n    wire = length(prot - vec3(0,0,clamp(prot.z, -len, len))) - wireThick;\n    wire2 = length(prot - vec3(clamp(prot.x, -len, len),0,0)) - wireThick;\n    //distAndMat = matmin(distAndMat, vec2(min(wire, wire2), matPipe));\n\n    // Wires\n    //float wireThick = 0.01;\n    prot = RotateY(p, PI*0.25);\n    prep = Repeat(prot.x, 0.25*0.707);\n/*    wire = length(vec2(prep, abs(prot.y))) - wireThick;\n    wire = max(wire, length(p.xz)-len);\n\n    wire2 = max(prep, max(0.25-p.z, max(0.25-p.x, wire)));\n    matmin(dist, mat, wire2, matPipe);\n    wire = max(prep, max(0.25+p.z, max(0.25+p.x, wire)));\n    matmin(dist, mat, wire, matPipe);\n\n    prep = Repeat(prot.z, 0.25*0.707);\n    wire = length(vec2(prep, abs(prot.y))) - wireThick;\n    wire = max(wire, length(p.xz)-len);\n\n    wire2 = max(prep, max(0.25+p.z, max(0.25-p.x, wire)));\n    matmin(dist, mat, wire2, matPipe);\n    wire = max(prep, max(0.25-p.z, max(0.25+p.x, wire)));\n    matmin(dist, mat, wire, matPipe);*/\n\n    // Ladder-struts in spokes\n    prep = Repeat(p.x, 0.25);\n    d = length(vec2(prep, abs(p.y) - 0.0))-0.015;\n    d = max(d, length(p.xz)-len);\n    d = max(d, abs(p.z) - 0.25);\n    matmin(dist, mat, d, matSpoke);\n\n    prep = Repeat(p.z, 0.25);\n    d = length(vec2(prep, abs(p.y) - 0.0))-0.015;\n    d = max(d, length(p.xz)-len);\n    d = max(d, abs(p.x) - 0.25);\n    matmin(dist, mat, d, matSpoke);\n\n    // 45 degree struts\n    prep = Repeat(prot.z+0.09, 0.25*0.707);\n    d = length(vec2(prep, abs(prot.y) - 0.0))-0.015;\n    d = max(d, length(p.xz)-len);\n    d = max(d, abs(p.x) - 0.25);\n    matmin(dist, mat, d, matSpoke);\n\n    prep = Repeat(prot.x+0.09, 0.25*0.707);\n    d = length(vec2(prep, abs(prot.y) - 0.0))-0.015;\n    d = max(d, length(p.xz)-len);\n    d = max(d, abs(p.z) - 0.25);\n    matmin(dist, mat, d, matSpoke);\n\n    // Solar array\n/*    prot = RotateY(p + vec3(-8.0,0.0,0.0), PI*0.25);\n\tprep = Repeat(prot.z, 0.5*0.707);\n    prot = RotateX(vec3(prot.xy, prep), 0.5);\n    //prot = vec3(prot.x, prot.y, prep);\n    vec3 cr = normalize(cross(sunDir, vec3(1,0,0)));\n    cr = normalize(cross(cr, sunDir));\n    //prot = vec3(prot.x, sunDir.y * prot.y - cr.z * prot.z, cr.x * prot.y + sunDir.z * prot.z);\n\td = sdBox(prot, vec3(4.0, 0.001, 0.095));\n    d = max(d, length(p.xz)-len);\n    d = max(d, 0.5-p.x);\n    d = max(d, 0.5+p.z);\n    matmin(dist, mat, d, matSolarPanel);*/\n\n    p = RotateY(p,-ROT_SPEED*iTime);\n\n    // Communications tower / truss\n    d = Truss(p.xzy + vec3(0,0,4), 0.015, 0.0075, 3.535, 0.05);\n    matmin(dist, mat, d, matGlossyRough);\n\n    // Dishes\n    float tempD;\n    uint tempM;\n    Dish(RepeatY(RotateY(p, sin(floor(p.y/.666+.5)*1.73+iTime*0.1)) + vec3(0,4.9,0), 0.666), tempD, tempM);\n    tempD = max(tempD, Flip(p.y+4.9, 2.666));\n    matmin(dist, mat, tempD, tempM);\n\n    //float d = length(p) - 2.0;\n    //matmin(dist, mat, d, 0u);// distAndMat, vec2(d, matGlossyRough));\n    //d = length(p-3.0) - 2.0;\n    //distAndMat = matmin(distAndMat, vec2(d, matChrome));\n\n/*    d = cylCap(p.zxy - vec3(0.0, 0.0, 2.0), 0.05, 2.0);\n    matmin(dist, mat, d, SetMatRGB(0u, 255u, 0u));\n    d = cylCap(p.yzx - vec3(0.0, 0.0, 2.0), 0.05, 2.0);\n    matmin(dist, mat, d, SetMatRGB(255u, 0u, 0u));\n    d = cylCap(p.xyz - vec3(0.0, 0.0, 2.0), 0.05, 2.0);\n    matmin(dist, mat, d, SetMatRGB(0u, 0u, 255u));*/\n\n    //return distAndMat;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvec4 texPanelsDense(vec2 uv, out vec3 normal) {\n\n    vec3 texNormal = vec3(0);\n    vec4 texColor = vec4(0);\n    float mask = 0.0;\n    for (int i = ZERO_TRICK; i < 9; i++) {\n        vec3 tempN;\n        vec4 tempC = texPanels(uv/float(i+1)+37.5*float(1-i), tempN);\n        texColor = mix(tempC, texColor, mask);\n        texNormal = mix(tempN, texNormal, mask);\n        mask = saturate((texColor.a-0.05)*200.0);\n    }\n\n    normal = texNormal;\n    return texColor;\n}\n\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n\t// -------------------------------- animate ---------------------------------------\n    const vec3 sunCol = vec3(2.58, 2.38, 2.10)*0.8;\n\tconst vec3 sunDir = normalize(vec3(0.93, 1.0, 1.0));\n    const vec3 skyCol = vec3(0.3,0.45,0.8)*0.5;\n    const float exposure = 1.7;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv /= 3.0;  // zoom in\n\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,-1.75,0);\n\n    // debugging camera\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\n\tfloat my=iMouse.y/iResolution.y*3.14 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*13.0;  // 9\n    if ((dot(iMouse.xy, vec2(1.0)) <= 64.0)) {\n        camPos = vec3(10.0, 6.6, -8.0)*1.0;\n        int whichCam = int(iTime*0.095) % 3;\n        float remainder = fract(iTime * 0.095);\n        if (whichCam == 0) {\n            camPos = vec3(10.0, 6.6, -8.)*(1.4 - remainder*.2);\n            camLookat=vec3(0,-1.75,0);\n            camUp=vec3(0,1,0.5);\n        }\n        else if (whichCam == 1) {\n            camPos = vec3(1.0, 4. + remainder*2., -1.)*6.;\n            camLookat=vec3(0,-1.75,0);\n            camUp=vec3(1,1,-0.5);\n        }\n        else if (whichCam == 2) {\n/*            camPos = vec3(-4.0, 6.6, 7.)*2.;\n            camLookat=vec3(0,-2.5,0);\n            camUp=vec3(1,1,-0.5);\n            uv *= 0.5;*/\n            camPos = vec3(-4.0-remainder*2., 6.6+remainder*6., 7.+remainder*6.)*2.;\n            camLookat=vec3(0,-2.5,0);\n            camUp=vec3(1,1,-0.5);\n            uv *= 0.5+remainder*0.5;\n        }\n    }\n\n    \n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n    float dist;\n    uint mat;\n    //vec2 distAndMat;\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0.0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = ZERO_TRICK; i < 250; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = (camPos + rayVec * t);\n        float walkA, walkB;\n        //vec2 distAndMatA, distAndMatB;\n        {\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry. The idea is that the\n            // distance field returns the distance to the closest object, and then\n            // we know we are safe to \"march\" along the ray by that much distance\n            // without hitting anything. We repeat this until we get really close\n            // and then break because we have effectively hit the object.\n            DistanceToObject(pos, dist, mat);\n\n\n\n/*    vec3 pRot = RotateY(pos,ROT_SPEED*iTime);\n\n    float density = 8.0;\n    vec3 cyl = cylTransform(pRot);\n    cyl.x *= density; // cyl.x is the angle around the space station. cyl.z is the length from the center.\n\n    const float scale = 1.0;\n    float scaleDen = scale / density;\n    cyl = cyl.yzx/scaleDen;\n    cyl.z *=scaleDen;\n    cyl.y = cyl.y - 8.0*density;\n    vec3 cylBasic = cyl;\n    cyl.y = abs(cyl.y) - 1.0; // make it a ring instead of solid cylinder\n\n    cyl.z = cyl.y;*/\n\n\n            // 2d voxel walk through the city blocks.\n            // The distance function is not continuous at city block boundaries,\n            // so we have to pause our ray march at each voxel boundary.\n            walkA = dist;\n            /*float dx = -fract(pos.x);\n            if (rayVec.x > 0.0) dx = fract(-pos.x);\n            float dz = -fract(pos.z);\n            if (rayVec.z > 0.0) dz = fract(-pos.z);\n            float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\n            nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\n            //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\n            walkA = min(walkA, nearestVoxel);*/\n        }\n        dist = walkA;\n        float walk = walkA;\n        // move down the ray a safe amount\n        t += walk;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(dist) < smallVal)) break;\n    }\n\n    // Ray trace a ground plane to infinity\n    float alpha = -camPos.y / rayVec.y;\n/*    if ((t > maxDepth) && (rayVec.y < -0.0))\n    {\n        pos.xz = camPos.xz + rayVec.xz * alpha;\n        pos.y = -0.0;\n        t = alpha;\n        distAndMat.y = 0.0;\n        distAndMat.x = 0.0;\n    }*/\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if ((t <= maxDepth) || (t == alpha))\n\t{\n      \t//vec2 distAndMat = vec2(0.0);  // Distance and material\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        //vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\n        //                   dist - DistanceToObject(pos - smallVec.yxy).x,\n        //                   dist - DistanceToObject(pos - smallVec.yyx).x);\n        vec3 normalU = vec3(0.0);\n        for( int i=ZERO_TRICK; i<4; i++ )\n        {\n            vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n            /*if (i==0) {\n                distAndMat = DistanceToObject(pos+0.0005*e);\n                normalU += e*distAndMat.x;\n            } else {*/\n            float tempDist;\n            uint tempMat;\n            DistanceToObject(pos+0.0005*e, tempDist, tempMat);\n                normalU += e*tempDist;\n            //}\n        }\n        vec3 normal = normalize(normalU);\n\n\n        // calculate ambient occlusion.\n        float ff = 0.0125;\n        float aa = 80.0;\n        float ambient = 1.0;\n        for( int i=ZERO_TRICK; i<6; i++ )\n        {\n            float tempDist;\n            uint tempMat;\n            DistanceToObject(pos + normal * ff, tempDist, tempMat);\n            ambient *= saturate(tempDist*aa);\n            ff *= 2.0;\n            aa /= 2.0;\n        }\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        //vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.01;\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n\t\tfor (int i = ZERO_TRICK; i < 40; i++)\n        {\n            vec3 shadowPos = nudgePos + sunDir * iter;\n            float tempDist;\n            uint tempMat;\n            DistanceToObject(shadowPos, tempDist, tempMat);\n\t        sunShadow *= saturate(tempDist*200.0);\t// Shadow hardness\n            if (tempDist <= 0.0) break;\n\n            float walk = tempDist;\n            float dx = -fract(shadowPos.x);\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\n            float dz = -fract(shadowPos.z);\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\n            walk = min(walk, nearestVoxel);\n\n            iter += max(0.005, walk);\n            if (iter > 4.5) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        float specular = 0.0;\n        vec3 texColor = vec3(0.5, 0.5, 0.5);\n        vec3 rustColor = vec3(0.5, 0.45, 0.4);\n        /*if ((distAndMat.y >= matFloor) && (distAndMat.y < matFloor + 1.0)) {\n            texColor = mix(texColor, rustColor, distAndMat.y);\n//            texColor *= (distAndMat.y*0.75+0.25);\n        }*/\n        vec3 pRot = RotateY(pos,ROT_SPEED*iTime);\n        if (mat == matWall) {\n            texColor = vec3(0.5, 0.6, 0.7);\n        }\n        else if (mat == matPipe) {\n            texColor = vec3(0.15, 0.12, 0.1)*0.5;\n        }\n        else if (mat == matChrome) {\n            texColor = vec3(0.01, 0.01, 0.01);\n            specular = 1.0;\n        }\n        else if (mat == matGlossyRough) {\n            texColor = vec3(0.5);\n            specular = 0.99;\n        }\n        else if (mat == matYellow) {\n            texColor = vec3(0.6, 0.42, 0.05)*.755;\n            specular = 0.1;\n        } else if (mat == matSideWindows) {\n            vec3 cyl = cylTransform(pRot);\n            float grid = max(abs(fract(cyl.x*16.)*2.-1.), abs(fract(cyl.z*32.)*2.-1.));\n            grid = saturate(grid*5.-4.5);\n            texColor = vec3(0.5,0.7,1.0)*grid;\n\t        specular = .2;\n            /*vec3 spNorm;\n            vec4 rgbspec = texSolarPanels(cyl.xz*16.0, spNorm);\n            vec3 cyl = cylTransform(pRot);\n            vec3 spNorm;\n            vec4 rgbspec = texSolarPanels(cyl.xz*16.0, spNorm);\n            texColor = rgbspec.rgb;\n\t        specular = rgbspec.w;*/\n        } else if (mat == matFloor) {\n\n            vec3 cyl = cylTransform(pRot);\n            vec3 spNorm;\n            if (length(pRot) > 7.0) cyl.xy *= vec2(16.0,4.0);\n            vec4 rgbspec = texPanelsDense(cyl.xy*8.0 * vec2(0.2, 1.2), spNorm);\n//            texColor = normal.xyz*0.5+0.5;// vec3(0.0) + rgbspec.aaa*4.0;\n            texColor = vec3(0.0,0.02,0.05);\n            if (length(pRot) > 7.0) texColor += rgbspec.aaa*7.0-0.39;\n            else texColor = max(vec3(0.33),texColor + rgbspec.aaa*4.0);\n            texColor *= vec3(0.96, 0.98, .97);\n\t        specular = rgbspec.w * 0.1;\n            if (abs(normal.y) > 0.9) texColor = vec3(0.4);\n            //texColor = vec3(0.0,1.0,0.0);\n        } else if (mat == matDome) {\n            vec3 cyl = cylTransform(pRot);\n            texColor *= vec3(0.91, 0.97, 0.998)*.8;\n            float windows = saturate(abs(fract(cyl.z*64.0)-0.5)*16.0-4.0);\n            //windows = max(windows, saturate(abs(fract(cyl.x*24.0)-0.5)*16.0-4.0));\n            //if (abs(normal.y) > 0.15) texColor = mix(texColor, vec3(0.6, 0.7, 0.9)*0.4, windows);\n            //if (abs(cyl.z) < 8.25) {\n            //if (length(normal.yz) < .7) {\n                specular = windows*0.2;\n                texColor *= windows*.35+.65;\n            //}\n        } else if (IsMatRGB(mat)) {\n            texColor = GetMatRGB(mat)*(1.0/255.0);\n        }\n\n        float n = 0.0;\n        float doubler = 1.0;\n        for (int i = ZERO_TRICK; i < 4; i++) {\n            n += noise(pRot * 8.0 * doubler) / doubler;\n            doubler *= 2.0;\n            //n += noise(pos*16.0)*0.5;\n            //n += noise(pos*32.0)*0.25;\n            //n += noise(pos*64.0)*0.125;\n        }\n        texColor *= (n*0.25+0.75);\n\n        if (mat == matSpoke) {\n            texColor = vec3(1.0)*0.6;\n        }\n\n        if (mat == matSolarPanel) {\n            vec3 spNorm;\n            vec4 rgbspec = texSolarPanels(Rotate(pRot.xz*64.0, PI*0.25), spNorm);// vec3(0.3, 0.4, 0.5)*0.35;\n            texColor = rgbspec.rgb;\n\t        specular = rgbspec.w;\n        }\n        vec3 texNorm;\n\t\t//vec4 rgbspec = texSolarPanels(pos.yz*16.0, texNorm);\n        //specular = rgbspec.w;\n        //if (distAndMat.y >= 100.0) {\n            // world space transform...\n        \t//normal = normalize(normal+ texNorm);\n            //texColor = fract(vec3(pos.xz, 0.0));\n        //}\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = ambient;// (ambient*3.0 + ambientS) * 0.25;\n        // Add sky color with ambient acclusion\n        lightColor += (skyCol * saturate(dot(normal, normalize(earthPos)) *0.5+0.5))*pow(ambientAvg, 0.25);\n\n        vec3 ref = reflect(rayVec, normalize(normal));\n        //vec3 envTemp = texture(iChannel0, ref).xyz;\n        //vec3 env = saturate(envTemp * envTemp * envTemp * envTemp);// GetEnvMap(ref, sunDir);\n        vec3 env;\n        if (mat == matGlossyRough) {\n            env = GetEnvMapSpaceGlossy(pRot, ref, sunDir, sunCol, sunShadow);\n        } else {\n            env = GetEnvMapSpace(pRot, ref, sunDir, sunCol, sunShadow);\n        }\n\n        // Make windows-looking lights even though that would be the\n        // floor and the roof for the people inside. It still looks cool. :D\n        if (mat == matFloor) {\n            float n2 = saturate((n-0.5)*1.);\n            float windows = 1.0-saturate(abs(fract(pRot.y*16.)-.5)*14.-.9);\n            if (texColor.x < 0.0001) {\n                texColor = vec3(0.4);\n                texColor *= windows;\n                lightColor += vec3(.99,.8,.35)*2.*n2;\n            }\n            //texColor = vec3(n2);\n            //texColor = vec3(windows);\n        }\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        finalColor = mix(finalColor, env, specular);\n        // I'm a terrible person for doing this on a space scene, but...\n        // Let's fake some fog just to make it look bigger. :/\n        finalColor = mix(finalColor, vec3(.07,.13,.2), .08);\n\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.25) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n        finalColor = GetEnvMapSpace(camPos, rayVec, sunDir, sunCol, 1.0);\n    }\n\n    // vignette?\n    finalColor *= vec3(1.1) * saturate(1.1 - length(uv/1.2));\n    finalColor *= exposure;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0));\n}\n\nconst float kKeyLeft  = 37.5 / 256.0;\nconst float kKeyUp    = 38.5 / 256.0;\nconst float kKeyRight = 39.5 / 256.0;\nconst float kKeyDown  = 40.5 / 256.0;\nconst float kKeySpace = 32.5 / 256.0;\n\nfloat SampleKey(float key)\n{\n\treturn step(0.5, texture(iChannel1, vec2(key, 0.25)).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SetRandomSeed(fragCoord.xy, iResolution.xy, iFrame);\n    // Do a multi-pass render if anti-aliasing is on\n    vec3 finalColor = vec3(0.0);\n    finalColor = RayTrace(fragCoord);\n\n\tvec2 R = iResolution.xy;\n    vec2 uv = ( 2.*fragCoord - R ) / R.y;          // [-1,1] vertically\n    uv *= 18.0;\n    //uv  += iMouse.xy * 0.1;\n    //uv.x += iTime * 1.1;\n    vec3 texNormal;\n    vec4 texColor = texPanelsDense(uv, texNormal);\n    vec3 tempLightDir = normalize( vec3((iMouse.xy-fragCoord)*0.003, 1.0) );\n    float lightDot = dot(tempLightDir, normalize(texNormal.xyz));\n    //finalColor = texColor.rgb * max(0.0,lightDot)*0.8 + vec3(0.01, 0.2, 0.4)*0.2;\n    //finalColor += vec3(1.0) * pow(max(0.0,lightDot), 104.0) * texColor.a;\n    //if (iMouse.z > 0.0) finalColor = texNormal * 0.5 + 0.5;\n    //if (SampleKey(kKeySpace) > 0.5) finalColor = vec3(1) * texColor.w;\n    fragColor = vec4(sqrt(saturate(finalColor)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define saturate(a) clamp(a, 0.0, 1.0)\nconst float PI=3.14159265;\n\n// Makes compile times much faster.\n// Forces for loops to not unroll because compiler thinks the zero is not a constant.\n#define ZERO_TRICK max(0, -iFrame)\n\nvec2 Rotate(vec2 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec2(cos * v.x - sin * v.y, sin * v.x + cos * v.y);\n}\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n// Find 2 perpendicular vectors to the input vector.\nmat3 MakeBasis(vec3 normal) {\n\tmat3 result;\n    result[0] = normal;\n    if (abs(normal.y) > 0.5) {\n        result[1] = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    } else {\n        result[1] = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    }\n    result[2] = normalize(cross(normal, result[1]));\n    return result;\n}\n\n\n// ---- Random functions use one 32 bit state var to change things up ----\n// This is the single state variable for the random number generator.\nuint randomState = 4056649889u;\n// 0xffffff is biggest 2^n-1 that 32 bit float does exactly.\n// Check with Math.fround(0xffffff) in javascript.\nconst float invMax24Bit = 1.0 / float(0xffffff);\n\n// This is the main hash function that should produce a non-repeating\n// pseudo-random sequence for 2^31 iterations.\nuint SmallHashA(in uint seed) {\n    return (seed ^ 1057926937u) * 3812423987u ^\n            ((seed*seed) * 4000000007u);\n}\n// This is an extra hash function to clean things up a little.\nuint SmallHashB(in uint seed) {\n    return (seed ^ 2156034509u) * 3699529241u;\n}\n\n// Hash the random state to get a random float ranged [0..1]\nfloat RandFloat() {\n    randomState = SmallHashA(randomState);\n    // Add these 2 lines for extra randomness. And change last line to tempState.\n    //uint tempState = (randomState << 13) | (randomState >> 19);\n    //tempState = SmallHashB(tempState);\n    return float((randomState>>8) & 0xffffffu) * invMax24Bit;\n}\n// Hash the random state to get 2 random floats ranged [0..1]\n// Reduced precision to 16 bits per component.\nvec2 RandVec2() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec2(tempState & 0xffffu,\n                (tempState >> 16) & 0xffffu) / float(0xffff);\n}\n// Hash the random state to get 3 random floats ranged [0..1]\n// Reduced precision to 10 bits per component.\nvec3 RandVec3() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec3((tempState >> 2) & 0x3ffu,\n                (tempState >> 12) & 0x3ffu,\n                (tempState >> 22) & 0x3ffu) / float(0x3ffu);\n}\n\n// Returns a random float from [0..1]\nfloat HashFloat(uint seed) {\n    seed = SmallHashA(seed);\n    return float((seed >> 8) & 0xffffffu) * invMax24Bit;\n}\n// Reduced precision to 16 bits per component.\nvec2 HashVec2(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec2(seed & 0xffffu,\n                (seed >> 16) & 0xffffu) / float(0xffff);\n}\n// Reduced precision to 10 bits per component.\nvec3 HashVec3(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec3((seed >> 2) & 0x3ffu,\n                (seed >> 12) & 0x3ffu,\n                (seed >> 22) & 0x3ffu) / float(0x3ffu);\n}\n// Reduced precision to ** 6 ** bits per component.\nvec4 HashVec4(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec4((seed >> 8) & 0x3fu,\n                (seed >> 14) & 0x3fu,\n                (seed >> 20) & 0x3fu,\n                (seed >> 26) & 0x3fu) / float(0x3fu);\n}\nfloat HashFloatI2(ivec2 seed2) {\n    return HashFloat(uint(seed2.x ^ (seed2.y * 65537)));\n}\nvec2 HashVec2I2(ivec2 seed2) {\n    return HashVec2(uint(seed2.x ^ (seed2.y * 65537)));\n}\nvec3 HashVec3I2(ivec2 seed2) {\n    return HashVec3(uint(seed2.x ^ (seed2.y * 65537)));\n}\nvec4 HashVec4I2(ivec2 seed2) {\n    return HashVec4(uint(seed2.x ^ (seed2.y * 65537)));\n}\n\nvoid SetRandomSeed(in vec2 fragCoord, in vec2 iResolution,\n                  in int iFrame) {\n    uint primex = max(uint(iResolution.x), 5003u);  // This prime is far from any 2^x\n    randomState = uint(fragCoord.x);\n    randomState += uint(fragCoord.y) * primex;\n    randomState += uint(iFrame) * primex * uint(iResolution.y);\n    // This shouldn't really be an if condition.\n    // This should be true for any application that's not debugging things.\n    //if (hashedSeed) {\n        RandFloat();\n    //}\n}\n\n// ---- Procedural textures ----\n\nvec3 mingrad(vec3 a, vec3 b) {\n    if (a.x < b.x) return a;\n    else return b;\n}\n\nvec3 dCircle(vec2 uv, float rad) {\n    vec2 grad = normalize(uv);\n    return vec3(length(uv) - rad, grad);\n}\n\nvec3 dBox(vec2 uv, vec2 rad) {\n    vec2 grad = (abs(uv.x*rad.y) > abs(uv.y*rad.x)) ? vec2(1, 0) : vec2(0, 1);\n    grad *= sign(uv);\n\n    vec2 dist = abs(uv) - rad;\n    float d = min(max(dist.x, dist.y), 0.0) + length(max(dist, 0.0));\n    return vec3(d, grad);\n\n    //return vec3(length(uv) - rad, grad);\n}\n\nvec4 texPanels(vec2 uv, out vec3 normal) {\n    vec4 hash = HashVec4I2(ivec2(floor(uv+.0)));\n    vec4 hash2 = HashVec4I2(ivec2(hash*8192.0));\n    vec4 hash3 = HashVec4I2(ivec2(hash2*8192.0));\n    ivec2 fl = ivec2(floor(uv));\n    vec2 centered = fract(uv) - 0.5;\n    vec2 radOut = 0.35*hash2.xy + 0.1;\n    radOut *= float((fl.x&1) ^ (fl.y&1)) *0.25+0.75;  // Checkerboard scale it so it looks less repetitive\n    if (hash.z > 0.99) radOut.x = radOut.y;\n    float radThick = 1.0 / 32.0;\n    // Jitter it as much as possible without going out of radius.\n    vec2 jitterPos = centered + (hash.xy*2.0-1.0)*(0.5-radOut);\n    vec3 dc;\n    if (hash.z > 0.99) dc = dCircle(jitterPos, radOut.x - radThick);\n    else dc = dBox(jitterPos, vec2(radOut - radThick));\n    float d = saturate(dc.x/radThick);\n    if ((d <= 0.0) || (d >= 1.0)) dc.yz = vec2(0.0);\n\n    normal = normalize(vec3(dc.yz, 1.0));\n    return vec4(vec3(1, 1, 1)-d*0.1, 0.1-d*0.05);// vec3(hash3.rgb*(1.0-d));\n}\n\n#define ANTIALIASING_SAMPLES 1\nvec4 texSolarPanels(vec2 uv, out vec3 normal) {\n    vec4 hash = HashVec4I2(ivec2(floor(uv+vec2(0.5,.25))));\n    ivec2 fl = ivec2(floor(uv));\n    vec2 centered = fract(uv) - 0.5;\n    float radThick = 1.0 / 64.0;\n    vec3 dc = dBox(centered, vec2(0.02,0.55) - radThick);\n    dc.x = saturate(dc.x/radThick);\n    radThick *= 0.5;\n    vec3 dc2 = dBox(centered - vec2(0, 0.25), vec2(0.55,0.0125) - radThick);\n    dc2.x = saturate(dc2.x/radThick);\n    vec3 dc3 = dBox(centered + vec2(0, 0.25), vec2(0.55,0.0125) - radThick);\n    dc3.x = saturate(dc3.x/radThick);\n    dc2 = mingrad(dc3, dc2);\n    dc = mingrad(dc, dc2);\n    float d = dc.x;\n    if ((d <= 0.0) || (d >= 1.0)) dc.yz = vec2(0.0);\n\n    normal = normalize(vec3(dc.yz + vec2(abs(sin((uv.x + 0.5)*PI)*0.1), 0.0), 1.0));\n    float pad = (d < 1.0) ? 1.0 : 0.0;\n    vec4 padCol = mix(vec4(1,1,1,0.25)*0.5, vec4(0.7, 0.5, 0.1, 0.5)*0.25, hash.x);\n    //float maxDelta = max(dFdy(uv.x), dFdy(uv.y));\n    //return vec4(vec3(1.0)* maxDelta, 0.0);\n#if ANTIALIASING_SAMPLES == 1\n    return mix(vec4(.01, .015, .1, 0.8), vec4(0.7, 0.5, 0.1, 0.5)*0.5, 0.1);\n#endif\n\n    return mix(vec4(.01, .015, .1, 0.8), padCol, pad);\n}\n\nvec4 texHex(vec2 uv, out vec3 normal) {\n    vec4 hash = HashVec4I2(ivec2(floor(uv+.0)));\n    ivec2 fl = ivec2(floor(uv));\n    vec2 centered = fract(uv) - 0.5;\n    \n    float repx = abs(fract(uv.x)-0.5)*2.0;\n    float repy = abs(fract(uv.y)-0.5)*2.0;\n\n    normal = normalize(vec3(0,0,1.0));\n    return vec4(vec3(repx, repy, 1),0.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}