{
    "Shader": {
        "info": {
            "date": "1563906779",
            "description": "Tool's Undertow album art, except a little more alive. Video: https://youtu.be/uERhSuFRKgw",
            "flags": 8,
            "hasliked": 0,
            "id": "wlXSRj",
            "likes": 6,
            "name": "Tool - Undertow",
            "published": 3,
            "tags": [
                "tool",
                "undertow"
            ],
            "usePreview": 0,
            "username": "dc",
            "viewed": 411
        },
        "renderpass": [
            {
                "code": "// Author: Dillon Cower (dcower@)\n// License: Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n#define HIGH_QUALITY 0\n#define DO_THE_ANGLE 0\n\n#if HIGH_QUALITY\n#define STEPS 500\n#define STEP_SIZE 0.08\n#define D_MIN 0.0001\n#define D_MAX 30.0\n#define LIGHT_D_MIN 0.025\n#define LIGHT_D_MAX 10.0\n#define LIGHT_STEPS 200\n#define LIGHT_STEP_SIZE 0.2\n#else\n#define STEPS 125\n#define STEP_SIZE 0.3\n#define D_MIN 0.025\n#define D_MAX 20.0\n#define LIGHT_D_MIN 0.05\n#define LIGHT_D_MAX 10.0\n#define LIGHT_STEPS 30\n#define LIGHT_STEP_SIZE 0.5\n#endif\n\n#define powabs(x, y) pow(abs(x), y)\n\nfloat get_start_fade() {\n    return min(1.0, iTime / 10.0);\n}\n\nfloat Rand(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat ValueNoise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 s = smoothstep(0.0, 1.0, f);\n    float nx0 = mix(Rand(i + vec2(0.0, 0.0)), Rand(i + vec2(1.0, 0.0)), s.x);\n    float nx1 = mix(Rand(i + vec2(0.0, 1.0)), Rand(i + vec2(1.0, 1.0)), s.x);\n    return mix(nx0, nx1, s.y);\n}\n\n/*float random_flicker(float time) {\n    return clamp(round(Rand(vec2(round(time * 20.0) / 20.0)) + 1.2), 0.0, 1.0);\n}*/\n\nfloat random_flicker(float time) { return 1.0; }\n\n// by iq:\nfloat noise( const in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy) + f.xy;\n    return textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\n}\n\n/*float noise( const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}*/\n\nfloat iqhash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n// Was getting radial artifacts with commented out noise above...\nfloat noise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( iqhash(n+0.0  ), iqhash(n+1.0  ),f.x),\n                   mix( iqhash(n+57.0 ), iqhash(n+58.0 ),f.x),f.y),\n               mix(mix( iqhash(n+113.0), iqhash(n+114.0),f.x),\n                   mix( iqhash(n+170.0), iqhash(n+171.0),f.x),f.y),f.z);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smax(float a,float b,float k){ return -smin(-a,-b,k);}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\n\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nconst float blood_pumping_scale = 11.0;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat get_heartbeat(float time) {\n    float x = mod(time * 6.0, 14.0);\n    // NOTE: This same equation with |floor| is broken on iOS.\n    return saturate(ceil(x - 2.0)) - saturate(x - 2.0) + saturate(ceil(x)) - saturate(x);\n}\n\n// Safe atan2 from: https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle\nfloat atan2(in float y, in float x) {\n    return x == 0.0 ? sign(y)*3.1415926535/2.0 : atan(y, x);\n}\n\nfloat finger( in vec3 p, float size_mult, float seed)\n{\n    p = rotX(-3.1415/2.0 * -0.05) * p;\n    \n    // position the fingers -- move them away from the origin\n    p -= vec3(11.0 * (1.0 + size_mult) / 2.0, 0.0, -1.0);\n    \n    // start animation\n    //float start_curl = -1.0 * (1.0 - powabs(get_start_fade(), 0.75));\n    //float start_curl = 1.0 * (1.0 - get_start_fade());\n    float start_radius_add = 2.0 * powabs(1.0 - get_start_fade(), 0.7);\n    //float start_curl = 1.0;\n    //float start_radius_add = (1.0 - powabs(get_start_fade(), 1.5)) * 4.0;\n    \n    //float an = 2.2 + start_curl * 2.2 - (1.0 - powabs(get_start_fade(), 0.5)) * 1.0;\n    float an = 1.0 + 1.2 * powabs(get_start_fade(), 0.7);\n    vec2 torus_c = vec2(sin(an),cos(an));\n    p = rotZ(5.5 + an) * p;\n\n    float angle = 0.5 * atan2(p.y, p.x) + 3.1415/4.0 * 0.75;\n    float along_torus = clamp(abs(cos(angle)), 0.0, 1.0);\n    float r = clamp(2.0 - 2.0 * min(powabs(along_torus, 2.0), 100.0), 0.0, 4.0);\n    \n    // Breathing effect:\n    vec3 q = get_start_fade() * vec3(0.0,\n        cos(p.y + iTime * 2.0)*0.5 * along_torus + sin(p.z) * 0.3 + sin(iTime * 0.5) * 0.5,\n                  0.0) * abs(p.x * 0.3)\n        + p;\n        \n    q.x /= clamp(abs(p.x * 0.1 + 1.0), 0.0, 1.0);\n    q.y /= clamp(abs(p.x * 0.1 + 1.0), 0.0, 1.0);\n    \n    float radius = size_mult * 8.0 + start_radius_add;\n    \n    // Curl the end of the finger.\n    float ango = 3.1415 * 0.75;\n    float time = seed * 3.0 + iTime * 1.5;\n    float time_seed = abs(cos(seed * 123.0)) + 1.0;\n    q = q + vec3(\n        sin(seed + time_seed * time * 0.3) * powabs(1.0 * clamp(4.0 - length(p - vec3(sin(ango) * radius, cos(ango) * radius, 0.0)), 0.0, 1000.0), 2.0),\n        sin(seed + time_seed * time * 0.7) * powabs(0.7 * clamp(4.0 - length(p - vec3(sin(ango) * radius, cos(ango) * radius, 0.0)), 0.0, 1000.0), 2.0),\n        sin(seed + time_seed * time * 0.3) * powabs(0.3 * clamp(7.0 - length(p - vec3(sin(ango) * radius, cos(ango) * radius, 0.0)), 0.0, 1000.0), 2.0)\n    );\n\n    // flatten\n    //q.y = q.y * abs(powabs(p.y + 0.0, 0.25));\n    //q.z = q.z * abs(powabs(p.z, 0.5));\n    r = clamp(r * abs(p.y + 6.0), 0.0, r);\n    //r *= 1.5;\n\n    return sdCappedTorus(q, torus_c, radius, r);\n}\n\nfloat body( in vec3 p)\n{\n    // android fix:\n    //p = rotationMatrix(normalize(vec3(sin(iTime * 13.0), sin(iTime * 7.0), sin(iTime * 11.0))), 0.025* get_heartbeat(iTime)) * p;\n  p += vec3(sin(iTime * 13.0), sin(iTime * 11.0), sin(iTime * 7.0)) * 0.25 * get_heartbeat(iTime);\n    \n    p -= vec3(0, -0.5, 0.0);\n\n    //p.y = p.y + 0.2 * min(powabs(abs(p.x*0.5), 1.8), 200.0);\n    p.z = p.z * 1.0 - 0.5 + 0.2 * min(powabs(abs(p.x*.3), 1.0), 200.0);\n    //p.z = p.z + p.z * 0.03 * min(powabs(abs(p.x*0.15), 2.6), 200.0);\n    \n    p.z *= 0.085;\n    //p.y *= 0.5;\n    //p.xy *= 0.5;\n    //p.y *= 1.5;\n    //p.y *= 1.0;\n    \n    float radius = 5.0 + 11.0 * powabs(get_start_fade(), 1.4);\n    \n    //p.y += -3.0 + radius - 4.0 * (1.0 - powabs(get_start_fade(), 1.4));\n    //p.y += -3.0 + radius - 4.0 * (1.0 - powabs(get_start_fade(), 1.4));\n    //p.y += -3.0 + 16.0;\n    p.y += -3.0 + radius;\n    //p.y -= 4.0 * (1.0 - get_start_fade());\n    \n    float an = 1.0;\n    //float an = 0.3 + 0.7 * powabs(get_start_fade(), 0.5);\n    //an = 0.8;\n    //float an = 3.14159;\n    vec2 torus_c = vec2(sin(an),cos(an));\n    //vec3 rot_for_radius = p;\n    //p = rotZ(5.5 + an) * p;\n    //float angle = 0.5 * atan(p.y, p.x) + 3.1415/4.0 * 0.75;\n    float angle = 0.5 * atan2(p.y, p.x) + 3.1415/4.0 * 1.0;\n    \n    angle = angle + 0.4 * (1.0 - powabs(get_start_fade(), 0.5));\n    //float along_torus = clamp(abs(cos(angle)), 0.0, 1.0);\n    //float r = clamp(2.0 - 2.0 * min(powabs(along_torus, 2.0), 100.0), 0.0, 4.0);\n    //float r = clamp(1.0 - 1.0 * min(powabs(along_torus, 1.0), 100.0), 0.0, 4.0);\n    //float r = 1.0;\n    float r = 1.0;\n    //p.xy *= vec2(cos(angle + 8.2), sin(angle)) * 1.0;\n    p.xy *= powabs(vec2(cos(angle + 8.2), sin(angle)) * 1.0, vec2(6.0));\n    \n    p.z *= 1.03;\n    p.x *= 0.8;\n\n    return sdCappedTorus(p, torus_c, radius, r);\n}\n\n// from mskr@\nfloat sabs(float d, float eps) {\n    float abs = abs(d);\n    if(d > -eps && d < eps) return mix(abs, eps, (eps - abs) / eps / 2.);\n    return abs;\n}\n\nvec3 sphIntersect3(in vec3 p)\n{\n    float d = 1e10;\n    \n    float seed_sign = 124.0 * sign(p.x);\n    \n    // mirror p along x axis; smooth abs to get rid of artifact in center.\n    p.x = sabs(p.x, 0.5);\n    \n    //p = rotationMatrix(vec3(1.0, 0.0, 0.0), -3.1415/2.0 * 0.7) * p * powabs(get_start_fade(), 0.5);\n    p = rotationMatrix(vec3(1.0, 0.0, 0.0), -3.1415/2.0 * 0.7) * p;\n    \n    // pump dat blood\n    p *= 1.0 + 0.01* get_heartbeat(iTime);\n\n    //p = rotationMatrix(vec3(1.0, 0.0, 0.0), -3.1415/2.0 * 1.0 * iTime) * p;\n    //p = rotationMatrix(vec3(1.0, 0.0, 0.0), -3.1415 * sin(iTime*0.2)) * p;\n\n    // bow\n    p.z = p.z + (sign(p.z) * powabs(p.z, 1.0) + 9.0) * 0.02 * min(powabs(abs(p.x*0.15), 3.0), 200.0);\n    // p.z = p.z + p.z * 0.01 * min(powabs(abs(p.x*0.15), 3.0), 200.0);\n    p.x *= 1.1;\n    \n    // breathing body\n    /*p = 0.1 * p * vec3(0.0,\n        cos(p.y + iTime * 2.0)*0.5 + sin(p.z) * 0.3 + sin(iTime * 0.5) * 0.5,\n                  0.0) * abs(p.x * 0.3)\n        + p;*/\n    //p.x = p.x + 0.5 * sin(iTime * 2.0);\n    //p.y = p.y + 0.05 * sin(iTime * blood_pumping_scale);\n    \n    p.x = p.x + (0.5 * sin(iTime * 0.8) + 0.5);\n    p.y = p.y + 0.05 * sin(iTime * blood_pumping_scale);\n   \n    \n    //float dist_between = 4.5 * powabs(get_start_fade(), 0.5);\n    //float dist_between = 4.5 * mix(0.5, 1.0, powabs(get_start_fade(), 0.5));\n    const float dist_between = 4.5;\n    // side fingers\n    float rot_amount = 0.1 + 0.125 * 2.5 * abs(sin(iTime * 0.37));\n    //rot_amount = 0.0;\n    \n    //vec3 finger_p = rotX(-3.1415/2.0 * -0.05) * p;\n    \n    vec3 rot_axis = vec3(0.0, 0.0, 1.0);\n    d = min(d, finger(rotationMatrix(rot_axis, rot_amount) * p + vec3(0.0, 0.0, -dist_between * 2.0), 0.8, -123.0 + seed_sign));\n    d = min(d, finger(rotationMatrix(rot_axis, rot_amount / 2.0) * p + vec3(0.0, 0.0, -dist_between), 0.9, 15235.0 + seed_sign));\n    d = min(d, finger(rotationMatrix(rot_axis, rot_amount / 3.0) * p + vec3(0.0, 0.0, 0.0), 0.975, 4124.3 + seed_sign));\n    d = min(d, finger(rotationMatrix(rot_axis, rot_amount / 2.0) * p + vec3(0.0, 0.0, dist_between), 0.9, 412.0 + seed_sign));\n    d = min(d, finger(rotationMatrix(rot_axis, rot_amount) * p + vec3(0.0, 0.0, dist_between * 2.0), 0.8, 632.0 + seed_sign));\n   \n    // smax for in-between fingers\n    float finger_d = d;\n    float body_d = body(p);\n    \n    d = opSmoothSubtraction(finger_d, body_d, clamp(powabs(abs(p.x / 10.0), 2.0), 0.0, 30.0));\n\n    d = smin(d, finger_d, (3.75 - 3.0 * clamp(abs(p.y / 10.0), 0.0, 1.0)) * clamp(p.x / 25.0, 0.0, 1.0));\n\n    //d = smin(d, body_d, 5.0 * (1.0 - get_start_fade()));\n    \n    // fade hack\n    //d = d + 3.0 - powabs(get_start_fade(), 0.4) * 3.0;\n\n    return vec3(d, finger_d, body_d);\n}\n\nfloat sphIntersect(in vec3 p)\n{\n    return sphIntersect3(p).x;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat noise_texture(vec3 p) {\n    float val = 0.0;\n    //p *= 0.5;\n    //p += 33.0;\n    \n    //p += vec3(powabs(1.0 - get_start_fade(), 0.5) * 4.0, powabs(1.0 - get_start_fade(), 0.5) * 3.0, powabs(1.0 - get_start_fade(), 0.5) * 7.0);\n    float s = sign(p.x);\n    /*if (p.x < 10.0 && p.x >= 0.0) {\n        s = powabs(p.x * 0.1, 2.0) * 10.0;\n    } else if (p.x > -10.0 && p.x <= 0.0) {\n        s = powabs(p.x * 0.1, 2.0) * 10.0;\n    }*/\n\n    p += vec3(s * (1.0 - powabs(get_start_fade(), 0.7)) * 20.0, 0.0, 0.0);\n  p += 0.2 * vec3(get_heartbeat(iTime) * 1.0 * sin(iTime * 0.3), get_heartbeat(iTime) * 1.0 * cos(iTime * 0.7), get_heartbeat(iTime) * 1.0 * sin(iTime * 0.2));\n\n  //p += vec3(sin(iTime * blood_pumping_scale) * 0.05, 0.0, 0.0);\n    \n#if HIGH_QUALITY\n    const float divisor = 1.25 + 0.5;\n    val += texture(iChannel0,\n                   vec2(p.x + p.z + 5.0, p.x + p.y + p.z - 6.0)).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.z + 11.0, p.x + p.y + p.z - 39.0) / 2.0).r * 0.25;\n#else\n    const float divisor = 1.25;\n#endif\n    val += texture(iChannel1,\n                   vec2(p.x + p.z + p.y * 3.0 + 33.0, p.x + p.y + p.z - 3.0) / 4.0).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.y + 13.0, p.y + p.z - 9.0) / 8.0).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.z + 119.0, p.y + p.z + 133.0) / 16.0).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.z + 70.0, p.y + p.z + 130.0) / 32.0).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.z, p.y + p.z) / 64.0).r * 0.25;\n    \n    val *= (1.0 / divisor);\n        \n    //val += texture(iChannel0,\n    //               vec2(p.x / 1241.0 + p.y / 1233.0 + p.z / 1111.0,\n    //                    p.x / 1111.0 + p.y / 1111.0 + p.z / 333.0) * 20.0).r;\n    /*val += texture(iChannel0,\n                   vec2(1.0 / p.x / 124.0 + p.y / 123.0 + 1.0 / p.z / 111.0,\n                        p.x / 111.0 + 1.0 / p.y / 111.0 + 1.0 / p.z / 33.0) * 5.0).r;*/\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float initial_fade = 10.0;\n    \n    //vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n#if DO_THE_ANGLE\n    vec3 ro = normalize(vec3(30.0, 0.0, 40.0)) * 35.0;\n    vec3 ta = vec3( 3.0, 1.0 + 0.13*cos(0.3*0.0), 0.0 );\n    mat3 ca = setCamera(ro, ta, 0.0);\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.5 + 3.0 * q ;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 rd = ca * normalize(vec3(p.xy, 3.0));\n    //m = vec2(0.05, 0.0);\n#else\n    vec2 camera_m = vec2(m.x, 1.0-m.y);\n    camera_m = mix(vec2(0.5), camera_m, 0.5);\n    float fov_change = camera_m.y;\n\n    float an =  3.1415/2.0 + 3.1415 * camera_m.x;\n    //float cr = 0.15*sin(0.2*0.0);\n    float cr = 0.0;\n    vec3 poser = vec3(0.0, 0.0, -18.0 + 17.0 * (fov_change - 0.5));\n    // adding position here makes things a little wonky when rotating but ehhhh\n    vec3 ro = (poser + 4.4 + 0.6*smoothstep(10.0,20.0,0.0)) * vec3(sin(an),0.0,cos(an)) * 4.0;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.5 + 3.0 * q ;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 ta = vec3( 0.0, 1.0 + 0.13*cos(0.3*0.0), 0.0 );\n    mat3 ca = setCamera( ro, ta, cr );\n    // z parameter controls fov\n    vec3 rd = ca * normalize( vec3(p.xy,5.0 - 4.0 * (fov_change - 0.5)));\n    //vec3 rd = normalize( vec3(p,-2.0) );\n#endif\n   \n    float tmin = 1e10;\n    float t = 0.0;\n    float fog_amount = 0.0;\n    float dmin = 1e10;\n    \n    for (int i = 0; i < STEPS; i++) {\n        float d = sphIntersect(ro + t*rd);\n        float screen_x = 2.0*(q.x - 0.5);\n        #if HIGH_QUALITY\n        float step_size = STEP_SIZE; \n        #else\n        float step_size = abs(screen_x) < 0.25 ? STEP_SIZE * 3.5 : STEP_SIZE * (3.0 * abs(screen_x)); \n        #endif\n        //float step_size = STEP_SIZE; \n        t += d * step_size;\n        dmin = min(d, dmin);\n        if (d < D_MIN || d > D_MAX) break;\n    }\n    \n    if (t < tmin) {\n        tmin = t;\n    }\n    \n    //float d = sphIntersect(ro + tmin*rd);\n    \n    vec3 pos = ro + tmin*rd;\n    \n    //vec3 bg_color = vec3(0.05);\n    vec3 bg_color = vec3(0.0);\n    \n    vec3 col = bg_color;\n\n    if( dmin <= 1.1)\n    {\n        //vec3 diffuse_color = vec3(0.9, 0.12, 0.12);\n        vec3 diffuse_color = vec3(0.9, 0.15, 0.15);\n        \n        float heartbeat_ambience = clamp(min(get_heartbeat(iTime), 1.0 - abs(pos.x * 0.075)), 0.0, 1.0);\n        diffuse_color *= 1.0 + 0.2 * heartbeat_ambience;\n\n        // texture\n        float tex_amount = 0.5 ;//+ 0.05 * abs(sin(iTime * blood_pumping_scale));\n        //diffuse_color *= mix(1.0, noise_texture(nor * 40.0), tex_amount);\n        diffuse_color *= mix(1.0, noise_texture(pos * 1.0), tex_amount);\n\n            vec3 d3 = sphIntersect3(ro + tmin*rd);\n            //diffuse_color *= 1.0 - powabs(abs(0.1 * pos.x), 2.0) * (clamp(1.0 - abs(pos.z*0.2), 0.0, 1.0));\n            float darken_amount = 0.8;\n            diffuse_color = mix(diffuse_color, diffuse_color * clamp(1.0 - clamp(powabs(abs(0.1 * pos.x), 1.9), 0.0, 1.0) + d3.z * clamp(pos.z + 10.0, 0.0, 1.0), 0.0, 1.0),\n                                darken_amount * (0.75 + 0.25 * get_start_fade()));\n\n        col = diffuse_color;\n        \n        const float del = 0.01;\n        vec3 nor = vec3(\n            (sphIntersect(ro + tmin * rd + vec3(del, 0.0, 0.0)) - sphIntersect(ro + tmin * rd - vec3(del, 0.0, 0.0))),\n            (sphIntersect(ro + tmin * rd + vec3(0.0, del, 0.0)) - sphIntersect(ro + tmin * rd - vec3(0.0, del, 0.0))),\n            (sphIntersect(ro + tmin * rd + vec3(0.0, 0.0, del)) - sphIntersect(ro + tmin * rd - vec3(0.0, 0.0, del))));\n\n        nor *= (vec3(0.4) + 0.6 * vec3(noise_texture(pos.zyx* 1.0 + 4.0), noise_texture(pos.zxy * 1.0+ 4.0), noise_texture(pos.xzy * 1.0+ 4.0)));\n        nor = normalize(nor);\n        \n        vec3 lp = vec3(0.0, cos(iTime * 0.1) * 5.0 + 13.0, cos(iTime * 1.0) * 2.0 + 9.0);\n        \n        //lp += vec3(0.0, (1.0 - get_start_fade()) * -20.0, (1.0 - get_start_fade()) * -10.0);\n        //lp += vec3(0.0, sin(get_start_fade() * 3.1415 / 1.0 + 3.5), -cos(get_start_fade() * 3.1415 / 2.0)) * (1.0 - powabs(get_start_fade(), 0.5)) * -30.0;\n        lp += vec3(0.7 * (m.x - 0.5), m.y - 0.5, -((m.y) - 1.0 * 0.5) / 10.0) * 50.0;\n        //vec3 lp = vec3(0.0, sin(iTime)*11.0, cos(iTime) * 2.0 + 7.0);\n        //vec3 lp = vec3(20.0, 0.0, 10.0);\n        \n        lp = mix(\n            -50.0 * vec3(0.0,\n                 sin(get_start_fade() * 3.1415 / 2.0 + 3.5 + 3.1415/1.0) + 0.5,\n                 -cos(get_start_fade() * 3.1415 / 2.0 + 3.1415/1.0) - 1.0),\n                 lp,\n                 powabs(get_start_fade(), 0.5));\n\n        // march towards light.\n        float light_tmin = 1e10;\n        float light_t = 0.0;\n        vec3 to_light = normalize(lp - pos);\n        bool hit_toward_light = false;\n        vec3 light_ro = pos + to_light * 0.5;\n\n        for (int i = 0; i < LIGHT_STEPS; i++) {\n            vec3 p = light_ro + light_t * to_light;\n            float d = sphIntersect(p);\n            light_t += d * LIGHT_STEP_SIZE;\n            if (length(p - lp) < 0.1) {\n                break;\n            }\n            if (d < LIGHT_D_MIN) {\n                hit_toward_light = true;\n                break;\n            }\n            if (d > LIGHT_D_MAX) break;\n        }\n\n        if (light_t < light_tmin) {\n            light_tmin = light_t;\n        }\n\n        //col *= dot(nor, lp) * 0.3 + 0.7;\n        float ambient_amount = 0.0;\n        float light_amount = max(0.0, dot(nor, to_light)) * (1.0 - ambient_amount);\n        light_amount *= min(1.0, 300.0 / powabs(length(lp - pos), 2.0));\n\n        if (hit_toward_light) {\n            light_amount *= 0.0;\n            //col *= 4.0;\n            //col *= 0.75;\n        }\n\n        //light_amount += max(0.0, dot(nor, normalize(vec3(0.0, 0.0, 1.0))));\n\n        col *= powabs(light_amount + ambient_amount, 1.8);\n\n        // light #2\n        lp = vec3(0.0, 20.0, 20.0);\n        to_light = normalize(lp - pos);\n        light_amount = max(0.0, dot(nor, to_light)) * (1.0 - ambient_amount);\n        light_amount *= min(1.0, 256.0 / powabs(length(lp - pos), 2.0));\n        \n        //col += powabs(0.5 * light_amount * diffuse_color, vec3(1.5));\n        \n       // light #3\n        lp = normalize(vec3(-25.0, 15.0, 25.0)) * 40.0;\n        to_light = normalize(lp - pos);\n        light_amount = max(0.0, dot(nor, to_light)) * (1.0 - ambient_amount);\n        light_amount *= min(1.0, 400.0 / powabs(length(lp - pos), 2.0));\n        \n        col += powabs(1.0 * light_amount * diffuse_color, vec3(1.5));\n\n        \n        // light #4\n        lp = normalize(vec3(25.0, 15.0, 25.0)) * 40.0;\n        to_light = normalize(lp - pos);\n        light_amount = max(0.0, dot(nor, to_light)) * (1.0 - ambient_amount);\n        light_amount *= min(1.0, 400.0 / powabs(length(lp - pos), 2.0));\n        \n        col += powabs(1.0 * light_amount * diffuse_color, vec3(1.5));\n        \n        col *= random_flicker(iTime);\n\n        //col = powabs(col, vec3(1.5));\n\n        // \"anti-alias\"\n        col = mix(col, bg_color, clamp(powabs(max(0.0, dmin - D_MIN), 0.5) * 3.0, 0.0, 1.0));\n\n    }\n    \n    col = powabs(col * 1.3, vec3(1.0));\n    //col += 16.0/255.0;\n    fragColor = vec4( col, 1.0 );\n\n    //fragColor = vec4( col, 1.0 ) * powabs(get_start_fade(), 0.25);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define powabs(x, y) pow(abs(x), y)\n\nfloat Rand(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat ValueNoise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 s = smoothstep(0.0, 1.0, f);\n    float nx0 = mix(Rand(i + vec2(0.0, 0.0)), Rand(i + vec2(1.0, 0.0)), s.x);\n    float nx1 = mix(Rand(i + vec2(0.0, 1.0)), Rand(i + vec2(1.0, 1.0)), s.x);\n    return mix(nx0, nx1, s.y);\n}\n\n/*float random_flicker(float time) {\nreturn clamp(round(Rand(vec2(round(time * 20.0) / 20.0)) + 1.2), 0.0, 1.0);\n}*/\n\nfloat random_flicker(float time) { return 1.0; }\n\n// polynomial smooth min\n// from iq: https://iquilezles.org/articles/smin\n//float smin( float a, float b, float k )\n//{\n//    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n//    return mix( b, a, h ) - k*h*(1.0-h);\n//}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smax(float a,float b,float k){ return -smin(-a,-b,k);}\n\nconst float D3 = 146.83;\nconst float G3 = 196.00;\nconst float A3 = 220.00;\nconst float C4 = 261.63;\n\n// time: 0   1   2    3  4  5 6  7   | 8\n//       5 h 7   7  s 10 0    0  0\n//       G3  A3  A3   C4 D3   D3 D3 \n\nconst float bpm_scale = 0.25 / 4.0;\n//const float bpm_scale = 1.0;\nconst float time_scale = 1.0 / 1.0;\nconst float note_scale = 0.25;\n\nfloat get_time_in_note(float note_pos) {\n    if (note_pos < 2.0) { // 5, skip h7\n        return note_pos;\n    } else if (note_pos < 4.0) { // 7, skip s10\n        return note_pos - 2.0;\n    } else if (note_pos < 6.0) { // 0..\n        return note_pos - 4.0;\n    } else if (note_pos < 7.0) {\n        return note_pos - 6.0;\n    } else if (note_pos < 8.0) {\n        return note_pos - 7.0;\n    }\n\n    return 0.0;\n}\n\nfloat get_note(float note_pos) {\n    float note;\n    if (note_pos <= 1.0) { // 0 - 1\n        note = G3;\n        //note = 0.0;\n    } else if (note_pos <= 2.0) { // 1 - 2\n        note = A3;\n    } else if (note_pos <= 4.0) { // 2 - 4\n        // Slide.\n        //float note_slide = (note_pos - 2.0) / 2.0;\n        //note_slide = powabs(note_slide, 2.0);\n        float time_in_note = get_time_in_note(note_pos);\n        if (time_in_note <= 1.0) {\n            note = A3;\n        } else if (time_in_note <= 2.0) {\n            note = C4;\n        }\n        float note_slide = time_in_note / 2.0;\n        // ~sigmoid\n        note_slide = 1.0 / (1.0 + powabs(2.0, 10.0 * -(note_slide - 0.5) * 2.0));\n        note_slide = round(note_slide * 4.0) / 4.0;\n        //note = mix(A3, C4, note_slide);\n        //note_slide = smoothstep(0.0, 1.0, note_slide);\n        //note = mix(A3, C4, note_slide);\n    } else if (note_pos <= 5.0) { // 4 - 5\n        note = D3;\n    } else if (note_pos <= 6.0) {\n        note = D3;\n    } else if (note_pos <= 7.0) {\n        note = D3;\n    } else if (note_pos <= 8.0) {\n        note = D3;\n    }\n\n    return note * note_scale;\n}\n\n#define wave(frequency, time) ((sin(2.0 * 3.1415926535 * (frequency) * (time)) + sin(2.0 * 3.1415926535 * (frequency) * 1.01 * (time)) + sin(2.0 * 3.1415926535 * (frequency) * 0.99 * (time))) / 3.0)\n#define add_harmonic(num, power, frequency, time) actual_power = powabs(1.0 - time_in_note, 1.0) * powabs((1.0 - num / 12.0), 0.5); total_power += actual_power; sound += wave(frequency * num, time) * actual_power\n\nfloat play_note(float note, float note_pos, float time, float time_in_note) {\n    float pluck_amount = 0.0;\n\n    /*if (note_pos < 1.0 || // 5, skip h7\n(note_pos > 2.0 && note_pos < 3.0) || // 7, skip s10\n(note_pos > 4.0 && note_pos < 5.0) || \n(note_pos > 6.0 && note_pos <= 8.0) ) {\npluck_amount = 1.0 - powabs(min(time_in_note, 0.2) / 0.2, 0.2);\n}*/\n\n    pluck_amount = 1.0 - powabs(min(time_in_note, 0.4) / 0.4, 0.2);\n\n    float wave_temp;\n    float sound = 0.0;\n\n    // bend note slightly at start.\n    float start_bend_amount = pluck_amount * (1.0 - min(mod(note_pos, 1.0), 0.25) / 0.25);\n    //note = note - note * start_bend_amount * 0.0025;\n    //note = time_in_note * 400.0;\n\n    float total_power = 0.0;\n    float actual_power = 0.0;\n    add_harmonic(1.0, 1.0, note, time);\n    add_harmonic(2.0, 1.0, note, time);\n    add_harmonic(3.0, 1.0, note, time);\n    add_harmonic(4.0, 1.0, note, time);\n    add_harmonic(5.0, 1.0, note, time);\n    add_harmonic(6.0, 1.0, note, time);\n    add_harmonic(7.0, 1.0, note, time);\n    add_harmonic(8.0, 1.0, note, time);\n    add_harmonic(9.0, 1.0, note, time);\n    add_harmonic(10.0, 1.0, note, time);\n    add_harmonic(11.0, 1.0, note, time);\n    add_harmonic(12.0, 1.0, note, time);\n    sound /= total_power;\n\n    // Distort, but distort a bit less over time.\n    float distortion = 6.0 - 2.0 * time_in_note;\n    //float distortion = 5.0;\n    sound = clamp(sign(sound) * powabs(abs(sound), 0.5) * distortion, -1.0 ,1.0);\n\n    float time_for_noise = floor(time_in_note * iSampleRate * 0.4) / 0.4 / iSampleRate;\n    float pluck_sound = mod(ValueNoise(vec2(time_for_noise) * 50000.0), 1.0);\n    sound = mix(sound, pluck_sound, pluck_amount * 0.25);\n\n    return sound;\n}\n\nfloat play_sound(float time)\n{\n    const float bpm = 175.0 * bpm_scale;\n    const float bps = bpm / 60.0;\n    const float num_notes = 8.0;\n    float note_pos = mod(time * bps, num_notes);\n    //float time_in_note = mod(note_pos, 1.0);\n    float time_in_note = get_time_in_note(note_pos);\n    float time_in_riff = note_pos / bps;\n\n    //float pluck_amount = get_pluck_amount(note_pos);\n    float rand_note = (Rand(vec2(floor(time * bps) / bps)) + 1.0) / 2.0;\n    //note_pos = mix(note_pos, rand_note * 8.0, (min(time * 0.1, 1.0) - 0.1) * rand_note);\n\n    float prev_note = get_note(note_pos - 0.25);\n    float curr_note = get_note(note_pos);\n    float next_note = get_note(note_pos + 0.25);\n\n    float subsample_scale = powabs(abs(sin(time_in_riff * 0.1)), 4.0) * 8.0;\n    time_in_riff *= iSampleRate;\n    time_in_riff = floor(time_in_riff / subsample_scale) * subsample_scale;\n    time_in_riff /= iSampleRate;\n\n    float prev_sound = play_note(prev_note, note_pos, time_in_riff, time_in_note) + play_note(prev_note / 2.0, note_pos, time_in_riff, time_in_note);\n    float curr_sound = play_note(curr_note, note_pos, time_in_riff, time_in_note) + play_note(curr_note / 2.0, note_pos, time_in_riff, time_in_note);\n    prev_sound *= 0.5;\n    curr_sound *= 0.5;\n\n    float prev_fade_time = 0.5;\n    //float sound = curr_sound;\n    float sound = mix(prev_sound, curr_sound, min(time_in_note, prev_fade_time) / prev_fade_time);\n\n    return sound;\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat get_heartbeat(float time) {\n    float x = mod(time * 6.0, 14.0);\n    // NOTE: This same equation with |floor| is broken on iOS.\n    return saturate(ceil(x - 2.0)) - saturate(x - 2.0) + saturate(ceil(x)) - saturate(x);\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    /*float subsample_scale = powabs(1.0 + abs(sin(time * 0.25)), 0.25) * 8.0;\n\ntime *= iSampleRate;\ntime = floor(time / subsample_scale) * subsample_scale;\ntime /= iSampleRate;*/\n\n    float real_time = time;\n\n    time = time * time_scale;\n\n    float sound;\n    float total_power = 0.0;\n    const int taps = 4;\n    float power = 1.0;\n    for (int i = 0; i < taps; i++) {\n        total_power += power;\n        sound += play_sound(time - float(i) * 1.0/3.0) * power;\n        power *= 0.3;\n    }\n    sound /= total_power;\n\n    //sound = mix(sound, mod(ValueNoise(vec2(real_time) * 50000.0), 1.0), 1.0 - random_flicker(real_time));\n    sound = mix(sound, 0.0, 1.0 - random_flicker(real_time));\n\n    float time_for_noise = floor(mod(real_time, 30.0) * iSampleRate * 2.4) / 2.4 / iSampleRate;\n    float noise_sound = mod(ValueNoise(vec2(time_for_noise * 5.0, time_for_noise * 5.0) * sin(real_time * 0.05) * 5000.0), 1.0);\n    sound = mix(sound, noise_sound, 0.025 + 0.02 * sin(real_time * 0.2));\n\n    #define GET_PREVIOUS_SAMPLE_TIME(time) ((time) - 1.0 / iSampleRate)\n    #define HEARTBEAT_PHASE(time) ((60.0 + get_heartbeat(time) * 0.0) * 2.0 * 3.14159 * mod((time) * 6.0 + 13.0, 14.0) / 6.0)\n\n    float heartbeat_amount = get_heartbeat(real_time + 0.0);\n    float heartbeat_phase = HEARTBEAT_PHASE(real_time + 0.0);\n    float heartbeat = clamp(sin(heartbeat_phase) * 1.25, -1.0, 1.0);\n\n    //float heartbeat = sin((heartbeat_amount * 10.0 + 80.0) * 2.0 * 3.14159 * real_time);\n    sound = mix(sound * 0.65, heartbeat, powabs(heartbeat_amount, 0.5));\n\n    //float sound = mix(prev_sound, curr_sound, min(time_in_note, prev_fade_time) / prev_fade_time);\n\n    //float initial_fade = min(time, 0.5);\n    float initial_fade = 10.0;\n    return vec2( \n        sound * min(powabs(time / initial_fade, 1.5), 1.0)//*exp(-3.0*time)\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}