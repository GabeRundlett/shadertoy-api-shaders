{
    "Shader": {
        "info": {
            "date": "1618516281",
            "description": "Sphere orbiting around another sphere. Early stuff, so poorly written and poorly commented. ",
            "flags": 0,
            "hasliked": 0,
            "id": "NdXXW8",
            "likes": 1,
            "name": "Distorted Orbit",
            "published": 3,
            "tags": [
                "distortion",
                "sphere",
                "cool"
            ],
            "usePreview": 0,
            "username": "nialred",
            "viewed": 218
        },
        "renderpass": [
            {
                "code": "struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Circle\n{\n    vec2 center;\n    float radius;\n};\n    \nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n\nint intersect_circle(in vec2 uv, in Circle circle)\n{    \n    vec2 distance = abs(uv - circle.center);\n    \n    float radius_check = length(distance);\n    \n    /*\n    // Could use this instead to get smooth edges between sphere and background\n    float difference = radius - radius_check;\n    float color = clamp(difference / fwidth(difference), 0., 1.);\n    fragColor = vec4(color, 0.0, 1.0 - color, 1.0);\n    */\n    \n    if (radius_check < circle.radius)\n    {\n        // Inside circle\n        return 1;\n    } \n    else\n    {\n        // Outside circle\n        return 0;\n    } \n}\n\nvec4 diffuse(in vec3 surface, in vec3 center, in vec4 color, in vec3 light_pos) {\n\t// Surface normal\n\tvec3 n = normalize(surface - center);\n\t\n\t// Light direction from surface\n\tvec3 l = normalize(light_pos - surface);\n\n\t// The diffuse equation\n\treturn color * max(0.0, dot(n, l));\n}\n\nfloat diffuse2(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(current_pos - light_pos);\n    \n    float intensity = max(0.0, dot(normal, light_dir));\n    \n    return intensity;\n}\n\nfloat intersect_sphere(in Ray ray, in Sphere sphere)\n{\n    // Sphere center to ray origin\n    vec3 co = (ray.origin - sphere.center);\n    \n    // The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance\n\tfloat discrim = dot(co, ray.direction) * dot(co, ray.direction) - \n                         (dot(co, co) - (sphere.radius * sphere.radius));\n    \n    if (discrim >= 0.0)\n    {\n        return -dot(ray.direction, co) - sqrt(discrim);\n    }\n    else\n    {\n        return -1.0;\n    }\n\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates\n    vec2 uv = fragCoord.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_norm = uv / iResolution.xy;\n    \n    /*\n    // Initialize circle object\n    Circle circle = Circle(vec2(iResolution.x / 2.0, iResolution.y / 2.0), 200.0);\n    \n    // Check if current pixel position is inside the circle\n    int hit_circle = intersect_circle(uv, circle);\n    \n    // Color the pixel accordingly\n    if (hit_circle == 1)\n    {\n        fragColor = vec4(uv_norm.x, uv_norm.y, 1.0, 1.0);\n    }\n    else \n    {\n        fragColor = vec4(0.25 * uv_norm.x, 0.25 * uv_norm.y, 0.25, 1.0);\n    }\n    */\n    \n    \n    // Shift the range from [0 1] to [-1 1]\n    vec2 uv_norm_shift = uv_norm * 2.0 - 1.0;\n    \n    // Pixel position in 3D space (screen is at a z value of 0)\n    vec3 pixel_pos = vec3(uv_norm_shift.x / (iResolution.y/iResolution.x), uv_norm_shift.y, 0.0);\n    \n    // Eye position is behind the screen somewhere (hence the -4 z value)\n    vec3 eye_pos = vec3(0.0, 0.0, -4.0);\n    \n    // Ray used to see if it intersects with sphere\n    vec3 ray_dir = normalize(pixel_pos - eye_pos);\n    \n    // Define sphere with 3D center and radius values\n    //Sphere sphere = Sphere(vec3(0.0, 0.0, 7.0), 1.0);\n    Sphere sphere = Sphere(vec3(sin(0.5*iTime)*2.0, 0.0, (cos(0.5*iTime)*5.0) + 5.0), 0.25);\n    Sphere sphere2 = Sphere(vec3(0.0, 0.0, 5.0), 1.0);\n    \n    // Define ray\n    Ray ray = Ray(eye_pos, ray_dir);\n    \n    float surf_dist = intersect_sphere(ray, sphere);\n    float surf_dist2 = intersect_sphere(ray, sphere2);\n    \n    vec3 point = eye_pos + (surf_dist * ray_dir);\n    vec3 point2 = eye_pos + (surf_dist2 * ray_dir);\n    \n    \n    float z_buff = point.z - point2.z;\n    \n    // Distortion \"frequency\"\n    float d = sin(dot(uv_norm_shift ,vec2(12.9898,78.233))) + cos(dot(uv_norm_shift ,vec2(12.9898,78.233))) + 5.0;\n    \n    // Distort the distance to surface \n    float dist_disp = sin(d * point.x) * sin(d * point.y) * sin(d * point.z);\n    float dist_disp2 = sin(0.0 * point2.x) * sin(0.0 * point2.y) * sin(0.0 * point2.z);\n    vec3 disp_point = eye_pos + ((surf_dist + dist_disp) * ray_dir);\n    vec3 disp_point2 = eye_pos + ((surf_dist2 + dist_disp2) * ray_dir);\n    \n    // Distort the location of the current point on the sphere\n    float point_disp = sin(d * point.x) * sin(d * point.y) * sin(d * point.z);\n    \n    // If positive, then we draw a pixel of the sphere\n\tif (surf_dist >= 0.0 && surf_dist2 >= 0.0)\n    {\n        if (z_buff > 0.0)\n        {\n            // Choose a diffuse color\n            vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n            // Choose an ambient color\n            vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n            // Position of a white light\n            vec3 light_pos = vec3(20.0, 10.0, -10.0);\n            \n            fragColor = ambient_col + diffuse(disp_point2, sphere2.center, diffuse_col, light_pos);\n        }\n        \n        else\n        {\n            // Choose a diffuse color\n            vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n            // Choose an ambient color\n            vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n            // Position of a white light\n            vec3 light_pos = vec3(20.0, 10.0, -10.0);\n        \n            fragColor = ambient_col + diffuse(disp_point, sphere.center, diffuse_col, light_pos);\n        }\n    }\n    \n    else if (surf_dist < 0.0 && surf_dist2 >= 0.0)\n    {\n        // Choose a diffuse color\n        vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n        // Choose an ambient color\n        vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n        // Position of a white light\n        vec3 light_pos = vec3(20.0, 10.0, -10.0);\n            \n        fragColor = ambient_col + diffuse(disp_point2, sphere2.center, diffuse_col, light_pos);\n     }\n     \n     else if (surf_dist >= 0.0 && surf_dist2 < 0.0)\n     {\n         // Choose a diffuse color\n        vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n        // Choose an ambient color\n        vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n        // Position of a white light\n        vec3 light_pos = vec3(20.0, 10.0, -10.0);\n        \n        fragColor = ambient_col + diffuse(disp_point, sphere.center, diffuse_col, light_pos);\n      }\n      \n      else\n      {\n          // Otherwise we draw the color of the background\n          fragColor = vec4(0.0, 0.0, 0.0, 1);\n      }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}