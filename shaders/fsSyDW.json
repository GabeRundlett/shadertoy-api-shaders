{
    "Shader": {
        "info": {
            "date": "1643493191",
            "description": "This shader calculates the force of gravity at each point/pixel of this texture.\nThe force is dependent on the position and mass of particles.\nThe denser the \"rings\" are, the stronger the gravity.",
            "flags": 0,
            "hasliked": 0,
            "id": "fsSyDW",
            "likes": 2,
            "name": "Gravity Heatmap",
            "published": 3,
            "tags": [
                "gravity",
                "heatmap"
            ],
            "usePreview": 0,
            "username": "GDur",
            "viewed": 240
        },
        "renderpass": [
            {
                "code": "//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c)\n{\n    vec3 m = mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0);\n    vec3 rgb = clamp(abs(m - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n\nfloat calculateGravityIntensity(in vec2 fragCoord, vec3[3] planets)\n{\n  // planet xy = coords\n  // planet z  = mass\n\n  float gravitationForce = 0.0;\n  for (int i = 0; i < 3; i++) {\n    vec3 p = planets[i];\n    vec2 diffVector = (p.xy - fragCoord);\n    float magnitudeSquared = dot(diffVector, diffVector);\n    // magnitude could be 0. Division by 0 is \"infinity\".\n    magnitudeSquared += .1;\n    float G = (sin(iTime/4.0) / 2.0 + 0.5)*.001;\n    // float G = 0.001 ;\n    gravitationForce -= (G * p.z) / (magnitudeSquared);\n  }\n  return gravitationForce;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float radius = length(iResolution.xy);\n  float massMultiplicator = radius * radius;\n\n  float sinT = 200.0 ; //* sin(iTime / 4.0);\n  float cosT = 200.0 ; //* cos(iTime / 4.0);\n  \n  vec3 planets[3];\n  planets[0] = vec3(iResolution.xy / 2.0, 9.0 * massMultiplicator);\n  planets[1] = vec3(iResolution.x / 2.0 + sinT * 2.0, iResolution.y / 2.0 + cosT * 1.5, 2.0 * massMultiplicator);\n  planets[2] = vec3(iResolution.x / 2.0 - sinT * 4.0, iResolution.y / 2.0, 13.0 * massMultiplicator);\n\n  float gravityIntensity = calculateGravityIntensity(fragCoord, planets);\n\n  // the force of gravity will have a huge range eg.: 1 to 10k\n  // here we use the tan function to let the colors repeat which creates the \"rings\"\n  // a lot of different variations would be possible\n  float max = 3.0;\n  float min = 1.0;\n  float gravitationForce = tan(gravityIntensity * 10.0) * 0.5;\n  if (gravitationForce < min) {\n    gravitationForce = min;\n  }\n  if (gravitationForce > max) {\n    gravitationForce = max;\n  }\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord / iResolution.xy * .8;\n  vec3 col2 = 0.5 + .5 * cos((iTime / 3.0 + gravitationForce) * .9 + uv.xyx + vec3(0, 2, 3));\n  fragColor = vec4(col2, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}