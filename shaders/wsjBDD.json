{
    "Shader": {
        "info": {
            "date": "1590104299",
            "description": "Julia revolute along Mandelbrot's cardioid.\n\nInspired by: \nhttps://twitter.com/matthen2/status/1262247041238839296\n \nThank you Patapom for the ref.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wsjBDD",
            "likes": 14,
            "name": "Julia Revolute on Cardioid",
            "published": 3,
            "tags": [
                "julia",
                "mandelbrot",
                "cardioid",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 580
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_DIST\t\t13.\n#define PI radians(180.)\n\nconst int maxIterations = 7;\nconst float majorRadius = 4.;\n\nvec3 pn;\n\nvec2 csqr(vec2 v)\n{\n    return vec2(v.x * v.x - v.y * v.y, 2. * v.x * v.y );\n}\n\n// Apparently from IQ\nfloat julia2d(vec2 z, vec2 c)\n{\n\tfloat k = 1., h = 1.;    \n    for (int i = 0;i < maxIterations; i++)\n    {\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.)\n            break;\n\t\tz = csqr(z) + c;\n    }\n\treturn sqrt(k / h) * log(k);\n}\n\nfloat map(vec3 p)\n{\n\tfloat\tt = atan(p.x, p.z) + iTime;\n    vec2\tc = vec2(0.5 * cos(t) - 0.25 * cos(2. * t), 0.5 * sin(t) - 0.25 * sin(2. * t));\t\t// Mendelbrot Cardioid\n    float\tr = length(p.xz) - majorRadius;\n    float\td = julia2d(vec2(r, p.y), c);\n\treturn  max(d, min(dot(p, pn), dot(p, pn * vec3(1, -1, -1))));\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    return col*col;\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 250; i++)\n  {\n    float h = sgn * map(ro + rd * t);\n    t += h * 0.4;\t\t\t\t\t\t// Perf killer :(\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float t = rayMarch(1., ro, rd, 1.5);\n    vec3\tcol = vec3(0.3);\n    if(t < MAX_DIST)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);   \n        col = texture(iChannel0, reflect(rd, n)).rgb;\n    }\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(vec3 color, float v)\n{\n    return mix(color, vec3(dot(color, color)), v);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n    col = desaturate(col, 0.5);\n\tcol = contrast(col, 1.2);\n\tcol = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n\t\t\t cos(a),\t0.0,\t\tsin(a),\n\t\t\t 0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(a),\t0.0,\t\tcos(a));\n}       \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    pn = rotY( 0.3 * (cos(iTime) + 1.) ) * vec3(0,0,1);\n    \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + PI;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) - 0.5;\n        vec3 ro = 7. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd);\n        \n\n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}