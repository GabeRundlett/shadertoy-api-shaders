{
    "Shader": {
        "info": {
            "date": "1718491767",
            "description": "Implemented \"Trivial Algorithm for Interactive Water Simulation\" \nShould be equivalent to https://www.shadertoy.com/view/WttBWj\nWill try to improve it later.",
            "flags": 32,
            "hasliked": 0,
            "id": "X3cSzr",
            "likes": 14,
            "name": "Trivial Water",
            "published": 3,
            "tags": [
                "water"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    //render the water depth\n    pos = floor(pos);\n    Water w = unpackWater(LOAD(ch0, pos), pos);\n    float terrh = (w.height - w.depth);\n    vec3 normal = terrainNormal(pos);\n    float d = max(0.0, dot(normalize(vec3(1,1,1)), normal));\n    vec4 terrain = 1.5*vec4(1,1,1,1) * d * (1.0 - 0.75*exp(-terrh));\n    fragColor = terrain * exp(-2.0*w.depth * vec4(1.000,0.302,0.000,1.0));\n    //fragColor += 4.0*w.flow;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    // Compute the new flow\n    pos = floor(pos);\n    Water w = unpackWater(LOAD(ch0, pos), pos);\n    Water wx0 = unpackWater(LOAD(ch0, pos + vec2(-1, 0)), pos + vec2(-1, 0));\n    Water wx1 = unpackWater(LOAD(ch0, pos + vec2(1, 0)), pos + vec2(1, 0));\n    Water wy0 = unpackWater(LOAD(ch0, pos + vec2(0, -1)), pos + vec2(0, -1));\n    Water wy1 = unpackWater(LOAD(ch0, pos + vec2(0, 1)), pos + vec2(0, 1));\n\n    float h0 = w.height;\n    vec4 hxy = vec4(wx0.height, wx1.height, wy0.height, wy1.height);\n    vec4 outflow = max(vec4(0.0), h0 - hxy);\n    const float K = 0.99;\n    const float P = 0.25;\n    w.flow = w.flow * K + outflow * P;\n\n    float localFlow = sum(w.flow);\n    if(localFlow > w.depth) //to prevent the depth from becoming negative\n    {\n        w.flow = w.flow * w.depth / localFlow;\n    }\n    \n    fragColor = packWater(w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n\nstruct Water\n{\n    vec4 flow;\n    float depth;\n    float height;\n};\n\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n\nfloat terrainHeight(vec2 pos)\n{\n    float h = perlinNoise(pos / 100.0, 1, 6, 0.4, 2.0, 3541u) * 1.0 + 2.0;\n    h -= 2.0*exp(-dot(pos - vec2(250),pos - vec2(250))/(150.0*150.0));\n    return h;\n}\n\nvec3 terrainNormal(vec2 pos)\n{\n    const float eps = 1.5;\n    vec3 n = vec3(terrainHeight(pos + vec2(eps, 0.0)) - terrainHeight(pos - vec2(eps, 0.0)),\n                  terrainHeight(pos + vec2(0.0, eps)) - terrainHeight(pos - vec2(0.0, eps)),\n                  1.0*eps);\n    return normalize(n);\n}\n\n//5 bits for shared exponent, 9 bits for each component\nuint packvec3(vec3 v)\n{\n    //get the exponent\n    float maxv = max(abs(v.x), max(abs(v.y), abs(v.z)));\n    int exp = clamp(int(ceil(log2(maxv))), -15, 15);\n    float scale = exp2(-float(exp));\n    vec3 sv = v*scale;\n    sv = round(clamp(sv, -1.0, 1.0) * 255.0);\n    sv = sv + 255.0;\n    uint packed = uint(exp + 15) | (uint(sv.x) << 5) | (uint(sv.y) << 14) | (uint(sv.z) << 23);\n    return packed;\n}\n\nvec3 unpackvec3(uint packed)\n{\n    int exp = int(packed & 0x1Fu) - 15;\n    vec3 sv = vec3((packed >> 5) & 0x1FFu, (packed >> 14) & 0x1FFu, (packed >> 23) & 0x1FFu);\n    vec3 v = (sv - 255.0) / 255.0;\n    v *= exp2(float(exp));\n    return v;\n}\n\nvec4 packWater(Water w)\n{\n    uint packed0 = packvec3(vec3(w.flow.xy, 0.0));\n    uint packed1 = packvec3(vec3(w.flow.zw, 0.0));\n    return vec4(uintBitsToFloat(packed0), uintBitsToFloat(packed1), w.depth, 0.0);\n}\n\nWater unpackWater(vec4 packed, vec2 pos)\n{\n    Water w;\n    w.flow.xy = unpackvec3(floatBitsToUint(packed.x)).xy;\n    w.flow.zw = unpackvec3(floatBitsToUint(packed.y)).xy;\n    w.depth = packed.z;\n    w.height = terrainHeight(pos) + w.depth;\n    return w;\n}\n\nfloat sum(vec4 v)\n{\n    return v.x + v.y + v.z + v.w;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    // Compute the new inertia\n    pos = floor(pos);\n    Water w = unpackWater(LOAD(ch0, pos), pos);\n    Water wx0 = unpackWater(LOAD(ch0, pos + vec2(-1, 0)), pos + vec2(-1, 0));\n    Water wx1 = unpackWater(LOAD(ch0, pos + vec2(1, 0)), pos + vec2(1, 0));\n    Water wy0 = unpackWater(LOAD(ch0, pos + vec2(0, -1)), pos + vec2(0, -1));\n    Water wy1 = unpackWater(LOAD(ch0, pos + vec2(0, 1)), pos + vec2(0, 1));\n    \n    vec4 incomingFlow = vec4(wx1.flow.x, wx0.flow.y, wy1.flow.z, wy0.flow.w);\n    float localFlow = sum(w.flow);\n    float adjacentFlow = sum(incomingFlow);\n    w.depth = max(w.depth - localFlow + adjacentFlow, 0.0);\n    w.flow = mix(w.flow, incomingFlow, 0.0); //tried to add advection, doesnt work well\n\n    if(iMouse.z > 0.0)\n    {\n        vec2 mpos = iMouse.xy;\n        vec2 d = mpos - pos;\n        float r = length(d);\n        w.depth += 0.5 * exp(-r * r / 100.0);\n    }\n    \n    if(pos.x < 1.0 || pos.x > iResolution.x - 2.0 || pos.y < 1.0 || pos.y > iResolution.y - 2.0)\n    {\n        w.depth = 0.0;\n    }\n    \n    fragColor = packWater(w);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}