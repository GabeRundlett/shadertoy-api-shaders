{
    "Shader": {
        "info": {
            "date": "1482768863",
            "description": "A small deferred rendering experiment (+ Tonemapping comparison)\nHad to simulate multiple render target in a dirty way :(\nWill shadertoy support multiple render target one day? :D \n\nUsing tonemapping functions from:\nhttps://www.shadertoy.com/view/lslGzl",
            "flags": 96,
            "hasliked": 0,
            "id": "ltyXRh",
            "likes": 15,
            "name": "deferred rendering test",
            "published": 3,
            "tags": [
                "rendering",
                "ramarching",
                "deferred"
            ],
            "usePreview": 1,
            "username": "kloumpt",
            "viewed": 1541
        },
        "renderpass": [
            {
                "code": "//#define iTime 0.0\n\nfloat czm_luminance(vec3 rgb) {\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n\nvec3 tonemapReinhard(vec3 color) {\n  float l = czm_luminance(color);\n  return color  * l / (l + 1.0);\n}\n\n\n\nfloat A = 0.15;\nfloat B = 0.50;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.02;\nfloat F = 0.30;\nfloat W = 11.2;\n\nvec3 Uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\n\nvec3 tonemapUncharted(vec3 color) {\n   color *= 1.0;  // Hardcoded Exposure Adjustment\n\n   float ExposureBias = 2.0;\n   vec3 curr = Uncharted2Tonemap(ExposureBias * color);\n\n   vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\n   color = curr*whiteScale;\n      \n   return color;\n}\n\n\n\n\n\nvec3 toGamma(vec3 color, float gamma) {\n    return pow(color, vec3(1.0 / gamma));\n}\n\n\n\n\n\nfloat gamma = 2.2;\n\n\nvec3 linearToneMapping(vec3 color)\n{\n\tfloat exposure = 1.;\n\tcolor = clamp(exposure * color, 0., 1.);\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n\tfloat exposure = 1.5;\n\tcolor *= exposure/(1. + color / exposure);\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 RomBinDaHouseToneMapping(vec3 color)\n{\n    color = exp( -1.0 / ( 2.72*color + 0.15 ) );\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\n\n    // May be very wrong? :))))\n    color = toGamma(color, 1./3.0);\n    color = toGamma(color, gamma);\n    \n\treturn color;\n}\n\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 s = vec4(0.5/iResolution.xy, -0.5/iResolution.x, 0.0);\n\n    \n   \tvec3 final_color = texture(iChannel0, uv).rgb;\n    \n    float exposure = 1.0 + 1.0 + 0.0*floor(mod(iTime * 0.25, 9.0));\n    final_color *= exposure;\n\n    vec3 color = final_color;\n\n    // Stolen from https://www.shadertoy.com/view/lslGzl\n    // with the tonemapping functions\n    float n = 8.0;\n    int i = int(n * (1. - uv.x));\n    i = 6;\n    if (i == 1) color = linearToneMapping(color);\n    if (i == 2) color = simpleReinhardToneMapping(color);\n    if (i == 3) color = lumaBasedReinhardToneMapping(color);\n    if (i == 4) color = whitePreservingLumaBasedReinhardToneMapping(color);\n    if (i == 5) color = RomBinDaHouseToneMapping(color);\t\t\n    if (i == 6) color = filmicToneMapping(color);\n    if (i == 7) color = Uncharted2ToneMapping(color);\n\n    final_color = color;\n \n    \n    \n    \n    \n    fragColor = vec4(final_color, 1.0);\n    \n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 6609,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/tomanka/caravela"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define iTime 0.0\n/*\n * Shapes ops \n */\n\n// Sphere - signed - exact\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n// Box - signed - exact\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\t\n// Torus - signed - exact\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\t\n// Cylinder - signed - exact\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\t\n// Cone - signed - exact\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\t\n// Plane - signed - exact\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\t\n// Hexagonal Prism - signed - exact\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\t\n// Triangular Prism - signed - exact\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\t\n// Capsule / Line - signed - exact\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\t\n// Capped cylinder - signed - exact\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\t\n// Capped Cone - signed - bound\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n\t\n// Ellipsoid - signed - bound\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n\t\n// Triangle - unsigned - exact\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\t\n// Quad - unsigned - exact\n//float dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n\t\n\n\n/*\n * Boolean ops \n */\n\n// Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n\t\t\n// Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\t\t\n// Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n\t\t\n\n\n\n\n/*\n * Domain operations\n */\n\n// Repetition\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    //return primitve( q );\n    return q;\n}\n\n\t\t\n// Rotation/Translation\nvec3 opTx( vec3 p, mat4 m )\n{\n    return  (m * vec4(p, 1.0)).xyz;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\n// Scale\n/*\nfloat opScale( vec3 p, float s )\n{\n    return primitive(p/s)*s;\n}\n*/\n\n// Camera definition\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat map(vec3 p);\n\t\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 30.0;\n   \n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (10.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>10.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) return vec2(t, 0);\n    return vec2(t, 1);\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\nvec4 render( in vec3 ro, in vec3 rd ) {\n    vec2 res = castRay(ro,rd);\n    \n    float t = res.x;\n    float m = res.y;\n    vec3 pos = ro + t*rd;\n    if( m == 1.0 ) {        \n        return vec4(pos, calcAO(pos, calcNormal(pos)));\n\n    }\n\n\treturn vec4(-1000.0, -1000.0, -1000.0, map(pos));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n    // camera\t\n    float cam_rot = 3.1415 * (mo.x * 2.0 + 0.85);\n    vec3 ro = vec3(cos(cam_rot) * 4.0 * (0.8 - mo.y), 1.75, sin(cam_rot) * 4.0 * (0.8 - mo.y)) * 1.5;\n    vec3 ta = vec3( -0.5, 1.5, 0.5 ) ;\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    if (fragCoord.y <= 2.0) {\n        if ( fragCoord.x  <= 2.0) {\n            fragColor = vec4(ro, 0);\n            return;\n            \n        }\n        \n        if (fragCoord.x  <= 4.0) {\n            fragColor = vec4(ta, 0);\n            return;\n\n        }\n        \n    }\n    \n    // render\t\n    vec4 col = render( ro, rd );\n\n\t\t\n\n    \n    fragColor = col;\n}\n\n\nfloat opU_v2(float a, float b, float s) {\n    return min(min(a, b), length(vec2(a, b)) - s);\n}\n\nfloat map(vec3 p) {\n    float d = sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0));\n    \n    float rot_x = iTime * 3.1415 * 0.2;\n    float cx = cos(rot_x);\n    float sx = sin(rot_x);\n    \n    float rot_z = iTime * 3.1415 * 0.125;\n    float cz = cos(rot_z);\n    float sz = sin(rot_z);\n    \n    p = vec3(\n        p.x,\n        p.y * cx - p.z * sx,\n        p.z * cx + p.y * sx\n    );\n    \n    p = vec3(\n        p.x * cz - p.y * sz,\n        p.y * cz + p.x * sz,\n        p.z\n    );\n    \n    d = opU(d, sdBox(p - vec3(0.0, 1.5, -1.5), vec3(1.6, 1.5, 0.1)));\n    d = opU(d, sdBox(p - vec3(1.5, 1.5, -0.25), vec3(0.1, 0.75, 2.25)));\n    \n    d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75, 0.75, -0.75), vec3(0.75 - 0.025)) - 0.025, 0.1));\n    //d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75 * 3.0, 0.75, -0.75 * 3.0), vec3(0.75)) - 0.025));\n    \n    return d;\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define iTime 0.0\n/*\n * Shapes ops \n */\n\n// Sphere - signed - exact\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n// Box - signed - exact\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\t\n// Torus - signed - exact\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\t\n// Cylinder - signed - exact\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\t\n// Cone - signed - exact\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\t\n// Plane - signed - exact\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\t\n// Hexagonal Prism - signed - exact\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\t\n// Triangular Prism - signed - exact\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\t\n// Capsule / Line - signed - exact\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\t\n// Capped cylinder - signed - exact\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\t\n// Capped Cone - signed - bound\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n\t\n// Ellipsoid - signed - bound\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n\t\n// Triangle - unsigned - exact\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\t\n// Quad - unsigned - exact\n//float dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n\t\n\n\n/*\n * Boolean ops \n */\n\n// Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n\t\t\n// Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\t\t\n// Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n\t\t\n\n\n\n\n/*\n * Domain operations\n */\n\n// Repetition\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    //return primitve( q );\n    return q;\n}\n\n\t\t\n// Rotation/Translation\nvec3 opTx( vec3 p, mat4 m )\n{\n    return  (m * vec4(p, 1.0)).xyz;\n}\n\n\nfloat map(vec3 p);\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 ro = texture(iChannel0, vec2(0.0, 0.0)).xyz;\n   \n    vec4 hit = texture(iChannel0, uv);\n    vec3 normal = vec3(0.0);\n    if (hit.xyz == vec3(-1000.0)) {\n\t\tfragColor = vec4(vec3(0.0), hit.w);\n    }\n    fragColor = vec4(calcNormal(hit.xyz), distance(ro, hit.xyz));\n}\n\n\n\nfloat opU_v2(float a, float b, float s) {\n    return min(min(a, b), length(vec2(a, b)) - s);\n}\n\nfloat map(vec3 p) {\n    float d = sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0));\n    \n    float rot_x = iTime * 3.1415 * 0.2;\n    float cx = cos(rot_x);\n    float sx = sin(rot_x);\n    \n    float rot_z = iTime * 3.1415 * 0.125;\n    float cz = cos(rot_z);\n    float sz = sin(rot_z);\n    \n    p = vec3(\n        p.x,\n        p.y * cx - p.z * sx,\n        p.z * cx + p.y * sx\n    );\n    \n    p = vec3(\n        p.x * cz - p.y * sz,\n        p.y * cz + p.x * sz,\n        p.z\n    );\n    \n    d = opU(d, sdBox(p - vec3(0.0, 1.5, -1.5), vec3(1.6, 1.5, 0.1)));\n    d = opU(d, sdBox(p - vec3(1.5, 1.5, -0.25), vec3(0.1, 0.75, 2.25)));\n \n    d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75, 0.75, -0.75), vec3(0.75 - 0.025)) - 0.025, 0.1));\n    //d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75 * 3.0, 0.75, -0.75 * 3.0), vec3(0.75)) - 0.025));\n    \n    return d;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define iTime 0.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 depth_and_normal = texture(iChannel1, uv);\n    \n    vec3 hit = texture(iChannel0, uv).xyz;\n    \n    vec3 color = vec3(0.0);\n    \n    if (depth_and_normal.xyz == vec3(0.0) ) {\n    \tfragColor = vec4(0.0);\n    } else  {\n        \n        vec2 scale = vec2(1.5, 0.5) * 0.50;\n        if (hit.y <= 0.0125){\n            fragColor = mix(vec4(1.0), texture(iChannel2, hit.zx * scale), 0.9) * vec4(1.0, 0.5, 0.25, 1.0);\n        } else {\n            vec3 p = hit;\n            \n\n            float rot_x = iTime * 3.1415 * 0.2;\n            float cx = cos(rot_x);\n            float sx = sin(rot_x);\n\n            float rot_z = iTime * 3.1415 * 0.125;\n            float cz = cos(rot_z);\n            float sz = sin(rot_z);\n\n            p = vec3(\n                p.x,\n                p.y * cx - p.z * sx,\n                p.z * cx + p.y * sx\n            );\n\n            p = vec3(\n                p.x * cz - p.y * sz,\n                p.y * cz + p.x * sz,\n                p.z\n            );\n            \n            \n            fragColor = mix(vec4(1.0), texture(iChannel2, p.xz * scale), 0.9);\n            //fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    }\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define iTime 0.0\n/*\n * Shapes ops \n */\n\n// Sphere - signed - exact\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n// Box - signed - exact\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\t\n// Torus - signed - exact\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\t\n// Cylinder - signed - exact\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\t\n// Cone - signed - exact\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\t\n// Plane - signed - exact\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\t\n// Hexagonal Prism - signed - exact\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\t\n// Triangular Prism - signed - exact\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\t\n// Capsule / Line - signed - exact\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\t\n// Capped cylinder - signed - exact\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\t\n// Capped Cone - signed - bound\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n\t\n// Ellipsoid - signed - bound\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n\t\n// Triangle - unsigned - exact\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\t\n// Quad - unsigned - exact\n//float dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n\t\n\n\n/*\n * Boolean ops \n */\n\n// Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n\t\t\n// Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\t\t\n// Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n\t\t\n\n\n\n\n/*\n * Domain operations\n */\n\n// Repetition\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    //return primitve( q );\n    return q;\n}\n\n\t\t\n// Rotation/Translation\nvec3 opTx( vec3 p, mat4 m )\n{\n    return  (m * vec4(p, 1.0)).xyz;\n}\n\n\n\n\nfloat map(vec3 p);\n\n\nstruct Light {\n    vec3 p;\n    float r;\n    vec3 c;\n};\n\n\nLight lights[5];\n\nvec3 ambiant_light_color = vec3(0.1, 0.9, 1.0) * 0.0015;\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n#define T(l) textureLod(iChannel3,U/256.,l)\n\nfloat mask(vec2 p) { // see https://www.shadertoy.com/view/ldyXDd\n#define DMUL  8.12235325   \n#define SIZE  5.5\n    vec2 U = floor(p/SIZE)*SIZE;\n    p += ( T(0.).xy - .5 ) *DMUL;\n    return fract( p.x*1.705 + p.y*.5375 ); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tlights[0] = Light(vec3(-3.0,  5.0,  0.0), 10.0, vec3(1.0, 0.25, 0.25));\n\tlights[1] = Light(vec3( 0.0,  5.0, -3.0), 10.0, vec3(0.5, 1.0, 0.25));\n\tlights[2] = Light(vec3( 0.0,  5.0,  3.0), 10.0, vec3(0.5, 0.25, 1.0));\n\tlights[3] = Light(vec3( 3.0,  5.0,  0.0), 10.0, vec3(0.25, 1.0, 1.0));\n\tlights[4] = Light(vec3( 5.0,  15.0,  -9.0), 35.0, vec3(1.0, 1.0, 0.5));\n    \n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n\n    vec3 camera_pos = texture(iChannel0, vec2(0.0, 0.0)).rgb;\n    \n    vec4 hit_and_ao = texture(iChannel0, uv);\n    vec4 depth_and_normal = texture(iChannel1, uv);\n    vec4 color_rgba = texture(iChannel2, uv);\n    \n    \n    \n    vec3 hit = hit_and_ao.xyz;\n    vec3 ray_dir = normalize(hit - camera_pos);\n    \n    float ao = hit_and_ao.w;\n    vec3 color = color_rgba.rgb;\n    float depth = depth_and_normal.w;\n    vec3 normal = depth_and_normal.xyz;\n    \n    \n    vec3 final_color = vec3(0.0, 0.0, 0.0);\n    \n    if (color_rgba.a == 0.0) {\n        final_color = ambiant_light_color / 0.15;\n    } else {\n\n        float rot = iTime + 0.2;\n        float cr = cos(rot);\n        float sr = sin(rot);\n        final_color += color * ambiant_light_color;\n        for (int i = 0; i < 4; i++) {\n            \n        if (i == 0) {\n            //cr = 1.0;\n            //sr = 1.0;\n        }\n            lights[i].p = vec3(lights[i].p.x * cr - lights[i].p.z * sr, lights[i].p.y, lights[i].p.z * cr + lights[i].p.x * sr);\n            vec3 light_dir = -normalize(hit - lights[i].p); \n            float dist = distance(hit, lights[i].p);\n            \n            float shininess = 4.0;\n\n            float lambertian = dot(light_dir, normal);\n            float specular = 0.0;\n\n            if(lambertian > 0.0) {\n\n                // this is blinn phong\n                vec3 half_dir = normalize(light_dir + ray_dir);\n                float specAngle = max(dot(half_dir, normal), 0.0);\n                specular = pow(specAngle, shininess);\n\n            }\n            final_color += (\n                smoothstep(-0.25, 1.0, lambertian) *  lights[i].c * color +\n                specular * lights[i].c * vec3(1.0) \n            ) * smoothstep(lights[i].r, 0.0, dist) * (0.1 + 0.9 * softshadow(hit, light_dir, 0.02 + 0.02 * mask(fragCoord.xy + iTime * 1000.0), dist));\n            \n            \n              \n                \n                \n        }\n        \n        \n        final_color *= mix(1.0, ao, 0.75) ;\n        \n        //final_color = mix(final_color, final_color*0.5  + vec3(0.25), 0.0 * smoothstep(5.0, 10.0, depth));\n\n    }\n    \n    \n    fragColor = vec4(final_color.rgb, 1.0);\n}\n\n\n\nfloat opU_v2(float a, float b, float s) {\n    return min(min(a, b), length(vec2(a, b)) - s);\n}\n\nfloat map(vec3 p) {\n    float d = sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0));\n    \n    float rot_x = iTime * 3.1415 * 0.2;\n    float cx = cos(rot_x);\n    float sx = sin(rot_x);\n    \n    float rot_z = iTime * 3.1415 * 0.125;\n    float cz = cos(rot_z);\n    float sz = sin(rot_z);\n    \n    p = vec3(\n        p.x,\n        p.y * cx - p.z * sx,\n        p.z * cx + p.y * sx\n    );\n    \n    p = vec3(\n        p.x * cz - p.y * sz,\n        p.y * cz + p.x * sz,\n        p.z\n    );\n    \n    d = opU(d, sdBox(p - vec3(0.0, 1.5, -1.5), vec3(1.6, 1.5, 0.1)));\n    d = opU(d, sdBox(p - vec3(1.5, 1.5, -0.25), vec3(0.1, 0.75, 2.25)));\n     \n    d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75, 0.75, -0.75), vec3(0.75 - 0.025)) - 0.025, 0.1));\n    //d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75 * 3.0, 0.75, -0.75 * 3.0), vec3(0.75)) - 0.025));\n    \n    return d;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}