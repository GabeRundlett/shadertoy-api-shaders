{
    "Shader": {
        "info": {
            "date": "1681373130",
            "description": "I've had the idea to store colors in the blue channel and the velocity of pixels in the red and green channels (for X and Y, respectively) and while I ran into many issues I had not considered, I think it still came out well",
            "flags": 32,
            "hasliked": 0,
            "id": "msyXR3",
            "likes": 1,
            "name": "weird fluid sim type thing",
            "published": 3,
            "tags": [
                "2d",
                "simulation"
            ],
            "usePreview": 1,
            "username": "oatmealine",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(float2rgb(texture(iChannel0, uv).b), 1.0);\n    //fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SEARCH_RANGE 10\n#define DAMPING 0.8\n#define SEARCH_WEIGHT 1.2\n\nfloat hash(vec2 p){\n  return fract(1e4*sin(17.*p.x+p.y*0.1)*(0.1+abs(sin(p.y*13.+p.x))));\n}\n\nfloat noise(vec2 x){\n  vec2 f = fract(x);\n  vec2 i = x-f;\n\tfloat a = hash(i);\n\tfloat b = hash(i+vec2(1.,0.));\n\tvec2 u = f*f*(3.-2.*f);\n\treturn mix(a,b,u.x)+((hash(i+vec2(0.,1.))-a)*(1.-u.x)+(hash(i+1.)-b)*u.x)*u.y;\n}\n\nfloat fbm(vec2 p){\n  float value = 0.;\n  float freq = 1.;\n  float amp = 0.5;\n  for (int i=0; i<5; i++) {\n    value += amp*(noise((p-1.)*freq));\n    freq *= 1.9;\n    amp *= 0.6;\n  }\n  return value;\n}\n\nvec3 noiseTimeBabey(vec2 uv) {\n    return vec3(\n        hash(uv + vec2(iTime, -iTime)),\n        hash(uv + vec2(iTime * 0.5, iTime)),\n        hash(uv + vec2(-iTime, -iTime))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (\n        iTime < 1.0 ||\n        (iMouse.z > 1.0 && abs(iMouse.x - fragCoord.x) < 32.0 && abs(iMouse.y - fragCoord.y) < 32.0)\n    ) {\n        fragColor = vec4(noiseTimeBabey(fragCoord.xy / iResolution.xy), 1.0);\n    } else {\n        vec2 thisUV = fragCoord / iResolution.xy;\n        float dt = iTimeDelta;\n        \n        // calculate Wind\n        float windAngle = fbm(vec2(thisUV.x + iTime * 0.3, thisUV.y - iTime * 0.3));\n        vec2 windVel = vec2(cos(windAngle * PI * 2.0), sin(windAngle * PI * 2.0)) * dt;\n        \n        // search in a range for potential collissions\n        vec3 accumCol = vec3(0.0, 0.0, 0.0);\n        vec2 accumVel = vec2(0.0, 0.0);\n        float accumWeight = 0.0;\n\n        for (int x = -SEARCH_RANGE; x <= SEARCH_RANGE; x++) {\n            for (int y = -SEARCH_RANGE; y <= SEARCH_RANGE; y++) {\n                vec2 uv = (fragCoord + vec2(float(x), float(y))) / iResolution.xy;\n                vec3 data;\n                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n                  data = noiseTimeBabey(uv);\n                } else {\n                  data = texture(iChannel1, uv).rgb;\n                }\n                \n                // extract data\n                vec2 vel = data.rg;\n                vec3 col = float2rgb(data.b);\n                \n                // predict next pos\n                vec2 pos = clamp(uv + vel * dt, 0.0, 1.0);\n                // dampen velocity\n                vel *= pow(DAMPING, dt);\n                \n                // calculate a \"weight\" of sorts of how much the pixel's new position\n                // would overlap with ours\n                float dist = length(pos - thisUV);\n                float weight = 1.0 - (smoothstep(0.0, SEARCH_WEIGHT, dist) / SEARCH_WEIGHT);\n                \n                // add onto our accumulator\n                accumCol += col * weight;\n                accumVel += vel * weight;\n                accumWeight += weight;\n            }\n        }\n        \n        if (accumWeight > 0.0) {\n            // average\n            vec3 col = accumCol / accumWeight;\n            vec2 vel = accumVel / accumWeight;\n            // add wind vel\n            vel += windVel;\n\n            // output\n            fragColor = vec4(vec3(vel.x, vel.y, rgb2float(col)), 1.0);\n        } else {\n            fragColor = vec4(vec3(windVel.x, windVel.y, rgb2float(noiseTimeBabey(thisUV))), 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.14159\n\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n#endif\n\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\nvec3 float2rgb(float h) {\n    return hue2rgb(h);\n}\nfloat rgb2float(vec3 c) {\n\tfloat cMax=max(max(c.r,c.g),c.b),\n\t      cMin=min(min(c.r,c.g),c.b),\n\t      delta=cMax-cMin;\n\tvec3 hsv=vec3(0.,0.,cMax);\n\tif(cMax>cMin){\n\t\tif(c.r==cMax){\n\t\t\thsv.x=(c.g-c.b)/delta;\n\t\t}else if(c.g==cMax){\n\t\t\thsv.x=2.+(c.b-c.r)/delta;\n\t\t}else{\n\t\t\thsv.x=4.+(c.r-c.g)/delta;\n\t\t}\n\t\thsv.x=fract(hsv.x/6.);\n\t}\n\treturn hsv.x;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}