{
    "Shader": {
        "info": {
            "date": "1582404486",
            "description": "Trying to render spectral colors into screen space with as little desaturation as possible given the white-level, and no color banding.\nMouse and Top/bottom: see description in source.\nHow best to fix the banding that shows up for violet?",
            "flags": 0,
            "hasliked": 0,
            "id": "wtGXzm",
            "likes": 19,
            "name": "Spectral color tonemap",
            "published": 3,
            "tags": [
                "spectrum",
                "light",
                "color",
                "perception",
                "tonemap"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 988
        },
        "renderpass": [
            {
                "code": "/*\nhttps://www.shadertoy.com/view/wtGXzm\n\nSpectral tonemap (closest sRGB approximation without banding)\n\nTrying to render spectral colors into screen space with as little desaturation\nas possible given the white-level, and no color banding.\n\n\nMouse: plot R,G,B and Luminance at a horizontal slice through the image.\nHorizontal lines: limits (0 and 1)\n\nTop: Just enough white added so that color-matching RGB values are nonnegative.\nBottom: No white added, negative values get handled by tonemap.\nIn-between: gradient of white.\n\n\n*/\n\n// srgbl - linear srgb\nvec3 wavelength_to_srgbl (float l_nm ) {\n    if (l_nm<370.||l_nm>780.) return vec3(0.);\n    vec4 l = vec4(1.065, 1.014, 1.839, 0.366);\n    vec4 c = vec4(593.,556.3,449.8, 446.);\n    vec4 s = vec4(.056,.075,.051, .043);\n    if (l_nm<446.) s.a = 0.05; // fix creep from violet back to blue\n    vec4 v = (log(l_nm)-log(c))/s;\n    vec4 xyzx = l*exp(-.5*v*v);\n    vec3 xyz = xyzx.xyz+vec3(1,0,0)*xyzx.a;\n    const mat3 xyz_to_rgb = \n      mat3(3.240,-.969,.056, -1.537,1.876,-.204, -0.499,0.042,1.057);\n    vec3 rgb = xyz_to_rgb*xyz;\n    return rgb;\n}\n\nfloat rgb_to_lum (vec3 v) {\n  vec3 w = vec3(.213,.715,.072);\n  return dot(w,v);\n}\n\nvec3 rgb_to_hue (vec3 v) {\n  vec2 hv = mat3x2( 1., 0., -.5, .866, -.5,-.866) * v;\n  float h = atan(hv.y,hv.x);\n  v = .5+.5*cos(h-vec3(0,1,2)/3.*2.*pi);\n  v -= -log(dot(vec3(1.),exp(-v*10.)))/10.;\n  v/=rgb_to_lum(v);\n  return v;\n}\n\nfloat rgb_to_sat (vec3 v) {\n  v/=rgb_to_lum(v);\n  vec3 h = rgb_to_hue(v);\n  if (any(isnan(h))) return 0.;\n  // doesn't matter which component of (1-v)/(1-h) is used!\n  return dot(vec3(1./3.), (1.-v)/(1.-h) );\n}\n\nvec3 tonemap (vec3 color) {\n  vec3  hue = rgb_to_hue(color);\n  float sat = rgb_to_sat(color);\n  float lum = rgb_to_lum(color);\n\n  // smooth-clamp\n  sat = -log(exp(-sat*10.)+exp(-10.))/10.;\n\n  /* tonemapping options:\n       - desaturate when very bright\n       - smooth-clamp brightness to a maximum that still\n          allows some color variation                              */\n  // sat = sat*(exp(-lum*lum*2.));\n  // lum = .8*(1.-exp(-lum));\n\n  color = lum*mix(vec3(1.),hue,sat);\n  return color;\n}\n\nvec3 testcolor(float x, float l_nm) {\n  vec3 color1 = (wavelength_to_srgbl(l_nm)+.85)*.3; // no negative values\n  vec3 color2 = wavelength_to_srgbl(l_nm)*.3;       // no white background\n  vec3 color = mix(color2,color1,x*x*x*x);\n\n  color = tonemap(color);\n#if 0\n  // hack - closer to appearance of desired result (still not ideal)\n  color1 = tonemap(color1);\n  color2 = tonemap(color2);\n  color = mix(color2,color1,x*x*x*x);\n#endif\n  return color;\n}\n\nvec3 srgbl_to_srgb (vec3 linearRGB);\nvec3 dither (vec2 fc);\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord ) {\n  vec2 mouse = iMouse.xy/iResolution.xy;  \n  vec2 R = iResolution.xy;\n  vec2 uvr = fragCoord/R;\n  \n  // Always initialize all variables.\n  fragData = vec4(0.);\n  // Start all black\n  vec3 color = vec3(0.);\n  \n  float l_nm = fragCoord.x/iResolution.x*500.+300.;\n  color = testcolor(uvr.y,l_nm);\n  \nif (iMouse.z>0.) {\n  mat2 window = mat2(0,0,iResolution.xy);\n  mat2 domain = mat2(300, -.1,800, 1.1);\n  float slice = iMouse.y/iResolution.y;\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, vec3(0.1), 0, 0, 1., 0. );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, vec3(0.0), 0, 0, 1., 1. );\n  \n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*vec3(1,0,0), 0, 0, 1., testcolor(slice,x).x );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*vec3(0,1,0), 0, 0, 1., testcolor(slice,x).y );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*vec3(0,0,1), 0, 0, 1., testcolor(slice,x).z );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*vec3(1,1,1), 0, 0, 1., rgb_to_lum(testcolor(slice,x)) );\n  PLOT_CONTINUOUS(color, fragCoord, window, domain, .8*(.5+.5*cos(uvr.x*4e2+vec3(0,2,4))), 0, 0, 1., rgb_to_sat(testcolor(slice,x)) );\n    \n}\n  \n  // demonstrate that there isn't clipping\n  if (any(lessThan(color,vec3(-1e-5)))) color = vec3(1);\n  if (any(greaterThan(color,vec3(1.+1e-5))) ) color = vec3(0);\n\n  fragData.rgb = srgbl_to_srgb(color);\n  fragData.rgb += dither(fragCoord);\n}\n\nvec3 srgbl_to_srgb(vec3 linearRGB) {\n  // https://www.shadertoy.com/view/4tXcWr\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\n\treturn mix(higher, lower, cutoff);\n}\n\nuint triple32(uint x) {\n    // https://www.shadertoy.com/view/WttXWX\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvec3 dither (vec2 fc) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(c.x+(c.y<<10)+(uint(iFrame)<<20));\n  uvec3 h = (uvec3(z)>>uvec3(0,8,16))&0xFFu;\n  return vec3(ivec3(h)-128)/128./256.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Expression Plotter by ttg https://www.shadertoy.com/view/3t3XWf\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n\nconst float pi = 3.1415927;\n\nvec2 compsin (float x) { return vec2(cos(x),sin(x)); }\nfloat sinc (float x) { return abs(x)<1e-4?1.:sin(x)/x; }\n\nfloat minv (vec3 v) { return min(min(v.x,v.y),v.z); }\nfloat maxv (vec3 v) { return max(max(v.x,v.y),v.z); }\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}