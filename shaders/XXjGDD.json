{
    "Shader": {
        "info": {
            "date": "1710082107",
            "description": "Modified Perlin noise to tile in a triangular grid. It only has 3 samples per octave instead of the usual 4. \nThis is inspired by \"Pattern-Based Texturing Revisited\" by Fabrice Neyret and Marie-Paule Cani [url]https://hal.science/inria-00537511v1[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "XXjGDD",
            "likes": 9,
            "name": "Triangular Tiling Perlin Noise",
            "published": 3,
            "tags": [
                "noise",
                "triangle",
                "hexagon",
                "square",
                "barycentric",
                "tiling",
                "hex",
                "tile",
                "tri",
                "bary",
                "cardinal"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 333
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis demo generates Perlin noise using a triangular grid instead of the typical square \ngrid. While it currently looks very different from Perlin noise, simply decrease the \nCONTRAST to ~2.0, and it will resemble the bilinear Perlin noise you're familiar with.\n\nWhile inspired by \"Pattern-Based Texturing Revisited\" by Fabrice Neyret and Marie-Paule \nCani (https://hal.science/inria-00537511v1), it's important to note that this \nimplementation deviates from the instructions and includes several variations of the \noriginal idea presented in the paper. So don't take this version as gospel.\n\nThe demo features mouse controls for zooming along the y-axis and controlling rotation \nalong the x-axis. Additionally, all pertinent parameter constants are provided below, \nallowing you to adjust the resulting noise or modify debug settings.\n\nFor a more practical cardinal tiling solution, check out my cardinal tiling: \nhttps://www.shadertoy.com/view/lcBSRG\n\nTriangle Perlin also works in 3D with tetrahedra. You can use the 4-sample Rhombic \nDodecahedron Tiling shown here: \nhttps://www.shadertoy.com/view/mlBczy\n*/\n\n// Size of the noise cells, value range is 1 to infinity\n#define GRIDSIZE 5.0\n\n// Number of noise layers, value range is 1 to infinity\n#define OCTAVES 5\n\n// Scaling of successive octaves, value range is 1 to infinity\n#define LACUNARITY 2.0\n\n// Amplitude reduction of each successive octave, value range is 0 to 1\n#define PERSISTENCE 0.5\n\n// 1 no contrast, higher values increase contrast, ~2 is vanilla Perlin\n#define CONTRAST 20.0\n\n// Enable repeating Tiling.\n// 0 = No tiling\n// 1 = Square Tiling\n// 2 = Single Triangle Tiling\n// 3 = Single Triangle Tiling with unique centers\n// 4 = Double Triangle Tiling\n// 5 = Double Triangle Tiling with unique centers (mostly Fabrice's)\n#define TILING 5\n\n// Enable for equal-sided triangle, otherwise right triangles useful for baking 2 \n// triangles into a square texture\n#define EQUAL\n\n// Enable to add lines for the grid outlines\n#define SHOWGRID\n#define THICKNESS 0.004\n\n// Constants \n#define HALF_ROOT3      0.8660254038\n#define QUARTER_ROOT3   0.4330127019\n#define ONE_OVER_ROOT3  0.5773502692\n#define TWO_OVER_ROOT3  1.1547005384\n#define HALF_OVER_ROOT3 0.2886751346\n#define TRIANGLE_MAT    mat2(1, ONE_OVER_ROOT3, 0, TWO_OVER_ROOT3)\n#define TWO_PI          6.2831853072\n\n// Helper Function for Perlin noise\nfloat rndGradient(vec2 id, vec2 grid, vec2 offset, uint gridsize, uvec2 seed) {\n\n    // Current cell coordinates\n    vec2 localID = id + offset;\n    vec2 localGrid = grid - offset;\n\n    #if TILING == 1\n        // Repeat along the edges of a square\n        localID = mod(localID, float(gridsize)); \n    #endif\n    \n    #if TILING > 1\n        // Repeat along the edges of a square\n        vec2 repeatingID = mod(localID, float(gridsize)); \n\n        // Calculate the centered coordinates\n        vec2 centeredID = (repeatingID - float(gridsize) * 0.5) * 2.;\n\n        // Mirror the coordinates along the centered xy axis\n        vec2 mirrorID = abs(centeredID);\n        \n        #if TILING == 2 || TILING == 3\n            // Mirror outer sqare edges\n            vec2 mirroredID = mirrorID.x > mirrorID.y ? mirrorID.xy : mirrorID.yx;\n\n            // Mirror along the lower left to upper right axis\n            mirroredID = repeatingID.x != repeatingID.y ? mirroredID : \n                                              vec2(float(gridsize), mirroredID.y);\n        \n        #else\n            // Mirror outer sqare edges\n            vec2 mirroredID = mirrorID.x < mirrorID.y ? repeatingID.xy : repeatingID.yx;\n            \n            // Mirror the diagonal\n            mirroredID = repeatingID.x != repeatingID.y ? mirroredID : vec2(float(gridsize)-mirroredID.x, 0);\n        #endif\n        \n        #if TILING == 2\n            // Mirrored centers\n            vec2 centerID = repeatingID.x > repeatingID.y ? repeatingID : repeatingID.yx;\n            \n        #elif TILING == 4\n            // 2 unique centers for two variants\n            vec2 centerID = repeatingID.x > repeatingID.y ? repeatingID : repeatingID.yx;\n        \n        #else\n            // Unique centers\n            vec2 centerID = localID;\n        #endif\n        \n        // Find the outline\n        #if TILING == 2 || TILING == 3\n            bool isOnOutline = mirroredID.x > float(gridsize) - 1.5;\n            \n        #else            \n            bool isOnOutline = mirroredID.y == 0.;            \n        #endif\n        \n        // Overwrite edges so the texture mirrors\n        localID = isOnOutline ? mirroredID : centerID;   \n    #endif\n    \n    // Generate a random offset for the current cell\n    vec2 randomOffset = hash22(localID + vec2(seed)) *2.-1.;\n    \n    #if TILING == 2 || TILING == 3\n        // Kind of sign, but returns 1 on 0\n        vec2 sgnID = step(centeredID,vec2(0)) *2.-1.;\n        \n        // Find the corner and center points on the outline\n        vec2 doubleMirrorID = abs(mirroredID - (float(gridsize)*0.5));\n        bool blank = doubleMirrorID.x + doubleMirrorID.y == float(gridsize);\n    \n        // Make the noise align with the edge instead of rotating it so all edges fit perfectly\n        if (isOnOutline && !blank && mirrorID.y == float(gridsize)) {\n            // Top and bottom edge\n            randomOffset = vec2(randomOffset.x * sgnID.x, 0);\n            \n            // Reverse shearing to triangular coordinates back to square ones\n            randomOffset *= mat2(HALF_ROOT3, 0, -QUARTER_ROOT3, 1);\n            \n        } else if (isOnOutline && !blank && mirrorID.x == float(gridsize)) {        \n            // Right and Left edge\n            randomOffset = vec2(0, randomOffset.x * sgnID.y);\n            \n            // Apply the triangle rotation\n            randomOffset.y *= HALF_ROOT3;\n            randomOffset.x -= 0.5 * randomOffset.y;\n            \n        } else if (isOnOutline && !blank) {        \n            // Diagonal edge\n            randomOffset = vec2(randomOffset.x * sgnID.x);            \n            randomOffset *= 0.25*sqrt(3.);\n        }\n        \n    #elif TILING == 4 || TILING == 5    \n        // Find the corner and center points on the outline\n        bool blank = localID.x == float(gridsize);\n    \n        // Make the noise align with the edge instead of rotating it so all edges fit perfectly\n        if (isOnOutline && !blank && mirrorID.x == float(gridsize)) {\n        \n            // Right and Left edge, with 120 deg rotation\n           randomOffset = rotateUV(randomOffset, vec2(HALF_ROOT3,-0.5));\n            \n        } else if (isOnOutline && !blank && mirrorID.y != float(gridsize)) {        \n            // Diagonal edge from Right and Left edge with 240 deg rotation\n           randomOffset = rotateUV(randomOffset, vec2(-HALF_ROOT3,-0.5));\n        }\n        \n        // Correct for slating\n        localGrid *= inverse(TRIANGLE_MAT);  \n    #endif\n        \n    // Generate random gradient    \n    float gradient = dot(localGrid, randomOffset);\n    \n    #if TILING > 1        \n        if (blank) {\n            // Make the corner and center points on borders a constant random value\n            gradient = randomOffset.x * randomOffset.y; // Scale down so they are not as extreme\n        }        \n    #endif\n\n    return gradient;\n}\n\n// Function to generate Perlin 2D noise in a triangular grid\nfloat trianglePerlin(vec2 position, uint gridsize, uvec2 seed, float contrast) {\n\n    // Scale the position by the grid size\n    position *= float(gridsize);\n    \n    // Current cell coordinates\n    vec2 id = floor(position);\n    vec2 grid = position - id;\n    \n    // Generate alpha values (weights) for barycentric interpolation.\n    float weightA = min(1.0 - grid.x, 1.0 - grid.y);\n    float weightB = min(grid.x, grid.y);\n    float weightC = 1. - (weightA + weightB);\n    \n    // Combine weight/alpha values. \n    vec3 weights = vec3(weightA, weightB, weightC);\n        \n    // Change the weights' contrast for less edgy results.\n    weights = smoothContrast(weights, contrast);\n    \n    // Switch between diagonal sides to save a sample\n    vec2 offsetC = grid.x < grid.y ? vec2(0,1) : vec2(1,0);\n        \n    // Sample noise at the corners\n    float a = rndGradient(id, grid, vec2(0,0), gridsize, seed);\n    float b = rndGradient(id, grid, vec2(1,1), gridsize, seed);\n    float c = rndGradient(id, grid, offsetC, gridsize, seed);\n    \n    // Bilinear interpolation between the corner values\n    float result = a * weights.x + b * weights.y + c * weights.z;\n    \n    // Rescale result to 0-1       \n    return result*0.5+0.5;\n}\n\n// Noise with Octaves, Perlin in this case\nfloat octaveNoise(vec2 position, float gridsize, int octaves, \n                  float lacunarity, float persistence, float contrast) {\n    \n    // Initialize the variables    \n    // For amplitude math, see: https://www.desmos.com/calculator/xgqeepapwn\n    uvec2 seed = uvec2(421);\n    float amplitude = 1.0;\n    float amplitudeSum = 0.0;\n    float result = 0.0;\n    \n    // For each octave\n    for(int i = 0; i < octaves; ++i) {\n        // Sample noise and apply amplitude\n        result += trianglePerlin(position, uint(gridsize), seed, contrast) * amplitude;\n        \n        // Add up amplitude to normalize the result later\n        amplitudeSum += amplitude;\n        \n        // Increase frequency for the next octave\n        gridsize *= lacunarity;\n        \n        // Decrease amplitude for the next octave\n        amplitude *= persistence;\n        \n        // Change seed/offset noise so it is unique for the next octave\n        seed += uvec2(gridsize);\n    }\n    \n    // Normalize the result to the 0-1 range\n    result /= amplitudeSum;\n\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Initialize variables for angle and zoom\n    float angle = 0.0;\n    float zoom = 1.1;\n    \n    // If the mouse was not clicked, animate\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with steps\n        float zoomSteps = 10.0;\n        float mouseZoom = (floor(mouse.y * zoomSteps) + \n                           smoothstep(0.75, 1.0, fract(mouse.y * zoomSteps))) \n                           / zoomSteps;\n        zoom = mix(3.1, 0.05, mouseZoom);\n        \n        // Mouse controls rotation direction        \n        angle = mouse.x * 1.5;\n        \n    } else {\n        // Set static zoom\n        zoom = 1.05;\n        \n        // Time controls rotation direction \n        angle = iTime * 0.1;\n    }\n    \n    // Make the rotation plateau at 0, 120, 240 degree angles    \n    angle = (floor(3.0 * angle) + smoothstep(0.25, 1.0, fract(3.0 * angle))) / 3.0;\n        \n    // Convert angle to radians\n    angle *= TWO_PI;\n    \n    // Calculate direction clockwise\n    vec2 direction = vec2(sin(angle), cos(angle));\n    \n    // Center of the screen position\n    #ifdef EQUAL\n        vec2 offset = vec2(0.5, QUARTER_ROOT3);\n    #else\n        vec2 offset = vec2(0.5);\n    #endif\n    \n    // Square centered UVs on (0.5,0.5)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + offset;\n        \n    // Apply zoom on coordinates (0.5,0.5) point\n    uv = (uv - 0.5) * zoom + 0.5;  \n    \n    // Change the rotation center depending on the slanting of the triangles\n    vec2 center = vec2(0.5, HALF_OVER_ROOT3);\n    \n    #ifdef EQUAL\n        vec2 uvRot = uv;\n        \n        // Offset every other line\n        uvRot.x += mod(floor(uv.y * TWO_OVER_ROOT3), 2.0) * 0.5;\n        \n        // Make coords repeat so each other cell rotates around center\n        uvRot = mod(uvRot, vec2(1.0, HALF_ROOT3));\n    #else\n         // Make coord grid repeat\n        vec2 uvRot = fract(uv);\n        \n        // Reverse slant the triangle so at every rotation it fits its bounds again\n        uvRot *= inverse(TRIANGLE_MAT);\n    #endif   \n    \n    // Rotate UVs around the center coordinate\n    uvRot = rotateUV(uvRot - center, direction.xy) + center; \n    \n    #ifdef EQUAL\n        // Slants the square grid to an equalsided triangle\n        // from oneshade: https://www.shadertoy.com/view/7tXGWj\n        uv *= TRIANGLE_MAT;        \n    #endif \n    \n    // Slant the rotated coords to triangles\n    uvRot *= TRIANGLE_MAT;\n        \n    // Chess triangle mask\n    vec3 uvStripe = abs(fract(vec3(uv, uv.x - uv.y) * 0.5 - 0.25) - 0.5);\n    vec3 stripe = step(uvStripe, vec3(0.25)) * 2.0 - 1.0; \n    float chess = stripe.x * stripe.y * stripe.z;\n    \n    // Alternate rotated and static UVs\n    vec2 uvNoise = chess < 0.5 ? uvRot + floor(uv) : uv;\n        \n    // Sample the noise\n    float noise = octaveNoise(uvNoise, GRIDSIZE, OCTAVES, LACUNARITY, PERSISTENCE, CONTRAST);\n        \n    // Artistic increase of the variance, so the noise is not so gray\n    noise = smoothContrast(noise, 4.0);\n    \n    // Apply colormap for better readability\n    vec3 color = viridis(noise);   \n    \n    // Calculate anti-aliasing effect\n    vec2 uvFwidth = fwidth(uv);\n    float aa = max(uvFwidth.x, uvFwidth.y) * 2.0;\n    \n    // Turn black background invisible at cardinal angles\n    if (abs(fract(angle / TWO_PI * 3.0) - 0.5) < 0.499) {     \n    \n        // Create smooth chess mask with alternating tiles\n        vec2 uvGrid = uvNoise - floor(uv);\n        vec3 uvStripeSmooth = abs(vec3(uvGrid, uvGrid.x - uvGrid.y) * 2.0 - 1.0);\n        vec3 stripeSmooth = smoothstep(1.0 + aa, 1.0 - aa, uvStripeSmooth);\n        float chessSmooth = stripeSmooth.x * stripeSmooth.y * stripeSmooth.z;\n        color *= max(chess, chessSmooth);\n    }\n    \n    #ifdef SHOWGRID\n        // Debug grid for the large triangles of the grid\n        vec3 line = abs(fract(vec3(uv, uv.x - uv.y)) * 2.0 - 1.0);\n        color *= smoothstep(THICKNESS - aa, THICKNESS + aa, 1.0 - max(line.x, max(line.y, line.z)));  \n    #endif\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// GENERIC FUNCTIONS ____________________________________________________________\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Simplified Smoothstep https://www.desmos.com/calculator/un0o21eokv\nvec3 smoothValue(vec3 x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    float powAlpha = pow(alpha, contrast);\n    float powInfAlpha = pow(1.-alpha, contrast);\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInfAlpha);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example https://www.desmos.com/calculator/n6gpory8yq\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// RANDOM NUMBER GENERATOR _________________________________________________\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n    return vec2(q) * SMALLESTFLOAT;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}