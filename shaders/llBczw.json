{
    "Shader": {
        "info": {
            "date": "1507882333",
            "description": "fork of:\nhttps://www.shadertoy.com/view/4tyXWt",
            "flags": 0,
            "hasliked": 0,
            "id": "llBczw",
            "likes": 11,
            "name": " Rocket In The Skies",
            "published": 3,
            "tags": [
                "volume",
                "cloud",
                "scattering",
                "smoke",
                "rocket",
                "bounding",
                "deferred"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 781
        },
        "renderpass": [
            {
                "code": "//sign 3d Rocket In The Skies deferred volume marching\n\n//self  : https://www.shadertoy.com/view/llBczw\n//parent: https://www.shadertoy.com/view/4tyXWt\n\n\n/*\na lot of entities here are very priimitive and coarse:\n- shapes\n- rotations\nBut hats not the point here. \nThis is more aboud compositioning smoke and solids and a background\nit has basic g-buffering, by first measuring 2 distances\n, within 2 bounding volumes; vec2 d=vec2(gds(p,t),gdt(p,t))\n as first step before calculating colors.\n*/\n\n// Constants\n#define pi acos(-1.)\n\n// Time Scaling\n#define tim iTime*0.1\n#define rocketRotation 1.5*sin(0.9*tim) \n\n#define cSun vec3(1)\n#define cSky vec3(.5,.8,.99)\n#define cAmb vec3(.4)\n\n//octaves of smoke volumes\n#define octavesSmoke 12\n\n//Raymarching solid\n#define minPrimStepSize .1\n#define iterRm 100\n//volumeMarching smoke\n#define RmSmokSampleSize .1\n#define iterRmSmoke 50\n//volumeMarching smoke illumination\n#define RmSmokSampleSize2 .2\n#define iterRmSmoke2 5 \n\n#define smokeStart vec3(5,-50,5) \n#define smokeEnd  vec3(5) \n#define smokeThickness 1.\n#define smokeOffset .1\n\n\n//exiting smoke...\n#define oExting 10.\nconst float oScat = 12.5 ;\n\n#define sat(a) clamp(a,.0,1.)\n#define u5(a) ((a)*.5+.5)\n\n#define ma0(a) max(a,.0)\n\nvec2 rot2D(vec2 p,float a)\n{float s=sin(radians(a)),c=cos(radians(a))\n;return p*mat2(c,s,-s,c);}\n//if i ever saw inefficient style\nvec2 frot(const float a,vec2 v){float c= cos(a),s= sin(a)\n;vec2 u=v;v.x=u.x*c+u.y*s;v.y=u.x*-s+u.y*c;return v;}\n\n // replace this by something better\nfloat hash(vec3 p){p=17.*fract( p*0.3183099+.1)\n;return fract(p.x*p.y*p.z*(p.x+p.y+p.z));}\n\nfloat noise(vec3 x)\n{vec3 p=floor(x),f=fract(x);f=f*f*(3.0-2.0*f);return mix\n(mix(mix(hash(p+vec3(0,0,0))\n        ,hash(p+vec3(1,0,0)),f.x)\n    ,mix(hash(p+vec3(0,1,0))\n        ,hash(p+vec3(1,1,0)),f.x),f.y)\n,mix(mix(hash(p+vec3(0,0,1))\n        ,hash(p+vec3(1,0,1)),f.x)\n    ,mix(hash(p+vec3(0,1,1))\n        ,hash(p+vec3(1,1,1)),f.x),f.y),f.z);}\n\n//return smoke density at [u].\nfloat sampleSmoke(vec3 u)\n{float n=0.,a=1.,f=3.,l=2.\n;for (int i=0;i<octavesSmoke;++i\n){n+=a*noise(f*u+vec3(.0,tim*200.,3.*tim));a/=l;f*=l;}\n;vec3 d=normalize(smokeEnd-smokeStart)\n;u=smokeStart-u;\n;return 2.*sat((n*exp(-2.5*length(u-(dot(u,d))*d))-smokeOffset)\n                *(1.-exp(-.05*length(u))));}\n\n//shape lib\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float r){p-=a,b-=a\n;float h=sat(dot(p,b)/dot(b,b));return length(p-b*h)-r;}\nfloat mBox(vec3 p, vec3 b)\n{return max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);}\nvoid angularRepeat(const float a,inout vec2 v)\n{float t=mod(atan(v.y,v.x)+a*.5,a)-a*.5\n;v=vec2(cos(t),sin(t))*length(v);}\n\n//return distance of p to rocket shape.\n//shape code looks mildly messy, but thats the nature of such.\nfloat dfRocketBody(vec3 p)\n{p.xz=frot(rocketRotation,p.xz)\n;vec3 q=p\n;angularRepeat(pi*.25,q.zx)\n;float d=q.z//body\n;d=max(d,frot(pi*-.125    ,q.yz+vec2(-.7  ,0)).y)\n;d=max(d,frot(pi*-.25 *.75,q.yz+vec2(-0.95,0)).y)\n;d=max(d,frot(pi*-.125*.5 ,q.yz+vec2(-0.4 ,0)).y)\n;d=max(d,frot(pi* .125*.25,q.yz+vec2(+0.2 ,0)).y)\n;d=max(d,frot(pi* .125*.8 ,q.yz+vec2(.55  ,0)).y)\n;d=max(d,-.8-p.x)\n;d-=.5\n;vec3 t=q-vec3(-1.46,0,0)//trusters\n;t.yz=frot(pi*-.2,t.yz)\n;d=min(d,mBox(t,vec3(.1,.4,.27)))\n;d=min(d,mBox(t-vec3(-.09,.0,.0),vec3(.1,.3,.07)));\n;vec3 w=p-vec3(.1,.0,.0)//window\n;angularRepeat(pi*.25,w.xy)\n;w-=vec3(.17,.0,.0)\n;d=min(d,mBox(w,vec3(.03,.2,.55)))\n;return d;}\nfloat dfRocketFins(vec3 u)\n{u.xz=frot(rocketRotation,u.xz)\n;angularRepeat(pi*.5,u.zx)\n;u-=vec3(0,-1.+cos(u.y+.2)*.5,0)\n;u.yz=frot(pi*.25,u.yz)\n;return mBox(u,vec3(.17,.03,3.)*(1.-u.y*.5))*.5;}\nfloat dfRocket(vec3 p)\n{float q=mBox(p,vec3(2.5,.8,.8))\n;if (q>1.)return q\n;return min(dfRocketBody(p),dfRocketFins(p));}\n\n//bounding volumes for smoke and solids\nfloat sampleSmokeCap(vec3 u)\n{return sdCapsule(u,smokeStart,smokeEnd,smokeThickness);}\nfloat sampleRocketCCy(vec3 u)\n{return dfRocket(u-(smokeEnd+vec3(0,2.3,0)));}\n\n//i rarely see worse gBuffers\nbool isIntersectingSmokeShape(vec3 u, float e, out float d)\n{d=sampleSmokeCap(u);return d<e;}\n//return shortest distance to transparent surface (non reflecting smoke\n//return if smoke is visible (z+gBuffer)\nfloat gdt(vec3 u,vec3 t){vec3 p=u;float d=.0,e=.0005,m=minPrimStepSize;\n;for(int i=0;i< iterRm;++i\n){if(isIntersectingSmokeShape(p,e,m))return d\n ;else{e=.00005*d;d+=m;p=d*t+u;}}return -1.;}\n\n//return distance to solid\nfloat gds(vec3 u,vec3 t){vec3 p=u;float d=.0,e=.0005,m;\n;for(int i= 0 ;i<iterRm;++i\n){m=sampleRocketCCy(p);\n    if(m-e<0.)return d\n ;else{e=.0005*d;d+=m;p=d*t+u;}}return -1.;}\n\nfloat getIncidentSunlight(vec3 u,vec3 t){float a=1.,d=.0\n;for(int i=0;i<iterRmSmoke2;++i\n){if(!isIntersectingSmokeShape(u,.005,d))break\n ;a*=exp(-oExting*sampleSmoke(u)*RmSmokSampleSize2);u+=t\n;}return a;}\n\n//rayorigin,raydirection,sundirection\nvec4 calcSmoke(vec3 u,vec3 t,vec3 s)\n{t*=RmSmokSampleSize\n;float d,a=1.;vec3 c=vec3(0)\n;for(int i=0;i<iterRmSmoke;++i\n){if(a<.05||!isIntersectingSmokeShape(u,.005,d))break\n ;float g=sampleSmoke(u)\n ;a*=exp(-oExting*g*RmSmokSampleSize)\n ;c+=a*RmSmokSampleSize*g*oScat*(cAmb+cSun*getIncidentSunlight(u,s));\n ;u+=t;}return vec4(c,a);}\n\n//4x sampling is fine whete curvature=0.\nvec3 calcRocketNormal(vec3 p ){vec2 e=vec2(1,-1)*.5773*.0005\n;return normalize(e.xyy*sampleRocketCCy(p+e.xyy)\n+e.yyx*sampleRocketCCy(p+e.yyx)\n+e.yxy*sampleRocketCCy(p+e.yxy)\n+e.xxx*sampleRocketCCy(p+e.xxx));}\n\n//return color of rocket.\nvec4 calcRocket(in vec3 u,in vec3 t, in vec3 s)\n{vec3 n=calcRocketNormal(u)\n;t=reflect(t,n)\n;vec3 c=vec3(0)\n;float amb=sat(u5(n.y))\n;float dif=sat(dot(n,s))\n;float spe=pow(sat(dot(t,s)),16.)\n;if(dfRocketBody(u)>dfRocketFins(u)\n){if(u.y<smokeEnd.y-.85||u.y>smokeEnd.y+1.34)\n   if (u.y>smokeEnd.y+3.41)c=vec3(.1);\n   else c=vec3(.9);\n  else c=vec3(.1);}\n vec3 r=vec3(0)\n;r+=dif*4.3*vec3(1,.8,.55)\n;r+=spe*7.*vec3(1,.9,.7)*dif+amb\n;return vec4(c*r,.0);}\n\n//raydirection,sundirection\nvec3 calcSkyCol(vec3 t,vec3 s)\n{float d=ma0(dot(t,s)),v=pow(1.-ma0(t.y),5.)*.5\n;vec3 a=v*cSun*.4+cSky;\n;a+=cSun*pow(d, 6.5)*.32\n;a+=cSun*min(pow(d, 1600.),.3)*.65\n;return a;}\n\nvoid mainImage(out vec4 o,vec2 u)\n{u=(u.xy-iResolution.xy * .5)/iResolution.y\n;vec2 m=2.*((iMouse.xy/iResolution.xy)-.5)\n;if(iMouse.xy==vec2(0))m.y=.0\n;vec3 t=vec3(u,1)\n//low precision roatations in deg of camera and light direction\n;t.yz=rot2D(t.yz, 90.*m.y)\n;t.xz=rot2D(t.xz,130.*m.x+180.)\n;t=normalize(t)\n;vec3 p=vec3(0,7,3.*smokeOffset)\n;float lEle=10.*pi/180.\n;float lAzi=90.*pi/180.+tim*20.\n;vec3 s=vec3(cos(lAzi)*cos(lEle),sin(lEle),sin(lAzi)*cos(lEle))\n//2 distances, deferred shading:\n;vec2 d=vec2(gds(p,t),gdt(p,t))\n;if(all(lessThan(vec3(-1,-1,d.y),d.yxx))//if smoke is infront of solid\n){o=               calcSmoke(p+t*d.y,t,s)//dual mix\n ;o=vec4(mix(o.rgb,calcRocket(p+t*d.x,t,s).rgb,o.a),.0);//dual mix\n}else if(d.x>-1.)o=calcRocket(p+t*d.x,t,s)//solid only\n;else if(d.y>-1.)o=calcSmoke(p+t*d.y,t,s);//smoke only\nif (d.x==-1.)o.rgb=mix(o.rgb,calcSkyCol(t,s),o.a);//background\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}