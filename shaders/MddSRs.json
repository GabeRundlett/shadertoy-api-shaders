{
    "Shader": {
        "info": {
            "date": "1461013755",
            "description": "saturn with some warping and color blending",
            "flags": 0,
            "hasliked": 0,
            "id": "MddSRs",
            "likes": 7,
            "name": "disco saturn",
            "published": 3,
            "tags": [
                "saturn"
            ],
            "usePreview": 0,
            "username": "substack",
            "viewed": 1015
        },
        "renderpass": [
            {
                "code": "//glsl-noise:\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat torus (vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\nmat4 scale (float x, float y, float z) {\n  return mat4(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);\n}\nmat4 invert(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvec3 sunpos = vec3(20,10,20);\nvec2 model(vec3 p) {\n  mat4 m = invert(scale(1.8,0.3,1.8));\n  float ring = torus(vec3(m*vec4(p,1)),vec2(4.5,0.5))\n    + snoise(p*8.0)*0.05;\n  float planet = sphere(p,4.0);\n  float sun = sphere(p-sunpos,2.0);\n  return vec2(min(ring,min(planet,sun)));\n}\n\nvec3 calcNormal(vec3 pos) {\n  const float eps = 0.002;\n\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize(v1*model(pos + v1*eps).x\n    + v2*model(pos + v2*eps).x\n    + v3*model(pos + v3*eps).x\n    + v4*model(pos + v4*eps).x);\n}\n\nconst int steps = 25;\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n  for (int i = 0; i < steps; i++) {\n    if (latest < precis || dist > maxd) break;\n    vec2 result = model(rayOrigin + rayDir * dist);\n    latest = result.x;\n    type = result.y;\n    dist += latest;\n  }\n  if (dist < maxd) res = vec2(dist, type);\n  return res;\n}\n\nvec2 raytrace(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 50.0, 0.001);\n}\n\nvec2 square(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec3 camera(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n  return mat3(uu, vv, ww);\n}\n\nvec3 camera(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = lookAt(origin, target, 0.0);\n  return camera(camMat, screenPos, lensLength);\n}\n\nvec3 lighting (vec3 pos, vec3 nor, vec3 rd, float dis, vec3 mal) {\n  vec3 lin = vec3(0.0);\n  vec3  lig = normalize(vec3(1.0,0.7,0.9));\n  float dif = max(dot(nor,lig),0.0);\n  lin += dif*vec3(2);\n  lin += vec3(0.05);\n  return mal*lin;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float cameraAngle = 0.2 * t;\n  vec3 rayOrigin = vec3(18.0 * sin(cameraAngle), 2.2, 18.0 * cos(cameraAngle));\n  vec3 rayTarget = vec3(0, 0, 0);\n  vec2 screenPos = square(iResolution.xy);\n  float lensLength = 2.0;\n  vec3 rayDirection = camera(rayOrigin, rayTarget, screenPos, lensLength);\n  rayDirection.x += sin(4.0*t + uv.x*4.0) / 20.0;\n  rayDirection.y += cos(8.0*t + uv.y*4.0) / 20.0;\n\n  vec2 collision = raytrace(rayOrigin, rayDirection);\n  if (collision.x > -0.5) {\n    vec3 pos = rayOrigin + rayDirection * collision.x;\n    if (length(pos) > 25.0 && length(pos-vec3(sunpos))<=5.0) { // sun\n      fragColor = vec4(1,1,1,1);\n    } else if (length(pos) <= 6.0) { // planet\n      vec3 nor = calcNormal(pos);\n      vec3 mat = (vec3(0.9,0.75,0.6+sin(pos.y*2.0+3.0)*0.05))*vec3(\n        sin(pos.y*2.0*sin(pos.y*2.5)+sin(pos.y*2.0)+snoise(pos*3.0)*0.4)*0.05+0.6\n      );\n      vec3 col = lighting(pos, nor, rayDirection, collision.x, mat);\n      col = pow(clamp(col,0.0,1.0), vec3(1.2));\n      fragColor = vec4(col, 1.0);\n    } else { // ring\n      float edge = length(pos)+snoise(pos*8.0)*0.03;\n      vec3 col = vec3(0.95,0.8,0.7)*vec3(\n        sin(1.5+sqrt(length(pos)*4.0)*2.0+sqrt(sin(length(pos)*8.1))\n          +snoise(pos*12.0)*0.3)*0.2+0.6)\n        * (abs(edge-8.6)<0.1?0.2:1.0)\n      ;\n      if (length(pos)>=10.0) col = vec3(0,0,0);\n      else if (abs(pos.y)>0.35) col = vec3(0,0,0);\n      else {\n        vec3 p = normalize(-sunpos)*7.5;\n        col *= min(1.0,(length(pos-p)-4.0)/4.0);\n      }\n      fragColor = vec4(col, 1.0);\n    }\n  } else {\n    fragColor = vec4(vec3(pow(snoise(rayDirection*128.0),4.0)),1);\n  }\n  fragColor.x *= sin(t*3.0+sin(t*4.0+uv.x*uv.x*2.0)+cos(t*4.0+uv.y*uv.y*8.0));\n  fragColor.y *= sin(t*2.0+sin(t*2.0+uv.x*uv.x*8.0)+cos(t*1.0+uv.y*uv.y*8.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}