{
    "Shader": {
        "info": {
            "date": "1484854395",
            "description": "Playing with fractals",
            "flags": 0,
            "hasliked": 0,
            "id": "MlVXRG",
            "likes": 5,
            "name": "Brainfarm",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "lherm",
            "viewed": 765
        },
        "renderpass": [
            {
                "code": "// Based on code from Cabbibo, IQ and Connor Bell\n\n#define PI 3.1415926\n#define M 100\n#define MD 20.\n#define P 0.01\n\n// ----------\n// USEFUL FUNCTIONS\n// ----------\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n// ----------\n// DISTANCE FUNCTIONS FROM IQ\n// ----------\n\n\nvec3 opRep(in vec3 p, in float c)\n{\n    return mod(p, c)-(c*.5);\n}\n\n// ----------\n// CAMERA\n// ----------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// ----------\n// MODELLING\n// ----------\n\nfloat trap;\n\nvec2 DE(in vec3 p)\n{\n    #define REP\n    #ifdef REP\n    p.z -= iTime;\n    p = opRep(p, 3.5);\n    #else\n    p.z -= 1.5;\n    #endif\n    pR(p.xy, -PI / 4.);\n    float d = 1000.;\n    float o = 1.;\n    float sz = 1.9;\n    for (int i = 0; i < 15; i++)\n    {\n        if (p.x + p.y < 0.) p.xy = -p.yx;\n        pR(p.xy, (PI / 10.) * sin(iTime * .5));\n        p = abs(p);\n        if (p.x + p.z < 0.) p.xz = -p.zx;\n        pR(p.zx, (PI / 10.) * sin(iTime * .5));\n        if (p.y + p.z < 0.) p.yz = -p.zy;\n        p = sz*p - o * (sz-1.);\n        d = min(d, length(p)*pow(sz,-float(i)-1.));\n        if (dot(p, p) < 256.) trap = distance(p, vec3(0.));\n        \n    }\n    float res = d;\n    return vec2(res, 1.);\n}\n\nvec2 trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.;\n    float id = -1.;\n    for (int i = 0; i < M; i++)\n    {\n        vec2 m = DE(ro+rd*t);\n        if (m.x < P || t > MD) break;\n        t += m.x;\n        id = m.y;\n    }\n    if (t > MD) id = -1.;\n    return vec2(t, id);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor , float io )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = DE(aopos).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec3 eps = vec3(P, 0., 0.);\n    return normalize(vec3(\n\t    DE(p+eps.xyy).x - DE(p-eps.xyy).x,\n\t    DE(p+eps.yxy).x - DE(p-eps.yxy).x,\n\t    DE(p+eps.yyx).x - DE(p-eps.yyx).x ));\n}\n\nvec3 render(in vec2 res, in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.);\n    vec3 lightPos = vec3(1., 4., 3.);\n    if (res.y > -.5)\n    {\n        vec3 p = ro + rd * res.x;\n        vec3 n = calcNormal(p);\n        vec3 lightDir = normalize(lightPos - p);\n        float match = max(0., dot(lightDir, n));\n        float occ = calcAO(p, n, 1.);\n        color = vec3(trap) * match * occ;\n    }\n    else\n    {\n        color = mix(vec3(0.), vec3(1.), rd.y);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 ro = vec3(0., 0., 4.);\n    vec3 ta = vec3(0.);\n    mat3 camMat = calcLookAtMatrix(ro, ta, 0.); // 0. is camera roll\n    vec3 rd = normalize(camMat * vec3(uv.xy, 2.));\n    \n    vec2 res = trace(ro, rd);\n    vec3 color = render(res, ro, rd);\n    // Fog taken from https://www.shadertoy.com/view/4s2XRd\n    color = mix(color, vec3(0.), smoothstep(5., 20., res.x));\n    color = abs(sin(vec3(.1245, .235, .8423) * color + iTime));\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}