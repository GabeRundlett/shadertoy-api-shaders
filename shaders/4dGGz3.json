{
    "Shader": {
        "info": {
            "date": "1455502187",
            "description": "Driving your scooter through the fog at night probably isn't a good idea... but flipping off that guy with no headlights was just plain dumb.",
            "flags": 49,
            "hasliked": 0,
            "id": "4dGGz3",
            "likes": 35,
            "name": "City Driving",
            "published": 3,
            "tags": [
                "game",
                "driving"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 2156
        },
        "renderpass": [
            {
                "code": "//City Driving by eiffie\n//I was just checking performance before making a game.\n#define PI 3.14159\n//originally from iq and mods by others\n#define inside(a) (fragCoord.y-a.y == 0.5 && (fract(a.x) == 0.1 || fragCoord.x-a.x == 0.5))\n#define load(a) texture(iChannel0,(vec2(a,0.0)+0.5)/iResolution.xy)\n#define save(a,b) if(inside(vec2(a,0.0))){fragColor=b;return;}\n\nvec2 rep(vec2 p, vec2 a){return abs(mod(p+a,a*2.0)-a);}\nfloat RRomb(vec3 p, vec4 r, vec3 d){return length(max(abs(p)-r.xyz+p.y*vec3(abs(p.x+d.y)*d.x*2.0,0.0,abs(p.z)*d.z*2.0),0.0))-r.w;}\nvec3 CO;mat3 MX;\nfloat DEC(in vec3 p){\n\tp=MX*(p-CO);\n\tp*=5.0;\n\tp.xz=p.zx;p.z=-p.z;//flippin car, i can't tell which is the front\n\tp.y+=0.275;\n\tfloat h=0.07-0.01*p.x;\n\tfloat dB=RRomb(p,vec4(0.75,h,0.33,0.08), vec3(-0.1,-0.15,-0.12));\n\tif(dB>1.0)return dB-0.5;\n\tfloat dC=RRomb(p-vec3(0.1,0.23,0.0),vec4(0.31,h,0.3,0.05), vec3(0.74,-0.18,0.55));\n\tp.x=abs(p.x)-0.48;\n\tp.y+=0.09;\n\tfloat r=length(p.xy);\n\tdC=max(min(dB,dC)*0.9,-(r-0.17));\n\tfloat dT=length(max(vec2(r-0.1,abs(abs(p.z)-0.35)-0.05),0.0))-0.03;\n\treturn min(dC,dT)*0.2;\n}\nfloat DE(vec3 z0){//amazing surface/box thnx to kali/tglad\n\tfloat dC=DEC(z0);\n\tvec2 q=z0.xz*0.1;\n\tfloat th=(sin(q.x+cos(q.y))+sin(q.y+cos(q.x)))-0.1;\n\tz0.xz=rep(z0.xz,vec2(4.25));\n\tvec4 z=vec4(z0,1.0);\n\tvec2 c=vec2(1.0,0.66);\n\tfloat dS=z0.y+2.0,dB=length(vec2(length(max(abs(z.xz)-vec2(0.5),0.0))-3.6,z.y+th))-0.36;//ground,tunnel\n\n\tz.xz=clamp(z.xz, -1.0, 1.0) *2.0-z.xz;\n\tz*=2.0/clamp(dot(z.xyz,z.xyz),0.75,1.37);\n\tz.yz+=c;\n\tdS=min(dS,(length(max(abs(z.xyz)-vec3(0.82,2.83,0.82),0.0))-0.33)/z.w);//buildings\n\n\t//unrolled loop\n\tz.xz=clamp(z.xz, -1.0, 1.0) *2.0-z.xz;\n\tz*=2.0/clamp(dot(z.xyz,z.xyz),0.75,1.37);\n\tz.yz+=c;\n\tdS=min(dS,(length(max(abs(z.xyz)-vec3(0.82,2.83,0.82),0.0))-0.33)/z.w);//buildings\n\t\t\n\tfloat dR=max(dB,z0.y+0.2+th);//road\n\tdS=max(dS,-dB);//city with tunnel removed\n\tfloat dG=dS+0.037;//interior is glass\n\tz.xyz=abs(mod(z.xyz,0.4)-0.2);\n\tdS=max(dS,-max(z.y-0.16,min(z.x,z.z)-0.15)/z.w);//cut out windows\n\treturn min(min(dS,dG),min(dC,dR));\n}\n\nvec4 mcol;\nfloat CE(vec3 z0){//for coloring\n\tfloat dC=DEC(z0);\n\tvec2 c=z0.xz*0.1;\n\tfloat th=(sin(c.x+cos(c.y))+sin(c.y+cos(c.x)))-0.1;\n\tz0.xz=rep(z0.xz,vec2(4.25));\n\tvec4 z=vec4(z0,1.0);\n\tc=vec2(1.0,0.66);\n\tfloat b=length(max(abs(z.xz)-vec2(0.5),0.0))-3.6;\n\tfloat dS=z0.y+2.0,dB=length(vec2(b,z.y+th))-0.36;//ground,tunnel\n\tfloat a=atan(z.z,z.x);\n\tz.xz=clamp(z.xz, -1.0, 1.0) *2.0-z.xz;\n\tz*=2.0/clamp(dot(z.xyz,z.xyz),0.75,1.37);\n\tz.yz+=c;\n\tdS=min(dS,(length(max(abs(z.xyz)-vec3(0.82,2.83,0.82),0.0))-0.33)/z.w);//buildings\n\n\t//unrolled loop\n\tz.xz=clamp(z.xz, -1.0, 1.0) *2.0-z.xz;\n\tz*=2.0/clamp(dot(z.xyz,z.xyz),0.75,1.37);\n\tz.yz+=c;\n\tdS=min(dS,(length(max(abs(z.xyz)-vec3(0.82,2.83,0.82),0.0))-0.33)/z.w);//buildings\n\t\t\n\tc.x=abs(fract(z.x*z.y*2.0)*0.2-0.1);\n\tfloat dR=max(dB,z0.y+0.2+th);//road\n\tdS=max(dS,-dB);//city with tunnel removed\n\tfloat dG=dS+0.037;//interior is glass\n\tvec4 c2=floor(z*2.5);\n\tz.xyz=abs(mod(z.xyz,0.4)-0.2);\n\tdS=max(dS,-max(z.y-0.16,min(z.x,z.z)-0.15)/z.w);//cut out windows\n\t\n\tif(dS<dR && dS<dG && dS<dC){\n\t\tz*=200.0;\n\t\tdS+=sin(z.x+2.4*sin(z.y+2.4*sin(z.z)))*0.00005;\n\t\tmcol=vec4(c.x*vec3(1.0,0.9,0.7),1.0);\n\t}else if(dR<dG && dR<dC){\n\t\tfloat d=0.04+smoothstep(0.01,0.0,max(abs(b)-0.0025,abs(fract(a*10.0)-0.5)*0.1-0.01));\n\t\tmcol=vec4(d,d,mcol.x*0.1,32.0);//rand(z0.xz)\n\t\tmcol*=clamp(dC*20.0,0.0,1.0);\n\t}else if(dG<dC){\n\t\tfloat spec=step(-0.8,sin((1.0+iTime*0.01)*(4.0*c2.x-c2.y+3.0*c2.z)))-0.5;\n\t\tz.xyz=vec3(0.2)*fract((c2.x+c2.z-c2.y)*0.32454213)*step(0.0,z0.y+1.9);\n\t\tmcol=vec4(z.xyz,spec);\t\t\n\t}else{\n\t\tmcol=vec4(0.0);\n\t}\n\treturn min(min(dS,dG),min(dR,dC));\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ){//huh, you'll probably be inside the buildings\n\tfloat rnd=fract(sin(dot(fragCoord,vec2(13.14,63.242)))*2342.123); //try an abs of the DE if you are\n\t/*float t=rnd*DE(ro),d,px=1.0/iResolution.x;\n\tfor(int i=0;i<64;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(d<px*t || t>20.0)break;\n\t}*/\n\tfloat t=rnd*DE(ro),px=1.0/iResolution.x;\n\tfloat d,pd=10.0,os=0.0,step;\t\n\tfor(int i=0;i<64;i++){\n\t\td=DE(ro+rd*t);\n#define AUTO_OVERSTEP\n#ifdef AUTO_OVERSTEP\n\t\tif(d>=os){\t\t//we have NOT stepped over anything\n\t\t\tos=0.47*d*d/pd;//calc overstep based on ratio of this step to last\n\t\t\tstep=d+os;\t//add in the overstep\n\t\t\tpd=d;\t//save this step length for next calc\n\t\t}else{\n\t\t\tstep=-os;d=1.0;pd=10.0;os=0.0;//remove ALL of overstep\n\t\t}\n#else\n\t\tstep=d;\n#endif\n\t\tt+=step;\n\t\tif(t>20.0 || d<px*t)break;\n\t}\n\tvec3 fog=vec3(1.0-abs(rd.y))*(0.9+0.1*rnd);\n\tvec3 col=fog;\n\tif(t<20.0){\n\t\tmcol=vec4(rnd,0.0,0.0,0.0);\n\t\tfloat nd=CE(ro+rd*t);\n\t\tfloat vis=clamp(1.0-nd/d,0.0,1.0);\n\t\tfloat spec=0.07*clamp((1.0-vis)*t*0.4,0.0,1.0);\n\t\tmcol.rgb/=(1.0+nd*nd*100000.0);\n\t\tif(mcol.a<0.0)mcol.rgb*=10.0*vec3(0.5+0.5*vis,0.9,1.0-0.5*vis);\n\t\tmcol.rgb*=4.0/(t*t)*max(vis,0.5);\n\t\tmcol.rgb=mix(mcol.rgb,fog,spec);\n\t\tcol=mix(mcol.rgb,fog,clamp(sqrt(t)/4.4,0.0,1.0));\n\t}\n\tfragColor=vec4(col,1.0);\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n//from Walkable Character WADS keys by MMGS https://www.shadertoy.com/view/MsKGR3 (but changed direction of rot y)\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,-sa,    .0,1.,.0,   sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec3 ro=load(0).xyz;\n\tvec3 fw=normalize(load(2).xyz);\n    vec2 uv=fragCoord/iResolution.xy;\n    float b=length(uv-iMouse.xy/iResolution.xy);\n    if(b<0.25){\n        fw=-fw;\n        uv-=(iMouse.x==0.0?vec2(0.125):iMouse.xy/iResolution.xy);\n        uv/=0.25;\n        uv.x=-uv.x;\n    }else{\n        uv=uv-0.5;\n    }\n    uv.y*=iResolution.y/iResolution.x;\n\tvec3 rd=lookat(fw)*normalize(vec3(uv,1.0));\n    \n\tCO=load(3).xyz;\n\tvec3 rt=-load(5).xyz;\n   \tMX=(rotate_z(rt.z)*rotate_x(rt.x))*rotate_y(rt.y);\n\tmainVR(fragColor, fragCoord, ro, rd);\n    fragColor.rgb=mix(vec3(1.0,0.5,0.2),fragColor.rgb,clamp(abs(b-0.25)*60.0,0.0,1.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159\n#define PID2 (PI/2.0)\n#define TAU (2.0*PI)\n#define RAD 4.25\n#define C vec2(RAD,0.0)\n//state handling originally from iq's bricks but modified by others\n#define inside(a) (fragCoord.y-a.y == 0.5 && (fract(a.x) == 0.1 || fragCoord.x-a.x == 0.5))\n#define load(a) texture(iChannel0,(vec2(a,0.0)+0.5)/iResolution.xy)\n#define save(a,b) if(inside(vec2(a,0.0))){fragColor=b;return;}\n#define LEFT_ARROW 37\n#define UP_ARROW 38\n#define RIGHT_ARROW 39\n#define DOWN_ARROW 40\nbool KeyDown(in int key){\n\treturn (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);\n}\n\nvec2 rep(vec2 p, vec2 a){return abs(mod(p+a,a*2.0)-a);}\nfloat DE(vec3 z0){//amazing surface/box thnx to kali/tglad\n\tvec2 q=z0.xz*0.1;\n\tfloat th=(sin(q.x+cos(q.y))+sin(q.y+cos(q.x)))-0.1;\n\tz0.xz=rep(z0.xz,vec2(4.25));\n\tvec4 z=vec4(z0,1.0);\n\tvec2 c=vec2(1.0,0.66);\n\tfloat dS=z0.y+2.0,dB=length(vec2(length(max(abs(z.xz)-vec2(0.5),0.0))-3.6,z.y+th))-0.36;//ground,tunnel\n\n\tz.xz=clamp(z.xz, -1.0, 1.0) *2.0-z.xz;\n\tz*=2.0/clamp(dot(z.xyz,z.xyz),0.75,1.37);\n\tz.yz+=c;\n\tdS=min(dS,(length(max(abs(z.xyz)-vec3(0.82,2.83,0.82),0.0))-0.33)/z.w);//buildings\n\n\t//unrolled loop\n\tz.xz=clamp(z.xz, -1.0, 1.0) *2.0-z.xz;\n\tz*=2.0/clamp(dot(z.xyz,z.xyz),0.75,1.37);\n\tz.yz+=c;\n\tdS=min(dS,(length(max(abs(z.xyz)-vec3(0.82,2.83,0.82),0.0))-0.33)/z.w);//buildings\n\t\t\n\tfloat dR=max(dB,z0.y+0.2+th);//road\n\tdS=max(dS,-dB);//city with tunnel removed\n\tfloat dG=dS+0.037;//interior is glass\n\tz.xyz=abs(mod(z.xyz,0.4)-0.2);\n\tdS=max(dS,-max(z.y-0.16,min(z.x,z.z)-0.15)/z.w);//cut out windows\n\treturn min(min(dS,dG),dR);\n}\nfloat roadHeight(in vec2 q){\n\tq*=0.1;\n\treturn -(sin(q.x+cos(q.y))+sin(q.y+cos(q.x)));\n}\nbool onRoad(inout vec3 z0){\n\tvec2 q=z0.xz*0.1;\n\tfloat th=(sin(q.x+cos(q.y))+sin(q.y+cos(q.x)));\n\tq=z0.xz;\n\tq=rep(q,vec2(4.25));\n\tfloat b=abs(length(max(abs(q)-vec2(0.5),0.0))-3.6);\n\tif(b<0.3 && abs(z0.y+th)<0.25){z0.y=-th;return true;}\n\treturn false;\n}\n// Tetrahedral normal from IQ.\nvec3 normal(vec3 p, float e){vec2 v=vec2(-e,e);return normalize(v.yxx*DE(p+v.yxx)+v.xxy*DE(p+v.xxy)+v.xyx*DE(p+v.xyx)+v.yyy*DE(p+v.yyy));}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tif(fragCoord.y>1.0 || fragCoord.x>6.0)discard;\n\tvec4 st0,st1,st2,st3,st4,st5;\n\tif(iFrame==0){\n\t\tst0=vec4(0.0,-1.75,RAD,iTime);//position,time\n\t\tst1=vec4(0.01,0.0,0.0,0.0);//velocity\n\t\tst2=vec4(0.01,0.0,0.0,0.0);//direction lagging velocity\n\t\tst3=vec4(0.0,0.0,RAD,0.0);//position of black car\n\t\tst4=vec4(0.0,0.0,0.0,0.0);//center of black car \"block\"\n\t\tst5=vec4(0.0,0.0,0.0,1.0);//rotations, direction of black car\n\t}else{\n\t\tst0=load(0);\n\t\tst1=load(1);\n\t\tst2=load(2);\n\t\tst3=load(3);\n\t\tst4=load(4);\n\t\tst5=load(5);\n\t}\n\tfloat dtime=iTime-st0.w;\n\tfloat ln=length(st1.xz);\n\tvec2 n=st1.xz/ln;\n\tif(KeyDown(UP_ARROW))st1.xz+=n*dtime*dtime;\n\tif(KeyDown(DOWN_ARROW) && ln>0.001)st1.xz*=0.9;\n\tfloat rt=0.0;\n\tif(KeyDown(LEFT_ARROW))rt=5.0;\n\tif(KeyDown(RIGHT_ARROW))rt=-5.0;\n   \tif(rt!=0.0){rt*=sqrt(ln)*dtime;st1.xz=rotate(st1.xz,rt);}\n\tst0.w=iTime;\n\tst0.xyz+=st1.xyz;\n\tif(!onRoad(st0.xyz)){\n\t\tst1.y-=0.5*dtime*dtime;//bounce around (ok it makes no sense that you still can steer)\n\t\tfloat d=DE(st0.xyz);\n#define RADIUS 0.05\n\t\tif(d<RADIUS){\n\t\t\tvec3 N=normal(st0.xyz,max(0.001,d));\n\t\t\tfloat dr=dot(N,normalize(st1.xyz));\n\t\t\tif(dr<0.0){\n\t\t\t\tst0.xyz-=st1.xyz*(RADIUS-d);\n\t\t\t\tst1.xyz=reflect(st1.xyz,N);\n\t\t\t\tif(ln>0.001)st1.xz*=1.0-0.9*abs(dr);\n\t\t\t\tst1.y*=0.5-st1.y*0.1;\n\t\t\t\tst0.xyz+=st1.xyz;\n\t\t\t}\n\t\t}\n\t\tif(st0.y<-1.9){\n\t\t\tst1.w+=dtime;\n\t\t\tif(st1.w>2.0){\n\t\t\t\tst0=vec4(0.0,-1.75,4.25,iTime);\n\t\t\t\tst1=vec4(0.01,0.0,0.0,0.0);\n\t\t\t\tst2=vec4(0.01,0.0,0.0,0.0);\n\t\t\t}\n\t\t}\n\t}else{\n\t\tst1.y=roadHeight(st0.xz+st1.xz)-roadHeight(st0.xz);\n\t\tst1.w=0.0;\n\t}\n\tst2=mix(st2,st1,clamp(dtime*3.0,0.0,1.0));\n\t\t\n\t//other car\n\tfloat a=mod(st5.y,PID2);\n    float d=length(st3.xz-st0.xz);\n\tif(a<dtime){\n\t\tfloat b=floor(st5.y/PID2)*PID2;\n\t\tvec2 c=rotate(C*2.0,b);\n\t\tfloat d1=length(st4.xy+rotate(C,st5.y+st5.w*0.25)-st0.xz);\n\t\tfloat d2=length(st4.xy+c+rotate(C,st5.y+PI-st5.w*0.25)-st0.xz);//if close and ahead turn randomly\n        if(d<min(d1,d2) && d<5.0){if(fract(sin(iTime)*234.142)>0.5)d2=d1+0.1;else d2=d1-0.1;}\n\t\tif(d2<d1){\n\t\t\tst4.xy+=c;st5.w=-st5.w;st5.y+=PI-2.0*a;\n\t\t}\n\t}\n    if(d<0.15){//crash\n        st1.xz+=(st0.xz-st3.xz)*dtime;\n    }\n\tst5.y+=st5.w*0.5*dtime;\n\tst5.y=mod(st5.y,TAU);\n\tst3.xz=st4.xy+rotate(C,st5.y);\n\tst3.y=roadHeight(st3.xz);\n\tln=roadHeight(st4.xy+rotate(C,st5.y-0.05));//st5.w\n\trt=roadHeight(st4.xy+rotate(C*(1.0+0.05),st5.y));\n\tst5.x=-(ln-st3.y)*5.0;\n\tst5.z=(rt-st3.y)*5.0;\n\t\n\tsave(0,st0);\n\tsave(1,st1);\n\tsave(2,st2);\n\tsave(3,st3);\n\tsave(4,st4);\n\tsave(5,st5);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}