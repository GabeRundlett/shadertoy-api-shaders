{
    "Shader": {
        "info": {
            "date": "1553316315",
            "description": "Just a weird electric ball.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdBSWR",
            "likes": 10,
            "name": "Electric Ball",
            "published": 3,
            "tags": [
                "ball",
                "electric",
                "electricity"
            ],
            "usePreview": 0,
            "username": "kubiak",
            "viewed": 1514
        },
        "renderpass": [
            {
                "code": "float ringAmp = 0.025;\nfloat ringThickness = 0.01;\nfloat ringFreq = 20.0;\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nvec4 quatForAxisAngle(float angle, vec3 axis) {\n    vec4 q;\n    \n    float half_angle = angle/2.0;\n    q.x = axis.x * sin(half_angle);\n    q.y = axis.y * sin(half_angle);\n    q.z = axis.z * sin(half_angle);\n    q.w = cos(half_angle);\n    return q;\n}\n\nvec3 spherePos(vec2 uv, vec3 ro, float radius, out float h) {\n    //vec3( 0.0, 0.0, 5.0 );\n    vec3 rd = normalize( vec3( uv, -radius ) );\n\n    // intersect sphere\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - 1.0; \n    h = b*b - c;\n    \n    float t = -b - sqrt(h);\n    vec3 pos = ro + t*rd;\n    return pos;\n}\n\nvec3 rotateVectorY(vec3 v, float angle) {\n    vec4 q = quatForAxisAngle(angle, vec3(0.0, 1.0, 0.0));\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n    return v + 2.0*cross(q.xyz, temp); \n}\n\nvec3 ringColor(vec3 bg, float pct) {\n    vec3 baseColor = vec3(0.3, 0.3, 1.0);\n    vec3 boost = (1.0 + (1.0-pct)) * vec3(3.5, 3.5, 3.5);\n    float a = (1.0 - pct) * 0.6;\n    \n    return mix(bg, baseColor * boost, a);\n}\n\nvec3 doRing(vec3 col, vec3 pos, vec2 uv, float down) {\n    float centerDist = 0.7 - abs(0.5 - uv.x);\n    centerDist = pow(centerDist, 4.0);\n    \n    float normSin = sin(pos.z * ringFreq + iTime * 15.0) * ringAmp + 0.5 - (centerDist * 0.5 * down);\n    \n    normSin += noise(pos*15.0) * 0.02;\n    normSin += noise(pos*2.0) * 0.02;\n    //normSin += noise(pos*15.0) * 0.02;\n    \n    float d = abs(normSin - uv.y);\n    if(d < ringThickness)\n    {\n        col = ringColor(col, d / ringThickness);\n    }\n    \n    return col;\n}\n\nvec2 rotate2d(vec2 p, float a) {\n    vec2 rpt = vec2(0.5, 0.5);\n    p = p - rpt;\n\tfloat x = p.x * cos(a) - p.y * sin(a);\n\tfloat y = p.y * cos(a) + p.x * sin(a);\n    return vec2(x, y) + rpt;\n}\n\nvec3 DoRings(vec2 uv, vec2 p, float angle) {\n    float h;\n    uv = rotate2d(uv, angle);\n    \n    vec3 pos = spherePos(p, vec3( 0.0, 0.0, -2.5 ), -2.0, h);\n    vec3 posRotated = rotateVectorY(pos, iTime * -0.5);    \n    vec3 col;\n    col = doRing(col.rgb, posRotated, uv, -1.0);    \n    pos = spherePos(p, vec3( 0.0, 0.0, 2.5 ), 2.0, h);\n    \n    posRotated = rotateVectorY(pos, iTime * -0.5); \n    col = doRing(col.rgb, posRotated, uv, 1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n        \n    vec4 col = vec4(0.0);      \n\n#if 1\n\tcol.rgb += DoRings(uv, p, 0.0);\n    col.rgb += DoRings(uv, p, 3.14 * 0.5);\n    col.rgb += DoRings(uv, p, 3.14 * 0.35);\n    col.rgb += DoRings(uv, p, 3.14 * 0.65);\n#else     \n    col.rgb += DoRings(uv, p, 0.0 + iTime *0.2);\n    //col.rgb += DoRings(uv, p, 3.14 * 0.5 + iTime*0.3);\n    col.rgb += DoRings(uv, p, 3.14 * 0.25 + iTime*-0.25);\n    //col.rgb += DoRings(uv, p, 3.14 * 0.75 + iTime*-0.1);\n    //col.rgb += DoRings(uv, p, 3.14 * 0.15 + iTime*0.05);\n    //col.rgb += DoRings(uv, p, 3.14 * 0.65 + iTime*-0.15);\n#endif\n    \n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}