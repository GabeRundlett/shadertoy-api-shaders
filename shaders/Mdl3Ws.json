{
    "Shader": {
        "info": {
            "date": "1382745508",
            "description": "Raymarching an implicit 3D surface with distance estimation (distance field). Used to compare traditional central-difference based gradients, vs analytical dual-number based techniques. It works great :) See https://www.shadertoy.com/view/Xd2GzR too",
            "flags": 0,
            "hasliked": 0,
            "id": "Mdl3Ws",
            "likes": 47,
            "name": "Dual Real Numbers",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "distancefield",
                "dual"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 4124
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computing the distance field for the implicit function\n//\n// f(x,y,z) = z² - (y²-3x²)·(3y²-x²)·(1-x)\n//\n// which uses the f/|grad(f)| approximation (for more info on this, see this \n// article: https://iquilezles.org/articles/distance). \n//\n// The shader compares two techniques of computing gradients. The traditional\n// way of using central differences and evaluating the function multiple times\n// per point, and the use of  dual-numbers to compute analytical derivatives \n// automatically from the funcion definition \n// (see  http://jliszka.github.io/2013/10/24/exact-numeric-nth-derivatives.html),\n// which requieres far less evaluations (faster!) and no epsilon tweaking \n// whatsoever.\n//\n// See https://www.shadertoy.com/view/Xd2GzR for complex dual numbers\n\n\n//#define DONT_USE_DUALS\n\nconst float precis = 0.001;\n\n//==================================================================================\n// some dual real numbers functions, for f : R3 -> R1\n\nstruct dualR3\n{\n    float x, y, z;\n\tfloat dx, dy, dz;\n};\n\nvec4 dSet( float a ) { return vec4( a, 0.0, 0.0, 0.0 ); }\nvec4 getX( dualR3 n ) {\treturn vec4(n.x, n.dx, 0.0, 0.0 ); }\nvec4 getY( dualR3 n ) {\treturn vec4(n.y, 0.0, n.dy, 0.0 ); }\nvec4 getZ( dualR3 n ) {\treturn vec4(n.z, 0.0, 0.0, n.dz ); }\n\nvec4 dSqrX( dualR3 a ) { return vec4( a.x*a.x, 2.0*a.x*a.dx, 0.0, 0.0 ); }\nvec4 dSqrY( dualR3 a ) { return vec4( a.y*a.y, 0.0, 2.0*a.y*a.dy, 0.0 ); }\nvec4 dSqrZ( dualR3 a ) { return vec4( a.z*a.z, 0.0, 0.0, 2.0*a.z*a.dz ); }\n\nvec4 dMul( vec4 a, vec4 b ) { return vec4( a.x*b.x, a.y*b.x + a.x*b.y, a.z*b.x + a.x*b.z, a.w*b.x + a.x*b.w ); }\n\n\n#ifndef DONT_USE_DUALS\n\n//===========================================================================================\n// dual-numbers way: compute gradients (and distance estimation) analytically\n//===========================================================================================\n\nvec4 func( dualR3 p )\n{\n    // f(x,y,z) = z² - (y²-3x²)·(3y²-x²)·(1-x)\n    return dSqrZ(p) - dMul( dMul( dSqrY(p) - 3.0*dSqrX(p), 3.0*dSqrY(p) - dSqrX(p)), dSet(1.0) - getX(p) );\n}\t\n\t\nvec3 grad( in vec3 p )\n{\n\treturn func( dualR3(p.x,p.y,p.z,1.0,1.0,1.0) ).yzw;\n}\n\nfloat dist( vec3 p )\n{\n    vec4 f = func( dualR3(p.x,p.y,p.z,1.0,1.0,1.0) );\t\n\treturn f.x / length(f.yzw);\n}\t\n\nfloat map( vec3 p )\n{\n\treturn func( dualR3(p.x,p.y,p.z,0.0,0.0,0.0) ).x;\n}\n#else\n//===========================================================================================\n// traditional way: compute gradients (and distance estimation) by central differences\n//===========================================================================================\nfloat func( vec3 p )\n{\n    // f(x,y,z) = z² - (y²-3x²)·(3y²-x²)·(1-x)\n\treturn p.z*p.z - (p.y*p.y-3.0*p.x*p.x)*(3.0*p.y*p.y - p.x*p.x)*(1.0-p.x);\n}\n\nvec3 grad( in vec3 pos )\n{\n    vec3 eps = vec3(precis,0.0,0.0);\n\treturn vec3(\n           func(pos+eps.xyz) - func(pos-eps.xyz),\n           func(pos+eps.zxy) - func(pos-eps.zxy),\n           func(pos+eps.yzx) - func(pos-eps.yzx) ) / (2.0*precis);\n}\n\nfloat dist( vec3 p )\n{\n\treturn func(p) / length(grad(p));\n}\n\nfloat map( vec3 p )\n{\n    return func( p );\n}\n#endif\n\n//==================================================================================\n\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat mind = precis*2.0;\n\tfloat maxd = 15.0;\n\t\n\t\n\t{\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - 1.5*1.5;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0,0.0);\n\th = sqrt(h);\n\tmind = max( mind, -b - h );\n\tmaxd = min( maxd, -b + h );\n    }\n\n    float h = 1.0;\n\tfloat t = mind;\n    for( int i=0; i<150; i++ )\n\t{\n        if( abs(h)<precis||t>maxd ) continue;\n\t    h = dist( ro+rd*t );\n        t += 0.25*abs(h);\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec2(t,sign(h));\n}\n\nvec3 calcNormal( in vec3 p )\n{\n\treturn normalize( grad(p) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n\tfloat mind = precis*2.0;\n\tfloat maxd = 15.0;\n\t\n\t{\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - 1.5*1.5;\n\tfloat h = b*b - c;\n\th = sqrt(h);\n\tmaxd = min( maxd, -b + h );\n\tmind = max( mind, -b - h );\n    }\n\t\n    float res = 1.0;\n    float t = mind;\n    for( int i=0; i<32; i++ )\n    {\n        if( t>maxd ) continue;\n        float h = map( ro + rd*t );\n\t\th = abs(h);\n        res = min( res, k*h/t );\n        t += 0.1;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    // animation\t\n\tfloat time = iTime;\n\t\n\tvec3 tot = vec3(0.0);\n\tfor( int a=0; a<10; a++ )\n\t{\n\t\tvec2 pof = texture( iChannel1, (0.5+13.0*float(a))/iChannelResolution[1].xy  ).xz;\n\t\t\t\t  \n\t\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy + pof)/iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\t\t\n    // camera\n\tfloat an = 0.3*time - 6.2*m.x;\n\tfloat cr = 0.15*sin(0.2*time);\n    vec3 ro = 2.5*vec3(sin(an),0.0,cos(an));\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t// raymarch\n    vec2 t = intersect(ro,rd);\n\t\n\t// shade\n    vec3 col = vec3(0.0);\n    if( t.x>0.0 )\n    {\n        // geometry\n        vec3 pos = ro + t.x*rd;\n        vec3 nor = calcNormal(pos);\n\n\t\t// diffuse\n\t\tcol = vec3(0.0);\n\t\tfloat off = 1.0*texture( iChannel1, fragCoord.xy/iChannelResolution[1].xy, -100.0 ).x;\n\t\tvec3  uu  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\tvec3  vv  = normalize( cross( uu, nor ) );\n\t\tfor( int i=0; i<10; i++ )\n\t\t{\n#if 0\t\n\t\t\tvec3 rr = normalize(-1.0 + 2.0*hash3(off+float(i)*123.5463));\n\t\t\trr = normalize( nor + 7.0*rr );\n\t\t\trr = rr * sign(dot(nor,rr));\t\t\t\t\t\t\t  \n#else\n\t\t\tvec2  aa = hash2( off + float(i)*203.1 + float(a)*13.7 );\n\t\t\t//vec2 aa = texture( iChannel1, (vec2(37.0,31.0)*float(i)+fragCoord.xy)/iChannelResolution[1].xy, -100.0 ).xz;\n\t\t\tfloat ra = sqrt(aa.y);\n\t\t\tfloat rx = ra*cos(6.2831*aa.x); \n\t\t\tfloat ry = ra*sin(6.2831*aa.x);\n\t\t\tfloat rz = sqrt( 1.0-aa.y );\n\t\t\tvec3  rr = vec3( rx*uu + ry*vv + rz*nor );\n#endif\t\t\t\n\t\t\tfloat ds = 1.0;//softshadow( pos, rr, 64.0 );\n\t\t\t\n            col += ds*mix( 0.5*vec3(0.2,0.1,0.0), vec3(0.8,0.9,1.0), smoothstep(-0.1,0.1,rr.y) );\n\t\t\t\t\t\t  //vec3(0.1)*pow( texture( iChannel0, rr ).xyz, vec3(2.2) );\n\t\t}\n        col /= 10.0;\n\t\t\n\t\tfloat ii = 0.5+0.5*t.y;\n\t\t\n        // specular\t\t\n\t\tfloat fre = pow( clamp(1.0+dot(rd,nor),0.0,1.0), 5.0 );\n\t\tvec3 ref = reflect( rd, nor );\n\t\tfloat rs = 1.0;//softshadow( pos, ref, 32.0 );\n        col += ii * 1.0* (0.04 + 1.0*fre) * pow( texture( iChannel2, ref ).xyz, vec3(2.0) ) * rs;\n\n        // color\n\t\tcol *= mix( vec3(1.0,0.5,0.2), vec3(1.0,1.0,1.0), ii );\n\t\t//col *= 1.5;\n    }\n\telse\n\t{\n        // background\t\t\n\t\tcol =0.9* pow( texture( iChannel2, rd ).xyz, vec3(2.2) );\n\t}\n\t\n\t\ttot += col;\n\t}\n\n\ttot /= 10.0;\n\t\n\t// gamma\n\ttot = pow( clamp( tot, 0.0, 1.0 ), vec3(0.45) );\n\t\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}