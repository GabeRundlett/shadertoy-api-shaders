{
    "Shader": {
        "info": {
            "date": "1598256558",
            "description": "Where Captain Nemo commands and watches dolphins (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "wt2fzz",
            "likes": 17,
            "name": "Nautilus Interior",
            "published": 3,
            "tags": [
                "ocean",
                "dolphin",
                "submarine",
                "verne",
                "fiction"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 415
        },
        "renderpass": [
            {
                "code": "// \"Nautilus Interior\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0    // = 1 for optional antialiasing\n\n#define FISH  1  // optional fish (dolphins)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 vuPos, sunDir, ltDir, qHit, bSize;\nfloat tCur, dstFar, winRad, tunRad, whlAng, wvBase;\n#if FISH\nvec3 fishPos;\nfloat fishAngI;\n#endif\nint idObj, idObjEx;\nconst int idWal = 1, idWalB = 2, idTun = 3, idLad = 4, idWin = 5, idGlas = 6, idWEnd = 7, idNut = 8,\n   idPipe = 9, idPer = 10, idScrn = 11, idWhl = 12, idWhlB = 13, idWhlS = 14, idWhlD = 15, idComp = 16,\n   idLev = 17, idDial = 18, idBras = 19, idBox = 20, idFlot = 21, idLit = 22;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = (id);  qHit = q; }\n\nvec2 SphGrid (vec3 p)\n{\n  vec3 q;\n  vec2 a, sc, nSeg;\n  float dMin, d1, d2, r;\n  nSeg = vec2 (12., 15.);\n  sc = sin (0.07 * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n  q = p;\n  r = length (q.yz);\n  a = 2. * pi * (floor (nSeg * atan (q.zx, - vec2 (q.y, r)) / (2. * pi)) + 0.5) / nSeg;\n  q.yz = Rot2D (q.yz, a.x);\n  d1 = dot (vec2 (q.y, abs (q.z)), sc);\n  q.yz = Rot2D (vec2 (r, q.x), a.y);\n  d2 = dot (vec2 (q.y, abs (q.z)), sc);\n  return vec2 (d1, d2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp, qq;\n  vec2 d2;\n  float dMin, d, wThk, zOff, s, dw, r;\n  dMin = dstFar;\n  wThk = 0.07;\n  zOff = -2.;\n  pp = p;\n  pp.x = abs (pp.x) - bSize.x;\n  q = pp;\n  d2 = SphGrid (q);\n  d2.x = max (d2.x, 0.3 * winRad - length (q.yz)); \n  d = SmoothMin (d2.x, d2.y, 0.02);\n  d = max (SmoothMax (abs (PrSphDf (q, winRad)) - wThk, d, 0.02), -0.01 - q.x);\n  DMINQ (idWin);\n  d = max (abs (PrSphDf (q, winRad + 0.5 * wThk)) - 0.25 * wThk, -0.01 - pp.x);\n  DMINQ (idGlas);\n  q = pp;\n  q.x -= -0.05;\n  d = PrCylAnDf (q.yzx, winRad - wThk + 0.2, 0.2, 0.05);\n  q.yz = Rot2D (q.yz, 2. * pi * floor (12. * atan (q.z, - q.y) / (2. * pi) + 0.5) / 12.);\n  q.xy -= vec2 (-0.1, - winRad - 0.1);\n  d = max (d, - PrCylDf (q.yzx, 0.13, 0.1));\n  DMINQ (idWEnd);\n  d = max (abs (q.z) - 0.5 * min (abs (q.z) - sqrt3 * abs (q.y), 0.) - 0.1, abs (q.x - 0.05) - 0.05);\n  DMINQ (idNut);\n  q = p;\n  dw = winRad - length (q.yz);\n  q.z -= zOff;\n  s = length (q.zx - vec2 (clamp (q.z, - bSize.z, bSize.z), 0.)) - bSize.x - 0.1;\n  d = abs (max (s, abs (q.y) - bSize.y)) - 0.02;\n  qq.y = q.y + bSize.y;\n  qq.z = abs (q.z) - bSize.z - bSize.x + tunRad + 0.05;\n  r = length (vec2 (q.x, qq.z));\n  d = max (dw, max (d, min (tunRad + 0.05 - r, 0.2 - abs (qq.y + 0.1))));\n  DMINQ (idWal);\n  q.y = qq.y + 0.9;\n  q.z = qq.z;\n  d = min (max (abs (r - tunRad) - 0.05, abs (q.y) - 1.), q.y + 0.9);\n  DMINQ (idTun);\n  d = abs (s + 0.08) - 0.04;\n  q = p;\n  q.y = mod (q.y + 1., 2.) - 1.;\n  q.z -= zOff;\n  if (d < bSize.z - abs (q.z)) {\n    q.z = mod (q.z + 1., 2.) - 1.;\n  } else {\n    q.z = abs (q.z) - bSize.z;\n    q.zx = Rot2D (q.zx, pi / 12.);\n    q.z = 0.85 * dot (q.zx, sin (2. * pi * (floor (12. * atan (q.x, - q.z) / (2. * pi)) +\n       0.5) / 12. + vec2 (0., 0.5 * pi)));\n  }\n  d = max (dw + 0.34, SmoothMax (d, 0.05 - length (max (abs (q.yz) - 0.85, 0.)), 0.03));\n  DMINQ (idWalB);\n  q = p;\n  q.z -= zOff;\n  q.xz = abs (q.xz) - vec2 (bSize.x - 0.25, bSize.z + 0.8);\n  d = PrCylDf (q.xzy, 0.1 + 0.03 * smoothstep (0.87, 0.9, abs (mod (q.y + 1., 2.) - 1.)), bSize.y);\n  DMINQ (idPipe);\n  q.xy -= vec2 (-0.15, -2.);\n  d = PrCylDf (q.yzx, 0.3, 0.05);\n  DMINQ (idPipe);\n  q = p;\n  q.z = abs (q.z - zOff) - bSize.z - bSize.x + 0.4;\n  d = max (abs (q.y) - bSize.y - 2., PrCylDf (vec3 (q.x, mod (q.y + 0.5, 1.) - 0.5, q.z).yzx,\n     0.09, 0.7));\n  d = min (d, PrCylDf (vec3 (abs (q.x) - 0.7, q.yz).xzy, 0.11, bSize.y + 2.));\n  DMINQ (idLad);\n  q = p;\n  q.yz -= vec2 (bSize.y - 1.6, 3.);\n  d = PrCylDf (q.xzy, 0.15, 1.6);\n  DMINQ (idPer);\n  q.y -= -2.2;\n  d = min (PrCapsDf (vec3 (q.x, abs (q.y) - 0.6, q.z).yzx, 0.05, 1.2),\n     PrCapsDf (vec3 (abs (q.x) - 1.2, q.yz).xzy, 0.05, 0.6));\n  DMINQ (idPer);\n  d = PrBoxDf (q, vec3 (1.2, 0.6, 0.03));\n  DMINQ ((q.z < 0.) ? idScrn : idPer);\n  q = p;\n  q.yz -= vec2 (-1.2, 1.5);\n  d = PrCylDf (q, 0.1, 0.2);\n  DMINQ (idWhl);\n  q.xy = Rot2D (q.xy, whlAng);\n  d = min (PrCylAnDf (q, 1.1, 0.1, 0.1), PrCylDf (q + vec3 (0., 0., -0.3), 0.2, 0.5));\n  DMINQ (idWhl);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (12. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 12.);\n  q.x += 0.8;\n  d = PrCapsDf (q.yzx, 0.05, 0.8);\n  DMINQ (idWhlS);\n  q = p;\n  q.yz -= vec2 (- bSize.y + 2.3, 2.55);\n  d = PrRoundBoxDf (q, vec3 (0.3, 2.3, 0.3), 0.05);\n  q.y -= 2.2;\n  d = min (d, PrRoundBoxDf (q, vec3 (1.2, 0.1, 0.3), 0.05));\n  DMINQ (idWhlB);\n  q.x = abs (q.x) - 1.1;\n  q.y -= 0.2;\n  d = PrCylDf (q.xzy, 0.12, 0.1);\n  DMINQ (idBras);\n  q = p;\n  q.yz -= vec2 (- bSize.y + 1.4, 2.55);\n  d = PrCylDf (q.yzx, 0.1, 0.65);\n  q.x = abs (q.x) - 0.5;\n  d = min (d, PrCylDf (q.yzx, 0.7, 0.1));\n  DMINQ (idWhlD);\n  q = p;\n  q.x = abs (q.x) - 2.;\n  q.y -= - bSize.y + 0.5;\n  q.z = (q.z > 0.) ? q.z - 6. : abs (q.z + 8.) - 2.;\n  d = PrRoundBoxDf (q, vec3 (0.5, 0.5, 1.), 0.05);\n  DMINQ (idBox);\n  q.xy -= vec2 (bSize.x - 2.1, bSize.y - 2.);\n  q.z = abs (q.z) - 0.15;\n  d = PrCylDf (q.xzy, 0.05, 4.);\n  DMINQ (idPipe);\n  q.y = abs (q.y - 3.5) - 0.5;\n  d = PrRoundBoxDf (q, vec3 (0.1, 0.25, 0.5), 0.05);\n  DMINQ (idBox);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (2., - bSize.y + 0.7, 0.1);\n  q.x = abs (q.x);\n  d = max (- min (min (max (q.x - 0.07, abs (q.z) - 0.6), 0.), 0.18 - q.x),\n     length (vec2 (q.y - min (q.y, 0.5), q.z)) - 0.7);\n  d = min (min (d, PrCylDf (q.yzx, 0.1, 0.25)), PrCapsDf (q.xzy, 0.06, 2.));\n  DMINQ (idLev);\n  q = p;\n  q.yz -= vec2 (-0.35, 2.65);\n  r = length (q.xz);\n  d = max (abs (r - 0.55) - 0.05, abs (q.y) - 0.1);\n  DMINQ (idBras);\n  d = max (r - 0.5, abs (q.y + 0.02) - 0.08);\n  DMINQ (idComp);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (bSize.x - 0.05, -1., 4.);\n  d = PrCylDf (q.yzx, 0.35, 0.05);\n  DMINQ (idDial);\n  q.y -= -2.;\n  d = PrCylDf (q.xzy, 0.05, 2.);\n  DMINQ (idPipe);\n  q = p;\n  q = abs (vec3 (q.x, q.y + 4., q.z - zOff))- vec3 (bSize.x - 0.25, 0.5,  bSize.z - 1.7);\n  q.z = abs (q.z) - 1.2;\n  d = PrCapsDf (q, 0.4, 0.5);\n  DMINQ (idFlot);\n  q = p;\n  q.xz = abs (vec2 (q.x, q.z - zOff));\n  q -= vec3 (bSize.x, bSize.y - 1., 4.);\n  q.z = abs (q.z) - 2.;\n  d = PrCapsDf (q, 0.2, 0.5);\n  DMINQ (idLit);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    d = 0.01 + float (j) / 20.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.6 + 0.4 * clamp (1. - 2. * ao, 0., 1.);\n}\n\nvec4 ObjCol (vec3 ro)\n{\n  vec4 col4;\n  vec3 w;\n  float a, s;\n  if (idObj <= idLad) {\n    if (idObj == idWal) {\n      col4 = vec4 (0.7, 0.8, 0.7, 0.1);\n      if (ro.y < - bSize.y + 0.1) {\n        col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (8. * ro.x, 1.));\n        w.xz = max (abs (ro.xz) - vec2 (1.6, 2.6), 0.);\n        if (length (w.xz) < 0.5) col4 = vec4 (0.5, 0.2, 0., 0.1) *\n           (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (8. * ro.z, 1.)));\n      } else if (ro.y > bSize.y - 0.1) {\n        col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (4. * ro.z, 1.));\n        col4 = mix (vec4 (0.8, 0.3, 0.3, 0.1), col4, step (0.2, length (vec2 (abs (ro.x) - 2.,\n           mod (ro.z + 1., 2.) - 1.))));\n        col4 = mix (vec4 (1., 1., 0.8, -1.), col4, smoothstep (0.03, 0.05, abs (abs (ro.x) - 3.)));\n        col4 = mix (vec4 (0., 0.5, 0., -1.), col4, step (0.07, abs (length (vec2 (abs (ro.z + 2.) - bSize.z -\n           bSize.x + tunRad + 0.05, ro.x)) - tunRad)));\n      } else col4 = mix (vec4 (0.3, 1., 0.3, 0.), col4, smoothstep (0.05, 0.1, \n         max (abs (abs (ro.x) - 2.3), abs (ro.y) - 0.7)));\n    } else if (idObj == idWalB) {\n      col4 = vec4 (0.6, 0.7, 0.6, 0.1) * (0.8 + 0.2 * smoothstep (0.05, 0.1,\n         length (abs (qHit.yz) - 1.)));\n    } else if (idObj == idTun) {\n      col4 = mix (vec4 (0.3, 0.7, 0.3, -1.), vec4 (0., 0.4, 0., 0.), \n         step (0., max (length (qHit.xz) - tunRad, 0.5 - qHit.y)));\n    } else if (idObj == idLad) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.1);\n    }\n  } else if (idObj <= idPipe) {\n    if (idObj == idWin) {\n      col4 = vec4 (0.7, 0.8, 0.7, 0.2) * (0.5 + 0.5 * step (0.02, abs (length (qHit) - winRad)));\n    } else if (idObj == idWEnd) {\n      col4 = vec4 (0.5, 0.55, 0.1, 0.2) * (0.5 + 0.5 * step (abs (ro.x), bSize.x - 0.1));\n    } else if (idObj == idNut) {\n      col4 = vec4 (0.4, 0.4, 0.5, 0.2);\n    } else if (idObj == idPipe) {\n      col4 = vec4 (0.3, 0.3, 0.3, 0.05);\n    }\n  } else if (idObj <= idWhlS) {\n    if (idObj == idPer) {\n      col4 = vec4 (0.4, 0.4, 0.42, 0.1);\n    } else if (idObj == idWhl) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.5 + 0.5 * step (0., min (abs (length (qHit.xy) - 1.1) - 0.02,\n         length (qHit.xy) - 0.11)));\n      col4 = mix (vec4 (0.4, 0.4, 0.8, 0.3), col4, step (0.05, length (vec2 (qHit.x, qHit.y - 1.1))));\n    } else if (idObj == idWhlB) {\n      col4 = mix (vec4 (0.8, 0.8, 0.8, -1.), vec4 (0.7, 0.5, 0.2, 0.05),\n         smoothstep (0.01, 0.02, abs (abs (qHit.z) - 0.15)));\n    } else if (idObj == idWhlS) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.5 + 0.5 * step (0.05, abs (qHit.x + 0.7)));\n    }\n  } else if (idObj <= idDial) {\n    if (idObj == idWhlD) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.5 + 0.5 * step (0., min (abs (qHit.x) - 0.04,\n         length (qHit.yz) - 0.105)));\n    } else if (idObj == idComp) {\n      if (qHit.y > 0.) {\n        col4 = vec4 (1., 1., 1., 0.1);\n        qHit.xz = Rot2D (qHit.xz, -0.5 * whlAng);\n        col4 = mix (vec4 (0.8, 0.2, 0.2, 0.1), col4, step (0.05, length (vec2 (qHit.x, qHit.z - 0.4))));\n        s = min (abs (qHit.x), abs (qHit.z));\n        qHit.xz = Rot2D (qHit.xz, 2. * pi * floor (36. * atan (qHit.z, - qHit.x) /\n           (2. * pi) + 0.5) / 36.);\n        if (abs (qHit.x + 0.45) < 0.02) s = min (s, abs (qHit.z));\n        col4 *= (0.1 + 0.9 * smoothstep (0.003, 0.008, s));\n      } else col4 = vec4 (0.7, 0.7, 0., 0.2);\n    } else if (idObj == idLev) {\n      col4 = (length (qHit.xz) > 0.07) ? vec4 (0.7, 0.5, 0.2, 0.05) : vec4 (0.3, 0.4, 0.1, 0.05);\n      col4 *= 0.5 + 0.5 * step (0., min (1.7 - qHit.y, length (qHit.yz) - 0.11));\n    } else if (idObj == idDial) {\n      if (length (qHit.yz) < 0.27) {\n        if (ro.z < 0.) {\n          s = 1.;\n          a = atan (qHit.z, - qHit.y) / (2. * pi);\n          if (abs (a) > 0.12) {\n            s = abs (qHit.z);\n            qHit.yz = Rot2D (qHit.yz, 2. * pi * floor (16. * a + 0.5) / 16.);\n            if (abs (qHit.y + 0.25) < 0.02) s = min (s, abs (qHit.z));\n          }\n        } else {\n          s = abs (dot (sign (Rot2D (qHit.yz, - pi * tCur)), vec2 (0.5)));\n        }\n        col4 = vec4 (1., 1., 1., 0.1) * (0.1 + 0.9 * smoothstep (0.01, 0.02, s));\n      } else col4 = vec4 (0.7, 0.7, 0., 0.2);\n    }\n  } else if (idObj <= idLit) {\n    if (idObj == idBras) {\n      col4 = vec4 (0.7, 0.7, 0., 0.2);\n      qHit.xz = abs (qHit.xz);\n      if (abs (length (qHit.xz) - 0.55) < 0.04) col4 *= 0.5 +\n         0.5 * smoothstep (0.005, 0.01, min (qHit.x, qHit.z));\n    } else if (idObj == idBox) {\n      if (abs (ro.x) < 3.) col4 = vec4 (0.3, 0.5, 0.4, 0.) * (0.5 + \n         0.5 * smoothstep (0.02, 0.03, abs (abs (qHit.x) - 0.1) - 0.01));\n      else col4 = vec4 (0.5, 0.7, 0.6, 0.1) * (0.5 + 0.5 * smoothstep (0.02, 0.03, abs (qHit.y)));\n    } else if (idObj == idFlot) {\n      col4 = vec4 (0.7, 0.3, 0.1, 0.) * (0.5 + 0.5 * smoothstep (0.02, 0.03,\n         abs (abs (qHit.z) - 0.3) - 0.05));\n    } else if (idObj == idLit) {\n      col4 = vec4 (vec3 (1., 1., 0.8) * (0.93 + 0.07 * cos (32. * pi * qHit.y)), -1.);\n    }\n  }\n  return col4;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float wAmp, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.05 * p + vec2 (0., 0.05 * tCur);\n  wAmp = 1.;\n  h = wvBase;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= 2. * qRot;\n    t4 = q.xyxy + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    t4 = abs (sin (t4));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wAmp *= 0.5;\n  }\n  return 0.4 * h * (1. - smoothstep (0.5, 1.2, length (p - vuPos.xz) / dstFar));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd, float u)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  ro.y *= u;\n  rd.y *= u;\n  s = 0.;\n  sLo = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - u * WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 1.3 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > u * WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x)).xzy;\n}\n\n#if FISH\n\nfloat FishDf (vec3 p)\n{\n  vec3 q;\n  float dMin, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye;\n  p.x = abs (p.x);\n  p.z -= 2.;\n  p.yz = Rot2D (p.yz, 0.2 * fishAngI);\n  q = p;\n  q.z -= -0.6;\n  dBodyF = PrEllipsDf (q, vec3 (0.7, 0.8, 2.4));\n  q = p;\n  q.z -= -1.2;\n  q.yz = Rot2D (q.yz, fishAngI);\n  q.z -= -1.6;\n  dBodyB = PrEllipsDf (q, vec3 (0.35, 0.5, 2.5));\n  q.z -= -2.2;\n  q.yz = Rot2D (q.yz, 2. * fishAngI);\n  q.xz -= vec2 (0.5, -0.5);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.8, 0.07, 0.4));\n  q = p;\n  q.yz -= vec2 (-0.3, 1.7);\n  q.yz = Rot2D (q.yz, 0.1);\n  q.y = abs (q.y) - 0.04;\n  dMouth = PrEllipsDf (q, vec3 (0.25, 0.12, 0.6));\n  q = p;\n  q.yz -= vec2 (0.7, -1.);\n  q.yz = Rot2D (q.yz, 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.05, 1., 0.35));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz -= vec2 (0.7, -0.1);\n  q.xz = Rot2D (q.xz, 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.9, 0.04, 0.3));\n  q = p;\n  q -= vec3 (0.4, -0.1, 1.1);\n  dEye = PrSphDf (q, 0.1);\n  idObjEx = 1;\n  dMin = SmoothMin (dBodyF, dBodyB, 0.3);\n  dMin = SmoothMin (SmoothMin (dMin, dFinT, 0.1), dMouth, 0.15);\n  dMin = SmoothMin (SmoothMin (dMin, dFinD, 0.02), dFinP, 0.02);\n  if (dEye < dMin) {\n    idObjEx = 2;\n    dMin = dEye;\n  }\n  return 0.9 * dMin;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  p.x = abs (abs (p.x) - 18.) - 4.;\n  return FishDf (p - fishPos);\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\n#endif\n\nvec3 SkyGrndCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float sd, a, f, ff, fd;\n  a = atan (rd.z, rd.x) + 0.001 * tCur * sign (rd.x);\n  if (rd.y < 0.01 * Fbm1 (64. * a) - 0.005) {\n    col = mix (vec3 (0.2, 0.35, 0.2), vec3 (0.3, 0.35, 0.35), 0.5 +\n       0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n       (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  } else {\n    q = 0.01 * (ro.xz + vec2 (0., 8.) * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = 0.7 * (0.7 + 0.5 * ff) * (vec3 (1.) - vec3 (0.2, 0.2, 0.1) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix ((vec3 (0.7, 0.7, 0.75)), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n    sd = pow (max (dot (rd, sunDir), 0.), 256.);\n    col += (0.1 * sd + 0.3 * pow (sd, 4.)) * vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvec3 SeaFloorCol (vec3 rd)\n{\n  return mix (vec3 (0.05, 0.17, 0.12), vec3 (0., 0.15, 0.2), \n     smoothstep (0.4, 0.7, Fbm2 (2. * rd.xz / rd.y)));\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 2.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return vec3 (0.1, 0.3, 0.4) * (0.2 + 0.4 * (rd.y + 1.)) * (1. + 0.3 * gd);\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnw, rdd, rdo, colUw, ltDirF;\n  float dstObj, dstWat, eta, atFac; \n  bool unWat, hitWat;\n  eta = 1.33;\n  atFac = 3.;\n  rdo = rd;\n  unWat = (ro.y < WaveHt (ro.xz));\n  dstWat = WaveRay (ro, rd, (! unWat ? 1. : -1.));\n#if FISH\n  if (idObj == idGlas) {\n    fishAngI = 0.1 * sin (pi * tCur);\n    dstObj = ExObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == 1) col4 = vec4 (vec3 (0.7, 0.7, 0.8) * (1. -\n         0.2 * smoothstep (-0.5, -0.3, vn.y)), 0.1);\n      else if (idObjEx == 2) col4 = vec4 (0.3, 1., 0.3, -1.);\n      if (col4.a >= 0.) {\n        ltDirF = normalize (vec3 (0., 1., 0.5));\n        col = col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDirF), 0.) +\n           col4.a * pow (max (dot (reflect (rd, vn), ltDirF), 0.), 32.));\n      } else col = col4.rgb * (0.7 - 0.3 * dot (vn, rd));\n    }\n  } else dstObj = dstFar;\n#else\n  dstObj = dstFar;\n#endif\n  hitWat = (dstWat < min (dstObj, dstFar));\n  if (hitWat) {\n    ro += dstWat * rd;\n    vnw = WaveNf (ro, dstWat);\n    if (! unWat) {\n      rd = refract (rd, vnw, 1. / eta);\n    } else {\n      vnw *= -1.;\n      rdd = refract (rd, vnw, eta);\n      rd = (length (rdd) > 0.) ? rdd : reflect (rd, vnw);\n    }\n  }\n  if (dstObj >= dstFar) col = (hitWat == unWat) ? SkyGrndCol (ro, rd) : SeaFloorCol (rd);\n  if (! unWat) {\n    if (hitWat) col = mix (col, 0.8 * SkyGrndCol (ro, reflect (rdo, vnw)),\n       pow (1. - abs (dot (rdo, vnw)), 5.));\n  } else {\n    colUw = UnwCol (rd);\n    if (dstObj < dstFar) col = mix (colUw, col, min (1., exp (- atFac * dstObj / dstFar)));\n    else if (dstWat < dstFar) col = (rd.y > 0.) ? mix (colUw, col,\n       exp (- atFac * dstWat / dstFar)) : colUw;\n    else col = colUw;\n  }\n\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDirL[5];\n  vec2 vf;\n  float dstObj, nDotL, dSum, sSum, ao, wd;\n  bool isMet, exVu;\n  bSize = vec3 (4.5, 5.1, 10.);\n  winRad = 2.5;\n  tunRad = 1.55;\n  dstObj = ObjRay (ro, rd);\n  exVu = (dstObj < dstFar && (idObj == idScrn || idObj == idGlas));\n  if (dstObj < dstFar && ! exVu) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro);\n    vf = vec2 (0.);\n    if (idObj == idWal || idObj == idWalB || idObj == idWin || idObj == idWEnd || idObj == idTun ||\n       idObj == idBox) {\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idNut || idObj == idPipe) {\n      vf = vec2 (128., 0.2);\n    } else if (idObj == idWhl || idObj == idWhlS || idObj == idWhlD) {\n      vf = vec2 (128., 0.1);\n    } else if (idObj == idWhlB || idObj == idLev) {\n      vf = vec2 (64., 0.2);\n    }\n    wd = smoothstep (-0.7, 0.7, wvBase);\n    if (col4.a >= 0.) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      ltDirL[0] = normalize (bSize * vec3 (1., 0.7, 1.));\n      ltDirL[1] = normalize (bSize * vec3 (-1., 0.7, 1.));\n      ltDirL[2] = normalize (bSize * vec3 (1., 0.7, -1.));\n      ltDirL[3] = normalize (bSize * vec3 (-1., 0.7, -1.));\n      ltDirL[4] = ltDir;\n      dSum = 0.;\n      sSum = 0.;\n      isMet = (idObj == idWal || idObj == idWalB || idObj == idComp || idObj == idDial);\n      for (int k = 0; k < 5; k ++) {\n        nDotL = max (dot (vn, ltDirL[k]), 0.);\n        if (isMet) nDotL *= nDotL;\n        dSum += ((k < 5) ? 0.7 : 1.) * nDotL;\n        sSum += ((k < 5) ? 0.7 : 1.) * pow (max (dot (normalize (ltDirL[k] - rd), vn), 0.), 64.);\n      }\n      ao = ObjAO (ro, vn);\n      col = ao * col4.rgb * (0.2 + 0.4 * dSum) + step (0.95, ao) * col4.a * sSum;\n      col *= mix (vec3 (1.), vec3 (0.6, 0.8, 1.), wd);\n    } else col = col4.rgb * (0.7 - 0.3 * dot (vn, rd)) * (1. - 0.5 * wd);\n  }\n  if (exVu) {\n    if (idObj == idGlas) {\n      ro += dstObj * rd;\n    } else {\n      ro = vec3 (0., 3., 3.);\n      rd = normalize (vec3 (qHit.xy, 2.));\n    }\n    col = ExShowScene (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2.5 * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = mod (0.03 * tCur, 2.);\n    az += 0.5 * pi * SmoothBump (0.25, 0.75, 0.15, mod (t, 1.)) * sign (t - 1.);\n    el += 0.1 * abs (az);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -4.5);\n  ro.z *= 1. + abs (cos (az));\n  vuPos = ro;\n  zmFac = 3. + 1.5 * abs (sin (az));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n  sunDir = normalize (vec3 (1., 1., -1.));\n  whlAng = 0.2 * pi * sin (0.05 * pi * tCur);\n  wvBase = 2. + 7. * sin (0.03 * pi * tCur);\n#if FISH\n  fishPos = vec3 (0., wvBase - 8., mod (45. + 2. * tCur, 90.) - 45.);\n#endif\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a +\n       0.5) * pi)) / zmFac;\n    uvv.x = 2. * tan (0.5 * atan (uvv.x / asp)) * asp;\n    rd = vuMat * normalize (vec3 (uvv, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}