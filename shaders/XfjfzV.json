{
    "Shader": {
        "info": {
            "date": "1725912734",
            "description": "Realtime videofeed from dedicated forcefield testing site.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfjfzV",
            "likes": 8,
            "name": "Forcefield testing",
            "published": 3,
            "tags": [
                "icosahedron",
                "forcefield"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 158
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Forcefield visual effect.\n\n//==============================================================================\n\n// NOTE: some values may cause problems (code doesn't\n// handle a+b-c=0, though it should).\nconst float blast_attack =0.0625;\nconst float blast_release=0.37;\nconst float field_release=0.25;\nconst float frame_release=1.0/50.0;\n\nconst float rof=2.5; // Rate of fire.\n\nconst float FAR=1e7;\n\n//==============================================================================\n\nconst float pi=3.14159265358979;\n\n//==============================================================================\n// Similar to https://www.shadertoy.com/view/lcBXDW\n// but gaussian only.\n\n// From https://www.shadertoy.com/view/ml3yWj\n// Eabs<3.5e-4\n// Erel<3.6e-4\nfloat erf(float x)\n{\n    return tanh(x*(1.128776206+x*x*0.100709669));\n}\n\n// Integrate blob's field along the ray ro+t*rd, on [L,H].\nfloat I(float A,mat3 M,vec3 c,vec3 ro,vec3 rd,float L,float H)\n{\n    float P=sqrt(dot((rd*M),rd));\n    float Q=dot((ro-c)*M,rd)+dot(rd*M,ro-c);\n    float R=dot((ro-c)*M,ro-c);\n    return 0.5*sqrt(pi)/P*exp(0.25*Q*Q/(P*P)-R)*(erf(P*H+0.5*Q/P)-erf(P*L+0.5*Q/P));\n}\n\n//==============================================================================\n// From https://www.shadertoy.com/view/MfBfzh\n\n// Compute normal/tangent/bitangent basis (in columns of\n// the returned matrix) for face containing (unnormalized)\n// direction v.\nmat3 ico_basis(vec3 v)\n{\n    vec3 a=abs(v),s=2.0*step(0.0,v)-1.0;                    // Magnitude and zero-less sign.\n    vec3 d=vec3(sqrt(1.25)+0.5,sqrt(1.25)-0.5,0)/sqrt(3.0); // Off-diagonal normal coordinates.\n    vec3 n=vec3(1)/sqrt(3.0);                               // Find normal to containing face.\n    if(dot(a,d    -n)>0.0) n=d;                             // Heavily inspired by\n    if(dot(a,d.yzx-n)>0.0) n=d.yzx;                         // \"Dodecahedron & Icosahedron\" by gaz\n    if(dot(a,d.zxy-n)>0.0) n=d.zxy;                         // https://www.shadertoy.com/view/wdcczs\n    n*=s;                                                   // Incorporate signs.\n    vec3 t=normalize(n-s*(abs(n.x)==abs(n.y)?d:n*n));       // Tangent.\n    t=normalize(t-dot(t,n)*n);                              // Make orthogonal to normal.\n    return mat3(n,t,cross(n,t));                            // Output basis.\n}\n\n// Compute normalized barycentric coordinates corresponding\n// to (unnormalized) direction v in basis B.\nvec3 ico_weights(mat3 B,vec3 v)\n{\n    v/=dot(v,B[0]);                                                      // Project onto icosahedron with in-radius 1.\n    vec3 w=((v-B[0])*B).yz*mat3x2(1,0,-0.5,sqrt(0.75),-0.5,-sqrt(0.75)); // Barycentric coordinates.\n    return w=(2.0+(3.0+sqrt(5.0))*w)/6.0;                                // Normalize to [0;1]^3, x+y+z=1.\n}\n\n// Compute normalized direction from basis and barycentric coordinates.\n// Inverse of ico_weights.\nvec3 ico_dir(mat3 B,vec3 v)\n{\n    return normalize(B*vec3(1,mat3x2(1,0,0,sqrt(1.0/3.0),0,-sqrt(1.0/3.0))*(6.0*v-2.0)/(3.0+sqrt(5.0))));\n}\n\n//==============================================================================\n// From https://www.shadertoy.com/view/dllSW7\n\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\n//==============================================================================\n// Noise with derivatives, and its fBm.\n// From https://www.shadertoy.com/view/DtdyDl\n\nfloat rnd2i(ivec2 v)\n{\n    return float(int(hash(uint(v.x+65536*v.y))))*4.6566129e-10;\n}\n\nfloat rnd3i(ivec3 v)\n{\n    return float(int(hash(uint(v.x+1024*v.y+1024*1024*v.z))))*4.6566129e-10;\n}\n\n// 2D value noise. Gradient in xy, value in z.\nvec3 noise2d(vec2 v)\n{\n    ivec2 i=ivec2(floor(v)),e=ivec2(0,1);\n    v=fract(v);\n    float A=rnd2i(i+e.xx);\n    float B=rnd2i(i+e.yx);\n    float C=rnd2i(i+e.xy);\n    float D=rnd2i(i+e.yy);\n    vec2 d=30.0*v*v*(v*(v-2.0)+1.0);\n    v=v*v*v*(v*(v*6.0-15.0)+10.0);\n    return vec3(\n        vec2(mix(B-A,D-C,v.y),mix(C-A,D-B,v.x))*d,\n        mix(mix(A,B,v.x),mix(C,D,v.x),v.y));\n}\n\nvec3 fbm2d(int n,float a,mat2 B,vec2 v)\n{\n    float w=1.0;\n    mat2 M=mat2(1,0,0,1);\n    vec3 ret=vec3(0);\n    for(int i=0;i<n;++i)\n    {\n        vec3 r=w*noise2d(M*v);\n        r.xy=r.xy*M;\n        ret+=r;\n        w*=a;\n        M=B*M;\n    }\n    return ret;\n}\n\n//==============================================================================\n\nvec3 height(int n,vec2 v)\n{\n    float a=0.0625,b=2.0;\n    return vec3(a*b,a*b,a)*fbm2d(n,0.5,2.25*mat2(0.6,-0.8,0.8,0.6),b*v);\n}\n\n//==============================================================================\n\n// Returns t-th blast center, amplitude and width.\nvec4 blast(int t)\n{\n    uint h=hash(uint(t));\n    float r=sqrt(float(h&255u)/255.0);\n    float a=2.0*pi*float((h>>8)&255u)/256.0;\n    float A=0.5+2.5*float((h>>16)&255u)/256.0;\n    float w=0.125+0.25*float((h>>24)&255u)/256.0;\n    return vec4(r*cos(a),r*sin(a)+1.0,A,w);\n}\n\n// Returns the exponential moving average of the normalized\n// blast time profile (w chosen to have maximum 1 at T):\n//     w*(1-exp(-t/A))*exp(-t/B)\n// that is\n//     w/C ∫ (1-exp(-(t-τ)/A))*exp(-(t-τ)/B)*exp(-τ/C) dτ on [0;∞)\nfloat blast_intensity(float A,float B,float C,float t)\n{\n    float a=1.0/A+1.0/B;\n    float b=1.0/B;\n    float c=1.0/C;\n    float T=log(a/b)/(a-b);\n    float w=1.0/(exp(-b*T)-exp(-a*T));\n    return w*c*((exp(-b*t)-exp(-c*t))/(c-b)-(exp(-a*t)-exp(-c*t))/(c-a));\n}\n\nfloat blast_sum(vec3 ro,vec3 rd,vec2 s,float A,float B,float C,float t)\n{\n    float ret=0.0;\n    for(int i=0;i<int(7.0*(B+C)+1.0);++i)\n    {\n        vec4 F=blast(int(t)-i);\n        float w=1.0/(F.w*F.w);\n        ret+=F.z*blast_intensity(A,B,C,float(i)+fract(t))\n                *I(F.z,mat3(w,0,0,0,w,0,0,0,0),vec3(F.xy,0),ro,rd,s.x,s.y);\n    }\n    return ret;\n}\n\nfloat blast_sum(vec3 ro,vec3 rd,vec2 s,float A,float B,float C,float t,float f)\n{\n    return blast_sum(ro,rd,s,f*A,f*B,f*C,f*t)/f;\n}\n\n//==============================================================================\n\nvec3 sky(vec3 r)\n{\n    return mix(vec3(0.01,0.04,0.5),vec3(0.4,0.7,0.9),1.0/(1.0+25.0*abs(r.y)));\n}\n\n//==============================================================================\n\nconst vec3 l=normalize(vec3(2,5,3)); // Fake light direction.\n\nvec4 ray(vec3 ro,vec3 rd)\n{\n    vec4 ret=vec4(sky(rd),FAR);\n    if(rd.y<0.0) // Terrain.\n    {\n        // Dumb, secant based ray-terrain intersection,\n        // for flat-ish terrain.\n        float h=0.0625;\n        ret.w=-ro.y/rd.y;\n        vec3 r=ro+ret.w*rd;\n        ret.w+=height(2,r.xz).z/rd.y;\n        r=ro+ret.w*rd;\n        vec3 v=height(5,r.xz);\n        vec3 n=normalize(vec3(v.xy,exp(2e-2*length(r-ro))).xzy);\n        ret.xyz=mix(ret.xyz,vec3(0.5,0.2,0.1)*(max(dot(n,l),0.0)+0.125*v.z),exp(-1e-3*length(r-ro)));\n    }\n    float R=1.0,p=dot(ro,rd),d=p*p-dot(ro,ro)+R*R;\n    if(d>0.0) // Generator.\n    {\n        float t=-p-sqrt(d);\n        vec3 r=ro+t*rd;\n        vec3 n=normalize(r);\n        mat3 B=ico_basis(n);\n        float G=4.0;\n        vec3 w=G*(3.0*ico_weights(B,n)-1.0);\n        vec3 e=round((floor(w-w.yzx)-floor(w.zxy-w))/3.0); // https://www.shadertoy.com/view/dtySDy\n        e=normalize(ico_dir(B,(e/G+1.0)/3.0));\n        if(t>0.0&&r.y>height(2,r.xz).z) // Blinkenlights.\n        {\n            ret.xyz=vec3(0.02)*max(dot(e,l),0.0);\n            ret.xyz+=vec3(2,8,2)*exp(-4096.0*dot(n-e,n-e))*pow(abs(sin(iTime+1e4*height(2,37.0*e.xz).z)),128.0);\n            ret.w=min(ret.w,t);\n        }\n    }\n    return ret;\n}\n\nvec4 forcefield(vec3 ro,vec3 rd,float R,float t,float g)\n{\n    if(t>g) return vec4(0);\n    vec3 r=ro+t*rd;\n    vec3 n=normalize(r);\n    mat3 B=ico_basis(n);\n    float G=5.0;\n    vec3 w=G*(3.0*ico_weights(B,n)-1.0);\n    vec3 e=round((floor(w-w.yzx)-floor(w.zxy-w))/3.0);  // https://www.shadertoy.com/view/dtySDy\n    n=mix(n,normalize(ico_dir(B,(e/G+1.0)/3.0)),0.875); // 0=fully spherical, 1=fully flat.\n    float b=max(n.z,0.0)*blast_sum(R*n,vec3(0,1e-3,1),vec2(0,1),blast_attack,blast_release,field_release,iTime,rof);\n    float k=1.7+1e3*b;\n    float p=0.125;\n    vec3 P=vec3(7,4,1);\n    float q=(k-1.0)/(1.0+k);\n    float a=mix(pow(1.0-abs(dot(n,rd)),5.0),1.0,q*q);   // Schlick's approximation.\n    return a*vec4(ray(r,reflect(rd,n)).rgb+0.125*dot(w-e,w-e),1);\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 xy=fragCoord/iResolution.xy;\n    vec3 ro=vec3(5,1,5)*cos(0.37*iTime+vec3(0,11,11))+vec3(0,2,0);\n    vec3 ez=normalize(ro-sin(1e-2*vec3(13,17,19)*iTime)),ex=normalize(cross(vec3(0,1,0),ez)),ey=cross(ez,ex);\n    vec3 rd=normalize((xy.x-0.5)*iResolution.x/iResolution.y*ex+(xy.y-0.5)*ey-1.0*ez+vec3(0,0.5,0));\n    float R=2.5;\n    vec3 col=sky(rd);\n    vec4 C=vec4(0);\n    vec2 sl=vec2(0,FAR),sh=vec2(0,0);\n    float g=FAR;\n    if(ro.z<0.0) sl.x=max(sl.x,-ro.z/rd.z>0.0?-ro.z/rd.z:FAR);\n    else         sl.y=min(sl.y,-ro.z/rd.z>0.0?-ro.z/rd.z:FAR);\n    vec4 f=ray(ro,rd);\n    col=f.rgb;\n    sl.y=min(sl.y,g=f.a);\n    sl.y=max(sl.y,sl.x);\n    float p=dot(ro,rd),d=p*p-dot(ro,ro)+R*R;\n    if(d>0.0) // Forcefield.\n    {\n        vec2 s=-p+sqrt(d)*vec2(-1,+1);\n        vec4 c0=forcefield(ro,rd,R,s.x,g);\n        vec4 c1=forcefield(ro,rd,R,s.y,g);\n        sh=vec2(min(max(sl.x,s.y),sl.y),sl.y);\n        sl=vec2(sl.x,max(min(sl.y,s.x),sl.x));\n        C.xyz=c0.xyz+c1.xyz*(1.0-c0.w);\n        C.w=c0.w+c1.w*(1.0-c0.w);\n    }\n    vec2 a=vec2(0);\n    for(int k=0;k<2;++k)\n        a[k]=blast_sum(ro,rd,(k==0?sl:sh),blast_attack,blast_release,frame_release,iTime,rof);\n    a[1]*=1.0-C.w;\n    col=mix(col,vec3(73,17,2)*a[1],a[1]);\n    col=mix(col,C.xyz,C.w);\n    col=mix(col,vec3(73,17,2)*a[0],a[0]);\n    col=tanh(1.125*col);\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}