{
    "Shader": {
        "info": {
            "date": "1530720675",
            "description": "The numeric  key pad  controls  your gun and the firing of your bullets. Two keys start the gun moving:\n     < and 4    counterclockwise\n     > or 6      clockwise\nUsing the ^ or 8 key stops  the movement of your gun and fires your bullets.",
            "flags": 48,
            "hasliked": 0,
            "id": "XsyfD3",
            "likes": 40,
            "name": "Paratrooper (game)",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "retro",
                "pixel",
                "paratrooper",
                "arcade",
                "dos"
            ],
            "usePreview": 1,
            "username": "reinder",
            "viewed": 2991
        },
        "renderpass": [
            {
                "code": "// Paratrooper. Created by Reinder Nijhoff 2018\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XsyfD3\n//\n// I made this shader because I wanted to try to create a simple \n// but complete game on Shadertoy.\n//\n// Buffer A: Game logic. As usual this code started nice, but in the\n//           end I added a lot of if-statements and it became a mess.\n// Buffer B: Rendering of the screen (320x200).\n// Buffer C: Encoding and decoding of bitmaps used.\n//\n// So here it is: Paratrooper (\"The worst IBM program of 1983\").\n//\n//\n//             *Your Mission*\n//\n// Do not allow enemy  paratroopers to land\n// on either side of your gun base. If four\n// paratroopers  land on one  side of  your\n// base,  they will overpower your defenses\n// and blow  up your  gun.  After  you have\n// survived the first round of helicopters,\n// watch out for the jet bombers. Every jet\n// pilot has a deadly aim!\n// The numeric  key pad  controls  your gun\n// and the firing of your bullets. Two keys\n// start the gun moving:\n//     < and 4    counterclockwise\n//     > or 6     clockwise\n// Using the ^ or 8 key stops  the movement\n// of your gun and fires your bullets.\n//\n//                 *Scoring*\n//     HELICOPTER or JET  .  .  10 points\n//     ENEMY PARATROOPER  .  .   5 points\n//     BOMB.  .  .  .  .  .  .  30 points\n//\n// Each bullet you fire costs you one point\n//\n//    PRESS space bar FOR KEYBOARD PLAY\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 scale = RES / (iResolution.xy - vec2(0,20));\n    float s = max(scale.x, scale.y);\n    vec2 uv = (fragCoord.xy * s - .5 * (iResolution.xy * s - RES));\n    if( inBox(ivec2(uv), ivec2(0), ivec2(RES)) ) {    \n\t    if (iResolution.x < 320.) uv *= .5;\n\t    fragColor = vec4(texture(iChannel0, (uv + .5) / iResolution.xy).rgb, 1.0);\n    } else {\n        fragColor = vec4(0,0,0,1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Paratrooper. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XsyfD3\n//\n// I made this shader because I wanted to try  to create a simple \n// but complete game in Shadertoy.\n//\n\n#define FIXED_TIME_STEP\n#define FORCE_NO_UNROLL +min(0,int(iFrame))\n\n#define RES vec2(320,200)\n#define CANON_CENTER ivec2(160,157)\n\n#define COL_WHITE vec3(1)\n#define COL_BLACK vec3(0)\n#define COL_MAGENTA (vec3(253,93,252)/255.)\n#define COL_CYAN (vec3(95,255,254)/255.)\n\n#define INF 1e10\n\n// game defines\n\n#define GAME_OVER 0.\n#define GAME_HELICOPTER 1.\n#define GAME_JET 2.\n\n#define EXPLOSION_DURATION 1.\n#define GAME_OVER_DURATION 3.\n\n#define ROUND_HELICOPTER_TIME 20.\n#define ROUND_JET_TIME 5.\n#define ROUND_COOL_DOWN_TIME 1.\n\n#define CANON_ROT_SPEED 2.3\n#define CANON_MAX_ANGLE 1.4\n\n#define MAX_BULLETS 8\n#define BULLET_SPEED 125.\n#define SHOT_COOLDOWN .21\n\n\n#define MAX_AIRCRAFTS 6\n#define MIN_AIRCRAFT_DT .75\n#define MAX_AIRCRAFT_DT 5.5\n#define AIRCRAFT_SPEED 70.\n\n#define MAX_PARATROOPERS 5\n#define MIN_PARATROOP_DT 1.25\n#define MAX_PARATROOP_DT 6.\n\n#define PARATROOPER_SPEED_0 92.\n#define PARATROOPER_SPEED_1 47.5\n#define MIN_PARATROOP_OPEN_DT .2\n#define MAX_PARATROOP_OPEN_DT .8\n\n#define BOMB_DT 0.5\n#define BOMBS_DT 2.\n#define BOMB_SPEED 105.\n\n#define DEAD_PARATROOPER_DT 1.\n\n#define BULLET_DATA_OFFSET 10\n#define AIRCRAFT_DATA_OFFSET 20\n#define PARATROOPER_DATA_OFFSET 30\n\n// global game variables\n\nfloat gDT;\nfloat gCanonMovement;\nfloat gCanonAngle;\nfloat gMode;\n\nfloat gScore;\nfloat gHighScore;\nfloat gEndRoundTime;\nfloat gEndRoundTimeCoolDown;\nfloat gGameOverTime;\n\nfloat gLastShot;\nvec3 gBulletData[MAX_BULLETS];\n    \nfloat gLastAircraft;\nvec2 gAircraftData[MAX_AIRCRAFTS];\n\nfloat gLastParatrooper;\nvec4 gParatrooperData[MAX_PARATROOPERS];\n\nvec4 gDeadParatroopers;\nvec4 gParatroopersLeft;\nvec4 gParatroopersRight;\n\nvec4 gExplosion1;\nvec4 gExplosion2;\n\nvoid saveGameState(ivec2 uv, float time, inout vec4 f) {\n    if(uv.x == 0) f = vec4(time, gCanonMovement, gCanonAngle, gMode);\n    if(uv.x == 1) f = vec4(gLastShot, gLastAircraft, gScore, gHighScore);\n    if(uv.x == 2) f = vec4(gLastParatrooper,gEndRoundTime,gEndRoundTimeCoolDown,gGameOverTime);\n    if(uv.x == 3) f = gDeadParatroopers;\n    if(uv.x == 4) f = gParatroopersLeft;\n    if(uv.x == 5) f = gParatroopersRight;\n    if(uv.x == 6) f = gExplosion1;\n    if(uv.x == 7) f = gExplosion2;\n    \n    for (int i=0; i<MAX_BULLETS; i++) {\n        if(uv.x == i+BULLET_DATA_OFFSET) f = vec4(gBulletData[i],0);\n    }\n    for (int i=0; i<MAX_AIRCRAFTS/2; i++) {\n        if(uv.x == i+AIRCRAFT_DATA_OFFSET) f = vec4(gAircraftData[i*2+0], gAircraftData[i*2+1]);\n    }\n    for (int i=0; i<MAX_PARATROOPERS; i++) {\n        if(uv.x == i+PARATROOPER_DATA_OFFSET) f = gParatrooperData[i];\n    }\n}\n\nvoid loadGameStateMinimal(float time, sampler2D storage) {\n    vec4 f;\n\n    f = texelFetch(storage, ivec2(0,0), 0);\n#ifdef FIXED_TIME_STEP\n    gDT = (1./60.);\n#else\n    gDT = time - f.x;\n#endif\n    gCanonMovement = f.y;\n    gCanonAngle = f.z;\n    gMode = f.w;\n    \n    f = texelFetch(storage, ivec2(1,0), 0);\n    gLastShot = f.x;\n    gLastAircraft = f.y;\n    gScore = f.z;\n    gHighScore = f.w;\n    \n    f = texelFetch(storage, ivec2(2,0), 0);\n    gLastParatrooper = f.x;\n    gEndRoundTime = f.y;\n    gEndRoundTimeCoolDown = f.z;\n    gGameOverTime = f.w;\n    \n    gDeadParatroopers = texelFetch(storage, ivec2(3,0), 0);\n    gParatroopersLeft = texelFetch(storage, ivec2(4,0), 0);\n    gParatroopersRight = texelFetch(storage, ivec2(5,0), 0);\n    \n    gExplosion1 = texelFetch(storage, ivec2(6,0), 0);\n    gExplosion2 = texelFetch(storage, ivec2(7,0), 0);\n}\n\nvoid loadGameStateFull(float time, sampler2D storage) {\n    loadGameStateMinimal(time, storage);\n        \n    for (int i=0; i<MAX_BULLETS; i++) {\n    \tgBulletData[i] = texelFetch(storage, ivec2(i+BULLET_DATA_OFFSET,0), 0).xyz;\n    }\n    \n    for (int i=0; i<MAX_AIRCRAFTS/2; i++) {\n        vec4 f = texelFetch(storage, ivec2(i+AIRCRAFT_DATA_OFFSET,0), 0);\n        gAircraftData[i*2+0] = f.xy;\n        gAircraftData[i*2+1] = f.zw;\n    } \n    \n    for (int i=0; i<MAX_PARATROOPERS; i++) {\n    \tgParatrooperData[i] = texelFetch(storage, ivec2(i+PARATROOPER_DATA_OFFSET,0), 0);\n    }\n}\n\n//\n// Hash functions\n//\n// Hash without Sine by Dave_Hoskins\n//\n// https://www.shadertoy.com/view/4djSRW\n//\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// game functions\nivec2 getAircraftPos(vec2 data, float time) {\n    float t = (time-abs(data.x));\n    if (t > 0.) {\n        int p = int(t * AIRCRAFT_SPEED) - 10;\n        bool ltr = data.x > 0.;\n    \treturn ivec2(ltr ? p : int(RES.x) - p, ltr ? 18 : 6);\n    } else {\n        return ivec2(-1);\n    }\n}\n\n// draw functions\n\nbool inBox(const ivec2 uv, const ivec2 lt, const ivec2 rb) {\n    return (uv.y >= lt.y && uv.y < rb.y && uv.x >= lt.x && uv.x < rb.x);\n}\n\nvoid drawBox(const ivec2 uv, const ivec2 lt, const ivec2 rb, const vec3 color, inout vec3 f) {\n\tif (inBox(uv, lt, rb)) f = color;    \n}\n\nvoid drawSprite(const ivec2 uv, const ivec2 lt, const ivec2 rb, const ivec2 offset, const in sampler2D d, const bool flip, inout vec3 f) {\n    if (inBox(uv, lt, rb)) {\n        ivec2 c = uv - lt;\n    \tc.x = flip ? (rb.x-lt.x)-c.x-1 : c.x;\n    \n        vec3 col = texelFetch(d, offset + c, 0).rgb;    \n        f = col.r > 0. ? col : f;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Paratrooper. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XsyfD3\n//\n// I made this shader because I wanted to try  to create a simple \n// but complete game in Shadertoy.\n//\n// Buffer A: Game logic. As usual this code started nice, but in the\n//           end I added a lot of if-statements and it became a mess.\n//\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\nconst int KEY_S     = 83;\nconst int KEY_W     = 87;\n\nbool KP(int key) {\n\treturn texelFetch( iChannel0, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KT(int key) {\n\treturn texelFetch( iChannel0, ivec2(key, 2), 0 ).x > 0.0;\n}\n\nfloat sBox( in vec2 ro, in vec2 rd, in vec2 rad ) {\n    if(rd.x == 0.) rd.x = 0.001;\n    vec2 m = 1./rd;\n    vec2 n = m*ro;\n    vec2 k = abs(m)*rad;\n\t\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n\n\tfloat tN = max( t1.x, t1.y );\n\tfloat tF = min( t2.x, t2.y );\n    if( tN > tF || tF < 0.0) {\n        return -1.0;\n    } else {\n\t\treturn tN;\n    }\n}\n\nbool shoot(float time) {\n    if (gLastShot + SHOT_COOLDOWN < time) {\n        gLastShot = time;\n        return true;\n    }\n    return false;\n}\n\nvoid paratrooperLand(float x, inout vec4 data) {\n    if(data.x <= 0.) data.x = x;\n    else if(data.y <= 0.) data.y = x;\n    else if(data.z <= 0.) data.z = x;\n    else if(data.w <= 0.) data.w = x;\n}\n\nvoid killParatrooperAtPos(float x, inout vec4 data) {\n    if(data.x == x) data.x = 0.;\n    if(data.y == x) data.y = 0.;\n    if(data.z == x) data.z = 0.;\n    if(data.w == x) data.w = 0.;\n}\n\nvoid deadParatrooper(float x, float time) {\n    float visibleUntil = time + DEAD_PARATROOPER_DT;\n    if (gDeadParatroopers.y < visibleUntil) {\n        gDeadParatroopers.x = x;\n        gDeadParatroopers.y = visibleUntil;\n    } else {\n        gDeadParatroopers.z = x;\n        gDeadParatroopers.w = visibleUntil;\n    }\n    if (x < 160.) {\n        killParatrooperAtPos(x, gParatroopersLeft);\n    } else {\n        killParatrooperAtPos(x, gParatroopersRight);\n    }\n}\n\nvoid initExplosion(vec2 pos, float time, float type) {\n    if (gExplosion1.z < time - EXPLOSION_DURATION) {\n        gExplosion1 = vec4(pos, time, type);\n    } else {\n        gExplosion2 = vec4(pos, time, type);\n    }\n}\n\nvoid initNewBullet(int index) {\n    float a = gCanonAngle;\n    gBulletData[index].z = a;\n    gBulletData[index].xy = vec2(CANON_CENTER) + vec2(sin(a),-cos(a)) * 20.;\n}\n\nvoid initAircraft(int index, float time, bool direct) {\n    float h = direct ? 0. : hash11(float(index)+time);\n    gLastAircraft += mix(MIN_AIRCRAFT_DT, MAX_AIRCRAFT_DT, h*h*h*h);\n    if (gLastAircraft < gEndRoundTime) {\n        float d = hash11(float(index)+time+.5)-.4 > 0. ? 1. : -1.;\n        float ph = hash11(float(index)+time+.75);\n        float p = gMode > GAME_HELICOPTER + .5 ?  \n           (ph > .25 ? gLastAircraft + BOMB_DT : INF) : MAX_PARATROOP_DT * ph + gLastAircraft;\n        gAircraftData[index] = vec2(gLastAircraft * d, p);\n    } else {\n        gAircraftData[index] = vec2(-20);\n    }\n}\n\nvoid initAircrafts(float time) {\n    gLastAircraft = time;\n    for (int i=0; i<MAX_AIRCRAFTS; i++) {\n        initAircraft(i, time, i == 0);\n    }\n}\n\nbool fourParatroopersLanded(vec4 d) {\n    return d.x > 0. && d.y > 0. && d.z > 0. && d.w > 0.;\n}\n\nvoid initNewRound(float mode, float time) {\n    gMode = mode;\n    gEndRoundTime = time + \n        ((gMode < GAME_HELICOPTER + .5) ? ROUND_HELICOPTER_TIME : ROUND_JET_TIME);\n    \n    initAircrafts(time);\n}\n\nvoid initNewGame(float time) {\n    gParatroopersLeft = vec4(0);\n    gParatroopersRight = vec4(0);\n    gScore = 0.;\n    gLastShot = time;\n    gGameOverTime = 0.;\n    \n    for (int i=0; i<MAX_BULLETS; i++) {\n    \tgBulletData[i].z = -20.;\n    }\n    for (int i=0; i<MAX_PARATROOPERS; i++) {\n    \tgParatrooperData[i].x = -20.;\n    }\n    \n    initNewRound(GAME_HELICOPTER, time);\n}\n\nvoid recycleBullet(inout vec3 bullet, float score) {\n    bullet.z = -20.;\n    gScore += score;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 uv = ivec2(fragCoord);\n    \n    // gameloop\n    if( uv.y == 0 && uv.x < 100) {\n        loadGameStateFull(iTime, iChannel1);\n\t\tbool gameOver = false;\n     \t\n        if (gMode < GAME_OVER + .5) {      \n            if( KP(KEY_SPACE) ) {\n                initNewGame(iTime);       \n            }\n        } else {\n            // user input\n            bool wantShot = false;\n            if (gGameOverTime < .5) {\n                if( KP(KEY_LEFT) || KP(KEY_A) ) {\n                    gCanonMovement = -1.;\n                }\n                if( KP(KEY_RIGHT) || KP(KEY_D) ) {\n                    gCanonMovement = 1.;\n                }\n                if( KP(KEY_UP) || KP(KEY_W) || KP(KEY_SPACE) ) {\n                    gCanonMovement = 0.;\n                    wantShot = shoot(iTime);\n                    if (wantShot) {\n                        gScore = max(0., gScore - 1.);\n                    }\n                }\n                gCanonAngle += gCanonMovement * gDT * CANON_ROT_SPEED;\n                gCanonAngle = sign(gCanonAngle) * min(abs(gCanonAngle), CANON_MAX_ANGLE);\n            }\n            \n            // save old y-coordinate for collision detection with bullets\n            for (int i=0; i<MAX_PARATROOPERS; i++) {\n            \tgParatrooperData[i].w = gParatrooperData[i].y;\n            }\n            \n            if (gMode < GAME_HELICOPTER + .5) {\n                // helicopter mode\n                \n                // aircrafts\n                float wantParatrooper = -20.;\n                for (int i=0; i<MAX_AIRCRAFTS FORCE_NO_UNROLL; i++) {\n                    ivec2 p = getAircraftPos(gAircraftData[i], iTime);\n                    if (p.x < -20 || p.x > int(RES.x) + 20) {\n                        initAircraft(i, iTime, false);\n                    }\n                    if (gAircraftData[i].y < iTime && iTime > gLastParatrooper + MIN_PARATROOP_DT) {\n                        // drop paratrooper\n                        wantParatrooper = floor(float(p.x)/6.)*6.;\n                        gAircraftData[i].y = iTime + MAX_PARATROOP_DT * hash11(float(i)+iTime+.75);\n                    }\n                }\n\n                // paratroopers\n                float paratrooperFrameDist_0 = (gDT * PARATROOPER_SPEED_0);\n                float paratrooperFrameDist_1 = (gDT * PARATROOPER_SPEED_1);\n\n                for (int i=0; i<MAX_PARATROOPERS FORCE_NO_UNROLL; i++) {\n                    vec4 p = gParatrooperData[i];\n                    if (p.x > 0.) {\n                        gParatrooperData[i].y += p.z > 0. && p.z < iTime \n                            ? paratrooperFrameDist_1 : paratrooperFrameDist_0;\n                        if (p.y > 190.) {\n                            float x = p.x;\n                            if (p.z < 0.) {\n                                deadParatrooper(x, iTime);\n                            } else {\n                                if (x<160.) {\n                                    paratrooperLand(x, gParatroopersLeft );\n                                } else {\n                                    paratrooperLand(x, gParatroopersRight );\n                                }\n                            }\n                            gParatrooperData[i].x = -20.;\n                        }\n                    } else if(wantParatrooper > 0.) {\n                        float x = abs(wantParatrooper-RES.x*.5);\n                        if (x > 30. && x < RES.x*.5 - 5.) {\n                            gParatrooperData[i].xyw = vec3(wantParatrooper, 30.,30.);\n                            gParatrooperData[i].z = iTime +mix(MIN_PARATROOP_OPEN_DT, MAX_PARATROOP_OPEN_DT, hash11(float(i)+iTime+.25));;\n                        }\n                        wantParatrooper = -20.;\n                        gLastParatrooper = iTime;\n                    }\n                }\n            } else {\n                // jet mode\n                \n                // aircrafts\n                float wantBomb = -20.;\n                for (int i=0; i<MAX_AIRCRAFTS FORCE_NO_UNROLL; i++) {\n                    ivec2 p = getAircraftPos(gAircraftData[i], iTime);\n                    if (gAircraftData[i].y < iTime) {\n                        // drop bomb\n                        if(iTime > gLastParatrooper + BOMBS_DT) {\n                        \twantBomb = float(p.x);\n                        }\n                        gAircraftData[i].y = INF;\n                    }\n                }\n                \n                // use paratrooperdata for bombs\n                for (int i=0; i<MAX_PARATROOPERS FORCE_NO_UNROLL; i++) {\n                    vec4 p = gParatrooperData[i];\n                    if (p.x > 0.) {\n                        gParatrooperData[i].xy -= normalize(p.xy - vec2(160,175)) * (gDT * BOMB_SPEED);\n                        if (p.y > 170.) {\n                            gParatrooperData[i].x = -20.;\n                            gameOver = true;\n                        }\n                    } else if(wantBomb > 0.) {\n                        gParatrooperData[i].xyw = vec3(wantBomb, 20., 20.);\n                        wantBomb = -20.;\n                        gLastParatrooper = iTime;\n                    }\n                }\n            }\n\n            // bullets\n            float bulletFrameDist = (gDT * BULLET_SPEED);\n\n            for (int i=0; i<MAX_BULLETS FORCE_NO_UNROLL; i++) {\n                if (gBulletData[i].z > -10.) {\n                    float a = gBulletData[i].z;\n                    vec2 ro = gBulletData[i].xy;\n\n                    vec2 newPos = ro + vec2(sin(a),-cos(a)) * bulletFrameDist;\n                    if (newPos.x < 0. || newPos.x > RES.x || newPos.y < 0.) {\n                        gBulletData[i].z = -20.;\n                    }\n                    vec2 rd = normalize(newPos - ro);\n\n          \t\t\tif (gGameOverTime < .5) {\n                        if (gBulletData[i].z > -10.) {\n                            for (int j=0; j<MAX_AIRCRAFTS FORCE_NO_UNROLL; j++) {\n                                ivec2 p = getAircraftPos(gAircraftData[j], iTime);\n                                float d = sBox(ro - vec2(p), rd, vec2(12,5));\n                                if (d > 0. && d < bulletFrameDist) {\n                                    initAircraft(j, iTime, false);\n                                    initExplosion(vec2(p), iTime, 4.);\n                                    recycleBullet(gBulletData[i], 10.);\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (gBulletData[i].z > -10.) {            \n                            if (gMode < GAME_HELICOPTER + .5) {\n                                for (int j=0; j<MAX_PARATROOPERS FORCE_NO_UNROLL; j++) {\n                                    vec2 p = gParatrooperData[j].xy;\n                                    float dy = (gParatrooperData[j].y - gParatrooperData[j].w)*.5;\n                                    float d = sBox(ro - p + vec2(0,4.-dy), rd, vec2(2,4.+dy));\n                                    if (d > 0. && d < bulletFrameDist) {\n                                        gParatrooperData[j].x = -20.;\n                                        initExplosion(p, iTime, 1.);\n                                        recycleBullet(gBulletData[i], 5.);\n                                        break;\n                                    } else if(gParatrooperData[j].z > 0. && iTime > gParatrooperData[j].z) {\n                                        float d = sBox(ro - p + vec2(0,15.-dy), rd, vec2(6,7.+dy));\n                                        if (d > 0. && d < bulletFrameDist) {\n                                            gParatrooperData[j].z = -20.;\n                                            initExplosion(p, iTime, 1.);\n                                            recycleBullet(gBulletData[i], 5.);\n                                            break;\n                                        }\n                                    }\n                                }\n                            } else {\n                                // bombs\n                                for (int j=0; j<MAX_PARATROOPERS FORCE_NO_UNROLL; j++) {\n                                    vec2 p = gParatrooperData[j].xy;\n                                    float dy = (gParatrooperData[j].y - gParatrooperData[j].w)*.5;\n                                    float d = sBox(ro - p + vec2(0,-dy), rd, vec2(4,2.+dy));\n                                    if (d > 0. && d < bulletFrameDist) {\n                                        gParatrooperData[j].x = -20.;\n                                        initExplosion(p, iTime, 2.);\n                                        recycleBullet(gBulletData[i], 30.);\n                                        break;\n                                    }\n                                }\n                            }\n                        }       \n                    }\n\n                    gBulletData[i].xy = newPos;\n                } else if(wantShot) {\n                    initNewBullet(i);\n                    wantShot = false;\n                }\n               \n                for (int i=0; i<MAX_PARATROOPERS FORCE_NO_UNROLL; i++) {\n                    if (gParatrooperData[i].x > 0.) {\n                        gEndRoundTimeCoolDown = iTime + ROUND_COOL_DOWN_TIME; \n                    }\n                }\n                float endTime = max(gEndRoundTimeCoolDown, gEndRoundTime + (RES.x/AIRCRAFT_SPEED) + ROUND_COOL_DOWN_TIME);\n\n                if (iTime > endTime) {\n                    if (gMode < GAME_HELICOPTER + .5) {\n\t\t\t\t\t\tinitNewRound(GAME_JET, iTime);\n               \t\t} else {\n                    \tinitNewRound(GAME_HELICOPTER, iTime);\n                    }\n                }\n            }\n        }\n        \n        if (gameOver || \n            fourParatroopersLanded(gParatroopersLeft) || \n            fourParatroopersLanded(gParatroopersRight)) {\n            \n            if (gGameOverTime < .5) {\n                gGameOverTime = iTime + GAME_OVER_DURATION;\n                gHighScore = max(gHighScore, gScore);\n                initExplosion(vec2(CANON_CENTER), iTime, 3.);\n            }\n        }\n\n        if (gGameOverTime > .5 && iTime > gGameOverTime) {\n            initNewGame(iTime);\n            gMode = GAME_OVER;\n        }\n        \n        // save state\n        saveGameState(uv, iTime, fragColor);\n    }\n    \n    if (iFrame == 0) {\n        fragColor = vec4(0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Paratrooper. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XsyfD3\n//\n// I made this shader because I wanted to try  to create a simple \n// but complete game in Shadertoy.\n//\n// Buffer B: Rendering of the screen (320x200).\n//\n\nmat2 rotMatrix(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid drawHLine(ivec2 uv, const int y, const int height, vec3 color, inout vec3 f) {\n\tif (uv.y >= y && uv.y < y + height) f = color;\n}\n\nvoid drawTitle(ivec2 uv, const in sampler2D d, inout vec3 f) {\n    if (inBox(uv, ivec2(51,40), ivec2(51+218,64))) {\n\t    int i = (uv.x-51)/20;\n        if (i * 16 < iFrame) {\n            int o = int[](0,1,2,1,3,2,4,4,0,5,2)[i] * 20;                    \n            drawSprite(uv, ivec2(51+i*20,40), ivec2(51+i*20+20,64), ivec2(o,0), iChannel1, false, f);\n        }\n    }\n}\n\nvec3 spriteCanon(ivec2 uv) {\n    vec3 col = COL_BLACK;\n    \n    ivec2 uvRot = ivec2(rotMatrix(gCanonAngle) * vec2(uv));\n    \n    drawBox(uvRot, ivec2(-1,-12), ivec2(1,0), COL_CYAN, col);\n    drawBox(uvRot, ivec2(-2,-11), ivec2(2,0), COL_CYAN, col);\n    \n    drawBox(uv, ivec2(-2,-4), ivec2(2,-3), COL_MAGENTA, col);\n    drawBox(uv, ivec2(-4,-3), ivec2(4,-1), COL_MAGENTA, col);\n    drawBox(uv, ivec2(-5,-1), ivec2(5,9), COL_MAGENTA, col);\n    drawBox(uv, ivec2(-1,-1), ivec2(1,1), COL_CYAN, col);\n    return col;\n}\n\nvoid drawCanon(ivec2 uv, inout vec3 f) {\n    vec3 col = spriteCanon(uv - CANON_CENTER);\n    if (col.x > 0.) f = col;\n}\n\nvoid drawHelicopter(ivec2 uv, ivec2 heliPos, int si, const in sampler2D d, inout vec3 f) {\n    if (heliPos.y > 0) {\n        drawSprite(uv, heliPos - ivec2(12,5), heliPos + ivec2(12,5), ivec2(24 * si, 24), d, heliPos.y < 8, f);\n    }\n}\n\nvoid drawJet(ivec2 uv, ivec2 jetPos, int si, const in sampler2D d, inout vec3 f) {\n    if (jetPos.y > 0) {\n        drawSprite(uv, jetPos - ivec2(12,5), jetPos + ivec2(12,5), ivec2(24 * si, 63), d, jetPos.y < 8, f);\n    }\n}\n\nvoid drawBomb(ivec2 uv, vec3 paratrooperData, float time, const in sampler2D d, inout vec3 f) {\n    if (paratrooperData.x > 0. ) {\n        ivec2 pos = ivec2(paratrooperData.xy);\n    \tdrawBox(uv - pos, ivec2(-1,-2), ivec2(1,2), COL_WHITE, f);\n    \tdrawBox(uv - pos, ivec2(-2,-1), ivec2(2,1), COL_WHITE, f);\n    }\n}\n\nvoid drawParatrooper(ivec2 uv, vec3 paratrooperData, float time, const in sampler2D d, inout vec3 f) {\n    if (paratrooperData.x > 0. ) {\n        ivec2 pos = ivec2(paratrooperData.xy);\n        drawSprite(uv, pos - ivec2(2,8), pos + ivec2(2,0), ivec2(12,39), d, false, f);\n        if (paratrooperData.z > 0. && paratrooperData.z < time) {\n        \tdrawSprite(uv, pos - ivec2(6,22), pos + ivec2(6,-8), ivec2(0,34), d, false, f);            \n        }\n    }\n}\n\nvoid drawExplosion(ivec2 uv, vec4 d, float time, const sampler2D tex, inout vec3 f) {\n    if (time < d.z + EXPLOSION_DURATION && uv.y < 190) {\n    \tfloat t = (d.z - time) * (1. / EXPLOSION_DURATION);\n        vec2 p = vec2(uv)-d.xy;\n        float h = hash12(p*.3);\n        if (h*h*h > t) {\n            vec2 r = normalize(2. * hash22(p) - 1.) * hash12(p);\n            vec2 delta = r * vec2(-t, 1.-t) + vec2(0., t*6.);\n\n            float speed = .5 * (d.x-160.);\n            if (d.w > 3.5) {\n                speed = d.y > 8. ? AIRCRAFT_SPEED : -AIRCRAFT_SPEED;\n                speed *= (1. / EXPLOSION_DURATION);\n            } else if (d.w > 2.5) {\n                speed = 0.;\n                delta *= 10.;\n                p.y -= t * 500.;\n            }\n            p.x += speed * t;\n            p -= 20.*delta*t;\n            \n            uv = ivec2(d.xy + p);\n\n            if (d.w < 1.5) {\n                drawSprite(uv, ivec2(d.xy) - ivec2(6,22), ivec2(d.xy) + ivec2(6,-8), ivec2(0,34), tex, false, f); \n            } else if (d.w < 2.5) {\n                drawBomb(uv, vec3(d.xyz), time, tex, f);\n            } else if (d.w < 3.5) {\n            \tdrawCanon(uv, f);\n            } else if (d.w < 4.5) { \n                if (gMode > GAME_HELICOPTER + .5) {\n                    drawJet(uv, ivec2(d.xy), 0, tex, f);\n                } else {\n                    drawHelicopter(uv, ivec2(d.xy), 0, tex, f);\n                }\n            }\n        }\n    }\n}\n\nvoid drawScore( ivec2 uv, ivec2 rt, float score, inout vec3 col ) {\n    for (int i=0; i<6; i++) {\n        if (score > 0. || i == 0) {\n            float s = mod(score, 10.);\n            drawSprite(uv, rt, rt+ivec2(8,7), ivec2(72,73) + ivec2(s*8.,0), iChannel1, false, col);\n            rt.x -= 8;\n            score = floor(score * .1);\n        }\n    }\n}\n\nvoid drawDeadParatrooper( ivec2 uv, vec2 d, float time, inout vec3 col ) {\n    if (d.y > time) {\n        drawSprite(uv, ivec2(d.x-6.,170), ivec2(d.x+6.,185), ivec2(0,48), iChannel1, false, col);\n    }\n}\n\nvoid drawLandedParatrooper( ivec2 uv, float x, float y, inout vec3 col ) {\n    if (x > 0.) {\n        drawSprite(uv, ivec2(x-2.,182.-y), ivec2(x+2.,190.-y), ivec2(12,39), iChannel1, false, col);\n    }\n}\n\nvoid drawLandedParatroopers( ivec2 uv, vec4 d, inout vec3 col ) {\n\tdrawLandedParatrooper(uv, d.x, 0., col);\n\tdrawLandedParatrooper(uv, d.y, d.y==d.x?8.:0., col);\n\tdrawLandedParatrooper(uv, d.z, (d.z==d.x?8.:0.) + (d.z==d.y?8.:0.), col);\n\tdrawLandedParatrooper(uv, d.w, (d.w==d.x?8.:0.) + (d.w==d.y?8.:0.) + (d.w==d.z?8.:0.), col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 uv = ivec2(fragCoord);\n    \n    if (iResolution.x < 320.) uv *= 2;\n    \n    if (fragCoord.x < RES.x && fragCoord.y < RES.y ) {\n\t\tuv.y = int(RES.y) - uv.y;\n        \n        loadGameStateMinimal(iTime, iChannel0);\n\n        vec3 col = COL_BLACK;\n\n        // canon\n        if (gGameOverTime < .5) {\n\t        drawCanon(uv, col);\n        }\n        \n        if (gMode > GAME_OVER + .5) {\n            // bullets\n            for (int i=0; i<MAX_BULLETS FORCE_NO_UNROLL; i++) {\n                vec3 b = texelFetch(iChannel0, ivec2(i+BULLET_DATA_OFFSET,0), 0).xyz;\n                if (b.z > -10.) {\n                    if(uv.x == int(b.x) && uv.y == int(b.y)) {\n                        col = COL_WHITE;\n                    }\n                }\n            }\n\n            // aircrafts\n            for (int i=0; i<MAX_AIRCRAFTS/2 FORCE_NO_UNROLL; i++) {\n                vec4 b = texelFetch(iChannel0, ivec2(i+AIRCRAFT_DATA_OFFSET,0), 0);\n                ivec2 p1 = getAircraftPos(b.xy, iTime);\n                ivec2 p2 = getAircraftPos(b.zw, iTime);\n                if (gMode > GAME_HELICOPTER + .5) {\n\t                drawJet(uv, p1, (i + int(iTime * 8.)) & 1, iChannel1, col);\n    \t            drawJet(uv, p2, (i + int(iTime * 8.)) & 1, iChannel1, col);\n                } else {\n\t                drawHelicopter(uv, p1, (i + int(iTime * 16.)) & 3, iChannel1, col);\n    \t            drawHelicopter(uv, p2, (i + int(iTime * 16.)) & 3, iChannel1, col);\n                }\n            }\n\n            // paratroopers\n            for (int i=0; i<MAX_PARATROOPERS FORCE_NO_UNROLL; i++) {\n                vec3 b = texelFetch(iChannel0, ivec2(i+PARATROOPER_DATA_OFFSET,0), 0).xyz;\n                if (gMode < GAME_HELICOPTER + .5) {\n                \tdrawParatrooper(uv, b, iTime, iChannel1, col);\n                } else {\n\t                drawBomb(uv, b, iTime, iChannel1, col);\n                }\n            }\n            \n            // landed paratroopers\n            drawLandedParatroopers(uv, gParatroopersLeft, col);\n            drawLandedParatroopers(uv, gParatroopersRight, col);\n            \n            // deadParatroopers\n            drawDeadParatrooper(uv, gDeadParatroopers.xy, iTime, col);\n            drawDeadParatrooper(uv, gDeadParatroopers.zw, iTime, col);\n        } else {\n            drawTitle(uv, iChannel1, col);\n            if (iResolution.x > 320.) {\n            \tdrawSprite(uv, ivec2(28,80), ivec2(291,87), ivec2(0,80), iChannel1, false, col);\n            }\n        }\n        \n        drawExplosion(uv, gExplosion1, iTime, iChannel1, col);\n        drawExplosion(uv, gExplosion2, iTime, iChannel1, col);\n        \n        drawHLine(uv, 190, 1, COL_CYAN, col);\n        drawBox(uv, ivec2(145,166), ivec2(176,190), COL_WHITE, col);\n\n        // score\n        if (uv.y > 190) {\n            drawSprite(uv, ivec2(0,192), ivec2(46,199), ivec2(24,73), iChannel1, false, col); \n            drawScore(uv, ivec2(100,192), gScore, col);\n            drawSprite(uv, ivec2(200,192), ivec2(269,199), ivec2(0,73), iChannel1, false, col); \n            drawScore(uv, ivec2(308,192), gHighScore, col);\n        }\n            \n        fragColor = vec4(col, 1.0);\n    } else {\n        fragColor = vec4(0,0,0,1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Paratrooper. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XsyfD3\n//\n// I made this shader because I wanted to try  to create a simple \n// but complete game in Shadertoy.\n//\n// Buffer C: Encoding and decoding of bitmaps used.\n//\n//\n// Knarkowicz created a lot of nice shaders that uses encoded bitmaps. \n// See for example: \n//\n// https://www.shadertoy.com/view/Xs2fWD [SH17B] Pixel Shader Dungeon\t\n// https://www.shadertoy.com/view/XtlSD7 [SIG15] Mario World 1-1\n// https://www.shadertoy.com/view/ll2BWz Sprite Rendering \n//\n\n//unpack sprites\nvec3 unpackCol(uint x, uint d) {\n\tuint v = (d >> ((x & 0xfU) << 1)) & 0x3U;\n    \n    return v == 0x0U ? vec3(0) : \n    \t   v == 0x2U ? COL_CYAN : \n    \t   v == 0x3U ? COL_MAGENTA : COL_WHITE;\n}\n\nvec3 unpackBW(uint x, uint d) {\n    return vec3((d >> (x & 0x1fU)) & 0x1U);\n}\n\nbool resolutionChanged() {\n    return floor(texelFetch(iChannel0, ivec2(iResolution.xy-1.), 0).r) != floor(iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 col = vec3(iResolution.xy,0);\n    \n    if (resolutionChanged()) {\n        ivec2 c = ivec2(fragCoord);   \t    \n        uint d = 0x0U;\n        const int ycol = 73;\n\n        if(c.y < ycol) {\n            d = (c.y==0) ? c.x < 16 ? 0x1555555U : c.x < 32 ? 0x5540000U : c.x < 48 ? 0x55550000U : c.x < 64 ? 0x55000155U : c.x < 80 ? 0x155555U : c.x < 96 ? 0x55400U : c.x < 112 ? 0x55555500U : c.x < 128 ? 0x15U : d : d;\n\t\t\td = (c.y==1) ? c.x < 16 ? 0x6aaaaa5U : c.x < 32 ? 0x1a990000U : c.x < 48 ? 0xaaa50000U : c.x < 64 ? 0xa50006aaU : c.x < 80 ? 0x6aaaaaU : c.x < 96 ? 0x1a9900U : c.x < 112 ? 0xaaaaa500U : c.x < 128 ? 0x6aU : d : d;\n            d = (c.y==2) ? c.x < 16 ? 0x1aaaaa99U : c.x < 32 ? 0x6a6a4000U : c.x < 48 ? 0xaa990000U : c.x < 64 ? 0x99001aaaU : c.x < 80 ? 0x1aaaaaaU : c.x < 96 ? 0x6a6a40U : c.x < 112 ? 0xaaaa9900U : c.x < 128 ? 0x1aaU : d : d;\n            d = (c.y==3) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffaa9000U : c.x < 48 ? 0xffe90003U : c.x < 64 ? 0xe400ffffU : c.x < 80 ? 0xfffffffU : c.x < 96 ? 0x3ffaa90U : c.x < 112 ? 0xffffe900U : c.x < 128 ? 0xfffU : d : d;\n            d = (c.y==4) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffeaa403U : c.x < 48 ? 0xffe9000fU : c.x < 64 ? 0xd003ffffU : c.x < 80 ? 0xfffffffU : c.x < 96 ? 0xfffeaa4U : c.x < 112 ? 0xffffe900U : c.x < 128 ? 0xfffU : d : d;\n            d = (c.y==5) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xfffaa90fU : c.x < 48 ? 0xffe9003fU : c.x < 64 ? 0xc00fffffU : c.x < 80 ? 0xfffffffU : c.x < 96 ? 0x3ffffaa9U : c.x < 112 ? 0xffffe900U : c.x < 128 ? 0xfffU : d : d;\n            d = (c.y==6) ? c.x < 16 ? 0xe9000fe9U : c.x < 32 ? 0x3fea50fU : c.x < 48 ? 0xfe900ffU : c.x < 64 ? 0xfe900U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xff03fea5U : c.x < 112 ? 0xfe900U : c.x < 128 ? 0x0U : d : d;\n            d = (c.y==7) ? c.x < 16 ? 0xe9000fe9U : c.x < 32 ? 0xff990fU : c.x < 48 ? 0xfe903fdU : c.x < 64 ? 0xfe900U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xfd00ff99U : c.x < 112 ? 0xfe903U : c.x < 128 ? 0x0U : d : d;\n            d = (c.y==8) ? c.x < 16 ? 0xe9000fe9U : c.x < 32 ? 0x3fe90fU : c.x < 48 ? 0xfe90ff9U : c.x < 64 ? 0xfe900U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xf9003fe9U : c.x < 112 ? 0xfe90fU : c.x < 128 ? 0x0U : d : d;\n            d = (c.y==9) ? c.x < 16 ? 0xe9555fe9U : c.x < 32 ? 0x555fe90fU : c.x < 48 ? 0x5fe90fe9U : c.x < 64 ? 0xfe955U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0x555fe90fU : c.x < 128 ? 0x0U : d : d;\n            d = (c.y==10) ? c.x < 16 ? 0xe6aaafe9U : c.x < 32 ? 0xaaafe90fU : c.x < 48 ? 0xafe90fe6U : c.x < 64 ? 0xfe6aaU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xaaafe90fU : c.x < 128 ? 0x1U : d : d;\n            d = (c.y==11) ? c.x < 16 ? 0xdaaaafe9U : c.x < 32 ? 0xaaafe90fU : c.x < 48 ? 0xafe90fdaU : c.x < 64 ? 0xfdaaaU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xaaafe90fU : c.x < 128 ? 0x6U : d : d;\n            d = (c.y==12) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffffe90fU : c.x < 48 ? 0xffe90fffU : c.x < 64 ? 0xfffffU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xffffe90fU : c.x < 128 ? 0x3fU : d : d;\n            d = (c.y==13) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffffe903U : c.x < 48 ? 0xffe90fffU : c.x < 64 ? 0x3ffffU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xffffe90fU : c.x < 128 ? 0x3fU : d : d;\n            d = (c.y==14) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffffe900U : c.x < 48 ? 0xffe90fffU : c.x < 64 ? 0xffffU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xffffe90fU : c.x < 128 ? 0x3fU : d : d;\n            d = (c.y==15) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0x3fcU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xfe90fU : c.x < 128 ? 0x0U : d : d;\n            d = (c.y==16) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0xff0U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe6400fe4U : c.x < 112 ? 0xfe90fU : c.x < 128 ? 0x0U : d : d;\n            d = (c.y==17) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0x3fc0U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xda900fd0U : c.x < 112 ? 0xfe90fU : c.x < 128 ? 0x0U : d : d;\n            d = (c.y==18) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0xff00U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xfaa57fc0U : c.x < 112 ? 0x555fe90fU : c.x < 128 ? 0x15U : d : d;\n            d = (c.y==19) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0x3fd00U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xfe9aff00U : c.x < 112 ? 0xaaafe903U : c.x < 128 ? 0x6aU : d : d;\n            d = (c.y==20) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0xff900U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xff6bfc00U : c.x < 112 ? 0xaaafe900U : c.x < 128 ? 0x1aaU : d : d;\n            d = (c.y==21) ? c.x < 16 ? 0xfe4U : c.x < 32 ? 0xfe400U : c.x < 48 ? 0xfe40fe4U : c.x < 64 ? 0xfe400U : c.x < 80 ? 0xfe40U : c.x < 96 ? 0x3ffff000U : c.x < 112 ? 0xffffe400U : c.x < 128 ? 0xfffU : d : d;\n            d = (c.y==22) ? c.x < 16 ? 0xfd0U : c.x < 32 ? 0xfd000U : c.x < 48 ? 0xfd00fd0U : c.x < 64 ? 0xfd000U : c.x < 80 ? 0xfd00U : c.x < 96 ? 0xfffc000U : c.x < 112 ? 0xffffd000U : c.x < 128 ? 0xfffU : d : d;\n            d = (c.y==23) ? c.x < 16 ? 0xfc0U : c.x < 32 ? 0xfc000U : c.x < 48 ? 0xfc00fc0U : c.x < 64 ? 0xfc000U : c.x < 80 ? 0xfc00U : c.x < 96 ? 0x3ff0000U : c.x < 112 ? 0xffffc000U : c.x < 128 ? 0xfffU : d : d;\n            c.y -= 24;\t\n\n            d = (c.y==0) ? c.x < 16 ? 0xfff00000U : c.x < 32 ? 0xfffU : c.x < 48 ? 0xffffffffU : c.x < 64 ? 0xfff00000U : c.x < 80 ? 0xfffU : c.x < 96 ? 0x3c000U : d : d;\n            d = (c.y==1) ? c.x < 16 ? 0x40000000U : c.x < 32 ? 0x1U : c.x < 48 ? 0x14000U : c.x < 64 ? 0x40000000U : c.x < 80 ? 0x1U : c.x < 96 ? 0x14000U : d : d;\n            d = (c.y==2) ? c.x < 16 ? 0x55000000U : c.x < 32 ? 0x30055U : c.x < 48 ? 0x555500U : c.x < 64 ? 0x5500000cU : c.x < 80 ? 0x300055U : c.x < 96 ? 0x555500U : d : d;\n            d = (c.y==3) ? c.x < 16 ? 0x55557fU : c.x < 32 ? 0x555c0155U : c.x < 48 ? 0x1550055U : c.x < 64 ? 0x55555cU : c.x < 80 ? 0x555c0155U : c.x < 96 ? 0x1550055U : d : d;\n            d = (c.y==4) ? c.x < 16 ? 0x55400U : c.x < 32 ? 0x54300554U : c.x < 48 ? 0x5540005U : c.x < 64 ? 0x5540cU : c.x < 80 ? 0x54030554U : c.x < 96 ? 0x5540005U : d : d;\n            d = (c.y==5) ? c.x < 16 ? 0x100000U : c.x < 32 ? 0x400U : c.x < 48 ? 0x4000010U : c.x < 64 ? 0x100000U : c.x < 80 ? 0x400U : c.x < 96 ? 0x4000010U : d : d;\n            d = (c.y==6) ? c.x < 16 ? 0x400000U : c.x < 32 ? 0x100U : c.x < 48 ? 0x1000040U : c.x < 64 ? 0x400000U : c.x < 80 ? 0x100U : c.x < 96 ? 0x1000040U : d : d;\n            d = (c.y==7) ? c.x < 16 ? 0x55000000U : c.x < 32 ? 0x55U : c.x < 48 ? 0x555500U : c.x < 64 ? 0x55000000U : c.x < 80 ? 0x55U : c.x < 96 ? 0x555500U : d : d;\n            d = (c.y==8) ? c.x < 16 ? 0x8000000U : c.x < 32 ? 0x8020U : c.x < 48 ? 0x80200800U : c.x < 64 ? 0x8000000U : c.x < 80 ? 0x8020U : c.x < 96 ? 0x80200800U : d : d;\n            d = (c.y==9) ? c.x < 16 ? 0xaaaa0000U : c.x < 32 ? 0x2aaaU : c.x < 48 ? 0x2aaaaaaaU : c.x < 64 ? 0xaaaa0000U : c.x < 80 ? 0x2aaaU : c.x < 96 ? 0x2aaaaaaaU : d : d;\n            c.y -= 10;\n\n            d = (c.y==0) ? c.x < 16 ? 0xaa00U : d : d;\n            d = (c.y==1) ? c.x < 16 ? 0xaaaa0U : d : d;\n            d = (c.y==2) ? c.x < 16 ? 0x2aaaa8U : d : d;\n            d = (c.y==3) ? c.x < 16 ? 0xaaaaaaU : d : d;\n            d = (c.y==4) ? c.x < 16 ? 0xaaaaaaU : d : d;\n            d = (c.y==5) ? c.x < 16 ? 0x14aaaaaaU : d : d;\n            d = (c.y==6) ? c.x < 16 ? 0x14c00003U : d : d;\n            d = (c.y==7) ? c.x < 16 ? 0xaa30000cU : d : d;\n            d = (c.y==8) ? c.x < 16 ? 0x2830000cU : d : d;\n            d = (c.y==9) ? c.x < 16 ? 0x280c0030U : d : d;\n            d = (c.y==10) ? c.x < 16 ? 0x820c0030U : d : d;\n            d = (c.y==11) ? c.x < 16 ? 0x820300c0U : d : d;\n            d = (c.y==12) ? c.x < 16 ? 0x820300c0U : d : d;\n            d = (c.y==13) ? c.x < 16 ? 0x8200c300U : d : d;\n            c.y -= 14;\n\n            d = (c.y==0) ? c.x < 16 ? 0x5500U : d : d;\n            d = (c.y==1) ? c.x < 16 ? 0x15540U : d : d;\n            d = (c.y==2) ? c.x < 16 ? 0x55550U : d : d;\n            d = (c.y==3) ? c.x < 16 ? 0x7d7d0U : d : d;\n            d = (c.y==4) ? c.x < 16 ? 0x55550U : d : d;\n            d = (c.y==5) ? c.x < 16 ? 0x115544U : d : d;\n            d = (c.y==6) ? c.x < 16 ? 0x505505U : d : d;\n            d = (c.y==7) ? c.x < 16 ? 0x46910U : d : d;\n            d = (c.y==8) ? c.x < 16 ? 0x11440U : d : d;\n            d = (c.y==9) ? c.x < 16 ? 0x4100U : d : d;\n            d = (c.y==10) ? c.x < 16 ? 0x1400U : d : d;\n            d = (c.y==11) ? c.x < 16 ? 0x1400U : d : d;\n            d = (c.y==12) ? c.x < 16 ? 0x4100U : d : d;\n            d = (c.y==13) ? c.x < 16 ? 0x50050U : d : d;\n            d = (c.y==14) ? c.x < 16 ? 0x10040U : d : d;\n            c.y -= 15;\n\n            d = (c.y==0) ? c.x < 16 ? 0x2aU : c.x < 32 ? 0x2a0000U : c.x < 48 ? 0x0U : d : d;\n            d = (c.y==1) ? c.x < 16 ? 0x82U : c.x < 32 ? 0x820000U : c.x < 48 ? 0x0U : d : d;\n            d = (c.y==2) ? c.x < 16 ? 0x202U : c.x < 32 ? 0x2020000U : c.x < 48 ? 0x0U : d : d;\n            d = (c.y==3) ? c.x < 16 ? 0x808U : c.x < 32 ? 0x8080000U : c.x < 48 ? 0x0U : d : d;\n            d = (c.y==4) ? c.x < 16 ? 0xaaaaa008U : c.x < 32 ? 0xa0080156U : c.x < 48 ? 0x156aaaaU : d : d;\n            d = (c.y==5) ? c.x < 16 ? 0x20U : c.x < 32 ? 0x200558U : c.x < 48 ? 0x5580000U : d : d;\n            d = (c.y==6) ? c.x < 16 ? 0x20U : c.x < 32 ? 0x201560U : c.x < 48 ? 0x15600000U : d : d;\n            d = (c.y==7) ? c.x < 16 ? 0xffff008cU : c.x < 32 ? 0xb0aa80U : c.x < 48 ? 0xaa80ffffU : d : d;\n            d = (c.y==8) ? c.x < 16 ? 0x80U : c.x < 32 ? 0x832000U : c.x < 48 ? 0x20000000U : d : d;\n            d = (c.y==9) ? c.x < 16 ? 0xaaaaaa33U : c.x < 32 ? 0xaa300aaaU : c.x < 48 ? 0xaaaaaaaU : d : d;\n            col = unpackCol(uint(c.x), d);\n        } else {\n            c.y -= ycol;\n            if(c.y==0) d =c.x < 32 ? 0x1e001e33U : c.x < 64 ? 0x7f3f1c3cU : c.x < 96 ? 0x3c183e00U : c.x < 128 ? 0x387e383cU : c.x < 160 ? 0x3c3e3fU : d;\n            if(c.y==1) d =c.x < 32 ? 0x33000c33U : c.x < 64 ? 0x46663666U : c.x < 96 ? 0x661c631cU : c.x < 128 ? 0xc063c66U : c.x < 160 ? 0x666333U : d;\n            if(c.y==2) d =c.x < 32 ? 0x7000c33U : c.x < 64 ? 0x16666303U : c.x < 96 ? 0x6018731cU : c.x < 128 ? 0x63e3660U : c.x < 160 ? 0x666330U : d;\n            if(c.y==3) d =c.x < 32 ? 0xe3f0c3fU : c.x < 64 ? 0x1e3e6303U : c.x < 96 ? 0x38187b00U : c.x < 128 ? 0x3e603338U : c.x < 160 ? 0x7c3e18U : d;\n            if(c.y==4) d =c.x < 32 ? 0x38000c33U : c.x < 64 ? 0x16366303U : c.x < 96 ? 0xc186f00U : c.x < 128 ? 0x66607f60U : c.x < 160 ? 0x60630cU : d;\n            if(c.y==5) d =c.x < 32 ? 0x33000c33U : c.x < 64 ? 0x46663666U : c.x < 96 ? 0x6618671cU : c.x < 128 ? 0x66663066U : c.x < 160 ? 0x30630cU : d;\n            if(c.y==6) d =c.x < 32 ? 0x1e001e33U : c.x < 64 ? 0x7f671c3cU : c.x < 96 ? 0x7e7e3e1cU : c.x < 128 ? 0x3c3c783cU : c.x < 160 ? 0x1c3e0cU : d;\n            c.y -= 7;\n\n            if(c.y==0) d =c.x < 32 ? 0x3c7f3f3fU : c.x < 64 ? 0x3cU : c.x < 96 ? 0x0U : c.x < 128 ? 0x7U : c.x < 160 ? 0x3f3e7fU : c.x < 192 ? 0x3f667f67U : c.x < 224 ? 0x1f3f1c3eU : c.x < 256 ? 0x1c0f3f00U : c.x < 288 ? 0x66U : d;\n            if(c.y==1) d =c.x < 32 ? 0x66466666U : c.x < 64 ? 0x66U : c.x < 96 ? 0x0U : c.x < 128 ? 0x6U : c.x < 160 ? 0x666346U : c.x < 192 ? 0x66664666U : c.x < 224 ? 0x36663663U : c.x < 256 ? 0x36066600U : c.x < 288 ? 0x66U : d;\n            if(c.y==2) d =c.x < 32 ? 0xc166666U : c.x < 64 ? 0x3b7e000cU : c.x < 96 ? 0x3e3e1eU : c.x < 128 ? 0x3b1e3eU : c.x < 160 ? 0x666316U : c.x < 192 ? 0x66661636U : c.x < 224 ? 0x66666363U : c.x < 256 ? 0x63066600U : c.x < 288 ? 0x66U : d;\n            if(c.y==3) d =c.x < 32 ? 0x181e3e3eU : c.x < 64 ? 0x66030018U : c.x < 96 ? 0x636330U : c.x < 128 ? 0x6e3066U : c.x < 160 ? 0x3e631eU : c.x < 192 ? 0x3e3c1e1eU : c.x < 224 ? 0x663e7f63U : c.x < 256 ? 0x7f063e00U : c.x < 288 ? 0x3cU : d;\n            if(c.y==4) d =c.x < 32 ? 0x30163606U : c.x < 64 ? 0x3e3e0030U : c.x < 96 ? 0x7f033eU : c.x < 128 ? 0x63e66U : c.x < 160 ? 0x366316U : c.x < 192 ? 0x66181636U : c.x < 224 ? 0x66366363U : c.x < 256 ? 0x63460600U : c.x < 288 ? 0x18U : d;\n            if(c.y==5) d =c.x < 32 ? 0x66466606U : c.x < 64 ? 0x6600066U : c.x < 96 ? 0x36333U : c.x < 128 ? 0x63366U : c.x < 160 ? 0x666306U : c.x < 192 ? 0x66184666U : c.x < 224 ? 0x36666363U : c.x < 256 ? 0x63660600U : c.x < 288 ? 0x18U : d;\n            if(c.y==6) d =c.x < 32 ? 0x3c7f670fU : c.x < 64 ? 0xf3f003cU : c.x < 96 ? 0x3e3e6eU : c.x < 128 ? 0xf6e3bU : c.x < 160 ? 0x673e0fU : c.x < 192 ? 0x3f3c7f67U : c.x < 224 ? 0x1f67633eU : c.x < 256 ? 0x637f0f00U : c.x < 288 ? 0x3cU : d;\n            col = unpackBW(uint(c.x), d);\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}