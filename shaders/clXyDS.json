{
    "Shader": {
        "info": {
            "date": "1692039132",
            "description": "2d automata history with variations. Only seen this with Game of Life before.\n\nCONTROLS: left/right=prev/next CA, up/down=prev/next CA clear, 7-9=speed, c=color, v=view, p=pause, space=regen, 1-5=clear method, w/s=zoom,  b=box, t=text\n",
            "flags": 48,
            "hasliked": 0,
            "id": "clXyDS",
            "likes": 30,
            "name": "Automata History Box",
            "published": 3,
            "tags": [
                "3d",
                "interactive",
                "voxel",
                "automata"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 425
        },
        "renderpass": [
            {
                "code": "\n// Increase SIZE in Common if your GPU can handle it!\n\n// Press UP/DOWN(clear) or LEFT/RIGHT for variants.\n\n// More keys: up/down=prev/next CA clear, 7-9=speed, c=color, v=view, p=pause, space=regen, 1-5=clear method, w/s=zoom,  b=box, t=text\n\n// Voxel cube from https://www.shadertoy.com/view/4lfSW4 by glk7\n\n#define EPS 0.001\n\nfloat N;\nint colmethod;\nint bbox;\nint row;\n\nfloat text(vec2 uv, float index)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(index,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv);// + _spc() + print_integer(iFrameRate,0,uv); \n    \n    return col;\n}\n\n\n// Taken from https://iquilezles.org/articles/palettes\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat cellval( in ivec3 p )\n{\n    int iN=int(N);\n    int n=p.x+p.y*iN+p.z*iN*iN;\n    int pos = (SPC-1) - (n % SPC);\n    int pi=(n%CPP)/SPC;\n    n /= CPP;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    ivec2 p2 = ivec2(n%r.x,n/r.x);\n\n    vec4 outv = texelFetch(iChannel0, p2, 0 );\n\n    int val = int(outv[pi]);\n    val >>= BPS*pos;\n    val = val & AND_VAL;\n    \n    return float(val);\n}\n\nbool map(in vec3 p, out float v) \n{\n    p+=5.; // 0 == -5\n\n    int NM=int(N)-1;\n    if (bbox == 1) {\n        int x=int(p.x),y=int(p.y),z=int(p.z);\n        //if (z==NM-2 || (x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n        if ((x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n            v=-1.;\n            return true;\n        }\n    }\n\n    float cv = cellval(ivec3(p));\n\n    if (int(p.z)==row) \n        v=-1.;\n    else if(colmethod == 1) {\n        v=cv*0.12; // col by state value\n    } else\n        v=length(p-N/2.)*0.1+1.5; // col by distance\n\n    return cv > 0.5;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    return normalize(smoothstep(0.1, 0.0, bmax - p) - \n                     smoothstep(0.1, 0.0, p - bmin));\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (dot(re - ro, rd) < EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < int(N*3.); ++i) {\n        if (map(ep, v)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (dot(re - ro, rd) < EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro, -rd, -invrd, bmin, bmax, re, pa);\n    if (dot(re - ro, rd) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 32.; ++i) {\n        if (map(ep, v)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (dot(re - ro, rd) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0/v0;\n    const vec3 invv1 = 1.0/v1;\n    const vec3 invv2 = 1.0/v2;\n    const vec3 invv3 = 1.0/v3;\n    const vec3 invv4 = 1.0/v4;\n    const vec3 invv5 = 1.0/v5; \n    const vec3 invv6 = 1.0/v6;\n    const vec3 invv7 = 1.0/v7;\n    vec3 invn = 1.0/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, float zmod, int view,\n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float yp=-3., xrot=-0.66;\n    if (view == 1) yp=0., xrot=0.0;\n    if (view == 2) yp=0., xrot=1.;\n    if (view == 3) yp=0., xrot=-1.;\n\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, yp, -d+zmod);\n\n    float mxc, myc;\n\n    if (iMouse.z > 0.) {\n        mxc = clamp(-((iMouse.x / iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n        myc = clamp((iMouse.y / iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    } else {\n        mxc=sin(sin(iTime*0.33))*1.17;\n        myc = xrot;\n    }\n\n    float mxs = sqrt(1.0-(mxc*mxc));\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=SIZE;\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < int(N)) N=float(maxsize-(1-maxsize%2));\n\n    float index = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int show2d = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    row = min(int(texelFetch(iChannel1, ivec2(5,0), 0 ).x),int(N)-2);\n    colmethod = int(texelFetch(iChannel1, ivec2(6,0), 0 ).x);\n    float zmod = texelFetch(iChannel1, ivec2(7,0), 0 ).x;\n    bbox = int(texelFetch(iChannel1, ivec2(8,0), 0 ).x);\n    int view = int(texelFetch(iChannel1, ivec2(10,0), 0 ).x);\n\n    if (show2d == 1 && fragCoord.y < N && fragCoord.x > iResolution.x - N) {\n        fragColor=texelFetch(iChannel2, ivec2(iResolution.x - fragCoord.x, fragCoord.y),0)*100.;\n        return;\n    }\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, index);    \n\n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(N, N, N) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(N*0.5), N*1.37, zmod, view, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 / rd;\n    vec3 invl = 1.0 / l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    #ifdef HORIZON\n    float yp=(iResolution.y - fragCoord.y);\n    float hp=0.10; if(view==1) hp=0.4; if(view==2) hp=1.;\n    float yf1=iResolution.y*hp, yf2=iResolution.y*(hp+0.2);\n    if (yp >= yf1 && yp < yf2) color = mix(vec3(0.4, 0.45, 0.85),vec3(0.03, 0.03, 0.03), 1.-(yf2-yp)/(yf2-yf1));\n    else if (yp < yf1) color = vec3(0.4, 0.45, 0.85);\n    #endif\n\n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n    \n    fragColor += text_pixel;    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "music",
                        "id": 20,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Persistive Keyboard Input buffer\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_M     = 77;\nconst int KEY_P     = 80;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) { fragColor = vec4(0.,0.,0.,1.0); discard; }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=1.001;\n                    if (kx > LAST_PATT+0.5) kx=0.5;\n                } else {\n                    kx-=1.001;\n                    if (kx < 0.) kx=LAST_PATT+0.5;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = -1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_T, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        float row = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_SPACE) )\n            row = 0.;\n        fragColor = vec4(row+1.001,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        float zmod = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_W)) zmod += 1.;\n        if( readKey(KEY_S)) zmod -= 1.;\n        zmod = clamp(zmod, -20., 40.);\n        fragColor = vec4(zmod,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 8 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_B, 1., 2.);\n        return;\n    }\n\n    if (ix == 9 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_P, 1., 2.);\n        if (readKey(KEY_DOWN) || readKey(KEY_UP))\n            fragColor = vec4(0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 4.);\n        return;\n    }\n\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// 3d cell buffer, pixel packed with 1 bit per state and using 15 bits per component for 15*4=60 cells per pixel \n// Max size: for 800*450, pow(800*450*60,1/3) = 278!\n// Could use up to 24 bits per component for desktop, but won't work on mobile\n\nint N;\n\nint cellval( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (SPC-1) - (n % SPC);\n    int pi=(n%CPP)/SPC;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= BPS*pos;\n    val = val & AND_VAL;\n    return val;\n}\n\nint aut2dval( in ivec3 p) {\n    ivec2 p2 = ivec2(p.x,p.y);\n    \n    int val = int(texelFetch(iChannel2, p2, 0 ).x*10.+0.);\n    return val;\n}\n\nvec4 cv4( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    return texelFetch(iChannel0, p2, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    int pos1d=int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    pos1d *= CPP;\n    if (pos1d > N*N*N) { fragColor = vec4(0.); return; }\n    fragCoord.x = float(pos1d % int(iResolution.x));\n    fragCoord.y = float(pos1d / int(iResolution.x));\n\n    float xres = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    int speed = 1+int(texelFetch(iChannel1, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel1, ivec2(9,0), 0 ).x);\n\n    int row = int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    if (row < N-2+speed) speed=0;\n    row = min(row,N-2);\n\n    int z=pos1d/(N*N);\n    pos1d-=z*N*N;\n    int y=pos1d/N;\n    int x=pos1d-y*N;\n\n    ivec4 fst=ivec4(0);\n\n    bool regen = iFrame < 1 || int(xres) != int(iResolution.x) || row==1;\n\n    if (!regen && (iFrame % (speed+1) > 0 || pause == 1)) {\n        fragColor = cv4(ivec3(x,y,z),0,0,0);\n        return;\n    }\n\n    for (int i=0; i<CPP; i++) {\n        int fi=i/SPC;\n        int xi=x+i,yi=y,zi=z;\n        if (xi >= N) {xi-=N; yi++; if (yi >= N) {yi=0; zi++;}}\n        ivec3 pos3d=ivec3(xi,yi,zi);\n\n        int NM=N-1;\n        if (xi==0 || yi==0 || zi==0 || xi==NM || yi==NM || zi==NM) {\n            fst[fi] = fst[fi]<<BPS;\n            continue;\n        }\n\n        if (regen) {\n            fst[fi] = (fst[fi] << BPS);\n            continue;\n        }\n\n        int st;\n        if (zi==row) {\n            st=aut2dval(pos3d);\n        }\n        else {\n            st = cellval(pos3d,0,0,1);\n        }\n\n        fst[fi] = (fst[fi] << BPS) | st;\n\n        fragCoord.x+=1.;\n        if(fragCoord.x >= iResolution.y) { fragCoord.y+=1.; fragCoord.x=0.; }\n    }\n\n    fragColor = vec4(fst);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SIZE 90.\n\nconst int BPS = 1; // Bits per state\nconst int SPC = 15; // States per component (BPS*SPC must be <=24, and to work for mobile <=15)\nconst int CPP = SPC*4; // Cells Per Pixel (*1,2,3,4 will work)\nconst int AND_VAL = (1 << BPS) - 1;\n\n//#define HORIZON\n\nconst float LAST_PATT = 28.001;\nfloat density=50.;\nfloat liveval = 0.1;\nint stayset, bornset;\nint clearmethod;\n\nvoid setRules(int index) {\n    int v1, v2;\n    clearmethod=-1;\n\n    if (index == 0) {v1 = 230, v2=196; density=10.; clearmethod=1; }   // Chaotic life, forced symmetry \n    if (index == 1) {v1 = 240, v2=40; density=73.;}    // Ink blobs \n    if (index == 2) {v1 = 70, v2=4; density=20.;}      // \"Self-activating\" GOL\n    if (index == 3) {v1 = 122, v2=225; density=60.;}   // Worms in static\n    if (index == 4) {v1 = 120, v2=4; density=85.;}     // Black vs white landscape \n    if (index == 5) {v1 = 175, v2=8; density=20.;}     // Stable bg\n    if (index == 6) {v1 = 241, v2=92; density=11.;}    // Oddly growing rects\n    if (index == 7) {v1 = 122, v2=240; density=60.;}   // Stable worms\n    if (index == 8) {v1 = 122, v2=65; density=60.;}    // Chaos + stable\n    if (index == 9) {v1 = 122, v2=65; density=70.;}    // Chaos + stable II\n    if (index == 10) {v1 = 96, v2=57; density=100.;}   // Grow to stable flashing\n    if (index == 11) {v1 = 249, v2=228; density=14.;}  // Growing blobs\n    if (index == 12) {v1 = 243, v2=24; density=55.;}   // Stable BW\n    if (index == 13) {v1 = 243, v2=88; density=45.;}   // Stable BW II\n    if (index == 14) {v1 = 249, v2=216; density=31.;}  // Stable \"stones\"\n    if (index == 15) {v1 = 121, v2=16; density=54.;}   // Squiggly no chaos\n    if (index == 16) {v1 = 185, v2=9; density=50.;}    // Ant war\n    if (index == 17) {v1 = 113, v2=89; density=50.;}   // Ant war with spots\n    if (index == 18) {v1 = 227, v2=255; density=18.;}  // Hornet's nest\n    if (index == 19) {v1 = 242, v2=18; density=63.;}   // Slow growing blobs in chaos\n    if (index == 20) {v1 = 5, v2=12; density=70.;}     // Chaotic life III\n    if (index == 21) {v1 = 219, v2=216; density=50.;}  // Black eating ant war\n    if (index == 22) {v1 = 248, v2=65; density=10.;}   // Random to stable takeover\n    if (index == 23) {v1 = 248, v2=66; density=10.;}   // Growing jigsaw\n    if (index == 24) {v1 = 0, v2=61; density=90.;}     // Triangles\n    if (index == 25) {v1 = 222, v2=32; density=100.;}  // Stone\n    if (index == 26) {v1 = 51, v2=4; density=10.;}     // Non-growing chaos\n    if (index == 27) {v1 = 120, v2=68; density=97.;}   // Slow growing \"maps\"\n    if (index == 28) {v1 = 38, v2=20;  density=9.;}    // Chaotic life II\n\n    stayset=v1, bornset=v2;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": " // Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nint N;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    if (p.y < 0) p.y = N-1;\n    if (p.x < 0) p.x = N-1;\n    if (p.y >= N) p.y = 0;\n    if (p.x >= N) p.x = 0;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nfloat cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return val;\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., liveval);\n}\n\nfloat restart(vec2 fragCoord, int method) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = vec2(N,N) / 2.; \n    float w=25., h=25., radius=25.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;\n        return 0.;\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;\n        return 0.;\n    }\n    if (method == 3) {\n        if (length(fragCoord-mid)< radius)\n            return liveval;\n        return 0.;\n    }\n    if (method == 4) {\n        if (fragCoord.x > mid.x - radius && fragCoord.x < mid.x + radius && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius)\n            return liveval;\n        return 0.;\n    }\n\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    if (int(fragCoord.y) > N) discard;\n    if (int(fragCoord.x) > N) { fragColor = vec4(0.); return; }\n\n    float ix = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int method = int(texelFetch(iChannel3, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel3, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel3, ivec2(9,0), 0 ).x);\n    \n    setRules(int(ix));\n    if(clearmethod>=0) method=clearmethod;\n    \n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_RIGHT) || readKey(KEY_LEFT) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)\n     || readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor =  vec4(restart(fragCoord, method), 0.,0.,0.);\n        return;\n    }\n\n    ivec2 px = ivec2( fragCoord );\n\n    if (iFrame % (speed+1) > 0 || pause == 1) {\n        fragColor = vec4( cellval(px), 0.0, 0.0, 0.0 );\n        return;\n    }\n    \n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    int f = 0;\n    if (e==1) {\n        f = 0;\n        if ((stayset & (1<<(k-1))) > 0 ) f=1;\n    }\n    else {\n        f = (bornset & (1<<(k-1))) > 0 ? 1 : 0;\n    }\n\n    float ff = float(f)/10.;\n\n\tfragColor = vec4( ff, 0.0, 0.0, 0.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// resolution change\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4(iResolution.x); }\n",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}