{
    "Shader": {
        "info": {
            "date": "1493283171",
            "description": "Simulation of light drop-off in two dimensions with multisample anti-aliasing",
            "flags": 0,
            "hasliked": 0,
            "id": "MsScRc",
            "likes": 15,
            "name": "2D point lights",
            "published": 3,
            "tags": [
                "2d",
                "mouse",
                "interactive",
                "lighting",
                "antialiasing",
                "msaa"
            ],
            "usePreview": 0,
            "username": "fermion",
            "viewed": 1314
        },
        "renderpass": [
            {
                "code": "#define pixelWidth 1.0/iResolution.x\n#define offset_a pixelWidth * 0.5\n#define offset_b pixelWidth * 0.8\n// \n//\nstruct Light {\n    vec3 color;\n    vec2 pos;\n    float min;\n    float max;\n    float brightness;\n};\n \n//Line is used to define lines and boxes\nstruct Line {\n    vec2 start;\n    vec2 end;\n};\n\n//Define box to obstruct light   \nLine box= Line(vec2(0.7, 0.5), vec2(0.8, 0.6));\n\n//Two Lights, light0 is controlled by the mouse, light1 moves in a sine wave\n//                   { Color },          {Position},    {Min},{Max},{Brightness}\nLight light0 = Light(vec3(1.0, 1.0, 1.0), vec2(0.5, 0.7), 0.0, 1.5, 0.7);\nLight light1 = Light(vec3(1.0, 1.0, 1.0), vec2(0.5, 0.5), 0.0, 2.5, 0.7);\n\n/////////////////////////////////////////////////////////////\n\nfloat hyperstep(float min, float max, float x) {\n    \t            \n    if (x < min) {\n        return 1.0;\n    }\n    else if (x > max) {\n        return 0.0;\n    }\n    else {\n\n        //linear interpolation of x between min and max\n        float value= (x - min) / (max - min);\n\n        //hyperbolic function: 100/99 * (9x + 1)^2 - 1/99\n        return (100./99.) / ((9. * value + 1.) * (9. * value + 1.)) - (1./99.);\n    }\n}\n\n\n\nvec2 intersectPoint(Line line_0, Line line_1) {\n    \n    float slope_0, slope_1, x, y;\n    \n    if (line_0.start.x == line_0.end.x) {\n        \n        //slope_0 is infinite\n        slope_1= (line_1.start.y - line_1.end.y) / (line_1.start.x - line_1.end.x);\n        \n        x= line_0.start.x;\n        y= slope_1 * x + line_1.start.y;\n        \n    }\n    else if (line_1.start.x == line_1.end.x) {\n        \n        //slope_1 is infinite\n        slope_0= (line_0.start.y - line_0.end.y) / (line_0.start.x - line_0.end.x);\n        \n        x= line_1.start.x;\n        y= slope_0 * (x - line_0.start.x) + line_0.start.y;\n        \n    }\n    else {\n    \n        slope_0= (line_0.start.y - line_0.end.y) / (line_0.start.x - line_0.end.x);\n        slope_1= (line_1.start.y - line_1.end.y) / (line_1.start.x - line_1.end.x);\n\n        if (slope_0 != slope_1) {\n\t\t\t\n            //calculate y-intercept of line_1 based on line_0.start\n            float b= slope_1 * (line_0.start.x - line_1.start.x) + line_1.start.y;\n            \n            x= (b - line_0.start.y) / (slope_0 - slope_1);\n            y= slope_0 * x + line_0.start.y;\n            x= x + line_0.start.x;\n            \n\n        }\n        //lines are parallel\n        else return vec2(-1.0);\n    }\n    \n    \n    return vec2(x, y);\n}\n\nbool inside(Line box, vec2 point) {\n    \n    vec2 minValues = vec2( min(box.start.x, box.end.x), min(box.start.y, box.end.y) );\n    vec2 maxValues = vec2( max(box.start.x, box.end.x), max(box.start.y, box.end.y) );\n    \n    if (point.x < minValues.x) return false;\n    if (point.x > maxValues.x  ) return false;\n    if (point.y < minValues.y) return false;\n    if (point.y > maxValues.y  ) return false;\n    return true;\n    \n}\n\nbool intersects(Line a, Line b) {\n    \n    vec2 point = intersectPoint(a, b);\n    \n    return inside(a, point) && inside(b, point);\n}\n\nvec3 calculateLighting(vec2 pixel, Light light) {\n    \n    Line LoS= Line(pixel, light.pos);\n    \n    if ( intersects(LoS, Line(box.start, vec2(box.end.x, box.start.y))) ||\n         intersects(LoS, Line(box.start, vec2(box.start.x, box.end.y))) ||\n         intersects(LoS, Line(box.end, vec2(box.start.x, box.end.y)))   ||\n         intersects(LoS, Line(box.end, vec2(box.end.x, box.start.y))) ) {\n        \n        return vec3(0.0);\n    }\n    else {\n               \n        return hyperstep(light.min, light.max,  distance(pixel, light.pos)) * light.brightness * light.color;\n    }\n}\n\nvec3 multisample(vec2 pixel) {\n \n    vec2 points[4];\n    \n    points[0] = pixel + vec2(offset_a, offset_b);\n    points[1] = pixel + vec2(-offset_a, -offset_b);\n    points[2] = pixel + vec2(offset_b, -offset_a);\n    points[3] = pixel + vec2(-offset_b, -offset_a);\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i= 0; i < 4; i++) {\n        color+= calculateLighting(points[i], light0);\n        color+= calculateLighting(points[i], light1);\n    }\n    \n    return color / 4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n    vec2 pixel= fragCoord / iResolution.y;\n    \n    light0.pos= iMouse.xy / iResolution.y;\n    \n    light1.pos.y= sin(iTime) / 4.0 + 0.5;\n    \n    //background color\n    vec3 color= vec3(0.2, 0.1, 0.0);\n      \n    //anti-aliasing\n    color+= multisample(pixel);\n    \n    //without anti-aliasing\n    //color+= calculateLighting(pixel, light0);\n    //color+= calculateLighting(pixel, light1);\n    \n    if (inside(box, pixel)) {\n        \n        //box color\n        color = vec3(0.25, 0.4, 0.0);\n    }\n    \n    fragColor= vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}