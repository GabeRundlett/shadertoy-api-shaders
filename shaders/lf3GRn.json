{
    "Shader": {
        "info": {
            "date": "1711290721",
            "description": "By placing a point dipole on a sphere and taking the directions of the magnetic vector potential along the sphere, you get a tangent space with only one discontinuity. In view space, you can always hide that away from the camera!",
            "flags": 0,
            "hasliked": 0,
            "id": "lf3GRn",
            "likes": 3,
            "name": "1 pole tangent space on sphere",
            "published": 3,
            "tags": [
                "dipole",
                "tangent",
                "tangentspace"
            ],
            "usePreview": 0,
            "username": "hasse",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "// CC0\n// This is a method for computing tangents with just a normal vector.\n// It's based on taking the vector potential of a magnetic dipole and\n// forcing it to be perpendicular to the normal. This method is nice\n// in that it only has one point of discontinuity, which is optimal\n// for a sphere: https://en.wikipedia.org/wiki/Hairy_ball_theorem.\n//\n// You probably shouldn't use this for generating tangents unless you\n// have a very specific use case in mind. My motivation is to improve\n// random replay shift of ReSTIR-PT; discontinuities in tangent space\n// appear as noisy lines on surfaces, so avoiding discontinuity is vital.\n//\n// Parameters:\n//     \"moment\" is the general direction of the field (orientation of magnet).\n//     \"singularity\" is the normal where you'll get a discontinuity (position of magnet)\n//     \"normal\" is the normal for which you want to produce a tangent.\n//\n// \"singularity\" and \"normal\" should be unit vectors. Singularity\n// and moment must be perpendicular to each other, otherwise you get\n// two discontinuities.\n//\n// To hide the singularity in view space, set \"moment\" to the\n// X or Y vector of your view space and \"singularity\" to the -Z vector.\nvec3 dipole_tangent_field(vec3 moment, vec3 singularity, vec3 normal)\n{\n    vec3 potential = cross(moment, normal - singularity);\n    return normalize(potential - dot(potential, normal) * normal);\n}\n\n\n\n\n\n\n// Visualization code below.\n\nvec2 sphere_intersection(vec3 pos, float radius, vec3 ray_origin, vec3 ray_dir)\n{\n    vec3 rp = ray_origin - pos;\n    float a = dot(ray_dir, ray_dir);\n    float b = dot(rp, ray_dir);\n    float c = dot(rp, rp) - radius * radius;\n    float discriminant = b * b - a * c;\n    if(discriminant < 0.0f) return vec2(-1.0f);\n    float sqrtD = sqrt(discriminant);\n    return (vec2(-sqrtD, sqrtD) - b) / a;\n}\n\nmat3 rot_x(float a)\n{\n    return mat3(1, 0, 0, 0, cos(a), sin(a), 0, -sin(a), cos(a));\n}\n\nmat3 rot_y(float a)\n{\n    return mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0f - 1.0f;\n    uv.x *= float(iResolution.x)/iResolution.y;\n    vec3 ray_dir = normalize(vec3(uv, -9.0f));\n    vec3 ray_origin = vec3(0,0,10);\n    \n    mat3 view = rot_y(-3.141592 * 2.0f * iMouse.x / iResolution.x);\n    view *= rot_x(3.141592 * 2.0f * iMouse.y / iResolution.y);\n    ray_dir = view * ray_dir;\n    ray_origin = view * ray_origin;\n\n    vec2 hit_t = sphere_intersection(vec3(0), 1.0f, ray_origin, ray_dir);\n    vec3 hit_p = ray_origin + ray_dir * hit_t.x;\n    \n    vec3 normal = normalize(hit_p);\n\n    // World-space version where you can see the singularity:\n    vec3 tangent = dipole_tangent_field(vec3(0,1,0), vec3(0,0,1), normal);\n    // View-space version which hides the singularity:\n    //vec3 tangent = dipole_tangent_field(view[0], -view[2], normal);\n \n    vec3 color = tangent * 0.5 + 0.5; // Visualize tangent vectors\n    //vec3 color = vec3(abs(dot(tangent, normal))); // for quick visual proof of tangent-ness\n    if(hit_t.x < 0.0) color = vec3(0);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}