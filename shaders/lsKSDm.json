{
    "Shader": {
        "info": {
            "date": "1464879155",
            "description": "[url=https://www.shadertoy.com/view/MdKXDD]One Tweet Cellular Pattern[/url] displaced on ball with page curl for showing two different effect\nyou can use mouse axis y for control curl effect\nans mouse axis x for control the displace scale",
            "flags": 0,
            "hasliked": 0,
            "id": "lsKSDm",
            "likes": 15,
            "name": "Ray Marching Experiment 46",
            "published": 3,
            "tags": [
                "ray",
                "experiment",
                "curl",
                "marching",
                "effect",
                "cellular",
                "pattern",
                "page",
                "46"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 1282
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst vec3 startColor = vec3(1,0.26,0);\nconst vec3 endColor = vec3(0.33,0.2,0.49);\n\nvec4 p = vec4(1.2,0.92,1.88,0.8);\nvec3 k = vec3(-.3, 5, 4);\n\n/* One Tweet Cellular Pattern : https://www.shadertoy.com/view/MdKXDD */\n#define ff length(fract(p*=mat2(7, -5, 5, 7)*.1) - .5)\n   \nvec4 DrawBack(vec2 p) // creux\n{\n    p-=.5;\n    p*=20.;\n    return vec4(min(min(ff, ff), ff)/.7); /* One Tweet Cellular Pattern : https://www.shadertoy.com/view/MdKXDD */\n}\n\nvec4 DrawFront(vec2 p) // relief\n{\n   \tp-=.5;\n    p*=20.;\n    return 1.-vec4(min(min(ff, ff), ff)/.7); /* One Tweet Cellular Pattern : https://www.shadertoy.com/view/MdKXDD */\n}\n\n/////////////////////////////////////////////////////////\n// page curl effect from the shader https://www.shadertoy.com/view/XlX3RS\n// himself based on qt540 project sample \"qmlvideofx\"; himself inspired from \n//http://rectalogic.github.com/webvfx/examples_2transition-shader-pagecurl_8html-example.html\n\nfloat curlExtent = 0.;\n    \nconst float minAmount = -0.16;\nconst float maxAmount = 1.3;\nconst float PI = 3.14159;\nconst float scale = 512.0;\nconst float sharpness = 3.0;\nvec4 bgColor;\n\nfloat amount;\nfloat cylinderCenter;\nfloat cylinderAngle;\nconst float cylinderRadius = 1. / PI / 2.0;\n\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)\n{\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\n\nvec4 antiAlias(vec4 color1, vec4 color2, float distance)\n{\n    distance *= scale;\n    if (distance < 0.0) return color2;\n    if (distance > 2.0) return color1;\n    float dd = pow(1.0 - distance / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\n\nfloat distanceToEdge(vec3 point)\n{\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\n\nvec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)\n{\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))\n        return bgColor;\n    if (yc > 0.0)\n        return DrawFront(p);\n    vec4 color = DrawFront(point.xy);\n    vec4 tcolor = vec4(0.0);\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\n\nvec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)\n{\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n    if (shadow < 0.0)\n        shadow = 0.0;\n    else\n        shadow *= amount;\n    vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\n\nvec4 backside(float yc, vec3 point)\n{\n    vec4 color = DrawFront(point.xy);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\n\n/////////////////////////////////////////////\n\n//////2D FUNC TO MODIFY////////////////////\nvec3 effect(vec2 uv) \n{\n    uv/=8.;\n    uv+=0.5;\n    \n\tbgColor = DrawBack(uv);\n    \n    curlExtent = (sin((iTime)*0.3)*0.5+0.5);\n    \n    if (iMouse.z>0.) curlExtent = 1.-iMouse.y/iResolution.y;\n        \n\tamount = curlExtent * (maxAmount - minAmount) + minAmount;\n\tcylinderCenter = amount;\n\tcylinderAngle = 2.0 * PI * amount;\n\n    const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n    mat3 rotation = mat3(c, s, 0, -s, c, 0, 0.12, 0.258, 1);\n    c = cos(angle);\n    s = sin(angle);\n    mat3 rrotation = mat3(c, s, 0, -s, c, 0, 0.15, -0.5, 1);\n    vec3 point = rotation * vec3(uv, 1.0);\n    float yc = point.y - cylinderCenter;\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n    if (yc < -cylinderRadius) // See through to background\n    {\n        color = bgColor;\n    } \n    else if (yc > cylinderRadius) // Flat surface\n    {\n        \n        color = DrawFront(uv);\n    } \n    else \n    {\n        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n        float hitAngleMod = mod(hitAngle, 2.0 * PI);\n        if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) \n        {\n            color = seeThrough(yc, uv, rotation, rrotation);\n        } \n        else \n        {\n            point = hitPoint(hitAngle, yc, point, rrotation);\n            if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) \n            {\n                color = seeThroughWithShadow(yc, uv, point, rotation, rrotation);\n            } \n            else \n            {\n                color = backside(yc, point);\n                vec4 otherColor;\n                if (yc < 0.0) \n                {\n                    float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n                    shado *= pow(-yc / cylinderRadius, 3.0);\n                    shado *= 0.5;\n                    otherColor = vec4(0.0, 0.0, 0.0, shado);\n                } \n                else \n                {\n                    otherColor = DrawFront(uv);\n                }\n                color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n            }\n        }\n    }\n    return color.rgb;\n}\n\n///////FRAMEWORK////////////////////////////////////\nvec4 displacement(vec3 p)\n{\n    vec3 col = effect(p.xz);\n    \n    col = clamp(col, vec3(0), vec3(1.));\n    \n    float scale = 0.2;\n    if (iMouse.z > 0.)\n        scale *= iMouse.x / iResolution.x;\n    \n    float dist = dot(col,vec3(scale));\n    \n    return vec4(dist,col);\n}\n\n////////BASE OBJECTS///////////////////////\nfloat obox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\nfloat osphere( vec3 p, float r ){ return length(p)-r;}\n////////MAP////////////////////////////////\nvec4 map(vec3 p)\n{\n   \tvec4 disp = displacement(p);\n        \n    float y = 1. - smoothstep(0., 1., disp.x);\n    \n    float dist = osphere(p, +4.8 -y);\n    \n    return vec4(dist, disp.yzw);\n}\n\n///////////////////////////////////////////\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.015, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n///////////////////////////////////////////\nfloat march(vec3 ro, vec3 rd, float rmPrec, float maxd, float mapPrec)\n{\n    float s = rmPrec;\n    float d = 0.;\n    for(int i=0;i<250;i++)\n    {      \n        if (s<0.025*log(d*d/s/500.)||s>maxd) break;\n        s = map(ro+rd*d).x;\n        d += s*0.2;\n    }\n    return d;\n}\n\n////////MAIN///////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float time = iTime*0.3;\n    float cam_a = 0.; // angle z\n    \n    float cam_e = 5.2; // elevation\n    float cam_d = 1.; // distance to origin axis\n   \t\n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); //Change camere view here\n  \tfloat li = 0.6; // light intensity\n    float prec = 0.00001; // ray marching precision\n    float maxd = 10.; // ray marching distance max\n    float refl_i = 0.45; // reflexion intensity\n    float refr_a = 0.7; // refraction angle\n    float refr_i = 0.8; // refraction intensity\n    float bii = 0.35; // bright init intensity\n    float marchPrecision = 0.8; // ray marching tolerance precision\n       \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. -1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); //\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = march(ro, rd, prec, maxd, marchPrecision);\n    \n    if (d<maxd)\n    {\n        vec2 e = vec2(-1., 1.)*0.005; \n    \tvec3 p = ro+rd*d;\n        vec3 n = calcNormal(p);\n        \n        b=li;\n        \n        vec3 reflRay = reflect(rd, n);\n\t\tvec3 refrRay = refract(rd, n, refr_a);\n        \n        vec3 cubeRefl = texture(iChannel0, reflRay).rgb * refl_i;\n        vec3 cubeRefr = texture(iChannel0, refrRay).rgb * refr_i;\n        \n        col = cubeRefl + cubeRefr + pow(b, 15.);\n        \n        ///////////////////////////////////////////////////\n        /* iq lighting */\n       \tfloat occ = calcAO( p, n );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, reflRay.y );\n        float fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( reflRay, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( p, lig, 0.02, 2.5 );\n       \tdom *= softshadow( p, reflRay, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol *= brdf;\n\t\t///////////////////////////////////////////////////\n        \n    \tcol = mix(col, map(p).yzw, 0.5);\n    }\n    else\n    {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n\tfragColor.rgb = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}