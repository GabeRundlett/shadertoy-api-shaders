{
    "Shader": {
        "info": {
            "date": "1581720076",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "Wl3XD2",
            "likes": 21,
            "name": "Day 57",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 621
        },
        "renderpass": [
            {
                "code": "// thanks to mla and Kali!\n// They have super nice examples on inversion\n\n// it's really simple, basically\n// p /= dot(p,p);\n// p = sin(p);\n// SDFs\n// return distance*dot(p,p);\n\n\n// and ofc Inigo quilez for pallete!\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.4)*0.1;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.4)*1.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 1.;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    \n    fragColor = max(fragColor, 0.);\n    //fragColor.xyz = pow(fragColor.xyz, vec3(2.,1. + sin(iTime)*0.2,1. - sin(iTime)*0.2));\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.45 + dot(uvn,uvn)*.9));\n\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    fragColor *= 1. - dot(uvn,uvn)*1.;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define pi acos(-1.)\n#define lightDist 7.\nvec3 glow = vec3(0);\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat valueNoise(float i){return mix(texture(iChannel0,vec2(floor(i))/1024.),texture(iChannel0,vec2(floor(i) + 1.)/1024.),smoothstep(0.,1.,fract(i))).x; }\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec2 uCoords;\n\n#define pmod(p,x) mod(p,x) - x*0.5\n\n#define modDist 1.\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sqId;\n\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define dmax(a,b) a.x > b.x ? a : b\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\n    vec3 u = p;\n    u.z = mod(u.z, lightDist) - 0.5*lightDist;\n    \n    vec2 sqId = vec2(pModPolar(p.xy, 6.), floor(p.z/modDist));\n    float ri = texture(iChannel0, vec2(sqId.x*0.01, sqId.y*0.01)).x;\n    float rb = texture(iChannel0, vec2(sqId.x*0.014, sqId.y*0.015)).x;\n    //p.y += 0.4;\n    //p.xy *= rot(-0.7*pi);    \n    \n    p.z = pmod(p.z, modDist);\n    \n    //d.x = min(d.x,p.y);\n    //d.x = min(d.x,length(p) - 0.1);\n    \n    \n    #define W 0.5\n    \n    float wall = -p.x + W;\n    if(rb < 0.33){\n    \tfloat freq = 40.;\n    \tvec2 uWall = fract(p.yz*freq) - 0.5;\n    \twall -= smoothstep(0.,0.3,length(uWall))*0.004;\n    \td = dmin(d,vec2(wall, 1.));\n    } else if(rb < 0.66){\n    \tfloat freq = 10.;\n    \tvec2 uWall = fract(p.yz*freq) - 0.5;\n        \n        wall += smoothstep(0.1,1., min(length(uWall.x), length(uWall.y)))*0.01;\n    \t//wall -= smoothstep(0.,0.3,length(uWall))*0.004;\n    \td = dmin(d,vec2(wall, 5.));\n    } else {\n    \tfloat freq = 21.;\n    \tvec2 uWall = fract(p.yz*freq) - 0.5;\n        \n        //wall += smoothstep(0.,1., exp(-length(uWall.x) ))*0.03;\n        \n        wall += smoothstep(0.,1., max(exp(-length(uWall.x*20.) ), exp(-length(uWall.y*20.) )))*0.002;\n        //wall += smoothstep(0.2,1., length(uWall.x))*0.03;\n        //wall += smoothstep(0.2,1., min(length(uWall.x), length(uWall.y)))*0.03;\n    \t//wall -= smoothstep(0.,0.3,length(uWall))*0.004;\n    \td = dmin(d,vec2(wall, 6.));\n    }\n    \n    //wall -= length(uWall)*0.006;\n    \n    //wall -= sin(uWall.x + uWall.y )*0.001;\n    \n    \n    u.x = abs(u.x);\n    u.x -= 0.05;\n    u.y -= 0.5;\n    \n    //q.xz *= rot(0.25);\n    \n    vec3 l = vec3(0);\n    l.z = floor(p.z/lightDist)*lightDist ;\n    l.y += W*0.6;\n    l.z += 0.5*lightDist;\n    d = dmin( d, vec2( sdCapsule( u, vec3(0,0,0.5), vec3(0.0), 0.03 ), 4.) );\n    \n    \n    vec3 q = p;\n    \n    q = p ;\n    q.y = abs(q.y);\n    //p.y -= 0.29;\n    q.y -= W*0.6;\n    \n    d = dmin(d, vec2(length(q.xy ) - 0. , 1.));\n    \n\n    //p.xy\n    \n    q.xy -= vec2(W, 0.);\n    q.xy = abs(q.xy) - vec2(0.01,0.04);\n    \n    d = dmin(d,vec2(max(q.x,q.y ), 2. ));\n    q = p;\n    q.xy -= vec2(W, 0.);\n    q.z -= W*0.91;\n    q.zx = abs(q.zx) - vec2(0.05,0.01);\n    d = dmin(d,vec2(\n        max(\n            max(q.z,q.x ),\n            -max(q.z + 0.02,q.x - 0.002 )\n        )\n        , 2.) );\n    \n    //d.x = min(d.x,max(p.x,p.y ) + 0.001 );\n    \n    \n    \n    p.z -= modDist*0.5;\n    p.x -= 0.5;\n    //d = dmin(d,vec2(length(p) - 0.02, 2.) );\n    \n    float bW = 0.3;\n    p.z += bW*1.75;\n    vec2 dB = dmax(\n        vec2(sdRoundBox( p, vec3(0.01,0.1,bW), 0.001 ), 2.),\n        vec2(-sdRoundBox( p + vec3(0.02,0,0), vec3(0.01,0.1*0.8,bW*0.8), 0.004 ), 3.)\n    \t);\n\n    \n    if(ri > 0.8){\n    \td = dmin(d,dB );\n    \n    }\n        \n    if(sqId.x == 1.){\n        //p.y\n    \t\n    \t//d = dmin(d,vec2(length(p) - 0.22, 2.) );\n    \t//d = dmin(d,vec2(max(p.z,p.x ) - 0.1, 2.) );\n    }\n    \n    //d = dmin(d,vec2(length(p) - 0.02, 2.) );\n    uCoords = p.yz;\n    //d.x *= 0.1;\n    return d;\n}\n\n\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0);\n    return normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n    \n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p,inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n    p = ro; t = 0.; hit = false;\n    for (int i = 0; i < 250; i++){\n    \td = map(p);\n        if(d.y == 4.)\n    \t\tglow += exp(-d.x*10.);\n        if (d.x < 0.001){\n            hit = true;\n        \tbreak;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n\treturn d;\n}\n#define mx (iTime*0.7 + 20.*iMouse.x/iResolution.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - dot(uv, uv)*0.05;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    ro.z += mx;\n    \n    vec3 rd = normalize(vec3(uv, 1.9));\n    \n    rd.xy *= rot(sin(iTime*0.2)*0.1);\n    rd.yz *= rot(sin(-iTime*0.2)*0.02);\n    \n    bool hit; float t; vec3 p ; ro;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    float lightNoise;\n    if(hit){\n        vec3 l = vec3(0);\n        float lid = floor(p.z/lightDist);\n        l.z = lid*lightDist ;\n        l.y += W*0.6;\n        l.z += 0.5*lightDist;\n    \tvec3 n = getNormal(p);\n    \t//col += n*0.7;\n        vec3 albedo;\n        if(d.y == 1.){\n        \talbedo = vec3(1);\n        }\n    \tvec3 h = normalize(l - rd);\n        \n        float diff = max(dot(n, l),0.);\n        float spec = pow(max(dot(n, h),0.), 20.);\n        float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n        \n        vec3 lightCol = vec3(1.,1.,1.);\n\n        vec3 L = normalize(l - p);\n        vec3 H = normalize(L - rd);\n\n\n        int id = int(d.y);\n        float METALNESS = 0.1;\n        float ROUGHNESS = 0.5;\n        \n        \n        vec3 F0 = vec3(0.03); \n        if(d.y == 2.){\n        \talbedo = vec3(0.02);\n        } else if (d.y == 1.){\n        \talbedo = vec3(1.);\n        }else if (d.y == 4.){\n        \tcol = vec3(1.);\n        } else if (d.y == 3.){\n            \n            uCoords.x += sin(uCoords.y*200. + iTime);\n        \tcol += mix(\n                texture(iChannel0, uCoords*0.4).x,\n                texture(iChannel0, uCoords*0.4).x,0.1\n            \n            );\n            col = 1. - col;\n        }else if (d.y == 5.){\n        \tF0 = vec3(0.63); \n        \talbedo = vec3(0.1);\n        \t//col = vec3(1.);\n        }else if (d.y == 6.){\n        \tMETALNESS = 0.9;\n        \tROUGHNESS = 0.9;\n        \talbedo = vec3(1.);\n        \t//col = vec3(1.);\n        }\n        //albedo = vec3(1);\n        vec3 N = getNormal(p);\n        vec3 V = normalize(ro - p);\n        //vec3 V = -rd;\n\n        F0 = mix(F0, albedo, METALNESS);\n\n        // calculate per-light radiance\n        float distL    = length(l - p)*1.;\n        float attenuation = 1. / (distL * distL);\n        //float attenuation = dist*0.02;\n        //attenuation = 1.;\n        vec3 radiance     = lightCol * attenuation;        \n\n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, ROUGHNESS);   \n        float G   = GeometrySmith(N, V, L, ROUGHNESS);      \n        vec3 F    = fresnelSchlick(clamp(dot(N, V), 0.0, 1.0), F0);     \n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - METALNESS;\t  \n\n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = numerator / max(denominator, 0.001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0); \n        \n        lightNoise = valueNoise(iTime*200.)*0.9*(mod(lid, 2.)- 1.)*abs(sin(iTime));\n        attenuation -= lightNoise;\n        \n\t\t//attenuation += valueNoise(iTime);\n        col += (kD * albedo / PI + specular) * radiance * NdotL * attenuation; \n        \n\t\t\n\n        //col.xz += mod(uCoords, 0.29);\n    } else {\n    \n    }\n    \n    col += glow * (0.05 - lightNoise*2.);\n    \n    col *= 1. -  smoothstep(0.,1., t*0.03);\n    \n    //col += glow*0.02*smoothstep(0.,1.,t*4.1);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}