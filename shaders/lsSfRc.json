{
    "Shader": {
        "info": {
            "date": "1501440867",
            "description": "mouse does things\n\nA hull curve that also serves as conveyor belt snake.\n\nsometimes apparently hard problems turn out to be surprisingly simple;\nI thought this would not have an analytic solution, where it turned it to be; c=a-b;",
            "flags": 0,
            "hasliked": 0,
            "id": "lsSfRc",
            "likes": 0,
            "name": "snake hull3 tanStep()",
            "published": 3,
            "tags": [
                "conveyor",
                "hull",
                "sawcos",
                "tanrope",
                "tanstep"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 544
        },
        "renderpass": [
            {
                "code": "//remove [endless] to see only 1 segment.\n//sadly the modulo of this function creates a silly discontinuity, maybe not on all machines.\n#define endless\n\n#define aa 10./iResolution.y\n//view zoom\n#define viewZoom 5.\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\n#define pi acos(-1.)\n\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,1.-15./iResolution.y);}\nvec3 SawCos3(vec3 c){\n vec3 s=vec3(sawCos(c.r),sawCos(c.g),sawCos(c.b));\n c=mix(s//supersmooth sawCos() ripple\n      ,smoothstep(aa,-aa,c)//make \"negative inside\" brighter than \"positive outside\"\n      ,.8)////mix the above 2 values\n        /(abs(c)+.5);//diminish over distance, and give \"below surface\" an extra glow.\n return sqrt(c);\n}//increase gamma \n\n//a modulo tiled grid.\nfloat grid(vec2 u){u=abs(fract(u)-.5);\n u.x=max(max(u.x,u.y),1./8.);u.x=u.x*8.-3.;\n u.x=fract(u.x)/(4.-(floor(u.x+3.)));\n                   \n u.x*=u.x;return u.x*u.x;}\n\n//with more symmetry, these boil down to\n//step(c,0)*a+b*step(0,c);\n//step(a,b) == (sign(a-b)*.5+.5);\n  /*\nfloat aa(float a,float b){\n //float b=1.;\n return abs(a-b);\n//above is identical to below\n if(a>b)a=a-b;\n else   a=b-a;\n return a;\n}\n*/\n\n//return distance to quater worm\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);   \n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n //if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n\n/*\n//obsoleted code.\nvec3 ccc2(vec2 u, vec2 m){\n vec3 c=vec3(0);\n vec2 r;    \n //r.x=1.-m.x;//length(m-vec2(1))*.5;//making the UI simpler for debugging\n r.x=m.x;//length(m)*.5;\n r.y=-m.x+2.;//making input static\n r*=.5;    \n r=clamp(r,0.,1.);\n vec4 i=vec4(vec2(0.,r.y),vec2(1.,1.-r.x));//2 circle center, set by their radii. \n i=vec2(1.-u.x,u.y).xyxy-i;\n float a=halfWorm(i.zw,-r.x+1.,-1.);\n float b=halfWorm(i.xy, r.x   , 1.);    \n c.g=mix(b,a,step(a,b));//if(b>a)c.g=a;else c.g=b;\n c-=m.y+2.5;\n c.b=grid(u);\n return c;}\n*/\n\n//return 2 circle centers, set by their radii.\nvec4 ccc(inout vec2 m){m=clamp(vec2(m.x,-m.x+2.),0.,2.)*.5;  \n return vec4(0.,m.y,1.-vec2(0,m.x));}\n//ccc2() is special case of ccc()\nvec4 ccc2(inout float m){m=clamp(m,0.,2.)*.5;  \n return vec4(0.,1.-m,1.-vec2(0,m));}\n\nfloat wormEuclid(vec2 u,vec2 m){\n vec4 i=ccc2(m.x); \n i=vec2(1.-u.x,u.y).xyxy-i;\n float a=halfWorm(i.zw,-m.x+1.,-1.);\n float b=halfWorm(i.xy, m.x   , 1.);\n return mix(b,a,step(a,b));}\n\n\n\nfloat wormY(vec2 u,vec2 m){\n vec4 i=ccc2(m.x);\n m.y=1.-m.x;\n i=vec2(1.-u.x,u.y).xyxy-i;\n float b=abs(u.x);\n m.x=(.5+sign(m.y-b)*(-.5+1.*m.y));//this is some disymmetry right here\n //I ended up using m.x for something different.\n //this turned out not too pritty, ugly discontinuity as result.\n u=(u+sign(m.y-b)*.5-.5)/m.x;\n return m.x*(sign(b-m.y)*(sqrt(1.-(u.x*u.x))-1.)-u.y);}\n\n\n//float pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\n//float pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\n//hg_sdf\n\nvec3 co(vec2 u){\n vec2 m=fr(iMouse.xy);u=fr(u);\n vec3 c; \n vec2 v=u; \n #ifdef endless\n float s=floor(v.x);\n s=mod(s,2.)*2.-1.;\n v.x=fract(v.x*s);\n #endif\n    \n c.r=wormEuclid(v,m)-m.y-2.5;\n c.g=wormY     (v,m);\n c.b=grid(u);\n \n c=SawCos3(c);//smoothest gradient visualization, this function may replace it?\n //no, i am tired of this one for now, not merging it with other stuff...\n  \n \n return c*.5+c.yzx*.2;}\n \nvoid  mainImage(out vec4 o, vec2 u){o=vec4(co(u),1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}