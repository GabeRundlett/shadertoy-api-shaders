{
    "Shader": {
        "info": {
            "date": "1525895331",
            "description": "very sparse convolution of a ~poisson disc distribution and a kernel ( cf profile() ).\n+ variants: n local points, fractalization, variation of blob size and intensity.\n\nsince sparse (contrarily to Gabor noise) the look is the shape of the kernel profile",
            "flags": 0,
            "hasliked": 0,
            "id": "Ms3BR2",
            "likes": 4,
            "name": "blue spotnoise, sparse convol",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "utils",
                "gabor",
                "sparseconvolution",
                "mz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 769
        },
        "renderpass": [
            {
                "code": "#define VARIANT 0      // 1: enlarge tested region around cell\nfloat ofs = 0.;        // jitter centers in -ofs ... 1.+ofs\n\nvec2  CYCLE = vec2(0); // pattern repeat scale ( in #cells )\n\nfloat CELL = 20.,      // number of cells along height\n      RATIO = 1.,      // cell length / cell width\n    RADIUS = 1.,       // dot size ( in CELL% ) . Equivalent to filtering dots\n  RADIUS_D = .0,       // size distribution \n     AMP_D = .0;       // dot intensity distribution around .5 (attention: same seed)\n\nint     NB = 1,        // NB dot per cell ( 1 = blue noise, more = stratified )\n     DEPTH = 1,        // fractal cascade of dots\n     SHAPE = 1,\n     BLEND = 0;        // combination: 0: add (continuum) 1: max (spots)\n\n\n// === dot shape\n\nfloat profile(float d) {  // for large footprints, use VARIANT=1\n   //d = clamp(d,0.,1.);\n    switch(SHAPE) {\n        case 0: return smoothstep(1.,0.,d);            // continuous bounded blob (smoothstep,=spline)\n        case 1: return exp(-.5*d*d*6.);                // gaussian ( bof )\n        case 2: d*=1.5; return sqrt(max(0.,1.-d*d));    // hemisphere\n        case 3: d = max(0.,1.-d); return 1. - sqrt(1.-d*d );// antisphere (peak)\n    }\n}\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x ) \n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) + 1e-30; // <- eps to fix a windows/angle bug\n}\n#define hash3i(x) hash3(uvec3(ivec3(floor(x)))) // because of uint(-float) bug\n\n\n// === Voronoi =====================================================\n// --- Base Voronoi. inspired by https://www.shadertoy.com/view/MslGD8\n\n#define hash22(p)  fract( 18.5453 * sin( p * mat2(127.1,311.7,269.5,183.3)) )\n#define disp(p) ( -ofs + (1.+2.*ofs) * hash22(p) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.y;\n    demo( floor(U.x-iTime-.2*sin(4.*U.y-3.*iTime)) +4.); // demo mode\n    U *= CELL/vec2(RATIO,1);\n    //U.x += iTime;                                   // for demo\n    vec2 U0 = U; \n    O-=O;\n\tfloat s = 1., t=0., height;\n    \n    for (int i=0; i<DEPTH; i++) {\n        vec2 u = U, iu = floor(u);\n        height = 0.;\n        #if VARIANT\n        for( int k=0; k < 25; k++ ) {                 // loop on neighbord cells\n            vec2 p = iu + vec2(k%5-2,k/5-2);          // searching for rock\n        #else\n        for( int k=0; k < 9; k++ ) {\n            vec2 p = iu + vec2(k%3-1,k/3-1);\n        #endif\n            for( int n=0; n<NB; n++) {\n                vec3 H = hash3i(vec3(CYCLE==vec2(0)?p:mod(p,CYCLE),n));\n                vec2 //o = disp(p),\n                       o = ( -ofs + (1.+2.*ofs) * H.xy ),\n                       r = p - u + o;\n                float d = length(r)/(RADIUS+RADIUS_D*(2.*H.z-1.)), // draw blob\n                      a = .5 + AMP_D*(2.*H.z-1.),\n                      h = a *  profile(d);\n                if (BLEND == 0)  height += h ;\n                else             height = max(height, h);\n            }\n        }\n        O += s * height;\n        U *= 2.;  t += s; s /= 2.;\n    }\n    O /= t;\n    if (BLEND==1) O*=2.;\n        \n    O *= vec4(1,.8,.6,1);                            // for demo\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// autodemo touches most parameters\n\n#define demo(t) {                                    \\\n    vec3 h1 = hash3i(t*vec3( 1  , 7.2,-3.1)),        \\\n         h2 = hash3i(t*vec3( 7.2,-3.1, 9.7));        \\\n      NB = 1+int(2.*h1.x);                           \\\n   DEPTH = 1+int(2.*h1.y);                           \\\n   SHAPE = int(4.*h1.z);                             \\\n   if (h2.x>.66) RADIUS_D = .3; else if (h2.x>.33) AMP_D = .3; \\\n   BLEND = int(2.*h2.y);                             \\\n   if (h2.z>.7) CELL=60.,RATIO=30.;                  \\\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}