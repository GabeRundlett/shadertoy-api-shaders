{
    "Shader": {
        "info": {
            "date": "1552228425",
            "description": "...",
            "flags": 0,
            "hasliked": 0,
            "id": "WslSzX",
            "likes": 2,
            "name": "Ray_trace_319group",
            "published": 3,
            "tags": [
                "raytrace"
            ],
            "usePreview": 0,
            "username": "Krause",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 512;\nconst float MIN_DIST = 0.0001;\nconst float MAX_DIST = 512.;\nconst float EPSILON = 0.0001;\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Hit {\n    vec3 normal;\n    vec3 pos;\n    float t;\n    bool exist;\n};\n    \nstruct material{\n\tvec3 k_a;\n    vec3 k_d;\n    float alpha;\n    vec3 k_s;\n};\n    \nstruct Options{\n    vec4 sphere; \n    vec3 sph_color;\n    vec4 plane; \n    vec3 pl_color;\n    vec2 torus;\n    vec3 torus_center;\n    vec3 tor_color;\n    vec2 hex;\n    vec3 hex_center;\n    vec3 hex_color;\n    vec3 box;\n    vec3 box_center;\n    vec3 box_color;\n    material material1;\n    material material2;\n    material material3;\n};\n    \n \nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec3 c, vec2 t )\n{\n  vec2 q = vec2(length8((p-c).xz)-t.x,(p-c).y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus( vec3 p, vec3 c, vec2 t )\n{\n  vec2 q = vec2(length((p-c).xz)-t.x,(p-c).y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere(vec3 p, vec3 c, float s) \n{\n  \treturn length(p-c)-s;\n}\n\nfloat udRoundBox(vec3 p, vec3 c, vec3 b, float r)\n{\n  return length(max(abs(p-c)-b,0.0))-r;\n}\n\nfloat sdHexPrism( vec3 p, vec3 c, vec2 h )\n{\n    vec3 q = abs(p-c);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat minimal(float f1, float f2, float f3, float f4, float f5) \n{\n    return min(min(f1,f4), min(min(f2,f3),f5)) ;\n}\n\nfloat scene(vec3 pos, Options data)\n{  \n    float dPlane = sdPlane(pos, data.plane);\n    float dSphere = sdSphere(pos, data.sphere.xyz, data.sphere.w);\n    float dTorus = sdTorus(pos, data.torus_center, data.torus);\n    float dHex = sdHexPrism(pos, data.hex_center, data.hex);\n    float dBox = udRoundBox(pos, data.box_center, data.box, 0.4);\n    \n    return minimal(dPlane, dSphere, dTorus, dBox, dHex);  \n}\n\nvec3 scene_normal( vec3 pos, float d, Options data)\n{\n    vec3 n;\n\t\n    n.x = scene( vec3( pos.x + EPSILON, pos.y, pos.z ), data ) - d;\n    n.y = scene( vec3( pos.x, pos.y + EPSILON, pos.z ), data ) - d;\n    n.z = scene( vec3( pos.x, pos.y, pos.z + EPSILON ), data ) - d;\n\t\n    return normalize(n);\n}\n\nHit ray_march(const Ray ray, Options data) \n{\n    Hit res;\n    \n    res.t = MIN_DIST;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(ray.pos + res.t*ray.dir, data);\n        if (dist < EPSILON) {\n\t\t\tbreak;\n        }\n        res.t += dist;\n        if (res.t > MAX_DIST) {\n            res.exist = false;\n            return res;\n        }\n    }\n    \n    res.pos = ray.pos + res.t*ray.dir;\n    res.normal = scene_normal(res.pos, scene(res.pos,data), data);\n    res.exist = true;\n    \n    return res;  \n}\n\nbool Visible(vec3 pos, vec4 light, Options data) \n{\n    Ray ray;\n    ray.pos = light.xyz;\n    ray.dir = normalize(pos - light.xyz);\n    \n    Hit hit = ray_march(ray, data);\n    \n    if( length(pos-light.xyz) > hit.t+0.1 )\n        return true;\n    else\n        return false;\n    \n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxlen, Options data)\n{\n    for( float t=MIN_DIST; t < maxlen ;)\n    {\n        float h = scene(ro + rd*t, data);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvec3 shade(vec3 pos, vec3 nrm, vec4 light, Options data)\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat res = 0.1;\n\tfloat vis = shadow( pos, toLight, toLightLen, data );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tres += diff * attn * vis;\n\t}\n\t\n\treturn vec3( res, res, res );\n    \n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 intensity, Options data) \n{\n    vec3 N = scene_normal(p, scene(p,data), data);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float LN = dot(L, N);\n    float RV = dot(R, V);\n    \n    if (LN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (RV < 0.0) {\n        return intensity * (k_d * LN);\n    }\n    return intensity * (k_d * LN + k_s * pow(RV, alpha));\n}\n\nvec3 phong(vec4 lights[2], material m, vec3 p, vec3 eye, Options data) \n{\n    vec3 color = vec3(0);\n    vec3 intensity = vec3(0.8, 0.8, 0.8);\n    \n    for(int i=0; i<2; i++)\n    \tcolor += phongContribForLight(m.k_d, m.k_s, m.alpha, p, eye,\n                                  lights[i].xyz,\n                                  intensity, data);\n      \n    return color;\n}\n\nvec3 RayTrace(const Ray ray, vec4 lights[2], Options data)\n{\n    \n\tvec3 color = vec3(0,0,0);\n\tHit hit = ray_march(ray, data); \n    \n\tif (!hit.exist)\n\t\treturn color;\n    \n    if (sdSphere(hit.pos, data.sphere.xyz, data.sphere.w)<(EPSILON)) {\n        color = data.sph_color;\n        color += phong(lights, data.material1, hit.pos, ray.pos, data);\n    } else if (sdPlane(hit.pos, data.plane)<EPSILON) {\n        color += phong(lights, data.material2, hit.pos, ray.pos, data);\n    } else if (sdTorus(hit.pos, data.torus_center, data.torus)<EPSILON) {\n        color = data.tor_color;\n        color += phong(lights, data.material2, hit.pos, ray.pos, data);\n    } else if (udRoundBox(hit.pos, data.box_center, data.box, 0.4)<EPSILON) {\n        color = data.box_color;\n        color += phong(lights, data.material1, hit.pos, ray.pos, data);\n    } else if (sdHexPrism(hit.pos, data.hex_center, data.hex)<EPSILON) {\n        color = data.hex_color;\n        color += phong(lights, data.material3, hit.pos, ray.pos, data);\n    }\n    \n    vec3 help = normalize(vec3(1.0,0.9,0.7));\n    \n    for(int i=0;i<2;i++){\n    \tif(!Visible(hit.pos, lights[i],data))\n            color += clamp( dot( hit.normal, help ), 0.0, 1.0 )*shade(hit.pos,hit.normal,lights[i], data);\n    }\n   \n        \n\treturn color;\n}\n\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {   //??????\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Options data;\n    data.sphere = vec4(4,1.5+abs(2.*sin(iTime)),4,1.5);\n    data.sph_color = vec3(1.0,0.0,0.0);\n    \n    data.plane = vec4(0.0,1.0,0.0,0.9);\n    data.pl_color = vec3(0.0,1.0,0.0);\n    \n    data.torus = vec2(1.5+abs(sin(iTime)),0.5);\n    data.torus_center = vec3(4.+2.*sin(iTime),0,4.+4.*sin(iTime)) ;\n    data.tor_color = vec3(0.5,0.0,0.5);\n    \n    data.hex = vec2(1.5,1.5); \n    data.hex_center = vec3(-5.,7.2+2.*sin(iTime),-3.+4.*abs(cos(iTime))) ;\n    data.hex_color = vec3(0.1,0.0,0.2);\n    \n    data.box_center = vec3(-5.,1.3,-3);\n    data.box = vec3(2,2,2);\n    data.box_color = vec3(0.5);\n    \n    data.material1.k_a = vec3(0.2, 0.2, 0.2);\n    data.material1.k_d = vec3(0.7, 0.4, 0.3);\n    data.material1.k_s = vec3(1.0, 1.0, 1.0);\n    data.material1.alpha = 12.0;\n    \n    data.material2.k_a = vec3(0.0, 0.0, 0.0);\n    data.material2.k_d = vec3(0.2, 0.2, 0.2);\n    data.material2.k_s = vec3(1.0, 1.0, 1.0);\n    data.material2.alpha = 10.0;\n    \n    data.material3.k_a = vec3(0.1, 0.1, 0.1);\n    data.material3.k_d = vec3(0.1, 0.2, 0.5);\n    data.material3.k_s = vec3(1.0, 1.0, 1.0);\n    data.material3.alpha = 6.0;\n    \n    \n    vec4 lights[2];\n    lights[0] = vec4(4.*sin(iTime),5,5.*cos(iTime),5);\n    lights[1] = vec4(-2.,7,7,15);\n    \n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 4.0, 35.0);\n    \n    \n    Ray ray;\n    ray.pos = eye;\n    ray.dir = dir;\n    \n    fragColor = vec4(RayTrace(ray,lights,data),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}