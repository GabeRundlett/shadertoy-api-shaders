{
    "Shader": {
        "info": {
            "date": "1624472211",
            "description": "sdfsdg",
            "flags": 48,
            "hasliked": 0,
            "id": "sl2GR3",
            "likes": 7,
            "name": "basic pt direct light 32",
            "published": 3,
            "tags": [
                "sdfg"
            ],
            "usePreview": 1,
            "username": "MinimilisticBits",
            "viewed": 305
        },
        "renderpass": [
            {
                "code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv).xyzw;\n    vec3 col = c.xyz;\n    if(texture(iChannel1, vec2(0.99)).x > 0.5){\n        col/=(c.w+1.);\n    }\n    col = vec3(1.)-exp(-1.*col);\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.3,0.3)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.1);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define KEY_A 65.0\n#define KEY_W 87.0\n#define KEY_S 83.0\n#define KEY_D 68.0\n\n#define KEY_C 67.0\n\n\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc = c * pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\n//NOT MY CODE////////////////////\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel0, uv).r;\n\n        return key > 0.0;\n}\n////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).xyz;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //vec3 d = texture(iChannel1, vec2(40.,0.)/iResolution.xy).xyz;\n    //vec3 p = vec3(0.);\n    //vec3 d;\n    //d = normalize(vec3(uv.x, 1., uv.y));\n    vec3 d = vec3(0.,-1.,0.);\n    vec3 side = vec3(1.,0.,0.);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, -mouse.y*130.);\n    d.xy = rot(d.xy, mouse.x*180.);\n    side.xy = rot(side.xy, mouse.x*180.);\n    //vec3 prevcol = col;\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n    if(fragCoord.x < 0.05*iResolution.x && prev_state.x < 0.5){\n        if(isPressed(KEY_W)){\n            col-=d*0.1;\n        }\n        if(isPressed(KEY_S)){\n            col+=d*0.1;\n        }\n        if(isPressed(KEY_A)){\n            col-=side*0.1;\n        }\n        if(isPressed(KEY_D)){\n            col+=side*0.1;\n        }\n    }\n    \n    if(fragCoord.x > iResolution.x*0.5 && fragCoord.x < iResolution.x*0.6 && prev_state.x < 0.5){\n        col = vec3(-mouse.y*90., mouse.x*180., 0.);\n    }\n    \n    if(fragCoord.x > 0.95*iResolution.x){\n        if(isPressed(KEY_C)){\n            col = (col.x > 0.5)?vec3(0.):vec3(1.);\n        }\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\n    c = c * pi/180.;\n    float l = length(a);\n    a/=l;\n    float ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\n    ang += c;\n    return vec2(cos(ang),sin(ang))*l;\n}*/\n\n//As suggested by LilBensson: NOT MY CODE\nvec2 rot(vec2 a, float c){\n    c = -c * 3.14159/180.;\n    float co = cos(c);\n    float si = sin(c);\n    return a * mat2x2(co, si, -si, co);\n}\n////////////////////\n\nfloat box(vec3 p, vec3 s){\n    vec3 a = abs(p)-s;\n    return max(max(a.x,a.y),a.z);\n}\nfloat escape;\n\n\nvec3 pal(float t, vec3 a, vec3 b){\nreturn 0.5+0.5*cos(2.*3.14159*t*a + b);\n}\n\n/////////////////////////////////\n\nvec3 fold(vec3 p0){\nvec3 p = p0;\n//if(abs(p.x) > 1.)p.x = 1.0-p.x;\n//if(abs(p.y) > 1.)p.y = 1.0-p.y;\n//if(abs(p.z) > 1.)p.z = 1.0-p.z;\nif(length(p) > 1.)return p;\np = mod(p,2.)-1.;\n\nreturn p;\n}\n\n\n//NOT MY CODE///////////////\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n///////////////////////////\n\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float fixed_radius2 = 10.9;\n  float min_radius2 = 1.1;\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp; dz *= temp;\n  }else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp; dz *= temp;\n  }\n}\nvoid box_fold(inout vec3 z, inout float dz) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nvoid box_fold(inout vec3 z) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nfloat escape2;\n\nfloat jb(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape2 = 0.;\n    for(int i=0;i++<12;){\n        p=vec3(2,4,2)-abs(p-vec3(4,4,2)),\n            s*=e=8./min(dot(p,p),9.),\n            p=abs(p)*e;\n            escape2 += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\nfloat fractal_de46(vec3 p){\n    float s = 2.;\n    float e = 0.;\n    escape = 0.;\n    for(int j=0;++j<7;){\n        p.xz=abs(p.xz)-2.3,\n        p.z>p.x?p=p.zyx:p,\n        p.z=1.5-abs(p.z-1.3+sin(p.z)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.x=3.-abs(p.x-5.+sin(p.x*3.)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.y=.9-abs(p.y-.4),\n        e=12.*clamp(.3/min(dot(p,p),1.),.0,1.)+\n        2.*clamp(.1/min(dot(p,p),1.),.0,1.),\n        p=e*p-vec3(7,1,1),\n        s*=e;\n        escape+=exp(-0.2*dot(p,p));\n        }\n    return length(p)/s;\n}\nfloat fractal_de51(vec3 p){\n    for(int j=0;++j<8;)\n        p.z-=.3,\n        p.xz=abs(p.xz),\n        p.xz=(p.z>p.x)?p.zx:p.xz,\n        p.xy=(p.y>p.x)?p.yx:p.xy,\n        p.z=1.-abs(p.z-1.),\n        p=p*3.-vec3(10,4,2);\n\n    return length(p)/6e3-.001;\n}\n\nfloat fractal_de15(vec3 p){\n    p=abs(p)-1.2;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n    if(p.x<p.y)p.xy=p.yx;\nescape2 = 0.;\n    float s=1.;\n    for(int i=0;i<6;i++)\n    {\n      p=abs(p);\n      float r=2./clamp(dot(p,p),.1,1.);\n      s*=r;\n      p*=r;\n      p-=vec3(.6,.6,3.5);\n              escape2+=exp(-0.2*dot(p,p));\n\n    }\n    float a=1.5;\n    p-=clamp(p,-a,a);\n    return length(p)/s;\n}\n\nfloat rota = 96.;\nfloat rotb = 180.;\nvec3 lig = normalize(vec3(0.6,-0.9,0.9));\n\n\n\nfloat dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob){\n    /*c = vec3(0.3,0.7,0.8);\n    a2 = 0.1;\n    prob = 0.9;\n    l = 0.;\n    \n        vec3 pos = vec3(1.1,-0.3,1.4)-p;\n                float aa22 = jb((pos)/1.)*1.;\n                \n    float plane = p.z - 1.;\n    \n    float final = max(aa22, box(p, vec3(5.)));\n\n    vec3 color = vec3(0.5,0.5,0.8);\n  \n       if(final == aa22){a2 = 0.1;prob=0.9;c=pal(escape, vec3(0.9), vec3(0.9,0.6,0.2));\n       l=escape*0.006;}\n     */\n     \n     c = vec3(0.9,0.8,0.6);\n    a2 = 10.;\n    prob = 0.;\n    l = 0.;\n    //float a = box(vec3(0.,4.,-5.)-p, vec3(10.,10.,0.2));\n    //float b = box(vec3(0.,4.,5.)-p, vec3(10.,10.,0.2));\n    //float c1 = box(vec3(7.,4.,0.)-p, vec3(0.2,10.,10.));\n    //float c2 = box(vec3(-7.,4.,0.)-p, vec3(0.2,10.,10.));\n    //float c3 = box(vec3(0.,9.,0.)-p, vec3(10.,0.2,10.));\n    float b2 = box(vec3(-5.,-59.5,15.)-p, vec3(22.,0.00000000000004,22.));\n    float aa2 = fractal_de51((vec3(-20.0,28.0,13.0)-p)/10.)*10.;\n    vec3 pos = (vec3(-15.0,-2.7,-3.0)-p);\n    pos.yz = rot(pos.yz, 90.);\n    float aa3 = max(jb(pos/10.)*10., box(p, vec3(25.)));\n    float aa = fractal_de46((vec3(-5.0,25.0,13.0)-p)/10.)*10.;\n\n    //float final = min(min(min(min(min(min(b2, a),b),c1),c2),c3),aa);\n    float final = min(min(aa,aa2),aa3);\n    if(final == b2)l = 3.;\n    //if(final == c1)c = vec3(0.9,0.1,0.1);\n    //if(final == c2)c = vec3(0.1,0.9,0.1);\n    if(final == aa||final == aa2){a2 = 0.4;prob=0.1;c=pal(escape*2., vec3(0.9,0.9,0.9),vec3(0.9,0.6,0.4));}\n    if(final == aa3){l=escape2*0.006;a2 = 0.1;prob=0.8;c=pal(escape2, vec3(0.9,0.9,0.9),vec3(0.4,0.6,0.9));}\n\n    //return final;\n     \n    return final;\n}\n\nvec3 anglephong(float a,vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float t = pow(r2, 2./(1.+a));\n    float x = cos(2.*3.14159*r1)*sqrt(1.-t);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-t);\n    float z = sqrt(t);\n//same explanation as above:\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat denn = 0.01;\nbool trac(inout vec3 p, vec3 d, inout float dd, inout float l,\ninout vec3 c, inout float a, inout float prob, inout uint r, inout float k){\n    for(int i = 0; i < 380; i++){\n        dd = dis(p,l,c,a,prob);\n        if(dd<0.01)return true;\n        if(rndf(r) < denn){\n           d = anglephong(1000., d, r);\n        }\n        k+=exp(-dd*20.);\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    vec3 c;\n    float l,a,prob;\n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.01, p.yz),l,c,a,prob) - dis(vec3(p.x-0.01, p.yz),l,c,a,prob),\n            dis(vec3(p.x, p.y+0.01, p.z),l,c,a,prob) - dis(vec3(p.x, p.y-0.01, p.z),l,c,a,prob),\n            dis(vec3(p.x, p.y,p.z+0.01),l,c,a,prob) - dis(vec3(p.x, p.y,p.z-0.01),l,c,a,prob)\n        )\n    );\n}\n\nfloat noise(vec3 uv){\n//uv += 1000.;\n//numbers so large that looks like random noise\n    return fract(sin(uv.x*23. + uv.y*345. + uv.z *200.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\n\n\nvec3 angledircos(vec3 n, inout uint r){\n//2 random numbers between 0 and 1\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nvec3 angledircos2(vec3 n, inout uint r){\n//2 random numbers between 0 and 1\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float theta = acos(sqrt(r2));\n    float phi = 2.*3.14159*r1;\n    float x = cos(phi)*sin(theta);\n    float y = sin(phi)*sin(theta);\n    float z = cos(theta);\n    \n    //float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    //float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    //float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));  \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat powerh(float a, float pdf1, float b, float pdf2){\n    pdf1*=a;\n    pdf2*=b;\n    return (pdf1*pdf1)/(pdf1*pdf1 + pdf2*pdf2);\n\n}\n\nfloat remap(float v, float l0, float h0, float ln, float hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nvec3 remap(vec3 v, vec3 l0, vec3 h0, vec3 ln, vec3 hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nfloat random3d(vec3 p){\nreturn fract(sin(p.x*214. + p.y*241. + p.z*123.)*100. + cos(p.x*42. + p.y*41.2+p.z*32.)*10.);\n}\n\nfloat worley3d(vec3 p){\nvec3 f = floor(p);\n\nfloat ll = 999.;\nfor(int i = 0; i < 27; i++){\nvec3 coords = vec3(float(i%3)-1., mod(float(i/3)-1., 3.), float(i/9)-1.);\nvec3 col = f+coords;\nvec3 curr = vec3(random3d(col), random3d(col+2.), random3d(col+4.))-0.5;\nfloat len = length((col+curr)-p);\nll = min(ll, len);\n}\nreturn ll;\n\n}\nfloat hash(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise222( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbmss(vec3 p)\n{\n    float scale = 0.1;\n    float threshold = 0.3;\n    float sum = 0.;\n        p += vec3(5., 0., 0.);\n        for(int i = 1; i <= 8; i++)\n        {\n            sum += noise222(p * scale * pow(2., float(i))) / pow(1.7, float(i));\n        }\n        return max(sum - threshold, 0.);\n}\nfloat fbm(vec3 p, vec3 cam){\n//p.yz = rot(p.yz, iTime*0.3);\n//float a = texture(iChannel0, p).x*0.5 +texture(iChannel0, p*2.).y*0.25+\n//texture(iChannel0, p*4.).z*0.125+texture(iChannel0, p*8.).x*0.0625;\n//float a = texture(iChannel0, p).x*0.9;\n\nfloat b = fbmss(p*232.);\n\nfloat Srb = clamp(remap((cam.z-6500.)/2000., 0., 0.07, 0., 1.),0.,1.);\n//a *= clamp(abs(length(p)-6500.)*0.00013, 0.0, 1.);\n//a -= clamp((p.z)*0.4,0., 1.);\n//a = max(a,0.);\n//vec3 pos = vec3(0.,0.,6500.)-p;\n//pos.xz = rot(pos.xz, iTime*200.);\n//float cap = box(pos, vec3(100.,500.,100.));\n//cap = capsule(pos, vec3(0.,-2000., 6500.), vec3(0.,2000.,6500.), 100.);\n//cap = abs(cap)+0.01;\n//float density = exp(-cap*0.00002);\nreturn clamp(((Srb)*b*clamp((cam.z-6500.)*0.44,0.,1.)),0.,1.);\n}\n\n\n//float PM(float cost, float g){\n//float a = 3./(8.*3.14159);\n//float b = ((1.0-g*g)*(1.0+cost*cost))/((2.0+g*g)*pow(1.0+g*g-2.*g*cost, 3./2.));\n//return a*b;\n//}\n//my own code as well, just can't find the math\nvec3 boreyleigh(float costheta, vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat a = 1.0+costheta*costheta;\nfloat v = 3.14159*3.14159*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave*0.000000000002))*a;\n}\n\nvec3 boreyleighconstant(vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat v = 8.*pow(3.14159, 3.)*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave));\n}\n\nvec3 bommie(float costheta, vec3 wave){\nfloat T = 3.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn 0.434*C*((4.*3.14159*3.14159)/(wave*wave))*0.5*Bm;\n}\nvec3 bommieconstant(vec3 wave){\nfloat T = 3.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn Bm;\n}\n\nfloat PM(float cost, float g){\nfloat a = 3./(8.*3.14159);\nfloat b = (1.0-g*g)*(1.0+cost*cost);\nfloat c = (2.0+g*g)*pow(1.0+g*g-2.*g*cost, 3./2.);\nreturn a*(b/c);\n}\n\nfloat PR(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\nvec3 reyleighapprox(vec3 wave, float cost, float h){\nfloat n = 1.00029;\nfloat d = 1432.1;\nfloat a = (1.0+cost*cost)/(2.0*h*h);\nvec3 b = pow(2.*3.14159/wave,vec3(4.));\nfloat c = pow((n*n-1.0)/(n*n+2.),2.);\nfloat d2 = pow(d/2.,6.);\nreturn a*b*c*d2;\n}\n\nvec4 clouds2(vec3 p, vec3 d, vec3 lig){\nvec3 waves = vec3(0.00000519673, 0.0000121427, 0.0000296453);\n\nfloat transmission = 1.0;\nvec3 Ex = vec3(1.0);\n\nfloat phase = PM(max(dot(d,lig),0.), 0.76);\n\nvec3 wavelengths = vec3(680., 550., 440.);\n\nvec2 t = vec2(0.);\nvec3 energy = vec3(1.);//0000296453\nvec3 rayleighcoefficients = vec3(0.00000519673, 0.0000121427, 0.0000296453);\nvec3 T = vec3(0.);\nfloat reyleighH = 8500.;\nfloat MieH = 1200.;\n\nvec3 accumulateLight = vec3(0.);\nvec3 accumulateLightMie = vec3(0.);\nvec3 accumother = vec3(0.);\n//if(intersect(p, vec3(0.,0.,0.), 8500.0, d, t)){\n//col = vec3(t.x);\nvec3 ccc = p;\nvec3 cam = p;\nvec3 fin = p+d*t.y;\nvec3 div = vec3(fin-cam) / 40.;\nvec3 precomputed = ((vec3(5.8,13.5,33.1)))*exp(-6.);\nvec3 precomputed2 = vec3(0.210)*exp(-5.);\nfloat mm = length(cam-fin);\nvec3 energyLoss = exp(-rayleighcoefficients*mm);\nfloat Is = 3.;\nvec3 Ip = vec3(0.);\nvec3 accum = vec3(0.);\nfloat accum11 = 0.;\nfloat minus = 0.32;\nfloat mult = 0.00002;\n\nfloat zz = max(dot(vec3(0.,0.,1.),lig),0.);\n/////////////\nvec3 br = boreyleighconstant(wavelengths.zyx*0.0005);\nvec3 bm = bommieconstant(wavelengths*0.024);\n\n////////////\nfloat pm = PM(max(dot(vec3(0.,0.,1.),lig),0.), 0.76)*5.;\nfloat pr = PR(max(dot(vec3(0.,0.,1.),lig),0.))*2.;\nfloat pm2 = PM(max(dot(d,lig),0.), 0.76)*7.;\nfloat pr2 = PR(max(dot(d,lig),0.))*4.;\nfloat keepdensity = 0.;\n\nfor(int i = 0; i < 180; i++){\n//accum += ph(length(cam), reyleighH)*length(div);\nfloat density = max(fbm(cam*mult, cam)-minus-abs(cam.z-6500.)*0.00044, 0. );\n//max(fbm(cam*mult, cam)-minus-abs(cam.z-8400.)*0.00194, 0. );\ndensity = smoothstep(0.,1.,density);\ndensity = clamp(density, 0., 1.);\nkeepdensity += density;\nif(density > 0.01 && length(cam-ccc)>200.){\naccum += density*2.1;\n//accum11 += ph(length(cam)-6500., MieH)*length(div);\n\nvec3 accum2 = vec3(0.);\n//float accum3 = 0.;\n//energy = energy*(1.0-rayleighcoefficients);\n        vec3 cam2 = cam;\n        \n        for(int k = 0; k < 10; k++){\n            float density2 = max(fbm(cam2*mult, cam2)-minus-abs(cam2.z-6500.)*0.00044,0.);\n            //+ max(fbm(cam2*mult, cam2)-minus-abs(cam2.z-8400.)*0.00194,0.) ;\n            density2 = smoothstep(0.,1.,density2);\ndensity2 = clamp(density2, 0., 1.);\n\n            //accum2 += ph(length(cam2), reyleighH)*length(div2);\n            accum2 += density2*7.1;\n            //accum3 += ph(length(cam2)-6500., MieH)*length(div2);\n            cam2 += lig*30.1;\n\n        }\n\n\n//accumulateLightMie += exp(-br*accum2)\n//*length(div)*transmission*density*length(div);\n\nEx = Ex*exp(-accum*2.3);\ntransmission*= 1.0-density;\ntransmission *= 0.99;\n//accumulateLightMie += exp(-br*accum2)*90.*\n//transmission*density;\n//accumulateLight += density*Ex*(\n//(1.0-exp(-accum2*bm*10.1))*exp(-accum2*bm*10.1)*pr2\n//+(1.0-exp(-accum2*bm*125.))*pm2*exp(-accum2*bm*15.)\n//+ exp(-accum2*bm*10.1)*mix(vec3(0.1,0.07,0.02)*333., vec3(1.), smoothstep(0.,1.,zz))*0.1\n//)\n //   ;\naccumulateLight += density*max(Ex,0.03)*((1.0-exp(-3.4*bm.zyx*accum2))*exp(-3.4*bm*accum2)*1.0\n+exp(-0.1*bm*accum2)*2.1 + \nexp(-.6*accum2*(1.0-zz*0.9)) +pm2*exp(-accum2*5.1)*mix(bm.zyx*3., vec3(1.), zz)\n\n)*1.0;//*mix(bm.zyx*2.,vec3(1.),zz);\n    \naccumulateLight += density*max(Ex,0.03)*(bm.zyx\n    *exp(-0.01*waves*accum2)*0.01 + br.zyx*exp(-0.01*bm.zyx*accum2)*92.)*.02*\n    reyleighapprox(wavelengths.zyx*5.9, max(dot(d,lig),0.), accum2.x)*5.0*0.5;\n\n}\n\ncam += d*(90.6-30.*noise(cam));\n//if(length(cam)>7500.){break;}\n}\n\nreturn vec4(accumulateLight*2.0, transmission);\n\n}\n\nvec3 F(vec3 A, vec3 B, vec3 C, vec3 D, vec3 E, float cost, float y){\nreturn (1.0+A*exp(B/cost))*(1.0+C*exp(D*y) + E*cos(y)*cos(y));\n}\n\nfloat intersect(vec3 p, vec3 d, vec4 sphere){\nvec3 cam = p;\nfor(int i = 0; i < 80; i++){\nfloat dist = -(length(sphere.xyz-p)-sphere.w);\nif(dist < 0.01){\nreturn length(p-cam);\n}\np += d*dist;\n}\nreturn 0.;\n}\nfloat RayleighPhase(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\nvec3 skyp2(vec3 p, vec3 d, vec3 lig){\n\nfloat l = intersect(p, d, vec4(0., 0.,0.,8500.));\nvec3 div = ((p+d*l)-p)/40.;\nvec3 wavelengths = vec3(680., 580., 440.);\nfloat accum = 0.;\nvec3 energy = vec3(0.);\nvec3 waves = vec3(0.00000519673, 0.0000121427, 0.0000296453);\n\nfor(int i = 0; i < 40; i++){\naccum += exp(-(length(p)-3500.)/8500.)*length(div);\n\nfloat accum2 = 0.;\nvec3 cam = p;\n\nfloat l2 = intersect(p, lig, vec4(0.,0.,0.,8500.));\nvec3 div2 = ((cam+lig*l2)-cam);\nfloat CP = length(div2);\n\ndiv2 /= 40.;\nif(length(p)-6500. > 0.05){\nif(l2 > 0. ){\n//accum2 += exp(-length());\n    for(int k = 0; k < 40; k++){\n        accum2 += exp(-(length(p)-3500.)/8500.)*length(div2);\n        \n        cam += div2;\n    }\n    \n    //energy += S(wavelengths, max(dot(d,lig),0.), length(p)-6500.);\n    \n    //energy += reyleighapprox(wavelengths*0.0000004, max(dot(d,lig),0.), length(p));\n}\n\nenergy += exp(-waves*89.*accum)\n    *exp(-waves*4.*accum2)*length(div)*\n    reyleighapprox(wavelengths*0.067, max(dot(d,lig),0.), length(p))\n    *RayleighPhase(max(dot(d,lig),-1.));\n}\np+=div;\n}\nvec3 final = energy*0.11+exp(-acos(max(dot(d,lig),0.))*50.);\nvec4 c = clouds2(vec3(0.,0.,5200.),d,lig);\nfinal = final*c.w + c.xyz;\nreturn final;\n}\n\nvec3 skyp3(vec3 d, vec3 lig){\nfloat cost = max(dot(lig, vec3(0.,0.,1.)),0.);\nfloat thetaS = acos(cost);\nfloat cosp = max(dot(d, vec3(0.,0.,1.)),0.);\nfloat thetaP = acos(cosp);\nfloat y = acos(max(dot(d,lig),0.));\nfloat ycos = cos(y);\n\nfloat T = 2.;\n\nfloat Yz = (4.0453*T-4.9710)*tan((4./9. - T/120.)*(3.14159-2.*thetaS))-0.2155*T+2.4192;\n\nfloat tt = thetaS*thetaS;\nfloat ttt =  thetaS*thetaS*thetaS;\nvec3 xA = vec3(0.00166*ttt-0.00375*tt+0.00209*thetaS,\n-0.02903*ttt + 0.06377*tt - 0.03202*thetaS + 0.00394,\n0.11693*ttt - 0.21196*tt + 0.06052*thetaS + 0.25886\n);\nfloat xz = xA.x*T*T + xA.y*T + xA.z;\n\nvec3 yA = vec3(0.00275*ttt-0.00610*tt+0.00317*thetaS,\n-0.04214*ttt + 0.08970*tt - 0.04153*thetaS + 0.00516,\n0.15346*ttt - 0.26756*tt + 0.06670*thetaS + 0.26688\n);\nfloat yz = yA.x*T*T + yA.y*T + yA.z;\n\nvec3 A = vec3(0.1787*T-1.4630, -0.0193*T-0.2592, -0.0167*T-0.2608);\nvec3 B = vec3(-0.3554*T+0.4275, -0.0665*T+0.0008, -0.0950*T+0.0092);\nvec3 C = vec3(-0.0227*T+5.3251, -0.0004*T+0.2125, -0.0079*T+0.2102);\nvec3 D = vec3(0.1206*T-2.5771, -0.0641*T-0.8989, -0.0441*T-1.6537);\nvec3 E = vec3(-0.0670*T+0.3703, -0.0033*T+0.0452, -0.0109*T+0.0529);\n\nvec3 Ff = F(A,B,C,D,E,cosp, y);\nvec3 Ff2 = F(A,B,C,D,E,cos(0.), thetaS);\n//return Ff2;\nfloat Y = (Yz*Ff.x)/Ff2.x;\nfloat x = (xz*Ff.y)/Ff2.y;\nfloat ys = (yz*Ff.z)/Ff2.z;\n\nvec3 XYZ = vec3((x*Y)/ys, Y, (((1.0-x-ys)*Y)/ys)).xyz;\nvec3 RGB = vec3(3.2404542*XYZ.x - 1.5371385*XYZ.y - 0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\nvec3 final = RGB.xyz*0.03;\nvec4 c = clouds2(vec3(0.,0.,5200.),d,lig);\nfinal = final*c.w + c.xyz;\nreturn final;\n}\n\nfloat beckmann_D2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,4.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.001);\n}\n\nfloat beckmann_pdf2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,3.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.0001);\n}\n\nvec3 beckmann_S(vec3 n, inout uint r, float a){\n        float r1 = rndf(r);\n        float r2 = rndf(r);\n    \n        float theta = atan(sqrt(-a*a*log(1.-r1)));\n        //float theta = acos(sqrt((1.-r1)/(r1*(a*a-1.)+1.) ));\n        float phi = 2.*3.14159*r2;\n        \n        float x = cos(phi)*sin(theta);\n        float y = sin(phi)*sin(theta);\n        float z = cos(theta); \n         \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nfloat beckmann_pdf(vec3 m, vec3 n, float a){\nfloat angle = acos(max(dot(m,n),0.));\nfloat a1 = 1./(3.14159*a*a*pow(max(dot(m,n),0.),3.)); // should be the pdf over a solid angle\nfloat b1 = exp(-((tan(angle)*tan(angle))/(a*a)));\nreturn max(a1*b1,0.0001);\n}\n\nfloat ggx_G(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat g1 = (2.*max(dot(n,h),0.)*max(dot(n,-wi),0.))/max(dot(-wi,h),0.);\nfloat g2 = (2.*max(dot(n,h),0.)*max(dot(n,l),0.))/max(dot(-wi,h),0.);\nfloat G = min(1.,min(g1,g2));\nreturn G;\n}\n\nfloat ggx_G2(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat top = 2.*max(dot(n,-wi),0.);\nfloat bottom = max(dot(n,-wi),0.)+sqrt(a*a + (1.-a*a)*pow(max(dot(n,-wi),0.),2.));\nreturn top/bottom;\n}\n\nvec3 ggx_F(vec3 Fo, float cost){\nreturn Fo + (1.-Fo)*pow(1.-cost,5.);\n}\n\nvec3 sampleSun(vec3 n, inout uint r, float theta){\n        float diff = 1.-cos(theta);\n        float z = cos(theta) + rndf(r)*diff;\n        float angle = rndf(r)*3.14159*2.;\n        float radius = sqrt(1. - z*z);\n        float x = cos(angle) * radius;\n        float y = sin(angle) * radius;\n        \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\nvec3 lerp(vec3 a, vec3 b, float t){\nreturn a + (b-a)*t;\n}\nfloat lerp(float a, float b, float t){\nreturn a + (b-a)*t;\n}\nvec3 renderpixel(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 p2 = p;\n    vec3 d2 = d;\n    float dd;\n    vec3 prevp = p;\n    vec3 tt = vec3(1.);\n    float l = 0.;\n    vec3 c = vec3(0.9);\n    float a = 0.;\n    float probability=0.;\n    const int bounces = 36;\n    float ll = 0.;\n    float k = 0.;\n    for(int i = 0; i < bounces; i++){\n        if(trac(p,d,dd,l,c,a,probability,r,k)){\n            vec3 n = norm(p-d*0.01,dd);\n            p+=n*0.03;\n            vec3 wi = d;\n            //float a = 100000.;\n//explained above\nfloat rough = a;\nrough = rough*rough;\n            d = angledircos(n,r);\n        if(i == 0)ll=length(p-prevp);\n            float number = rndf(r);\n            //float probability = 0.9;\n            if(number < probability){\n               d = beckmann_S(reflect(wi,n), r, rough);\n            }\n//\n            bool bo = (int(fragCoord.x)/64 + int(fragCoord.y)/64)%2==0;\n           //bo = true;\n          //bo = fragCoord.x < iResolution.x*0.5;\n            if(l>0.01){\n                col += tt*c;\n                break;\n            }\n            //vec3(0.,4.,4.)-p, vec3(1.,1.\n            //vec3(0.,-4.,0.)-p, vec3(8.,0.00000000000004,8.))\n            vec3 lpos = vec3(-5.,-59.5,15.);\n            float area = 44.*44.;\n            float r1 = rndf(r)*2.0-1.0;\n            float r2 = rndf(r)*2.0-1.0;\n\n            lpos.x += r1*22.;\n            lpos.z += r2*22.;\n            vec3 ldir = lpos-p;\n            float dist2 = length(lpos-p)*length(lpos-p);\n           \n           ////////////////////////////\n           float theta = 0.1;\n           vec3 lightdir = sampleSun(lig, r, theta);\n           /////////////////////////////\n\n\n            ldir = normalize(lightdir);\n            \n            vec3 brdf = c/3.14159 ;\n            //float rough = 1.;\n\n            //Oren-Nayar model\n           /* float A = 1.0-0.5*((rough*rough)/(rough*rough+0.33));\n            float B = 0.45*((rough*rough)/(rough*rough+0.09));\n            float thetai = acos(max(dot(d,n),0.));\n            float thetar = acos(max(dot(-wi, n),0.));\n            float aa = max(thetai,thetar);\n            float bb = min(thetai, thetar);\n            //float phii = acos(max(dot(vec3(-1.,0.,0.), ),0.));\n            */\n            //brdf = c/3.14159*(A+(B*max(0., dot(d,-wi))*sin(aa)*tan(bb)));\n            \n            float hemipdf = max(dot(d,n),0.)/3.14159;\n            hemipdf = max(hemipdf, 0.0000000000000001);\n        \n            vec3 brdf2 = c/3.14159 ;\n            float hemipdf2 = max(dot(d,n),0.)/3.14159;\n            hemipdf2 = max(hemipdf2, 0.0000000000000001);\n            vec3 h = normalize(d+ -wi);\n            vec3 h2 = normalize(ldir+-wi);\n             float D;\n           D=beckmann_D2(reflect(wi,n), d, rough);\n           \n               float G = ggx_G2(h,n,wi,d,rough);//cook torrance based geometry term\n           vec3 F = ggx_F(c, max(dot(-wi, n), 0.));//schlicks approx to the fresnel term\n           vec3 specular = (D*G*F)/max(4.*max(dot(-wi,n),0.)*max(dot(d,n),0.6),0.0001);\n        \n        \n        float D2; \n   D2 = beckmann_D2(reflect(ldir,n), wi, rough);\n  \n   float G2 =ggx_G2(h2,n,wi,ldir,rough);\n   vec3 F2 = ggx_F(c, dot(-wi, h2));\n   vec3 specular2 = (D2*G2*F2)/max(4.*dot(-wi,n)*dot(ldir,n),0.0001);\n   \n   \n   \n               \n        \n            //if(number < probability){\n                brdf = lerp(brdf,specular,probability);\n                hemipdf = lerp(hemipdf,beckmann_pdf2(reflect(wi,n),d,rough), probability);\n                hemipdf = max(0.000000001, hemipdf);\n\n                brdf2 = lerp(brdf2,specular2,probability);\n                hemipdf2 = lerp(hemipdf2,beckmann_pdf2(reflect(ldir,n),wi,rough),probability);\n                \n                hemipdf2 = max(hemipdf2,0.00000001);\n            //}\n            \n                                           brdf *=  (1.0+2.*probability*max(dot(d,n),0.));\n                                brdf2 *=  (1.0+2.*probability*max(dot(d,n),0.));\n\n            \n            vec3 L = vec3(0.9,0.7,0.5)*4.;\n            \n           vec3 curr = p;\n            float l2;\n            float a2,prob2;\n            float k2;\n            //vec3 lightdir = anglephong(100000., lig, r);\n            //theta - 0, pi/2\n            float height = cos(theta);\n            float ar = 2.*3.14159*(1.0-height);\n            if(!trac(curr, lightdir,dd,l2,c,a2,prob2,r,k2) && dot(ldir,n)>0.){\n                //if(i==0)tt *= brdf*(max(dot(d,n),0.00001)/hemipdf);\n                float brpdf = max(dot(ldir, n),0.)/3.14159;\n                brpdf = max(brpdf, 0.00000001);\n                //if(number < probability){\n                    brpdf = lerp(brpdf,hemipdf2,probability);\n                //}\n                float pdf = 1./ar;\n                float weight = powerh(1., pdf, 1., brpdf);\n                col += tt*brdf2*L*weight*dot(ldir,n);\n                //break;\n            }\n            \n           //MIS\n           float an = acos(dot(d,lig));\n           if((an) <= theta){\n               curr = p;\n               if(!trac(curr, d,dd,l2,c,a2,prob2,r,k2)){\n                   float heightbrdf = cos(an);\n                   float arbrdf = 2.*3.14159*(1.-heightbrdf);\n                   float pdf = 1./arbrdf;\n                   float weight = powerh(1.,hemipdf,1.,pdf);\n                   col += tt*brdf*weight*L*max(dot(d,n),0.)/hemipdf;\n                   break;\n               }\n           }\n            \n            /*if(bo){\n               if(i == 0 && l > 0.01){\n                   col+=tt*l;\n                   break;\n               }\n               if(l > 0.01){\n                   break;\n               }\n           \n               float l2;\n               vec3 lpp = p;\n               float a2,prob2;\n               if(trac(lpp,ldir,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(lpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n                   if(l2>0.01 && i < bounces-1 && dot(ln, -ldir) > 0.0 && dot(n, ldir) > 0.0){\n                  \n                       float pdf = dist2/(max(dot(ln, -ldir),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       float brpdf = max(dot(ldir, n),0.)/3.14159;\n                       brpdf = max(brpdf, 0.00000001);\n                       if(number < probability){\n                           brpdf = hemipdf2;\n                       }\n                       //power heuristics as explained above, on the high specular parts,\n                       //the weight will return a number closer to 0, so that the direct light sampling\n                       //wouldn't sample in an area where it's useless \n                       float weight = powerh(1., pdf, 1., brpdf);\n                       col += (tt*brdf2*l2*weight)*(max(dot(n, ldir),0.000001)/pdf);\n                   }\n               }\n           \n           //brdf sampling for mis \n               vec3 bpp = p;\n               if(trac(bpp,d,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(bpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n        \n                   if(l2>0.01 ){\n                   \n                       float dist3 = length(bpp-p)*length(bpp-p);\n                       float pdf = dist3/(max(dot(ln, -d),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       //float hemipdf = max(dot(d,n),0.)/3.14159;\n                       //hemipdf = max(hemipdf, 0.00000001);\n                       float weight = powerh(1., hemipdf, 1., pdf);\n                       col += (tt*brdf*weight*l2)*(max(dot(d,n),0.000001)/hemipdf);\n                   }\n               }\n            }*/        \n            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n            \n            if(i > 3){\n                float t_max = max(tt.x, max(tt.y, tt.z));\n                if(rndf(r) > t_max){\n                    break;\n                }\n                tt *= 1./t_max;\n            }\n\n           /*if(i == 0){\n             //   col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;\n                    }\n                }\n                col += accum*vec3(0.9,0.6,0.4)*0.6;\n            }else{\n                                //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n            }*/\n        }else{\n        float k2;\n        //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\nif(i==0)ll=length(p-prevp);\n/*           if(i == 0){\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                vec3 lightdir = anglephong(1000., lig, r);\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;;\n                    }\n                }\n                col += accum*vec3(0.9,0.6,0.4)*0.6;\n            }*/\n            if(i==0){\n                col += tt*skyp2(vec3(0.,0.,7000.),d, lig)*0.5;\n            }else{\n                col += tt*skyp2(vec3(0.,0.,7000.),d, lig)*0.9;\n            }\n            //col += tt*texture(iChannel1,d.xzy).xyz;\n            break;\n        }\n    }\n    \n    /*vec3 glow;\n    float l2,a2,prob2;\n    vec3 c2;\n    for(int i = 0; i < 40; i++){\n        float dist2 = abs(dis2(p2))+0.001;\n        p2 += d2*dist2;\n        if(dis(p2,l2,c2,a2,prob2) < 0.01)break;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*pal(escape, vec3(0.9,0.9,0.9),vec3(0.4,0.4,0.9));\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }*/\n    //col += glow*0.0*vec3(0.4,0.7,0.8)*texture(iChannel1, (p.xz-p.y)*0.9).x;\n    //col += 1./(1.+exp(-2.*(ll*0.2-2.)))*vec3(0.2,0.2,0.2)*0.5;\n    return col;\n}\nvec3 get_color(vec3 p, vec3 d, vec2 frag){\n    vec3 prevp = p;\n    vec3 p2 = p;\n    vec3 d2 = d;\n    vec3 prevp2 = p2;\n    bool hit_obj = false;\n    vec3 ligc = vec3(0.9,0.8,0.4);\n    vec3 col = vec3(0.);\n    float k = 0.;\n    vec3 glow = vec3(0.);\n    float l = 0.;\n    vec3 c = vec3(0.);\n    float a = 0.;\n    float prob = 0.;\n    bool ref = false;\n    for(int i = 0; i < 80; i++){\n    //dis(p,l,c,a,prob);\n    //float dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob){\n\n        float dist2 = abs(dis(p2,l,c,a,prob))+0.001;\n        p2 += d2*dist2;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*c;\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }\n    col = glow*12.;\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n\n    int tiles = 4;\n    int samples = 100;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(prev_state.x > 0.5){\n        if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n        if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n    }\n    int jk = iFrame%samples;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 diff = ((1.)/iResolution.xy);\n   // uv *= 0.5;\n    //uv.x += 0.1;\n    uv = uv * 2.0 - 1.0;\n    float r1 = rndf(r)*2.0-1.0;\n    float r2 = rndf(r)*2.0-1.0;\n    uv += diff*(vec2(r1,r2))*1.;\n\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n  \n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n   // d.xz = rot(d.xz, 30.);\n    \n    \n    vec3 p = texture(iChannel1, vec2(0.)).xyz;\n    \n    vec3 rotations = texture(iChannel1, vec2(0.55)).xyz;\n    //d.xz = rot(d.xz,90.);\n    //d.yz = rot(d.yz,rota);\n    float rota = 0.;\n    float rotb = 0.;\n    rota = rotations.x;\n    rotb = rotations.y;\n    d.yz = rot(d.yz,rota);\n    d.xy = rot(d.xy, rotb);\n    vec3 col = vec3(0.);\n    if(prev_state.x > 0.5){\n        \n        float focaldist = 2.3;\n        float radius = 0.001;\n\n        vec3 camdirection = vec3(0.,1.,0.);\n        camdirection.yz = rot(camdirection.yz, rota);\n        camdirection.xy = rot(camdirection.xy, rotb);\n        vec3 sidex = vec3(1.,0.,0.);\n        vec3 sidey = vec3(0.,0.,1.);\n       // sidex.yz = rot2(sidex.yz,rota);\n        //sidex.xz = rot(sidex.xz, -20.);\n       // sidex.yz = rot(sidex.yz,rota);\n        sidex.xy = rot(sidex.xy,rotb);\n    //    sidex.yz = rot(sidex.yz,rota);\n\n        //sidey.xz = rot(sidey.xz,-20.);\n        sidey.yz = rot(sidey.yz,rota);\n        sidey.xy = rot(sidey.xy,rotb);\n    \n        float ang = rndf(r)*2.0*3.14159;\n        float dist = min(length((vec2(0.0,-0.4)-uv)*0.2),1.);\n        float scale = sqrt(rndf(r))*radius;\n       //vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n       //vec2 aa = normalize(vec2(0.,1.));\n        vec2 offset = vec2(cos(ang), sin(ang))*scale;\n        //if(offset.x > offset.y)offset.xy=offset.yx;\n        //offset.x+=-1.;\n    \n       //offset*=radius;\n       //NOT MY CODE////////////////////////\n        vec3 focuspoint = p + ((d*focaldist) / dot(d,camdirection)); //these will lie on the focal plane\n        /////////////////////////////////////\n       // vec3 dd = vec3(uv.x,1.,uv.y);\n       // dd.yz = rot(dd.yz, rota);\n       // dd.xy = rot(dd.xy, rotb);\n       //vec3 focuspoint = p+(dd*focaldist);\n        //p.xz += offset;\n\n        p = p + sidex*offset.x;\n        p = p + sidey*offset.y;\n\n        d = normalize(focuspoint - p);\n    \n    \n        col = renderpixel(p,d, r, fragCoord);\n        col = clamp(col, 0., 1.);\n        //col = tonemap_uchimura2(col);\n        //col = pow(col, vec3(1.6))*1.8;\n        //col = pow(col, vec3(1./2.2));\n\n        if(jk != 0){\n            col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n        }\n    }else{\n        col = get_color(p,d,fragCoord.xy);\n    }\n    // Output to screen\n    fragColor = vec4(col,float(jk));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}