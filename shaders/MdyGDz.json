{
    "Shader": {
        "info": {
            "date": "1454168866",
            "description": "Pinball game, my high score is 130 whats yours?\nUse z/x or left/right arrow keys to control the flaps.",
            "flags": 112,
            "hasliked": 0,
            "id": "MdyGDz",
            "likes": 83,
            "name": "pinball game",
            "published": 3,
            "tags": [
                "game",
                "pinball"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 5189
        },
        "renderpass": [
            {
                "code": "//Ethan Shulman/public_int_i 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Text rendering is taken from mplancks Distance Field Typeface - https://www.shadertoy.com/view/XsBSDm\n\n\n//Image - 2D ui\n\n\n\n\n//Distance field font is taken from mplancks Distance Field Typeface - https://www.shadertoy.com/view/XsBSDm\n\nfloat g_cw = 15.; // char width in normalized units\nfloat g_ch = 30.; // char height in normalized units\n\nfloat g_cwb = .6; // character width buffer as a percentage of char width\nfloat g_chb = .5; // line buffer as a percentage of char height\n\n// vertical segment with the bottom of the segment being s\n// and having length d\nfloat vd( vec2 s, float d, vec2 uv )\n{    \n    float t = (d * (uv.y - s.y)) / (d*d);\n    t = clamp(t, 0., 1.);\n    return .1 * length((s + t * vec2(0., d)) - uv);\n}\n\n// horizontal segment with the left of the segment being s\n// and having length d\nfloat hd( vec2 s, float d, vec2 uv )\n{    \n    float t = (d * (uv.x - s.x)) / (d*d);\n    t = clamp(t, 0., 1.);\n    return .1 * length((s + t * vec2(d, 0.)) - uv);\n}\n\n// divide the experience into cells.\nvec2 mod_uv(vec2 uv)\n{\n    return vec2(mod(uv.x, g_cw * (1. + g_cwb)), \n                mod(uv.y, g_ch * (1. + g_chb)));\n}\n\n// ---------------------------------------------\n// ALPHABET\nfloat a(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch * .9, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .9, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw, uv));\n    return r;\n}\n\nfloat b(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(.0, g_ch), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .3, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .5, uv));\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    return r;\n}\n\nfloat c(vec2 uv)\n{    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .9, uv));\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .9, uv));\n    return r;\n}\n\nfloat d(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(0.), g_cw * .9, uv));\n    r = min(r, hd(vec2(.0, g_ch), g_cw * .9, uv));\n    return r;\n}\n\nfloat e(vec2 uv)\n{    \n    float r = hd(vec2(.0, g_ch), g_cw, uv);\n    r = min(r, vd(vec2(0.), g_ch, uv));\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\n\nfloat f(vec2 uv)\n{\n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(0.), g_ch, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\n\nfloat g(vec2 uv)\n{    \n    float r = hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv);\n    r = min(r, vd(vec2(0., g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, .1 * g_ch), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .5, g_ch * .6), g_cw * .4, uv));\n    return r;\n}\n\nfloat h(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    r = min(r, hd(vec2(.0, g_ch * .6), g_cw, uv));\n    return r;\n}\nfloat i(vec2 uv)\n{    \n    float r = hd(vec2(0.), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch, uv));\n    r = min(r, hd(vec2(0., g_ch), g_cw, uv));\n    return r;\n}\n\nfloat j(vec2 uv)\n{    \n    float r = vd(vec2(g_cw, g_ch * .1), g_ch * .9, uv);\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(0., g_ch * .1), g_ch * .2, uv));\n    return r;\n}\n\n\nfloat k(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, g_ch*.7), g_ch * .3, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .5, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\n\nfloat l(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    return r;\n}\n\nfloat m(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    r = min(r, hd(vec2(0., g_ch), g_cw * .3, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .6), .3 * g_ch, uv));\n    r = min(r, hd(vec2(g_cw * .7, g_ch), g_cw * .3, uv));\n    return r;\n}\n\nfloat n(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));    \n    r = min(r, vd(vec2(g_cw * .1, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .3, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .7, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .9, 0.), g_ch * .2, uv));\n    return r;\n}\n\nfloat o(vec2 uv)\n{    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    return r;\n}\n\nfloat p(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(0., g_ch), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .3, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\nfloat q(vec2 uv)\n{    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));    \n    r = min(r, vd(vec2(g_cw * .7, g_ch * -.05), g_cw * .4, uv));\n    return r;\n}\n\nfloat r(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(.0, g_ch), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .3, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .5, uv));\n    return r;\n}\nfloat s(vec2 uv)\n{    \n    float r = hd(vec2(0.), g_cw * .9, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch * .6), g_cw * .7, uv));\n    r = min(r, vd(vec2(0., g_ch * .7), g_ch * .2, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch), g_cw * .8, uv));\n    return r;\n}\n\nfloat t(vec2 uv)\n{    \n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch, uv));\n    return r;\n}\n\n\nfloat u(vec2 uv)\n{    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .9, uv);\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .9, uv));\n    return r;\n}\n\nfloat v(vec2 uv)\n{    \n    float r = vd(vec2(0., g_ch * .5), g_ch * .5, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .5), g_ch * .5, uv));\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .2), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .2), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch * .1, uv));\n    return r;\n}\n\nfloat w(vec2 uv)\n{    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .1), g_ch * .3, uv));\n    r = min(r, hd(vec2(0.), g_cw * .3, uv));\n    r = min(r, hd(vec2(g_cw * .7, 0.), g_cw * .3, uv));\n    return r;\n}\n\nfloat x(vec2 uv)\n{    \n    float r = vd(vec2(0., g_ch * .9), g_ch * .1, uv);\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .2, uv));    \n    r = min(r, vd(vec2(g_cw, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .3), g_ch * .1, uv));    \n    r = min(r, vd(vec2(0.), g_ch * .2, uv));\n    \n    return r;\n}\n\nfloat y(vec2 uv)\n{    \n    float r = vd(vec2(0., g_ch * .8), g_ch * .2, uv);\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .6), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .6), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .8), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch * .5, uv));\n    \n    return r;\n}\nfloat z(vec2 uv)\n{    \n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .9, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .7, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .3, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .1, g_ch * .1), g_ch * .1, uv));\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    return r;\n}\n\n// ---------------------------------------------\n// NUMBERS\n\nfloat n1(vec2 uv)\n{    \n    float r = hd(vec2(g_cw * .3, g_ch), g_cw * .2, uv);\n    r = min(r, vd(vec2(g_cw * .5, 0.) , g_ch, uv));\n    return r;\n}\n\n\nfloat n2(vec2 uv)\n{    \n    float r = hd(vec2(0., g_ch), .9 * g_cw, uv);\n    r = min(r, vd(vec2(g_cw, g_ch*.7), g_ch * .2, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch * .6), g_cw * .7, uv));\n    r = min(r, vd(vec2(0.), g_ch * .5, uv));\n    r = min(r, hd(vec2(0.), g_cw * .9, uv));\n    return r;\n}\nfloat n3(vec2 uv)\n{    \n    float r = hd(vec2(0., g_ch), .9 * g_cw, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch * .6), g_cw * .7, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .2, uv));\n    r = min(r, hd(vec2(0.), g_cw * .9, uv));\n    return r;\n}\nfloat n4(vec2 uv)\n{    \n    float r = vd(vec2(0., g_ch * .6), g_ch * .4, uv);\n    r = min(r, hd(vec2(.0, g_ch * .6), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    return r;\n}\n\nfloat n5(vec2 uv)\n{    \n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(0., g_ch*.6), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .1, g_ch * .6), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .4, uv));\n    r = min(r, hd(vec2(0.), g_cw * .9, uv));\n    return r;\n}\nfloat n6(vec2 uv)\n{    \n    float r = hd(vec2(g_cw * .1, g_ch), g_cw * .9, uv);\n    r = min(r, vd(vec2(0., g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch * .6), g_cw * .7, uv));\n    return r;\n}\nfloat n7(vec2 uv)\n{\n    \n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .9, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .7, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .3, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .1, 0.), g_ch * .2, uv));\n    return r;\n}\n\nfloat n8(vec2 uv)\n{    \n    float r = hd(vec2(g_cw * .1, 0.), g_cw * .8, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch * .6), g_cw * .7, uv));\n    r = min(r, vd(vec2(0., g_ch * .1), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .1, g_ch), .8 * g_cw, uv));\n    r = min(r, vd(vec2(0., g_ch * .7), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .2, uv));\n    return r;\n}\nfloat n9(vec2 uv)\n{    \n    float r = hd(vec2(g_cw * .1, 0.), g_cw * .8, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch * .6), g_cw * .6, uv));\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(0., g_ch * .7), g_ch * .2, uv));\n    return r;\n}\nfloat n0(vec2 uv)\n{    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n\n    r = min(r, vd(vec2(g_cw * .9, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .7, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .3, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .1, g_ch * .1), g_ch * .1, uv));\n    \n    return r;\n}\n\nfloat forwardSlash(vec2 uv)\n{    \n    float r = vd(vec2(g_cw * .9, g_ch * .9), g_ch * .1, uv);\n    r = min(r, vd(vec2(g_cw * .7, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .3, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .1, g_ch * .1), g_ch * .1, uv));\n    return r;\n}\n\n\nfloat renderInt(vec2 uv, int i) {\n    vec2 suv = uv;\n    \n    float d = 1.;\n    \n    int di = i;\n    for (int i = 0; i < 4; i++) {\n        int ci = int(fract(float(di)/10.)*10.);\n        if (ci == 0) {\n            d = min(n0(suv), d);\n        }\n        if (ci == 1) {\n            d = min(n1(suv), d);\n        }\n        if (ci == 2) {\n            d = min(n2(suv), d);\n        }\n        if (ci == 3) {\n            d = min(n3(suv), d);\n        }\n        if (ci == 4) {\n            d = min(n4(suv), d);\n        }\n        if (ci == 5) {\n            d = min(n5(suv), d);\n        }\n        if (ci == 6) {\n            d = min(n6(suv), d);\n        }\n        if (ci == 7) {\n            d = min(n7(suv), d);\n        }\n        if (ci == 8) {\n            d = min(n8(suv), d);\n        }\n        if (ci == 9) {\n            d = min(n9(suv), d);\n        }\n        \n        \n        suv.x += g_cw*1.3;\n        di /= 10;\n        if (di == 0) break;\n    }\n    return d;\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 res = vec4(iResolution.xy,1./iResolution.xy);\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    \n    vec4 scoring = texture(iChannel1, vec2(1.5,0.5)/iResolution.xy);\n\n    vec2 tuv = (uv-.5)*400.,\n        dtuv = tuv;\n    float txt = 1.;\n    \n    #define rc(f) txt = min(txt, f(tuv=tuv-vec2(g_cw*1.3,0.))-.1)\n    #define sc() tuv-=vec2(g_cw*1.3,0.)\n    #define nl() tuv+=vec2(0.,g_ch*1.3)\n    \n\n    if (scoring.y == .1) {\n\t\ttuv.x += 150.;\n        \n        rc(s);\n        rc(c);\n        rc(o);\n        rc(r);\n        rc(e);\n    }\n   \t    \n    if (scoring.y == 0.) {\n        tuv.x += 180.;\n            \n        rc(p);\n        rc(r);\n        rc(e);\n        rc(s);\n        rc(s);\n        sc();\n        rc(z);\n        rc(forwardSlash);\n        rc(x);\n        sc();\n        rc(t);\n        rc(o);\n        sc();\n        rc(p);\n        rc(l);\n        rc(a);\n        rc(y);\n        \n        tuv = dtuv;\n        tuv.x += 110.;\n        tuv.y -= 90.;\n        tuv *= .75;\n        \n        rc(p);\n        rc(i);\n        rc(n);\n        rc(b);\n        rc(a);\n        rc(l);\n        rc(l);\n    } else {\n        if (scoring.y == .2) {\n            tuv -= vec2(-100.,160.);\n        } else {\n            tuv.x -= 100.;\n        }\n        txt = min(txt, renderInt(tuv,int(scoring.x*4096.)));\n    }\n        \n    col = mix(col, mix(vec3(.1),vec3(.4,.8,1.),max(0.,1.-abs(txt)*6.)), max(0.,1.-abs(txt)*3.));\n    \n    fragColor = vec4(floor(pow(col, vec3(1.43,1.55,1.2))*6.)/6., 1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 1429,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/megadrivemusic/i-am-the-program"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Ethan Shulman/public_int_i 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//thanks to iq for the great tutorials, code and information\n\n\n//Buf A - Game logic\n\n\n//distance functions from iq's site\nfloat udBox( vec2 p, vec2 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\nfloat sdSphere( vec2 p, float r) {\n    return length(p)-r;\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nvec4 flap;\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nfloat pins(in vec2 rp) {\n    vec2 p = rp;\n    vec2 p2 = rp;\n    \n    p.x = abs(p.x+.12)-.25;\n    \n    p2.x -= .7;   \n    \n    return min(\n        sdSphere(p,.03),\n        sdSphere(p2,.03) );\n}\n\n\nfloat flaps(in vec2 rp) {\n    vec2 b1 = rp;\n    b1.x += .79;\n    \n    vec2 b2 = b1;\n    \n    b1.y -= .24;\n    b2.y += .24;\n    \n    b1.xy = rot(b1.xy,2.-flap.x);\n    b2.xy = rot(b2.xy,flap.y+1.);\n    \n    b1.y += .08;\n    b2.y -= .08;\n    \n    return min( udBox(b1, vec2(.013,.12)),\n                udBox(b2, vec2(.013,.12)) );\n}\n\n\nfloat map(in vec2 rp) {\n    \n    vec2 asr = rp;\n    asr.y = abs(asr.y);\n    asr.x -= -1.;\n    asr.xy = rot(asr.xy, 2.3);\n    \n    return min( min( min( udBox(abs(asr-vec2(.7,.75))-vec2(.15,.2),vec2(.07,.02)),\n                        length(asr-vec2(1.1,1.35))-.1),\n                    sdCapsule(asr,vec2(0.,.7),vec2(0.,.4),.05)),\n       \t\t\t\t-sdBox(rp-vec2(0.,0.),vec2(1.,.5)));\n}\n\nfloat df(vec2 p) {\n    return min(map(p),min(flaps(p),pins(p)));\n}\n\nvec2 normal(vec2 p) {\n    const vec2 NE = vec2(.0001,0.);\n\treturn normalize(vec2(df(p+NE)-df(p-NE),\n                            df(p+NE.yx)-df(p-NE.yx)) );\n}\nvec2 flapsNormal(vec2 p) {\n    const vec2 NE = vec2(.0001,0.);\n\treturn normalize(vec2(abs(flaps(p+NE))-abs(flaps(p-NE)),\n                          abs(flaps(p+NE.yx))-abs(flaps(p-NE.yx))) );\n}\n\nvec4 encodeBall(vec4 b) {\n    return b+1.;\n}\nvec4 decodeBall(vec4 b) {\n    return b-1.;\n}\n\nconst float epsilon = .0001;\nconst float ballRadius = .035;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ind = int(floor(fragCoord.x));\n    if (ind > 3) { discard;return; }\n    \n    if (iFrame < 10) {\n        //init\n        if (ind == 0) {\n            fragColor = encodeBall( vec4(-0.5,0.3,0.,0.) );\n        }\n        if (ind == 1) {\n            fragColor = vec4(0.);\n        }\n        if (ind == 2) {\n            fragColor = vec4(0.);\n        }\n        return;\n    }\n    \n    \n    if (ind == 2) {\n        //flaps\n        vec4 flaps = texture(iChannel0, vec2(2.5,.5)/iResolution.xy);\n        \n        flaps.z = max(clamp(texture(iChannel1, vec2(90.5, 0.5)/255.).x, 0., 1.),\n                      clamp(texture(iChannel1, vec2(37.5, 0.5)/255.).x, 0., 1.));\n        flaps.w = max(clamp(texture(iChannel1, vec2(88.5, 0.5)/255.).x, 0., 1.),\n                      clamp(texture(iChannel1, vec2(39.5, 0.5)/255.).x, 0., 1.));\n        flaps.xy = clamp(flaps.xy+(flaps.zw-.5)*2./5., 0., 1.);\n        \n        fragColor = flaps;\n        return;\n    }\n    \n    vec4 scoring = texture(iChannel0, vec2(1.5, 0.5)/iResolution.xy);\n    flap = texture(iChannel0, vec2(2.5, 0.5)/iResolution.xy);\n    \n    //ball\n    vec4 b = decodeBall( texture(iChannel0, vec2(.5)/iResolution.xy) );\n\t\n    b.z -= .02/60.;\n    b.zw = clamp(b.zw,-1.,1.);\n    \n    vec2 dir = normalize(b.zw);\n    float len = length(b.zw);\n    vec2 reflDir;\n    bool hit = false;\n    \n    float s = 0.;\n    for (int i = 0; i < 8; i++) {\n        vec2 p = b.xy+dir*s;\n        float dst = df(p);\n        if (dst < ballRadius) {\n            hit = true;\n            break;\n        }\n\n        s += dst;\n        if (s > len) break;\n    }\n    \n    s = min(s,len);\n    b.xy += dir*s;\n    \n    if (ind == 1) {\n        if (hit) {\n            if (pins(b.xy) < ballRadius+epsilon*10.) {\n                scoring.x += floor((b.x+1.)*3.)/4096.;\n            }\n        }\n        if (scoring.y < .2) {\n            if (iTime-scoring.z > 2. && max(flap.z,flap.w) > 0.) {\n                scoring.x = 0.;\n                scoring.y = .2;\n            }\n        }\n        if (b.x < -.9) {\n        \tscoring.y = .1;\n            scoring.z = iTime;\n        }\n        fragColor = scoring;\n        return;\n    }\n    \n    if (hit) {\n        vec2 hn = normal(b.xy);\n        if (flaps(b.xy) < ballRadius+epsilon*10. && ((b.y > 0. && flap.z > 0.) || (b.y < 0. && flap.w > 0.))) {\n            hn = flapsNormal(b.xy-vec2(-.2,0.));\n            b.zw += hn*.01;\n            b.xy += hn*(ballRadius-df(b.xy)+epsilon*10.);\n        } else {\n            b.zw = reflect(normalize(b.zw),hn)*length(b.zw)*.75;\n            b.xy += hn*(ballRadius-df(b.xy)+epsilon);\n        }\n    }\n\n    if (scoring.y < .2) {\n        b = vec4(-0.5,0.3,0.,0.);\n    }\n    b = clamp(b,-1.,1.);\n    fragColor = encodeBall(b);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Shulman/public_int_i 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//thanks to iq for the great tutorials, code and information\n//thanks to XT95 for the ambient occlusion function\n\n\n\n// Bub B - 3D rendering, raymarched\n\n\n\n#define FOV_SCALE 1.3\n#define ITERATIONS 60\n#define SHADOW_ITERATIONS 24\n#define REFLECTION_ITERATIONS 24\n\n#define EPSILON .0008\n#define NORMAL_EPSILON .004\n\n#define VIEW_DISTANCE 4.\n\n#define pi 3.141592\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float metallic,roughness;\n};\nstruct light {\n    vec3 position, color;\n    float size;\n};\n    \n    \n    \nconst float ballRadius = .035;\n    \nvec4 ball,flap;\n\nvec4 encodeBall(vec4 b) {\n    return b+1.;\n}\nvec4 decodeBall(vec4 b) {\n    return b-1.;\n}\n    \n\nconst vec3 ambient = vec3(.4);\n\n\n#define nLights 2\n\n#if nLights != 0\nlight lights[nLights];\n#endif    \n\nvoid initLights() {\n    #if nLights != 0\n    lights[0] = light(vec3(0.2,0.5,.5),\n                      vec3(1.,.7,.85),\n                      1.5);\n    \n    lights[1] = light(vec3(0.2,0.5,-.5),\n                      vec3(0.75,.95,.83),\n                      1.5);\n\t#endif\n}\n\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nfloat sdBall(in vec3 rp) {\n    return length(rp-vec3(ball.x,1.065,ball.y))-ballRadius;\n}\n\nfloat flaps(in vec3 rp) {\n    vec3 b1 = rp;\n    b1.y -= 1.05;\n    b1.x += .79;\n    \n    vec3 b2 = b1;\n    \n    b1.z -= .24;\n    b2.z += .24;\n    \n    b1.xz = rot(b1.xz,2.-flap.x);\n    b2.xz = rot(b2.xz,flap.y+1.);\n    \n    b1.z += .08;\n    b2.z -= .08;\n    \n    return min( udBox(b1, vec3(.013,.05,.12)),\n                udBox(b2, vec3(.013,.05,.12)) );\n}\n\nfloat pins(in vec3 rp) {\n    vec3 p = rp;\n    p.y -= 1.1;\n    vec3 p2 = p;\n    \n    p.x = abs(p.x+.12)-.25;\n    \n    p2.x -= .7;    \n    \n    return min(\n        sdCapsule(p,vec3(0.),vec3(0.,-.12,0.),.03),\n        sdCapsule(p2,vec3(0.),vec3(0.,-.12,0.),.03) );\n}\n\nfloat map(in vec3 rp) {\n    \n    vec3 asr = rp;\n    asr.z = abs(asr.z);\n    asr.x -= -1.;\n    asr.xz = rot(asr.xz, 2.3);\n    \n    return min( min(min(udBox(abs(asr-vec3(.7,1.05,.75))-vec3(.15,0.,.2),vec3(.07,.06,.02)),\n                        length(asr-vec3(1.1,1.1,1.35))-.1),\n                    sdCapsule(asr,vec3(0.,1.05,.7),vec3(0.,1.05,.4),.05)),\n        max(-sdBox(rp-vec3(0.,1.,0.),vec3(1.,.1,.5)), -rp.y+1. ));\n}\n\nfloat df(in vec3 rp) {\n    return min(pins(rp), min(sdBall(rp), min(flaps(rp), map(rp))));\n}\nfloat df_hq(in vec3 rp) {\n\treturn df(rp);//-texture(iChannel1,(abs(rp.xz)+abs(rp.yy)*.5)).x*.004*max(0.,cos(iTime+length(cos(rp*4.234)*14.234)));\n}\n\n\n\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal2(in vec3 rp) {\n    return normalize(vec3(df(rp+ne)-df(rp-ne),\n                          df(rp+ne.yxz)-df(rp-ne.yxz),\n                          df(rp+ne.yzx)-df(rp-ne.yzx)));\n}\n\n\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df_hq(rp+ne)-df_hq(rp-ne),\n                          df_hq(rp+ne.yxz)-df_hq(rp-ne.yxz),\n                          df_hq(rp+ne.yzx)-df_hq(rp-ne.yzx)));\n}\n\n\nmaterial mat(vec3 rp) {\n    \n    int closestId = -1;\n    float closestDst = 999999.;\n    \n    #define cd(f,i) if ((buf=f(rp))<closestDst){closestId=i;closestDst=buf;}\n    \n    float buf;\n    cd(pins,0);\n\tcd(flaps,1);\n    cd(sdBall,2);\n    cd(map,3);\n    \n    if (closestId == 0) {\n        return material(vec3(1.),\n                        vec3(1.),\n                        vec3(1.,rp.x+.5,rp.x+.5)*(.75+cos(rp.y*100.+iTime*10.)*.25),\n                        0.,\n                        1.);\n    }\n    if (closestId == 1) {\n        return material(vec3(.34), //diffuse\n                     vec3(.74,.54,.65), //specular\n                  \t vec3(0.), //emissive\n                     .74,//metallic\n                     .1);//roughness\n    }\n    if (closestId == 2) {\n\t\treturn material(vec3(.74), //diffuse\n                     vec3(.9), //specular\n                  \t vec3(0.), //emissive\n                     0.84,//metallic\n                     0.04);//roughness   \n    }\n    \n    float boxes = length(max(abs(mod(abs(rp.xz),.5)-.25)-.24, 0.));\n    if (boxes > 0.) {\n        vec3 c = vec3(length(max(abs(mod(abs(rot(rp.xz,.4)),.02)-.01)-.008, 0.))>0.? .2 : 0.);\n    \treturn material(c, vec3(.4)+c*.5, vec3(0.), 1., .03);\n    }\n    \n    float bid = (floor(rp.x/.5)+floor(rp.z/.5)*12.)+150.;\n    return material(vec3(cos(bid*.0383+.9824),cos(bid*.0283+1.639),cos(bid*.0729+.9824))*.5+.5, //diffuse\n                     vec3(1.-(cos(bid*.234)*.5+.5)*.5), //specular\n                  \t vec3(0.), //emissive\n                     cos(bid*.983+.9824)*.5+.5,//metallic\n                     cos(bid*.234)*.5+.5);//roughness\n\n}\n\n\n\n//rp = ray pos\n//rd = ray dir\n//maxDist = max trace distance\n//returns -1 if nothing is hit\nfloat trace(in vec3 rp, inout vec3 rd, float maxDist) {\n    \n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON || s > maxDist) break;\n        s += d;\n        \n        //rd = normalize(rd+vec3(.01,-.001,0.)*d);\n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\nfloat rTrace(in vec3 rp, inout vec3 rd, float maxDist) {\n    \n    float d,s = 0.;\n    for (int i = 0; i < REFLECTION_ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON || s > maxDist) break;\n        s += d;\n        \n        //rd = normalize(rd+vec3(.01,-.001,0.)*d);\n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\n\nvec3 randomHemiRay(in vec3 d, in vec3 p, in float amount) {\n    vec3 rand = normalize(cos(cos(p)*512.124+cos(p.yzx*16.234)*64.3249+cos(p.zxy*128.234)*64.4345));\n    return mix(d, rand*sign(dot(d,rand)), amount);\n}\n\nfloat rand(vec3 s) {\n    \n    //Thanks to Shane for the improved random function\n    return fract(cos(dot(s, vec3(7, 157, 113)))*43758.5453);\n\n    /* old\n    return fract( (fract(s.x*32.924)*8. + fract(s.x*296.234) +\n                 fract(s.y*32.924)*8. + fract(s.y*296.234) +\n                 fract(s.z*32.924)*8. + fract(s.z*296.234))*98.397 );*/\n}\nvec3 randDir(vec3 s) {\n    return vec3(sin(rand(s.yzx+.89234)*34.24),\n                cos(rand(s.zxy-1.445)*34.24),\n                -cos(rand(s)*34.35));\n}\n\n//ambient occlusion function is XT95's from https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion(in vec3 rp, in vec3 norm) {\n    float sum = 0., s = EPSILON;\n    vec3 lastp = rp;\n    \n    for (int i = 0; i < 16; i++) {\n        vec3 p = rp+randomHemiRay(norm,lastp*(1.+float(i)*.15),.3)*s;\n        sum += max(0., (s*.5-abs(df(p)))/(s*s));//randomHemiRay(norm,rp,.5)*s);\n        lastp = p;\n        s += .01;\n    }\n    \n    return clamp(1.-sum*.01, 0., 1.);\n}\n\nfloat softShadowTrace(in vec3 rp, in vec3 rd, in float maxDist, in float penumbraSize, in float penumbraIntensity) {\n    vec3 p = rp;\n    float sh = 0.;\n    float d,s = 0.;\n    for (int i = 0; i < SHADOW_ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        sh += max(0., penumbraSize-d)*float(s>penumbraSize*2.);\n        s += d;\n        if (d < EPSILON || s > maxDist) break;\n    }\n    \n    if (d < EPSILON) return 0.;\n    \n    return max(0.,1.-sh/penumbraIntensity);\n}\n\nvec3 background(in vec3 rd) {\n\tvec3 c = vec3(0.);\n    #if nLights != 0\n    for (int i = 0; i < nLights; i++) {\n        c += lights[i].color*max(0., dot(rd, normalize(lights[i].position)))*.6;\n    }\n    #endif\n    return c;\n}\nvec3 background_gi(in vec3 rd) {\n    return background(rd);\n}\n\nvec3 locateSurface(in vec3 rp) {    \n    vec3 sp = rp;\n    for (int i = 0; i < 3; i++) {\n        float sd = abs(df(rp));\n        if (sd < EPSILON) return sp;\n        sp += normal2(sp)*sd*.5;\n    }\n    return sp;\n}\nvoid lighting(in vec3 td, in vec3 sd, in vec3 norm, in vec3 reflDir, in material m, inout vec3 dif, inout vec3 spec) {\n    float ao = ambientOcclusion(td,norm);\n    dif = ambient*ao;\n    spec = vec3(0.);\n        \n    #if nLights != 0\n    for (int i = 0; i < nLights; i++) {\n        vec3 lightVec = lights[i].position-td;\n        float lightAtten = length(lightVec);\n        lightVec = normalize(lightVec);\n        float shadow = softShadowTrace(sd, lightVec, lightAtten, .01, .01);\n        lightAtten = max(0., 1.-lightAtten/lights[i].size)*shadow;\n        \n    \tdif += max(0., dot(lightVec,norm))*lights[i].color*lightAtten;\n        spec += pow(max(0., dot(reflDir, lightVec)), 4.+(1.-m.roughness)*78.)*shadow*lights[i].color;\n    }\n\t#endif\n}\n\n//copy of shade without reflection trace\nvec3 shadeNoReflection(in vec3 rp, in vec3 rd, in vec3 norm, in material m) {\n    vec3 sd = rp+norm*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 reflDir = reflect(rd,norm);\n\n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n\n    return (1.-m.metallic)*lightDif*m.diffuse +\n        \t(.5+m.metallic*.5)*lightSpec*m.specular +\n        \tm.emissive ;\n}\n\nvec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {\n    vec3 sd = rp+norm*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 dlc = vec3(0.);\n    \n    vec3 slc = vec3(0.);\n    vec3 reflDir = reflect(rd,norm);\n    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness);\n    tReflDir *= sign(dot(tReflDir,reflDir));\n       \n    float rtd = rTrace(sd,tReflDir,VIEW_DISTANCE);\n    if (rtd < 0.) {\n        slc = background(tReflDir);\n    } else {\n        vec3 rhp = sd+tReflDir*rtd;\n        slc = shadeNoReflection(rhp,reflDir,normal(rhp),mat(rhp));\n    }\n    \n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n    dlc += lightDif;\n    slc += lightSpec;\n    \n    float fres = 1.-max(0., dot(-rd,norm));\n    \n    return (1.-m.metallic)*dlc*m.diffuse +\n        \tslc*m.specular*((.5-m.metallic*.5)*fres+m.metallic*(.5+m.metallic*.5)) +\n        \tm.emissive ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord.xy - R*.5)/R.x;\n\n    initLights();\n    \n    ball = decodeBall(texture(iChannel0,vec2(.5)/iResolution.xy));\n    flap = texture(iChannel0,vec2(2.5,0.5)/iResolution.xy);\n  \n\tcameraLocation = vec3(-1.3, .5, 0.);\n\tcameraRotation = vec2(ball.y*.4, 1.03);\n    \n    \n    vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3(uv*vec2(1.,-1.)*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n        \n\tfloat itd = trace(rp,rd,VIEW_DISTANCE);\n    if (itd < 0.) {\n        fragColor = vec4(background(rd),1.);\n        return;\n    }\n    \n\n    vec3 hp = rp+itd*rd;\n    #ifndef PATH_TRACE\n    fragColor = vec4(mix(shade(hp,\n                      rd,\n                      normal(hp),\n                      mat(hp)), background(rd), max(0.,itd/VIEW_DISTANCE)),1.);\n\t#else\n    \n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Shulman/public_int_i 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Buf C - Motion blur\n\n//#define enabled\n\nconst float blur = .3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = texture(iChannel0, uv).xyz*(1.+9.*(1.-blur));\n    #ifndef enabled\n    fragColor = texture(iChannel0,uv);\n    return;\n    #endif\n    vec2 oneDivRes = 1./iResolution.xy;\n    for (int i = 0; i < 4; i++) {\n        #define fi float(i)\n        #define ff float(iFrame)\n        c += texture(iChannel1, uv+vec2(sin(fi*1.942+ff*.749+ff*.09823+.9234),\n                                          cos(fi*1.893+ff*.617+ff*.07954))*oneDivRes).xyz;\n    }\n    fragColor = vec4(c/(5.+9.*(1.-blur)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}