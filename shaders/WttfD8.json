{
    "Shader": {
        "info": {
            "date": "1612643550",
            "description": "particles + metaballs = metafluid",
            "flags": 32,
            "hasliked": 0,
            "id": "WttfD8",
            "likes": 11,
            "name": "Metafluid",
            "published": 3,
            "tags": [
                "simulation",
                "metaballs",
                "fake",
                "water",
                "fluid",
                "metafluid"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "float blob(in vec2 p, in vec2 o, in float r) {\n    p -= o;\n    return r * r / dot(p, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Render the particles with some metaball goo\n    float totalDist = 0.0;\n    for (int i=0; i < NUMBER_OF_PARTICLES; i++) {\n        float distToBlob = blob(uv, getParticlePos(i), BLOB_RADIUS);\n        totalDist += distToBlob;\n    }\n\n    vec3 color = vec3(0.25, 0.25, 1.0);\n    //color = mix(vec3(0.25, 0.25, 1.0), vec3(1.0), totalDist * 0.02); // To see the particles\n    color *= smoothstep(0.95, 1.0, totalDist);\n    color *= fragCoord.y / iResolution.y * 1.5;\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Particle settings\n#define NUMBER_OF_PARTICLES 100\n\n#define BLOB_RADIUS 0.04\n\n#define REPULSION 0.005\n#define MOUSE_REPULSION 0.01\n#define REPULSION_RADIUS 0.1\n\n// Environment settings\n#define GRAVITY 0.0005\n#define DECAY 0.9\n\n// Utilities\n#define getParticlePos(id) texelFetch(iChannel0, ivec2(id, 0), 0).xy\n#define getParticleVel(id) texelFetch(iChannel0, ivec2(id, 1), 0).xy\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec2 randomPos(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy) - 0.5;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// For animating the particles' motions\nvec2 animation(in float time) {\n    if (iMouse.z > 0.0) {\n        vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        return vec2(0.0005 * sin(time * 2.0 - mouse.x), 0.0);\n    }\n\n    return vec2(0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 topRight = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFragCoord.x < NUMBER_OF_PARTICLES && iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            // Initialize random positions (velocities start at 0)\n            if (iFragCoord.y == 0) {\n                fragColor.xy = randomPos(fragCoord.x);\n            }\n        }\n\n        if (iFrame > 0) {\n            // Load particle data\n            vec2 particlePos = getParticlePos(iFragCoord.x);\n            vec2 particleVel = getParticleVel(iFragCoord.x);\n\n            // Gravitate and bounce\n            particleVel += animation(iTime);\n            particleVel.y -= GRAVITY;\n            vec2 refl = sign(topRight - abs(particlePos));\n            particleVel.xy *= refl;\n            if (refl.x < 0.0 || refl.y < 0.0) {\n                 particleVel.xy *= DECAY;\n            }\n\n            // Push particles away from each other\n            for (int i=0; i < NUMBER_OF_PARTICLES + 1; i++) {\n                if (i != iFragCoord.x && i != NUMBER_OF_PARTICLES) {\n                    vec2 particlePos2 = getParticlePos(i);\n                    vec2 toParticle = particlePos2 - particlePos;\n                    float distToParticle = length(toParticle);\n                    if (distToParticle < REPULSION_RADIUS) {\n                        particleVel -= toParticle / distToParticle * REPULSION;\n                        particleVel *= DECAY;\n                    }\n                }\n\n                // The mouse acts as an extra blob with a unique repulsiveness\n                if (i == NUMBER_OF_PARTICLES && iMouse.z > 0.0) {\n                    vec2 particlePos2 = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n                    vec2 toParticle = particlePos2 - particlePos;\n                    float distToParticle = length(toParticle);\n                    if (distToParticle < REPULSION_RADIUS) {\n                        particleVel -= toParticle / distToParticle * MOUSE_REPULSION;\n                        particleVel *= DECAY;\n                    }\n                }\n            }\n\n            // Update particle data\n            if (iFragCoord.y == 0) {\n                fragColor.xy = particlePos;\n                fragColor.xy += particleVel;\n                fragColor.xy = clamp(fragColor.xy, BLOB_RADIUS - topRight, topRight - BLOB_RADIUS);\n            }\n\n            if (iFragCoord.y == 1) {\n                fragColor.xy = particleVel;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}