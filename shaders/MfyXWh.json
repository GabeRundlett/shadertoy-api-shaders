{
    "Shader": {
        "info": {
            "date": "1715098816",
            "description": "I merged the colors of https://www.shadertoy.com/view/wdjGWR with the distance estimation of https://www.shadertoy.com/view/XtfXzN\n\nI thought it looked nice ^^",
            "flags": 0,
            "hasliked": 0,
            "id": "MfyXWh",
            "likes": 11,
            "name": "Julia raymarched",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "julia"
            ],
            "usePreview": 0,
            "username": "barth",
            "viewed": 217
        },
        "renderpass": [
            {
                "code": "// controls : click and drag to navigate\n\n// base raymarching rendering thing\n// https://www.youtube.com/watch?v=yxNnRSefK94\n\n\n// fractal by\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\n\n#define MARCHING_ITERATIONS 64\n\n#define MARCHING_STEP 0.5\n\n#define CAMERA_DISTANCE 4.0\n\n#define MAX_MANDELBROT_DIST 3.0\n#define MANDELBROT_STEPS 10\n\n// cosine based palette, 4 vec3 params\nvec3 cosineColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette (float t) {\n    vec3 colorPhase = vec3(0.30, 0.15, 0.90);\n    float paletteFrequency = 0.01;\n    float offset = 0.5;\n    float amplitude = 0.5;\n    return cosineColor( t, vec3(offset),vec3(amplitude),vec3(paletteFrequency), colorPhase);\n}\n\n// distance estimator to a julia set (https://www.shadertoy.com/view/XtfXzN)\n// returns the distance to the set on the x coordinate \n// and the color on the y coordinate\nvec2 DE(vec3 pos)\n{\n    float t = iTime / 3.0;\n    \n\tvec4 c = 0.5 * vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<MANDELBROT_STEPS;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>MAX_MANDELBROT_DIST)\n        {\n\t\t\tbreak;\n        }\n\t}\n    \n    float colorIndex = 50.0*pow(md2,0.128/float(MARCHING_ITERATIONS));\n\n\treturn vec2(0.25*sqrt(mz2/md2)*log(mz2), colorIndex);\n}\n\n\n// TRACING A PATH : \n// measuring the distance to the nearest object on the x coordinate\n// and returning the color index on the y coordinate\nvec2 trace  (vec3 origin, vec3 ray) {\n\t\n    //t is the point at which we are in the measuring of the distance\n    float t =0.0;\n    float c = 0.0;\n    \n    for (int i=0; i<MARCHING_ITERATIONS; i++) {\n    \tvec3 path = origin + ray * t;\t\n    \tvec2 dist = DE(path);\n    \t// we want t to be as large as possible at each step but not too big to induce artifacts\n        t += MARCHING_STEP * dist.x;\n        c += dist.y;\n    }\n    \n    return vec2(t,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t// Pixel coordinates from -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Adjusting aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //ray direction (camera is at (0,0,0), view plane is at 0,0,1)\n    vec3 ray = normalize(vec3 (uv,1.0));\n\n    //ROTATING THE CAMERA (rotating the ray)\n    float rotAngle = 0.4+iTime/40.0 + 6.28*iMouse.x / iResolution.x;\n    //rotation matrix around the y axis\n    ray.xz *= mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n    \n    //camera position (rays origin)\n    float camDist = CAMERA_DISTANCE * iMouse.y / iResolution.y;\n    if (iMouse.xy==vec2(0)) camDist = CAMERA_DISTANCE*0.55;\n    vec3 origin = vec3 (camDist * sin(rotAngle),0.0,-camDist *cos(rotAngle));           \n    \n    //tracing the ray (getting the distance of the closest object in the ray direction)\n\tvec2 depth = trace(origin,ray);\n\t\n    //rendering with a fog calculation (further is darker)\n\tfloat fog = 1.0 / (1.0 + depth.x * depth.x * 0.1);\n\t\n    //frag color\n    vec3 fc = vec3(fog);\n    \n    \n    // Output to screen\n    fragColor = vec4(palette(depth.y)*fog,0.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}