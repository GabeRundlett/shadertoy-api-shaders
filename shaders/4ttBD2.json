{
    "Shader": {
        "info": {
            "date": "1541346596",
            "description": "Shows 2D reflections in slow motion. Uses no sqrt nor trigonometry except for when calculating length of lines in polygon, and first time calculating ray direction. This is to improve performance, tho not running on every pixel would probably help too.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttBD2",
            "likes": 11,
            "name": "Slow-Motion Reflections",
            "published": 3,
            "tags": [
                "2d",
                "reflection",
                "lines",
                "vectors",
                "speedoflight"
            ],
            "usePreview": 0,
            "username": "Hullburg",
            "viewed": 883
        },
        "renderpass": [
            {
                "code": "// Made by Hullburg\n// https://en.wikipedia.org/wiki/Illumination_problem\n// It would probably improve performance a lot to do the raycasting on a processor\n// or store the segments in a buffer.\n// Note how the fps decreases over time.\n// If the length of each segment in the polygon is calculated beforehand, the rest of the calculation need not use sqrt, sin, cos, or tan ever.\n// This means irrational numbers can be completely avoided, wich are hard to compute.\n// I think irrational numbers have something to do with the illumination problem.\n\n//#pragma optimize(off)\n\n//#define illuminationProblemSolution\t// (2, 0) cant be hit\n//#define filledLines\t// off for AA ish, on for round corners\n#define maxIterations 128\n#define polygonWidth 4.\t// pixels\n#define rayWidth 2.\t// pixels\n\n#define white vec3(1)\n#define black vec3(0)\n#define red vec3(1,0,0)\n#define green vec3(0,1,0)\n#define blue vec3(0,0,1)\n\n#define debugCol blue\n#define backgroundColor white\n#define lineColor black\n#define pointColor red\n\n#ifndef illuminationProblemSolution\n    const vec2 polygon[] = vec2[] (\n        vec2(0, 0),\n        vec2(1., 0),\n        vec2(1.2, -0.5),\n        vec2(1., -1),\n        vec2(0, -1),\n        vec2(-0.5, 0.5),\n        vec2(-0.5, 1),\n        vec2(0, 0.5),\n        vec2(0, 0)\n    );\n#else\n    // Invented by D. Castro\n    // Starting in (-2, 0) there is no way to hit (2, 0)\n    const float scale = 1./3.;\n    const vec2 polygon[] = vec2[] (\n        //vec2(\t0,\t0\t)*scale,\n        vec2(\t1,\t0\t)*scale,\n        vec2(\t1,\t1\t)*scale,\n        vec2(\t2,\t1\t)*scale,\n        vec2(\t2,\t2\t)*scale,\n        vec2(\t3,\t1\t)*scale,\n        vec2(\t3,\t0\t)*scale,\n        vec2(\t4,\t0\t)*scale,\n        vec2(\t3,\t-1\t)*scale,\n        vec2(\t2,\t-1\t)*scale,\n        vec2(\t2,\t-2\t)*scale,\n        vec2(\t1,\t-1\t)*scale,\n        vec2(\t0,\t-1\t)*scale,\n        vec2(\t0,\t-2\t)*scale,\n        vec2(\t-1,\t-1\t)*scale,\n        vec2(\t-2,\t-2\t)*scale,\n        vec2(\t-2,\t-1\t)*scale,\n        vec2(\t-3,\t-1\t)*scale,\n        vec2(\t-4,\t0\t)*scale,\n        vec2(\t-3,\t0\t)*scale,\n        vec2(\t-3,\t1\t)*scale,\n        vec2(\t-2,\t2\t)*scale,\n        vec2(\t-2,\t1\t)*scale,\n        vec2(\t-1,\t1\t)*scale,\n        vec2(\t-1,\t0\t)*scale,\n        vec2(\t1,\t0\t)*scale\n    );\n#endif\n\n/*const float pl[] = float[] (\n    0.\n);*/\n\n\nstruct lseg {\n    vec2 a;\n    vec2 b;\n    float l;\n    vec2 dir;\n    vec2 nml;\n    float c;\n};\n    \n\n#define changeInterval(omin, omax, val, nmin, nmax) ( ((val - omin) / (omax - omin)) * (nmax - nmin) + nmin )\n//#define screenInterval(pos) changeInterval( vec2(0), iResolution.xy, pos, vec2(-iResolution.z, -1), vec2(iResolution.z, 1) )\n#define screenInterval(pos) (pos*2. - iResolution.xy) / iResolution.y\n#define mh screenInterval(iMouse.xy)\n#define mc screenInterval(abs(iMouse.zw))\n#define m iMouse.z >= 0\n\n    \n/*generalForm getGeneral(vec2 a, vec2 b) {\n    generalForm l;\n    l.a = a.y - b.y;\n    l.b = b.x - a.x;\n    l.c = -(l.a*a.x + l.b*)//a.x*b.y - b.x*a.y;\n    return l;\n}*/\n\nfloat lsqr(vec2 v) {\n    return v.x*v.x + v.y*v.y;\n}\n// magnitude of regular cross\nfloat cross2(vec2 a, vec2 b) {\n    return a.x*b.y - b.x*a.y;\n}\n// aka 2d cross\nvec2 perpendicular(vec2 v) {\n    return vec2(v.y, -v.x);\n}\n\n// Returns line in form ax + by = c, abc are the vector components\n// xy is the line's normal, z is the distance from origo along the normal\n/*vec3 getGeneral(vec2 origin, vec2 dir) {\n    vec2 normal = vec2(dir.y, -dir.x);\n    \n    return vec3(normal, dot(normal, origin));\n}*/\n\n// Returns distance along d1 to poi.\n// Only d1 must be normalized.\n// Better than lineInt in 2D, otherwise getting scalar requires sqrt\n// makes vector between origins making ASA triangle, then uses law of sines\n// simplify l = |v|*sin(angle(d2, v))/sin(angle(d1, d2)) using cross product\nfloat rayIntScalar(\n    vec2 o1, vec2 d1,\n    vec2 o2, vec2 d2\n) {\n    vec2 v = (o2 - o1);\n    \n    return abs(cross2(v, d2)) / abs(cross2(d1, d2));\n}\nvec2 rayInt(\n    vec2 o1, vec2 d1,\n    vec2 o2, vec2 d2\n) {\n    return o1 + d1 * rayIntScalar(\n        o1, d1,\n        o2, d2\n    );\n}\n// Does not work for vertical lines. Obsolete.\nvec2 lineInt(\n    vec2 n1, float c1,\n    vec2 n2, float c2\n) {\n    float\n        a1 = n1.x, b1 = n1.y,\n    \ta2 = n2.x, b2 = n2.y;\n    \n    // solve equation system for x\n    float x = \n        cross2(vec2(n1.y, c1), vec2(n2.y, c2)) /\t//(b1*c2 - b2*c1) /\n        cross2(n2, n1);\t//(b1*a2 - b2*a1);\n    float y = (c2 - a2*x) / b2;\t// solve line 2 for y\n    \n    return vec2(x, y);\n}\n\n// Obsolete. Should perhaps be avoided\nbool poiOnSegment(vec2 a, vec2 b, float l, vec2 p) {\n    return lsqr(a - p) <= l*l && lsqr(b - p) <= l*l;\n}\n\nbool segmentCutsLine(vec2 nml, float h, vec2 a, vec2 b) {\n    return sign((dot(a, nml) - h)) != sign((dot(b, nml) - h));\t// are points on diffrent sides of line?\n}\nbool segCutsSeg(\n    vec2 a1, vec2 b1, vec2 n1, float h1,\n    vec2 a2, vec2 b2, vec2 n2, float h2\n) {\n    return segmentCutsLine(n1, h1, a2, b2) && segmentCutsLine(n2, h2, a1, b1);\n}\nbool segCutsSeg(\n    vec2 a1, vec2 b1, vec2 d,\n    vec2 a2, vec2 b2\n) {\n    vec2 n1 = vec2(d.y, -d.x);\n    float h1 = dot(n1, a1);\n    \n    d = (b2 - a2);\n    vec2 n2 = vec2(d.y, -d.x);\n    float h2 = dot(n2, a2);\n    \n    return segmentCutsLine(n1, h1, a2, b2) && segmentCutsLine(n2, h2, a1, b1);\n}\nbool segCutsSeg(\n    vec2 a1, vec2 b1,\n    vec2 a2, vec2 b2\n) {\n    vec2 d = (b1 - a1);\n    vec2 n1 = vec2(d.y, -d.x);\n    float h1 = dot(n1, a1);\n    \n    d = (b2 - a2);\n    vec2 n2 = vec2(d.y, -d.x);\n    float h2 = dot(n2, a2);\n    \n    return segmentCutsLine(n1, h1, a2, b2) && segmentCutsLine(n2, h2, a1, b1);\n}\n\n// Better to check segCutsSeg first as this requires l\nbool segmentInt(\n    vec2 o1, vec2 d1, inout float l1,\n    vec2 o2, vec2 d2, float l2\n) {\n    vec2 nml1 = vec2(d1.y, -d1.x);\n    float h = dot(nml1, o1);\n    \n    if (segmentCutsLine(nml1, h, o2, o2 + l2*d2)) {\n        float l = rayIntScalar(o1, d1, o2, d2);\n        \n        bool cuts = l >= 0. && l <= l1;\n        l1 = cuts ? l : l1;\n        return cuts;\n    }\n}\n\n// Returns factor of d\nfloat closestPointOnLineScalar(vec2 o, vec2 d, vec2 p) {\n    return dot(p - o, d);\t// rounding error not here\n}\n// Can be <0\nfloat distanceToLine(vec2 p, vec2 nml, float h) {\n    return dot(nml, p) - h;\t// Rounding error here if nml is not normalized 100%\n}\n\n// Obsolete.\nbool aabbInt(\n\tvec2 a1, vec2 a2,\n    vec2 b1, vec2 b2\n) {\n    return\n        max(a1.x, a2.x) > min(b1.x, b2.x) &&\n        max(a1.y, a2.y) > min(b1.y, b2.y) &&\n        max(b1.x, b2.x) > min(a1.x, a2.x) &&\n        max(b1.y, b2.y) > min(a1.y, a2.y) ;\n}\nbool inAABB(\n    vec2 p,\n\tvec2 a, vec2 b\n) {\n    return\n        max(a.x, b.x) > p.x &&\n        max(a.y, b.y) > p.y &&\n        p.x > min(a.x, b.x) &&\n        p.y > min(a.y, b.y) ;\n}\n\n\nvec3 drawPoint(vec3 bgcol, vec3 drawCol, float r, vec2 p, vec2 c) {\n    //#define pointCol vec3(1,0,0)\n    \n    r /= 1.*iResolution.y;\t// pixels to screen\n    \n    #ifdef filledLines\n    \tfloat amount = lsqr(p - c) <= r*r ? 1. : 0. ;\n    #else\n    \tfloat amount = smoothstep(r*r, 0., lsqr(p - c));//max(0., r - length(p - c)) / r;\n    #endif\n    \n    return mix(bgcol, drawCol, amount);\n}\nfloat onLine(float width, vec2 pos, vec2 nml, float h) {\t// for drawline\n    width /= 1.*iResolution.y;\t// pixels to screen\n    \n    #ifdef filledLines\n    \treturn abs(distanceToLine(pos, nml, h)) <= width ? 1. : 0.;\n    #endif\n    \n    return max(0., width - abs(distanceToLine(pos, nml, h))) / width;\t// re here\n}\nvec3 drawLine(vec3 col, float width, vec2 pos, vec2 nml, float h) {\n    #define lineCol lineColor\n    \n    float weight = onLine(width, pos, nml, h);\t// re here\n    \n    return mix(col, lineCol, weight);\n}\nvec3 drawSegment(vec3 col, vec3 drawCol, float width, vec2 pos, vec2 o, vec2 dir, float l) {\n    float d = closestPointOnLineScalar(o, dir, pos);\t// re not here\n    \n    if (0. <= d && d <= l) {\n        vec2 nml = vec2(dir.y, -dir.x);\n        return drawLine(col, width, pos, nml, dot(nml, o));\t// re at nml\n    }\n    \n    #ifdef filledLines\n        else if(lsqr(pos - (o + l*dir)) <= width*width) {\t// draw round end\n            return drawPoint(col, lineCol, width, pos, o + l*dir);\n        }\n    #endif\n    \n    return col;\n}\n\n\n// Returns hit line direction w/ line length\n// d must be normalized\n// Except is exception line that will not be checked for int. Out id is int line\n// Note that l can be modified.\n#define segmentsArray polygon\nvec2 firstIntersection(out int id, in int except, vec2 o, vec2 d, inout float l) {\n    //int id = -1;\n    vec2 d2 = vec2(0);\n    for (int i = 0; i <= segmentsArray.length(); i++) {\n        if (i == except) {\n            continue;\n        }\n        vec2 e = o + l*d;\n        vec2 c0 = segmentsArray[i], c1 = segmentsArray[i + 1];\n        if (segCutsSeg(\n            o, e, d,\n            c0, c1\n        )) {\n            id = i;\n            d2 = c1 - c0;\n            l = rayIntScalar(\n                o, d,\n                c0, d2\n            );\n        }\n    }\n    \n    return d2;\n}\n\n// Trace ray\n// Returns number of hits\nint traceRay(\n    out int id, out vec2 end,\n    inout vec2 dir, inout vec2 start, float maxLength,\n    bool draw, vec2 uv, inout vec3 col\n) {\n    if (draw) {\n        col = drawPoint(col, pointColor, 12., uv, start);\t//first dot\n    }\n    \n    vec2 poi = start;\n    float lLeft = maxLength;\n    id = -1;\n    \n    int i;\n    for (i = 0; i <= maxIterations && lLeft > 0.; i++) {\n        \n        float l = lLeft;\n        start = poi;\n        int except = id;\n        vec2 hitDir = firstIntersection(id, except, start, dir, l);\t// l is inout\n        \n        //if(l < 0.) {col = debugCol; break;}\n        hitDir = normalize(hitDir);\t// can be raplaced w/ hitDir / pl[id]\n        vec2 surfaceNml = vec2(hitDir.y, -hitDir.x);\n        lLeft -= l;\n        poi = start + l*dir;\n        \n        if (draw) {\n            col = drawSegment(col, lineColor, rayWidth, uv, start, dir, l);\n            col = drawPoint(col, pointColor, rayWidth * 3., uv, poi);\n        }\n        \n        dir = reflect(dir, surfaceNml);\n    }\n    \n    if (draw) {\n        col = drawPoint(col, pointColor, 12., uv, poi);\t//last dot\n    }\n    \n    end = poi;\n    return i;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates\n    vec2 uv = screenInterval(fragCoord);\n    //vec3 ray = normalize( vec3(uv, focalLength) );\n    \n    vec2 testO, testE;\n    if (iMouse.x <= 0. && iMouse.y <= 0.) {    // Preview\n        testE = vec2(1, 1);\n        testO = vec2(0.5, -0.5);\n    } else {\n    \ttestO = mc;\n    \ttestE = mh;\n    }\n    #ifdef illuminationProblemSolution\n    \ttestO = vec2(-2,0)*scale;\n    #endif\n    float testL = distance(testO, testE);\n    vec2 testD = (testE - testO) / testL;\n    //vec3 testLine = getGeneral( testO, testD );\n    vec2 testN = vec2(testD.y, -testD.x);//testLine.xy;\n    float testC = dot(testN, testO);//testLine.z;\n    lseg test =  lseg(\n        testO,\n        testE,\n        testL,\n        testD,\n        testN,\n        testC\n    );\n\n    // pixel color\n    vec3 col = backgroundColor;\t//vec3(1.);\n    \n    // Draw polygon\n    for(int i = 0; i <= polygon.length(); i++) {\n        vec2 c0 = polygon[i];\n        vec2 c1 = polygon[i + 1];\n        float l = distance(c0, c1);\n        //float lBug = distance(c0, c1) + 0.000000000000000000000000000000000001;\n        vec2 dir = c1 - c0;\n        vec2 dirn = dir / l;\n        vec2 nml = vec2(dir.y, -dir.x);\n        //vec2 nmlBug = perpendicular(dirBug);\n        vec2 nmln = nml / l;\n        float h = dot(nml, c0);\n        \n        col = drawSegment(col, lineColor, polygonWidth, uv, c0, dirn, l);\t// Rounding eror w/ dir here. Dir must be divided by exactly l, otherwise screen becomes black. (dir / l) * l still works.\n        //col = drawPoint(col, 0.03, uv, c0);\n        \n        if (segCutsSeg(\n            testO, testE, testN, testC,\n            c0, c1, nml, h\n        )) {\n            vec2 poi = rayInt(\n                testO, testD,\t//testN, testC,\n                c0, dir\t//nml, h\n            );\n            col = drawPoint(col, blue, 12., uv, poi);\n        }\n    }\n    col = drawPoint(col, green, 12., uv, polygon[0]);\n    \n    \n    int id;\n    vec2 end;\n    traceRay(\n        id, end,\n        testD, testO, iTime <= 0. ? 20. : iTime,\n        true, uv, col\n    );\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}