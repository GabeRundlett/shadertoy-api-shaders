{
    "Shader": {
        "info": {
            "date": "1620429911",
            "description": "I've decided to replicate one of Dave's creations in Material Maker ([url]https://materialmaker.org/[/url]) and export it to Shadertoy. It turned out to be not as easy as I expected, but it was fun anyway.",
            "flags": 0,
            "hasliked": 0,
            "id": "fsBSRy",
            "likes": 7,
            "name": "Square tiling (Material Maker)",
            "published": 3,
            "tags": [
                "animation",
                "generated",
                "dave",
                "materialmaker",
                "beesandbombs"
            ],
            "usePreview": 0,
            "username": "demicuz",
            "viewed": 336
        },
        "renderpass": [
            {
                "code": "// The code is not meant to be read by humans :)\n// Original: https://twitter.com/beesandbombs/status/1387181859264737282\n// The colors are slightly off, and the shader itself is quite wasteful\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb_to_hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv_to_rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat easeInOutCubic(float x) {\n\treturn x < 0.5 ? 4.0 * x * x * x : 1.0 - pow(-2.0 * x + 2.0, 3.0) / 2.0;\n}vec2 scale(vec2 uv, vec2 center, vec2 scale) {\n\tuv -= center;\n\tuv /= scale;\n\tuv += center;\n    return uv;\n}vec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nvec3 blend_dissolve(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\tif (rand(uv) < opacity) {\n\t\treturn c1;\n\t} else {\n\t\treturn c2;\n\t}\n}\n\nvec3 blend_multiply(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\nvec3 blend_screen(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;\n}\n\nfloat blend_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_hard_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*0.5*(c1*c2+blend_overlay(uv, c1, c2, 1.0)) + (1.0-opacity)*c2;\n}\n\nfloat blend_soft_light_f(float c1, float c2) {\n\treturn (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);\n}\n\nvec3 blend_soft_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_soft_light_f(c1.x, c2.x), blend_soft_light_f(c1.y, c2.y), blend_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_burn_f(float c1, float c2) {\n\treturn (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);\n}\n\nvec3 blend_burn(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_burn_f(c1.x, c2.x), blend_burn_f(c1.y, c2.y), blend_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_dodge_f(float c1, float c2) {\n\treturn (c1==1.0)?c1:min(c2/(1.0-c1),1.0);\n}\n\nvec3 blend_dodge(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_dodge_f(c1.x, c2.x), blend_dodge_f(c1.y, c2.y), blend_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_lighten(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*max(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_difference(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*clamp(c2-c1, vec3(0.0), vec3(1.0)) + (1.0-opacity)*c2;\n}\nconst float p_o5267_cx = 0.000000000;\nconst float p_o5267_cy = 0.000000000;\nconst float p_o5267_scale_x = 0.800000000;\nconst float p_o5267_scale_y = 0.800000000;\nconst float p_o5266_amount = 1.000000000;\nvec3 blend_darken_o5265 (vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec4 master_blend_o5265 (vec4 c1, vec4 c2, float amount){\n\treturn vec4(blend_darken_o5265(c1.rgb, c2.rgb, amount*c1.a),\n\t            min(1.0, c2.a+amount*c1.a));\n}\n\nvec4 blend_o5265 (vec4 c1, vec4 c2, float amount) {\n\tif (c1.a > 0.0 && c2.a > 0.0) return master_blend_o5265 (c1, c2, amount);\n\telse if (c1.a > 0.0) return c1;\n\telse return c2;\n}const float p_o5229_tx = 9.000000000;\nconst float p_o5229_ty = 9.000000000;\nconst float p_o5229_overlap = 1.000000000;\n#define p_o5229_bevel 5.5/iResolution.y\nconst float p_o5217_cx = -1.000000000;\nconst float p_o5217_cy = 0.000000000;\nconst float p_o5222_cx = 1.000000000;\nconst float p_o5222_cy = 0.000000000;\nconst float p_o5221_cx = 0.000000000;\nconst float p_o5221_cy = -1.000000000;\nconst float p_o5220_cx = 0.000000000;\nconst float p_o5220_cy = 1.000000000;\nconst float p_o5214_w = 0.500000000;\nconst float p_o5214_h = 0.500000000;\nconst float p_o5214_cx = 0.000000000;\nconst float p_o5214_cy = 0.000000000;\nconst float p_o5224_cx = 0.000000000;\nconst float p_o5224_cy = 0.000000000;\nfloat o5229_input_in(vec3 p) {\nfloat o5217_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5217_cx+0.5, p_o5217_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5222_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5222_cx+0.5, p_o5222_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5218_0_1_sdf2d = min( o5217_0_1_sdf2d, o5222_0_1_sdf2d);\nfloat o5221_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5221_cx+0.5, p_o5221_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5220_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5220_cx+0.5, p_o5220_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5219_0_1_sdf2d = min( o5221_0_1_sdf2d, o5220_0_1_sdf2d);\nfloat o5216_0_1_sdf2d = min( o5218_0_1_sdf2d, o5219_0_1_sdf2d);\nvec2 o5214_0_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_1_sdf2d = length(max(o5214_0_d,vec2(0)))+min(max(o5214_0_d.x,o5214_0_d.y),0.0);\nfloat o5215_0_1_sdf2d = max(- o5216_0_1_sdf2d, o5214_0_1_sdf2d);\nvec2 o5214_2_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_3_sdf2d = length(max(o5214_2_d,vec2(0)))+min(max(o5214_2_d.x,o5214_2_d.y),0.0);\nfloat o5223_0_1_sdf3d = mix(o5215_0_1_sdf2d, o5214_0_3_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5224_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5224_cx+0.5, p_o5224_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5225_0_1_sdf3d = mix(o5214_0_3_sdf2d, o5224_0_1_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5226_0_1_sdf3d = max(- o5223_0_1_sdf3d, o5225_0_1_sdf3d);\n\nreturn o5226_0_1_sdf3d;\n}\nconst float p_o5263_hue = 0.000000000;\nconst float p_o5263_saturation = 2.000000000;\nconst float p_o5263_value = 1.000000000;\nvec4 o5263_f(vec4 c) {\n\tvec3 hsv = rgb_to_hsv(c.rgb);\n\treturn vec4(hsv_to_rgb(vec3(fract(hsv.x+p_o5263_hue), clamp(hsv.y*p_o5263_saturation, 0.0, 1.0), clamp(hsv.z*p_o5263_value, 0.0, 1.0))), c.a);\n}const float p_o5242_gradient_0_pos = 0.166113000;\nconst float p_o5242_gradient_0_r = 1.000000000;\nconst float p_o5242_gradient_0_g = 0.878431022;\nconst float p_o5242_gradient_0_b = 0.250979990;\nconst float p_o5242_gradient_0_a = 0.486274987;\nconst float p_o5242_gradient_1_pos = 0.500000000;\nconst float p_o5242_gradient_1_r = 1.000000000;\nconst float p_o5242_gradient_1_g = 0.411765009;\nconst float p_o5242_gradient_1_b = 0.717647016;\nconst float p_o5242_gradient_1_a = 0.486274987;\nconst float p_o5242_gradient_2_pos = 0.832226000;\nconst float p_o5242_gradient_2_r = 0.109803997;\nconst float p_o5242_gradient_2_g = 0.760783970;\nconst float p_o5242_gradient_2_b = 0.756862998;\nconst float p_o5242_gradient_2_a = 0.486274987;\nvec4 o5242_gradient_gradient_fct(float x) {\n  if (x < 0.5*(p_o5242_gradient_0_pos+p_o5242_gradient_1_pos)) {\n    return vec4(p_o5242_gradient_0_r,p_o5242_gradient_0_g,p_o5242_gradient_0_b,p_o5242_gradient_0_a);\n  } else if (x < 0.5*(p_o5242_gradient_1_pos+p_o5242_gradient_2_pos)) {\n    return vec4(p_o5242_gradient_1_r,p_o5242_gradient_1_g,p_o5242_gradient_1_b,p_o5242_gradient_1_a);\n  }\n  return vec4(p_o5242_gradient_2_r,p_o5242_gradient_2_g,p_o5242_gradient_2_b,p_o5242_gradient_2_a);\n}\nvec4 o5229_input_color_map(vec2 uv) {\nvec2 o5242_0_wat = abs((uv) - 0.5);\nfloat o5242_0_d = o5242_0_wat.x+o5242_0_wat.y;vec4 o5242_0_1_rgba = o5242_gradient_gradient_fct(fract(2.0*(5.0/3.0)*o5242_0_d));\nvec4 o5263_0_1_rgba = o5263_f(o5242_0_1_rgba);\n\nreturn o5263_0_1_rgba;\n}\nconst float p_o5271_repeat = 0.500000000;\nconst float p_o5271_gradient_0_pos = 0.000000000;\nconst float p_o5271_gradient_0_r = 0.000000000;\nconst float p_o5271_gradient_0_g = 0.000000000;\nconst float p_o5271_gradient_0_b = 0.000000000;\nconst float p_o5271_gradient_0_a = 1.000000000;\nconst float p_o5271_gradient_1_pos = 0.252491694;\nconst float p_o5271_gradient_1_r = 0.000000000;\nconst float p_o5271_gradient_1_g = 0.000000000;\nconst float p_o5271_gradient_1_b = 0.000000000;\nconst float p_o5271_gradient_1_a = 1.000000000;\nconst float p_o5271_gradient_2_pos = 0.750830565;\nconst float p_o5271_gradient_2_r = 1.000000000;\nconst float p_o5271_gradient_2_g = 1.000000000;\nconst float p_o5271_gradient_2_b = 1.000000000;\nconst float p_o5271_gradient_2_a = 1.000000000;\nconst float p_o5271_gradient_3_pos = 1.000000000;\nconst float p_o5271_gradient_3_r = 1.000000000;\nconst float p_o5271_gradient_3_g = 1.000000000;\nconst float p_o5271_gradient_3_b = 1.000000000;\nconst float p_o5271_gradient_3_a = 1.000000000;\nvec4 o5271_gradient_gradient_fct(float x) {\n  if (x < p_o5271_gradient_0_pos) {\n    return vec4(p_o5271_gradient_0_r,p_o5271_gradient_0_g,p_o5271_gradient_0_b,p_o5271_gradient_0_a);\n  } else if (x < p_o5271_gradient_1_pos) {\n    return mix(vec4(p_o5271_gradient_0_r,p_o5271_gradient_0_g,p_o5271_gradient_0_b,p_o5271_gradient_0_a), vec4(p_o5271_gradient_1_r,p_o5271_gradient_1_g,p_o5271_gradient_1_b,p_o5271_gradient_1_a), ((x-p_o5271_gradient_0_pos)/(p_o5271_gradient_1_pos-p_o5271_gradient_0_pos)));\n  } else if (x < p_o5271_gradient_2_pos) {\n    return mix(vec4(p_o5271_gradient_1_r,p_o5271_gradient_1_g,p_o5271_gradient_1_b,p_o5271_gradient_1_a), vec4(p_o5271_gradient_2_r,p_o5271_gradient_2_g,p_o5271_gradient_2_b,p_o5271_gradient_2_a), ((x-p_o5271_gradient_1_pos)/(p_o5271_gradient_2_pos-p_o5271_gradient_1_pos)));\n  } else if (x < p_o5271_gradient_3_pos) {\n    return mix(vec4(p_o5271_gradient_2_r,p_o5271_gradient_2_g,p_o5271_gradient_2_b,p_o5271_gradient_2_a), vec4(p_o5271_gradient_3_r,p_o5271_gradient_3_g,p_o5271_gradient_3_b,p_o5271_gradient_3_a), ((x-p_o5271_gradient_2_pos)/(p_o5271_gradient_3_pos-p_o5271_gradient_2_pos)));\n  }\n  return vec4(p_o5271_gradient_3_r,p_o5271_gradient_3_g,p_o5271_gradient_3_b,p_o5271_gradient_3_a);\n}\nfloat o5229_input_t_map(vec2 uv) {\nvec2 o5271_0_wat = abs((uv) - 0.5);\nfloat o5271_0_d = max(o5271_0_wat.x,o5271_0_wat.y);vec4 o5271_0_1_rgba = o5271_gradient_gradient_fct(2.0*abs(fract(-0.2*iTime + p_o5271_repeat*o5271_0_d)-0.5));\nfloat o118692_0_1_f = easeInOutCubic((dot((o5271_0_1_rgba).rgb, vec3(1.0))/3.0));\n\nreturn o118692_0_1_f;\n}\nvec3 blend_darken_o5229 (vec3 c1, vec3 c2, float opacity) {\n\t//return min(c1, c2);\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec4 master_blend_o5229 (vec4 c1, vec4 c2, float amount){\n\treturn vec4(blend_darken_o5229(c1.rgb, c2.rgb, c1.a*amount),\n\t            min(1.0, c2.a+amount*c1.a));\n}\n\nvec4 tiler_o5229(vec2 uv, vec2 tile, float overlap, float bevel) {\n\tvec2 if_calculated = abs(uv-0.5)-overlap*(1.0/tile);\n\tif (if_calculated.x > 0.5 || if_calculated.y > 0.5) {\n\t\treturn vec4(0.0);\n\t}\n\t\n\tvec2 p = uv*tile;\n\t\n\tvec2 cell_id = floor(p);\n\tvec2 local_uv = fract(p);\n\tvec2 fetching_uv = (cell_id + 0.5)/tile;\n\t\n\tvec4 color = vec4(1.0, 1.0, 1.0, 0.0);\n\t\n\tfor (float dx = -overlap; dx <= overlap; ++dx) {\n\t\tfor (float dy = -overlap; dy <= overlap; ++dy) {\n\t\t\tvec2 local_uv_offset = vec2(dx, dy);\n\t\t\tvec2 local_fetching_uv = fetching_uv - local_uv_offset/tile;\n\t\t\t\n\t\t\tif (local_fetching_uv.x < 0.0 || local_fetching_uv.x > 1.0 || local_fetching_uv.y < 0.0 || local_fetching_uv.y > 1.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvec2 localler_uv = local_uv + local_uv_offset;\n\t\t\t\n\t\t\tfloat sdf = o5229_input_in(vec3(localler_uv, o5229_input_t_map(local_fetching_uv)));\n\t\t\t//float sdf_color = step(sdf, 0.0);\n\t\t\tfloat sdf_color = smoothstep(bevel, -bevel, sdf);\n\t\t\t\n\t\t\tvec4 fetched_color = o5229_input_color_map(local_fetching_uv);\n\t\t\t//if (color == vec4(0.0)) {\n\t\t\t//\tfetched_color.a *= sdf_color;\n\t\t\t//\tcolor = vec4(1.0);\n\t\t\t//}\n\t\t\tif (sdf_color > 0.0) {\n\t\t\t\tfetched_color.a *= sdf_color;\n\t\t\t\tcolor = master_blend_o5229(color,fetched_color,1.0);\n\t\t\t}\n\t\t\t\n\t\t\t//color = max(color, o5229_input_color_map(local_fetching_uv)*sdf);\n\t\t\t//color = blend_darken_o5229(o5229_input_color_map(local_fetching_uv)*sdf,color,1.0);\n\t\t}\n\t}\n\treturn color;\n\t//if (color.a < 0.000001) return vec4(0.0);\n\t//else return color;\n}const float p_o5252_cx = 0.000000000;\nconst float p_o5252_cy = 0.000000000;\nconst float p_o5268_tx = 8.000000000;\nconst float p_o5268_ty = 8.000000000;\nconst float p_o5268_overlap = 1.000000000;\n#define p_o5268_bevel 5.5/iResolution.y\nfloat o5268_input_in(vec3 p) {\nfloat o5217_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5217_cx+0.5, p_o5217_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5222_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5222_cx+0.5, p_o5222_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5218_0_1_sdf2d = min( o5217_0_1_sdf2d, o5222_0_1_sdf2d);\nfloat o5221_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5221_cx+0.5, p_o5221_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5220_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5220_cx+0.5, p_o5220_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5219_0_1_sdf2d = min( o5221_0_1_sdf2d, o5220_0_1_sdf2d);\nfloat o5216_0_1_sdf2d = min( o5218_0_1_sdf2d, o5219_0_1_sdf2d);\nvec2 o5214_0_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_1_sdf2d = length(max(o5214_0_d,vec2(0)))+min(max(o5214_0_d.x,o5214_0_d.y),0.0);\nfloat o5215_0_1_sdf2d = max(- o5216_0_1_sdf2d, o5214_0_1_sdf2d);\nvec2 o5214_2_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_3_sdf2d = length(max(o5214_2_d,vec2(0)))+min(max(o5214_2_d.x,o5214_2_d.y),0.0);\nfloat o5223_0_1_sdf3d = mix(o5215_0_1_sdf2d, o5214_0_3_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5224_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5224_cx+0.5, p_o5224_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5225_0_1_sdf3d = mix(o5214_0_3_sdf2d, o5224_0_1_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5226_0_1_sdf3d = max(- o5223_0_1_sdf3d, o5225_0_1_sdf3d);\n\nreturn o5226_0_1_sdf3d;\n}\nconst float p_o5264_hue = 0.000000000;\nconst float p_o5264_saturation = 2.000000000;\nconst float p_o5264_value = 1.000000000;\nvec4 o5264_f(vec4 c) {\n\tvec3 hsv = rgb_to_hsv(c.rgb);\n\treturn vec4(hsv_to_rgb(vec3(fract(hsv.x+p_o5264_hue), clamp(hsv.y*p_o5264_saturation, 0.0, 1.0), clamp(hsv.z*p_o5264_value, 0.0, 1.0))), c.a);\n}const float p_o183339_cx = 0.000000000;\nconst float p_o183339_cy = 0.000000000;\nvec4 o5268_input_color_map(vec2 uv) {\nvec2 o5242_0_wat = abs((scale((uv), vec2(0.5+p_o183339_cx, 0.5+p_o183339_cy), vec2((9.0/8.0), (9.0/8.0)))) - 0.5);\nfloat o5242_0_d = o5242_0_wat.x+o5242_0_wat.y;vec4 o5242_0_1_rgba = o5242_gradient_gradient_fct(fract(2.0*(5.0/3.0)*o5242_0_d));\nvec4 o183339_0_1_rgba = o5242_0_1_rgba;\nvec4 o5264_0_1_rgba = o5264_f(o183339_0_1_rgba);\n\nreturn o5264_0_1_rgba;\n}\nfloat o5268_input_t_map(vec2 uv) {\nvec2 o5271_0_wat = abs((uv) - 0.5);\nfloat o5271_0_d = max(o5271_0_wat.x,o5271_0_wat.y);vec4 o5271_0_1_rgba = o5271_gradient_gradient_fct(2.0*abs(fract(-0.2*iTime + p_o5271_repeat*o5271_0_d)-0.5));\nfloat o118692_0_1_f = easeInOutCubic((dot((o5271_0_1_rgba).rgb, vec3(1.0))/3.0));\n\nreturn o118692_0_1_f;\n}\nvec3 blend_darken_o5268 (vec3 c1, vec3 c2, float opacity) {\n\t//return min(c1, c2);\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec4 master_blend_o5268 (vec4 c1, vec4 c2, float amount){\n\treturn vec4(blend_darken_o5268(c1.rgb, c2.rgb, c1.a*amount),\n\t            min(1.0, c2.a+amount*c1.a));\n}\n\nvec4 tiler_o5268(vec2 uv, vec2 tile, float overlap, float bevel) {\n\tvec2 if_calculated = abs(uv-0.5)-overlap*(1.0/tile);\n\tif (if_calculated.x > 0.5 || if_calculated.y > 0.5) {\n\t\treturn vec4(0.0);\n\t}\n\t\n\tvec2 p = uv*tile;\n\t\n\tvec2 cell_id = floor(p);\n\tvec2 local_uv = fract(p);\n\tvec2 fetching_uv = (cell_id + 0.5)/tile;\n\t\n\tvec4 color = vec4(1.0, 1.0, 1.0, 0.0);\n\t\n\tfor (float dx = -overlap; dx <= overlap; ++dx) {\n\t\tfor (float dy = -overlap; dy <= overlap; ++dy) {\n\t\t\tvec2 local_uv_offset = vec2(dx, dy);\n\t\t\tvec2 local_fetching_uv = fetching_uv - local_uv_offset/tile;\n\t\t\t\n\t\t\tif (local_fetching_uv.x < 0.0 || local_fetching_uv.x > 1.0 || local_fetching_uv.y < 0.0 || local_fetching_uv.y > 1.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvec2 localler_uv = local_uv + local_uv_offset;\n\t\t\t\n\t\t\tfloat sdf = o5268_input_in(vec3(localler_uv, o5268_input_t_map(local_fetching_uv)));\n\t\t\t//float sdf_color = step(sdf, 0.0);\n\t\t\tfloat sdf_color = smoothstep(bevel, -bevel, sdf);\n\t\t\t\n\t\t\tvec4 fetched_color = o5268_input_color_map(local_fetching_uv);\n\t\t\t//if (color == vec4(0.0)) {\n\t\t\t//\tfetched_color.a *= sdf_color;\n\t\t\t//\tcolor = vec4(1.0);\n\t\t\t//}\n\t\t\tif (sdf_color > 0.0) {\n\t\t\t\tfetched_color.a *= sdf_color;\n\t\t\t\tcolor = master_blend_o5268(color,fetched_color,1.0);\n\t\t\t}\n\t\t\t\n\t\t\t//color = max(color, o5268_input_color_map(local_fetching_uv)*sdf);\n\t\t\t//color = blend_darken_o5268(o5268_input_color_map(local_fetching_uv)*sdf,color,1.0);\n\t\t}\n\t}\n\treturn color;\n\t//if (color.a < 0.000001) return vec4(0.0);\n\t//else return color;\n}const float p_o5270_color_r = 1.000000000;\nconst float p_o5270_color_g = 1.000000000;\nconst float p_o5270_color_b = 1.000000000;\nconst float p_o5270_color_a = 1.000000000;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec4 o5229_0_1_rgba = tiler_o5229((scale((UV), vec2(0.5+p_o5267_cx, 0.5+p_o5267_cy), vec2(p_o5267_scale_x, p_o5267_scale_y))), vec2(p_o5229_tx, p_o5229_ty), p_o5229_overlap, p_o5229_bevel);\nvec4 o5268_0_1_rgba = tiler_o5268((scale((scale((UV), vec2(0.5+p_o5267_cx, 0.5+p_o5267_cy), vec2(p_o5267_scale_x, p_o5267_scale_y))), vec2(0.5+p_o5252_cx, 0.5+p_o5252_cy), vec2((8.0/9.0), (8.0/9.0)))), vec2(p_o5268_tx, p_o5268_ty), p_o5268_overlap, p_o5268_bevel);\nvec4 o5252_0_1_rgba = o5268_0_1_rgba;\nvec4 o5265_0_1_rgba = blend_o5265(o5229_0_1_rgba, o5252_0_1_rgba, 1.0);\nvec4 o5270_0_1_rgba = vec4(p_o5270_color_r, p_o5270_color_g, p_o5270_color_b, p_o5270_color_a);\nvec4 o5266_0_s1 = o5265_0_1_rgba;\nvec4 o5266_0_s2 = o5270_0_1_rgba;\nfloat o5266_0_a = p_o5266_amount*1.0;\nvec4 o5266_0_2_rgba = vec4(blend_normal((scale((UV), vec2(0.5+p_o5267_cx, 0.5+p_o5267_cy), vec2(p_o5267_scale_x, p_o5267_scale_y))), o5266_0_s1.rgb, o5266_0_s2.rgb, o5266_0_a*o5266_0_s1.a), min(1.0, o5266_0_s2.a+o5266_0_a*o5266_0_s1.a));\nvec4 o5267_0_1_rgba = o5266_0_2_rgba;\nfragColor = o5267_0_1_rgba;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}