{
    "Shader": {
        "info": {
            "date": "1642158420",
            "description": "2d Colorful Clouds",
            "flags": 32,
            "hasliked": 0,
            "id": "ssfcWM",
            "likes": 1,
            "name": "2d Colorful Clouds",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "fractal",
                "cloud",
                "fire",
                "generated"
            ],
            "usePreview": 0,
            "username": "ersh",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "// (C) Copyright 2021 by Yury Ershov\n\n#define OUTPUT_AVG     0    // Average 4 buffers or use only one\n#define SMOOTH         1    // Filter output: 0=no; 1=slightly; 2=more\n#define WARP           1\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth(in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2. + V( 0.0,  0.0)*8. + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 20.; \\\n//EOM\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y) + \\\n//          V(-s.x,  0.0) + V( 0.0,  0.0)*2.) / 5.; \\\n// EOM\n//#define AVG \\\n//  return (V(0.0, -s.y) + V(-s.x, 0.0) + V(s.x, 0.0) + V(0.0, s.y))/4.; \\\n// EOM\n//#define AVG \\\n//  return (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n//EOM\n//#define AVG \\\n//  vec3 avg = \\\n//         (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n//          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n//          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n//  vec3 pt = V(0.0, 0.0); \\\n//  float diff = distance(avg, pt); \\\n//  return mix(pt, avg, smoothstep(0.0, 1.0, diff*1.5)); \\\n// EOM\n#define min2(a,b)                       vec3(min(a.x,b.x),min(a.y,b.y),min(a.z,b.z))\n#define min4(a1,a2,a3,a4)               min2(min2(a1,a2),min2(a3,a4))\n#define min8(a1,a2,a3,a4,b1,b2,b3,b4)   min2(min4(a1,a2,a3,a4),min4(b1,b2,b3,b4))\n#define max2(a,b)                       vec3(max(a.x,b.x),max(a.y,b.y),max(a.z,b.z))\n#define max4(a1,a2,a3,a4)               max2(max2(a1,a2),max2(a3,a4))\n#define max8(a1,a2,a3,a4,b1,b2,b3,b4)   max2(max4(a1,a2,a3,a4),max4(b1,b2,b3,b4))\n#define AVG \\\n  vec3 mn = min8( \\\n          V(-s.x, -s.y),  V( 0.0, -s.y),     V( s.x, -s.y), \\\n          V(-s.x,  0.0),                     V( s.x,  0.0), \\\n          V(-s.x,  s.y),  V( 0.0,  s.y),     V( s.x,  s.y)); \\\n  vec3 mx = max8( \\\n          V(-s.x, -s.y),  V( 0.0, -s.y),     V( s.x, -s.y), \\\n          V(-s.x,  0.0),                     V( s.x,  0.0), \\\n          V(-s.x,  s.y),  V( 0.0,  s.y),     V( s.x,  s.y)); \\\n  vec3 avg = \\\n         (V(-s.x, -s.y) + V( 0.0, -s.y)*2. + V( s.x, -s.y) + \\\n          V(-s.x,  0.0)*2.                 + V( s.x,  0.0)*2. + \\\n          V(-s.x,  s.y) + V( 0.0,  s.y)*2. + V( s.x,  s.y)) / 12.; \\\n  vec3 pt = V(0.0, 0.0); \\\n  float minmaxdiff = clamp(distance(mn,mx), 0.01, 0.67); \\\n  float diff = distance(avg, pt); \\\n  return mix(pt, avg, smoothstep(0.0, 1.0, diff / minmaxdiff)); \\\n// EOM\n\n#define T(a, b)  texture(a, fract(b))\n\n#define V(X,Y)   T(iChannel0, c + vec2(X, Y)).rgb\nvec3 avg0(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   T(iChannel1, c + vec2(X, Y)).rgb\nvec3 avg1(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   T(iChannel2, c + vec2(X, Y)).rgb\nvec3 avg2(in vec2 c, in vec2 s) { AVG }\n#undef V\n#define V(X,Y)   T(iChannel3, c + vec2(X, Y)).rgb\nvec3 avg3(in vec2 c, in vec2 s) { AVG }\n#undef V\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if WARP\n  float size = iResolution.x / (25.0 + pow(sin(iTime/5.5),9.)*10.);\n  float angle = iTime / 25.0;\n  float kx = sin(iTime/10.)/(iResolution.x*1.3*(1.2-pow(sin(iTime/15.),5.)));\n  float ky = pow(sin(iTime/14.),3.)/(iResolution.x*1.3*(1.16-pow(sin(iTime/22.),7.)));\n  fragCoord = fragCoord.xy - iResolution.xy / 2.0;\n  float stretch_x = fragCoord.x - iResolution.x * 1.5 / 2.0 * sin(iTime/11.);\n  float stretch_y = fragCoord.y - iResolution.y * 1.5 / 2.0 * sin(iTime/19.);\n  fragCoord = fragCoord.xy * rotate2d(angle + kx*stretch_x - ky*stretch_y);\n#endif\n\tvec2 uv = fragCoord / iResolution.xy;\n    fragColor.a = 1.0;\n\n#if OUTPUT_AVG\n#if SMOOTH\n    vec2 s = vec2(1., 1.) / iResolution.xy;\n\tfragColor = vec4(\n            (avg0(uv, s) +\n            avg1(uv, s) +\n            avg2(uv, s) +\n            avg3(uv, s)) / 4.\n            , 1.);\n#else\n\tfragColor = vec4(\n            (T(iChannel0,uv).rgb +\n            T(iChannel1,uv).rgb +\n            T(iChannel2,uv).rgb +\n            T(iChannel3,uv).rgb) / 4.\n            , 1.);\n#endif\n\n#else\n\n#if SMOOTH\n    fragColor.rgb = avg0(uv, vec2(1., 1.) / iResolution.xy);\n#else\n    fragColor.rgb = T(iChannel0,uv).rgb;\n#endif\n\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        1     // Cause the fire to flare up\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 2 in...\nvec3 hash32(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1099, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,-uv.y);\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,-uv.y);\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = fract(uv + vec2(DX, DY)); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    vec3 c = clamp(texture(iChannel0, d).rgb + (hash32(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c, v+0.0001);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 60.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 2 in...\nvec3 hash32(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1099, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,-uv.y);\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,-uv.y);\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = fract(uv + vec2(DX, DY)); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    vec3 c = clamp(texture(iChannel0, d).rgb + (hash32(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c, v+0.0001);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 70.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 2 in...\nvec3 hash32(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1099, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,-uv.y);\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,-uv.y);\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = fract(uv + vec2(DX, DY)); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    vec3 c = clamp(texture(iChannel0, d).rgb + (hash32(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c, v+0.0001);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// (C) Copyright 2021 by Yury Ershov\n\n#define INIT_RND        0     // Initialize the field by random levels; otherwise flat.\n#define CLICK_TO_RESET  1     // Click mouse to reset the field.\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 80.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 2 in...\nvec3 hash32(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1099, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n#if FLARE_UP\n#define COORD (1.-uv.y)\n#else\n#define COORD 1.\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 2\n#if CLICK_TO_RESET\n       || iMouse.z > 0.\n#endif\n       ) {\n#if !INIT_RND\n        fragColor = vec4(0.,0.,0.,-uv.y);\n#else\n        float c = hash12(fragCoord);\n        fragColor = vec4(c,c,c,-uv.y);\n#endif\n        return;\n    }\n\n    if (\n      //length(iMouse.xy - fragCoord) > 10. &&\n#if AVG_EVERY_N > 0\n      (iFrame % AVG_EVERY_N != 0) &&\n#endif\n      hash12(fragCoord) > 0.05*COORD\n    ) {\n        fragColor = texture(iChannel0,uv);\n        return;\n    }\n\n    vec2 s1 = vec2(1., 1.) / iResolution.xy;\n    vec2 d = uv;\n    float v = texture(iChannel0, d).a;\n    float vv; vec2 dd;\n#define TEST(DX, DY)  \\\n    dd = fract(uv + vec2(DX, DY)); \\\n    vv = texture(iChannel0, dd).a; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( s1.x,    0.);\n    TEST(-s1.x,    0.);\n    TEST(   0.,  s1.y);\n    TEST(   0., -s1.y);\n    TEST(-s1.x, -s1.y);\n    TEST( s1.x,  s1.y);\n    TEST(-s1.x,  s1.y);\n    TEST( s1.x, -s1.y);\n#if LOOKUP_DIST > 1\n    vec2 s2 = s1 * 2.;\n    TEST( s2.x,   0.);\n    TEST(-s2.x,   0.);\n    TEST(   0., s2.y);\n    TEST(   0.,-s2.y);\n    TEST( s2.x, s1.y);\n    TEST(-s2.x,-s1.y);\n    TEST(-s1.x, s2.y);\n    TEST( s1.x,-s2.y);\n    TEST( s2.x,-s1.y);\n    TEST(-s2.x, s1.y);\n    TEST( s1.x, s2.y);\n    TEST(-s1.x,-s2.y);\n#if LOOKUP_DIST > 2\n    TEST( s2.x, s2.y);\n    TEST(-s2.x,-s2.y);\n    TEST( s2.x,-s2.y);\n    TEST(-s2.x, s2.y);\n#endif\n#endif\n\n    vec3 c = clamp(texture(iChannel0, d).rgb + (hash32(uv)-0.5)/100., 0., 1.);\n    fragColor = vec4(c, v+0.0001);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}