{
    "Shader": {
        "info": {
            "date": "1492176780",
            "description": "mouse+arrow change the camera\n\nunholy union of 3:\nbufA=CameraIO ->  bufB=3d canvas\nbufC=display float data\nbufD=2d canvas ",
            "flags": 48,
            "hasliked": 0,
            "id": "XsjyDW",
            "likes": 10,
            "name": "011 mix(3d camera,Data,2d)",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "text",
                "projection",
                "buffer",
                "channel",
                "canvas",
                "float",
                "unholyunion",
                "toomanycooks"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 875
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 Out,in vec2 In){ \n    \n    Out=vec4(0);vec4 t=vec4(0);\n    t=texture(iChannel1,In/iResolution.xy, -100.0);//bufB=3d\n    Out.xyzw+=1.*t;\n    \n    t=texture(iChannel2,In/iResolution.xy, -100.0);//bufC=text\n    Out.xyz+=1.*t.w*t.xyz*t.xyz;\n    \n    //Out+= .2*texture(iChannel3,In/iResolution.xy, -100.0);//bufD=2d\n        \n////post processing:\n    Out*=Out;//f(Out)=Out*Out; simple way to increase contrast.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//camera IO\n// https://www.shadertoy.com/view/4lVXRm\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(fragCoord, P + 0.5))) fragColor = V\n#define load(P) texture(iChannel1, (P + 0.5) / iChannelResolution[1].xy, -100.0)\n#define key(K)  step(0.5, texture( iChannel0, vec2(K, 1.0/6.0) ).x)\n\nconst vec2 MEMORY_BOUNDARY = vec2(4.0, 3.0);\n\nconst vec2 POSITION = vec2(1.0, 0.0);\n\nconst vec2 VMOUSE = vec2(1.0, 1.0);\nconst vec2 PMOUSE = vec2(2.0, 1.0);\n\nconst vec2 TARGET = vec2(0.0, 2.0);\n\nconst vec2 RESOLUTION = vec2(3.0, 1.0);\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const float KEY_BIND_FORWARD = FORWARD; const float KEY_BIND_BACKWARD = BACKWARD; const float KEY_BIND_RIGHT = RIGHT; const float KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\treturn vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, max(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(fragCoord, MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord - 0.5);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    Collision(ptarget, target);\n    \n    store(TARGET, vec4(target, 0.0));\n    \n    position += (target - position) * iTimeDelta * 5.0; \n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4( pm + (iMouse.zw - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by genis sole - 2016\n// https://www.shadertoy.com/view/4lVXRm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n//basic ray-marching loop\n#define MaxSteps 96\n//smallest positive 16 bit float is exp2(-126.)\n#define eps exp2(-126.)\n\n//scale of 2d texturing\n#define zoom 5.\nconst float PI = acos(-1.);\nconst vec2 POSITION = vec2(1.,0.);\nconst vec2 VMOUSE = vec2(1.);\n#define load(P) texture(iChannel1,(P+.5)/iChannelResolution[1].xy,-100.)\n#define pi acos(-1.)\n#define pih acos(0.)\n////phi=golden-Ratio: 1/phi=1-phi\n#define phi (sqrt(5.)*.5-.5)\n////return 2x2matrix that mirrors a point on a line, that is rotated by r*0.5 radians.\n#define r2(r) mat2(sin(r+vec4(pih,0,0,-pih)))\n////r2(r) is equal to the matrix of a SINGLE rotation by [r], but (a*r2(r))*r2(r)=a is a double,refletion back and forth.\n////see \"complex number rotation in 2d\", which also uses \"half-angles\"\n\n    //projecting an iChannel to 3d space.\nvec4 project(vec2 p){\n //p*=r2(iTime*.1);\n p/=zoom;    \n p.x*=iResolution.y/iResolution.x;\n p+=vec2(.5);\n p=fract(p); \n vec4 r=vec4(0);\n r+= texture(iChannel2,p, -100.0);//BufC=float data\n r+= 0.1*texture(iChannel3,p, -100.0);//BufD=3d canvas\n return r;}\n\nvec3 Grid(vec3 ro,vec3 rd){\n    ro.z+=sin(length(ro.xy));\n float d =-ro.y/rd.y;\n if(d <=0.)return vec3(.4);    \n vec2 p=(ro.xz + rd.xz*d);\n \n //projecting 2d canvases into 3d traversable plane:\n return project(p).xyz;\n    \n p/=zoom;    \n p.x*=iResolution.y/iResolution.x;\n p+=vec2(.5);\n p=fract(p); \n vec4 r=vec4(0);\n r+= texture(iChannel2,p, -100.0);//BufC=float data\n r+= 0.1*texture(iChannel3,p, -100.0);//BufD=3d canvas\n return r.xyz;\n    \n //vec2 e=min(vec2(1.),fwidth(p));\n //vec2 l=smoothstep(vec2(1.),1.-e,fract(p))+smoothstep(vec2(0.),e,fract(p))-(1.-e);  \n //return mix(vec3(.4),vec3(.8)*(l.x+l.y)*.5,exp(-d*.01));\n}\n\n//return distance of [p]Point to box [s]size box [r]Roundness\nfloat dfBox(vec3 p,vec3 s,float r){return length(max(abs(p)-s+vec3(r),0.0))-r;}\n\n#define opU(a,b) a=min(a,b);\n//offset mod() for repeating space, xplained by \"hg_sdf\"\n#define pMod(x,d) (mod(x+d*.5,d)-d*.5)\nfloat df2(vec3 p){\n float r=p.z-.1*sin(1.5*length(p.xy             )-iTime)\n            -.1*sin(1.5*length(p.xy*.61-vec2(55))-iTime);\n                 p.z+=.5;\n //p.z=pMod(p.z,100.);\n vec3 q=vec3(pMod(p.xy,vec2(20,10)),p.z);\n opU(r,length(q-vec3(0,0,5))-1.);\n q=vec3(pMod(p.xy,vec2(17,13)),p.z);\n opU(r,dfBox(q-vec3( 3, 1,1.),vec3(2),0.15));\n q=vec3(pMod(p.xy,vec2(61,21)),p.z);\n opU(r,dfBox(p-vec3(-3, 1,1.),vec3(2),1.2));\n opU(r,dfBox(p-vec3( 0,-3,1.),vec3(2),.7));return r;}\n\n//distance field returns distance of p ti defined geometry\nfloat df(vec3 p){\n  return df2(p);\n  vec3 sphereCenter=vec3(0);\n  return length(p-sphereCenter)-1.;\n  //return sin(length(p.xy))-p.z;\n}\n\nvec3 normal(vec3 p){const vec2 e=vec2(.001,0);return normalize(vec3(\n df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx)));}\n//below normal has a branch for very small normals\n\nvec3 normal2(vec3 p){const vec2 e=vec2(.01,0);\n vec3 n=vec3(df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx));\n if(length(n)<0.01)return vec3(0);//makes is easier to distinguish if the camera is far from any surface.\n return normalize(n);}\n\n//#define dynamicEps\n\n//#define eps 1e-4\n//[o]=rayOrigin [d]=rayDirection\nvec4 rm2(vec3 o,vec3 d){d=normalize(d);\n float e=0.;//total distance\n for(int i=0;i<MaxSteps;i++){\n  if(df(o+d*e)<eps)break;//surface hit at .xyz with distance .w to [in ro]\n  e+=df(o+d*e);//increment total distance marched on ray\n }return vec4(o,e);}//surface missed\n\n#ifdef dynamicEps\n//this is experimental tweaking\nconst float verysmallpositive=FPSmultipier*0.0000000000000000000000000000000000000117;//3.5/1e40;//taking 1./1e40 as planck constant for floats in gl.\nconst float almostone=1.+verysmallpositive*20.;\n//i find values like these to cause a scene with a horizon co compile as fast as a scene that looks down at a flat ground.\n#endif\nfloat rm(vec3 o,vec3 i){float e,d;for(int j=0;j<MaxSteps;j++){float p=df(o+i*d);if(p<e)return d;d+=p;\n#ifdef dynamicEps                                 \n e=e+verysmallpositive+e*almostone;\n#endif\n }return d;}\n\n//////Camera functions.start\n\n//camera.rm\nvec3 Camera2(in vec2 fragCoord,out vec3 o){\n vec2 m = load(VMOUSE).xy/iResolution.x;\n m.y=-m.y;    \n float a=1./max(iResolution.x, iResolution.y);\n vec3 d=normalize(vec3((fragCoord-iResolution.xy*.5)*a,.5));\n mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n d =rotY*(rotX*d);\n return normalize(d);}\n\n//camera.ollj\nvoid Camera(vec2 q,vec3 e,vec3 t,vec3 u,out vec3 o,out vec3 i,float v){\t\n vec3 z=normalize(t-e),x=normalize(cross(z,u)),y=normalize(cross(x,z))*q.y;x*=q.x;//vec3 x,y,z==vec3 u,v,w\n float f=acos(dot(z,normalize(x))),//fow.xy\n s=(10./(2.*tan(abs(f)/2.)));o=e+(x+y)*(.15+.5*v)*s;i=normalize((e+z*2.+(x+y)*s)-o);}\n\n\nconst float lookUp=.3;\n//all while lookDown is just fine being >.4, allowing you to look down into the abyss:\nconst float lookDown=.4;\nvec3 Camera(in vec2 uv,out vec3 o){\n  float el=0.;\n  float az=0.;\n  if(iMouse.z>0.){\n    az=az + 2.*acos(-1.)*iMouse.x;\n    el=clamp (el + 0.8 *pi*iMouse.y,-lookDown*pi, lookUp * pi);\n  }\n  vec3 potision=vec3(0.);\n  vec3 target=vec3(0,-1.,0.);\n  vec3 vd=potision - target;\n  vec2 ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : pih));\n  vec2 ca = cos (ori),sa=sin (ori);\n  mat3 vuMat = mat3 (ca.y, 0., -  sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  return vuMat*normalize (vec3(uv, 2.5));}\n//from   https://www.shadertoy.com/view/MsScDz\n\n//////camera functions.end\n#define ccc color=clamp(color,vec3(0),vec3(1));\nvoid mainImage( out vec4 Out, in vec2 fragCoord ){\n\tvec3 o = load(POSITION).xyz;\n    o=vec3(o.x,-o.z,o.y);//simple 90° rotation\n    vec3 d = vec3(0.0);\n    d=Camera2(fragCoord,o);//i is rotated by camera\n    vec3 color=vec3(0);\n    o+=vec3(9,6,0);//camera position offset to better fit the distanceField\n    d=vec3(d.x,-d.z,d.y);//simple 90° rotation\n    vec3 dist=vec3(rm(o,d));\n    color=pow(fract(d),floor(d));\n   \n    vec3 hit=o+d*dist;//3d space were ray hit a surface\n    vec3 n=normal(hit);\n    color=n*.5+.5;//surface normals, shifted to visible range\n    vec2 a=vec3(hit).xy;\n    a.y*=-sign(n.z);\n    color-=n.z*project(a).xyz;ccc\n    a=vec3(hit).xz;\n    a.x*=sign(n.y);\n    color-=n.y*project(a*9.).xyz;ccc\n    a=vec3(hit).yz;\n    a.x*=-sign(n.x);\n    color-=n.x*project(a*9.).xyz;ccc\n     \n        \n    //color.xyz = Grid(o,d);//optionally add the old raytraced 2d plane grid.\n    \n    //my way of doing \"distance fog\"\n    color=clamp(color,vec3(0),vec3(1));\n    color*=pow(pow(color,vec3(.5e-1)),dist-3.);\n    \n    color.xyz=pow(color.xyz, vec3(0.4545));\n    Out = vec4(color.xyz, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define load(P) texture(iChannel1,(P+.5)/iChannelResolution[1].xy,-100.)\n\n//https://www.shadertoy.com/view/MtyXDV\n\n// strange bug ? using at_sign @ after define command in comment produces error message:\n//    Unknown Error: ERROR: 0:? : '' : syntax error\n// uncomment next line to check it out...              \n//#define at 64  // @    \n\n//=================================================================\n// ViewShaderData2.glsl    \n//   v1.0  2017-04-11  initial release\n//                     !!! BUGS: integer and float conversion displays wrong values in some cases !!! \n//   v1.1  2017-04-12  char() corrections\n//                     convertion routines corrected by Timo Kinnunen!  \n// Display shader data like \n//   date, time, frameCount, runtime, fps, resolution & mouse position.\n// Click and Drag mouse button to display current mouse position.\n// This release 2 uses the font texture to display integer and float values.\n// useful infos:\n//      font:  https://www.shadertoy.com/view/MtVXRd\n//   numbers:  https://www.shadertoy.com/view/llySRh\n// version 1:  https://www.shadertoy.com/view/llcXDn\n//=================================================================\n\n//--- common data ---\nfloat time = 0.0;\nvec2 uv  = vec2(0.0);  // -1 .. 1\nvec2 tp  = vec2(0.0);  // text position\n\n//== font handling ================================================\n\n#define FONT_SPACE 0.5\n\nconst vec2 vFontSize  = vec2(8.0, 15.0);  // multiples of 4x5 work best\n\n//----- access to the image of ascii code characters ------\n\n#define SPACE tp.x-=FONT_SPACE;\n\n#define S(a) c+=char(a);   tp.x-=FONT_SPACE;\n\n#define _note  S(10);   //\n#define _star  S(28);   // *\n#define _smily S(29);           \n#define _ tp.x-=FONT_SPACE;\n#define _exc   S(33);   // !\n#define _add   S(43);   // + \n#define _comma S(44);   // ,\n#define _sub   S(45);   // -\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign \n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n//---------------------------------------------------------\n// return font image intensity of character ch at text position tp\n//---------------------------------------------------------\n\n//float char(float ch)    // old versions\n//{ return texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));}\n//  vec4 f = texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(ch,16.-(1e-6)-floor(ch)/16.))/16.));  \n\nfloat char(int ch)\n{\n  vec4 f = any(lessThan(vec4(tp,1,1), vec4(0,0,tp))) \n               ? vec4(0) \n               : texture(iChannel0,0.0625*(tp + vec2(ch - ch/16*16,15 - ch/16)));  \n  if (iMouse.z > 0.0) \n    return f.x;   // 2d \n  else\n    return f.x * (f.y+0.3)*(f.z+0.3)*2.0;   // 3d\n}\n\n//== drawings =============================================\n\n//--- draw line segment from A to B ---\nfloat drawSegment(vec2 A, vec2 B, float r)  // \n{\n    vec2 g = B - A;\n    vec2 h = uv - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.5*r, d);\n}\n//--- draw circle at pos with given radius ---\nfloat circle(in vec2 pos, in float radius, in float halo)\n{\n  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);\n}\n\n//--- display number fraction with leading zeros --- \nfloat drawFract(int digits, float fn) \n{ \n  float c = 0.0; \n  fn = fract(fn) * 10.0; \n  for (int i = 1; i < 60; i++) \n  {\n    c += char(48 + int(fn)); // add 0..9\n    tp.x -= FONT_SPACE; \n    digits -= 1; \n    fn = fract(fn) * 10.0; \n    if (digits <= 0 || fn == 0.0) break; \n  } \n  tp.x -= FONT_SPACE*float(digits); \n  return c; \n}\n                                                                                                             \n//--- display integer value --- \nfloat drawInt(int val, int minDigits)\n{\n  float c = 0.; \n  if (val < 0) \n  { val = -val; \n    if (minDigits < 1) minDigits = 1;\n    else minDigits--;\n    _sub                   // add minus char\n  } \n  int fn = val, digits = 1; // get number of digits \n  for (int n=0; n<10; n++)\n  {\n    fn /= 10; \n    if (fn == 0) break; \n    digits++;\n  } \n  digits = max(minDigits, digits); \n  tp.x -= FONT_SPACE * float(digits); \n  for (int n=1; n < 11; n++) \n  { \n    tp.x += FONT_SPACE; // space\n    c += char(48 + (val-((val/=10)*10))); // add 0..9 \n    if (n >= digits) break;\n  } \n  tp.x -= FONT_SPACE * float(digits); \n  return c;\n}\n\n//--- display float value ---\nfloat drawFloat(float fn, int prec, int maxDigits)\n{ \n  float tpx = tp.x-FONT_SPACE*float(maxDigits);\n  float c = 0.; \n  if (fn < 0.0) \n  { \n    c = char(45); // write minus sign\n    fn = -fn; \n  }\n  tp.x -= FONT_SPACE; \n  c += drawInt(int(fn),1); \n  c += char(46); SPACE; // add dot \n  c += drawFract(prec, fract(fn)); \n  tp.x = min(tp.x, tpx); \n  return c; \n}\n\nfloat drawFloat(float value)           {return drawFloat(value,2,5);} \n\nfloat drawFloat(float value, int prec) {return drawFloat(value,prec,2);} \n\nfloat drawInt(int value)               {return drawInt(value,1);}\n\n//=================================================================\n\nconst vec3 headColor = vec3(0.90, 0.60, 0.20);\nconst vec3 backColor = vec3(0.15, 0.10, 0.10);\nconst vec3 mpColor   = vec3(0.99, 0.99, 0.00);\nconst vec3 mxColor   = vec3(1.00, 0.00, 0.00);\nconst vec3 myColor   = vec3(0.00, 1.00, 0.00);\n      vec3 dotColor  = vec3(0.50, 0.50, 0.00);\n      vec3 drawColor = vec3(1.0, 1.0, 0.0);\n      vec3 vColor    = backColor;\n\nfloat aspect = 1.0;\nvec2 pixelPos   = vec2(0.0);  // pixel position:  0 .. resolution-1\nvec2 mousePos   = vec2(200);  // mouse pixel position  \nvec2 lp         = vec2(0.5);  // last mouse position \nvec2 mp         = vec2(0.5);  // current mouse position \nvec2 resolution = vec2(0.0);  // window resolution\n\n//----------------------------------------------------------------\nvoid SetTextPosition(float x, float y)  //x=line, y=column\n{\n  tp = 10.0*uv; \n  tp.x = tp.x +17. - x;\n  tp.y = tp.y -9.4 + y;\n}\n//----------------------------------------------------------------\nvoid SetColor(float red, float green, float blue)\n{\n  drawColor = vec3(red,green,blue);    \n}\n//----------------------------------------------------------------\nvoid WriteFloat(const in float fValue \n               ,const in int maxDigits \n               ,const in int decimalPlaces)\n{\n  vColor = mix(vColor, drawColor, drawFloat (fValue, decimalPlaces));\n  SPACE;\n}\n//----------------------------------------------------------------\nvoid WriteInteger(const in int iValue)\n{\n  vColor = mix(vColor, drawColor, drawInt (iValue));\n  SPACE;\n}\n//----------------------------------------------------------------\nvoid WriteDate()\n{\n  float c = 0.0;\n  c += drawInt(int(iDate.x));       _sub;\n  c += drawInt(int(iDate.y +1.0));  _sub;\n  c += drawInt(int(iDate.z)); _\n  vColor = mix(vColor, drawColor, c);\n}\n//----------------------------------------------------------------\nvoid WriteTime()\n{\n  float c = 0.0;\n  c += drawInt(int(mod(iDate.w / 3600.0, 24.0)));    _ddot;\n  c += drawInt(int(mod(iDate.w / 60.0 ,  60.0)),2);  _ddot;\n  c += drawInt(int(mod(iDate.w,          60.0)),2);  _\n  vColor = mix(vColor, drawColor, c);\n}\n//----------------------------------------------------------------\nvoid WriteFPS()\n{\n  // print Frames Per Second - FPS  see https://www.shadertoy.com/view/lsKGWV\n  //float fps = (1.0 / iTimeDelta + 0.5);\n  float fps = iFrameRate;\n  SetColor (0.8, 0.6, 0.3);\n  WriteFloat(fps, 6, 1);\n  float c = 0.0;\n  _f _p _s\n  vColor = mix(vColor, drawColor, c);\n}\n//----------------------------------------------------------------\nvoid WriteMousePos(float ytext, vec2 mPos)\n{\n  int digits = 3;\n  float radius = resolution.x / 200.;\n\n  // print dot at mPos.xy \n  if (iMouse.z > 0.0) dotColor = mpColor;\n  float r = length(mPos.xy - pixelPos) - radius;\n  vColor += mix(vec3(0), dotColor, (1.0 - clamp(r, 0.0, 1.0)));\n\n  // print first mouse value\n  SetTextPosition(1., ytext);\n\n  // print mouse position\n  if (ytext == 7.)\n  {\n    drawColor = mxColor;\n    WriteFloat(mPos.x,6,3);\n    SPACE;\n    drawColor = myColor;\n    WriteFloat(mPos.y,6,3);\n  }\n  else\n  {\n    drawColor = mxColor;\n    WriteInteger(int(mPos.x));\n    SPACE;\n    drawColor = myColor;\n    WriteInteger(int(mPos.y));\n  }\n}    \n//----------------------------------------------------------------\nvoid WriteText1()\n{\n  SetTextPosition(1.,1.);\n  float c = 0.0;\n  //_star _ _V _i _e _w _ _S _h _a _d _e _r   \n  //_ _D _a _t _a _ _2 _ _ _v _1 _dot _1 _ _star \n  vColor += c * headColor;\n}\n//----------------------------------------------------------------\nvoid WriteTestValues()\n{\n  float c = 0.0;\n  SetTextPosition(1.,12.);\n    c += drawInt(123, 8);   \n  _ c += drawInt(-1234567890);    // right now !!!\n  _ c += drawInt(0);                \n  _ c += drawInt(-1);                \n  _ c += drawFloat(-123.456);     // right now !!!\n\n  SetTextPosition(1.,13.);\n    c += drawInt(-123, 8);   \n  _ c += drawInt(1234567890,11);\n  _ c += drawFloat(0.0,0,0);\n  _ c += drawFloat(1.0,0,0);\n  _ c += drawFloat(654.321);      // nearly right\n  _ c += drawFloat(999.9, 1);\n  _ c += drawFloat(pow(10., 3.),1);   \n  _ c += drawFloat(pow(10., 6.),1);   \n  \n  SetTextPosition(1.,14.);\n  c += drawFloat(exp2(-126.0),60);\n  vColor += c * headColor;\n}\n//---------------------------------------------------------\n// draw ring at given position\n//---------------------------------------------------------\nfloat ring(vec2 pos, float radius, float thick)\n{\n  return mix(1.0, 0.0, smoothstep(thick, thick + 0.01, abs(length(uv-pos) - radius)));\n}\n//----------------------------------------------------------------\n// define center coodinates\n#define CC(c) (2.0 * c / resolution - 1.0) * ratio;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = iTime;\n  resolution = iResolution.xy;\n  aspect = resolution.x / resolution.y;    // aspect ratio\n  vec2 ratio = vec2(aspect, 1.0);\n  pixelPos = fragCoord.xy;  //  0 .. resolution\n  mousePos = iMouse.xy;     //  0 .. resolution\n  uv = CC(pixelPos);        // -1 .. 1\n  mp = CC(iMouse.xy);       // -1 .. 1\n  lp = CC(iMouse.zw);       // -1 .. 1\n    \n  // draw axis\n  vColor = mix(vColor, vec3(0.2), drawSegment(vec2(-99.,0.), vec2(99.,0.), 0.01));\n  vColor = mix(vColor, vec3(0.2), drawSegment(vec2(0.,-99.), vec2(0.,99.), 0.01));\n\n  // version & test values   \n  WriteText1();     \n  WriteTestValues();\n      \n  // mouse position & coordinates\n  WriteMousePos(5., iMouse.zw);  // last position\n  WriteMousePos(6., iMouse.xy);  // current position\n\n  // circle Radius\n  float radius = length(mp - lp);\n  SetColor (0.9, 0.9, 0.2);\n  float c = 0.0;\n  _  _r _eq\n  vColor += c * drawColor;\n  WriteFloat (radius,6,2);    \n      \n  // Circle\n  float intensity = ring(mp.xy, radius, 0.01);\n  drawColor = vec3(1.5, 0.4, 0.5);\n  vColor = mix(vColor, drawColor, intensity*0.2);\n    \n  // Resolution\n  SetTextPosition(27.0, 1.0);\n  SetColor (0.8, 0.8, 0.8);\n  WriteInteger(int(iResolution.x));  _star _  vColor += c * drawColor;\n  WriteInteger(int(iResolution.y));\n\n  // Date\n  SetTextPosition(1.0, 19.);\n  SetColor (0.9, 0.9, 0.4);\n  WriteDate();   \n  SPACE\n      \n  // Time\n  SetColor (1.0, 0.0, 1.0);\n  WriteTime();\n  SPACE\n\n  // Frame Counter\n  SetColor (0.4, 0.7, 0.4);\n  WriteInteger(iFrame);\n  SPACE\n\n  // Shader Time\n  SetColor (0.0, 1.0, 1.0);\n  WriteFloat(time, 6, 2);\n  SPACE\n      \n  // Frames Per Second\n  WriteFPS();\n\n  fragColor = vec4(vColor,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//better documented: https://www.shadertoy.com/view/XsByDW\n\n//this is a core 2d canvas with core basics.\n\n////A define is identical to an \"alias\" or \"bind\", a useful shorthand.\n#define zoom 5.\n\n#define pi acos(-1.)\n#define pih acos(0.)\n////phi=golden-Ratio: 1/phi=1-phi\n#define phi (sqrt(5.)*.5-.5)\n\n////return a sinusoid over time with range.y [-1 .. 1] & wavelength of 1 second.\n#define hz sin(iTime*pi*2.)\n////return a sinusoid over time with range.y [ 0 .. 1] & wavelength of 1 second.\n#define hz1 (hz*.5+.5)\n\n////By discarding the whole part (of a line) with x=fract(x), you get a seesaw with range.y [0 .. 1];\n#define frac(a) a=fract(a)\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n\n////return 2x2matrix that mirrors a point on a line, that is rotated by r*0.5 radians.\n#define r2(r) mat2(sin(r+vec4(pih,0,0,-pih)))\n////r2(r) is equal to the matrix of a SINGLE rotation by [r], but (a*r2(r))*r2(r)=a is a double,refletion back and forth.\n////see \"complex number rotation in 2d\", which also uses \"half-angles\"\n\n//return polar (distamce,angle) coordinates of carthesian (x,y) input.\n//vec2 c2p(vec2 p){return vec2(length(p),atan(p.y,p.x));}\n//return carthesian (x,y) coordinates of polar (distamce,angle) input.\n//vec2 p2c(vec2 p){return p.x*vec2(cos(p.y),sin(p.y));}\n\nvec2 frame(vec2 p){p/=iResolution.xy;\n    p-=vec2(.5);//move xy=vec2(0,0) to the center of range [0 .. 1].xy\n    p*=zoom;//scale by [zoom]\n    p.x*=iResolution.x/iResolution.y;//m.x scales by aspect ratio.\n  //p=p*r2(iTime);//rotation transform, clockwise over time\n  //p=p*r2(sin(iTime*phi*2.)*.1);//rotation transform, PENDULUM over time\nreturn p;}\n\n//if(a p.dimension is exactly on a cell border && a direction is negative) cubeid.dimension-=1.\n//vec3 getRt(vec3 p, vec3 d){return p-step(d,vec3(0));}//likely faster.\nvec3 getRt(vec3 p, vec3 d){return p-vec3(lessThan(d,vec3(0)));}//works on older gl versions\n//caveat if(on cell border and parallel to it) the lower cell(s) get(s) ignored\n\nfloat df(vec2 p){\n    vec3 pp=vec3(p,0.);\n    //p=getRt2(p,p);\n    vec2 mouse=frame(iMouse.xy)-p;\n    float DitanceToMouse =length(mouse);//distance of p to framed-mouse\n    float DitanceToMetaball=DitanceToMouse*length(p);//simple metaball.\n    float d=0.;\n    d-=hz*.1;//oscillate [d] a little bit over time. (larger oscillations distract too much)\n  //d+=DitanceToMouse;\n  \n  //d+=max(abs(mouse.x),abs(mouse.y));//distance to square\n  //d+=min(abs(p.x),abs(p.y));//distance to cross\n  //d+=max(abs(p.x),abs(p.y))*(3.-hz1)-min(abs(mouse.x),abs(mouse.y));//distance to (distorting) star.\n  \n  d+=DitanceToMetaball-2.;\n  //d+=min(length(p),DitanceToMouse)*phi*4.-2.;//union of 2 distances to 2 points via min(a,b)\n  //d+= min(DitanceToMouse*1.5,DitanceToMetaball)-2.;//union of 2 distances \n////mix(a,b,c) does linear interpolation on a line trough a and b, c=0.0 returns a,c=1.0 returns b:\n  //d+= mix(DitanceToMetaball,min(DitanceToMouse*1.5,DitanceToMetaball),hz)-2.;\n////max(a,b) returns the UNION of 2 distance fields [a] and [b]\n  //d+=max(length(p),  DitanceToMouse     )-1.;//distance to union\n////max(a,-b) returns the distance to shpe [a], substracted by distance to shape [b].\n////(but that is for distances to volumes, in 2d we need an offset (here -2.)):\n  //d+=max(length(p)-2.,-(DitanceToMouse-2.));\n  //d+=(DitanceToMouse+length(p))-2.;//(poorly scaled) oval\n  //d+= DitanceToMouse/length(p)+length(p)-2.;//hearty\n    return d;//return distance to mouse\n}////see http://mercury.sexy/hg_sdf/\n\n//[p]=framed screenspace pixel (position of pixel on screen). [d]=\nvec3 cam(vec2 p,vec3 d){\n mat3 m=mat3(1,0,0,   0,1,0 ,   0,0,1);\n return vec3(p,1.)*m;\n}\n\nvoid mainImage(out vec4 Out,in vec2 In){vec2 p=frame(In);\n                                        \n    \n                                        \n    vec2 p2=p;//we change p soon, and copy a backup of it here.\n    float c=length(p);//length(a.xyzw) returns euclidean distance, pythagrean, squareroot of sum of squares.\n    frac(p);//.xy grid <- seesaw\n    ss2t(p);//.xy grid    seesaw <- triangle\n    p*=p*p; //f(p)=p*p*p; simple way to make p more exponential (for p range[0 .. 1])\n                               \n    frac(c);//distance to point (0,0) <- seesaw\n  //ss2t(c);//distance to point (0,0)    seesaw <- triangle\n    c*=.5;\n    c*=hz1;//multiply [c] by a sinusoid over time see \"#define hz...\"\n    Out=vec4(c,p,1.);//set the \"out vec4 Out\" value, \n\n    float di=df(p2);//di stores [distance of [p2] to distance field df()\n    frac(di);//display distance fiels just as we display distance to point (0,0)\n  //di=step(di+hz1,1.);//display distance field as \"inside and outside of distance 1.0\"\n  //di=1.-di;//optional inversion, with offset\n    Out.xyz+=di*.5;//show distance field. Additive visualization is lazy and fast (and bad style)\n///end of distance field code\n                                        \n    vec3 cent=getRt(vec3(0),vec3(0,1,1));\n    Out.xyz+=step(length(p2-cent.xy),.1);\n            \n////post processing:\n    Out*=Out;//f(Out)=Out*Out; simple way to increase contrast.\n}",
                "description": "",
                "inputs": [],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}