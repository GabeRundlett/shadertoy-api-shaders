{
    "Shader": {
        "info": {
            "date": "1678710058",
            "description": "lol",
            "flags": 0,
            "hasliked": 0,
            "id": "ddGGRG",
            "likes": 36,
            "name": "Slicing a SDF with macros ðŸ’€",
            "published": 3,
            "tags": [
                "slice",
                "macro",
                "slicing"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "// from blackle\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + cross(ax, p) * sin(ro);\n}\n// from iq\nfloat sdBox( vec3 p ){\n  vec3 b = vec3(0.5);\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n#define saturated_smoothstep(x) smoothstep(0.,1.,x)\n\n// ANIMATION VARIALBES\nconst float loop_len = 4.;\nconst float loop_reps = 3.;\nfloat curve_a = 0.;\nfloat curve_b = 0.;\nfloat curve_c = 0.; \n \n\n// DEFINE A CURSED \"RECURSIVE SDF LEVEL\" FUNCTION\n#define FN(sdf_in,sdf_out,cutting_plane,mod_a,mod_b) float sdf_out(vec3 p){ \\\n    vec3 cuttingplane = normalize(cutting_plane);                           \\\n    float cp_sdf = dot(p,normalize(cutting_plane));                         \\\n    float d = max(sdf_in( erot(p,cuttingplane, mod_a)), -cp_sdf  );         \\\n    float db = max(sdf_in( erot(p,cuttingplane,- mod_b)),cp_sdf);           \\\n    return min(d,db);                                                       \\\n} \n\n// DEFINE RECURSIVE SDFS\nFN(sdBox,iter_a,vec3(1),curve_a*0.6,curve_a*0.2)\nFN(iter_a,iter_b,vec3(-0.5,0.2,0.6),curve_b*0.2,curve_b*0.7)\nFN(iter_b,iter_c,vec3(0.5,-0.2,0.6),curve_c*0.7,curve_c*0.5)\n\nfloat map(vec3 p){    \n    p = erot(p,normalize(vec3(0,1,0)),iMouse.x/iResolution.x*7.);\n    \n    // ANIMATION LOGIC\n    float t = mod(iTime,loop_len);\n    float t_phase = t/loop_len;\n    float t_phase_step = 1./(loop_reps+1.);\n    t_phase *= 1. - saturated_smoothstep((t_phase - t_phase_step*3.)/t_phase_step); \n    curve_a = saturated_smoothstep(t_phase/t_phase_step);\n    curve_b = saturated_smoothstep((t_phase- t_phase_step)/t_phase_step);\n    curve_c = saturated_smoothstep((t_phase- t_phase_step*2.)/t_phase_step);\n    \n    \n    // ACTUAL SDF CALL\n    return iter_c(p);\n}\n\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0);\n    return normalize(vec3(\n        map(p+t.xyy) - map(p-t.xyy),\n        map(p+t.yxy) - map(p-t.yxy),\n        map(p+t.yyx) - map(p-t.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 rd = normalize(vec3(uv,1));\n    \n    vec3 ro = vec3(0,0,-2);\n    \n    vec3 p = ro;\n    \n    \n    float t = 0.;\n    bool hit = false;\n    \n    for(float i = 0.; i < 150.; i++){\n        float d = map(p);\n        \n        if(d < 0.001){\n            hit = true;\n            break;\n        }\n        \n        p = ro+ rd*(t+=d);\n    }\n    \n    if(hit){\n        vec3 n = getNormal(p);\n        col = 0.5 + n*0.5;\n    }\n    col = pow(max(col,0.),vec3(0.6545));\n    \n\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}