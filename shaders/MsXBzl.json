{
    "Shader": {
        "info": {
            "date": "1497894864",
            "description": "PBR Lighting using Cook-Torrance Specular and Lambertian Diffuse. Reference for others and future me.\n\nNothing new, but needed a lighting model for in-development shaders.\n\nNo attempt was made to shorten character count as this is a reference piece.",
            "flags": 32,
            "hasliked": 0,
            "id": "MsXBzl",
            "likes": 50,
            "name": "PBR Lighting Demo",
            "published": 3,
            "tags": [
                "lighting",
                "demo",
                "ibl",
                "pbr"
            ],
            "usePreview": 1,
            "username": "ssell",
            "viewed": 3761
        },
        "renderpass": [
            {
                "code": "/** \n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n\n//------------------------------------------------------------------------------------------\n// Defines to see individual lighting elements\n//------------------------------------------------------------------------------------------\n\n//#define DIFFUSE_ONLY\n//#define SPECULAR_ONLY\n//#define SPECULAR_NDF_ONLY\n//#define SPECULAR_ATTEN_ONLY\n//#define SPECULAR_FRESNEL_ONLY\n\n/*\n * -----------\n * - Sources -\n * -----------\n * \n *   Real Shading in Unreal Engine 4\n *   http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n *\n *   Physically Based Rendering - Cookâ€“Torrance\n *   http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\n * \n *   PBR Theory\n *   https://learnopengl.com/#!PBR/Theory\n *\n * -----------------\n * - Channel Input -\n * -----------------\n *\n *   iChannel0: UI Input/Render (from Buf A)\n *   iChannel1: Roughness Texture\n *   iChannel2: Albedo Texture\n *   iChannel3: Ambient IBL Cubemap\n *\n * -----------\n * - Sliders -\n * -----------\n *\n *   Roughness: [0.0, 1.0] Controls the microfacet intensity. Higher roughness results\n *   in the specular lighting being spread across a great part of the surface. Low roughness\n *   results in a smoother surface and more focused/tight specular highlights.\n *\n *   Metallic: [0.0, 1.0] Controls the incident fresnel term. Performs a mix(0.04, 1.0, ).\n *   Insulators (dielectrics) such as organics, plastic, stone, etc. have a (much) lower\n *   incident fresnel value, and thus a lower metallic value. Conductors such as metals have\n *   a higher incident fresnel term and thus a higher metallic value. The final fresnel value\n *   also controls the ratio between (diffuse:specular) lighting, and thus a lower metallic\n *   value results in a greater diffuse (and smaller specular) contribution.\n *\n *   DirectIntens: [0.0, 4.0] Controls an intensity modifier applied to the direct lighting\n *   (the directional light source). \n *\n *   AmbientIntens: [0.0, 4.0] Controls an intensity modifier applied to the ambient lighting\n *   (the environmental map reflection).\n *\n *   Rough: [Flat, Texture] If flat, the value specified in 'Roughness' will be used as the\n *   roughness parameter in lighting calculations. If 'Texture', then the roughness parameter\n *   is calculated as (texture(iChannel1).r * Roughness).\n *\n *   Diff: [Normals, Texture] If 'Normals', then adjusted surface normals will be used as the\n *   albedo color. Otherwise, the texture in iChannel2 will be sampled.\n *\n *   IBL Steps: [1.0, 128.0] Number of steps used to calculate the IBL (Image-Based Lighting)\n *   ambient light value. Turn both Roughness and Metallic up and see the benefit of a large \n *   number of IBL steps.\n *\n *   HDR On: [Off, On] Enables/disables the HDR.\n *\n * -----------------\n * - Lighting Flow -\n * -----------------\n *\n * *(In Progress)*\n *\n * This section will give a high-level overview of the lighting calculations\n * and the order in which they occur. This should help provide a basic idea\n * of how the various functions interact with each other.\n *\n * Before I begin, there are two things to note:\n *\n *     (1) The individual functions have more detailed/specific comments.\n *     (2) The cited references above cover this topic much better than me.\n *\n * Now, to begin, the general equation for PBR lighting is:\n *\n *     light = (kD * diffuse) + (kS * specular)\n *\n * Where kD:kS represent the ratio between diffuse and specular lighting. \n * Due to the pesky law called the Conservation of Energy, our outgoing \n * light can not exceed our incoming light and thus (kD + kS) == 1.0.\n *\n *   --------------------\n *   - Diffuse Lighting -\n *   --------------------\n *\n *   Diffuse light is the light that is refracted: enters the body of the substance,\n *   scatters internally, and then eventually exits the substance. Along the way some\n *   of the light is absorbed and transformed into heat.\n *\n *   The extent to which the light scatters, and the randomness of it, allows it to be\n *   approximated as being equal from all angles. And thus the diffuse term does not\n *   vary as the viewing angle changes.\n *\n *   This shader calculates the diffuse term using the simple Lambertian function of:\n *\n *       diffuse = (albedo / pi)\n *       albedo = sample of texture in iChannel2\n *\n *   There are other more accurate and complex diffuse calculations, but the Lambertian\n *   is relatively accurate and, most importantly, extremely cheap.\n *\n *   The ratio of diffuse lighting is calculated as:\n *\n *       kD = (1.0 - kS)\n *\n *   Where kS is detailed later.\n *\n *   -----------------------------\n *   - Specular Lighting General -\n *   -----------------------------\n *\n *   The specular lighting component is split into two different variations:\n *\n *       (1) Analytical\n *       (2) Image-Based Lighting (IBL)\n *\n *   The scene in this shader makes use of one of each.\n *\n *   In general, specular lighting is the light that is reflected off of the\n *   surface and does not enter into the body. As it does not enter the body,\n *   it does not get absorbed or take on the albedo color. \n *\n *   Also, unlike the diffuse component, it is based on view angle in addition\n *   to the surface normal and light direction.\n *\n *   Specular light is composed of three distinct parts: normal distribution function (NDF),\n *   geometric attenuation, and fresnel reflectivity.\n *\n *   These combined create the Bidirectional Reflectance Distribution Function (BRDF).\n *\n *   For both modes of specular lighting, kS is equal to the Fresnel reflectance.\n *   \n *   --------------\n *   - Analytical -\n *   --------------\n *\n *   The single directional light in the scene makes use of analytical specular lighting.\n *   The formula for analytical lighting is:\n *\n *       = (NDF * Fresnel * Attenuation) / (4.0 * dot(normal, toLight) * dot(normal, toView))\n *\n *   ------------------------\n *   - Image-Based Lighting -\n *   ------------------------\n * \n *   For ambient lighting we make use of an environmental map.\n *\n *   A hemispherical integration is approximated using a Riemann Sum. For each step\n *   of the sum, a light vector to the environmental map is sampled. These sample directions\n *   are generated using the Hammersley distribution, and are averaged for the total\n *   ambient contribution.\n */\n\n#define Epsilon         0.001\n#define NearClip        Epsilon\n#define FarClip         20.0\n\n#define PI              3.14159\n#define ONE_OVER_PI     0.31831\n#define ONE_OVER_TWO_PI 0.15915\n\nfloat Roughness         = 0.0;\nfloat Metallic          = 0.0;\nfloat DirectIntensity   = 1.0;\nfloat AmbientIntensity  = 1.0;\n\nfloat RoughTextureOn    = 1.0;\nfloat AlbedoTextureOn   = 1.0;\nfloat IBLSteps          = 1.0;\n\n//------------------------------------------------------------------------------------------\n// Math Functions\n//------------------------------------------------------------------------------------------\n\n// if(a > b) { return ra; } else { return rb; }\nfloat StepValue1(float a, float b, float ra, float rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\nvec3 StepValue3(float a, float b, vec3 ra, vec3 rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\n//------------------------------------------------------------------------------------------\n// UI Functions\n//------------------------------------------------------------------------------------------\n\nfloat UISlider(int id)\n{\n    return texture(iChannel0, vec2(float(id) + 0.5, 0.5) / iResolution.xy).r;\n}\n\nvec4 RenderSliders(in vec2 uv)\n{\n    Roughness        = clamp(UISlider(0), 0.001, 1.0);\n    Metallic         = clamp(UISlider(1), 0.0, 1.0);\n    DirectIntensity  = clamp(UISlider(2), 0.0, 1.0) * 4.0;\n    AmbientIntensity = clamp(UISlider(3), 0.0, 1.0) * 4.0;\n    \n    RoughTextureOn   = clamp(UISlider(4), 0.0, 1.0);\n    AlbedoTextureOn  = clamp(UISlider(5), 0.0, 1.0);\n    IBLSteps         = 1.0 + clamp(UISlider(6), 0.0, 1.0) * 64.0;\n    \n    return texture(iChannel0, uv);\n}\n\n//------------------------------------------------------------------------------------------\n// Ray Structures and Functions\n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct RayHit\n{\n    bool  hit;\n  \tvec3  surfPos;\n    vec3  surfNorm;\n    float material;\n};\n    \n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n//------------------------------------------------------------------------------------------\n// SDF Functions\n//------------------------------------------------------------------------------------------\n\nfloat Scene_SDF(vec3 point, inout RayHit hit)\n{\n  \tfloat sdf = FarClip;\n    \n    float circle = length(abs(point - vec3(0.0, 0.0, 0.0))) - 1.0;\n    hit.material = StepValue1(sdf, circle, 1.0, hit.material); \n    sdf = min(sdf, circle);\n    \n    return circle;\n}\n\nvec3 Scene_Normal(vec3 point)\n{\n    RayHit hit;\n\n\treturn normalize(vec3(\n        (Scene_SDF(vec3(point.x + Epsilon, point.y, point.z), hit) - Scene_SDF(vec3(point.x - Epsilon, point.y, point.z), hit)),\n        (Scene_SDF(vec3(point.x, point.y + Epsilon, point.z), hit) - Scene_SDF(vec3(point.x, point.y - Epsilon, point.z), hit)),\n        (Scene_SDF(vec3(point.x, point.y, point.z + Epsilon), hit) - Scene_SDF(vec3(point.x, point.y, point.z - Epsilon), hit))));\n}\n\n//------------------------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------------------------\n\nRayHit RaymarchScene(in Ray ray)\n{\n    RayHit hit;\n    \n    hit.hit      = false;\n    hit.material = 0.0;\n    \n    float sdf = FarClip;\n    \n    for(float depth = NearClip; depth < FarClip; )\n    {\n    \tvec3 pos = ray.origin + (ray.direction * depth);\n        \n        sdf = Scene_SDF(pos, hit);\n        \n        if(sdf < Epsilon)\n        {\n            hit.hit      = true;\n            hit.surfPos  = pos;\n            hit.surfNorm = Scene_Normal(pos);\n            \n            return hit;\n        }\n        \n        depth += sdf;\n    }\n    \n    return hit;\n}\n\n//------------------------------------------------------------------------------------------\n// Texture Sampling\n//------------------------------------------------------------------------------------------\n\n// Source: https://www.shadertoy.com/view/ld3SRr\nvec4 SampleSphere(vec3 p, vec3 n, sampler2D sampler)\n{\n    p = fract(p * 0.5 +0.5);\n    \n    float sw = 0.1;\n    vec3 stitchingFade = vec3(1.)-smoothstep(vec3(0.5-sw),vec3(0.5),abs(p-0.5));\n    \n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    vec4 cX = abs(n.x)*texture(sampler,p.zy);\n    vec4 cY = abs(n.y)*texture(sampler,p.xz);\n    vec4 cZ = abs(n.z)*texture(sampler,p.xy);\n    \n    return  vec4(stitchingFade.y*stitchingFade.z*cX.rgb\n                +stitchingFade.x*stitchingFade.z*cY.rgb\n                +stitchingFade.x*stitchingFade.y*cZ.rgb,cX.a+cY.a+cZ.a)/fTotal;\n}\n\nfloat SampleRoughness(in vec3 p, in vec3 n)\n{\n    return SampleSphere(p, n, iChannel1).r;\n}\n\nvec3 SampleAlbedo(in vec3 p, in vec3 n)\n{\n    return SampleSphere(p, n, iChannel2).rgb;\n}\n\nvec3 SampleEnvironment(in vec3 reflVec)\n{\n    return texture(iChannel3, reflVec).rgb;\n}\n\n//------------------------------------------------------------------------------------------\n// Light Structures and Functions\n//------------------------------------------------------------------------------------------\n\n/**\n * Calculates the vector (h) half-way inbetween the light (l) and view (v).\n *\n *       v\\   |h  /l\n *         \\  |  /\n *          \\ | /\n *           \\|/\n * -------------------------\n */\nvec3 CalculateHalfVector(\n    in vec3 toLight,\n    in vec3 toView)\n{\n    return normalize(toLight + toView);\n}\n\n/**\n * GGX/Trowbridge-Reitz NDF\n *\n * Calculates the specular highlighting from surface roughness.\n *\n * Roughness lies on the range [0.0, 1.0], with lower values\n * producing a smoother, \"glossier\", surface. Higher values \n * produce a rougher surface with the specular lighting distributed\n * over a larger surface area.\n *\n * See it graphed at:\n * https://www.desmos.com/calculator/pjzk3yafzs\n */\nfloat CalculateNDF(\n    in vec3  surfNorm,\n    in vec3  halfVector,\n    in float roughness)\n{\n    float a = (roughness * roughness);\n    float halfAngle = dot(surfNorm, halfVector);\n    \n    return (a / (PI * pow((pow(halfAngle, 2.0) * (a - 1.0) + 1.0), 2.0)));\n}\n\n/**\n * GGX/Schlick-Beckmann microfacet geometric attenuation.\n *\n * The attenuation is modified by the roughness (input as k)\n * and approximates the influence/amount of microfacets in the surface.\n * A microfacet is a sub-pixel structure that affects light\n * reflection/occlusion.\n */\nfloat CalculateAttenuation(\n    in vec3  surfNorm,\n    in vec3  vector,\n    in float k)\n{\n    float d = max(dot(surfNorm, vector), 0.0);\n \treturn (d / ((d * (1.0 - k)) + k));\n}\n\n/**\n * GGX/Schlick-Beckmann attenuation for analytical light sources.\n */\nfloat CalculateAttenuationAnalytical(\n    in vec3  surfNorm,\n    in vec3  toLight,\n    in vec3  toView,\n    in float roughness)\n{\n    float k = pow((roughness + 1.0), 2.0) * 0.125;\n    \n    float lightAtten = CalculateAttenuation(surfNorm, toLight, k);\n    float viewAtten  = CalculateAttenuation(surfNorm, toView, k);\n    \n    return (lightAtten * viewAtten);\n}\n\n/**\n * GGX/Schlick-Beckmann attenuation for IBL light sources.\n * Uses Disney modification of k to reduce hotness.\n */\nfloat CalculateAttenuationIBL(\n    in float roughness,\n    in float normDotLight,          // Clamped to [0.0, 1.0]\n    in float normDotView)           // Clamped to [0.0, 1.0]\n{\n    float k = pow(roughness, 2.0) * 0.5;\n    \n    float lightAtten = (normDotLight / ((normDotLight * (1.0 - k)) + k));\n    float viewAtten  = (normDotView / ((normDotView * (1.0 - k)) + k));\n    \n    return (lightAtten * viewAtten);\n}\n\n/**\n * Calculates the Fresnel reflectivity.\n * The metalic parameter controls the fresnel incident value (fresnel0).\n */\nvec3 CalculateFresnel(\n    in vec3 surfNorm,\n    in vec3 toView,\n    in vec3 fresnel0)\n{\n\tfloat d = max(dot(surfNorm, toView), 0.0); \n    float p = ((-5.55473 * d) - 6.98316) * d;\n        \n    return fresnel0 + ((1.0 - fresnel0) * pow(1.0 - d, 5.0));\n}\n\n/**\n * Standard Lambertian diffuse lighting.\n */\nvec3 CalculateDiffuse(\n    in vec3 albedo)\n{                              \n    return (albedo * ONE_OVER_PI);\n}\n\n/**\n * Cook-Torrance BRDF for analytical light sources.\n */\nvec3 CalculateSpecularAnalytical(\n    in    vec3  surfNorm,            // Surface normal\n    in    vec3  toLight,             // Normalized vector pointing to light source\n    in    vec3  toView,              // Normalized vector point to the view/camera\n    in    vec3  fresnel0,            // Fresnel incidence value\n    inout vec3  sfresnel,            // Final fresnel value used a kS\n    in    float roughness)           // Roughness parameter (microfacet contribution)\n{\n    vec3 halfVector = CalculateHalfVector(toLight, toView);\n    \n    float ndf      = CalculateNDF(surfNorm, halfVector, roughness);\n    float geoAtten = CalculateAttenuationAnalytical(surfNorm, toLight, toView, roughness);\n    \n    sfresnel = CalculateFresnel(surfNorm, toView, fresnel0);\n    \n    vec3  numerator   = (sfresnel * ndf * geoAtten);\n    float denominator = 4.0 * dot(surfNorm, toLight) * dot(surfNorm, toView);\n    \n#ifdef SPECULAR_NDF_ONLY\n    return vec3(ndf);\n#elif defined(SPECULAR_ATTEN_ONLY)\n    return vec3(geoAtten);\n#elif defined(SPECULAR_FRESNEL_ONLY)\n    return sfresnel;\n#else\n    return (numerator / denominator);\n#endif\n}\n\n/**\n * Generates a 2D directional vector on the hemisphere from the Hammersley point set.\n * Source: http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n */\nvec2 Hammersley(float i, float numSamples)\n{   \n    uint bits = uint(i);\n    \n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    \n    float radicalInverseVDC = float(bits) * 2.3283064365386963e-10; // / 0x100000000\n    \n    return vec2((i / numSamples), radicalInverseVDC);\n} \n\n/**\n * Importance Sampling to solve the radiance integral.\n *\n * We use importance sampling (as opposed to uniform or random (Monte Carlo)) to\n * generate light sample vectors that are biased to the microsurface halfway\n * vector based on the roughness. \n */\nvec3 ImportanceSample(\n    in vec2  xi,\n    in float roughness,\n    in vec3  surfNorm)\n{\n\tfloat a = (roughness * roughness);\n    \n    // Spherical Coordinates to Cartesian\n    float phi = 2.0 * PI * xi.x;\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));\n    float sinTheta = sqrt(1.0 - (cosTheta * cosTheta));\n    \n    vec3 H = vec3((sinTheta * cos(phi)), (sinTheta * sin(phi)), cosTheta);\n    \n    // From Tangent-Space to World-Space\n    vec3 upVector = StepValue3(0.999, surfNorm.z, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    vec3 tangentX = normalize(cross(upVector, surfNorm));\n    vec3 tangentY = cross(surfNorm, tangentX);\n    \n    return ((tangentX * H.x) + (tangentY * H.y) + (surfNorm * H.z));\n}\n\n/**\n * Performs the Riemann Sum approximation of the IBL lighting integral.\n *\n * The ambient IBL source hits the surface from all angles. We average\n * the lighting contribution from a number of random light directional\n * vectors to approximate the total specular lighting.\n *\n * The number of steps is controlled by the 'IBL Steps' global.\n */\nvec3 CalculateSpecularIBL(\n    in    vec3  surfNorm,\n    in    vec3  toView,\n    in    vec3  fresnel0,\n    inout vec3  sfresnel,\n    in    float roughness)\n{\n    vec3 totalSpec = vec3(0.0);\n    vec3 toSurfaceCenter = reflect(-toView, surfNorm);\n    \n    for(float i = 0.0; i < IBLSteps; ++i)\n    {\n        // The 2D hemispherical sampling vector\n    \tvec2 xi = Hammersley(i, IBLSteps);\n        \n        // Bias the Hammersley vector towards the specular lobe of the surface roughness\n        vec3 H = ImportanceSample(xi, roughness, surfNorm);\n        \n        // The light sample vector\n        vec3 L = (2.0 * dot(toView, H) * H) - toView;\n        \n        float NoV = clamp(dot(surfNorm, toView), 0.0, 1.0);\n        float NoL = clamp(dot(surfNorm, L), 0.0, 1.0);\n        float NoH = clamp(dot(surfNorm, H), 0.0, 1.0);\n        float VoH = clamp(dot(toView, H), 0.0, 1.0);\n        \n        if(NoL > 0.0)\n        {\n            vec3 color = SampleEnvironment(L);\n            \n            float geoAtten = CalculateAttenuationIBL(roughness, NoL, NoV);\n            vec3  fresnel = CalculateFresnel(surfNorm, toView, fresnel0);\n            \n            sfresnel += fresnel;\n#ifdef SPECULAR_NDF_ONLY\n            totalSpec += 0.0;\n#elif defined(SPECULAR_ATTEN_ONLY)\n            totalSpec += geoAtten / (NoH * NoV);\n#elif defined(SPECULAR_FRESNEL_ONLY)\n            totalSpec += fresnel / (NoH * NoV);\n#else\n            totalSpec += (color * fresnel * geoAtten * VoH) / (NoH * NoV);\n#endif\n        }\n    }\n    \n    sfresnel /= IBLSteps;\n    \n    return (totalSpec / IBLSteps);\n}\n\n/**\n * Calculates the total light contribution for the analytical light source.\n */\nvec3 CalculateLightingAnalytical(\n    in vec3  surfNorm,\n    in vec3  toLight,\n    in vec3  toView,\n    in vec3  albedo,\n    in float roughness)\n{\n    vec3 fresnel0 = mix(vec3(0.04), albedo, Metallic);\n    vec3 ks       = vec3(0.0);\n    vec3 diffuse  = CalculateDiffuse(albedo);\n    vec3 specular = CalculateSpecularAnalytical(surfNorm, toLight, toView, fresnel0, ks, roughness);\n    vec3 kd       = (1.0 - ks);\n    \n    float angle = clamp(dot(surfNorm, toLight), 0.0, 1.0);\n    \n#ifdef DIFFUSE_ONLY\n\treturn diffuse * angle;\n#elif defined(SPECULAR_ONLY) || defined(SPECULAR_NDF_ONLY) || defined(SPECULAR_ATTEN_ONLY) || defined(SPECULAR_FRESNEL_ONLY)\n    return specular * angle;\n#else\n    return ((kd * diffuse) + specular) * angle;\n#endif\n}\n\n/**\n * Calculates the total light contribution from the ambient IBL environmental map.\n */\nvec3 CalculateLightingIBL(\n    in vec3  surfNorm,\n    in vec3  toView,\n    in vec3  albedo,\n    in float roughness)\n{\n    vec3 fresnel0 = mix(vec3(0.04), albedo, Metallic);\n    vec3 ks       = vec3(0.0);\n    vec3 diffuse  = CalculateDiffuse(albedo);\n    vec3 specular = CalculateSpecularIBL(surfNorm, toView, fresnel0, ks, roughness);\n    vec3 kd       = (1.0 - ks);\n    \n#ifdef DIFFUSE_ONLY\n\treturn diffuse;\n#elif defined(SPECULAR_ONLY) || defined(SPECULAR_NDF_ONLY) || defined(SPECULAR_ATTEN_ONLY) || defined(SPECULAR_FRESNEL_ONLY)\n    return specular;\n#else\n    return ((kd * diffuse) + specular);\n#endif\n}\n\n\n//------------------------------------------------------------------------------------------\n// Material\n//------------------------------------------------------------------------------------------\n\nvec3 Material_Apply(in RayHit hit, vec3 toView)\n{\n    vec3 albedo = StepValue3(AlbedoTextureOn, 0.5, SampleAlbedo(hit.surfPos, hit.surfNorm), (hit.surfNorm + 1.0) * 0.5);\n    float roughness = StepValue1(RoughTextureOn, 0.5, SampleRoughness(hit.surfPos, hit.surfNorm) * Roughness, Roughness);\n    \n    vec3 lighting = \n        CalculateLightingAnalytical(\n            hit.surfNorm,\n            normalize(vec3(0.3, 1.0, 0.0)),\n            toView,\n            albedo,\n            roughness) * DirectIntensity;\n    \n    lighting +=\n        CalculateLightingIBL(\n            hit.surfNorm,\n            toView,\n            albedo,\n            roughness) * AmbientIntensity;\n\n    return lighting;\n}\n\n//------------------------------------------------------------------------------------------\n// Misc Effects\n//------------------------------------------------------------------------------------------\n\nvec3 HDR(in vec3 color)\n{\n    // Arbitrary HDR ...\n    return StepValue3(UISlider(7), 0.5, vec3(1.0) - exp(-color), color);   \n}\n\nfloat Vignette(in vec2 uv)\n{\n    return 0.2 + (0.8 * pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.2));\n}\n\nvec3 OrbitAround(vec3 origin, float radius, float rate)\n{\n  \treturn vec3((origin.x + (radius * cos(iTime * rate))),\n                (origin.y),\n                (origin.z + (radius * sin(iTime * rate))));\n}\n\nvec3 Render(vec2 fragCoord, Camera camera)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    vec3 final = mix(vec3(0.0), vec3(0.15), uv.y);\n    \n    Ray ray = Camera_GetRay(camera, uv);\n    RayHit rayHit = RaymarchScene(ray);\n    \n    if(rayHit.hit)\n    {\n        final = Material_Apply(rayHit, -ray.direction);\n    }\n    \n    return final;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nconst vec2 AAOffsets[4] = vec2[](\n    vec2(-0.1,  0.4),\n    vec2( 0.4,  0.1),\n    vec2( 0.1, -0.4),\n    vec2(-0.4, -0.1));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    vec4 sliders = RenderSliders(fragCoord.xy / iResolution.xy);\n    \n    Camera camera = Camera_LookAt(OrbitAround(vec3(0.0, -0.175, 0.0), 4.0, 0.5), vec3(0.0, -0.175, 0.0));\n    \n    vec3 sceneColor = (Render(fragCoord + AAOffsets[0], camera) + \n                       Render(fragCoord + AAOffsets[1], camera) +\n                       Render(fragCoord + AAOffsets[2], camera) +\n                       Render(fragCoord + AAOffsets[3], camera)) * 0.25;\n    \n    vec3 finalColor = HDR(sceneColor);\n    \n    finalColor *= Vignette(uv);                               // Apply vignette\n    finalColor  = mix(finalColor, sliders.rgb, sliders.a);    // Display the sliders\n    \n    fragColor.rgb = finalColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Source: https://www.shadertoy.com/view/ldKSDm\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 140.\n#define WIDGET_COLOR vec3(0.0)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\nvoid setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uv = fragCoord.xy;\n    \n    int rx = int(iResolution.x * 0.5) - 295;\n    int ry = int(iResolution.y) - 30;\n    \n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n        \n   \t//-----------------------------------------------------------\n    // Top Row\n    //-----------------------------------------------------------\n    \n    _slider(rx,       ry, 0, 0.10) _R _o _u _g _h _n _e _s _s\n    _slider(rx + 150, ry, 1, 0.90) _M _e _t _a _l _l _i _c\n    _slider(rx + 300, ry, 2, 0.60) _D _i _r _e _c _t _I _n _t _e _n _s\n    _slider(rx + 450, ry, 3, 0.15) _A _m _b _i _e _n _t _I _n _t _e _n _s\n        \n    //-----------------------------------------------------------\n    // Bottom Row\n    //-----------------------------------------------------------\n    \n    ry = int(iResolution.y) - 10;\n    \n    if(uiSlider(4).r <= 0.5)\n    {\n        _slider(rx, ry, 4, 1.0) _R _o _u _g _h _spc _F _l _a _t\n    }\n    else\n    {\n        _slider(rx, ry, 4, 0.0) _R _o _u _g _h _spc _T _e _x _t _u _r _e\n    }\n        \n    if(uiSlider(5).r <= 0.5) \n    { \n        _slider(rx + 150, ry, 5, 1.0) _D _i _f _f _spc _N _o _r _m _a _l _s\n    }\n    else \n    { \n        _slider(rx + 150, ry, 5, 1.0) _D _i _f _f _spc _T _e _x _t _u _r _e \n    }\n    \n    _slider(rx + 300, ry, 6, 0.0625) _I _B _L _spc _S _t _e _p _s\n    \n    if(uiSlider(7).r <= 0.5)\n    {\n    \t_slider(rx + 450, ry, 7, 1.0) _H _D _R _spc _O _f _f\n    }\n    else\n    {\n        _slider(rx + 450, ry, 7, 1.0) _H _D _R _spc _O _n\n    }\n        \n        \n    fragColor = min(col.rgba, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}