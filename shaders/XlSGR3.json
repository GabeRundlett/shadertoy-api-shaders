{
    "Shader": {
        "info": {
            "date": "1446991137",
            "description": "My first attempt at creating a raycasted scene using intersection equations and all. Not optimized. \nAlso could anyone tell me why lines 80 and 89 doesn't work (when uncommented)?",
            "flags": 0,
            "hasliked": 0,
            "id": "XlSGR3",
            "likes": 3,
            "name": "Raycasted spheres",
            "published": 3,
            "tags": [
                "raycast"
            ],
            "usePreview": 0,
            "username": "Aj_",
            "viewed": 2343
        },
        "renderpass": [
            {
                "code": "const int NUM_PRIMS = 4;\t//number of spheres in the scene\nconst int NUM_LIGHTS = 4; //number of lights in the scene\nconst float FAR = 100.;\t//far clipping plane distance\n\n#define MRX(X) mat3(1., 0., 0. ,0., cos(X), -sin(X) ,0., sin(X), cos(X))\t//x axis rotation matrix\n#define MRY(X) mat3(cos(X), 0., sin(X),0., 1., 0.,-sin(X), 0., cos(X))\t//y axis rotation matrix\t\n#define MRZ(X) mat3(cos(X), -sin(X), 0.\t,sin(X), cos(X), 0.\t,0., 0., 1.)\t//z axis rotation matrix\n#define MRF(X,Y,Z) MRZ(Z)*MRY(Y)*MRX(X)\t//x,y,z combined rotation macro\n\nstruct Primitive {\t//structure for representing primitves\n    vec3 forward;\t//forward of the primitive. Only applicable to planes\n    float id;\t//id for indentifying the object\n    vec3 pos;\t//positionof the object in the world space\n    vec3 normal;\t//surface normal at the point of intersection\n    float size;\t//size of the object. only applicable to some primitive like spheres\n    bool isIntersected ;\t//used to store ray intersection status\n    vec3 intersecPoint;\t//point of intersection by the ray\n    float specular;  //specular reflection value for the primitive\n};  \n    \n\nstruct Light {\t//structuer for storing light info\n    vec3 pos;\t//position of the light\n    vec3 col;\t//color of the light\n};\n\n\n//sphere-ray intersection solver\n/*\tsph -> reference to the primitive object. (sphere in this case)\n *\trayOr -> origin position of the ray\n *\trayDir -> direction of the ray\n *\tsmooth -? extra smoothing boundary for calculating intersection.\n */\n\t\nvoid getSphereIntersec(inout Primitive sph, vec3 rayOr, vec3 rayDir, float smoothVal) {\n    vec3 rx = rayOr-sph.pos;\n    float vrx = dot(rayDir, rx);\n    float drx = distance(rayOr,sph.pos);\n    float v = vrx*vrx \n         - (drx*drx - (sph.size+smoothVal)*(sph.size+smoothVal)); //sphere line intersection equation    \n    float ld = -vrx; //sphere line intersection equation\n\tfloat sqrtv = sqrt(abs(v)); \n    float dist1 = ld + sqrtv; //dist to intersection point1\n    float dist2 = ld - sqrtv; //dist to intersection point2\n    sph.intersecPoint =rayOr+ min(dist1, dist2) * rayDir; //calculating the closest intersection point   \t\n    sph.isIntersected = v<0.?false:true;\t//set whether the sphere was interseced \n    sph.normal =normalize(sph.intersecPoint - sph.pos); //set the surface normal at the intersection point\n      \n}\n//plane-ray intersection solver\n/*\tplane -> reference to the plane object. \n *\trayOr -> origin position of the ray\n *\trayDir -> direction of the ray\t\n */\nvoid getPlaneIntersec(inout Primitive plane, vec3 rayOr, vec3 rayDir) {\n    float rdn = dot( rayDir, plane.normal); //plane line intersection\n    float frdn = rdn==0.?1.:rdn; \n    float dfc = dot(plane.normal, (plane.pos - rayOr))/frdn; //dist of plane from ray origin\n     plane.intersecPoint = rayOr + dfc*rayDir; //intersection point of plane and ray\n   \n    plane.isIntersected = rdn==0.?false:true; //whether or not the plane was intersected, without considering its size\n    vec3 dVec = vec3(plane.intersecPoint - plane.pos); //distance from the center of the plane to the point of intersection\n    plane.isIntersected = (plane.isIntersected&&(abs(dVec.x)\t//if the point of intersection is outside the plane \n                          +abs(dVec.y)+abs(dVec.z)<=plane.size))?true:false;\t//set as not intersected, otherwise intersected\n    \n    \n}\n\n\nfloat minLen; //distance from the ray origin to the closest intersection point\nPrimitive nope; //dummy 'null' equivalent object\nPrimitive prim ; //temporary primitive object representing the intersected object\n    \n//Checks which primitive in prims is first intersected by the ray and returns it\n//rayOr -> Origin of the ray\n//rayDir -> direction of the ray\n//prims -> primitive array\n //smooth -> smoothness value to send to the intersection solver function\nPrimitive processRayIntersect(vec3 rayOr, vec3 rayDir,inout Primitive prims[NUM_PRIMS], float smoothVal) {\n     \n    minLen = FAR+1.; //initialize minLen to the farthest possible distance   \n    prim = nope;   //no object has been intersected yet\n    \n       float tl; \n    for(int i=1;i<NUM_PRIMS;i++) { //for every primitive in prims\n       \n    \tprims[i].id = float(i);\n        getSphereIntersec(prims[i], rayOr, rayDir, smoothVal); //process sphere-ray intersection\n        tl = distance(rayOr, prims[i].intersecPoint);\t//get distance from the ray origin to the intersection point\n        minLen = prims[i].isIntersected&&tl<=minLen?tl:minLen; //if the current primitive was intersected, and t1 is less than minLen, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//set minLen as t1\n        \n        if(tl==minLen) {\t//if minLen is same as t1\n            prim = prims[i];\t//this is the first primitive the ray has encountered\n        }\n    }\n    \n    getPlaneIntersec(prims[0], rayOr ,rayDir); // process plane-ray intersection\n    tl = distance(rayOr, prims[0].intersecPoint); // distance from ray origin to point of intersection on plane\n    minLen = prims[0].isIntersected&&tl<=minLen?tl:minLen; //if the plane has been intersected and if t1 is less than minLen\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// then set t1 as minLen\n        \n    if(tl==minLen) {    //if t1 is minLen\n        prim = prims[0]; //the object that is interected first is the plane\n\n    }\n    return prim; //return the primitive that was that is first intersected by the ray\n    \n   \n    }\n\n\n\t\n\t//Creates a scene containing 3 spheres, a plane and some lights and then calls ray-primitive intersection\n\t// solvers, calculates reflection value for the intersection point and then sets the pixel color\n\t//rayOr -> ray origin\n\t//rayDir -> ray direction\n\t//vec3 sphPos -> pre defined position for center sphere\n\t\nvec3 makeScene(vec3 rayOr,vec3 rayDir, vec3 sphPos) {\n   \n  \n    Primitive sph1, plane1, sph2, sph3, sph4, sph5; //Spheres\n    sph3.size = .18;  //setting sphere size\n    sph3.pos =sphPos + vec3(0., 0., sph3.size);\t//sphere position\n    \n    sph1.size = .08;\n    sph1.pos = vec3(sph3.pos.x-(sph1.size+sph3.size)*1.02,sph3.pos.y, sph1.size-.001);\n    sph2.size =.18;\n    sph2.pos = vec3(sph3.pos.x+(sph3.size+sph2.size)*1.02,sph3.pos.y, sph3.size-.001);\n    sph1.specular = sph2.specular = sph3.specular = .5;    //specular reflection values for spheres\n    \n    plane1.pos = vec3(vec2(sph3.pos.xy), sph1.pos.z - sph1.size+.005); //plane position\n    plane1.normal = normalize(vec3(0., 0., .1)); //plane surface normal\n    plane1.size = 1.;  //plane's side length\n    \n    Primitive prims[NUM_PRIMS];\n    \n    prims[0] = plane1; //adding primitives into an array\n    prims[1] = sph1;\n    prims[2] = sph2;\n    prims[3] = sph3;    \n    //prims[4] = sph4;\n    //prims[5] = sph5;\n       \n    \n  \n    Primitive rayPrim = processRayIntersect(rayOr, rayDir, prims, 0.); //perform camera ray intersection check on all primitives\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //rayPrim is the primitive that was first intersected by the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //camera ray\n    Light lights[NUM_LIGHTS]; //lights array\n    lights[0].pos = vec3(sph2.pos.x, sph2.pos.y+.9, .9);//pos of light1;\n    lights[0].col = vec3(.1, .4, .2)*2.; //set light color\n    lights[1].pos =  vec3(-.8, .3, .4);\n    lights[1].col = vec3(.4, .1, .1)*3.;\n    lights[2].pos = vec3(1.8, .2, .5);\n    lights[2].col = vec3(.2, .1, .4)*4.;\n    lights[3].pos = vec3(.5, .2, 7.2);\n    lights[3].col = vec3(.3, .3, .8);\n    Primitive lightPrim;\n    vec3 finalCol = vec3(0.,0.,0.); //initialize final pixel color to zero vector\n    vec3 lRefl;\t//\n    float str;\n    for(int i=0;i<NUM_LIGHTS;i++) {\n        lightPrim = processRayIntersect(lights[i].pos\n                        , normalize(rayPrim.intersecPoint - lights[i].pos), prims, .001); //check if a light ray from this light\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//reaches the point intersected by the camera ray and set lightPrim\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//as the primitive first intersected by the light ray\n        if(lightPrim.id == plane1.id) { //if the light ray towards the primitive intersection point intersects the plane\n\t\t\t\t\t\t\t\t\t\t\n        finalCol+= lightPrim.id==rayPrim.id?max(dot(rayPrim.normal //if the ray from the light and the ray from the camera intersect\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n               , normalize( -(rayPrim.intersecPoint) + lights[i].pos))\t//the aame primitive, calculate diffuse shading color value for the\n               *lights[i].col*.4, 0.):vec3(0., 0., 0.);\t\t\t\t\t//current light and add it to the pixel color\n            \n        }\n        else { //if the light ray didn't intersect the plane\n        lRefl = reflect(rayPrim.intersecPoint - lights[i].pos //calculate the reflection vector at the intersected surface\n                            , rayPrim.normal);\t\t\t\t  //point for the light ray\n        str = max((-1.*dot(normalize(lRefl), rayDir)-rayPrim.specular), 0.0) *5.; //calculate specular reflection value\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  //for the light ray\n\t\t\t\t\t\t\t\t\t\t\t\t\n        finalCol += mix(finalCol,                  //if the light ray and the camera ray hit the same point,\t\t\n                       lightPrim.id==rayPrim.id?   //add the light value vector to the final pixel color\n                        str*lights[i].col\t\t   //else add a zero vector\n            :vec3(0., 0., 0.)\n                        , .9 );\n       }\n    }\n\n    \n    return finalCol;\t//return the final pixel color\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    nope.normal = vec3(0., 0., 0.); //set the normal for the nope object\n    nope.id = -1.;\n\tfloat t = iTime;\n\tvec2 uv = (fragCoord.xy )/max(iResolution.x, iResolution.y); //normalized uv co-ordinates\n    vec3 center = vec3(vec2(iResolution.xy/2./max(iResolution.x, iResolution.y)), -3.0); //get the center of the uv co-ordinate\n    uv -=center.xy; //offset the uv co-ordinates so that the new center will be at (0, 0)\n    mat3 rotM = MRZ(t); //create a x axis rotation matrix whose angle varies by time\n    vec3 camPos = vec3(0, -4., 3.0);//vec3(0.5, .25, 15.25); //position the camera\n    camPos = rotM*(camPos); //apply rotation to camera\n    vec3 sph1Pos = vec3 (0., 0., 0.); //place sphere 1 at (0, 0, 0)\n    vec3 forward = normalize(sph1Pos - camPos); //set the camera to look at sphere 1\n    vec3 upVec = normalize(cross(cross(forward, vec3(0., 0., 1.)), forward)); //set a vector perpendicular to\n\t\t\t\t\t\t\t\t\t\t\t\t// the both z-axis and the camera forwars as the camera up vector\n   \n    vec3 scrnPos = camPos+forward*2.; //position the screen plane\n    vec3 planeLeft = normalize(cross(forward, upVec)); //calculate the left direction vector of the screen plane\n\tvec3 planeUV =upVec * uv.y + planeLeft*uv.x; //find out a point on the plane for the current pixel\n    vec3 rayDirUV = normalize(scrnPos + planeUV - camPos); //calculate the ray direction as the direction from\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //the camera position to the point on the screen\n    vec3 val = makeScene(camPos,rayDirUV, sph1Pos); //get the color value for the current pixel\n    fragColor = vec4(vec3(val), 1.); //set the pixel color\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}