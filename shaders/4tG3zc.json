{
    "Shader": {
        "info": {
            "date": "1476129852",
            "description": "Taking the directional light box a little further (from https://www.shadertoy.com/view/4lV3zV)\nDrag mouse from screen center for mouse look",
            "flags": 0,
            "hasliked": 0,
            "id": "4tG3zc",
            "likes": 10,
            "name": "Directional Light Box Repeat SDF",
            "published": 3,
            "tags": [
                "sdf",
                "light"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 888
        },
        "renderpass": [
            {
                "code": "#define WALK_SPEED 2.0 // in units per second\n\n// For antialiasing, it will take a randomly jittered sample for each cell in a NxN grid for a total of N^2 samples.\n// SAMPLES_PER_PIXEL_STRATIFY is the N, so that number squared number of samples will be taken per pixel.\n#define SAMPLES_PER_PIXEL_STRATIFY 2\n\n//----- light params\nvec3 lightAmbient\t\t\t\t= vec3(0.01,0.01,0.01);\n\nvec4 directionalLightRotationAxisAngle = vec4(normalize(vec3(0.0, 0.0, 1.0)), 1.7);\nvec3 directionalLightSourcePosition    = vec3(-1.5, 2.0, 0.0);\nvec2 directionalLightExtents           = vec2(2.0, 1.0);\nfloat directionalLightSoften           = 1.0/8.0;  //  How much the shadow softens over distance. Smaller value = sharper shadow.\nvec2 directionalLightUVDistanceScale   = vec2(0.05, 0.3); // How much the uv scales over distance. uv /= (1.0 + localPos.y * directionalLightUVDistanceScale);\nfloat directionalLightFalloff          = 0.04; // Controls light attenuation over distance. multiplied by distance^2\n\nfloat directionalLightModulus          = 5.0; // how often the light repeats horizontally\n\nvec3 torchLightColor = vec3(0.2, 0.15, 0.01);\nfloat torchLightDistanceAttenuation = 0.005;\nfloat torchLightDistanceBias = -1.0;\n\n//----- Fog params\nvec3 distanceFogColor                  = vec3(0.0, 0.0, 0.0);\nvec2 distanceFogBiasDensity            = vec2(-7.0, 0.5);\n\n//----- Camera\nfloat cameraViewWidth\t= 6.0;  // Height is calculated via aspect ratio\nfloat cameraDistance\t= 6.0;  // intuitively backwards!\n\n// hash without sine from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\nfloat SDFCircle( in vec2 coords, in vec3 offsetRadius )\n{\n    coords -= offsetRadius.xy;\n    float v = coords.x * coords.x + coords.y * coords.y - offsetRadius.z;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return abs(v)/length(g); \n}\n\n//----------------------------------------------------------------------------------------\nfloat SDFLine( in vec2 coords, in vec3 offsetSlope )\n{\n    coords -= offsetSlope.xy;\n    float v = coords.x * offsetSlope.z - coords.y;\n    vec2  g = vec2(offsetSlope.z,-1.0);\n    return abs(v)/length(g);\n}\n\n//============================================================\nfloat GetMode ()\n{\n    return iTime;\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in mat4 boxTransform, in mat4 inverseBoxTransform, in vec3 boxHalfSizes, out vec2 uv ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (boxTransform*vec4(rayDirection,0.0)).xyz;\n\tvec3 roo = (boxTransform*vec4(rayOrigin,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxHalfSizes;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\tvec3 normal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n\t// texture coordinates \n\tvec3 uaxis = vec3(1.0,0.0,0.0);\n\tvec3 vaxis = vec3(0.0,1.0,0.0);\n\t\n\tif (abs(normal.x) > 0.9)\n\t{\n\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\n\t}\n\telse if (abs(normal.y) > 0.9)\n\t{\n\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\t\t\n\t}\n    \n    vec3 relPoint = roo + rdd * timeNear;\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis) * 0.25,\n\t\tdot(relPoint, vaxis) * 0.25\n\t);    \n\n    // convert to ray space\n\t\n\tnormal = (inverseBoxTransform * vec4(normal,0.0)).xyz;\n\n\treturn vec4( timeNear, normal );\n}\n\n\n//============================================================\n// matrix functions from https://www.shadertoy.com/view/ld23DV\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}*/\n\n//============================================================\n// returns t and normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere, out vec2 uv)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    // NOTE: this will report a miss if ray starts inside the sphere.\n\tfloat collisionTime = -b - sqrt(discr);\n    \n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz);\n    \n    // texture coordinates are just the angular part of spherical coordiantes of normal\n    uv = vec2\n\t(\n\t\tatan(normal.z, normal.x),\n\t\tacos(normal.y)\n\t);\n    \n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and normal\n// plane xyz = normal, w = distance\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{\n    // only consider front face hits\n    // Note: if you disable this line, you may get problems due to the fact that i don't push shadow rays away from the bounce surface.\n    if (dot(rayDir, plane.xyz) >= 0.0)\n        return vec4(-1.0);    \n    \n    // calculate the collision time\n    float collisionTime = (-plane.w - dot(plane.xyz, rayPos)) / dot(plane.xyz, rayDir);\n        \n    // only consider positive hit times\n    if (collisionTime < 0.0)\n        return vec4(-1.0);\n    \n    // calculate normal\n    bool fromInside = dot(plane.xyz, rayDir) > 0.0;\n    vec3 normal = plane.xyz * (fromInside ? -1.0 : 1.0);\n    \n    // calculate tangent, bitangent\n    vec3 tangent;\n    if (abs(normal.x) > 0.1)\n        tangent = normalize(cross(vec3(0.0, 1.0, 0.0), normal));\n    else\n        tangent = normalize(cross(vec3(1.0, 0.0, 0.0), normal)); \n\tvec3 bitangent = cross(normal, tangent);\n    \n    // calculate uv\n    vec3 intersectionPoint = rayPos + rayDir * collisionTime;\n    uv.x = dot(intersectionPoint, tangent);\n    uv.y = dot(intersectionPoint, bitangent);\n    \n    // return hit info\n    return vec4(collisionTime, normal);\n}\n\n//============================================================\nmat4 GetDirectionalLightMatrixInverse ()\n{\n\tmat4 rot = rotationAxisAngle(directionalLightRotationAxisAngle.xyz, directionalLightRotationAxisAngle.w );\n\tmat4 tra = translate( directionalLightSourcePosition.x, directionalLightSourcePosition.y, directionalLightSourcePosition.z );\n\treturn tra * rot; \n}\n\n//============================================================\nmat4 GetDirectionalLightMatrix ()\n{\n\tmat4 rot = rotationAxisAngle(directionalLightRotationAxisAngle.xyz, -directionalLightRotationAxisAngle.w );\n\tmat4 tra = translate( -directionalLightSourcePosition.x, -directionalLightSourcePosition.y, -directionalLightSourcePosition.z );\n\treturn rot * tra;     \n}\n\n//============================================================\nvec3 WorldSpaceToDirectionalLightSpace (vec3 worldPosition)\n{\n\tvec3 localPosition = (GetDirectionalLightMatrix() * vec4(worldPosition, 1.0)).xyz; \n    localPosition.xz /= directionalLightExtents;\n    return localPosition;\n}\n\n//============================================================\n// x,y is uv. z is an instance index to use for variation.\nvec3 LightSpaceToLightUV (vec3 lightPosition)\n{\n    // calculate the uv from the light position. X is flipped\n    vec3 uv;\n    uv.xy = lightPosition.xz;\n    uv.x *= -1.0;\n        \n    // apply x axis modulus to make the light repeat\n\tuv.y = mod(uv.y + directionalLightModulus * 0.5, directionalLightModulus) - directionalLightModulus * 0.5;   \n\n    // apply scaling of uv over distance to fake projection\n\tuv.xy /= (1.0 + lightPosition.y * directionalLightUVDistanceScale);   \n    \n    // calculate the instance index\n    uv.z = floor((lightPosition.z + directionalLightModulus * 0.5) / directionalLightModulus);\n    \n    // return adjusted uv coordinates\n    return uv;\n}\n\n//============================================================\nvec3 GetLightColor (vec3 uv)\n{    \n    // let's draw some SDF's into the light color -> add color and also shadows.\n    // Use uv.z (the instance index) as a source of variation;\n    vec2 textureuv = uv.yx*0.5+0.5;\n    \n    float circleScale = hash12(vec2(uv.z, 0.645));\n    circleScale *= circleScale;\n    circleScale *= 0.15;\n    \n    float slope = hash12(vec2(uv.z, 1.374)) * 2.0 - 1.0;\n    slope *= slope * slope;\n    slope *= 100.0;\n    \n    float slope2 = hash12(vec2(uv.z, 3.7163)) * 2.0 - 1.0;\n    slope2 *= slope2 * slope2;\n    slope2 *= 100.0;    \n    \n    float shadeDist = SDFCircle(textureuv, vec3(0.5, 0.5, circleScale));\n    \n    shadeDist = min(shadeDist, SDFLine(textureuv, vec3(0.5, 0.5, slope)));\n    shadeDist = min(shadeDist, SDFLine(textureuv, vec3(0.5, 0.5, slope2)));\n    \n    float shade = smoothstep(0.00, 0.1, shadeDist);\n    \n    vec3 color = texture(iChannel0, textureuv).rgb;\n       \n    // draw a randomly colored circle on the canvas too\n    vec3 circleColor = hash32(vec2(uv.z, 8.453));\n    vec3 circleColorScale = hash32(vec2(uv.z, 7.846));\n    circleColorScale.z *= 0.1;\n    float circleDist = SDFCircle(textureuv, circleColorScale);\n    float colorLerp = 1.0 - smoothstep(0.00, 0.1, circleDist);\n    color = mix(color, circleColor, colorLerp);\n    \n    circleColor = hash32(vec2(uv.z, 3.645));\n    circleColorScale = hash32(vec2(uv.z, 2.164));\n    circleColorScale.z *= 0.1;\n    circleDist = SDFCircle(textureuv, circleColorScale);\n    colorLerp = 1.0 - smoothstep(0.00, 0.1, circleDist);\n    color = mix(color, circleColor, colorLerp);    \n    \n    return color * shade;\n}\n\n//============================================================\nvec3 ObjectRepeat (float cameraZ, float repeatDistance, float offset, float radius)\n{\n    float tileIndex = floor((cameraZ - offset) / repeatDistance);\n    \n    float xRange = 1.0 - radius;\n    \n    float x = (hash13(vec3(tileIndex, repeatDistance, offset)) * 2.0 - 1.0) * xRange * 2.0;\n    \n    float z = max(0.0, ( tileIndex + 1.0) * repeatDistance) + offset;\n    \n    return vec3(x, radius, z);\n}\n\n//============================================================\nvec3 GetBumpMapNormal (vec2 uv, mat3 tangentSpace)\n{    \n\tfloat delta = -1.0/512.0;\n\tfloat A = texture(iChannel1, uv + vec2(0.0, 0.0)).x;\n\tfloat B = texture(iChannel1, uv + vec2(delta, 0.0)).x;\n    float C = texture(iChannel1, uv + vec2(0.0, delta)).x;    \n    \n\tvec3 norm = normalize(vec3(A - B, A - C, 0.15));\n\t\n\treturn normalize(tangentSpace * norm);\n}\n\n//============================================================\nvoid TraceRay (in vec3 cameraPos, in vec3 rayPos, in vec3 rayDir, inout vec4 hitInfo, inout vec3 hitDiffuse, inout vec3 hitEmissive, inout float hitSpecularPower, inout bool hitSomething, in bool shadowRay)\n{\n    vec4 info = hitInfo; \n    vec2 uv;\n    \n    // the floor\n    info = RayIntersectPlane(rayPos, rayDir, vec4(0.0, 1.0, 0.0, 0.0), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        float checkerBoard = (mod(floor(uv.x) + floor(uv.y), 2.0) < 1.0 ? 1.0 : 0.4);        \n        hitDiffuse = vec3(checkerBoard);\n        hitEmissive = vec3(0.0);\n        hitSpecularPower = 1000.0;\n        hitInfo = info;\n        hitSomething = true;        \n    }\n    \n    for (int objectIndex = 0; objectIndex < 3; ++objectIndex)\n    {\n        // a blue box\n        mat4 rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), 1.0);\n        vec3 trans = ObjectRepeat(cameraPos.z, 27.2, 3.1 + float(objectIndex)*4.7, 0.25);\n        mat4 tra = translate( trans.x, trans.y, trans.z);\n        mat4 txi = tra * rot; \n        mat4 txx = inverse( txi );    \n        info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(0.25), uv);\n        if (info.x > 0.0 && info.x < hitInfo.x) {\n            hitDiffuse = vec3(0.2, 0.2, 0.9);\n            hitEmissive = vec3(0.0);\n            hitSpecularPower = 10.0;\n            hitInfo = info;\n            hitSomething = true;\n        }    \n\n        // a red ball\n        trans = ObjectRepeat(cameraPos.z, 28.3, 1.5 + float(objectIndex)*8.2, 0.5);\n        info = RayIntersectSphere(rayPos, rayDir, vec4(trans.x, trans.y, trans.z, 0.5), uv);\n        if (info.x > 0.0 && info.x < hitInfo.x) {\n            hitDiffuse = vec3(0.9, 0.2, 0.2);\n            hitEmissive = vec3(0.0);\n            hitSpecularPower = 100.0;\n            hitInfo = info;\n            hitSomething = true;        \n        }    \n\n        // a green ball\n        trans = ObjectRepeat(cameraPos.z, 29.7, 1.7 + float(objectIndex)*6.3, 0.125);\n        info = RayIntersectSphere(rayPos, rayDir, vec4(trans.x, trans.y, trans.z, 0.125), uv);\n        if (info.x > 0.0 && info.x < hitInfo.x) {\n            hitDiffuse = vec3(0.2, 0.9, 0.2);\n            hitEmissive = vec3(0.0);\n            hitSpecularPower = 100.0;\n            hitInfo = info;\n            hitSomething = true;        \n        }     \n\n        // a magenta box\n        trans = ObjectRepeat(cameraPos.z, 26.8, 2.0  + float(objectIndex)*7.28, 0.125);\n        rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), 1.9);\n        tra = translate(trans.x, trans.y, trans.z);\n        txi = tra * rot; \n        txx = inverse( txi );    \n        info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(0.125), uv);\n        if (info.x > 0.0 && info.x < hitInfo.x) {\n            hitDiffuse = vec3(0.9, 0.2, 0.9);\n            hitEmissive = vec3(0.0);\n            hitSpecularPower = 10.0;\n            hitInfo = info;\n            hitSomething = true;\n        }\n    }\n           \n\n    // Walls and cieling \n    if (GetMode() >= 4.0)\n    {\n        // left wall\n        info = RayIntersectPlane(rayPos, rayDir, vec4(-1.0, 0.0, 0.0, 2.0), uv);\n        if (info.x > 0.0 && info.x < hitInfo.x)\n        {\n            hitDiffuse = texture(iChannel1, uv/2.0).rgb * 5.0;\n            hitEmissive = vec3(0.0);\n            hitSpecularPower = 1000.0;\n            hitInfo = info;\n            hitSomething = true;    \n            \n            // do some fake bump mapping\n\t\t\tmat3 tangentSpace = mat3\n\t\t\t(\n\t\t\t\tvec3(0.0, 0.0, 1.0),\n\t\t\t\tvec3(0.0, 1.0, 0.0),\n\t\t\t\tvec3(-1.0, 0.0, 0.0)\n\t\t\t);\n            hitInfo.yzw = GetBumpMapNormal(uv/2.0, tangentSpace);\n        }      \n        \n        // Dont consider cieling and right wall for shadows.\n        // a hack to get around the fact that we grow the uv's, but use the directional light to cast back\n        // up the directional light, which WILL have shadows. We ought to be adjusting reverse light direction.\n        if (!shadowRay)\n        {\n            // cieling\n            info = RayIntersectPlane(rayPos, rayDir, vec4(0.0, -1.0, 0.0, 4.0), uv);\n            if (info.x > 0.0 && info.x < hitInfo.x)\n            {\n                hitDiffuse = texture(iChannel1, uv/2.0).rgb * 5.0;\n                hitEmissive = vec3(0.0);\n                hitSpecularPower = 1000.0;\n                hitInfo = info;\n                hitSomething = true;        \n                \n                // do some fake bump mapping\n                mat3 tangentSpace = mat3\n                (\n                    vec3(1.0, 0.0, 0.0),\n                    vec3(0.0, 0.0, 1.0),\n                    vec3(0.0,-1.0, 0.0)\n                );\n                hitInfo.yzw = GetBumpMapNormal(uv/2.0, tangentSpace);                \n            }              \n\n            // right wall\n            info = RayIntersectPlane(rayPos, rayDir, vec4( 1.0, 0.0, 0.0, 2.0), uv);\n            if (info.x > 0.0 && info.x < hitInfo.x)\n            {   \n                vec3 lightpos = WorldSpaceToDirectionalLightSpace(rayPos+rayDir*info.x);\n                vec3 lightuv = LightSpaceToLightUV(lightpos);\n\n                if (abs(lightuv.x) >= 1.0 || abs(lightuv.y) >= 1.0)\n                {\n                    hitDiffuse = texture(iChannel1, uv/2.0).rgb * 5.0;\n                    hitEmissive = vec3(0.0);\n                    hitSpecularPower = 1000.0;\n                    hitInfo = info;\n                    hitSomething = true;               \n                    \n                    // do some fake bump mapping\n                    mat3 tangentSpace = mat3\n                    (\n\t\t\t\t\t\tvec3(0.0, 0.0, 1.0),\n\t\t\t\t\t\tvec3(0.0, 1.0, 0.0),\n\t\t\t\t\t\tvec3(1.0, 0.0, 0.0)\n                    );\n                    hitInfo.yzw = GetBumpMapNormal(uv/2.0, tangentSpace);                        \n                }\n                else\n                {\n                    hitDiffuse = vec3(0.0);\n                    hitEmissive = GetLightColor(lightuv);\n                    hitSpecularPower = 1000.0;\n                    hitInfo = info;\n                    hitSomething = true;                                   \n                }\n            }   \n        }\n        \n    }\n    \n    // light source plane - test last\n    mat4 lightMatrix = GetDirectionalLightMatrixInverse();\n    vec4 plane;\n    plane.xyz = lightMatrix[1].xyz;\n    plane.w = length(directionalLightSourcePosition);\n    info = RayIntersectPlane(rayPos, rayDir, plane, uv);    \n    // if ever a shadow ray hits the light source as the closest intersection, return a miss, so we don't get shadows from behind the light source!\n    if (shadowRay)\n    {\n        if (info.x > 0.0 && info.x < hitInfo.x) {\n            hitDiffuse = vec3(0.0);\n            hitEmissive = vec3(0.0);\n            hitSpecularPower = 0.0;\n            hitInfo = vec4(1000.0, -rayDir);\n            hitSomething = false;        \n        }        \n    }\n    // else if we are not doing a shadow ray, and the mode is >= 1, then we want to show the light source as an object\n    else if (GetMode() >= 1.0)\n    {\n        if (info.x > 0.0 && info.x < hitInfo.x) {\n            \n            vec3 lightpos = WorldSpaceToDirectionalLightSpace(rayPos+rayDir*info.x);\n            vec3 lightuv = LightSpaceToLightUV(lightpos);            \n            \n            if (abs(lightuv.x) <= 1.0 && abs(lightuv.y) <= 1.0)\n            {\n            \thitDiffuse = vec3(0.0);\n                if (GetMode() >= 3.0)\n            \t\thitEmissive = GetLightColor(lightuv);\n                else\n                    hitEmissive = vec3(1.0);\n            \thitSpecularPower = 10.0;\n            \thitInfo = info;\n            \thitSomething = true;\n            }\n        }            \n    }    \n}\n\n//============================================================\nvoid LightBoxLight (in vec3 cameraPos, in vec3 shadePoint, vec3 normal, vec3 directionalLightReverseDir, vec3 rayDir, in float specularPower, out vec3 diff, out vec3 spec) {\n    \n    // start with a white directional light diffuse\n    float diffuse = clamp(dot(normal, directionalLightReverseDir), 0.0, 1.0);\n    diff = vec3(diffuse);\n    \n    // add in specular\n    vec3 reflection = reflect(directionalLightReverseDir, normal);\n    float dp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n    spec = vec3(pow(dp, specularPower));    \n\n    // apply shadows\n    vec3 shadowRayPos = shadePoint;        \n    vec3 shadowRayDir = directionalLightReverseDir;\n    vec3 shadowHitDiffuse = vec3(0.0);\n    vec3 shadowHitEmissive = vec3(0.0);\n    float shadowHitSpecularPower = 0.0;\n    vec4 shadowHitInfo = vec4(10000.0, -directionalLightReverseDir); \n    bool shadowHitSomething = false;  \n    TraceRay(cameraPos, shadowRayPos, shadowRayDir, shadowHitInfo, shadowHitDiffuse, shadowHitEmissive, shadowHitSpecularPower, shadowHitSomething, true);\n    diff *= float(!shadowHitSomething);\n    spec *= float(!shadowHitSomething);\n\n    // in mode greater than zero we limit this directional lighting to repeating boxes in uv coordinates\n    vec3 uv;\n\tvec3 localPos;    \n    if (GetMode() >= 1.0)\n    {\n        // get position in light space and get uv\n        localPos = WorldSpaceToDirectionalLightSpace(shadePoint);\n        uv = LightSpaceToLightUV(localPos);\n        \n        // set shade to 1 if it's inside, 0 if it's outside        \n    \tfloat shade = float(abs(uv.x) < 1.0 && abs(uv.y) < 1.0);\n        \n        // if it is behind the light source, don't light it!\n        shade *= step(0.0, localPos.y);\n        \n        // apply distance attenuation\n        shade *=  1.0 - clamp(directionalLightFalloff * localPos.y * localPos.y, 0.0, 1.0);   \n        \n        // apply shading to the lighting\n        spec *= shade;\n        diff *= shade;\n    }\n    \n    // soften shadows over a distance\n\tif (GetMode() >= 2.0)\n    {\n        float softenDistance = clamp(localPos.y * directionalLightSoften, 0.001, 0.999);\n    \tfloat softenX = smoothstep(1.0, 1.0 - softenDistance, abs(uv.x));\n    \tfloat softenY = smoothstep(1.0, 1.0 - softenDistance, abs(uv.y));\n    \tdiff *= softenX * softenY;\n        spec *= softenX * softenY;\n    }\n    \n    // apply texture to light if we should!\n    if (GetMode() >= 3.0)\n    {\n        diff *= GetLightColor(uv);\n    }\n    \n    diff = clamp(diff, 0.0, 1.0);\n    spec = clamp(spec, 0.0, 1.0);\n}\n\n//============================================================\nvoid TorchLight (in vec3 cameraPos, in vec3 shadePoint, vec3 normal, vec3 rayDir, in float specularPower, out vec3 diff, out vec3 spec) {\n    \n    vec3 lightPos = cameraPos + vec3(-1.5, 1.0, 0.0);\n    \n    vec3 lightColor = torchLightColor * (hash11(iTime)*0.25+0.75);\n    \n    // start with a yellow point light that has quadratic distance attenuation\n    vec3 reverseLightVector = vec3(lightPos - shadePoint);\n    vec3 reverseLightDir = normalize(reverseLightVector);\n    float diffuse = clamp(dot(normal, reverseLightDir), 0.0, 1.0);\n    float distToLight = length(reverseLightVector);\n    float attenDistt = max(0.0, distToLight + torchLightDistanceBias);\n    float falloff = 1.0 - clamp(torchLightDistanceAttenuation * attenDistt * attenDistt, 0.0, 1.0);\n    diff = diffuse * lightColor * falloff;    \n    \n    // add in specular\n    vec3 reflection = reflect(reverseLightDir, normal);\n    float dp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n    spec = pow(dp, specularPower) * lightColor * falloff;    \n        \n    // apply shadows by seeing if anything is between the shade point and the light\n    vec3 shadowRayPos = shadePoint;        \n    vec3 shadowRayDir = reverseLightDir;\n    vec3 shadowHitDiffuse = vec3(0.0);\n    vec3 shadowHitEmissive = vec3(0.0);\n    float shadowHitSpecularPower = 0.0;\n    vec4 shadowHitInfo = vec4(10000.0, -reverseLightDir); \n    bool shadowHitSomething = false;  \n    TraceRay(cameraPos, shadowRayPos, shadowRayDir, shadowHitInfo, shadowHitDiffuse, shadowHitEmissive, shadowHitSpecularPower, shadowHitSomething, true);\n    float shadow = float(shadowHitSomething);\n    shadow*= float(shadowHitInfo.x < distToLight);\n    shadow = 1.0 - shadow;\n    diff *= shadow;\n    spec *= shadow;\n\n    // clamp the resulting color\n    diff = clamp(diff, 0.0, 1.0);\n    spec = clamp(spec, 0.0, 1.0);\n}\n\n//============================================================\nvec3 ShadePoint (vec3 cameraPos, vec3 rayDir, vec3 shadePoint, vec3 normal, vec3 emissive, vec3 diffuse, float specularPower, vec3 directionalLightReverseDir)\n{\n    // start with emissive and ambient light\n    vec3 pixelColor = emissive + diffuse * lightAmbient;\n    \n    // add in the directional light box light\n    vec3 lightDiff, lightSpec;\n    LightBoxLight(cameraPos, shadePoint, normal, directionalLightReverseDir, rayDir, specularPower, lightDiff, lightSpec);\n    pixelColor += lightDiff * diffuse + lightSpec;\n    \n    // add in a camera local flickering yellow point light\n    if (GetMode() >= 6.0)\n    {\n    \tTorchLight(cameraPos, shadePoint, normal, rayDir, specularPower, lightDiff, lightSpec);\n    \tpixelColor += lightDiff * diffuse + lightSpec;\n    }\n    \n    return clamp(pixelColor, 0.0, 1.0);    \n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    mat4 dirLightMat = GetDirectionalLightMatrixInverse();\n    vec3 directionalLightReverseDir = -dirLightMat[1].xyz;\n    \n    vec3 finalColor = vec3(0.0);\n    for (int i = 1; i <= SAMPLES_PER_PIXEL_STRATIFY*SAMPLES_PER_PIXEL_STRATIFY; ++i)\n    {\n        // calculate stratified subpixel jitter in a grid\n        float x = mod(float(i)-1.0, float(SAMPLES_PER_PIXEL_STRATIFY));\n        float y = mod(floor(float(i) / float(SAMPLES_PER_PIXEL_STRATIFY)), float(SAMPLES_PER_PIXEL_STRATIFY));\n        vec2 jitter = hash21(float(i)) / float(SAMPLES_PER_PIXEL_STRATIFY);\n        jitter.x += x / float(SAMPLES_PER_PIXEL_STRATIFY);\n        jitter.y += y /float(SAMPLES_PER_PIXEL_STRATIFY);\n        \n        // set up the camera\n        vec2 percent = ((fragCoord.xy+jitter) / iResolution.xy) - vec2(0.5,0.5);  \n        vec3 rayPos;\n        vec3 rayTarget;\n        \n        float walkOffset = max(0.0, GetMode() - 7.0) * 0.5 + 3.14;\n        vec2 camOffset = vec2(cos(walkOffset*6.28), abs(sin(walkOffset*6.28))*-1.0);        \n\n        float walkDistance = max(0.0, GetMode() - 7.0) * WALK_SPEED;            \n        rayPos = vec3(0.0+camOffset.x * 0.2, 2.5+camOffset.y * 0.15, -6.0 + walkDistance);\n        \n        float angleX = 0.0;\n        float angleY = 0.0;\n\n        if (iMouse.z > 0.0) {\n            vec2 mouse = iMouse.xy / iResolution.xy;\n            angleX = 3.14 + 6.28 * -mouse.x;\n            angleY = (mouse.y - 0.5) * 3.14;//(mouse.y * 3.90) - 0.4;\n        }\n\n        vec3 cameraFwd\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY)));           \n        vec3 cameraLeft = normalize(cross(cameraFwd,vec3(0.0,1.0,0.0)));\n        vec3 cameraUp = normalize(cross(cameraLeft,cameraFwd));\n\n        float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n        rayTarget = rayPos + (cameraFwd * cameraDistance)\n            + (cameraLeft * percent.x * cameraViewWidth)\n            + (cameraUp * percent.y * cameraViewHeight);\t\t\n\n        vec3 rayDir = normalize(rayTarget - rayPos);\n\n        // Trace our ray\n        vec3 hitDiffuse = vec3(0.0);  // rgb\n        vec3 hitEmissive = vec3(0.0); // rgb\n        float hitSpecularPower = 0.0; // spec power\n        vec4 hitInfo = vec4(10000.0, -cameraFwd);  // distance, normal \n        bool hitSomething = false;\n        TraceRay(rayPos, rayPos, rayDir, hitInfo, hitDiffuse, hitEmissive, hitSpecularPower, hitSomething, false);\n        \n        // shade the point\n        vec3 worldPos = rayPos + rayDir * hitInfo.x;\n        vec3 pixelColor = ShadePoint(rayPos, rayDir, worldPos, hitInfo.yzw, hitEmissive, hitDiffuse, hitSpecularPower, directionalLightReverseDir);\n        pixelColor*= float(hitSomething);\n        \n        // apply distance fog after reaching mode 5\n        float fogDist = max(length(worldPos - rayPos) + distanceFogBiasDensity.x, 0.0) * step(5.0, GetMode());\n        float fogAmt = 1.0 - exp( -fogDist*distanceFogBiasDensity.y);\n        pixelColor = mix(pixelColor, distanceFogColor, fogAmt);\n        \n\t\t// incrementally average our pixel color in\n        finalColor = mix(finalColor, pixelColor, 1.0 / float(i));\n    }\n    \n    // output final gamma corrected color\n\tfragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}