{
    "Shader": {
        "info": {
            "date": "1544901832",
            "description": "copied, modified from: https://www.shadertoy.com/view/XdtyzM\nfrom top left, clockwise:\noriginal, correction for Tritanomaly, Protanomaly, Deuteranomaly",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXGzH",
            "likes": 0,
            "name": "Color blindness correction",
            "published": 3,
            "tags": [
                "filter",
                "colorblindness"
            ],
            "usePreview": 0,
            "username": "ttyy",
            "viewed": 682
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\n#define PI 3.1415926535897932384626433832795\n\n/******************************************************************************\n * This shader simulates three kinds of color blindness, and does so more     *\n * accurately than most other shaders of this kind. The xy coordinates for    *\n * the LMS colorspace that I use are calculated from the 'cone fundamentals'  *\n * for the human eye.                                                         *\n *                                                                            *\n * Most other shaders around here which use pre-existing XYZ->LMS matrices    *\n * that were designed not for color blindness research, but instead for       *\n * approximating how our eyes perform white balance, among other photography  *\n * color issues.                                                              *\n ******************************************************************************/\n\n\nstruct transfer {\n\tfloat power;\n\tfloat off;\n\tfloat slope;\n\tfloat cutoffToLinear;\n\tfloat cutoffToGamma;\n};\n\nstruct rgb_space {\n\tmat3 primaries;\n\tvec3 white;\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\t(r1), (r2), 1.0 - (r1) - (r2),\\\n\t\t(g1), (g2), 1.0 - (g1) - (g2),\\\n\t\t(b1), (b2), 1.0 - (b1) - (b2))\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define White(x, y)\\\n\tvec3((x), (y), 1.0 - (x) - (y))/(y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag(inverse((space).primaries)*(space).white)\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\n/* Commenting these out in favor of XYZ primary equivalents\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);*/\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// CIE 1931 RGB\nconst mat3 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Identity RGB\nconst mat3 primariesIdentity = mat3(1.0);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC (Rec. 601) and SMPTE-240M\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Never-popular, antiquated, and idealized 'HDTV' primaries based mostly on the\n// 1953 NTSC colorspace. SMPTE-240M officially used the SMPTE-C primaries\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat3 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\nconst mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = White(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = White(1.0/3.0, 1.0/3.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = White(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = White(0.312713, 0.329016);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = White(0.34567, 0.35850);\n\n// White point for DCI-P3 Theater\nconst vec3 whiteTheater = White(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = White(0.283, 0.298);\n\n// White balance for LMS so that each channel's spectral sensitivities peak at\n// exactly 1.0, at least according to the 2006 cone fundamentals\nconst vec3 whiteLmsUnity = White(89766673.0/387074477.0, 103822461.0/387074477.0);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; used by older Macintosh systems\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, and is what Adobe RGB uses\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma and full range values)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point and linearized\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteLmsUnity, gam10);\n\n\n/*\n * Settings\n */\n\n// Choose RGB colorspace for the display\nconst rgb_space space = rgb_space(primaries709, whiteD65, gamSrgb);\n\nconst mat3 toXyz = rgbToXyz(space);\nconst mat3 toRgb = xyzToRgb(space);\n\n// Choose main XYZ->LMS conversion matrix from which others derive\n//const mat3 lmsMat = HUNT;\n\n// Normalize the LMS matrix to the white point\n//const mat3 toLms = inverse(diag((lmsMat*space.white)))*lmsMat;\n\n// Or not\n//const mat3 toLms = lmsMat;\n\n// Use LMS primaries instead of a pre-created matrix\nconst mat3 toLms = xyzToRgb(LmsRgb);\n\n\n/*\n * Conversion Functions\n */\n\nvec3 toLinear(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));\n\tvec3 lower = color/trc.slope;\n\tvec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\nvec3 toGamma(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToGamma));\n\tvec3 higher = (1.0 + trc.off)*pow(color, vec3(1.0/trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1.0 - trc.off)*pow(-1.0*color, vec3(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Scales a color to the closest in-gamut representation of that color\nvec3 gamutScale(vec3 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = (high - 1.0)/(high - luma);\n\tfloat scale = max(lowScale, highScale);\n\tcolor += scale*(luma - color);\n\n\treturn color;\n}\n\nvec3 convert(vec3 color, float multp, float multd, float multt)\n{\n\t// Convert to XYZ and grab luma\n\tcolor = toXyz*color;\n\n\t// Convert to LMS\n\tcolor = toLms*color;\n\n\t// Calculate color blindness simulation adaptation matrix variables\n\t// such that the given two colors remain the same\n\tconst vec3 white = toLms*space.white;\n\tconst vec3 blue = toLms*space.primaries[2];\n\tconst vec3 red = toLms*space.primaries[0];\n\n\tconst vec2 prota = inverse(mat2(\n\t\twhite.g, blue.g,\n\t\twhite.b, blue.b\n\t))*vec2(white.r, blue.r);\n\n\tconst vec2 deuta = inverse(mat2(\n\t\twhite.r, blue.r,\n\t\twhite.b, blue.b\n\t))*vec2(white.g, blue.g);\n\n\tconst vec2 trita = inverse(mat2(\n\t\twhite.r, red.r,\n\t\twhite.g, red.g\n\t))*vec2(white.b, red.b);\n\n\t// Perform color blindness adjustments\n\t// I'm using 3 separate matrices (as of 2018-02-11) to allow simulating\n\t// mixed types of color blindness (not sure how accurate it is though)\n\tmat3 adaptProta = mat3(\n\t\t1.0 - multp, 0.0, 0.0,\n\t\tprota.x*multp, 1.0, 0.0,\n\t\tprota.y*multp, 0.0, 1.0\n\t);\n\n\tmat3 adaptDeuta = mat3(\n\t\t1.0, deuta.x*multd, 0.0,\n\t\t0.0, 1.0 - multd, 0.0,\n\t\t0.0, deuta.y*multd, 1.0\n\t);\n\n\tmat3 adaptTrita = mat3(\n\t\t1.0, 0.0, trita.x*multt,\n\t\t0.0, 1.0, trita.y*multt,\n\t\t0.0, 0.0, 1.0 - multt\n\t);\n\n\t// Old single matrix\n\t/*mat3 adapt = mat3(\n\t\t1.0 - multp, deuta.x*multd, trita.x*multt,\n\t\tprota.x*multp, 1.0 - multd, trita.y*multt,\n\t\tprota.y*multp, deuta.y*multd, 1.0 - multt\n\t);*/\n\n\tcolor = adaptTrita*adaptDeuta*adaptProta*color;\n\n\t// Convert back to XYZ\n\tcolor = inverse(toLms)*color;\n\n\t// Convert to RGB\n\tfloat luma = color.y;\n\tcolor = toRgb*color;\n\tcolor = gamutScale(color, luma);\n\n\treturn color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 color;\n\n\tvec2 texRes = vec2(textureSize(iChannel0, 0));\n\tvec2 texCoord = mod(fragCoord, iResolution.xy/vec2(2.0))/texRes;\n\ttexCoord *= texRes.x/iResolution.x * 2.;\n\n\t//float amount = clamp(2.0/PI*asin(sin((iTime/2.0 + 0.5)*PI))*4.0 + 0.5, 0.0, 1.0);\n\t//float amount = 1.0 - 2.0*iMouse.x/iResolution.x;\n    float amount = -1.;\n\n    vec2 tc = abs(mod(texCoord+1.,2.) - 1.);\n\tfragColor = texture(iChannel0, tc);\n\tcolor = toLinear(fragColor.rgb, space.trc);\n\n\t// Control how much of each variant of colorblindness is simulated\n\tvec3 prota = convert(color, amount, 0.0, 0.0);\n\tvec3 deuta = convert(color, 0.0, amount, 0.0);\n\tvec3 trita = convert(color, 0.0, 0.0, amount);\n\n\t// Calculate which quadrant is being computed\n\tint quadrant = int(dot(round(fragCoord/iResolution.xy), vec2(1.0, 2.0)));\n\n\t// Color each pixel depending on said quadrant\n\tcolor = mix(prota, color, bvec3(quadrant - 0));\n\tcolor = mix(deuta, color, bvec3(quadrant - 1));\n\tcolor = mix(trita, color, bvec3(quadrant - 3));\n    \n\tcolor = toGamma(color, space.trc);\n\n\tfragColor.rgb = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}