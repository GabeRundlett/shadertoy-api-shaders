{
    "Shader": {
        "info": {
            "date": "1645536447",
            "description": "hmm",
            "flags": 32,
            "hasliked": 0,
            "id": "7sXBWl",
            "likes": 13,
            "name": "Lens Dirt Texture [Day 796]  ",
            "published": 3,
            "tags": [
                "lens",
                "bokeh",
                "camera",
                "flare",
                "dirt",
                "chromab",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 668
        },
        "renderpass": [
            {
                "code": "\n// BuffA is just fiddling with some noise to generate a dirt texture\n// BuffB does bokeh with BuffA as input\n\n// Image draws BuffB and attenuates it by a circle.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uvn = (fragCoord)/iResolution.xy;\n\n    vec3 col = vec3(0);\n    \n    \n    float param = iTime;\n    vec2 muv = vec2(sin(param),cos(param + sin(iTime + param)))*0.4;\n    \n    if(iMouse.z > 0.){\n        muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    }\n    \n    float sdCirc = length(uv-muv);\n    \n    // sample the lens dirt texture\n    col = texture(iChannel0,uvn).xyz;\n    col *= smoothstep(0.7,0.,sdCirc);\n\n    \n    // draw fake ball\n    col = mix(col,vec3(8)*mix(vec3(1.),col,0.99),smoothstep(0.1,0.,sdCirc - 0.01));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nmat3 orthBasis( vec3 z ) {\n  z = normalize( z );\n  vec3 up = abs( z.y ) > 0.999 ? vec3( 0.0, 0.0, 1.0 ) : vec3( 0.0, 1.0, 0.0 );\n  vec3 x = normalize( cross( up, z ) );\n  vec3 y = cross( z, x );\n  return mat3( x, y, z );\n}\n\n\nvec3 cyclicNoise( vec3 p ) {\n  vec3 sum = vec3( 0.0 );\n  float amp = 0.52;\n  float warp = 0.6;\n  mat3 rot = orthBasis( vec3( 0.5,-.5,.2 ) );\n\n  for ( int i = 0; i < 4; i ++ ) {\n    p *= rot * 2.0;\n    p += sin( p.zxy * warp );\n    sum += sin( cross( cos( p ), sin( p.yzx ) ) ) * amp;\n    amp *= 0.5;\n    warp *= 1.3;\n  }\n\n  return sum;\n}\n\nmat2 _rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a) );\n}\n\nvec4 cyclicNoise( vec4 p ) {\n  vec4 sum = vec4( 0.0 );\n  float amp = 0.5;\n  float warp = 1.1;\n\n  p.xw *= _rot(1.5);\n  p.wy *= _rot(.9);\n\n  for ( int i = 0; i < 5; i ++ ) {\n\n    p += sin( p.wzxy * warp );\n    sum += sin( dot( cos( p ), sin( p.yzwx ) ) ) * amp;\n    amp *= 0.5;\n    warp *= 1.3;\n    p.xz *= _rot(0.9);\n    p.xy *= _rot(4.9);\n  }\n\n  return sum;\n}\n\n\nvec3 getNoise(vec2 uv){\n    vec3 col = vec3(0);\n    vec3 na = cyclicNoise(vec3(uv + 20.,5.));\n    \n    \n    vec3 n = cyclicNoise(\n        vec3(\n            uv*10. + na.xy*4.,\n            cyclicNoise(vec3(uv,1.)).x*4.\n        )\n    );\n    vec3 nb = cyclicNoise(\n        vec3(\n            uv*2. - n.xy*1.,\n            cyclicNoise(vec3(n.xy,n)).x*-.2  - 10.\n        )\n    );\n    \n    vec3 nc = cyclicNoise(\n        vec3(\n            uv*22. - n.xy*1. + nb.xz*1.,\n            n.y*1. + nb.x - n.x\n        )\n    );\n    \n    vec3 nd = cyclicNoise(\n        vec3(\n            n.xy*2. + nc.xz*0.6,\n            nc.y + 5.\n        )\n    );\n    vec3 ne = cyclicNoise(\n        vec3(\n            nd.xy*2. + uv.xy,\n            nd.x*1. + 441.\n        )\n    );\n    //ne = max(ne,0.8);\n    \n    n *= nb*7.*dot(nc,vec3(0.2 - nd.x,1. - nd.y,0.1))*nd*ne*3.;\n    \n    n = dot(n,vec3(0.23,1,0.5))*vec3(1.);\n    \n    n = max(n,0.);\n    \n    n = n/(1.+n);\n    \n    n = pow(n,vec3(4.1))*55.;\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n\n    \n    col += getNoise(uv);\n\n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// dave hoskins hash\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// iq hsv2rgbsmooth\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //uv * 1.5;\n    vec2 uvn = (fragCoord)/iResolution.xy;\n    \n    //uvn += normalize(uv)*dot(uv,uv)*0.06;\n    vec3 col = vec3(0);\n    \n    float iters = 1000.;\n    float ratio = iResolution.x/iResolution.y;\n        \n        \n    if(iFrame > 20) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    } else {\n\n        for(float i = 0.; i < iters; i++){\n\n            vec3 r = hash33(vec3(uv*445. + 1150.,i));\n            r.x = i/iters;\n            //r.y = 1.-i/iters;\n            float eta = 1./(mix(1.15,1.25,r.z));\n\n            vec3 c = hsv2rgbSmooth( vec3(r.z*1.,1,1) );\n\n            vec2 offs = vec2(sin(r.x*3.14*2.),cos(r.x*3.14*2.));\n            offs *= pow(sqrt(r.y),0.9)*(1.+0.1*r.y*dot(uv,uv) - 0.3*dot(offs,normalize(uv)));\n\n            if(ratio > 1.){\n                offs.y *= ratio;\n            } else {\n                offs.x *= ratio; // ?\n            }\n\n            col += texture(iChannel0,uvn - normalize(uv)*0.03*r.z*dot(uv,uv) + offs*0.03).xyz/iters*c*5.;\n        }\n\n        col+= clamp(texture(iChannel0,uvn ).xyz,0.,0.4)*0.1;\n\n        fragColor = vec4(col,1.0);\n    }\n\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}