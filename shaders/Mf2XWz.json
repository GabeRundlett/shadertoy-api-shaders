{
    "Shader": {
        "info": {
            "date": "1706230959",
            "description": "Analytical expressions for integrals of Gabor-crossectioned beam along the (segment of) ray.\nClick bar of the screen to select accuracy:\nLeft - fake (fast, has artifacts).\nCenter - low (fast).\nRight - high (slow).",
            "flags": 0,
            "hasliked": 0,
            "id": "Mf2XWz",
            "likes": 5,
            "name": "Gabor beams",
            "published": 3,
            "tags": [
                "ray",
                "godrays",
                "gabor"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 192
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Consider a beam along z axis, whose value (density, energy, whatever)\n// is given by f(x,y). Suppose that f is expressible as a sum of\n// Gabor functions:\n//     G(x,y)=exp(-(x^2+y^2)/W^2)*cos(Kx*x+Ky*y+K0)\n// Note that you can, if you so chose, just use the Fourier\n// transform of (possibly windowed) exp((x^2+y^2)/W^2)*f(x,y).\n// We are interested in finding beam's total value along\n// some ray Ro+Rd*t. This involves integral\n//     ∫ exp(-P^2*t^2-Q*t-R)*cos(A*t+B) dt\n// for some P,Q,R,A,B.\n// Note that if we want to add a decay factor exp(-C*t)\n// (e.g. fog), the expression still has the same form.\n// The \"complete\" integral (from -∞ to +∞) is\n//     sqrt(pi)*cos(0.5*A*Q/P^2-B)*exp(-R+(Q*Q-A*A)/(4.0*P^2))/P\n// If we want an integral from L to H (say, a segment from\n// camera to ray hitting an obstacle), we can crudely estimate it\n// multiplying the above by\n//     (erf(H*P+Q/(2*P))-erf(L*P+Q/(2*P))))/2\n// which is exact for A=B=0 (pure gaussian beam).\n// Alternatively, we can use exact expression for the\n// indefinite integral:\n//     (sqrt(pi)/(4*P))*exp(X^2-Y^2-R)*(cos(Z)*(erf(P*t+X+i*Y)+erf(P*t+X-i*Y))+i*sin(Z)*(erf(P*t+X+i*Y)-erf(P*t+X-i*Y)))\n// where\n//     X=Q/(2*P)\n//     Y=A/(2*P)\n//     Z=2*X*Y-B\n// which simplifies to\n//     (sqrt(pi)/(2*P))*exp(X^2-Y^2-R)*(cos(Z)*Re[erf(P*t+X+i*Y)]-sin(Z)*Im[erf(P*t+X+i*Y)])\n// which we, for numerical reasons, compute as\n//     (sqrt(pi)/(2*P))*exp(X^2-R)*(cos(Z)*Re[F(P*t+X+i*Y)]-sin(Z)*Im[F(P*t+X+i*Y)])\n// where F(z)=exp(-Im(z)^2)*erf(z).\n\n// NOTE: gaussian beams (e.g. lasers) are often described in terms of\n// Hermite-Gaussian, or Laguerre-Gaussian modes instead (see e.g.\n// https://en.wikipedia.org/wiki/Gaussian_beam#Higher-order_modes).\n// Expressions for those are, however, hairier. Switching between\n// Hermite/Laguerre and Gabor basis should be quite doable.\n\n//==============================================================================\n// Helper functions.\n\nconst float pi=3.14159265358979;\n\nfloat erf(float x)\n{\n    float t=1.0/(1.0+0.5*abs(x));\n    return sign(x)*(1.0-t*exp(\n        -x*x-1.26551223\n        +t*(+1.00002368\n        +t*(+0.37409196\n        +t*(+0.09678418\n        +t*(-0.18628806\n        +t*(+0.27886807\n        +t*(-1.13520398\n        +t*(+1.48851587\n        +t*(-0.82215223\n        +t*(+0.17087277)))))))))));\n}\n\n// Scaled complex error function.\n// See https://www.shadertoy.com/view/4f2XWz.\nvec2 F(vec2 z)\n{\n    float X=z.x,Y=z.y;\n    float XY=X*Y,C=cos(XY),S=sin(XY),T=(abs(XY)<1e-4?1.0:S/XY); // T=sinc(XY).\n    float C2=(C-S)*(C+S),S2=2.0*C*S;\n    float re=0.5*exp(-Y*Y)*X*Y*Y*T*T;\n    float im=0.5*exp(-Y*Y)*Y*T*C;\n    for(int i=1;i<=22;++i)\n    {\n        float n=float(i);\n        float L=exp(-(Y-0.5*n)*(Y-0.5*n));\n        float H=exp(-(Y+0.5*n)*(Y+0.5*n));\n        float D=1.0/(n*n+4.0*X*X);\n        re+=D*(2.0*X*exp(-Y*Y-0.25*n*n)-X*(L+H)*C2+0.5*n*(L-H)*S2);\n        im+=D*(                         X*(L+H)*S2+0.5*n*(L-H)*C2);\n    }\n    return vec2(\n        exp(-Y*Y)*erf(X)+(2.0*exp(-X*X)/pi)*re,\n                         (2.0*exp(-X*X)/pi)*im);\n}\n\n// Approximation of the above.\n// Max. abs. error ~0.025.\nvec2 F_approx(vec2 z)\n{\n    float x=z.x,y=z.y,x2=x*x,y2=y*y;\n    float D=3.0*y*(4.0+y2)/(12.0+y2*(11.0+6.0*y2)); // Approx. of Dawson integral.\n    float E=tanh(x*(1.129675826+x2*0.099792702)); // Approx. of erf(x), see https://www.shadertoy.com/view/ml3yWj.\n    float w=1.12837*D*exp(-x2)/sqrt(1.0+0.363*x2);\n    float a=(1.0-0.590/(1.0+0.119*x2+0.538*y2))*2.0*x*y;\n    return vec2(E*exp(-y2)+w*sin(a),w*cos(a));\n}\n\n//==============================================================================\n\n// Gabor function.\n// C.w is radius, C.xy is wave vector, C.z is phase offset.\nfloat G(vec4 C,vec2 v)\n{\n    return exp(-dot(v,v)/(C.w*C.w))*cos(dot(C.xyz,vec3(v,1)));\n}\n\n// Definite integral ∫ G(C,(ro+t*rd).xy) dt on (-∞;+∞).\n// NOTE: ro and rd are in beam's coordinate system.\nfloat K(vec4 C,vec3 ro,vec3 rd)\n{\n    float P2=dot(rd.xy,rd.xy)/(C.w*C.w),P=sqrt(P2);\n    float Q=2.0*dot(ro.xy,rd.xy)/(C.w*C.w);\n    float R=dot(ro.xy,ro.xy)/(C.w*C.w);\n    float A=dot(rd.xy,C.xy);\n    float B=dot(ro.xy,C.xy)+C.z;\n    return sqrt(pi)*cos(0.5*A*Q/(P*P)-B)*exp(-R+(Q*Q-A*A)/(4.0*P*P))/P;\n}\n\n// Indefinite integral ∫ G(C,(ro+t*rd).xy) dt.\n// NOTE: ro and rd are in beam's coordinate system.\nfloat J(vec4 C,vec3 ro,vec3 rd,float t)\n{\n    float P2=dot(rd.xy,rd.xy)/(C.w*C.w),P=sqrt(P2);\n    float Q=2.0*dot(ro.xy,rd.xy)/(C.w*C.w);\n    float R=dot(ro.xy,ro.xy)/(C.w*C.w);\n    float A=dot(rd.xy,C.xy);\n    float B=dot(ro.xy,C.xy)+C.z;\n    float X=0.5*Q/P;\n    float Y=0.5*A/P;\n    float Z=2.0*X*Y-B;\n    vec2 v=F(vec2(P*t+X,Y));\n    return (sqrt(pi)/(2.0*P))*exp(X*X-R)*(cos(Z)*v.x-sin(Z)*v.y);\n}\n\n// Definite integral ∫ G(C,(ro+t*rd).xy) dt on [L,H].\n// NOTE: ro and rd are in beam's coordinate system.\nfloat I_exact(vec4 C,vec3 ro,vec3 rd,float L,float H)\n{\n    float P2=dot(rd.xy,rd.xy)/(C.w*C.w),P=sqrt(P2);\n    float Q=2.0*dot(ro.xy,rd.xy)/(C.w*C.w);\n    float R=dot(ro.xy,ro.xy)/(C.w*C.w);\n    float A=dot(rd.xy,C.xy);\n    float B=dot(ro.xy,C.xy)+C.z;\n    float X=0.5*Q/P;\n    float Y=0.5*A/P;\n    float Z=2.0*X*Y-B;\n    vec2 Lv=F(vec2(P*L+X,Y));\n    vec2 Hv=F(vec2(P*H+X,Y));\n    return (sqrt(pi)/(2.0*P))*exp(X*X-R)*(cos(Z)*(Hv.x-Lv.x)-sin(Z)*(Hv.y-Lv.y));\n}\n\n// Approximation of the above.\nfloat I_approx(vec4 C,vec3 ro,vec3 rd,float L,float H)\n{\n    float P2=dot(rd.xy,rd.xy)/(C.w*C.w),P=sqrt(P2);\n    float Q=2.0*dot(ro.xy,rd.xy)/(C.w*C.w);\n    float R=dot(ro.xy,ro.xy)/(C.w*C.w);\n    float A=dot(rd.xy,C.xy);\n    float B=dot(ro.xy,C.xy)+C.z;\n    float X=0.5*Q/P;\n    float Y=0.5*A/P;\n    float Z=2.0*X*Y-B;\n    vec2 Lv=F_approx(vec2(P*L+X,Y));\n    vec2 Hv=F_approx(vec2(P*H+X,Y));\n    return (sqrt(pi)/(2.0*P))*exp(X*X-R)*(cos(Z)*(Hv.x-Lv.x)-sin(Z)*(Hv.y-Lv.y));\n}\n\n// Fake of the above.\n// Exact for C.xyz=0.\nfloat I_fake(vec4 C,vec3 ro,vec3 rd,float L,float H)\n{\n    float P2=dot(rd.xy,rd.xy)/(C.w*C.w),P=sqrt(P2);\n    float Q=2.0*dot(ro.xy,rd.xy)/(C.w*C.w);\n    float R=dot(ro.xy,ro.xy)/(C.w*C.w);\n    float A=dot(rd.xy,C.xy);\n    float B=dot(ro.xy,C.xy)+C.z;\n    float X=0.5*Q/P;\n    float Y=0.5*A/P;\n    float Z=2.0*X*Y-B;\n    return 0.5*(erf(H*P+X)-erf(L*P+X))*sqrt(pi)*cos(0.5*A*Q/(P*P)-B)*exp(-R+(Q*Q-A*A)/(4.0*P*P))/P;\n}\n\nfloat I(vec4 C,vec3 ro,vec3 rd,float L,float H)\n{\n    float id=3.0*abs(iMouse.z)/iResolution.x;\n    if     (id>=2.0) return I_exact (C,ro,rd,L,H);\n    else if(id>=1.0) return I_approx(C,ro,rd,L,H);\n    else             return I_fake  (C,ro,rd,L,H);\n}\n\n//==============================================================================\n// Terrain texture.\n\n//https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)| 1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nfloat rnd(ivec2 v)\n{\n    return float(int(hash(uint(v.x+65536*v.y))))*4.6566129e-10;\n}\n\nfloat vnoise(vec2 v)\n{\n    ivec2 i=ivec2(floor(v)),e=ivec2(0,1);\n    v=smoothstep(0.0,1.0,v-vec2(i));\n    return mix(\n        mix(rnd(i+e.xx),rnd(i+e.yx),v.x),\n        mix(rnd(i+e.xy),rnd(i+e.yy),v.x),v.y);\n}\n\nfloat fbm(vec2 v)\n{\n    float ret=0.0;\n    float w=1.0;\n    for(int i=0;i<5;++i)\n    {\n        ret+=w*vnoise(v);\n        v *=mat2(1.6,1.2,-1.2,1.6);\n        w*=0.5;\n    }\n    return ret;\n}\n\n//==============================================================================\n// Phase function.\n\n// Based on\n//     https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\nfloat Phase(float g,float c)\n{\n    float d=1.0+g*g-2.0*g*c;\n    return (1.5*(1.0-g*g)/(2.0+g*g))*(1.0+c*c)/(d*sqrt(d));\n}\n\n//==============================================================================\n// Main image.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tfloat a=0.25*iTime;\n    vec3 col=vec3(0.25,0.5,0.75);\n    // Camera setup.\n    // +x=East, +y=North, +z=Up.\n\tvec3 ro=vec3(7.0*cos(a)+sin(1.3*a),5.0*sin(0.7*a),5.0*sin(a)+cos(1.3*a)+7.0);\n    vec3 ta=vec3(0.0,0.0,0.0);\n    vec3 ww=normalize(ta-ro);\n    vec3 uu=normalize(cross(ww,vec3(0.0,0.0,1.0)));\n    vec3 vv=normalize(cross(uu,ww));\n\tvec3 rd=normalize(xy.x*uu+xy.y*vv+1.5*ww);\n    // Beams.\n    vec4 Cr0=vec4(0,0,0,2),Cr1=vec4(2,1,4.+a,2);\n    vec4 Cg0=vec4(0,0,0,2),Cg1=vec4(5,2,2.+a,2);\n    vec4 Cb0=vec4(0,0,0,2),Cb1=vec4(2,4,3.+a,2);\n    a*=0.25;\n    vec3 Ro=vec3(5,4,2)*(sin(vec3(5,2,7)*a+1.0)+sin(vec3(6,2,5)*a+4.0))+vec3(0,0,7);\n    vec3 Go=vec3(7,3,2)*(sin(vec3(4,5,4)*a+2.0)+sin(vec3(3,4,7)*a+5.0))+vec3(0,0,7);\n    vec3 Bo=vec3(4,7,2)*(sin(vec3(2,7,5)*a+3.0)+sin(vec3(3,5,4)*a+6.0))+vec3(0,0,7);\n    vec3 Rt=vec3(3,2,0)*(sin(vec3(4,4,0)*a)+sin(vec3(5,1,0)*a));\n    vec3 Gt=vec3(4,3,0)*(sin(vec3(3,5,0)*a)+sin(vec3(2,3,0)*a));\n    vec3 Bt=vec3(2,5,0)*(sin(vec3(1,2,0)*a)+sin(vec3(5,4,0)*a));\n    vec3 Rz=normalize(Ro-Rt),Ry=normalize(cross(Rz,vec3(1,0,0))),Rx=cross(Ry,Rz);\n    vec3 Gz=normalize(Go-Gt),Gy=normalize(cross(Gz,vec3(1,0,0))),Gx=cross(Gy,Gz);\n    vec3 Bz=normalize(Bo-Bt),By=normalize(cross(Bz,vec3(1,0,0))),Bx=cross(By,Bz);\n    mat3 Rm=mat3(Rx,Ry,Rz);\n    mat3 Gm=mat3(Gx,Gy,Gz);\n    mat3 Bm=mat3(Bx,By,Bz);\n    // Ray-ground intersection.\n    float t=-ro.z/rd.z;\n    vec3 v=ro+t*rd;\n    if(t>0.0)\n    {\n        col=mix(col,vec3(0.8,0.4,0.2)*(0.5+0.25*exp(-length(v-ro)/32.0)*fbm(v.xy)),exp(-length(v-ro)/512.0));\n        vec3 Rv=(v-Ro)*Rm;\n        vec3 Gv=(v-Go)*Gm;\n        vec3 Bv=(v-Bo)*Bm;\n        // NOTE: multiplying by .z provides Lambert factor.\n        col+=vec3(0.7,0.2,0.2)*Rz.z*(G(Cr0,Rv.xy)+0.5*G(Cr1,Rv.xy));\n        col+=vec3(0.2,0.7,0.2)*Gz.z*(G(Cg0,Gv.xy)+0.5*G(Cg1,Gv.xy));\n        col+=vec3(0.2,0.2,0.7)*Bz.z*(G(Cb0,Bv.xy)+0.5*G(Cb1,Bv.xy));\n    }\n    else t=1e7;\n    float L=0.0,H=t;\n    // Beam render.\n    float g=-0.5; // Mie scattering coefficient.\n    col+=vec3(0.7,0.2,0.2)*Phase(g,dot(-rd,Rz))*(I(Cr0,(ro-Ro)*Rm,rd*Rm,L,H)+0.5*I(Cr1,(ro-Ro)*Rm,rd*Rm,L,H));\n    col+=vec3(0.0,0.7,0.2)*Phase(g,dot(-rd,Gz))*(I(Cg0,(ro-Go)*Gm,rd*Gm,L,H)+0.5*I(Cg1,(ro-Go)*Gm,rd*Gm,L,H));\n    col+=vec3(0.0,0.2,0.7)*Phase(g,dot(-rd,Bz))*(I(Cb0,(ro-Bo)*Bm,rd*Bm,L,H)+0.5*I(Cb1,(ro-Bo)*Bm,rd*Bm,L,H));\n    if(fragCoord.y<32.0) col+=0.25*floor(3.0*fragCoord.x/iResolution.x)-0.125;\n    col.xyz=mix(12.92*col.xyz,1.055*pow(col.xyz,vec3(1.0/2.4))-0.055,step(0.0031308,col.xyz)); // sRGB\n\tfragColor=vec4(col.xyz,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}