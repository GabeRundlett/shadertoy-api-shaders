{
    "Shader": {
        "info": {
            "date": "1500066247",
            "description": "Reused for API, you're not really supposed to see this.",
            "flags": 48,
            "hasliked": 0,
            "id": "Xs2fDR",
            "likes": 21,
            "name": "Import Temp",
            "published": 3,
            "tags": [
                "temp"
            ],
            "usePreview": 0,
            "username": "cornusammonis",
            "viewed": 989
        },
        "renderpass": [
            {
                "code": "// Fork of \"Multispectral Mixing Fluid 6\" by cornusammonis. https://shadertoy.com/view/tsVcDD\n// 2020-10-19 06:18:08\n\n// Fork of \"Multispectral Mixing Fluid 5\" by cornusammonis. https://shadertoy.com/view/tsKyDD\n// 2020-10-17 03:16:24\n\n// Fork of \"Multispectral Mixing Fluid 4b\" by cornusammonis. https://shadertoy.com/view/WdycDD\n// 2020-10-16 22:31:44\n\n// Fork of \"Multispectral Mixing Fluid 4\" by cornusammonis. https://shadertoy.com/view/3dyyDD\n// 2020-10-16 03:31:45\n\n// Fork of \"Multispectral Mixing Fluid 3\" by cornusammonis. https://shadertoy.com/view/3dyyWD\n// 2020-10-16 01:47:26\n\n// Fork of \"Multispectral Mixing Fluid 2\" by cornusammonis. https://shadertoy.com/view/WdVcDh\n// 2020-10-15 22:48:27\n\n// Fork of \"Multispectral Mixing Fluid\" by cornusammonis. https://shadertoy.com/view/WdGyWh\n// 2020-10-15 03:12:14\n\n// Fork of \"Faster Multiscale MIP Fluid\" by cornusammonis. https://shadertoy.com/view/wdVSR3\n// 2020-10-14 04:24:29\n\n/*\n\tFor long-time Shadertoyers, you may notice that this bears a striking\n\tresemblance to Florian Berger's \"Spilled\" shader here: \n\t\thttps://www.shadertoy.com/view/MsGSRd\n\n\tI've used the same visualization code for the sake of comparison\n\t(and of course convenience).\n\n\tIn the spite of the visual similarity, the CFD algorithm itself bears \n\tnothing at all in common at first glance. Nonetheless, the resemblance\n\tis not a coincidence. This is not at all obvious without some fairly\n\tdeep analysis, but Florian's shader and mine are actually both \n\tapproximations of the same distribution, which boils down to sums of\n    second partial derivatives, which can be found here in the viscous stress \n\tportion of the filtered Navier-Stokes equations:\n\thttps://en.wikipedia.org/wiki/Large_eddy_simulation\n\n\tI may be wrong on this relation to Navier-Stokes, tell me if you\n\tknow otherwise.\n\n\tAt any rate, benchmarking this using Shadertoy Unofficial Plugin, here:\n\t\thttps://github.com/patuwwy/ShaderToy-Chrome-Plugin\n\tit can run at about 2400fps at 800x450, which is the default resolution \n\tfor me without going in fullscreen, or about 1100fps at 1200x675 on a 980Ti\n\t(64x paint calls). Pretty good! It runs well at 4K widescreen, but I'm not \n\tsure how to benchmark that in a browser.\n*/\n\n// This license applies to the visualization code below:\n/* \n\tCreated by florian berger (flockaroo) - 2016\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat getVal(vec2 uv)\n{\n    return texture(iChannel2,uv).x;\n    //return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv)\n{\n    return sample_biquadratic_gradient(iChannel2, iResolution.xy, uv, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv),0.2);\n    //n *= n;\n    n=normalize(n);\n    //fragColor=vec4(n,4);\n    vec3 light = normalize(vec3(1,1,2));\n    //float diff=clamp(dot(n,light),0.5,1.0);\n    //float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    //spec=pow(spec,12.0)*1.0;\n    \n    float spec = ggx(reflect(light,n), vec3(0,1,0), light, 0.4, 0.8);\n    \n    float d = texture(iChannel2,uv).x;\n    float occ = 0.0;\n    for (float m = 1.0; m <= 10.0; m +=1.0) {\n        float dm = texture(iChannel2, uv, m).x;\n        occ += smoothstep(-8.0, 8.0, (d - dm))/pow(m,1.5);\n    }\n\n    occ = pow(clamp(3.0-2.2*occ,0.0,1.0), 0.4);\n    //spec=0.0;\n\t//fragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n    fragColor = texture(iChannel0,uv);\n    //fragColor = 0.5+0.1*vec4(d);\n    fragColor = occ*(0.15*spec + (1.0+2.0*spec) * vec4(colorFromSpectrum(getPackedSpectrum(iChannel1, fragCoord)),1));\n    //fragColor = vec4(occ);\n    \n    \n    \n    \n    /*\n    fragColor = 0.5 + 0.3*texture(iChannel0,uv).zwzw;//vec4(colorFromSpectrum(getPackedSpectrum(iChannel1, fragCoord)),1);\n\t#define C(d) sample_biquadratic_exact_lod(iChannel0, uv + ((d)+0.), s)\n    int s = 5;\n    vec2 U = fragCoord.xy;\n    vec2 t = 1.0 / iResolution.xy;\n    //fragColor = 0.5 + 0.3 * C(-40,-22).xyxy;\n    //fragColor = 0.5 + 0.5 * C(vec2(-0.5)).xyxy;*/\n    \n    //fragColor = 0.5 + 0.2*vec4(textureLod(iChannel0, uv, 0.0).zw,0,0);\n    fragColor = mix(fragColor, texture(iChannel3, uv), uv.x > 0.5 ? 1.0 : 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\n//#define D(x,y) sample_biquadratic_exact(iChannel0, iResolution.xy, t*(U+vec2(x,y)))\n\n/*\nvec2 advect(vec2 uv, float ts){\n    vec2 AspectRatio = iResolution.xy/iResolution.y;\n    vec2 k1 = GetVelocityUV(posUV)/AspectRatio;\n    vec2 k2 = GetVelocityUV(posUV-0.5*k1*ts)/AspectRatio;\n    vec2 k3 = GetVelocityUV(posUV-0.5*k2*ts)/AspectRatio;\n    vec2 k4 = GetVelocityUV(posUV-k3*ts)/AspectRatio;\n    return ts/6.*(k1+2.0*k2+2.0*k3+k4);\n}*/\n\n#define E(d) sample_biquadratic_exact(iChannel0, iResolution.xy, uv + texel * (d+0.))\nvec4 advect(vec2 uv, vec2 v, float ts){\n    vec2 texel = 1.0/iResolution.xy;\n    uv += v * texel;\n    vec4 k1 = E();\n    vec4 k2 = E(-0.5*k1.xy*ts);\n    vec4 k3 = E(-0.5*k2.xy*ts);\n    vec4 k4 = E(-k3.xy*ts);\n    return 1.0*(k1+2.0*k2+2.0*k3+k4)/6.0;\n}\n\n//#define C(x,y) textureLod(iChannel0, t*(U+float(1<<s)*vec2(x,y)),float(s))\n#define C(x,y) sample_biquadratic_exact_lod(iChannel0, t*(U+float(1<<s)*vec2(x,y)), s) \n//#define D(x,y) texture(iChannel0, t*(U+vec2(x,y)))\n#define D(x,y) sample_biquadratic_exact(iChannel0, iResolution.xy, t*(U+vec2(x,y)))\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O = O-O;\n    vec2 t = 1./iResolution.xy;\n    vec2 uv = U*t;\n    vec2 diff = sample_biquadratic_gradient(iChannel2, iResolution.xy, uv, 0.0);\n    vec2 q = uv - .5;\n    int s = 10;\n    vec2 mdiff = vec2(0);\n    vec4 sample_prev = textureLod(iChannel0, uv, 0.0);\n    vec2 offset_prev = sample_prev.zw;\n    for (; s >= 0; s--) {\n        O.xy -= (float(s+1)) * (2.0 * vec2(C(0,1).x + C(0,-1).x, C(1,0).y + C(-1,0).y)\n            -4.0 * C(0,0).xy + (C(1,-1) - C(1,1) - C(-1,-1) + C(-1,1)).yx);\n        //mdiff += (1.0/float(s+1)) * sample_biquadratic_gradient_lod(iChannel2, uv, s);\n        mdiff += sample_biquadratic_gradient_lod(iChannel2, uv, s);\n    }\n    vec2 offset = 0.3*O.xy+0.03*mdiff;\n    vec2 new_offset = mix(offset,offset_prev,0.8);\n    //O = (D(O.x,O.y) + vec4(0e-4*q / (dot(q,q)+.01),0,0)) + vec4(0.2 * diff - t*offset,0,0);\n    //O = (advect(uv,offset,1.0) + vec4(0e-3*q / (dot(q,q)+.01),0,0)) + vec4(-0.1 * diff - t*offset,0,0);\n    O = (advect(uv,new_offset,1.0) + vec4(0e-3*q / (dot(q,q)+.01),0,0)) + vec4(-0.01 * mdiff - t*new_offset,0,0);\n    //O *= 1.0;\n    O.zw = new_offset;\n\n    if (iMouse.z > 0.0) {\n        vec4 mouseUV = iMouse / iResolution.xyxy;\n        vec2 delta = normz(mouseUV.zw - mouseUV.xy);\n        vec2 md = (mouseUV.xy - uv) * vec2(1.0,t.x/t.y);\n        float amp = clamp(1.0*exp(max(-24.0,-dot(md,md)/MOUSE_RADIUS)),0.0,1.0);\n\t\t\n\t\tO += vec4(delta * amp,0,0);\n    }\n\n    if(iChannelResolution[1].z < 1.0) {\n    \tO = vec4(1e-4);    \n    } else if(reset()) {\n        O = vec4(1e-4);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define MOUSE_RADIUS 0.0002\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x,0.0, 1.0) * 255.0);\n    uvec4 r = uvec4(x) & uvec4(0xFF);\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    vec4 fmag = vec4(r) / 255.0;\n    return fmag;\n}\n\n#define unpack(x) unpackUnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packUnorm4x8(x))\n\n#define unpack16(x) unpackSnorm2x16(floatBitsToUint(x))\n#define pack16(x) uintBitsToFloat(packSnorm2x16(x))\n\n\n#define WAVELENGTHS 16\n\n#define SQRT_TWO_PI 2.50662827463\nfloat gaussian(float x, float mu, float sig) {\n    return (1.0/(SQRT_TWO_PI*sig)) * exp(-0.5 * pow((x-mu)/sig,2.0));\n}\n\n#define SIGMA 2.2\n//          |         |\n//0 1 2 3 4 5 6 7 8 9 A B C D E F\n/*vec3 sampleWeights(float i) {\n\treturn vec3(gaussian(i,2.666,SIGMA),gaussian(i,7.5,SIGMA),gaussian(i,12.333,SIGMA));\n}*/\n\nvec3 sampleWeights(float i) {\n\treturn vec3(gaussian(i,2.666,SIGMA),gaussian(i,7.5,SIGMA),gaussian(i,12.333,SIGMA));\n}\n\n\n/*#define LOG_SCALE0 0.82\n#define LOG_SCALE1 0.25\n#define LOG_SCALE2 7.0*/\n\n/*\n#define LOG_SCALE0 0.9\n#define LOG_SCALE1 0.1\n#define LOG_SCALE2 6.0*/\n\n#define LOG_SCALE0 0.82\n#define LOG_SCALE1 0.25\n#define LOG_SCALE2 7.0\n\nvoid upsample(vec3 upsamp, inout float spectrum[WAVELENGTHS]) {\n    vec3 col = vec3(0);\n    vec3 dw = vec3(0);\n    \n    for(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n        dw += sw;\n    }\n    \n    for(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n        spectrum[i] = -LOG_SCALE1*log(LOG_SCALE2*LOG_SCALE0*dot(sw/dw,1.0-upsamp));\n    }\n}\n\nvec3 downsample(float spectrum[WAVELENGTHS]) {\n    vec3 col = vec3(0);\n    for(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n        col += sw * (1.0-exp(-spectrum[i]/LOG_SCALE1))/LOG_SCALE0;\n    }\n    return col;\n}\n\nvoid vec16toArray(inout float spectrum[WAVELENGTHS], vec4 spec0, vec4 spec1, vec4 spec2, vec4 spec3) {\n    spectrum[0] = spec0.x;\n    spectrum[1] = spec0.y;\n    spectrum[2] = spec0.z;\n    spectrum[3] = spec0.w;\n    spectrum[4] = spec1.x;\n    spectrum[5] = spec1.y;\n    spectrum[6] = spec1.z;\n    spectrum[7] = spec1.w;\n    spectrum[8] = spec2.x;\n    spectrum[9] = spec2.y;\n    spectrum[10] = spec2.z;\n    spectrum[11] = spec2.w;\n    spectrum[12] = spec3.x;\n    spectrum[13] = spec3.y;\n    spectrum[14] = spec3.z;\n    spectrum[15] = spec3.w; \t\n}\n\nvoid unpackSpectrum(vec4 packed, inout float spectrum[WAVELENGTHS]) {\n    vec4 unpack0 = unpack(packed.x);\n    vec4 unpack1 = unpack(packed.y);\n    vec4 unpack2 = unpack(packed.z);\n    vec4 unpack3 = unpack(packed.w);\n    \n    vec16toArray(spectrum, unpack0, unpack1, unpack2, unpack3);    \n}\n\nvec3 colorFromSpectrum(vec4 packed) {\n\tfloat spectrum[WAVELENGTHS];\n\tunpackSpectrum(packed, spectrum);\n    return downsample(spectrum);\n}\n\nvec4 packSpectrum(float spectrum[WAVELENGTHS]) {\n\treturn vec4(\n        pack(vec4(spectrum[0],spectrum[1],spectrum[2],spectrum[3])),\n        pack(vec4(spectrum[4],spectrum[5],spectrum[6],spectrum[7])),\n        pack(vec4(spectrum[8],spectrum[9],spectrum[10],spectrum[11])),\n        pack(vec4(spectrum[12],spectrum[13],spectrum[14],spectrum[15]))\n    );    \n}\n\nvec4 getPackedSpectrum(sampler2D channel, vec2 fragCoord) {\n\treturn texelFetch(channel, ivec2(fragCoord), 0);    \n}\n\n// Fast Biquadratic Interpolation by paniq, Public Domain\n// https://www.shadertoy.com/view/wtXXDl\n\n// avoid hardware interpolation\n#define RES iResolution.xy\n#define RESMOD(d) (ivec2(RES) + ((d) % ivec2(RES))) % ivec2(RES)\nvec4 sample_biquadratic_exact(sampler2D channel, vec2 iResolution, vec2 uv) {\n    vec2 q = fract(uv * iResolution);\n    ivec2 t = ivec2(floor(uv * iResolution));\n    ivec3 e = ivec3(-1, 0, 1);\n    vec4 s00 = texelFetch(channel, RESMOD(t + e.xx), 0);\n    vec4 s01 = texelFetch(channel, RESMOD(t + e.xy), 0);\n    vec4 s02 = texelFetch(channel, RESMOD(t + e.xz), 0);\n    vec4 s12 = texelFetch(channel, RESMOD(t + e.yz), 0);\n    vec4 s11 = texelFetch(channel, RESMOD(t + e.yy), 0);\n    vec4 s10 = texelFetch(channel, RESMOD(t + e.yx), 0);\n    vec4 s20 = texelFetch(channel, RESMOD(t + e.zx), 0);\n    vec4 s21 = texelFetch(channel, RESMOD(t + e.zy), 0);\n    vec4 s22 = texelFetch(channel, RESMOD(t + e.zz), 0);    \n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\t\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);    \n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n//#define RES2 \n#define RESMOD2(d) (LODres + ((d) % LODres)) % LODres\n\n//#define PM(d) mod(vec2(1) + mod(d,vec2(1)),vec2(1))\n#define PM(d) fract(d)\n\nvec4 sample_biquadratic_exact_lod(sampler2D channel, vec2 uv, int lod) {\n    //return textureLod(channel, uv, float(lod));\n    ivec2 LODres = textureSize(channel, lod);\n    vec2 FC = uv * vec2(LODres);\n    vec2 q = fract(FC);\n    ivec2 t = ivec2(floor(FC));\n    ivec3 e = ivec3(-1, 0, 1);\n    vec4 s00 = texelFetch(channel, RESMOD2(t + e.xx), lod);\n    vec4 s01 = texelFetch(channel, RESMOD2(t + e.xy), lod);\n    vec4 s02 = texelFetch(channel, RESMOD2(t + e.xz), lod);\n    vec4 s12 = texelFetch(channel, RESMOD2(t + e.yz), lod);\n    vec4 s11 = texelFetch(channel, RESMOD2(t + e.yy), lod);\n    vec4 s10 = texelFetch(channel, RESMOD2(t + e.yx), lod);\n    vec4 s20 = texelFetch(channel, RESMOD2(t + e.zx), lod);\n    vec4 s21 = texelFetch(channel, RESMOD2(t + e.zy), lod);\n    vec4 s22 = texelFetch(channel, RESMOD2(t + e.zz), lod);    \n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\t\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);    \n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n// accurate analytical gradient with 8 taps\nvec2 sample_biquadratic_gradient(sampler2D channel, vec2 res, vec2 uv, float mip) {\n    vec2 q = fract(uv * res);\n    vec2 c = (q*(q - 1.0) + 0.5) / res;\n    vec2 w0 = uv - c;\n    vec2 w1 = uv + c;\n    vec2 cc = 0.5 / res;\n    vec2 ww0 = uv - cc;\n    vec2 ww1 = uv + cc;\n    float nx0 = textureLod(channel, vec2(ww1.x, w0.y), mip).r - textureLod(channel, vec2(ww0.x, w0.y), mip).r;\n    float nx1 = textureLod(channel, vec2(ww1.x, w1.y), mip).r - textureLod(channel, vec2(ww0.x, w1.y), mip).r;\n    \n    float ny0 = textureLod(channel, vec2(w0.x, ww1.y), mip).r - textureLod(channel, vec2(w0.x, ww0.y), mip).r;\n    float ny1 = textureLod(channel, vec2(w1.x, ww1.y), mip).r - textureLod(channel, vec2(w1.x, ww0.y), mip).r;\n    \n\treturn vec2(nx0 + nx1, ny0 + ny1) / 2.0;\n}\n\nvec4 biquad(vec2 q, vec4 s00, vec4 s01, vec4 s02, vec4 s10, vec4 s11, vec4 s12, vec4 s20, vec4 s21, vec4 s22) {\n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\t\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);    \n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\t    \n}\n\n// avoid hardware interpolation\nvoid sample_biquadratic_exact_unpack(sampler2D channel, vec2 uv, vec2 iResolution, out float spectrum[WAVELENGTHS]) {\n    vec2 q = fract(uv * iResolution);\n    ivec2 t = ivec2(floor(uv * iResolution));\n    ivec3 e = ivec3(-1, 0, 1);\n    \n    vec4 p00 = texelFetch(channel, RESMOD(t + e.xx), 0);\n    vec4 p01 = texelFetch(channel, RESMOD(t + e.xy), 0);\n    vec4 p02 = texelFetch(channel, RESMOD(t + e.xz), 0);\n    vec4 p12 = texelFetch(channel, RESMOD(t + e.yz), 0);\n    vec4 p11 = texelFetch(channel, RESMOD(t + e.yy), 0);\n    vec4 p10 = texelFetch(channel, RESMOD(t + e.yx), 0);\n    vec4 p20 = texelFetch(channel, RESMOD(t + e.zx), 0);\n    vec4 p21 = texelFetch(channel, RESMOD(t + e.zy), 0);\n    vec4 p22 = texelFetch(channel, RESMOD(t + e.zz), 0);\n    \n    \n    vec4 spec0 = biquad(q, \n                   unpack(p00.x), unpack(p01.x), unpack(p02.x),\n                   unpack(p10.x), unpack(p11.x), unpack(p11.x), \n                   unpack(p20.x), unpack(p21.x), unpack(p21.x));\n    \n    vec4 spec1 = biquad(q, \n                   unpack(p00.y), unpack(p01.y), unpack(p02.y),\n                   unpack(p10.y), unpack(p11.y), unpack(p11.y), \n                   unpack(p20.y), unpack(p21.y), unpack(p21.y));\n    \n    vec4 spec2 = biquad(q, \n                   unpack(p00.z), unpack(p01.z), unpack(p02.z),\n                   unpack(p10.z), unpack(p11.z), unpack(p11.z), \n                   unpack(p20.z), unpack(p21.z), unpack(p21.z));\n    \n    vec4 spec3 = biquad(q, \n                   unpack(p00.w), unpack(p01.w), unpack(p02.w),\n                   unpack(p10.w), unpack(p11.w), unpack(p11.w), \n                   unpack(p20.w), unpack(p21.w), unpack(p21.w));\n    \n    vec16toArray(spectrum, spec0, spec1, spec2, spec3);\n\n}\n\nvec4 bilin(vec2 q, vec4 p11, vec4 p12, vec4 p21, vec4 p22) {\n    vec4 x1 = mix(p11, p21, q.x);\n    vec4 x2 = mix(p12, p22, q.x);\n    return mix(x1, x2, q.y);    \n}\n\n\nvoid sample_bilinear_unpack(sampler2D channel, vec2 uv, vec2 iResolution, out float spectrum[WAVELENGTHS]) {\n    \n/*\n    vec2 pixel = P * c_textureSize + 0.5;\n    \n    vec2 frac = fract(pixel);\n    pixel = (floor(pixel) / c_textureSize) - vec2(c_onePixel/2.0);\n\n    vec3 C11 = texture(iChannel0, pixel + vec2( 0.0        , 0.0)).rgb;\n    vec3 C21 = texture(iChannel0, pixel + vec2( c_onePixel , 0.0)).rgb;\n    vec3 C12 = texture(iChannel0, pixel + vec2( 0.0        , c_onePixel)).rgb;\n    vec3 C22 = texture(iChannel0, pixel + vec2( c_onePixel , c_onePixel)).rgb;\n\n    vec3 x1 = mix(C11, C21, frac.x);\n    vec3 x2 = mix(C12, C22, frac.x);\n    return mix(x1, x2, frac.y);\n*/\n    \n    vec2 p = uv * iResolution - 0.5;\n    vec2 q = fract(p);\n    vec2 tx = 1.0 / iResolution;\n    \n    //ivec2 t = ivec2(floor(floor(p)/iResolution - tx/2.0));\n    ivec2 t = ivec2(floor(p+0.0));\n    \n    ivec3 e = ivec3(-1, 0, 1);\n    \n    vec4 p12 = texelFetch(channel, RESMOD(t + e.yz), 0);\n    vec4 p11 = texelFetch(channel, RESMOD(t + e.yy), 0);\n    vec4 p21 = texelFetch(channel, RESMOD(t + e.zy), 0);\n    vec4 p22 = texelFetch(channel, RESMOD(t + e.zz), 0);\n    \n    vec4 spec0 = bilin(q, \n                   unpack(p11.x), unpack(p12.x),\n                   unpack(p21.x), unpack(p22.x));\n    \n    vec4 spec1 = bilin(q, \n                   unpack(p11.y), unpack(p12.y),\n                   unpack(p21.y), unpack(p22.y));\n    \n    vec4 spec2 = bilin(q, \n                   unpack(p11.z), unpack(p12.z),\n                   unpack(p21.z), unpack(p22.z));\n    \n    vec4 spec3 = bilin(q, \n                   unpack(p11.w), unpack(p12.w),\n                   unpack(p21.w), unpack(p22.w));\n    \n    vec16toArray(spectrum, spec0, spec1, spec2, spec3);\n\n}\n\n\n#define SAMPLE_CHAN x\n\nvec2 sample_biquadratic_gradient_lod(sampler2D channel, vec2 uv, int lod) {\n    //uv = (uv * iResolution.xy - 0.5) / iResolution.xy;\n    ivec2 LODres = textureSize(channel, lod) - 0;\n    vec2 FC = uv * (vec2(LODres)) - vec2(0.0,0.0);\n    vec2 q = fract(FC);\n    ivec2 t = ivec2(floor(FC));\n    ivec3 e = ivec3(-1, 0, 1);\n    float s_sw = texelFetch(channel, RESMOD2(t + e.xx), lod).SAMPLE_CHAN;\n    float s_w  = texelFetch(channel, RESMOD2(t + e.xy), lod).SAMPLE_CHAN;\n    float s_nw = texelFetch(channel, RESMOD2(t + e.xz), lod).SAMPLE_CHAN;\n    float s_n  = texelFetch(channel, RESMOD2(t + e.yz), lod).SAMPLE_CHAN;\n    float s_c  = texelFetch(channel, RESMOD2(t + e.yy), lod).SAMPLE_CHAN;\n    float s_s  = texelFetch(channel, RESMOD2(t + e.yx), lod).SAMPLE_CHAN;\n    float s_se = texelFetch(channel, RESMOD2(t + e.zx), lod).SAMPLE_CHAN;\n    float s_e  = texelFetch(channel, RESMOD2(t + e.zy), lod).SAMPLE_CHAN;\n    float s_ne = texelFetch(channel, RESMOD2(t + e.zz), lod).SAMPLE_CHAN; \n    \n\tvec2 p = q * (q-1.0) + 0.5;\n\tvec2 nq  = 1.0 - q;\n\tvec2 nq2 = 1.0 - 2.0*q;\n\tvec2 np  = 1.0 - p;\n\tvec2 ppq = p+q-0.5;\n\tvec2 pmq = p-q+0.5;\n    \n\n\n\tvec2 W_c  = vec2(2.0 * np.y * nq2.x, 2.0 * np.x * nq2.y);\n\tvec2 W_n  = vec2(ppq.y * nq2.x, 2.0 * q.y * np.x);\n\tvec2 W_s  = vec2(pmq.y * nq2.x, -2.0 * nq.y * np.x);\n\tvec2 W_e  = vec2(2.0 * q.x * np.y, ppq.x * nq2.y);\n\tvec2 W_w  = vec2(-2.0 * nq.x * np.y, pmq.x * nq2.y);\n\tvec2 W_nw = vec2(-nq.x * ppq.y, pmq.x * q.y);\n\tvec2 W_se = vec2(q.x * pmq.y, -ppq.x * nq.y);\n\tvec2 W_ne = vec2(q.x * ppq.y, ppq.x * q.y);\n\tvec2 W_sw = vec2(-nq.x * pmq.y, -pmq.x * nq.y);\n\n\tvec2 sum = W_c * s_c + W_n * s_n + W_s * s_s + W_e * s_e + W_w * s_w \n\t\t\t+ W_nw * s_nw + W_se * s_se + W_ne * s_ne + W_sw * s_sw;\n\n\treturn sum / 2.0;\n}\n\n\n\n\n// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// a simple modification for this shader to get a vec4\nvec4 rand4( vec2 fragCoord, vec2 iResolution, int iFrame ) {\n    uvec2 p = uvec2(fragCoord);\n    uvec2 r = uvec2(iResolution);\n    uint c = p.x + r.x*p.y + r.x*r.y*uint(iFrame);\n\treturn vec4(hash3(c),hash1(c + 75132895U));   \n}\n// End IQ's integer hash\n\n\n\n\n\n\n\n\n\n// GGX from Noby's Goo shader https://www.shadertoy.com/view/lllBDM\n\n// MIT License: https://opensource.org/licenses/MIT\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "bool reset() {\n    return false;\n    //return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nfloat getVal(vec2 uv)\n{\n    return texture(iChannel3,uv).x;\n    //return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 tx = 1.0 / iResolution.xy;\n\n    float spectrum[WAVELENGTHS];\n    //vec2 dif = getGrad(uv, tx.x);\n    \n    vec4 A = textureLod(iChannel0, uv, 0.0); \n    vec2 a = 1.0*A.zw;// +0.5 * A.xy - 0.001*dif;\n    \n    vec4 packed = getPackedSpectrum(iChannel2, fragCoord);\n    unpackSpectrum(packed, spectrum);\n    \n    float spectrum_advect[WAVELENGTHS];\n    //sample_biquadratic_exact_unpack(iChannel2, uv + tx *a.xy, iResolution.xy, spectrum_advect);\n    sample_bilinear_unpack(iChannel2, uv + tx *a.xy, iResolution.xy, spectrum_advect);\n    \n    for (int i = 0; i < WAVELENGTHS; i++) {\n    \t spectrum[i] = mix(spectrum[i], spectrum_advect[i], 0.9);   \n    }\n    \n    if (iMouse.z > 0.0) {\n        vec4 mouseUV = iMouse / iResolution.xyxy;\n        vec2 delta = normz(mouseUV.zw - mouseUV.xy);\n        vec2 md = (mouseUV.xy - uv) * vec2(1.0,tx.x/tx.y);\n        float amp = clamp(10.0*exp(max(-24.0,-0.5*dot(md,md)/MOUSE_RADIUS)),0.0,1.0);\n\n        vec4 r0 = rand4(vec2(iTime), iResolution.xy, 0);\n        vec4 r1 = rand4(vec2(iTime), iResolution.xy, 1);\n        vec4 r2 = rand4(vec2(iTime), iResolution.xy, 2);\n        for (int i = 0; i < WAVELENGTHS; i++) {\n            /*\n            float spec = exp(- 64.0 * (\n                r0.x * gaussian(float(i), float(WAVELENGTHS) * r0.y, r0.z * 2.0) +\n                r1.x * gaussian(float(i), float(WAVELENGTHS) * r1.y, r1.z * 2.0) + \n                r2.x * gaussian(float(i), float(WAVELENGTHS) * r2.y, r2.z * 2.0)));*/ \n            \n            float spec = (\n                r0.x * gaussian(float(i), float(WAVELENGTHS) * r0.y, r0.z * 2.0) +\n                r1.x * gaussian(float(i), float(WAVELENGTHS) * r1.y, r1.z * 2.0) + \n                r2.x * gaussian(float(i), float(WAVELENGTHS) * r2.y, r2.z * 2.0));\n            \n            //spectrum[i] = mix(spectrum[i], spec, amp);\n    \t\t//spectrum[i] = max(1.0/255.0,spectrum[i] - spec * amp);\n\n            spectrum[i] = max(1.0/255.0,spectrum[i] + (2.0 * r0.w - 1.5) * spec * amp);\n    \t}\n    }\n    \n    //this seems to be a good texture initialization method:\n    if(iChannelResolution[1].z < 1.0) {\n        vec3 up = vec3(0);\n        upsample(up, spectrum);  \n        fragColor = packSpectrum(spectrum);\n    } else if((iChannelResolution[1].z == 1.0 && texture(iChannel2,vec2(0.5)) == vec4(0)) || reset()) {\n        vec3 up = textureLod(iChannel1, uv, 0.0).xyz;\n        upsample(up, spectrum);  \n        fragColor = packSpectrum(spectrum);\n    } else {\n\t\tfragColor = packSpectrum(spectrum);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    \n/*\nU:\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-7.0606907e-001   4.6167731e-001  -1.4625093e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n\nV:\n 6.2750203e-003  5.2398670e-002  3.7276962e-001  \n-1.6414278e-003  4.2486224e-002  5.4995743e-001\n-4.3498466e-002 -1.0892533e-001  2.4023362e-001\n-1.3135171e-001 -3.3953004e-001 -7.8265086e-004\n-3.0484343e-001 -5.0984393e-001  1.8311873e-002\n-6.2280256e-001  3.2918550e-001 -2.3270335e-002\n-5.8224388e-076  3.2916004e-064 -1.0109051e-055\n 6.2280256e-001 -3.2918550e-001  2.3270335e-002\n 3.0484343e-001  5.0984393e-001 -1.8311873e-002\n 1.3135171e-001  3.3953004e-001  7.8265088e-004  \n 4.3498466e-002  1.0892533e-001 -2.4023362e-001\n 1.6414278e-003 -4.2486224e-002 -5.4995743e-001\n-6.2750203e-003 -5.2398670e-002 -3.7276962e-001\n\ndiag(S):\n\n  5.2045614e-001\n  4.5787111e-002\n  5.3607463e-003\n  1.3379961e-003\n  2.4305267e-005\n  6.5520767e-008\n  2.7241624e-013\n  1.8098574e-013\n  4.2556708e-014\n  3.2104951e-014\n  5.6655005e-016\n  2.1958056e-018\n  1.0637097e-030\n\n*/\n\n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n    \n    #define Po(m,n) texelFetch(iChannel0, RESMOD(ivec2(fragCoord) + ivec2(m,n)), 0)\n    #define Go(m,n) texelFetch(iChannel1, RESMOD(ivec2(fragCoord) + ivec2(m,n)), 0)\n    \n    vec2 P1 = vec2(0);\n    vec2 P2 = vec2(0);\n    vec2 P3 = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n\n        vec2 t = Po(i,0).xy;\n        float g = Go(i,0).x;\n        \n        P1 += vec2(p_x1[index], p_y1[index]) * t;\n        P2 += vec2(p_x2[index], p_y2[index]) * t;\n        P3 += vec2(p_x3[index], p_y3[index]) * t;\n        \n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n    \n    if(reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(pack16(P1),pack16(P2),pack16(P1), G);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n    \n    #define Po(m,n) texelFetch(iChannel0, RESMOD(ivec2(fragCoord) + ivec2(m,n)), 0)\n    \n    vec2 P = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n        \n        vec4 tx = Po(0,i);\n        vec2 t1 = unpack16(tx.x);\n        vec2 t2 = unpack16(tx.y);\n        vec2 t3 = unpack16(tx.z);\n\n        float g = tx.w;\n        \n        P += s_i[0] * vec2(p_x1[index], p_y1[index]).yx * t1;\n        P += s_i[1] * vec2(p_x2[index], p_y2[index]).yx * t2;\n        P += s_i[2] * vec2(p_x3[index], p_y3[index]).yx * t3;\n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n\n    if(reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(P.x + P.y + G);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}