{
    "Shader": {
        "info": {
            "date": "1491223640",
            "description": "An abstract representation of some shallow water flowing through a subterranean tunnel.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsScRD",
            "likes": 57,
            "name": "Abstract Water Tunnel",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "tunnel",
                "refraction",
                "water",
                "abstract"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 4579
        },
        "renderpass": [
            {
                "code": "/*\n\n\tAbstract Water Tunnel\n\t---------------------\n\n\tThis is merely an abstract representation of some water flowing through a \n\ttunnel, so isn't in any way supposed to be a treatise on water physics...\n    or even a loose reference. :)\n\n\tI've been meaning to do a basic reflection\\refraction example for a while. \n\tI made the setting abstract to avoid having to deal with the physics - \n\tand ultimately, GPU effort - that tend to accompany realistic scenes. \n\tHaving said that, the edges required to give a pseudo polygonal effect \n\tkind of complicated things a little.\n\n\tThe scene geometry is reasonably cheap. When including extra passes, it kind \n\tof has to be. I chose a watery setting, because I could get away with just \n\tone refractive bounce. In fact, if I'd chosen deep water, I probably could \n\thave got away with just the reflection, but I thought clear shallow water\n\twould look more interesting.\n\n\tI coded this on my fast machine, which can run it in fullscreen without a \n\tproblem, but I targeted it toward the 800x450 canvas. I was too afraid to \n\ttest it on my slow machine, just in case the FPS was much lower than I \n    expected. :) Regardless, I've done my best to keep operations, iterations, \n\tetc, down to a reasonable level. Hopefully, it'll run well enough on the \n\taverage machine.\n\n\tBy the way, I rushed in the comments, but I'll tidy them up in due course.\n\tIf you spot any errors, feel free to let me know - especially if I've done\n\tsomething stupid, like invert the refracted ray, etc. I make dumb mistakes \n    like that all... the... time. :D\n    \n\n    // Other examples:\n\n    // A more physically realistic example... that I proabably should have \n    // referred to. :)\n    Where the River Goes (+ PostFX) - P_Malin\n    https://www.shadertoy.com/view/XdG3zd\n\n    // Really nice.\n    Tunnel with lamps - TambakoJaguar\n\thttps://www.shadertoy.com/view/MsVXzK\n \n\n*/\n\n#define FAR 40. // Maximum ray distance. Analogous to the far plane.\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic picture focus adjusting thing with your eyes.\n//#define THREE_D \n\n//#define NO_RERACTION // Displays just the reflected water. Cheaper.\n\n\n// Scene object ID. Either water (0) or the tunnel walls (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n// Fabrice's consice, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7., 157., 113.);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    //p = p*p*(3. - 2.*p);\n    p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \nconst vec2 e = vec2(0, 1);\n\n\n\n/*\n// The standard vec3 to vec3 hash, commonly attributed to IQ. On a GPU, the \"sin\" function\n// tends to break down with large time values.\nvec3 hash(in vec3 p){\n    \n\n\tp = vec3( dot(p,vec3(127.1, 311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5, 183.3, 246.1)),\n\t\t\t  dot(p,vec3(113.5, 271.9, 124.6))); \n\t\n\tp = fract(sin(p)*43758.5453123)*2. - 1.;\n    \n    mat2  m = r2(iTime*2.);//in general use 3d rotation\n\tp.xy = m * p.xy;//rotate gradient vector\n    //p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n}\n*/\n\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash(vec3 p){\n\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz + 19.19);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n    \n    /*\n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = r2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;//rotate gradient vector\n    p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n    */\n\n}\n\n/*\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash(vec3 p){ \n   \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    //mat2  m = r2(iTime);//in general use 3d rotation\n\t//p.xy = m * p.xy;//rotate gradient vector\n    ////p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n\n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    p = fract(vec3(2097152, 262144, 32768)*n); \n    return sin(p*6.2831853 + iTime); \n}\n*/\n\n// Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into cubes, \n// attach random 3D vectors to each of the cube's eight verticies, then smoothly \n// interpolate the space between them.\nfloat gradN3D(in vec3 f){\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec3 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec3 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec3 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec3 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec3 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec3 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between\n    // cubes, the result is blending of random values throughout the 3D space. By the way, the \"dot\" operation\n    // makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(mix(dot(hash(p + e.xxx), f - e.xxx), dot(hash(p + e.yxx), f - e.yxx), w.x),\n                      mix(dot(hash(p + e.xyx), f - e.xyx), dot(hash(p + e.yyx), f - e.yyx), w.x), w.y),\n                  mix(mix(dot(hash(p + e.xxy), f - e.xxy), dot(hash(p + e.yxy), f - e.yxy), w.x),\n                      mix(dot(hash(p + e.xyy), f - e.xyy), dot(hash(p + e.yyy), f - e.yyy), w.x), w.y), w.z);\n    \n    // Taking the final result, and putting it into the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n\n/* \nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    \n    p = fract(p) - .5;    \n    return dot(p, p);\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.5));\n    \n    \n    //p = fract(p) - .5;    \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz))*1.5;\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n    \n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    //p = abs(fract(p)-.5);\n    //return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    //return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n\n\nfloat cellTile(in vec3 p){\n    \n     \n    vec3 d = vec3(.75); // Set the maximum.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    d.z = drawObject(p - vec3(.81, .62, .53));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawObject(p - vec3(.39, .2, .11));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n     \n   \n    d.z = drawObject(p - vec3(.62, .24, .06));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawObject(p - vec3(.2, .82, .64));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n    //d = sqrt(d);\n    \n    //return 1. - (d.x*2.66);\n    return ((d.y - d.x)*2.66);\n    //return (1.-sqrt(d.x)*1.33);\n    \n} \n*/\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0);\n    //float s = sin(z/24.)*cos(z/12.);\n    //return vec2(s*12., 0.);\n    \n    return vec2(sin(z*.15)*2.4, cos(z*.25)*1.7); \n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x - floor(x) - .5);} // Triangle function.\n// PF - phase variance. Varies between zero and 1. Zero is redundant, as it returns the triangle function.\nvec3 trap(in vec3 x, float pf){ return (tri(x - pf*.125) + tri(x + pf*.125))*.5; } // Trapezoid function.\n\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    // Far more interesting formations, and fast, but not fast enough for this example.\n    //return cellTile(p/5.)*.75 + cellTile(p/2.5)*.25; \n    \n\t//return dot(tri(p*.384 + tri(p.yzx*.192)), vec3(.666));\n    return dot(trap(p*.384 + trap(p.yzx*.192, .75), .75), vec3(.666));\n}\n\n// Perturbing the water. Just a very basic sinusoidal combination. Definitely not water physics. :)\nfloat surfFunc2(in vec3 p){\n    \n    p += vec3(0, 0, -iTime*4.); // Flow it in the Z-direction - down the tunnel.\n    \n\treturn dot(sin(p + sin(p.yzx*2. + iTime*1.)), vec3(.1666)) + .5;\n\n}\n \n\n// Standard tunnel distance function with some perturbation thrown into the mix. A water plane has been \n// worked in also. A tunnel is just a tube with a smoothly shifting center as you traverse lengthwise. \n// The walls of the tube are perturbed by a pretty cheap 3D surface function.\nfloat map(vec3 p){\n    \n    float sf = surfFunc(p); // Some triangular based noise to perturb the walls. Gives a low-poly effect.\n\n    p.xy -= path(p.z); // Wrap the tunnel around the path.\n    \n \n    // Round tunnel: Euclidean distance: length(tun.xy)\n    float n = 1. - length(p.xy*vec2(0.5, 0.7071)) + (0.5 - sf);\n    \n    // Square tunnel: Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    //float n = 1.- max(tun.x, tun.y) + (0.5 - sf);\n    \n    // Rounded square tunnel.\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    //float n = 1. - pow(dot(pow(tun, vec2(4)), vec2(1)), 1./4.) + (0.5 - sf);\n    \n    // Hexagonal tunnel.\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.75);\n    //float n = 1. - max(tun.x*.866025 + tun.y*.5, tun.y) + (0.5 - sf); //1.133975\n    \n    \n    sf = surfFunc2(p); // Some watery perturbation. Very minimal.\n    p.y += (.5-sf)*.5 + .85; // Add it to the water surface plane.\n    \n    // Object ID.\n    objID = step(n, p.y);\n\n    return min(n, p.y); // Return the object isovalue (distance).\n    \n \n}\n\n// The refraction distance field. It's exactly the same as above, but doesn't include\n// the water plane. It's here to save cycles.\nfloat mapRef(vec3 p){\n    \n    float sf = surfFunc(p); // Some triangular based noise to perturb the walls.\n\n    p.xy -= path(p.z); // Wrap the tunnel around the path.\n   \n    // Round tunnel: Euclidean distance: length(tun.xy)\n    float n = 1. - length(p.xy*vec2(0.5, 0.7071)) + (0.5 - sf);\n    \n    // Square tunnel: Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    //float n = 1.- max(tun.x, tun.y) + (0.5 - sf);\n    \n    // Rounded square tunnel.\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    //float n = 1. - pow(dot(pow(tun, vec2(4)), vec2(1)), 1./4.) + (0.5 - sf);\n    \n    // Hexagonal tunnel.\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.75);\n    //float n = 1. - max(tun.x*.866025 + tun.y*.5, tun.y) + (0.5 - sf); //1.133975\n    \n    // Object ID.\n    objID = 1.;\n\n    return n; // Return to object isovalue (distance).\n\n \n}\n\n\n// The bump function.\nfloat bumpFunc(vec3 p){\n\n    // Just one layer of moving gradient noise to give the impression that the surface is rippled.\n    // By the way, the cheaper cubic interpolation (see the function) shows grid lines when bump \n    // mapped. There's a quintic option, but the ripples are so small, that no one will notice.\n    return gradN3D(p*8. + vec3(0, iTime, 0.));\n}\n\n// Standard function-based bump mapping function.\nvec3 bumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpFunc(p);                 \n    vec3 grad = (vec3(bumpFunc(p - e.xyy), bumpFunc(p - e.yxy), bumpFunc(p - e.yyx)) - ref)/e.x;                     \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;//.001*(t*.125 + 1.)\n        \n        t += d*.86; // Using slightly more accuracy in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<32; i++){\n\n        d = map(ro + rd*t);//*rDir;\n        \n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n// Another pass, which is the first, and only, refracted bounce. \n// Virtually the same as above, but uses a slimmed down distance function - due\n// to the fact that the water plane doesn't need to be included.\nfloat traceRefr(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<32; i++){\n\n        d = mapRef(ro + rd*t);\n        \n        if((d<0. && abs(d)<0.002*(t*.25 + 1.)) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0015*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .2); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .2, 1.); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(6./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormalRefr(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(6./iResolution.y, 0);\n\n\tfloat d1 = mapRef(p + e.xyy), d2 = mapRef(p - e.xyy);\n\tfloat d3 = mapRef(p + e.yxy), d4 = mapRef(p - e.yxy);\n\tfloat d5 = mapRef(p + e.yyx), d6 = mapRef(p - e.yyx);\n\tfloat d = mapRef(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = mapRef(p + e.xyy), d2 = mapRef(p - e.xyy);\n\td3 = mapRef(p + e.yxy), d4 = mapRef(p - e.yxy);\n\td5 = mapRef(p + e.yyx), d6 = mapRef(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.003, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = mapRef(p + e.xyy), d2 = mapRef(p - e.xyy);\n\td3 = mapRef(p + e.yxy), d4 = mapRef(p - e.yxy);\n\td5 = mapRef(p + e.yyx), d6 = mapRef(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    // Object texture color, with some contract thrown in.\n    vec3 tx = tex3D(iChannel0, p/3., n );\n    tx = smoothstep(.1, .5, tx);\n    \n    // Coloring the tunnel walls.\n    if(svObjID>.5) {\n        \n        tx *= vec3(1, .55, .35); // Brownish.\n\n        // Optional: Extra crevice darkening from biological buildup. Adds\n        // depth - addition to the shadows and AO. \n        tx *= smoothstep(.1, .6, surfFunc(p))*.6 + .4;\n        \n        // Alternative algae in the crevices.\n        //float c = smoothstep(.1, .6, surfFunc(p));\n        //tx *= vec3(c*c, c, c*c*c)*.6 + .4;\n    }\n    else tx *= vec3(.6, .8,  1); // Tinting the water blue, to give bluish reflections.\n\n    \n    return tx; // pow(tx, vec3(1.33))*1.66;\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float edge, float crv, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 1.5/(1. + lDist*0.125 + lDist*lDist*0.025);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        diff = pow(diff, 4.)*.66 + pow(diff, 8.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = (objCol*(diff + 0.7 + vec3(1, .6, .2)*spec*2.));\n        \n        // Edges and curvature.\n        //sceneCol *= clamp(crv, 0., 1.);\n        //sceneCol += edge*.15;\n        sceneCol *= 1. - edge*.9;\n        \n\n        // Attenuation only. To save cycles, the shadows and ambient occlusion\n        // from the first pass only are used.\n        sceneCol *= atten;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - .5*iResolution.x);\n    uv.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n    \n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*3.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n\n   \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0, .25, 3.);\n    \n\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n    #ifdef THREE_D\n    ro.x -= sg*.15; lk.x -= sg*.15; lp.x -= sg*.15;\n    #endif\n    \n    /*\n    // Attempting to influence the camera with the wave motion. Needs a faster camera speed.\n\t// Anyway, it didn't make the cut, but it's a work in progress. :)\n    float sfRo = surfFunc2(ro);\n    float sfLk = surfFunc2(lk);\n    ro.y += sfRo*.16;\n    lk.y += sfLk*.12;\n    */\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + (uv.x*right + uv.y*up)*FOV);\n\n    // Edge and curvature variables. Passed to the normal functions... The refraction\n    // pass has seperate normal function.\n    float edge = 0., crv = 1.;\n\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    svObjID = objID;\n    float oSvObjID = svObjID;\n\n    \n\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Retrieving the normal at the hit point, plus the edge and curvature values.\n    vec3 sn = getNormal(sp, edge, crv);\n    \n\n    // Bump the water surface with some basic gradient noise.\n    if(oSvObjID<0.5) sn = bumpMap(sp, sn, .02);\n    \n    // Fresnel. Handy for all kinds of aesthetic purposes, but here it'll be used \n    // as a transmission ratio for the reflection and refraction.\n    float fr = clamp(1. + dot(rd, sn), 0., 1.);\n    \n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(sp, rd, sn, lp, edge, crv, t);\n    \n    // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n    // right without them.\n    float sh = softShadow(sp + sn*.0011, lp, 16., t); // Set to \"1.,\" if you can do without them.\n    float ao = calculateAO(sp, sn);\n    sh = (sh + ao*.3)*ao;\n    \n    // Fog - based off of distance from the camera. This will be applied at the end.\n    float fog = smoothstep(0., .95, t/FAR);\n    \n    \n    \n   \n    // SECOND PASS\n    \n    // Reflected and refracted rays.\n    vec3 refl = reflect(rd, sn); // Standard reflection.\n    vec3 refr = refract(rd, sn, 1./1.33); // Water refraction. Note the inverted index.\n    \n    // We're branching off from the same spot in two directions, so we'll use this so as\n    // not to interfere with the original surface point vector, \"sp.\" It was a style\n    // choice on my part, but there are other ways.\n    vec3 refSp; \n    \n    // REFLECTED PASS\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n\n\n    // The ray is edged off the surface, as required, but note that it has to be enough\n    // to avoid conflict with the break condition in the \"reflected\" trace algorithm. To\n    // make things difficult, I've chosen a relaxed break condition to speed up the first\n    // pass... but reflections (and shadows) require surface accuracy, so it's a choice \n    // between lag and accuracy, or speed and artifacts. I can't win. :) Having said that,\n    // this example seems to be pretty free of artifacts.\n    t = traceRef(sp + sn*0.0015, refl);\n    svObjID = objID;\n    \n    // Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n    refSp = sp + refl*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(refSp, edge, crv);//*rDir;\n \n    \n    vec3 reflColor = doColor(refSp, refl, sn, lp, edge, crv, t);\n    \n    #ifdef NO_RERACTION\n    // Fake deeper water version. Just reflected water with no refraction. Obviously cheaper.\n    if(oSvObjID<0.5) sceneColor = sceneColor*.1 +  reflColor*(fr*fr); \n    else sceneColor += reflColor*.5; // Add a portion of the reflection to the tunnel walls.\n    #else    \n    // REFRACTED PASS\n    \n    // If we hit the water surface, refract, retrieve the refracted color, then combine\n    // it with the reflected color retrieved above.\n    if(oSvObjID<0.5){  \n\n        // Standard reflracted ray, which is just a refraction of the unit\n        // direction ray from the intersected surface. You use the normal\n        // at the surface point to do this also.\n\n        t = traceRefr(sp - sn*.0025, refr);\n        svObjID = objID;\n\n        // Advancing the ray from the new origin, \"sp,\" to the new refracted hit point.\n        refSp = sp + refr*t;\n\n        // Retrieving the normal at the reflected hit point.\n        sn = getNormalRefr(refSp, edge, crv);\n\n        vec3 refrColor = doColor(refSp, refr, sn, lp, edge, crv, t);\n        \n        // Add a small portion of the diffuse water color to the reflected and refracted colors.\n        // The Fresnel value is used to provide a rough reflection to refraction ratio. It's based\n        // on very rough science, but it gives a nice enough effect.\n        sceneColor = sceneColor*.2 + mix(refrColor, reflColor, pow(fr, 5.)*.8 + .2)*vec3(.6, .8, 1);\n        \n    }\n    else { // If the tunnel walls were hit, just add the reflected color from above.\n        \n        sceneColor += reflColor*.5; // Add a portion of the reflection to the tunnel walls.\n        //sceneColor = mix(sceneColor, reflColor, fr*fr*fr*.75 + .25); // Another way.\n        //sceneColor = sceneColor*.5 + mix(sceneColor, reflColor, .75); // etc.\n    }\n    #endif\n   \n   \n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway.\n    sceneColor *= sh;\n    \n    \n    // APPLYING FOG\n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fogCol = vec3(.7, .75, 1)*(rd.y*.25 + .75)*1.5;\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n    \n    \n    // POSTPROCESSING\n    // Interesting red to blueish mix.\n    //sceneColor = mix(sceneColor, pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)), uv.y);\n    sceneColor = pow(max(sceneColor, 0.), vec3(1.33))*1.66; // Adding a bit of contrast.\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.5 + .5;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)).zyx, sceneColor, \n                    // pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n\n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}