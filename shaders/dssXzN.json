{
    "Shader": {
        "info": {
            "date": "1668624298",
            "description": "Gyroid Slices \nmusic for mood only - Greenhouse Gasses | by Cevin Key\n\n@smjtyazdi https://twitter.com/smjtyazdi/status/1484828390104485896 (sliced SDFs)",
            "flags": 0,
            "hasliked": 0,
            "id": "dssXzN",
            "likes": 66,
            "name": "Sliced Gyroid Fly Though",
            "published": 3,
            "tags": [
                "raymarching",
                "gyroid"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 964
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Sliced Gyroid Fly Though\n    11/16/22 | @byt3_m3chanic\n\n    music for mood only - Greenhouse Gasses | by Cevin Key\n\n    Original post here about sliced SDF's. Kind of updated\n    version (extra loops to help backside of sdf's)\n    \n    @smjtyazdi https://twitter.com/smjtyazdi/status/1484828390104485896\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n\n#define PI  3.1415926\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a){ return fract(sin(dot(a,vec2(22.34,35.34)))*483434.);}\n\n//globals\nmat2 trot;\nfloat glow=0.,tglow=0.;\n\nconst float ofx = 1.25;\n\nfloat sdGry(vec3 p, float s, float t, float b) {\n    p *= s;\n    return abs(dot(sin(p*ofx),cos(p.zxy))-b)/(s*ofx)-t;\n}\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,1.);\n    \n    vec3 q = p;\n    float tt = .5+.5*sin(T*.2);\n    \n    float k = 8./dot(p,p);\n    float mul = 1./k;\n    p*=k;\n    \n    p.xy*= trot;\n    p.yz += vec2(-1.25, T);\n    \n    float d = .365, mf = 1e5;\n    float mm = .25+.25*sin(T*.75);\n    \n    for(float j=-2.;j<2.;j++){\n        vec3 nf =p;\n        nf.z=round(nf.z/d+j)*d;\n        float ids = mod(nf.z,2.);\n        \n        float fd= sdGry(nf, .725, .05, .65);\n        \n        nf.z=clamp(p.z,nf.z-d/4.,nf.z+d/4.);\n        fd=length(vec2(max(.0,fd), nf.z-p.z));\n\n        float idx = mod(nf.z,5.);\n        \n        if(idx<mm+.025&&idx>mm) tglow+=.002/(.015+fd*fd);\n        if(ids<mm+.075&&ids>mm) glow+=.002/(.015+fd*fd);\n   \n        mf=min(mf,fd);\n    }\n    if(mf<res.x) res=vec2(mf,3.);\n\n    res.x*= mul/1.35;\n    return res;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    trot=rot(T*.072);\n    \n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,.5);\n    vec3 rd = normalize(vec3(uv, -1));\n    \n    float x = M.xy == vec2(0) || M.z < 0. ? 0. : -(M.y/R.y * .5 - .25) * PI;\n    float y = M.xy == vec2(0) || M.z < 0. ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n\n    mat2 rx = rot(x),ry = rot(y);\n    \n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 p = ro;\n\n    float d=0.,m=0.;\n    for(int i=0;i<164;i++){\n        vec2 t = map(p);\n        d += i<64? t.x*.35:t.x*.75;\n        m  = t.y;  \n        p = ro + rd * d;\n        if(t.x<d*1e-4||d>45.) break;\n    } \n    \n    float sp = .2+.2*sin(uv.x*4.1+T);\n    vec3 fog = mix(vec3(0.043,0.153,0.255),vec3(0.235,0.302,0.000),clamp((uv.y+.5-sp),0.,1.));\n\n    C = mix(C,vec3(glow,glow*.65,glow*.15),clamp(glow,.0,.6));\n    C = mix(C,vec3(tglow*.15,tglow*.465,tglow),clamp(tglow,.0,.8));\n    \n    C = mix(C,fog, 1.-exp(-20.*d*d*d));\n    \n    C = clamp(C,vec3(0),vec3(1));\n    O = vec4(pow(C, vec3(.4545)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}