{
    "Shader": {
        "info": {
            "date": "1494376130",
            "description": "two circles in a sphere, for personal experiments",
            "flags": 0,
            "hasliked": 0,
            "id": "XsScWV",
            "likes": 1,
            "name": "Two circles in a sphere",
            "published": 3,
            "tags": [
                "sphere"
            ],
            "usePreview": 0,
            "username": "starea",
            "viewed": 441
        },
        "renderpass": [
            {
                "code": "/** \n * Interactive Poisson Blending by Ruofei Du (DuRuofei.com)\n * starea @ ShaderToy,License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Demo: https://www.shadertoy.com/view/4l3Xzl\n * \n * Halftone Sphere remixed from Milo Yip's https://www.shadertoy.com/view/4tKSDm\n **/\n\nconst float SPHERE_DIAMETER = 0.9; \nconst float PI = 3.1415926535897932;\nconst float PI_2 = PI / 2.0; \n\nmat3 rotationXY(in vec2 angle);\nvec3 render(in vec2 p, in mat3 rot);\n\nvec3 tutorial(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // step 0: define the screen coordinates p\n    vec2 p = (fragCoord.xy / iResolution.xy - 0.5) * 2.0 * vec2(iResolution.x / iResolution.y, 1.0); \n    \n    vec3 col = (length(p) <= 0.9) ? vec3(0.0) : vec3(1.0); \n   \t\n    // step 1: normal vector, assuming the n_z to outwards the screen, n_x = p_x, n_y = p_y, n_z = sqrt(1-p_x^2-p_y^2)\n    vec3 n = vec3( p, sqrt(1.0 - dot(p, p)) ); \n    // visualize the normal vector, [-1, 1]\n    // col = n; \n    col = vec3(n * 0.5 + 0.5); \n    //return col;\n    \n    // step 2: define the spherical coordinates, [-1, 1]\n    vec2 s = vec2(acos(n.z), atan(n.y, n.x)) / PI; \n    col = vec3(s * 0.5 + 0.5, 0.0); \n    \n    // step 3: divide the sphere into many squares\n    uv = fract(s * vec2(30.0, 20.0));\n    col = vec3(uv, 0.0);\n    \n    // step 4: texture mapping with circles\n    float r = 0.4;\n    col = length(uv - 0.5) < r ? vec3(1.0) : vec3(0.0); \n    \n  \t// step 5: change the radius of the circles\n    r = ceil(s.x * 30.0) / 45.0;\n    col = length(uv - 0.5) < r ? vec3(1.0) : vec3(0.0); \n    \n    // step 6: define the rotation matrix based on the mouse\n    mat3 rot = rotationXY( vec2(iMouse.yx / iResolution.yx) * vec2(PI, -2.0 * PI) + vec2(-1.0, 1.0) * 0.5 * PI ); \n\n    const int KERNEL_RADIUS = 2;\n    const int KERNEL_SIZE = (KERNEL_RADIUS * 2) + 1; \n                          \n    // step 7: integrate all code into a function named render, and conduct super sampling\n    vec3 sum = vec3(0.0); \n    col = vec3(0.0); \n    for (int x = -KERNEL_RADIUS; x <= KERNEL_RADIUS; ++x) {\n        for (int y = -KERNEL_RADIUS; y <= KERNEL_RADIUS; ++y) {\n            sum += render( p + vec2(x, y) / (2.0 * iResolution.xx), rot); \n        }\n    }\n    col = sum / 25.0; \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec3 col = tutorial(fragColor, fragCoord); \n    fragColor = vec4(col, 1.0); \n}\n\n// rotation matrix from step 6, forked from https://www.shadertoy.com/view/4tKSDm\nmat3 rotationXY(in vec2 angle) {\n\tvec2 c = cos(angle);\n\tvec2 s = sin(angle);\n\treturn mat3(\n\t\tc.y, 0.0, -s.y,\n\t\ts.y * s.x, c.x, c.y * s.x,\n\t\ts.y * c.x, -s.x, c.y * c.x\n\t);\n}\n\n// integration from step 7\nvec3 render(in vec2 p, in mat3 rot) {\n    if (length(p) > SPHERE_DIAMETER) return vec3(1.0); \n    vec3 n = rot * vec3(p, sqrt(1.0 - dot(p, p)));\n    vec2 s = vec2(acos(n.z), atan(n.y, n.x)) / PI;\n    vec2 uv = fract(s * vec2(15.0, 15.0));\n    float r = ceil( (1.0 - abs(s.x * 2.0 - 1.0)) * 15.0) / 45.0;\n    // r = ceil(s.x * 30.0) / 45.0;\n    vec3 col = vec3(0.1);\n    if (uv.x < 0.1) col = vec3(1.0); \n    if (s.x < 0.85) col = vec3(0.1); \n    \n    // step 8, add light\n    vec3 lightPos = vec3(1.0, -1.0, -1.0);\n    //col += col * vec3(1.0) * max(dot(n, normalize(lightPos - n)), 0.0);\n    \n    return col; \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}