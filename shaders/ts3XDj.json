{
    "Shader": {
        "info": {
            "date": "1572884324",
            "description": "Going up to L=16 without totally completely blowing up!",
            "flags": 0,
            "hasliked": 0,
            "id": "ts3XDj",
            "likes": 10,
            "name": "Spherical harmonics optimized",
            "published": 3,
            "tags": [
                "solver",
                "spherical",
                "harmonics",
                "sh",
                "factorials"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 789
        },
        "renderpass": [
            {
                "code": "// Based on Spherical harmonics solver by Roninkoi\n// @ https://www.shadertoy.com/view/3dKGWG\n//\n// Thanks mainly to optimized factorial calculations this shader gets upto order L=16\n// while still retaining a little bit of semblance!\n//\n// (Factorials are incredibly wasteful, both computationally and cognitively,\n// for simple things like multiplying all the numbers between A and B together.)\n//\n// Changes: \n// - Automatic mode to go through all configurations (using triangular numbers!)\n// - Combining factorials to cancel unnecessary calculations\n// - Calculating factorials using floating-point to cope better with the range of values\n// - Using bit-shifting to calculate powers of -1 without looping\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Four bands of Spherical Harmonics functions (or atomic orbitals if you want). For\n// reference and fun.\n\nprecision highp float;\n\n// azimuthal quantum number\n#define L 11\n\n// magnetic quantum number\n#define M 1\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // antialias level (try 1, 2, 3, ...)\n#endif\n\n#define AUTOMATIC\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n#define PI 3.1415926535898\n#define E 2.7182818284591\n\nint factorial(int n) // n!\n{\n    int r = 1;\n    \n    for (int i = 2; i <= n; ++i) {\n        r *= i;\n    }\n    \n    return r;\n}\nfloat factorialDiv(int n, int j) // ((n+j)!)/((n-j)!)\n{\n    float r = 1.0;\n    for (int i = n-j+1; i <= n+j; i++) {\n        r *= float(i);\n    }\n    \n    return r;\n}\nfloat factorialMul(int n, int j) // ((n+j)!)*(n!)\n{\n    float r1 = 1.0;\n    for (int i = 2; i <= n; i++) {\n        r1 *= float(i);\n    }\n    float r2 = 1.0;\n    for (int i = n+1; i <= n+j; i++) {\n        r2 *= float(i);\n    }\n    \n    return r1*r1*r2;\n}\nfloat factorialDivDividedByMul(int l, int k, int m) { // ((l+k)!)/((l-k)!) /  ((k+m)!)*(k!)\n\n    float r1 = 1.0;\n    float r2 = 1.0;\n    float r3 = 1.0;\n    for (int i = l-k+1; i <= l+k  ; i++) r1 *= float(i);\n    for (int i = 2    ; i <=   k  ; i++) r2 *= float(i);\n    for (int i = k+1  ; i <=   k+m; i++) r3 *= float(i);\n    return r1/(r2*r2)/r3;\n}\n\nfloat powerim1(float x, int n) // negative power\n{\n    return float(1-((n&1)<<1));\n}\n\nfloat poweri(float x, int n) // negative power\n{\n/*    float p = 1.;\n    \n    for (int k = 0; k < n; ++k) {\n        p *= x;\n    }\n    \n    return p;*/\n    return pow(x,float(n));\n}\n\n// hypergeometric\nfloat F(int l, int m, int k, float x)\n{\n    //float f0 = float(factorialDiv(l + k)) / float(factorial(l - k));\n    //float f0 = factorialDiv(l,k);\n    float f0 = factorialDivDividedByMul(l,k,m);\n         \n    //float f1 = powerim1(-1., k) / float(factorial(m + k) * factorial(k));\n    //float f1 = powerim1(-1., k) / factorialMul(k, m);\n    float f1 = powerim1(-1., k);\n    \n    float f2 = poweri((1. - x) * 0.5, k);\n    \n    return f0 * f1 * f2;\n}\n\n// Legendre polynomials from hypergeometric, negative m\nfloat Pgm(int l, int m, float x)\n{\n    float lf = float(l);\n    float mf = float(m);\n    \n    float a = pow((1. - x) / (1. + x), mf * 0.5);\n    \n    float s = 0.0;\n    \n    for (int k = 0; k <= l; ++k) {\n        s += F(l, m, k, x);\n    }\n    \n    return a * s;\n}\n\n// Legendre polynomials from hypergeometric\nfloat Pg(int l, int m, float x)\n{\n    float lf = float(l);\n    float mf = float(m);\n    \n    //float a = float(factorial(l + m) / factorial(l - m));\n    \n    float pm = Pgm(l, m, x);\n    \n    //return a * pm;\n    return pm;\n}\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SH( in int l, in int m, in vec3 s ) \n{\n    vec3 ns = normalize(s);\n    \n    if (m < 0) {\n        float c = ns.x;\n        ns.x = ns.z;\n        ns.z = c;\n        m = -m;\n    }\n    \n    // quantum mechanics convention\n    float a0 = sqrt(\n//    \tfloat(2 * l + 1) / float(factorial(l + m)/factorial(l - m)) / (4.0 * PI)\n//    \tfloat(2 * l + 1) * float(factorial(l + m)/factorial(l - m)) / (4.0 * PI)\n    \tfloat(2 * l + 1) * factorialDiv(l,m) / (4.0 * PI)\n    );\n    \n    // spherical coordinates\n    float thetax = ns.y;\n    float phi = atan(ns.z, ns.x);\n    \n    float pl = Pg(l, m, abs(thetax));\n    if (thetax < 0.0) pl *= powerim1(-1., l + m);\n    \n    float r = powerim1(-1.0, (m)) * a0 * cos(float(m) * phi) * pl;\n    \n    return r;\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 p00 = p;\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n\n    int l = L;\n    int m = M;\n    #ifdef AUTOMATIC\n    int x = ((iFrame>>1)&0x7FF)/15;\n    int Y = int(floor(sqrt(0.25+float(2*x))-0.5));\n    int X = int(floor(float(x)-0.5*float(Y+Y*Y)));\n    l = Y+1;\n    m = X+1;\n    #endif\n\td=length(p00); n=p00/d; r = SH(l, m, p ); s = SHAPE; res = s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 3.0;//10.0;\n    float h = 1.0;\n    float t = 1.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<100; i++ )\n    {\n        if( h<0.001||t>maxd ) break;\n        vec3 p = ro+rd*t ;\n\t    vec3 res = map(p);\n        h = res.x;\n\t\tm = res.yz;\n        //t += h*0.3;\n        t += h*0.2;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\t\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 10.0*iMouse.x/iResolution.x;\n    float am = 2.*iMouse.y/iResolution.y - 1.;\n    float turn = radians(360./256.)*float(iFrame&0xFF);\n    vec3  ro = vec3(1.5*sin(an+turn),1.5*sin(am),1.5*cos(an+turn)) * 1.0;\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.3) * clamp(1.0-length(p)*0.5,0.0,1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}