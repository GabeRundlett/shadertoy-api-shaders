{
    "Shader": {
        "info": {
            "date": "1499875956",
            "description": "Rhombuses with easing.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsBBzw",
            "likes": 0,
            "name": "Easing Rhombus",
            "published": 3,
            "tags": [
                "easing"
            ],
            "usePreview": 0,
            "username": "r21nomi",
            "viewed": 464
        },
        "renderpass": [
            {
                "code": "float map(float value, float beforeMin, float beforeMax, float afterMin, float afterMax) {\n\treturn afterMin + (afterMax - afterMin) * ((value - beforeMin) / (beforeMax - beforeMin));\n}\n\nvec2 patternize(vec2 st) {\n\treturn fract(vec2(st));\n}\n\nfloat box(vec2 _st, vec2 _size){\n\t_size = vec2(0.5) - _size * 0.5;  // Adjust size.\n\tvec2 uv = step(_size, _st);\n\tuv *= step(_size, vec2(1.0) - _st);\n\treturn uv.x * uv.y;\n}\n\nmat2 rotate2d(float _angle){\n\treturn mat2(cos(_angle), -sin(_angle),  sin(_angle), cos(_angle));\n}\n\n// From Robert Penner's Easing Functions.\n// http://gizma.com/easing/\nfloat easeOutQuad(float t) {\n\treturn -t * (t - 2.0);\n}\n\nfloat exposeInOut(float t) {\n\tif (t == 0.0) {\n\t\treturn 0.0;\n\t\n\t} else if (t == 1.0) {\n\t\treturn 1.0;\n\t\n\t} else if ((t /= 0.5) < 1.0) {\n\t\treturn 0.5 * pow(2.0, 10.0 * (t - 1.0));\n\t\n\t} else {\n\t\treturn 0.5 * (-pow(2.0, -10.0 * --t) + 2.0);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n\tint count = 6;\n\t\n\t// Divide by 2 since the origin of display is center(the range of y is -1.0 ~ 1.0)\n\tst *= float(count / 2);\n\t\n\t// Apply easing.\n\tfloat easing =  exposeInOut(fract(iTime * 1.1));\n\tfloat speed = iTime + easing;\n\t\n\t// Animate\n\tst.x += mod(st.y, 2.0) < 1.0 ? -speed : speed;\n\t\n\t// Patternize\n\tvec2 p = patternize(st);\n\t\n\t// Rotate\n\tp -= 0.5;  // Move each items to center.\n\tp *= rotate2d(iTime);  // Rotate.\n\tp += 0.5;  // Set rotation axis to center.\n\n\tfloat minScale1 = 0.5;\n\tfloat minScale2 = 0.1;\n\tfloat maxScale = 1.0;\n\t\n\t// Scale with animation.\n\tfloat scale = easing < 0.5 ?  map(easing, 0.0, 1.0, maxScale, minScale1) : map(easing, 0.0, 1.0, minScale1, maxScale);\n\tfloat scale2 = easing < 0.7 ?  map(easing, 0.0, 1.0, maxScale, minScale2) : map(easing, 0.0, 1.0, minScale2, maxScale);\n\t\n\t// Box\n\tfloat b2 = box(p, vec2(0.6 * scale));\n\tfloat b1 = box(p, vec2(0.4 * scale2));\n\t\n\tfloat result = b1 + b2;\n\tfloat offset = 1.0 + sin(iTime * 5.0 + fract(st.x) * fract(st.y)) / 2.0;\n\t\n\tvec3 color = vec3(\n\t\tresult * offset * sin(iTime * 10.0 * fract(p.x)),  // This sin(time * fract(p.x)) make box noisy.\n\t\tresult * offset * 0.2,\n\t\tresult * offset * 0.9\n\t);\n\t\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}