{
    "Shader": {
        "info": {
            "date": "1693574342",
            "description": "My first SDF scene!\nUsed AA, bounding sphere and shadow casting",
            "flags": 0,
            "hasliked": 0,
            "id": "DtsBDS",
            "likes": 4,
            "name": "SDF - temple",
            "published": 3,
            "tags": [
                "prototype"
            ],
            "usePreview": 0,
            "username": "mcavazotti",
            "viewed": 178
        },
        "renderpass": [
            {
                "code": "float pillars(vec3 p) {\n    float s = 12.;\n    p = abs(p/s) - (vec3(2.,1.,2.5) * 0.5- 0.5);\n    p = (p.x<p.z) ? p.zyx : p.xyz;\n    p.z -= min(0.0, round(p.z));\n    return sdCappedCylinder(p*s, 5., 1.);\n}\nfloat ceiling(vec3 p) {\n    float plane1 = sdBox(p-vec3(0.,10.,0.), vec3(7.5,0.25,10.5));\n    float plane2 = sdBox(p-vec3(0.,10.5,0.), vec3(7.,.5,10.));\n    float plane3 = sdBox(p-vec3(0.,11.,0.), vec3(7.5,0.25,10.5));\n\n    float cover = sdTriPrism2(p - vec3(0.,11.,0.),vec2(7.,0.),vec2(-7.,0.),vec2(0.,5.), 10.);\n    vec3 tmpP = vec3(p.x,p.y,abs(p.z))/.8 - vec3(0.,11./0.8,13.);\n    float detail = .8*sdTriPrism2(tmpP,vec2(7.,0.),vec2(-7.,0.),vec2(0.,5.), 1.);\n    \n    \n    return min(min(plane1,min(plane2,plane3)),opSubtraction(detail,cover));\n}\n\nfloat buildingFloor(vec3 p) {\n    float floorP = sdBox(p- vec3(0.,-0.5,0.), vec3(7.5,1.,10.5));\n    \n    float stairs1 = sdBox(p- vec3(0.,-0.5-0.75 / 2.,11.), vec3(2.5,0.75,.5));\n    float stairs2 = sdBox(p- vec3(0.,-1. ,11.5), vec3(4.,0.5,1.5));\n    float stairs3 = sdBox(p- vec3(0.,-1.25,12.), vec3(6.,0.25,3.));\n    \n    return min(min(stairs1,min(stairs2,stairs3)),floorP);\n}\n\nfloat ground(vec3 p) {\n    return sdPlane(p- vec3(0.,-1.5,0.), vec3(0.,1.,0.), 0.);\n}\n\nfloat temple(vec3 p) {\n    return min(pillars(p - vec3(0.,5.,0.)),min(buildingFloor(p),ceiling(p)));\n}\n\nvec2 scene(vec3 p) {\n    float g = ground(p);\n    // Bounding Sphere\n    if(g > sdSphere(p,20.)) {\n        float t = temple(p);\n        float v = min(g, temple(p));\n        return vec2(v, v == t? -1.:1.);\n    }\n    return vec2(g,1.);\n}\n\nvec3 getNormal(vec3 p) {\n    float dx = scene(vec3(p.x + EPSILON, p.y, p.z)).x - scene(vec3(p.x - EPSILON, p.y, p.z)).x;\n    float dy = scene(vec3(p.x, p.y + EPSILON, p.z)).x - scene(vec3(p.x, p.y - EPSILON, p.z)).x;\n    float dz = scene(vec3(p.x, p.y, p.z + EPSILON)).x - scene(vec3(p.x, p.y, p.z - EPSILON)).x;\n    \n    return normalize(vec3(dx,dy,dz));\n}\n\n\nvec4 render(vec3 eye, vec3 dir, vec3 directionalLight, vec3 lightColor,vec3 ambient, vec3 groundColor, vec3 templeColor) {\n    float dist = MIN_DIST;\n    vec3 normDir = normalize(dir);\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = eye + normDir * dist;\n        vec2 renderP = scene(p);\n        float d = renderP.x;\n        vec3 albedo = renderP.y < 0.? templeColor:groundColor;\n        \n        if(d < EPSILON) {\n            vec3 normal = getNormal(p);\n            float intensity = clamp(dot(directionalLight,-normal),0.,1.);\n            if(intensity > 0.) {\n                vec3 shadowDir = normalize( normal-directionalLight);\n                float shadowDist = 2.*d + 2.*EPSILON;\n                \n                for(int is = 0; is < MAX_MARCHING_STEPS; is++) {\n                    vec3 ps = p + shadowDir * shadowDist;\n                    \n                    float ds = scene(ps).x;\n                    \n                    if(ds < EPSILON) return vec4(albedo*ambient, 1.);\n                    \n                    shadowDist +=ds;\n                    if(shadowDist > MAX_DIST)\n                        break;\n                }\n                return vec4(albedo*mix(ambient,lightColor, intensity ),1.);\n            }\n\n            return vec4(albedo*mix(ambient,lightColor, intensity ),1.);\n\n        }\n        \n        dist += d;\n        if(dist > MAX_DIST)\n            break;\n    }\n    return vec4(.3,.5,.8,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 eye = vec3(sin(iTime*0.5)*35., sin(3. +iTime*0.5)*15. + 25., cos(iTime*0.5)*60.);\n    vec3 target = vec3(0., 5., 0.);\n    vec3 directionalLight = normalize(vec3(1.,-1.5,-1.));\n    vec3 ambientLight = vec3(0.5,0.5,0.6);\n    vec3 dirLightColor = vec3(0.8,0.8,0.6);\n    vec3 groundColor = vec3(0.2,0.6,0.3);\n    vec3 templeColor = vec3(0.25,0.25,0.15);\n    \n    mat4 viewToWorld = generateViewMatrix(eye, target, vec3(0., 1., 0.));\n    \n    vec4 color = vec4(0.);\n    int AA =2;\n    for(int i = 0; i < AA; i++)\n        for(int j = 0; j < AA; j++) {\n            vec2 offset = vec2(float(i),float(j)) / float(AA) - 0.5;\n            vec3 rayDir = rayDirection(60., iResolution.xy+ offset, fragCoord);\n            vec3 worldRayDir = (viewToWorld * vec4(rayDir, 0.)).xyz;\n            color += vec4(pow(render(\n                    eye, \n                    worldRayDir, \n                    directionalLight, \n                    dirLightColor, \n                    ambientLight,\n                    groundColor,\n                    templeColor\n                \n                ).xyz,vec3(0.4545)),1.);\n        }\n    \n    fragColor = color/ float(AA*AA);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define EPSILON 1e-4\n#define MIN_DIST 0.0\n#define MAX_DIST 1e5\n#define MAX_MARCHING_STEPS 1000\n\n\n\n/*\n** RAY FUNCTIONS \n*/\n\nvec3 rayDirection(float fieldOfView, vec2 resolution, vec2 coord) {\n    vec2 xy = coord - resolution / 2.0;\n    float z = resolution.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 generateViewMatrix(vec3 eye, vec3 target, vec3 up ) {\n    vec3 f = normalize(target - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n/*\n** OPERATIONS\n*/\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n/*\n** SDFs https://iquilezles.org/articles/distfunctions/\n*/\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\n\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTriPrism2( vec3 p, in vec2 p0, in vec2 p1, in vec2 p2, float h )\n{\n    float d = sdTriangle(p.xy,p0,p1,p2);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}