{
    "Shader": {
        "info": {
            "date": "1544493208",
            "description": "experimenting with hex grid and making damn sure to avoid as much branching as i can",
            "flags": 32,
            "hasliked": 0,
            "id": "XlGBWt",
            "likes": 15,
            "name": "hexholes",
            "published": 3,
            "tags": [
                "raymarching",
                "raymarch",
                "sdf"
            ],
            "usePreview": 0,
            "username": "benhardy",
            "viewed": 613
        },
        "renderpass": [
            {
                "code": "\n// This buffer does some bokeh based on the alpha channel of buffer A which is the distance of the surface from the pixel.\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = vec3(0.);\n    \n    // Gaussian blur by mrharicot https://www.shadertoy.com/view/XdfGDH\n    \n    //declare stuff\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\tfloat depth = texture(iChannel0, uv).a;\n    \n    //create the 1-D kernel\n    float sigma = mix(0.05, 4., max(0., -1. + depth*depth*0.1));\n    float Z = .0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            base += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n        }\n    }\n   \tvec4 b = vec4(base/(Z*Z), 1.0);\n\n    fragColor = b;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\n/**\n * centred modulo\n */\nfloat cmod(float x, float r) {\n    return mod(x + 0.5 *r, r) - 0.5 *r;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n/**\n * Ray marching parameters for this scene\n */\n#define MAX_STEPS  10000\n#define MAX_DIST   100.0\n#define EPSILON    0.001\n#define STEP_RATIO 0.3\n\n/**\n * object ids\n */\n#define ID_FLOOR 1\n#define ID_BIZZO 2\n#define ID_TUBE  3\n#define ID_CAP   4\n\n#define COS_30    0.8660254037844387\n#define HEX_EVEN  1.7320508075688772\n\nfloat hex_hole_board(vec3 where, float hole_radius, \n                     float thickness, float rounding) {\n    where = abs(where);\n\tfloat d_plane = where.y - thickness/2.0;\n    \n    vec3 first = where;\n    first.z = abs(cmod(first.z, HEX_EVEN));\n    // this is either gonna be 0 or 1 on alternating rows\n    float odd_row_bump = floor(first.z / (0.5*COS_30));\n    first.x -= 0.5 * odd_row_bump;\n    first.z -= COS_30 * odd_row_bump;\n    first.x = cmod(first.x, 1.0);\n    float d_hole = length(first.xz) - hole_radius;\n\n    float d_board = max(d_plane, -d_hole);\n    float d_edge = length(vec2(d_plane+rounding, d_hole)) - rounding;\n    return min(d_board, d_edge);\n}\n\n/**\n * fold space into polar coords and put a hex hole board there,\n * forming a tube along the Z axis\n */\nfloat hex_hole_tube(vec3 where, \n                    float tube_radius,\n                    float hole_radius,\n                    float thickness,\n                    float hole_rounding) {\n\tfloat where_angle = atan(where.x, where.y);\n    float where_radius = length(where.xy);\n    where.x = where_angle * tube_radius;\n    where.y = where_radius - tube_radius;\n    return hex_hole_board(where, hole_radius, thickness, hole_rounding);\n}\n\n/*\n * framing and bracing between columns\n */\nfloat measure_frame(vec3 where_tube, float tube_rad) {\n    float r = length(where_tube.xy);\n    where_tube.z = cmod(where_tube.z, 5.0);\n    float sheath = r-tube_rad-0.3;\n    float interior = r-tube_rad-0.1;\n    float bar = length(where_tube.zy-vec2(0,0)) - 0.3;\n    float sheath_cut = abs(where_tube.z)-0.5;\n    float frame = min(sheath, bar);\n    float weld = length(vec2(bar, sheath)) - 0.10;\n    float weld2 = max(sheath - 0.5, bar - 0.05);\n    frame = min(frame, min(weld, weld2));\n    frame = max(frame, -interior);\n    frame = max(frame, sheath_cut);\n    return frame;\n}\n\n/**\n * find the closest object in the scene and return its distance and id\n */\nvec2 measure(vec3 where) {\n    vec2 closest = vec2(100000.0, 0.0);\n\n    float dist_floor = hex_hole_board(where, 0.42, 0.2, 0.1);\n    if (dist_floor <= closest.x) {\n        closest = vec2(dist_floor, ID_FLOOR);\n    }\n    vec3 where_tube = where.xzy; // flip tube around x\n    where_tube.x = cmod(where_tube.x, 10.0);\n    float tube_rad = 6.0/PI;\n    float dist_tube = hex_hole_tube(where_tube, tube_rad, 0.42, 0.2, 0.1);\n    if (dist_tube <= closest.x) {\n        closest = vec2(dist_tube, ID_TUBE);\n    }\n\tfloat frame = measure_frame(where_tube, tube_rad);\n    if (frame <= closest.x) {\n        closest = vec2(frame, ID_CAP);\n    }\n    return closest;\n}\n\n/**\n * Figure out coloring for where we hit\n */\nconst vec4 floor_color = vec4(0.18,0.18,0.22,0.0);\nconst vec4 bizzo_color = vec4(0.2,0.5,0.7,0.2);\nconst vec4 guts_color = vec4(0.5,0.2,0.1,0.0);\nconst vec4 rod_color = vec4(1,0,0,1.0);\nconst vec4 bone_color = vec4(0.6,0.57,0.50,0.2);\nconst vec4 tube_color = vec4(1,1,1,0.2);\nconst vec4 sky = vec4(0,0,0,0);\n\nvec4 paint(vec2 hit, vec3 where) {\n\n    int who = int(hit.y);\n    float ambient = 0.0;\n    if (who == ID_FLOOR) {\n        return bone_color;\n    }\n    if (who == ID_BIZZO) {\n        return bizzo_color;\n    }\n    if (who == ID_TUBE) {\n        return tube_color;\n    }\n    if (who == ID_CAP) {\n        return bone_color;\n    }\n    return sky;\n}\n\n// end of model stuff\n\nvec3 calc_surface_normal(vec3 hit);\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax );\n\n/**\n * main entrypoint\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(sin(iTime*0.31)*15.0+5.0,\n                    sin(iTime*0.22)*15.0+20.0,\n                    cos(iTime*0.13)*10.0-15.0);\n    vec3 look_at = vec3(10,12.0+10.0*sin(iTime*0.05),0);\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    for(int steps = 0; steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0,0,0);\n    if (who == 0){\n        fragColor = vec4(fog_color, 1.0);\n        return;\n    }\n\tvec3 hit = where;\n    vec4 the_paint = paint(current, where);\n    vec3 to_light = normalize(vec3(-5,15,-1));\n    float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    vec3 surface_normal = calc_surface_normal(hit);\n    float dotty = dot(to_light, surface_normal);\n    float light_amount = max(0.0, dotty);\n    float light_fade = 1.0;\n    float ambient = the_paint.w;\n    float lighting = ambient + (1.0-ambient) * \n        (shadow*0.5 * (1.0 + light_amount * light_fade));\n\n\tvec3 coloring = light_fade *(the_paint.xyz * lighting)\n        + fog_color * (1.0-light_fade);\n    vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    vec3 toEye = normalize(-ray);\n\tfloat specular = pow(max(0.0, dot(toEye, reflected)), 32.0);\n\tcoloring += vec3(specular, specular, specular);\n    fragColor = vec4(coloring, total_dist * 0.1);\n}\n\n#define NORMAL_DELTA 0.001\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = measure( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}