{
    "Shader": {
        "info": {
            "date": "1547043986",
            "description": "Yet another Cornell Box. I have optimised the code of [url=https://www.shadertoy.com/view/XlGcWD]RIOW 2.07: Instances[/url] for the Cornell Box and added direct light sampling to reduce noise. Only Lambertian solid materials and cubes are supported. ",
            "flags": 0,
            "hasliked": 0,
            "id": "3dfGR2",
            "likes": 48,
            "name": "Yet another Cornell Box",
            "published": 3,
            "tags": [
                "ray",
                "cornellbox",
                "pathtracer",
                "box",
                "cornell",
                "tracer",
                "path"
            ],
            "usePreview": 1,
            "username": "reinder",
            "viewed": 5661
        },
        "renderpass": [
            {
                "code": "// Yet another Cornell Box. Created by Reinder Nijhoff 2019\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/3dfGR2\n// \n// Yet another Cornell Box. I have optimised the code of my shader \"RIOW 2.07: Instances\"\n// for the Cornell Box and added direct light sampling to reduce noise. Only Lambertian \n// solid materials and cubes are supported. \n//\n// These shaders are my implementation of the raytracer described in the (excellent) \n// book \"Ray tracing in one weekend\" and \"Ray tracing: the next week\"[1] by Peter Shirley \n// (@Peter_shirley).\n//\n// = Ray tracing in one week =\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\n//\n// = Ray tracing: the next week =\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\n//\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\n//\n\n#define MOVE_CAMERA\n\n#define MAX_FLOAT 1e5\n#define EPSILON 0.01\n#define MAX_RECURSION 3\n#define SAMPLES (12+min(0,iFrame))\n\n#define LAMBERTIAN 0\n#define DIFFUSE_LIGHT 1\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray trace helper functions\n//\n\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 rotate_y(const in vec3 p, const in float t) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\n//\n// Ray\n//\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nray ray_translate(const in ray r, const in vec3 t) {\n    ray rt = r;\n    rt.origin -= t;\n    return rt;\n}\n\nray ray_rotate_y(const in ray r, const in float t) {\n    ray rt = r;\n    rt.origin = rotate_y(rt.origin, t);\n    rt.direction = rotate_y(rt.direction, t);\n    return rt;\n}\n\n//\n// Material\n//\n\nstruct material {\n    int type;\n    vec3 color;\n};\n\n//\n// Hit record\n//\n\nstruct hit_record {\n    float t;\n    vec3 p, normal;\n    material mat;\n};\n\nhit_record hit_record_translate(const in hit_record h, const in vec3 t) {\n    hit_record ht = h;\n    ht.p -= t;\n    return ht;\n}\n   \nhit_record hit_record_rotate_y(const in hit_record h, const in float t) {\n    hit_record ht = h;\n    ht.p = rotate_y(ht.p, t);\n    ht.normal = rotate_y(ht.normal, t);\n    return ht;\n}\n\nvoid material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \n                      out ray scattered) {\n    scattered = ray(rec.p, random_cos_weighted_hemisphere_direction(rec.normal, g_seed));\n    attenuation = rec.mat.color;\n}\n\nvec3 material_emitted(const in hit_record rec) {\n    if (rec.mat.type == DIFFUSE_LIGHT) {\n        return rec.mat.color;\n    } else {\n        return vec3(0);\n    }\n}\n\n//\n// Hitable\n//\n\nstruct hitable { // always a box\n    vec3 center, dimension; \n};\n    \nbool box_intersect(const in ray r, const in float t_min, const in float t_max,\n                   const in vec3 center, const in vec3 rad, out vec3 normal, inout float dist) {\n    vec3 m = 1./r.direction;\n    vec3 n = m*(r.origin - center);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.) return false;\n    \n    float t = tN < t_min ? tF : tN;\n    if (t < t_max && t > t_min) {\n        dist = t;\n\t\tnormal = -sign(r.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \n                 const in float t_max, inout hit_record rec) {\n    float dist;\n    vec3 normal;\n    if (box_intersect(r, t_min, t_max, hb.center, hb.dimension, normal, dist)) {\n        rec.t = dist;\n        rec.p = r.origin + dist*r.direction;\n        rec.normal = normal;\n        return true;\n    } else {\n        return false;\n    }\n}\n\n//\n// Camera\n//\n\nstruct camera {\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\n    float lens_radius;\n};\n\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \n                    const in float vfov, const in float aspect, const in float aperture, \n                    const in float focus_dist) {\n    camera cam;    \n    cam.lens_radius = aperture / 2.;\n    float theta = vfov*3.14159265359/180.;\n    float half_height = tan(theta/2.);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\n    return cam;\n}\n    \nray camera_get_ray(camera c, vec2 uv) {\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return ray(c.origin + offset, \n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset));\n}\n\n//\n// Color & Scene\n//\n\nbool world_hit(const in ray r, const in float t_min, \n               const in float t_max, out hit_record rec) {\n    rec.t = t_max;\n    bool hit = false;\n\n    const material red = material(LAMBERTIAN, vec3(.65,.05,.05));\n    const material white = material(LAMBERTIAN, vec3(.73));\n    const material green = material(LAMBERTIAN, vec3(.12,.45,.15));\n\n    const material light = material(DIFFUSE_LIGHT, vec3(15));\n    \n    if (hitable_hit(hitable(vec3(278,555,279.5), vec3(65,1,52.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=light;   \n   \n    ray r_ = ray_rotate_y(ray_translate(r, vec3(130,0,65)), -18./180.*3.14159265359);\n    hit_record rec_ = rec;    \n    if (hitable_hit(hitable(vec3(82.5), vec3(82.5)),r_,t_min,rec.t,rec_)) \n        hit=true, \n        rec=hit_record_translate(hit_record_rotate_y(rec_, 18./180.*3.14159265359),-vec3(130,0,65.)), \n        rec.mat=white;\n    \n\tr_ = ray_rotate_y(ray_translate(r, vec3(265,0,295)), 15./180.*3.14159265359);\n    rec_ = rec;    \n    if (hitable_hit(hitable(vec3(82.5,165,82.5), vec3(82.5,165,82.5)),r_,t_min,rec.t,rec_)) \n        hit=true, \n        rec=hit_record_translate(hit_record_rotate_y(rec_, -15./180.*3.14159265359),-vec3(265,0,295)), \n        rec.mat=white;\n\n  \tif (hitable_hit(hitable(vec3(556,277.5,277.5), vec3(1,277.5,277.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=red;\n    if (hitable_hit(hitable(vec3(-1,277.5,277.5), vec3(1,277.5,277.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=green;\n   \n    if (hitable_hit(hitable(vec3(277.5,556,277.5), vec3(277.5,1,277.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=white;\n    if (hitable_hit(hitable(vec3(277.5,-1,277.5), vec3(277.5,1,277.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=white;\n    if (hitable_hit(hitable(vec3(277.5,277.5,556), vec3(277.5,277.5,1)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=white;\n    \n    return hit;\n}\n\n\nbool shadow_hit(const in ray r, const in float t_min, const in float t_max) {\n    hit_record rec;\n    rec.t = t_max;\n   \n    ray r_ = ray_rotate_y(ray_translate(r, vec3(130,0,65)), -18./180.*3.14159265359);  \n    if (hitable_hit(hitable(vec3(82.5), vec3(82.5)),r_,t_min,rec.t,rec)) \n        return true;\n    \n\tr_ = ray_rotate_y(ray_translate(r, vec3(265,0,295)), 15./180.*3.14159265359);  \n    if (hitable_hit(hitable(vec3(82.5,165,82.5), vec3(82.5,165,82.5)),r_,t_min,rec.t,rec)) \n        return true;\n  \n    return false;\n}\n\nvec3 color(in ray r) {\n    vec3 col = vec3(0);\n    vec3 emitted = vec3(0);\n\thit_record rec;\n    \n    for (int i=0; i<MAX_RECURSION && world_hit(r, EPSILON, MAX_FLOAT, rec); i++) {\n        if (rec.mat.type == DIFFUSE_LIGHT) { // direct light sampling code\n            return i == 0 ? rec.mat.color : emitted;\n        }\n\n        vec3 attenuation;\n        material_scatter(r, rec, attenuation, r);\n        col = i == 0 ? attenuation : col * attenuation;\n\n        // direct light sampling\n        vec3 pointInSource = (2.*hash3(g_seed)-1.) * vec3(65,1,52.5) + vec3(278,555,279.5);\n        vec3 L = pointInSource - rec.p;\n        float rr = dot(L, L);\n        L = normalize(L);\n\n        ray shadowRay = ray(rec.p, L);\n        if (L.y > 0.01 && dot(rec.normal, L) > 0. && !shadow_hit(shadowRay, .01, 1000.)) {\n\t        const float area = (65.*52.5*4.);\n            float weight = area * L.y * dot(rec.normal, L) / (3.14 * rr);\n            emitted += col * 15. * weight;\n        }\n    }\n    return emitted;\n}\n\n//\n// Main\n//\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\n    float aspect = iResolution.x/iResolution.y;\n#ifdef MOVE_CAMERA\n    vec3 lookfrom = vec3(278. + sin(iTime * .7)*200., 278, -800. + sin(iTime)*100.);\n#else\n    vec3 lookfrom = vec3(278. , 278, -800.);\n#endif\n    vec3 lookat = vec3(278,278,0);\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\n\n    vec3 tcol = vec3(0);\n    \n    for (int i=0, l = SAMPLES; i<l; i++) {\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\n\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 40., aspect, .0, 10.);\n        ray r = camera_get_ray(cam, uv);\n        tcol += color(r);\n    }\n    \n    frag_color = vec4(sqrt(tcol / float(SAMPLES)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}