{
    "Shader": {
        "info": {
            "date": "1604666942",
            "description": "First experiment of using raymarching to create something pleasant looking.\nWildly unoptimized :)",
            "flags": 0,
            "hasliked": 0,
            "id": "td3fz7",
            "likes": 1,
            "name": "neon_heart",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "skerys",
            "viewed": 386
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 10000.0\n#define SURFACE_DISTANCE 0.01\n#define EPSILON 0.01\n\nconst float PI = 3.14159265359;\nconst float deg2rad = 0.0174532925;\n\nmat2 rot(float a){\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotatePointUnityEuler(vec3 p, float x, float y, float z){\n\tp.xz *= rot(deg2rad * y);\n    p.zy *= rot(deg2rad * x);    \n    p.yx *= rot(deg2rad * z);\n    \n    return p;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sin01(float a)\n{\n    float b = sin(a*5.0) / 2.0 + 0.5;\n    return b*b;\n}\n\nfloat sin02(float a)\n{\n    float b = sin(a) / 2.0 + 0.5;\n    return b*b*b*b*b*b*b;\n}\n\nfloat sin03(float a)\n{\n    return sin(a) / 2.0 + 0.5;\n}\n\n\nfloat displacement(vec3 p)\n{\n    return sin(5.0 * p.x + 4.0*iTime)*sin(5.0 * p.y + 4.0*iTime)*sin(5.0 * p.z + 4.0*iTime);\n}\n\nfloat distanceToScene(vec3 p)\n{\n    //Main sphere\n    vec4 mainSphere = vec4(0.07*sin01(iTime), -0.07*sin01(iTime), 0, 0.5 + 0.075*sin01(iTime));\n    float shape1 = sdSphere(p - mainSphere.xyz, mainSphere.w);\n    \n    //vec3 cylinderRightPos = vec3(0);\n    vec3 cylinderRightPos = vec3(0.227, 0.432, 0.099);\n    float cylinderRightRadius = 0.1 - 0.015 * sin02((iTime + PI/4.0 - 0.2)*5.0);\n    float cylinderRightHeight = 0.5;\n    \n    vec3 bp = p - cylinderRightPos;    \n    bp = rotatePointUnityEuler(bp, 58.423, 2.507, -22.109);\n    \n    shape1 = smin(shape1, sdRoundedCylinder(bp, cylinderRightRadius,0.1, cylinderRightHeight), 0.25);\n    \n    vec3 cylinderSmallPos = vec3(-0.1, 0.831, 0.568);\n    float cylinderSmallRadius = 0.075 - 0.01 * sin02((iTime + PI/4.0 - 0.1)*5.0);\n    float cylinderSmallHeight = 0.555;\n    \n    bp = p - cylinderSmallPos;\n    bp = rotatePointUnityEuler(bp, 65.568, -113.973, -41.671);\n    \n    shape1 = smin(shape1, sdRoundedCylinder(bp, cylinderSmallRadius,0.1, cylinderSmallHeight), 0.1);\n    \n    vec3 smallSpherePos = vec3(0.25 + 0.075*sin01(iTime - .03), -0.35 - 0.075*sin01(iTime - .03), -0.177 -  0.075*sin01(iTime - .03));\n    \n    bp = p - smallSpherePos;\n    bp = rotatePointUnityEuler(bp, -47.688, 23.452, 43.371);\n    \n    shape1 = smin(shape1, sdSphere(bp, 0.2  + 0.1*sin01(iTime - .03)), 0.3);\n    \n    vec3 anglePos = vec3(-0.108, 0.206, 0.137);\n    vec3 anglePos2 = vec3(0.218, 0.186, 0.259);\n    \n    bp = p - anglePos;\n    bp = rotatePointUnityEuler(bp, 10.428, 6.331, 42.379);\n    \n    shape1 = smin(shape1, sdSolidAngle(bp, vec2(sin(PI/4.0),cos(PI/4.0)), 0.4 - 0.1 * sin02((iTime + PI/2.0) * 5.0)) -0.1, 0.02);\n    \n    bp = p - anglePos2;\n    bp = rotatePointUnityEuler(bp, -41.338, -20.374, -74.936);\n    \n    shape1 = smin(shape1, sdSolidAngle(bp, vec2(sin(PI/4.0),cos(PI/4.0)), 0.4 - 0.1 * sin02((iTime + PI/2.0) * 5.0)) -0.1, 0.02);\n    \n    vec3 torusPos = vec3(0.228, 0.706, 0.503);\n    vec2 torusRadii = vec2(0.38, 0.18);\n    \n    bp = p - torusPos;\n    bp = rotatePointUnityEuler(bp, 22.816, 25.841, -106.461);\n    bp.y *= 1.0 - 0.05 * sin02((iTime + PI/4.0 - 0.15)*5.0);\n    bp.z *= 1.0 + 0.1 * sin02((iTime + PI/4.0 - 0.15)*5.0);\n        \n    float shape2 = sdTorus(bp, torusRadii);\n    \n    vec3 valveAPos = vec3(0.22, 1.024, 0.343);\n    vec3 valveBPos = vec3(0.317, 1.041, 0.478);\n    vec3 valveCPos = vec3(0.386, 0.991, 0.636);\n        \n    float valveRadius = 0.05;\n    float valveHeight = 0.4;\n    \n    bp = p - valveAPos;\n    bp = rotatePointUnityEuler(bp, -25.892, 30.911, -21.724);\n    \n    shape2 = smin(shape2, max(abs(sdRoundedCylinder(bp, valveRadius, 0.0, valveHeight)) - 0.01, bp.y - 0.3), 0.01);\n    \n    bp = p - valveBPos;\n    bp = rotatePointUnityEuler(bp, -6.346, 25.177, -22.851);\n    \n    shape2 = smin(shape2, sdRoundedCylinder(bp, valveRadius, 0.0, valveHeight-0.1), 0.01);\n    \n    bp = p - valveBPos;\n    bp = rotatePointUnityEuler(bp, 16.24, 18.123, -27.795);\n    \n    shape2 = smin(shape2, sdRoundedCylinder(bp, valveRadius, 0.0, valveHeight-0.1), 0.01);\n    \n    vec3 cylinderLeftPos = vec3(-0.255 + 0.03 * sin02((iTime + PI/4.0 - 0.2)*5.0), 0.075, 0.273);\n    float cylinderLeftRadius = 0.075;\n    float cylinderLeftHeight = 0.8;\n    bp = p - cylinderLeftPos;\n    \n    float k = 0.05 * sin02((iTime + PI/4.0 - 0.2)*5.0);\n    float c = cos(k*bp.y);\n    float s = sin(k*bp.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m*bp.xy,bp.z);\n    bp = q;\n    \n    float shape3 = sdRoundedCylinder(bp, cylinderLeftRadius, 0.0, cylinderLeftHeight);\n    \n    vec3 cylinderLeftSmall1Pos = vec3(-0.308 -0.02 * sin02((iTime + PI/4.0 - 0.2)*5.0), 1.085, 0.273);\n    float cylinderLeftSmall1Radius = 0.075;\n    float cylinderLeftSmall1Height = 0.25;\n    \n    bp = p - cylinderLeftSmall1Pos;\n    \n    k = -0.3 * sin02((iTime + PI/4.0 - 0.2)*5.0);\n    c = cos(k*bp.y);\n    s = sin(k*bp.y);\n    m = mat2(c, -s, s, c);\n    q = vec3(m*bp.xy,bp.z);\n    bp = q;\n    \n    bp = rotatePointUnityEuler(bp, 0.0, 0.0, 13.068);\n    \n    shape3 = min(shape3, sdRoundedCylinder(bp, cylinderLeftSmall1Radius,0.0, cylinderLeftSmall1Height));\n    \n    vec3 cylinderLeftSmall2Pos = vec3(-0.188-0.02 * sin02((iTime + PI/4.0 - 0.2)*5.0), 1.157, 0.257);\n    float cylinderLeftSmall2Radius = 0.075;\n    float cylinderLeftSmall2Height = 0.2;\n    \n    bp = p - cylinderLeftSmall2Pos;\n    bp = rotatePointUnityEuler(bp, -25.213, 22.086, -51.354);\n    \n    shape3 = smin(shape3, max(abs(sdRoundedCylinder(bp, cylinderLeftSmall2Radius,0.0, cylinderLeftSmall2Height)) - 0.02, bp.y - 0.14), 0.01);\n    \n    float dist = min(shape1, shape2);\n    dist = min(dist, shape3);\n    \n    dist += displacement(p) * 0.01;\n    \n    return dist;\n    \n}\n\nconst float NOISE_GRANULARITY = 255.0/255.0;\nfloat random(vec2 coords) {\n\treturn fract(sin(dot(coords.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, vec2 uv)\n{\n    float d = 0.0;\n    float iter = 0.0;\n    for(int i = 0; i < MAX_STEPS && d < MAX_DISTANCE; i++)\n    {\n        iter += 1.0;\n        vec3 p = ro + rd * d;\n        float dist = distanceToScene(p);\n        d += 0.75 * dist;\n        if(dist < SURFACE_DISTANCE)\n        {\n            \n            return vec2(d, iter + (iter/6.0 + 0.5) * dist / SURFACE_DISTANCE);\n        }\n    }\n    return vec2(0.0, iter - d / MAX_DISTANCE + 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0, 0.3, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1)); \n\n    vec2 d = rayMarch(ro, rd, uv);\n   \n    vec3 gold = vec3(0.6, 0.4, 0.05);\n    vec3 lavender = vec3(0.58, 0.48,0.71);\n    \n    vec3 myCol = mix(gold, lavender, sin03(iTime * 2.5));\n\n    col = sin02(iTime * 5.0) * myCol * d.y * d.x / 75.0 + myCol * d.y / 50.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}