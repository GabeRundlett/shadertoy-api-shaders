{
    "Shader": {
        "info": {
            "date": "1459023124",
            "description": "Same as https://www.shadertoy.com/view/XscGWs# with impossible normals commented out",
            "flags": 0,
            "hasliked": 0,
            "id": "Ms3SDH",
            "likes": 5,
            "name": "The Possible Rubies",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "refraction",
                "smooth",
                "ruby"
            ],
            "usePreview": 0,
            "username": "valgusk",
            "viewed": 403
        },
        "renderpass": [
            {
                "code": "// inspired by https://www.shadertoy.com/view/ldfXzn\n \n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define DELTA               0.01\n#define RAY_LENGTH_MAX      80.0\n#define MAX_STEPS           120\n#define MAX_RAYS            7 // start ray, [reflection, refraction]...\n#define MAX_SUBREFRACTIONS  20\n#define REFRACTION          1.762\n\n#define reflectionI         (ray * 2 + 1)\n#define backupI             (ray + 1)\n#define refractionI         (ray * 2 + 2)\n#define REPEAT_PATTERN      vec3(10.0, 10.0, 10.0) * 3.2\n#define MAX_REPEAT          1.0\n#define USE_ADDITIONAL_RAYS false\n\n// gem definition\n#define TOP_CONE_ANGLE      vec2(0.5038710255240861, 0.8637789008984333)\n#define BOT_CONE_ANGLE      vec2(0.7808688094430303, -0.6246950475544243)\n#define GEM_SCALE           21.0\n#define GEM_TOP_OFFSET      0.2\n#define GEM_BOT_OFFSET      0.2\n#define TOP_CONE_HEIGHT     0.05\n#define MAGICSTEPS          10.0\n\n#define REFLECTION_POWER     10.0\n\n#define M_PI              3.1415926535897932384626433832795\n\nmat3 mRotate (in vec3 angle) {\n    float c = cos (angle.x);\n    float s = sin (angle.x);\n    mat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n    c = cos (angle.y);\n    s = sin (angle.y);\n    mat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n    c = cos (angle.z);\n    s = sin (angle.z);\n    mat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n    return rz * ry * rx;\n}\n\n\nfloat cone(in vec3 p, in vec3 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -p.y-c.z;\n    float d2 = max(dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2),0.0)) + min(max(d1, d2), 0.0);\n}\n\nvec3 rayForRepeat(in vec3 ray, in vec3 repeatPattern) {\n    vec3 q = ray + repeatPattern * 0.5;\n    vec3 k = floor (q / repeatPattern);\n    \n    q -= repeatPattern * (k + 0.5);\n    \n    if(max(max(abs(k.x), abs(k.y)), abs(k.z)) > MAX_REPEAT) q = ray; \n    \n    //vec3 k =vec3(1.0,1.0,1.0);\n    mat3 rotateMatrix = mRotate (k + iTime * 0.1);\n    //revertBy = inverse(rotateMatrix);\n    return rotateMatrix * q;\n}\n\nvec3 rayForRepeat(in vec3 ray, in vec3 repeatPattern, out mat3 revertBy) {\n    //vec3 overflowedRay   = mod(ray,repeatPattern);\n    //vec3 patternCenter   = -0.5 * repeatPattern;\n    //return patternCenter + overflowedRay;\n\n    vec3 q = ray + repeatPattern * 0.5;\n    vec3 k = floor (q / repeatPattern);\n    //if(max(max(k.x, k.y), k.z) < 2.0)\n    q -= repeatPattern * (k + 0.5);\n    \n    if(max(max(abs(k.x), abs(k.y)), abs(k.z)) > MAX_REPEAT) q = ray; \n    //vec3 k =vec3(1.0,1.0,1.0);\n    mat3 rotateMatrix = mRotate (k + iTime * 0.1);\n    revertBy = rotateMatrix;//inverse(rotateMatrix);\n    return rotateMatrix * q;\n}\n\nfloat conebination( vec3 rayDot )\n{\n    float scale = GEM_SCALE;\n    //vec2 top = normalize(vec2(0.35, 0.6));\n    vec2 top = TOP_CONE_ANGLE;\n    //vec2 bot = normalize(vec2(0.5, -0.4));\n    vec2 bot = BOT_CONE_ANGLE;\n\n    float horizontal = length(vec2(rayDot.x,rayDot.z)) / scale;\n    float vertical   = rayDot.y / scale;\n\n    float gemEdgeY = abs(top.y) * (GEM_TOP_OFFSET + GEM_BOT_OFFSET) / (abs(top.y) + abs(top.x*bot.y/bot.x)) -GEM_TOP_OFFSET;\n\n    float dotTop = top.x * horizontal + top.y * (vertical - GEM_TOP_OFFSET);\n    float dotBot = bot.x * horizontal + bot.y * (vertical + GEM_BOT_OFFSET);\n\n    return max(max(dotTop, dotBot), vertical - gemEdgeY - TOP_CONE_HEIGHT) * scale;\n}\n\nfloat atan2(in float y, in float x)\n{\n    float s = (abs(x) > abs(y)) ? 1.0 : 0.0;\n    return mix(M_PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec3 conebinationNormal( vec3 rayDot )\n{\n\n    float scale = GEM_SCALE;\n    vec2 top = TOP_CONE_ANGLE;\n    vec2 bot = BOT_CONE_ANGLE;\n\n\n    mat3 revertBy;\n    vec3 modifiedRay = rayForRepeat(rayDot, REPEAT_PATTERN, revertBy) / scale;\n\n    vec2 horizontalNormal  = normalize(vec2(modifiedRay.x,modifiedRay.z));\n\n    // fake normals \n    vec2 topAdd = vec2(0.0, 0.0);\n\n    // fake normals end\n\n    float horizontal = length(vec2(modifiedRay.x,modifiedRay.z));\n    float vertical   = modifiedRay.y;\n\n    float gemEdgeY = abs(top.y) * (GEM_TOP_OFFSET + GEM_BOT_OFFSET) / (abs(top.y) + abs(top.x*bot.y/bot.x)) -GEM_TOP_OFFSET;\n\n    float dotTop = top.x * horizontal + top.y * (vertical - GEM_TOP_OFFSET);\n    float dotBot = bot.x * horizontal + bot.y * (vertical + GEM_BOT_OFFSET);\n    float dotCut = vertical - gemEdgeY - TOP_CONE_HEIGHT;\n\n    float maxDot = max(dotTop, dotBot);\n    maxDot = max(maxDot, dotCut);\n\n    vec2 verticalNormal = (maxDot == dotCut) ?\n        vec2(0.0, 1.0) :\n        ((maxDot == dotTop) ? top + topAdd: bot)  ;\n\n/*    float angle = atan2(horizontalNormal.x, horizontalNormal.y);\n\n    float sideStepB = (2.0 * M_PI / 14.0); \n    float stepAngleB = (floor(angle / sideStepB) + 0.5) * sideStepB;\n    float subAngleB = angle - stepAngleB;\n    vec2 horizontalNormalB = normalize(vec2(sin(stepAngleB), cos(stepAngleB)));\n\n    if (maxDot == dotTop) { \n        float sideStepT = (2.0 * M_PI / 7.0);\n        float stepAngleT = (floor(angle / sideStepT) + 0.5) * sideStepT;\n        float subAngleT = angle - stepAngleT;\n\n        vec2 horizontalNormalT = normalize(vec2(sin(stepAngleT), cos(stepAngleT)));\n\n        float fullConeHeight = (gemEdgeY - GEM_TOP_OFFSET);\n        float hitConeHeight = (vertical);\n        float maxConeHeight = (TOP_CONE_HEIGHT);\n\n\n\n        float ratio = abs(gemEdgeY - vertical)/TOP_CONE_HEIGHT;\n        bool outside = (abs(fullConeHeight * sin(subAngleT) /(vertical)) > mix(0.0, sin(sideStepT / 2.0), ratio));\n\n        horizontalNormal = outside ? horizontalNormalB : horizontalNormalT;\n    } else  {\n        horizontalNormal = horizontalNormalB;\n    }*/\n\n\n    return normalize(vec3(\n        horizontalNormal.x * verticalNormal.x,\n        verticalNormal.y,\n        horizontalNormal.y * verticalNormal.x\n    )) * revertBy;\n}\n\n\n\n\nfloat cube(in vec3 ray)\n{\n    vec3 sides = vec3 (2.5, 2.5, 2.5) * 1.5;\n    vec3 distances = abs(ray) - sides/2.0;\n    float maxDistance = max(distances.x, max(distances.y, distances.z));\n\n\n    return min(maxDistance, 0.0) + length(max(maxDistance, 0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat gem(in vec3 ray)\n{\n    float heightFactor = 1.3;\n    vec3 coneBase = vec3(0.35, 0.4, 1.64 * heightFactor);\n    vec3 coneBase2 = vec3(0.4, 0.3, 2.5 * heightFactor);\n\n\n    // your magical distance function\n    float cone1 = cone(vec3(ray.x, ray.y - coneBase.z , ray.z), coneBase);\n    float cone2 = cone(vec3(ray.x, -ray.y - coneBase2.z, ray.z), coneBase2);\n    return max(ray.y - coneBase.z * 0.3, min(cone1, cone2));\n\n}\n\n\n\nfloat getDistance (in vec3 ray) {\n    //return sdSphere(rayForRepeat(ray, REPEAT_PATTERN), 2.0);\n    ray = rayForRepeat(ray, REPEAT_PATTERN);\n    return conebination(ray);\n}\n\nvec3 getBackground(in vec3 start, in vec3 direction, in vec3 origin, in vec2 fragCoord) {\n    //return texture(iChannel0, origin).rgb;\n    //return texture(iChannel1, direction.xy).rgb;\n\n    vec3 coord = normalize(direction);\n    \n    float elevation = abs(asin(coord.x));\n    float modifier = (1.0 - 0.5 * length(coord.xz));\n    //elevation *= modifier;\n    float rotation = atan2(coord.y, coord.z) + iTime * 0.5;\n    bool rail;\n    bool row = mod(rotation, M_PI / 20.0) < 0.04;\n    float beg = 0.045;\n    float off = 0.008;\n    bool col = elevation < M_PI * (beg + off) && elevation > M_PI * (beg - off);\n    vec3 ret;\n    if(elevation < M_PI * 0.07  && (row || col) ){\n        ret = vec3(1.0,0.8,1.0);\n    } else {\n        ret = vec3(0.4,0.1,0.05) * (M_PI / 2.0 - abs(elevation - M_PI * beg));\n    }\n\n    \n    vec3 grain = normalize(vec3(\n        mod(coord.x * coord.y + (1.0 - coord.z), 0.03 * mod(iTime, 0.016)),\n        mod(coord.x * coord.z + (1.0 - coord.y), 0.07 * mod(iTime, 0.007)),\n        mod(coord.z * coord.y + (1.0 - coord.x), 0.05 * mod(iTime, 0.011)) \n    ));\n    \n    return  ret + mod(mod(vec3(10000000.0 * iTime), abs(grain)), 0.0013) * 100.0;\n}\n\nvec3 getFragmentColor (in vec3 origin, in vec3 direction, in vec2 fragCoord) {\n    vec3 originalDirection = direction;\n    vec3 startPoints[MAX_RAYS];\n    vec3 directions[MAX_RAYS];\n    vec3 luminocities[MAX_RAYS];\n    vec2 data[MAX_RAYS];\n    vec3 rgb = vec3(0.0, 0.0, 0.0);\n\n    vec3 reflectFactor   = vec3(1.0, 0.9, 0.9) * 0.5;\n    vec3 refractFactor   = vec3(1.0, 1.0, 1.0) * 1.0;\n    vec3 airAbsorbFactor = vec3(0.003, 0.003, 0.001) * 0.05; // random values for now;\n    vec3 gemAbsorbFactor = vec3(0.1, 0.6, 0.6) * 0.5; //random values for now;\n\n    vec3 normal;\n    vec3 reflection;\n    vec3 refraction;\n    vec3 luminocityA;\n    vec3 luminocityB;\n\n    float side = (getDistance(origin) <= 0.0) ? -1.0 : 1.0;\n    float refractionIndex = 1.0 / REFRACTION;\n\n    directions[0]   = direction;\n    startPoints[0]  = origin;\n    luminocities[0] = vec3(1.0, 1.0, 1.0) * 1.2;\n    data[0] = vec2(1.0, refractionIndex);\n\n    bool outOfSteps = false;\n    bool outOfTime = false;\n    \n    for(int ray = 0; ray < MAX_RAYS; ray++){\n        vec3 luminocity = luminocities[ray];\n\n        vec3 startPoint = startPoints[ray];\n        vec3 direction  = normalize(directions[ray]);\n\n\n        vec2 delta      = vec2 (DELTA, 0.0);\n        side            = data[ray].x;\n        refractionIndex = data[ray].y;\n\n        outOfSteps = false;\n        outOfTime = false;\n        bool modelOuted = (side == 1.0);\n\n        if(max(luminocity.z, max(luminocity.x, luminocity.y)) >= 2.0 * DELTA){\n            outOfSteps = true;\n\n            int totalSteps = 0;\n            float rayLength = 0.0;\n\n\n            for(int step=0; step < MAX_SUBREFRACTIONS; step++){\n                float totalMinimum = RAY_LENGTH_MAX;\n                float prevRayLength = rayLength;\n                // have not reached max refractions\n                outOfSteps = false;\n\n                // launch ray\n\n\n                float distance = RAY_LENGTH_MAX;\n                for (int rayStep = 0; rayStep < MAX_STEPS; ++rayStep) {\n                    outOfSteps = false;\n                    distance = side * getDistance (startPoint) * 0.8;\n                    totalMinimum = min(distance, totalMinimum);\n                    float distMin = max (distance, DELTA);\n                    rayLength += distMin;\n                    outOfTime = false;\n                    \n                    if (distance <= 0.0 || ((rayLength > RAY_LENGTH_MAX || totalSteps >= MAX_STEPS))) {\n                        \n                        outOfSteps = totalSteps > MAX_STEPS;\n                        outOfTime = (rayLength > RAY_LENGTH_MAX || outOfSteps);\n                        break;\n                    }\n                    startPoint += direction * distMin;\n                    totalSteps += 1;\n                    outOfSteps = true;\n                }\n\n                float subRayLength = rayLength - prevRayLength;\n\n\n                // decrease luminocity removing absorb_value * traveled_distance\n                //luminocity -= -rayLength * absorber;\n\n                vec3 absorber = (modelOuted ? airAbsorbFactor : gemAbsorbFactor);\n                //float boost = (1.5 - min(totalMinimum, 1.5)) * 0.04;\n                //boost += (1.0 - min(totalMinimum, 1.0)) * 0.07;\n                //boost += (0.5 - min(totalMinimum, 0.5)) * 0.1;\n                //boost = boost * boost;\n                luminocity = max(luminocity - absorber * subRayLength, 0.0);//  + ((side == 1.0 && distance > 0.0) ? boost : 0.0 );\n                //luminocity = luminocity * (-rayLength * absorber + 1.0);\n\n                if(outOfTime) break;\n\n                normal = conebinationNormal(startPoint) * side;\n\n                reflection = reflect (direction, normal);\n                refraction = refract (direction, normal, refractionIndex);\n\n                // next intersection is new surface\n                if (modelOuted) break;\n\n                // detect total internal reflection\n                if (dot(refraction, refraction) <= 2.0 * DELTA) {\n                    // ray is reflected\n                    direction = reflection;\n                    startPoint += DELTA * MAGICSTEPS * direction;\n                } else {\n                    // ray is refracted\n                    direction = refraction;\n\n                    // next distance is negative\n                    // and normal is reverted\n                    side = -side;\n\n                    // next refraction index is reveted\n                    refractionIndex = 1.0/refractionIndex;\n\n                    // exiting model internal reflection\n                    modelOuted = (side == 1.0);\n                }\n\n                // have reached max refractions\n                outOfSteps = true;\n            }\n        }\n\n        bool rayEnd =  outOfTime || max(luminocity.z, max(luminocity.x, luminocity.y)) < 2.0 * DELTA ;\n        float reflectMultiplier = pow(max (0.0, REFLECTION_POWER * dot(reflection, direction)), 0.3);\n        vec3 lumen = min((reflectFactor * reflectMultiplier), 1.0);\n        luminocityA = rayEnd ? luminocity * (USE_ADDITIONAL_RAYS ? luminocity : luminocity * 0.0) : lumen * luminocity;\n        luminocityB = rayEnd ? vec3(0.0, 0.0, 0.0) : luminocity * (refractFactor);\n\n        if(rayEnd){\n            // still traversing, didn't hit nothing\n            reflection  = direction;\n            refraction  = direction;\n        }\n\n        if(USE_ADDITIONAL_RAYS && backupI < MAX_RAYS && luminocities[backupI] == vec3(0.0, 0.0, 0.0)) {\n            directions[backupI]   = reflection;\n            startPoints[backupI]  = startPoint + reflection * DELTA;\n            luminocities[backupI] = luminocity;\n            data[backupI] = vec2(1.0, 1.0/REFRACTION);\n        }\n\n        if(refractionI < MAX_RAYS) {\n            directions[reflectionI]   = reflection;\n            startPoints[reflectionI]  = startPoint + reflection * DELTA * MAGICSTEPS;\n            luminocities[reflectionI] = luminocityA;\n            data[reflectionI] = vec2(1.0, 1.0/REFRACTION);\n        }\n        if(refractionI < MAX_RAYS) {\n            directions[refractionI]   = refraction;\n            startPoints[refractionI]  = startPoint; //+ refraction * DELTA;\n            luminocities[refractionI] = luminocityB;\n            data[refractionI] = vec2(-1.0, REFRACTION);\n        }\n\n        if(refractionI >= MAX_RAYS || (!USE_ADDITIONAL_RAYS && rayEnd)){\n            vec3 finisher = (side == 1.0) ? airAbsorbFactor : gemAbsorbFactor;\n            //vec3 col = (direction * 0.3 + vec3(1.0,1.0,1.0)*0.7) * (luminocity  - 500.0 * finisher);\n            //vec3 col = (direction * 0.3 + vec3(1.0,1.0,1.0)*0.7);\n            //rgb = vec3(max(rgb.x, col.x), max(rgb.y, col.y), max(rgb.z, col.z));\n\n            //vec3 col = texture(iChannel0, direction).rgb;\n            vec3 col;\n\n\n            col = getBackground(startPoint, direction, originalDirection, fragCoord);\n                //col = abs(direction - 0.5);\n                //col = (direction * 0.3 + vec3(1.0,1.0,1.0)*0.7);\n                //   col = (direction * 0.2 + vec3(1.0,1.0,1.0)*0.7);\n\n            col *= (luminocity  - luminocity * 1000.0 * finisher);\n            rgb = max(rgb, col);\n        }\n    }\n    \n    rgb = clamp(rgb, 0.18, 1.0);\n    return  rgb;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    // Define the ray corresponding to this fragment\n    vec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 direction = normalize (vec3 (frag, 2.0));\n\n    // Set the camera\n    vec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\n    vec3 forward = -origin;\n    vec3 up = vec3 (sin (iTime * 0.5), 2.0, 0.0);\n    mat3 rotation;\n    rotation [2] = normalize (forward);\n    rotation [0] = normalize (cross (up, forward));\n    rotation [1] = cross (rotation [2], rotation [0]);\n    direction = rotation * direction;\n\n    // Set the fragment color\n    fragColor = vec4 (getFragmentColor (origin, direction, frag), 1.0);\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}