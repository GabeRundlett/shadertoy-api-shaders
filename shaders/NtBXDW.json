{
    "Shader": {
        "info": {
            "date": "1627644212",
            "description": "How do you ray march a 4d object?\nThis is the best method I've found so far (earlier attempts on my page). It works for general 4d SDFs. Lots of options if you want to play. criticism and suggestions v welcome.",
            "flags": 0,
            "hasliked": 0,
            "id": "NtBXDW",
            "likes": 7,
            "name": "2d ray marching 4d objects-Demo",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "projection",
                "4d",
                "learning",
                "tesseract",
                "hypercube",
                "hypercube",
                "4draymarching",
                "4dsdf"
            ],
            "usePreview": 0,
            "username": "xertrov",
            "viewed": 467
        },
        "renderpass": [
            {
                "code": "/*\n\n# 2D RAYMARCHING 4D OBJECTS (VOLUMES AND WIREFRAMES) USING ONLY SDFs\n\nMax Kaye - July 2021\nhttps://xk.io\n\nDistributed under CC0 - <https://creativecommons.org/publicdomain/zero/1.0/>\n\n## intro\n\nThis 4d ray-marcher uses an experimental 2-stage method to render 4d objects\nvia SDFs.\n\n## the method\n\nThis breaks down the ray marching into a Z march and (repeated) W march.\nThis is not ideal, though, because we no longer know exactly how far to\ntravel in Z each loop, even with an exact SDM. The problem is that we\nmight to too far in Z and overshoot an adjacent edge in W.\n\nThe best method I've found is:\n\nBased *axial* distance estimates (e.g., `d = abs(p) - s` -- which is exact\nfor tesseract edges), calculate how far it is safe to travel. Changing the\nbasis of `d` (into the basis of our Z and W *ray directions*, not raw axes)\nlets the ray marcher make much more accurate steps commpared to things like\njust multiplying the distance estimate by 0.2.\n\nHowever, this alone doesn't solve the problem. The main other problem is\nthat rays travel too fast through the middle of the cube (and the middle\nof edges, too). Since we're using the SDF for tesseract *edges* (not faces),\nthere's nothing really for the rays to collide with. That means that a ray\ngoing through the middle of the cube cannot safely travel very far at all,\n(in the Z direction) even tho the distance estimate is quite large, still.\nIf you want to see what this effect looks like, comment SLOW_THRU.\n\nThis method is still no where near as accurate (or as efficient) as ray\nmarching only in Z. You can still see some edge-artifacts on the default\nsettings, and if you reduce EDGE_WIDTH the effect becomes very noticeable.\nThe solution is to increase the effective angular resolution.\n\n## about the thing that is shown\n\nThe shape color is based on w-depth. The green background shows how many\nsteps (including the ray marches in W) that were taken to render that\npixel. The green coulds ({dis,en}abled via SPOOKY_BITS) are an artifact of\nslowing the rays near each axix's zero (only while marching on Z) -- this\ncan be adjusted via the SPOOK_BE_GONE definition. Large values make for\nwibly wobly, sometimes-hollow blobs.\n\nImprovement potential:\n\n* Slow rays near verticies -- this looks like another point of distortion and\n  this tech might help here, too.\n\n* figure out a more efficient method of slowing rays near the middle of the\n  axes and around corners.\n\n* lighting and refaction / transaprency (for solid 4d objs -- they work as\n  expected atm, mind)\n\n*/\n\nprecision highp float;\n\n// #define SPOOKY_BITS // comment this to turn off spooky cloudy bits\n#define ORTHOGONAL_CAM // Perspective cam has artifacting and works best with SPOOKY_BITS disabled\n#define EDGE_WIDTH 0.02 // lower => artifacting. I suggest ~0.08 or more for perspective cam.\n#define EDGE_LENGTH .4 // side length\n\n#define SLOW_THRU // comment to see the artifacting caused by rays going too fast through the middle of the cube\n\n#define MAX_STEPS 400\n#define MAX_DIST 50.\n#define SURF_DIST 0.005\n\n#define RM_2STEP 1\n#define RM_NORMAL 0\n#define RM_NORMAL_1D 0\n\n#ifdef SPOOKY_BITS\n#define SPOOK_BE_GONE 0.0\n#else\n#define SPOOK_BE_GONE 0.06\n#endif\n\nfloat sdTesseractEdge(in vec4 p, in vec4 b, out vec4 d) {\n  d = abs(p) - b;\n  return length(best3(d)); // best2 for faces, best3 for edges, best4 (all of them) for corners\n}\n\nfloat sdTesseractFaces(in vec4 p, in vec4 b, out vec4 d) {\n  d = abs(p) - b;\n  return length(best2(d)); // best2 for faces, best3 for edges, best4 (all of them) for corners\n}\n\nfloat sdHypersphere(in vec4 p, in float r, out vec4 d) {\n  d = abs(p) - r;\n  return length(p) - r;\n}\n\nfloat mapWDists(vec4 p, out vec4 distsOut) {\n  /*\n  NB: I suggest only enabling one shape at a time to start with, and only\n  have 1 on at a time (at least until you have a feel for things). Careful\n  with shapes being on top of each other.\n  */\n\n  vec4 dists;\n  float d = 999.;\n\n  d = min(d, sdTesseractEdge(p, vec4(EDGE_LENGTH), dists) - EDGE_WIDTH);\n  distsOut = dists;  // for more shapes: distsOut = min(distsOut, dists);\n\n  // /* position offset works like normal: */\n  // d = min(d, sdTesseractEdge(p - vec4(0,0,0,-1.5), vec4(EDGE_LENGTH), dists) - EDGE_WIDTH);\n  // distsOut = min(distsOut, dists);\n\n  // /* \"solid\" objects (i.e., faces, not edges) work fine */\n  // d = min(d, sdTesseractFaces(p - vec4(0,0,0,-1.5), vec4(EDGE_LENGTH), dists) - EDGE_WIDTH);\n  // distsOut = min(distsOut, dists);\n\n  // /* hyperspheres are a bit boring. */\n  // d = min(d, sdHypersphere(p - vec4(0,0,0,-1.5), EDGE_LENGTH, dists) - EDGE_WIDTH);\n  // distsOut = min(distsOut, dists);\n\n  return d;\n}\n\nfloat map(vec4 p) {\n  vec4 temp;\n  return mapWDists(p, temp);\n}\n\n// Typical raymarching alg. Steps are returned for debugging.\nvec4 rayMarch(inout vec4 p, in vec4 rd, out vec4 dists) {\n  float dS = 99., d = 0., minDS = dS, steps = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    steps++;\n    dS = mapWDists(p, dists);\n    minDS = min(minDS, abs(dS));\n    d += dS;\n    p = p + rd * dS;\n    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;\n  }\n  return vec4(d, dS, minDS, steps);\n}\n\nvec2 e = vec2(.0001, 0);\n\n// Raymarchign that will\nvec4 rayMarch1d(inout vec4 p, in vec4 rd, in vec4 rd2, out vec4 dists) {\n  vec4 dists2, p2;\n  float dS = 99., dSx = 99., dSy, dSz, dSw, d = 0., minDS = dS, steps = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    steps++;\n    dS = mapWDists(p, dists);\n    if (dS > SURF_DIST) {  // we are receeding,\n      p2 = p - rd2 * 1.41;\n      vec4 innerRmd = rayMarch(p2, rd2 * vec4(1,1,1,1), dists2);\n      steps += innerRmd.w;\n      if (innerRmd.y < SURF_DIST) { p = p2; }\n      /* minWith 4d */\n      // float ddS = dS - innerRmd.y;\n      // dists = (max(0., ddS) * dists + max(0., -ddS) * dists2) * -1. / abs(ddS);\n      /* -- end minWith */\n      dists = minWith14(dS, dists, innerRmd.y, dists2);\n      dS = min(dS, innerRmd.y);\n      minDS = min(minDS, innerRmd.z);\n    }\n    minDS = min(minDS, (dS));\n    mat4 chBasis = mat4(0, 0, 0, 0, 0, 0, 0, 0, rd.x, rd.y, rd.z, rd.w, rd2.x, rd2.y, rd2.z, rd2.w);\n    vec4 components = normalize(dists * chBasis);\n    d += dS;\n    /* first, take the largest of the components we got back from the change\n    of basis (it breaks for some angles with less than this - I'm not really\n    sure why) */\n    float dsFactor = maxOf(vec4(components.zw, -components.zw));\n    #ifdef SLOW_THRU\n    // then, slow down the ray whenever it has a coordinate near 0 for some axis.\n    dsFactor *= min(1., max(minOf(abs(p)) + SPOOK_BE_GONE, .01));\n    #endif\n    p = p + rd * dS * dsFactor;\n    // * sin(atan(dSw, dSz)) * (min(1., max(minOf(abs(p)) + SPOOK_BE_GONE, .01))); // move slower inside;\n    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;\n  }\n  return vec4(d, dS, minDS, steps);\n}\n\n\nvec2 scaleUvWithAspect(vec2 st) {\n  float aspect = u_resolution.x / u_resolution.y;\n  float scaleX = step(1.0, aspect), scaleY = 1. - scaleX;\n  aspect = max(aspect, 1. / aspect);\n  st.x = st.x * scaleY + scaleX * (st.x * aspect - (aspect - 1.) / 2.);\n  st.y = st.y * scaleX + scaleY * (st.y * aspect - (aspect - 1.) / 2.);\n  return st - .5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = scaleUvWithAspect(gl_FragCoord.xy / u_resolution.xy);\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time / 3.;\n  vec3 col = BLACK;\n  uv *= 1.0;\n\n  vec4 ro, rd;\n  mat4 r = rot4(t * 1.27 + 3.283, 1) * rot4(t * 1.14 - 1.4389, 4) * rot4(t * .923 - 2.34985, 5) * rot4(t * .8132 + 1.3536, 3);\n\n  // starting this with (uv.w -= 2) (like you might with the z axis) results in issues rendering b/c the ray doesn't pass close enough to the objects to get the sideways projection right.\n  #ifdef ORTHOGONAL_CAM\n    r *= rot4(mouse.x * TAU, 1) * rot4(mouse.y * TAU, 4);\n    uv *= 3.;\n    ro = vec4(uv, -2, 0);\n    rd = vec4(0, 0, 1, 0);\n  #else\n    r *= rot4(mouse.y * TAU, 4);\n    vec2 mxr = sinCos(12.0 + 0.5*t + 10.0*mouse.x);\n\t  ro = vec4( 3.0*mxr.y, .0, 3.0*mxr.x, 0.);\n    float fov = .7;\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro.xyz );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    rd = normalize(vec4(uv.x*uu + uv.y*vv + fov*ww, 0.));\n    mat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n    \t\t\t\t vv.x, vv.y, vv.z, 0.0,\n    \t\t\t\t ww.x, ww.y, ww.z, 0.0,\n    \t\t\t\t -dot(uu,ro.xyz), -dot(vv,ro.xyz), -dot(ww,ro.xyz), 1.0 );\n  #endif\n  vec4 rd2 = rd.xywz;\n\n  ro *= r;\n  rd *= r;\n  rd2 *= r;\n\n  vec4 p = ro, dists, rmd;\n  if (RM_NORMAL == 1) { p = vec4(uv.xy, ro.zw); }\n  if (RM_NORMAL == 1 || RM_NORMAL_1D == 1) { rmd = rayMarch(p, rd, dists); }\n  else if (RM_2STEP == 1) { rmd = rayMarch1d(p, rd, rd2, dists); }\n\n  float d = rmd.x, dS = rmd.y, minDS = rmd.z, steps = rmd.w;\n\n  float shapeOnly = step(1., 1. - minDS + SURF_DIST * 2.);\n  float sst = 0.05;  // smoothstep threshhold\n\n\n  col.g += S(.0, float(MAX_STEPS * 6), rmd.w) * S(0., sst / 2., minDS);\n  // col.r += S(.05, .0, minDS);\n  col.b += S(.05, .0, minDS) * hh(S(1.41, -1.41, p.w));\n  col.r += S(.05, .0, minDS) * hh(S(1.41, -1.41, p.z));\n  // col.g += S(.05, .0, minDS) * S(1.41, -1.41, p.z);\n  // col += S(.01, .0, abs(minDS - .02)) * vec3(0.4667, 0.1882, 0.0314);\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* copy pasted from my libs. lots is written by me. you're welcome to use it, but caveat emptor. */\n\n#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define SQRT_3 1.7320508\n#define SQRT_2 1.41421356\n\n#define S(a, b, t)smoothstep(a, b, t)\n#define hh(x)(x * 0.5 + 0.5)\n#define zoth vec4(0.0, 1.0, 2.0, 0.5)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n\nvec2 best2(vec3 p) {\n  vec2 r = vec2(max(p.x, p.y), min(p.x, p.y)); // : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nvec2 best2(vec4 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { r = vec2(p.z, r.x); }\n  else if (p.z > r.y) { r = vec2(r.x, p.z); }\n  if (p.w > r.x) { return vec2(p.w, r.x); }\n  else if (p.w > r.y) { return vec2(r.x, p.w); }\n  return r;\n}\n\nvec3 best3(vec4 p) {\n  vec2 zw = vec2(max(p.z, p.w), min(p.z, p.w));\n  // p.z > p.w ? vec2(p.z, p.w) : vec2(p.w, p.z);\n  vec2 xy = vec2(max(p.x, p.y), min(p.x, p.y));\n  if (xy.y > zw.x) {return vec3(xy, zw.x);} // testme\n  if (zw.y > xy.x) {return vec3(zw, xy.x);}\n  return vec3(max(xy.x, zw.x), min(xy.x, zw.x), max(xy.y, zw.y));\n\n  /* tests\n  col = best2(zoth.xyz) == vec2(2., 1.) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.zywx) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxzy) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxyz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.xywz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  */\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\nfloat maxOf(vec2 v) {\n  return max(v.x, v.y);\n}\nfloat sumOf(vec2 v) {\n  return v.x + v.y;\n}\n\nfloat minOf(vec3 v) {\n  return min(minOf(v.xy), v.z);\n}\nfloat maxOf(vec3 v) {\n  return max(maxOf(v.xy), v.z);\n}\nfloat sumOf(vec3 v) {\n  return sumOf(v.xy) + v.z;\n}\n\nfloat minOf(vec4 v) {\n  return min(minOf(v.xyz), v.w);\n}\nfloat maxOf(vec4 v) {\n  return max(maxOf(v.xyz), v.w);\n}\nfloat sumOf(vec4 v) {\n  return sumOf(v.xyz) + v.w;\n}\n\nfloat bestOf(vec2 p) {\n  // return p.x > p.y ? p.x : p.y;\n  return max(p.x, p.y);\n}\nfloat bestOf(vec3 p) {\n  return max(max(p.x, p.y), p.z);\n}\nfloat bestOf(vec4 p) {\n  return max(bestOf(p.xyz), p.w);\n}\n\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\nvec2 sinCos(in float a) {\n  return vec2(sin(a), cos(a));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\nmat4 rot4(float angle, int axis) {\n  float s = sin(angle), c = cos(angle);\n  mat4 r = mat4(\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  // XY, XZ, XW\n  return axis == 0 ? r\n    : axis == 1 ? mat4(r[0].xzyw, r[2].xzyw, r[1].xzyw, r[3].xzyw)\n    : axis == 2 ? mat4(r[0].xwzy, r[3].xwzy, r[2].xwzy, r[1].xwzy)\n    // YZ, YW\n    : axis == 3 ? mat4(r[3].wxyz, r[0].wxyz, r[1].wxyz, r[2].wxyz)\n    : axis == 4 ? mat4(r[3].wxzy, r[0].wxzy, r[1].wxzy, r[2].wxzy)\n    // ZW\n    : axis == 5 ? mat4(r[3].wzxy, r[2].wzxy, r[0].wzxy, r[1].wzxy) : mat4(0.);\n}\n\n\n\nvec2 minWith(vec2 a, vec2 b) {\n  return (min(0., (a.x - b.x)) * a + min(0., (b.x - a.x)) * b) * -1. / abs(b.x - a.x);\n  // if (a.x <= b.x) {\n  //   return a;\n  // }\n  // return b;\n}\nvec4 minWith14(float a, vec4 av, float b, vec4 bv) {\n  float ba = b - a;\n  return (max(0., ba) * av + max(0., -ba) * bv) * -1. / abs(ba);\n  return b > a ? bv : av;\n}\n\n\n\n// Some SDFs\n\n\nfloat sdTriangle1(vec2 uv, float b) {\n  float willFold = sign(step(.0, -uv.x) + (step(.0, -uv.y) * step(0., -dot(sinCos(TAU / 12.), uv))));\n  float splitAt = -dot(sinCos(- 7. * TAU / 12.), uv);\n  float top = sign(splitAt);\n  float foldAngle = (step(0., top) * TAU / 4. + step(0., -top) * (TAU / 12.)) * willFold;\n  vec2 n = sinCos(foldAngle);\n  float fold = -dot(n, uv) * willFold;\n  uv += fold * n * 2.;\n  // get distance to line that is our edge\n  return dot(uv, sinCos(TAU / 6.)) - b * .5;\n}\n\nvec4 sdTriangle1(vec3 p, float b) {\n  return vec4(length(vec2(sdTriangle1(p.xy, b), p.z)), abs(p)); // approximate dists for each axis\n}\n\nfloat sdTriangle2(vec2 uv, float b) {\n  float a = atan(uv.x, uv.y) + PI;\n  float id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return  uv.y - b / 2.;  // estimate based only on y; but it works...\n}\n\nvec4 sdTriangle2(vec3 p, float b) {\n  vec3 dd = abs(p) - vec3(0,b,0);\n  return vec4(length(vec2(sdTriangle2(p.xy, b), p.z)), dd);\n}\n\nvec2 foldXyThirds(vec2 uv, out float id) {\n  float a = atan(uv.x, uv.y) + PI;\n  id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return abs(uv);\n}\n\nvec2 foldXyThirds(vec2 uv) {\n  float id;\n  return foldXyThirds(uv, id);\n}\n\nfloat sdTriangleGen(vec3 p, float r, out vec3 dists) {\n  p.xy = foldXyThirds(p.xy);\n\n  vec3 a = vec3(r / 2. * SQRT_3, r / 2., 0.);\n  vec3 b = a * vec3(-1, 1, 1);\n  vec3 ap = p - a;\n  vec3 ab = b - a;\n  //* (step(r / 2., p.y) * 2. - 1.)\n  float dotPaBa = dot(ap, ab);\n  float dotBaBa = dot(ab, ab);\n  float h = clamp(dotPaBa / dotBaBa, -0., 1.);\n  dists = ap - h * ab;\n  float d = length(dists);\n  // for negative:\n  // * (step(r / 2., p.y) * 2. - 1.);\n\n  return d;\n}\n\n/* searching for a similar generalized tetrahedron method didn't work,\nbut i found some fun triangle methods.\n\nThe following isn't exact, but it's p nice:\n*/\n\n\nvec3 sdTetrahedronInner(vec3 p, float r) {\n  float ySign = sign(p.y);\n  p.xz = abs(ySign < 0. ? p.zx : p.xz);\n  p.y = abs(p.y);\n  vec3 box = vec3(mix(r/2., r, p.y / r), r, mix(r/2., r, -p.y / r));\n  return p - box;\n}\n\nfloat sdTetrahedron(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(bestOf(dists));\n}\n\nfloat sdTetrahedronFrame(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(best2(dists));\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}