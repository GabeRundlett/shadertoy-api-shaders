{
    "Shader": {
        "info": {
            "date": "1604334545",
            "description": "theres diagonal banding, and i do fourier analysis here to try to adress that:\nhttps://www.shadertoy.com/view/WsdBzH",
            "flags": 0,
            "hasliked": 0,
            "id": "Ws3BzH",
            "likes": 3,
            "name": "Costas5 MixedPrimeBase * pqfm",
            "published": 3,
            "tags": [
                "noise",
                "dither",
                "bluenoise",
                "costas",
                "costasarray",
                "patternfree"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animateable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//   self: https://www.shadertoy.com/view/Ws3BzH\n//parent0: https://www.shadertoy.com/view/tstBRr\n//parent1: https://www.shadertoy.com/view/Wsdfzr\n//parent2: https://www.shadertoy.com/view/tdjfzR\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\n/*\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n\n\nlist of primes \n(stop at the number, where either\n, i find no good enough costasArray, or take to loong to find one)\n2,    //will skip this, cause its costasArray is too similar to [3]\n3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, \n43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\n101\t103\t107\t109\t113\t127\t131\t137\t139\t149\t151\t157\t163\t167\t173\n\t179\t181\t191\t193\t197\t199\t211\t223\t227\t229\t233\t239\t241\t251\t257\t263\t269\t271\t277\t281\n\t283\t293\t307\t311\t313\t317\t331\t337\t347\t349\t353\t359\t367\t373\t379\t383\t389\t397\t401\t409\n\t419\t421\t431\t433\t439\t443\t449\t457\t461\t463\t467\t479\t487\t491\t499\n*/\n\n\n    \n\n/*\n\n5,3\n\nthe base (count of numbers) is the product of all larger primes\nand the smallest prime multiplies that amount by itself\n\nlets take the bases 3,5,7\n\nand its value       131 \none   threes means we counted ober 5*7 one   times, so the sum is +=1*5*7\nthree fives  means we counted over   7 three times, so the sum is +=3*  7\none   sevens                                      , so the sum is +=1\n->  5*7+3*7+1 == (5+3)*7+1 = 8*7+1=57\n, now, this is silly, while bases are very small, lets go bigger\n, also remember, a base os a mod(), base 10 never reaches 10, cause it includes 0\n\nlets do a 7 primes digit, with the bases\n3, 5, 7, 11, 13, 17, 19, \nand its\n2  3  3  9   8   0    11\n\nthe sum is\n0\n+ 2*5* 7* 11* 13* 17* 19\n+   3* 7* 11* 13* 17* 19\n+      3* 11* 13* 17* 19\n+          9* 13* 17* 19\n+              8* 17* 19\n+                  0* 19\n+                     11\n=4382152\n\n\n\n\n//lets see how many bits we need for the largest value of N primes, and stay below 32 bits.\n\n3, 5, 7, 11, 13, 17, 19, 23\n0\n+ 3*5* 7* 11* 13* 17* 19*23\n+   4* 7* 11* 13* 17* 19*23\n+      6* 11* 13* 17* 19*23\n+         10* 13* 17* 19*23\n+             12* 17* 19*23\n+                 16* 19*23\n+                     18*23\n+                        22\n=148728579 (still < 32^2-1 bit range)\n\n3, 5, 7, 11, 13, 17, 19, 23,29\n0\n+ 3*5* 7* 11* 13* 17* 19*23*29\n+   4* 7* 11* 13* 17* 19*23*29\n+      6* 11* 13* 17* 19*23*29\n+         10* 13* 17* 19*23*29\n+             12* 17* 19*23*29\n+                 16* 19*23*29\n+                     18*23*29\n+                        22*29\n+                           28\n4313128819(needs 33 bits)\n\nin retrospect, lets also ditch the 3 and 5, and get the 31 instead\n 7, 11,13,17,19,23,29,31\n0\n+ 6*11*13*17*19*23*29*31\n+   10*13*17*19*23*29*31\n+      12*17*19*23*29*31\n+         16*19*23*29*31\n+            18*23*29*31\n+               22*29*31\n+                  28*31\n+                     30\n6685349670 (needs 33 bits), ditch 7 and 11, take in 37\n\n\n  13,17,19,23,29,31,37\n0\n+ 12*17*19*23*29*31*37\n+    16*19*23*29*31*37\n+       18*23*29*31*37\n+          22*29*31*37\n+             28*31*37\n+                30*37\n+                   36\n=3212440750  (within 32 bit AND it is 74% of its max value 4294967295\n*/\n\n#define arrLen 7\nint mixedPrimeBase(int[arrLen] a //[a] stores a number in bases [b] (different base foreach digit)\n){int b[arrLen]=int[arrLen](37,31,29,23,19,17,13);\n ;int c=1,r=0;//CumilativeBaseFactor , accumulatorToReturn\n ;for(int i=0;i<arrLen;i++){;r+=(a[i]-1)*c;c*=b[i];}return r;}\n\n/*\ntheres another approach to this, with more prime bases, but each base is only binary.\nsee [boolean but jittery]\nthis may actually be much more memory efficient and cooler in animation\nits largest value would be \"111111111111111...\" as the sum of many primes. (no multiplication in here)\nbut that would have 32 or 64 (or more) primes.\nwe just chose arbitiary large primes (not necessarily many small ones)\nas long as the sum of all primes (sum < (pow(2,32)-1)) we will be fine.\n\n*/\n\n//todo, 2d fourier transform\n\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\n/*\n\ncostas arrays are pattern free==aperiodic\n3d costas arrays are impractival (too large LUT)\nbut a self recursed 2d costas array is still semi-aperiodic\n, great for dithering (in theory)\nsome of them still compress nicely due to meta-patterns between 2 of em\n\n\ncostas array [mode==0] is pattern free \nin short, it is an extension to the \"place the most exclusive queens on a checkerboard\"\n- BUT where even ALL XY-differentials between any 2 tokens must be unique (on a torus repetition)\nThis is (in theory) ideal for dithering\n(or as a basis for a music scmapler, that just has to add local arbitiary (strided) repetitions)\n\nThe [mode==1] greyscaling gradient is BASIC (and too much of a pattern)\n\nIt can easily be more distorted\n, by applying a second greyscaling-recursionpass [mode==2] of a costas array \n\nIf that is the same CostasArray over itself, it is only SEMI-pattern-free\n, even that but likely still good enough.\n\nTo turn this into (any amount of) (pattern free) BLUE (noise)\n,simply mix(a,b,0.75) 2 of these, where the scale.xy of one of CostasArray [a] \nis an interger multiple of the scale of the scale.xy of CostasArray [b]\n(and make sure, that both costas arrays are also costas-arrays over a tiled neighborhood)\n\nalso see [worlds ugliest music]==  https://www.youtube.com/watch?v=RENk9PK06AQ\n*/\n\n#define animatePaletteSpeed .9\n\n#define mode int(5.*iMouse.y/iResolution.y)\n//#define mode 4\n\n//mode 2 shows costas array as boolean dots\n//mode 1 shows it as linear fade gradient\n//mode 9 suffles the gradeitn by the same costas array\n//- this looks fine for most costas arrays, though its only semi-pattern.free\n//I assume mode 2 fails on SIMPLE costas3() costas arrays (that compress more than a LUT)\n//it sure looked nicer on my LUT arrays.\n//mode 4 cycles trhough all modes\n\n#define period 3\n\n//place multiple smaller tiles (important to expose some pattern)\n#define MultiTile 5.\n\n//scale by period\n#define zoom (min(iResolution.x,iResolution.y)/float(period-1))\n//pixel perfect, but only in preview\n//#define zoom 1.\n\n/*  //mathematical construction of a costas array list quickly hits limits of 32bit int\n    //therefore this segment is quite limited in its utility, and therefore commented out\n\n#define base1 2\n//the  (pase,period) pairs -> (3,5) (3,7) (5,7) make costas arrays\n//the  (pase,period) pairs (2,11) (2,13) (2,29) look a lot like they make costas arrays\n//(5,9) (7 11)\n//the function below fails for too large [#] values\n//it breaks for period>=37 (overflow or low float precision?)\n\n//way too high exponents in this one.\nint poi(int a,int b){//integer pow(a,b) as loop is slow but more precise\n ;//b=abs(b) //imply b>-1\n ;int r=a;for(int i=0;i<b;i++){r*=a;}return r;}\nint costas3(int x,int b\n){//return int(round(pow(float(b),float(x)+1.)))%int(period)//round() is essential on type float\n ;return poi(int(b),int(x))%period //type int has larger range, but type int exp() is silly\n ;}\n\n//return entry [a] of CostasArray list\n//return entry a of array (is a heightmap-like wrapper function)\n/**/\n\n\nint ae(int a){    \nint c[]=int[3](1,3,2);\n//;int c[]=int[5](3,5,1,4,2);//LEAST NOTICEABLE diagonal banding (also in reverse)   \n//int c[]=int[5](5,2,4,3,1);//diagonal banding (also in reverse)   \n//;int c[]=int[7](3,7,1,4,6,5,2);//diagonal great (reversed to kill banding)    \n//;int c[]=int[11](1,10,4,3,8,11,9,5,7,2,6);//diagonal great    \n//;int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);//diagonal good\n//;int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);//diagonal great\n//all costas arrays of size 19 are (no diagonal symmetry at all):\n//;int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);//meh\n//;int c[]=int[19](1,13,12,18,11,15,17,7,10,5,14,19,16,8,6,2,9,3,4);//bad\n//;int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);//diagonal meh\n//;int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);//----great and sdiagonal\n//;int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);//\n//;int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);\n/**/\n;return c[(       a  )%period]\n;//return c[(period-a-1)%period]//reverse\n;}    //i admit, its quite the LUT\n    //but give it a try, because it should be VERY aperiodic, in theory, great for dithering\n    //\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\nint gpo(int a){int b[arrLen]=int[7](37,31,29,23,19,17,13);return b[a];}\n\nint getCostasOf(int a,int p){//return costas at Position of Array#\n if(a<4){\n  if(a<2){\n   if(a==0){int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);return c[p%37]\n     ;}else{int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);return c[p%31];}\n     }else{\n   if(a==2){int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);return c[p%29]\n     ;}else{int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);;return c[p%23];}\n}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);return c[p%19];}\n   if(a==5){int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);;return c[p%17];}\n           {int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);;return c[p%13];}}}\n\nint Cs(ivec2 u,int a){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //tile to positive infinity\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)//-1??\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r+=(iFrame/4)%per\n ;r=r%per;\n ;return r;}\n\nvec4 CostasNoise(ivec2 u){\n ;u/=2\n /*\n ;int[arrLen] m=int[arrLen](0,0,0,0,0,0,0);\n ;m[0]=Cs(u,0);\n ;m[1]=Cs(u,1);\n ;m[2]=Cs(u,2);\n ;m[3]=Cs(u,3);\n ;m[4]=Cs(u,4);\n ;m[5]=Cs(u,5);\n ;m[6]=Cs(u,6);\n ;float a=float(mixedPrimeBase(m))/float(3212440750)//first attempt failed*/\n     //VERY exponential weights seem silly mow, but the precison would be neat.\n     \n \n ;float r=0.;\n ;float f[]=float[7](1.,2.,3.,2.,.4,.5,.6)//weights (should be exponential)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n ;r+=float(Cs(u,0))/float(gpo(0))*f[0];\n ;r+=float(Cs(u,1))/float(gpo(1))*f[1];\n ;r+=float(Cs(u,2))/float(gpo(2))*f[2];\n ;r+=float(Cs(u,3))/float(gpo(3))*f[3];\n ;r+=float(Cs(u,4))/float(gpo(4))*f[4];\n ;r+=float(Cs(u,5))/float(gpo(5))*f[5];\n ;r+=float(Cs(u,6))/float(gpo(6))*f[6];\n ;float a=r/(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])\n ;return vec4(a,a,a,1);\n}\n\n/*\nvec4 getCostasOfFloat(vec2 u //parent main function as backup subroutine\n){//u=u.yx\n ;int m=mode\n ;if (m==4)m=int(iTime+2.)%3;  \n ;if(m==0)m=2 ;else if (m==2)m=0 //swap mode 0 and 2\n ;vec3 c=vec3(0)\n ;ivec2 U=ivec2(MultiTile*u*float(period)/iResolution.y)\n ;if(u.x<float(period-1)*zoom\n   &&u.y<float(period-1)*zoom //if not the blue part\n ){\n  #ifdef MultiTile\n  ;U=U%period\n  #endif\n  ;//U=U.yx                          //sqivel domains\n  //;u*=float(period)/iResolution.y\n  ;//if(u.x<2.)c=vec3(1);\n  ;float f=0.\n  ;int a=0\n  ;if(m==0         //the [period-] is just for symmetry, actually optional\n  ){if(ae(U.y)==period-U.x)a=period/2;//black or grey  \n  }else{\n   ;a=ae(U.y)+(U.x)       \n   //[period-] is just for symmetry, actually optional\n   ;a=period-a%period   //;if(a>period)a-=period //single overflow   (no mod needed) \n   ;if(m>1\n   ){a=ae(a)//+(U.y)     //+1 ae() recursion the +=y just removes symmetry, is semi arbitiary naoise\n    ;a+=ae(period-1)\n    ;a=a%period;}}\n  ;f=float(a)/float(period) \n      \n  #ifdef animatePaletteSpeed\n  ;if(m!=0){f-=fract(iTime*animatePaletteSpeed)////cos(iTime)*.5+.5\n   ;if(f<0.)f+=1.;}\n  #endif\n  ;c=mix(vec3(f,f,f),mix(vec3(0,.4,1),vec3(1,.4,0),f),iMouse.x/iResolution.x)\n ;}\n //below code highlights lower right triangle points green \n //IFF they have a diagonal mirror\n ;if(period-U.x-1>U.y\n    ){if(ae(U.y)==period-U.x\n     ){if(ae((period-U.x-1))==U.y+1)\n         c+=vec3(0,1,0);}}//bottom left mirroreds marked white\n  //IFF they have a diagonal mirror\n ;if(U.x<U.y\n    ){\n     ;if(ae(U.y)==period-U.x\n     ){\n     if(ae(U.x)==period-U.y)\n         c+=vec3(0,1,0);}}//top left mirroreds marked white /**/\n// ;return vec4(c,1);}\n\nvoid mainImage(out vec4 O, vec2 u\n){//O=getCostasOfFloat(u);\n ;//u*=4.\n ;u/=1.5\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;O=CostasNoise(ivec2(u)+scroll);\n }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nselection of some costasArrays\npersonally i only care for diagonal-mirror-SYMMETRICAL costasArrays, because these compress a lot better.\n\nall* symmetrical costas arrays of order 3 are:\nint[3](1,3,2);\nall* symmetrical costas arrays of order 5 are: (all length 5 ones are banding, one hjust hides it thebest)\n//;int c[]=int[5](3,5,1,4,2);//LEAST NOTICEABLE diagonal banding (also in reverse)    \n//int c[]=int[5](5,2,4,3,1);//diagonal banding (also in reverse)   \nall* symmetrical costas arrays of order 7 are:\n//;int c[]=int[7](3,7,1,4,6,5,2);//diagonal great (reversed to kill banding)\n//;int c[]=int[7](1,2,7,4,6,5,3);//diagonal meh mixer   \n//;int c[]=int[7](1,7,3,4,6,5,2);//diagonal bad zigzag\n//;int c[]=int[7](2,1,6,4,7,3,5);//diagonal good (minor band)  \n//;int c[]=int[7](3,6,1,7,5,2,4);//diagomnal great (minor band)\n//;int c[]=int[7](2,1,5,7,3,6,4);//diagonal meh (minor band)\n//;int c[]=int[7](1,2,7,5,4,6,3);//diagonal bad onedirectional  \n//;int c[]=int[7](4,7,3,1,6,5,2);//diagonal minor band  (reversed to kill banding)\n//;int c[]=int[7](5,7,4,3,1,6,2);//2,6,1,3,4,7,5);//diagonal bad (even after reversing)\n//;int c[]=int[7](5,3,7,4,6,2,1);//1,2,6,4,7,3,5);//diagonal horrible band (even after reversing)\nall!! symmetrical costas arrays of order 11 are:\n//;int c[]=int[11](1,10,4,3,8,11,9,5,7,2,6);//diagonal great    \n//;int c[]=int[11](1,7,11,6,8,4,2,5,10,9,3);//diagonal great rainy\n//;int c[]=int[11](3,10,1,9,6,5,7,11,4,2,8);//diagonal good (jitters)\n//;int c[]=int[11](1,6,8,9,4,10,3,7,5,2,11);//diagonal bad\n//;int c[]=int[11](1,7,5,8,10,4,9,6,2,3,11);//diagonal horrible band\n\n//all symmetrical costas arrays of size 13 are:\n//;int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);//diagonal good\n    \n//all symmetrical costas arrays of size 17 are:     \n;int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);//diagonal great\n//;int c[]=int[17](1,7,15,11,8,10,2,5,17,6,4,13,12,16,3,14,9);//diagonal good rain\n//;int c[]=int[17](1,12,14,15,6,16,11,4,7,3,9,13,2,10,8,5,17);//diagonal bad\n//;int c[]=int[17](1,11,15,7,12,13,16,6,3,5,14,10,8,2,9,4,17);//diagonal horrible band\n//;int c[]=int[17](2,6,3,13,14,1,9,5,11,4,7,16,10,8,15,17,12);//diagonal horrible band\n\n//0 symmetrical costas arrays of size 19, only 2 in total\n//;int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);//meh\n//;int c[]=int[19](1,13,12,18,11,15,17,7,10,5,14,19,16,8,6,2,9,3,4);//bad\n\n//all!! symmetrical costas arrays of size 23 are:\n//;int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);//diagonal meh\n//;int c[]=int[23](5,3,2,20,1,12,9,19,7,15,21,6,22,17,10,23,14,18,8,4,11,13,16);//diagonal bad\n//;int c[]=int[23](1,16,13,11,17,8,19,22,12,7,21,15,20,5,9,18,14,2,10,3,4,6,23);//diagonal horrible    \n//;int c[]=int[23](2,9,14,4,10,12,16,17,1,21,8,18,7,19,22,13,11,6,3,20,5,23,15);//diagonal horrible    \n\nall!! symmetrical costas arrays of order 29 are:\n//;int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);//diagonal great\n//;int c[]=int[29](7,20,28,8,25,15,1,4,23,27,22,14,16,12,6,13,18,17,26,2,29,11,9,24,5,19,10,3,21);//diagonal okay\n//;int c[]=int[29](1,17,22,13,19,23,24,27,11,8,25,15,28,7,18,6,26,12,21,3,5,20,16,14,9,2,10,4,29);//diagonal bad\n//;int c[]=int[29](2,1,8,12,25,15,18,3,13,22,17,4,9,28,6,29,11,7,21,27,19,10,26,24,5,23,20,14,16);//diagonal bad\n//;int c[]=int[29](6,26,23,28,5,8,27,1,16,14,7,18,4,21,12,20,2,15,3,9,10,24,19,29,25,17,11,13,22);//diagonal horrible (vetically linear)\n\nall!! costas arrays of order 31 are: (only one asymmetrical one)\n;int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);//\n \nall KNOWN symmetrical costas arrays of order 37 are:\n//;int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);//diagonal meh (reverse is banded)\n//;int c[]=int[37](14,9,32,29,22,16,33,20,2,15,27,18,21,1,10,6,36,12,37,8,13,5,26,24,34,23,11,30,4,28,35,3,7,25,31,17,19);//diagonal bad (reverse is banded)\n\n\nall* symmetrical costas arrays of order 2 are: (skipped, too small)\n,1,2\nall* symmetrical costas arrays of order 4 are: (skipped, non prime)\n,1,2,4,3\nall* symmetrical costas arrays of order 6 are: (skipped, non prime)\n,1,4,5,3,2,6\n,1,5,3,6,2,4\n,1,6,3,5,4,2\n,1,6,4,3,5,2\n,2,4,5,1,6,3\nall* symmetrical costas arrays of order 8 are: (skipped, non prime)\n,1,5,8,4,2,7,6,3);\n,1,7,3,8,6,5,2,4);\n,1,7,4,3,5,8,2,6);\n,3,5,1,8,2,7,6,4);\nall* symmetrical costas arrays of order 9 are: (skipped, non prime)\n,1,4,6,2,9,3,8,7,5);\n,2,1,5,8,3,9,7,4,6);\nall* symmetrical costas arrays of order 10 are: (skipped, non prime)\n,1,7,4,9,3,5,8,6,2,10\n,2,1,9,4,5,8,10,6,3,7\n,2,6,8,1,9,5,3,4,10,7\n,2,8,9,4,1,3,7,5,10,6\n,3,9,1,4,5,10,8,7,2,6\n,3,9,7,8,4,1,6,10,2,5,\nall* symmetrical costas arrays of order 12 are: (skipped, non prime)\n,1,2,8,12,7,9,5,3,6,11,10,4\n,1,2,11,5,4,9,12,10,6,8,3,7\n1,4,11,2,10,7,6,8,12,5,3,9\n3,6,1,12,10,2,7,9,8,5,11,4\nall* symmetrical costasArrays of order 16 are  (skipped, non prime)\n1,13,3,16,14,8,10,6,15,7,12,11,2,5,9,4\n3,12,1,4,10,6,14,9,8,5,15,2,16,7,11,13\n3,13,4,15,12,6,10,2,7,8,11,1,14,16,9,5\n6,14,10,7,9,1,4,16,5,3,12,11,15,2,13,8\nall* symmetrical costasArrays of order 27 are (skipped, non prime)\n1,25,19,5,4,12,10,16,26,7,18,6,23,27,24,8,21,11,3,22,17,20,13,15,2,9,14\n3,9,1,8,13,15,19,4,2,20,11,25,5,17,6,27,14,24,7,10,26,23,22,18,12,21,16\n3,24,10,26,20,15,13,23,14,1,8,4,22,19,21,2,5,25,9,17,6,7,11,16,27,12,18\n4,17,21,9,11,16,25,12,1,7,26,22,14,15,13,20,23,3,24,6,18,8,2,27,10,5,19\n6,10,23,13,16,1,11,20,15,2,7,26,4,27,9,5,19,25,17,8,24,22,3,21,18,12,14\n6,16,20,12,14,7,1,25,8,17,18,26,11,23,10,24,15,13,3,19,22,27,5,2,9,4,21\n6,23,14,8,21,1,26,4,22,20,12,11,16,3,17,13,15,24,27,10,5,9,2,18,25,7,19\n\n\n    \n\n\n[*]== there are more than these BUT these extra costas-arrays are just a few SPECIFIC diagonal offsets \n(aslong the mirror axis) of the ones that are listed.\nand theres always the 4 axisAligned mirrors of g-symmetry.\n\nsome symmetrical costasArrays f order 30 are: (skipped, non prime)\n,1,23,14,12,18,26,30,20,25,11,10,4,16,3,21,13,22,5,19,8,15,17,2,28,9,6,29,24,27,7\n,11,22,5,13,23,10,2,26,29,15,19,20,14,4,6,21,18,27,1,30,25,7,3,9,16,28,17,8,24,12\n,12,24,20,17,2,9,29,3,16,4,28,18,19,27,22,6,10,1,30,8,14,25,11,5,15,7,21,23,26,13\n,13,26,2,21,29,4,9,11,15,27,12,8,17,18,7,22,1,30,20,23,6,24,19,16,10,3,25,5,28,14\n\na symmetrical costas array of order 35 is: (skipped, non prime)\n,1,12,7,27,32,30,3,24,31,17,19,2,16,29,20,13,10,35,11,15,23,33,21,8,26,25,4,34,14,6,9,5,22,28,18\n,\na symmetrical costas array of order 65 is: (skipped, non prime)\n,1,29,46,16,24,37,17,22,12,63,55,9,15,42,13,4,7,26,44,56,50,8,49,5,40,18,32,34,2,54,51,27,65,28,53,57,6,39,38,25,48,14,59,19,62,3,58,41,23,21,31,61,35,30,11,20,36,47,43,64,52,45,10,60,33\n\na symmetrical costas array of order 99 is: (skipped, non prime)\n1,33,94,11,21,59,40,85,39,44,4,75,88,36,73,56,60,45,67,61,5,24,55,22,87,30,92,64,37,26,49,51,2,79,38,14,29,35,9,7,97,63,89,10,18,70,62,76,31,99,32,78,65,74,23,16,96,71,6,17,20,47,42,28,53,95,19,69,68,46,58,86,15,54,12,48,82,52,34,91,98,77,93,90,8,72,25,13,43,84,80,27,83,3,66,57,41,81,50\n\t33\t94\t11\t21\t59\t40\t85\t39\t44\t4\t75\t88\t36\t73\t56\t60\t45\t67\t61\t5\t24\t55\t22\t87\t30\t92\t64\t37\t26\t49\t51\t2\t79\t38\t14\t29\t35\t9\t7\t97\t63\t89\t10\t18\t70\t62\t76\t31\t99\t32\t78\t65\t74\t23\t16\t96\t71\t6\t17\t20\t47\t42\t28\t53\t95\t19\t69\t68\t46\t58\t86\t15\t54\t12\t48\t82\t52\t34\t91\t98\t77\t93\t90\t8\t72\t25\t13\t43\t84\t80\t27\t83\t3\t66\t57\t41\t81\t50\n\n/**/\n\n/*\n\n//for compatibility with old opengl versions \n//(and to make arrays forksafe)\n//define shitty array struct\n//, with get()set()wrappers and constant array length code.\n//maxlen 27 ceashes too many tested environments (this first version is a bit shitty, too)\n#define maxLen 26\nstruct arr{int a[maxLen];int len;};\nvoid setN(inout arr u,int n,int s){n=clamp(n,1,maxLen);u.len=max(u.len,n);u.a[n-1]=s;}\nint  getN(arr u,int n){return u.a[clamp(n-1,0,u.len-1)];}//worksafing clamp()is faster than mod()\narr  newA(){arr r; r.len=1; r.a[0]=0;return r;}\n\n\n//modify setArray()to set the size of the array \n//AND the height of its pixels (last parameter)\n//theres only 1 pixel per column (later ones overwrite earlier ones)\n//any 2 pixels in the same line will be marked in white\n//where this is found ONCE (is not a CostasArray in that case)\narr setArray(){ //this could be read from a vertex buffer.\n ;arr a=newA()\n ;setN(a,1,1)\n ;setN(a,2,3)\n ;setN(a,3,4)\n ;setN(a,4,2)\n ;setN(a,5,5)\n\n//slow checker if an \n//struct arr{int a[maxLen];int len;}; \n//is a costasArray: https://www.shadertoy.com/view/tdjXWh\n//return array type[arr] as list of differentials of [a] with indexDistance [d]=[0<d<a.len]\narr strideDiff(arr a,int d\n){arr r=newA()\n ;for(int i=1;i<maxLen;i++\n ){setN(r,i,getN(a,i)-getN(a,i+d))\n  ;if (i+d>=a.len)break;}\n ;return r;}\n//getDupeEntry;\n//return pointers to the first 2 found duplicate entries in [a], comparing from a[0] till a[l].\n//if (there are no duplicate entry in [a] till entry a[l] )return ivec2(-1,-1)\nivec2 getDupeEntryS(ivec2 r,arr a,int i,int j\n){for(i=1;i<j;i++){if(getN(a,i)==getN(a,j))return ivec2(i,j);}\n ;return r;}\nivec2 getDupeEntry(arr a\n){ivec2 r=ivec2(-1,-1)//default state of [no dupes found]\n ;for(int i=0;i<maxLen-1;i++\n ){if(i==a.len)return r\n  ;r=getDupeEntryS(r,a,i,a.len-i)\n ;}return r;}\n//return if [a] is a [costas array] of order [a.len]\nivec3 isCostas(arr a\n){for(int i=1;i<=a.len;i++\n ){ivec2 dupes=getDupeEntry(strideDiff(a,i))\n  ;if(dupes.x!=-1)return ivec3(dupes,i);//return 2 indexes of found duplicate differential and dx\n  ;}\n ;return ivec3(-1,-1,-1);}//case of no dupes AND all in bounds == is costas Array\n\n/**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}