{
    "Shader": {
        "info": {
            "date": "1664267050",
            "description": "This shader is about cubes and spheres",
            "flags": 0,
            "hasliked": 0,
            "id": "ftVfRm",
            "likes": 1,
            "name": "Cubes and spheres-bipyramids",
            "published": 3,
            "tags": [
                "raymarching",
                "cubes"
            ],
            "usePreview": 0,
            "username": "Visiware",
            "viewed": 220
        },
        "renderpass": [
            {
                "code": "// License: MIT\n// This shader is ported here for a video: https://www.youtube.com/watch?v=PBI_yvz25aI\n// At first this shader was written and runned on my local machine, so there may be rough\n\n#define PI 3.1415926535897932384626433832795\n#define PI2 (PI*2)\n\n#define CirclePart(angle) (angle*PI2)\n\n#define FOV 1.309\n\nfloat intersectSDF(float distA,float distB) {\n\treturn max(distA,distB);\n}\n\nfloat unionSDF(float distA,float distB) {\n\treturn min(distA,distB);\n}\n\nfloat differenceSDF(float distA,float distB) {\n\treturn max(distA,-distB);\n}\n\n\n\nmat4 TransMatrix(float x,float y,float z) {\n\tmat4 m = mat4(1);\n\t\n\tm[3][0] = x;\n\tm[3][1] = y;\n\tm[3][2] = z;\n\t\n\treturn m;\n}\n\nmat4 RotMatrixY(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][2] = -sin(angle);\n\tm[2][0] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\nmat4 RotMatrixX(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][1] = sin(angle);\n\tm[1][0] = -sin(angle);\n\tm[1][1] = cos(angle);\n\t\n\treturn m;\n}\n\n\n\n\nfloat GeoSphereSDF(vec3 o,float r) {\n\tvec3 onorm = normalize(o);\n\t\n\tfloat value = -max(abs(onorm.x),abs(onorm.z));\n\tif (value < -0.25) {\n\t\tvalue = -0.25;\n\t}\n\t\n\treturn length(o) - (r + 1.2*value);\n}\n\nfloat CubeSDF(vec3 o,float size) {\n\tvec3 d = abs(o) - vec3(size/2.,size/2.,size/2.);\n\t\n\tfloat distin = min(max(d.x, max(d.y, d.z)), 0.0);\n\tfloat distout = length(max(d, 0.0));\n\t\n\treturn distin + distout;\n}\n\n\n\nfloat MultiSphereCubeSDF(vec3 o,float r,float size,float l) {\n\tfloat ly = l*2.;\n\t\n\tfloat mx = mod(o.x,l);\n\tfloat my = mod(o.y,ly);\n\tfloat mz = mod(o.z,l);\n\t\n\tbool xodd = (mod(o.x,l*2.0) > 0. && mod(o.x,l*2.0) < l);\n\tbool zodd = (mod(o.z,l*2.0) > 0. && mod(o.z,l*2.0) > l);\n\t\n\to.x = mx - l/2.;\n\to.y = my - ly/2.;\n\to.z = mz - l/2.;\n\t\n\tbool which = (xodd && !zodd) || (!xodd && zodd);\n\t\n\treturn GeoSphereSDF(o,r)*float(which) + CubeSDF(o,size)*float(!which);\n}\n\n\n\nfloat SceneSDF(vec3 ori) {\n\tfloat d = MultiSphereCubeSDF(ori,0.8,1.5,5.0);\n\treturn d;\n}\n\n#define NORM_EPSILON 0.0001\n\nvec3 SceneNormal(vec3 ori) {\n\treturn normalize(vec3(SceneSDF(vec3(ori.x + NORM_EPSILON,ori.y,ori.z)) - SceneSDF(vec3(ori.x - NORM_EPSILON,ori.y,ori.z)),\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y + NORM_EPSILON,ori.z)) - SceneSDF(vec3(ori.x,ori.y - NORM_EPSILON,ori.z)),\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y,ori.z + NORM_EPSILON)) - SceneSDF(vec3(ori.x,ori.y,ori.z - NORM_EPSILON))));\n}\n\n\n\n\n#define ITERMAX 500\n\n#define DISTMAX 1500.0\n\n#define EPSILON 0.005\n\nstruct CastRet_t {\n    bool casted;\n    vec3 normal;\n};\n\nCastRet_t TraceObjects(vec3 pos,vec3 dir,float outmax) {\n\tCastRet_t maincast;\n\t\n\tmaincast.normal = vec3(0.0,0.0,0.0);\n\tmaincast.casted = false;\n\t\n\tvec3 ori = pos;\n\tfloat l = 0.;\n\t\n\tfor (int i = 0; i < ITERMAX; i++) {\n\t\tfloat d = SceneSDF(ori);\n\t\t\n\t\t\n\t\tif (l > outmax) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tl += d;\n\t\t\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\tvec3 epspos = ori - dir*EPSILON;\n\t\t\t\n\t\t\tmaincast.casted = true;\n\t\t\tmaincast.normal = SceneNormal(epspos);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (d > DISTMAX) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tori += dir*d;\n\t}\n\t\n\treturn maincast;\n}\n\n\n\n#define MINCOLOR 0.04\n\nvec3 RaytraceObjects(vec3 pos,vec3 dir) {\n\tvec3 color = vec3(0.0,0.0,0.0);\n\t\n\tCastRet_t maincast = TraceObjects(pos,dir,DISTMAX);\n\t\n\tif (maincast.casted) {\n\t\tcolor = (maincast.normal + vec3(1.0,1.0,1.0))/2.0;\n\t}\n\t\n\t\n\treturn color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float x = fragCoord.x;\n\tfloat y = fragCoord.y;\n    \n    mat4 camera = RotMatrixX(PI/2. + iMouse.x/iResolution.x)*TransMatrix(0.0,0.0,0.0 - iTime*10.0);\n    \n    mat4 camera_notrans = camera;\n    camera_notrans[3][0] = 0.0;\n    camera_notrans[3][1] = 0.0;\n    camera_notrans[3][2] = 0.0;\n    \n\tvec3 pos = (camera*vec4(0.0,0.0,0.0,1.0)).xyz;\n\tvec3 dir = (camera_notrans*normalize(vec4((x - iResolution.x/2.0)/iResolution.x*tan(FOV/2.0)*iResolution.x/iResolution.y,(y - iResolution.y/2.0)/iResolution.y*tan(FOV/2.0),-1.0,1.0))).xyz;\n\t\n\tfragColor = vec4(RaytraceObjects(pos,dir),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}