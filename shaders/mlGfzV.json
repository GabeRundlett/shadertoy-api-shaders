{
    "Shader": {
        "info": {
            "date": "1702300496",
            "description": "A CSG polygon driven Poincare tiling with an animated pattern overlay.",
            "flags": 0,
            "hasliked": 0,
            "id": "mlGfzV",
            "likes": 140,
            "name": "Poincare Disc Animation",
            "published": 3,
            "tags": [
                "csg",
                "tile",
                "hyperbolic",
                "poincare"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2247
        },
        "renderpass": [
            {
                "code": "/*\n\n\tPoincare Disc Animation\n\t-----------------------\n    \n    A CSG polygon driven Poincare tiling with an animated pattern overlay.\n    \n\tThis simple animation has been sitting around in my account for way too\n    long. I made it at the same time as one of my other hyperbolic related \n    postings. There are not a great deal of animated Poincare disc examples\n    around, so I wanted to make one. Like so many things I put together, it \n    was coded up without putting a great deal of thought into it. On a \n    personal level, I don't like producing code that involves \"magic\" numbers \n    and guesswork. However, there's a little bit of that in here. I'd imagine \n    experts in this area will probably roll their eyes at the sheer hackory \n    involved. :)\n    \n    In fact, I'm secretly hoping someone will see this and post an example \n    that shows me a better way to do it... Whilst I'm putting in requests, \n    one of those colored interwoven ribbon demonstrations on a Poincare disc\n    would be nice. :) \n    \n    In regard to the pattern itself, that was fairly easy. Rendering lines,\n    points, etc., on a hyperbolic plane is similar to that on a Euclidean\n    plane. However, you're using a coordinate system akin to polar coordinates,\n    which is fine, unless it's been a while and you try to position things\n    with Euclidean coordinates. In fact, the code up to that point is pretty \n    reliable. However, I really hacked around to render the arcs between side\n    midpoints, and to render the repeat animation objects, so I was left \n    thinking that there'd have to be a more elegant way to do this.\n    \n    Anyway, the purpose of this was to post something artistic rather than a \n    treatise on hyperbolic geometry, for which there are already plenty of \n    interesting examples on here. The next step would be to post some cool \n    looking hyperbolic patterns using more realiable code. :)\n    \n\n\n\n    Poincare disc examples:\n\n    // The hyperbolic transformation itself is based on STB's example here,\n    // which I'm assuming was in turn based on a slide presentation by\n    // Vladimir Bulatov: http://www.bulatov.org/math/1001/index.html\n\t//\n    Hyperbolic Poincaré transformed - stb\n\thttps://www.shadertoy.com/view/3lscDf\n\n\n    // Another hyperbolic pattern example.\n    Hyperbolic Poincare Weave - Shane\n    https://www.shadertoy.com/view/tljyRR\n    \n\n*/\n\n\n// Because I was rushed, this particular pattern only works with two \n// arrangements, namely the \"3-8\" triangle setup and the \"4-6\" quad. \n// Next times, I'll try to get more to work.\n//\n// Polygon shape - 0: Triangle, 1: Quad.\n#define POLY 0\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's unsigned line distance formula.\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n\n// P represents the number of polygon vertices, and Q is the number of \n// adjacent polygons to each vertex within the Poincare disc.\n//\n// For tilings to work, the following must be true: (P − 2)*(Q − 2)>4.\n//\n// For instance, 3 and 7 will work, but 4 and 4 will not.\n//\n// 3-7, 3-8, 4-5, 5-4, 5-6, 6-4, 7-3, 8-3, 8-4, etc..\n//\n\n// Because I was rushed, this particular pattern only works with two \n// arrangements. Next time, I'll try to get more to work.\n#if POLY == 0\nconst int N = 3;\t// Polygon vertices.\nconst int Q = 8;\t// Polygons meeting at a vertex.\n#else\nconst int N = 4;\t// Polygon vertices.\nconst int Q = 6;\t// Polygons meeting at a vertex.\n#endif\n\n#define PI\t\t3.14159265\n#define TAU\t    6.28318531\n\n\n// Calculating the initial circular domain according to number of polygon\n// sides (N) and the number of adjacent polygons (Q): STB was clever enough to  \n// use repeat polar space to position the rest. Anyway, the idea is to use the\n// polygon geometry to set up the required geometrical diagram (see the line \n// below), then use a mixture of standard Euclidean and hyperbolic geometry (if\n// needed) to calculate the required values, which are described below.\n// \nvec3 initDomain(){\n    \n\t// There are quite a few ways to calculate the initial circular domain \n    // values, simply because there are several solutions to the same geometric \n    // problems, which is all this is. In fact, as geometric situations go,\n    // this is not a particularly difficult one to solve.\n\n    // The following is some highschool level circle and triangle geometry to \n    // get the values we're after.\n    //\n    // The Hyperbolic Chamber - Jos Leys\n    // http://www.josleys.com/article_show.php?id=83\n    //\n    // I also find the imagery on the following page helpful as well:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n   \n    // I can't for the life of me remember how I calculated these, but they're\n    // based on the diagrams you'll find in the links above. At the time, I was\n    // looking for the most concise solution I could, and forgot to write down what\n    // \"d2\" and \"r2\" represented on the diagrams... Either way, it was something \n    // simple. I'll locate the original code at some stage and expand on it.\n    //\n    float a = sin(PI/float(N)), b = cos(PI/float(Q)); // Polygon angle lengths.\n\tfloat d2 = cos(PI/float(N) + PI/float(Q))/a;\n\tfloat r2 = 1./(b*b/a/a - 1.); // Adjacent polygon radius (squared).\n\t\n    // Distance between adjacent polygon centers, the adjacent polygon radius,\n    // and the current polygon radius. We're assuming no negatives, but I'm \n    // capping things above zero, just in case.\n\treturn sqrt(max(vec3(1. + r2, r2, d2*d2*r2), 0.));  \n\n}\n\n\n\n// Count variable, which is seful for all kinds of things. It's a measure\n// of how many iterations were required to get to the current polygon.\n// The center polygon would have a count of one, and should increase as we \n// radiate outwards.\nfloat count;\n// Relates to the side number.\nfloat gIA; \n\n\n \n\n// Hyperbolically reflecting the polygon across each of it's edges\n// via an inverse Mobius transform.\nvec3 transform(vec2 p, vec3 domInfo){\n    \n    // Side number.\n    gIA = 0.;\n \n    \n    \n    \n    // Polygon value, set to the maximum. The surrounding circcles will\n    // be used to carve out the final value.\n    float gPoly = 1e5;\n   \n    \n    // Performing multiple reflective inversions to fill out the disk. Due \n    // to the nature of the hyperbolic transform, the polygon tiles get \n    // smaller as you approach the outer disk, and never reach the edge. \n    // There are a bunch of proofs in complex analysis that illustrate\n    // this, but nothing shows it as well as a computer program. :)\n    // Drop the number of iterations and you'll see the process unfold.\n    for(int i=0; i<24; i++){\n       \n        \n        // The following is a standard polar repeat operation. It works\n        // the same in hyperbolic space as it does in Euclidian space.\n        // If you didn't do this, you'd reflect across just the one\n        // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n        float na = floor(mod(atan(p.x, p.y), 6.2831589)/TAU*float(N));\n        float ia = (na + .5)/float(N);\n        vec2 vert = rot2(ia*TAU)*vec2(0, domInfo.x);\n\n        float rSq = domInfo.y*domInfo.y;\n\n       \n        // Circle inversion, which relates back to an inverse Mobius\n        // transformation. There are a lot of topics on just this alone, but \n        // the bottom line is, if you perform this operation on a point within\n        // the Poincare disk, it will be reflected. It's similar to the\n        // \"p /= dot(p, p)\" move that some may have used before.\n        vec2 pc = p - vert;\n        float lSq = dot(pc, pc);\n        \n        \n     \n\n        // If the distance (we're squaring for speed) from the current point to\n        // any vertex point is within the circle limits, hyperbolically reflect it.\n        if(lSq<rSq){\n\n            p = pc*rSq/lSq + vert;\n    \n            // Maintaining chirality. There are times when you need this.\n            p.x = -p.x;\n            \n            // If we have a hit, increase the counter. This value can be useful\n            // for coloring, and other things.\n            count++; \n\n        }\n        else {\n\n            // We're not inside, so render the last CSG polygon we have on record.\n            //\n            // I've lazily set it to a global, but there'd be cleaner ways to work \n            // the calculations in. Technically, you could wrap this in an else\n            // statement, but I think it's cleaner out here.\n            float poly = (length(p) - domInfo.z);\n            poly = max(poly, -(length(pc) - domInfo.y));\n            gPoly = min(gPoly, poly);\n            \n            // Side number.\n            gIA = na; \n            \n     \n            // We're outside of the domain, so break from the loop.\n            break;\n        }\n\n        \n    }\n    \n    // Local coordinates and polygon distance.\n    return vec3(p, gPoly);\n}\n\n\n// Mouse pointer inversion.\nvec2 mouseInversion(vec2 p){\n    \n    // Mouse coordinates.\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    // Hack for the zero case instance. If someone has a better way,\n    // feel free to let me know.\n    if(length(m) < 1e-3) m += 1e-3; \n    // A hack to stop some craziness occurring on the border.\n    //if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n    \n    // Taking the mouse point and inverting it into the circle domain.\n    // Feel free to check some figures, but all will get mapped to \n    // values that lie within circle radius.\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m; \n    float t = (k - 1.)/dot(p - invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x; // Keep chirality. MLA does this. \n    \n    return p;\n    \n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    // Aspect correct coordinates: Actually, \"fragCoord\" is already in \n    // aspect correct form, so shifting and scaling is all that is\n    // required in this particular pixelshader environment.\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n  \n    \n    /*\n    // Moving to the half plane model.\n    const float sc = 2.;\n    uv.y += sc/2. + 1.;\n    uv /= dot(uv, uv)/sc;\n    uv.y -= 1.; \n    */\n    \n    // Contracting things just a touch to fit the Poincare domain on \n    // the canvas.\n    uv *= 1.1;\n     \n     \n    // Hyperbolic the hyperbolic... I made that up, but it spherizes things \n    // a bit, which looks interesting.\n    //uv *= (.65 + dot(uv, uv)*.35);\n     \n    \n    // Poincare coordinates.\n    vec2 p = uv;\n    \n    \n    // Canvas rotation for a bit of variance.\n    p *= rot2(-iTime/8.);\n  \n\n\n    // A bit of mouse inversion and rotation to begin with. You'll\n    // see this a lot in various hyperbolic examples, and others.\n    p = mouseInversion(p);\n    \n    \n    vec2 oP = p;\n    \n    // Inversion count. It's used for all kinds of things, like \n    // random number production, etc.\n    count = 0.;\n  \n    \n    // Filling in the domain origin information: From left to right, it \n    // returns the distance between adjacent polygon centers, the adjacent \n    // polygon radius, and the current polygon radius. These values remain\n    // the same for all polygons throughout the hyperbolic plane, so this \n    // is all that's required to tile the disc.\n    //\n    // domInfo.x: Distance between adjacent polygon centers.\n    // domInfo.y: The adjacent polygon radius.\n    // domInfo.z: The current polygon radius.\n    vec3 domInfo = initDomain(); \n    \n    \n   \n    \n    // Handling the imagery outside the Poincare circle domain by inverting or\n    // mirroring it back into the circle so that it shows up.\n    //\n    // By the way, if you want to get more of an intuitive feel for circle \n    // inversion, I recommend Numberphile's \"Epic Circles\" video, here:\n    // https://www.youtube.com/watch?v=sG_6nlMZ8f4\n    if(length(p)> 1.) p /= dot(p, p); \n  \n\n    \n        \n\n    // Get local transformed polygon coordinates (p3.xy) and the polygonal \n    // distance field itself (p3.z).\n    vec3 pp3 = transform(p, domInfo);\n    \n    // Local coordinates and polygon distance field value.\n    p = pp3.xy;\n    float gPoly = pp3.z;\n    \n    // Flipping from reflection to reflection. Just as in Euclidean geometry,\n    // animated objects sometimes need their directions flipped from \n    // polygon to polygon.\n    float flip = mod(count, 2.)*2. - 1.; // Values: -1 and 1.\n    \n \n    // Setting a ring distance field, then using that to add more to the \n    // smoothing factor to alleviate aliasing around the borders. It's \n    // hacky, and no substitute for super sampling, but it works well \n    // enough here.\n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf*ssf;//(count*count + 1.);//fwidth(shape);// \n\n \n    \n    // Setting the color, according to the hyperbolic reflection count.\n    // IQ's versatile palette routine. It's one of my favorites.\n    vec3 oCol = .5 + .45*cos(TAU*count/12. + vec3(1, 0, 2));\n \n \n    \n    // The background color. It looks interesting enough like this, but the lines\n    // give it additional depth.\n    vec3 col = vec3(0.);\n    \n     \n    // For some reason, this setup gives nicer width edging, whereas the\n    // normal way I go about it does not... I'll look into it later. :)\n    col = mix(col, oCol, 1. - smoothstep(0., sf, gPoly + .01));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gPoly) - .005));\n\n    \n    \n    // Polygon side debug.\n    //if(gIA==0.) col *= vec3(8, 2, 1);\n    //if(gIA==1.) col *= vec3(4, 1, 12);\n   \n    // Vertices and edges.\n    vec2[N] v, e;\n    \n    // The first vextex position.\n    vec2 r = vec2(0, domInfo.x - domInfo.y);\n    \n    // Vertices and edges.\n    float vert = 1e5, mid = 1e5;\n     \n    for(int i = 0; i<N; i++){\n       // Mulitples of v0.\n       v[i] = rot2(TAU/float(N)*float(i))*vec2(0, domInfo.z);\n       // Midpoint edges are rotated between successive vertices. \n       e[i] = rot2(TAU/float(N)*(float(i) + .5))*r;\n       \n       // Vertex and midpoint distances.\n       vert = min(vert, length(p - v[i]));\n       mid = min(mid, length(p - e[i])); // Not used, but they're here anyway.\n    }\n    \n     \n \n    // Saving the background color. \n    vec3 svOCol = oCol;\n    \n    \n    // Rendering the polygon vertex points.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert - .04));\n    \n    \n    float lw = .06; // Line width.\n    float cw = .07*3./float(N); // Moving rectangle width.\n     \n    // Going one extra to render the half of the first strip again.\n    for(int i = 0; i<=N; i++){\n    \n       \n        // On the last iteration we want to render half the \n        // first strip over the top to make the overlapping pattern.\n        if(i==N && (p.y + lw/2.*0.<0.)) break;\n\n    \n        // domInfo.x: Distance between adjacent polygon centers.\n        // domInfo.y: The adjacent polygon radius.\n        // domInfo.z: The current polygon radius.\n        // A magic radius related number for the \"3-8\" and \"4-6\" combinations.\n        // 3-8: .212 // 4-6: .405\n        float magic = N == 3? .212 : .405;\n        // Vertex center of the adjoining circle that creates the arc for this\n        // particular polygon side -- It's at an angle midway between the vertex\n        // points flanking the side and at a constant distance that was hacked in\n        // by trial and error. Obviously, it'd be better to calculate it properly.\n        vec2 vv = rot2(fract((float(i + 1))/float(N))*TAU)*vec2(0, domInfo.x + domInfo.z*magic);\n        \n        // The arc line itself.\n        float df = length(p - vv) - (domInfo.x);\n        df = abs(df) - lw;\n\n\n\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., df))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, df));\n        col = mix(col, vec3(.07), 1. - smoothstep(0., sf, df + .015));\n  \n \n        // Controls the number of animated squares.\n        // 3 and up will work, but the width \"cw\", will need adjusting.\n        float m = 3.; \n       \n        // Animated objects: More magic numbers. I'm not even sure what\n        // I was thinking to arrive at this... Sigh! :)\n        float aNum = (float(N) - .5)*float(Q)*m  + float(Q*2) + 1.;  \n        if(N == 4) aNum = float(N*Q)*m;\n        // Animation: Reversing each time a polygon is hyperbolically\n        // reflected across the side boundary. On a Euclidean plane, you'll\n        // do something similar.\n        float t2 = iTime;\n        if(flip<0.){ t2 = -t2; }\n     \n        // The center of the neighboring circle contributing to this \n        // polygon side arc.\n        vec2 cntr = p - vv;\n\n        // Reverse the direction on the outside of the disc.\n        float dir = (length(uv) > 1.)? -1. : 1.;\n        cntr *= rot2((fract(dir*t2/aNum))*TAU);\n\n        // Animated polar object stuff: Rotate the angle, then move\n        // along the radius to the appropriate distance.\n        float na = floor(atan(cntr.x, cntr.y)/6.2831*aNum);\n        float ia = (na + .5)/aNum;\n        cntr *= rot2(ia*6.2831);\n        cntr.y -= domInfo.x;\n\n        // The animated object (just a rectangle) and rendering.\n        float df3 = max(abs(cntr.x), abs(cntr.y)) - cw;\n        df3 = max(df3, df + .03);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, df3));\n        col = mix(col, svOCol*1.3 + .1, 1. - smoothstep(0., sf, df3 + .015)); \n      \n   \n    }\n    \n    \n    // Polygon edge debug.\n    //if(p.y + lw/2.*0.>0.) col *= .5;\n    \n    // Flipped polygon debug.\n    //if(flip<0.) col *= .5; // Area affected.\n    \n    \n    // At the last minute, I decided to render different colors on the\n    // outside of disc... I'm still not sure whether it worked or not. :D\n    col = mix(col, col.yxz, smoothstep(0., sf, length(uv) - 1.));\n    \n    // Outer ring.\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf*4., abs(length(uv) - 1.)));\n    float ring = abs(length(uv) - 1.) - .01;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*4., ring));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ring));\n    col = mix(col, vec3(.07), 1. - smoothstep(0., sf, ring + .01));\n\n \n    //vec3 gr = vec3(1)*dot(col, vec3(.299, .587, .114));\n    //col = mix(col, gr, smoothstep(0., sf, length(uv) - 1.));\n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    \n    // Rough gamma correction, then present to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}