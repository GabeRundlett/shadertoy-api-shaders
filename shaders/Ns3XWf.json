{
    "Shader": {
        "info": {
            "date": "1634144285",
            "description": "I'm really enjoying using ray intersection to remove repetition artifacts, it opens up so many possibilities. \n\nIt also looks cool if you reverse time",
            "flags": 0,
            "hasliked": 0,
            "id": "Ns3XWf",
            "likes": 263,
            "name": "Spiraled Layers",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf",
                "spiral",
                "roll",
                "rolling"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 10719
        },
        "renderpass": [
            {
                "code": "#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define STEPS 200\n#define MDIST 100.0\n\n//some neat animation\n//#define FUN_MODE\n\n//Reverse time\n//#define iTime -iTime\n\n//Change to 2.0 for AA\n#define AA 1.0\n\nvec3 rdg = vec3(0);\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\nfloat h11(float a) {\n    a+=0.65343;\n    return fract(fract(a*a*12.9898)*43758.5453123);\n}\nfloat diplane(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)/rd;\n    return rc.z+0.01;\n}\nfloat lim(float p, float s, float lima, float limb){\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat idlim(float p, float s, float lima, float limb){\n    return clamp(round(p/s),lima,limb);\n}\nfloat lim2(float p, float s,  float limb){\n    return p-s*min(round(p/s),limb);\n}\nfloat idlim2(float p, float s, float limb){\n    return min(round(p/s),limb);\n}\nfloat spiral(vec2 p, float t, float m, float scale, float size, float expand){\n    size-=expand-0.01;\n    //Offset Spiral To the left\n    t = max(t,0.);\n    \n    p.x+=pi*-t*(m+m*(-t-1.));\n    t-=0.25;\n    \n    vec2 po = p;\n    //Move Spiral Up\n    p.y+=-t*m-m*0.5;\n    \n    //Counter the rotation\n    p*=rot(t*pi*2.+pi/2.);\n    \n    //Polar Map\n    float theta = atan(p.y,p.x);\n    theta = clamp(theta,-pi,pi);\n    p = vec2(theta,length(p));\n    \n    //Create Spiral\n    p.y+=theta*scale*0.5;\n\n    //Duplicate Line outwards to fill spiral\n    float py = p.y;\n    float id = floor((p.y+m*0.5)/m);\n    p.y = lim(p.y,m,0.,floor(t));\n        \n    //Line SDF of the spiral\n    float a = abs(p.y)-size;\n    \n    //Calcuate moving outer spiral segment\n    p.y = py;\n    p.x -= pi;\n    p.y -= (floor(t)+1.5)*m-m*0.5;\n    float b = max(abs(p.y),abs(p.x)-(pi*2.)*fract(t)+size );\n    \n    //The unrolled Line SDF\n    a = min(a,b-size);\n    b = abs(po.y)-size;\n    b = max(po.x*30.,b);\n    \n    //Combine Them\n    a = min(a,b);\n\n    return a;\n}\nvec3 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(1);\n    float c = 0.;\n    float t = iTime; \n\n    float size = 0.062; //Thickness of spiral curls\n    float scale = size-0.01; //Space between spiral curls\n    \n    float expand = 0.04; //Corner Rounding Amount \n\n    float m2 = size*6.0; //Repetition Sizes\n    float m = pi*scale; //Repetition Sizes\n    \n    float ltime = 10.0; //How often the spirals rolls repeat\n    \n    p.y-=(t/ltime)*size*6.; //Move everything upwards so it stays in frame\n    \n    p.x-=3.;  //small offset for framing\n    \n    float width = 0.5; //Lane Width\n    float count = 6.0; //Number of spirals (x2)\n    \n    float modwidth = width*2.0+0.04+0.06;\n    \n    float id3 = idlim(p.z,modwidth,-count,count);\n    t+=h11(id3*0.76)*8.0; //it took like 15 minutes to find this seed\n    p.z = lim(p.z,modwidth,-count,count);\n    \n    #ifdef FUN_MODE\n        scale+=(sin(t)*0.5+0.5)*0.05;\n        m = pi*scale;\n    #endif\n    \n    float to = t;\n    vec3 po = p;\n\n    //Spiral 1\n    float stack = -floor(t/ltime);\n    float id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    a.x = spiral(p.xy,t,m,scale,size,expand);\n    c = a.x;\n    \n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 2\n    p = po;\n    t = to;\n    p.y+=size*2.0;\n    t-=ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    \n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 3\n    p = po;\n    t = to;\n    p.y+=size*4.0;\n    t-=2.*ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);    \n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    \n    a.x = min(a.x,max(p.y+size*5.,p.x)); //Artifact Removal\n    \n    a.x = ext(po.yzx,a.x,width-expand*0.5+0.02)-expand;\n    //SDF without intersection boundries for AO\n    c = ext(po.yzx,c,width-expand*0.5+0.02)-expand; \n    \n    //Intersection distance to plane between each lane\n    b.x = diplane(po ,vec3(modwidth)*0.5, rdg); //Artifact Removal\n    b.y = 0.;\n\n    a=(a.x<b.x)?a:b; //Artifact Removal\n    \n    return vec3(a,c);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid render( out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(5,1.8,-12)*1.2;\n    ro.zx*=rot(0.09);\n    \n    //Mouse control\n    if(iMouse.z>0.5){\n    ro.yz*=rot(0.5*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-0.5*(iMouse.x/iResolution.x-0.5));\n    }\n    //Camera Setup\n    vec3 lk = vec3(-2.5,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*2.0+uv.x*r+uv.y*cross(f,r));  \n    rdg = rd;\n\n    vec3 p = ro;\n    vec3 d;\n    float dO = 0.;\n    bool hit = false;\n    \n    //Raymarcher\n    for(int i = 0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(d.x<0.001||i==STEPS-1){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    //Color Surface\n    if(hit&&d.y!=0.){\n        vec3 ld = normalize(vec3(0.5,0.4,0.9));\n        vec3 n = norm(p);\n        rdg = ld;\n        float shadow = 1.;\n        float h = 0.09;\n        for(int i = 0; i < 64; i++){\n            vec3 dd = map(p+ld*h+n*0.005);\n            if(dd.x<0.001&&dd.y==0.0){break;}\n            if(dd.x<0.001){shadow = 0.0; break;}\n            shadow = min(shadow,dd.z*30.0);\n            if(h>7.0) {break;}\n            h+=dd.x;\n        }\n        shadow = max(shadow,0.8);\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.05,n,p)*AO(.1,n,p);\n        ao = max(ao,0.1);\n        n.xz*=rot(4.*pi/3.);\n        col = n*0.5+0.5;\n        col = col*shadow;\n        col*=ao;\n    }\n    //Color Background\n    else{\n        col = mix(vec3(0.355,0.129,0.894),vec3(0.278,0.953,1.000),clamp((rd.y+0.05)*2.0,-0.15,1.5));\n    }\n    //Gamma Approximation\n    col = sqrt(col);\n    fragColor = vec4(col,0.0);  \n}\n\n//External AA (check render function for usual code)\n#define ZERO min(0.0,abs(iTime))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float px = 1.0/AA; vec4 col = vec4(0);\n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}