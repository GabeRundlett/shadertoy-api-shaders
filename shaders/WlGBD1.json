{
    "Shader": {
        "info": {
            "date": "1614226391",
            "description": "Inspired by reinder's Venice shader: https://www.shadertoy.com/view/MdXGW2\nAnd Kendall Miles' amazing track: Lost in florence.\nlook in common tab for settings.\ntry clicking",
            "flags": 96,
            "hasliked": 0,
            "id": "WlGBD1",
            "likes": 38,
            "name": "Arno river â™«",
            "published": 3,
            "tags": [
                "reflection",
                "music",
                "blur",
                "light",
                "dof",
                "audio",
                "bloom",
                "city",
                "river",
                "bridge",
                "buildings"
            ],
            "usePreview": 0,
            "username": "TheNosiriN",
            "viewed": 1150
        },
        "renderpass": [
            {
                "code": "//Made by: TheNosiriN\n//Move the camera with the mouse\n//Look in \"Common\" tab for define settings\n//When it compiles restart the timer so the song starts with the shader\n\n//dont mind the horrible buildings in the distance ._.\n\n\n\nvec3 bloomQuery(vec2 coord){\n    vec4 col = texture(iChannel0, coord);\n    if (col.a == EPSILON){ return col.rgb; }\n    return vec3(0);\n}\n\nvec3 bloom(vec2 uv, vec4 inColor)\n{\n\tfloat numSamples = 1.0;\n    vec3 color = inColor.rgb;\n\n\tfor (float x=-2.0; x<=2.0; x++){\n\t\tfor (float y=-2.0; y<=2.0; y++)\n\t\t{\n\t\t\tvec2 uv2 = uv + (vec2(x, y) * (1./iResolution.xy));\n            color += bloomQuery(uv2);\n            numSamples++;\n\t\t}\n\t}\n    \n\treturn saturate(color / numSamples + inColor.rgb);\n}\n\n\n\n\nfloat Gaussian (float x, float sigma){\n    return exp(-(x*x) / (2.0 * sigma*sigma));\n}\n\nvec3 blur(in vec2 uv, float size, float sigma, bool query)\n{\n    float total = 0.0;\n    vec3 ret = vec3(0);\n    \n    for (float iy=0.0; iy<size; iy++)\n    {\n        float fy = Gaussian(iy-size/2.0, sigma);\n        float ofy = (iy-size/2.0) * (1./iResolution.y);\n        \n        for (float ix=0.0; ix<size; ix++)\n        {\n            float fx = Gaussian(ix-size/2.0, sigma);\n            float ofx = (ix-size/2.0) * (1./iResolution.x);\n            \n            float f = fx*fy;\n            total += f;\n            if (query){\n                ret += bloomQuery(uv + vec2(ofx, ofy)).rgb * f;\n            }else{\n                ret += texture(iChannel0, uv + vec2(ofx, ofy)).rgb * f;\n            }\n        }\n    }\n    return ret / total;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    \n    \n    vec4 tex = texture(iChannel0, uv);\n    \n    #ifdef POSTPROCESS\n    if (tex.a != 0.0){\n        #ifdef SOFTER\n            float dist = saturate(pow(abs((tex.a*2.0-1.0)+0.7), 0.8));\n            color = mix(bloom(uv,tex), blur(uv,16.0,40.0,false), dist);\n        #else\n            color = mix(bloom(uv,tex), blur(uv,16.0,40.0,false), saturate(tex.a*2.0-0.3));\n        #endif\n    }else{\n        color.rgb = tex.rgb;\n    }\n    #else\n    color = tex.rgb;\n    #endif\n    \n    color *= 0.2 + 0.9*pow(32.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.2);\n    color *= min(1.0, iTime/7.0); //fade in\n    //color *= saturate((92.0-iTime)/7.0); //fade out in 92 sec\n    \n\tfragColor = vec4(vec3(color), tex.a);\n  \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 25547,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/darius-bailey-667130523/kendall-miles-x-i-eat-plants-for-a-living-lost-in-florence"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec4 building(vec3 p, vec2 wh, vec2 roof, float scale)\n{\n    p.y -= wh.y;\n    p /= scale;\n    \n    vec3 ap = abs(p);\n    vec3 q = ap - vec3(wh, wh.x);\n    vec2 d = vec2(mv3(q), 0);\n    \n    p.xz = abs(p.xz);\n    \n    //roof\n    float rf = MAX_DIST; roof.y /= wh.x;\n    vec3 rp = p-vec3(0,wh.y+roof.y,0); rp.xz *= roof.y;\n    if (roof.x == 0.0){\n        rf = max(max(mv2(p.xz)-wh.x, mv2(rp.xz)+rp.y), -rp.y-roof.y)-wh.x/5.0;\n    }else if(roof.x == 1.0){\n        float rfn = abs(rp.x)+rp.y; rf = max(-rfn, rfn-wh.x/5.0);\n        rf = max(rf, mv2(p.xz)-wh.x*1.25);\n        rf = min(rf, max(rfn, mv2(p.xz)-wh.x));\n    }\n    d.x = min(rf, d.x);\n    \n    //windows\n    vec2 wp = p.xy;\n    float wl = 0.2, ww = 0.15;\n    float v = pModInterval1(wp.x, ww*4.0, -floor(wh.x), floor(wh.x))+floor(wh.x);\n    float c = pModInterval1(wp.y, 1.0, -floor(wh.y)+1., floor(wh.y)-1.)+floor(wh.y);\n    float wd = min(length(wp.xy)-ww, max(abs(wp.x)-ww, abs(wp.y+wl)-wl));\n    //wd = max(wd, abs(p.z-wh.x)-0.1);\n    \n    d = maxd(d, vec2(-wd, 2));\n    \n    return vec4(d, v, c);\n}\n\n\nvec3 scene(vec3 p, float depth, float maxdist){\n    vec3 d = vec3(0);\n    p.xz *= rotate(remap(p.z, 0.0, 100.0, 0.0, 45.0));\n    setpz(p);\n    //p.x = abs(p.x);//-10.0;\n    \n    \n    //river side\n    d.x = max(p.y-1.0, -abs(p.x)+15.);\n    d.x = min(d.x, max(abs(p.y-0.8)-0.2, -abs(p.x)+14.5));\n    vec3 rp = p;\n    \n    \n    //buildings\n    p.x += 20.0; p.y-=0.5;\n    vec3 brp = p;\n    vec2 bdim = vec2(1), rdim = vec2(1);\n    vec2 c = vec2(-pModInterval1(p.x, 4.0, -20.0, 0.0), 0);\n    c.y = pMod1(p.z, c.x+3.5);\n    \n    vec4 rand = iHash(c);\n    \n    rdim.y = rand.w*1.5;\n    rdim.x = round(rand.z);\n    bdim.x = remap(round(rand.x),0.,1.,1.,1.5);\n    bdim.y = remap(round(rand.y),0.,1.,1.,2.+c.x*0.3);\n    \n    vec4 bu = building(p.zyx, bdim, rdim, 1.0);\n    vec2 b = bu.xy;\n    if (b.y == 2.0){\n        b.y = iHash(bu.zw+bu.wz+c).x > 0.2 ? 2. : 0.;\n    }\n    \n    /* cant get it working\n    vec2 neighbor = c+face(p).xy*vec2(4.0, c.x+3.2);\n    float ne = length(p+vec3(neighbor.x,0,neighbor.y))-bdim.x;\n    b.x = min(b.x, ne);\n    */\n    \n    //the buildings have a very horrible stepping problem\n    //this doesnt remove everything but its not as noticeable\n    b.x *= remap(depth,0.0,maxdist,0.5,0.1);\n    //\n    d = mind(d, vec3(b.x,b.y, 0));\n    \n    \n    //riverside cont.\n    vec3 rvs = vec3(length(p.yz+vec2(1.5,0))-1.5, 0,0);\n    d = maxd(d, -rvs);\n    \n    //bridge\n    vec3 bp = rp; float space = 80.0;\n    float cf = pMod1(bp.z, space);\n    float shape = abs(bp.z)-space/2.+2.0;\n    rvs.x = max(length(bp.xy*vec2(0.2,1))-2.8, -shape);\n    rvs.x = min(rvs.x, max(max(rvs.x-0.25, -shape), shape-0.5));\n    cf = abs(pMod1(rp.x, 3.0));\n    \n    float bh = 1.2-(cf*0.4); float bw = 1.1;\n    float edge = min(length(rp.xy-vec2(0,bh))-bw, max(abs(rp.x)-bw,rp.y-bh));\n    rvs.x = min(rvs.x, max(edge-0.25, -abs(bp.z)+space/2.-2.2));\n    rvs = maxd(rvs, vec3(-edge,3,0));\n    \n    //doing mod again for the bridge inside thingys\n    //bp = rp;\n    cf = pMod1(bp.z, 1.25);\n    \n    #ifdef YELLOW_BRIDGE\n    rvs = maxd(rvs, vec3(-max(edge-0.25, abs(bp.z)-0.2),2,0));\n    #else\n    rvs = maxd(rvs, vec3(-max(edge-0.25, abs(bp.z)-0.2),3,0));\n    #endif\n    \n    \n    d = mind(d, rvs);\n    \n    \n    //water\n    return mind(d, vec3(p.y+1.,1,0));\n}\n\n\n\nvec4 raymarch(vec3 eye, vec3 dir, float maxdist)\n{\n    vec3 info = vec3(0);\n    float depth = 0.0, i;\n    for (i=0.0; i<256.0 && depth<maxdist; i++){\n        vec3 p = eye + depth * dir;\n        info = scene(p, depth, maxdist);\n        if (abs(info.x) < EPSILON * depth)break;\n        depth += info.x;\n    }\n    return vec4(min(depth,maxdist), info.yz, i/256.0);\n}\n\n\n\nvec3 normal(vec3 p, float depth, float maxdist)\n{\n \tvec3 P = vec3(-4, 4, 0) * 0.001;\n \treturn normalize(\n        scene(p+P.xyy, depth, maxdist).x * \n        P.xyy + scene(p+P.yxy, depth, maxdist).x * \n        P.yxy + scene(p+P.yyx, depth, maxdist).x * \n        P.yyx + scene(p+P.xxx, depth, maxdist).x * \n        P.xxx\n    );\n}\n\n\n\n\n\n\nvec4 makePixel(vec3 eye, vec3 dir, vec4 dist, vec3 P, vec3 N, int bounce)\n{\n    vec4 color;\n    \n    setpz(P);\n    if (dist.y == 3.0){ N = triplanarNormal(iChannel1, P, N, 1.0, 2.0, 1.0); }\n    \n    float shading = saturate(dot(N, light)*0.5+0.25);\n    shading = mix(min(1.0,shading*3.0), shading, dot(normalize(eye), N));\n\n    color.x = (shading+0.1)+(dist.x/MAX_DIST)*0.1;\n    \n    if (bounce == 0){\n        color.y = 1.0-saturate(pow(dist.w,1.)*4.0);\n    }else{\n        color.y = saturate(pow(dist.w,3.0)*3.0);\n    }\n    //color.y = saturate(pow(dist.w,1.)*4.0);\n    \n    if (dist.y == 2.0){ color.xyz = vec3(0,0,1); }\n    color.a = saturate(dist.x/MAX_DIST);\n    \n    return color;\n}\n\n\n\nfloat getBackground(vec3 dir){\n    //dir.y -= light.y;\n    float sun = smoothstep(0.005, -0.005, length(dir.xy-vec2(0.3,0.09))-0.05);\n    \n    return sun*0.4;\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 P )\n{\n    vec2 uv = P/iResolution.xy;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ O = vec4(0.0); return; }\n    #endif\n    uv = (P-iResolution.xy*0.5)/iResolution.y;\n    \n    float fv = 2.0;\n    vec3 eye = vec3(0,1.8,-10);\n    vec3 lookAt = vec3(0, 2.5, 10.0);\n    \n    if (iMouse.z>0.0){\n        fv = 2.5;\n        eye = vec3(-20.0,7.0,-30);\n        lookAt = vec3(-10.0, 5.0, 10.0);\n    }\n    \n    \n    vec3 f = normalize(lookAt - eye);\n    vec3 s = normalize(cross(f, vec3(0,1,0)));\n    mat4 view = mat4(vec4(s, 0.0), vec4(cross(s, f), 0.0), vec4(-f, 0.0), vec4(0,0,0,1));\n    vec3 dir = vec3(view * vec4(normalize(vec3(uv, -fv)), 0.0));\n    \n    dir.xy *= rotate(sin(TIME));\n    dir.yz *= rotate(sin(TIME*0.5));\n    dir.xz *= rotate(sin(TIME*0.25));\n    \n    \n    vec4 color;\n    \n    vec4 dist = raymarch(eye, dir, MAX_DIST);\n    \n    if (dist.x < MAX_DIST)\n    {\n        vec3 P = eye + dir * dist.x;\n        vec3 N = normal(P, dist.x, MAX_DIST);\n        if (dist.y == 1.0){\n            eye = P;\n            float noise = pow(sin(dir.x*1000.0)*0.5+0.5,1.)*0.02*(dist.x/MAX_DIST);\n            \n            setpz(P);\n            N = triplanarNormal(iChannel0, P, N, 0.2, 0.2, 4.0);\n            N = normalize(N+noise);\n            \n            dir = normalize(reflect(dir, N));\n            dist = raymarch(eye, dir, MAX_DIST/2.0);\n            \n            if (dist.x < MAX_DIST/2.0){\n                P = eye + dir * dist.x;\n                N = normal(P, dist.x, MAX_DIST/2.0);\n                color = makePixel(eye, dir, dist, P, N, 1);\n            }else{\n                color.z = 0.5;\n                color.x = getBackground(dir);\n            }\n            color.x *= 0.5;\n        }else{\n            color = makePixel(eye, dir, dist, P, N, 0);\n        }\n    }else{\n        color.z = 0.5;\n        color.x = getBackground(dir);\n    }\n    \n\n    // Output to screen\n    O = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define MARGIN //for just a bit more fps\n#define YELLOW_BRIDGE //how does it look?\n#define SOFTER //I cant decide between soft and softer\n#define POSTPROCESS //comment this if you have a really bad pc\n//for color switching over the song, its not perfectly in synch but it looks nice\n#define SWITCH_COLORS\n//\n\n\nconst float marginSize = 0.08; //letterbox size\n\nconst vec3 light = normalize(vec3(1.0, 0.25, 1.0));\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\n\nconst float PI = 3.1415972;\nconst mat2 M2 = mat2(0.8,-0.6,0.6,0.8);\n\n\n\n#define TIME (iTime+40.0)\n#define mind(a, b) (a.x < b.x ? a:b)\n#define maxd(a, b) (a.x > b.x ? a:b)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define setpz(p) (p.z += TIME + (iMouse.z>0.0 ? iMouse.x/iResolution.x*80.0 : 0.0))\n//my attempt at synching audio\n#define SUNTIME saturate(sin((iTime-9.0)*0.75)*3.0)\n//\n\n\n\nfloat mv2(vec2 v){ return max(v.x, v.y); }\nfloat mv3(vec3 v){ return max(v.x, max(v.z, v.y)); }\n//float hash21(vec2 p){ return fract(sin(dot(p, p+5373.836))*9272.8363); }\n\n// simple 4 channel Hash by: James_Harnett, https://www.shadertoy.com/view/4dVBzz\nvec4 iHash(vec2 c){\n    uvec2 uc = uvec2(abs(c));\n    uint n = uint(uc.x*1597334677U^uc.y*3812015801U);\n    return vec4( (n*(n^(n>>15)))*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU) ) * 1.0/float(0xffffffffU);\n}\n\n\n\nmat2 rotate(float angle){\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nvec3 face(vec3 p){\n    vec3 ap = abs(p);\n    float mx = mv3(ap);\n    return step(0., ap-mx)*sign(p);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) {\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvec3 triplanarMap(sampler2D tex, vec3 p, vec3 n, float scale, float lod)\n{\n    p *= scale;\n    \n    return  (textureLod(tex,p.xy,lod).rgb*n.z*n.z\n            +textureLod(tex,p.zy,lod).rgb*n.x*n.x\n            +textureLod(tex,p.xz,lod).rgb*n.y*n.y);\n}\nvec3 triplanarNormal(sampler2D tex, vec3 p, vec3 N, float strength, float scale, float lod)\n{\n    vec3 P = vec3(-4, 4, 0) * 0.01;\n    \n    vec3 B;\n    B.x = triplanarMap(tex, p+P.xzz, N, scale, lod).r;\n    B.y = triplanarMap(tex, p+P.zxz, N, scale, lod).r;\n    B.z = triplanarMap(tex, p+P.zzx, N, scale, lod).r;\n    B -= triplanarMap(tex, p, N, scale, lod).r;\n    \n    B = (B-N*dot(B,N));\n    return normalize(N+B*strength);\n}\n\n\n\nfloat remap(float val, float OldMin, float OldMax, float NewMin, float NewMax){\n    return (((val - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nconst vec3 day1 = vec3(0.671,0.216,0.341);\nconst vec3 day2 = vec3(0.984,0.388,0.043);\nconst vec3 day3 = vec3(0.490,0.478,0.635);\n\nconst vec3 night1 = vec3(0.157,0.059,0.212);\nconst vec3 night2 = vec3(0.784,0.420,0.596);\nconst vec3 night3 = vec3(1.000,0.757,0.627);\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51; float b = 0.03;\n    float c = 2.43; float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec4 cheapAA(sampler2D tex, vec2 fragCoord, float blur)\n{\n\tvec4 pixelColor;\n\tpixelColor =  texture(tex, (fragCoord + vec2( 0.0, 0.0)) / iResolution.xy).rgba / 2.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur, blur)) / iResolution.xy).rgba / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur,-blur)) / iResolution.xy).rgba / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur,-blur)) / iResolution.xy).rgba / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur, blur)) / iResolution.xy).rgba / 8.0;\n\treturn pixelColor;\n}\n\nvoid mainImage( out vec4 O, in vec2 P )\n{\n    vec3 color;\n    vec2 uv = P/iResolution.xy;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ O = vec4(0.0); return; }\n    #endif\n    \n    vec3 col;\n    vec4 rtex = texture(iChannel0, uv);\n    \n    #ifdef SWITCH_COLORS\n    float suntime = SUNTIME;\n    vec3 sky1 = mix((day1+night1)/3.0, night1, suntime);\n    vec3 sky2 = mix(day2, night2, suntime);\n    vec3 sky3 = mix(day3, night3, suntime);\n    #else\n    vec3 sky1 = night1;\n    vec3 sky2 = night2;\n    vec3 sky3 = night3;\n    #endif\n    \n    if (rtex.z == 1.0){\n        color = vec3(1,1,0);\n        rtex.a = EPSILON;\n    }else{\n        vec4 tex = cheapAA(iChannel0, P, 0.5);\n        \n        vec3 sky = mix(sky2, sky1, abs(uv.y*2.0-1.0)+0.2);\n\n        if (rtex.z == 0.5){\n            color = mix(sky2+rtex.r, sky1, abs(uv.y*2.0-1.0)+0.2);//+tex.x;\n        }else{\n            color = mix(sky1, sky2, tex.a);\n            color = mix(color, mix(tex.r*sky3, sky, tex.a), tex.y);\n        }\n        \n        \n    }\n    \n    color = smoothstep(0.0,1.0,color);\n    color = ACESFilm(color);\n    O = vec4(color,rtex.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}