{
    "Shader": {
        "info": {
            "date": "1580533754",
            "description": "Diffuse illumination only for the moment",
            "flags": 0,
            "hasliked": 0,
            "id": "WstXDX",
            "likes": 1,
            "name": "Jake's Global Illumination",
            "published": 3,
            "tags": [
                "ray",
                "global",
                "illumination",
                "tracing"
            ],
            "usePreview": 0,
            "username": "JakeLockey",
            "viewed": 278
        },
        "renderpass": [
            {
                "code": "vec2 curCoord = vec2(0.0,0.0);\nbool eviLight = true;\nint bounceCount = 1;\nfloat AA = 4.0; //perfect squares only\n\nvec3 b2(vec3 P, vec3 refRay,vec3 N, vec3 col, float gTd, float sTr, float fres){\n    \n    vec3 diffCol = vec3(0.0,0.0,0.0);\n    \n    for(int i=0; i<int(RaySims); i++){\n        vec3 rayDir = genDiffRay(P,N,curCoord*iTime*(float(i)+1.0));\n        //vec3 rayDir = refRay;\n        vec3 Collision = checkCollide(P,rayDir);\n        if(Collision.x>0.0){\n            if(int(Collision.y)==0){ //Sphere\n                Sphere tempS = objects.spheres[int(Collision.z)];\n\n                if(bounceCount >= 3){\n                    vec3 newP = P + (rayDir*Collision.x);\n                \tvec3 newN = (tempS.pos-newP)/length(tempS.pos-newP);\n                \tnewP = newP + newN*(0.0001);\n                \tvec3 tempRef = reflect(rayDir,newN)/length(reflect(rayDir,newN));\n                    //diffCol+=b3(newP,tempRef,newN,tempS.col,tempS.gTd,tempS.sTr,tempS.fres);\n                }\n                else{\n                    //diffCol+=tempS.col;\n                }\n\n            }\n            if(int(Collision.y)==1){ //Triangle\n                Triangle tempT = objects.triangles[int(Collision.z)];\n\n                if(bounceCount >= 3){\n                \tvec3 newP = P + (rayDir*Collision.x);\n                \tvec3 newN = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n                \tnewN = newN/length(newN);\n                \tnewP = newP + newN*(0.00001);\n                \tvec3 tempRef = reflect(rayDir,newN)/length(reflect(rayDir,newN));\n                    //diffCol+=b3(newP,tempRef,newN,tempT.col,tempT.gTd,tempT.sTr,tempT.fres);\n                }\n                else{\n                \t//diffCol+=tempT.col;\n                }\n            }\n\n            if(int(Collision.y)==2){ //Light\n                Light tempL = objects.lights[int(Collision.z)];\n                diffCol+=tempL.col;\n                //return tempL.col;\n\n            }\n\n        }\n        else{\n            if(eviLight){\n\t\t\t\tdiffCol+=texture(iChannel0,vec3(rayDir.x,rayDir.z,rayDir.y)).xyz;\n            }\n        }\n    }\n    \n    vec3 shadowCol = vec3(0.0,0.0,0.0);\n    if(!checkShadow(P)){\n        shadowCol = col;\n    }\n    \n    //diffCol/=RaySims;\n    col*=diffCol;\n    col/=RaySims;\n    col = (col+shadowCol)/2.0;\n    \n    return col;\n}\n\n\nvec3 b1(vec3 P, vec3 refRay,vec3 N, vec3 col, float gTd, float sTr, float fres){\n    \n    vec3 diffCol = vec3(0.0,0.0,0.0);\n    float tempCount = 0.0;\n    \n    for(int i=0; i<int(RaySims); i++){\n        vec3 rayDir = genDiffRay(P,N,curCoord*iTime*(float(i)+1.0));\n        //vec3 rayDir = refRay;\n        vec3 Collision = checkCollide(P,rayDir);\n        if(Collision.x>0.0){\n            if(int(Collision.y)==0){ //Sphere\n                Sphere tempS = objects.spheres[int(Collision.z)];\n\t\t\t\t\n                if(bounceCount >= 2){\n                    vec3 newP = P + (rayDir*Collision.x);\n                \tvec3 newN = (tempS.pos-newP)/length(tempS.pos-newP);\n                \tnewP = newP + newN*(0.0001);\n                \tvec3 tempRef = reflect(rayDir,newN)/length(reflect(rayDir,newN));\n                    diffCol+=b2(newP,tempRef,newN,tempS.col,tempS.gTd,tempS.sTr,tempS.fres);\n                }\n                else{\n\t\t\t\t\ttempCount+=1.0;\n                    //diffCol+=tempS.col;\n                }\n           \t\t\n\n            }\n            if(int(Collision.y)==1){ //Triangle\n                Triangle tempT = objects.triangles[int(Collision.z)];\n\t\t\t\t\n                if(bounceCount >= 2){\n                \tvec3 newP = P + (rayDir*Collision.x);\n                \tvec3 newN = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n                \tnewN = newN/length(newN);\n                \tnewP = newP + newN*(0.00001);\n                \tvec3 tempRef = reflect(rayDir,newN)/length(reflect(rayDir,newN));\n                    diffCol+=b2(newP,tempRef,newN,tempT.col,tempT.gTd,tempT.sTr,tempT.fres);\n                }\n                else{\n                    tempCount+=1.0;\n                \t//diffCol+=tempT.col;\n                }\n            }\n\n            if(int(Collision.y)==2){ //Light\n                Light tempL = objects.lights[int(Collision.z)];\n                diffCol+=tempL.col;\n                //return tempL.col;\n\n            }\n\n        }\n        else{\n\t\t\tif(eviLight){\n\t\t\t\tdiffCol+=texture(iChannel0,vec3(rayDir.x,rayDir.z,rayDir.y)).xyz;\n            }\n            else{\n                tempCount+=1.0;\n            }\n        }\n    }\n    \n    vec3 shadowCol = vec3(0.0,0.0,0.0);\n    if(!checkShadow(P)){\n        shadowCol = col;\n    }\n    \n    //diffCol/=(RaySims-tempCount);\n    col*=diffCol;\n    col/=(RaySims);\n    //col = (col+shadowCol)/2.0;\n    \n    return col;\n}\n\n\n\n\nvec3 castCamRay(vec2 xy){\n    float ratio = Cam.dir.z/length(Cam.dir.xy);\n    vec3 VertPerp = vec3(-Cam.dir.x*ratio, -Cam.dir.y*ratio, length(Cam.dir.xy));\n    vec3 yComp = VertPerp * xy.y;\n    \n    vec3 HoriPerp = vec3(Cam.dir.y,-Cam.dir.x,0.0)/length(vec3(Cam.dir.y,-Cam.dir.x,0.0));\n    vec3 xComp = HoriPerp * xy.x;\n    \n    vec3 ray = (Cam.dir*3.0)+xComp+yComp;\n    vec3 rayDir = (ray/length(ray));\n\n    vec3 P = Cam.pos;\n    vec3 N = vec3(0.0,0.0,0.0);\n    vec3 Collision = checkCollide(P,rayDir);\n    if(Collision.x>0.0){\n        if(int(Collision.y)==0){ //Sphere\n            Sphere tempS = objects.spheres[int(Collision.z)];\n\t\t\t\n            if(bounceCount>=1){\n                P = P + (rayDir*Collision.x);\n                N = (tempS.pos-P)/length(tempS.pos-P);\n                P = P + N*(0.0001);\n                vec3 tempRef = reflect(rayDir,N)/length(reflect(rayDir,N));\n                return b1(P,tempRef,-N,tempS.col,tempS.gTd,tempS.sTr,tempS.fres);\n            }\n            else{\n                return tempS.col;\n            }\n        }\n        if(int(Collision.y)==1){ //Triangle\n            Triangle tempT = objects.triangles[int(Collision.z)];\n\n            if(bounceCount>=1){\n                P = P + (rayDir*Collision.x);\n                N = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n                N = -N/length(N);\n                P = P + N*(0.00001);\n                vec3 tempRef = reflect(rayDir,N)/length(reflect(rayDir,N));\n                return b1(P,tempRef,N,tempT.col,tempT.gTd,tempT.sTr,tempT.fres);\n            }\n            else{\n                return tempT.col;\n            }\n        }\n\n        if(int(Collision.y)==2){ //Light\n            Light tempL = objects.lights[int(Collision.z)];\n            return tempL.col;\n\n        }\n\n    }\n    else{\n\t\tif(eviLight){\n\t\t\treturn texture(iChannel0,vec3(rayDir.x,rayDir.z,rayDir.y)).xyz;\n        }\n    }\n    \n    \n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 LookAt = vec3(0.0,0.0,1.0);\n    Cam.pos.x =\t12.0*cos(iTime/1.2);\n   \tCam.pos.y = 12.0*sin(iTime/1.2);\n    Cam.dir = (LookAt-Cam.pos)/length(LookAt-Cam.pos);\n    \n    \n    Sphere[3] spheres = Sphere[](S1,S2,S3);\n\tTriangle[2] triangles = Triangle[](T1,T2);\n    Light[1] lights = Light[](L1);\n    \n    \n    objects = SceneObjects(spheres,triangles,lights);\n    \n    \n    // Normalized pixel coordinates (from -1 to 1 on the y axis, and propotional to the res on the x)\n    vec2 xy = vec2((2.0*(iResolution.x/iResolution.y)) * fragCoord.x/iResolution.x - (iResolution.x/iResolution.y), 2.0 * fragCoord.y/iResolution.y - 1.0);\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    \n    for(float i = -0.5+(0.5/(AA/sqrt(AA))); i<0.5; i+=1.0/(AA/sqrt(AA))){\n        for(float j = -0.5+(0.5/(AA/sqrt(AA))); j<0.5; j+=1.0/(AA/sqrt(AA))){\n    \t\tcurCoord = xy + vec2(i/iResolution.x,j/iResolution.y);\n    \t\tcol+=castCamRay(curCoord);\n        }\n    }\n\n  \t\n    col = col/AA;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float RaySims = 30.0;\nfloat PI = 3.14159265359;\n\nstruct Light{\n    vec3 pos;\n    float r;\n    vec3 col;\n};\nLight L1 = Light(vec3(-5.0,0.0,5.0), 0.0, vec3(1.0,1.0,1.0)*1.0);\n    \nstruct Camera{\n    vec3 pos;\n    vec3 dir;\n    float dist;\n};\nCamera Cam = Camera(vec3(-8.0,8.0,9.0),vec3(1.0,-1.0,-0.9),3.0);\n\nstruct Sphere{\n    vec3 pos;\n    float r;\n    vec3 col;\n    float gTd; //Scale from pure gloss to pure diffuse (0.0 - 1.0)\n    float sTr; //Scale from perfectly smooth to perfectly rough (0.0 - 1.0)\n    float fres; //Steepness of the fresnel effect (Higher => more diffuse faster)\n        \n};\nSphere S1 = Sphere(vec3(0.0,0.0,1.0),2.0,vec3(1.0,0.0,0.0),1.0,1.0,100.0);\nSphere S2 = Sphere(vec3(2.1213,2.1213,1.0),1.0, vec3(0.0,1.0,0.0),1.0,1.0,100.0);\nSphere S3 = Sphere(vec3(-2.1213,-2.1213,1.0),1.0, vec3(0.0,0.0,1.0),1.0,1.0,100.0);\n\n\nstruct Triangle{\n    vec3 Vert1;\n    vec3 Vert2;\n    vec3 Vert3;\n    vec3 col;\n    float gTd; //Scale from pure gloss to pure diffuse (0.0 - 1.0)\n    float sTr; //Scale from perfectly smooth to perfectly rough (0.0 - 1.0)\n    float fres; //Steepness of the fresnel effect (Higher => more diffuse faster)\n};\nTriangle T1 = Triangle(vec3(5.0,5.0,-1.0), vec3(5.0,-5.0,-1.0), vec3(-5.0,5.0,-1.0), vec3(0.7,0.7,0.7),1.0,1.0,100.0);\nTriangle T2 = Triangle(vec3(5.0,-5.0,-1.0), vec3(-5.0,-5.0,-1.0), vec3(-5.0,5.0,-1.0), vec3(0.8,0.8,0.8),1.0,1.0,100.0);\nTriangle T3 = Triangle(vec3(5.0,5.0,-1.0), vec3(5.0,-5.0,10.0), vec3(5.0,-5.0,-1.0), vec3(0.8,0.8,0.8),1.0,1.0,100.0);\nTriangle T4 = Triangle(vec3(5.0,5.0,-1.0), vec3(5.0,5.0,10.0), vec3(5.0,-5.0,10.0), vec3(0.7,0.7,0.7),1.0,1.0,100.0);\n    \nstruct SceneObjects{\n    Sphere[3] spheres;\n    Triangle[2] triangles;\n    Light[1] lights;\n};\nSceneObjects objects;\n\n\n\n\nvec3 checkCollide(vec3 Origin, vec3 rayDir){\n    float closestP = -1.0;\n    int objectNum = -1;\n    int SphTriOrLight = -1;\n    \n    //Check Spheres\n    for(int i = 0; i<objects.spheres.length(); i++){\n        Sphere tempS = objects.spheres[i];\n        \n        vec3 L = (tempS.pos-Origin); //Ray from sphere center to origin\n    \tfloat tca = dot(L,rayDir); //Distance to the closest point rayDir gets to sphere center\n    \n    \n    \tif(tca<=0.0){ //If the sphere is behind the camera\n    \t   \tcontinue;\n    \t}\n    \n    \tfloat d = sqrt(abs(dot(L,L)-(tca*tca))); //Gets the distance from the closest point to the sphere center\n        \n        if(length(L)-tca<0.00000000001){\n            d=0.00000000001;\n        };\n    \n    \tif(d>=tempS.r){\n    \t    continue;\n    \t}\n    \n    \tfloat thc = sqrt((tempS.r*tempS.r)-(d*d)); //Gets the distance from the closest point to the first point of intersection\n    \tfloat distToPoint= tca-thc; //Gets the distance away from the origin to the first point of intersection along rayDir\n        \n        if(i==0||closestP==-1.0){\n            closestP = distToPoint;\n            SphTriOrLight = 0;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphTriOrLight = 0;\n        \tobjectNum = i;\n        }\n    \t\n    }\n    //Check triangles\n    for(int i = 0; i<objects.triangles.length(); i++){\n        Triangle tempT = objects.triangles[i];\n        \n        vec3 normal = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n        \n        //Test if ray is parallel to plane \n        if(dot(rayDir,normal)<0.001){\n            continue;\n        }\n        \n        vec3 p0l0 = tempT.Vert1 - Origin;\n        \n        //Dist to Intersection Point on plane\n        float distToPoint = dot(p0l0,normal) / dot(rayDir,normal);\n        if(distToPoint<0.0){\n            continue;\n        }\n        \n        vec3 P = Origin + rayDir*distToPoint; //Point of intersection\n        \n        //Check to see if ray is within the triangle\n        vec3 C;\n        //edge 1\n        vec3 edge1 = tempT.Vert2 - tempT.Vert1;\n\t\tvec3 vp1 = P - tempT.Vert1;\n        C = cross(edge1,vp1);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 2\n        vec3 edge2 = tempT.Vert3 - tempT.Vert2;\n\t\tvec3 vp2 = P - tempT.Vert2;\n        C = cross(edge2,vp2);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 3\n        vec3 edge3 = tempT.Vert1 - tempT.Vert3;\n\t\tvec3 vp3 = P - tempT.Vert3;\n        C = cross(edge3,vp3);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        \n        \n        \n        if(closestP==-1.0){\n            closestP = distToPoint;\n            SphTriOrLight = 1;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphTriOrLight = 1;\n        \tobjectNum = i;\n        }\n        \n    }\n    //Check Lights\n    for(int i = 0; i<objects.lights.length(); i++){\n        Light tempL = objects.lights[i];\n        \n        vec3 L = (tempL.pos-Origin);\n    \tfloat tca = dot(L,rayDir);\n    \n    \n    \tif(tca<=0.0){\n    \t   \tcontinue;\n    \t}\n    \n    \tfloat d = sqrt(abs(dot(L,L)-(tca*tca)));\n        \n        if(length(L)-tca<0.00000000001){\n            d=0.00000000001;\n        };\n    \n    \tif(d>=tempL.r){\n    \t    continue;\n    \t}\n    \n    \tfloat thc = sqrt((tempL.r*tempL.r)-(d*d));\n    \tfloat distToPoint= tca-thc;\n        \n        if(closestP==-1.0){\n            closestP = distToPoint;\n            SphTriOrLight = 2;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphTriOrLight = 2;\n        \tobjectNum = i;\n        }\n    \t\n    }\n    \n    return vec3(closestP,SphTriOrLight,objectNum);\n       \n}\n\nbool checkShadow(vec3 P){\n\tvec3 rayDir = (L1.pos - P)/length(L1.pos - P);\n    vec3 Collision = checkCollide(P,rayDir);\n    \n    if(Collision.y==2.0){\n        return false;\n    }\n    return true;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 genDiffRay(vec3 P, vec3 N, vec2 seed){\n    /*vec2 randAng = vec2(rand(seed)*PI,rand(seed*2.0)*PI);\n    \n    float ratio = N.z/length(N.xy);\n    \n    vec3 VertPerp = vec3(0.0,0.0,0.0);\n    vec3 HoriPerp = vec3(0.0,0.0,0.0);\n\tif(N==vec3(0.0,0.0,1.0)||N==vec3(0.0,0.0,-1.0)){\n        VertPerp = vec3(1.0,0.0,0.0);\n        HoriPerp = vec3(0.0,1.0,0.0);\n    }\n    else{\n        VertPerp = vec3(-N.x*ratio, -N.y*ratio, length(N.xy));\n        HoriPerp = vec3(N.y,-N.x,0.0)/length(vec3(N.y,-N.x,0.0));\n    }\n    \n    vec3 yComp = (VertPerp * cos(randAng.x))+(N*sin(randAng.x));\n    yComp/=length(yComp);\n    vec3 xComp = (HoriPerp * cos(randAng.y))+(N*sin(randAng.y));\n    xComp/=length(xComp);\n    vec3 diffRay = yComp+xComp-N;*/\n    \n    \n    vec3 randPoint = vec3((rand(seed)*2.0)-1.0,(rand(seed*4.0)*2.0)-1.0,(rand(seed*3.0)*2.0)-1.0)+P; //gen rand point around P\n    vec3 randRay = P-randPoint;\n    //randRay = randRay/length(randRay);\n    vec3 diffRay = N+randRay;\n    return (diffRay/length(diffRay));\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}