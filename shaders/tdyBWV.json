{
    "Shader": {
        "info": {
            "date": "1607973985",
            "description": "raymarching test",
            "flags": 0,
            "hasliked": 0,
            "id": "tdyBWV",
            "likes": 2,
            "name": "dick v1",
            "published": 3,
            "tags": [
                "dickraymarching"
            ],
            "usePreview": 0,
            "username": "spplash",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.f\n#define SURF_DIST .01f\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0., 1.);\n\n\tvec3 c = a + t*ab;\n\treturn length(p-c) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz) - r.x;\n\treturn length(vec2(x, p.y)) - r.y;\n}\n\nfloat dBox(vec3 p, vec3 hsize) {\n\treturn length(max(abs(p) - hsize, 0.f));\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn max(a, b) + h*h*0.25/k;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(abs(length(p.xz)),p.y)) - vec2(h,r);\n  d.x = abs(d.x) - 0.01;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb)\n{\n//  p.x = abs(p.x);\n  p.z = -p.z;\n  float k = (sc.y*p.z>sc.x*p.y || p.z < 0.) ? dot(p.zy,sc) : length(p.zy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat GetDist(vec3 p) {\n    //p = p//* vec3(0.8, 1.2, 0.8);\n    vec3 c = p - vec3(0., 1.0, 0.);\n\n\t//float d = sdCappedCylinder(c, 0.3, 0.3);\n    \n    float bl1 = sdEllipsoid(c-vec3(0.2, 0., 0.), vec3(0.25, 0.35, 0.25));\n    float bl2 = sdEllipsoid(c-vec3(-0.2, 0., 0.), vec3(0.25, 0.35, 0.25));\n    float bls = smin(bl1, bl2, 0.2);\n    \n    float r = 1.3 + sin(iTime)/4.;\n    \n    float pn = sdCappedTorus(c-vec3(0., 0.15 - r, 0.), vec2(.8, 0.6), r, 0.2);\n    \n    float d = smin(bls, pn, 0.1);\n    \n\treturn d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tvec2 res = vec2(0.0,-1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n\n#if 1\n\t// raytrace bounding plane\n\tfloat tp = (3.5-ro.y)/rd.y;\n\tif( tp>0.0 ) tmax = min( tmax, tp );\n#endif\n\n\t// raymarch scene\n\tfloat t = tmin;\n\tfor( int i=0; i<256 && t<tmax; i++ )\n\t{\n\t\tvec2 h = vec2(GetDist(ro+rd*t), 0.);\n\t\tif(abs(h.x)<(0.0005*t))\n\t\t{\n\t\t\tres = vec2(t,h.y);\n\t\t\tbreak;\n\t\t}\n\t\tt += h.x;\n\t}\n\n\treturn res;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n\tvec2 e = vec2(0.01, 0);\n\n\tvec3 n = d - vec3(\n\t\tGetDist(p - e.xyy),\n\t\tGetDist(p - e.yxy),\n\t\tGetDist(p - e.yyx));\n\n\treturn normalize(n);\n}\n\nfloat rand(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat rand2d(vec2 v)\n{\n\tvec2 K1 = vec2(23.14069263277926,2.665144142690225);\n\treturn fract( cos( dot(v,K1) ) * 12345.6789 );\n}\n\nfloat rand3d(vec3 v)\n{\n\tvec3 K1 = vec3(23.14069263277926, 2.665144142690225, 7.5739974548463465);\n\treturn fract( cos( dot(v,K1) ) * 12345.6789 );\n}\n\nmat3 setCamera(in vec3 ro, in vec3 lookat)\n{\n\tvec3 cw = normalize(lookat-ro);\n\tvec3 cp = vec3(sin(0.), cos(0.),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 resolution = iResolution.xy;\n\tvec2 uv = (fragCoord.xy-.5*resolution) / resolution.y;\n\n\tvec3 sky_col = vec3(0.3, 0.0, 0.0);\n\tvec3 col = sky_col;\n\n\tfloat light_coef = 1.;\n\tvec3 light_color = vec3(1., 0.8, 0.8);\n\n\tcol = clamp((1.-length(uv-vec2(0., -0.5)) - 0.1*rand2d(uv+iTime)) * light_coef, 0., 1.) * light_color;\n\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    vec3 lookat = vec3(0., 1., 0.);\n    vec3 ro = lookat + vec3( 2.5*cos(0.1*iTime + 7.0*mo.x), 0.8 + 1.0*mo.y, 2.5*sin(0.1*iTime + 7.0*mo.x) );\n//\tvec3 ro = lookat + vec3(-3.0f, 1.f, -2.0f);\n    mat3 cam_mat = setCamera(ro, lookat);\n    \n    \n\tvec3 rd = cam_mat * normalize(vec3(uv.x+0., uv.y, 1));\n\n\tvec2 d = RayMarch(ro, rd);\n\n\tvec3 p = ro + rd * d.x;\n\n\tif (d.y > -0.5) {\n\t\t// moving light\n\t\tvec3 lightPos = vec3(-1.2, 1.1, -0.9);\n\t\tvec3 light_dir = lightPos - p;\n\t\tvec3 l = normalize(light_dir);\n\t\tvec3 normal = GetNormal(p);\n\n\t\tvec3 sky_l_dir = vec3(0, 1, 0);\n\n\t\t// light coef\n\t\tfloat main_light = clamp(dot(normal, l) - rand3d(p/*+iTime*/)*0.05, 0., 1.) * 0.5;\n\n\t\tcol = vec3(0.4, 0.4, 0.4);\n        \n\t\t// lightning\n\t\tvec3 lin = vec3(0.);\n\t\tlin += 2. * (0.1+light_coef * main_light) * light_color;\n\n\t\tcol = col * lin;\n\n\t\t// gama\n\t\tcol = pow(col, vec3(1./2.2));\n\t}\n\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}