{
    "Shader": {
        "info": {
            "date": "1588004851",
            "description": "This actually started as a water rendering experiment - https://iquilezles.org/articles/simplewater/simplewater.htm , but then I suddenly wanted to create an island and so I made one. I still have absolutely no idea about rendering water though.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXBWn",
            "likes": 8,
            "name": "Stranded island",
            "published": 3,
            "tags": [
                "raymarching",
                "water",
                "island"
            ],
            "usePreview": 0,
            "username": "42yeah",
            "viewed": 521
        },
        "renderpass": [
            {
                "code": "vec2 rand2d(vec2 p) {\n    return fract(sin(vec2(\n        dot(p, vec2(12.345, 67.890)),\n        dot(p, vec2(190.61, 312.21))\n    )) * 41235.45) * 2.0 - 1.0;\n}\n\nfloat perlin(vec3 p) {\n    vec2 u = floor(p.xz);\n    vec2 f = fract(p.xz);\n    vec2 s = smoothstep(0.0, 1.0, f);\n\n    vec2 a = rand2d(u);\n    vec2 b = rand2d(u + vec2(1.0, 0.0));\n    vec2 c = rand2d(u + vec2(0.0, 1.0));\n    vec2 d = rand2d(u + vec2(1.0, 1.0));\n\n    return mix(\n        mix(dot(a, f), dot(b, f - vec2(1.0, 0.0)), s.x),\n        mix(dot(c, f - vec2(0.0, 1.0)), dot(d, f - vec2(1.0, 1.0)), s.x),\n        s.y\n    );\n}\n\nfloat fbm(vec3 p) {\n    p.xz *= 2.0;\n    int octaves = 2;\n    float amplitude = 0.5;\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        p += iTime * vec3(0.1, 0.0, 0.3);\n        value += amplitude * perlin(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nfloat water(vec3 p) {\n    p.xz *= 0.2;\n    float f = fbm(p);\n    float g = fbm(p + vec3(0.5, 1.0, 0.2));\n    return p.y + fbm(vec3(f, 0.0, g)) - 0.5;\n}\n\nfloat distToCenter(vec3 p) {\n    return clamp(1.5 - length(p.xz) / 5.0, 0.0, 1.5);\n}\n\nfloat sol(vec3 p) {\n    float dtm = distToCenter(p);\n    float per = perlin(p * 0.7) * 1.0 + 3.5;\n    return p.y - per * dtm;\n//    return p.y + distToMiddle;\n}\n\nvec2 map(vec3 p) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = water(p);\n    if (dist < closest) { closest = dist; id = 0.5; }\n    \n    dist = sol(p);\n    if (dist < closest) { closest = dist; id = 1.5; }\n    \n    return vec2(closest, id);\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 160; i++) {\n        vec2 info = map(ro + rd * depth);\n        if (info.x <= 0.001) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n    }\n    return vec2(depth, id);\n}\n\nvec3 getIslandColor(vec3 p) {\n    vec3 baseColor = vec3(0.5, 0.21, 0.1);\n    float total = 1.0;\n    float sandiness = 1.0 - clamp((p.y - 0.2) * (perlin(p) * 0.5 + 0.5) * 1.3, 0.0, 1.0);\n    baseColor = mix(baseColor, vec3(0.76, 0.69, 0.5), sandiness);\n    \n    float grassiness = (total - sandiness) * clamp(1.0 - (p.y - 3.87), 0.0, 1.0);\n    baseColor = mix(baseColor, vec3(0.28, 0.6, 0.21), grassiness);\n    \n    baseColor = mix(baseColor, vec3(1.0, 1.0, 1.0), total - sandiness - grassiness);\n//    float dtm = distToMiddle(p);\n    return vec3(baseColor);\n}\n\nvec3 getSkyColor(vec3 p, vec3 rd) {\n    vec3 skyColor = vec3(0.3, 0.65, 0.99);\n    skyColor = mix(skyColor, vec3(1.0), pow(clamp(rd.y, 0.0, 1.0), 0.7));\n    return skyColor;\n}\n\nvec3 getColor(float id, vec3 p, vec3 rd) {\n    if (id < -0.5) { return getSkyColor(p, rd); }\n    if (id < 1.0) { return vec3(0.21, 0.67, 0.89) * 0.7; }\n    if (id < 2.0) { return getIslandColor(p); }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 getNormal(vec3 p) {\n    const float epsilon = 0.001;\n    return normalize(vec3(\n        map(vec3(p.x + epsilon, p.yz)).x - map(vec3(p.x - epsilon, p.yz)).x,\n        map(vec3(p.x, p.y + epsilon, p.z)).x - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        map(vec3(p.x, p.y, p.z + epsilon)).x - map(vec3(p.x, p.y, p.z - epsilon)).x\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec3 ro = vec3(13.0 - (sin(iTime) * 0.5 + 0.5), 3.0 + sin(iTime * 0.5), 1.0 + cos(iTime));\n    vec3 center = vec3(0.0, 1.5, 0.0);\n    \n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    \n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n    \n    vec2 info = intersect(ro, rd);\n    \n    vec3 pos = ro + rd * info.x;\n    \n    float foginess = 1.0 - clamp(distToCenter(pos) * 6.0, 0.0, 1.0);\n    if (foginess >= 1.0) {\n        vec3 objColor = getSkyColor(pos, rd);\n        objColor = pow(objColor, vec3(0.4545));\n        fragColor = vec4(objColor, 1.0);\n        return;\n    }\n    vec3 n = getNormal(pos);\n    \n    float ambient = 1.0;\n    float diffuse = max(dot(n, lightDir), 0.0);\n    float dome = 0.2 + 0.8 * clamp(n.y, 0.0, 1.0);\n    float back = max(dot(n, vec3(-lightDir.x, 0.0, -lightDir.z)), 0.0);\n    \n    vec3 light = vec3(0.0);\n    light += ambient * vec3(0.1, 0.1, 0.1);\n    light += diffuse * vec3(1.0, 1.0, 1.12);\n    light += dome * vec3(0.1, 0.1, 0.4);\n    light += back * vec3(5.0, 2.9, 2.0);\n\n    if (info.y < -0.5) {\n        light = vec3(1.0);\n    }\n\n    vec3 objColor = getColor(info.y, pos, rd) * light;\n    objColor = mix(objColor, getSkyColor(pos, rd), foginess);\n    objColor = pow(objColor, vec3(0.4545));\n\n    fragColor = vec4(objColor, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}