{
    "Shader": {
        "info": {
            "date": "1519672883",
            "description": "Click your mouse to follow the white rabbit down to the rabbit hole ! Fullscreen is better.",
            "flags": 0,
            "hasliked": 0,
            "id": "Md3yRf",
            "likes": 39,
            "name": "The Rabbit Hole",
            "published": 3,
            "tags": [
                "2d",
                "droste",
                "escher",
                "kifs",
                "fold"
            ],
            "usePreview": 0,
            "username": "rigel",
            "viewed": 1239
        },
        "renderpass": [
            {
                "code": "// Author: Rigel rui@gil.com\n// licence: https://creativecommons.org/licenses/by/4.0/\n// link: https://www.shadertoy.com/view/Md3yRf\n\n\n/*\nThis was inpired by Escher painting \"Print Gallery\" and this lecture\nhttps://youtu.be/clQA6WhwCeA?t=7m50s\n\nI wanted to do something with the Escher/Droste effect, and I discovered \nthis blog post http://roy.red/droste-.html#droste \nby user Roy Wiggins https://www.shadertoy.com/user/roywig\n\nAnd his other post about KIFS (Kaleidoscopic Iterated Function Systems)\nhttp://roy.red/folding-the-koch-snowflake-.html#folding-the-koch-snowflake\n\nAn this sended me along a rabbit hole of folding space, and constructing \nKIFS with escher like spiral zooms :) \n\nThere are plenty of Escher/Droste effect on shadertoy, but this one by reinder\nis like total magic. https://www.shadertoy.com/view/Mdf3zM\n*/\n\n\n// utility functions\n// conversion from cartesian to polar\nvec2 toPolar(vec2 uv) { return vec2(length(uv),atan(uv.y,uv.x)); }\n// conversion from polar to cartesian\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\n// complex division in polar form z = vec2(radius,angle)\nvec2 zdiv(vec2 z1, vec2 z2) { return vec2(z1.x/z2.x,z1.y-z2.y); }\n// complex log in polar form z = vec2(radius,angle)\nvec2 zlog(vec2 z) { return toPolar(vec2(log(z.x),z.y)); }\n// complex exp in polar form z = vec2(radius,angle)\nvec2 zexp(vec2 z) { z = toCarte(z); return vec2(exp(z.x),z.y); }\n// smoothstep antialias with fwidth\nfloat ssaa(float v) { return smoothstep(-1.,1.,v/fwidth(v)); }\n// stroke an sdf 'd', with a width 'w', and a fill 'f' \nfloat stroke(float d, float w, bool f) {  return abs(ssaa(abs(d)-w*.5) - float(f)); }\n// fills an sdf 'd', and a fill 'f'. false for the fill means inverse \nfloat fill(float d, bool f) { return abs(ssaa(d) - float(f)); }\n// a signed distance function for a rectangle 's' is size\nfloat sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// a signed distance function for a circle, 'r' is radius\nfloat sdfCircle(vec2 uv, float r) { return length(uv)-r; }\n// a signed distance function for a hexagon\nfloat sdfHex(vec2 uv) { vec2 auv = abs(uv); return max(auv.x * .866 + auv.y * .5, auv.y)-.5; }\n// a signed distance function for a equilateral triangle\nfloat sdfTri(vec2 uv) { return max(abs(uv.x) * .866 + uv.y * .5, -uv.y)-.577; }\n// a 'fold' is a kind of generic abs(). \n// it reflects half of the plane in the other half\n// the variable 'a' represents the angle of an axis going through the origin\n// so in normalized coordinates uv [-1,1] \n// fold(uv,radians(0.)) == abs(uv.y) and fold(uv,radians(90.)) == abs(uv.x) \nvec2 fold(vec2 uv, float a) { a -= 1.57; vec2 axis = vec2(cos(a),sin(a)); return uv-(2.*min(dot(uv,axis),.0)*axis); }\n// 2d rotation matrix\nmat2 uvRotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n\n// this functions 'folds' space with the symmetries of the Koch Snowflake\n// https://en.wikipedia.org/wiki/Koch_snowflake\n// it returns a coordinate system uv, where you can draw whatever you like\n// 'n' is the number of iterations\nvec2 uvKochSnowflake(vec2 uv, int n) {\n    uv = fold(vec2(-abs(uv.x),uv.y),radians(150.))-vec2(.0,.44);\n    for (int i=0; i<n; i++) \n        uv = fold(vec2(abs(uv.x),uv.y)*3.-vec2(.75,.0),radians(60.))-vec2(.75,.0);\n    return uv;\n}\n\n// this functions 'folds' space with the symmetries of the Sierpinski Carpet\n// https://en.wikipedia.org/wiki/Sierpinski_carpet\n// it's like the 2d equivalent of the menger sponge\n// it returns a coordinate system uv, where you can draw whatever you like\n// 'n' is the number of iterations\nvec2 uvSierpinskiCarpet(vec2 uv, int n) {\n    for (int i=0; i<n; i++) {\n        uv = fold(abs(uv*3.),radians(45.))-vec2(2.0,1.0);\n        uv = vec2(uv.x,abs(uv.y)-1.);\n    }\n    return uv;    \n}\n\n// the scene\nvec3 TheRabbitHole(vec2 uv) {\n\n    // a flag for the scene\n    float sc = 1.;\n\t// save current uv for the rabbit\n    vec2 uvr = uv;\n\n    // if mouse clicked apply the Escher/Droste transform\n    if (iMouse.z >.0) {\n        float scale = log(4.);\n        float angle = atan(scale/6.283);\n        \n        // this line is an infinite zoom\n        uv /= exp(mod(iTime*.8,6.283/angle));\n        \n        // this line is the Escher Deformation with a vec2(scale,rotation)\n        uv = toCarte(zexp(zdiv(zlog(toPolar(uv)),vec2(cos(angle),angle))));\n        \n        // this line is the Droste Effect for the size of the frame\n        uv /= exp(scale*floor(log(sdfRect(uv*vec2(.8,.66),vec2(0.)))/scale));\n        sc = -1.;\n    }\n\n    // the frame\n    float frame = min(\n        stroke(sdfRect(uv,vec2(1.5,1.75)),.5,true),\n        // drawing a simple rectangle in the sierpinsi carpet coordinate system\n        fill(sdfRect(uvSierpinskiCarpet(mod((uv-vec2(.25,.0))*6.,3.)-1.5,2),vec2(1.)),false));\n\n    // the canvas behind the rabbit\n    float canvas = fill(sdfRect(uv,vec2(1.4,1.6)),true)*(1.-sdfRect(uv,vec2(.4,.6)));\n    \n    // uv for the rabbit\n    uvr = sc == 1. ? uvr*.2+vec2(0.,.15) : uvr*.5*uvRotate(iTime*4.);\n    \n    // uv for the rabbit ears\n    vec2 uvears = vec2(abs(uvr.x),uvr.y)*uvRotate(radians(-20.)); \n    float ears = stroke(sdfCircle(vec2(-abs(uvears.x),uvears.y)-vec2(.16,.3),.2),.04,true); \n    \n    // uv for the rabbit eyes\n    vec2 uveyes = vec2(abs(uvr.x),uvr.y)*uvRotate(radians(-40.)); \n    float eyes = fill(sdfCircle(vec2(-abs(uveyes.x),uveyes.y)-vec2(.05,.1),.07),false); \n    \n    // nose ant teeth\n    float nose = fill(sdfCircle(vec2(abs(uvr.x),uvr.y)-vec2(.008,.0),.02),false);\n    float teeth = fill(sdfRect(vec2(abs(uvr.x),uvr.y)-vec2(.007,-.045),vec2(.005,.015)),false);\n\n    // the face is just a bunch of circles\n    float face = max(max(\n        fill(sdfCircle(uvr-vec2(.0,.0),.07),true),\n        fill(sdfCircle(vec2(abs(uvr.x),uvr.y)-vec2(.078,.05),.07),true)),\n        fill(sdfCircle(uvr-vec2(.0,.1),.12),true));\n    \n    // compose the rabbit\n    float rabbit = min(min(min(eyes,nose),teeth),max(ears,face));\n\n    // a coodinate system uv for the Koch Snowflake KIFS\n    vec2 uvka = uvKochSnowflake(vec2(abs(uv.x),uv.y)*.7-vec2(2.3,.0),2);\n    vec2 uvkb = vec2(uvka.x,mod(uvka.y+iTime,.8)-.4);\n    // drawing a pattern with this uv\n    float kifs = max(max(max(min(\n        fill(sdfCircle(uvkb,.4),false),\n        fill(sdfRect(uvka-vec2(.0,-1.5),vec2(.6,6.)),true)),\n        stroke(sdfRect(uvka,vec2(1.,.2)),.3,true)),\n        fill(sdfHex(uvka-vec2(cos(iTime),sin(iTime)*2.)),true)), \n        fill(sdfRect(uvkb,vec2(.2)),true));\n\n    // the small clock on the left\n    vec2 uvc = (uv+vec2(3.3,.0))*1.2;\n    vec2 uvch = sc==1. ? uvc : uvc*uvRotate(radians(iTime*60.));\n    float chronos = min(min(\n        fill(sdfHex(uvc),true),\n        stroke(sdfCircle(uvc,.4),.1,false)+\n        stroke(mod(atan(uvc.y,uvc.x)+radians(15.),radians(30.))-radians(15.),.15,false)),\n        fill(sdfRect(uvch-vec2(.0,.15),vec2(.03,.15)),false));\n    \n    // the small card figure on the right    \n    vec2 uvh = (uv-vec2(3.3,.0))*1.2;\n    float card = max(max(stroke(sdfHex(uvh),.1,true),\n    fill(sdfCircle(vec2(uvh.x,-sc*uvh.y-sqrt(abs(uvh.x)*.25)+.15)*1.2,.3),true)),\n    fill(sdfTri(uvh*7.+vec2(.0,2.2)),true)*sc);\n\n\t// background\n    vec3 c = vec3(.9)* (sc == 1. ? 1. : 1.2-length(uv)*.15);\n    // mixing all components together\n    c = mix(c,vec3(.1),canvas);\n    c = mix(c,vec3(.6)-sc*vec3(.3),kifs);\n    c = mix(c,vec3(.3)-sc*vec3(.3,.0,.0),chronos);\n    c = mix(c,vec3(.3)-sc*vec3(.3,.0,.0),card);\n    c = mix(c,vec3(.2),frame);\n    c = mix(c,vec3(sc),rabbit);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n\n\tfragColor = vec4( TheRabbitHole(uv*6.), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}