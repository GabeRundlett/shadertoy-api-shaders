{
    "Shader": {
        "info": {
            "date": "1684539820",
            "description": "Update 1: now with soft shadows\nUpdate 2: now with box",
            "flags": 0,
            "hasliked": 0,
            "id": "clGGDG",
            "likes": 1,
            "name": "Ray Marching Attempt #3 (wip)",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "NikoAnimation",
            "viewed": 141
        },
        "renderpass": [
            {
                "code": "// INIT VARS\nvec2 camAngle = vec2(-2.0, -0.1);\nfloat fov = 0.3; // <-- 90*  0-1 == 0-360\n\nfloat minDELength = 0.0001;\nfloat maxRayLength = 1000.0;\nfloat maxSteps = 1000.0; // had to be float so i could divide ¯\\_(ツ)_/¯\n\nvec2 lightAng = vec2(1.0, 0.0);\nfloat AOMultiplier = 2.0;\nfloat shadowSoftness = 1.0;\n\nfloat sphere_de(vec3 pos, vec3 objPos, float radius) {\n    return length(pos-objPos)-radius;\n}\nfloat plane_de(vec3 pos, float z) {\n    return pos.z + z;\n}\nfloat box_de( vec3 p, vec3 b, vec3 objPos )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//float modsphere_de( in vec3 p, in vec3 c)\n//{\n//    vec3 q = mod(p+0.5*c,c)-0.5*c;\n//    return sphere_de(q, vec3(0.0, 0.0, 2.0), 2.0);\n//}\nfloat octahedron_de( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat overall_de(vec3 pos) {\n    \n    float objList[3] = float[] (\n        plane_de(pos, 0.0), \n        sphere_de(pos, vec3(-5.0, 0.0, 2.0), 2.0), \n        box_de(pos, vec3( 1.0, 1.0, 2.0), vec3(0.0, 0.0, 1.0))\n    );\n    \n    float min_de = maxRayLength;\n    for(int i=0; i<3; i++) {\n        if (objList[i] < min_de) {\n            min_de = objList[i];\n        }\n    } return min_de;\n}\nvec3 get_normal(vec3 pos) {\n\tfloat dist = overall_de(pos);\n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = dist - vec3(\n        overall_de(pos-e.xyy),\n        overall_de(pos-e.yxy),\n        overall_de(pos-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 ray_move(vec3 pos, vec3 dir, float dist) {\n    \n    /*\n    pos.x += cos(dir.x)*dist;\n    pos.y += sin(dir.x)*dist;\n    pos.z += sin(dir.y)*dist;\n    */\n    vec3 newPos = pos + normalize(dir)*dist;\n    return newPos;\n}\nvec3 deg_to_vec(vec2 dir) { //Used to convert angle based vec2s to vec3 directions\n    vec3 pos;\n    pos.x += cos(dir.x);\n    pos.y += sin(dir.x);\n    pos.z += sin(dir.y);\n    return normalize(pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightAng = vec2(iTime, 0.5);\n    vec3 camPos = vec3(3.0, 10.0, 3.0);\n\n    // Calculate aspect ratio (assumes width is higher than height)\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 suv = (uv*2.0)-1.0; // Signed screen coordinates (-1 - +1)\n    suv.x *= aspectRatio; // Account for aspect ratio\n\n    // Get ray angle\n    vec3 rayPos = camPos;\n    vec2 rayAng = (fov*suv + camAngle); // mod values for correct angle\n    \n    float b = 1.0;\n    \n    float de;\n    float totalDist;\n    float steps;\n    do {\n        de = overall_de(rayPos);\n        rayPos = ray_move(rayPos, deg_to_vec(rayAng), de);\n        totalDist += de;\n        steps += 1.0;\n    } while (de > minDELength && totalDist < maxRayLength && steps < maxSteps);\n    \n    if (de < minDELength) {\n        \n        rayPos = ray_move(rayPos, get_normal(rayPos), minDELength*2.0);\n        rayAng = lightAng;\n        \n        totalDist = minDELength*2.0;\n        float res = 1.0;\n        vec3 origPos = rayPos;\n        do {\n            de = overall_de(rayPos);\n            rayPos = ray_move(rayPos, deg_to_vec(rayAng), de);\n            totalDist += de;\n            res = min(res, shadowSoftness*de/totalDist);\n        } while (de > minDELength && totalDist < maxRayLength);\n        \n        \n        if (de < minDELength) {\n            \n              b = 0.0;\n            //b = clamp(dot(get_normal(rayPos), deg_to_vec(lightAng)), .2, 1.0);\n            \n            //b = (dot(get_normal(rayPos), deg_to_vec(lightAng)))/1.4-(steps/maxSteps)*AOMultiplier;\n            \n            //vec3 vecRayAngle = deg_to_vec(rayAng);\n            //vec3 reflectedAng = reflect(vecRayAngle, get_normal(rayPos));\n            //b += dot(vecRayAngle, reflectedAng);\n            \n        } if (totalDist > maxRayLength) {\n        \n           b = res;\n           \n        }\n        //b -= 10.0*shadowSoftness*minDE/totalMinDE;//+ (steps/maxSteps)*AOMultiplier;\n        //b += clamp(doctt(refle(deg_to_vec(rayAng), get_normal(rayPos)), deg_to_vec(lightAng)), .2, 1.0);\n        \n        b = clamp((b-(steps/maxSteps)+0.2)*AOMultiplier, 0.0, 1.0);\n        \n    } else {\n        b = 0.0;\n    }\n    // Output to screen\n    fragColor = vec4(b, b, b, 1.0);\n    //fragColor = vec4(get_normal(rayPos) ,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}