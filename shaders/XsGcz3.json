{
    "Shader": {
        "info": {
            "date": "1522725560",
            "description": " A visual representation of Sebastian Aaltonen's shadow optimization technique, which is being used in this shader: [url]https://www.shadertoy.com/view/lsKcDD[/url]. The key math happen in the function triangulate() bellow:\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XsGcz3",
            "likes": 21,
            "name": "Triangulation for Shadows",
            "published": 3,
            "tags": [
                "2d",
                "shadows"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1350
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A visual representation of Sebastian Aaltonen's shadow optimization \n// technique for SDFs, which is being used in this shader: \n// https://www.shadertoy.com/view/lsKcDD\n//\n// The black line is the ray being marched\n// The red dot is the position of the previous marching+sampling point\n// The red circle is bounding distance of the SDF measured at the red dot\n// The green dot is the position of the current marching+sampling point\n// The green circle is bounding distance of the SDF measured at the green dot\n// The brown dots and line are the intersection of the bounding circles\n// The yellow dot is triangulated closest point in the ray to the SDF\n\n\n// The key math happen in the function triangulate() bellow:\n\n\nvec2 triangulate( in float r1, in float r2 )\n{\n    float y = r2*r2/(2.0*r1);\n    float d = sqrt(r2*r2-y*y);\n    return vec2(y,d);\n    \n    // alternative form\n    //\n    // float y = 0.5*r2/r1;\n    // float d = sqrt(1.0-y*y);\n    // return r2*vec2(y,d);\n}\n\n\n\n//------------------------------------------------------\n\nfloat line(  in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat circ( in vec2 p, in vec2 cen, in float rad )\n{\n    return abs(length(p-cen) - rad);\n}\n\nfloat disk( in vec2 p, in vec2 cen, in float rad )\n{\n    return length(p-cen) - rad;\n}\n\nfloat triangle( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    float h2 = dot( b-a,  b-a ); float h = sqrt(h2);\n    float py = dot( p-a,  b-a ) / h;\n    float px = dot( p-a, (b-a).yx*vec2(-1,1));\n    \n    float d1 = py - h;\n    float d2 = ( abs(px) - r*py ) / sqrt(r*r+h2);\n    \n    return max(d1,d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    vec2 pa = vec2(-1.4,-0.4 );\n    vec2 pb = vec2( 1.3, 0.5 );\n    vec2 ba = normalize( pb - pa );\n    \n    vec2 pc = pa + ba;    float rc = 0.8 + 0.15*sin(1.0*iTime);\n    vec2 pd = pc + ba*rc; float rd = 0.6 + 0.15*sin(1.7*iTime);\n    \n\tvec2 yd = triangulate( rc, rd );\n    \n    vec2 ia = pd - ba*yd.x;\n    vec2 ib = ia + vec2(1,-1)*ba.yx*yd.y;\n    vec2 ic = ia - vec2(1,-1)*ba.yx*yd.y;\n    \n    float d1 = line( p, pa, pb );\n    float d2 = circ( p, pc, rc );\n    float d3 = circ( p, pd, rd );\n    float d4 = disk( p, pc, 0.03 );\n    float d5 = disk( p, pd, 0.03 );\n    float d6 = line( p, ib, ic );\n    float d7 = disk( p, ia, 0.03 );\n    float d8 = disk( p, ib, 0.03 );\n    float d9 = disk( p, ic, 0.03 );\n    \n    float d0 = triangle( p, pb+0.2*ba, pb, 0.05);\n\n        \n    \n\tvec3 col = vec3(1.0);\n\n    col *= 0.97 + 0.03*smoothstep( 0.0,40.0*px, d1 )*\n                       smoothstep( 0.0,40.0*px, d2 )*\n                       smoothstep( 0.0,40.0*px, d3 )*\n                       smoothstep( 0.0,40.0*px, d4 )*\n                       smoothstep( 0.0,40.0*px, d5 )*\n                       smoothstep( 0.0,40.0*px, d6 )*\n                       smoothstep( 0.0,40.0*px, d7 )*\n                       smoothstep( 0.0,40.0*px, d8 )*\n                       smoothstep( 0.0,40.0*px, d9 );\n    \n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep(0.0*px,3.0*px, d0 ));\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep(0.0*px,3.0*px, d1 ));\n    col = mix( col, vec3(0.9,0.0,0.0), 1.0-smoothstep(0.0*px,2.0*px, d2 ));\n    col = mix( col, vec3(0.0,0.6,0.2), 1.0-smoothstep(0.0*px,2.0*px, d3 ));\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep(3.0*px,5.0*px, d4 ));\n    col = mix( col, vec3(0.8,0.0,0.0), 1.0-smoothstep(0.0*px,2.0*px, d4 ));\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep(3.0*px,5.0*px, d5 ));\n    col = mix( col, vec3(0.0,0.6,0.2), 1.0-smoothstep(0.0*px,2.0*px, d5 ));\n    col = mix( col, vec3(0.6,0.5,0.1), 1.0-smoothstep(0.0*px,2.0*px, d6 ));\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep(3.0*px,5.0*px, d7 ));\n    col = mix( col, vec3(1.0,0.8,0.0), 1.0-smoothstep(0.0*px,2.0*px, d7 ));\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep(3.0*px,5.0*px, d8 ));\n    col = mix( col, vec3(0.6,0.5,0.1), 1.0-smoothstep(0.0*px,2.0*px, d8 ));\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0-smoothstep(3.0*px,5.0*px, d9 ));\n    col = mix( col, vec3(0.6,0.5,0.1), 1.0-smoothstep(0.0*px,2.0*px, d9 ));\n\t\n\n\n    col *= 1.0-0.1*length(p);\n    \n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}