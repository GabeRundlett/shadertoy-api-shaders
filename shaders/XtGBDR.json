{
    "Shader": {
        "info": {
            "date": "1542177823",
            "description": "Testing [url]https://www.shadertoy.com/view/MlKfzm[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "XtGBDR",
            "likes": 9,
            "name": "Test Rounded Cone Intersector",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "cone"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 816
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Testing https://www.shadertoy.com/view/MlKfzm.\n\n\nvec4 iRoundedCone( in vec3  ro, in vec3  rd, \n                   in vec3  pa, in vec3  pb, \n                   in float ra, in float rb,\n                   out float v )\n{\n    vec3  ba = pb - pa;\n\tvec3  oa = ro - pa;\n    float rr = ra - rb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(ba,oa);\n    float m2 = dot(ba,rd);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n\n    float d2 = m0 - rr*rr;\n\n    float k2 = d2    - m2*m2;\n    float k1 = d2*m3 - m1*m2 + m2*rr*ra;\n    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2.0 - m0*ra*ra;\n    \n\tfloat h = k1*k1 - k0*k2;\n\tif(h < 0.0) return vec4(-1.0);\n    float t = (-sqrt(h)-k1)/k2;\n\n    // body\n    float y = m1 - ra*rr + t*m2;\n    if( y>0.0 && y<d2 ) \n    {\n        v = y/d2;\n        return vec4(t, normalize(oa+t*rd-ba*v) );\n    }\n\n\t// base cap\n\th = m3*m3 - m5 + ra*ra;\n\tif( h>0.0 )\n    {\n        v = 0.0;\n        t = -m3 - sqrt( h );\n\t    return vec4( t, (oa+t*rd)/ra );\n    }\n    return vec4(-1.0);\n}\n\n//---------------------------------\n\n#define AA 2\n\nconst int num = 80; // make this bigger for more precision curve\n\n\nvec3 path( in float h )\n{\n    return 0.5*sin(6.2831*h*vec3(3.0,2.0,5.0)+vec3(0.0,1.0,3.0)+0.5*iTime*vec3(1.1,1.3,1.7));\n}\n\nfloat size( in float h )\n{\n    return 0.04 + 0.03*sin(6.2831*h*8.0+1.3);\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, out float h )\n{\n    vec3  oce = path(0.0);\n    float ora = size(0.0);\n    vec4 tnor = vec4(1e20);\n    float hm = 0.0;\n    for( int i=1; i<=num; i++ )\n    {\n        float h = float(i)/float(num);\n        vec3  ce = path(h);\n        float ra = size(h);\n\n        vec4 tmp; float tmpv;\n        tmp = iRoundedCone( ro, rd, oce, ce, ora, ra, tmpv );\n        if( tmp.x>0.0 && tmp.x<tnor.x ) { tnor = tmp; hm=h+tmpv/float(num); }\n\n        oce = ce;\n        ora = ra;\n    }\n\n    h = hm;\n    return tnor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.01*iTime;\n\tvec3 ro = vec3( 1.0*sin(an), 0.4, 1.0*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n        // raytrace\n        float hm;\n        vec4 tnor = intersect( ro, rd, hm );\n        float t = tnor.x;\n\n        // backround        \n        vec3 col = vec3(0.015)*(1.0-0.15*dot(p,p));\n        \n        // tubes\n        if( t<1e19 )\n        {\n            // material\n            vec3 mate = 0.5 + 0.5*cos(2.0*hm*6.2831+vec3(0.0,2.0,3.0));\n            \n            // lighting\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            const vec3 lig = vec3(0.8,0.6,0.0);\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            float kk; float sha = (intersect( pos+nor*0.001, lig, kk ).x<1e19) ? 0.0 : 1.0;\n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            \n            col = vec3(0.05,0.1,0.15)*amb + vec3(1.0,0.8,0.5)*dif*sha;\n            col *= mate;\n            col += 0.5*pow(spe,16.0)*dif*sha;\n            col += fre*fre*0.2*mate*(0.5+0.5*dif*sha);\n        }\n\t\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}