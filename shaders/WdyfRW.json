{
    "Shader": {
        "info": {
            "date": "1608928815",
            "description": "A raymarched mandelbulb with epic orbit trap coloring. If you change \"sliced\" (line 1) to 1 the mandelbulb will be sliced in half with an epic infinite zoom.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdyfRW",
            "likes": 3,
            "name": "Epic Mandelbulb",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbulb",
                "raymarcher",
                "cursed",
                "3amneverbeforeseenfootage"
            ],
            "usePreview": 0,
            "username": "CubeyTheCube",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "#define sliced 0\n#define iters 4\n#define AA 1.0\n#define gamma 1.5\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\nvec3 transform( in vec3 p, in float xrot, in float yrot, in float zrot, in vec3 pos )\n{   vec4 rot = vec4((p - pos),1.0)*rotationX(xrot)*rotationY(yrot)*rotationZ(zrot);\n    return rot.xyz;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec2 mandelbulb( in vec3 p )\n{\n    float mdist = 1e12;\n    vec3 w = p;\n    float exp = 8.0;\n    float m = dot(w,w);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<iters; i++ )\n    {\n        dz = exp*pow(sqrt(m),exp-1.0)*dz + 1.0;\n        \n        float r = length(w);\n        float b = exp*acos( w.y/r);\n        float a = exp*atan( w.x, w.z );\n        w = p + pow(r,exp) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) ); \n        mdist = min(mdist, length(w));\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n          break; \n    }\n\n    float sde = 0.25*log(m)*sqrt(m)/dz;\n    if(sliced == 1) {\n    return vec2(max(sde,-box(p-vec3(2.0,0.0,0.0),vec3(2.0,2.0,2.0))), mdist);\n    }\n    else return vec2(sde,mdist);\n}\n\n\nvec2 dist( vec3 p ) {\n    float time = sliced==1?1.:min(5.0,iTime);\n    vec2 m = mandelbulb(transform(p,-iMouse.y/time*20./iResolution.y,-iMouse.x/time*20./iResolution.x,0.0,vec3(0.0,0.0,-8.0)));\n    float trap = m.y;\n    return vec2(min(1e12,m.x),trap);\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = dist(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\nvec3 normal( in vec3 pos ) \n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           dist(pos+eps.xyy).x - dist(pos-eps.xyy).x,\n           dist(pos+eps.yxy).x - dist(pos-eps.yxy).x,\n           dist(pos+eps.yyx).x - dist(pos-eps.yyx).x ) );\n}\nvec3 color( in vec2 px, in float y )\n{\n    vec3 c = vec3(0.0, 0.0,-12.0);\n    vec3 r = normalize(vec3(px, 600));\n    vec3 k = c;\n    float t = 1.0;\n    int j;\n    for (j = 0; j<40; j++) {\n        k=c+r*t;\n        t+=dist(k).x;\n        if(!(dist(k).x>=0.01 && t<1e12)) {\n            break;\n        }\n    }\n    if (t>=1e12 || j==40) {\n        return mix(vec3(135.0, 206.0, 235.0)/255.0, vec3(1.0,1.0,1.0), y/iResolution.y);\n    }\n    float colorI = (sin(pow(dist(k).y,0.3)*6.0)+1.0)/2.0;\n    vec3 color = vec3(0.,0.,0.);\n    vec3 control[5] = vec3[5](vec3(0.0, 0.02745, 0.39216), vec3(0.125, 0.41961, 0.79608), vec3(0.92941, 1.0, 1.0), vec3(1.0, 0.66667, 0.0), vec3(0.0, 0.00784, 0.0));\n    if (colorI<0.16) {\n    color = mix(control[0], control[1], colorI/0.16);\n    } else if (colorI<0.42) {\n    color = mix(control[1], control[2], (colorI-0.16)/0.26);\n    } else if (colorI < 0.6425) {\n    color = mix(control[2], control[3], (colorI-0.42)/0.2225);\n    } else if (colorI < 0.8575) {\n    color = mix(control[3], control[4], (colorI-0.6425)/0.215);\n    } else {\n    color = mix(control[4], control[0], (colorI-0.8575)/0.1425);\n    }\n    vec3 sc = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    vec3 n = normal(k);\n    vec3 l = normalize(vec3(3.0,2.0,-10.0)-k);\n    float shade = dot(n,l)*softshadow(k,l,0.01,32.);\n    vec3 h = normalize(l-r);\n    float spec = exp(-acos(max(0.,dot(n,h)))/0.25);\n    return min(vec3(1.0,1.0,1.0), shade * sc + vec3(spec));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.,0.,0.);\n    for (float m = 0.0; m<AA; m++) {\n    for (float n = 0.0; n<AA; n++) {\n    vec2 p = fragCoord+vec2(m,n)/AA-iResolution.xy/2.0;\n    col += color(p/(sliced==1?iTime:min(iTime,1.0)), fragCoord.y);\n    }}\n    fragColor = vec4(col/(AA*AA),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}