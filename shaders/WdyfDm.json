{
    "Shader": {
        "info": {
            "date": "1607671211",
            "description": "We are a team come from Seasun in China. Our team's code is Matrix, and it's our logo.",
            "flags": 32,
            "hasliked": 0,
            "id": "WdyfDm",
            "likes": 5,
            "name": "The Logo Of Matrix Team",
            "published": 3,
            "tags": [
                "logo",
                "rainbow",
                "matrix",
                "seasun"
            ],
            "usePreview": 0,
            "username": "Ernst",
            "viewed": 561
        },
        "renderpass": [
            {
                "code": "// Bloom \n// Created by Ernst\n\nfloat Square(int x)\n{ \n    return float(x * x); \n}\n\nvec4 Bloom(vec2 fragCoord)\n{\n\tconst int   blurRadius    = 8;\n    const float blurVariance  = 0.1 * float(blurRadius * blurRadius);    \n    vec2        invResolution = 1.0 / iResolution.xy;\n    \n    vec4 sum = vec4(texture(iChannel0, fragCoord.xy * invResolution).rgb * 13.0, 13.0);\n   \n    for (int dx = -blurRadius; dx < blurRadius; dx += 2)\n    {\n        for (int dy = -blurRadius; dy < blurRadius; dy += 2) \n        {\n\t        vec3 src = texture(iChannel0, (fragCoord.xy + vec2(dx, dy) + 0.5) * invResolution).rgb;\n            float weight = exp2(-(Square(dx) + Square(dy)) / blurVariance);\n            sum += vec4(src, 1.0) * weight * 4.0;\n        }\n    }\n    \n    return vec4(pow(sum.rgb / sum.a, vec3(0.35)), 1.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = Bloom(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Draw Background : The Rain Of Numbers\n// Created by Ernst\n\nfloat SignTex(int index, vec2 uv)\n{\n    const float border = 0.2;\n \tif (uv.x >= border && uv.x <= 1.0 - border && uv.y >= border && uv.y <= 1.0 - border)\n    {\n \t\tif (index == 0)\n        {\n        \tif (abs(uv.x - 0.5) > 0.2 || abs(uv.y - 0.5) > 0.25)\n            {\n                return 1.0;\n            }\n        }\n        else if (index == 1)\n        {\n            if (abs(uv.x - 0.5) < 0.08)\n            {\n                return 1.0;\n            }\n        }\n    }\n    return 0.0;\n}\n\n\nvec4 DrawBackground(vec2 fragCoord, float randSeed, float sizeScale)\n{\n    vec4 col = vec4(0);\n    vec2 curSignSize = vec2(SIGN_WIDTH * sizeScale, SIGN_HEIGHT * sizeScale);\n    \n    vec2 curFragCoord = fragCoord;\n    vec2 originIndex = vec2(floor(curFragCoord.x / curSignSize.x), floor(curFragCoord.y / curSignSize.y));\n\n    vec2 newIndex = originIndex;\n    //Rand A Speed\n    float rand = Random(vec2(newIndex.x, randSeed), RANDOM_SEED) ;\n    curFragCoord.y += SPEED * TIME * (rand + 0.3);\n\n    //Rand Zero Or One\n    newIndex.y = floor(curFragCoord.y / (curSignSize.y));\n    float signRand = Random(vec2(newIndex.y,newIndex.x), RANDOM_SEED);\n    \n    vec2 uv = (curFragCoord - newIndex * curSignSize) / curSignSize;\n\n    //Rand The Length\n    int screenHeightCount = int(curFragCoord.y / SCREEN_HEIGHT);\n    float relativeY = curFragCoord.y - float(screenHeightCount) * SCREEN_HEIGHT;\n    float signLength = SCREEN_HEIGHT * (rand + 0.1);\n    if (relativeY < signLength)\n    {\n        float change = (1.0 - relativeY / signLength);\n        float res = SignTex(int(signRand * 10.0) % 2, uv);\n        col.g = res * change * pow((change + 0.2), 2.0);\n        if (res > 0.0)\n        {\n            float whiteColor = abs(sin(_Time.y * rand)) * pow(change, 4.0);\n            col.rb = vec2(whiteColor);\n        }\n    }\n\n    return col * float(int(originIndex.x) % 2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    //Draw Background\n    vec4 backgroundColor = DrawBackground(fragCoord, 0.0, 0.5) * 0.2;\n    backgroundColor += DrawBackground(fragCoord + vec2(SIGN_WIDTH * 0.9, 0.0), 10.0, 1.5);\n    fragColor = backgroundColor;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// GlitchWaveJitter For Background\n// Draw Team Name : MATRIX\n// Draw Company Name : TECH CENTER\n// Created by Ernst\n\n#define _WaveJitterSpeed 0.6\n#define _WaveJitterDuration 1.0\n#define _WaveJitterDensity 0.001\n#define _WaveJitterRGBSplit 0.0\n#define _WaveJitterFading 0.5\n#define _GlitchEllipseData vec4(0.0, 1.0, 0.0, 1.0)\n#define _IsUseGlitchEllipseData 0.0\n#define _UseShake 1.0\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 ivec2(UI0, UI1)\n#define UI3 ivec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n#define SS(a, b, x) (smoothstep(a, b, x) * smoothstep(b, a, x))\n\nfloat GetEllipseValue(vec2 uv, vec4 ellipseData)\n{\n    vec2 center = vec2(0.5f, 0.5f);\n    vec2 p2c = 2.0 * (uv - center);\n    float distance = length(p2c);\n\n    float insideValue = ellipseData.z;\n    float outsideValue = ellipseData.w;\n    float power = (distance - ellipseData.x) / (ellipseData.y - ellipseData.x);\n    return mix(insideValue, outsideValue, clamp(power, 0.0, 1.0));\n}\n\nfloat RandomNoise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\nvec3 Hash33(vec3 p)\n{\n    ivec3 q = ivec3(ivec3(p)) * UI3;\n    q = (q.x ^ q.y ^ q.z) * UI3;\n    return -1. + 2. * vec3(q) * UIF;\n}\n\nfloat Gnoise(vec3 x)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    // gradients\n    vec3 ga = Hash33(p + vec3(0., 0., 0.));\n    vec3 gb = Hash33(p + vec3(1., 0., 0.));\n    vec3 gc = Hash33(p + vec3(0., 1., 0.));\n    vec3 gd = Hash33(p + vec3(1., 1., 0.));\n    vec3 ge = Hash33(p + vec3(0., 0., 1.));\n    vec3 gf = Hash33(p + vec3(1., 0., 1.));\n    vec3 gg = Hash33(p + vec3(0., 1., 1.));\n    vec3 gh = Hash33(p + vec3(1., 1., 1.));\n\n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\n    // interpolation\n    float Gnoise = va + u.x * (vb - va) +\n        u.y * (vc - va) +\n        u.z * (ve - va) +\n        u.x * u.y * (va - vb - vc + vd) +\n        u.y * u.z * (va - vc - ve + vg) +\n        u.z * u.x * (va - vb - ve + vf) +\n        u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n\n    return 2. * Gnoise;\n}\n\nvec2 uvR;\nvec2 uvG;\nvec2 uvB;\nvec2 uvDefault;\n\nvec4 CopyScreen(vec2 uv)\n{\n    uvDefault = uvR = uvB = uvG = uv;\n    return vec4(texture(iChannel0, uv).xyz, 1.0);\n}\n\nvec4 GlitchWaveJitter(in vec4 color, in vec2 uv)\n{\n    float time = _Time.y * _WaveJitterSpeed;\n    float distortionAmount = SS(_WaveJitterDuration * 0.001, _WaveJitterDuration * 0.5, mod(time, _WaveJitterDuration));\n\n\tfloat uvy = uvDefault.y * uv.y * _WaveJitterDensity;\n    float distortion = Gnoise(vec3(0.0, uvy * 1.0, time * 500.00)) * (distortionAmount * 3.0 + 0.05);\n    distortion *= Gnoise(vec3(0.0, uvy * 2.0, time * 250.0)) * (distortionAmount * 2.0 + 0.025) * _UseShake;\n    distortion += smoothstep(0.999, 1.0, sin((uvDefault.y + time * 1.6) * 2.)) * 0.02;\n    distortion -= smoothstep(0.999, 1.0, sin((uvDefault.y + time) * 2.0)) * 0.02;\n    distortion += smoothstep(0.999, 1.0, sin((uvDefault.y + time * 1.2) * 2.)) * 0.02;\n    distortion -= smoothstep(0.999, 1.0, sin((uvDefault.y + time) * 0.8)) * 0.02;\n    \n    vec2 uvShift = vec2(distortion, 0);\n\n    uvR += uvShift * (0.5 + _WaveJitterRGBSplit * uvShift * RandomNoise(vec2(5, _Time.x)));\n    uvG += uvShift * (0.5 + _WaveJitterRGBSplit * uvShift * RandomNoise(vec2(7, _Time.x)));\n    uvB += uvShift * (0.5 + _WaveJitterRGBSplit * uvShift * RandomNoise(vec2(13, _Time.x)));\n\n    vec4 colorR = vec4(texture(iChannel0, uvR).xyz, 1.0);\n    vec4 colorG = vec4(texture(iChannel0, uvG).xyz, 1.0);\n    vec4 colorB = vec4(texture(iChannel0, uvB).xyz, 1.0);\n\n    vec4 finalColor = vec4(vec3(colorR.x, colorG.y, colorB.z), 1);\n    float power = mix(_WaveJitterFading, _WaveJitterFading * GetEllipseValue(uv, _GlitchEllipseData), step(0.5, _IsUseGlitchEllipseData));\n\n    finalColor = mix(color, finalColor, power);\n\n    return finalColor;\n}\n\nvec4 DrawTeamName(float charWidth, float splitWidth, vec2 startCoord, vec2 fragCoord)\n{\n\tvec4 col = vec4(0);\n    vec2 charSize = vec2(charWidth + splitWidth, (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y);\n    vec2 uv = (fragCoord - startCoord) / charSize;\n    bool bounds = all(greaterThanEqual(uv, vec2(0)));\n    bounds = bounds && all(lessThan(uv, vec2(6.0, 1.0)));\n    if (bounds)\n    {\n        vec2 printCharSize = CHAR_SIZE;\n        highp int index = int(floor(uv.x));\n        int charCode = 0;\n        if (index == 0)\n        {\n        \t//charCode = ch_m;\n            charCode = 18732593;\n            printCharSize = vec2(5.0, 5.0);\n        }\n        else if (index == 1)\n        {\n        \tcharCode = ch_a;\n        }\n        else if (index == 2)\n        {\n        \tcharCode = ch_t;\n        }\n        else if (index == 3)\n        {\n        \tcharCode = ch_r;\n        }\n        else if (index == 4)\n        {\n        \tcharCode = ch_i;\n        }\n        else if (index == 5)\n        {\n        \tcharCode = ch_x;\n        }\n        uv = fract(uv);\n        uv.x *= 1.0 + splitWidth / charWidth;\n        col += Char(charCode, uv, printCharSize);\n    }\n    return col;\n}\n\nvec4 DrawDate(float charWidth, float splitWidth, vec2 startCoord, vec2 fragCoord)\n{\n\tvec4 col = vec4(0);\n    vec2 charSize = vec2(charWidth + splitWidth, (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y);\n    vec2 uv = (fragCoord - startCoord) / charSize;\n    bool bounds = all(greaterThanEqual(uv, vec2(0)));\n    bounds = bounds && all(lessThan(uv, vec2(8.0, 1.0)));\n    if (bounds)\n    {\n        highp int index = int(floor(uv.x));\n        int charCode = 0;\n        if (index == 0)\n        {\n        \tcharCode = ch_2;\n        }\n        else if (index == 1)\n        {\n        \tcharCode = ch_0;\n        }\n        else if (index == 2)\n        {\n        \tcharCode = ch_1;\n        }\n        else if (index == 3)\n        {\n        \tcharCode = ch_9;\n        }\n        else if (index == 4)\n        {\n        \tcharCode = ch_0;\n        }\n        else if (index == 5)\n        {\n        \tcharCode = ch_9;\n        }\n        else if (index == 6)\n        {\n        \tcharCode = ch_0;\n        }\n        else if (index == 7)\n        {\n        \tcharCode = ch_4;\n        }\n        uv = fract(uv);\n        uv.x *= 1.0 + splitWidth / charWidth;\n        col += Char(charCode, uv, CHAR_SIZE);\n    }\n    return col;\n}\n\nvec4 DrawCompany(float charWidth, float splitWidth, vec2 startCoord, vec2 fragCoord)\n{\n\tvec4 col = vec4(0);\n    vec2 charSize = vec2(charWidth + splitWidth, (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y);\n    vec2 uv = (fragCoord - startCoord) / charSize;\n    bool bounds = all(greaterThanEqual(uv, vec2(0)));\n    bounds = bounds && all(lessThan(uv, vec2(12.0, 1.0)));\n    if (bounds)\n    {\n        highp int index = int(floor(uv.x));\n        int charCode = 0;\n        if (index == 0)\n        {\n        \tcharCode = ch_t;\n        }\n        else if (index == 1)\n        {\n        \tcharCode = ch_e;\n        }\n        else if (index == 2)\n        {\n        \tcharCode = ch_c;\n        }\n        else if (index == 3)\n        {\n        \tcharCode = ch_h;\n        }\n        else if (index == 4)\n        {\n        \tcharCode = ch_sp;\n        }\n        else if (index == 5)\n        {\n        \tcharCode = ch_c;\n        }\n        else if (index == 6)\n        {\n        \tcharCode = ch_e;\n        }\n        else if (index == 7)\n        {\n        \tcharCode = ch_n;\n        }\n        else if (index == 8)\n        {\n        \tcharCode = ch_t;\n        }\n        else if (index == 9)\n        {\n        \tcharCode = ch_e;\n        }\n        else if (index == 10)\n        {\n        \tcharCode = ch_r;\n        }\n        uv = fract(uv);\n        uv.x *= 1.0 + splitWidth / charWidth;\n        col += Char(charCode, uv, CHAR_SIZE);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = CopyScreen(uv);\n    color = GlitchWaveJitter(color, uv);   \n    fragColor = color;\n    \n    vec4 backgroundColor = color;\n    vec4 dampingGroundcolor = backgroundColor;\n    const float size = 0.35;\n    if (uv.x < 1.0 - size)\n   \t{\n      float damping = pow(uv.x / (1.0 - size), 12.0);\n      dampingGroundcolor *= damping;\n    }\n    \n    //Draw Team Name : MATRIX\n    float charWidth = SCREEN_WIDTH / 14.0;\n    float charHeight = (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y;\n    float charSplit = charWidth / 6.0;\n    vec4 teamNameColor = DrawTeamName(charWidth, charSplit, vec2(charWidth * 1.5, (SCREEN_HEIGHT - charHeight) / 2.0), fragCoord);\n    \n    //Draw Company Name : TECH CENTER\n    charWidth = SCREEN_WIDTH / 50.0;\n    charHeight = (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y;\n    charSplit = charWidth / 6.0;\n    vec4 companyColor = DrawCompany(charWidth, charSplit, vec2(SCREEN_WIDTH - charWidth * (3.0 + 12.0), charHeight * 0.8), fragCoord);\n    \n    //Draw Date : 20190904\n    charWidth = SCREEN_WIDTH / 80.0;\n    charHeight = (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y;\n    charSplit = charWidth / 6.0;\n    vec4 dateColor = DrawDate(charWidth, charSplit, vec2(charWidth * 4.0, charHeight * 1.0), fragCoord);\n    dateColor *= vec4(0.1, 0.2, 0.3, 1.0);\n    \n    uv = fragCoord.xy / iResolution.xy;\n\n    fragColor = dampingGroundcolor;\n    fragColor += vec4(0.8, 0.5, 0.1, 1) * teamNameColor * 0.35 + backgroundColor * teamNameColor;\n    fragColor += companyColor;\n    fragColor += dateColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Common GLSL\n// Created by Ernst\n\n/* --------------------------------------------- */\n/* Control Macros */\n#define TIME (iTime + 100.0)\n#define _Time vec4((TIME / 20.0), TIME, (TIME * 2.0), (TIME * 3.0))\n\n#define PI2 6.28318530718\n#define PI 3.1416\n\n#define SCREEN_WIDTH iResolution.x\n#define SCREEN_HEIGHT iResolution.y\n#define RANDOM_SEED 10.0\n#define SPEED 200.0\n#define SIGN_WIDTH 15.0\n#define SIGN_HEIGHT (SIGN_WIDTH * 2.0)\n#define SIGN_SIZE vec2(SIGN_WIDTH, SIGN_HEIGHT)\n#define SIGN_HEIGHT_NUMBER (SCREEN_HEIGHT / SIGN_HEIGHT)\n\n#define Deg2Rad 0.01745329\n#define Rad2Deg 57.29578\n\n/* --------------------------------------------- */\n/* Common Function */\n\nfloat Random (vec2 st, float n) \n{\n \tst = floor(st * n);\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n/* --------------------------------------------- */\n/* Print Character */\n\n#define CHAR_SIZE vec2(3.0, 7.0)\n\n/*M\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n â–ˆ         010    \nâ–ˆ â–ˆ      101    \nâ–ˆ â–ˆ      101    \nâ–ˆâ–ˆâ–ˆ -> 111 -> 010 101 101 111 101 101 101 -> 712557\nâ–ˆ â–ˆ      101    \nâ–ˆ â–ˆ      101    \nâ–ˆ â–ˆ      101    \n*/\n\n//Automatically generated from a sprite sheet.\nint ch_sp = 0;\nint ch_a = 712557;\nint ch_b = 1760622;\nint ch_c = 706858;\nint ch_d = 1760110;\nint ch_e = 2018607;\nint ch_f = 2018596;\nint ch_g = 706922;\nint ch_h = 1498989;\nint ch_i = 1909911;\nint ch_j = 1872746;\nint ch_k = 1498477;\nint ch_l = 1198375;\nint ch_m = 1571693;\nint ch_n = 1760109;\nint ch_o = 711530;\nint ch_p = 711972;\nint ch_q = 711675;\nint ch_r = 1760621;\nint ch_s = 2018927;\nint ch_t = 1909906;\nint ch_u = 1497963;\nint ch_v = 1497938;\nint ch_w = 1498109;\nint ch_x = 1496429;\nint ch_y = 1496210;\nint ch_z = 2004271;\nint ch_1 = 730263;\nint ch_2 = 693543;\nint ch_3 = 693354;\nint ch_4 = 1496649;\nint ch_5 = 1985614;\nint ch_6 = 707946;\nint ch_7 = 1873042;\nint ch_8 = 709994;\nint ch_9 = 710250;\nint ch_0 = 711530;\nint ch_per = 2;\nint ch_que = 693378;\nint ch_exc = 599170;\nint ch_com = 10;\nint ch_scl = 65556;\nint ch_col = 65552;\nint ch_usc = 7;\nint ch_crs = 11904;\nint ch_dsh = 3584;\nint ch_ast = 21824;\nint ch_fsl = 304292;\nint ch_bsl = 1189001;\nint ch_lpr = 346385;\nint ch_rpr = 1118804;\nint ch_lba = 862355;\nint ch_rpa = 1647254;\n\n\n//Extracts bit b from the given number.\nfloat Extract_bit(int n, ivec2 bitSize, float b)\n{\n\t//return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n    int index = int(floor(b));\n    int size = bitSize.x * bitSize.y;\n    \n    return (n & ((1 << (size - 1)) >> index)) > 0 ? 1.0 : 0.0;\n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat Sprite(int spr, vec2 uv, vec2 bitSize)\n{\n    vec2 charSize = bitSize;\n    uv = 1.0 - uv;\n\tuv *= charSize;\n    uv = floor(uv);\n   \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (charSize.x - uv.x - 1.0) + uv.y * charSize.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,charSize));\n    \n    return bounds ? Extract_bit(spr, ivec2(bitSize), bit) : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat Char(int ch, vec2 uv, vec2 bitSize)\n{\n    float px = Sprite(ch, uv, bitSize);\n    return px;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Distort Effect\n// Created by Ernst\n\n#define Distortion_Center vec2(0.0, 0.0);\n#define Distortion_Multiplier vec2(1.0, 1.0);\n#define Distortion_Intensity 0.3\n#define Distortion_Scale 0.4\n\nfloat rcp(float value)\n{\n    return 1.0 / value;\n}\n\nvec2 DistortUV(vec2 uv)\n{\n    float amount = 1.6 * max(abs(Distortion_Intensity * 100.0), 1.0);\n    float theta = Deg2Rad * min(160.0, amount);\n    float sigma = 2.0 * tan(theta * 0.5);\n    \n    vec2 DistCenter = 2.0 * Distortion_Center - vec2(1.0, 1.0);\n    vec2 DistAxis = Distortion_Multiplier;\n    float DistTheta = Distortion_Intensity;\n    float DistSigma = sigma;\n    float DistScale = 1.0 / Distortion_Scale;\n    float DistIntensity = Distortion_Intensity * 100.0;\n    \n    uv = (uv - 0.5) * DistScale + 0.5;\n    vec2 ruv = DistAxis * (uv - 0.5 - DistCenter);\n    float ru = length(vec2(ruv));\n\n    if (DistIntensity > 0.0)\n    {\n        float wu = ru * DistTheta;\n        ru = tan(wu) * (rcp(ru * DistSigma));\n        uv = uv + ruv * (ru - 1.0);\n    }\n    else\n    {\n        ru = rcp(ru) * DistTheta * atan(ru * DistSigma);\n        uv = uv + ruv * (ru - 1.0);\n    }\n\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvDistorted = DistortUV(uv);\n    fragColor = vec4(texture(iChannel0, uvDistorted).xyz, 1.0); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}