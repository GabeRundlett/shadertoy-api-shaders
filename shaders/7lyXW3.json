{
    "Shader": {
        "info": {
            "date": "1641422717",
            "description": "The way the transitions happen is definitly inspired by the Synesthesia app which I tried a few months ago. Synesthesia is super powerful for exploring shader variations that exist in your code. Here I have it set up so you can draw the variation in.",
            "flags": 32,
            "hasliked": 0,
            "id": "7lyXW3",
            "likes": 11,
            "name": "FBM [ UI ]",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "fbm",
                "color",
                "ui",
                "util"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "float circle(vec2 p, float r, float sf)\n{    \n    return 1.0-smoothstep(r-EPS*sf, r+EPS*sf, length(p));\n}\n\n//for gold rim texture\nfloat SIN(vec2 p, float r)\n{\n    float c = length(p);\n    return abs(sin(c*50./r))*(1.0-smoothstep(r-EPS, r+EPS,c));\n}\nvec3 drawFancyCircle(vec3 col, \n                     vec2 uv,\n                     vec2 pos, \n                     float r){\n                     \n    vec2 light = vec2(1.);\n    float scale = 0.6/r;\n    vec3 tx1 = vec3(texture(iChannel1, \n    (pos)/r/2.)).rgb+0.;\n    \n    //super hacky texture call to lighting that allows\n    //me to shift the texture by the circle\n    //position, scale it by the texture radius,\n    //adjust aspect ratio, and ajust the center again\n    vec3 tx0 = vec3(texture(iChannel0, \n    ((pos)*scale*rot(iTime))*vec2(iResolution.y/iResolution.x,1.)+0.5\n    )).rgb;\n    \n    vec2 lightDir = normalize(light - max(pos,EPS));\n    //shadow circle\n    col = mix(col, vec3(0.0), circle(pos-lightDir*0.1*r,r,20.));\n    //rim lighting circle\n    col = mix(col, gold+dot(pos,-lightDir), circle(pos, r,1.));\n    //gold outer circle\n   // col = mix(col, gold-tx1.x+0.2, circle(pos, r*0.97, 1.));\n    //sin gradient on outer circle\n    col-=SIN(uv-pos,r)/4.;\n    //black inner circle\n    col = mix(col, vec3(0.1), circle(pos, r*0.7, 5.));\n    //grey center circle\n    col = mix(col, tx0, circle(uv-pos,r*0.6, 1.)); \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    float asp = iResolution.y/iResolution.x;\n    // Time varying pixel color\n    vec3 col = load0(fragCoord).rgb;\n\n    // Output to screen\n    vec2 st = uv*UV_SCALE;\n    vec2 flST = floor(st);\n    vec2 frST = fract(st)-0.5;\n    //col += flST.y/8.;\n    float border = smoothstep(0.47,0.5, abs(frST.y));\n    col += border;\n    vec2 dotPos = vec2(uv.x*UV_SCALE,frST.y) -\n    vec2(load1(vec2(flST.y+0.5,1.5)).x,0.)*UV_SCALE/asp;\n    \n    float c = smoothstep(0.22,0.2,length(dotPos));\n    col += c;\n    col = drawFancyCircle(col, \n                    uv/100., \n                    dotPos,\n                    0.4);\n        \n    if(floor((iMouse.y/iResolution.y)*UV_SCALE) == flST.y){\n        col += vec3(0.5,0.,0.);\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//return a cleared vector for the game state \nvec4 clear(){\n    return vec4(0.,0.,0.,1.);\n}\n\n//return all components of a new animation\nvec4 getNewAnimation(){\n                //time,frame,holding,clear\n    return vec4(iTime,iFrame,0.,0.);\n}\n\n//return all components of the current animation\nvec4 getGameState(){\n    return load0(GAME_STATE_ADDRESS);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    if(iFrame < 1){\n    //initialize\n    \n        if(fragCoord == GAME_STATE_ADDRESS){\n            fragColor = getNewAnimation();\n        }\n        else if(fragCoord.x < NUMBER_OF_VARIABLES){\n            //set position\n            if(fragCoord.y == 0.5){\n                fragColor = vec4(vec3(rnd(fragCoord.x)),1.);\n            }\n            if(fragCoord.y == 1.5){\n                fragColor = vec4(vec3(rnd(fragCoord.x)),1.);\n            }\n        }\n    }\n    \n    else{\n    //update\n    \n        vec4 gameState = getGameState();\n        float startTime = gameState.x;\n        float frameNum = gameState.y;\n        float cleared = gameState.w;\n        //if we are at the game State Adress\n        if(fragCoord == GAME_STATE_ADDRESS){ \n\n                if(cleared == 1.){\n                    fragColor = getNewAnimation();\n                }\n                else if((iTime - startTime) > DURATION){\n                    fragColor.w = 1.;//clear();\n                }\n                else{\n                    fragColor = gameState;\n                }\n            }\n\n        else if(fragCoord.x < NUMBER_OF_VARIABLES){\n            \n            if(cleared == 1.){\n                if(fragCoord.y == 0.5){\n                        fragColor = mix(load0(fragCoord.xy),\n                                     vec4(vec3(load0(fragCoord.xy)),1.),0.02);\n                        }\n                if(fragCoord.y == 1.5){\n                        fragColor = vec4(vec3(load0(fragCoord.xy)),1.);\n                    }\n                }\n                else{\n                   \n                    vec2 uv = fragCoord/iResolution.y;\n                    vec2 st = uv*UV_SCALE;\n                    vec2 flST = floor(st);\n                    vec2 frST = fract(st)-0.5;\n                    vec2 m = iMouse.xy/iResolution.xy;\n                    vec2 flM = floor(m*UV_SCALE);\n                    vec2 frM = fract(m);\n                    \n                    if(fragCoord.y == 1.5){\n                        if(iMouse.z > 0.5 && flM.y+0.5 == fragCoord.x){\n                                fragColor = vec4(vec3(frM.x),1.);\n                            \n                        }     \n                        else{\n                            fragColor = load0(fragCoord.xy);\n                        }\n                    }\n                    else if(fragCoord.y == 0.5){\n                        fragColor = mix(load0(fragCoord.xy),\n                                    vec4(vec3(load0((fragCoord.xy+vec2(0.,1.) ))),1.),0.02);;\n                    }\n                }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define load0(ADDRESS) texture(iChannel0,ADDRESS/iResolution.xy)\n#define load1(ADDRESS) texture(iChannel1,ADDRESS/iResolution.xy)\n#define PI acos(-1.)\n#define DURATION 2.\n#define EPS 0.01\n#define NUMBER_OF_VARIABLES 12.\n#define GAME_STATE_ADDRESS vec2(NUMBER_OF_VARIABLES+5.5,0.5)\n\n#define _f1 load0(vec2(0.5,0.5)).x\n#define _f2 load0(vec2(1.5,0.5)).x\n#define _f3 load0(vec2(2.5,0.5)).x\n#define _f4 load0(vec2(3.5,0.5)).x\n#define _f5 load0(vec2(4.5,0.5)).x\n#define _f6 load0(vec2(5.5,0.5)).x\n#define _f7 load0(vec2(6.5,0.5)).x\n#define _f8 load0(vec2(7.5,0.5)).x\n#define _f9 load0(vec2(8.5,0.5)).x\n#define _f10 load0(vec2(9.5,0.5)).x\n#define _f11 load0(vec2(10.5,0.5)).x\n#define _f12 load0(vec2(11.5,0.5)).x\n#define _f13 load0(vec2(12.5,0.5)).x\n\n#define UV_SCALE 12.\n#define gold vec3(215., 254., 256.)/255.\nfloat rnd(float a){\n    return fract(sin(a)*45960.24562);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n\n\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*4254.);  \n}\n\n\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nfloat fbm(vec2 st, float N, float rt){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      //st.x += iTime;\n  }\n  return ret;\n  \n}\n\nfloat voronoi(vec2 uv){\n  \n    float d = 100.;\n    vec2 uvFL = floor(uv);\n    vec2 uvFR = fract(uv);\n  \n    for(float i = -1.; i <= 1.; i++){\n      for(float j = -1.; j <= 1.; j++){\n      \n        vec2 nachbar = vec2(i,j);\n        d = min(d, length( uvFR - noise(uvFL + nachbar)  - nachbar));\n      }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = vec4(0.,0.,0.,1.);\n  vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n  \n  uv*= clamp(_f11,0.5,1.)*2.;\n  uv.x+=_f12*2.;\n  uv.y+=_f13*1.;\n  vec3 col = vec3(0.0);\n  \n  float fa1 = smoothstep(0.2, 0.9,\n              abs( fract(fbm(uv + length(uv)*_f1*.5,5., 2.)*_f2*2.)-0.5) );\n  //float fa1 = smoothstep(0.2, 0.9,\n             // abs( fract(fbm(uv + length(uv)*0.5,5., 2.)*2.)-0.5) );\n  \n  float fb1 = fbm(uv*_f3*2. + vec2(3. ,3. ) ,5., 5.);\n  \n\n  \n  float fb2 = fbm(uv*_f4*3.+ fa1/(_f5*5.) ,4., 3.);\n    //float fb2 = fbm(uv*3.+ fa1/5. ,4., 3.);\n\n    float fb3 = fbm(uv*_f6*1.*rot(_f7) + vec2(1. ,47. ) + fb2*_f8*.5 , 3., 2.);\n   \n   \n    float fb3b = fbm(uv*_f9*2. + fb1*_f10*2. + vec2(sin(uv.x/4.),0.), 2., 2.);\n    float fb3c = fbm(uv + fb1*2. + vec2(3.), 4., 2.);\n\n    col = mix(col, vec3(0.,1.,1.),pow(fb3*1.1, 5.));\n    \n    col = mix(col, vec3(atan(vec2(uv.x,uv.y+0.4))*.8, 0.), pow(fb3,1.6));\n    //col = mix(col, vec3(0.,sin(uv.y),0.9), pow(fb2, 15.));\n    col = mix(col, vec3(0.,0.,0.),fa1*.9);    \n    col *= 1.5;\n    \n   \n    col = sin(vec3(1.,2.,9.)/80. + col + 6.1);\n    //col = mix(vec3(1.,0.,0.), vec3(1.), clamp(col*3.,0.,1.));\n    col = mix(col, vec3(.0,0.0,0.2),voronoi(uv*3.))*1.;\n    float dasBit = pow(dot(normalize(vec3(1.)),normalize(vec3(uv,1.))),9.);\n    col = mix(col, vec3(.9,0.9,0.9),pow(fb2,5.))*1.3 +dasBit;  \n    \n    //col = mix(col, vec3(.9, .0 ,1.), );\n    \n    col = mix(col, vec3(4.3), pow(fb3b, 4.) );\n    col = mix(col, vec3(2.,6.,9.)*.1, pow(fb3c, 4.) );\n    //col = mix(col, vec3(0.9,0.4,0.)*1., pow(fb3, 7.) );\n    \n    //when I use Flux it's this: \n    //fragColor = vec4(col*vec3(0.9,0.8,.4),1.0); //lol\n    //but that is actually only there because I forgot flux the first time lol\n    col *= 1.4;\n    //col =pow(col,vec3(1.,0.9, 1.));\n    fragColor = vec4(col*vec3(0.8,0.65,.2),1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}