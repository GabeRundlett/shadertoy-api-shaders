{
    "Shader": {
        "info": {
            "date": "1587452409",
            "description": "This uses Linearly Transformed Cosines for the lighting because it's really fast. Didn't turn out as well as i hoped it'll be tho but ehh.",
            "flags": 33,
            "hasliked": 0,
            "id": "tsjyDG",
            "likes": 22,
            "name": "Spiral Glow Cube",
            "published": 3,
            "tags": [
                "raytracing",
                "cube",
                "fog",
                "shadows",
                "diffuse",
                "vr",
                "webvr",
                "ltc"
            ],
            "usePreview": 1,
            "username": "JuliaPoo",
            "viewed": 948
        },
        "renderpass": [
            {
                "code": "// LTC code modified from EvilRyu by JuliaPoo\n// \t\thttps://www.shadertoy.com/view/4tBBDK\n// Distance functions and softshadow are from inigo quilez\n// \t\thttps://iquilezles.org/articles/rmshadows\n//\t\thttps://iquilezles.org/articles/distfunctions\n\n\n// ###############################\n// ### STRUCTS and other stuff ###\n// ###############################\n\n#define LIGHT_WIDTH 1.\n#define CEIL_HEIGHT 20.\n#define N_LIGHTS 7\n#define END 50.\n\n#define TSCALE 0.5\n\n#define TAO 6.2831853\n#define PI 3.14159\n\n#define UNDEFINED_ID -1\n#define LIGHT_ID 0\n#define CURTAIN_ID 1\n#define FLOOR_ID 2\n\n#define LUTSIZE  8.0\n#define MATRIX_PARAM_OFFSET 8.0\n\n#define ep 0.005\n\nstruct CAM {\n    vec3 lookat;\n    vec3 ro;\n\n    vec3 forw;\n    vec3 up;\n    vec3 right;\n    \n    float field;\n};\n    \nstruct RAY {\n\tvec3 ro;       \n    vec3 rd;\n};\n\n/*\nstruct PETAL {\n    float curve1;\n    float curve2;\n    float curve3;\n    float curve4;\n    float curve5;\n    float wide;\n    float bound;\n    float opt;\n};\n*/    \n\nmat2 rot(float a)\n{\n    float c0 = cos(a);\n    float s0 = sin(a);\n    return mat2(\n        c0,-s0,\n        s0, c0\n    );\n}\n\nstruct LIGHT {\n    vec3 points[4];\n    vec3 col;\n    vec3 pos;\n};\n    \nint OBJ_ID = UNDEFINED_ID;\nLIGHT all_light[N_LIGHTS];\nCAM camera;\nfloat LDIST[N_LIGHTS-1] = float[N_LIGHTS-1](END, END, END, END, END, END);\nbool is_belowfloor = false;\n\n// #############\n// ### SCENE ###\n// #############\n\n// --- Useful Funcs ---\n    \nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n    \n/* well i dont need them for now so\n\nfloat ssub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sint( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n*/\n\n// --- PRIMITIVES ---   \n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  //p.y -= clamp( p.y, 0.0, h );\n  return length( p.xz ) - r;\n}\n\n// --- Actual shapes ---\n\nfloat sdLightCube(vec3 P)\n{\n    vec3 p = P;\n    p.yz *= rot(-TSCALE*iTime*3.);\n    p.xy *= rot(-TSCALE*iTime);\n    \n    float d = sdBox(p, vec3(LIGHT_WIDTH));\n    return d;\n}\n\nfloat sdLight(vec3 P)\n{\n    float d = min(sdLightCube(P), abs(P.y - CEIL_HEIGHT));\n    return d;\n}\n\nfloat sdRods(vec3 p, float m, float thc)\n{\n    \n    float ang = TAO/m;\n    float a = mod(atan(p.z,p.x), ang) - ang/2.;\n    p.y /= 2.;\n    p.xz = vec2(length(p.xz), 0.) * rot(a);\n    p.y += 3.;\n    p.x += cos(p.y)*3.;\n\tfloat d = sdVerticalCapsule(p, 6., thc);\n    \n    return d*.4;\n}\n\nfloat sdCurtain(vec3 P)\n{\n    \n    float clamp1 = length(P) - 3.5;\n    if (clamp1 > 0.) return clamp1+ep;\n    //float clamp2 = length(P) - 2.;\n    //if (clamp2 < 0.) return END;\n    \n    vec3 p = P;\n    \n    p.yz *= rot(sin(TSCALE*iTime*.7)/4.);\n    float s = sin(TSCALE*iTime) + TSCALE*iTime;\n    p.xz *= rot(s);\n    \n    p.xz *= rot(cos(p.y));\n    float d = sdRods(p, 20., .03);\n    d = smin(d, sdRods(p, 12.36, .05), .1);\n    //d = smin(d, sdRods(p, 7.63, .07), .07);\n    //d = smin(d, sdRods(p, 4.72, .1), .05);\n    \n    return d;\n}\n\nfloat sdFloor(vec3 P)\n{\n    float a = P.y + 3.1;\n    if (abs(a) > .05) return abs(a);\n    return abs(a + texture(iChannel1, P.xz/10.).x*.04)*.8;\n}\n\nfloat sdScene(vec3 P)\n{\n    \n   \tfloat d0 = sdLight(P);\n    float d1 = sdCurtain(P);\n    float d2 = sdFloor(P);\n    \n    float d = d0;\n    OBJ_ID = LIGHT_ID;\n    \n    if (d > d1)\n    {\n        d = d1;\n        OBJ_ID = CURTAIN_ID;\n    }\n    \n    if (d > d2 && !is_belowfloor)\n    {\n        d = d2;\n        OBJ_ID = FLOOR_ID;\n    }\n    \n    return d;\n}\n\n// #################\n// ### RENDERING ###\n// #################\n\n// --- Camera ---\n\nvoid InitCamera(inout CAM c)\n{\n    vec2 M = (iMouse.xy/iResolution.xy - 0.5) * PI;\n    if (length(iMouse.xy) < ep) M = vec2(0., .3);\n    \n    // x,y,z = right, up, forw\n    c.lookat = vec3(0., .5, 0.);\n    \n    c.ro = vec3(0., 0., 9.);\n    c.ro.yz *= rot(M.y);\n    c.ro.xz *= rot(M.x);\n    \n    c.forw = normalize(c.lookat - c.ro);\n    c.right = normalize(cross(c.forw, vec3(0.0, 1.0, 0.0)));\n    c.up = normalize(cross(c.right, c.forw));\n    c.field = 2.;\n}\n\nvoid InitRay(inout RAY r, CAM c, vec2 uv)\n{\n    r.rd = normalize(uv.x*c.right + uv.y*c.up + c.field*c.forw);\n    r.ro = c.ro;\n}\n\nvoid InitLight(inout LIGHT all_light[N_LIGHTS])\n{\n    // These was a pain to type\n    \n    vec3 p0 = vec3( LIGHT_WIDTH, LIGHT_WIDTH, LIGHT_WIDTH);\n    vec3 p1 = vec3(-LIGHT_WIDTH, LIGHT_WIDTH, LIGHT_WIDTH);\n    vec3 p2 = vec3( LIGHT_WIDTH,-LIGHT_WIDTH, LIGHT_WIDTH);\n    vec3 p3 = vec3(-LIGHT_WIDTH,-LIGHT_WIDTH, LIGHT_WIDTH);\n    vec3 p4 = vec3( LIGHT_WIDTH, LIGHT_WIDTH,-LIGHT_WIDTH);\n    vec3 p5 = vec3(-LIGHT_WIDTH, LIGHT_WIDTH,-LIGHT_WIDTH);\n    vec3 p6 = vec3( LIGHT_WIDTH,-LIGHT_WIDTH,-LIGHT_WIDTH);\n    vec3 p7 = vec3(-LIGHT_WIDTH,-LIGHT_WIDTH,-LIGHT_WIDTH);\n    \n    vec3 pp0 = vec3( 0.,-LIGHT_WIDTH, 0.);\n    vec3 pp1 = vec3(-LIGHT_WIDTH, 0., 0.);\n    vec3 pp2 = vec3( 0., 0.,-LIGHT_WIDTH);\n    vec3 pp3 = vec3( 0., 0., LIGHT_WIDTH);\n    vec3 pp4 = vec3( LIGHT_WIDTH, 0., 0.);\n    vec3 pp5 = vec3( 0., LIGHT_WIDTH, 0.);\n    \n    mat2 m1 = rot(TSCALE*iTime);\n    mat2 m2 = rot(TSCALE*iTime*3.);\n    p0.xy *= m1; p0.yz *= m2;\n    p1.xy *= m1; p1.yz *= m2;\n    p2.xy *= m1; p2.yz *= m2;\n    p3.xy *= m1; p3.yz *= m2;\n    p4.xy *= m1; p4.yz *= m2;\n    p5.xy *= m1; p5.yz *= m2;\n    p6.xy *= m1; p6.yz *= m2; \n    p7.xy *= m1; p7.yz *= m2;\n    \n    pp0.xy *= m1; pp0.yz *= m2;\n    pp1.xy *= m1; pp1.yz *= m2;\n    pp2.yz *= m2;\n    pp3.yz *= m2;\n    pp4.xy *= m1; pp4.yz *= m2;\n    pp5.xy *= m1; pp5.yz *= m2;\n    \n    vec3 c = vec3(CEIL_HEIGHT, 10., -10.);\n    \n    all_light = LIGHT[N_LIGHTS](\n        \n        LIGHT(vec3[4](p0, p1, p5, p4), vec3(1., .5, .6), pp5),\n        LIGHT(vec3[4](p1, p0, p2, p3), vec3(.4, 1., .6), pp3),\n        LIGHT(vec3[4](p0, p4, p6, p2), vec3(.3, .4, 1.), pp4),\n        LIGHT(vec3[4](p3, p7, p5, p1), vec3(1., 1., .2), pp1),\n        LIGHT(vec3[4](p4, p5, p7, p6), vec3(.3, 1., 1.), pp2),\n        LIGHT(vec3[4](p2, p6, p7, p3), vec3(1., .4, 1.), pp0),\n        \n        LIGHT(vec3[4](c.yxy, c.yxz, c.zxz, c.zxy), 2.*vec3(.5, .3, .2), vec3(0., 10., 0.))\n        \n    );\n}\n\n// --- Raytracing ---\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(sdScene(p + e.xyy)-sdScene(p - e.xyy), \n                          sdScene(p + e.yxy)-sdScene(p - e.yxy),\t\n                          sdScene(p + e.yyx)-sdScene(p - e.yyx)));\n}\n\nfloat Intersect(RAY r)\n{\n    float t = 0.01;\n    float ld; vec3 ln;\n    vec3 p;\n    for( int i=0; i<256; i++ )\n    {\n        p = r.ro + r.rd*t;\n        float c = sdScene(p);\n        \n        for (int i = 0; i < N_LIGHTS-1; ++i)\n        {\n            ln = normalize(all_light[i].pos);\n            ld = max(dot(ln, all_light[i].pos) - dot(ln, p), sdLightCube(p));\n            if (ld < LDIST[i]) LDIST[i] = ld;\n        }\n        \n        if( c < ep ) break;\n        t += c;\n        if( t>END ) return END;\n    }\n    return t;\n}\n\n// -- Shading --\n\nfloat IntegrateEdge(vec3 v1, vec3 v2)\n{\n    float cosTheta = dot(v1, v2);\n    float theta = acos(cosTheta);    \n    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);\n\n    return res;\n}\n\nvoid ClipQuadToHorizon(inout vec3 L[5], out int n)\n{\n    // detect clipping config\n    int config = 0;\n    if (L[0].z > 0.0) config += 1;\n    if (L[1].z > 0.0) config += 2;\n    if (L[2].z > 0.0) config += 4;\n    if (L[3].z > 0.0) config += 8;\n\n    // clip\n    n = 0;\n\n    if (config == 0)\n    {\n        // clip all\n    }\n    else if (config == 1) // V1 clip V2 V3 V4\n    {\n        n = 3;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 2) // V2 clip V1 V3 V4\n    {\n        n = 3;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 3) // V1 V2 clip V3 V4\n    {\n        n = 4;\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n        L[3] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 4) // V3 clip V1 V2 V4\n    {\n        n = 3;\n        L[0] = -L[3].z * L[2] + L[2].z * L[3];\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n    }\n    else if (config == 5) // V1 V3 clip V2 V4) impossible\n    {\n        n = 0;\n    }\n    else if (config == 6) // V2 V3 clip V1 V4\n    {\n        n = 4;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 7) // V1 V2 V3 clip V4\n    {\n        n = 5;\n        L[4] = -L[3].z * L[0] + L[0].z * L[3];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 8) // V4 clip V1 V2 V3\n    {\n        n = 3;\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n        L[1] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] =  L[3];\n    }\n    else if (config == 9) // V1 V4 clip V2 V3\n    {\n        n = 4;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[2].z * L[3] + L[3].z * L[2];\n    }\n    else if (config == 10) // V2 V4 clip V1 V3) impossible\n    {\n        n = 0;\n    }\n    else if (config == 11) // V1 V2 V4 clip V3\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 12) // V3 V4 clip V1 V2\n    {\n        n = 4;\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n    }\n    else if (config == 13) // V1 V3 V4 clip V2\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = L[2];\n        L[2] = -L[1].z * L[2] + L[2].z * L[1];\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n    }\n    else if (config == 14) // V2 V3 V4 clip V1\n    {\n        n = 5;\n        L[4] = -L[0].z * L[3] + L[3].z * L[0];\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n    }\n    else if (config == 15) // V1 V2 V3 V4\n    {\n        n = 4;\n    }\n    \n    if (n == 3)\n        L[3] = L[0];\n    if (n == 4)\n        L[4] = L[0];\n}\n\n\nvec3 LTC_Evaluate(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4])\n{\n    vec3 T1, T2;\n    T1 = normalize(V - N*dot(V, N));\n    T2 = cross(N, T1);\n\n    Minv = Minv * transpose(mat3(T1, T2, N));\n\n    vec3 L[5];\n    L[0] = Minv * (points[0] - P);\n    L[1] = Minv * (points[1] - P);\n    L[2] = Minv * (points[2] - P);\n    L[3] = Minv * (points[3] - P);\n\n    int n=0;\n    ClipQuadToHorizon(L, n);\n    \n    if (n == 0)\n        return vec3(0, 0, 0);\n\n    L[0] = normalize(L[0]);\n    L[1] = normalize(L[1]);\n    L[2] = normalize(L[2]);\n    L[3] = normalize(L[3]);\n    L[4] = normalize(L[4]);\n\n    float sum = 0.0;\n\n    sum += IntegrateEdge(L[0], L[1]);\n    sum += IntegrateEdge(L[1], L[2]);\n    sum += IntegrateEdge(L[2], L[3]);\n    if (n >= 4)\n        sum += IntegrateEdge(L[3], L[4]);\n    if (n == 5)\n        sum += IntegrateEdge(L[4], L[0]);\n\n    sum =  max(0.0, sum);\n\n    vec3 Lo_i = vec3(sum);\n\n    return Lo_i;\n}\n\n\nfloat shadow( in RAY r, float w )\n{\n    float t = 0.01;\n    float c = 0.;\n    float s = 1.;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 p = r.ro + r.rd*t;\n        c = min(sdCurtain(p), sdLight(p));\n        s = min( s, 0.5+0.5*c/(w*t) );\n        if( c < ep) break;\n        t += c;\n        if( t > END ) break;\n    }\n    \n    s = min(max(s,0.0), 1.);\n    s = s*s*(3.0-2.0*s);\n    \n    return 1. - s;\n}\n\nvoid LTC_shading(float roughness, \n                 vec3 N, \n                 vec3 V, \n                 vec3 pos, \n                 vec3 m_spec, \n                 vec3 m_diff,\n                 LIGHT light,\n                 inout vec3 col)\n{\n    \n    \n    float theta = acos(dot(N, V));\n    vec2 uv = vec2(roughness, theta/(0.5*PI)) * float(LUTSIZE-1.);   \n    vec2 wx = uv/iChannelResolution[0].xy;\n            \n    uv += vec2(0.5);\n\n    vec4 params = texture(iChannel0, (uv+vec2(MATRIX_PARAM_OFFSET, 0.0))/iChannelResolution[0].xy);\n\n    mat3 Minv = mat3(\n        vec3(  1,        0,      params.y),\n        vec3(  0,     params.z,   0),\n        vec3(params.w,   0,      params.x)\n    );\n\n    vec3 spec = LTC_Evaluate(N, V, pos, Minv, light.points)*m_spec;\n\n    spec *= texture(iChannel0, uv/iChannelResolution[0].xy).x;\n\n    vec3 diff = LTC_Evaluate(N, V, pos, mat3(1), light.points)*m_diff; \n\n    RAY r = RAY(pos+.1*N, normalize(light.pos-pos));\n    float sha = shadow( r, .008 );\n\n    vec3 col0  = light.col * (m_spec*spec + m_diff*diff)*sha;\n    col0 /= 2.0*PI;\n    \n    // Some inaccuracy but it looks nicer so.\n    col += col0*2.;\n}\n\nvec3 Render(vec2 uv)\n{\n    \n    if (camera.ro.y < -3.1) is_belowfloor = true;\n    \n    RAY ray;\n    \n    InitLight(all_light);\n    InitRay(ray, camera, uv);\n    \n    float d = Intersect(ray);\n    vec3 P = d*ray.rd + ray.ro;\n    vec3 N = get_normal(P);\n    vec3 V = -ray.rd;\n    \n    vec3 n;\n    vec3 col = vec3(0);\n    \n    float roughness;\n    vec3 spec;\n    vec3 diff;\n    \n    for (int i = 0; i < N_LIGHTS-1; ++i)\n    {\n        // Add cheap af fog\n        col += pow(clamp(abs(1./LDIST[i])*0.03, 0., .5), .8)*all_light[i].col*.5;\n    }\n    \n    if (d == END || abs(P.y - CEIL_HEIGHT) < ep)\n    {\n        P = END*ray.rd + ray.ro;\n        float grad = P.y/(END);\n        col += vec3(grad*grad) *  2.*vec3(.5, .3, .2);\n        return col;\n    }\n    \n    if (OBJ_ID == CURTAIN_ID) \n    {\n        roughness = .3;\n        diff = vec3(1.);\n        spec = vec3(1.); \n    }\n    \n  \tif (OBJ_ID == FLOOR_ID)\n    {\n        roughness = 1. - texture(iChannel1, P.xz/10.).x - .1;\n        diff = vec3(1.);\n        spec = vec3(1.); \n    }\n    \n    if (OBJ_ID == LIGHT_ID)\n    {\n        \n        float ld;\n     \tfor (int i = 0; i < N_LIGHTS-1; ++i)\n        {\n            vec3 ln = normalize(all_light[i].pos);\n            ld = dot(ln, all_light[i].pos) - dot(ln, P);\n            if (ld < ep)\n            {\n                col += all_light[i].col;\n                return col;\n            }\n        }\n    }\n    \n    for (int i = 0; i < N_LIGHTS; ++i)\n    {\n    \tLTC_shading(roughness, N, V, P, diff, spec, all_light[i], col);\n    }\n    \n    \n    return col;\n}\n\n// #######################\n// ### POST PROCESSING ###\n// #######################\n\nvoid PostProcessing(inout vec3 col)\n{\n\tcol = pow(col, vec3(1.3));\n    col *= vec3(1.2,1.,1.);\n}\n\n// ############\n// ### MAIN ###\n// ############\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + 2.0 * uv;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    InitCamera(camera);\n    vec3 col = Render(uv);\n    \n    PostProcessing(col);\n    \n    fragColor = vec4(col,1.0);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir)\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1. + 4.0 * uv;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.y -= .4;\n    \n    \n    // x,y,z = right, up, forw\n    vec2 M = (iMouse.xy/iResolution.xy - 0.5) * PI;\n    if (length(iMouse.xy) < ep) M = vec2(0., .3);\n    \n    camera.lookat = vec3(0., -.4, 0.) + fragRayOri;\n    camera.ro = vec3(0., .5, 6.) + fragRayDir;\n    camera.ro.zy *= rot(M.y);\n    camera.ro.xz *= rot(M.x);\n    camera.forw = normalize(camera.lookat - camera.ro);\n    camera.right = normalize(cross(camera.forw, vec3(0.0, 1.0, 0.0)));\n    camera.up = normalize(cross(camera.right, camera.forw));\n    camera.field = 2.;\n    \n    vec3 col = Render(uv);\n    \n    PostProcessing(col);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// LTC code modified from EvilRyu by JuliaPoo\n// https://www.shadertoy.com/view/4tBBDK\n\n#define P fragCoord\n#define C fragColor\n#define v vec2\n#define V vec4\n#define B 8.\n\nvoid s(v pos, V val, v P, inout V C)\n{\n    if(abs(P.x-pos.x)<0.01&&abs(P.y-pos.y)<0.01)\n        C=val;\n}\n\nvoid setLUT(v P, inout V C)\n{\n    s(v(0.5, 0.5), V(1.000000), P, C);\n    s(v(1.5, 0.5), V(1.000000), P, C);\n    s(v(2.5, 0.5), V(0.999138), P, C);\n    s(v(3.5, 0.5), V(0.953919), P, C);\n    s(v(4.5, 0.5), V(0.855017), P, C);\n    s(v(5.5, 0.5), V(0.677721), P, C);\n    s(v(6.5, 0.5), V(0.475624), P, C);\n    s(v(7.5, 0.5), V(0.306905), P, C);\n    s(v(0.5, 1.5), V(1.000000), P, C);\n    s(v(1.5, 1.5), V(0.999990), P, C);\n    s(v(2.5, 1.5), V(0.995492), P, C);\n    s(v(3.5, 1.5), V(0.955938), P, C);\n    s(v(4.5, 1.5), V(0.852346), P, C);\n    s(v(5.5, 1.5), V(0.676815), P, C);\n    s(v(6.5, 1.5), V(0.478562), P, C);\n    s(v(7.5, 1.5), V(0.311751), P, C);\n    s(v(0.5, 2.5), V(1.000000), P, C);\n    s(v(1.5, 2.5), V(0.999952), P, C);\n    s(v(2.5, 2.5), V(0.993337), P, C);\n    s(v(3.5, 2.5), V(0.950365), P, C);\n    s(v(4.5, 2.5), V(0.844905), P, C);\n    s(v(5.5, 2.5), V(0.674537), P, C);\n    s(v(6.5, 2.5), V(0.487632), P, C);\n    s(v(7.5, 2.5), V(0.327273), P, C);\n    s(v(0.5, 3.5), V(1.000000), P, C);\n    s(v(1.5, 3.5), V(0.999865), P, C);\n    s(v(2.5, 3.5), V(0.991766), P, C);\n    s(v(3.5, 3.5), V(0.942684), P, C);\n    s(v(4.5, 3.5), V(0.831852), P, C);\n    s(v(5.5, 3.5), V(0.673589), P, C);\n    s(v(6.5, 3.5), V(0.505564), P, C);\n    s(v(7.5, 3.5), V(0.355949), P, C);\n    s(v(0.5, 4.5), V(1.000000), P, C);\n    s(v(1.5, 4.5), V(0.999665), P, C);\n    s(v(2.5, 4.5), V(0.986371), P, C);\n    s(v(3.5, 4.5), V(0.930421), P, C);\n    s(v(4.5, 4.5), V(0.813602), P, C);\n    s(v(5.5, 4.5), V(0.678975), P, C);\n    s(v(6.5, 4.5), V(0.537882), P, C);\n    s(v(7.5, 4.5), V(0.403271), P, C);\n    s(v(0.5, 5.5), V(1.000000), P, C);\n    s(v(1.5, 5.5), V(0.999025), P, C);\n    s(v(2.5, 5.5), V(0.973317), P, C);\n    s(v(3.5, 5.5), V(0.900245), P, C);\n    s(v(4.5, 5.5), V(0.804126), P, C);\n    s(v(5.5, 5.5), V(0.703751), P, C);\n    s(v(6.5, 5.5), V(0.594890), P, C);\n    s(v(7.5, 5.5), V(0.481143), P, C);\n    s(v(0.5, 6.5), V(1.000000), P, C);\n    s(v(1.5, 6.5), V(0.992850), P, C);\n    s(v(2.5, 6.5), V(0.926124), P, C);\n    s(v(3.5, 6.5), V(0.860745), P, C);\n    s(v(4.5, 6.5), V(0.833379), P, C);\n    s(v(5.5, 6.5), V(0.782873), P, C);\n    s(v(6.5, 6.5), V(0.703637), P, C);\n    s(v(7.5, 6.5), V(0.620129), P, C);\n    s(v(0.5, 7.5), V(0.987461), P, C);\n    s(v(1.5, 7.5), V(0.938899), P, C);\n    s(v(2.5, 7.5), V(0.942983), P, C);\n    s(v(3.5, 7.5), V(0.943682), P, C);\n    s(v(4.5, 7.5), V(0.943818), P, C);\n    s(v(5.5, 7.5), V(0.943681), P, C);\n    s(v(6.5, 7.5), V(0.943351), P, C);\n    s(v(7.5, 7.5), V(0.942877), P, C);\n\n    s(v(B+0.5, 0.5), V(0.000200, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+1.5, 0.5), V(0.040821, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+2.5, 0.5), V(0.163499, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+3.5, 0.5), V(0.359810, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+4.5, 0.5), V(0.608219, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+5.5, 0.5), V(0.849327, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+6.5, 0.5), V(1.026876, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+7.5, 0.5), V(1.127918, -0.000000, 1.000000, -0.000000), P, C);\n    s(v(B+0.5, 1.5), V(0.000200, -0.000046, 1.052217, 0.228243), P, C);\n    s(v(B+1.5, 1.5), V(0.040821, -0.009316, 1.052066, 0.228242), P, C);\n    s(v(B+2.5, 1.5), V(0.163218, -0.036566, 1.051517, 0.228141), P, C);\n    s(v(B+3.5, 1.5), V(0.360871, -0.077435, 1.049110, 0.226851), P, C);\n    s(v(B+4.5, 1.5), V(0.608870, -0.112986, 1.040456, 0.216178), P, C);\n    s(v(B+5.5, 1.5), V(0.850681, -0.110371, 1.022363, 0.171798), P, C);\n    s(v(B+6.5, 1.5), V(1.033758, -0.063836, 1.011022, 0.089896), P, C);\n    s(v(B+7.5, 1.5), V(1.130218, 0.000062, 1.000010, -0.000080), P, C);\n    s(v(B+0.5, 2.5), V(0.000200, -0.000096, 1.232269, 0.481573), P, C);\n    s(v(B+1.5, 2.5), V(0.040829, -0.019653, 1.232083, 0.481559), P, C);\n    s(v(B+2.5, 2.5), V(0.163323, -0.077152, 1.229494, 0.481157), P, C);\n    s(v(B+3.5, 2.5), V(0.361362, -0.161748, 1.215935, 0.476966), P, C);\n    s(v(B+4.5, 2.5), V(0.602530, -0.224893, 1.149731, 0.444834), P, C);\n    s(v(B+5.5, 2.5), V(0.832866, -0.211716, 1.066321, 0.339254), P, C);\n    s(v(B+6.5, 2.5), V(1.033638, -0.123274, 1.025543, 0.170803), P, C);\n    s(v(B+7.5, 2.5), V(1.137644, 0.000154, 0.999953, -0.000082), P, C);\n    s(v(B+0.5, 3.5), V(0.000199, -0.000159, 1.627474, 0.797472), P, C);\n    s(v(B+1.5, 3.5), V(0.040836, -0.032524, 1.635685, 0.797401), P, C);\n    s(v(B+2.5, 3.5), V(0.164108, -0.127318, 1.628042, 0.795956), P, C);\n    s(v(B+3.5, 3.5), V(0.365844, -0.258932, 1.575327, 0.783120), P, C);\n    s(v(B+4.5, 3.5), V(0.602895, -0.339455, 1.372632, 0.710306), P, C);\n    s(v(B+5.5, 3.5), V(0.825683, -0.302224, 1.158343, 0.512880), P, C);\n    s(v(B+6.5, 3.5), V(1.030563, -0.173519, 1.049980, 0.243539), P, C);\n    s(v(B+7.5, 3.5), V(1.151713, 0.000105, 0.999957, -0.000055), P, C);\n    s(v(B+0.5, 4.5), V(0.000198, -0.000248, 2.529443, 1.253956), P, C);\n    s(v(B+1.5, 4.5), V(0.040880, -0.051100, 2.570697, 1.253684), P, C);\n    s(v(B+2.5, 4.5), V(0.166706, -0.198049, 2.542881, 1.248409), P, C);\n    s(v(B+3.5, 4.5), V(0.380361, -0.384441, 2.334701, 1.206127), P, C);\n    s(v(B+4.5, 4.5), V(0.617299, -0.459699, 1.772357, 1.025249), P, C);\n    s(v(B+5.5, 4.5), V(0.835445, -0.380695, 1.304201, 0.680722), P, C);\n    s(v(B+6.5, 4.5), V(1.040850, -0.213042, 1.089431, 0.306573), P, C);\n    s(v(B+7.5, 4.5), V(1.176060, 0.000010, 1.000023, -0.000021), P, C);\n    s(v(B+0.5, 5.5), V(0.000187, -0.000388, 4.301116, 2.076506), P, C);\n    s(v(B+1.5, 5.5), V(0.041070, -0.084546, 5.305590, 2.075270), P, C);\n    s(v(B+2.5, 5.5), V(0.175521, -0.321638, 5.161014, 2.051541), P, C);\n    s(v(B+3.5, 5.5), V(0.413187, -0.560077, 4.055352, 1.869406), P, C);\n    s(v(B+4.5, 5.5), V(0.665130, -0.580464, 2.432246, 1.376237), P, C);\n    s(v(B+5.5, 5.5), V(0.870094, -0.441204, 1.506300, 0.819691), P, C);\n    s(v(B+6.5, 5.5), V(1.068578, -0.241436, 1.137736, 0.354430), P, C);\n    s(v(B+7.5, 5.5), V(1.219174, -0.000534, 1.000063, 0.000162), P, C);\n    s(v(B+0.5, 6.5), V(0.000144, -0.000631, 6.468958, 4.381222), P, C);\n    s(v(B+1.5, 6.5), V(0.042200, -0.177353, 20.085962, 4.369584), P, C);\n    s(v(B+2.5, 6.5), V(0.209979, -0.606367, 16.868328, 4.106197), P, C);\n    s(v(B+3.5, 6.5), V(0.500901, -0.795643, 8.099620, 2.893355), P, C);\n    s(v(B+4.5, 6.5), V(0.769693, -0.688227, 3.439625, 1.659662), P, C);\n    s(v(B+5.5, 6.5), V(0.955036, -0.470746, 1.760819, 0.883184), P, C);\n    s(v(B+6.5, 6.5), V(1.134532, -0.254869, 1.190455, 0.377490), P, C);\n    s(v(B+7.5, 6.5), V(1.308330, -0.002944, 0.999844, 0.001275), P, C);\n    s(v(B+0.5, 7.5), V(0.000102, -0.118482, 1184.816772, 1184.816284), P, C);\n    s(v(B+1.5, 7.5), V(0.319603, -3.097308, 7133.888672, 23.645655), P, C);\n    s(v(B+2.5, 7.5), V(0.546638, -1.442077, 133.966263, 8.593670), P, C);\n    s(v(B+3.5, 7.5), V(0.837342, -1.129903, 20.226521, 3.658263), P, C);\n    s(v(B+4.5, 7.5), V(1.004258, -0.809128, 5.700182, 1.768790), P, C);\n    s(v(B+5.5, 7.5), V(1.117055, -0.531464, 2.269246, 0.923613), P, C);\n    s(v(B+6.5, 7.5), V(1.336692, -0.312752, 1.241618, 0.414403), P, C);\n    s(v(B+7.5, 7.5), V(1.670654, -0.056394, 0.998759, 0.033416), P, C);\n}\n\nvoid mainImage( out V C, in v P )\n{\n    V lastFrame = texture(iChannel0, v(.5));\n\n    if (lastFrame.a != 0. && iFrame > 2) {\n        C = lastFrame;\n        return;\n    }\n\n    if( P.x > 16. || P.y > 8. ) discard;\n\tsetLUT(P, C);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}