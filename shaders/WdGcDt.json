{
    "Shader": {
        "info": {
            "date": "1604146670",
            "description": "Encoding precalculated functions into the cube map faces to create a rocky landscape tunnel flythrough.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdGcDt",
            "likes": 65,
            "name": "Desert Passage II",
            "published": 3,
            "tags": [
                "voronoi",
                "tunnel",
                "texture",
                "rock",
                "sand",
                "desert"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1491
        },
        "renderpass": [
            {
                "code": "/*\n\n\tDesert Passage II\n\t-----------------\n\n\tEncoding precalculated functions into the cube map faces to create a rocky landscape \n    tunnel flythrough. This has been sitting in my account for a while, but I was too lazy\n\tto tidy the code up and post it until now. :)\n\n    To be honest, I find wrapped texture precalculation, packing and subsequent unpacking a\n\tlittle on the laborious side, so I wouldn't expect anyone to want to try to sift through\n\tthe code in order to decipher it. Regardless, this is just a proof of concept to show\n    that it's possible to encode more interesting surfaces (2D or 3D) into textures for \n    realtime use.\n\n    The surfaces themselves are just layers of 3D Voronoi and noise, which are pretty easy \n    to produce, but prohibitively expensive to construct on the fly in realtime. The sand\n    pattern comes from another example of mine.\n\n\tEncoding 3D information into textures isn't new, and has been performed by myself and \n\tothers on Shadertoy a few times. This version is unique in the sense that neighboring\n\tvalues are packed into all four channels in order to reduce the total number of texture\n\tcalls required for smooth interpolation -- Down from 8 to 2, which is obviously quicker.\n\tHowever, as mentioned previously, how well your machine handles this will depend on its\n\tability to deal with textures in memory and other things.\n\n\tMy machine can almost run this in fullscreen at full efficiency. However, if you have a \n    system that doesn't enjoy this, I apologize in advance, but will add that texture\n\tprecalculation is still worth the effort.\n\t\n\n\n\tRelated examples:\n\n\t// It won Breakpoint way back in 2009. For anyone not familiar with the demoscene, \n    // it's a big deal. :)\n\tElevated - IQ\n\thttps://www.shadertoy.com/view/MdX3Rr\n\n\n\t// One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 100.\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    n = n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n*/\n\n/* \n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(113, 1)));\n    return fract(vec2(2097152, 262144)*n)*2. - 1.;\n\n}\n*/\n\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// vec2 to vec2.\nvec2 hash22(vec2 p){\n\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 42.123);\n    p = fract((p3.xx + p3.yz)*p3.zy)*2. - 1.;\n    return p;\n    \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    //mat2  m = r2(mod(iTime, 6.2831853)); \n\t//p.xy = m * p.xy;//rotate gradient vector\n  \t//return p;\n}\n\n// Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f){\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22(p + e.xx), f - e.xx), dot(hash22(p + e.yx), f - e.yx), w.x),\n                  mix(dot(hash22(p + e.xy), f - e.xy), dot(hash22(p + e.yy), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec2 p){\n    \n    return gradN2D(p)*.57 + gradN2D(p*2.)*.28 + gradN2D(p*4.)*.15;\n    \n}\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n\n\n\n\n// Repeat gradient lines. How you produce these depends on the effect you're after. I've used a smoothed\n// triangle gradient mixed with a custom smoothed gradient to effect a little sharpness. It was produced\n// by trial and error. If you're not sure what it does, just call it individually, and you'll see.\nfloat grad(float x, float offs){\n    \n    // Repeat triangle wave. The tau factor and \".25\" factor aren't necessary, but I wanted its frequency\n    // to overlap a sine function.\n    x = abs(fract(x/6.283 + offs - .25) - .5)*2.;\n    \n    float x2 = clamp(x*x*(-1. + 2.*x), 0., 1.); // Customed smoothed, peaky triangle wave.\n    //x *= x*x*(x*(x*6. - 15.) + 10.); // Extra smooth.\n    x = smoothstep(0., 1., x); // Basic smoothing - Equivalent to: x*x*(3. - 2.*x).\n    return mix(x, x2, .15);\n    \n/*    \n    // Repeat sine gradient.\n    float s = sin(x + 6.283*offs + 0.);\n    return s*.5 + .5;\n    // Sine mixed with an absolute sine wave.\n    //float sa = sin((x +  6.283*offs)/2.);\n    //return mix(s*.5 + .5, 1. - abs(sa), .5);\n    \n*/\n}\n\n// One sand function layer... which is comprised of two mixed, rotated layers of repeat gradients lines.\nfloat sandL(vec2 p){\n    \n    // Layer one. \n    vec2 q = rot2(3.14159/18.)*p; // Rotate the layer, but not too much.\n    q.y += (gradN2D(q*18.) - .5)*.05; // Perturb the lines to make them look wavy.\n    float grad1 = grad(q.y*80., 0.); // Repeat gradient lines.\n   \n    q = rot2(-3.14159/20.)*p; // Rotate the layer back the other way, but not too much.\n    q.y += (gradN2D(q*12.) - .5)*.05; // Perturb the lines to make them look wavy.\n    float grad2 = grad(q.y*80., .5); // Repeat gradient lines.\n      \n    \n    // Mix the two layers above with an underlying 2D function. The function you choose is up to you,\n    // but it's customary to use noise functions. However, in this case, I used a transcendental \n    // combination, because I like the way it looked better.\n    // \n    // I feel that rotating the underlying mixing layers adds a little variety. Although, it's not\n    // completely necessary.\n    q = rot2(3.14159/4.)*p;\n    //float c = mix(grad1, grad2, smoothstep(.1, .9, n2D(q*vec2(8))));//smoothstep(.2, .8, n2D(q*8.))\n    //float c = mix(grad1, grad2, n2D(q*vec2(6)));//smoothstep(.2, .8, n2D(q*8.))\n    //float c = mix(grad1, grad2, dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5);//smoothstep(.2, .8, n2D(q*8.))\n    \n    // The mixes above will work, but I wanted to use a subtle screen blend of grad1 and grad2.\n    float a2 = dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5;\n    float a1 = 1. - a2;\n    \n    // Screen blend.\n    float c = 1. - (1. - grad1*a1)*(1. - grad2*a2);\n    \n    // Smooth max\\min\n    //float c = smax(grad1*a1, grad2*a2, .5);\n   \n    return c;\n    \n    \n}\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\nfloat sand(vec2 p){\n    \n    // Rotating by 45 degrees. I thought it looked a little better this way. Not sure why.\n    // I've also zoomed in by a factor of 4.\n    p = vec2(p.y - p.x, p.x + p.y)*.7071/4.;\n    \n    // Sand layer 1.\n    float c1 = sandL(p);\n    \n    // Second layer.\n    // Rotate, then increase the frequency -- The latter is optional.\n    vec2 q = rot2(3.14159/12.)*p;\n    float c2 = sandL(q*1.25);\n    \n    // Mix the two layers with some underlying gradient noise.\n    c1 = mix(c1, c2, smoothstep(.1, .9, gradN2D(p*vec2(4))));\n    \n/*   \n\t// Optional screen blending of the layers. I preferred the mix method above.\n    float a2 = gradN2D(p*vec2(4));\n    float a1 = 1. - a2;\n    \n    // Screen blend.\n    c1 = 1. - (1. - c1*a1)*(1. - c2*a2);\n*/    \n    \n    // Extra grit. Not really necessary.\n    //c1 = .7 + fBm(p*128.)*.3;\n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took me far too long before it hit me. :)\n    return c1/(1. + gT*gT*.015);\n}\n\n/////////\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\n\n/*\n// Based on the triangle function that Shadertoy user Nimitz has used in various triangle noise \n// demonstrations. See Xyptonjtroz - Very cool.\n// https://www.shadertoy.com/view/4ts3z2\n// Anyway, these have been modified slightly to emulate the sin and cos waves.\nvec3 triS(in vec3 x){ return 1. - abs(fract(x/6.283185307 + .25) - .5)*4.; } // Triangle function.\nvec3 triC(in vec3 x){ return 1. - abs(fract(x/6.283185307 + .5) - .5)*4.; } // Triangle function.\nvec2 triS(in vec2 x){ return 1. - abs(fract(x/6.283185307 + .25) - .5)*4.; } // Triangle function.\nvec2 triC(in vec2 x){ return 1. - abs(fract(x/6.283185307 + .5) - .5)*4.; } // Triangle function.\nfloat triS(in float x){ return (1. - abs(fract(x/6.283185307 + .25) - .5)*4.); } // Triangle function.\nfloat triC(in float x){ return (1. - abs(fract(x/6.283185307 + .5) - .5)*4.); } // Triangle function.\n\n// Quantized version of the path below.\nvec2 path(in float z){ \n    //return vec2(0);\n    return vec2(triC(z*.18/1.)*2. - triS(z*.1/1.)*4., triS(z*.12/1.)*3. - 1.);\n}\n*/\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0);\n    return vec2(cos(z*.18/1.)*2. - sin(z*.1/1.)*4., sin(z*.12/1.)*3. - 1.);\n}\n\n\n// A 2D texture lookup: GPUs don't make it easy for you. If wrapping wasn't a concern,\n// you could get away with just one GPU-filtered filtered texel read. However, there\n// are seam line issues, which means you need to interpolate by hand, so to speak.\n// Thankfully, you can at least store the four neighboring values in one pixel channel,\n// so you're left with one texel read and some simple interpolation.\n//\n// By the way, I've included the standard noninterpolated option for comparisson.\nfloat txFace1(in samplerCube tx, in vec2 p){\n   \n    \n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    \n    #if 0\n    \n    // The standard noninterpolated option. It's faster, but doesn't look very nice.\n    // You could change the texture filtering to \"mipmap,\" but that introduces seam\n    // lines at the borders -- which is fine, if they're out of site, but not when you\n    // want to wrap things, which is almost always.\n    return texture(tx, vec3(.5, uv.y, -uv.x)).x; \n    \n    #else\n    \n    // Smooth 2D texture interpolation using just one lookup. The pixels and\n    // its three neighbors are stored in each channel, then interpolated using\n    // the usual methods -- similar to the way in which smooth 2D noise is\n    // created.\n    vec4 p4 = texture(tx, vec3(.5, uv.y, -uv.x)); \n\n    return mix(mix(p4.x, p4.y, p.x), mix(p4.z, p4.w, p.x), p.y);\n    \n    // Returning the average of the neighboring pixels, for curiosity sake.\n    // Yeah, not great. :)\n    //return dot(p4, vec4(.25));\n    \n    #endif\n/*   \n    // Four texture looks ups. I realized later that I could precalculate all four of \n    // these, pack them into the individual channels of one pixel, then read them\n    // all back in one hit, which is much faster.\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    vec4 x = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 0)+ .5)/cubemapRes) - .5;\n    vec4 y = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(0, 1)+ .5)/cubemapRes) - .5;\n    vec4 z = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 1)+ .5)/cubemapRes) - .5;\n    vec4 w = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n\n    return mix(mix(x, y, p.x), mix(z, w, p.x), p.y);\n*/  \n    \n}\n\n// 2D Surface function.\nfloat surfFunc2D(in vec3 p){\n    \n     return txFace1(iChannel0, p.xz/64.);\n}\n\n\n// The 3D surface function. This one converts the 3D position to a 3D voxel \n// position in the cubemap, then reads the isovalue. Actually, one option does\n// that, and the other is forced to read out eight neighboring values to \n// produce a smooth interpolated value. As in real life, it looks nicer, but \n// costs more. :)\nfloat txFace0(in vec3 p){\n    \n    #if 0\n    \n    // One sample... Ouch. :D It's a shame this doesn't work, because it's \n    // clearly faster. Unfortunately, it's virtually pointless from an aesthetic\n    // aspect, as you can see, but there'd be times when you could get away with it.\n    vec3 col = texMapCh(iChannel0, p).xyz;\n    \n    #else\n    \n    // Eight samples, for smooth interpolation. Still not as good as the real \n    // thing -- and by that, I mean, calculating on the fly. However, it's \n    // good enough. I'd need to think about it, but I'm wondering whether a\n    // four or five point tetrahedral interpolation would work? It makes my\n    // head hurt thinking about it right now, but it might. :)\n    vec3 col = texMapSmoothCh(iChannel0, p).xyz;\n    \n    #endif\n    \n    return col.x;\n    \n}\n\n\n// 3D surface function.\nfloat surfFunc3D(in vec3 p){ return txFace0(p/8.); }\n    \n\n// Tunnel cross sectional distance.\nfloat dist(in vec2 p){\n    \n    return length(p);\n    //p = abs(p);\n    //return max((p.x + p.y)*.7071, max(p.x, p.y));\n    \n}\n\n// Rock and object ID holders.\nint rID = 0;\nint svRID;\nvec2 vRID;\nvec2 svVRID;\n\n// The desert scene. Adding a heightmap to an XZ plane. Not a complicated distance function. :)\nfloat map(vec3 p){\n    \n    // Retrieve the 3D surface value. Note (in the function) that the 3D value has been \n    // normalized. That way, everything points toward the center.\n    float sf3D = surfFunc3D(p);\n    \n    // Retrieve the 2D surface value from another cube map face.\n    float sf2D = surfFunc2D(p);\n     \n    // Path function.\n    vec2 pth = path(p.z); \n\n    \n    // The tunnel itself.\n    float tun = 2. - dist((p.xy - pth)*vec2(.7, 1));\n\n    // Second tunnel --- Needs work, so not used here.\n    //tun = smax(tun, 2. - dist((p.xy - path(p.z*1.5 + .5)*1.35)), 4.);\n    \n    \n    // Terrain.\n    float ter = p.y + (.5 - sf2D)*4. - sf2D*2.75;\n \n    // Hollowing the tunnel out of the terrain.\n    ter = smax(ter, tun, 3.);\n     \n    // Adding a bit more of the 2D texture and 3D texture.\n    ter += (.5 - sf2D) +  (.5 - sf3D); \n\n    \n    // The sand layer upon which the sand pattern sits -- The \n    // sand pattern itself is added later via bump mapping.\n    float snd = p.y - pth.y - sf2D*2. + 2.65; \n\n    // Storing the terrain and sand layer distance for later usage.\n    vRID = vec2(ter, snd);\n\n    // Return the minimum distance.\n    return min(ter, snd);\n \n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    \n    for(int i=0; i<120; i++){\n    \n        h = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<.001*(t*.05 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += h*.85; \n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved \n// make a difference. Also because of the random nature of the scene, the tetrahedral normal \n// has the same aesthetic effect as the regular - but more expensive - one, so it's an easy \n// decision.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*/\n\n \n// Standard normal function. It's not as fast as the tetrahedral calculation, \n// but more symmetrical.\nvec3 normal(in vec3 p, float ef) {\n\t\n    vec2 e = vec2(.001, 0); // .001*ef\n\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n  \n// Surface bump function..\nfloat bumpSurf3D( in vec3 p){\n    \n    float n = 0.;\n    // Mixing the sand and rock normals at the borders.\n    float bordCol0Col1 = svVRID.x - svVRID.y;\n    const float bordW = .05;\n    \n    // Rocks.\n    if(svRID==0){\n        n = txFace0(p/8.);\n        n = mix(n, 1.-txFace0(p/2.), .25);\n        n = mix(n, txFace0(p*1.5), .1);\n        \n        n = mix(.5, n, smoothstep(0., bordW, -(bordCol0Col1)));\n    }\n    else{\n        \n        // Sand.\n        n = sand(p.xz*1.25);\n        n = mix(.5, n, smoothstep(0., bordW, (bordCol0Col1)));\n       \n/*       \n        // Sand pattern alternative.\n        p *= vec3(1.65, 2.2, 3.85)/1.25;\n        //float ns = n2D(p.xz)*.57 + n2D(p.xz*2.)*.28 + n2D(p.xz*4.)*.15;\n        float ns = n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n\n        // vec2 q = rot2(-3.14159/5.)*p.xz;\n        // float ns1 = grad(p.z*32., 0.);//*clamp(p.y*5., 0., 1.);//smoothstep(0., .1, p.y);//\n        // float ns2 = grad(q.y*32., 0.);//*clamp(p.y*5., 0., 1.);//smoothstep(0., .1, p.y);//\n        // ns = mix(ns1, ns2, ns);\n\n        ns = (1. - abs(smoothstep(0., 1., ns) - .5)*2.);\n        ns = mix(ns, smoothstep(0., 1., ns), .65);\n\n        // Use the height to taper off the sand edges, before returning.\n        //ns = ns*smoothstep(0., .2, p.y - .075);\n    \n\n        // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n        // formed in the distance. Simply lessen the value when it's further away. Most people would\n        // figure this out pretty quickly, but it took far too long before it hit me. :)\n        n = ns/(1. + gT*gT*.015);\n*/        \n        \n        \n    }\n    \n    \n    \n    \n    //return mix(min(n*n*2., 1.), surfFunc3D(p*2.), .35);\n    return n;//min(n*n*2., 1.);\n    \n    /*\n    // Obtaining some terrain samples in order to produce a gradient\n    // with which to distort the sand. Basically, it'll make it look\n    // like the underlying terrain it effecting the sand. The downside\n    // is the three extra taps per bump tap... Ouch. :) Actually, it's\n    // not that bad, but I might attempt to come up with a better way.\n    float n = txFace0(p);\n    vec3 px = p + vec3(.001, 0, 0);\n    float nx = txFace0(px);\n    vec3 pz = p + vec3(0, 0, .001);\n    float nz = txFace0(pz);\n    \n    // The wavy sand, that has been perturbed by the underlying terrain.\n    return sand(p.xz + vec2(n - nx, n - nz)/.001*1.);\n    */\n\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p);\n   \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */ \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.2/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 48; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .035, .5); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n \n// Standard sky routine: Gradient with sun and overhead cloud plane. I debated over whether to put more \n// effort in, but the dust is there and I'm saving cycles. I originally included sun flares, but wasn't \n// feeling it, so took them out. I might tweak them later, and see if I can make them work with the scene.\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld){ \n    \n    // Sky color gradients.\n    vec3 col = vec3(.8, .7, .5), col2 = vec3(.4, .6, .9);\n    \n    //return mix(col, col2, pow(max(rd.y*.5 + .9, 0.), 5.));  // Probably a little too simplistic. :)\n     \n    // Mix the gradients using the Y value of the unit direction ray. \n    vec3 sky = mix(col, col2, pow(max(rd.y + .15, 0.), .5));\n      \n    // Adding the sun.\n    float sun = clamp(dot(ld, rd), 0., 1.);\n    sky += vec3(1, .7, .4)*vec3(pow(sun, 16.))*.2; // Sun flare, of sorts.\n    sun = pow(sun, 32.); // Not sure how well GPUs handle really high powers, so I'm doing it in two steps.\n    sky += vec3(1.6, 1, .5)*vec3(pow(sun, 32.))*.35; // Sun.\n    \n     // Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.15;\n    rd = normalize(rd);\n   \n    // A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float t = (SC - ro.y - .15)/(rd.y + .15); // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>0.) sky =  mix(sky, vec3(2), smoothstep(.45, 1., fBm(1.5*uv/SC))*\n                        smoothstep(.45, .55, rd.y*.5 + .5)*.4);\n    \n    // Return the sky color.\n    return sky*vec3(1.1, 1, .9);\n}\n\n\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n// hash based 3d value noise\nvec4 hash41(vec4 p){\n    return fract(sin(mod(p, 6.2831589))*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41(mod(h, 6.2831)), hash41(mod(h + s.x, 6.2831)), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// The grungey texture -- Kind of modelled off of the metallic Shadertoy texture,\n// but not really. Most of it was made up on the spot, so probably isn't worth \n// commenting. However, for the most part, is just a mixture of colors using \n// noise variables.\nvec3 GrungeTex(in vec3 p){\n    \n \t// Some fBm noise.\n    //float c = n2D(p*4.)*.66 + n2D(p*8.)*.34;\n    float c = n3D(p*3.)*.57 + n3D(p*7.)*.28 + n3D(p*15.)*.15;\n   \n    // Noisey bluish red color mix.\n    vec3 col = mix(vec3(.25, .115, .02), vec3(.35, .5, .65), c);\n    // Running slightly stretched fine noise over the top.\n    col *= n3D(p*vec3(150., 150., 150.))*.5 + .5; \n    \n    // Using a smooth fract formula to provide some splotchiness... Is that a word? :)\n    col = mix(col, col*vec3(.75, .95, 1.1), sFract(c*4., 12.));\n    col = mix(col, col*vec3(1.2, 1, .8)*.8, sFract(c*5. + .35, 12.)*.5);\n    \n    // More noise and fract tweaking.\n    c = n3D(p*8. + .5)*.7 + n3D(p*18. + .5)*.3;\n    c = c*.7 + sFract(c*5., 16.)*.3;\n    col = mix(col*.6, col*1.4, c);\n    \n    // Clamping to a zero to one range.\n    return clamp(col, 0., 1.);\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.     \n\tvec3 ro = vec3(0, 4.*0. - .5, iTime*5.); // Camera position, doubling as the ray origin.\n    vec3 lookAt = ro + vec3(0, -.2*0., .5);  // \"Look At\" position.\n    \n    //vec3 lp = vec3(0, 0, ro.z + 8.);\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(0, 0, ro.z) + vec3(FAR*.125, FAR*.35, FAR);\n\t\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlookAt.xy += path(lookAt.z);\n    //lp.xy += path(lp.z);\n \n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.5; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/32.)*rd.xy;\n    \n  \n\n\t// Raymarching.\n    float t = trace(ro, rd);\n    \n    gT = t;\n    \n    svVRID = vRID;\n    svRID = vRID[0]<vRID[1]? 0 : 1;\n    \n   \n    // Sky. Only retrieving a single color this time.\n    //vec3 sky = getSky(rd);\n    \n    // The passage color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = vec3(0);\n    \n    // Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    // the mist, so that's why it's declared in an untidy postion outside the block below...\n    // It seemed like a good idea at the time. :)\n    vec3 sp = ro+t*rd; \n    \n    float pathHeight = sp.y;//surfFunc(sp);// - path(sp.z).y; // Path height line, of sorts.\n    \n    // If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        \n        vec3 sn = normal(sp, 1.); // Surface normal. //*(1. + t*.125)\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp - sp;\n        float lDist = max(length(ld), 0.001);\n        ld /= lDist; // Normalize the light direct vector.\n        \n        lDist /= FAR; // Scaling down the distance to something workable for calculations.\n        float atten = 1./(1. + lDist*lDist*.025);\n\n        \n        // Texture scale factor.        \n        const float tSize = 1./8.;\n        \n        // Extra shading in the sand crevices.\n        float bSurf = bumpSurf3D(sp);\n        \n        vec3 oSn = sn;\n        \n        float bf = svRID == 0? .5 : .05;\n        sn = doBumpMap(sp, sn, bf);\n         \n        \n        // Soft shadows and occlusion.\n        float sh = softShadow(sp, lp, sn, 8.); \n        float ao = calcAO(sp, sn); // Amb, 6.ient occlusion.\n \n        \n        float dif = max( dot( ld, sn ), 0.); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 32.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Dirt... or close enough.\n       \n        // Overal global ambience. Attempting to at apply some science to it, by using\n        // Blackle's more thought out ambient lighting, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //float amb = pow(length(sin(sn*2.)*.45 + .5)/sqrt(3.), 2.)*.25; // Studio.\n        float amb = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1.5, 1.5, sn.y)*.25; // Outdoor.\n \n        \n\n        // 3D surface function.\n        float sf3D = surfFunc3D(sp);\n        \n         \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = clamp(mix(vec3(1.2, .75, .5)*vec3(1, .9, .8), vec3(.7, .5, .25), (sp.y - 1.)*.15), \n                vec3(.5, .25, .125), vec3(1));\n          \n        //col = min(vec3(1.2, .75, .5)*vec3(1, .9, .8), 1.);\n    \n         \n        // Setting the terrain color and sand color. \n        vec3 col0 = col, col1 = col;\n        \n        // Trick to mix things at the borders for a less brutal transition.\n        float bordCol0Col1 = svVRID.x - svVRID.y;\n        const float bordW = .1;\n        /*\n        if(svRID==0 || abs(bordCol0Col1)<bordW){\n \n            // Coloring the soil.\n        \tvec3 colR = mix(vec3(1, .8, .5), vec3(.5, .25, .125), clamp((sp.y + 2.)*.5, 0., 1.));\n        \tcol0 = mix(col0, colR, .5);\n            \n        }\n        */\n        \n        if(svRID==1 || abs(bordCol0Col1)<bordW){\n            col1 = mix(col1*vec3(1.5), vec3(1, .9, .8), .2);\n        }        \n        // Return the color, which is either the sandy terrain color, the object color,\n    \t// or if we're in the vicinity of both, make it a mixture of the two.\n    \tcol = mix(col0, col1, smoothstep(-bordW, bordW, bordCol0Col1));\n        \n         \n       \n        // Finer details.\n        col = mix(col*vec3(1.05, 1, 1.2)/4., col, smoothstep(0., 1., sf3D));\n        col = mix(col/1.35, col*1.35, bSurf);\n        \n        // Grungey overlay: Add more to the rock surface than the sand.\n        // Surface texel.\n        vec3 tx = GrungeTex(sp/4.);//*vec3(1.2, 1.15, 1.05);//\n        col = mix(col, col*tx*3., mix(.5, .25, smoothstep(-bordW, bordW, bordCol0Col1))); \n        \n        \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        vec3 refSky = getSky(sp, reflect(rd, sn), ld);\n        col += col*refSky*.05 + refSky*fre*fre2*.15; \n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = col*(dif*sh + amb + vec3(1, .97, .92)*spe*fre2*sh);\n        \n        \n        \n        \n \n        // Applying the shadows and ambient occlusion.\n        col = col*ao*atten;\n \n    }\n    \n  \n    // Combine the scene with the sky using some cheap volumetric substance.\n    vec3 gLD = normalize(lp - vec3(0, 0, ro.z));\n    vec3 sky = getSky(ro, rd, gLD);\n    \n    // Simulating sun scatter over the sky and terrain: IQ uses it in his Elevated example.\n    sky += vec3(1., .6, .2)*pow(max(dot(rd, gLD), 0.), 16.)*.25;\n    sky = min(sky, 1.);\n    \n    //col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n    col = mix(col, sky, smoothstep(0., .99, t/FAR)); // Linear fade. Much dustier. I kind of like it.\n    \n    \n    // Greyish tone.\n    //col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5);\n    \n    \n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord/iResolution.xy;\n    col = min(col, 1.)*pow( 16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n \n    // Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n\n\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace0(vec3 p){\n   \n    \n    //vec3 pix = vec3(1./4./dims.x, 0, 0);\n    vec3 pix = vec3(1./1./dims.x, 0, 0);\n \n    vec4 col;\n    \n    for(int i = 0; i<4; i++){\n        \n        vec3 q = p + vec3(0, i&1, i>>1)/dims.x;\n        \n        vec3 rotF = vec3(0); // Rotation factor - Range: [0, 1].\n        \n        // Wrapped multilayer tertiary order Voronoi.\n        gSc = vec3(4);\n        vec3 sc = vec3(1, 1, 1);\n        vec3 v = Voronoi(q*gSc, sc, rotF, 1./1., 1);\n        float res = max(1.-v.x, 0.);// mix(max(1. - v.x, 0.), (v.y - v.x), .0);\n        gSc = vec3(8);\n        sc = vec3(1, 1, 1);\n        v = Voronoi((q - .0)*gSc, sc, rotF, 1., 1);\n        res = mix(res, 1. - max(1. - v.x, 0.), .125); \n        //res = min(res, max((1. - v.x)/2., 0.));\n        gSc = vec3(16);\n        sc = vec3(1, 1, 1);\n        rotF = vec3(1);\n        v = Voronoi((q - .0)*gSc, sc, rotF, 1., 1);\n        res = mix(res, max(v.y - v.x, 0.), .0625); \n        \n    \n        // The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        // but not the look we're going for here.\n        col[i] = res;//max(1. - res*.85 - res*res*.15, 0.);\n         \n        //p += pix;\n        \n    }\n    \n    // Return the four function values -- One for each channel.\n    return col;\n    \n}\n\n\n\n\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace1(vec2 uv){\n    \n    // It's a 2D conversion, but we're using a 3D function with constant Z value.\n    vec3 p;\n    // Just choose any Z value you like. You could actually set \"p.z\" to any constant,\n    // or whatever, but I'm keeping things consistant.\n    p.z = floor(.0*cubemapRes.x)/cubemapRes.x; \n       \n    vec4 col;\n    \n    for(int i = 0; i<4; i++){\n\n        // Since we're performing our own 2D interpolation, it makes sense to store\n        // neighboring values in the other pixel channels. It makes things slightly\n        // more confusing, but saves four texel lookups -- usually in the middel of\n        // a raymarching loop -- later on.\n        \n        // The neighboring position for each pixel channel.\n        p.xy = mod(floor(uv*cubemapRes) + vec2(i&1, i>>1), cubemapRes)/cubemapRes;\n\n        // Individual Voronoi cell scaling.\n        vec3 sc = vec3(1);\n        vec3 rotF = vec3(0); // Rotation factor.\n        \n        // Put whatever function you want here. In this case, it's Voronoi.\n        gSc = vec3(8);\n        vec3 v = Voronoi(p*gSc, sc, rotF, 1., 0);\n        float res = 1. - v.x;\n        //gSc = vec3(16);\n        //v = Voronoi(p*gSc, sc, rotF, 1., 1);\n        //res = mix(res, v.y - v.x, .333);\n        // The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        // but not the look we're going for here.\n        \n        // Layering in some noise as well. This is all precalculated, so speed isn't\n        // the primary concern... Compiler time still needs to be considered though.\n        gSc = vec3(4);\n        float res2 = n3DT(p*gSc);\n        gSc = vec3(8);\n        res2 = mix(res2, n3DT(p*gSc), .333);\n        gSc = vec3(16);\n        res2 = mix(res2, n3DT(p*gSc), .333);\n        //gSc = vec3(16);\n        //res2 = mix(res2, n3DT(p*gSc), .333);\n        \n        // Mix in the Voronoi and the noise.\n        col[i] =  mix(res, res2, .5);\n\n    }\n    \n    return col;\n}\n\n// Converting your UV coordinates to 3D coordinates. I've seen some pretty longwinded\n// obfuscated conversions out there, but it shouldn't require anything more than \n// the following. By the way, the figure \"dims.x\" is factored down by four to account\n// for the four pixel channels being utilized, but the logic is the same.\nvec3 convert2DTo3D(vec2 uv){\n    \n    // Converting the fract(uv) coordinates from the zero to one range to the whole\n    // number, zero to... 1023 range.\n    uv = floor(uv*cubemapRes);\n    \n    // Converting the UV coordinate to a linear representation. The idea is to convert the\n    // 2D UV coordinates to a linear value, then use that to represent the 3D coordinates.\n    // This way, you can effectively fit all kinds of 3D dimensions into a 2D texture array\n    // without having to concern yourself with 2D texture wrapping issues. In theory, so \n    // long as the dimensions fit, and the X dimension is a multiple of four, then anything\n    // goes. As mentioned, the maximum cubic dimension allowable for one cube face is \n    // 160 cubed. In that respect, rectangular dimensions, like vec3(160, 80, 320), etc, \n    // would also fit.\n    //\n    // For instance, the 137th pixel in the third row on a 1024 by 1024 cubemap face texture \n    // would be the number 2185 (2*1024 + 137).\n    float iPos = dot(uv, vec2(1, cubemapRes.x));\n    \n    // In this case the XY slices comprise of 160 pixels (or whatever number we choose) along \n    // X and Y, so the pixel position in any block would be modulo 160*160. The xyBlock position \n    // would have to be converted to X and Y positions, which would be xyBlock mod dimX, and \n    // floor(xyBlock/dimX) mod dimY respectively. The Z position would depend on how many \n    // 160 by 160 blocks deep we're in, which translates to floor(iPos/(dimX*dimY)).\n    //\n    // Anyway, that's what the following lines represent.\n    \n    // XY block (or slice) linear position.\n    float xyBlock = mod(iPos, dims.x*dims.y);\n    \n    // Converting to X, Y and Z position.\n    vec3 p = vec3(mod(floor(vec3(xyBlock, xyBlock, iPos)/vec3(1, dims.x, dims.x*dims.y)), dims));\n    \n    //vec3 p = vec3(mod(xySlice, dims.x), mod(floor((xySlice)/dims.x), dims.y),\n                  //floor((iPos)/(dims.x*dims.y)));\n    \n    // It's not necessary, but I'm converting the 3D coordinates back to the zero to one\n    // range... There'd be nothing stopping you from centralizing things (p/dims - .5), but \n    // this will do.\n    return p/dims;\n}\n\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n  \n    // Pixel storage.\n    vec4 col;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's something \n    // I never would have considered. :)\n    if(textureSize(iChannel0,0).x<2 || iFrame<1){\n        \n        // This is part of an ugly hack that attempts to force the GPU compiler\n        // to not unroll the Voronoi loops. Not sure if it'll work, but I'm \n        // trying it anyway, in the hope to get compiler times down on some\n        // machines. For the record, this takes about 3 seconds to compile on \n        // my machine.\n        gIFrame = iFrame;\n        \n        \n        /*\n        // Debug information for testing individual cubeface access.\n        if(faceID==0) col = vec4(0, 1, 0, 1);\n        else if(faceID==1) col = vec4(0, .5, 1, 1);\n        else if(faceID==2) col = vec4(1, 1, 0, 1);\n        else if(faceID==3) col = vec4(1, 0, 0, 1);\n        else if(faceID==4) col = vec4(.5, .5, .5, 1);\n        else col = vec4(1, 1, 1, 1);\n        */\n        \n        \n        // Fill the first cube face with a custum 3D function.\n        if(faceID==0){\n            \n            vec3 p = convert2DTo3D(uv);\n            \n            col = funcFace0(p);\n           \n        }\n        \n        // Fill the second cube face with a custom 2D function... We're actually\n        // reusing a 3D function, but it's in slice form, which essentially makes\n        // it a 2D function.\n        if(faceID==1){\n\n            col = funcFace1(uv);\n            \n        }\n        \n        \n\n        /*\n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n        */\n\n        \n    }\n    else {\n        \t\n        // The cube faces have already been initialized with values, so from this point,\n        // read the values out... There's probably a way to bypass this by using the \n        // \"discard\" operation, but this isn't too expensive, so I'll leave it for now.\n        col = tx(iChannel0, uv, faceID);\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// The cubemap texture resultion.\n#define cubemapRes vec2(1024)\n\n// If you use all four channels of one 1024 by 1024 cube face, that would be\n// 4096000 storage slots (1024*1024*4), which just so happens be 160 cubed.\n// In other words, you can store the isosurface values of a 160 voxel per side\n// cube into one cube face of the cubemap.\n//\n// The voxel cube dimensions: That's the one you'd change, but I don't really\n// see the point, since setting it to the maximum resolution makes the most\n// sense. For demonstrative purposes, dropping it to say, vec3(80), will show\n// how a decrease in resolution will affect things. Increasing it to above the\n// allowable resolution (for one cube face) to say, vec3(200), will display the\n// wrapping issues.\n//\n// On a side note, I'm going to put up an example later that uses four of the \n// cubemap faces, which should boost the resolution to 256... and hopefully,\n// not add too much to the complexity, and consequent lag that would follow.\nconst vec3 dimsVox = vec3(100); \nconst vec3 scale = vec3(1, 1, 1);\nconst vec3 dims = dimsVox/scale;\n\n\n\n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(tx, fcP[id]);\n}\n\n\nvec4 texMapCh(samplerCube tx, vec3 p){\n    \n    p *= dims;\n    int ch = (int(p.x*4.)&3);\n    p = mod(floor(p), dims);\n    float offset = dot(p, vec3(1, dims.x, dims.x*dims.y));\n    vec2 uv = mod(floor(offset/vec2(1, cubemapRes.x)), cubemapRes);\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    uv = fract((uv + .5)/cubemapRes) - .5;\n    return vec4(1)*texture(tx, vec3(-.5, uv.yx))[ch];\n    \n}\n\n// Used in conjunction with the function below. When doing things eight times over, any \n// saving is important. If I could trim this down more, I would, but there's wrapping\n// and pixel snapping to consider. Having said that, I might take another look at it,\n// at some stage.\nvec4 txChSm(samplerCube tx, in vec3 p){\n   \n    p = mod(floor(p), dims);\n    //vec2 uv = mod(floor(dot(p, vec3(1, dims.x, dims.x*dims.y))/vec2(1, cubemapRes.x)), cubemapRes);\n    vec2 uv = floor(dot(p, vec3(1, dims.x, dims.x*dims.y))/vec2(1, cubemapRes.x));\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably... definitely not doing this. :)\n    uv = fract((uv + .5)/cubemapRes) - .5;\n    return texture(tx, vec3(-.5, uv.yx));\n    \n}\n\n// Smooth texture interpolation that access individual channels: You really need this -- I \n// wish you didn't, but you do. I wrote it a while ago, and I'm pretty confident that it works. \n// The smoothing factor isn't helpful at all, which surprises me -- I'm guessing it molds things \n// to the shape of a cube. Anyway, it's written in the same way that you'd write any cubic \n// interpolation: 8 corners, then a linear interpolation using the corners as boundaries.\n//\n// It's possible to use more sophisticated techniques to achieve better smoothing, but as you \n// could imagine, they require more samples, and are more expensive, so you'd have to think about \n// it before heading in that direction -- Perhaps for texturing and bump mapping.\nvec4 texMapSmoothCh(samplerCube tx, vec3 p){\n\n    // Voxel corner helper vector.\n\t//const vec3 e = vec3(0, 1, 1./4.);\n\tconst vec2 e = vec2(0, 1);\n\n    // Technically, this will center things, but it's relative, and not necessary here.\n    //p -= .5/dimsVox.x;\n    \n    p *= dimsVox;\n    vec3 ip = floor(p);\n    p -= ip;\n\n    \n    //int ch = (int(ip.x)&3), chNxt = ((ch + 1)&3);  //int(mod(ip.x, 4.))\n    //ip.x /= 4.;\n/*\n    float c = mix(mix(mix(txChSm(tx, ip + e.xxx, ch).x, txChSm(tx, ip + e.yxx, chNxt).x, p.x),\n                     mix(txChSm(tx, ip + e.xyx, ch).x, txChSm(tx, ip + e.yyx, chNxt).x, p.x), p.y),\n                 mix(mix(txChSm(tx, ip + e.xxy, ch).x, txChSm(tx, ip + e.yxy, chNxt).x, p.x),\n                     mix(txChSm(tx, ip + e.xyy, ch).x, txChSm(tx, ip + e.yyy, chNxt).x, p.x), p.y), p.z);\n*/\n    \n     vec4 txA = txChSm(tx, ip + e.xxx);\n     vec4 txB = txChSm(tx, ip + e.yxx);\n\n     float c = mix(mix(mix(txA.x, txB.x, p.x), mix(txA.y, txB.y, p.x), p.y),\n                   mix(mix(txA.z, txB.z, p.x), mix(txA.w, txB.w, p.x), p.y), p.z);\n\n \n \t/*   \n    // For fun, I tried a straight up average. It didn't work. :)\n    vec4 c = (txChSm(tx, ip + e.xxx*sc, ch) + txChSm(tx, ip + e.yxx*sc, chNxt) +\n             txChSm(tx, ip + e.xyx*sc, ch) + txChSm(tx, ip + e.yyx*sc, chNxt) +\n             txChSm(tx, ip + e.xxy*sc, ch) + txChSm(tx, ip + e.yxy*sc, chNxt) +\n             txChSm(tx, ip + e.xyy*sc, ch) + txChSm(tx, ip + e.yyy*sc, chNxt) + txChSm(tx, ip + e.yyy*.5, ch))/9.;\n \t*/\n    \n    return vec4(c);\n\n}\n\n\n\n\n// If you want things to wrap, you need a wrapping scale. It's not so important\n// here, because we're performing a wrapped blur. Wrapping is not much different\n// to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash function\n// for anything that's procedurally generated with random numbers. If you're using\n// a repeat texture, then that'll have to wrap too.\nvec3 gSc;\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\n\n// 3x1 hash function.\nfloat hash( vec3 p ){ return fract(sin(dot(p, vec3(21.71, 157.97, 113.43)))*45758.5453); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    return fract(sin(mod(dot(p, vec2(27.609, 157.583)), 6.2831589))*43758.5453); \n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// IQ's exponential-based smooth maximum function. Unlike the polynomial-based\n// smooth maximum, this one is associative and commutative.\nfloat smaxExp(float a, float b, float k){\n\n    float res = exp(k*a) + exp(k*b);\n    return log(res)/k;\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n\n// With the spare cycles, I thought I'd splash out and use Dave's more reliable hash function. :)\n//\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine.\n// Creative Commons Attribution-ShareAlike 4.0 International Public License.\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33G(vec3 p){\n\n    \n    p = mod(p, gSc);\n\tp = fract(p * vec3(.10313, .10307, .09731));\n    p += dot(p, p.yxz + 19.1937);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n   \n    /*\n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = rot2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;//rotate gradient vector\n    p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n    */\n\n}\n\n/*\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33(vec3 p){ \n   \n    \n    p = mod(p, gSc);\n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    //mat2  m = rot2(iTime);//in general use 3d rotation\n\t//p.xy = m * p.xy;//rotate gradient vector\n    ////p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n    float n = sin(dot(p, vec3(57, 113, 27)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;  \n\n    \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n); \n    //return sin(p*6.2831853 + iTime)*.5; \n}\n*/\n\n// hash based 3d value noise\nvec4 hash41T(vec4 p){\n    p = mod(p, vec4(gSc, gSc));\n    return fract(sin(mod(p, 6.2831589))*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3DT(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41T(h), hash41T(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// David_Hoskins puts together some pretty reliable hash functions. This is \n// his unsigned integer based vec3 to vec3 version.\nvec3 hash33(vec3 p)\n{\n    p = mod(p, gSc);\n\tuvec3 q = uvec3(ivec3(p))*uvec3(1597334673U, 3812015801U, 2798796415U);\n\tq = (q.x ^ q.y ^ q.z)*uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn -1. + 2. * vec3(q) * (1. / float(0xffffffffU));\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .002;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHexagon(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n\n// This is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n//\n//\nvec3 cellID;\nint gIFrame;\n\nivec4 gID;\n\n// Distance metric: Put whatever you want here.\nfloat distMetric(vec3 p, vec3 b, int id){\n    \n    \n    if(id==0){\n    \treturn (dot(p, p));///2.; // Sphere squared.\n    }\n    else {\n        \n        //float d2 = sBoxS(p.xy, b.xy, 0.);\n        float d2 = sdHexagon(p.xy, min(b.x, b.y));\n        return opExtrusion(d2, p.z, b.z);\n\n        \n        //return (dot(p, p));\n        //return length(p); // Standard spherical Euclidean distance.\n\n        //return max(max(length(p.xy), length(p.yz)), length(p.xz)); // Cylinder cross.\n\n        //p = max(abs(p)*.8660254 + p.yzx*.5, -p);\n        //return max(max(p.x, p.y), p.z); // Triangular.\n\n        // Uncomment this for all metrics below.\n        p = abs(p) - b;\n        \n        \n        //p = (p + p.yzx)*.7071;\n        //return max(max(p.x, p.y), p.z); // Can't remember -- Diamond related. :)\n\n\n        return max(max(p.x, p.y), p.z); // Cube.\n        //return (p.x + p.y + p.z)*.5;//7735; // Octahedron.\n\n        //p = p*.8660254 + p.yzx*.5;\n        //return max(max(p.x, p.y), p.z); // Hex.\n\n/*        \n        float taper = (p.x + p.y + p.z)/3.*2.*.65 + .35; // Linear gradient of sorts.\n        //float taper = p.y + .5; // Original.\n        //taper = mix(taper, max(taper, .5), .35); // Flattening the sharp edge a bit.\n\n        p = abs(p)*2.;\n        //p = vec2(abs(p.x)*1.5, (p.y)*1.5 - .25)*2.; // Used with triangle.\n\n        float shape = max(max(p.x, p.y), p.z); // Square.\n        //float shape = max(p.x*.866025 - p.y*.5, p.y); // Triangle.\n        //float shape = max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n        //float shape = max(max(p.x, p.y), (p.x + p.y)*.7071); // Octagon.\n        //float shape = length(p); // Circle.\n        //float shape = dot(p, p); // Circle squared.\n\n\n        //shape = (shape - .125)/(1. - .125);\n        //shape = smoothstep(0., 1., shape);\n\n\n        //return shape;\n        return max(shape, taper);\n*/\n    }\n    \n}\n\n// 2D 3rd-order Voronoi: This is just a rehash of Fabrice Neyret's version, which is in\n// turn based on IQ's original. I've simplified it slightly, and tidied up the \"if\" statements.\n//\nvec3 Voronoi(in vec3 q, in vec3 sc, in vec3 rotF, float offsF, int id){\n    \n    \n\t//const vec3 sc = vec3(1, 2, 1);\n    gSc /= sc;\n \tvec3 d = vec3(1e5); // 1.4, etc.\n    \n    float r;\n    \n    // Widen or tighten the grid coverage, depending on the situation. Note the huge (5x5x5 tap) \n    // spread. That's to cover the third order distances. In a lot of cases, (3x3x3) is enough,\n    // but in some, 64 taps (4x4x4), or even more, might be necessary.\n    //\n    // Either way, this is fine for static imagery, but needs to be reined in for realtime use.\n    for(int z = -2; z <= 2; z++){ \n        for(int y = -2; y <= 2; y++){ \n            for(int x =-2; x <= 2; x++){\n\n                vec3 cntr = vec3(x, y, z) - .5;\n                vec3 p = q;\n\t\t\t\tvec3 ip = floor(p/sc) + .5; \n                p -= (ip + cntr)*sc;\n                ip += cntr;\n                \n                // Random position and rotation vectors.\n                vec3 rndP = hash33(ip);\n                vec3 rndR = hash33(ip + 3.)*6.2831*rotF;\n\n                // Rotate.\n                p = rot(rndR)*p;\n                //p.xy *= rot2(rndR.x);\n                //p.yz *= rot2(rndR.y);\n                //p.zx *= rot2(rndR.z);\n               \n                // Postional offset.\n                p -= rndP*offsF*sc;\n                \n                \n                // Scale -- Redundant here.\n\t\t\t\tvec3 b = sc/2.*vec3(1, 1, 1.5);\n                // Distance metric.\n                r = distMetric(p, b, id);\n\n                // 1st, 2nd and 3rd nearest distance metrics.\n                d.z = max(d.x, max(d.y, min(d.z, r))); // 3rd.\n                d.y = max(d.x, min(d.y, r)); // 2nd.\n                d.x = min(d.x, r);//smin(d.x, r, .2); // Closest.\n                \n                // Redundant break in an attempt to ensure no unrolling.\n                // No idea whether it works or not.\n                if(d.x>1e5) break; \n\n            }\n        }\n    }\n\n    \n    return min(d, 1.);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}