{
    "Shader": {
        "info": {
            "date": "1547022812",
            "description": "draw a cube. implemente camera,light, WebGL.drawArrays(TRIANGLES, 0, 3),WebGL.side,deepTest\nplan to implemente texture,drawElement,effect and others soon.\ndeepTest:  https://www.shadertoy.com/view/3sXGzl",
            "flags": 0,
            "hasliked": 0,
            "id": "tsXGzf",
            "likes": 3,
            "name": "cube Cube",
            "published": 3,
            "tags": [
                "cube"
            ],
            "usePreview": 0,
            "username": "changjiu",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "/*\n * @author changjiu\n * @date 2019.1.9\n * @contact  drift bottle\n**/\n\n/*\n * @作者 长久兄\n * @日期 2019.1.9\n * @联系方式 漂流瓶\n**/\n\nstruct Triangle\n{\n    \n    vec3 a; //pointA\n    vec3 b;\t//pointB\n    vec3 c;\t//pointC\n    vec3 n; //normal\n\n};\n\nTriangle triangles[12];\n\nvoid getOneCube( void )\n{\n    vec3 verts[8];\n\n    verts[0] = vec3( -1.0, -1.0, -1.0 );\n    verts[1] = vec3( -1.0, -1.0,  1.0 );\n    verts[2] = vec3( -1.0,  1.0, -1.0 );\n    verts[3] = vec3( -1.0,  1.0,  1.0 );\n    verts[4] = vec3(  1.0, -1.0, -1.0 );\n    verts[5] = vec3(  1.0, -1.0,  1.0 );\n    verts[6] = vec3(  1.0,  1.0, -1.0 );\n    verts[7] = vec3(  1.0,  1.0,  1.0 );\n\n    triangles[0].a = verts[1];\n    triangles[0].b = verts[5];\n    triangles[0].c = verts[7];\n    triangles[0].n = vec3( 0.0, 0.0, 1.0 );\n    \n    triangles[1].a = verts[1];\n    triangles[1].b = verts[7]; \n    triangles[1].c = verts[3];\n    triangles[1].n = vec3( 0.0, 0.0, 1.0 );\n\n\n    triangles[2].a = verts[5];\n    triangles[2].b = verts[4];\n    triangles[2].c = verts[6];\n    triangles[2].n = vec3( 1.0, 0.0, 0.0 );\n\n    triangles[3].a = verts[5];\n    triangles[3].b = verts[6];\n    triangles[3].c = verts[7];\n    triangles[3].n = vec3( 1.0, 0.0, 0.0 );\n\n\n    triangles[4].a = verts[3];\n    triangles[4].b = verts[7];\n    triangles[4].c = verts[6];\n    triangles[4].n = vec3( 0.0, 1.0, 0.0 );\n\n    triangles[5].a = verts[3];\n    triangles[5].b = verts[6];\n    triangles[5].c = verts[2];\n    triangles[5].n = vec3( 0.0, 1.0, 0.0 );\n\n    triangles[6].a = verts[0];\n    triangles[6].b = verts[6];\n    triangles[6].c = verts[4];\n    triangles[6].n = vec3( 0.0, 0.0, -1.0 );\n\n    triangles[7].a = verts[0];\n    triangles[7].b = verts[2];\n    triangles[7].c = verts[6];\n    triangles[7].n = vec3( 0.0, 0.0, -1.0 );\n\n\n    triangles[8].a = verts[1];\n    triangles[8].b = verts[2];\n    triangles[8].c = verts[0];\n    triangles[8].n = vec3( -1.0, 0.0, 0.0 );\n\n    triangles[9].a = verts[1];\n    triangles[9].b = verts[3];\n    triangles[9].c = verts[2];\n    triangles[9].n = vec3( -1.0, 0.0, 0.0 );\n\n\n    triangles[10].a = verts[1]; \n    triangles[10].b = verts[0]; \n    triangles[10].c = verts[4]; \n    triangles[10].n = vec3( 0.0, -1.0, 0.0 );\n\n    triangles[11].a = verts[1]; \n    triangles[11].b = verts[4];\n    triangles[11].c = verts[5];\n    triangles[11].n = vec3( 0.0, -1.0, 0.0 );\n\n}\n\n\nmat4 getPerspectiveProjectMatrix(float fovy, float aspect, float near, float far){\n    mat4 projectMatrix;\n    \n\tfloat rd, s, ct;\n\n\n  \tfovy = 3.1415926 * fovy / 180.0 / 2.0;\n  \ts = sin(fovy);\n\n\n  \trd = 1.0 / (far - near);\n  \tct = cos(fovy) / s;\n\n\n      projectMatrix[0][0]  = ct / aspect;\n      projectMatrix[0][1]  = 0.0;\n      projectMatrix[0][2]  = 0.0;\n      projectMatrix[0][3]  = 0.0;\n\n      projectMatrix[1][0]  = 0.0;\n      projectMatrix[1][1]  = ct;\n      projectMatrix[1][2]  = 0.0;\n      projectMatrix[1][3]  = 0.0;\n\n      projectMatrix[2][0]  = 0.0;\n      projectMatrix[2][1]  = 0.0;\n      projectMatrix[2][2]  = -(far + near) * rd;\n      projectMatrix[2][3]  = -1.0;\n\n      projectMatrix[3][0]  = 0.0;\n      projectMatrix[3][1]  = 0.0;\n      projectMatrix[3][2]  = -2.0 * near * far * rd;\n      projectMatrix[3][3]  = 0.0;\n\n      return projectMatrix;\n\n}\n\nmat4 matTranslate(mat4 e, float x, float y, float z) {\n    \n  e[3][0] += e[0][0] * x + e[1][0] * y + e[2][0] * z;\n  e[3][1] += e[0][1] * x + e[1][1] * y + e[2][1] * z;\n  e[3][2] += e[0][2] * x + e[1][2] * y + e[2][2] * z;\n  e[3][3] += e[0][3] * x + e[1][3] * y + e[2][3] * z;\n    \n  return e;\n}\n\nmat4 getViewMatrix(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ){\n    mat4 viewMatrix;\n    \n\tfloat fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n\n\n  \t  fx = centerX - eyeX;\n      fy = centerY - eyeY;\n      fz = centerZ - eyeZ;\n\n      // Normalize f.\n      rlf = 1.0 / sqrt(fx*fx + fy*fy + fz*fz);\n      fx *= rlf;\n      fy *= rlf;\n      fz *= rlf;\n\n      // Calculate cross product of f and up.\n      sx = fy * upZ - fz * upY;\n      sy = fz * upX - fx * upZ;\n      sz = fx * upY - fy * upX;\n\n      // Normalize s.\n      rls = 1.0 / sqrt(sx*sx + sy*sy + sz*sz);\n      sx *= rls;\n      sy *= rls;\n      sz *= rls;\n\n      // Calculate cross product of s and f.\n      ux = sy * fz - sz * fy;\n      uy = sz * fx - sx * fz;\n      uz = sx * fy - sy * fx;\n\n\n      viewMatrix[0][0]  = sx;\n      viewMatrix[0][1]  = ux;\n      viewMatrix[0][2]  = -fx;\n      viewMatrix[0][3]  = 0.0;\n\n      viewMatrix[1][0]  = sy;\n      viewMatrix[1][1]  = uy;\n      viewMatrix[1][2]  = -fy;\n      viewMatrix[1][3]  = 0.0;\n\n      viewMatrix[2][0]  = sz;\n      viewMatrix[2][1]  = uz;\n      viewMatrix[2][2]  = -fz;\n      viewMatrix[2][3]  = 0.0;\n\n      viewMatrix[3][0]  = 0.0;\n      viewMatrix[3][1]  = 0.0;\n      viewMatrix[3][2]  = 0.0;\n      viewMatrix[3][3]  = 1.0;\n    \n      viewMatrix = matTranslate(viewMatrix, -eyeX, -eyeY, -eyeZ);\n\n      return viewMatrix;\n\n}\n\n\nvec3 getCameraPosition(){\n\tvec3 cameraPosition;\n    cameraPosition.x = sin(iTime)*4.0;\n    cameraPosition.y = sin(iTime+0.5)*4.0;\n    cameraPosition.z = cos(iTime)*4.0;\n\treturn cameraPosition;\n}\n\nvec4 getFinalV4(vec4 v4) {\n    \n    mat4 modelMatrix = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n\t//mat4 viewMatrix = mat4(1, 0, -0, 0, -0, 1, -0, 0, 0, 0, 1, 0, 0, 0, -100, 1);\n    \n    vec3 cameraPosition = getCameraPosition();\n    mat4 viewMatrix = getViewMatrix(cameraPosition.x, cameraPosition.y, cameraPosition.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n\t//mat4 projectMatrix = mat4(2.4142136573791504, 0, 0, 0, 0, 2.4142136573791504, 0, 0, 0, 0, -1.0202020406723022, -1, 0, 0, -2.0202019214630127, 0);\t\n    \n    mat4 projectMatrix  = getPerspectiveProjectMatrix(45.0, iResolution.x/iResolution.y, 1.0, 100.0);\n    \n    mat4 mvpMatrix = projectMatrix * viewMatrix * modelMatrix;\n    \n    return mvpMatrix * v4;\n}\n\nvec4 V3ToV4(vec3 v3) {\n    \n    return vec4(v3.xyz, 1.0);\n    \n}\n\nvec2 V3ToV2(vec3 v3) {\n\n    //v3 project to iResolution.xy\n\n    float x = round(iResolution.x/2.0 + v3.x*iResolution.x/2.0);\n    float y = round(iResolution.y/2.0 + v3.y*iResolution.y/2.0);\n    return vec2(x, y);\n\n}\n\nvec2 V4ToV2(vec4 v4) {\n\n    //v4 project to between -1.0 and 1.0\n\n    vec3 v3 = vec3(v4.xyz);\n\n    v3 = v3 / v4.w;\n\n    return V3ToV2(v3);\n}\n\nfloat v2Cross(vec2 v2a, vec2 v2b) {\n    return v2a.x * v2b.y - v2a.y * v2b.x;\n}\n\nbool isPointInTriangle2D(vec2 point,vec2 tpA, vec2 tpB, vec2 tpC) {\n    vec2 PA = tpA - point;\n    vec2 PB = tpB - point;\n    vec2 PC = tpC - point;\n    \n    float t1 = v2Cross(PA,PB);\n    float t2 = v2Cross(PB,PC);\n    float t3 = v2Cross(PC,PA);\n    //return t1 * t2 > 0.0 && t1 * t3 > 0.0;\n    return t1 >= 0.0 && t2 >= 0.0 && t3 > 0.0;\n}\n\nfloat getLightWeightByNormal(vec3 normal){\n\tfloat lightWeight = 1.0;\n    \n    vec3 lightDirection1 = normalize(vec3(1.0, 0.6, 0.3));\n    \n    vec3 lightDirection2 = -1.0*lightDirection1;\n    \n    float lightWeight1 = max(0.0,dot(lightDirection1, normal));\n    \n    float lightWeight2 = max(0.0,dot(lightDirection2, normal));\n    \n\treturn lightWeight1 + lightWeight2;\n}\n\nvec3 getColorOnTriangle(Triangle triangle){\n\n    vec3 color = vec3(1,0,0);\n    \n    float lightWeight = getLightWeightByNormal(triangle.n);\n    \n    color = color * lightWeight;\n    \n    color += 0.0;\n        \n    return color;\n    \n}\n\nvec2 getV2form2Line(vec3 line1, vec3 line2){\n    vec2 v2;\n    \n\t//((b1c2-b2c1)/(a1b2-a2b1)，(a2c1-a1c2)/(a1b2-a2b1))\n    \n    v2.x = (line1.y*line2.z-line2.y*line1.z)/(line1.x*line2.y-line2.x*line1.y);\n    v2.y = (line2.x*line1.z-line1.x*line2.z)/(line1.x*line2.y-line2.x*line1.y);\n    \n\treturn v2;\n}\n\nvec3 getLineABCfrom2Point(vec2 p1, vec2 p2){\n    vec3 lineABC;\n    lineABC.x = p2.y - p1.y; //A\n\n\tlineABC.y = p2.x - p1.x; //B\n\n\tlineABC.z = p2.x * p1.y - p2.y * p1.x; //C\n    \n    return lineABC;\n\n}\n\nvec3 getV3from3v2and2v3(vec3 v3a, vec3 v3b, vec2 v2p, vec2 v2a, vec2 v2b){\n    vec3 v3;\n    \n    float ap = distance(v2a,v2p);\n    float pb = distance(v2b,v2p);\n    v3 = v3a + (v3b-v3a)*ap/(ap+pb);\n\treturn v3;\n}\n\nfloat getPointZonTriangle(vec2 v2a, vec2 v2b, vec2 v2c, vec3 v3a, vec3 v3b, vec3 v3c, vec2 p){\n\tfloat z;\n    \n    vec3 lineab = getLineABCfrom2Point(v2a, v2b);\n    vec3 linecp = getLineABCfrom2Point(v2c, p);\n    \n    vec2 v2ab = getV2form2Line(lineab, linecp);\n    \n    vec3 v3ab = getV3from3v2and2v3(v3a, v3b, v2ab, v2a, v2b);\n    \n    vec3 v3p = getV3from3v2and2v3(v3c, v3ab, p, v2c, v2ab);\n    \n    return v3p.z;\n}\n\nbool isTriangleV2clockwise(vec2 p1, vec2 p2, vec2 p3){\n    bool isTriangleV2clockwise = false;\n    \n    if ((p2.x - p1.x) *(p3.y - p1.y) -(p3.x - p1.x) *(p2.y-p1.y) < 0.0){  \n\t\tisTriangleV2clockwise = true;\n    } \n    \n    return isTriangleV2clockwise;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord;\n    \n    vec3 col;\n    \n    bool isCurrentPixInCube = false;\n    \n    getOneCube();\n    \n    int index = -1;\n    \n    float zBuffer = 99999.0;\n    \n    for(int i=0; i<12; i++ ){\n        vec2 pA = V4ToV2( getFinalV4( V3ToV4(triangles[i].a)));\n    \tvec2 pB = V4ToV2( getFinalV4( V3ToV4(triangles[i].b)));\n    \tvec2 pC = V4ToV2( getFinalV4( V3ToV4(triangles[i].c)));\n        \n        if(isPointInTriangle2D(uv, pA, pB, pC)){\n            vec4 finalV4a = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3a = finalV4a.xyz / finalV4a.w;\n            vec4 finalV4b = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3b = finalV4b.xyz / finalV4b.w;\n            vec4 finalV4c = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3c = finalV4c.xyz / finalV4c.w;\n            //float z = (finalV3a.z+finalV3b.z+finalV3c.z)/3.0;\n            \n            //float z = getPointZonTriangle(pA, pB, pC, finalV3a, finalV3b, finalV3c, uv);\n            \n            index = i;\n            /*\n            if(!isTriangleV2clockwise(pA, pB, pC)){            \n            \tindex = i;\n                break;\n            }\n\t\t\t*/\n            \n            /*\n            if(z < zBuffer){\n            \tzBuffer = z;\n                index = i;\n            }\n\t\t\t*/\n\n        };\n    \t\n    }\n    \n    \n    if(index != -1){\n    \tcol = getColorOnTriangle(triangles[index-0]);\n    }else{\n    \tcol = vec3(0.2,0.2,0);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}