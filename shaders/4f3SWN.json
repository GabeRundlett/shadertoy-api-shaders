{
    "Shader": {
        "info": {
            "date": "1713900561",
            "description": "Been fighting my GPU for weeks trying to get this to work. Went a bit overboard for the 3D visualization, but I'm really happy with it lol\n\nrun at 32 paint calls per frame, then go down to 1 per frame, then disable ultra_fast_3d",
            "flags": 32,
            "hasliked": 0,
            "id": "4f3SWN",
            "likes": 6,
            "name": "naive dsl terrain generation",
            "published": 3,
            "tags": [
                "procedural",
                "terrain",
                "landscape",
                "volumetric",
                "mountain",
                "generation",
                "absorbtion"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 131
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    \n\n\n    #ifdef start_3d\n    \n        O = texture(iChannel2, uv);\n    \n    #else \n    \n        float s = textureLod(iChannel0, vec2(1), 8.).z;\n\n        if (s > .2){\n\n            O = texture(iChannel2, uv);\n\n        } else if (s > .1){\n\n            O = texture(iChannel1, uv);\n            O = vec4(O.w*O.w, sqrt(O.w), O.w, 1);\n\n        } else {\n\n            O = texture(iChannel0, uv);\n            O = vec4(O.z*O.z, O.z, sqrt(O.z), 1);\n\n        }\n    #endif\n    \n    #ifdef debug\n        O = texture(iChannel0, uv);\n        O = O.zzzz;\n    #endif\n\n    \n    #ifdef debug2\n        if (uv.x > .5){\n            O = textureLod(iChannel0, uv, 8.); \n            if (uv.y > .5){\n                O.xy = vec2(O.z > .2);\n                O.zw = vec2(O.z > .1);\n            }        \n        }\n    #endif\n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy - r)/r.y;\n    O = vec4(0);\n    \n    float margin = \n    //1. * exp(-float(iFrame)*1e-3);\n    //max(0., exp(-float(iFrame) * 1e-3)*r.x/2. - 20.);\n    (iFrame < 512?5.:0.);\n    \n    if (length(cuv) < 2./r.y){\n        O = vec4(0,0,1,1);\n    } else {\n        O = texelFetch(iChannel0, ivec2(U), 0);\n        \n        if (O.z == 0.){ // If 0, pixel is empty. \n                       // Check for neighbours\n                      // Spawn new pixels if allowed.\n            \n            float sum = 0.; \n            bool done = false;\n            float t,w = 0.;\n            vec4 n;\n            vec2 d;\n            if (textureLod(iChannel0, uv, 1.).z > 0.){\n                for (float i = 0.; i<4.; i++){\n\n                    t = i * pi / 2. + pi*mod(float(iFrame), 100.) / 2.;\n                    d = vec2(cos(t), sin(t));\n                    n = texelFetch(iChannel0, ivec2(U + d), 0);\n\n                    if (n.z > .9){\n                        done = true;\n                        w = n.w;\n                        break;\n                    }\n\n                    sum += float(dot(n.xy,d)<-thing);\n                }\n            }\n            \n            vec3 h = hash(uvec3(U.xy, iFrame + int(iDate.w))); // iDate.w makes it different every time\n            if (sum < .1){ // Possibly spawn new pixel\n                if (h.y < 1e-4 && (U.x > r.x - margin || U.x < margin || U.y < margin || U.y > r.y - margin)){\n                    \n                    t = h.x * pi * 2.;\n                    O.xy = vec2(cos(t), sin(t));\n                    O.z = .5;\n                    \n                }\n                \n            } else { // It's ALIVEEEEE\n            \n                if (done){\n                \n                    O.z = 1.;\n                    O.w = 0.;\n                    //O.xy = d; // Unused extra info\n                    \n                } else {\n                \n                    t = h.x * pi * 2.;\n                    O.xy = vec2(cos(t), sin(t));\n                    O.z = .5;\n                    \n                }\n            }\n            \n        } else if (O.z == .5){ // If .5, pixel is moving\n        \n            O = vec4(0); // Die\n            \n        } else if (O.z > .9){ // If 1, pixel is final.\n        \n            //*\n            vec4 n;\n            vec2 d;\n            int c = 0;\n            float t,avg = 0., ma = 0.;\n            \n            if (textureLod(iChannel0, uv, 1.).z > 0.){\n\n                for (float i = 0.; i<4.; i++){\n\n                    t = i * pi / 2.;\n                    d = vec2(cos(t),sin(t));\n                    n = texelFetch(iChannel0, ivec2(U + d), 0);\n\n                    if (n.z > 0.){\n                        c++;\n                        avg += n.w;\n                        ma = max(ma, n.w);\n                    }\n\n                }\n            }\n    \n            avg /= float(c);\n            if (c == 1){\n                O.w = 0.0;\n            } else {\n                O.w = mix(avg, ma, \n                    .85 - exp(-(r.y)/3e2 - 1.)\n                );\n                //O.w = ma*.99;\n            }\n        }\n        \n        //if (iMouse.z > 0. && length(cuv - muv) < .01) O.z = 1.;\n\n    }    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    \n    float t = float(iFrame) * pi / 2.;\n    vec4 a = texelFetch(iChannel0, ivec2(U), 0);\n    vec4 b = texelFetch(iChannel1, ivec2(U), 0);\n\n    //a.w *= min(1., (-abs(cuv.y * cuv.y * cuv.y) + 1.0) * (min(cuv.x*cuv.x, 1.)*.2 + .8));\n    //Heightmap framing\n\n    a.w = pow(a.w, .5);\n    \n    if (a.z > .5) b = a;\n    if (a.w == 0.) {\n\n        vec4 n;\n        vec2 d;\n        int c = 0;\n        float ma = 0., avg = 0.;\n\n        for (float i = 0.; i<4.; i++){\n\n            t = i * pi / 2.;\n            d = vec2(cos(t),sin(t));\n            n = texelFetch(iChannel1, ivec2(U + d), 0);\n            \n            ma = max(ma, n.w);\n            avg += n.w * .25;\n        }\n\n        //b.w = avg;\n        //b.w = ma * .93;\n        //b.w = 0.;\n        //b.w = mix(avg, ma*.93, sin(iTime)*.5 + .5);\n        //b.w = avg;\n        \n        b.w = mix(ma*.99, avg, .5);\n        \n                \n    }\n    \n    \n    O = b;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define thing .65\n// .7  - high quality\n// .69 - balanced\n// .65 - fast\n\n// Thing is essentially the rate of life. \n// sin(pi/4) is the turning point between reproduction and spontaneous death\n\n#define ultra_fast_3d\n//#define start_3d\n\n// if you want to render at any reasonable speed with start_3d, make sure ultra_fast_3d is\n// enabled and you're rendering at 16+ paint calls with the shadertoy plugin.\n\n//#define debug\n//#define debug2\n\nconst float pi = 3.1415926;\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && length(z) > 1.;);\n    return z;\n}\n\nvec2 gaussianSample(uvec3 x){\n    vec3 a = hash(x)*2.-1.;\n    vec3 b = hash(x + uvec3(1))*2.-1.;\n    \n    return vec2(a.x+a.y+a.z, b.x+b.y+b.z)/3.;\n}\n\nmat2 rot(float t){\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define n(x) m=min(m, x)\n#define r iResolution.xy\n\nfloat waterLevel = .3;\nfloat scale = 7.;\n\nvec3[] dirs = vec3[5](\n    vec3(1, 0, 0),\n    vec3(0, 1, 0),\n    vec3(0, 0, 1),\n    vec3(-1, 0, 0),\n    vec3(0, -1, 0)\n);\n\n\nfloat boxDF( vec3 p, vec3 b ){ // Box Signed Distance Function By Inigo Quilez\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n} \n\n\nfloat df(vec3 p){\n    float m = 1e9;\n\n    float bounding = boxDF(p, vec3(scale/2., scale/2., 50.));\n    \n    if (bounding > .5 || p.z < 0.){\n        n(bounding);\n    } else {\n\n        vec2 uv = (p.xy *vec2(r.y/r.x, 1) +scale/2.)/scale;\n        n(\n            max(\n                p.z - texture(iChannel1, uv).w,\n                bounding\n            )\n        );\n    }\n    \n    return m;\n}\n\nvec3 normal(vec3 p, float e){\n    float c = df(p);\n    return normalize(vec3(\n        c - df(p - vec3(e, 0, 0)),\n        c - df(p - vec3(0, e, 0)),\n        c - df(p - vec3(0, 0, e))\n    ));\n}\n\nfloat plane(vec3 o, vec3 dir, vec3 pos, vec3 norm){\n    return dot(o - pos, norm) / dot(dir, -norm);\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = iMouse.z > .5?(2.*iMouse.xy - r)/r.y:vec2(iTime/2., -.3);\n    \n    float s = textureLod(iChannel0, vec2(1), 8.).z;\n    #ifndef start_3d\n        if (s < .2) return;\n    #endif\n    \n    #ifdef ultra_fast_3d\n        s = mod(float(iFrame)*16., r.y);\n\n        if (abs(U.y-s) > 8.){\n            O = texture(iChannel2, uv);\n            return;\n        }\n    #endif\n    \n    \n    \n    vec3 o = vec3(0);\n    vec3 dir = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    o -= dir*15.;\n    vec3 right = normalize(cross(dir, vec3(0, 0, 1)));\n    vec3 up = cross(right, dir);\n    \n    vec2 camUV = cuv * .2;\n    vec3 dirV = vec3(sin(camUV.x)*cos(camUV.y), cos(camUV.x)*cos(camUV.y), sin(camUV.y));\n    dirV = normalize(dir * dirV.y + right * dirV.x + up * dirV.z);\n\n    int steps = 0;\n    float d,t=0.;\n    vec3 p = o;\n    bool hit = false;\n\n    for (; steps < 2<<7; steps++){\n        p = o + dirV * t;\n        d = df(p) * min(1., max(.05, length(p.xy)/10.));\n        t += d;\n\n        if (d < 1e-2){\n            steps+=8;\n            if (steps > 2<<7 - 8) hit = true;\n        }\n    }\n\n    vec3 norm = normal(p, 5e-3);\n    float light = max(0., dot(norm, normalize(vec3(1))));\n    \n    vec3 op = p;\n    p.z = texture(iChannel1, (p.xy *vec2(r.y/r.x, 1) +scale/2.)/scale).w;\n    float gs = max(0., norm.z - .5);\n    float sr = smoothstep(waterLevel, waterLevel + .1, p.z);\n    float wt = -p.z + waterLevel;\n    \n    vec3 gscol = mix(vec3(.1, .3, .1), vec3(1), smoothstep(.6, .8, p.z));\n    vec3 srcol = mix(vec3(.7, .7, .4), vec3(.2), sr);\n    \n    O.xyz = mix(srcol, mix(srcol, gscol, sr), gs);\n    \n    if (wt > 0. && length(norm.xy) == 1.) O.xyz *= pow(vec3(.45, .83, .945), vec3(wt*50.));\n    \n    if (length(norm.xy) == 1.) light = exp(op.z);\n    \n    O.xyz *= light;\n    \n    O *= 4.;\n    O /= O + 1.;\n    \n    if (!hit){\n        O = pow(vec4(.4, .6, .9, 1), vec4(dot(dirV, vec3(0,0,-1))));\n    }\n    \n    if (!hit || (p.z < waterLevel && norm.z > 0.)){\n        // raytrace the water\n        \n        float t1 = 0., t2 = 1e3;\n        vec3 waterNorm;\n        \n        for (int i = 0; i < 5; i++){\n            float x = plane(o, dirV, dirs[i]==vec3(0,0,1)?vec3(0,0,waterLevel):dirs[i] * scale/2., dirs[i]);\n            if (dot(dirV, dirs[i]) < 0.){\n                if (x > t1){\n                    t1 = x;\n                    waterNorm = dirs[i];\n                }\n\n            } else {\n                t2 = min(t2, x);\n            }\n        }\n        \n        p = o + dirV * t1;\n        \n        if (abs(p.x) < scale/2. + 1e-3 && abs(p.y) < scale/2. + 1e-3 && p.z < waterLevel + 1e-3){\n            //O = mix(O, vec4(.1, .2, .5, 1), .8);\n            \n            O.xyz *= pow(vec3(.45, .83, .945), vec3(((hit?t:t2)-t1)*20.));\n            \n            float fresnel = pow(1.-dot(-dirV, waterNorm), 5.);\n            O += fresnel;\n        }\n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}