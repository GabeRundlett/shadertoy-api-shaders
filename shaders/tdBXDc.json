{
    "Shader": {
        "info": {
            "date": "1555094703",
            "description": "Thanks to UglySwedishFish#3207 on discord for their help with specular lighting\n\nTextured spheres ",
            "flags": 0,
            "hasliked": 0,
            "id": "tdBXDc",
            "likes": 2,
            "name": "Raytracing - Textured Spheres",
            "published": 3,
            "tags": [
                "raytracing",
                "light",
                "sphere"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 498
        },
        "renderpass": [
            {
                "code": "#define E 2.71828\n\n//ray data, used to get the pixel color by sending (or casting) a ray per pixel into the scene\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \n//material represents the way light bounces off the surface of a primitive\nstruct material\n{\n\tfloat kSpecular;\n    float kDiffuse;\n    float glossiness;\n};\n    \n//one-color sphere\nstruct sphere\n{\n\tvec3 origin;\n    vec3 color;\n    float radius;\n    material mat;\n};\n    \n//point light\nstruct light\n{\n    vec3 origin;\n  \tfloat intensity;\n};\n    \nstruct directionalLight\n{\n    vec3 direction;\n    float intensity;\n};\n\nstruct intersection\n{\n    //distance from the origin of the ray to the intersection\n    float dist;\n    //color of the primitive at the intersection\n    vec3 color;\n    //normal of the primitive at the intersection\n    vec3 normal;\n    //material of the primitive at the intersection\n    material mat;\n};\n    \nconst float renderDistance = 9999.0;\n\n//return value if a ray misses a primitive\nconst intersection miss = intersection(renderDistance, vec3(.0), vec3(.0), material(.0, .0, .0));\n\n\n\nconst int sphereCount = 6;\n\nconst int lightCount = 3;\n\nconst float ambientLight = .1;\n\nconst vec3 WHITE = vec3(1.0);\nconst vec3 GREEN = vec3(.0, 1.0, .0);\nconst vec3 RED = vec3(1.0, .0,.0);\nconst vec3 TEAL = vec3(.0, 1.0, 1.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, .0);\n\n\n//gets the intersection between a ray and a sphere\n//from : https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/minimal-ray-tracer-rendering-spheres\nintersection sphereIntersect(in ray pRay, in sphere pSphere)\n{\n    float radius2 = pSphere.radius*pSphere.radius;\n    vec3 L = pSphere.origin - pRay.origin; \n    float tca = dot(L, pRay.direction); \n    float d2 = dot(L,L) - tca * tca; \n    if (d2 > radius2) return miss; \n    float thc = sqrt(radius2 - d2); \n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    float t = min(t0, t1);\n    \n    vec3 hit = pRay.origin + pRay.direction * t;\n    vec3 coords = hit - pSphere.origin;\n\tvec2 uv = vec2(atan(coords.z, coords.x), acos(coords.y/pSphere.radius));\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    //return the distance from the ray's origin to the point\n    return intersection(t, color*pSphere.color, normalize(pSphere.origin - hit), pSphere.mat);\n}\n\nfloat lightAura(in ray pRay, in light pLight, sphere[sphereCount] spheres)\n{\n\t//distance from the ray's origin to the light's origin\n    float distanceToLightOrigin = distance(pLight.origin, pRay.origin);\n    \n    //projection of the ray on the light, aka the point on the ray which is the closest to the light's origin\n    vec3 rayProjection = pRay.origin + pRay.direction * distanceToLightOrigin;\n    \n    return pLight.intensity /(distance(pLight.origin, rayProjection)*100.0);\n}\n\n//mixes two intersection\n//Think of this as a more optimized way of saying :\n//if(mixRatio = 0) return a, else return b\nintersection mixIntersections(intersection a, intersection b, float mixRatio)\n{\n\treturn intersection\n            (\n            mix(a.dist, \tb.dist, \tmixRatio),\n            mix(a.color, \tb.color, \tmixRatio),\n            mix(a.normal, \tb.normal, \tmixRatio),\n            material\n                (\n                mix(a.mat.kSpecular, \tb.mat.kSpecular, \tmixRatio),\n                mix(a.mat.kDiffuse, \tb.mat.kDiffuse, \tmixRatio),\n                mix(a.mat.glossiness, \tb.mat.glossiness, \tmixRatio)\n\t\t\t\t)\n            );\n}\n\nfloat getDiffuse(intersection pIntersection, vec3 lightDirection)\n{\n    //clamp the dot product of the normal of the point and of the origin of the light\n\treturn clamp(dot(pIntersection.normal, lightDirection), .0, 1.0) * pIntersection.mat.kDiffuse;\n}\n\n\nfloat getSpecular(vec3 point, intersection pIntersection, ray pRay, vec3 lightDirection)\n{\n    //reflection of the light on the surface\n    vec3 reflection = reflect(lightDirection, pIntersection.normal);\n    \n    //specular term\n    //Thanks to UglySwedishFish#3207 on discord for their help with this :\n    //dot products range from -1 to 1, so the dot product of the reflection and the ray's direction\n    //has to be clamped so that a negative value doesn't get squared into a positive value\n    return pow(clamp(dot(normalize(reflection), pRay.direction), .0, 1.0), pIntersection.mat.glossiness) * pIntersection.mat.kSpecular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n    \n    directionalLight SUN = directionalLight(normalize(vec3(-.5, -1.5, 1.5)), 2.0);\n    \n    ray currentRay = ray(vec3(uv.xy, .0), normalize(vec3(uv, 1.))); \n    \n    material mat = material(.7, .2, 32.);\n    vec3 col = vec3(1.);\n    \n    vec2 path = vec2(.0);\n    path.x += sin(time);\n    path.x += sin(time*2.);\n    path.x += 2.0*cos(time*.1);\n    path.x *= sin(time);\n    \n    path.y += sin(time*.1);\n    path.y += cos(time);\n    \n    \n    //sphere definitions\n    sphere spheres[sphereCount] = sphere[sphereCount]\n\t(\n\t\tsphere(vec3(cos(time), .2, 4.0), \tWHITE,\t1., mat),\n\t    sphere(vec3(-path.x + 1.0, -path.y, 5.0), \t\tWHITE,\t1.0,mat),\n        sphere(vec3(sin(time)*2.0, 2.0, 4.0), \t\tTEAL,\t1.5,mat),\n        sphere(vec3(2.0, -1.0, 10.0), \t\t\t\tTEAL,\t.8, mat),\n        sphere(vec3(path.x, path.y, 10.0), \tGREEN,\t1., mat),\n        sphere(vec3(.0, .0, 8.0), \t\t\t\t\tRED,\t1.0,mat)\n\t);\n    \n    //light definitions\n    light lights[lightCount] = light[lightCount]\n    (\n        light(vec3(1.0, .2, 10.0 + abs(sin(iTime)*10.0)), 5.),\n        light(vec3(.0, -2.0, 10.0), 7.),\n        light(vec3(1.0, 1.0, .0), 20.)\n    );    \n    \n    intersection finalIntersection = miss;\n    \n    //for every sphere, see whether the ray intersects it\n    for(int i = 0; i < sphereCount; i++)\n    {\n        //sphere intersection returns the distance at which the sphere is intersected\n        intersection currentIntersection = sphereIntersect(currentRay, spheres[i]);\n        \n        //if the current distance is smaller than the final distance\n        //set the final intersection to be the current intersection\n        float distanceSmaller = float(currentIntersection.dist < finalIntersection.dist);\n        finalIntersection = mixIntersections(finalIntersection, currentIntersection, distanceSmaller);\n    }\n    \n    //whether the ray missed or not\n    bool rayMissed = finalIntersection.dist == miss.dist;\n    \n    //the point where the ray hit a primitive\n    vec3 hit = currentRay.origin + currentRay.direction * finalIntersection.dist;\n    \n    vec3 finalCol = vec3(.0);\n    vec3 aura = vec3(.0);\n    \n    //sun light\n    finalCol += min(finalIntersection.color * \n        (\n            getDiffuse(finalIntersection, SUN.direction) + \n            getSpecular(hit, finalIntersection, currentRay, SUN.direction)\n            + ambientLight\n        ) * \n        SUN.intensity ,1.0)*\n        clamp(dot(finalIntersection.normal, SUN.direction), ambientLight, 1.0);\n    \n    for(int i = 0; i < lightCount; i++)\n    {        \n        //the light's intensity is its intensity variable divided by its attenuation over distance\n        float lightIntensity = lights[i].intensity / pow(distance(hit, lights[i].origin), 2.0);                \n        vec3 lightDirection = normalize(hit - lights[i].origin);\n        \n        //final color\n    \tfinalCol +=\n        \t//color of the primitive\n        \tfinalIntersection.color *\n            //lighting terms\n        \t(\n            getDiffuse(finalIntersection, lightDirection)\n            + getSpecular(hit, finalIntersection, currentRay, lightDirection)\n            + ambientLight\n            ) *\n            //intensity of the light\n            lightIntensity *\n            clamp(dot(finalIntersection.normal, lightDirection), ambientLight, 1.0);\n        aura += lightAura(currentRay, lights[i], spheres)* float(finalIntersection.dist > distance(lights[i].origin, currentRay.origin));\n    }\n\n\t//background color\n\tvec3 bgCol = vec3(ambientLight) + pow(E, 1.0 - 1.0/ pow(min(dot(currentRay.direction, SUN.direction), .0), 2.0)) * YELLOW;\n    bgCol = clamp(bgCol, .0, 1.0);\n    //select between the background color (if the ray missed) and the final color (if the ray hit)\n    finalCol = mix(finalCol, bgCol, float(rayMissed));\n    finalCol += aura;\n    \n    // Output to buffer\n    fragColor = vec4(finalCol, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}