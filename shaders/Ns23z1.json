{
    "Shader": {
        "info": {
            "date": "1616959298",
            "description": "Just a bunch of cubes in a repeated space with some noisy movement",
            "flags": 0,
            "hasliked": 0,
            "id": "Ns23z1",
            "likes": 41,
            "name": "Autumn grid ",
            "published": 3,
            "tags": [
                "raymarching",
                "cubes",
                "repeated"
            ],
            "usePreview": 0,
            "username": "josemorval",
            "viewed": 915
        },
        "renderpass": [
            {
                "code": "//Box signed distance\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Distance mapping\nfloat map(vec3 p){\n    float d = 1000.;\n    vec3 q = p;\n    \n    //Here we compute the cell coordinates + index per cell\n    float size = 2.;\n    vec3 iq = floor((p+size/2.)/size);\n    q = mod(q+size/2.,size)-size/2.;\n    \n    //Some noisy pattern\n    float n=0.;\n    n+=0.5*sin(0.8*iq.x+1.1*iTime)*sin(0.71*iq.y+0.2*iTime+0.4)*sin(0.85*iq.z+0.3*iTime+1.4);\n    n+=0.5*sin(0.5*iq.x+1.1*iTime+1.5)*sin(0.3*iq.y+1.3*iTime+1.7)*sin(0.1*iq.z+0.3*iTime+2.4);\n    n = 1.-smoothstep(0.,0.2,n+0.1);\n\n    \n    //Distance to box in a cell + space clamp (tweak box distance to raymarch slow)\n    d = 0.25*box(q,0.9*vec3(n));\n    d = max(d,box(p,vec3(9.)));\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = 0.001*vec2(1.,0.);float d = map(p);\n    return normalize(vec3(map(p+e.xyy)-d,map(p+e.yxy)-d,map(p+e.yyx)-d));\n}\n\n//Raymarch (and shadow march) routines\nconst float FAR = 10000.;\nfloat raytrace(vec3 ro,vec3 rd){\n    float t = 0.;\n    for(int i=0;i<200;i++){\n        float d = map(ro+rd*t);\n        if(abs(d)<0.001){\n            return t;\n        }\n        t+=d;\n    }\n    \n    return FAR;\n}\n\nfloat shadow(vec3 ro,vec3 rd){\n    float t = 0.;\n    for(int i=0;i<200;i++){\n        float d = map(ro+rd*t);\n        if(abs(d)<0.001){\n            return 0.;\n        }\n        t+=d;\n    }\n    \n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * fragCoord/iResolution.xy;;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n\n    float f =0.5*sin(0.5*iTime)-0.5;\n\n    //Ortho camera\n    vec3 ro= 5.*vec3(3.*sin(f),2.,3.*cos(f));\n    vec3 rd = -normalize(ro);\n    vec3 up = vec3(0.,1.,0.);vec3 fw =rd;vec3 ri = cross(fw,up); up = cross(ri,fw);\n    ro=ro+20.*(uv.x*ri+uv.y*up);\n    \n    float t = raytrace(ro,rd);\n    \n    //Background\n    col = vec3(1.,0.9,0.8)*(0.4-0.3*uv.y);\n    vec3 lightdir = normalize(vec3(1.,2.,1.));\n    \n    if(t<FAR){\n        \n        //Simple lighting (dot, shadow and height based)\n        vec3 pos = ro+rd*t;\n        vec3 n = normal(pos);\n        float sha = shadow(pos+0.01*n,lightdir);\n        \n        vec3 lin = max(dot(n,lightdir),0.)*vec3(1.,0.95,0.85)*(0.+1.*sha);\n        lin += 1.1*vec3(0.1,0.05,0.0)*(1.5+0.1*pos.y);\n        \n        \n        col = lin;\n \n    }\n\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}