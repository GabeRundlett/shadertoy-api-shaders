{
    "Shader": {
        "info": {
            "date": "1613876186",
            "description": "For a good friend of mine.\n\nThe code is hilariously sloppy though, please don't scrutinize it :P",
            "flags": 0,
            "hasliked": 0,
            "id": "3lVfzh",
            "likes": 3,
            "name": "Lightning and Sunshine",
            "published": 3,
            "tags": [
                "sun",
                "lightning",
                "thunder",
                "sunshine"
            ],
            "usePreview": 0,
            "username": "timeisbeautifulhere",
            "viewed": 326
        },
        "renderpass": [
            {
                "code": "\n#define LIGHTNING_POINTS 12\n\n#define LIGHTNING_COLOR vec3(0.0,0.0,1.0)\n#define OFFSET 0.05\n#define OFFSET_TIMECONST 45.0\n//This looks interesting\n//#define OFFSET_TIMECONST 175.0\n#define SCALE_FACTOR 0.95\n#define WHITE vec3(1.0)\n\n#define SUN_POS vec2(0.0,0.7)\n#define SUN_RADIUS 0.2\n#define SUN_COLOR vec3(1.0,0.84,0.0)\n\n#define SUNRAY_RADIUS 0.7\n#define SUNRAY_COUNT 14.0\n#define SUNRAY_STRIPE_COUNT 10.0\n#define SUNRAY_SCALE 0.5\n#define SUNRAY_STRIPE_THICKNESS 0.01\n#define SUNRAY_COLOR vec3(1.0,0.41,0.0)\n#define SUNRAY_TIME_CONST 0.3\n\n#define PI 3.14159\n\n#define L_CLOSE 1\n#define L_MID 2\n#define L_FAR 3\n#define L_NONE 0\n#define L_DEBUG 10\n#define L_DEBUG2 11\n\n#define S_ORB 1\n#define S_RAY 2\n#define S_NONE 0\n\n#define BEAN_COUNT_X 8.0\n#define BEAN_COUNT_Y 5.0\n#define BEAN_THICKNESS 0.02\n#define BEAN_LENGTH 0.03\n#define BEAN_TIME_CONST 0.05\n#define BEAN_COLOR vec3(0.5,0.05,0.0)\n\nint lightning_check(vec2 uv){\n\n    float sun_y = (SUN_POS.y+1.0)/2.0;\n    if(uv.y>sun_y)\n        return L_NONE;\n    uv.y /= sun_y;\n    if(uv.y>0.95)\n        return L_NONE;\n    \n    float lightning_width = SUNRAY_RADIUS/2.0;\n    \n    int l_points = LIGHTNING_POINTS;\n    \n    int lightning_n1 = int(floor(uv.y*float(l_points)));\n    int lightning_n2 = int(ceil(uv.y*float(l_points)));\n    \n    float lightning_y1 = float(lightning_n1)/float(l_points);\n    float lightning_y2 = float(lightning_n2)/float(l_points);\n    \n    float width_n1 = lightning_width*lightning_y1,\n        width_n2 = lightning_width*lightning_y2;\n    \n    float scale1 = pow(SCALE_FACTOR, float(l_points)-float(lightning_n1)),\n        scale2 = pow(SCALE_FACTOR, float(l_points)-float(lightning_n2));\n    width_n1 *= scale1;\n    width_n2 *= scale2;\n    \n    float uv_interp = (lightning_y2-uv.y)/(lightning_y2-lightning_y1);\n    float width_uv = mix(width_n2, width_n1, uv_interp);\n    \n    float offset_offset = sin(iTime*OFFSET_TIMECONST);\n\n    float offset1 = OFFSET * scale1 * offset_offset,\n        offset2 = -1.0 * OFFSET * scale2 * offset_offset;\n    if(lightning_n1%2==0){\n        offset1*=-1.0;\n        offset2*=-1.0;\n    }\n    \n    if(lightning_n1==0)\n        offset1 = 0.0;\n    \n    float left_n1 = (-1.0)*width_n1/2.0+offset1,\n        right_n1 = width_n1/2.0+offset1,\n        left_n2 = (-1.0)*width_n2/2.0+offset2,\n        right_n2 = width_n2/2.0+offset2;\n\n    float left_uv = mix(left_n2, left_n1, uv_interp),\n        right_uv = mix(right_n2, right_n1, uv_interp),\n        middle_uv = (left_uv+right_uv)/2.0;\n    \n    if(uv.x < left_uv || uv.x > right_uv)\n        return L_NONE;\n    \n    float dist_uv = abs(uv.x-middle_uv);\n    float dist_proportion = 2.0*dist_uv/width_uv;\n    \n    if(dist_proportion<0.4)\n        return L_CLOSE;\n    if(dist_proportion<0.8)\n        return L_MID;\n    else if(dist_proportion<=1.0)\n        return L_FAR;\n    else if(dist_proportion>1.0)\n        return L_FAR;\n    else\n        return L_NONE;\n}\n\nint sun_check(vec2 uv){\n    vec2 sun_pos = SUN_POS;\n    uv.y = 2.0*uv.y-1.0;\n    vec2 relative_uv = uv - sun_pos;\n    vec2 relative_pc = vec2(\n        atan(relative_uv.y, relative_uv.x),\n        length(relative_uv)\n    );\n    \n    if(relative_pc[1]>SUNRAY_RADIUS)\n        return S_NONE;\n    \n    if(relative_pc[1]<=SUN_RADIUS)\n        return S_ORB;\n    \n    if(relative_pc[1]<=SUNRAY_RADIUS){\n        \n        //angle = [0,2PI]\n        float uv_angle = relative_pc[0]+PI;\n        float angle_displace = mod(iTime*SUNRAY_TIME_CONST, 2.0*PI);\n        uv_angle += angle_displace;\n        \n        float ray_angle_size = 2.0*PI/SUNRAY_COUNT;\n        float ray_n = floor(uv_angle/ray_angle_size);\n        float ray_angle_displace = (ray_angle_size - (ray_angle_size*SUNRAY_SCALE))/2.0;\n        \n        float ray_start = ray_n * ray_angle_size + ray_angle_displace,\n            ray_end = (ray_n+1.0) * ray_angle_size - ray_angle_displace;\n        \n        //Check if angle is in \"bounds\" of closest ray\n        if(uv_angle<ray_start || uv_angle>ray_end)\n            return S_NONE;\n        \n        //Finally, check if distance from sun puts\n        //uv on a \"ray stripe\"\n        float dist_outside_sun = relative_pc[1]-SUN_RADIUS;\n        float ray_length = SUNRAY_RADIUS-SUN_RADIUS;\n        float stripe_dist = ray_length/SUNRAY_STRIPE_COUNT;\n        \n        float closest_stripe_n = floor(dist_outside_sun/stripe_dist),\n            closest_stripe = closest_stripe_n * stripe_dist;\n        \n        if(closest_stripe_n<0.001)\n            return S_NONE;\n        \n        if(abs(closest_stripe-dist_outside_sun)<SUNRAY_STRIPE_THICKNESS)\n            return S_RAY;\n        \n        \n        return S_NONE;\n    }\n    return S_NONE;\n}\n\nbool bean_check(vec2 uv){\n    //[0,1]\n    uv.x = (uv.x+1.0)/2.0;\n    uv.x = fract(uv.x - iTime*BEAN_TIME_CONST);\n\n    float bean_dy = 1.0/BEAN_COUNT_Y,\n        bean_dx = 1.0/BEAN_COUNT_X;\n    \n    float closest_bean_y_n = round(uv.y/bean_dy),\n        closest_bean_x_n = round(uv.x/bean_dx);\n    \n    float closest_bean_y = closest_bean_y_n * bean_dy,\n        closest_bean_x = closest_bean_x_n * bean_dx;\n    \n    if(abs(closest_bean_y-uv.y)<BEAN_THICKNESS\n        && abs(closest_bean_x-uv.x)<BEAN_LENGTH){\n        //return true;\n        \n        float x_relative = uv.x-closest_bean_x;\n        if(abs(x_relative)<(BEAN_LENGTH-BEAN_THICKNESS))\n            return true;\n    \n        //Check if inside bounds of a rounded edge\n        //by making ends semicircles\n        vec2 bean_edge = vec2(0.0);\n        \n        if(x_relative<0.0){\n            bean_edge = vec2(\n                closest_bean_x-BEAN_LENGTH+BEAN_THICKNESS,\n                closest_bean_y\n            );\n        }else{\n            bean_edge = vec2(\n                closest_bean_x+BEAN_LENGTH-BEAN_THICKNESS,\n                closest_bean_y\n            );\n        }\n        \n        return distance(uv,bean_edge)<=BEAN_THICKNESS;\n            \n    }\n    else\n        return false;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // x = [-1,1], y = [0,1]\n    vec2 uv = vec2(\n        (2.0*fragCoord.x-iResolution.x)/iResolution.x,\n        fragCoord.y/iResolution.y\n    );\n    vec3 col = vec3(0.0);\n    \n    if(bean_check(uv))\n        col = BEAN_COLOR;\n    \n    int s_check = sun_check(uv);\n    int l_check = lightning_check(uv);\n    \n    if(s_check == S_RAY)\n        col = SUNRAY_COLOR;\n    \n    if(l_check == L_CLOSE)\n        col = mix(LIGHTNING_COLOR, WHITE, 0.7);\n    else if(l_check == L_MID)\n        col = mix(LIGHTNING_COLOR, WHITE, 0.3);\n    else if(l_check == L_FAR)\n        col = LIGHTNING_COLOR;\n    \n    if(s_check == S_ORB)\n        col = SUN_COLOR;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}