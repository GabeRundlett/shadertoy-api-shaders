{
    "Shader": {
        "info": {
            "date": "1491157935",
            "description": "This is a slightly modified version of Flyguy's \"Infinite Maze\" (https://www.shadertoy.com/view/Mdd3R8). I refactored the code to add a \"mainVR\" entry point.",
            "flags": 1,
            "hasliked": 0,
            "id": "Xs2yzW",
            "likes": 7,
            "name": "Infinite Maze (in VR)",
            "published": 3,
            "tags": [
                "distancefield",
                "raymarch",
                "random",
                "maze"
            ],
            "usePreview": 0,
            "username": "marciot",
            "viewed": 900
        },
        "renderpass": [
            {
                "code": "/*\n    Infinite Maze\n    --------------\n\n    Slightly modified version of the original, expanded to support VR.\n    \n    Original Author: Flyguy\n    Original URL:    https://www.shadertoy.com/view/Mdd3R8\n\n    Change Log:\n      marciot - Added mainVR\n\n*/\n\n#define PI 3.1415926535898\n\n//Raymarch settings\n\n#define MIN_DIST 0.001\n#define MAX_DIST 24.0\n#define MAX_STEPS 96\n#define STEP_MULT 1.0\n#define NORMAL_OFFS 0.01\n\n//Scene settings\n\n//#define SHOW_RAY_COST\n//#define SHOW_TILES\n#define FLY_MODE\n#define SKY_COLOR vec3(0.00, 0.00, 0.00)\n#define HAZE_COLOR vec3(0.50, 0.9, 0.00)\n#define WALL_HEIGHT 0.5\n#define WALL_WIDTH 0.125\n#define MAZE_SCALE 1.5\n\n//Object IDs\n#define SKYDOME 0.\n#define FLOOR 1.\n#define WALLS 2.\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nvec2 tile = vec2(0);\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\nfloat noise(vec2 pos) \n{\n\treturn abs(fract(sin(dot(pos ,vec2(19.9*pos.x,28.633*pos.y))) * 1341.9453*pos.x));\n}\n\nvec4 texture3Plane(sampler2D tex,vec3 norm, vec3 pos, float mip)\n{\n    vec4 texel = vec4(0);\n    \n    texel = mix(texel, texture(tex, pos.yz, mip), abs(norm.x));\n    texel = mix(texel, texture(tex, pos.xz, mip), abs(norm.y));\n    texel = mix(texel, texture(tex, pos.xy, mip), abs(norm.z));\n    \n    return texel;\n}\n\n//==== Distance field operators/functions by iq. ====\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n\nvec2 sdSphere(vec3 p, float s, float id)\n{\n  return vec2(length(p) - s, id);\n}\n\nvec2 sdPlane(vec3 p, vec4 n, float id)\n{\n  // n must be normalized\n  return vec2(dot(p,n.xyz) + n.w, id);\n}\n//===================================================\nvec2 sdMaze(vec3 p, float id)\n{\n    vec2 t = floor(p.xy * MAZE_SCALE);\n    \n\tp.xy = fract(p.xy * MAZE_SCALE) - 0.5;    \n\tp.x *= 2.0*floor(fract(noise(t) * 4.3) * 1.8) - 1.0; \n    \n\tfloat d = abs(1.0 - 2.0*abs(dot(p.xy, vec2(1.0)))) / (2.0 * sqrt(2.0));\n    \n    #ifdef SHOW_TILES\n    \ttile = t;\n    #endif\n    \n    return vec2(max((d / MAZE_SCALE) - WALL_WIDTH / 2.0, -p.z - WALL_HEIGHT), id);\n}\n\n//Distance to the scene\nvec2 Scene(vec3 p)\n{\n    vec2 d = vec2(MAX_DIST, SKYDOME);\n    \n    d = opU(d, sdPlane(p, vec4(0, 0,-1, 0), FLOOR));\n    \n    d = opU(d, sdMaze(p, WALLS));\n    \n\treturn d;\n}\n\n//Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz).x - Scene(p - off.xyz).x,\n            Scene(p + off.zxy).x - Scene(p - off.zxy).x,\n            Scene(p + off.yzx).x - Scene(p - off.yzx).x\n        )\n    );\n}\n\n//Raymarch the scene with the given ray\nMarchResult MarchRay(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec2 object = Scene(orig + dir * dist);\n        //Add the sky dome and have it follow the camera.\n        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));\n        \n        dist += abs(object.x) * STEP_MULT;\n        \n        id = object.y;\n        \n        steps++;\n        \n        if(abs(object.x) < MIN_DIST * dist)\n        {\n            break;\n        }\n    }\n    \n    MarchResult result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    result.id = id;\n    \n    return result;\n}\n\n//Scene texturing/shading\nvec3 Shade(MarchResult hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.0);\n\n    if(hit.id == FLOOR)\n    {\n        float d = sdMaze(hit.position, 0.0).x;\n        float a = smoothstep(0.05, 0.04, d);\n        \n        color = mix(vec3(0.3), vec3(1,0.1,1), a);\n    }\n    if(hit.id == WALLS)\n    {\n        float a = smoothstep(0.05, 0.04, min(-hit.position.z, hit.position.z + WALL_HEIGHT));\n        color = mix(vec3(0.3), vec3(1, 0.1, 1), a);\n    }\n    color *= texture3Plane(iChannel0,hit.normal, hit.position * 4.0, -1.0).r * 0.5 + 0.5;\n    \n    //Lighting\n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(hit.normal, direction);\n    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction, hit.normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular, 5.0));\n    color *= (1.0-(hit.steps / float(MAX_STEPS)));\n\t\n    //Fog / haze\n    float sky = smoothstep(MAX_DIST - 1.0, 0.0, hit.dist);\n    float haze = clamp(0.5/(hit.dist/MAX_DIST),0.0,1.0);\n    \n    vec3 skycol = mix(HAZE_COLOR, SKY_COLOR, clamp(-hit.position.z * 0.2, 0.0, 1.0));\n    \n    color = mix(skycol, color, sky * haze);\n    \n    #ifdef SHOW_TILES\n    color = texture(iChannel1, tile/iChannelResolution[1].xy+0.5, -99.0).rgb * (1.0-(hit.steps / float(MAX_STEPS)));\n    #endif\n    \n    return color;\n}\n   \nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{   \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.2 / 8.0);\n        angles.x = iTime * 0.2;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, 13.0 * tau / 64.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = ro + vec3(0, 0,-2) * rotate;\n    \n    #ifdef FLY_MODE\n    orig -= vec3(0, iTime, 0);\n    #else\n    orig -= vec3(0, 0, 0);\n    #endif\n    \n    rd.z *= -1.;\n    vec3 dir = rd * rotate;\n    \n    //Ray marching\n    MarchResult hit = MarchRay(orig, dir);\n    \n    //Shading\n    vec3 color = Shade(hit, dir, orig);\n    \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps / float(MAX_STEPS));\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    float FOV    = PI/3.; // FOV - Field of view.\n    vec3 forward = vec3(0., 0., -1.);\n    vec3 up      = vec3(0., 1., 0.);\n    vec3 right   = vec3(1., 0., 0.);\n    \n    // rd - Ray direction.\n    vec3 rd      = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    vec3 ro      = vec3(0.,0.,0.);\n    \n    mainVR( fragColor, fragCoord, ro, rd );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}