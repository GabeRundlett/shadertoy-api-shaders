{
    "Shader": {
        "info": {
            "date": "1572438423",
            "description": "The picture-framed image is a bit of a computer graphics cliche, but an effective way to display an otherwise simple geometric pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsKGzh",
            "likes": 47,
            "name": "Framed Geometric Pattern",
            "published": 3,
            "tags": [
                "2d",
                "truchet",
                "wood",
                "pattern",
                "maze",
                "frame",
                "herringbone"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1189
        },
        "renderpass": [
            {
                "code": "/*\n\n\n\tFramed Geometric Pattern\n\t------------------------\n\n\tI made this a while ago. It's not that exciting, but I thought I'd put\n\tit up anyway. :)\n\n    The picture-framed image is a bit of a computer graphics cliche, but an \n\teffective way to display an otherwise simple geometric pattern. Like a \n\tlot of grid-based patterns out there, this one is Truchet based. The \n\tpicture frame itself was applied using standard distance field and \n\tlayering techniques.\n\n\tThe background image is just some offset circles and is based on an\n\tunderlying herringbone grid pattern. The timber is just an application of \n\tan old layered noise technique, which I'd imagine was first oulined by \n\tKen Perlin, back in the day.\n\n\t\n\tOther Examples:\n\n    // BigWIngs's popular Youtube channel. It's always informative seeing how \n\t// others approach various graphics topics.\n    Shader Coding: Truchet Tiling Explained! -  The Art of Code\n\thttps://www.youtube.com/watch?v=2R7h76GoIJM\n\n\n\t// Flipped Truchet pattern basics. Fabrice does it in a few of his \n\t// examples too, if anyone wants to track them down.\n    TruchetFlip - JT\n    https://www.shadertoy.com/view/4st3R7\n\n\n*/\n\n// Originally, this was a plain pattern I put together, just for something to do.\n// I thought it looked a little too plain, so got a bit carried away. Anyway, if\n// you're more of a \"less is more\" person, like me, here's the original.\n//#define PATTERN_ONLY\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589))*43758.5453); \n}\n\n// IQ's animated vec2 to float hash.\nfloat hash21A(vec2 p){  \n    float x = fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n    return sin(x*6.2831 + iTime/3.)*.5 + .5;\n}\n\n// IQ's rounded box formula -- slightly modified.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// Textureless 3D Value Noise:\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value noise.\n//\n// By the way, a few people have managed to reduce the original down to this state, \n// but I haven't come across any who have taken it further. If you know of any, I'd\n// love to hear about it.\n//\n// I've tried to come up with some clever way to improve the randomization line\n// (h = mix(fract...), but so far, nothing's come to mind.\n\nfloat n3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(27, 113, 57);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*p*(p*(p * 6. - 15.) + 10.);\n    \n    // Even smoother, but this would have to be slower, surely?\n\t//vec3 p3 = p*p*p; p = ( 7. + ( p3 - 7. ) * p ) * p3;\t\n\t\n    // Cosinusoidal smoothing. OK, but I prefer other methods.\n    //p = .5 - .5*cos(p*3.14159);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n);\n    return sin(p*6.2831853 + iTime*1.57); \n    \n}\n\n\n// The Truchet distance field. Truchet patterns, in their various forms, are \n// pretty easy to put together; Render some rotationally symmetric tiles, then\n// randomly rotate them. If you know how to render simple 2D objects like \n// squares, circles, arcs, etc, you should be good to go. As you can see from\n// the imagery, these tiles consist of a line of circles and some chopped\n// out circles.\nfloat distField(vec2 p){\n    \n    // Saving the original position.\n    vec2 oP = p;\n \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Random value for the tile. This one is time based.\n    float rnd = hash21A(ip);\n    \n    // If the random number generated by the unique ID for the\n    // tile is above a certain threshold, flip it upside down.\n    if(rnd<.5) p.y = -p.y;\n  \n    \n    // Distance field.\n    float d = 1e5;\n    \n    // Radius.\n    float r = .09;\n    \n    // Two circles on diagonally opposite corners.\n    d = min(d, length((p) - vec2(-.5, .5)) - .5);\n    d = min(d, length((p) - vec2(.5, -.5)) - .5);\n\n    // Some small circles down the center.\n    float d2 = length(p - .3) - r*.9;\n    d2 = min(d2, length(p - .1) - r*.7); \n    d2 = min(d2, length(p + .1) - r*.7); \n    d2 = min(d2, length(p + .3) - r*.9);  \n    \n    // Flip checkered tiles. It's a necessary operation to perform\n    // for this style of Truchet tile.\n    if(mod(ip.x + ip.y, 2.)<.5) d = -d;\n    if(rnd>=.5) d = -d;\n    \n    // Put in some decorative borders. I like them, but you can take\n    // them out if you feel it's too much.\n    d = max((d - r*1.25), -(abs(abs(d ) - .05) - r/3.));\n    \n    // Combining the dotted lines and circles, whilst allowing for\n    // the checkerboard flipping.\n    if(mod(ip.x + ip.y, 2.)<.5){\n        if(rnd<.5) d = max(d, -d2);\n        else d = min(d, d2);\n    }\n    else {\n       if(rnd<.5) d = min(d, d2);\n        else d = max(d, -d2); \n    }\n    \n    // Adding a grid. Not necessary, but I like it.\n    p = abs(p);\n    float grid = abs(max(p.x, p.y) - .5) - .015;\n    d = min(d, grid);\n    \n   \n    // Rendering circles at the grid vertices, whilst accounting\n    // for checkerboard flipping.\n    vec2  q = oP - .5;\n    vec2 iq = floor(q);\n    q -= iq + .5;\n\n    if(mod(iq.x + iq.y, 2.)<.5){\n        d = min(d, length(q) - r*1.4);\n    }\n    else {\n       d = max(d, -(length(q) - r*1.4));\n    }\n    \n\n    // Return the distance field value.\n    return d;\n}\n\n// Skewing and unskewing.\nvec2 skewXY(vec2 p, vec2 v){ return mat2(1, -v.y, v.x, 1)*p; }\nvec2 unskewXY(vec2 p, vec2 v){ return inverse(mat2(1, -v.y, v.x, 1))*p; }\n\n\n// The background pattern.\nvec4 bgField(vec2 q2){\n    \n    // Helper variables: Scale, skewing vector, \n    // individual cell dimension, and block dimension.\n    const float scale = 1./1.25;\n\tconst vec2 sk = vec2(1, -1)/5.; // 12 x .2\n\tvec2 dim = vec2(1.5, 1)*scale;\n\tvec2 s = (vec2(2.5, 2.5) - abs(sk)/2.)*scale; // 12 x .2\n\n    \n    \n    float d = 1e5;\n    vec2 cntr, p, ip;\n    \n    vec2 id = vec2(0);\n    vec2 l = dim;\n    cntr = vec2(0);\n    float boxID = 0.;\n    vec2 offs = vec2(1, 0);\n    \n    for(int i = 0; i<4; i++){\n         \n        // With herringbone arrangements, the rectangular tile needs to\n        // be intermittently rotated by 90 degrees, which means flipping\n        // dimensions, etc.\n        if(i==2) {\n            cntr = vec2((dim.x + dim.y)/2., -dim.y/4.);\n            l = l.yx;\n            offs = offs.yx;\n        }\n        \n    \tp = q2 - cntr; // Local coordinates, based on a square grid.\n    \tp = skewXY(p, sk); // Skewing by the X and Y skewing values.\n        ip = floor(p/s); // Local tile ID.\n        p -= (ip + .5)*s; // New local position.\n        p = unskewXY(p, sk); // Unskewing.\n\n        \n        // Individual positional tile ID.\n        vec2 idi = ip*s + cntr + l/2.;\n        // Don't forget to unskew the ID... Yeah, skewing is confusing. :)\n        idi = unskewXY(idi, sk);\n        \n        // The brick dimension itself. Not used here.\n        //float di2D = sBoxS(p, l/2., .04);\n       \n \n        // We're rendering a large circle and two smaller circles in each \n        // rectangular tile, which are randomly flipped in accordance with\n        // the tile ID.\n        if(hash21(idi)<.5) p = -p;\n        \n        float lw = dim.y/4.; // Offset.\n        float sz = dim.y/2.; // Size.\n        float ew = .04*scale; // Empty border width, or margin, to CSS folk.\n        \n        vec3 df;\n        \n        // Large circle, and two smaller circles.\n        df.x = length(p - offs*lw) - (sz - ew);\n        df.y = length(p + offs*lw*2. + offs.yx*lw) - (sz/2. - ew);\n        df.z = length(p + offs*lw*2. - offs.yx*lw) - (sz/2. - ew);\n\n        // A little offset circle inside the large circle.\n        vec2 rnd22 = hash22(idi);\n        df.x = max(df.x, -(length(p - offs*lw - rnd22*(lw/2. + .05*scale)) - lw/2.5));          \n \n        // Obtain the smallest of the three circles for this particular tile.\n        vec3 dfi = df.x<df.y && df.x<df.z? vec3(df.x, offs*lw) :\n        \t\t   df.y<df.z? vec3(df.y, offs*lw*2. + offs.yx*lw) :\n        \t\t   vec3(df.z, offs*lw*2. - offs.yx*lw);\n        \n        // If one of the circle objects in this particular tile is smaller than the\n        // overall smallest object, update the distance field, object ID, and make\n        // a note of the rectangular tile ID.\n        if(dfi.x<d){\n            \n            d = dfi.x;\n            id = idi + dfi.yz;\n            boxID = float(i);\n            \n        }\n        \n        // Move the position down by the longest length.\n        cntr -= -dim.y;\n        \n    }\n    \n    // Return the distance, ID and rectangular tile ID.\n    return vec4(d, id, boxID);\n}\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n    // Return the hatch value.\n    return hatch;\n    \n}\n\n \n// One of many simple wood grain formulas. Not much thought was put into it.\n// This one has accentuated grain marks for a more cartoonish look, but more\n// realistic grains can be created in a simpilar fashion.\nvec4 woodGrain(in vec3 p){\n\n   \n    // Noise.\n    float ns = (n3D(p*96.)*.67 + n3D(p*192.)*.33);\n    \n    // Slight perturbation.\n    //p += (n3D(2.5*p)*.66 + n3D(5.*p)*.34)*.5;\n    p += (n3D(2.*p)*.57 + n3D(4.*p)*.28 + n3D(8.*p)*.15)*.5;\n    \n    // Stretching things out along one of the axes -- In this case the Y axis.\n    p *= vec3(1, 80, 1)*4.;\n    \n    // Cheap fract lines.\n    float v = fract(-p.y*.1);\n    //float v = fract(dot(p, vec3(-.1)));\n    v *= v;\n    v = min(v, v*(1. - v)*5.); // Smoothing the fract lines.\n\n    // Using the value above to produce the timber color. I did this a while\n    // ago, but I'm sure I knew what I was doing at the time. :D\n    vec3 rWood = pow(min(vec3(1.5, 1, 1)*mix(.3, .9, v), 1.), vec3(1, 3, 12));\n    vec3 wood = mix(vec3(.6, .4, .2), vec3(1.2, .8, .4), v);\n    //vec3 wood = mix(vec3(.5, .125, .025)/1.25, vec3(.75, .27, .05)*1.5, v);\n    //vec3 wood = mix(vec3(1, .8, .6)/3., vec3(1.2, 1, .8), v);\n    \n    wood = mix(wood, rWood, .25 - v*.25);\n    \n    // Adding in a sprinking of noise.\n    vec3 rNoise = pow(min(vec3(1, 1, 1)*mix(.8, 1., ns), 1.), vec3(1, 2, 3));\n    wood = min(wood*rNoise*1.1, 1.);\n    \n    // Toning things down, just a touch.\n    //wood = pow(wood, vec3(.95));\n    \n    // Returning the timber color value, and the distance value -- which in this\n    // case, is just the red channel, but it could be something more sophisticated.\n    return vec4(wood, wood.x);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling only.\n    float gSc = 10.;\n    vec2 p = uv*gSc;\n    \n    // Saving a copy of the original.\n    vec2 oP = p;\n    \n    // Resolution based scaling.\n    float sf = gSc/iResolution.y;\n\n    // The framed distance field.\n    float d = distField(p);\n    \n    // The background pattern.\n    vec4 dBg = bgField(rot2(-3.14159/4.)*oP);\n    \n    // Frame width, rounding factors and frame dimensions.\n    const float frW = .45;\n    const float rF = .05, rF2 = .01;\n    vec2 fDim = vec2(14, 6);\n    \n    #ifdef PATTERN_ONLY\n    // A quick hack to display the Truchet pattern only.\n    fDim *= 2.;\n    #endif\n    \n    \n    \n    // The square frame.\n    vec2 q = p;\n    float sqr = sBoxS(q, fDim/2. + frW*2., rF);\n    float fr = max(sqr, -sBoxS(q,fDim/2., rF2)); \n  \n    // The frame shadow.\n    q = (p - vec2(frW/2., -frW/2.));\n    float sqr2 = sBoxS(q, fDim/2. + frW*2., rF);\n    float fr2 = max(sqr2, -sBoxS(q, fDim/2., rF2));\n    \n    \n    // Using a standard distance filed operation to cut down the size of \n    // the cavas to the frame.\n    d = max(d, sqr + frW*2.);\n\n    \n    // A hatch value, just to add a little extra texture here and there.\n    float hatch = doHatch(oP/gSc, iRes);\n    \n    \n    // The timber color.\n    float frSh = clamp(.25 - fr/frW*2., 0., 1.);\n    vec4 wGrain = woodGrain(vec3(oP/4., 1. + frSh*.1));\n    // Last minute adjustment: Toning the wood grain down a bit, if desired.\n    //wGrain.xyz = mix(wGrain.xyz, wGrain.w*wGrain.w*vec3(.85, .8, .75), .25);\n \n    \n    // Applying some cheap hatching.\n    wGrain.xyz *= hatch*.3 + .8;\n\n    \n    // The scene color. Initialized to zero.\n    vec3 col = vec3(0);\n     \n    \n    // Applying the background circle pattern.\n    vec4 wGrainBg = woodGrain(vec3(oP/3. + .5, 1.));\n    col = vec3(.95, .8, .7)*(wGrainBg.w*.3 + .85);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*1.5, dBg.x))*.35);\n    col = mix(col, vec3(.95, .8, .7)*(hatch*.2 + .9), (1. - smoothstep(0., sf, dBg.x + .05))*.7);\n\n    // A cleaner background.\n    //col = vec3(.95, .8, .7);\n    //col *= wGrainBg.w*.5 + .7;     \n    \n    // Applying some subtle hatching.\n    col *= hatch*.35 + .75;\n         \n    \n    // Putting the frame shadow down first.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*15., fr2 - .05))*.65);\n    \n    // The frame.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., fr))*.5);\n    col = mix(col, wGrain.xyz*frSh, (1. - smoothstep(0., sf, fr)));\n   \n   \n    // The frame content: In this case, the dot-like Truchet pattern.\n    col = mix(col, vec3(.8) + hatch*.3, (1. - smoothstep(0., sf, sqr + frW*2.)));\n    col = mix(col, vec3(.01, .005, 0) + hatch*.05, (1. - smoothstep(0., sf, d)));\n    \n    // Outer edging.\n    col = mix(col, vec3(.1, .05, 0), (1. - smoothstep(0., sf*1.5, abs(fr + .01) - .01))*.85);\n    \n    // Inner edging... or something like that -- Like everyone else, I make this stuff \n    // up as I go along. :)\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*1.5, abs(fr + .15) - .01))*.75);\n    \n    // Subtle highlighting.\n    col = mix(col, col*1.35, (1. - smoothstep(0., sf*4., max((fr + .02), -(fr2 + .02)))));\n\n  \n    // Cheap paper grain.\n    oP = floor(oP/gSc*1024.);\n    vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    col *= .9 + .1*rn3.xyz  + .1*rn3.xxx;    \n\n     \n     \n    // Applying a subtle silhouette, for art's sake.\n\tuv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./32.); \n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}