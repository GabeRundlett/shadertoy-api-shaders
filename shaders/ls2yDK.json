{
    "Shader": {
        "info": {
            "date": "1493913242",
            "description": "distance to y=cos(x)\nshow point-ARRAY-distance, ended up showing the distance to (an array of) x=sin(y);\n#define showWhat\nshows 1 of 4 quadrants, zoomed, the rest is mirror symmetry.\nas texture THAT should have more utility than the font-texture. Fourier!",
            "flags": 0,
            "hasliked": 0,
            "id": "ls2yDK",
            "likes": 4,
            "name": "y=cos(x) distance texture ",
            "published": 3,
            "tags": [
                "sin",
                "linear",
                "array",
                "algebra",
                "lut"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 770
        },
        "renderpass": [
            {
                "code": "//started as a plotter that shows distane to an ARRAY of points\n//ended up as showing the distance to (an array of) x=sin(y);\n//only shows 1 of 4 quadrants, the rest is mirror symmetry.\n\n//parent: https://www.shadertoy.com/view/XsByzd\n\n//uncomment and make this a texture to load n iChannel*\n//#define showWhat\n\n//comment out to show fract() of gradient:\n//#define fractit\n\n#define zoom 16.\n\n\n#define pi acos(-1.)\n\n//return framed [u]\nvec2 frame(vec2 u){u=u/iResolution.xy;\n #ifndef showWhat\n u.y-=.5;\n u.x*=iResolution.x/iResolution.y;\n u*=zoom*4.;\n #else\n u=u.yx;\n u.x*=pi*.5;\n u.y*=32.;\n #endif\n return u;}\n\n//return shortest distance of [p] to an array of vec2();\nfloat points(vec2 p){const int num=9;\n vec2 points[num];\n //this point-array comes from \n //https://www.shadertoy.com/view/XsByzd\n //and could lead to a bilinear solution to the same prolem.\n //but i cant find a good f(x) for this series:\n //it sure looks very tan() and log()\n points[0]=vec2(-0.875,pi/8.);\n points[1]=vec2(-0.75 ,pi/6.);\n points[2]=vec2(-0.5  ,pi/4.);\n points[3]=vec2(-0.25 ,pi*sqrt(2.)/4.);\n points[4]=vec2(0.    ,pow(pi,sqrt(2.)/4.0 )); \n points[5]=vec2(0.25  ,pow(pi,sqrt(2.)/2.0 ) ); \n points[6]=vec2(0.5   ,pow(pi,sqrt(2.)/sqrt(2.) )) ;\n points[7]=vec2(0.75  ,pow(pi,sqrt(2.))) ;\n points[8]=vec2(0.875 ,pow(pi,sqrt(2.))*3./2.);\n float r=exp2(126.);\n for (int i=0;i<num;i++){r=min(r,length(points[i]-p));}return r;}\n\n//w.x=wavelength w.y=amplitude\nfloat pointsSin(vec2 p,vec2 w){const float num=200.;\n const float tau=pi*2.;float r=1e22;\n for (float i=-100.;i-100.<num;i++){\n  float q=tau*i/num;\n  vec2 s=vec2(q,w.y*sin(q*w.x));\n  r=min(r,length(s-p));\n }return r;}\nfloat pointsSin(vec2 p){return pointsSin(p,vec2(1));}//special default\n                \nvoid mainImage(out vec4 Out,in vec2 In){\n vec2 u=frame(In);\n vec2 m=frame(iMouse.xy);\n //float lines=smoothstep(.0,.05,min(abs(u.x),abs(u.y)));\n //float grid=max(u.x,u.y);\n //grid=fract(grid); \n float point=0.;\n m.x/=pi*2.*zoom;\n m.x=1./m.x;\n \n \n m.x=max(m.x,.85);//my approximation sucks for longer wavelengths\n //scale amplitude and inverse scale both instead;\n \n //m.y=.0;//enforce amplitude of 0;\n if(iMouse.w>1.)point=pointsSin(vec2(mod(u.x,pi*2./m.x),u.y),m);\n else           point=pointsSin(vec2(mod(u.x    ,pi*2.    ),u.y));\n //point=points(u-vec2(16,0))-.05; //visualize a challenge.\n float red  =point;\n float green=point/32.;\n float blue =1./log(point*2.+1.);\n #ifndef fractit\n // fract(a*10./zoom) avoids moire nicely.\n red  =fract(red*10./zoom);//red  =fract(log2(red)*2.);\n //green=fract(green*10./zoom);\n //blue =fract(blue *10./zoom);\n #endif\n Out=vec4(red,green,blue,1);\n}\n\n/*\n//return angle between 2 vectors (is unsigned)\nfloat angleBetween(vec2 a,vec2 b){\n return acos(dot(normalize(a),normalize(b)));\n}\n//if(c is left of ray from a to b)return 1.; return 0.;\nfloat  isLeft(vec2 a,vec2 b,vec2 c){c-=a;b-=a;\n return step(determinant(mat2(b,c)),0.);}\n\n//return smoothstepped distance of p from a, to paint a dot\nfloat ddot(vec2 p,vec2 a){float r=length(p-a);\n return smoothstep(.1,.0,r);}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}