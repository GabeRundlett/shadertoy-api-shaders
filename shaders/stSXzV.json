{
    "Shader": {
        "info": {
            "date": "1628071929",
            "description": "This is shader displaying multiple stars layers, giving sence of animation (pass through them). \nYou can look around by holding left mouse button.\nShader was created based on video from 'The Art of Code' youtube channel.",
            "flags": 0,
            "hasliked": 0,
            "id": "stSXzV",
            "likes": 5,
            "name": "MN_StarField",
            "published": 3,
            "tags": [
                "stars",
                "starfield"
            ],
            "usePreview": 0,
            "username": "MarekNijaki",
            "viewed": 436
        },
        "renderpass": [
            {
                "code": "// Shadertoy uses GLSL language.\n\n// UV.\n// Default 'UV'.\n// vec2 uv = fragCoord/iResolution.xy; \n\n// Time varying pixel color.\n// vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\n// Default background colour.\n// Output to screen\n// fragColor = vec4(col,1.0);\n\n\n\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n\n// Global constant PI value.\nfloat PI = 3.1415;\n// Global constant for UV.\nvec2 UV;\n\n// Example how to check 'UV' coordinates values.\n// fragColor = vec4(vec3(0)+UV.x,1.0);\n// fragColor = vec4(vec3(0)+UV.y,1.0);\nvec2 GetUV_WithOriginInTheCenter(in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    // Multiply by '0.5' so 'UV' coordinates have their origin/pivot in the middle/center of the screen.\n    // 'UV' values will go from '-0.5' to '0' to '0.5'. \n    vec2 UV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    // Return value.\n    return UV;\n}\n\n// For 'numberOfGridTiles=3' 'UV' values will go from '-1.5' to '0' to '1.5'.\nvec2 SetGridTiles(vec2 UV, float numberOfGridTiles)\n{ \n    // Set tiles.\n    UV = UV * numberOfGridTiles;\n    // Return value.\n    return UV;\n}\n\n// Create grid ID's.\n// Can be visualised by 'col.rg +=  gridIDs;'.\n// Each cell will have diffrent colour.\nvec2 CreateGridIds(vec2 UV)\n{\n    // Get ID (truncate 'UV' coordinates numbers to only integer value, eg. '2.3' will give '2').\n    vec2 IDs = floor(UV);\n    // Return value.\n    return IDs;\n}\n\n// Create grid UV.\nvec2 CreateGridUV(vec2 UV)\n{\n    // WTF? not from -1.5 to 1.5 ???\n    // 'UV' goes from '-3' to '3', 'fract()' will return only fractual component of numbers. \n    // Each cell have values from '0' to '1'.\n    vec2 gridUV = fract(UV);\n    // Move origin of each cell from left bottom corner to middle of each cell.\n    // Each cell have values from '-0.5' to '0.5'.\n    gridUV = gridUV - 0.5;\n    // Return value.\n    return gridUV;\n}\n\n// Draw debug lines to show outline of the cells.\nvec3 DrawDebugCells(vec2 gridUV)\n{\n    // Create variable to store line colour.\n    vec3 col;\n    // Draw lines\n    if((gridUV.x > 0.49) || (gridUV.y > 0.49))\n      col.r = 1.0;\n    // Return value.\n    return col;\n}\n\n// Generate pseudo random value.\n// Can be Displayed by 'col = col + GeneratePseudoRandom_FromHash21(gridIDs);'\nfloat GeneratePseudoRandom_FromHash21(vec2 point)\n{\n    // Twist number so it will lok like random number.\n    point = fract(point * vec2(123.34, 456.21));\n    point = point + dot(point, point + 45.32);\n    // Get random value.\n    float randomVal = fract(point.x * point.y);\n    // Return value.\n    return randomVal;\n}\n\n// Randomize positions of grid 'UV' positions.\nvec2 RandomizeGridUVPositions(vec2 gridIDs, vec2 gridUV)\n{\n    // Get random value from '0' to '1'.\n    float randomOffsetX = GeneratePseudoRandom_FromHash21(gridIDs);\n    float randomOffsetY = fract(randomOffsetX * 34.0);\n    // Shift offset so shifted star will not go out of the cell completly (origin of the star was in '0.5, 0.5').\n    // Offsets will have values between '-0.5, -0.5' to '0.5, 0.5'.\n    randomOffsetX = randomOffsetX - 0.5;\n    randomOffsetY = randomOffsetY - 0.5;\n    // Randomize values of UV from '0' to '1' based od cells ID's.\n    gridUV = gridUV - vec2(randomOffsetX,randomOffsetY);    \n    // Return value.\n    return gridUV;\n}\n\n// Get distance to the center of 'UV'.\nfloat GetDistanceToTheCenter(vec2 UV)\n{\n    \n    // Origin is in the middle. \n    // 'length(UV)' will return distance for each pixel from UV to the middle.\n    // You can imagine this as a circle that is going from black to white (from middle to edges).\n    // For length value of '0' colour is black , for '1' colour is white.\n    float distanceToTheCenter = length(UV);\n    // Return value.\n    return distanceToTheCenter;\n}\n\n// Create smoothstep circle.\n// NOT USED BECAUSE: \n//   * In normal world, lighting fall off should go smoothly all the way to the screen edge.\n//   * 'smoothstep()' will have hard '0' or '1' values for areas outside of tresholds.\nfloat CreateSmoothstepWhiteCircle(vec2 UV, float lowerCutoff, float upperCutoff)\n{\n    // Get distance to the center of 'UV'.\n    float distanceToTheCenter = GetDistanceToTheCenter(UV); \n    // Smooth out the circle.    \n    // 'smoothstep()' takes two cutoff/edges parameters, which determine the lower and higher threshold values for the curve. \n    // When 'In' is lower than 'lowerCutoff', the output is '0', and when 'In' is above 'upperCutoff', the output is '1'.\n    // 'smoothstep()' will return interpolates between 'lowerCutoff' and 'upperCutoff' in a similar way to Lerp. \n    // However, the interpolation will gradually speed up from the start and slow down toward the end. \n    // This is useful for creating natural-looking animation, fading and other transitions.\n    float darkCircle = smoothstep(lowerCutoff, upperCutoff, distanceToTheCenter);\n    float whiteCircle = 1.0 - darkCircle;\n    // Return value.\n    return whiteCircle;\n}\n\nfloat CreateSmoothWhiteCircle(vec2 UV, float minInnerCircleRadius)\n{\n    // Get distance to the center of 'UV'.\n    float distanceToTheCenter = GetDistanceToTheCenter(UV); \n    \n    // Try not divide by 0?!!!\n    //if(distanceToTheCenter <> 0)\n    // 'clamp(x,min,max)' returns the value of 'x' constrained to the range 'min' to 'max'.\n    //whiteCircle = minInnerCircleRadius / clamp(distanceToTheCenter, -1.5, 1.5);\n    \n    // Create circle\n    float whiteCircle = minInnerCircleRadius / distanceToTheCenter;\n    // Return value.\n    return whiteCircle;\n}\n\n// Create cross/flares/rays.\nfloat CreateWhiteCross(vec2 UV, float crossIntensity)\n{    \n    // Gradient between '-0.5' to '0' to '0.5'.\n    float blackToWhiteGradientX = UV.x;\n    float blackToWhiteGradientY = UV.y;\n    // Gradient between '0.5' to '0' to '0.5'.\n    // This will look like vertical and horizontal black lines.\n    float whiteToBlackToWhiteGradientX = abs(blackToWhiteGradientX);\n    float whiteToBlackToWhiteGradientY = abs(blackToWhiteGradientY);\n    // Create cross/flare.\n    float blackCross = whiteToBlackToWhiteGradientX * whiteToBlackToWhiteGradientY; \n    // Set thickness/bluriness of cross/flare (higher value will result in clearer lines).\n    float crossSize = 1000.0;\n    blackCross = blackCross * crossSize;\n    // Clamp values between '0' and '1'.\n    blackCross = min(1.0, blackCross);\n    blackCross = max(0.0, blackCross);\n    // Create white cross.\n    float whiteCross = 1.0 - blackCross;\n    // Set intensity.\n    whiteCross = whiteCross * crossIntensity;\n    // Return value.\n    return whiteCross;\n}\n\n// Return rotation angle matrix.\n// 'PI' is aroung '3.1415'\n// '360' degrees is two 'PI' radians.\n// '180' degrees is 'PI' radians.\nmat2 RotationAngle(float angle)\n{\n    float sinus = sin(angle);\n    float cosinus = cos(angle);\n    return mat2(cosinus,-sinus,sinus,cosinus);\n}\n\n// Create star.\nvec3 CreateStars(vec2 gridIDs, vec2 UV, float starIntensity, float innerCircleRadius, float crossIntensity, \n                 float minRange, float maxRange, vec3 col)\n{\n    // Create circle.\n    float whiteStar = CreateSmoothWhiteCircle(UV, innerCircleRadius);\n        \n    // Applay first cross/flares/rays.\n    whiteStar = whiteStar + CreateWhiteCross(UV, crossIntensity);\n    // Rotate 'UV' around '45' degrees angle.\n    UV = UV * RotationAngle(PI / 4.0);\n    // Applay second cross/flares/rays.\n    whiteStar = whiteStar + CreateWhiteCross(UV, crossIntensity);\n    \n    // Get distance to the center of 'UV'.\n    float distanceToTheCenter = GetDistanceToTheCenter(UV); \n    // Cut star.\n    // Cut is needed, because in some cases, glow and flares could go out of the cell - for values bigger than '0.5'.\n    // That would be fine because neighbourhood cells will take care of drawing appropiate parts of star, but it can't go\n    // further - eg. 2 or more cells, because it would lead to artifacts.\n    minRange = clamp(minRange, 0.0, 0.5);\n    maxRange = clamp(maxRange, 0.0, 1.0);\n    whiteStar = whiteStar * smoothstep(maxRange, minRange, distanceToTheCenter); \n    \n    // Apply intensity.\n    whiteStar = whiteStar * starIntensity;\n    \n    \n    // Convert white star to star with colour.\n    vec3 star = vec3(whiteStar);\n    // Apply colour.    \n    star = star * col;\n    \n    // Return value.\n    return star;\n}\n\n// Create random colour.\nvec3 CreateRandomColour(vec2 gridIDs, float starIntensity)\n{\n    // Generate random value.\n    float randomVal = GeneratePseudoRandom_FromHash21(gridIDs);\n    // Rate of colour changes.\n    float colourChangeRate = 2.0;\n    \n    // Because small values are very close to each other, colour components will look almost the same.\n    // To avoid that we can multiply those components by some big number to disperse them all over 'sin()' method.\n    //float colourComponentsDispersionMagnifier = 1.0;\n    //vec3 col = sin(vec3(0.2, 0.3, 0.9) * randomVal * colourComponentsDispersionMagnifier) / 2.0 + 0.5;\n    \n    // Create random colour.\n    // 'sin(vec3(...))' will just do 'sin()' for each component separatly.\n    // '* iTime' will multiply 'sin()' outcomes over time value. \n    // Each colour component (RGB) will change with diffrent rates, because each have diffrent multiplication exponent (0.2, 0.3, 0.9). \n    // Colour components have values between '0.0' and '1.0'. 'Sin()' goes from '-1.0' to '1.0'.\n    // '/ 2.0' will result in values between '-0.5' and '0.5'.\n    // '+ 0.5' will result in values between '0.0' and '1.0', so appropiate for colour components.    \n    vec3 colour = sin(vec3(0.2, 0.3, 0.9) * randomVal * colourChangeRate * iTime) / 2.0 + 0.5;\n    \n    // Eliminate colours that we don't like (in this case remove most of green).\n    colour = colour * vec3(1.0, 0.3, 1.0);\n    // Set bigger stars more blue.\n    colour = colour * vec3(1.0, 1.0, 2.0 * starIntensity);\n    \n    // Return value.\n    return colour;\n}\n\n// Get mouse positon.\nvec2 GetMousePos()\n{\n  return (iMouse.xy - (iResolution.xy * 0.5)) / iResolution.y;\n}\n\n// Get mouse input.\nvec2 GetMouseInput()\n{\n  vec2 mousePos = GetMousePos();\n  return mousePos * 5.0;\n}\n\n// Create stars.\n// Also for each star draw parts of it that went out of the cell (neighbour cells will generate that star parts).\nvec3 CreateStarsWithNeighboursContributions(float densityOfStars, float layerRandomOffset, mat2 layerAngle)\n{\n    // Allow to look over star field (normal looking around).\n    //vec2 UVtmp = SetGridTiles(UV+GetMouseInput(), densityOfStars);\n    // Set grid tiles. \n    vec2 UVtmp = SetGridTiles(UV, densityOfStars);\n    // Allow to look over star field (paralax effect).\n    UVtmp = UVtmp + GetMouseInput();    \n    // Set rotation of layer.\n    UVtmp = UVtmp * layerAngle;\n    // Set random offset of layer.\n    UVtmp = UVtmp + layerRandomOffset;\n    // Create grid ID's.\n    vec2 gridIDs = CreateGridIds(UVtmp);\n    // Create grid 'UV'.\n    vec2 gridUV = CreateGridUV(UVtmp);    \n    // Create star variable.\n    vec3 stars;\n    // For each cell, add contributions from neighbourhood cells.\n    for(int x=-1; x<=1; x++)\n      for(int y=-1; y<=1; y++)\n      {\n        // Get neighbour offset.\n        vec2 offset = vec2(x,y);\n        // Compute offseted grid IDs and UV.\n        vec2 offsetedGridIDs = gridIDs+offset;\n        vec2 offsetedGridUV = gridUV-offset;\n        // Randomize grid 'UV' positions.\n        vec2 gridUV2 = RandomizeGridUVPositions(offsetedGridIDs, offsetedGridUV);\n        // Generate random star intensity (will also affect star size little bit).\n        float starIntensity = GeneratePseudoRandom_FromHash21(offsetedGridIDs);\n        starIntensity = max(0.5, starIntensity);\n        // Compute inner circle radius (below '0.01' stars become invisible).\n        // Big values make stars look like big glowy bulbs.\n        float innerCircleRadius = max(0.065, 0.065/densityOfStars);\n        // Compute star cross intensity (only stars with big intensity will have cross turn on).\n        float crossIntensity = smoothstep(0.8, 1.0, starIntensity);\n        crossIntensity = min(0.25, crossIntensity);        \n        // Set min and max range.\n        float minRange = 0.4; \n        float maxRange = 1.0;\n        // Create random colour.\n        vec3 col = CreateRandomColour(offsetedGridIDs, starIntensity);\n        // Create stars.\n        stars = stars + CreateStars(gridIDs, gridUV2, starIntensity, innerCircleRadius, crossIntensity, minRange, maxRange, col);\n      }    \n    // Draw debug cells.\n    //stars = stars + DrawDebugCells(gridUV);\n    // Return value.\n    return stars;\n}\n\n// Get fade factor, depending on layer depth.\nfloat GetFadeFactor(float depth)\n{\n    // This is only to show other way, how to achive similar result as smoothstep.\n    //if(depth > 0.9) \n    //{\n      // 0.9 * 10 => 9.0 => fract() => 0.0\n      // 0.91 * 10 => 9.1 => fract() => 0.1\n      // 0.92 * 10 => 9.2 => fract() => 0.2\n      // 0.99 * 10 => 9.9 => fract() => 0.9\n      //float interpolation = fract(depth*10.0);\n      // Fade out last part of animation (start will become more transparent whe they are very close to screen).\n      //fadeFactor = mix(fadeFactor, 0.0, fract(depth*10.0));\n    //}\n    \n    // Last part of depth should fade out again.\n    float fadeFactor = depth * smoothstep(1.0, 0.8, depth);\n    // Return value.\n    return fadeFactor;\n}\n\n// Create multiple layers of stars.\nvec3 CreateStarsLayers(float numOfLayers, float densityOfStars)\n{\n  // Caculate animation speed.\n  float passThroughAnimationSpeed = iTime * 0.1;\n  float rotateAnimationSpeed = iTime * 0.01;\n  // Stars layers.\n  vec3 starsLayers;\n  // Create layers of stars\n  for(float i=0.0; i<1.0; i += 1.0/numOfLayers)\n  {\n    // Depth of layer will change from small value to '1.0' over time. \n    // After it reach '1.0' depth will be shifted to small value and again start increasing.\n    float depth = fract(i+passThroughAnimationSpeed);\n    // Scale influence how many grid tiles is on given layer.\n    // To increase number of stars, scale must increase also.\n    // As for layers goes, each of them should have diffrent size of stars (from layers with low scale to high scale).\n    // Changing scale of each layer over time will give sense of passing through the stars.\n    float scale = mix(densityOfStars + numOfLayers, 0.5, depth);\n    // Compute layer random positon (so layers stars will not align into lines).\n    float layerRandomOffset = i * 453.23;\n    // Compute layer angle.\n    mat2 layerAngle = RotationAngle(PI * rotateAnimationSpeed);\n    // Layers that are far from screen (have low scale) should be fading from '0.0' to '1.0', as scale increase.\n    // This will prevent 'poping out' artifact when layers are shifted to the back (their scale is set to low number).\n    float fadeFactor = GetFadeFactor(depth);\n    // Create mulitple layers of stars.\n    starsLayers = starsLayers + CreateStarsWithNeighboursContributions(scale, layerRandomOffset, layerAngle) * fadeFactor;\n  }\n  // Return value.\n  return starsLayers;\n}\n\n\n// Main function.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Get UV with origin/pivot in the middle/center of the screen.\n    UV = GetUV_WithOriginInTheCenter(fragCoord);\n    // Create black colour.\n    vec3 col = vec3(0);\n    // Create stars layers.\n    col = col + CreateStarsLayers(7.0, 15.0);\n    // Output to screen.\n    fragColor = vec4(col,1.0);\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}