{
    "Shader": {
        "info": {
            "date": "1482611082",
            "description": "These dangles know how to party.\n\nGrab and shake with the mouse.\n\nInspired to dance by:\nDancing Tentacle by mplanck https://www.shadertoy.com/view/XldSDn\nMatroshka! by BigWIngs https://www.shadertoy.com/view/XlcSzM ",
            "flags": 96,
            "hasliked": 0,
            "id": "4tKXzz",
            "likes": 13,
            "name": "Dangles",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "dancing",
                "worms",
                "floppy",
                "dangle"
            ],
            "usePreview": 1,
            "username": "irwatts",
            "viewed": 1181
        },
        "renderpass": [
            {
                "code": "// Dangles - Created by Ian Reichert-Watts 2016\n// ian@shadowhelm.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Music: Bloc - KV\n// https://soundcloud.com/kvmusicprod/bloc\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 1 // Hide buf A data on bottom row\n    if ( fragCoord.y < 2.0 )\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n#endif\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture( iChannel0, uv );\n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Dangles - Created by Ian Reichert-Watts 2016\n// ian@shadowhelm.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Music: Bloc - KV\n// https://soundcloud.com/kvmusicprod/bloc\n\n// PARAM\nconst vec3 CAM_ORIGIN = vec3(0.0, 80.0, 100.0);\nconst float NEAR_CLIP = 0.002;\nconst float FAR_CLIP = 240.0;\n\nconst vec3 LIGHT_DIR = normalize( vec3(1.0,-1.0, 1.0) );\nconst float LIGHT_INTENSITY = 80.0;\nconst float LIGHT_POW = 12.0;\nconst float AMBIENT_INTENSITY = 0.42;\n\nconst float FRESNEL_INTENSITY = 8.0;\nconst float FRESNEL_POW = 2.0;\n\nconst float REFLECTION_INTENSITY = 1.0;\n\nconst float HEIGHT_FOG_Y = 20.0;\n\nconst float DIST_FOG_START = 80.0;\nconst float DIST_FOG_DENSITY = 4.0;\n\nconst float TRACERS_AMOUNT = 0.8;\n\nconst int NUM_STRANDS = 3;\nconst int NUM_JOINTS_PER_STRAND = 8;\nconst float STRAND_DIST = 12.0;\nconst float DAMPING = 0.95;\nconst float STRETCHINESS = 0.1;\nconst float SPRING_FORCE = 1.0;\nconst float SPRING_DEADZONE = 0.2;\nconst float SPRING_DIST = 2.0;\nconst float GRAVITY = 0.42;\nconst float ROTATE_SPEED = 0.42; \nconst int JOINT_STORAGE_OFFSET = 2;\n\n// CONST\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\n\n\n// VAR\nconst int NUM_JOINTS = NUM_JOINTS_PER_STRAND*NUM_STRANDS;\n\nvec4 joints[NUM_JOINTS];\nvec4 jointsPrev[NUM_JOINTS];\n\n\n// Distance functions and operations from https://iquilezles.org/articles/distfunctions\n// Modified by me for syntax/style and to include material id\nfloat combine( in float d1, in float id1, in float d2, in float id2, out float resId )\n{\n    if ( d1 < d2 )\n    {\n        resId = id1;\n        return d1;\n    }\n    else\n    {\n        resId = id2;\n        return d2;\n    }\n}\nfloat smin( in float d1, in float id1, in float d2, in float id2, in float k, out float resId )\n{\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    float o = k*h*(1.0-h);\n    resId = mix( id2, id1, h-o );\n    return mix( d2, d1, h )-o;\n}\nfloat sphere( in vec3 p, float s )\n{\n    return length( p )-s;\n}\nfloat torus( in vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x, p.y);\n    return length(q)-t.y;\n}\n                  \n\nfloat plane( in vec3 p )\n{\n    return p.y;\n}\n\nfloat map( in vec3 p, out float resId )\n{\n    float resD = FAR_CLIP;\n    resId = 0.0;\n    for( int i=0; i<NUM_JOINTS; i++ )\n    {\n        float jointIndex = mod( float(i), float(NUM_JOINTS_PER_STRAND) );\n        float strandIndex = float(i/NUM_JOINTS_PER_STRAND);\n        vec3 jointP = joints[i].xyz;\n        float sphereD = sphere( p-jointP, 2.0+2.0*(1.0-(jointIndex/float(NUM_JOINTS_PER_STRAND))) );\n        resD = smin( resD, resId, sphereD, jointIndex+5.0, 1.0, resId );\n        \n        \n        if ( jointIndex == 0.0 )\n        {\n            // Eyes\n            vec3 eye1, eye2;\n            if ( strandIndex == 1.0 )\n            {\n                eye1 = vec3(1.0, -1.0, 4.2);\n                eye2 = vec3(-1.0, -1.0, 4.2);\n            }\n            else\n            {\n                float rotYTime = -joints[i].a;\n                if ( strandIndex == 2.0 )\n                {\n                    rotYTime += PI;\n                }\n                mat3 m = mat3(\n                        vec3( cos(rotYTime), 0.0, sin(rotYTime)),\n                        vec3(0.0, 0.0, 1.0),\n                        vec3(-sin(rotYTime), 0.0, cos(rotYTime))\n                    );\n                eye1 = m*vec3(1.0, -1.0, -4.6);\n                eye2 = m*vec3(-1.0, -1.0, -4.6);\n            }\n            resD = combine( resD, resId, sphere( p-jointP-eye1, 0.42 ), 1.0, resId );\n            resD = combine( resD, resId, sphere( p-jointP-eye2, 0.42 ), 1.0, resId );\n            \n            if ( strandIndex == 1.0 )\n            {\n                // Glowrings\n                float time = iTime * 20.0;\n                float rotYTime = 0.2*sin( 0.5*time-joints[i].a );\n                mat3 m = mat3(\n                        vec3( cos(rotYTime), sin(rotYTime), 0.0),\n                        vec3(-sin(rotYTime), cos(rotYTime), 0.0),\n                        vec3(0.0, 0.0, 1.0)\n                    );\n                vec3 offset1 = vec3(1.25*vec2(sin( time ), sin( time )*cos( time )), 0.0);\n                vec3 offset2 = vec3(0.75*vec2(sin( time+0.25 ), sin( time+0.25 )*cos( time+2.0 )), 0.0);\n                vec3 offset3 = vec3(0.5*vec2(sin( time+0.5 ), sin( time+0.5 )*cos( time+3.0 )), 0.0);\n                resD = combine( resD, resId, torus( m*(p-jointP-vec3(0.0, 3.0, 0.0)+offset1), vec2(4.6, 0.3) ), 2.0, resId );\n                resD = combine( resD, resId, torus( m*(p-jointP-vec3(0.0, 2.0, 0.0)+offset2), vec2(4.6, 0.3) ), 3.0, resId );\n                resD = combine( resD, resId, torus( m*(p-jointP-vec3(0.0, 1.0, 0.0)+offset3), vec2(4.6, 0.3) ), 4.0, resId );\n            }\n        }\n    }\n    resD = combine( resD, resId, plane( p ), 0.0, resId );\n    \n    return resD;\n}\n\nbool castRay( in vec3 ro, in vec3 rd, out vec4 resPT, out float resId )\n{\n    float thresh = 0.002;\n    float t = NEAR_CLIP;\n    for( int i=0; i<256; i++ )\n    {\n        float d = map( ro+rd*t, resId );\n        if ( d < thresh )\n        {\n            resPT = vec4(ro+rd*(t-thresh), t-thresh);\n            return true;\n        }\n        if ( t > FAR_CLIP )\n        {\n            t = FAR_CLIP;\n            break;\n        }\n        t += d+thresh;\n    }\n    resPT = vec4(ro+rd*(t-thresh), t-thresh);\n    return false;\n}\n\nvec3 sampleNormal( in vec3 p )\n{\n    float id;\n\tvec3 eps = vec3( 0.1, 0.0, 0.0 );\n\tvec3 normal = vec3(map( p+eps.xyy, id ) - map( p-eps.xyy, id ),\n\t    \t\t\tmap( p+eps.yxy, id ) - map( p-eps.yxy, id ),\n\t    \t\t\tmap( p+eps.yyx, id ) - map( p-eps.yyx, id ));\n\treturn normalize(normal);\n}\n\nmat3 camMat3( in vec3 ro, in vec3 target )\n{\n    float roll = 0.0;\n    vec3 forward = normalize( target-ro );\n    vec3 wup = vec3(sin(roll), cos(roll), 0.0);\n    vec3 right = normalize( cross( forward, wup ) );\n    vec3 up = normalize( cross( right, forward ) );\n    return mat3(right, up, forward);\n}\n\n// Game state logic from Bricks Game by iq (https://www.shadertoy.com/view/MddGzf)\nfloat isInside( in vec2 p, in vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( in vec2 p, in vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside( fragCoord, re ) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside( fragCoord, re ) > 0.0 ) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 wavData = loadValue( vec2(0.0, 0.0) );\n    float fft = texture( iChannel2, vec2(0.0, 0.25) ).x; \n    float wave = texture( iChannel2, vec2(0.0, 0.75) ).x; \n    fft = max( fft, mix( wavData.r, 0.0, 0.001 ) );\n    wave = max( wave, mix( wavData.g, 0.0, 0.001 ) );\n    float fft2 = texture( iChannel2, vec2(0.8, 0.25) ).x; \n    float wave2 = texture( iChannel2, vec2(0.8, 0.75) ).x; \n    fft = max( fft2, mix( wavData.b, 0.0, 0.001 ) );\n    wave = max( wave2, mix( wavData.a, 0.0, 0.001 ) );\n    wavData.r = fft;\n    wavData.g = wave;\n    wavData.b = fft2;\n    wavData.a = wave2;\n    storeValue( vec2(0.0, 0.0), wavData, fragColor, fragCoord );\n    \n    vec4 interactData = loadValue( vec2(1.0, 0.0) );\n    \n    mat3 camMat = camMat3( CAM_ORIGIN, vec3(0.0, 0.0, 0.0) ); \n    \n    if ( iFrame == 0)\n    {\n        // Init joints\n        for( int i=0; i<NUM_JOINTS; i++ )\n        {\n            float jointIndex = mod( float(i), float(NUM_JOINTS_PER_STRAND) );\n            float strandIndex = float(i/NUM_JOINTS_PER_STRAND);\n            vec2 centeredCoord = ((iResolution.xy*0.5)-(iResolution.xy*0.5))/iResolution.y;\n            vec3 rayDir = camMat*normalize( vec3(centeredCoord, 2.0) );  \n            vec3 offset = vec3((strandIndex-floor(float(NUM_STRANDS)*0.5))*STRAND_DIST, -jointIndex*SPRING_DIST, 0.0);\n            offset.x += 2.0*sin( 5.4*jointIndex/float(NUM_JOINTS_PER_STRAND)+strandIndex*1.3 );\n            joints[i] = vec4(CAM_ORIGIN+offset+rayDir*100.0, 0.0);\n            jointsPrev[i] = joints[i];\n        }\n        \n        // Initial wav data\n        fft = 0.42;\n        wave = 0.9;\n        \n        // Initial interact data\n        interactData.xy = iResolution.xy*0.5;\n    }\n    \n    if ( fragCoord.y < 2.0 )\n    {\n        if ( iFrame > 0)\n        {\n            // Retrieve joint info\n            for( int i=0; i<NUM_JOINTS; i++ )\n            {\n                joints[i] = loadValue( vec2(float(i+JOINT_STORAGE_OFFSET), 0.0) );\n                jointsPrev[i] = loadValue( vec2(float(i+NUM_JOINTS+JOINT_STORAGE_OFFSET), 0.0) );\n            }\n        }\n        \n        // Update interact data\n        if ( iMouse.z > 0.0 )\n        {\n            interactData.xy = iMouse.xy;\n        }\n        if ( interactData.y > iResolution.y*0.5 )\n        {\n            interactData.y -= GRAVITY*10.0;\n        }\n            \n        // Move joints\n        for( int i=0; i<NUM_JOINTS; i++ )\n        {\n            float jointIndex = mod( float(i), float(NUM_JOINTS_PER_STRAND) );\n            float strandIndex = float(i/NUM_JOINTS_PER_STRAND);\n            vec4 tempJoint = joints[i];\n            if ( jointIndex == 0.0 )\n            {\n                float strandRatio = strandIndex/float(NUM_STRANDS);\n                vec2 interactCoord = interactData.xy;\n                vec2 centeredCoord = (interactCoord.xy-(iResolution.xy*0.5))/iResolution.x;\n                vec3 rayDir = camMat*normalize( vec3(centeredCoord, 2.0) );  \n                vec3 offset = vec3((strandIndex-floor(float(NUM_STRANDS)*0.5))*STRAND_DIST, 0.0, 0.0);\n                float rotYTime = -iTime*(ROTATE_SPEED+(0.005*pow( wave2, 0.1 ))-((0.02*fft2)));\n                mat3 m = mat3(\n                    vec3( cos(rotYTime), sin(rotYTime), 0.0),\n                    vec3(0.0, 0.0, 1.0),\n                    vec3(-sin(rotYTime), cos(rotYTime), 0.0)\n                );\n                offset *= m;\n\n                // Dance up and down\n                if ( strandIndex == 1.0 )\n                {\n                    offset.y += fft*wave*10.0;\n                }\n                else\n                {\n                    offset.y += fft*wave*20.0;\n                }\n                // Dance in circle\n                float time = iTime * 10.0;\n                offset.xy += 2.0*fft*vec2(sin( time ), sin( time )*cos( time ));\n                \n                // Set joint data\n                joints[i].xyz = CAM_ORIGIN+offset+rayDir*100.0;\n                joints[i].a = rotYTime;\n            }\n            else\n            {\n                // Verlet integration\n                joints[i].xyz += ((joints[i].xyz-jointsPrev[i].xyz)*DAMPING);\n\n                // Spring and stretch\n                vec4 parentDelta = joints[i-1]-joints[i];\n                vec3 springOffset = normalize( parentDelta.xyz )*(length( parentDelta.xyz )-SPRING_DIST);\n                joints[i].xyz += mix( springOffset, (springOffset*SPRING_FORCE), STRETCHINESS );\n                tempJoint.xyz += springOffset*(1.0-STRETCHINESS);\n\n                // Gravity\n                joints[i].xyz -= vec3(0.0, GRAVITY, 0.0);\n                tempJoint.xyz -= vec3(0.0, GRAVITY, 0.0);\n            }\n            jointsPrev[i] = tempJoint;\n        }\n        \n        // Store joint info\n        for ( int i=0; i<NUM_JOINTS; i++ )\n        {\n            storeValue( vec2(float(i+JOINT_STORAGE_OFFSET), 0.0), joints[i], fragColor, fragCoord );\n            storeValue( vec2(float(i+NUM_JOINTS+JOINT_STORAGE_OFFSET), 0.0), jointsPrev[i], fragColor, fragCoord );\n        }\n        \n        // Store interact data\n        storeValue( vec2(1.0, 0.0), interactData, fragColor, fragCoord );\n        \n        return;\n    }\n    \n    if ( iFrame > 0 )\n    {\n        // Retrieve joint info\n        for( int i=0; i<NUM_JOINTS; i++ )\n        {\n            joints[i] = loadValue( vec2(float(i+JOINT_STORAGE_OFFSET), 0.0) );\n            jointsPrev[i] = loadValue( vec2(float(i+NUM_JOINTS+JOINT_STORAGE_OFFSET), 0.0) );\n        }\n    }  \n    \t\n    fragColor = vec4(0.0);\n    \n    vec2 centeredCoord = (fragCoord-(iResolution.xy*0.5))/iResolution.x;\n    vec3 rayDir = camMat*normalize( vec3(centeredCoord, 2.0) );   \n    \n    float depth;\n    float resId;\n    vec3 norm;\n    vec4 resPT;\n    if ( castRay( CAM_ORIGIN, rayDir, resPT, resId ) && resPT.a > NEAR_CLIP )\n    {\n        depth = resPT.a/FAR_CLIP;\n        norm = sampleNormal( CAM_ORIGIN+rayDir*resPT.a );\n        \n        // Base Color\n        vec4 baseColor;\n        if ( resId == 0.0 )\n        {\n            float centerD = length( resPT );\n            float time = iTime;\n            float val = clamp( 10.0*sin( resPT.x*0.2+sin( resPT.z*0.2-time ) )*cos( resPT.z*0.2+sin( time ) ), 0.0, 0.2 );\n            float r = 2.8*sin( centerD*0.1 )*val;\n            float g = 0.8*abs( sin( centerD*0.2-fft2 ) )*(1.0-val);\n            float b = 2.8*abs( sin( centerD*0.1 ) );\n            baseColor = vec4(r, g, b, 1.0);\n        }\n        else if ( resId == 1.0 )\n        {\n            baseColor = vec4(1.0, 0.0, 0.0, 0.0);\n        }\n        else if ( resId == 2.0 )\n        {\n            baseColor = vec4(0.0, 2.0, 10.0, 0.0);\n        }\n        else if ( resId == 3.0 )\n        {\n            baseColor = vec4(0.0, 10.0, 0.4, 0.0);\n        }\n        else if ( resId == 4.0 )\n        {\n            baseColor = vec4(10.0, 0.1, 0.0, 0.0);\n        }\n        else\n        {\n            baseColor = vec4(0.8, 0.8, 0.8, 1.0);\n        }\n        baseColor.a += 1.0+0.8*sin( distance( resPT.xz, vec2(0.5, 0.5) )*1.0-atan( resPT.z-0.5, resPT.x-0.5 )+iTime*10.0 );\n        fragColor = baseColor;\n        \n        // Reflections\n        vec4 reflectionColor = texture( iChannel3, norm );;\n        fragColor += reflectionColor*baseColor.a*REFLECTION_INTENSITY;\n        \n        // Light Color\n        float r = 0.42*sin( iTime+fft*10.0 );\n        float g = 0.42*abs( sin( fft*20.0 ) );\n        float b = 0.42*abs( sin( fft*10.0 ) );\n        vec4 lightColor = vec4(r, g, b, 1.0);\n        \n        // Fresnel Light\n        float fresnel = pow( (1.0-abs( dot( -rayDir, norm ) )), FRESNEL_POW );\n        fragColor += fresnel*FRESNEL_INTENSITY*lightColor;\n        \n        // Directional Light\n        float lightDot = dot( -LIGHT_DIR, norm );\n        fragColor *= lightColor*(pow( clamp( lightDot, 0.2, 1.0 ), LIGHT_POW )*LIGHT_INTENSITY)+AMBIENT_INTENSITY;\n        \n        // Height Fog\n        float heightFog = 1.0 - clamp( (resPT.y/HEIGHT_FOG_Y), 0.6, 1.0 );\n        fragColor = mix( fragColor, lightColor, heightFog );\n        \n        // Distance Fog\n        float dFog = clamp( ((resPT.a-DIST_FOG_START)/FAR_CLIP)*DIST_FOG_DENSITY, 0.0, 1.0 );\n        fragColor = mix( fragColor, lightColor, dFog );\n        \n        // Flare\n        vec3 lightDelta = (-LIGHT_DIR*16.0)-(CAM_ORIGIN+rayDir*10.0);\n        float flareDot = dot( normalize( lightDelta ), rayDir );\n        float flareGlow = clamp( (flareDot-0.98)*20.0, 0.0, 1.0 );\n        flareGlow = pow( flareGlow, 3.0 )*20.0;\n        fragColor += flareGlow*lightColor;\n        \n        // Tracers\n        if ( iFrame > 0 )\n        {\n            // One Sample Blur technique by iq https://www.shadertoy.com/view/MsdGD2\n            float s = -0.5+2.0*fract(float(iFrame)/2.0);\n            vec2 uv = (fragCoord.xy + s) / iResolution.xy;\n            fragColor = mix( fragColor, texture( iChannel0, uv ), clamp( TRACERS_AMOUNT*depth*2.0-flareGlow*0.1, 0.0, 0.99 ) );\n        }\n    }\n  \t\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 15182,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/kvmusicprod/bloc"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}