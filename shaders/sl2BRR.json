{
    "Shader": {
        "info": {
            "date": "1651726292",
            "description": "Smoothstep build using the error function and its inverse.\nApproximates the common polynomial smoothsteps (+ their inverses) quite well.\nThe 1st derivative at x = 1/2 equals the sharpness parameter s.",
            "flags": 0,
            "hasliked": 0,
            "id": "sl2BRR",
            "likes": 9,
            "name": "ErfStep",
            "published": 3,
            "tags": [
                "smoothstep"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 325
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    Smoothstep build using the error function and its inverse.\n    Approximates the common polynomial smoothsteps (+ their inverses) quite well.\n    The 1st derivative at x = 1/2 equals the sharpness parameter s.\n    ErfStep(x, s) = Erf( InverseErf(x*2-1)*s )/2+1/2\n    ErfStep(ErfStep(x, s), 1/s) = x\n    \n    red:   ErfStep\n    blue:  inverse ErfStep\n    black: Smoothsteps\n*/\n\n\nfloat Smoothstep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    return x*x * (x * -2.0 + 3.0);\n}\n\nfloat Smootherstep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    return x*x*x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n\n// https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\nfloat Erf(float x)\n{\n\tbool neg = x < 0.0;\n    \n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xx = x*x;\n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return neg ? -y : y;\n}\n\nfloat ErfI(float x)\n{\n\tbool neg = x < 0.0;\n\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(1.0 - x*x);\n    float c = u * 0.5 + b;\n    \n    float y = sqrt(sqrt(c*c - u*a) - c);\n    \n    return neg ? -y : y;\n}\n\n\nfloat ErfStep(float x, float s)\n{\n    if(x <= 0.0) return 0.0;\n    if(x >= 1.0) return 1.0;\n    \n    return Erf(ErfI(x * 2.0 - 1.0) * s) * 0.5 + 0.5;\n}\n\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += .0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.125;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.25+0.0375;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    // sharpness parameter for the non-hardcoded erfstep curve\n    float s = min(mix(-0.125, 1.125, iMouse.x / iResolution.x), 1.0);\n    \n    if(s < 0.0)\n    s = (sin(iTime * 0.25) + 1.0) * 3.0 + 1.0;\n    else\n    s = 1.0 + s * 8.0;\n    \n    // inverse erfsteps (blue)\n   #if 1\n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/(  3.0/ 2.0)) -tex.y, 1.0)); \n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/( 15.0/ 8.0)) -tex.y, 1.0));            \n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/(  9.0/ 4.0)) -tex.y, 1.0));            \n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/( 45.0/16.0)) -tex.y, 1.0));            \n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/(225.0/64.0)) -tex.y, 1.0));\n   #endif\n    col = mix(col, vec3(0.1, 0.25, 1.0), Graph(ErfStep(tex.x, 1.0/s) -tex.y, 0.5));      \n\n    // erfsteps (red)\n   #if 1\n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x,   3.0/ 2.0) -tex.y, 1.5)); \n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x,  15.0/ 8.0) -tex.y, 1.5));            \n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x,   9.0/ 4.0) -tex.y, 1.5));            \n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x,  45.0/16.0) -tex.y, 1.5));            \n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x, 225.0/64.0) -tex.y, 1.5));\n   #endif\n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(ErfStep(tex.x, s) -tex.y, 0.5));        \n\n    // polynomial smoothsteps (thin + black)\n   #if 1\n    col = mix(col, vec3(0.1), Graph(Smoothstep(tex.x) -tex.y, -0.25));  \n    col = mix(col, vec3(0.1), Graph(Smootherstep(tex.x) -tex.y, -0.25)); \n    col = mix(col, vec3(0.1), Graph(Smoothstep(Smoothstep(tex.x)) -tex.y, -0.25));  \n    col = mix(col, vec3(0.1), Graph(Smootherstep(Smoothstep(tex.x)) -tex.y, -0.25));  \n    col = mix(col, vec3(0.1), Graph(Smootherstep(Smootherstep(tex.x)) -tex.y, -0.25));  \n   #endif\n   \n    #if 1\n    {\n        vec2 s = (uv0/iResolution.xy*2.0-1.0);\n        s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n        col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    }\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}