{
    "Shader": {
        "info": {
            "date": "1523366295",
            "description": "A very simple voronoi, no random, no good colors, just simplicity and a for loop. just iterate to find the smallest distance. i think what i am using is delaunay to generate the graph, i dont know.\n\ncommented in portuguese for my teacher.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVyDm",
            "likes": 2,
            "name": "a simple voronoi",
            "published": 3,
            "tags": [
                "voronoy"
            ],
            "usePreview": 0,
            "username": "indominator",
            "viewed": 835
        },
        "renderpass": [
            {
                "code": "//BASED ON iq's code: https://www.shadertoy.com/view/MslGD8\n\nconst int pontos_size = 9;\n\n//array dos pontos dentro do grafico, menor ponto eh 0,0 maior ponto eh 1,1\nconst vec2 pontos[] = \n    vec2[pontos_size](vec2(0.0,0.89),vec2(0.142,0.1214),vec2(0.9,0.5)\n                      ,vec2(0.3,0.89) ,vec2(0.14,0.134),vec2(0.9,0.214)\n                      ,vec2(0.23,0.3489) ,vec2(0.96,0.34),vec2(0.92,0.523));\n\n\n\nconst vec3 colors[] = \n    vec3[pontos_size](vec3(0.4,0.2363,0.1),vec3(0.1,1.,0.1),vec3(0.24152,0.,0.1),\n                     vec3(0.21354,0.2363,0.1),vec3(0.231,0.5,0.1)\n                      ,vec3(37./255., 207./255., 237./255.)\n                     ,vec3(37./255., 207./255., 142./255.)\n                      ,vec3(65./255., 134./255., 142./255.)\n                      ,vec3(238./255., 134./255., 142./255.));\n\n\n\nvec3 color(vec2 p,vec2 iRes){\n    \n\n\tint ponto=-1;\n    \n\tfloat m =  iRes.x*iRes.x; //tamanho da esfera , aumente ou altere caso necessario\n    \n    for( int i=0; i< pontos_size ; i++ )\n    {\n        vec2  g = pontos[i]*iRes;\n\n        //direcao do centro ao ponto\n\t    vec2  r = g - p;// + (g);\n\t\n        //hipotenusa ?\n        float d = dot( r, r );\n        \n        \n        if( d< m ){ //caso distancia seja menor que m\n            m =  d ;  // altera valor de m para na proxima iteracao\n            \t\t\t//para achar qual ponto eh o menor\n            ponto = i; \n        }\n        \n        \n    }\n    \n    \nif(ponto > -1)\n    return colors[ponto];\n    else return vec3(0.,0.,0.);\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy;\n    \n    vec3 c = color( p ,iResolution.xy); \n\n\n    fragColor = vec4( c, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}