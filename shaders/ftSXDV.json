{
    "Shader": {
        "info": {
            "date": "1628593608",
            "description": "Upgraded visuals - control widgets now in world space (see source)",
            "flags": 32,
            "hasliked": 0,
            "id": "ftSXDV",
            "likes": 29,
            "name": "Maze Ball Solved 2",
            "published": 3,
            "tags": [
                "game",
                "interactive",
                "dynamics",
                "physics",
                "puzzle"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 513
        },
        "renderpass": [
            {
                "code": "// \"Maze Ball Solved 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Roll the ball through the solved maze.\n  Drag knob to control tilt angles (vary automatically until first click);\n  click button for new random maze before timer expires; otherwise mouse\n  controls view angle.\n*/\n\n#define AA  0   // optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nvec3 wgObj[2], ltDir, qHit, bSize, vnBall;\nvec2 aTilt, ballPos, cEn, cEx;\nfloat dstFar, tCur, gSize, autoRot, nStep, growLim, pathLen, frameUp, tFrac;\nint idObj;\nconst int idMaz = 1, idFrm = 2, idAx = 3, idTimer = 4, idCon = 5, idBut = 6;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p :\n     vec2 (- p.y, p.x)) : ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat ValMaze (vec2 q)\n{\n  vec2 ut, e;\n  float dw, s;\n  ut = q * gSize;\n  s = Loadv4 (floor (ut)).x;\n  dw = WallDst (ut, s);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (ut) - e).x == ai) dw = min (dw, WallDst (ut, mod (ai + 2., 4.)));\n  }\n  return dw;\n}\n\nfloat HtMaze (vec2 q)\n{\n  return 1. - smoothstep (0.15, 0.4, ValMaze (q));\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h, frmLen, frmWid, frmGap;\n  dMin = dstFar;\n  frmWid = 1.3 * bSize.y;\n  frmLen = bSize.x * (1. - 0.9 / gSize) + 1.1 * frmWid;\n  frmGap = 0.1;\n  p.y -= frameUp;\n  q = p;\n  q.xy = Rot2D (q.xy, aTilt.x);\n  q.zy = Rot2D (q.zy, aTilt.y);\n  h = 0.5 * bSize.y * HtMaze (0.5 * q.xz / bSize.xz + 0.5 + 0.001);\n  q.y -= h;\n  d = 0.6 * PrRoundBoxDf (q, vec3 (bSize.xz * (1. - 0.9 / gSize), bSize.y + h).xzy - 0.02, 0.02);\n  DMINQ (idMaz);\n  q.y -= - h;\n  q.xz = (abs (q.x) < abs (q.z)) ? q.xz : q.zx;\n  q.z = abs (q.z) - frmLen;\n  d = PrRoundBoxDf (q, vec3 (frmLen + frmWid, frmWid, frmWid) - 0.1, 0.1);\n  DMINQ (idFrm);\n  frmLen += 2. * frmWid + frmGap;\n  q = p;\n  q.xy = Rot2D (q.xy, aTilt.x);\n  q.xz = (abs (q.x) < abs (q.z)) ? q.xz : q.zx;\n  q.z = abs (q.z) - frmLen;\n  d = PrRoundBoxDf (q, vec3 (frmLen + frmWid, frmWid, frmWid) - 0.1, 0.1);\n  DMINQ (idFrm);\n  frmLen += 2. * frmWid + frmGap;\n  q = p;\n  q.xz = (abs (q.x) < abs (q.z)) ? q.xz : q.zx;\n  q.z = abs (q.z) - frmLen;\n  d = PrRoundBoxDf (q, vec3 (frmLen + frmWid, frmWid, frmWid) - 0.1, 0.1);\n  DMINQ (idFrm);\n  q.x = abs (q.x) - frmLen;\n  q.y -= -0.5 * frameUp - frmWid;\n  d = PrRoundBoxDf (q, vec3 (frmWid, 0.5 * frameUp + frmWid, frmWid) - 0.1, 0.1);\n  DMINQ (idFrm);\n  frmLen = bSize.x * (1. - 0.9 / gSize) + frmWid;\n  frmLen += 2. * frmWid + frmGap;\n  q = p;\n  q.xy = Rot2D (q.xy, aTilt.x);\n  q.x = abs (q.x) - frmLen + 0.3 * frmWid + frmGap;\n  d = PrCapsDf (q.zyx, 0.6 * frmWid, frmWid + frmGap);\n  DMINQ (idAx);\n  frmLen += 2. * frmWid + frmGap;\n  q = p;\n  q.z = abs (q.z) - frmLen + 0.3 * frmWid + frmGap;\n  d = PrCapsDf (q, 0.6 * frmWid, frmWid + frmGap);\n  DMINQ (idAx);\n  p.y += frameUp;\n  q = p;\n  q.xz -= wgObj[0].xy;\n  d = PrRoundBoxDf (q, vec3 (wgObj[0].z, 0.2, wgObj[0].z) - 0.1, 0.1);\n  DMINQ (idCon);\n  q -= vec3 (aTilt / 0.2, 0.2).xzy;\n  d = PrRoundCylDf (q.xzy, 0.3, 0.1, 0.1);\n  DMINQ (idAx);\n  q = p;\n  q.xz -= wgObj[1].xy;\n  d = PrRoundCylDf (q.xzy, wgObj[1].z, 0.1, 0.1);\n  DMINQ (idBut);\n  q = p;\n  q -= vec3 (-0.9 * gSize, 0.1, 0.);\n  d = PrRoundBoxDf (q, vec3 (1., 0.2, 1.) - 0.1, 0.1);\n  DMINQ (idTimer);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;vec4 (0.9, 0.9, 0.95, 0.2);\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallRay (vec3 ro, vec3 rd)\n{\n  vec3 u;\n  float b, d, w, dMin, rad;\n  ro.y -= frameUp;\n  ro.xy = Rot2D (ro.xy, aTilt.x);\n  ro.zy = Rot2D (ro.zy, aTilt.y);\n  rd.xy = Rot2D (rd.xy, aTilt.x);\n  rd.zy = Rot2D (rd.zy, aTilt.y);\n  dMin = dstFar;\n  rad = 0.25;\n  u = ro - vec3 (ballPos.x, rad + 0.6 * bSize.y, ballPos.y);\n  b = dot (rd, u);\n  w = b * b - dot (u, u) + rad * rad;\n  if (w >= 0.) {\n    d = - b - sqrt (w);\n    if (d > 0. && d < dMin) {\n      dMin = d;\n      vnBall = (u + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\nfloat BallChqr (vec3 vn)\n{\n  vec3 u;\n  vec2 a;\n  u = QtToRMat (vec4 (Loadv4 (vec2 (6., 0.)).zw, Loadv4 (vec2 (7., 0.)).zw)) * vn;\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return step (0., sign (a.x) * sign (a.y));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 ut, utb, h;\n  float dstObj, dstBall, nw, nDotL, sh, s;\n  bool isBg, isMet;\n  dstBall = BallRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  isBg = false;\n  isMet = false;\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idMaz) {\n        if (qHit.y > 0.) {\n          ut = qHit.xz / bSize.xz;\n          col4 = mix (vec4 (0.6, 0.8, 0.6, 0.2), vec4 (0.4, 0.5, 0.8, 0.05) *\n             (0.8 + 0.2 * Fbm2 (64. * qHit.xz)), smoothstep (0.3, 0.35, ValMaze (0.5 * ut + 0.5)));\n          utb = 0.5 * gSize * (ut + 1.);\n          h = cEn + vec2 (0.6, 1.);\n          col4.rgb = mix (((length (ballPos + 0.5 * gSize - h) < 0.5) ?\n             vec3 (1., 0., 0.) : vec3 (0., 1., 0.)), col4.rgb,\n             smoothstep (0.15, 0.18, length (utb - h)));\n          h = cEx + vec2 (1.4, 1.);\n          col4 = mix (((length (ballPos + 0.5 * gSize - h) < 0.5) ?\n             vec4 (1., 0., 0., -1.) : vec4 (0., 1., 0., -1.)), col4,\n             smoothstep (0.15, 0.18, length (utb - h)));\n          if (nStep > 5. * growLim || pathLen > 0.) {\n            nw = floor (Loadv4 (floor (mod (utb - 0.5, gSize))).y / 32.);\n            if (nw > 0.) col4 = mix ((mod (nw / max (pathLen, 1.) - 0.2 * tCur, 1.) < 0.1) ?\n               vec4 (1., 0.8, 0., -1.) : ((dot (abs (aTilt), vec2 (1.)) < 0.01 || autoRot == 1.) ?\n               vec4 (1., 0.8, 0., -1.) : col4), col4, smoothstep (0.12, 0.15,\n               length (abs (fract (utb + 0.5) - 0.5))));\n          }\n          col4.rgb *= 0.8 + 0.2 * smoothstep (0.25, 0.3, length (0.5 * gSize * ut - ballPos));\n        } else col4 = vec4 (0.4, 0.3, 0.3, 0.);\n      } else if (idObj == idFrm) {\n        col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      } else if (idObj == idAx) {\n        col4 = vec4 (0.9, 0.8, 0.2, 0.2);\n      } else if (idObj == idBut) {\n        col4 = mix (vec4 (0.9, 0.8, 0.2, 0.2), vec4 (0.9, 0.9, 0.95, 0.2), step (0.35, length (qHit.xz)));\n      } else if (idObj == idCon) {\n        col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      } else if (idObj == idTimer) {\n        if (abs (length (qHit.xz) - 3. * bSize.y) < bSize.y) {\n          qHit.xz = Rot2D (qHit.xz, -0.5 * pi);\n          col4 = vec4 (mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.),\n             step (0.5 * (atan (qHit.z, - qHit.x) / pi + 1.), tFrac)), -1.);\n        } else col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      }\n      isMet = (idObj != idMaz);\n    } else if (dstBall < dstFar) {\n      vn = vnBall;\n      col4 = vec4 (mix (vec3 (1., 0.3, 1.), vec3 (0.8, 1., 0.3), BallChqr (vn)), 0.3);\n      vn.zy = Rot2D (vn.zy, - aTilt.y);\n      vn.xy = Rot2D (vn.xy, - aTilt.x);\n      isMet = true;\n    }\n  } else isBg = true;\n  if (isBg) {\n    if (rd.y < 0.) {\n      ro += (- ro.y / rd.y) * rd;\n      col4 = mix (vec4 (0.7, 0.3, 0.1, 0.1), vec4 (0.4, 0.2, 0.1, 0.1),\n         Fbm2 (ro.xz * vec2 (0.5, 4.)));\n      vn = vec3 (0., 1., 0.);\n      isMet = false;\n    } else col = vec3 (0.1);\n  }\n  if (! isBg || isBg && rd.y < 0.) {\n    sh = (! isBg && dstObj < min (dstBall, dstFar) && col4.a >= 0. || isBg && rd.y < 0.) ? \n       sh = ObjSShadow (ro, ltDir) : 1.;\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (isMet) nDotL *= nDotL;\n      col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) *  pow (max (dot (reflect (rd, vn), ltDir), 0.), 32.);\n      if (isBg) col *= 0.2 + 0.8 * smoothstep (0.93, 0.97, dot (normalize (64. * ltDir - ro), ltDir));\n    } else col = col4.rgb * (0.3 + 0.7 * sh) * (0.7 - 0.3 * dot (rd, vn));\n  }\n  if (! isBg && isMet && col4.a >= 0. || isBg && rd.y < 0.) {\n    rd = reflect (rd, vn);\n    h = mod (8. * vec2 (atan (rd.z, rd.x), 2. * asin (rd.y)) + 0.5, 1.) - 0.5;\n    col = mix (col, vec3 (1.), (isMet ? 0.05 : 0.01) * step (0.1, min (h.x, h.y)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, asp, sr, zmFac, oDist;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  gSize = Loadv4 (vec2 (0., 0.)).z;\n  nStep = Loadv4 (vec2 (1., 0.)).z;\n  stDat = Loadv4 (vec2 (3., 0.));\n  aTilt = clamp (stDat.zw, -0.25, 0.25);\n  cEn = Loadv4 (vec2 (3., 1.)).zw;\n  cEx = Loadv4 (vec2 (4., 1.)).zw;\n  stDat.zw = Loadv4 (vec2 (5., 1.)).zw;\n  growLim = stDat.z;\n  pathLen = stDat.w;\n  bSize = vec3 (0.5 * gSize, 0.15, 0.5 * gSize);\n  frameUp = 18. * bSize.y;\n  ballPos = Loadv4 (vec2 (4., 0.)).zw;\n  autoRot = Loadv4 (vec2 (2., 1.)).w;\n  tFrac = Loadv4 (vec2 (2., 0.)).z;\n  stDat = Loadv4 (vec2 (0., 1.));\n  el = stDat.z;\n  az = stDat.w;\n  vuMat = StdVuMat (el, az);\n  stDat = Loadv4 (vec2 (6., 1.));\n  zmFac = stDat.z;\n  oDist = stDat.w;\n  ro = vuMat * vec3 (0., 0., - oDist * gSize);\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  wgObj[0] = vec3 (0.9 * gSize, 0., 1.6);\n  wgObj[1] = vec3 (0.9 * gSize, 0.5 * gSize, 0.4);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Maze Ball Solved 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nvec4 ballQt;\nvec3 wgObj[2];\nvec2 aTilt, ballPos, ballVel;\nfloat gSize;\nconst float pi = 3.1415927;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p :\n     vec2 (- p.y, p.x)) : ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat HtMaze (vec2 p)\n{\n  vec2 e;\n  float dw, s;\n  p += 0.5 * gSize;\n  s = Loadv4 (floor (p)).x;\n  dw = WallDst (p, (s >= 0.) ? s : -1.);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (p) - e).x == ai) dw = min (dw, WallDst (p, mod (ai + 2., 4.)));\n  }\n  return max (1. - 4. * dw, 0.);\n}\n\nvoid Step ()\n{\n  float s, v;\n  s = 0.25;\n  ballVel -= 0.2 * sign (ballVel) *\n      vec2 (HtMaze (ballPos + vec2 (s * sign (ballVel.x), 0.)),\n            HtMaze (ballPos + vec2 (0., s * sign (ballVel.y))));\n  ballVel += 0.005 * aTilt - 0.03 * ballVel;\n  if (length (ballVel) > 0.1) ballVel *= 0.1 / length (ballVel);\n  ballPos += ballVel;\n  if (abs (ballPos.x) > 0.5 * gSize - 0.7) {\n    ballPos.x = (0.5 * gSize - 0.71) * sign (ballPos.x);\n    ballVel = vec2 (0.);\n  }\n  v = length (ballVel);\n  if (v > 0.) ballQt = normalize (QtMul (ballQt,\n     RotToQt (normalize (vec3 (- ballVel.y, 0., ballVel.x)), v / 0.25)));\n}\n         \nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, mPtrP, stDat, fVal, cb, cbi, cbf;\n  vec3 vCon, ro;\n  vec2 canvas, iFrag, ud, us, ev[4], cEn, cEx;\n  float tCur, nStep, growLim, autoRot, tGame, tBgn, ai, ar, nw, nwn, nb, dir,\n     az, el, asp, pathLen, zmFac, oDist;\n  int wgSel, wgReg, kIn;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = 10.;\n  if (Maxv2 (fragCoord) >= gSize) discard;\n  wgSel = -1;\n  wgReg = -2;\n  aTilt = vec2 (0.);\n  az = 0.;\n  el = -0.3 * pi;\n  asp = canvas.x / canvas.y;\n  init = (iFrame <= 5);\n  tGame = 60.;\n  zmFac = 8.;\n  oDist = 5.7;\n  if (! init) {\n    stDat = Loadv4 (vec2 (0., 1.));\n    el = stDat.z;\n    az = stDat.w;\n    autoRot = Loadv4 (vec2 (2., 1.)).w;\n    aTilt = Loadv4 (vec2 (3., 0.)).zw;\n    mPtrP = vec4 (Loadv4 (vec2 (1., 1.)).zw, Loadv4 (vec2 (2., 1.)).z, 0.);\n    wgSel = int (Loadv4 (vec2 (1., 0.)).w);\n    if (mPtr.z > 0.) {\n      vuMat = StdVuMat (el, az);\n      ro = vuMat * vec3 (0., 0., - oDist * gSize);\n      vCon = vuMat * normalize (vec3 (2. * mPtr.xy * vec2 (asp, 1.), zmFac));\n      ud = (ro.xz + (- (ro.y - 0.2) / vCon.y) * vCon.xz);\n      wgObj[0] = vec3 (0.9 * gSize, 0., 1.6);\n      wgObj[1] = vec3 (0.9 * gSize, 0.5 * gSize, 0.4);\n      us = ud - wgObj[0].xy;\n      if (Maxv2 (abs (us)) < wgObj[0].z - 0.1 || wgSel == 0) {\n        if (wgSel == 0 && Maxv2 (abs (us)) < wgObj[0].z + 0.3) {\n          aTilt = 0.2 * us;\n          autoRot = 0.;\n        }\n        wgReg = 0;\n      } else if (length (ud - wgObj[1].xy) < wgObj[1].z || wgSel == 1) {\n        if (mPtrP.z <= 0.) init = true;\n        wgReg = 1;\n      } else if (wgReg < 0) {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.25 * pi + pi * mPtr.y, -0.4 * pi, -0.1 * pi);\n      }\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else {\n      aTilt *= 0.9;\n      wgSel = -1;\n      wgReg = -2;\n    }\n  }\n  iFrag = floor (fragCoord);\n  fVal = Loadv4 (iFrag);\n  if (! init) {\n    tBgn = Loadv4 (vec2 (2., 0.)).w;\n    init = (tCur - tBgn > tGame + 10.);\n  }\n  if (init) {\n    mPtrP = mPtr;\n    autoRot = 1.;\n    nStep = 0.;\n    pathLen = 0.;\n    growLim = 2. * gSize;\n    tBgn = floor (tCur);\n    ar = -1.;\n    cEn = vec2 (0., 1.);\n    cEx = gSize - vec2 (2., 3.);\n    if (iFrag.y == 0. && iFrag.x < gSize - 1.) ar = 1.;\n    else if (iFrag.x == gSize - 1. && iFrag.y < gSize - 1.) ar = 0.;\n    else if (iFrag.y == gSize - 1. && iFrag.x > 0.) ar = 3.;\n    else if (iFrag.x == 0. && iFrag.y > 0.) ar = 2.;\n    if (iFrag.x == cEn.x && iFrag.y > cEn.y) ar = 0.;\n    else if (iFrag.x > cEx.x && iFrag.y <= cEx.y) ar = 2.;\n    if (iFrag.y > 0. && iFrag.y < gSize - 1.) {\n      if (Hashff (tCur + 111.1) > 0.5 && iFrag.x == floor (gSize / 4.)) ar = 2.;\n      if (Hashff (tCur + 211.1) > 0.5 && iFrag.x == floor (3. * gSize / 4.)) ar = 0.;\n    }\n    ballPos = cEn + vec2 (-0.5 * gSize + 0.8, -0.5 * gSize + 1.);\n    ballVel = vec2 (0.);\n    ballQt = vec4 (0., 0., 0., 1.);\n    fVal.x = ar;\n  } else {\n    nStep = Loadv4 (vec2 (1., 0.)).z;\n    cEn = Loadv4 (vec2 (3., 1.)).zw;\n    cEx = Loadv4 (vec2 (4., 1.)).zw;\n    stDat.zw = Loadv4 (vec2 (5., 1.)).zw;\n    growLim = stDat.z;\n    pathLen = stDat.w;\n    ++ nStep;\n    ar = fVal.x;\n    ev[0] = vec2 (0., 1.);\n    ev[1] = vec2 (1., 0.);\n    ev[2] = vec2 (0., -1.);\n    ev[3] = vec2 (-1., 0.);\n    cbf = vec4 (1., 2., 4., 8.);\n    if (nStep < growLim && ar < 0.) {\n      ai = floor (4. * Hashfv2 (iFrag + tCur));\n      if (Hashfv2 (iFrag + tCur + 11.1) > 0.3) {\n        if (iFrag.y == 1.) {\n          if (ai == 2.) ai = 0.;\n        } else if (iFrag.y == gSize - 2.) {\n          if (ai == 0.) ai = 2.;\n        } else if (iFrag.x == 1.) {\n          if (ai == 3.) ai = 1.;\n        } else if (iFrag.x == gSize - 2.) {\n          if (ai == 1.) ai = 3.;\n        }\n      }\n      if (Loadv4 (iFrag + ((ai < 2.) ? ((ai == 0.) ? ev[0] : ev[1]) :\n         ((ai == 2.) ? ev[2] : ev[3]))).x >= 0.) ar = ai;\n    }\n    fVal.x = ar;\n    if (nStep < growLim) fVal.y = (Maxv2 (iFrag) <= gSize - 2.) ? -1. : 0.;\n    if (nStep > 2. * growLim) pathLen = floor (Loadv4 (cEx).y / 32.);\n    if (Maxv2 (iFrag) <= gSize - 2.) {\n      cb = vec4 (0.);\n      ar = Loadv4 (iFrag).x;\n      cb.wz += vec2 ((ar == 0.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[0]).x;\n      cb.wx += vec2 ((ar == 2.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + vec2 (1., 1.)).x;\n      cb.yx += vec2 ((ar == 2.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[1]).x;\n      cb.yz += vec2 ((ar == 0.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      nw = fVal.y;\n      if (nStep == growLim) {\n        nw = dot (cb, vec4 (1.));\n      } else if (nStep > growLim && nStep < 2. * growLim) {\n        if (nw < 3.) {\n          nb = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y >= 3.) ++ nb;\n          if (nw + nb == 3.) nw = 4.;\n        } else nw = 4.;\n      } else if (nStep == 2. * growLim) {\n        if (nw < 3.) {\n          nw = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y < 3.) nw += cbf[k];\n        } else nw = 0.;\n      } else if (nStep > 2. * growLim && nStep < 5. * growLim && pathLen == 0.) {\n        if (nw > 0. && nw < 32.) {\n          dir = 0.;\n          cbi = 1. / cbf;\n          cb = mod (floor (nw * cbi), 2.);\n          if (iFrag == cEn) {\n            if (cb[2] > 0.) dir = 1.;\n            nw += 32. * 1.;\n          } else {\n            cbi = cbi.zwxy;\n            for (int k = 0; k < 4; k ++) {\n              if (nw < 32. && cb[k] > 0.) {\n                nwn = Loadv4 (mod (iFrag + ev[k], gSize)).y;\n                if ((nwn - 32.) * mod (floor (nwn * cbi[k]), 2.) > 0.) {\n                  nw += 32. * (floor (nwn / 32.) + 1.);\n                  kIn = k;\n                  break;\n                }\n              }\n            }\n            if (kIn == 0) {\n              if (cb[2] > 0. || cb[3] > 0.) dir = 1.;\n            } else if (kIn == 1) {\n              if (cb[3] > 0. || cb[0] > 0.) dir = 1.;\n            } else if (kIn == 2) {\n              if (cb[1] > 0.) dir = 1.;\n            } else if (kIn == 3) {\n              if (cb[2] > 0.) dir = 1.;\n            }\n          }\n          nw += 16. * (dir - mod (floor (nw / 16.), 2.));\n        }\n      }\n      fVal.y = nw;\n    }\n  }\n  if (! init && iFrag.y == 0. && iFrag.x <= 7.) {\n    ballPos = Loadv4 (vec2 (4., 0.)).zw;\n    ballVel = Loadv4 (vec2 (5., 0.)).zw;\n    ballQt = vec4 (Loadv4 (vec2 (6., 0.)).zw, Loadv4 (vec2 (7., 0.)).zw);\n    if (autoRot > 0.) aTilt = 0.15 * sin (0.1 * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n    if (nStep > growLim) Step ();\n  }\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) fVal.zw = vec2 (gSize, 0.);\n    else if (iFrag.x == 1.) fVal.zw = vec2 (nStep, float (wgSel));\n    else if (iFrag.x == 2.) fVal.zw = vec2 ((tCur - tBgn) / tGame, tBgn);\n    else if (iFrag.x == 3.) fVal.zw = aTilt;\n    else if (iFrag.x == 4.) fVal.zw = ballPos;\n    else if (iFrag.x == 5.) fVal.zw = ballVel;\n    else if (iFrag.x == 6.) fVal.zw = ballQt.xy;\n    else if (iFrag.x == 7.) fVal.zw = ballQt.zw;\n  } else if (iFrag.y == 1.) {\n    if      (iFrag.x == 0.) fVal.zw = vec2 (el, az);\n    else if (iFrag.x == 1.) fVal.zw = mPtr.xy;\n    else if (iFrag.x == 2.) fVal.zw = vec2 (mPtr.z, autoRot);\n    else if (iFrag.x == 3.) fVal.zw = cEn;\n    else if (iFrag.x == 4.) fVal.zw = cEx;\n    else if (iFrag.x == 5.) fVal.zw = vec2 (growLim, pathLen);\n    else if (iFrag.x == 6.) fVal.zw = vec2 (zmFac, oDist);\n  }\n  fragColor = fVal;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Maze Ball Solved 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nvec4 ballQt;\nvec3 wgObj[2];\nvec2 aTilt, ballPos, ballVel;\nfloat gSize;\nconst float pi = 3.1415927;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p :\n     vec2 (- p.y, p.x)) : ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat HtMaze (vec2 p)\n{\n  vec2 e;\n  float dw, s;\n  p += 0.5 * gSize;\n  s = Loadv4 (floor (p)).x;\n  dw = WallDst (p, (s >= 0.) ? s : -1.);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (p) - e).x == ai) dw = min (dw, WallDst (p, mod (ai + 2., 4.)));\n  }\n  return max (1. - 4. * dw, 0.);\n}\n\nvoid Step ()\n{\n  float s, v;\n  s = 0.25;\n  ballVel -= 0.2 * sign (ballVel) *\n      vec2 (HtMaze (ballPos + vec2 (s * sign (ballVel.x), 0.)),\n            HtMaze (ballPos + vec2 (0., s * sign (ballVel.y))));\n  ballVel += 0.005 * aTilt - 0.03 * ballVel;\n  if (length (ballVel) > 0.1) ballVel *= 0.1 / length (ballVel);\n  ballPos += ballVel;\n  if (abs (ballPos.x) > 0.5 * gSize - 0.7) {\n    ballPos.x = (0.5 * gSize - 0.71) * sign (ballPos.x);\n    ballVel = vec2 (0.);\n  }\n  v = length (ballVel);\n  if (v > 0.) ballQt = normalize (QtMul (ballQt,\n     RotToQt (normalize (vec3 (- ballVel.y, 0., ballVel.x)), v / 0.25)));\n}\n         \nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, mPtrP, stDat, fVal, cb, cbi, cbf;\n  vec3 vCon, ro;\n  vec2 canvas, iFrag, ud, us, ev[4], cEn, cEx;\n  float tCur, nStep, growLim, autoRot, tGame, tBgn, ai, ar, nw, nwn, nb, dir,\n     az, el, asp, pathLen, zmFac, oDist;\n  int wgSel, wgReg, kIn;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = 10.;\n  if (Maxv2 (fragCoord) >= gSize) discard;\n  wgSel = -1;\n  wgReg = -2;\n  aTilt = vec2 (0.);\n  az = 0.;\n  el = -0.3 * pi;\n  asp = canvas.x / canvas.y;\n  init = (iFrame <= 5);\n  tGame = 60.;\n  zmFac = 8.;\n  oDist = 5.7;\n  if (! init) {\n    stDat = Loadv4 (vec2 (0., 1.));\n    el = stDat.z;\n    az = stDat.w;\n    autoRot = Loadv4 (vec2 (2., 1.)).w;\n    aTilt = Loadv4 (vec2 (3., 0.)).zw;\n    mPtrP = vec4 (Loadv4 (vec2 (1., 1.)).zw, Loadv4 (vec2 (2., 1.)).z, 0.);\n    wgSel = int (Loadv4 (vec2 (1., 0.)).w);\n    if (mPtr.z > 0.) {\n      vuMat = StdVuMat (el, az);\n      ro = vuMat * vec3 (0., 0., - oDist * gSize);\n      vCon = vuMat * normalize (vec3 (2. * mPtr.xy * vec2 (asp, 1.), zmFac));\n      ud = (ro.xz + (- (ro.y - 0.2) / vCon.y) * vCon.xz);\n      wgObj[0] = vec3 (0.9 * gSize, 0., 1.6);\n      wgObj[1] = vec3 (0.9 * gSize, 0.5 * gSize, 0.4);\n      us = ud - wgObj[0].xy;\n      if (Maxv2 (abs (us)) < wgObj[0].z - 0.1 || wgSel == 0) {\n        if (wgSel == 0 && Maxv2 (abs (us)) < wgObj[0].z + 0.3) {\n          aTilt = 0.2 * us;\n          autoRot = 0.;\n        }\n        wgReg = 0;\n      } else if (length (ud - wgObj[1].xy) < wgObj[1].z || wgSel == 1) {\n        if (mPtrP.z <= 0.) init = true;\n        wgReg = 1;\n      } else if (wgReg < 0) {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.25 * pi + pi * mPtr.y, -0.4 * pi, -0.1 * pi);\n      }\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else {\n      aTilt *= 0.9;\n      wgSel = -1;\n      wgReg = -2;\n    }\n  }\n  iFrag = floor (fragCoord);\n  fVal = Loadv4 (iFrag);\n  if (! init) {\n    tBgn = Loadv4 (vec2 (2., 0.)).w;\n    init = (tCur - tBgn > tGame + 10.);\n  }\n  if (init) {\n    mPtrP = mPtr;\n    autoRot = 1.;\n    nStep = 0.;\n    pathLen = 0.;\n    growLim = 2. * gSize;\n    tBgn = floor (tCur);\n    ar = -1.;\n    cEn = vec2 (0., 1.);\n    cEx = gSize - vec2 (2., 3.);\n    if (iFrag.y == 0. && iFrag.x < gSize - 1.) ar = 1.;\n    else if (iFrag.x == gSize - 1. && iFrag.y < gSize - 1.) ar = 0.;\n    else if (iFrag.y == gSize - 1. && iFrag.x > 0.) ar = 3.;\n    else if (iFrag.x == 0. && iFrag.y > 0.) ar = 2.;\n    if (iFrag.x == cEn.x && iFrag.y > cEn.y) ar = 0.;\n    else if (iFrag.x > cEx.x && iFrag.y <= cEx.y) ar = 2.;\n    if (iFrag.y > 0. && iFrag.y < gSize - 1.) {\n      if (Hashff (tCur + 111.1) > 0.5 && iFrag.x == floor (gSize / 4.)) ar = 2.;\n      if (Hashff (tCur + 211.1) > 0.5 && iFrag.x == floor (3. * gSize / 4.)) ar = 0.;\n    }\n    ballPos = cEn + vec2 (-0.5 * gSize + 0.8, -0.5 * gSize + 1.);\n    ballVel = vec2 (0.);\n    ballQt = vec4 (0., 0., 0., 1.);\n    fVal.x = ar;\n  } else {\n    nStep = Loadv4 (vec2 (1., 0.)).z;\n    cEn = Loadv4 (vec2 (3., 1.)).zw;\n    cEx = Loadv4 (vec2 (4., 1.)).zw;\n    stDat.zw = Loadv4 (vec2 (5., 1.)).zw;\n    growLim = stDat.z;\n    pathLen = stDat.w;\n    ++ nStep;\n    ar = fVal.x;\n    ev[0] = vec2 (0., 1.);\n    ev[1] = vec2 (1., 0.);\n    ev[2] = vec2 (0., -1.);\n    ev[3] = vec2 (-1., 0.);\n    cbf = vec4 (1., 2., 4., 8.);\n    if (nStep < growLim && ar < 0.) {\n      ai = floor (4. * Hashfv2 (iFrag + tCur));\n      if (Hashfv2 (iFrag + tCur + 11.1) > 0.3) {\n        if (iFrag.y == 1.) {\n          if (ai == 2.) ai = 0.;\n        } else if (iFrag.y == gSize - 2.) {\n          if (ai == 0.) ai = 2.;\n        } else if (iFrag.x == 1.) {\n          if (ai == 3.) ai = 1.;\n        } else if (iFrag.x == gSize - 2.) {\n          if (ai == 1.) ai = 3.;\n        }\n      }\n      if (Loadv4 (iFrag + ((ai < 2.) ? ((ai == 0.) ? ev[0] : ev[1]) :\n         ((ai == 2.) ? ev[2] : ev[3]))).x >= 0.) ar = ai;\n    }\n    fVal.x = ar;\n    if (nStep < growLim) fVal.y = (Maxv2 (iFrag) <= gSize - 2.) ? -1. : 0.;\n    if (nStep > 2. * growLim) pathLen = floor (Loadv4 (cEx).y / 32.);\n    if (Maxv2 (iFrag) <= gSize - 2.) {\n      cb = vec4 (0.);\n      ar = Loadv4 (iFrag).x;\n      cb.wz += vec2 ((ar == 0.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[0]).x;\n      cb.wx += vec2 ((ar == 2.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + vec2 (1., 1.)).x;\n      cb.yx += vec2 ((ar == 2.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[1]).x;\n      cb.yz += vec2 ((ar == 0.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      nw = fVal.y;\n      if (nStep == growLim) {\n        nw = dot (cb, vec4 (1.));\n      } else if (nStep > growLim && nStep < 2. * growLim) {\n        if (nw < 3.) {\n          nb = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y >= 3.) ++ nb;\n          if (nw + nb == 3.) nw = 4.;\n        } else nw = 4.;\n      } else if (nStep == 2. * growLim) {\n        if (nw < 3.) {\n          nw = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y < 3.) nw += cbf[k];\n        } else nw = 0.;\n      } else if (nStep > 2. * growLim && nStep < 5. * growLim && pathLen == 0.) {\n        if (nw > 0. && nw < 32.) {\n          dir = 0.;\n          cbi = 1. / cbf;\n          cb = mod (floor (nw * cbi), 2.);\n          if (iFrag == cEn) {\n            if (cb[2] > 0.) dir = 1.;\n            nw += 32. * 1.;\n          } else {\n            cbi = cbi.zwxy;\n            for (int k = 0; k < 4; k ++) {\n              if (nw < 32. && cb[k] > 0.) {\n                nwn = Loadv4 (mod (iFrag + ev[k], gSize)).y;\n                if ((nwn - 32.) * mod (floor (nwn * cbi[k]), 2.) > 0.) {\n                  nw += 32. * (floor (nwn / 32.) + 1.);\n                  kIn = k;\n                  break;\n                }\n              }\n            }\n            if (kIn == 0) {\n              if (cb[2] > 0. || cb[3] > 0.) dir = 1.;\n            } else if (kIn == 1) {\n              if (cb[3] > 0. || cb[0] > 0.) dir = 1.;\n            } else if (kIn == 2) {\n              if (cb[1] > 0.) dir = 1.;\n            } else if (kIn == 3) {\n              if (cb[2] > 0.) dir = 1.;\n            }\n          }\n          nw += 16. * (dir - mod (floor (nw / 16.), 2.));\n        }\n      }\n      fVal.y = nw;\n    }\n  }\n  if (! init && iFrag.y == 0. && iFrag.x <= 7.) {\n    ballPos = Loadv4 (vec2 (4., 0.)).zw;\n    ballVel = Loadv4 (vec2 (5., 0.)).zw;\n    ballQt = vec4 (Loadv4 (vec2 (6., 0.)).zw, Loadv4 (vec2 (7., 0.)).zw);\n    if (autoRot > 0.) aTilt = 0.15 * sin (0.1 * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n    if (nStep > growLim) Step ();\n  }\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) fVal.zw = vec2 (gSize, 0.);\n    else if (iFrag.x == 1.) fVal.zw = vec2 (nStep, float (wgSel));\n    else if (iFrag.x == 2.) fVal.zw = vec2 ((tCur - tBgn) / tGame, tBgn);\n    else if (iFrag.x == 3.) fVal.zw = aTilt;\n    else if (iFrag.x == 4.) fVal.zw = ballPos;\n    else if (iFrag.x == 5.) fVal.zw = ballVel;\n    else if (iFrag.x == 6.) fVal.zw = ballQt.xy;\n    else if (iFrag.x == 7.) fVal.zw = ballQt.zw;\n  } else if (iFrag.y == 1.) {\n    if      (iFrag.x == 0.) fVal.zw = vec2 (el, az);\n    else if (iFrag.x == 1.) fVal.zw = mPtr.xy;\n    else if (iFrag.x == 2.) fVal.zw = vec2 (mPtr.z, autoRot);\n    else if (iFrag.x == 3.) fVal.zw = cEn;\n    else if (iFrag.x == 4.) fVal.zw = cEx;\n    else if (iFrag.x == 5.) fVal.zw = vec2 (growLim, pathLen);\n    else if (iFrag.x == 6.) fVal.zw = vec2 (zmFac, oDist);\n  }\n  fragColor = fVal;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}