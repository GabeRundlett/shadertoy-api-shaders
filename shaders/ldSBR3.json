{
    "Shader": {
        "info": {
            "date": "1501386880",
            "description": "a hull curve that also serves as conveyor belt snake.\n\nsometimes apparently hard problems turn out to be surprisingly simple;\ni thought this would not have an analytic solution, where it turned it to be; c=a-b;",
            "flags": 0,
            "hasliked": 0,
            "id": "ldSBR3",
            "likes": 0,
            "name": "snake conveyor hull",
            "published": 3,
            "tags": [
                "conveyor",
                "hull"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 516
        },
        "renderpass": [
            {
                "code": "#define pi acos(-1.)\n\n#define aa 10./iResolution.y\n//view zoom\n#define viewZoom 5.\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\n\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,1.-15./iResolution.y);}\nvec3 SawCos3(vec3 c){\n vec3 s=vec3(sawCos(c.r),sawCos(c.g),sawCos(c.b));\n c=mix(s//supersmooth sawCos() ripple\n      ,smoothstep(aa,-aa,c)//make \"negative inside\" brighter than \"positive outside\"\n      ,.8)////mix the above 2 values\n        /(abs(c)+.5);//diminish over distance, and give \"below surface\" an extra glow.\n return sqrt(c);\n}//increase gamma \n\nfloat grid(vec2 u){u=abs(fract(u)-.5);\n u.x=max(max(u.x,u.y),1./8.);u.x=u.x*8.-3.;\n u.x=fract(u.x)/(4.-(floor(u.x+3.)));\n u.x*=u.x;return u.x*u.x;}\n\n\n\n\n//with more symmetry, these boil down to\n//step(c,0)*a+b*step(0,c);\n//step(a,b) == (sign(a-b)*.5+.5);\n  /*\nfloat aa(float a,float b){\n //float b=1.;\n return abs(a-b);\n//above is identical to below\n if(a>b)a=a-b;\n else   a=b-a;\n return a;\n}\n*/\n\n//return distance to quater worm\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);   \n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n //if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n/* special halfWorm(u,1,1) shortcut.\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y));\n return abs(a-.5*(1.+sign(u.y)));}*/\n\n\n\nvec3 ccc2(vec2 u, vec2 m){\n vec3 c=vec3(0);\n vec2 r;\n    \n //r.x=1.-m.x;//length(m-vec2(1))*.5;//making the UI simpler for debugging\n r.x=m.x;//length(m)*.5;\n r.y=-m.x+2.;//making input static\n r*=.5;    \n r=clamp(r,0.,1.);\n vec4 i=vec4(vec2(0.,r.y),vec2(1.,1.-r.x));//2 circle center, set by their radii.\n //c.r=length(u-i.zw)-r.x;\n i.xy=vec2(0.,r.y);\n //c.g=length(u-i.xy)-r.y;  \n \n //worm distance.y problem:\n \n //worm euclideanDistance problem:\n i=vec2(1.-u.x,u.y).xyxy-i;\n float a=halfWorm(i.zw,-r.x+1.,-1.);\n float b=halfWorm(i.xy, r.x   , 1.);    \n c.g=mix(b,a,step(a,b));//if(b>a)c.g=a;else c.g=b;\n c-=m.y+2.5;\n c.b=grid(u);\n return c;}\n\n//return 2 circle centers, set by their radii.\nvec4 ccc(inout vec2 m){m=clamp(vec2(m.x,-m.x+2.),0.,2.)*.5;  \n return vec4(0.,m.y,1.-vec2(0,m.x));}\n\nfloat wormEuclid(vec2 u,vec2 m){\n vec4 i=ccc(m); \n i=vec2(1.-u.x,u.y).xyxy-i;\n float a=halfWorm(i.zw,-m.x+1.,-1.);\n float b=halfWorm(i.xy, m.x   , 1.);\n return mix(b,a,step(a,b));}\n\nfloat wormY(vec2 u,vec2 m){\n vec4 i=ccc(m); \n i=vec2(1.-u.x,u.y).xyxy-i;\n float a=999.,b=999.;\n if(abs(u.x)<m.y){\n   u.y=u.y/m.y;  \n   u.x=u.x/m.y;\n   b=1.-sqrt(1.-(u.x*u.x))-u.y;\n   //b=-b;\n   b*=m.y;\n }\n   else{\n    u-=1.;\n   \n   u.y=u.y/m.x;  \n   u.x=u.x/m.x;\n       u.x=u.x*2.-u.x;\n\n     \n     a=sqrt(1.-(u.x*u.x))-u.y-1.;\n      a*=m.x;\n         //1.-sqrt(1.-(u.x*u.x))-u.y;\n     /*\n    u.x-=1.;\n  u.y=u.y-1.;\n   u.y=u.y/m.x;\n   u.x=u.x/m.x;\n //if(abs(u.x)<m.y)\n \n a=\n     sqrt(1.-(u.x*u.x))-u.y-1.;\n   //-sqrt(1.-(u.x*u.x))+u.y-m.x*.5+1.5;\n    //a*m.y;\n*/\n }\n     //-sqrt(1.-(u.x*u.x))+u.x-m.x*.5+1.5;\n //   return a;\n return min(a,b);\n}\nvec3 co(vec2 u){\n vec2 m=fr(iMouse.xy);u=fr(u);\n vec3 c; \n c.r=wormEuclid(u,m)-m.y-2.5;\n c.g=wormY(u,m);\n c.b=grid(u);\n c=SawCos3(c);\n return c*.5+c.yzx*.2;}\n \nvoid mainImage( out vec4 o, in vec2 u ){o=vec4(co(u),1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}