{
    "Shader": {
        "info": {
            "date": "1426226799",
            "description": "mouse.x:  freq\nmouse.y: % normalization      S: tune spectrum instead\nC: colormap  M/N: modulations of contrast (before normalization) D:+derivatives\nT: stop time  Z: show complex Gabor F: flip left/right \nK: clamp normalization (no div by 0)\nP,RGB",
            "flags": 16,
            "hasliked": 0,
            "id": "XlsGDs",
            "likes": 18,
            "name": "Gabor 4: normalized",
            "published": 3,
            "tags": [
                "complex",
                "gabor"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 3091
        },
        "renderpass": [
            {
                "code": "// a lot more about normalized Gabor available in my report: https://hal.inria.fr/hal-01349134\n// here: trying a variant based on complex Gabor\n\n\n#define NB 600.        // number or gabor blobs\nfloat SIZE   = 0.0566; // .22 size of gabor blobs\nfloat SPREAD = 0.;     // .5  angular variation\n\n// --- utilities ------------------------------\n\n#define PI     3.14159265358979\n#define ISQRT2 0.7071067811865\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nfloat gauss(float x,float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(vec2 v,float s) { return gauss(v.x,s)*gauss(v.y,s); }\n\nfloat rnd(vec2 uv, int z) {\n\tif      (z==0) return texture(iChannel1,uv).r+texture(iChannel1,uv).b/256.;\n\telse if (z==1) return texture(iChannel1,uv).g+texture(iChannel1,uv).a/256.;\n\telse if (z==2) return texture(iChannel1,uv).b;\n\telse           return texture(iChannel1,uv).a;\n}\nfloat rndi(float i, float j) {\n# if 1 // precision required !\n    return fract(1e5*sin(i+3.*j+0.567));\n#else\n    j += i / iChannelResolution[1].x; i = mod(i,  iChannelResolution[1].x);\n\tvec2 uv = vec2(.5+i,.5+j)/ iChannelResolution[1].x;\n\treturn texture(iChannel1,uv).r+texture(iChannel1,uv).b/256.;\n#endif\n}\n\nfloat BesselJ0(float x) {\n    x=abs(x); return (x>PI/2.) ? sqrt(2./(PI*x))*cos(x-PI/4.) : cos(x*ISQRT2);\n}\nfloat BesselJ1(float x) {\n    float s=sign(x); x=abs(x);\n    return (x>2.4) ? s*sqrt(2./(PI*x))*sin(x-PI/4.) : s*0.581865*sin(PI/2.*x/1.8411838);    \n}\n\n// --- complex Gabor ------------------------------\nvec2 Gabor(vec2 pos, float freq, float a) {\n    float t = (keyToggle(64+20))? 0. : iTime; // 'T'\n    float g = gauss(pos,SIZE);\n    if (g < 1e-3) return vec2(0.);\n    vec2 dir = ISQRT2*(cos(a)*vec2(1.,1.)+ sin(a)*vec2(-1.,1.));\n    float phi = freq*dot(pos,dir) * 2.*PI - 10.*t;\n\n    #define CAS 1 // 1: normal   others: experiments\n#if CAS==1 // bilobe\n    return g*vec2(cos(phi),sin(phi));\n\n#elif CAS==2 // blob\n    a = 2.*PI*length(dir);\n    return - 2.*PI*SIZE*SIZE*gauss(a*SIZE,1.)*vec2(cos(-10.*t),sin(-10.*t));\n#elif CAS==3 // quadrilobe (alternate way: CAS=1 + #if 1 in main )\n    dir = vec2(-dir.y,dir.x);\n    float phi2 = freq*dot(pos,dir) * 2.*PI - 10.*t;\n    return (g*vec2(cos(phi),sin(phi)) +g*vec2(cos(phi2),sin(phi2)))/2. ;\n#elif CAS==4 // 1/2 ring (sampled)\n    vec2 n=vec2(0.);\n    for (float a=0.; a<PI/2.; a+= PI/20.) {\n     \tdir = ISQRT2*(cos(a)*vec2(1.,1.)+ sin(a)*vec2(-1.,1.));\n    \tphi = freq*dot(pos,dir) * 2.*PI - 10.*t;\n        n += g*vec2(cos(phi),sin(phi));\n    }\n    return (n/10.);\n#elif CAS==5 // ring-cos\n    phi = freq*length(pos) * 2.*PI - 10.*t;\n    return g*vec2(cos(phi),sin(phi));\n#else // ring-Bessel\n    phi = freq*length(pos) * 2.*PI - 10.*t;\n    return vec2(BesselJ0(phi),BesselJ1(phi)); // where to put SIZE ?\n#endif\n}\n\n// --- complex Gabor noise = kernel * point distrib\nvec2 GaborNoise(vec2 uv, float freq, float dir) {\n    vec2 f=vec2(0.); float fa=0.;\n\tfor (float i=0.; i<NB; i++) { \n\t\tvec2 pos = vec2(1.8*rndi(i,0.),rndi(i,1.));\n        float a = dir + SPREAD *PI*(2.*i/NB-1.);\n\t\tf += Gabor(uv-pos, freq, a);\n        // fa += pow(gauss(uv-pos),2.);\n\t}\n   //fragColor = vec4(100.*fa/NB); return;\n\treturn f *sqrt(200./NB); // /6.;\n}\n\n// ------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // --- controls \n    vec2 uv = fragCoord.xy / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float m = .5* iResolution.x / iResolution.y; // mid x\n\tfloat freq = mix(10., iResolution.x/10., mouse.x);\n    if (keyToggle(64+19)) SPREAD = mouse.y;      // 'S'\n    if (keyToggle(64+16)) SIZE *= .1;            // 'P'\n\t    \n    // --- Gabor noise = kernel * point distrib\n\tvec2 f  = GaborNoise(uv,freq,0.); \n    float l0 = length(f), k=.5;\n#if 0 // alternate quadrilobe management: #if 1 here + CAS=1 above\n    vec2 f2 = GaborNoise(uv,freq,PI/2.);\n    float l2 = length(f2);\n\tf = f+f2; l0 = sqrt(l0*l0+l2*l2); // l0 = length(f); // for comparison\n#endif\n    \n    // --- Display energy \n    if(keyToggle(64+13)) {           // 'M'\n\t    fragColor = vec4(.5*l0);     // show amplitude\n    \tif (l0<.2) fragColor.r = 1.-fragColor.r/.2; // div by ~0\n        if(keyToggle(64+4)) {                             // 'D'\n            fragColor.gb = vec2(0.);\n            if (keyToggle(64+18)) fragColor.r=0.;         // 'R'\n            float g = length(vec2(dFdx(l0),dFdy(l0)))*iResolution.y;\n        \tif (!keyToggle(64+7)) fragColor.g = 1.-.05*g; // 'G' low gradient\n        \t//k = clamp(1.-.01*g,0.,1.)*clamp(1.-.4*l0/.2,0.,1.);\n            k = .0005*length(vec2(dFdx(g),dFdy(g)))*iResolution.y;\n\t\t\tif (!keyToggle(64+2)) fragColor.b = (2.*k);   // 'B' marks discontinuities\n        }\n    }\n    // --- Normalize and display Gabor noise\n    else {\n\t    float b = (keyToggle(64+19)) ? 1. : 1.-mouse.y;\n        if(keyToggle(64+11)) l0 = max(k,l0); // 'K': clamp normalization\n    \tif ((uv.x<m)==!keyToggle(64+6)) f *= .5; else f /= mix(2.,l0,b);\n        //f0 = f;\n   \t\tif(!keyToggle(64+26)) f.x=f.y;       // real vs complex Gabor\n        if(keyToggle(64+3))                  // 'C'  colorMap\n        \t{ f = cos(3.14*f); if(!keyToggle(64+26)) f.y*=-1.; }\n    \tfragColor = vec4(.5+.5*f.x,.5+.5*f.y,0.,1.);\n    }\n    if(keyToggle(64+14)) fragColor = mix(fragColor,.5*vec4(l0),.5); // 'N'\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}