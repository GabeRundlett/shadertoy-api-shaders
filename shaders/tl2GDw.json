{
    "Shader": {
        "info": {
            "date": "1559849883",
            "description": "Extension of jaybird's Weyl Sequence shader - comparison to Halton, Hammersley, etc.",
            "flags": 32,
            "hasliked": 0,
            "id": "tl2GDw",
            "likes": 16,
            "name": "Low Discrepancy Sequences",
            "published": 3,
            "tags": [
                "random",
                "halton",
                "lowdiscrepancy",
                "weyl",
                "hammersley"
            ],
            "usePreview": 1,
            "username": "bernie_freidin",
            "viewed": 1765
        },
        "renderpass": [
            {
                "code": "// ^^ [Buffer A] is what you're looking for\n\n//$INPUT0=BUFFER_A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ========================================================================\n// Comparison between various 2D sequences\n// Bottom row: Weyl, Hammersley, Halton(2,3), random\n// Top row: bit-reversed de-interleaved sequence\n// Based on https://www.shadertoy.com/view/4dtBWH by jaybird\n// See also http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// ========================================================================\n\n//$INPUT0=BUFFER_A\n//$INPUT1=RGBA_NOISE_MEDIUM_TEXTURE\n\n#define POINTS_PER_FRAME 1\n#define POINTS_TOTAL 1024 // <-- set this to zero to continue forever (but disable Hammersley)\n#define POINTS_TOTAL_LOG_2 10 // <-- set this to zero to disable the bit-reverse de-interleaved sequence\n\n#if POINTS_TOTAL > 0\n#define DOT_SIZE max(0.000015, 0.08/float(POINTS_TOTAL))\n#else\n#define DOT_SIZE 0.000015\n#endif\n\nvec2 Weyl(int i)\n{\n\t//return fract(float(n)*vec2(0.754877669, 0.569840296));\n    return fract(vec2(i*ivec2(12664745, 9560333))/exp2(24.0)); // integer mul to avoid round-off\n}\n\nfloat Halton(int b, int i)\n{\n    float r = 0.0;\n    float f = 1.0;\n    while (i > 0) {\n        f = f / float(b);\n        r = r + f * float(i % b);\n        i = int(floor(float(i) / float(b)));\n    }\n    return r;\n}\n\nfloat Halton2(int i)\n{\n#if __VERSION__ >= 400\n\treturn float(bitfieldReverse(uint(i)))/4294967296.0;\n#else\n\treturn Halton(2, i);\n#endif\n}\n\nvec2 Halton23(int i)\n{\n    return vec2(Halton2(i), Halton(3, i));\n}\n\nvec2 Halton35(int i)\n{\n    return vec2(Halton(3, i), Halton(5, i));\n}\n\nvec2 Hammersley(int i, int n)\n{\n    return vec2(Halton2(i), float(i)/float(n));\n}\n\n// these values of m lead to complete reordered sequences .. but not all\n// of these are visually appealing\n/*\nn=16, m=[]\nn=32, m=[3,11]\nn=64, m=[5,13]\nn=128, m=[3,43]\nn=256, m=[]\nn=512, m=[3,9,19,27,57,171]\nn=1024, m=[5,25,41,205]\nn=2048, m=[3,683]\nn=4096, m=[17,241]\nn=8192, m=[3,2731]\nn=16384, m=[5,29,113,145,565,3277]\nn=32768, m=[3,9,11,33,99,331,993,2979,3641,10923]\nn=65536, m=[]\n*/\n    \nvec2 HammersleyReordered(int i, int n)\n{\n    int m = 1;\n    if (n == 512)\n        m = 27; // 19 also works\n    else if (n == 1024)\n        m = 41; // 25 also works\n    else if (n == 4096)\n        m = 45; // 45 has one sequence error but looks ok .. 17 and 241 have none but don't look good\n    //int j = (i + (i%m)*n)/m;\n    int j = (i*m)%n; // simpler .. always yields complete sequences as long as GCD(m,n)=1\n    return Hammersley(j, n);\n}\n\nvec2 Random(int i)\n{\n\tivec2 dims = textureSize(iChannel1, 0); // RGBA Noise Medium\n\treturn texelFetch(iChannel1, ivec2(i%dims.x, i/dims.y), 0).xy;\n}\n\n#if POINTS_TOTAL_LOG_2 > 0 && POINTS_TOTAL > 0\n#if (1 << POINTS_TOTAL_LOG_2) != POINTS_TOTAL || (POINTS_TOTAL_LOG_2 & 1) != 0\n\t// POINTS_TOTAL must be 1 << POINTS_TOTAL_LOG_2\n\t// also POINTS_TOTAL_LOG_2 must be even\n\tmismatch!\n#endif\nuint GetOddBits(uint x)\n{\n    x = x & 0x55555555U;\n    x = (x | (x >> 1)) & 0x33333333U;\n    x = (x | (x >> 2)) & 0x0F0F0F0FU;\n    x = (x | (x >> 4)) & 0x00FF00FFU;\n    x = (x | (x >> 8)) & 0x0000FFFFU;\n    return x;\n}\n\nuint BitReverseAndShift(uint x, int bits)\n{\n\tx = (x >>  1) & 0x55555555U | (x <<  1) & ~0x55555555U;\n\tx = (x >>  2) & 0x33333333U | (x <<  2) & ~0x33333333U;\n\tx = (x >>  4) & 0x0F0F0F0FU | (x <<  4) & ~0x0F0F0F0FU;\n\tx = (x >>  8) & 0x00FF00FFU | (x <<  8) & ~0x00FF00FFU;\n\tx = (x >> 16) & 0x0000FFFFU | (x << 16) & ~0x0000FFFFU;\n\treturn x >> (32 - bits); // shift result to lower bits\n}\n\nvec2 BitReverseDeInterleave(int i, int n)\n{\n    uint x = BitReverseAndShift(uint(i), POINTS_TOTAL_LOG_2);\n    return vec2(GetOddBits(x), GetOddBits(x >> 1))/sqrt(float(n));\n}\n#endif // POINTS_TOTAL_LOG_2 > 0 && POINTS_TOTAL > 0\n\nfloat ShadePoint(vec2 p)\n{\n\treturn 1.0 - smoothstep(0.0, DOT_SIZE, dot(p, p));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 5.0*fragCoord/iResolution.x;\n    float z = 0.0;\n    const int n = POINTS_TOTAL;\n    for (int i = 0; i < POINTS_PER_FRAME; i++) {\n        vec3 p = vec3(0);\n        int index = i + iFrame*POINTS_PER_FRAME;\n        if (index < n || n == 0) {\n            vec2 uv1 = uv;\n            if (uv.y < 1.0) {\n            #if POINTS_TOTAL > 0\n                if (p.z == 0.0 && uv1.x < 1.0) { p.xy = Hammersley(index, n) - uv1; p.z = 1.0; } uv1.x -= 1.0;\n            #endif // POINTS_TOTAL > 0\n                if (p.z == 0.0 && uv1.x < 1.0) { p.xy = Weyl(index) - uv1; p.z = 1.0; } uv1.x -= 1.0;\n                if (p.z == 0.0 && uv1.x < 1.0) { p.xy = Halton23(index) - uv1; p.z = 1.0; } uv1.x -= 1.0;\n                if (p.z == 0.0 && uv1.x < 1.0) { p.xy = Random(index) - uv1; p.z = 1.0; } uv1.x -= 1.0;\n            } else {\n                uv1.y -= 1.0;\n            #if POINTS_TOTAL > 0\n                if (p.z == 0.0 && uv1.x < 1.0) { p.xy = HammersleyReordered(index, n) - uv1; p.z = 1.0; } uv1.x -= 1.0;\n            #if POINTS_TOTAL_LOG_2 > 0\n            \tif (p.z == 0.0 && uv1.x < 1.0) { p.xy = BitReverseDeInterleave(index, n) - uv1; p.z = 1.0; } uv1.x -= 1.0;\n            #endif // POINTS_TOTAL_LOG_2 > 0\n            #endif // POINTS_TOTAL > 0\n            }\n        }\n        if (p.z == 1.0)\n        \tz = max(ShadePoint(p.xy), z);\n    }\n    fragColor.rgb = mix(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, vec3(1), z);\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}