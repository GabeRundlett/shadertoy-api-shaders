{
    "Shader": {
        "info": {
            "date": "1636629695",
            "description": "trakmania car with raymarching\n\nif someone knows how to reduce compilation time I would be very happy to know (take about 1min10 to compile currently).",
            "flags": 0,
            "hasliked": 0,
            "id": "sdVGzK",
            "likes": 24,
            "name": "trackmania car",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "car",
                "trackmania",
                "tmnf"
            ],
            "usePreview": 1,
            "username": "mdb",
            "viewed": 452
        },
        "renderpass": [
            {
                "code": "\n//ray tracing///////////////////////////////////////////////////////////////////////////\nstruct AABB{vec3 down, up;};\nAABB centerDim(vec3 center, vec3 dim){return AABB(center - 0.5*dim, center + 0.5*dim);}\nvec2 box(vec3 ro, vec3 rd, AABB aabb){\n        \n        vec3 dirfrac = 1.0 / rd;\n        vec3 t1 = (aabb.down - ro)*dirfrac;\n        vec3 t2 = (aabb.up - ro)*dirfrac;\n        \n        vec3 t3 = min(t1, t2);\n        vec3 t4 = t1 + t2 - t3;\n\n        float tmin = max(max(t3.x, t3.y), t3.z);\n        float tmax = min(min(t4.x, t4.y), t4.z);\n\n        if (tmax < 0.0 || tmin > tmax) return vec2(FALSE);\n\n        return vec2(tmin, tmax);\n}\nvec3 boxNormal(vec3 pos, AABB b){\n    pos -= 0.5*(b.up + b.down);\n    pos /= 0.5*abs(b.up - b.down);\n    vec3 n = vec3(0.0);\n    if(abs(pos.x)>0.995){n.x = pos.x;}\n    if(abs(pos.y)>0.995){n.y = pos.y;}\n    if(abs(pos.z)>0.995){n.z = pos.z;}\n    n = normalize(n);\n    return n;\n}\n\nfloat cylinder( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 pa, in vec3 pb, float ra ) {\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    \n    if (h < 0.) return FALSE;\n    \n    h = sqrt(h);\n    float d = (-b-h)/a;\n\n    float y = caoc + d*card;\n    if (y > 0. && y < caca && d >= distBound.x && d <= distBound.y) {\n        normal = (oc+d*rd-ca*y/caca)/ra;\n        return d;\n    }\n\n    d = ((y < 0. ? 0. : caca) - caoc)/card;\n    \n    if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\n        normal = normalize(ca*sign(y)/caca);\n        return d;\n    } else {\n        return FALSE;\n    }\n}\n\nvec2 iBox(vec3 ro, vec3 rd, AABB aabb, out vec3 normal){\n        \n        vec3 dirfrac = 1.0 / rd;\n        vec3 t1 = (aabb.down - ro)*dirfrac;\n        vec3 t2 = (aabb.up - ro)*dirfrac;\n        \n        vec3 t3 = min(t1, t2);\n        vec3 t4 = t1 + t2 - t3;\n\n        float tmin = max(max(t3.x, t3.y), t3.z);\n        float tmax = min(min(t4.x, t4.y), t4.z);\n\n        if (tmax < 0.0 || tmin > tmax) return vec2(FALSE);\n        \n        vec3 pos = ro + tmin*rd;\n        pos -= 0.5*(aabb.up + aabb.down);\n        pos /= 0.5*abs(aabb.up - aabb.down);\n        normal = vec3(0.0);\n        if(abs(pos.x)>0.995){normal.x = pos.x;}\n        if(abs(pos.y)>0.995){normal.y = pos.y;}\n        if(abs(pos.z)>0.995){normal.z = pos.z;}\n        normal = normalize(normal);\n\n        return vec2(tmin, tmax);\n}\n\n//ray marching//////////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/Xds3zN\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    return mix(a, b, h) + h * (1.0 - h) * k * 0.5;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n//parts//////////////////////////////////////////////////////////////////////////////////\n#ifdef CAR\nfloat sdfBody(vec3 pos){\n    vec3 p = pos; // main body\n    p = mat3x3(1.0, 0.0, 0.0,\n               0.0, 0.9987, 0.0507,\n               0.0, -0.0507, 0.9987) * pos;\n    p.y += 0.1*pow(max(-p.z, 0.0), 3.0);\n    float d = sdEllipsoid( p - vec3(0.0, 0.250172, 0.034988), vec3(0.214086, 0.167228, 1.03));\n    //bottom plate\n    #ifdef DETAILCAR\n    p = pos - vec3(0.0, 0.150917, -0.530452);\n    d = min(d, sdBox(p , vec3(0.170919, 0.032961, 0.121223)) - 0.02);\n    \n    //front wing (down)\n    p = pos - vec3(0.003025, 0.133558, -0.895936);\n    p.yz = mat2x2(0.6691, 0.7431, -0.7431, 0.6691) * p.yz;\n    d = smin(d, sdBox(p , vec3(0.22312, 0.003805, 0.035775)), 0.05);\n    //front wing (up)\n    p = pos - vec3(0.004898, 0.189705, -0.796952);\n    p.yz = mat2x2(0.9205, 0.3907, -0.3907, 0.9205) * p.yz;\n    d = smin(d, sdBox(p , vec3(0.154266, 0.003941, 0.062824)), 0.02);\n    //antena\n    p = pos - vec3(0.091767, 0.39, -0.440064);\n    d = smin(d, sdCylinder(p, vec2(0.003316, 0.042221)), 0.01);\n    #endif\n    //middle bump\n    p = pos - vec3(0.0, 0.434555, 0.394036);\n    p.yz = mat2x2(0.9945, -0.1045, 0.1045, 0.9945) * p.yz;\n    d = smin(d, sdEllipsoid(p , vec3(0.09712, 0.09712, 0.426178)), 0.07);\n    //glass\n    p = pos - vec3(0.0, 0.323151, 0.000632);\n    d = min(d, sdEllipsoid(p , vec3(0.144777, 0.132625, 0.405275)));\n    \n    //cokpit (void)\n    p = pos - vec3(-0.001684, 0.4563, 0.107312);\n    float c = sdBox(p, vec3(0.153123, 0.253123, 0.21701));\n    d = smax(d, -c, 0.05);\n    //side bump\n    vec3 ps = vec3(abs(pos.x), pos.y, pos.z);\n    p = ps - vec3(0.178125, 0.332702, 0.368919);\n    d = smin(d, sdEllipsoid(p , vec3(0.09712, 0.09712, 0.426178)), 0.03);\n    #ifdef DETAILCAR\n    //air entry 1 (void)\n    p = ps - vec3(0.232716, 0.336058, 0.263102);\n    p.xz = mat2x2(0.9980, -0.0627, 0.0627, 0.9980) * p.xz;\n    d = smax(d, -sdEllipsoid(p , vec3(0.048859, 0.065034, 0.327925)), 0.05);\n    #endif\n    //side air entry construction:\n    //big shape\n    p = ps - vec3(0.005926, 0.167606, -0.025842);\n    float bs = sdEllipsoid(p , vec3(0.414984, 1.0, 1.0));\n    bs = max(bs, -c);;\n    //top\n    bs = smax(bs, pos.y - 0.32 + max(0.0, 0.07/(1.0 + exp(10.0*(pos.z - 0.1)))), 0.03);\n    //bottom\n    bs = smax(bs, -pos.y + 0.1 + max(0.0, 0.3*(pos.z - 0.33)), 0.03);\n    //front\n    bs = smax(bs, -dot(ps - vec3(0.0, 0.0,-0.4), normalize(vec3(-0.5, -0.5, 1.0))), 0.01);\n    //air entry 2 void\n    #ifdef DETAILCAR\n    p = ps - vec3(0.30883, 0.17531, -0.281175);\n    bs = smax(bs, -sdBox(p, vec3(0.086429, 0.058429, 0.318638)), 0.02);\n    #endif\n    d = smin(d, bs, 0.02);\n    \n    //top cover\n    p = pos.xzy - vec3(-0.0, 0.380554, 0.340222);\n    d = min(d, sdRhombus(p, 0.073637, 0.103637, 0.047325, 0.1));\n    #ifdef DETAILCAR\n    //engine top\n    p = ps  - vec3(0.090865, 0.430824, 0.585795);\n    p.xz = mat2x2(0.9997, 0.0209, -0.0209, 0.9997) * p.xz;\n    p.xy = mat2x2(0.8090, 0.5877, -0.5877, 0.8090) * p.xy;\n    p.zy = mat2x2(0.9822, 0.1873, -0.1873, 0.9822) * p.zy;\n    d = min(d, sdBox(p, vec3(0.040173, 0.022703, 0.133894)) - 0.002);\n    //block under\n    p = pos - vec3(0.0, 0.156481, 0.518026);\n    d = min(d, sdBox(p, vec3(0.20718, 0.074986, 0.300785)) - 0.001);\n    #endif\n    //back cut\n    d = max(d, -dot(ps - vec3(0.0, 0.0, 0.529344), vec3(0.0, 0.85716, -0.5150)));\n    d = max(d, -dot(ps - vec3(0.0, 0.0, 0.89541), vec3(0.0, -0.1045, -0.9945)));\n    \n    //back under 1\n    p = ps - vec3(0.192716, 0.143408, 0.570004);\n    d = min(d, sdBox(p, vec3(0.00652, 0.067714, 0.25495)) - 0.001);\n    d = smax(d, -dot(ps - vec3(0.0, 0.0, 0.598839), vec3(0.0, 0.8386, -0.5446)), 0.05);\n    //back under 2\n    p = ps - vec3(0.069967, 0.147173, 0.616744);\n    d = min(d, sdBox(p, vec3(0.007172, 0.078738, 0.25495)) - 0.001);\n    d = smax(d, -dot(ps - vec3(0.0, 0.0, 0.118614), vec3(0.0, 0.9876, -0.1564)), 0.08);\n    \n    //back box\n    p = pos - vec3(0.0, 0.267777, 0.623707);\n    d = min(d, sdBox(p, vec3(0.137705, 0.022871, 0.24837)) - 0.001);\n    #ifdef DETAILCAR\n    //back smoke out\n    p = pos - vec3(0.0, 0.389587, 0.896463);\n    p.yz = mat2x2(0.9848, -0.1736, 0.1736, 0.9848) * p.yz;\n    d = smax(d, -sdBox(p, vec3(0.091775, 0.086516, 0.094237)), 0.06);\n    \n    p = ps - vec3(0.042621, 0.35046, 0.787099);\n    d = min(d, sdBox(p, vec3(0.031889, 0.011231, 0.072799)) - 0.005);\n    d = max(d, -sdBox(p, vec3(0.031889, 0.011231, 0.092799)));\n    \n    //back rombus top\n    p = ps.xzy - vec3(0.01, 0.727141, 0.390539);\n    d = min(d, sdRhombus(p, 0.031889, 0.011231, 0.092799, 0.001));\n    \n    //back pipe\n    p = ps;\n    d = min(d, sdCapsule(p, vec3(0.16925, 0.27345, 0.905582), vec3(-0.16925, 0.27345, 0.905582), 0.01));\n    d = smin(d, sdCapsule(p, vec3(0.211834, 0.294284, 0.808042), vec3(0.16925, 0.27345, 0.905582), 0.01), 0.01);\n    \n    //back wind\n    p = ps - vec3(0.002531, 0.469511, 0.871087);\n    p.yz = mat2x2(0.9923, 0.1236, -0.1236, 0.9923) * p.yz;\n    \n    float w2 = sdBox(p, vec3(0.20705, 0.00505, 0.082297));\n    p +=vec3(0.0, 0.01, 0.02);\n    w2 = smin(w2, sdBox(p, vec3(0.15705, 0.00505, 0.052297)), 0.05);\n    \n    p = ps - vec3(0.264567, 0.429921, 0.872511);\n    p.zy = mat2x2(0.9702, 0.0697, -0.0697, 0.9702) * p.zy;\n    p.xy = mat2x2(0.6427, -0.7660, 0.7660, 0.6427) * p.xy;\n    w2 = smin(w2, sdBox(p, vec3(0.004028, 0.060656, 0.077419)), 0.05);\n    d = min(d, w2);\n    //baxk wind support\n    p = ps - vec3(0.177204, 0.361375, 0.858586);\n    p.zy = mat2x2(0.9205, 0.3907, -0.3907, 0.9205) * p.zy;\n    d = smin(d, sdBox(p, vec3(0.003402, 0.125143, 0.025331)), 0.02);\n    #endif\n    \n    return d;\n}\n\nvec4 body(vec3 ro, vec3 rd, vec2 bounds){\n    float t = max(bounds.x, 0.0);\n    for(int i = 0; i < 100; i++){\n        float d = sdfBody(ro + rd*t);\n        t += d;\n        if(abs(d) < 0.001) return vec4(t);\n        if(t > bounds.y) break;\n    }\n    return vec4(FALSE);\n\n}\n\n#ifdef WHEELS\nfloat sdfWheel(vec3 pos){\n   \n    pos.yz = mat2x2(cos(ti), sin(ti), -sin(ti), cos(ti)) * pos.yz;\n    vec3 p = pos.zxy;\n    \n    float d = sdCylinder(p, vec2(0.164666, 0.08047)) - 0.02; // outer ring\n    d = smax(d, -sdCylinder(p, vec2(0.106692, 0.19047)), 0.05);  //inner void\n    d = min(d, sdCylinder(p, vec2(0.053409, 0.06047)) - 0.01); //inner cyclinder 1\n    d = min(d, sdCylinder(p, vec2(0.04409, 0.08047)));\n    //wheel segment\n    vec3 ps = pos; ps.x = abs(ps.x);\n    d = min(d, sdBox(ps - vec3(0.05, 0.0, 0.0), vec3(0.011874, 0.020373, 0.1459)));\n    d = min(d, sdBox(ps - vec3(0.05, 0.0, 0.0), vec3(0.011874, 0.1459, 0.020373)));\n    \n    return d;\n}\n\n\nvec4 wheel(vec3 ro, vec3 rd, vec2 bounds, vec3 center){\n    float t = max(0.0, bounds.x);\n    for(int i = 0; i < 100; i++){\n        float d = sdfWheel(ro + rd*t - center);\n        t += d;\n        if(abs(d) < 0.001) return vec4(t);\n        if(t > bounds.y) break;\n    }\n    return vec4(FALSE);\n\n}\n#endif\n\nvec4 frontSuspension(vec3 ro, vec3 rd, vec2 bounds, out vec3 normal){\n    float d = 1e5;\n    float c; vec3 n;\n    //left\n    c = cylinder(ro, rd, bounds, n, vec3(0.135909, 0.257544, -0.594238), \n                                    vec3(0.334025, 0.193496, -0.786161), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(0.050552, 0.222349, -0.804578), \n                                    vec3(0.387557, 0.222571, -0.812828), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(0.108501, 0.251853, -0.728061), \n                                    vec3(0.354193, 0.154254, -0.824183), 0.007);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(0.111717, 0.163316, -0.824627), \n                                    vec3(0.354193, 0.154254, -0.824183), 0.015);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(0.14054, 0.162967, -0.686332), \n                                    vec3(0.354193, 0.154254, -0.824183), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    //left\n    c = cylinder(ro, rd, bounds, n, vec3(-0.135909, 0.257544, -0.594238), \n                                    vec3(-0.334025, 0.193496, -0.786161), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(-0.050552, 0.222349, -0.804578), \n                                    vec3(-0.387557, 0.222571, -0.812828), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(-0.108501, 0.251853, -0.728061), \n                                    vec3(-0.354193, 0.154254, -0.824183), 0.007);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(-0.111717, 0.163316, -0.824627), \n                                    vec3(-0.354193, 0.154254, -0.824183), 0.015);\n    if(accept(c)){d = c; normal = n;}\n    c = cylinder(ro, rd, bounds, n, vec3(-0.14054, 0.162967, -0.686332), \n                                    vec3(-0.354193, 0.154254, -0.824183), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    //link wheel\n    \n    c = iBox(ro, rd, centerDim(vec3(0.351379, 0.1903, -0.819331), vec3(0.012586, 0.119632, 0.050369)), n).x;\n    if(accept(c)){d = c; normal = n;}\n    \n    c = iBox(ro, rd, centerDim(vec3(-0.341379, 0.1903, -0.819331), vec3(0.012586, 0.119632, 0.050369)), n).x;\n    if(accept(c)){d = c; normal = n;}\n    \n \n    if(d == 1e5) d = FALSE;\n    return vec4(d, 0.0, 0.0, 0.0);\n}\n\nvec4 backSuspension(vec3 ro, vec3 rd, vec2 bounds, out vec3 normal){\n    float d = 1e5;\n    float c; vec3 n;\n    \n    //left\n    c = cylinder(ro, rd, bounds, n, vec3(0.161399, 0.256042, 0.697725), \n                                    vec3(0.391399, 0.256042, 0.697725), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(0.161399, 0.189825, 0.697725), \n                                    vec3(0.391399, 0.189825, 0.697725), 0.02);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(0.381582, 0.14403, 0.711996), \n                                    vec3(0.18377, 0.13842, 0.706374), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(0.381582, 0.14403, 0.711996), \n                                    vec3(0.189643, 0.131519, 0.592709), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(0.381582, 0.14403, 0.701996), \n                                    vec3(0.232683, 0.272933, 0.641396), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    //right\n    c = cylinder(ro, rd, bounds, n, vec3(-0.161399, 0.256042, 0.697725), \n                                    vec3(-0.391399, 0.256042, 0.697725), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(-0.161399, 0.189825, 0.697725), \n                                    vec3(-0.391399, 0.189825, 0.697725), 0.02);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(-0.381582, 0.14403, 0.711996), \n                                    vec3(-0.18377, 0.13842, 0.706374), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(-0.381582, 0.14403, 0.711996), \n                                    vec3(-0.189643, 0.131519, 0.592709), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    c = cylinder(ro, rd, bounds, n, vec3(-0.381582, 0.14403, 0.701996), \n                                    vec3(-0.232683, 0.272933, 0.641396), 0.01);\n    if(accept(c)){d = c; normal = n;}\n    \n    \n \n    if(d == 1e5) d = FALSE;\n    return vec4(d, 0.0, 0.0, 0.0);\n}\n\n#ifdef DRIVER\nfloat sdfPilot(vec3 pos){\n    float d;\n    vec3 p = pos; // main body\n    //helmet\n    d = sdSphere(p - vec3(0.0, 0.4481, 0.228917), 0.071918);\n    d = smin(d, sdSphere(p - vec3(0.0, 0.376305, 0.188372), 0.033391), 0.1);\n    d = max(d, -dot(p - vec3(0.0, 0.319, 0.0), vec3(0.0, 0.9743, -0.2249)));\n    \n    //glass helmet\n    p -= vec3(0.0, 0.431697, 0.174894);\n    p.yz = mat2x2(0.9743, 0.2249, -0.2249, 0.9743) * p.yz;\n    float v = sdBox(p, vec3(0.074463, 0.028347, 0.065994));\n    v = max(v, pos.z - 0.226);\n    v = max(v, sdSphere(pos - vec3(0.0, 0.416611, 0.217582), 0.085037)); \n    d = min(d, v);\n    \n    //helmet box\n    p = pos - vec3(0.0, 0.474635, 0.172322);\n    p.yz = mat2x2(0.7986, 0.6018, -0.6018, 0.7986) * p.yz;\n    d = smin(d, sdBox(p, vec3(0.018936)), 0.01);\n    \n    //body\n    p = pos;\n    float b = sdBox(p - vec3(0.004708, 0.316866, 0.22124), vec3(0.106223, 0.023876, 0.035158));\n    b = smin(b, sdBox(p - vec3(0.004708, 0.213847, 0.140326), vec3(0.060611, 0.023876, 0.035158)), 0.3);\n    d = min(d, b);\n    \n    p = pos;\n    p.x = abs(p.x);\n    d = smin(d, sdCapsule(p, vec3(0.073469, 0.339284, -0.074294), vec3(0.135186, 0.347432, 0.213145), 0.023), 0.05);\n    \n    \n    //Steering wheel\n    p -= vec3(0.004708, 0.304301, -0.078684);\n    p.yz = p.zy;\n    d = min(d, sdTorus(p, vec2(0.077048, 0.01)));\n    d = min(d, sdBox(p, vec3(0.077048, 0.01, 0.01)));\n    \n    return d;\n}\n\nvec4 pilot(vec3 ro, vec3 rd, vec2 bounds){\n    float t = max(bounds.x, 0.0);\n    for(int i = 0; i < 100; i++){\n        float d = sdfPilot(ro + rd*t);\n        t += d;\n        if(abs(d) < 0.001) return vec4(t);\n        if(t > bounds.y) break;\n    }\n    return vec4(FALSE);\n\n}\n#endif\n\n\n#endif\n\n#define ZERO (min(iFrame,0))\n#define NORMAL(f)vec3 n = vec3(0.0);for( int i=ZERO; i<4; i++ ){vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);n += e*f(pos+e*0.001);}normal = normalize(n)\n//car intersection///////////////////////////////////////////////////////////////////////\n#define carID 1.0\n#define WHEELID 2.0\n#define SUSPEN1ID 6.0\n#define SUSPEN2ID 7.0\n#define DRIVERID 8.0\nvec4 car(vec3 ro, vec3 rd, out vec3 normal){    //vec4(distance, ID, uv)\n    float d = 1e10;\n    float ID = -1.0;\n    vec2 UV;\n    vec2 bb = box(ro, rd, centerDim(vec3(0.0, 0.29444, 0.0), vec3(1.06, 0.581, 2.0)));\n    if(bb.x == FALSE) return vec4(FALSE, carID, 0.0, 0.0);\n    #ifdef CAR\n    \n    vec2 w1;\n    //weel front right\n    w1 = box(ro, rd, centerDim(vec3(-0.430973, 0.188607, -0.808671), vec3(0.182413, 0.366184, 0.365647)));\n    if(accept(w1.x)){\n        #ifdef WHEELS\n        vec4 w2 = wheel(ro, rd, w1, vec3(-0.430973, 0.188607, -0.808671));\n        if(accept(w2.x)){\n            d = min(d, w2.x);\n            vec3 pos = ro + w2.x * rd - vec3(-0.430973, 0.188607, -0.808671);\n            NORMAL(sdfWheel);\n            UV = vec2(pos.x/0.182413*0.5 + 0.5, fract((atan(pos.y, pos.z)-ti)/2.0/PI));\n            ID = WHEELID + length(pos.yz);\n        }\n        #else\n        d = min(d, iBox(ro, rd, centerDim(vec3(-0.430973, 0.188607, -0.808671), vec3(0.182413, 0.366184, 0.365647)), normal).x);\n        #endif\n    }\n    \n    //weel front left\n    w1 = box(ro, rd, centerDim(vec3(0.438217, 0.189125, -0.808624), vec3(0.182413, 0.366184, 0.365647)));\n    if(accept(w1.x)){\n        #ifdef WHEELS\n        vec4 w2 = wheel(ro, rd, w1, vec3(0.438217, 0.189125, -0.808624));\n        if(accept(w2.x)){\n            d = min(d, w2.x);\n            vec3 pos = ro + w2.x * rd - vec3(0.438217, 0.189125, -0.808624);\n            NORMAL(sdfWheel);\n            UV = vec2(pos.x/0.182413*0.5 + 0.5, fract((atan(pos.y, pos.z)-ti)/2.0/PI));\n            ID = WHEELID + length(pos.yz);\n\n        }\n        #else\n        d = min(d, iBox(ro, rd, centerDim(vec3(0.438217, 0.189125, -0.808624), vec3(0.182413, 0.366184, 0.365647)), normal).x);\n        #endif\n    }\n    \n    //weel back right\n    w1 = box(ro, rd, centerDim(vec3(-0.442033, 0.188607, 0.690881), vec3(0.182413, 0.366184, 0.364647)));\n    if(accept(w1.x)){\n        #ifdef WHEELS\n        vec4 w2 = wheel(ro, rd, w1, vec3(-0.442033, 0.188607, 0.690881));\n        if(accept(w2.x)){\n            d = min(d, w2.x);\n            vec3 pos = ro + w2.x * rd - vec3(-0.442033, 0.188607, 0.690881);\n            NORMAL(sdfWheel);\n            UV = vec2(pos.x/0.182413*0.5 + 0.5, fract((atan(pos.y, pos.z)-ti)/2.0/PI));\n            ID = WHEELID + length(pos.yz);\n        }\n        #else\n        d = min(d, iBox(ro, rd, centerDim(vec3(-0.442033, 0.188607, 0.690881), vec3(0.182413, 0.366184, 0.364647)), normal).x);\n        #endif\n    }\n    \n    //weel back left\n    w1 = box(ro, rd, centerDim(vec3(0.446449, 0.188607, 0.690882), vec3(0.182413, 0.366184, 0.364647)));\n    if(accept(w1.x)){\n        #ifdef WHEELS\n        vec4 w2 = wheel(ro, rd, w1, vec3(0.446449, 0.188607, 0.690882));\n        if(accept(w2.x)){\n            d = min(d, w2.x);\n            vec3 pos = ro + w2.x * rd - vec3(0.446449, 0.188607, 0.690882);\n            NORMAL(sdfWheel);\n            UV = vec2(pos.x/0.182413*0.5 + 0.5, fract((atan(pos.y, pos.z)-ti)/2.0/PI));\n            ID = WHEELID + length(pos.yz);\n        }\n        #else\n        d = min(d, iBox(ro, rd, centerDim(vec3(0.446449, 0.188607, 0.690882), vec3(0.182413, 0.366184, 0.364647)), normal).x);\n        #endif\n    }\n    \n    //front suspension\n    vec2 s1 = box(ro, rd, centerDim(vec3(0.0, 0.208472, -0.718025), vec3(0.718633, 0.135897, 0.261572)));\n    if(accept(s1.x)){\n        vec3 n;\n        vec4 s2 = frontSuspension(ro, rd, s1, n);\n        if(accept(s2.x)){\n            d = min(d, s2.x);\n            normal = n;\n            ID = SUSPEN1ID;\n        }\n    }\n    \n    //back suspension\n    vec2 s2 = box(ro, rd, centerDim(vec3(0.0, 0.186288, 0.642109), 2.0*vec3(0.395562, 0.107907, 0.111553)));\n    if(accept(s2.x)){\n        vec3 n;\n        vec4 s3 = backSuspension(ro, rd, s2, n);\n        if(accept(s3.x)){\n            d = min(d, s3.x);\n            normal = n;\n            ID = SUSPEN2ID;\n        }\n    }\n    //pilot\n    #ifdef DRIVER\n    vec2 dr1 = box(ro, rd, centerDim(vec3(-0.001445, 0.349935, 0.107053), vec3(0.285502, 0.362948, 0.47058)));\n    if(accept(dr1.x)){\n        vec4 dr2 = pilot(ro, rd, dr1);\n        if(accept(dr2.x)){\n            d = min(d, dr2.x);\n            vec3 pos = ro + dr2.x * rd;\n            NORMAL(sdfPilot);\n            UV = vec2(0.0);\n            ID = DRIVERID;\n        }\n    }\n    #endif\n    \n    \n    //car body\n    float b1 = body(ro, rd, bb).x;\n    if(b1 != FALSE && b1 < d){\n        d = min(d, b1);\n        vec3 pos = ro + b1 * rd;\n        NORMAL(sdfBody);\n        ID = carID;\n        UV = vec2(pos.z*0.5+0.5, (atan(pos.x, pos.y) + PI)/2.0/PI);\n    }\n    \n    if(d == 1e10) return vec4(FALSE, carID, 0.0, 0.0);\n    return vec4(d, ID, UV);\n    \n    #else \n   return vec4(bb.x, ID, UV);\n    #endif\n    \n}\n/////////////////////////////////////////////////////////////////////////////////////////\nvec4 wheelTex(vec2 uv, float r){  //return vec4(col, specular)\n    vec2 uv2 = mod(uv, vec2(0.25, 0.25*0.125))*vec2(4.0, 32.0);\n    if (uv.x > 0.5) uv2.x = 1.0 - uv2.x;\n    vec3 col = vec3(uv2.xy, 0.0);\n    col = vec3(0.2);\n    float s = step(0.1, uv2.x - uv2.y);\n    s += step(0.1, -uv2.x + uv2.y);\n    s *= 0.5+0.5*step(0.01, abs(uv.x-0.5));\n    s *= 0.5+0.5*step(0.005, abs(uv.x-0.2));\n    s *= 0.5+0.5*step(0.005, abs(uv.x-0.7));\n    s *= 0.5+0.5*step(0.005, abs(uv.x-0.3));\n    s *= 0.5+0.5*step(0.005, abs(uv.x-0.8));\n    col = mix(vec3(0.1, 0.13, 0.14)*0.5, vec3(0.18, 0.18, 0.17), s);\n    col *= texture(iChannel1, uv).x*0.7+0.3;\n    \n    \n    r /= 0.5*0.366184;\n    col = mix(vec3(0.14, 0.12, 0.11), col, step(0.99, r));\n    col = mix(vec3(1.0, 0.96, 0.80), col, step(0.7, r));\n    col = mix(vec3(0.1, 0.08, 0.08), col, step(0.05, r));\n    \n    col *= 0.5+abs(uv.x - 0.5);\n    \n    s = 0.8*(1.0 - step(0.7, r));\n    s *= step(0.08, r);\n    s *= pow(texture(iChannel1, vec2(r, uv.y)).x, 0.3);\n    return vec4(col, s);\n}\n\nfloat inRect(vec2 v, float x1, float y1, float x2, float y2){ //up down\n    return (v.x < x1 && v.x > x2\n         && v.y < y1 && v.y > y2)? 1.0 : 0.0;\n}\n#define change if(d2 < d){d = d2;\nvec4 carTex(vec2 uv, vec3 pos){\n    #ifdef CARTEXTURE\n    float s = 0.0;\n    vec3 col = vec3(0.0);\n    vec2 uv2 = uv;\n    uv2.x += 0.4*texture(iChannel1, uv).x - 0.25;\n    \n    #define f(x) x*x*(3.0 - 2.0*x)\n    col = mix(vec3(0.73, 0.11, 0.12), vec3(0.9, 0.9, 0.9), f(min(1.0, uv2.x*2.0)));\n    col = mix(col, vec3(0.0, 0.2, 0.5), f(max(0.0, uv2.x*2.0-1.0)));\n    \n    vec3 p = pos; // main body\n    p.yz = mat2x2(0.9987, 0.0507,\n                 -0.0507, 0.9987) * p.yz;\n    p.y += 0.1*pow(max(-p.z, 0.0), 3.0);\n    float d = sdEllipsoid( p - vec3(0.0, 0.250172, 0.034988), vec3(0.214086, 0.167228, 1.03));\n    float d2;\n    //bottom plate\n    p = pos - vec3(0.0, 0.150917, -0.530452);\n    d2 = sdBox(p , vec3(0.170919, 0.032961, 0.121223)) - 0.02;\n    change col = vec3(0.1);}\n    \n    //front wing (down)\n    p = pos - vec3(0.003025, 0.133558, -0.895936);\n    p.yz = mat2x2(0.6691, 0.7431, -0.7431, 0.6691) * p.yz;\n    d2 = sdBox(p , vec3(0.22312, 0.003805, 0.035775));\n    change col *= vec3(1.5, 1.3, 1.7);}\n    //front wing (up)\n    p = pos - vec3(0.004898, 0.189705, -0.796952);\n    p.yz = mat2x2(0.9205, 0.3907, -0.3907, 0.9205) * p.yz;\n    d2 = sdBox(p , vec3(0.154266, 0.003941, 0.062824));\n    change col *= vec3(1.5, 1.3, 1.7);}\n    //antena\n    p = pos - vec3(0.091767, 0.39, -0.440064);\n    d2 = sdCylinder(p, vec2(0.003316, 0.042221));\n    change col = vec3(0.05);}\n    //middle bump\n    p = pos - vec3(0.0, 0.434555, 0.394036);\n    p.yz = mat2x2(0.9945, -0.1045, 0.1045, 0.9945) * p.yz;\n    d = min(d, sdEllipsoid(p , vec3(0.09712, 0.09712, 0.426178)));\n    //glass\n    p = pos - vec3(0.0, 0.323151, 0.000632);\n    d2 = sdEllipsoid(p , vec3(0.144777, 0.132625, 0.405275));\n    change col = vec3(0.06); s=0.4;}\n    //cokpit (void)\n    p = pos - vec3(-0.001684, 0.4563, 0.107312);\n    float c = sdBox(p, vec3(0.153123, 0.253123, 0.21701));\n    d = smax(d, -c, 0.05);\n    //side bump\n    vec3 ps = vec3(abs(pos.x), pos.y, pos.z);\n    p = ps - vec3(0.178125, 0.332702, 0.368919);\n    d = smin(d, sdEllipsoid(p , vec3(0.09712, 0.09712, 0.426178)), 0.03);\n    //air entry 1 (void)\n    p = ps - vec3(0.232716, 0.336058, 0.263102);\n    p.xz = mat2x2(0.9980, -0.0627, 0.0627, 0.9980) * p.xz;\n    d2 = -sdEllipsoid(p , vec3(0.048859, 0.065034, 0.327925));\n    if(d2 > d){d = d2; col*=1.0 - pos.z*2.0;}\n    //side air entry construction:\n    //big shape\n    p = ps - vec3(0.005926, 0.167606, -0.025842);\n    float bs = sdEllipsoid(p , vec3(0.414984, 1.0, 1.0));\n    bs = max(bs, -c);;\n    //top\n    bs = smax(bs, pos.y - 0.32 + max(0.0, 0.07/(1.0 + exp(10.0*(pos.z - 0.1)))), 0.03);\n    //bottom\n    bs = smax(bs, -pos.y + 0.1 + max(0.0, 0.3*(pos.z - 0.33)), 0.03);\n    //front\n    bs = smax(bs, -dot(ps - vec3(0.0, 0.0,-0.4), normalize(vec3(-0.5, -0.5, 1.0))), 0.01);\n    //air entry 2 void\n    p = ps - vec3(0.30883, 0.17531, -0.281175);\n    d2 = -sdBox(p, vec3(0.086429, 0.058429, 0.318638));\n    if(d2 > bs){bs = d2; col*=-0.6 - pos.z*8.0;}\n    d = smin(d, bs, 0.02);\n    \n    //top cover\n    p = pos.xzy - vec3(-0.0, 0.380554, 0.340222);\n    d2 = sdRhombus(p, 0.073637, 0.103637, 0.047325, 0.1);\n    change col=vec3(0.1);}\n    //engine top\n    p = ps  - vec3(0.090865, 0.430824, 0.585795);\n    p.xz = mat2x2(0.9997, 0.0209, -0.0209, 0.9997) * p.xz;\n    p.xy = mat2x2(0.8090, 0.5877, -0.5877, 0.8090) * p.xy;\n    p.zy = mat2x2(0.9822, 0.1873, -0.1873, 0.9822) * p.zy;\n    d2 = sdBox(p, vec3(0.040173, 0.022703, 0.133894)) - 0.002;\n    change col = vec3(0.1, 0.1, 0.15); s=0.5;}\n    //block under\n    p = pos - vec3(0.0, 0.156481, 0.518026);\n    d2 = sdBox(p, vec3(0.20718, 0.074986, 0.300785)) - 0.001;\n    change col = vec3(0.3);}\n    \n    //back cut\n    d = max(d, -dot(ps - vec3(0.0, 0.0, 0.529344), vec3(0.0, 0.85716, -0.5150)));\n    d = max(d, -dot(ps - vec3(0.0, 0.0, 0.89541), vec3(0.0, -0.1045, -0.9945)));\n    \n    //back under 1\n    p = ps - vec3(0.192716, 0.143408, 0.570004);\n    d2 = sdBox(p, vec3(0.00652, 0.067714, 0.25495)) - 0.001;\n    change col = vec3(0.2);}\n    d = smax(d, -dot(ps - vec3(0.0, 0.0, 0.598839), vec3(0.0, 0.8386, -0.5446)), 0.05);\n    //back under 2\n    p = ps - vec3(0.069967, 0.147173, 0.616744);\n    d2 = sdBox(p, vec3(0.007172, 0.078738, 0.25495)) - 0.001;\n    change col = vec3(0.2);}\n    d = smax(d, -dot(ps - vec3(0.0, 0.0, 0.118614), vec3(0.0, 0.9876, -0.1564)), 0.08);\n    \n    //back box\n    p = pos - vec3(0.0, 0.267777, 0.623707);\n    d2 = sdBox(p, vec3(0.137705, 0.022871, 0.24837)) - 0.001;\n    change col *= 3.0;} \n    \n    //back smoke out\n    p = pos - vec3(0.0, 0.389587, 0.896463);\n    p.yz = mat2x2(0.9848, -0.1736, 0.1736, 0.9848) * p.yz;\n    d = smax(d, -sdBox(p, vec3(0.091775, 0.086516, 0.094237)), 0.06);\n    \n    p = ps - vec3(0.042621, 0.35046, 0.787099);\n    d2 = sdBox(p, vec3(0.031889, 0.011231, 0.072799)) - 0.005;\n    change col = vec3(0.1, 0.1, 0.15); s = 1.0;}\n    d = max(d, -sdBox(p, vec3(0.031889, 0.011231, 0.092799)));\n    \n    //back rombus top\n    p = ps.xzy - vec3(0.01, 0.727141, 0.390539);\n    d2 = sdRhombus(p, 0.031889, 0.011231, 0.092799, 0.001);\n    change col*=0.2;}\n    //back pipe\n    p = ps;\n    d2 = sdCapsule(p, vec3(0.16925, 0.27345, 0.905582), vec3(-0.16925, 0.27345, 0.905582), 0.01);\n    change col = vec3(0.03); s=1.0;}\n    d2 = sdCapsule(p, vec3(0.211834, 0.294284, 0.808042), vec3(0.16925, 0.27345, 0.905582), 0.01);\n    change col = vec3(0.03); s=1.0;}\n    //back wind\n    p = ps - vec3(0.002531, 0.469511, 0.871087);\n    p.yz = mat2x2(0.9923, 0.1236, -0.1236, 0.9923) * p.yz;\n    \n    float w2 = sdBox(p, vec3(0.20705, 0.00505, 0.082297));\n    p +=vec3(0.0, 0.01, 0.02);\n    w2 = smin(w2, sdBox(p, vec3(0.15705, 0.00505, 0.052297)), 0.05);\n    \n    p = ps - vec3(0.264567, 0.429921, 0.872511);\n    p.zy = mat2x2(0.9702, 0.0697, -0.0697, 0.9702) * p.zy;\n    p.xy = mat2x2(0.6427, -0.7660, 0.7660, 0.6427) * p.xy;\n    w2 = smin(w2, sdBox(p, vec3(0.004028, 0.060656, 0.077419)), 0.05);\n    d = min(d, w2);\n    //baxk wind support\n    p = ps - vec3(0.177204, 0.361375, 0.858586);\n    p.zy = mat2x2(0.9205, 0.3907, -0.3907, 0.9205) * p.zy;\n    d2 = sdBox(p, vec3(0.003402, 0.125143, 0.025331)), 0.02;\n    change col = vec3(0.4);}\n    \n    \n    //dirt\n    pos.y -= pow(abs(pos.z*0.5), 2.0);\n    float intens = clamp((0.25-pos.y)*10.0, 0.0, 1.0);\n    col *= mix(vec3(1.0), texture(iChannel1, uv*3.0).rgb, intens);\n    \n    col = max(col, vec3(0.0));\n    return vec4(col, s);\n    #else\n    return vec4(1.0, 1.0, 1.0, 0.0);\n    #endif\n}\n\nvec4 pilotTex(vec3 pos){\n    float s = 0.0;\n    vec3 col = vec3(0.1, 0.1, 0.1);\n    col.gb *= min(abs(pos.z)*10.0, 1.0);\n    \n    vec3 p = pos;\n    float b = sdSphere((p - vec3(0.0, 0.4481, 0.228917))* vec3(1.0, 1.0, 0.3), 0.071918);\n    if(b>0.01)return vec4(col, s);\n    //helmet\n    float d = sdSphere(p - vec3(0.0, 0.4481, 0.228917), 0.071918);\n    d = smin(d, sdSphere(p - vec3(0.0, 0.376305, 0.188372), 0.033391), 0.1);\n    d = max(d, -dot(p - vec3(0.0, 0.319, 0.0), vec3(0.0, 0.9743, -0.2249)));\n    \n    float c = abs(pos.x);\n    col = vec3(0.9);\n    col = mix(vec3(1.0, 0.0, 0.0), col, step(0.01, c));\n    col = mix(vec3(0.0, 0.0, 1.0), col, step(0.005, abs(c-0.02)));\n    //glass helmet\n    p -= vec3(0.0, 0.431697, 0.174894);\n    p.yz = mat2x2(0.9743, 0.2249, -0.2249, 0.9743) * p.yz;\n    float d2 = sdBox(p, vec3(0.074463, 0.028347, 0.065994));\n    d2 = max(d2, pos.z - 0.226);\n    d2 = max(d2, sdSphere(pos - vec3(0.0, 0.416611, 0.217582), 0.085037)); \n    change col = vec3(0.0, 0.7, 0.9); s=0.7;}\n    \n    //helmet box\n    p = pos - vec3(0.0, 0.474635, 0.172322);\n    p.yz = mat2x2(0.7986, 0.6018, -0.6018, 0.7986) * p.yz;\n    d2 = sdBox(p, vec3(0.018936));\n    change col = vec3(0.5); s=0.0;}\n    \n    return vec4(col, s);\n}\n\nvec4 color(vec4 data, vec3 ro, vec3 rd){\n    float d = data.x;\n    if(d == FALSE) return texture(iChannel0, rd);\n    //col = vec3(1.0/d);\n    if(data.y == carID)\n        return carTex(data.zw, ro + d*rd);\n    if(data.y >= WHEELID && data.y < WHEELID+1.0)\n        return wheelTex(data.zw, data.y - WHEELID);\n    if(data.y == SUSPEN1ID || data.y == SUSPEN2ID)\n        return 0.2*vec4(0.19, 0.32, 0.4, 4.0);\n    if(data.y == DRIVERID)\n        return pilotTex(ro + d*rd);\n    \n    return vec4(1.0, 1.0, 1.0, 0.0);\n}\nvec3 getScene(vec3 ro, vec3 rd){\n    vec3 normal;\n    vec4 data = car(ro, rd, normal);\n    float d = data.x;\n    vec4 col = color(data, ro, rd);\n    if(d == FALSE) return col.rgb;\n    //return normal*0.5 + 0.5;\n    \n    //shadow and lights\n    vec3 n;\n    vec3 accu = vec3(0.0);\n    accu += col.rgb * vec3(0.03, 0.07, 0.1);\n    float dotSunNorm = dot(normal, sunPos);\n    #ifdef SHADOW\n    vec4 dataShadow = car(ro + d*rd + 0.01*normal, sunPos, n);\n    if (dataShadow.x == FALSE){\n        accu += col.rgb * max(0.0, dotSunNorm);\n        accu += col.w *  pow(max(0., dotSunNorm), 50.0);\n    }\n    #else\n    accu += col.rgb * max(0.0, dotSunNorm);\n    accu += col.w *  pow(max(0., dotSunNorm), 50.0);\n    #endif\n    \n    #ifdef REFLECTION\n    if(col.w > 0.01){\n        accu *= 1.0 - col.w;\n        vec3 p = ro + d*rd + 0.01*normal;\n        vec3 rd2 = reflect(rd, normal);\n        vec4 reflData = car(p, rd2, n);\n        vec3 col3 = color(reflData, p, rd2).rgb;\n        if(reflData.x != FALSE) col3 *= max(0.0, dot(n, sunPos));\n        accu += col.w * col3;\n       \n    }\n    #endif\n    return accu;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //wheel phase\n    ti = iTime*12.0;\n    sunPos = normalize(vec3(cos(iTime*0.5+1.5), 0.5, sin(iTime*0.5+1.5)));\n    //end\n\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv*=0.7;\n    \n    float t = iTime * 0.5;\n    vec3 camPos = vec3(cos(t), 0.5, sin(t))*1.7;\n    //vec3 camPos = vec3(cos(t), 0.9, sin(t))*1.2;\n    \n    \n    vec3 dir0 = normalize(-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    vec3 col = getScene(camPos, rd);\n   \n    col = 1.0 - exp(-col);\n    col = pow(col, vec3(1.0/2.0));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//constants and settings////////////////////////////////////////////////////////////////\nvec3 sunPos = normalize(vec3(0.2, 0.5, 1.0));\nfloat ti = 0.0;   //wheels rotation phase\n\n#define SHADOW\n#define REFLECTION\n\n#define CAR\n#define WHEELS\n#define DETAILCAR\n#define CARTEXTURE\n#define DRIVER\n\n\n#define PI 3.14159\n#define FALSE -1.0\n#define accept(a) a != FALSE && a < d \n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//from https://www.shadertoy.com/view/WlSSzK\n#define Rayleigh 1.\n#define Mie 1.\n#define RayleighAtt 1.\n#define MieAtt 1.2\n#define DistanceAtt 1e-5\n\n#define skyInt 1.4\nfloat g = -0.93;\nfloat gS = -0.43;\n\nvec3 _betaR = vec3(1.95e-2, 1.1e-1, 2.94e-1); \nvec3 _betaM = vec3(4e-2, 4e-2, 4e-2);\n\n\nvec3 calcAtmosphericScattering( float sR, float sM, out vec3 extinction, float cosine, float g1)\n{\n    extinction = exp(-(_betaR * sR + _betaM * sM));\n\n    // scattering phase\n    float g2 = g1 * g1;\n    float fcos2 = cosine * cosine;\n    float miePhase = Mie * pow(1. + g2 + 2. * g1 * cosine, -1.5) * (1. - g2) / (2. + g2);\n    //g = 0;\n    float rayleighPhase = Rayleigh;\n\n    vec3 inScatter = (1. + fcos2) * vec3(rayleighPhase + _betaM / _betaR * miePhase);\n    \n    return inScatter;\n}\n\nfloat fbm(vec2 x, int detail){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < detail; i++){\n        float n = texture(iChannel0, x).x;\n        a += b*n;\n        t += b;\n        b *= 0.7;\n        x *= 2.0; \n    \n    }\n    return a/t;\n}\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    \n    // Ray direction as color\n    vec3 col; \n    sunPos = normalize(vec3(cos(iTime*0.5+1.5), 0.5, sin(iTime*0.5+1.5)));\n    \n    float sundot = clamp(dot(rayDir,sunPos),0.0,1.0);\n    vec3 extinction;\n\n    // optical depth -> zenithAngle\n    float zenithAngle = max(0., rayDir.y); //abs( rd.y);\n    float sR = RayleighAtt / zenithAngle ;\n    float sM = MieAtt / zenithAngle ;\n    \n    vec3 inScatter = calcAtmosphericScattering(sR, sM, extinction, sundot, g);\n    vec3 skyCol = inScatter*(1.0-extinction);\n    \n    // sky\t\n    col = skyCol;// * vec3(1.6,1.4,1.0);\n            \n    // sun\n    col += 0.47*vec3(1.6,1.4,1.0)*pow( sundot, 350.0 ) * extinction;\n    // sun haze\n    col += 0.4*vec3(0.8,0.9,1.0)*pow( sundot, 2.0 ) * extinction;\n\n    // clouds\n    vec3 rd = rayDir;\n        if(rd.y > 0.01){\n        vec2 ro = 0.3 * iTime * vec2(0.7, 1.0);\n        vec2 sc = ro + rd.xz*(10.0)/rd.y;\n        col += 2. * vec3(1.0,0.95,1.0) * extinction * smoothstep(0.5,0.8,fbm(0.0005*sc, 5) );\n    }\n\n    // Output to cubemap\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}