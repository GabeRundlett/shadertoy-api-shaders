{
    "Shader": {
        "info": {
            "date": "1508216789",
            "description": "All your stellations are belong to us.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lScWz",
            "likes": 17,
            "name": "kepler poinsot",
            "published": 3,
            "tags": [
                "raymarching",
                "geometry",
                "stellation"
            ],
            "usePreview": 0,
            "username": "russ",
            "viewed": 796
        },
        "renderpass": [
            {
                "code": "//Finally figured out how to distance estimate these bad boys :-)\n//Code is modified from Knighty's shader https://www.shadertoy.com/view/XlX3zB\n//using the 'fold and cut' method aka Wythoff construction.\n\n//It still feels a little bit 'cheaty' : I'm using a separate code path for each of the \n//shapes, and creating redundant mirrors as compositions of the primary 3 mirrors, \n//in order to take the primary triangle to non-adjacent triangles, creating the stellation.\n//I had to work out the construction of these secondary mirrors by hand for each shape.\n//All distance estimation is then done in the primary triangle as usual.\n//I'm sure there must be a simpler, more elegant function that can create all these shapes\n//given different parameters, but it'll take a smarter guy than me to find it.\n\n//------------------------------------------------------------------------------------\n#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nfloat SRadius, VRadius, shape, shapeMix;\n\nvec3 nc, nd, ne , nf, p, pbc, pca;\n\nvoid init() {\n\t\n    float cospin=cos(PI/ 5.), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);\n\tpbc=vec3(scospin,0.,0.5);\n\tpca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc);\tpca=normalize(pca);\n    \n    //shape blending\n    float modTime = mod(iTime, 32.);\n    shape = floor(modTime / 8.);\n    modTime -= shape * 8.; \n    modTime = min(modTime, 8.-modTime);\n    shapeMix = smoothstep(0.,1., modTime - .1 );\n    float radMix = smoothstep(0.,1., modTime - 1.2 );\n    SRadius = .02*radMix;\n    VRadius = .03*radMix;\n    \n    //Extra mirrors for non-adjacent vertices\n    nd = reflect(vec3(0,1,0),nc);\n    ne = reflect(vec3(1,0,0), nd);\n    nd.x *= -1.;\n    nf = nc;\n    nf.xy *= -1.;\n    nf = reflect(nf,nc);\n    nf.y *= -1.;\n}\n\nvec3 fold(vec3 pos) {\n\tfor(int i=0;i<5 /*Type*/;i++){\n\t\tpos.xy=abs(pos.xy);//fold about xz and yz planes\n\t\tpos-=2.*min(0.,dot(pos,nc))*nc;//fold about nc plane\n\t}\n\treturn pos;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n//gad\nfloat D2Edge(vec3 pos) {\n\tpos-=p;\n\treturn length(pos-min(0.,pos.x)*vec3(1.,0.,0.))-SRadius;\n}\n\n//sissid / gike\nfloat D2Edge2(vec3 pos){\n    vec3 v = p- nd * (p.x / nd.x);\n    return min(sdCapsule(pos, p, v, SRadius),\n               sdCapsule(pos, v, vec3(0,0,v.z), SRadius));\n\n}\n\n//gissid\nfloat D2Edge3(vec3 pos){\n    vec3 v = p - nf * (p.y / nf.y);\n    return min(sdCapsule(pos, p, v, SRadius),\n               sdCapsule(pos, v, vec3(0,0,v.z), SRadius));                  \n}\n\nfloat D2Vertices(vec3 pos) {\n\treturn length(pos-p)-VRadius;\n}\n\n//sissid\nfloat D2Face(vec3 pos){\n    pos -= p;\n    vec3 n = normalize(cross(nd, vec3(0,1,0)));\n    float d = dot(pos, n);\n    d = max (d, dot(pos, pbc));\n    return d;\n}\n\n//gissid\nfloat D2Face2(vec3 pos){\n    pos -= p;\n    vec3 n = normalize(cross(nf, -vec3(1,0,0)));\n    float d = dot(pos, n);\n    d = max (d, dot(pos, pca));\n    return d;\n}\n\n//gad\nfloat D2Face3(vec3 pos){\n    pos -= p;\n    vec3 n = normalize(cross(-vec3(1,0,0), ne));\n    float d = dot(pos, n);\n    return d;\n}\n\n//gike - a bit more complex since we have 2 planes in primary triangle\nfloat D2Face4(vec3 pos){\n    pos -= p;\n    vec3 v = p-nd * (p.x/nd.x);\n    vec3 n = normalize(cross(nd,reflect(nd,vec3(nc.x,-nc.y,nc.z))));\n    float d = dot(pos, n);\n    pos += p - v;\n    n = normalize(vec3(p.z+v.z, 0, p.x));\n    d = min (d, dot(pos,n));\n    return d;\n}\n\nfloat Gad(vec3 pos){\n    p = pbc;\n    float d=100.;\n    d=min(d,D2Edge(pos));\n\td=min(d,D2Face3(pos));\n    d=min(d,D2Vertices(pos));\n    return d;\n}\n\nfloat Gike(vec3 pos){\n    p = pbc;\n    float d = 100.;\n    d=min(d,D2Edge2(pos));\n\td=min(d,D2Face4(pos));\n    d=min(d,D2Vertices(pos));\n    return d;\n}\n\nfloat Sissid(vec3 pos){\n    p = pbc;\n    float d = 100.;\n    d=min(d,D2Edge2(pos));\n\td=min(d,D2Face(pos));\n    d=min(d,D2Vertices(pos));\n    return d;\n}\n\nfloat Gissid(vec3 pos){\n    p = pca;\n    float d = 100.;\n    d=min(d,D2Edge3(pos));\n\td=min(d,D2Face2(pos));\n    d=min(d,D2Vertices(pos));\n    return d;\n}\n\nfloat Sphere(vec3 pos){\n    return length(pos) -.75;\n}\n\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 pos)\n{\n    float s = Sphere(pos);\n    pos = fold(pos);\n    float poly;\n    if(shape<1.) poly = Sissid(pos);\n    else if(shape<2.) poly = Gad(pos);\n    else if(shape<3.) poly = Gike(pos);\n    else poly = Gissid(pos);\n\treturn mix( s, poly, shapeMix);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n   \tvec3 rd = normalize(vec3(p, -1.4));\n\tvec3 ro = vec3(0.0, 0.0, 1.8);\n    ro.xz = rotate(ro.xz, -.47*iTime);\n    rd.xz = rotate(rd.xz, -.47*iTime);\n    ro.yz = rotate(ro.yz, -.83*iTime);\n    rd.yz = rotate(rd.yz, -.83*iTime);\n    ro.xy = rotate(ro.xy, -1.19*iTime);\n    rd.xy = rotate(rd.xy, -1.19*iTime);\n\n    init();\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n        rd = reflect(rd,n);\n\t}\n\n    rd.xy = rotate(rd.xy, 1.19*iTime);\n    rd.yz = rotate(rd.yz, .83*iTime);\n    vec3 col = texture(iChannel1, rd).rgb;\n   \tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}