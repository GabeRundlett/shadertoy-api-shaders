{
    "Shader": {
        "info": {
            "date": "1598782361",
            "description": "License CC0: Smooth kaleidoscope\nKaleidoscope with smoothing\nI thought this might be useful to someone else so I shared this ugly barebones shared\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wtSBWh",
            "likes": 3,
            "name": "Smooth kaleidoscope",
            "published": 3,
            "tags": [
                "kaleidoscope",
                "sabs"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "// License CC0: Smooth kaleidoscope\n// Kaleidoscope effects are cool but while the mirror effect ensure the curves are\n//  continuous the derivates are not. \n//  SABS has been a great tool whenever I needed an abs function that gave the illusion\n//   continuous derivates.\n//  I patched SABS into a kaleidoscope effect to get a smooth kaleidoscopic effect.\n\n// I thought this might be useful to someone else so I shared this ugly barebones shared\n\n#define TIME       iTime\n#define RESOLUTION iResolution\n\n#define PI         3.141592654\n#define TAU        (2.0*PI)\n\n// SABS by ollj, this has turned out extremely useful on many occassions\n//  https://www.shadertoy.com/view/Ws2SDK\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\n// http://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat df(vec2 p) {\n  const float rep = 6.0;\n\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  \n  // mod the angular component to get an kaleidoscope effect\n  // modMirror ensure curves are continuous\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  // Apply smoothing on right side of screen to make derivate of curves continuous\n  //   Left side non-smoothed for comparison\n  if (p.x > 0.0) {\n    float sa = PI/rep - SABS(PI/rep - abs(hpp.y), 0.25);\n    hpp.y = sign(hpp.y)*sa;\n  }\n\n  hp = toRect(hpp);\n  hp.x -= 0.5;\n  \n  rot(hp, TIME);\n  float d1 = box(hp, 0.25*vec2(0.5, 0.75));\n\n  float d = d1;\n\n  d = abs(d) - 0.01;\n  \n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  float d = df(p);\n  \n  vec3 col = vec3(0.0);\n  float aa = 1.0/RESOLUTION.y;\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  col += vec3(0.0, 0.5, 0.5)*(0.5 + 0.5*sin(200.0*d));\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}