{
    "Shader": {
        "info": {
            "date": "1626156020",
            "description": "Using a 2D regular grid as acceleration structure for raytracing (an infinite amount of) cylinders. I trace across the 2D grid and then intersect the cylinder inside each cell. When the first intersection is found, the tracing can stop.",
            "flags": 33,
            "hasliked": 0,
            "id": "NlXSzf",
            "likes": 4,
            "name": "Grid of Cylinders reactive",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raytracing",
                "grid",
                "cylinder",
                "regulargrid",
                "vr"
            ],
            "usePreview": 0,
            "username": "firebreathz",
            "viewed": 511
        },
        "renderpass": [
            {
                "code": "// Fork of \"Grid of Cylinders\" by iq. https://shadertoy.com/view/4dSGW1\n// 2021-07-13 05:56:57\n\n// Created by inigo quilez - iq/2013\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a techer, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// Try 4, 15, 30 samples if yo have a powerful machine\n\n#if HW_PERFORMANCE==30\n#define VIS_SAMPLES 0\n#else\n#define VIS_SAMPLES 1\n#endif\n\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\n\nfloat gAnimTime;\nfloat map( vec2 p ) \n{\n\tfloat f = textureLod( iChannel0, p/iChannelResolution[0].xy, 0.0 ).x;\n\t\n\tf *= sqrt( textureLod( iChannel2, (0.9*p + 20.0*gAnimTime)/2056.0, 0.0 ).x );\n\treturn 200.0*f;\n}\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 10.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    // traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\n\t\tfloat ma = map(pos);\n\t\t\n        // intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+1.25, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.9;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            // cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            // cap\t\t\t\n\t\t\ts = (ma - ro.y)/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+1.7*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 10.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\n\treturn res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 9.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat res = 10.0;\n\t\n    // first step we check noching\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\t\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<6; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\t\n        // test capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.009;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))/a;\n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\treturn res;\n}\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 20.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p += 100.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 15.0 + 4.0*sin(0.05*t);\n\t\n\t// collision\n\tfloat h;\n\th  = map( p+vec2(-1.0, 0.0) );\n\th += map( p+vec2( 1.0, 0.0) );\n\th += map( p+vec2( 0.0, 1.0) );\n\th += map( p+vec2( 0.0,-1.0) );\n\th /= 4.0;\n\th += 5.0;\n\ty = max( y, h );\n\n\treturn vec3( p.x, y, p.y );\n}\n\nvec4 texcyl( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, vec2(p.y,0.5+0.5*atan(n.x,n.z)/3.14) );\n\tvec4 y = texture( sam, p.xz );\n\treturn mix( x, y, abs(n.y) );\n}\n\nvec3 desat( in vec3 col, float a )\n{\n    return mix( col, vec3(dot(col,vec3(0.333))), a );\n}\n\nvec3 lig = normalize(vec3(-0.7,0.25,0.6));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n        // background color\t\n\t\tfloat sun = clamp( dot( rd, lig ), 0.0, 1.0 );\n\n\t\tvec3 bgcol = vec3(0.9,0.9,0.8) + 0.3*pow(sun,4.0)*vec3(1.0,1.0,0.0);\n\n        // raytrace\n        vec3 col = bgcol;\n\t\tvec4 res = castRay( ro, rd );\n        vec2 vos = res.zw;\n        float t = res.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + rd*t;\n\t\t\tfloat id  = hash1( vos );\n\t\t\tvec3  nor = calcNormal( fract(pos)-0.5, res.y );\n\t\t\tfloat h = map(vos);\n\n            // material color\t\t\t\n\t\t\tvec3 mate1 = 0.5 + 0.45*sin( 3.14*id + 0.8 + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate2 = 0.5 + 0.45*sin( 6.28*id + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate = mix( mate1, mate2, smoothstep( 9.0, 11.0, h) );\n\t\t\t\n\t\t\tvec3 uvw = pos - vec3(0.0,h,0.0);\n\t\t\tvec3 tex = texcyl( iChannel3, 0.2*uvw + 13.1*hash1(id), nor ).xyz;\n\t\t\tmate *= 0.2+4.0*pow( desat(tex,0.3), vec3(2.0) );\n            mate *= 1.5*sqrt(texture( iChannel0, pos.xz/iChannelResolution[0].xy ).xyz);\n            mate *= 0.02 + 0.98*smoothstep( 0.1,0.11, hash1(id) );\t\n\t\t\t\n            // material cheap/wrong bump\t\t\t \n            vec3 bn = -1.0 + 2.0*texcyl( iChannel1, 0.2*uvw*vec3(1.0,0.2,1.0) + 13.1*hash1(id), nor ).xyz;\n            //nor = normalize(nor + 0.45*bn*(1.0-0.5*nor.y) );\n\t\t\t\n\t\t\t// procedural occlusion\n\t\t\tfloat occ = nor.y*0.75;\n\t\t\tocc += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n\t\t\tocc += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n\t\t\tocc = 0.2 + 0.8*occ;\n\t\t\tocc *= pow( clamp((0.1+pos.y)/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n\t\t\tocc = occ*0.5+0.5*occ*occ;\n\t\t\tfloat rim = pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),5.0 );\n \n            //-------------\n            // lighitng\n            //-------------\n\t\t\tfloat amb = 1.0;\n            //-------------\n\t\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z)) ), 0.0, 1.0 ) * clamp(1.0-pos.y/20.0,0.0,1.0);;\n            //-------------\n\t\t\tfloat sha = 0.0;\n\t\t\tfloat dif = dot( nor, lig );\n\t\t\tif( dif<0.0 ) dif=0.0; else sha = castShadowRay( pos, lig );\n            float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0 ),3.0 );\n            //-------------\n\t\t\tvec3 lin  = 3.00*vec3(1.0,1.0,1.0)*0.7*sqrt(dif)*sha;\n\t\t\t     lin += 0.40*vec3(0.4,1.0,1.7)*amb*occ;\n\t\t\t     lin += 0.60*vec3(0.8,0.5,0.3)*bac*occ;\n\t\t\t\n\t\t\tcol = mate * lin + tex.x*1.5*vec3(1.0,1.0,1.0)*(0.3+0.7*rim)*spe*dif*sha;\n\n            // tone mapping\t\t\t\n\t\t\tcol *= 1.1 + 0.5*dot( rd, lig );\n\n            // fog\n            float ff = 1.0 - smoothstep( 0.0, 1.0, pow(t/160.0,1.8) );\n\t\t\tcol = mix( col, bgcol, 1.0-ff );\n\t\t}\n\t\tcol += 0.2*pow(sun,8.0)*vec3(1.0,0.7,0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n    gAnimTime = iTime;\n    \n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 4.0*iTime + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n\t\t#if VIS_SAMPLES>3\n        float time = 4.0*(iTime + 1.0*(0.4/24.0)*rr.w) + 50.0*mo.x;\n\t\t#else\n        float time = 4.0*(iTime) + 50.0*mo.x;\n\t\t#endif\n    #endif\t\n\n\t\t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time+5.0 ); ta.y = ro.y - 5.5;\n        float cr = 0.2*cos(0.1*time*0.5);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        // dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 17.0;\n        ro += (uu*(-1.0+2.0*rr.y) + vv*(-1.0+2.0*rr.w))*0.035;\n        rd = normalize( fp - ro );\n        #endif\n\n\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\ttot /= float(VIS_SAMPLES);\n\t\n\n\t// gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n\t// vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}\n    \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 cam = cameraPath( iTime );\n\n    gAnimTime = iTime*0.2;\n\n    vec3 ro = fragRayOri + cam + vec3(0.0,-2.0,0.0);\n    vec3 rd = fragRayDir*vec3(-1.0,1.0,-1.0);\n    vec3 col = render( ro, rd );\n\n    // gamma\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.44) );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy - vec2(0.15);\n    vec4 col = vec4(0.);//texture(iChannel0, p / iResolution.xy);\n    \n    float thickness = 0.003;\n    for(float i = 1.; i < 2.; i += 0.1){\n    \n    //float i = 1.3;\n    float j = -i/6.;\n        float gx = texture(iChannel0, uv.xy/i+vec2( thickness, 0.) - vec2(j)).x\n    - texture(iChannel0, uv.xy/i-vec2( thickness, 0.)- vec2(j)).x ;\n    \n    float gy = texture(iChannel0, uv.xy/i+vec2(0.,  thickness)- vec2(j)).x \n    - texture(iChannel0, uv.xy/i-vec2(0.,  thickness)- vec2(j)).x;\n\n    \n\t// hack: use g^2 to conceal noise in the video\n    float g = gx*gx + gy*gy;\n    \n    \n    col += vec4(vec3(g/8.,g/3.,g/2.)*10., 1.0);\n    col = clamp(col,0.,1.);\n    }\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}