{
    "Shader": {
        "info": {
            "date": "1548293988",
            "description": "More like the last one ([url]https://www.shadertoy.com/view/lsBSWK[/url]), but less boxes and therefore a bit faster. No global illumination or pathtracing, just good old direct illumination.",
            "flags": 32,
            "hasliked": 0,
            "id": "4tKBWy",
            "likes": 48,
            "name": "Boxes traced",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raytracing",
                "bvh",
                "boxes"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 4565
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2019 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // source\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n\n    // vignete     \n\tvec2 q = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n    // output\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ANIMATE\n\n//=====================================================\n\n#define ZERO min(0,iFrame)\n\nvec2  hash2( float n ) { return fract(sin(vec2(n,n+3.0))*vec2(43758.5453123,22578.1459123)); }\nfloat hash2( vec2 x )  { return fract(sin(dot(x,vec2(12.353,31.71))*43758.5453123)); }\n\nvec3 ihash3( uint n )\n{\n    uvec3 x = uvec3(n,n*7U+1U,n*13U+31U);\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    return vec3(x>>8)*(1.0/float(0x00ffffffU));\n}\n\n//==========================================\n\nstruct Box\n{\n\tvec3 cen;\n    vec3 rad;\n};\n\nvec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 ird, in Box box, out vec3 nor ) \n{\n    vec3 n = ird*(box.cen-ro);\n    vec3 k = abs(ird)*box.rad;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\tnor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n\treturn vec2( tN, tF );\n}\n\nbool boxIntersectAny( in vec3 ro, in vec3 rd, in vec3 ird, in Box box ) \n{\n    vec3 n = ird*(box.cen-ro);\n    vec3 k = abs(ird)*box.rad;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\treturn tN<tF && tF>0.0;\n}\n\n\n//=====================================================\n\nstruct Data\n{\n\tBox  box;\n    uint id;\n};\n\nData stack[14];\nint stPtr;\n\nvoid stack_reset(void) { stPtr=-1; }\nbool stack_is_empty(void) { return stPtr==-1; }\nData stack_pop( void ) { return stack[stPtr--]; }\nvoid stack_push( in Data s ) { stack[++stPtr] = s; }\n\nData generate( Data x, in uint ch )\n{\n    vec3 ra = ihash3( x.id*113U + ch*3U );\n    vec3 rb = ihash3( x.id*114U + ch*11U );\n    vec3 nr = x.box.rad*(0.5+0.4*rb);\n    vec3 di = -1.0+2.0*ra.xyz;\n    \n#ifdef ANIMATE\n    float sc = (x.id>=(1U<<10U)) ? 0.2+0.8*smoothstep(-0.98,-0.9,cos( float(x.id)*0.005 + iTime*0.5 )) : 1.0;\n    return Data( Box(x.box.cen+(x.box.rad-nr)*di, nr*sc), x.id*2U+ch );\n#else    \n    return Data( Box(x.box.cen+(x.box.rad-nr)*di, nr), x.id*2U+ch );\n#endif    \n}\n\nconst uint lth = (1U<<11U);\nconst vec3 ibox = vec3(4.0,2.0,4.0);\n\nvec4 cityIntersect( in vec3 ro, in vec3 rd, float tmax, out uint oID)\n{\n    vec3 ird = 1.0/rd;\n    vec4 res = vec4(-1.0);\n    \n    stack_reset();\n\n    // start with the root\n    Data x = Data( Box(vec3(0.0), ibox), 1U );\n    \n\tfor( int i=ZERO; i<400; i++ )\n\t{\n        // intersect node\n        vec3 nor;\n        vec2 tmp = boxIntersect( ro, rd, ird, x.box, nor );\n        if( tmp.y>0.0 && tmp.x<tmax )\n        {\n            // if leaf\n            if( x.id>=lth )\n            {\n                tmax = tmp.x;\n                res = vec4( tmp.x, nor );\n                oID = x.id;\n\n                // pop next node from the stach\n                if( stack_is_empty() ) break;\n                x = stack_pop();\n            }\n            // else, generate two children\n            else\n            {\n                stack_push( generate(x,0U) ); // push one on the stack\n                        x = generate(x,1U);   // and start traversing the other\n            }\n        }\n        // pop next node from the stack\n        else\n        {\n            if( stack_is_empty() ) break;\n            x = stack_pop();\n        }\n\t}\n\n    return res;\n}\n\nbool cityIntersectAny( in vec3 ro, in vec3 rd, in vec3 ird )\n{\n    bool res = false;\n\n    // start with the root\n    Data x = Data( Box(vec3(0.0), ibox), 1U );\n\n    stack_reset();\n\n    for( int i=ZERO; i<350; i++ )\n\t{\n        // intersect node\n        if( boxIntersectAny( ro, rd, ird, x.box ) )\n        {\n            // if leaf\n            if( x.id>=lth )\n            {\n                res = true;\n                break;\n            }\n            // else, generate two children\n            else\n            {\n                stack_push( generate(x,0U) ); // push one on the stack\n                        x = generate(x,1U);   // and start traversing the other\n            }\n        }\n        // pop next node from the stack\n        else\n        {\n            if( stack_is_empty() ) break;\n            x = stack_pop();\n        }\n\t}\n\n    return res;\n}\n\n//-----------------------------------------------------------------------------------------\n\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    vec2 uv = hash2( seed);\n\n    // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * uv.y;\n    float u = 2.0*uv.x - 1.0;\n    return /*normalize*/( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 off = ihash3(uint(iFrame)).xy - 0.5;\n    vec2 p = (2.0*(fragCoord+off)-iResolution.xy)/iResolution.y;\n\n    float seed = texelFetch( iChannel2, ivec2(fragCoord+off*1024.0)&255, 0 ).x;\n\n    float an = 0.5 + 0.01*iTime;\n\n    float cr = 0.2*sin(-0.05*an);\n\tvec3  ta = vec3(0.4,-0.3,1.10);\n\tvec3  ro = ta + vec3( 2.5*cos(an), 0.8, 2.5*sin(an) );\n    float fl = 3.0;\n\n    \n\t// camera\n    mat3 cam = setCamera( ro, ta, cr );\n    vec3 rd = normalize( cam * vec3(p,-fl) );\n\t\n    // box animation\n\tvec4 sph = vec4(0.0,0.0,0.0, 1.0) ;\n\n\n    vec3 col = vec3(0.07+0.04*rd.y);\n    float tmin = 1e10;\n    \n    \n    vec3 pos, nor;\n\n    // intersect\n    {\n    uint id = 0U;\n    vec4 res = cityIntersect( ro, rd, 100.0, id );\n    if( res.x>0.0 && res.x<tmin )\n    {\n        tmin = res.x;\n        pos = ro + tmin*rd;\n        nor = res.yzw;\n\t\tcol = abs(nor.x)*texture( iChannel1, 2.0*pos.yz ).xyz + \n              abs(nor.y)*texture( iChannel1, 2.0*pos.zx ).xyz + \n              abs(nor.z)*texture( iChannel1, 2.0*pos.xy ).xyz;\n\n        col *= 0.5;\n        col *= 0.5 + 0.4*sin(float(id)*0.005+vec3(0.0,0.5,1.0))\n                   + 0.1*sin(float(id)+vec3(0.0,0.5,1.0));\n        col *= 0.8 + 0.7*sin(float(id+2U));\n\t}\n    }\n\n    // lighting\n    if( tmin<1e9 )\n    {\n\t\tvec4 kk;        \n        uint kk2;\n\t\tvec3 light1 = normalize( vec3(-0.8,0.7,0.5) );\n        float dif = clamp(dot(nor,light1),0.0,1.0);\n        if( dif>0.001 )\n        dif *= (cityIntersectAny( pos+nor*0.001, light1, 1.0/light1 ) ? 0.0 : 1.0 );\n        \n        float occ = 0.0;\n\t\tfor( int j=ZERO; j<4; j++ )\n\t\t{\n            float s = seed + float(j) + float(iFrame)*13.1;\n            vec3 rr = cosineDirection( s, nor);\n            if( rr.y>0.0 )\n            {\n            vec3 irr = 1.0/rr;\n\t\t\tocc += (cityIntersectAny( pos+nor*0.001, rr, irr ) ? 0.0 : 1.0 );\n            }\n\t\t}\n\t\tocc /= 4.0;\n\n        // lighting        \n        vec3 lin = vec3(0.0);\n        lin += dif*vec3(9.0,6.50,5.0)*1.2;\n        lin += occ*2.5*mix(vec3(1.0,0.4,0.2),vec3(0.8,0.9,1.0),clamp(0.2+0.8*nor.y,0.0,1.0));\n        col = col * lin;\n        \n        vec3 hal = normalize( light1-rd);\n        float fre = 0.04 + 0.96*pow( clamp(dot(hal,-rd),0.0,1.0), 5.0 );\n        float spe = pow(clamp(dot( nor, hal ),0.0,1.0),8.0)*15.0*col.x*fre;\n        col += spe*dif;\n\n        // fog\n        col = mix( col, vec3(0.07), 1.0-exp( -0.015*tmin ) );\n    }\n    float t = tmin;\n \n    col = pow( col, vec3(0.4545) );\n\n    //------------------------------------------\n\t// reproject from previous frame and average\n    //------------------------------------------\n\n    mat4 oldCam = mat4( texelFetch(iChannel0,ivec2(0,0), 0),\n                        texelFetch(iChannel0,ivec2(1,0), 0),\n                        texelFetch(iChannel0,ivec2(2,0), 0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    // world space\n    vec4 wpos = vec4(ro + rd*t,1.0);\n    // camera space\n    vec3 cpos = (wpos*oldCam).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = -fl * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    // undo dither\n    spos -= off/iResolution.xy;\n\t// raster space\n    vec2 rpos = spos * iResolution.xy - .5;\n    ivec2 ipos = ivec2(floor(rpos));\n    // blend pixel color history\n    if( (ipos.y>0 || ipos.x>2) && iFrame>0 )\n    {\n        col = mix( textureLod( iChannel0, spos, 0.0 ).xyz, col, 0.18 );\n    }\n\n    //----------------------------------\n    // output\n\tivec2 ifc = ivec2(floor(fragCoord));\n\tif( ifc.y==0 && ifc.x<=2 )\n    {\n        // camera\n        fragColor = vec4( cam[ifc.x], -dot(cam[ifc.x],ro) );\n    }\n    else\n    {\n        // color\n        fragColor = vec4( col, 1.0 );\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}