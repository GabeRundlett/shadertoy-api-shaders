{
    "Shader": {
        "info": {
            "date": "1611348197",
            "description": "Various methods of applying dithering with and with out clamping techniques for use with Alpha to Coverage.\nMove mouse up & down to adjust simulated MSAA level.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlKyRy",
            "likes": 7,
            "name": "Limited Range Noise A2C Dither",
            "published": 3,
            "tags": [
                "dithering"
            ],
            "usePreview": 0,
            "username": "bgolus",
            "viewed": 755
        },
        "renderpass": [
            {
                "code": "// Various methods of applying blue noise dithering with and without clamping techniques for use with Alpha to Coverage.\n// Move mouse up & down to adjust the simulated MSAA level.\n//\n// ================================================================================================================================\n//\n// Most GPU dithering examples show a gradient or color image with few or no areas of solid white / black. This hides a significant\n// flaw with the usual \"ideal\" dithering technique of using a -0.5 to +1.5 triangular distribution noise. Solid white and black\n// areas are never fully solid white or black! This artifact is mostly fine to ignore for color values, especially when using HDR\n// rendering as it's rare for anything to be fully black, and values will rarely be exactly 1.0. But for dithering of alpha this is\n// a serious problem.\n//\n// This example shows off the problems with both basic unorm linear range dithering and snorm triangular dithering, basic clamping\n// solutions, and improved clamping solutions. Note, this is written with Nvidia's rounded Alpha to Coverage in mind, so noise is\n// 0.0 centered rather than 0.5 centered as you would want it to be for most dithering use cases.\n\n\n\n// Example 0\n// Basic rounding, no dithering\n// Here as an example of the current precision.\n\n\n\n// unorm linear dithering examples\n\n// Example 1\n// Effective at removing the banding, but still has something similar to banding due to there being areas with no dithering. This\n// contrast of dithered and not dithering isn't super obvious with blue noise, but it is still there. Switch to using random noise\n// and it becomes much more apparent. Also shows unwanted dithering in the black (or white) area due to dithering adding just enough\n// for it to get to the next quantized level.\n\n// Example 2\n// Removes unwanted dithering in the extremes by using a ternary to only apply dithering to values less than 1.0 and greather than 0.0.\n\n// Example 3\n// Removes unwanted dithering in the extremes by slightly scaling the step size. Virtually identical to the ternary based clamping,\n// but slightly faster.\n\n\n\n// snorm triangular remapped dithering examples\n\n// Example 4\n// Even more effective at removing banding, and completely removes the additional banding-like artifacts caused by there being area\n// no dithering. However has serious issues at the extremes showing very strong unwanted dithering artifacts. In very low precision\n// situations it also removes any apparent gradient!\n\n// Example 5\n// Using the same ternary operator to limit the dithering to values less than 1.0 and greater than 0.0. This removes the unwanted\n// dithering problem, but creates a new one as there is now an obvious hard edge cutoff when it hits the extremes. Neither the top\n// nor bottom of the gradient feel like they quite get close enough to 0.0 or 1.0 because the dithering is too strong.\n\n// Example 6\n// Hybrid unorm and snorm dithering! Blends between the two at the extremes of the gradient getting the best of both worlds. Removes\n// dithered / not dithered banding, but actually gets to 1.0 and 0.0 at the extremes without dithering appearing in the extremes.\n// Whether or not this is worthwhile over example 3 depends on your use case. On wider, softer gradients and MSAA 2x or 4x, this is\n// clearly visually superior. Especially so if using white noise instead of blue noise. Nearly identical to example 3 when doing\n// binary dithering, but obviously more expensive for no real benefit, so not useful with MSAA disabled.\n\n\n\n\n// animated noise assumes using an RGBA noise texture\n// don't use this with single channel noise\n// #define ANIMATED_NOISE\n\n#define DEFAULT_STEPS 4.0\n\n#define EXAMPLES 7.0\n#define EXAMPLE(n) if (uv.x < float(n+1)/EXAMPLES)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // alpha value rescaled so there are solid white and black areas\n    float y = uv.y * 1.25 - 0.125;\n    \n    float examples = 6.;\n    \n    float steps = DEFAULT_STEPS;\n    if (iMouse.y > 10.0)\n    {\n        steps = pow(2., round(mix(0., 4., clamp(iMouse.y / iResolution.y * 1.25 - 0.125, 0., 1.))));\n    }\n    \n    float a = clamp(y, 0., 1.);\n    \n    // texel matched UV for noise\n    vec2 noiseUV = fragCoord;\n    // offset so each example shows the same noise\n    noiseUV.x -= floor(uv.x * EXAMPLES) * floor(iResolution.x / EXAMPLES);\n    noiseUV /= iChannelResolution[0].xy;\n        \n    #if defined(ANIMATED_NOISE)\n    // assumes you're using RGBA noise texture\n    // scroll UVs\n    noiseUV.x += mod(float(iFrame), 32.) / 32.;\n    noiseUV.y += mod(float(iFrame), 64.) / 64.;\n    \n    vec4 noiseTex = texture(iChannel0, noiseUV);\n    \n    // select channel based on current frame\n    float frameMod = mod(float(iFrame), 4.);\n    float noise = dot(vec4(frameMod == 0., frameMod == 1., frameMod == 2., frameMod == 3.), noiseTex);\n    #else\n    \n    // just sample the noise texture\n    float noise = texture(iChannel0, noiseUV).r;\n    #endif\n    \n    EXAMPLE(0)\n    {\n        // no dithering, quantized value is simply rounded\n    }\n    \n    else EXAMPLE(1)\n    {\n        // -0.5 to +0.5 step range dithering\n        // shows unwanted dithering in the black, might show dithering white on some devices\n        // still has something like \"banding\" in lower precision situations due to stripes of un-dithered values\n        // this is more obvious with random noise\n        a = a + (noise - 0.5) / steps;\n    }\n    \n    else EXAMPLE(2)\n    {\n        // -0.5 to +0.5 step range dithering\n        // ternary op to prevent unwanted dithering on the extremes\n        // still has something like \"banding\" in lower precision situations due to stripes of un-dithered values\n        // this is more obvious with random noise\n        a = (1. > a && a > 0.) ? a + (noise - 0.5) / steps : a;\n    }\n    \n    else EXAMPLE(3)\n    {\n        // -0.5 to +0.5 step range dithering\n        // minor rescaling of step size to avoid unwanted dithering with a single extra MUL instead of using a ternary\n        // still has something like \"banding\" in lower precision situations due to stripes of un-dithered values\n        // this is more obvious with random noise\n        a = a + (noise - 0.5) / steps * 0.99999;\n    }\n    \n    else EXAMPLE(4)\n    {\n        // -1.0 to +1.0 step range dithering\n        // blue noise values remapped to a triangle noise (function outputs -1.0 to 1.0 range)\n        // shows significant artifacts outside the > 1.0 and < 0.0 alpha values\n        noise = remap_noise_tri_unity(noise);\n        a += noise / steps;\n    }\n    \n    else EXAMPLE(5)\n    {\n        // -1.0 to +1.0 step range dithering\n        // blue noise values remapped to a triangle noise (function outputs -1.0 to 1.0 range)\n        // ternary clamping removes artifacts outside the > 1.0 and < 0.0 alpha values, but shows harsh cutoff\n        noise = remap_noise_tri_unity(noise);\n        a = (1. > a && a > 0.) ? a + noise / steps : a;\n    }\n    \n    else EXAMPLE(6)\n    {\n        // hybrid -0.5 to +0.5 and -1.0 to +1.0 step range dithering\n        // blue noise values remapped to a triangle noise (function outputs -1.0 to 1.0 range)\n        // lerp from a \"2.0\" to a \"1.0\" range magnitude dither at the extremes over sqrt of 1 step\n        // minor rescaling of the step size to avoid unwanted dithering with a single extra MUL instead using a ternary\n        // with \"MSAA x1\" precision this is nearly identical to example 3, but much more expensive\n        noise = remap_noise_tri_unity(noise);\n        float factor = sqrt(clamp(min(a, (1.0 - a)) * steps, 0., 1.));\n        float error = mix(0.5, 1., factor) / steps * 0.99999;\n        a = a + noise * error;\n    } \n    \n    // rounded floor to mimic alpha to coverage\n    a = floor(a * steps + 0.5) / steps;\n    \n    // full precision gradient bands w/o dithering for direct comparison\n    if (fract(uv.x * EXAMPLES) < 0.5)\n        a = clamp(y, 0., 1.);\n    \n    fragColor = vec4(Linear2sRGB(a));    \n    \n    // UI stuff\n    \n    // display precision steps\n    float digit = PrintValue((fragCoord.xy / iResolution.x) * 44. - vec2((steps > 9. ? 19. : 16.) / EXAMPLES, 0.3), steps, 2., 0.);\n    fragColor = mix(fragColor, vec4(0.5,0.65,0.75,1.), digit);\n    \n    // display example nums\n    float num = PrintValue(vec2(fract(fragCoord.x / iResolution.x * EXAMPLES), (fragCoord.y - iResolution.y * 0.93) / iResolution.x ) * 44. / vec2(EXAMPLES, 1.), floor(uv.x * EXAMPLES), 1., 0.);\n    fragColor = mix(fragColor, vec4(0.), num);\n    \n    // 0.0 and 1.0 limit pips\n    if (abs(y - 0.5) > 0.5 && abs(y - 0.5) <= (0.5 + fwidth(y) * 2.))\n    {\n        if( mod(fragCoord.x + iResolution.x / (EXAMPLES * 2.) + 2., iResolution.x / EXAMPLES) < 4.)\n        {\n            fragColor = vec4(step(y, 0.5), 0.0, step(0.5, y), 1.);\n        }\n    }\n    \n    // separators\n    if (fract(uv.x * EXAMPLES) > 1. - fwidth(uv.x * EXAMPLES))\n    {\n        fragColor = vec4(0.);\n    }    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float remap_noise_tri_unity( float v )\n{\n    v = v*2.0-1.0;\n    return (v > 0.0 ? 1.0 : -1.0) * (1.0 - sqrt(1.0 - abs(v)));\n}\n\nfloat sRGB2Linear(float val)\n{\n    if( val <= 0.04045 )\n        val /= 12.92;\n    else\n        val = pow((val + 0.055)/1.055,2.4);\n    return val;\n}\n\nfloat Linear2sRGB(float val)\n{\n    if( val <= 0.0031308 )\n        val *= 12.92;\n    else\n        val = pow(val, 1./2.4) * 1.055 - 0.055;\n    return val;\n}\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}