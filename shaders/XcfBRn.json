{
    "Shader": {
        "info": {
            "date": "1724412489",
            "description": "Using a hexagon grid to produce a textured isometric block pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "XcfBRn",
            "likes": 55,
            "name": "Hexagon Blocks",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "cube",
                "hexagon",
                "vector",
                "isometric",
                "pattern",
                "art"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "/*\n\n\tHexagon Blocks\n\t--------------\n    \n    I wrote this a long time ago. I'm not sure what the most common hexagon grid \n    pattern would be, but isometric boxes would have to be a contender, possibly \n    because they're very easy to make, and the results are reasonably satisfying.\n    \n    They are constructed by producing a hexagon grid, then partitioning each hexagon\n    cell into three quads to represent cube faces. If you know how to render\n    polygons, then it should be pretty easy. Textured and shadowed examples are \n    less common, but that's pretty easy to do also, and is explained below.\n    \n    Anyway, this example is definitely not that interesting, but hopefully, it'll \n    be useful to someone out there.  \n\n\t\n    \n    \n    Other hexagonal pattern examples:\n\n    // With more effort, you can add stairs, doors, and all kinds of things.\n    hexastairs: ladder like + doors -- FabriceNeyret2 \n\thttps://www.shadertoy.com/view/wsyBDm\n    \n    // Another simple, but effective, hexagon grid-based pattern.\n    Repeating Celtic Pattern (360ch) -- FabriceNeyret2\n    https://www.shadertoy.com/view/wsyXWR\n\n    // JT has a heap of grid-based patterns that I like looking through.\n    // Here are just a couple:\n    //\n    hexagonally grouped weaved lines  -- jt \n    https://www.shadertoy.com/view/DdccDr\n    //\n    three directions city grid parts -- jt\n    https://www.shadertoy.com/view/DdccR8\n    \n    \n\n*/\n\n// Diagonal face pattern, or not.\n//#define DIAGONAL\n\n// Randomly invert some of the boxes. It's a pretty standard move and\n// makes the pattern look a little more interesting.\n//\n// Commenting it out will produce the cleaner, but more basic pattern.\n#define RANDOM_INVERT\n\n// Show the hexagon grid that the pattern is based on...\n// Probably a little redundant in this case, but it's there.\n//#define SHOW_GRID\n\n// Flat top hexagons, instead of pointed top.\n//#define FLAT_TOP\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n// Flat top hexagon, or pointed top.\n#ifdef FLAT_TOP\nconst vec2 s = vec2(1.732, 1);\n#else\nconst vec2 s = vec2(1, 1.732);\n#endif\n\n// Hexagon vertex IDs. They're useful for neighboring edge comparisons, etc.\n// Multiplying them by \"s\" gives the actual vertex postion.\n#ifdef FLAT_TOP\n// Vertices: Clockwise from the left.\n                     \n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n\n#else\n// Vertices: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\n\n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-6, -2), vec2(-6, 2), vec2(0, 4), \n                      vec2(6, 2), vec2(6, -2), vec2(0, -4));\n\nconst vec2[6] eID = vec2[6](vec2(-6, 0), vec2(-3, 3), vec2(3, 3), vec2(6, 0), \n                      vec2(3, -3), vec2(-3, -3));\n\n#endif\n\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n    \n    // Flat top and pointed top hexagons.\n    #ifdef FLAT_TOP\n    return max(dot(abs(p.xy), s/2.), abs(p.y*s.y));\n    #else   \n    return max(dot(abs(p.xy), s/2.), abs(p.x*s.x));\n    #endif\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n    \n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    // The ID is multiplied by 12 to account for the inflated neighbor IDs above.\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy*12.) : vec4(q.zw, ip.zw*12. + 6.);\n    //return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n\n}\n\n\n// Face pattern. Nothing exciting. Just a pseudo maze pattern.\nfloat cubeTex(vec2 p, vec2 gIP){\n\n    #ifdef DIAGONAL\n    float sc = 6.;\n    #else\n    float sc = 8.*.7071;\n    p *= rot2(3.14159/4.);\n    #endif\n    \n    p *= sc;    \n    \n    // Square cell partiioning.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Random rotation.\n    float rnd = hash21(ip + gIP*.123 +.01);\n    if(rnd<.5) p.y = -p.y;\n    \n    // Diagonal lines.\n    vec2 ap = abs(p - .5);\n    float d = abs((ap.x + ap.y)*.7071 - .7071);\n    ap = abs(p);\n    d = min(d, abs((ap.x + ap.y)*.7071 - .7071));\n    d -= .1666;\n    \n    // Scale back and return.\n    return -d/sc;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord.xy - res.xy*.5)/res.y;\n    \n    // Global scale factor.\n    const float sc = 4.;\n    // Smoothing factor.\n    float sf = sc/res.y;\n    \n    // Scene rotation, scaling and translation.\n    mat2 sRot = mat2(1, 0, 0, 1);//rot2(3.14159/12.); // Scene rotation.\n    vec2 camDir = sRot*normalize(s); // Camera movement direction.\n    vec2 ld = sRot*normalize(vec2(1, -1)); // Light direction.\n    vec2 p = sRot*uv*sc + camDir*iTime/3.;\n    \n   \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p);\n    \n    \n    // The vertex and edge IDs are multiplied by 12, so we're factoring that in.\n    vec2 sDiv12 = s/12.;\n\n    \n    #ifdef RANDOM_INVERT\n    // Random flipping number.\n    float rndT = hash21(p4.zw + .01)<.5? -1. : 1.;\n    \n    // Randomly flip the coordinates.\n    if(rndT<0.) p4.y = -p4.y;\n    #endif\n\n    // Center to edge lines.\n    float vLn[6];\n    \n    \n    // Hexagon shape.\n    float hexShape = getHex(p4.xy) - .5;\n     \n    // Iterate through all six sides of the hexagon cell.\n    for(int i = 0; i<6; i++){\n        \n        // Center to edge lines.\n        vLn[i] = distLineS(p4.xy, vec2(0), vID[i]*sDiv12);\n\n        // Border lines (start with \"hexShape = -1e5;\").\n        //float bord = distLineS(p4.xy, vID[i]*sDiv12, vID[(i + 1)%6]*sDiv12);\n        // Hexagon shape.\n        //hexShape = max(hexShape, bord);\n\n    }\n     \n    // Cube faces.\n    vec3 cube;\n    \n    // Top, left and right cube sides.\n    cube.x = max(max(hexShape, vLn[1]), -vLn[3]);\n    cube.y = max(max(hexShape, vLn[3]), -vLn[5]);\n    cube.z = max(max(hexShape, vLn[5]), -vLn[1]);\n    \n    \n    // The overall color and shade.\n    vec3 col = vec3(0);\n    vec3 shade = vec3(.9, .5, .4);\n    \n    // Cube shadows.\n    vec3 shad = vec3(1e5);\n    // Render quarter-wing shadow portions on two of the faces, then put the \n    // remaining face completely in shadow. It's a simple, but effective, trick.\n    shad.x = max(cube.x, distLineS(p4.xy, vID[3]*sDiv12, eID[1]*sDiv12));\n    shad.y = max(cube.y, distLineS(p4.xy, eID[4]*sDiv12, vID[3]*sDiv12));\n    shad.z = cube.z;\n    #ifdef RANDOM_INVERT\n    if(rndT<0.){ shad.xy = cube.xy; } // All in shade, if the hexagons are inverted.\n    \n    // Shift the shades to match the faces of the hexagons with flipped orientation.\n    if(rndT<0.) shade = shade.xzy; \n    #endif\n \n\n    // Applying the colors, patterns, etc, to the cube faces.\n    //\n    // Hmmm... I could've used cleaner color logic here, but it seems to work,\n    // so I'll leave it for now. I might tidy it up later.\n    for(int i = 0; i<3; i++){\n    \n        // Matrix containing the vertex-based basis vectors, which in turn is\n        // used for oriented texturing.\n        mat2 mR = inverse(mat2((vID[(i*2 + 1)%6]*sDiv12), (vID[(i*2 + 3)%6]*sDiv12)));\n        // Correctly oriented texture coordinates for this particular face.\n        vec2 txC = mR*p4.xy;\n        // Using the coordinates to create the face pattern.\n        float pat = cubeTex(txC, p4.zw*3. + float(i));\n        \n        // Random face color -- It's just a shade of green.\n        float rnd4 = hash21(p4.zw*3. + float(i)*1. + .3);\n        vec3 patCol = .5 + .45*cos(6.2831*rnd4/4. + vec3(0, 1, 2).yxz*1.4);\n        //vec3 patCol = vec3(.45, .6, .6); // Plain color.\n  \n        // Running a bit of a blue gradient through the colors.   \n        patCol = mix(patCol, patCol.zyx, clamp(-p4.x*.5 - p4.y + .5, 0., 1.));\n\n        // Running screen-based gradients throughout.\n        float uvx = uv.x*res.x/res.y;\n        patCol = mix(patCol, patCol.xzy, 1. - smoothstep(0., 1., -uv.x/3. + uv.y + .5));\n        patCol = mix(patCol, patCol.yxz, 1. - smoothstep(.2, .5, -uvx/2. + .5));\n        patCol *= 2.5;\n  \n        // Face, edge and trim colors.\n        vec3 faceCol = vec3(.9, 1, 1.2);\n        vec3 edgeCol = faceCol/10.;\n        vec3 trimCol = vec3(1.6, .8, .2)*mix(faceCol, patCol, .3);\n    \n        // Applying the pattern to the faces.\n        faceCol = mix(edgeCol, patCol, 1. - smoothstep(0., sf, pat));\n        \n        // Applying the face shades.\n        edgeCol *= shade[i];\n        trimCol *= shade[i];\n        faceCol *= shade[i];\n   \n        // Add the cube quads.\n        col = mix(col, edgeCol, (1. - smoothstep(0., sf, cube[i])));\n        col = mix(col, trimCol, (1. - smoothstep(0., sf, cube[i] + 1./56.)));\n        col = mix(col, edgeCol, (1. - smoothstep(0., sf, cube[i] + 1./56. + 1./28.)));\n        col = mix(col, faceCol, (1. - smoothstep(0., sf, cube[i] + 2.5/56. + 1./28.)));\n         \n        \n    }\n    \n\n    // Applying shadows.\n    for(int i = 0; i<3; i++){\n        col = mix(col, col*.25, (1. - smoothstep(0., sf*6.*res.y/450., shad[i] + .015)));\n    }\n    \n    // A bit of false ambient occusion.\n    #ifdef RANDOM_INVERT\n    if(rndT>0.) col *= max(1. - length(p4.xy)*.95, 0.);\n    else col *= max(.25 + length(p4.xy)*.75, 0.);\n    #else\n    col *= max(1. - length(p4.xy)*.95, 0.);\n    #endif\n    \n    #ifdef SHOW_GRID\n    // A little bit redundant, but here are the hexagon border lines.\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, abs(hexShape) - .005)));\n    #endif\n    \n    // Vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    // Rough gamma correction.\n    fragColor = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}