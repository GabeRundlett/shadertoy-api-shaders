{
    "Shader": {
        "info": {
            "date": "1651284758",
            "description": "sometimes you just gotta make some vaporwave",
            "flags": 32,
            "hasliked": 0,
            "id": "stffRl",
            "likes": 25,
            "name": "ａｅｓｔｈｅｔｉｃ alcove",
            "published": 3,
            "tags": [
                "raymarching",
                "neon",
                "aesthetic",
                "vaporwave"
            ],
            "usePreview": 1,
            "username": "Xibanya",
            "viewed": 511
        },
        "renderpass": [
            {
                "code": "float nrand(float x, float y) \n{\n    return fract(sin(dot(\n        vec2(x, y), vec2(12.9898, 78.233))) * \n        43758.5453); \n}\nvec4 Blend(vec4 top, vec4 bottom) \n{\n\tvec4 result;\n\tresult.a = top.a + bottom.a * (1.0 - top.a);\n\tresult.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * \n        (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float jitter = nrand(uv.y, iTime / 20.) * 2. - 1.;\n    uv.x += jitter * step(0.0, abs(jitter)) * 0.00175;\n    \n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\n\tvec3 blur = texture(iChannel0, uv.xy).rgb;\n    \n    float sub = -0.1;\n    float hard = 0.3;\n\n    float modulo = floor(mod(uv.x / texel.x * 0.25, 3.0));\n    vec3 tmp = blur.rgb;\n    float is0 = step(modulo, 0.) * step(0., modulo);\n    float is1 = step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(0., sub * hard, \n        sub * hard * 2.0) * is0;\n    tmp -= vec3(sub * hard, 0., \n        sub * hard) * step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(sub * hard * 2.0, \n        sub * hard, 0.) * (1. - is0) * (1. - is1);\n    vec3 col = Blend(vec4(tmp, 0.75), vec4(blur, 1.5)).rgb;\n    \n    float scanline = \n        sin((uv.y - sin(iTime / 200.)) * iResolution.y) * 0.015;\n    col.rgb -= scanline;\n    \n    vec2 vigUV = fragCoord.xy / iResolution.xy * 2. - 1.;\n    float vignette = smoothstep(-1., .75, 1. - dot(vigUV, vigUV));\n    col *= vignette;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float _XRot = -5.;\nfloat _YRot = 18.;\nfloat _XPos = -5.;\nfloat _YPos = 1.2;\nfloat _ZPos = 5.;\nfloat _FOV = 60.;\n\nconst int MARCH_STEPS = 100;\nconst int SHADOW_MARCH_STEPS = 50;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 SHADOW_COLOR = vec3(0.2, 0.1, 0.4);\nconst vec3 SPEC_COLOR = vec3(0.3, 0.9, 0.8);\nconst vec3 PINK = vec3(0.8, 0.4, 0.9) * 0.75;\nconst vec3 CYAN = vec3(0.1, 0.8, 0.9);\n\nstruct Objects {\n    float column; float alcove; float wall;\n    float ground; float shape; float accent;\n    float tri;\n};\n\nmat3 YRotationMatrix(float degrees)\n{\n\tfloat angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat3 rotateYMatrix = mat3(\n        c, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c);\n\treturn rotateYMatrix;\n}\nmat3 ZRotationMatrix(float degrees)\n{\n\tfloat angleZ = radians(degrees);\n\tfloat c = cos(angleZ);\n\tfloat s = sin(angleZ);\n\tmat3 rotateZMatrix = mat3(\n        c, -s, 0,\n\t\ts, c, 0,\n\t\t0, 0, 1\n\t\t);\n\treturn rotateZMatrix;\n}\nmat3 XRotationMatrix(float degrees)\n{\n\tfloat angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat3 rotateXMatrix = mat3(\n        1, 0, 0,\n\t\t0, c, -s, \n\t\t0, s, c);\n\treturn rotateXMatrix;\n}\nvoid Rotate(inout vec3 o, vec3 a)\n{\n    vec3 localScaledTranslatedRotX = o * XRotationMatrix(a.x);\n    vec3 localScaledTranslatedRotXY = localScaledTranslatedRotX * YRotationMatrix(a.y);\n    o = localScaledTranslatedRotXY * ZRotationMatrix(a.z);\n}\n\n//https://www.shadertoy.com/view/XtBfzz\nfloat gridTexture( in vec2 p )\n{\n    vec2 i = step(fract(p), vec2(1.0/ 30.));\n    return (1.0-i.x)*(1.0-i.y);\n}\n//https://www.shadertoy.com/view/XlcSz2\nfloat checkersTexture( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y, 2.0 );\n}\n//https://www.shadertoy.com/view/ws3Bzf\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n)\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n//https://iquilezles.org/articles/distfunctions/\nfloat SDFBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    vec3 v = min(d, 0.);\n    return length(max(d, 0.0)) + max(max(v.x, v.y), v.z);\n}\nfloat SDFTri( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat SDFCylinder(vec3 p, float r, float height) \n{\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y) - height);\n}\nfloat SDFCapped( vec3 p, float r, float h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat SDFSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\nfloat SDFCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat SDFUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat SDFSub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat ColumnSDF(vec3 p)\n{\n    vec4 a0 = vec4(p, 1.0);\n    vec3 colOffset = vec3(4., 0., 2.);\n    vec3 colPos = a0.xyz + vec3(0.95, 1.3, 2.35);\n\tfloat column = SDFBox(colPos, vec3(.4,.106, .4));\n    a0.xyz += colOffset;\n\tvec3 pos = a0.xyz - vec3(3.03,-1.42,-.43);\n\tcolumn = SDFUnion(column, SDFBox(pos,vec3(.5,.132,.5)), 0.2);\n\tpos = a0.xyz - vec3(3.03,.257,-.43);\n    float cyl = SDFCapped(pos, .36, 1.6);\n    //float cyl = SDFCylinder(pos, .365,1.593)\n\tcolumn = min(column, cyl);\n\tpos = (mat4(\n        1.0, .0, .0, .0, \n        .0, -1.0, .0, .0, \n        .0, .0, -1.0, .0, \n        -3.03, 1.788, -.43, 1.0) * a0).xyz;\n\tcolumn = min(column, SDFBox(pos,vec3(.4,.106,.4)));\n\tpos = (mat4(\n        1.0, .0, .0, .0, \n        .0, -1.0, .0, .0, \n        .0, .0, -1.0, .0, \n        -3.03, 1.924, -.43, 1.0) * a0).xyz;\n\tcolumn = SDFUnion(column, SDFBox(pos,vec3(.5,.132,.5)), 0.15);\n    return column;\n}\nfloat Scene(vec3 p, out Objects o) \n{\n    vec3 floorPos = p - vec3(10., -1.5, 10.);\n    o.ground = SDFBox(floorPos, vec3(200., 0.01, 200.));\n\n    vec3 wallP = p + vec3(10., 0., 20.);\n    o.wall = SDFBox(wallP, vec3(200., 20., 15.));\n    vec3 alcovePos = p + vec3(8., 2., 5.);\n    o.alcove = SDFCapsule(alcovePos, 3.,  2.);\n    o.wall = SDFSub(o.alcove, o.wall, 0.25);\n\n    o.accent = SDFBox(floorPos + vec3(0., -0.04, 18.9), vec3(200., 0.05, 4.));\n    o.accent = SDFSub(o.alcove, o.accent, 0.05);\n\t\n    vec3 colPos = p + vec3(9.5, 0., 1.);\n    o.column = ColumnSDF(colPos);\n    colPos = p + vec3(4.5, 0., 1.);\n    o.column = min(o.column, ColumnSDF(colPos));\n\n    vec3 triPos = alcovePos + vec3(0., -2.5, 1.25);\n    Rotate(triPos, vec3(0., 0., iTime * 6.));\n    o.tri = SDFTri(triPos, vec2(1., 0.1));\n    \n    float sdf = min(o.tri, min(o.accent, min(o.column, min(o.ground, o.wall))));\n\treturn sdf;\n}\n// meant to be called when distance is needed but color zones are not.\nfloat Distance(vec3 p)\n{\n    Objects o;\n    return Scene(p, o);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * EPSILON;\n    return normalize( e.xyy * Distance( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx * Distance( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy * Distance( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx * Distance( pos + e.xxx ) );\n}\nfloat March(vec3 pos, vec3 dir, out Objects o) \n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MARCH_STEPS; i++) \n    {\n        vec3 p = pos + depth * dir;\n        float dist = Scene(p, o);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= MAX_DIST) break;\n    }\n    return MAX_DIST;\n}\n// https://iquilezles.org/articles/rmshadows\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n    float mint = 0.02;\n    float tmax = 2.5;\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i< SHADOW_MARCH_STEPS; i++ )\n    {\n\t\tfloat h = Distance( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0);\n}       \nfloat GetLight(vec3 normal, vec3 p, vec3 lightPos)\n{\n    vec3 lightDir = normalize(p - lightPos);\n    float nDotL;\n    nDotL = max(0., dot((lightDir), normal));\n    float shadow = Shadow(p, lightDir);\n    shadow = smoothstep(0., 0.1, pow(shadow, 5.));\n    nDotL *= shadow;\n    return nDotL;\n}\nfloat GetLight2(vec3 normal, vec3 p, vec3 lightPos)\n{\n    vec3 lightDir = normalize(p - lightPos);\n    float nDotL;\n    nDotL = dot(normalize(lightDir), normal) * 0.5 + 0.5;\n    float shadow = smoothstep(0., 0.1, pow(Shadow(p, lightDir), 5.));\n    nDotL *= shadow;\n    return nDotL;\n}\nvec3 RayDir(float fieldOfView, vec2 size, vec2 fragCoord) \n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 Color(Objects o, vec3 pos, vec3 dir, vec3 normal, float dist)\n{\n    vec3 p = pos + dir * dist;\n    // ALBEDO\n    vec3 triColor = CYAN * 2.;\n    vec3 columnColor = vec3(1.) *  \n        (1. - biplanar(iChannel0, .5 * p, normal).r * 0.75);\n    vec3 sideWallColor = vec3(gridTexture(p.xy + vec2(0.09, 0.)));\n    vec3 alcoveColor = vec3(0.7, 0.8, 0.9) * (1. + columnColor * 0.25);\n    vec3 accentColor = vec3(1.2, 0.5, 0.9);\n    vec3 albedo = alcoveColor;\n    float tally = o.alcove;\n    albedo = o.wall < tally? max(vec3(0.9), sideWallColor) : albedo;\n    tally = min(tally, o.wall);\n    albedo = o.ground < tally? vec3(checkersTexture(p.xz)) : albedo;\n    tally = min(o.ground, tally);\n    albedo = o.column < tally? columnColor : albedo;\n    tally = min(o.column, tally);\n    albedo = o.accent < tally? accentColor : albedo;\n    tally = min(o.accent, tally);\n\n    // doing it this way to avoid issues with the overlap with the capsule\n    if (o.tri < o.ground && o.tri < o.wall && o.tri < o.accent && o.tri < o.column)\n    {\n        albedo = triColor;\n    }\n\n    if (o.wall < o.column && o.wall < o.ground && o.wall < o.alcove && o.wall < o.accent)\n    {\n        normal.xz *= sideWallColor.r;\n        p = pos + dir * max(0., (dist - (1. - sideWallColor.r)));\n    }\n\n    vec3 shadowColor = SHADOW_COLOR;\n\n    // DIFFUSE\n    vec3 light1Pos = vec3(25., 3.5, -10.);\n    float light1Term = GetLight(normal, p, light1Pos);\n    vec3 light1 = PINK * light1Term;\n    shadowColor = mix(shadowColor, PINK, light1Term);\n\n    vec3 light2Pos = vec3(-25., -3.5, 10.);\n    float light2Term = GetLight2(normal, p, light2Pos);\n    vec3 light2 = CYAN * light2Term;\n   \n    float diffuseTerm = clamp(light1Term + light2Term, 0., 1.);\n    vec3 diffuse = mix(shadowColor, light2, light2Term);\n\n    // FRESNEL\n    float fresnelTerm = 1. - max(0., dot(normal, -dir));\n    fresnelTerm = smoothstep(0.5, 0.8, fresnelTerm);\n    albedo += albedo * fresnelTerm * diffuseTerm;\n\n    // SPECULAR\n    vec3 specDir = vec3(-1.5, -0.8, -0.8);\n    float specTerm = max(0., dot(normal, normalize(dir - specDir)));\n    specTerm = o.column < o.ground? smoothstep(0.7, 1., specTerm) : 0.;\n    tally = min(o.column, o.ground);\n    specTerm = o.alcove < tally? 0. : specTerm;\n    tally = min(tally, o.alcove);\n    specTerm = o.wall < tally? specTerm * 2. : specTerm;\n    vec3 spec = SPEC_COLOR * specTerm * diffuseTerm * 0.0;\n\n    spec += (1. - smoothstep(0., 0.15, abs(o.accent + 0.03))) * accentColor * 2.;\n\n    float gloTri = o.tri - 0.01;\n    spec += (1. - smoothstep(0.1, 3., gloTri)) * triColor * 0.25;\n\n    spec += (1. - smoothstep(0., .2, abs(o.tri))) * triColor;\n    \n\n    return albedo * diffuse + spec;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rot = vec2(_XRot, _YRot);\n    //if (iMouse.xy != vec2(0)) rot += (vec2(iMouse.xy / iResolution.xy).yx * 2. - 1.);\n    \n\tvec3 dir = RayDir(_FOV, iResolution.xy, fragCoord);\n    dir *= XRotationMatrix(rot.x);\n    dir = dir * YRotationMatrix(rot.y);\n    vec3 pos = vec3(_XPos, _YPos, _ZPos);\n    Objects o;\n    float dist = March(pos, dir, o);\n    \n    if (dist > MAX_DIST - EPSILON) \n    {\n        fragColor = vec4(0.);\n\t\treturn;\n    }\n    vec3 p = pos + dist * dir;\n    vec3 normal = GetNormal(p);\n    vec3 diffuse = Color(o, pos, dir, normal, dist);\n    fragColor = vec4(diffuse, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}