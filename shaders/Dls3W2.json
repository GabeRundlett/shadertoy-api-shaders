{
    "Shader": {
        "info": {
            "date": "1672443849",
            "description": "simple mandlebrot, click and drag to pan.  Epilepsy warning.\n\nDisable the filter out by commenting it's define in Image.\n\nDisable the noisy filter by commenting NOISY_S in Buffer A.\n- NOISY_S should produce moirre-like gratings after a few cycles.",
            "flags": 32,
            "hasliked": 0,
            "id": "Dls3W2",
            "likes": 0,
            "name": "mandelbrot dream",
            "published": 3,
            "tags": [
                "fractal",
                "kernel"
            ],
            "usePreview": 0,
            "username": "graygoose",
            "viewed": 177
        },
        "renderpass": [
            {
                "code": "#define FILTER\nprecision highp float;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef FILTER\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    #else\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "precision highp float;\n\nint get_nearest_root(vec2 z){\n    int index = 0; float dist = 1000.;\n    \n    for(int i = 0; i < NROOTS; i++){\n        float d = length(z - roots[i]);\n        if(d < dist){\n            index = i; dist = d;\n        }\n    }\n    \n    return index;\n}\n\n#define ITER_MAX 2500\nint mandelbrot(vec2 p){\n    float x0 = p.x, y0 = p.y;\n    float x = 0., y = 0.;\n\n    int iter = 0;\n    while(x*x + y*y < 4. && iter < ITER_MAX){    \n        float xtemp = x*x - y*y + x0;\n        y = 2.*x*y + y0;\n        x = xtemp;\n\n        iter++;\n    }\n\n    return iter;\n}\n\nfloat hash(int n){ return fract(sin(float(n))*136.5453123); }\n\n// coloring using iter as a hash into a palette function\nvec3 hash_color(int i){\n    float max = float(ITER_MAX);\n    float r = mod(hash(i), float(ITER_MAX));\n    float g = mod(hash(i+1), float(ITER_MAX));\n    float b = mod(hash(i+2), float(ITER_MAX));\n\n    return vec3(r, g, b);\n}\n\n#define PI 3.1415926535\n\n\n#define MOUSE\n\n#define Z_SPD 0.001\n#define Z_SCALE 10.\n#define ZOOM (cos(iTime*Z_SPD*0.5)*sin(iTime*Z_SPD)*Z_SCALE)\n#define MZOOM (ZOOM*2.)\n#define BAILOUT 512.\n#define NOISY_S\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // scale math space -1.41855\n    vec2 z = vec2(-1.4185+ZOOM, 0.) + scale(fragCoord.xy, iResolution.xy, mat2(-2.*ZOOM, 0.47*ZOOM, -1.12*ZOOM, 1.12*ZOOM)); \n    #ifdef MOUSE\n    if (iMouse.z > 0.0) {\n        vec2 m = scale(iMouse.xy, iResolution.xy, mat2(-2., 0.47, -1.12, 1.12)*MZOOM);\n        z -= m;\n    }\n    #endif\n    \n    // mandelbrot \n    float x0 = z.x, y0 = z.y;\n    float x = 0., y = 0.;\n\n    float iter = 0.;\n    vec2 zn = vec2(0., 0.);\n    while(x*x + y*y < BAILOUT && int(iter) < ITER_MAX){    \n        float xtemp = x*x - y*y + x0;\n        y = 2.*x*y + y0;\n        x = xtemp;\n\n        zn = vec2(x, y);\n        iter++;\n    }\n\n    // stop for points that don't escape\n    if (int(iter) == ITER_MAX) {\n        fragColor = vec4(0., 0., 0., 1.);\n        return;\n    } \n    \n    if (int(iter) < ITER_MAX) {\n        float logzn = log(zn.x*zn.x + zn.y*zn.y) * 0.5;\n        float iter_part = log(logzn / log(2.)) / log(2.);\n        iter += 1. - iter_part;\n    }\n\n    // color\n    vec3 col1 = hash_color(int(iter));\n    vec3 col2 = hash_color(int(iter+1.));\n\n    // interpolated color\n    vec3 col = mix(col1, col2, fract(float(iter)));\n\n    // smooth coloring\n    #ifdef NOISY_S\n    float S = abs(cos(iTime*0.015))-sin(iTime*0.025);\n    #else\n    float S = abs(cos(iTime*0.05));\n    #endif\n    float N = float(ITER_MAX);\n    float v = mod(pow(pow((iter/float(ITER_MAX)), S) * N, 1.75), N)/N;\n\n\n    // color\n    fragColor = vec4(col * v, 1.);\n    //fragColor = vec4(hueShift(col, cos(iTime)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define STX sin(fragCoord.x*iTime)\n#define STY sin(fragCoord.y*iTime)\nprecision highp float;\n\n\n//#define TV_COLOR\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec4 C0 = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec4 L0 = filter3x3(fragCoord.xy, LAPLACIAN, iChannel0, iResolution.xy);\n    vec4 G0 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel0, iResolution.xy);\n    vec4 S0 = sobel(fragCoord.xy, iChannel0, iResolution.xy);\n    vec4 G1 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel1, iResolution.xy);\n\n    vec4 F0 = -L0 * (2.-C0);\n    vec4 col = C0*(sin(iTime*1.1)*0.5)*S0+2.*abs(cos(iTime*0.9)+1.)*F0;\n    col = col + cos(iTime)*C0*((G0 + G1) * 0.5);\n    \n    #ifdef TV_COLOR\n    O = vec4(hueShift(col.xyz, cos(iTime*0.01)), 1.);\n    #else\n    O = col;\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define NROOTS 3\nvec2 roots[NROOTS];\n\n#define SCALE(v, mx, a, b) (a + (v * (b - a) / mx))\nvec2 scale(vec2 mn, vec2 mx, mat2 bounds) {\n    return vec2(SCALE(mn.x, mx.x, bounds[0][0], bounds[0][1]),\n                SCALE(mn.y, mx.y, bounds[1][0], bounds[1][1]));\n}\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\n    // screen\nvec2 wrap(in vec2 p, in vec2 res) {\n    if (p.x > res.x) p.x = mod(p.x, res.x);\n    else if (p.x < 0.) p.x = res.x + p.x;\n    \n    if (p.y > res.y) p.y = mod(p.y, res.y);\n    else if (p.y < 0.) p.y = res.y + p.y;\n    \n    return p;\n}\n\n// math\n    //Generic 3x3 filter - vec3(center, edges, diagonals)\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, .05)\nvec4 filter3x3(in vec2 pos, in vec3 kernel, in sampler2D channel, in vec2 reso) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            \n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}\n\n\n    // Sobel\n#define SOBEL_EDGE_COLOR vec4(0.,0.,0.,1.)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.15, 0.98, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}