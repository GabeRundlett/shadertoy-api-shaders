{
    "Shader": {
        "info": {
            "date": "1685105198",
            "description": "Copied the dimensions from the wiki page:\nhttps://en.wikipedia.org/wiki/Jansen%27s_linkage\n\nI think I've done the motion in reverse but it looks more natural to me",
            "flags": 0,
            "hasliked": 0,
            "id": "cltXzN",
            "likes": 24,
            "name": "Jansen's Linkages",
            "published": 3,
            "tags": [
                "motion",
                "walk",
                "kinematics",
                "linkage",
                "jansen"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "#define res iResolution.xy\n#define pi 3.14159\n#define Dir(a) vec2(cos(a),sin(a))\n#define ss(a, b) smoothstep(-a/res.y, a/res.y, b)\n\n// Distance macros\n#define m(p) d = min(d, length(uv - p));\n#define l(p, q) d2 = min(d2, seg(uv, p, q));\n\n// iq's IK\nvec2 solve(vec2 p, float r1, float r2, float side) {\n    float h = dot(p,p);\n    float w = h + r1*r1 - r2*r2;\n    float s = max(4.0*r1*r1*h - w*w,0.0);\n    return (w*p + side * vec2(-p.y,p.x)*sqrt(s)) * 0.5/h;\n}\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 drawLeg(vec2 uv, float sc, float t) {\n    // Points\n    vec2 p = sc * vec2(38, 7.8);\n    vec2 pRot = p + sc * 15. * Dir(2. * t);\n    vec2 pIK1 = solve(pRot, sc * 41.5, sc * 50.0,  1.);\n    vec2 pIK1T = sc * 40.1 * Dir(atan(pIK1.y, pIK1.x) + 1.506);\n    vec2 pIK2 = solve(pRot, sc * 39.3, sc * 61.9, -1.);\n    vec2 pIK3 = pIK1T + solve(pIK2 - pIK1T, sc * 39.4, sc * 36.7, - 1.);\n    float a = atan(pIK3.y-pIK2.y, pIK3.x-pIK2.x);\n    vec2 pIK3T = pIK2 + sc * 49. * Dir(a + 1.73);\n    \n    // Point distances (could use dot then sqrt for better performance)\n    float d = length(uv);\n    m(p);\n    m(pRot);\n    m(pIK1);\n    m(pIK1T);\n    m(pIK2);\n    m(pIK3);\n    m(pIK3T);\n\n    // Segment distances\n    float d2 = 1e5;\n    l(vec2(0), pIK1);\n    l(vec2(0), pIK1T);\n    l(vec2(0), pIK2);\n    l(pIK1, pIK1T);\n    l(pIK1, pRot);\n    l(p, pRot);   \n    l(pIK2, pRot);    \n    l(pIK2, pIK3);\n    l(pIK2, pIK3T);\n    l(pIK1T, pIK3);\n    l(pIK3, pIK3T);    \n    \n    // Draw\n    float s = ss(1., 0.0125 - d);\n    float s2 = ss(1., 0.005 - d2);\n    return vec2(s, s2);\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    float t = iTime;\n    \n    float sc = 0.0058;\n    \n    vec3 col = vec3(0);\n    const float n = 2.;\n    for (float i = 0.; i < n; i++) {\n        float io = (i+1.) / n;\n        vec2 leg = drawLeg(uv, sc, t + io * pi);\n        vec3 cLeg = vec3(max(leg.x, leg.y), leg.xx);\n        col = max(col, io * cLeg);\n    }\n    \n    O = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}