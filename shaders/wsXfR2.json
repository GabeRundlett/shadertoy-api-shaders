{
    "Shader": {
        "info": {
            "date": "1588767448",
            "description": "A 3d black hole first try with rays\nMouse.X allows the user to ncrease or decrease the mass of the blackhole",
            "flags": 0,
            "hasliked": 0,
            "id": "wsXfR2",
            "likes": 2,
            "name": "Minimalist, Blackhole to present",
            "published": 3,
            "tags": [
                "noise",
                "blackhole",
                "hole",
                "dark"
            ],
            "usePreview": 0,
            "username": "Leria",
            "viewed": 306
        },
        "renderpass": [
            {
                "code": "#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t22.\n#define RAY_TRACING \t\t0\n#define GRAV_CONST\t\t\t6.674\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n    mat4 projection;\n \tvec3 pos; //position\n    vec3 focal_point; //focal point = target point\n    float vfov; //vertical fov\n};\n\nstruct BlackHole\n{\n    vec3 pos; //position\n    vec3 disk_normal;\n    float mass; //blackhole mass\n    float attraction_radius; //attraction radius of the blackhole\n    float inner_radius; //inner radius\n    float accretion_disk_radius; //accretion disk\n};\n\n///////////////////////////////////////////////\nBlackHole bh;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n//Transformations\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_black_hole(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tbh = BlackHole(pos, J, mass, radius, inner_rad, disk_rad);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\n//gravity stuff\nvoid space_time_bending(inout Ray r, inout vec3 p)\n{    \n\n    vec3 bh_vec = bh.pos - p;\n    float d = dot(bh_vec,bh_vec);\n    vec3 res = normalize(bh_vec) * (GRAV_CONST*bh.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + 0.05*res);\n}\n\nvoid init_black_hole(void)\n{\n \tset_black_hole(vec3(0., 0., -15.), iMouse.x/iResolution.y, RADIUS, 4., RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target, float theta /*degree*/)\n{\n    cam = Camera(mat4(1), pos, target, theta);\n}\n\nvoid init_camera(void)\n{\n    init_black_hole();\n    set_camera(vec3(0., 0., 30.), bh.pos, 60.); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\nfloat sdf_plane(vec3 pXp0, vec4 n)\n{\n\treturn dot(pXp0,n.xyz) + n.w ;   \n}\n\nfloat sdf_box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\nfloat sdf_torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 polar_coord(vec3 p)\n{\n    float phi = atan(p.x, p.z); //angle\n    float d_rad = length(vec2(p.x, p.z)); //delta radius\n    return vec2(d_rad*cos(phi), d_rad*sin(phi));\n}\n                 \nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    vec3 opacity, transmission;\n    \n    opacity = vec3(0.); transmission = vec3(1.);\n    \n    vec3 p = ray_interpolation(r, k*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3)))));\n    vec3 tmp = p;\n    float s = 0.;\n    \n    for(s; s < 2000.; s++)\n    {               \n        vec2 nu = polar_coord(p-bh.pos);\n        \n        if((length(nu) - bh.inner_radius >= 0.) && (length(nu)-bh.accretion_disk_radius <= 0.) && (distance(p.y, bh.pos.y) < .2))\n        {\n            vec4 tex = texture(iChannel0, p/8.+0.05*iTime);\n            float coef = length(p-bh.pos);\n        \tc += 0.1*tex.rrr*vec3(0.6, 0.3, 0.2);\n        }\n        \n        if(length(p) > 46.)\n        {\n        \tvec3 a = abs(r.dir);\n            float M = max(a.x, max(a.y, a.z));\n            vec2 u = M==a.x ? r.dir.yz : M==a.y ? r.dir.xz : r.dir.xy ;\n            \n           \tc += min(0.7*texture(iChannel1, (u/1.)).rgb*vec3(0.1, 0.1, 0.2), 0.7*texture(iChannel1, (u/1.)).rgb);\n            break;\n        }\n        \n        p += r.dir*k;\n        space_time_bending(r, p); //comment this line to see what's behind\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n    #if RAY_TRACING\n    vec3 point;\n    \n    if(intersect_disk(Ray(cam.pos, vec3(uv, -1.)), vec3(0., 0., -15.), vec3(-.25, 1., 0.), RADIUS, point))\n    {\n        vec4 tex = texture(iChannel0, point/16.+0.1*iTime);\n        color = tex.rrr*vec3(0.9, 0.5, 0.4);\n    }\n    \n    #else\n    vec3 ray_dir = vec3(uv, -1.);\n    bh.pos = normalize(vec3(-10, 20., bh.pos.z));\n    //float degree = mix(0., 10., iMouse.y);\n    ray_march_scene(Ray((vec4(cam.pos, 1.)*rotation_matrix(I, (-iMouse.y/40.)*PI/180.)).xyz, normalize(ray_dir)), .05, color);\n    #endif\n    \n    fragColor = vec4(color, 1.);\n}\n\n\n////////////////////////////////",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}