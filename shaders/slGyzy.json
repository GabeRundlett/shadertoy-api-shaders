{
    "Shader": {
        "info": {
            "date": "1661838224",
            "description": "This is an implementation of an animation from Craig S. Kaplan's \"Animated Color Mappings of Hinged Squares\" https://isohedral.ca/hinged-squares/ that appeared in the Bridges 2021 conference. Originally intended for golfing, but maybe I didn't succeed?",
            "flags": 0,
            "hasliked": 0,
            "id": "slGyzy",
            "likes": 27,
            "name": "Kaplan 5-Color Squares (634 ch)",
            "published": 3,
            "tags": [
                "loop",
                "squares",
                "golf",
                "reproduction",
                "swirled",
                "hinged"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 368
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Part of my Hinged Squares series:\n\n// Fathauer Hinged Squares    https://www.shadertoy.com/view/ftVyWw\n// Kaplan Hinged Squares      https://www.shadertoy.com/view/NtGcDm\n// Kaplan 5-Color Squares     https://www.shadertoy.com/view/slGyzy\n\n// This is the third and most complex of my hinged squares shaders. The question\n// this answers is, can you color the squares of the Kaplan Hinged Squares with\n// only five colors? Professor Kaplan figured out this beautiful way to do it,\n// and I hope he doesn't mind my shadertoy recreation.\n\n// https://isohedral.ca/hinged-squares/\n// https://archive.bridgesmathart.org/2021/bridges2021-23.pdf\n\n// I'm fairly pleased that I was able to get this down to 906 characters from the\n// the original's 2002. But it's still quite a hefty lad yet. I feel like there \n// are probably much more efficient ways to compute the diamonds and all the colors,\n// but I just haven't figured it out.\n\n// OTOH this is probably bordering on being a bit too complex for fun golfing,\n// so I won't be offended if the usual gang decides to skip this one.\n\n//*\n// From SnoothethDuckDuck: 634 chars (-212!)\n#define C(i) vec4[](vec4(1, .6, .2, 1),  \\\n                    o-o,                 \\\n                    vec4(.9, .2, .2, 1), \\\n                    o/o,                 \\\n                    vec4(0, .6, .5, 1))  \\\n                    [int(i) % 5]\n\nvoid mainImage( out vec4 o, vec2 u )\n{   \n    float x,\n          y, \n          a = modf(iTime * .3, x) * .78,\n          m = cos(a)*.2,\n          n = sin(a)*.2,\n          c = 4.*m*n+.2; // double angle formula\n    \n    o.xyz = 1./iResolution;\n    \n    u = (2./o.xy - 4.*u) * o.y * (mod(x, 2.) - .5) \n      + vec2(sin(4.*a) * .04 + .1, -.1) \n      - 5.*m*n;\n    \n    mat2 M = mat2(cos(vec4(0,11,33,0) - a));\n    u *= M;\n      \n    vec2 D = mod(.5*u/c, 5.),\n         b = mod(u = mod(u, c+c), c) - .5*c,         \n         r = round(D), // floor(D + .5)\n         f = floor(D),\n         A = abs(u - c);\n    \n    x = A.x, y = A.y;\n    o = mix(\n        // color 1\n        C(\n          y > c-m && x > c-n ? 4.5  + r.y + D+r+r \n          : \n          y < m   && x < n   ? 12.  + f.y - D-f\n          : \n          x < m   && y > c-n ? 3.   + r.y + D+f+f \n          : \n          x > c-m && y < n   ? 12.5 + f.y - D-r\n          : \n          u/u\n        ), \n        \n        // color 2\n        C(4 * int(D+=D) + 8 * int(D.y)),\n        \n        // mix amount\n        smoothstep(o.y, -o.y,\n        length(max(u = abs(u.x>c ^^ u.y>c ? b * M : M * b) - .1, 0.)) \n      + max(u.x, u.y)));\n}\n\n\n// From fenix: 846 chars (-60)\n/*\n#define C(i) vec4[](vec4(1, .6, .2, 1),vec4(0),vec4(.9, .2, .2, 1),vec4(1),vec4(0, .6, .5, 1))[(i) % 5]\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = 1./iResolution;\n    float i, a = modf(iTime * .3, i) * .78; // .78 = PI / 4\n          \n    u = (2./R.xy - 4.*u) * R.y * (mod(i, 2.) - .5) + vec2(sin(a * 4.) * .04 + .1, -.1) - sin(a + a) * .1;\n        \n    mat2 M = mat2(cos(vec4(0,11,33,0) - a));\n    u *= M;\n    \n    float c = abs(sin(a + a)) * .08 + .2,\n          m = cos(a)*.2,\n          n = sin(a)*.2;\n    \n    vec2 D = mod(u / (c+c), 5.),\n         q = u = mod(u, c+c),\n         b = mod(u, c) - c * .5;\n\n    O = mix(\n        ((q.y < m || q.y > c+c - m) && (q.x < n || q.x > c+c - n)) ?\n            C(int(D.y + 3.5) + int(D.x + 2.5) * 3) :\n        (q.y - c > -m && q.y - c < m && q.x - c > -n && q.x - c < n) ?\n            C((int(7. - D.y) * 2 + int(5. - D.x) + 2) * 2) :\n        (q.x - c > -m && q.x - c < m) && (q.y < n || q.y > c+c - n) ?\n            C(int(D.y + 2.5) + int(D.x + 2.) * 3) :\n        ((q.x < m || q.x > c+c - m) && (q.y - c > -n && q.y - c < n)) ?\n            C((int(8. - D.y) * 2 + int(7.5 - D.x)) * 2) : C(1),\n            \n        C(int(mod(D.x*-2., 5.)) + 3 * int(mod(D.y+D.y, 5.)) + 1),\n               smoothstep(-R.y, R.y,\n               -length(max(q = abs(u.x > c ^^ u.y > c ? b * M : M * b) - .1,0.)) - min(max(q.x,q.y),0.)));\n}\n*/\n\n// My first attempt at golfing this shader: 906 chars\n/* \nvec3 C[5] = vec3[](\n    vec3(1., .6, .2),\n    vec3(0),\n    vec3(.9, .2, .2),\n    vec3(1),\n    vec3(0., .6, .5));\n\n#define M mat2(cos(-a), sin(-a), -sin(-a), cos(-a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = 1./iResolution;\n    float a = mod(iTime * .3, 1.57); // 1.57 = PI / 2\n          \n    u = vec2(R.y / R.x, 1.) - 2.*u * R.y;\n    \n    if (a > .78) u = -u, a -= .78; // .78 = PI / 4\n         \n    u += vec2(sin(a * 4.) * .04 + .1, -.1) - sin(a + a) * .1;\n    u *= M;\n    \n    float c = abs(sin(a + a)) / 12.5 + .2,\n          m = cos(a)*.2,\n          n = sin(a)*.2;\n    \n    vec2 e, D = mod(u / (c+c), 5.),\n         q = u = mod(u, c+c);\n\n    a = u.x > c ^^ u.y > c ? -a : a;\n    u = mod(u, c);\n\n    // Lay down the colors for the diamonds\n    O = vec4(\n        ((q.y < m || q.y > c+c - m) && (q.x < n || q.x > c+c - n)) ?\n            C[(int(D.y + 3.5) + int(D.x + 2.5) * 3) % 5] :\n        (q.y - c > -m && q.y - c < m && q.x - c > -n && q.x - c < n) ?\n            C[(int(7. - D.y) * 2 + int(5. - D.x) + 2) * 2 % 5] :\n        (q.x - c > -m && q.x - c < m) && (q.y < n || q.y > c+c - n) ?\n            C[(int(D.y + 2.5) + int(D.x + 2.) * 3) % 5] :\n        ((q.x < m || q.x > c+c - m) && (q.y - c > -n && q.y - c < n)) ?\n            C[(int(8. - D.y) * 2 + int(7.5 - D.x)) * 2 % 5] : C[1], 0.0);\n    \n    e = abs(M * (u - c * .5)) - .1;\n    \n    // Add the squares on top\n    O.xyz = mix(O.xyz,\n                C[(int(mod(D.x*-2., 5.)) + 3 * int(mod(D.y+D.y, 5.)) + 1) % 5],\n                smoothstep(-R.y, R.y, -length(max(e,0.)) - min(max(e.x,e.y),0.)));\n}\n*/\n\n/* Original, pre-golf: 2002 characters\nvec3 colors[5] = vec3[](vec3(251.0, 176.0, 64.0) / 255.0, vec3(0.0, 0.0, 0.0), vec3(239.0, 65.0, 54.0) / 255.0, vec3(1.0, 1.0, 1.0), vec3(0.0, 167.0, 156.0) / 255.0);\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rotAng(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nconst float PI = 3.141592653589793;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n    float a = mod(iTime * 0.3, PI * 0.5);\n    if (a < PI * 0.25) p = -p;\n    a = mod(a, PI * 0.25);\n    \n    float a0 = a;\n     \n    p -= sin(a + a) * 0.1;\n    p.x += sin(a* 4.) * 0.04;\n    p += vec2(0.1, -0.1);\n    p *= rotAng((-a));\n    vec2 center = abs(vec2(sin(a + a))) / 25.0 + 0.1;\n\n    vec2 pa = p;\n    p = mod(p, 4.0 * center);\n    vec2 p0 = p;\n    if (p.x > 2.0 * center.x)\n    {\n        p.x -= 2.0 * center.x;\n        a = -a;\n    }\n    if (p.y > 2.0 * center.x)\n    {\n        p.y -= 2.0 * center.x;\n        a = -a;\n    }\n    mat2 r = rotAng(-a);\n    \n    if (p0.y < cos(a0)*0.2 || p0.y > center.x* 4. - cos(a0)*0.2)\n    {\n        vec3 dColor = colors[(int(mod(pa.y * 2.5/(10.*center), 5.) + 3.5)\n        + int(mod(pa.x * 2.5/(10.*center), 5.) + 2.5) * 3) % 5];\n        if (p0.x <= sin(a0)*0.2 || p0.x >= center.x * 4. - sin(a0)*0.2) fragColor.xyz = dColor;\n    }\n    if (p0.y - center.x*2. >= -cos(a0)*0.2 && p0.y - center.x*2. <= cos(a0)*0.2)\n    {\n        vec3 dColor = colors[(int(mod(pa.y * -2.5/(10.*center) + 2., 5.))*2 +\n        int(mod(pa.x * -2.5/(10.*center), 5.))+ 2)*2 % 5];\n        if (p0.x - center.x*2. >= -sin(a0)*0.2 && p0.x - center.x*2. <= sin(a0)*0.2) fragColor.xyz = dColor;\n    }\n    if (p0.x - center.x*2. > -cos(a0)*0.2 && p0.x - center.x*2. < cos(a0)*0.2)\n    {\n        vec3 dColor = colors[(int(mod(pa.y * 2.5/(10.*center), 5.) + 2.5)\n        + int(mod((pa.x - center.x*2.) * 2.5/(10.*center), 5.) + 2.5) * 3) % 5];\n        if (p0.y <= sin(a0)*0.2 || p0.y >= center.x * 4. - sin(a0)*0.2) fragColor.xyz = dColor;\n    }\n    \n    if (p0.x < cos(a0)*0.2 || p0.x > center.x*4. - cos(a0)*0.2)\n    {\n        vec3 dColor = colors[(int(mod(pa.y * -2.5/(10.*center) + 3., 5.))*2 +\n        int(mod((pa.x - center.x*2.) * -2.5/(10.*center), 5.))+ 2)*2 % 5];\n        if (p0.y - center.x*2. >= -sin(a0)*0.2 && p0.y - center.x*2. <= sin(a0)*0.2) fragColor.xyz = dColor;\n    }\n    \n    vec3 blockColor = colors[(int(mod(pa.x * -5. / (10. * center), 5.)) + 3*int(mod(pa.y * 5./(10.*center), 5.)) + 1) % 5];//0.5 + vec3(0.5)*inv;\n    fragColor.xyz = mix(fragColor.xyz, blockColor, smoothstep(-0.001, 0.001, -sdBox(r * (p - center), vec2(0.1))));\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}