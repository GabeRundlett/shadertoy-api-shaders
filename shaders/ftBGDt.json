{
    "Shader": {
        "info": {
            "date": "1624915608",
            "description": "Messing with [url=https://www.shadertoy.com/view/7ljGDc]https://www.shadertoy.com/view/7ljGDc[/url]. Also eliminated all the trigonometry (not much difference on a fast GPU, maybe in other contexts though). Left side: original, right side: trigless.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftBGDt",
            "likes": 18,
            "name": "Polygon Interpolation (Trigless)",
            "published": 3,
            "tags": [
                "test",
                "barycentric",
                "polygon",
                "interpolation",
                "meanvaluecoordinates",
                "trigless"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 326
        },
        "renderpass": [
            {
                "code": "// Try clicking with the mouse to see the weights interpolate it\n// back to its original position (purple is the original position,\n// green is the interpolated position, both should align)\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) (0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0)))\n\n// Number of vertices\n#define N 6\n\n// Trigless version\nvoid polyLerpWeightsTrigless(in vec2 p, in vec2[N] poly, out float[N] weights) {\n    float norm = 0.0;\n    for(int n = 0; n < N; n++) {\n        vec2 a = poly[(n - 1 + N) % N] - p;\n        vec2 b = poly[n] - p;\n        vec2 c = poly[(n + 1) % N] - p;\n\n        float d = length(b);\n        float ab = dot(a, b), bc = dot(b, c), ad = length(a) * d, dc = d * length(c);\n        float u = sqrt(max(0.0, (ad - ab) / (ad + ab))) * sign(a.x * b.y - a.y * b.x);\n        float v = sqrt(max(0.0, (dc - bc) / (dc + bc))) * sign(b.x * c.y - b.y * c.x);\n\n        weights[n] = (u + v) / d;\n        norm += weights[n];\n    }\n\n    for(int n = 0; n < N; n++) weights[n] /= norm;\n}\n\n// Original (slightly modified to match the interface of the trigless one)\nfloat cr2(vec2 A, vec2 B) {\n    return A.x*B.y-A.y*B.x;\n}\n\nfloat getAngle(vec2 A, vec2 B) {\n    return atan(cr2(A, B), dot(A, B));\n}\n\nvoid polyLerpWeightsOriginal(in vec2 p, in vec2[N] poly, out float[N] weights) {\n    vec2 vi, vi_min1, vi_plus1;\n    float sumweights = 0.0;\n    float ang1, ang2;\n    float t1, t2;\n    vec2 vi_p;\n    \n    for(int i = 0; i < N; i++) {\n        vi = poly[i];\n        vi_min1 = poly[(i-1 + N) % N];\n        vi_plus1 = poly[(i+1) % N];\n        vi_p = normalize(vi-p);\n        \n        \n        //ang1 = acos(dot(normalize(vi_min1-p), vi_p));\n        //ang2 = acos(dot(normalize(vi_plus1-p), vi_p));\n        ang1 = getAngle(normalize(vi_min1-p), vi_p);\n        ang2 = getAngle(vi_p, normalize(vi_plus1-p));\n        \n        \n        t1 = tan(ang1*0.5);\n        t2 = tan(ang2*0.5);\n        weights[i] = (t1 + t2) / distance(vi, p);\n        sumweights += weights[i];\n    }\n    \n    //normalize\n    float recp = 1.0/sumweights;\n    for(int i = 0; i < N; i++) {\n        weights[i] *= recp;\n    }\n}\n\n// Simple point in polygon test extracted from @iq's polygon\n// distance shader: https://www.shadertoy.com/view/wdBXRW\nbool pointInPolygon(in vec2 p, in vec2[N] v) {\n    bool res = false;\n    for (int i=0, j=N - 1; i < N; j = i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n\n        // Winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 c = bvec3(p.y >= v[i].y, p.y < v[j].y, e.x * w.y > e.y * w.x);\n        if (all(c) || all(not(c))) res = !res;  \n    }\n    \n    return res;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = 0.5 * iTime;\n    vec3 color = vec3(1.0);\n\n    vec2[N] poly;\n    poly[0] = vec2(1.0, 0.0);\n    poly[1] = vec2(0.5, sqrt(0.75));\n    poly[2] = vec2(-0.5, poly[1].y);\n    poly[3] = vec2(-1.0, 0.0);\n    poly[4] = vec2(-0.5, -poly[1].y);\n    poly[5] = vec2(0.5, -poly[1].y);\n\n    // Distort the vertices\n    for (int n=0; n < N; n++) {\n        float id = float(n + 3);\n        float freq = Hash11(id * 393.84) * 10.0 - 5.0;\n        float phase = Hash11(id * 183.37);\n        float amp = Hash11(id * 275.35) * 2.0;\n        float ang = iTime * freq + phase;\n        poly[n] += vec2(cos(ang), sin(ang)) * amp;\n        poly[n] *= 0.25;\n    }\n\n    if (pointInPolygon(uv, poly)) {\n        // Compute interpolation weights\n        float[N] weights1, weights2;\n        polyLerpWeightsOriginal(uv, poly, weights1);\n        polyLerpWeightsTrigless(uv, poly, weights2);\n\n        // Interpolate colors from vertices\n        vec3 polyLerp = vec3(0.0);\n        float side = step(0.0, uv.x); // Which side of the screen (left: 0, right: 1)\n        for (int n=0; n < N; n++) polyLerp += hue2rgb(float(n) / float(N)) * mix(weights1[n], weights2[n], side);\n        color = polyLerp;\n    }\n\n    // Get distance to edges\n    float d = 1000000.0;\n    for (int n=0; n < N; n++) d = min(d, sdLine(uv, poly[n], poly[(n + 1) % N]));\n\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, d));\n\n    if (iMouse.z > 0.0) {\n        // Compute weights for the mouse position\n        float[N] weights;\n        polyLerpWeightsTrigless(mouse, poly, weights);\n\n        // Exact mouse position (to test)\n        float distMouse = length(uv - mouse) - 0.015;\n        color = mix(color, vec3(0.6, 0.0, 0.8), smoothstep(unit, 0.0, distMouse));\n        color = mix(color, vec3(0.0), smoothstep(unit, 0.0, abs(distMouse))); // Outline\n\n        // Test to see if it interpolates back to its original position\n        vec2 mouseLerp = vec2(0.0);\n        for (int n=0; n < N; n++) mouseLerp += poly[n] * weights[n];\n\n        float distMouseLerp = length(uv - mouseLerp) - 0.015;\n        color = mix(color, vec3(0.0, 0.8, 0.6), smoothstep(unit, 0.0, distMouseLerp));\n        color = mix(color, vec3(0.0), smoothstep(unit, 0.0, abs(distMouseLerp))); // Outline\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}