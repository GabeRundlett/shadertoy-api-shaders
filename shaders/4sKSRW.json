{
    "Shader": {
        "info": {
            "date": "1463213220",
            "description": "lifecycle of mushrooms using cellular automata in a buffer shader\nTODO: make them look like mushrooms",
            "flags": 32,
            "hasliked": 0,
            "id": "4sKSRW",
            "likes": 1,
            "name": "mushroom kingdom",
            "published": 3,
            "tags": [
                "raytrace",
                "mushroom",
                "cellularautomata"
            ],
            "usePreview": 0,
            "username": "objelisks",
            "viewed": 814
        },
        "renderpass": [
            {
                "code": "// lighting stuff mostly taken from iq examples\n\nconst float EPSILON = 0.01;\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// helper function to create a 3d rotation matrix.\nmat3 rotateX(float angle) {\n    float ca = cos(angle);\n    float sa = sin(angle);\n\treturn mat3(1, 0, 0,  0, ca, -sa,  0, sa, ca);\n}\n\n// helper function to create a 3d rotation matrix.\nmat3 rotateY(float angle) {\n    float ca = cos(angle);\n    float sa = sin(angle);\n\treturn mat3(ca, 0, sa,  0, 1, 0,  -sa, 0, ca);\n}\n\nvec4 u(in vec4 a, in vec4 b) {\n    if(a.w < b.w) {\n\t\treturn a;\n    } else {\n\t\treturn b;\n    }\n}\n\nvec3 rep(in vec3 p, in vec3 c) {\n    vec3 q = mod(p, c) - 0.5*c;\n    return q;\n}\n\nvec4 mushroom(in vec3 pos) {\n    vec3 q = pos + vec3(0,1.0,0);\n    vec2 mushCoord = floor(q.xz) + iChannelResolution[0].xy/2.0;\n    vec4 mushMap = texture(iChannel0, mushCoord/iChannelResolution[0].xy);\n\treturn vec4(vec3(1,1,1), sdSphere(rep(q, vec3(1.0, 0, 1.0)), mushMap.r*0.3));\n}\n\n\nvec4 scene(in vec3 pos) {\n    return u(vec4(vec3(0.2,0.3,0.02), sdPlane(pos, normalize(vec4(0,1.0,0,1.0)))),\n            mushroom(pos));\n}\n\nvec3 n( in vec3 pos )\n{\n    vec2  eps = vec2( EPSILON, 0.0 );\n    return normalize( vec3( scene(pos+eps.xyy).w - scene(pos-eps.xyy).w,\n                            scene(pos+eps.yxy).w - scene(pos-eps.yxy).w,\n                            scene(pos+eps.yyx).w - scene(pos-eps.yyx).w ) );\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).w;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).w;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nvec3 lighting(in vec3 pos, in vec3 nor, in vec3 rd, inout vec3 col, in float t) { \n    vec3 ref = reflect( rd, nor );\n    \n    float occlusion = calcAO( pos, nor );\n    vec3  light = normalize( vec3(-0.6, 0.7, -0.5) );\n    float ambient = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float diffuse = clamp( dot( nor, light ), 0.0, 1.0 );\n    float backlight = clamp( dot( nor, normalize(vec3(-light.x,0.0,-light.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fresnel = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float specular = pow(clamp( dot( ref, light ), 0.0, 1.0 ),16.0);\n\n    diffuse *= softshadow( pos, light, 0.02, 2.5 );\n    dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 lightIn = vec3(0.0);\n    lightIn += 1.20*diffuse*vec3(1.00,0.85,0.55);\n    lightIn += 1.20*specular*vec3(1.00,0.85,0.55)*diffuse;\n    lightIn += 0.20*ambient*vec3(0.50,0.70,1.00)*occlusion;\n    lightIn += 0.00*dom*vec3(0.50,0.70,1.00)*occlusion;\n    lightIn += 0.60*backlight*vec3(0.25,0.25,0.25)*occlusion;\n    lightIn += 0.40*fresnel*vec3(1.00,1.00,1.00)*occlusion;\n    col = col*lightIn;\n\n    col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.2*t*t ) );\n\n    return col;\n}\n\nvec3 material(in vec3 col, in vec3 pos, in vec3 dir, in float d) {\n    return lighting(pos, n(pos), dir, col, d);\n}\n\nvec3 render(in vec3 o, in vec3 dir) {\n    vec3 background = vec3(0,0,0);\n    \n    float t = EPSILON;\n    for(int i=0; i<256; i++) {\n    \tvec3 pos = o + t*dir;\n        vec4 hit = scene(pos);\n        float dist = hit.w;\n        if(dist < EPSILON) return material(hit.xyz, pos, dir, dist);\n        t += 0.5 * dist;\n    }\n    \n    return background;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    vec3 origin = vec3(0, 0, 5.0);\n    vec3 dir = normalize(vec3(uv, -2.0));\n    \n    //mat3 rotation = rotateX(0.5) * rotateY(0.1);\n    //mat3 mouseRotation = rotateX(iMouse.y / iResolution.y * 3.1415 * 3.0) * rotateY(iMouse.x / iResolution.x * 3.1415 * 3.0);\n    mat3 mouseRotation = rotateX(-0.5) * rotateY(iMouse.x / iResolution.x * 3.1415 * 3.0);\n    \n    origin *= mouseRotation;\n    dir *= mouseRotation;\n    \n    vec3 color = render(origin, dir);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 coord(vec2 frag, int x, int y) {\n    return (frag + vec2(float(x), float(y)))/iChannelResolution[0].xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if(iTime < 0.1) {\n     \tfragColor = vec4((rand(fragCoord) > 0.5) ? 1.0 : 0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    vec4 current = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    \n    // only update every tenth frame\n    if(current.b < 1.0) {\n        current.b += 0.1;\n    \tfragColor = current;\n    \treturn;\n    }\n    \n    // simulation\n    float neighbors = 0.5;\n    neighbors += texture(iChannel0, coord(fragCoord, -1, -1)).r;\n    neighbors += texture(iChannel0, coord(fragCoord, -1,  0)).r;\n    neighbors += texture(iChannel0, coord(fragCoord, -1,  1)).r;\n    neighbors += texture(iChannel0, coord(fragCoord,  0, -1)).r;\n    neighbors += texture(iChannel0, coord(fragCoord,  0,  1)).r;\n    neighbors += texture(iChannel0, coord(fragCoord,  1, -1)).r;\n    neighbors += texture(iChannel0, coord(fragCoord,  1,  0)).r;\n    neighbors += texture(iChannel0, coord(fragCoord,  1,  1)).r;\n    \n    float cell = 0.0;\n    cell += neighbors < 2.0 ? -1.0 : 0.0; // kill\n    cell += (neighbors > 2.0 && neighbors < 4.0) ? 1.0 : 0.0; // live\n    cell += neighbors > 4.0 ? -1.0 : 0.0; // kill\n    \n    if(current.r > 0.5) {\n    \tcell = cell > 0.5 ? 1.0 : 0.0;\n    } else {\n     \tcell = (neighbors > 3.0 && neighbors < 4.0) ? 1.0 : 0.0;   \n    }\n    \n    fragColor = vec4(cell, 0, 0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}