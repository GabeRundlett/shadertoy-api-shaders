{
    "Shader": {
        "info": {
            "date": "1710138123",
            "description": "I originally published this to GLSL Sandbox. See top of shader source.\n    https://glslsandbox.com/e#18320.0\n\nZooming through fractal.",
            "flags": 0,
            "hasliked": 0,
            "id": "M3fXWl",
            "likes": 7,
            "name": "Playing with Kaleidoscopic IFS",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "loop"
            ],
            "usePreview": 0,
            "username": "mgattis",
            "viewed": 185
        },
        "renderpass": [
            {
                "code": "// Matthew Gattis, 11 Mar 2024 - Fixed\n// I have revisited this shader after all of these years.\n// I think I published this in like the 2012-2015 time frame.\n// Anyway, I fixed the artifacting. Well, I modified some code from Inigo Quilez.\n//     https://iquilezles.org/articles/sdfrepetition/\n// I also, uh, made a few other changes. Cleaned up the code.\n\n// MG - Playing with Kaleidoscopic IFS\n// http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-(escape-time-ifs)/\n// http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\n// If you know how to fix that artifacting, don't keep it to yourself.\n// It comes as a result of modulo.\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define M_PI                (3.1415926535897932384626433832795)\n\n#define MIN_DELTA       (0.01 / iResolution.y)\n#define MAX_DELTA       (2.0 / iResolution.y)\n#define MAX_DISTANCE    (3.0)\n\n#define MAX_ITERATIONS  (32)\n\nstruct surface\n{\n    int object;\n    int iteration;\n};\n\n// ----------------------------------------------------------------------------\n// I don't know where these came from. But thanks to whoever wrote these.\nvec3 vRotateX(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c*p.y+s*p.z, -s*p.y+c*p.z);\n}\n\nvec3 vRotateY(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x-s*p.z, p.y, s*p.x+c*p.z);\n}\n\nvec3 vRotateZ(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z);\n}\n\n// ----------------------------------------------------------------------------\n// Kaleidoscopic (escape time) IFS\n// knighty\n// http://www.fractalforums.com/sierpinski-gasket/kaleidoscopic-(escape-time-ifs)/\n#define FRACT_ITER      (20)\n#define FRACT_SCALE     (1.8)\n#define FRACT_OFFSET    (1.0)\nfloat DE(vec3 z)\n{\n    float c = 2.0;\n    //z.y = mod(z.y, c)-c/2.0;\n\n    z = vRotateZ(z, M_PI/2.0);\n\n    float r;\n    int n1 = 0;\n    for (int n = 0; n < FRACT_ITER; n++) {\n        float rotate = M_PI*0.5;\n        z = vRotateX(z, rotate);\n        z = vRotateY(z, rotate);\n        z = vRotateZ(z, rotate);\n\n        z.xy = abs(z.xy);\n        if (z.x+z.y<0.0) z.xy = -z.yx; // fold 1\n        if (z.x+z.z<0.0) z.xz = -z.zx; // fold 2\n        if (z.y+z.z<0.0) z.zy = -z.yz; // fold 3\n        z = z*FRACT_SCALE - FRACT_OFFSET*(FRACT_SCALE-1.0);\n    }\n    return (length(z) ) * pow(FRACT_SCALE, -float(FRACT_ITER));\n}\n\n// ----------------------------------------------------------------------------\n// domain repetition - 2008, 2013, 2023\n// Inigo Quilez\n// https://iquilezles.org/articles/sdfrepetition/\n// p, input position\n// s, scale/size\n// returns, distance to surface\nfloat repeated( vec3 p, float s )\n{\n    float id = floor(p.y/s + 0.5);\n    float  o = sign(p.y-s*id); // neighbor offset direction\n    \n    float d = 1e20;\n    for( int i=0; i<2; i++ )\n    {\n        float rid = id + float(i)*o;\n        vec3 r = vec3(p.x, p.y - s*rid, p.z);\n        d = min( d, DE(r) );\n    }\n    return d;\n}\n\n// ----------------------------------------------------------------------------\n// p, input position\n// o, output surface params\n// returns, distance to surface\nfloat getMap(in vec3 p, out surface o)\n{\n    o = surface(\n        0,\n        1);\n\n    return repeated(p, 2.0);\n}\n\n// ----------------------------------------------------------------------------\n// p, input position\n// returns, normal of closest surface\nvec3 getNormal(in vec3 p)\n{\n    float h = MIN_DELTA;\n    surface o;\n    return normalize(vec3(\n        getMap(p + vec3(h, 0.0, 0.0), o) - getMap(p - vec3(h, 0.0, 0.0), o),\n        getMap(p + vec3(0.0, h, 0.0), o) - getMap(p - vec3(0.0, h, 0.0), o),\n        getMap(p + vec3(0.0, 0.0, h), o) - getMap(p - vec3(0.0, 0.0, h), o)));\n}\n\n// ----------------------------------------------------------------------------\n// p, input position\n// d, input ray direction\n// o, output surface params\n// returns, distance to surface\nfloat castRay(in vec3 p, in vec3 d, out surface o)\n{\n    float distance = 0.0;\n    vec3 position = p;\n\n    for (int i = 0; i < MAX_ITERATIONS; i++)\n    {\n        float delta = getMap(p + distance * d, o);\n        distance += delta;\n\n        if (distance > MAX_DISTANCE)\n        {\n            o.object = 0;\n            o.iteration = i;\n            return MAX_DISTANCE;\n        }\n\n        float m = mix(MIN_DELTA, MAX_DELTA, distance / MAX_DISTANCE);\n\n        if (delta < m)\n        {\n            o.iteration = i;\n            return distance;\n        }\n    }\n\n    o.object = 0;\n    o.iteration = MAX_ITERATIONS;\n    return MAX_DISTANCE;\n}\n\n// ----------------------------------------------------------------------------\n// Palettes\n// Inigo Quilez\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = fragCoord / iResolution.y * 2.0;\n    p -= vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec3 origin = vec3(0.0, -mod(iTime * 0.1, 2.0) + 1.0, 0.0);\n    vec3 direction = normalize(vec3(p, 1.0));\n    direction = vRotateZ(direction, iTime * 0.1);\n    direction = vRotateX(direction, -M_PI / 2.0);\n\n    surface object;\n    float distance = castRay(origin, direction, object);\n    \n    float cheap_ao = 1.0 - float(object.iteration) / float(MAX_ITERATIONS);\n\n    // https://www.shadertoy.com/view/ll2GD3\n    // Line 28\n    vec3 color = pal(\n        pow(cheap_ao, 0.6),\n        vec3(0.5, 0.5, 0.5),\n        vec3(0.5, 0.5, 0.5),\n        vec3(1.0, 1.0, 1.0),\n        vec3(0.0, 0.10, 0.20));\n\n    color = mix(vec3(0.0), color, cheap_ao);\n\n    color = pow(\n        clamp(color, vec3(0.0), vec3(1.0)),\n        vec3(1.0 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}