{
    "Shader": {
        "info": {
            "date": "1646281613",
            "description": "Visualization of the Julia sets. The Mandelbrot set is pulsating in green behind and you can use the mouse the change the Julia set.",
            "flags": 0,
            "hasliked": 0,
            "id": "NsBfWW",
            "likes": 1,
            "name": "Julia  sets",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "mandelbrot",
                "julai"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 202
        },
        "renderpass": [
            {
                "code": "#define ITIME iTime*.1\n#define AA 2\nconst int maxIterations = 50;\nvec2 complexMul(vec2 a, vec2 b){\n    return vec2(\n              a.x*b.x - a.y * b.y,\n              2. * a.x * b.y\n            );\n}\n\nint julia(vec2 z, vec2 c){\n    for (int i=0;i<maxIterations;i++){\n        z = complexMul(z, z) + c;\n        if (length(z) > 1000.)\n            return i;\n    }\n    return -1;\n}\n\n//---------------------------------------------------------------------------\n//1D Perlin noise implementation from https://www.shadertoy.com/view/lt3BWM\n//---------------------------------------------------------------------------\n#define HASHSCALE 0.1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\n//------------------------------------------------------------------------------\n\nvec3 render(vec2 uv){\n    //Evaluate perlin noise to dertmine c\n    vec2 c = vec2(perlinNoise1D(ITIME), perlinNoise1D(ITIME+10.1231));\n    //Use mouse input if mb1 is held\n    if (iMouse.z > 0.){\n        c = (iMouse.xy/iResolution.xy-0.5)*3.;\n        c.x *= iResolution.x / iResolution.y;\n    }\n    \n    int j = julia(uv, c);\n    //Mandelbrot uses the same function as the julia sets\n    int m = julia(vec2(0), uv);\n    \n    vec3 col = pow(vec3(smoothstep(float(maxIterations)*0.01, float(maxIterations)*0.6, float(j))), vec3(.2,1.,.01));\n    col.y = float(m)/float(maxIterations)*sin(iTime);\n    col.y += 0.01/distance(c,uv)*smoothstep(-1.5,1.,sin(iTime*2.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 col = vec3(0);\n    \n    //AA\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = ((fragCoord+o)/iResolution.xy-0.5)*3.;\n        uv.x *= iResolution.x / iResolution.y;\n        //Draw\n        col += render(uv)/float(AA*AA);\n    }}\n\n\n    // Output to screen\n    fragColor = vec4 (col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}