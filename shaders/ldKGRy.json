{
    "Shader": {
        "info": {
            "date": "1456056602",
            "description": "Quite simple one, just for practicing\nImplement full Disney's (GTR) BRDF\n\n3b: [url]https://www.shadertoy.com/view/lsGGR3[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "ldKGRy",
            "likes": 1,
            "name": "Ray Marching Practice 4",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Takoa",
            "viewed": 529
        },
        "renderpass": [
            {
                "code": "// Sphere with Disney's (GTR) BRDF\n// \n// Notes: http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n//------------------------------------------------------------------\n//\n// ALL parts surrounded by \"/* Begin Disney's */\" and /* End Disney's */ are from Disney's codes\n// (https://github.com/wdas/brdf) which are licensed under the license below.\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n// Copyright Disney Enterprises, Inc.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License\n// and the following modification to it: Section 6 Trademarks.\n// deleted and replaced with:\n//\n// 6. Trademarks. This License does not grant permission to use the\n// trade names, trademarks, service marks, or product names of the\n// Licensor and its affiliates, except as required for reproducing\n// the content of the NOTICE file.\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n// Note: Disney's codes are slightly modified for compilability, readability, etc.\n\n#define PI 3.141592653\n#define INV_PI 0.3183098861\n#define GAMMA 2.2\n#define INV_GAMMA 0.4545454545\n\n#define EPSILON 0.0001\n\nvec3 sphereColor = vec3(0.3, 0.9, 0.6);\n\nvec3 cameraPosition = vec3(0.0, 0.0, 2.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraLookingAt = vec3(0.0, 0.0, -100.0);\n\nfloat roughness = 0.3; // Surface roughness, controls both diffuse and specular response.\nfloat subsurface = 0.0; // Controls diffuse shape using a subsurface approximation.\nfloat sheen = 0.0; // An additional grazing component, primarily intended for cloth.\nfloat sheenTint = 0.0; // Amount to tint sheen towards base color.\nfloat specular = 0.5; // Incident specular amount. This is in lieu of an explicit index-of-refraction.\nfloat specularTint = 0.0; // A concession for artistic control that tints incident specular towards the base color. Grazing specular is still achromatic.\nfloat metallic = 0.0; // The metallic-ness (0 = dielectric, 1 = metallic). This is a linear blend between two different models. The metallic model has no diffuse component and also has a tinted incident specular, equal to the base color.\nfloat anisotropic = 0.0; // Degree of anisotropy. This controls the aspect ratio of the specular highlight. (0 = isotropic, 1 = maximally anisotropic.)\nfloat clearcoat = 0.0; // A second, special-purpose specular lobe.\nfloat clearcoatGloss = 1.0; // Controls clearcoat glossiness (0 = a \\satin\" appearance, 1 = a \\gloss\" appearance).\n\nfloat getDistanceToSphere(vec3 rayPosition, vec3 spherePosition, float radius)\n{\n    return length(spherePosition - rayPosition) - radius;\n}\n\nfloat getDistance(vec3 position)\n{\n    return min(\n        getDistanceToSphere(position, vec3(-0.5, 0.0, 0.0), 1.0),\n        getDistanceToSphere(position, vec3(0.5, 0.0, 0.0), 1.0));\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n          getDistance(p + vec3(EPSILON, 0.0, 0.0)) - getDistance(p - vec3(EPSILON, 0.0, 0.0)),\n          getDistance(p + vec3(0.0, EPSILON, 0.0)) - getDistance(p - vec3(0.0, EPSILON, 0.0)),\n          getDistance(p + vec3(0.0, 0.0, EPSILON)) - getDistance(p - vec3(0.0, 0.0, EPSILON))\n        ));\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 rayRight = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * rayRight + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nfloat rayMarch(inout vec3 p, vec3 rayDirection)\n{\n    float d;\n    \n    for (int i = 0; i < 128; i++)\n    {\n        d = getDistance(p);\n        p += d * rayDirection;\n    }\n    \n    return d;\n}\n\nfloat sq(float f)\n{\n    return f * f;\n}\n\nfloat getSchlicksApproximation(float f)\n{\n    float g = clamp(1.0 - f, 0.0, 1.0);\n    float g2 = g * g;\n    \n    return g2 * g2 * g;\n}\n\nfloat gtr1(float cosThH, float roughness2)\n{\n    float roughness2M1 = roughness2 - 1.0;\n    \n    return roughness2M1 / (PI * log(roughness2) * (1.0 + roughness2M1 * cosThH * cosThH));\n}\n\nfloat gtr2WithAnisotropy(vec3 tangent, vec3 binormal, vec3 halfVector, float cosThH, float roughness2)\n{\n    float aspect = sqrt(1.0 - 0.9 * anisotropic);\n    float aspectX = roughness2 / aspect;\n    float aspectY = roughness2 * aspect;\n    float cosThHSinPhHDivA = dot(halfVector, tangent) / aspectX;\n    float sinThHSinPhHDivA = dot(halfVector, binormal) / aspectY;\n    \n    return 1.0 / (PI * aspectX * aspectY * sq(sq(cosThHSinPhHDivA) + sq(sinThHSinPhHDivA) + sq(cosThH))); // GTR with anisotropy (gamma = 2)\n}\n\nfloat smithG(float cosV, float alphaG2)\n{\n    float cosV2 = cosV * cosV;\n    \n    return 1.0 / (cosV + sqrt(alphaG2 + (1.0 - alphaG2) * cosV2));\n}\n\nvec3 getDisneysReflectance(\n    vec3 normal,\n    vec3 lightDirection,\n    vec3 viewDirection,\n    vec3 tangent,\n    vec3 binormal,\n    vec3 baseColor,\n    float roughness,\n    float subsurface,\n    float sheen,\n    float sheenTint,\n    float specular,\n    float specularTint,\n    float metallic,\n    float anisotropic, \n    float clearcoat,\n    float clearcoatGloss)\n{\n    vec3 halfVector = normalize(lightDirection + viewDirection);\n    float cosL = dot(normal, lightDirection);\n    float cosV = dot(normal, viewDirection);\n    float cosD = dot(lightDirection, halfVector);\n    float cosH = dot(normal, halfVector);\n    float roughness2 = sq(roughness);\n    \n    if (cosL < 0.0)\n        return vec3(0.0);\n    \n    float schlickL = getSchlicksApproximation(cosL);\n    float schlickV = getSchlicksApproximation(cosV);\n    float d90M1 = -0.5 + 2.0 * cosD * cosD * roughness;\n    float diffuse = (1.0 + d90M1 * schlickL) * (1.0 + d90M1 * schlickV);\n    \n    /* Begin Disney's */\n    float fSS90 = cosD * cosD * roughness;\n\tfloat fSS = mix(1.0, fSS90, schlickL) * mix(1.0, fSS90, schlickV);\n\tfloat ss = 1.25 * (fSS * (1.0 / (cosL + cosV) - 0.5) + 0.5);\n    \n    float luminance = 0.298912 * baseColor.x + 0.586611 * baseColor.y + 0.114478 * baseColor.z;\n    vec3 cTint = baseColor / luminance;\n    vec3 cSheen = mix(vec3(1.0), cTint, sheenTint);\n    /* End Disney's */\n    float schlickD = getSchlicksApproximation(cosD);\n    vec3 sheenAmount = schlickD * sheen * cSheen;\n    \n    float specularD = gtr2WithAnisotropy(tangent, binormal, halfVector, cosH, roughness2);\n    float schlickH = getSchlicksApproximation(cosH);\n    vec3 specularF = mix(mix(specular * 0.08 * mix(vec3(1.0), cTint, specularTint), baseColor, metallic),\n                  vec3(1.0),\n                  schlickH);\n    float specularG = smithG(cosL, roughness2) * smithG(cosV, roughness2);\n    \n    /* Begin Disney's */\n    float clearcoatD = gtr1(cosH, sq(mix(0.1, 0.001, clearcoatGloss)));\n    float clearcoatF = mix(0.04, 1.0, schlickH);\n    /* End Disney's */\n    float clearcoatG = smithG(cosL, 0.25) * smithG(cosV, 0.25);\n    \n    return ((baseColor * INV_PI * mix(diffuse, ss, subsurface) + sheenAmount) * (1.0 - metallic)\n           \t    + specularD * specularF * specularG\n        \t\t/* Begin Disney's */\n                + 0.25 * clearcoat * clearcoatD * clearcoatF * clearcoatG)\n                /* End Disney's */\n            * cosL;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 lightPosition = vec3(10.0 * cos(iTime), 10.0, 10.0 * sin(iTime));\n    vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n    vec3 p = cameraPosition;\n    float d = rayMarch(p, rayDirection);\n    \n    if (d < EPSILON)\n    {\n        vec3 normal = getNormal(p);\n        vec3 lightDirection = normalize(lightPosition - p);\n        vec3 tangent = normalize(cross(vec3(0.0, 1.0, 0.0), normal));\n    \tvec3 binormal = normalize(cross(normal, tangent));\n        vec3 reflectance = getDisneysReflectance(\n            normal,\n            lightDirection,\n            -rayDirection,\n            tangent,\n            binormal,\n            sphereColor,\n            roughness,\n            subsurface,\n            sheen,\n            sheenTint,\n            specular,\n            specularTint,\n            metallic,\n            anisotropic,\n            clearcoat,\n            clearcoatGloss);\n        \n        fragColor = vec4(pow(reflectance, vec3(INV_GAMMA)), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}