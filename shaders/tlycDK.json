{
    "Shader": {
        "info": {
            "date": "1614499058",
            "description": "Analytic intersection with the zero isosurface of a trilinear interpolation. It involves solving a cubic.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlycDK",
            "likes": 9,
            "name": "Trilinear Surface Intersect",
            "published": 3,
            "tags": [
                "raytracing",
                "ray",
                "intersection",
                "cubic",
                "trilinear",
                "analytic",
                "interpolation"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 232
        },
        "renderpass": [
            {
                "code": "/*\nI finally have a working ray vs. trilinear surface intersector!\n\na, b, c, d, e, f, g, and h correspond to the corners of a cube through which they\nare trilinearly interpolated. ASCII figure showing the orientation:\n\n c        d\n |\\‾‾‾‾‾‾‾|\\\n | \\        \\\n |  \\g    |  \\h\n |   |‾‾‾‾‾‾‾‾|\na|- -| - -|b  |\n  \\  |     \\  |\n   \\ |      \\ |\n    \\|_______\\|\n    e         f\n\na is at (0, 0, 0) and h is at (1, 1, 1).\n*/\n\n// Cubic solver\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float aa = a * a, bb = b * b;\n\n    float denom = 3.0 * aa;\n    float inflect = b / (3.0 * a);\n\n    float p = c / a - bb / denom;\n    float q = bb * b / (13.5 * aa * a) - b * c / denom + d / a;\n    float ppp = p * p * p, qq = q * q;\n\n    float p2 = abs(p);\n    float v1 = 1.5 / p * q;\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, 1.0);\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (p < 0.0) roots[0] = sign(q) * cosh(acosh(v2 * -sign(q)) / 3.0);\n        else roots[0] = sinh(asinh(v2) / 3.0);\n        roots[0] = -2.0 * sqrt(p2 / 3.0) * roots[0] - inflect;\n    }\n\n    else {\n        float ac = acos(v1 * sqrt(-3.0 / p)) / 3.0; // 0π/3,       2π/3,               4π/3\n        roots = vec4(2.0 * sqrt(-p / 3.0) * cos(vec3(ac, ac - 2.09439510239, ac - 4.18879020479)) - inflect, 3.0);\n    }\n\n    return roots;\n}\n\n// mla's suggestion to reverse the coefficients and reciprocate the results\n// Better at handling extreme cases and seems to work fine here\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n/*\n// Old trilinear surface intersection and normal\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Basically three nested linear interpolations expanded and regrouped\n    float coeff1 = -a * u * v * w + b * u * v * w + c * u * v * w - d * u * v * w + e * u * v * w - f * u * v * w - g * u * v * w + h * u * v * w;\n    float coeff2 = a * u * w + a * v * w + a * u * v - a * x * v * w - a * u * y * w - a * u * v * z - b * u * w - b * u * v + b * x * v * w + b * u * y * w + b * u * v * z - c * v * w - c * u * v + c * x * v * w + c * u * y * w + c * u * v * z + d * u * v - d * x * v * w - d * u * y * w - d * u * v * z - e * u * w - e * v * w + e * x * v * w + e * u * y * w + e * u * v * z + f * u * w - f * x * v * w - f * u * y * w - f * u * v * z + g * v * w - g * x * v * w - g * u * y * w - g * u * v * z + h * x * v * w + h * u * y * w + h * u * v * z;\n    float coeff3 = -a * w - a * u + a * x * w + a * u * z - a * v + a * y * w + a * v * z + a * x * v + a * u * y - a * x * y * w - a * x * v * z - a * u * y * z + b * u - b * x * w - b * u * z - b * x * v - b * u * y + b * x * y * w + b * x * v * z + b * u * y * z + c * v - c * y * w - c * v * z - c * x * v - c * u * y + c * x * y * w + c * x * v * z + c * u * y * z + d * x * v + d * u * y - d * x * y * w - d * x * v * z - d * u * y * z + e * w - e * x * w - e * u * z - e * y * w - e * v * z + e * x * y * w + e * x * v * z + e * u * y * z + f * x * w + f * u * z - f * x * y * w - f * x * v * z - f * u * y * z + g * y * w + g * v * z - g * x * y * w - g * x * v * z - g * u * y * z + h * x * y * w + h * x * v * z + h * u * y * z;\n    float coeff4 = a - a * z - a * x + a * x * z - a * y + a * y * z + a * x * y - a * x * y * z + b * x - b * x * z - b * x * y + b * x * y * z + c * y - c * y * z - c * x * y + c * x * y * z + d * x * y - d * x * y * z + e * z - e * x * z - e * y * z + e * x * y * z + f * x * z - f * x * y * z + g * y * z - g * x * y * z + h * x * y * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\n// Normalized partial derivatives with respect to x, y, and z of:\n// f(x, y, z) = a - az - ax + axz - ay + ayz + axy - axyz + bx - bxz - bxy + bxyz + cy - cyz - cxy + cxyz + dxy - dxyz + ez - exz - eyz + exyz + fxz - fxyz + gyz - gxyz + hxyz\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float pdx = -a + a * z + a * y - a * y * z + b - b * z - b * y + b * y * z - c * y + c * y * z + d * y - d * y * z - e * z + e * y * z + f * z - f * y * z - g * y * z + h * y * z;\n    float pdy = -a + a * z + a * x - a * x * z - b * x + b * x * z + c - c * z - c * x + c * x * z + d * x - d * x * z - e * z + e * x * z - f * x * z + g * z - g * x * z + h * x * z;\n    float pdz = -a + a * x + a * y - a * x * y - b * x + b * x * y - c * y + c * x * y - d * x * y + e - e * x - e * y + e * x * y + f * x - f * x * y + g * y - g * x * y + h * x * y;\n\n    return normalize(vec3(pdx, pdy, pdz));\n}\n*/\n\n// Simplified trilinear surface intersection and normal\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Reused values (reusing themselves too :D)\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    // Coefficients of the cubic intersection function\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\n/*\nNormalized partial derivatives with respect to x, y, and z of:\nf(x, y, z) = a - az - ax + axz - ay + ayz + axy - axyz + bx - bxz - bxy + bxyz + cy - cyz - cxy + cxyz + dxy - dxyz + ez - exz - eyz + exyz + fxz - fxyz + gyz - gxyz + hxyz\n*/\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float ba = b - a, ca = c - a;\n    float q = ba + c - d + e - f - g + h, qx = q * x;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n\n    float dx = ba + dbac * y + (fbae + q * y) * z;\n    float dy = ca + dbac * x + (gcae + qx) * z;\n    float dz = e - a + fbae * x + (gcae + qx) * y;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\n// To see only the unit cube, change the return statement to:\n// return t > 0.0 && all(lessThan(abs(p - 0.5), vec3(0.5)));\n// You may want to bring the ray origin closer to the origin though.\nbool intersectIsValid(in vec3 p, in float t) {\n    return t > 0.0 && all(lessThan(abs(p - 0.5), vec3(2.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - screenCenter) / iResolution.y * 3.14 : vec2(-0.85, -0.5);\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    ro += 0.5;\n\n    // Isovalues\n    float a = sin(time * 0.5) * 2.0;\n    float b = -cos(time);\n    float c = cos(time * 1.25);\n    float d = sin(time * 2.0) * 0.5;\n    float e = cos(time * 0.5) * 1.5;\n    float f = -sin(time * 1.5) * 0.25;\n    float g = sin(time);\n    float h = cos(time) * 0.75;\n\n    vec4 intersect = IntersectTrilinearSurf(ro, rd, a, b, c, d, e, f, g, h);\n    int numIntersects = int(intersect[3]);\n\n    // Find closest valid intersection\n    vec3 hitPos;\n    float tMin = 1000000.0;\n    bool intersecting = false;\n    for (int i=0; i < numIntersects; i++) {\n        vec3 posCandid = ro + rd * intersect[i];\n        float tCandid = intersect[i];\n        if (intersectIsValid(posCandid, tCandid) && tCandid < tMin) {\n            hitPos = posCandid;\n            tMin = tCandid;\n            intersecting = true;\n        }\n    }\n\n    if (intersecting) {\n        vec3 n = getTrilinearSurfNormal(hitPos, a, b, c, d, e, f, g, h);\n        fragColor = vec4(abs(n), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}