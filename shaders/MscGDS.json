{
    "Shader": {
        "info": {
            "date": "1451968039",
            "description": "Demo, shows how to save / update general purpose state in a buffer. Click on either side of the white line to toggle states.",
            "flags": 32,
            "hasliked": 0,
            "id": "MscGDS",
            "likes": 9,
            "name": "State Demo",
            "published": 3,
            "tags": [
                "state"
            ],
            "usePreview": 0,
            "username": "sixstring982",
            "viewed": 973
        },
        "renderpass": [
            {
                "code": "#define RAM_SIZE 128.0\n\n// Convert a linear index to a vec2 used to \n// index into the 128 * 128 virtual \"RAM\".\nvec2 cellFromIndex(float idx) {\n    return vec2(floor(idx / RAM_SIZE), floor(mod(idx, RAM_SIZE))) / iChannelResolution[0].xy;\n}\n\n// Read a value from \"RAM\", given an index.\n// This assumes that \"RAM\" is a 128 * 128 region,\n// which gives 128 * 128 = 16384 floats of memory.\n// This function assumes that this is indexed linearly,\n// sort of like RAM would be indexed in C.\nfloat read(in float index) {\n    return texture(iChannel0, cellFromIndex(index)).r;\n}\n\n// This function, if you're used to game development,\n// is a little like the \"render\" function. This is where\n// all game objects should be rendered.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 border = vec4(1.0);\n    vec4 rest;\n    // Read float in RAM cell 345, which describes the state to exhibit.\n    if (read(345.0) < 0.5) {\n\t\trest = vec4(uv, 0.5+0.5*sin(iTime), 1.0);\n    } else {\n\t\trest = vec4(0.0, 0.0, 0.5+0.5*sin(iTime),1.0);\n    }\n    \n    fragColor = mix(border, rest, smoothstep(0.0, 1.0, abs(uv.x - 0.5) * 100.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "/** State Demo\n  * sixstring982 - 2016\n  * \n  * This is a demo that shows how to initialize, read, and update\n  * persistent state. Any information can be stored like this\n  * (though, storing floats is usually a good idea). Games can be\n  * created like this, too, by sampling state.\n  * \n  * A longer tutorial describing the motivation of this demo can \n  * be found at:\n  * http://lunagameserve.com/articles/shadertoy_ram.html\n  */\n\n// The number of RAM storage locations is the square\n// of this. You can increase it, but (correct me if\n// I'm wrong), your shader needs to be at least this many\n// pixels in each dimension for this to work.\n#define RAM_SIZE 128.0\n\n// Convert a linear index to a vec2 used to \n// index into the 128 * 128 virtual \"RAM\".\nvec2 cellFromIndex(float idx) {\n    return vec2(floor(idx / RAM_SIZE), floor(mod(idx, RAM_SIZE))) / iChannelResolution[0].xy;\n}\n\n// Read a value from \"RAM\", given an index.\n// This assumes that \"RAM\" is a 128 * 128 region,\n// which gives 128 * 128 = 16384 floats of memory.\n// This function assumes that this is indexed linearly,\n// sort of like RAM would be indexed in C.\nfloat read(in float index) {\n    return texture(iChannel0, cellFromIndex(index)).r;\n}\n\n// Checks to see if the current fragCoord is in a \n// target RAM cell. This allows checking for each\n// cell in parallel.\nbool isCell(in vec2 uv, in float index) {\n    vec2 target = cellFromIndex(index);\n    return uv.x >= target.x - 0.005 &&\n           uv.x <= target.x + 0.005 &&\n           uv.y >= target.y - 0.005 &&\n           uv.y <= target.y + 0.005;\n}\n\n// This function, if you're used to game development,\n// is a little like the \"update\" function. This is\n// where updating of all variables should be done.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // See if this particular fragment is the RAM cell\n    // we want to update\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (isCell(uv, 345.0)) {\n        // Initialize variable\n    \tif (iFrame == 0) {\n\t        fragColor = vec4(0.0);\n            return;\n\t    }\n        \n        // Check condition\n        if (iMouse.z / iResolution.x > 0.0) {\n            // Update variable\n            if (iMouse.z / iResolution.x > 0.5) {\n            \tfragColor = vec4(1.0);\n            } else {\n                fragColor = vec4(0.0);\n            }\n        } \n        // Set variable to previous state\n        else {\n            fragColor = vec4(read(345.0));\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}