{
    "Shader": {
        "info": {
            "date": "1556286323",
            "description": "Fork of \"Patarty\" by MrsBeanbag. https://shadertoy.com/view/wtXGWr\nAdded some movement.\n\nIt's not a party, it's a patarty yeah !\n\nmy first shader lmaooo",
            "flags": 0,
            "hasliked": 0,
            "id": "3lXGD4",
            "likes": 4,
            "name": "Patarty Remix",
            "published": 3,
            "tags": [
                "amiga",
                "remix",
                "boom"
            ],
            "usePreview": 0,
            "username": "Lanza",
            "viewed": 453
        },
        "renderpass": [
            {
                "code": "// Fork of \"Patarty\" by MrsBeanbag. https://shadertoy.com/view/wtXGWr\n// 2019-04-26 12:45:38\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat plasma (in vec2 st) {\n    float value = 4.0 * noise(st);\n    return step(fract(value), 0.5);\n}\n\n// ray marching\nconst int max_iterations = 128;\nconst float grad_step = 0.0001;\nconst float clip_far = 10.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nfloat bounce = 0.0;\n\nvec3 diffuse_colour = vec3(0.0);\nvec3 specular_colour = vec3(0.0);\nvec3 final_diff_colour = vec3(0.0);\nvec3 final_spec_colour = vec3(0.0);\n\n// iq's distance function\nfloat sdSphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat sdUnion( float d0, float d1 ) {\n    return min( d0, d1 );\n}\n\nfloat sdUnion_mat( float d0, float d1, vec3 cd, vec3 cs ) {\n    if (d0 <= d1) {\n        return d0;\n    } else {\n        diffuse_colour = cd;\n        specular_colour = cs;\n        return d1;\n    }\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat potato( vec3 p ) {\n    float d0 = sdSphere( p + vec3(0.05,-0.5*sin(fract(iTime) * 13.2), 0.0), 0.45 );\n    float d1 = sdSphere( p + vec3(0.0, 0.0, 0.1), 0.6 );\n    float d2 = sdSphere( p + vec3(0.15 * cos(fract(iTime) * 6.6), 0.5, 0.0), 0.5 );\n    \n    float d = sdUnion_s( d0, d1, 0.4 );\n    return sdUnion_s( d, d2, 0.4 );\n}\n\nfloat eyes( vec3 p ) {\n    float e0 = sdSphere( p + vec3(0.15, -0.2, -0.42), 0.15 );\n    float e1 = sdSphere( p + vec3(-0.15, -0.22, -0.42), 0.15 );\n    return sdUnion(e0, e1);\n}\n\n// get distance in the world\nfloat dist_field( vec3 p ) {\n    vec3 pb = p;\n    pb.y += -0.2 + bounce;\n\tdiffuse_colour = vec3( 0.9, 0.7, 0.55 );\n\tspecular_colour = vec3( 0.0 );\n\n    float d = sdUnion_mat(potato(pb), eyes(pb), vec3(0.0), vec3(1.0));\n    \n    return d;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 p ) {\n    const vec2 k = vec2(1,-1);\n    return vec3( k.xyy*dist_field( p + k.xyy * grad_step ) + \n                 k.yyx*dist_field( p + k.yyx * grad_step ) + \n                 k.yxy*dist_field( p + k.yxy * grad_step ) + \n                 k.xxx*dist_field( p + k.xxx * grad_step ) );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye) {\n\tvec3 light_pos   = vec3( 20.0, 20.0, 30.0 );\n\tvec3 light_color = vec3( 1.0 );\n\n\tfloat shininess = 40.0;\n\t\n\tvec3 vl = normalize( light_pos - v );\n\tvec3 ref = reflect( dir, n );\n\t\n\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\tfloat specular = max( 0.0, dot( vl, ref ) );\n\t\t\n\tspecular = pow( specular, shininess );\n\t\t\n\treturn light_color * final_diff_colour * diffuse\n        + final_spec_colour * specular;\n}\n\n// ray marching\nbool ray_marching( vec3 o, vec3 dir, inout float depth, inout vec3 n ) {\n\tfloat t = 0.0;\n    for ( int i = 0; t < depth; i++ ) {\n        vec3 v = o + dir * t;\n        float d = dist_field( v );\n        if ( d < grad_step || i >= max_iterations) {\n    \t\tfinal_diff_colour = diffuse_colour;\n\t\t\tfinal_spec_colour = specular_colour;\n\t\t    n = normalize( gradient( v ) );\n    \t\tdepth = t;\n\t\t    return true;\n        }\n        t += d;\n    }\n    return false;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 3.5 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2(0.0, sin(iTime) ) );\n\t//mat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\n    bounce = fract(iTime*2.2)-0.5;\n    bounce *= bounce;\n\tfloat boom = pow(cos(bounce), 25.);\n\n\t// ray marching\n    float depth = clip_far;\n    vec3 n = vec3( 0.0 );\n\tif (ray_marching( eye, dir, depth, n)) {\n\t\t// shading\n\t\tvec3 pos = eye + dir * depth;\n    \n    \tvec3 color = shading( pos, n, dir, eye );\n\t\tfragColor = vec4( color, 1.0 );\n        return;\n    }\n    \n    vec2 st0 = vec2(.9, .5) - fragCoord.xy/iResolution.y;\n    vec2 st = vec2(length(st0), atan(st0.x, st0.y));\n\n\tvec3 color = vec3((1.- boom));\n    color.x += plasma(vec2(log(st.x), st.y + iTime*0.2)*3.0);\n    color.y += plasma(vec2(log(st.x) * boom, st.y + iTime*0.1)*4.0);\n    color.z += plasma(vec2(log(st.x), st.y - iTime*0.4)*5.0);\n\n\tfragColor = vec4(color*0.5,1.0);\n    return;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}