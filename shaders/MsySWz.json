{
    "Shader": {
        "info": {
            "date": "1463754198",
            "description": "trying to do one approch of Sub Surface Scattering.\nthe wax is better without texture lol. do you prefer with or without ?",
            "flags": 32,
            "hasliked": 0,
            "id": "MsySWz",
            "likes": 50,
            "name": "Wax Tunnel",
            "published": 3,
            "tags": [
                "tunnel",
                "wax"
            ],
            "usePreview": 1,
            "username": "aiekick",
            "viewed": 4121
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\ntrying to do one approch of Sub Surface Scattering.\nthe wax is better without texture lol. do you prefer with or without displaced texture ?\n*/\n\nvec4 cell(vec2 fragCoord, vec2 pixel)\n{\n\tvec2 uv = (fragCoord - pixel) / iResolution.xy;\n    return abs(texture(iChannel0, uv));\n}\n\n// shane code\nvoid mainImage( out vec4 f, vec2 g )\n{\n    f = vec4(0);\n    vec2 si = iResolution.xy;\n    vec2 uv = g/si;\n    vec3 col = vec3(0);\n    const float n = 3.;\n    for (float i=0.; i<n; i++)\n    {\n        // get adjacents cells from backbuffer \n        vec4 l = cell(g, vec2(-1,0)*i-0.5); \t// left cell\n        vec4 r = cell(g, vec2(1,0)*i-0.5); \t// rigt cell\n        vec4 t = cell(g, vec2(0,1)*i-0.5); \t// top cell\n        vec4 b = cell(g, vec2(0,-1)*i-0.5); \t// bottom cell    \n        vec4 lt = cell(g, vec2(-1,1)*i-0.5); \t// top left cell\n        vec4 rt = cell(g, vec2(1,1)*i-0.5); \t// top rigt cell\n        vec4 lb = cell(g, vec2(-1,-1)*i-0.5); \t// bottom left cell\n        vec4 rb = cell(g, vec2(1,-1)*i-0.5); \t// bottom right cell    \n        \n        // set buffer\n        f += (l+r+t+b+lt+rt+lb+rb)/8.;       \n    }\n    \n    f /= n;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n#define POINT_FLARE\n//#define POSITIVE_DISPLACE\n\nfloat hash(float n){ return fract(cos(n)*76543.);}\nvec3 hash3(vec3 p){return normalize(vec3(hash(p.x), hash(p.y), hash(p.z)));}\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.2), sin(t*0.2)) * 2.;\n}\n\nvec2 df(vec3 p)\n{\n\tp.xy -= path(p.z);\n\tp *= RotZ(p.z*0.45);\n\tp.xy *= sin(p.z + cos(p.z));\n\tfloat y = 1.72 - max(max(p.x, -p.x) + p.y, -p.y);\n\tvec3 tex = textureLod(iChannel0, vec2(max(p.x, -p.x), p.z)*0.06, 0.0).rgb;\n\tfloat d = dot(tex, vec3(0.71));\n#ifdef POSITIVE_DISPLACE\n    d *= -1.;\n#endif\n\tvec2 res = vec2(y+d, 1);\n    return res;\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat SubSurfaceScattering(vec3 surfPoint, vec3 lightPoint)\n{\n\tvec3 lightdir = normalize(lightPoint - surfPoint);\n\tfloat lightlen = length(lightPoint - surfPoint);\n\t\n\tvec3 rd = lightdir;\n\t\n\tconst float sssiter = 100.; // sub surface scattering steps // decrease cause banding\n\tfloat ms = lightlen / sssiter; // min step len\n\t\n\tvec3 p = surfPoint;\n\t\n\tfloat d = 0., s = 0.;\n\t\n\tfloat accum = 0.; // accumulation range [0 1]\n\t\n\tfor (float i=0.;i<sssiter;i++)\n\t{\n\t\t// next ray direction ( use hash for perturbated normal like)\n\t\trd = refract(rd, hash3(normalize(lightPoint-p)), 0.4); \n        \n\t\t// we have only one ray\n\t\t// so for create cheap ray distribution we change rd and \n\t\t// ray march distance d but keep original surfPoint\n\t\tp = surfPoint + rd * d;\n\t\t\n        // at beginning i would use different attenuation coef for inside and outside ray\n        // but there is somme noise, and the result was not very good, so i compute the ray march distance only when ray is inside material\n        // i can break when s is positive, but it add some noise, and like i continue to evaluate the ray, \n        // the accum will be better for closely thin Walls \n\t\t// s negative => interior of the df\n\t\tif (s < 0.) accum += ms ; \n\t\t//else accum += ms * ms;\n\n\t\ts = df(p).x;\n\t\td += ms; // d must be positive\n\t}\n\t\n\treturn accum;\n}\n\nvec4 light(vec3 ro, vec3 rd, float d, vec3 lightpos, vec3 lc)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, 0.1);\n\tvec3 refl = reflect(rd,n);\n\t\t\n\tvec3 lightdir = normalize(lightpos - p);\n\tfloat lightlen = length(lightpos - p);\n\t\n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, lightdir ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, lightdir ), 0.0, 1.0 ),16.);\n        \n\tvec3 brdf = vec3(0);\n\tbrdf += amb * vec3(1,0,0); // color mat\n\tbrdf += diff * 0.6;\n\tbrdf += spe * lc * 0.8;\n\t\n\treturn vec4(brdf, lightlen);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\n// not very satisfied by this, because, the redius of the point light not change very \n// well along z axis and the point light seems to be not to the good z, when is close to the cam its very bad :)\nvec3 DrawPointLight(vec3 ro, vec3 rd, float d, vec3 lp, float len, vec3 lc)\n{\n\tvec3 res = vec3(0);\n\tif (d>=len)\n\t{\n\t\tvec3 k = rd - normalize(lp-ro);\n\t\tres += lc * (len / 1000.) /dot(k, k);\n\t}\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 3.;\n     \n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord-si)/si.y;\n    \n    vec3 col = vec3(0.);\n    \n\t// first pointclose to the cam, light for the first plane ( without subsurface scatering)\n    vec3 lpNear = vec3(path(t+0.55),t+0.55);\n    \n    // second point light, far (with subsurface scatering)\n\tfloat k = (sin(t*0.3)*.5+.5);\n    vec3 lpFar = vec3(path(t+0.55 + 22.56*k),t+0.55 + 22.56*k);\n\t\n\tvec3 ro = vec3(path(t),t);\n  \tvec3 cv = vec3(path(t+0.1),t+0.1);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 100.;\n    float s = 1., so = s;\n    float d = 1.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (s<0.002*log(d*d)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s * (s>0.1?0.15:0.1);\n    }\n    \n\tif (d<md)\n\t{\n\t\tvec3 p = ro+rd*d;\n\t\t\n\t\tvec4 lightNear = light(ro, rd, d, lpNear, vec3(1));\n\t\tfloat attenNear = 0.9 / lightNear.w; // basic attenuation\n\t\tcol += lightNear.rgb * attenNear;\n\t\t\n\t\tvec4 lightFar = light(ro, rd, d, lpFar, vec3(1,0.57,0));\n        // ratio of len from surface point to the light in the material and len from cam to the light \n\t\tfloat attenFar = 0.8 * (lightFar.w - SubSurfaceScattering(p, lpFar)) / lightFar.w; \n\t\tcol += lightFar.rgb * attenFar;\n\t\t\n        #ifdef POINT_FLARE\n\t\tcol += DrawPointLight(ro, rd, d, lpFar, lightFar.w, vec3(1,0.57,0));\n        #endif\n\t}\n\t\n\tfragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}