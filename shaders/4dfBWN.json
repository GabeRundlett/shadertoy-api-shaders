{
    "Shader": {
        "info": {
            "date": "1496152401",
            "description": "Full demo: https://www.youtube.com/watch?v=-helx-SxnJo\nCurrently missing music and fxaa",
            "flags": 0,
            "hasliked": 0,
            "id": "4dfBWN",
            "likes": 16,
            "name": "OJ - Ljusf√§rd, scene 5",
            "published": 3,
            "tags": [
                "3d",
                "reflection",
                "morph"
            ],
            "usePreview": 0,
            "username": "rammoskar",
            "viewed": 958
        },
        "renderpass": [
            {
                "code": "#define TIME mod(iTime, 31.0)\n#define drum pow(1.0 - 2.0 * mod(TIME, 0.5), 5.0)\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz)-r;\n}\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n#define LPOS vec3(0, 0, -2)\nvec4 laser(vec3 p) {\n\tfloat music = drum; \n\tvec3 lightCol = vec3(1.0 * ( 1.0 + sin(TIME))*0.5, 0.5, 0.5);\n\tfloat visible = smoothstep(9.2,9.3, TIME);\n\tfloat dis = sdCylinder(p.xzy,  0.1 * (1.5 * music + 0.5));\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = (1.5 * music + 0.5) * lightCol * 100.0/(distanceToL*distanceToL);\n\n\treturn vec4(point * visible, distanceToL);\n}\n\nvec4 mirror(vec3 p) {\n\tfloat music = drum;\n\tfloat s = 15.0;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\tfloat h = clamp( TIME - 2.0, 0.0, 10.0);\n\tvec3 lightCol = vec3(0.5, 0.5, 1.0);\n\tfloat dis = sdCappedCylinder(q.zxy - vec3(-1.0 - h, 0.0, 0.0), vec2(0.01, 2.0));\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = (1.5 * music + 0.5) * lightCol * 40.0/(0.1*distanceToL + 0.3*distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\nvec3 evaluateLight(vec3 pos, inout float dis)\n{\n\tvec4 l = laser(pos);\n\tvec4 m = mirror(pos);\n\tdis = min(l.w, m.w);\n\treturn l.xyz + m.xyz;\n}\n\n\nvoid addLightning(inout vec3 color, vec3 normal, vec3 eye, vec3 pos) {\n\tvec3 lpos = LPOS;\n\n\tfloat dis = length(lpos - pos);\n\tvec3 invLight = normalize(lpos - pos);\n\tfloat diffuse = max(0.0, dot(invLight, normal));\n\tfloat spec = specular(normal, -invLight, normalize(eye - pos), 70.0);\n\n\tfloat str = 1.0/(0.1 + 0.01*dis + 0.01*dis*dis);\n\tfloat tmp = 0.0;\n\tcolor =  color * (0.2 + 0.8*diffuse*evaluateLight(pos, tmp).xyz) + spec*str;\n}\n\nfloat smin( float a, float b)\n{\n\tfloat k = 2.0;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\n\n#define SIZE 8.0\n#define PI 3.1415\n\n#define MAT_SPIN 1.0\n#define MAT_GROUND 2.0\n#define MAT_PILLAR 3.0\n\nvec2 spin(vec3 p) {\n\tp.x = p.x == 0.0 ? 0.00001 : p.x;\n\tfloat angle = atan(p.y, p.x);\n\tfloat numParts = 12.0;\n\tfloat partSize = PI / numParts;\n\tangle += PI;\n\tangle = mod(angle + TIME * 0.2, partSize) + partSize * 0.5 * max(0.0, numParts - 1.0);\n\tfloat len = length(p.xy);\n\tfloat lenSize = 7.0;\n\tfloat lenY = mod(len, lenSize) - lenSize * 0.5;\n\tfloat lenPart = floor(len / lenSize);\n\tfloat s = 0.5;\n\tif(lenPart == 0.0){\n\t\ts = 0.1 + 0.7 * drum; \n\t}\n\tvec3 newPos = vec3(len * cos(angle), lenY * sin(angle), p.z);\n\treturn vec2(sdCappedCylinder(newPos, vec2(s, 2.5)), MAT_SPIN);\n}\n\nvec2 gel(vec3 p) {\n\tfloat mt = 10.0;\n\tfloat t = TIME;\n\tfloat t1 = smoothstep(mt*0.0, mt*1.0, t);\n\tfloat t2 = smoothstep(mt*1.0, mt*2.0, t);\n\n\tfloat a = length(p - vec3(0.0, 0.0, -10.0 + t)) - 0.0 - t*t;\n\tfloat b = spin(p).x;\n\tfloat mdis = a*(1.0-t1) + b*t1*(1.0-t2) + t2*b;\n\treturn vec2(mdis, MAT_SPIN);\n}\n\nvec2 ground(vec3 p) {\n\tfloat s = 1.0;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\tfloat d = udRoundBox(q, vec3(s * 0.3), s * 0.3);\n\treturn vec2(d, MAT_GROUND);\n}\n\nvec2  pillars(vec3 p) {\n\tfloat s = 15.0;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\tfloat d = udRoundBox(q, vec3(2.0,0.2, clamp( TIME - 2.0, 0.0, 10.0)), 0.2);\n\treturn vec2(d, MAT_PILLAR);\n}\n\nvec2 map(vec3 p) {\n\tvec2 g = gel(p - vec3(0, 0, 0));\n\tvec2 solid = sun(pillars(p - vec3(0, 0, 0)), ground(p - vec3(0, 0, 2)));\n\tvec2 res = sun(g, solid);\n\treturn res;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = map(p + ep.xyz).x - map(p - ep.xyz).x;\n    normal.y = map(p + ep.yxz).x - map(p - ep.yxz).x;\n    normal.z = map(p + ep.yzx).x - map(p - ep.yzx).x;\n    return normalize(normal);\n\n}\n\nfloat occlusion(vec3 p, vec3 normal)\n{\n\tfloat o = 2.0*map(p + normal * 0.5).x;\n\treturn 0.2 + 0.8*o;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, inout vec3 finalPos, vec3 eye) {\n\tfloat t = 0.0;\n\tconst int maxIter = 100;\n\tconst float maxDis = 200.0;\n\tfloat d = 0.0;\n\tvec3 p = vec3(-1.0, -1.0, -1.0);\n\tvec3 col = vec3(0);\n\tconst int jumps = 3;\n\tfloat ref = 1.0;\n\tvec3 scatteredLight = vec3(0.0);\n\tfloat transmittance = 1.0;\n\tfor (int j = 0; j < jumps; j++) {\n\t\tfor (int i = 0; i < maxIter; i++) {\n\t\t\tp = ro + rd * t;\n\n\t\t\t\tvec2 res = map(p);\n\t\t\t\td = res.x;\n\t\t\t\tfloat fogAmount = 0.0025;\n\t\t\t\tfloat lightDis = -1.0;\n\t\t\t\tvec3 light = evaluateLight(p, lightDis);\n\t\t\t\td = min(min(d, 1.0), max(lightDis, 0.05));\n\t\t\t\tvec3 lightIntegrated = light - light * exp(-fogAmount * d);\n\t\t\t\tscatteredLight += transmittance * lightIntegrated;\n\t\t\t\ttransmittance *= exp(-fogAmount * d);\n\n\t\t\t\tt += d;\n\t\t\t\tfloat m = res.y;\n\t\t\t\tbool end = i == maxIter - 1 ||t > maxDis;\n\t\t\t\tif (d < 0.01 || end) {\n\t\t\t\tvec3 c = vec3(1);\n\t\t\t\tvec3 normal = getNormal(p);\n\t\t\t\tif (m == MAT_SPIN) {\n\t\t\t\t\tfloat angle = atan(p.y, p.x);\n\t\t\t\t\tfloat numParts = 12.0;\n\t\t\t\t\tfloat partSize = PI / numParts;\n\t\t\t\t\tangle += PI;\n\t\t\t\t\tfloat part = floor((angle + TIME * 0.2) / partSize);\n\t\t\t\t\tfloat len = length(p.xy);\n\t\t\t\t\tfloat lenSize = 7.0;\n\t\t\t\t\tfloat lenY = mod(len, lenSize) - lenSize * 0.5;\n\t\t\t\t\tfloat lenPart = floor(len / lenSize);\n\t\t\t\t\t part = part + lenPart * 10.0;\n\t\t\t\t\t vec3 newPos = vec3(len * cos(angle), lenY * sin(angle), p.z);\n\t\t\t\t\tc = vec3(0.4 + 0.4 * sin(part), 0.4 + 0.4 * sin(part * 0.5 + 1.0), 0.4 + 0.4 * sin(part * 0.25 + 2.0));\n\t\t\t\t\tc*=3.0;\n\n\t\t\t\t} else if (m == MAT_GROUND) {\n\t\t\t\t\tc = vec3(0.5);\n\t\t\t\t} else if (m == MAT_PILLAR) {\n\t\t\t\t\tc = vec3(1);\n\t\t\t\t}\n\t\t\t\tc *= occlusion(p, normal);\n\t\t\t\taddLightning(c, normal, eye, p);\n\t\t\t\tif (end) {\n\t\t\t\t\ttransmittance = 0.0;\n\t\t\t\t}\n\t\t\t\tcol = mix(col, transmittance * c + scatteredLight, ref);\n\t\t\t\tif (m == MAT_PILLAR && p.z < -0.0 && p.z > -9.0) {\n\t\t\t\t\tref = 1.0;\n\t\t\t\t} else {\n\t\t\t\t\tref = 0.0;\n\t\t\t\t}\n\t\t\t\trd = reflect(rd, getNormal(p));\n\t\t\t\tro = p + rd*0.02;\n\t\t\t\tt = 0.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t > maxDis) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ref < 0.1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinalPos = p;\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (9.0/ 16.0);//* (iResolution.y/iResolution.x);\n    \n    float t = TIME;\n    vec3 eye = vec3(0.0, -20.0 - TIME*2.0 , -30.0 + TIME);\n\tvec3 tar = vec3(0, -15, 0); \n\tvec3 lol = vec3(0, 1, 0);\n\tif (t > 20.0) {\n\t\teye = vec3(3.0, 3.0 , 40.0 - (t + 4.0) * 2.3);\n\t\ttar = vec3(2, 0, 0); \n\t\tlol = vec3(0,0,-1);\n\t\teye.xy = vec2(3,3) + smoothstep(30.0,30.8, t) * (vec2(0) - vec2(3,3));\n\t} else if (t > 17.0) {\n\t\teye = vec3(5.0 - t, 3.0 + t , -20.0);\n\t\ttar = eye + vec3(0,0.1, 1); \n\t\tlol = vec3(0,0,-1);\n\t} else if (t > 8.0) {\n\t\teye = vec3(15.0 - t, 13.0 , -12.0);\n\t\ttar = vec3(2, 0, 0); \n\t\tlol = vec3(0,0,-1);\n\t}\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(lol, dir));\n\tvec3 up = cross(dir, right);\n\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\n\tvec3 light = vec3(0.0, 0.0, 26.0 );\n\n\tvec3 finalPos = vec3(-1.0, -1.0, -1.0);\n\tfloat material = -1.0;\n\tvec3 color = raymarch(ro, rd, finalPos, eye);\n\n    fragColor = vec4(color, 1.0);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}