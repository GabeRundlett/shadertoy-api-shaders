{
    "Shader": {
        "info": {
            "date": "1539616856",
            "description": "fork of\nhttps://www.shadertoy.com/view/ldXBzH\nusing common tab and adding stuff like colors and shared subroutines.",
            "flags": 8,
            "hasliked": 0,
            "id": "4t3fDN",
            "likes": 10,
            "name": "Jammin 2 random fm sequences",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "random",
                "audio",
                "audiovisual",
                "chiptune",
                "chords",
                "jammin",
                "conmmon"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 764
        },
        "renderpass": [
            {
                "code": "//All code is in commons tab ,to use the same functions to render audio and video\n//, or at least some sort of audio-visualization, if only a blinking lights show\n//[audiovisual] tag means it uses moudular arithmetic (fourier analysis, roots of unity)\n//,without being overly excessive and crashing browsers/opengl\n\n//it can not point to buffers from the commonTab, so you can not get any backbuffer-accumulator (DFT FFT)\n//it can not include long linear sequences (loops) or sort trough nig trees (soo slow, likely crashes opengl)\n//it can however to a lot of modular arithmetic (and small fractals with <5 iterations)\n//, to intelligently oregami-fold short sequences into apparently more complex sequences.\n//it can easily do (aperiodic) ring-sequences, small hashes or [(permuted) linear congruential generators]\n//and band-filter or mod-cast them into a harmonic scale with nice thirds and fifths.\n\n//it can easily accumulate 64 waveforms of unique frequencies\n//, so we can do a lot of fourier-coefficients, butjust not fourier analysis.\n\nvoid mainImage(out vec4 o,vec2 u){o=Port(u.xy,iMouse.xyzw,iResolution.xy,iTime);}\n//vec2 mainSound( in int samp,float t){return Port(t);}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//All code is in commons tab ,to use the same functions to render audio and video\n//, or at least some sort of audio-visualization, if only a blinking lights show\n//[audiovisual] tag means it uses moudular arithmetic (fourier analysis, roots of unity)\n//,without being overly excessive and crashing browsers/opengl\n\n//it can not point to buffers from the commonTab, so you can not get any backbuffer-accumulator (DFT FFT)\n//it can not include long linear sequences (loops) or sort trough nig trees (soo slow, likely crashes opengl)\n//it can however to a lot of modular arithmetic (and small fractals with <5 iterations)\n//, to intelligently oregami-fold short sequences into apparently more complex sequences.\n//it can easily do (aperiodic) ring-sequences, small hashes or [(permuted) linear congruential generators]\n//and band-filter or mod-cast them into a harmonic scale with nice thirds and fifths.\n\n//it can easily accumulate 64 waveforms of unique frequencies\n//, so we can do a lot of fourier-coefficients, butjust not fourier analysis.\n\n//void mainImage(out vec4 o,vec2 u){o=Port(u.xy,iMouse.xyzw,iResolution.xy,iTime);}\nvec2 mainSound( in int samp,float t){return Port(t);}\n\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "//self  : https://www.shadertoy.com/view/4t3fDN\n//parent: https://www.shadertoy.com/view/ldXBzH\n//I like how ldXBzH does sequencing with a note key and some chords of different instruments\n//it had defunct code that clearly hinted at attempting to be a bit like this shader.\n\n//play melody of parent (longer notes), or own melody (faster)\n#define parentMelody 0\n\n#define vec1 float\n#define pi acos(-1.)\n#define sat(a) clamp(a,0.,1.)\n\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(a) clamp(a,0.,1.)\n#define pow2 exp2\n#define TT(d) mod(mod(time,1.0)-d,1.0)\n#define trunc(a) float(int(a))\n#define ma0(a) max(0.,a)\nvec2 fr(float a){return vec2(fract(a),floor(a));}\nfloat su(vec4 a){return a.x+a.y+a.z+a.w;}\n\n#define HASHSCALE1 .1031\nfloat hash1(float p\n){vec3 q=fract(vec3(p)*HASHSCALE1)\n ;q+=dot(q,q.yzx+19.19)\n ;return fract((q.x+q.y)*q.z);}\nint rand1To8(float t){return int(hash1(t)*8.);}\n\n//https://www.shadertoy.com/view/ldXBzH\nfloat[] C135 = float[](0.,2.,4.);\n//instrument subroutines\n\n//this is a messy family of functions that are only almost identical:\nfloat n2f      (float n){return 55. *pow(2.,(n- 3.)/12.);}\nvec4 n2f      (vec4 n){return 55. *pow(vec4(2),(n- 3.)/12.);}\nfloat noteFreq (int n  ){return n2f(float(n+39));}\nfloat noteKeyA (float n){float[] notes = float[](1046.5,1174.66,1318.51,1396.91,1567.98,1760.,1975.53, 2093.); \n                         return notes[int(n)%8];}//this could use https://www.shadertoy.com/view/Xl3BD4\nfloat noteMIDI (float n){return 440.*pow(2.,(n-69.)/12.);}\nvec4 noteMIDI (vec4 n){return 440.*pow(vec4(2),(n-69.)/12.);}\nfloat calcHertz(float n){return 440.*pow(2.,(n    )/12.);}\n\n//subroutines for //https://www.shadertoy.com/view/ldXBzH\nfloat ix(float o,float idx){return exp2(o)*noteKeyA(idx);}\nfloat ox(float t,float o,float idx){return ix(o,idx)*fract(t/2.)*pi*.8;}\n\n//instruments //https://www.shadertoy.com/view/ldXBzH\nfloat note(float k, float o,  float t){return sin(ox(t,o,k));}\nfloat noteSaw(float k, float o, float t){return tan(note(k,o,t));}\nfloat noteSquare(float idx, float o, float t\n){float a=floor(fract(t*2.)*2.+1.)*fract(t*.5)*.1\n ;return 3.*(fract(a*ix(o,idx))-.5);}\n\n\n//2 melodies, the first one is a slower-paced patent-shader melody.\n//second lemody tries to make some notes much shorter.\n//you MAY just change the 2nd hash-parameters, that define [r], to get a unique melody (highest frequency instrument only)\n\n#if parentMelody\n\n//#if 1   //alternatively just overwrite the [parentMelody] toggle\nfloat melody(float t,float c //Jammin 2 == parent = https://www.shadertoy.com/view/ldXBzH\n){float note\n ;t=mod(t,64.)< 32. ? mod(t,32.0)-94. : t\n ;float s=floor(2.*hash1(floor(t*2.+241.)))+1.\n ;t*=.25*s\n ;if(s==2.&& hash1(floor(t*4.0+738.))>.7)t*=2.//shorter notes\n ;float r=hash1(floor(t-3280.))\n ;if(r<=.8\n ){if(r>.4)c=floor(mod( 4.*t,8.))\n  ;else    c=floor(mod(-4.*t,8.));}\n ;return c;}\n \n#else\n\nfloat melody(float t, float c //Jammin 2 https://www.shadertoy.com/view/4t3fDN\n){t=mod(t,64.)< 32. ? mod(t,32.0)-94. : t            //identical to parent (above)\n ;float s=floor(2.0*hash1(floor(t*2.0+241.0)))+1.0  //identical to parent\n ;t*=mix(1.,4.,smoothstep(0.,1.,s-2.))                 //different line\n ;s=hash1(floor(t*4.+738.))                            //from contition parametr of parent\n ;t*=mix(1.,2.,step(s-.7,0.))//smoothstep(.0,1.,s-.7)) //definitely , not just mix() instead of if()\n ;//t*=.5*s                                             //opzional speed modifier, makes it more chaotic\n ;float r=hash1(floor(t-3280.0))                       //identical to parent\n ;if(r<=0.8){                                          //identical to parent  \n       t*=4.*mix(1.,-1.,step(.4,r))                    //identical to parent???, branch replaced by mix()\n    ;c=float(mod(t,8.0))               //THE biggest difference to the parent\n ;}return c;}\n \n#endif\n\n//sound2 wraps the melody(), procedurally generated, seeded with a rand1To8() hash\n//being the same function to be used by [image] AND [audio] contexts\n//, this defines [audiovisual]\nvec4 sound2(float t\n){float i=4.\n ;float l = mod(t,64.)< 32. ? 4. : 32.\n ;float j =float( rand1To8(mod(floor(t*2./i),l)-900.))\n ;float d=floor(melody(t,j)+24.)\n ;float c=floor(fract((2.*t+2.))*2.)\n ;return vec4(j+vec3(4,9,-c*8.-8.),d)///.xyz are a base-chord. .w is a melody\n ;}\n\nfloat soso(float t//audible mono uses sound2() as input\n){float c=0.\n ;vec4 nn=(floor(sound2(t)))\n ;float j=nn.x\n ;c+=.2*noteSaw(nn.w,2.,t)//sin(6.2831*nn.w*t);\n ;c+=.8*(noteSquare((nn.z+C135[0]),0.,t)*.3\n           +noteSaw((nn.y+C135[1]),1.,t)*.3\n           +noteSaw((nn.x+C135[2]),0.,t)*.15)\n ;return c;}\n\nfloat mi(vec4 a){return min(min(a.x,a.y),min(a.z,a.w));}\n\n\n//rgba colorspace matrices\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a){return rainbowt(-a,1./3.);}\nvec3 rainbows(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbows(float a){return rainbows(-a,1./3.);}\n#define ToRgb(w) return c.z*mix(vec3(1.),sat(w(-c.x)),c.y);}\nvec3 rainbows(vec3 c){ToRgb(rainbows)//3 tri waves, most blurry  , fast and precise cos-mix (blurriest because it is only linear)\nvec3 rainbowt(vec3 c){ToRgb(rainbowt)//3 cos waves, medium blurry, linear-mix not identical to hsv2rgb ,but close\n//hsv2rgb uses a capped triangle-wave, as such it appears to be the brighttest/sharpest because at any moment only 2/3 colors swap.\n#define hsv2rgb(c) c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008, but code is lost\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt //3 tri waves, most blurry, fast and precise, considder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n//vec3 HsvToRgb(vec3 c){vec3 p;p=abs(fract(c.xxx+vec3(3,2,1)/3.)*6.-3.);return c.z*mix(vec3(1),sat(p-1.),c.y);}\n//porter duff alpha compositing:\n//i do not define ut ..., because its a too short namespace to be spent on a define.\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}//#define ut(a,b) (a*(1.-b))\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\n\nvec4 colorNote(vec4 n, float y\n){float a=mi(abs(n-y))    \n ;y*=.02\n ;vec4 b=vec4(a)\n ;vec4 c=vec4(rainbows(y),1.)\n ;//vec4 c=vec4(1.-sat(vec3(y,.5+.5*cos(y*8.),1.-y)),1)//lazy gradient\n ;//return c\n ;return pdOut(b,c)\n ;}//yu likely wanted a non-gradient, welöl that just adds some y=fract(y*s)*v  y=floor(y*z)*w\n\n//port functions are entry points with different IO-contexts\nvec2 Port(float t){return vec2(soso(t));}//port for audio fm synth only does audio (passenger foprt)\nvec4 Port(vec2 u,vec4 m,vec2 r,float t //port for visuals has more parameters      (cargo port)\n){u=u.xy/r.xy\n ;vec4 c=sound2(t+u.x-1.0)\n ;c.w=floor(c.w)\n ;return colorNote(c,u.y*60.-20.);}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}