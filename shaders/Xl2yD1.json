{
    "Shader": {
        "info": {
            "date": "1508416791",
            "description": "a lot of canvas for a simple way2plane intersection.\nneeded to debug this for raymarching trough portals, must stop right behind the portal!\nportal normal is signed and its distance is signed, 4 different permutations matter here.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl2yD1",
            "likes": 1,
            "name": "gPRxZ plane intersection",
            "published": 3,
            "tags": [
                "ray",
                "plane",
                "tracing",
                "portal",
                "intersect",
                "gprxz"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 645
        },
        "renderpass": [
            {
                "code": "#define TestDivideByZeroCase -1\n\n//control speed of time, to make time static or negative.\n#define TimeS (iTime-1.)\n//-1. makes a better thumbnail for the first frame\n//-1. also offsets from [the initial VOID-state]:\n// Because Shadertoy has the PATHETIC error that iTime and iGlobalTime are not initialized.\n// iTime and iGlobalTime are initially ==NullPointer != 0. \n// This confuses many webgl implementations, eg: when using i=cos(acos(-1.)+iTime);\n// cos(acos(-1.)+0.)==-1. is fine.\n// (NullPointer +0.)!= 0. confuses many implementations. -> black screen on iTime==0.\n\n//  ColorgGradient==x>0, shows different gradients, index[1..4], points to a 2*2 matrix:\n//   2 gradients are euclidean sqrt(a), 2 of them 1/dot(a,a)\n//   2 gradients them are fract(a), 2 of them are not.\n//  ColorgGradient==0  is, by your powers combined, Captain Planet, all of the above.\n//  ColorgGradient==-1 is, a (disappearing) ring-variant of ColorgGradient==0\n//  ColorgGradient==-1 shows a spherical [Bounding Volume] in white/yellow\n#define ColorGradient 0\n\n//  HasMix linear interpolates between a hasn and a PolynomialWithExponent3\n#define MixHashPoly3 u5(cos(TimeS*0.61))\n//#define MixHashPoly3 .0\n\n//sub-pixel blur\n#define fsaa 14./min(iResolution.x,iResolution.y)\n\n//swivel view, make .y horizontal, more horizontal ScreenSpace for higher exponents.\n#define ViewSvivel\n//View.Zoom\n#define ViewZoom 5.\n//View.Frame\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n\n\n/* end__.Manual.Parameters\n   start.Lib.Frame.8\n*/\n//library of often used functions: //ounting, index starts at 0!\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u5(a) (a*.5+.5)\n#define u2(a) (a*2.-1.)\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n//max of vector\n#define miv(a) -mav(-a)\n//triangle wave //euclidean grid\n#define tri(a) abs(u2(fract(a)))\n#define grid(a) mav(tri(a))\n//clamp().special clamp.general; //clamp().pseudo.inverse\n#define sat(a) clamp(a,0.,1.)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//stretch; mirror_centric, most common, atomic\n#define stretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretchMinus; positive values do not change; stretchPlus; negatives do not change.\n#define stretchM(u,m) stretch((u*2.+m),m)*.5\n#define stretchP(u,m) stretch((u*2.-m),m)*.5\n//return squared length of a()\n#define dd(a) dot(a,a)\nv1 perp(v1 a){return v1(-a.y,a.x);}//perpendicular ==90deg rotation\nv0 dotp(v1 a,v1 b){return dot(perp(a),b);}//return [perpendicular dot product], can be useful for distance to line with niormalizedd input\nv0 dLine (v1 p,v1 a,v1 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}//return squared distance of [u] from segment, from [a] to [b]\nvec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n//not sure if aXorB() is correct, but looks useful. //https://en.wikipedia.org/wiki/Alpha_compositing\nvec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n//---trigonometry, rotations and (distance to) Quadratic functions.\n//(distance to quadratic is a cubic with less than 2 intersections==roots)\n#define cs(a) vec2(cos(a),sin(a))\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//golden ratios are the best factors for hashes because; phi.xy-1.=1/phi.xy\nconst v1 phi=v1(sqrt(5.)*.5)+v1(-.5,.5);\n//a not too work save plotter for quadratic functions.\nv1 evalQuad(v1 t,v1 A,v1 B,v1 C){A=(1.-t)*(A/B+C/A);return A*A;}\n//Solve quadratic equation for roots \nv2 SolveQuad(v2 a){v0 e=-a.x/3.;v0 p=a.y+a.x*e,t=p*p*p,\n q=-(2.*a.x*a.x-9.*a.y)*e/9.+a.z,d=q*q+4.*t/27.;if(d>.0){v1 x=(v1(1,-1)*sqrt(d)-q)*.5;\n return v2(suv(sign(x)*pow(abs(x),v1(1./3.)))+e);}v1 m=cs(acos(-sqrt(-27./t)*q*.5)/3.)\n  *v1(1,sqrt(3.));return v2(m.x+m.x,-suv(m),m.y-m.x)*sqrt(-p/3.)+e;}\n//return squared distance to line segment\n#define ddb(a) (dd(d+(c+b*t.a)*t.a))\n// Find the signed distance from a point to a bezier curve\nv0 dBezier(v1 p,v1 A,v1 B,v1 C){   \n //B=mix(B+v1(1e-4), B, abs(sign(B * 2.0 - A - C)));//colinear CV triviality\n v1 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p;v2 k=v2(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b),\n t=sat(SolveQuad(k));return sqrt(miv(v2(ddb(x),ddb(y),ddb(z))));}\n//---window function curve fittings.y:  https://www.shadertoy.com/view/Xtscz7\n#define bma(b,a,c) (((b)-(a))*(c)+a)\n//float Linear(float x, float a, float b){return  a*(x*(b/a-1.)+1.);}//doesnt look too good.\n#define wLinear(x,a,b) a*(x*(b/a-1.)+1.)\n//float Cosine(float x, float a, float b){return (b-a)*(1.-cos(x*acos(-1.)))*.5 + a;}\n#define wCosine(x,a,b) (bma(b,a,(1.-cos(x*acos(-1.)))*.5)\n//float Smoothstep(0,1,x), without sat(a);\n#define wSs2(x) (x)*(x)*(3.-2.*(x))\n#define wSs(x,a,b) wSs2((x)-(a)/((b)-(a)))//this is not too useful, without sat it sucks\n//bma(b,a,x*x*(3.-2.*x))\n//lower lipschitz == less likely spheretracking overestimation.\n//most general, smoothest most excessive, most zigzag, lowest lipschitz\n#define wHermiteD(x,a,b,e,f) (b+.5*x*(e+b-a+x*(a-b+e+x*3.*(e*3.+f+x*5./3.*(-e*3.-f+x*.4*(e*3.+f))))))\n#define wHermite(x,a,b,c,d) HermiteD(x,a,b,(c-b),(a-d))\n//special case of Hermite(), with a smooth .5 average. medium zigzag\n#define wCatmullRom(x,a,b,c,d) ((((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b)\n//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n#define wCubic(x,a,b,c,d) ((((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b)\n//Cosine() is smoother than Cubic()\n//fast good monochrome distance field visualization.\nv3 rg(v3 c){v3 b=smoothstep(fsaa,-fsaa,c);\n return mix(fract(c*4.),b,.5+(atan(c))/acos(-1.));}\n//return y=f(a,m); m.xyzw coefficients of GeneralPoynomWithExponent3==f();\nv0 p3(v0 a,v3 m){\n //return m.x+a*m.y+a*a*m.z+a*a*a*m.w;//lazy, worst\n //return dot(vec4(1),m*vec4(1.,a*vec3(1,a*vec2(1.,a))));//overly explicit vector processor\n return dot(vec4(1),m*vec4(1.,a,a*a,a*a*a));//explicit vector processor\n return m.x+a*(m.y+a*(m.z+a* m.w));//explixit MAD() (better precision)\n ;}//#define p3(u,f) (f.x+u*f.y+(u*u)*f.z+(u*u*u)*f.w)\n//---hash\n#define hs vec4(1031,.1030,.0973,.1099)\n//h* hashes, fast mediocre, better for mobile gpu, Sans Euclid, without trigonometry.\nv0 h11(v0 p){v2 f=fract(v2(p)*hs.y);f+=dot(f,f.yzx+19.19);return fract((f.x+f.y)*f.z);}\nv2 hash33(v2 a){a=fract(a*hs.xyz);a+=dot(a,a.yxz+19.19);return fract(a.zyx*(a.xxy+a.yzz));}//https://www.shadertoy.com/view/4djSRW\nv3 h44(v3 a){a=fract(a*hs);a+=dot(a,a.wzxy+19.19);return fract(a.zywx*(a.xxyz+a.yzzw));}//https://www.shadertoy.com/view/4djSRW\n\n/* End__.Lib.Frame.8\n   Start.Special\n*/\n//subroutines that are too special to enter the Library,\n// to not be generalized or specialized (for now).\n\n//a mix (interpolate between) a polynom.y and a hash.y\nfloat ph(float a,vec4 m){return mix(h11(a),p3(a,m),MixHashPoly3);}\n\n/* End__.Special\n   Start.Main\n*/\n\nvec4 eulerEuclid(vec2 u,vec4 m){\n float i=u5(cos(acos(-1.)+TimeS));\n //i=interval of dots, goes all the way to 0, maybe not on linux.\n //testing limited precision (of IEEE float)\n #if   TestDivideByZeroCase==0\n  i=.000000;\n #elif TestDivideByZeroCase==1 \n  i=.000001;\n #elif TestDivideByZeroCase==2\n  i=.000020;\n #endif\n vec2 x=i*vec2(fract(u.x/i),floor(u.x/i));//dividing by 0, or very small values, here.\n //and then multiplying by the same (asmall number).\n \n //m=vec4(-1);//static debug overwrite\n m.xyzw=m.ywzx;//swivel coefficients to something that makes more sense \n               // for mouse.xy inputs.\n vec2 a=vec2(ph(x.y  ,m),\n             ph(x.y+i,m));//position.y of \n a=u.y-a;\n float f=min(dd(vec2(x.x  ,a.x)), //halfDot on the left  side of a period.\n             dd(vec2(x.x-i,a.y)));//halfDot on the right side of a period.\n //Above [f] stores a squared distance, \n // to have th option to not squaretroot it below.\n vec4 c=vec4(0);\n #if ColorGradient<1\n  //ColorgGradient==0 combines all of the other 4 gradients below.\n  c.y=smoothstep(fsaa,-fsaa,f -5./fsaa);//faster, gradient is NOT Euclidean distance.\n  //gradiend it inverse square, good enough for circles!\n  c.z=fract(f);\n  f=sqrt(f);\n  #if ColorGradient==-1\n   c.x=smoothstep(fsaa,-fsaa,abs(f-i+fsaa*2.)-fsaa);//gradient is Euclidean distance.\n  #else\n   c.x=smoothstep(fsaa,-fsaa,   (f*.5       )-fsaa);//gradient is Euclidean distance.\n  #endif\n  c.w=fract(f);\n  c=mix(c,c.xxxx,u5(sin(iTime*acos(-1.))));//oscillate between showing; c.x; or; c\n #elif ColorGradient==1\n  c.x=smoothstep(fsaa,-fsaa,sqrt(f)-fsaa)      ;//gradient is Euclidean distance.\n #elif ColorGradient==2\n  c.y=smoothstep(fsaa,-fsaa,f  -5./fsaa);//faster, gradient is NOT Euclidean distance.\n  //gradiend it inverse square, good enough for circles!\n #elif ColorGradient==3\n  c.z=fract(f);\n #else \n  c.w=fract(sqrt(f));\n #endif\n return c;\n}\n\n\n\n\n\nfloat inv_error_function(float x){\n float INV_ALPHA=.5;\n float K =.5;\n\tfloat y = log(1.0 - x*x);\n\tfloat z = K + 0.5 * y;\n\treturn sqrt(sqrt(z*z - y * INV_ALPHA) - z) * sign(x);\n}\n\n//[n]PlaneNormal\n//[u]RayOrigin\n//[t]RayDirection\n//return distacne from origin to intersection.\nfloat gPRxZ(vec3 n,vec3 u,vec3 t){\n    return -(dot(n,u)/dot(n,t));}\nfloat gPRxZ(vec2 n,vec2 u,vec2 t){\n    return -(dot(n,u)/dot(n,t));}\n//second life wiki geometric\n//\n//calculate intersection of ray from [m.zw] to [m.xy] \n//and plane with notmal [n] and distance [d]to vec2(0)\n//from there move AWAY from [m.zw]\n//, in the direction of the surface normal, by [b]\n//return that point \"BEHIND\" the intersection point.\nvec2 pointBehindBound(vec2 n,float d,vec4 m,float b){\n n=normalize(n);//save\n vec2 i=m.zw+(m.xy-m.zw)*gPRxZ(n,m.zw+n*d,(m.xy-m.zw));\n //i-=n*sign(dot(m.zw,n)+d)*b;//stop a little bit behind the plane.\n i+=normalize(m.xy-m.zw)*.5;//same, but point is on ray [m]\n return i;}\n//this is intended tor teleporters\n//, where 4 permutations of \"normal\" and \"distance\" are relevant.\n\n/*\nexample use:\n vec2 planeNormal=normalize(vec2(1,5));\n float planeDist=-1.;   \n c.g=dot(u,planeNormal)-1.+planeDist;//draw signed boundary\n vec2 intersect=pointBehindBound(planeNormal,planeDist,m,.5);\n c.b=length(u-intersect)-.5;//draw blue around \"intersect\"\n*/\n\nvec2 rec(vec2 a){return vec2(a.x,-a.y);}\n\nvoid mainImage( out vec4 O,in vec2 U){\n vec2 u =fra(U);vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));  \n #ifdef ViewSvivel\n  u=u.yx;m=m.yxwz;//swivel view, use horizontal space to show higher exponentials.\n #endif    \n vec4 c=vec4(1); //c=eulerEuclid(u,m);\n //c.b=length(u-m.xy)-.1;\n c.r=sqrt(dLine(u,m.zw,m.xy))-.25;//line segment shows a ray\n\n    /*\na lot of canvas for a simple way2plane intersection.\nneeded to debug this for raymarching trough portals\n, must stop right behind the portal!\nportal normal is signed and its distance is signed\n, 4 different permutations matter here.\nbecause a portals back side is different than its front side.\n\n*/\n    \n vec2 planeNormal=normalize(vec2(-1,-5));\n float planeDist=1.;   \n c.g=dot(u,planeNormal)-1.+planeDist;//draw signed boundary\n vec2 intersect=pointBehindBound(planeNormal,planeDist,m,.5);\n c.b=length(u-intersect)-.5;//draw blue around \"intersect\"\n    \n c.rg=mix(c.rg,c.aa,.5);//mix a as yellow;\n c=rg(c);//distance gradient\n float grid=grid(u)*2.-1.5;\n grid=sat(grid);\n c=aOverB(vec4(grid),vec4(c.xyz,1.));\n O=vec4(c.xyz,1);}\n/* End__.Main\n   Start.Bisymmetry.4\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}