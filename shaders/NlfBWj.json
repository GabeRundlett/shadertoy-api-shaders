{
    "Shader": {
        "info": {
            "date": "1651444310",
            "description": "Sphere of Voxels",
            "flags": 0,
            "hasliked": 0,
            "id": "NlfBWj",
            "likes": 10,
            "name": "Voxel Sphere",
            "published": 3,
            "tags": [
                "cube",
                "sphere",
                "voxel",
                "circle",
                "effect",
                "moire",
                "minecraft",
                "normal",
                "henry",
                "segerman"
            ],
            "usePreview": 0,
            "username": "Spi3lot",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "// Inspired by Henry Segerman (henryseg): https://www.shadertoy.com/view/7ds3zB\n\n\n/* Implementation using ray marching - work in progress */\n\n#define EPSILON 0.001\n#define MAX_STEPS 250\n#define MAX_DISTANCE 2.0 * DISTANCE\n\n#define DISTANCE (2.0 + iTime * 2.0)\n#define ZOOM 1.25\n//#define ROTATE\n\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdClosestCube(vec3 p)\n{\n    vec3 distances = abs(p - round(p));\n    return min(min(distances.x, distances.y), distances.z);\n}\n\n/* Now implemented in RayMarch() * /\nfloat GetDist(vec3 p)\n{\n    \n    \n    float minDist = 1e20;\n    \n    float cube = sdClosestCube(p);\n    float sphere = sdSphere(trunc(p), iTime);\n    \n    //if (sphere < sqrt(3.0))\n    if (sphere < EPSILON)\n        minDist = -cube;  // Negative so that we exit the sphere\n    else\n        minDist = sphere;\n    \n    return minDist;\n}\n/* */\n\nvec3 GetNormal(vec3 dpdx, vec3 dpdy)\n{\n    return normalize(cross(dpdx, dpdy));\n    //return normalize(cross(dFdx(p), dFdy(p)));\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    // ALGORITHM:\n    //     RETURN THE INTERSECTION OF A SPHERE AND THE ADJACENT AND (TO THE CAMERA)\n    //     CLOSEST CUBE (ON AN INFINITE LATTICE OF CUBES) THAT IS\n    //     ENTIRELY CONTAINED INSIDE THE SPHERE\n\n    float dO = 0.0;\n    bool touchedSphere = false;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS;\n        \n        // touchedSphere does not change anything... how???\n        if (touchedSphere) {\n            // Negative so that we exit the sphere\n            dS = -sdClosestCube(p);\n        } else {\n            dS = sdSphere(trunc(p), iTime);\n            \n            if (dS <= EPSILON)  {\n                touchedSphere = true;\n                \n                // sdClosestCube(p) is negated so that we exit the sphere\n                // If my distance function would work properly, the sign would not make\n                // a lot of difference.\n                // Positive would mean that we are rendering the (visible) cubes that are\n                // entirely inside the sphere.\n                // Negative would mean that we are rendering the (visible) cubes that are just\n                // one unit away from the sphere, which would be the border of the sphere.\n                \n                // I actually want to render the cubes that are contained inside the\n                // sphere, but with my current implementation of the distance function\n                // only this (negated sign -> the border of the sphere) works.\n                dS = -sdClosestCube(p); \n            }\n        }\n\n        dO += dS;\n        if (abs(dS) <= EPSILON || dO > MAX_DISTANCE) break;\n    }\n\n    return dO;\n}\n\nvec4 intersection(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(DISTANCE);\n\n#ifdef ROTATE\n    ro *= vec3(cos(iTime), 1, sin(iTime));\n#endif\n\n    vec3 lookAt = vec3(0,0,0),\n         f = normalize(lookAt - ro),\n         r = normalize(cross(f, vec3(0,1,0))),\n         u = cross(r, f),\n         c = ro + f * ZOOM,\n         i = c + uv.x * r + uv.y * u,\n         rd = normalize(i - ro);\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    return vec4(p, d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = intersection(fragCoord);\n    vec4 px = intersection(fragCoord + vec2(1,0));\n    vec4 py = intersection(fragCoord + vec2(0,1));\n\n    // Background\n    fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    if (p.w <= MAX_DISTANCE && px.w <= MAX_DISTANCE && py.w <= MAX_DISTANCE)\n    {\n        vec3 dpdx = px.xyz - p.xyz;\n        vec3 dpdy = py.xyz - p.xyz;\n    \n        vec3 n = GetNormal(dpdx, dpdy);\n        fragColor = vec4(abs(n), 1.0);\n    }\n}\n\n/* */\n\n\n/* Implementation using ray tracing - does not work propely * /\n\n#define ZOOM 1.5\n\n\nvec3 GetNormal(vec3 p)\n{\n    vec3 difference = abs(p - round(p));\n    float closest = min(min(difference.x, difference.y), difference.z);\n    \n    if (closest == difference.x)\n        return sign(difference.x) * vec3(1,0,0);\n        \n    else if (closest == difference.y)\n        return sign(difference.y) * vec3(0,1,0);\n        \n    else if (closest == difference.z)\n        return sign(difference.z) * vec3(0,0,1);\n    \n    return vec3(0);\n    //return normalize(cross(dpdx, dpdy));\n    //return normalize(cross(dFdx(p), dFdy(p)));\n}\n\n\n// https://iquilezles.org/articles/intersectors/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0; // no intersection\n    return -b - sqrt(h);\n}\n\n\nvec4 intersection(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(DISTANCE);\n    vec3 lookAt = vec3(0,0,0),\n         f = normalize(lookAt - ro),\n         r = normalize(cross(f, vec3(0,1,0))),\n         u = cross(r, f),\n         c = ro + f * ZOOM,\n         i = c + uv.x * r + uv.y * u,\n         rd = normalize(i - ro);\n    \n    float d = sphIntersect(ro, rd, lookAt, iTime);\n    vec3 p = ro + rd * d;\n    \n    return vec4(p, d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = intersection(fragCoord);\n\n    // Background\n    fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    if (p.w > 0.0)\n    {\n        vec3 n = GetNormal(p.xyz);\n        fragColor = vec4(abs(n), 1.0);\n    }\n}\n\n/* */",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}