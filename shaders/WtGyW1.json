{
    "Shader": {
        "info": {
            "date": "1610900319",
            "description": "WIP. phase function of sphere (or cylinder) vs hexagonal prism (fix or random angle).\nSpace: shape = sphere-cyl  / hexa-prism (mouse.x = angle ) / random-angle hexa\n- red: reflection on shape\n- blue: refraction inside\n- green: + 1 internal reflection",
            "flags": 48,
            "hasliked": 0,
            "id": "WtGyW1",
            "likes": 1,
            "name": "phase function through shape",
            "published": 3,
            "tags": [
                "phenomena",
                "rainbow",
                "pathtracing",
                "ice",
                "fresnel",
                "arcs",
                "pillars",
                "glory",
                "sundogs",
                "parhelia",
                "halo120",
                "halo22"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 388
        },
        "renderpass": [
            {
                "code": "// 2D variant of \"aerial ice phenomena\" https://shadertoy.com/view/wtccz2\n\nvoid mainImage(out vec4 O, vec2 U) {   \n    O = T(U)/T(0).a;\n    O = pow( O, vec4(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define zoom            3.\n#define PI              3.1415927\n#define SQR(x)         (x)*(x)\n#define Fresnel(D,N,e)( e<1. ? fresnel(D,N,e) : fresnel(refract(D,N,e),N,e) )\n#define fresnel(D,N,e)  mix( pow( max(0.,1.-abs(dot(-D,N))), 5.), 1. , SQR((1.-e)/(1.+e)) )  // Schlick's approximation https://en.wikipedia.org/wiki/Schlick%27s_approximation\n#define keyDown(a)    ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n#if 0\n\n    #define hash(p)         fract(sin(dot(p,vec2(127.1,311.7))) *43758.5453123)   // https://www.shadertoy.com/view/llySRh\n\n#else\n\n// integer hash from https://www.shadertoy.com/view/XlXcW4\nvec3 ihash3( vec3 v ) {\n    uvec3 x = uvec3(v * float(0xffffffffU) );\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;   \n    return vec3(x)/float(0xffffffffU);\n}\n    #define hash(p) ihash3(vec3(fract((p)/100.),.5)).x\n\n#endif\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);                    // proj coord on line\n    return smoothstep(zoom*3./R.y,0.,length(p - b * h));               // dist to segment\n}\n\nvoid mainImage(out vec4 O, vec2 U) {   \n    O = T(U);                                                          // previous state\n    bool k = keyDown(32), b = keyDown(9);\n    if (U==vec2(.5)) { iMouse.z>0. || k || b ? O.a=1. : \n                       O.a++;                                          // cumulates - reset on mouse move\n                       if (k) O.x = mod(O.x+1.,3.);                    // SPACE: change crystal shape\n                       return; } \n    if  (iMouse.z>0.|| k || b )  O-=O; if(k) return;\n\n    int CASE = int(T(0).x);                                            // 0: sphere 1: cylinder 2: hexa-prism\n    \n    U = zoom*( 2.* U - R ) / R.y;    \n    vec2 D = vec2(1,0), _P,P,N, r,t,                                   // ray direction\n         M = iMouse.xy / R;\n    \n    for(float i=0.; i < 100.; i++) {                                   // samples per frame, then cumulates\n        vec2 d =  vec2( 2.*hash(vec2(i,iTime))-1.);                    // random sample on disk\n        float l, s = 1.*(i-1.11*iTime)/100., _s,                       // for hexa-cylinder: current side\n              f, I=8.;\n        if (CASE==1) s = M.x;                                          // manual tuning of hexa rotation\n              \n#define intersect(P,r) /* out: new P,N                                    internal intersection in shape */ \\\n     switch(CASE) {                                                                                         \\\n     case 0:                                                           /* sphere / cylinder */              \\\n        N = P -= 2.*dot(P,r) * r; break;                /*  |P + kr| = 1 → k² +2k(P.r) = 0 → k = -2(P.r) */ \\\n     case 1:                                                                                                \\\n     case 2:  vec2 n; l=99.;                                           /* hexa-cylinder ( WIP ) */          \\\n        for(float t,k=0.; k<6.; k++) {                                 /* case 0 for outside intersect */   \\\n            n = cos( (s+k)*PI/3. + vec2(0,PI/2.) );                                                         \\\n            t = ( sqrt(3.)/2. - dot(P,n) ) / dot(r,n);                 /* solve (OP+kr).n = cos(pi/6) */    \\\n            if (t>0. && t<l /* && length((P+t*r).xz)<1. */ ) l=t,/* _s=s+k,*/ N = n;   /* closest intersection > 0 */ \\\n          }                  /* start in convex hull so good even for 1st intersect                   */    \\\n        P += l*r;            /* s = _s;  */                                                                 \\\n        if (length(P) > 1.) I = 0.; /* continue;  /* forbiden on windows */                                 \\\n        break;                                                                                              \\\n     }\n\n#define C2S(c) sqrt(max(0., 1. - dot(c,c) ))                                                      // 2D renormalized version\n\n     _P = P = vec2(-3,d.x);\n     switch(CASE) {                                                    // 1st intersection on shape → N,P\n     case 0:\n        N = P = vec2(0,d.x) - C2S(d.x)*D;     break;                   // sphere / cylinder\n     case 1:                                                           // hexa-cylinder\n     case 2:\n        N = P = vec2(0,d.x) - C2S(d.x)*D;  \n        intersect(P,D); break;\n     }\n        O += .5*line(U,_P,P); _P = P;                                     // incoming ray\n\n        t = reflect(D,N);                                              // reflect on shape\n        f = Fresnel(D,N,1./1.3); // if (dot(-D,N)<-.1) O += log(-iTime); // test\n       // O.r += illu(t)* I * f;\n        O.r += line(U,_P,_P+10.*t) * I*f ;                             // reflected ray\n        I *= 1.-f;\n        r = refract(D,N,1./1.3);                                       // refraction in shape\n        intersect(P,r);                                                // next intersection\n        O.b += line(U,_P,P) * I; _P = P;                               // 1st internal ray\n        t = refract(r,-N,1.3);                                         // refraction out of shape\n        f = Fresnel(r,-N,1.3);  // if (dot(r,N)<-.1) O += log(-iTime); // test\n     // if (t!=vec2(0))  O.b += illu(t)* I * (1.-f);                   // ... but if total reflection\n        if (t!=vec2(0))  O.b +=  line(U,_P,_P+60.*t) * I * (1.-f);     // main exit \"lense ray\"                  // ... but if total reflection\n        for (int j=0; j<1; j++) {                                      // loop on internal bounces\n          I *= f;\n          r = reflect(r,-N);                                           // internal reflection\n          intersect(P,r);                                              // next intersection\n          O += line(U,_P,P) * I; _P = P;                               // internal reflected ray\n          t = refract(r,-N,1.3);                                       // refraction out of sphere\n          f = Fresnel(r,-N,1.3);  // if (dot(r,N)<-.1) O += log(-iTime); // test\n       // if (t!=vec2(0))  O.g += illu(t) * I * (1.-f);                // ... but if total reflection\n          if (t!=vec2(0))  O.g +=  line(U,_P,_P+60.*t) *  I * (1.-f);                   // ... but if total reflection\n        }\n}\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}