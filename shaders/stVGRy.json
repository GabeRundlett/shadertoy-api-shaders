{
    "Shader": {
        "info": {
            "date": "1638548003",
            "description": "Improved version of my terraforming shader. Better sphere mapping (still imperfect), and better interactivity. Click to add matter, use the left side buttons to change element type.",
            "flags": 32,
            "hasliked": 0,
            "id": "stVGRy",
            "likes": 38,
            "name": "Improved terraforming",
            "published": 3,
            "tags": [
                "interactive",
                "planet",
                "diffusion",
                "reaction"
            ],
            "usePreview": 0,
            "username": "hamtarodeluxe",
            "viewed": 686
        },
        "renderpass": [
            {
                "code": "#define RMSTEPS 75\n\nvec4 getData(vec3 p)\n{\n    vec4 v = texture(iChannel0, dirToUV(p)*simResRatio);\n    return vec4(v.x, v.y, v.z, v.w);\n}\n\nfloat hash( uint n ) //iq\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat getHeight(vec4 data, vec3 p)\n{\n    vec3 type = typeCoefs(data);\n    float h = 0.01;\n    h += (MAXDISP * ((1.-data.x)*0.2 + 0.3))*type.x;\n    h += (MAXDISP * (pow(data.y, 0.125)*0.4 + 0.3))*type.y ;\n    h += (MAXDISP * (pow(1.-data.y,0.5)*0.5 + 0.3))*type.z ;\n\n    return h;//*0. + 0.3;\n}\n\nvec3 normals(vec3 p)\n{\n    vec3 n;\n    float EPS = 0.01f;\n    vec3 e = vec3(EPS,0.,0.);\n    float baseR = RADIUS-MAXDISP;\n    n.x = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n    \n    e = vec3(0.,EPS,0.);\n    n.y = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n\n    e = vec3(0.,0., EPS);\n    n.z = length(p + e) - getHeight(getData(p+e), p+e) - (length(p - e) - getHeight(getData(p-e), p-e));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 dc = (vec2(fragCoord)/iResolution.xy)*2.-1.;\n\tdc.y *= float(iResolution.y)/float(iResolution.x);\n    \n    vec3 ro = cameraPos(iTime);\n\tvec3 rd = cameraRay(dc, ro);\n    \n    float h = hash(uint(fragCoord.x)+uint(fragCoord.y*iResolution.x)+uint(iFrame)*uint(iResolution.x*iResolution.y));\n    \n    vec3 hitSphP = vec3(1000., 1000.,1000.);\n    vec2 hitTs = vec2(1000.,1000.);\n    bool hitSph = isecSphere(ro, rd, vec3(0.), RADIUS, hitTs, hitSphP);\n    bool hitSurf = false;\n    vec3 p = vec3(0.);\n    vec4 data = vec4(1.);\n\n    if (hitSph)\n    {\n        vec3 hitSphPIn = vec3(1.,1.,1.);\n        vec2 hitTsSphIn = vec2(100.);\n        bool hitSphIn = isecSphere(ro, rd, vec3(0.), RADIUS-MAXDISP, hitTsSphIn, hitSphPIn);\n        float maxT = min(hitTs.y, hitTsSphIn.x) - hitTs.x;\n\n        float d = 500.;\n        ro = hitSphP;\n        float tLength = maxT / float(RMSTEPS);\n        float t = tLength * h;\n\n        float prevSurfH = MAXDISP;\n        \n        float baseR = RADIUS-MAXDISP;\n\n        for (int i = 0; i<RMSTEPS; i++)\n        {\n            p = ro + t*rd;\n            vec3 pNorm = normalize(p);\n            \n            data = getData(p);     \n            float surfH = getHeight(data, pNorm);\n            float h = length(p) - baseR; \n            \n            if(h<surfH)\n            {           \n                float maxSurfH = prevSurfH;\n                float minSurfH = surfH; \n                float maxT = t - tLength;\n                float minT = t;\n                float maxDelta = (length(ro + maxT*rd) - baseR)-maxSurfH;\n                float minDelta = minSurfH-h;\n\n                t = mix(minT, maxT, minDelta / (maxDelta+minDelta));\n                p = ro + t*rd;\n                pNorm = normalize(p);\n                h = length(p) - baseR;\n                data = getData(pNorm); \n                surfH = getHeight(data, pNorm);\n\n                for (int j = 0; j < 3; j++)\n                {\n                    if (h < surfH)\n                    {\n                        minT = t;\n                        minSurfH = surfH;\n                    }\n                    else\n                    {\n                        maxT = t;\n                        maxSurfH = surfH;\n                    }\n                    maxDelta = (length(ro + maxT*rd) - baseR)- maxSurfH;\n                    minDelta = minSurfH-(length(ro + minT*rd) - baseR);\n                  \n                    t = mix(minT, maxT, minDelta / (maxDelta+minDelta));\n                    p = ro + t*rd;\n                    pNorm = normalize(p);\n                    h = length(p) - baseR;\n                    data = getData(pNorm); \n                    surfH = getHeight(data, pNorm);\n                }\n\n                hitSurf = true;\n                t = t; \n                break;\n            }\n            prevSurfH = surfH;\n            t+=tLength;\n        }\n\n    }\n    \n    vec3 col = vec3(0.05);\n    \n    // Shading\n    if (hitSurf)\n    {\n        vec3 type = typeCoefs(data);\n        \n        float maxType = max(type.y,max(type.x,type.z));\n        float trans = maxType - (type.x+type.y+type.z-maxType)*0.5; // transition between types\n        trans = pow(trans,3.);\n        \n        vec3 col0 = mix(vec3(0.,0.2,0.35),0.8*vec3(0.05,0.8,1.),1.-data.x);\n        col0 = 0.8*mix(col0,vec3(0.025,0.8,1.), clamp(((1.-data.x)-0.7)/0.3, 0., 1.));\n\n        vec3 col1 = mix(vec3(0.05, 0.1, 0.05), vec3(0.5, 0.7, 0.05),pow(data.y,0.7));\n        \n        vec3 col2 = mix(vec3(0.15, .075, 0.1)*0.5,vec3(1., .5, 0.15),pow(data.x,2.5));\n\n        col = col0 * type.x + col1 * type.y + col2 * type.z;\n                        \n        float e =0.1f;\n        vec3 n = normals(p);\n        vec3 lightDir = vec3(0.57);\n        \n        vec3 ref = normalize(reflect (lightDir, n));\n        \n        float spec = clamp(dot(ref,rd),0.,1.);\n        spec = 0.75*type.x*pow(spec, 40.) + \n               0.2* type.y*pow(spec, 1.) + \n               0.2* type.z*pow(spec, 3.);\n\n        col += vec3(1.) * spec * trans;\n        \n        float fresnel = 1.-abs(dot(rd, n));\n        col += vec3(0.5,1.,1.)*0.125*type.x * pow(fresnel, 1.);\n        col += 0.3*type.y * pow(fresnel, 2.);\n        col += 0.1*type.z * pow(fresnel, 1.25);\n     }\n    \n    col *= 1./pow((pow(sqrt(0.05*h+dot(dc * 2., dc * 2.)*.4),2.)+1.),3.);\n    \n    // UI\n    {\n        float fl = clamp(floor((dc.y + UIRADIUS * 2.)/(UIRADIUS*4.)),-1., 1.);\n        \n        vec2 discPos = vec2(UIXOFFSET, fl*UIRADIUS*4.) ;\n        float l = length(dc-discPos);    \n        \n        uint typeI = uint(texelFetch(iChannel0, ivec2(iResolution.xy - 1.0), 0).w);\n        float ss = 0.005*(800./iResolution.x);\n        float tSelect = typeI == uint(fl + 1.) ? smoothstep(UIRADIUS+0.01, UIRADIUS+0.01+ss, l) : 1.;\n        col.rgb = mix(vec3(1.,1.,1.), col.rgb, tSelect);\n        \n        col.rgb = mix(typeColors[uint(fl + 1.)], col.rgb, smoothstep(UIRADIUS, UIRADIUS+ss, l));\n    }\n    vec3 hTexCoords = fract(vec3(fragCoord, iFrame)/32.);\n\n    float d = texture(iChannel1, vec3(hTexCoords)).r;\n\n    fragColor = vec4(pow(col, vec3(1. / 2.2)),1.0) + d * (2./255.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RADIUS 0.6\n#define MAXDISP 0.3\n#define UIRADIUS 0.04\n#define UIXOFFSET -0.85\n\n#define simRes min(iResolution.yy, vec2(450, 450))\n#define simResRatio ((simRes-1.)/(iResolution.xy-1.))\n\nvec2 fks[] = vec2[](vec2(0.014, 0.045), vec2(0.03, 0.0565), vec2(.0545, 0.062));\nvec3 typeColors[] = vec3[](vec3(0., 1., 1.), vec3(.2, 1., 0.13), vec3(1., .5, 0.15));\n\nfloat linstep(float x, float y, float t)\n{\n    return clamp((t-x)/(y-x), 0.,1.);\n}\n\nfloat noise (vec3 x, sampler3D tex)\n{\n    // Smoothing distance to texel\n    // https://iquilezles.org/articles/texture\n    x*=32.;\n    x += 0.5;\n    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\tx = f+i;    \n    x -= 0.5;\n    \n    return texture(tex, x/32.0).x;\n}\n\nbool isecSphere(vec3 ro, vec3 rd, vec3 pos, float r, out vec2 outT, out vec3 outP)\n{\n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,(ro-pos));\n    float c = dot((ro-pos),(ro-pos))-r*r;\n    float d = b*b-4.*a*c;\n    outP = vec3(0.);\n    outT = vec2(100.);\n    if (d<0.)\n        return false;\n\n    float sd = sqrt(d);\n    outT = vec2((-b-sd)/(2.*a),(-b+sd)/(2.*a)); \n    outT = vec2(min(outT.x, outT.y), max(outT.x, outT.y));\n    outP = ro + rd*outT.x;\n    outT = abs(outT);\n    return true;\n}\n\nvec3 cameraPos(float time)\n{\n    time *= 0.25f;\n    float sTime = sin(time);\n    return (1. + 0.1 * sTime) * vec3 (cos(time), 1., sTime);\n}\n\nvec3 cameraRay(vec2 dc, vec3 ro)\n{\n    vec3 lookAt = vec3(0.);\n\tvec3 fw = normalize(lookAt-ro);\n\tvec3 rg = normalize(vec3(-fw.z,0,fw.x));\n\tvec3 up = normalize(cross(rg,fw));\n\tfloat fo = 1.5;\n\tvec3 rd = normalize(fw * fo + up * dc.y + rg * dc.x);\n\treturn rd;\n}\n\nvec3 UVToDir(vec2 uv)\n{\n    vec3 position = vec3(2.0f * (uv.x - 0.5f), 0, 2.0f * (uv.y - 0.5f));                \n\n    vec2 absolute = abs(position.xz);\n    position.y = 1.0f - absolute.x - absolute.y;\n\n    if(position.y < 0.) {\n        position.xz = sign(position.xz) * (1.0-absolute.yx);\n    }\n    \n    return normalize(position);\n}\n\n// Expects normalized input\nvec2 dirToUV(vec3 dir)\n{\n    vec3 s = sign(dir);\n\n    float sum = dot(dir, s);        \n    vec3 oct = dir / sum;    \n\n    if(dir.y < 0.)\n    {\n        vec3 a = abs(oct);\n        oct.xz = s.xz * (vec2(1.0f) - a.zx);\n    }\n\n    return oct.xz * 0.5f + 0.5f;\n}\n\nvec2 os[8] = vec2[](vec2(0,1),\n                    vec2(0,-1),\n                    vec2(1,0),\n                    vec2(-1,0),  \n                    vec2(1,1),   \n                    vec2(1,-1),  \n                    vec2(-1,1), \n                    vec2(-1,-1));                 \n\nvec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    vec2 v0 = b - a;\n    vec2 v1 = c - a;\n    vec2 v2 = p - a;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float u = (d11 * d20 - d01 * d21) / denom;\n    float v = (d00 * d21 - d01 * d20) / denom;\n    float w = 1.0f - v - u;\n    return vec3 (w, u, v);\n}\n\nvec3 typeCoefs(vec4 data)\n{\n    return barycentric(data.zw, fks[0], fks[1], fks[2]);\n}\n\nvec4 runKernel(vec2 fragCoord, vec2 iResolution, sampler2D iChannel0, sampler3D noiseTex, float time)\n{  \n    vec4 sampleMid = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    if (fragCoord.x >= iResolution.x || fragCoord.y >= iResolution.y) return sampleMid;\n    \n    vec2 C = sampleMid.xy;  \n    \n    vec2 values[8];\n    vec2 k = vec2(0.);\n    float w = 0.;\n    vec3 debug= vec3(0.);\n    bool toto = false;\n    vec3 cP = UVToDir(fragCoord/iResolution);\n    for (int i = 0; i < 8; i++)\n    {\n        float d = 1.;\n        vec2 samp = fragCoord + os[i];\n        \n        vec2 dd = samp - clamp(samp, vec2(0.), iResolution + vec2(0.,0.));\n        vec2 add = abs(dd);\n        if (add.x > 0.0 && add.y > 0.0)\n        {\n            d = 0.;\n        }\n        if (add.x > 0.)\n        {\n            samp.x = fragCoord.x;\n            samp.y = samp.y - 2. * (samp.y - iResolution.y * 0.5);\n        }\n        else if (add.y >0.)\n        {\n            samp.y = fragCoord.y;\n            samp.x = samp.x - 2. * (samp.x - iResolution.x * 0.5);\n        }\n        vec3 sP = UVToDir(samp/iResolution);\n        vec3 l = cP-sP;\n        d /= dot(l, l);\n        \n    \tk += d*texelFetch(iChannel0, ivec2(samp),0).xy;\n        \n        w += d;\n    } \n\n    k/= w;\n    \n    vec2 D = k-C;\n    float s = 1.;\n    vec2 dr = 1.*vec2(1.,0.5);\n        \n    vec2 fk = sampleMid.zw;\n\n    float feed = fk.x;\n  \tfloat kill = fk.y;\n\n    vec2 nextC;\n\tnextC.x = C.x + (D.x*dr.x-C.x*C.y*C.y + feed*(1.-C.x))*s;\n    nextC.y = C.y + (D.y*dr.y+C.x*C.y*C.y -(kill+feed)*C.y)*s;\n\tC = nextC;\n    \n    return vec4(C, sampleMid.zw);\n}\n\n#define RUNKERNEL runKernel(fragCoord.xy, simRes, iChannel0, iChannel1, iTime);      \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n          \n    vec2 mouseDc = (vec2(iMouse.xy)/iResolution.xy)*2.-1.;\n\tmouseDc.y *= float(iResolution.y)/float(iResolution.x);\n    \n    vec3 ro = cameraPos(iTime);\n\tvec3 rd = cameraRay(mouseDc, ro);   \n    vec3 hitSphP = vec3(1.);\n    vec2 outT = vec2(1000.);\n    bool hitSph = isecSphere(ro, rd, vec3(0.), RADIUS-MAXDISP*0.5, outT, hitSphP);\n    \n    vec4 C = RUNKERNEL\n\n    if (iMouse.z > 0. && hitSph && ivec2(fragCoord.xy) != ivec2(iResolution.xy - 1.0))\n    {\n        vec3 pTex = UVToDir(uv/simResRatio);\n        vec3 pMouse = normalize(hitSphP);\n        float l = clamp(length(pTex-pMouse)/0.125, 0., 1.);\n \n    \tC.y += 0.1 * (1.-smoothstep(0.3,0.4, l));\n\n        uint typeI = uint(texelFetch(iChannel0, ivec2(iResolution.xy - 1.0), 0).w);\n\n        C.zw = mix(C.zw, fks[typeI], 0.5*(1.-linstep(0.1,0.8, l)));\n    } \n    \n    C.xy = clamp(C.xy,vec2(0.0),vec2(1.));\n        \n    if (dot(C.zw, C.zw) < 0.001)\n        C.zw = fks[0];\n        \n    fragColor = C;\n    \n    if (iFrame == 0)\n        fragColor = vec4(0.,0., fks[0]);\n    \n    if (ivec2(fragCoord.xy) == ivec2(iResolution.xy - 1.0))\n    {\n        if (iFrame == 0)\n            fragColor.w = 1.0f;\n        else if (iMouse.z > 0.)\n        {\n            float fl = clamp(floor((mouseDc.y + UIRADIUS * 2.)/(UIRADIUS*4.)),-1., 1.);\n            vec2 discPos = vec2(UIXOFFSET, fl*UIRADIUS*4.) ;\n            float l = length(mouseDc-discPos);\n            if (l < UIRADIUS)\n                fragColor.w = floor(fl + 1.);\n        }\n    }  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = RUNKERNEL\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = RUNKERNEL\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = RUNKERNEL\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}