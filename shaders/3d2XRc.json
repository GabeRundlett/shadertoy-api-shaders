{
    "Shader": {
        "info": {
            "date": "1557455811",
            "description": "Experimenting with returning the vector to the  nearest voronoi cell center and nearest edge. Using both vectors to do some interesting shading effects.",
            "flags": 0,
            "hasliked": 0,
            "id": "3d2XRc",
            "likes": 10,
            "name": "Voronoi Min Vector Shading",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "FrickHazard",
            "viewed": 724
        },
        "renderpass": [
            {
                "code": "// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#define GRID_SIZE 10.0\n#define SHADING_METHOD_SEED 112.7\n#define SHADING_METHOD_DURATION_TIME 8.0\n#define SHADING_METHOD_TRANSITION_TIME 2.0\n#define OFFSET_FUNTCION_SEED 22.4\n#define OFFSET_FUNTCION_DURATION_TIME 16.\n#define OFFSET_FUNTCION_TRANSITION_TIME 2.0\n#define PALETTE_SEED 324.6\n#define PALETTE_DURATION_TIME 10.\n#define PALETTE_TRANSITION_TIME 2.0\n#define PI 3.14159265\n\nfloat hash11(float p){p = fract(p * .1031);p *= p + 19.19;p *= p + p;return fract(p);}\nfloat hash12(vec2 p){ vec3 p3  = fract(vec3(p.xyx) * .1031); p3 += dot(p3, p3.yzx + 19.19);return fract((p3.x + p3.y) * p3.z);}\nvec2 hash21(float p){vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));p3 += dot(p3, p3.yzx + 19.19);return fract((p3.xx+p3.yz)*p3.zy);}\nmat2 rotate2d(float _angle){return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));}\n\nfloat panSequence = 0.;\nfloat rotateSequence = 0.;\nfloat shadingMethodTick = 0.;\nfloat shadingMethodTransition = 0.;\nfloat offsetFunctionTick = 0.;\nfloat offsetFunctionTransition = 0.;\nfloat paletteTick = 0.;\nfloat paletteTransition = 0.;\n\nvoid sequence()\n{\n  panSequence =    smoothstep(0.0, 4.0, mod(iTime, 20.)) - smoothstep(8.0, 12.0, mod(iTime, 20.));\n  rotateSequence = smoothstep(0.0, 3.0, mod(iTime, 10.)) - smoothstep(6.0,  9.0, mod(iTime, 10.));\n  shadingMethodTick = floor(iTime / SHADING_METHOD_DURATION_TIME);\n  shadingMethodTransition = smoothstep(0.0, SHADING_METHOD_TRANSITION_TIME, mod(iTime, SHADING_METHOD_DURATION_TIME));\n  offsetFunctionTick = floor((iTime + OFFSET_FUNTCION_TRANSITION_TIME) / OFFSET_FUNTCION_DURATION_TIME);\n  offsetFunctionTransition = smoothstep(0.0, OFFSET_FUNTCION_TRANSITION_TIME, mod((iTime + OFFSET_FUNTCION_TRANSITION_TIME), OFFSET_FUNTCION_DURATION_TIME));\n  paletteTick = floor(iTime / PALETTE_DURATION_TIME);\n  paletteTransition = smoothstep(0.0, PALETTE_TRANSITION_TIME, mod(iTime, PALETTE_DURATION_TIME));\n}\n// iq's palette function\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b * cos(2. * PI * (c * t + d));\n}\nvec3 randomPalette(float seed, float uniqCellSeed)\n{\n  switch(int(floor(seed * 4.)))\n  {\n      case 0: return palette(uniqCellSeed, vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.0, 0.25, 0.25));\n      case 1: return palette(uniqCellSeed, vec3(0.2, 0.3, 0.7), vec3(0.7, 0.7, 0.5), vec3(1. , 1. , 0.8), vec3(0.4, 0.33, 0.5 ));\n      case 2: return palette(uniqCellSeed, vec3(0.5, 0.4, 0.5), vec3(0.5, 0.5, 0.5), vec3(1. , 1. , 1. ), vec3(0.3, 0.6, 0.6));\n      case 3: return palette(uniqCellSeed, vec3(0.5, 0.8, 0.5), vec3(0.6, 0.4, 0.8), vec3(1. , 0.8 , 0.4 ), vec3(1., 1., 0.1));\n  }\n}\nvec3 randomColor(float uniqCellSeed)\n{\n    return mix(\n      randomPalette(hash12(vec2(PALETTE_SEED, paletteTick     )), uniqCellSeed),\n      randomPalette(hash12(vec2(PALETTE_SEED, paletteTick + 1.)), uniqCellSeed),\n      paletteTransition);\n}\nfloat isoLine(float dist, float lineScale){return abs(sin(lineScale * dist));}\n// -------------- different ways to render voronoi data  ------------------\nvec3 randomShadingMethod(vec4 voronoiData, float seed, float uniqCellSeed)\n{\n    float angle = abs(dot(normalize(voronoiData.xy), normalize(voronoiData.wz)));\n    float determinantValue = abs(voronoiData.x * voronoiData.w - voronoiData.z * voronoiData.y);\n    switch (int(floor(seed * 8.)))\n    {\n        case 0: return vec3(isoLine(length(voronoiData.zw), 20.)) * length(voronoiData.zw);\n        case 1: return isoLine(length(voronoiData.xy), 20.) * randomColor(uniqCellSeed);\n        case 2: return vec3(mix(0., 1., smoothstep(0.07, 0.14, length(voronoiData.xy)))) * randomColor(uniqCellSeed);\n        case 3: return angle * randomColor(uniqCellSeed);\n        case 4: return determinantValue * randomColor(uniqCellSeed);\n        case 5: return length(voronoiData.xy) / length(voronoiData.wz) * randomColor(uniqCellSeed);\\\n        case 6: return min(length(voronoiData.xy), length(voronoiData.wz)) * randomColor(uniqCellSeed);\n        case 7: return smoothstep(0., 0.1, length(voronoiData.xy) - length(voronoiData.wz)) * randomColor(uniqCellSeed);\n    } \n}\nvec3 getVoronoiColor(vec4 voronoiData, float uniqCellSeed)\n{\n   return mix(\n      randomShadingMethod(voronoiData, hash12(vec2(SHADING_METHOD_SEED, shadingMethodTick     )), uniqCellSeed),\n      randomShadingMethod(voronoiData, hash12(vec2(SHADING_METHOD_SEED, shadingMethodTick + 1.)), uniqCellSeed),\n      shadingMethodTransition);\n}\nvec2 getRandomCellOffsetFunction(vec2 pos, float seed, float uniqCellSeed)\n{\n   switch (int(floor(seed * 4.0)))\n   {\n       case 0: return vec2(sin(pos.y + iTime * 2.), cos(pos.x + iTime * 2.)) * normalize(pos + vec2(0.0001));\n       case 1: return hash21(uniqCellSeed) * vec2(mod(pos.y, 3.) * cos(iTime * 2.), mod(pos.x, 3.) * sin(iTime * 2.));\n       case 2: return vec2(0.4 * sin(iTime + PI * 2. * hash21(uniqCellSeed)));\n       case 3: return vec2(uniqCellSeed);\n   }\n}\nvec2 getCellOffsetFunction(vec2 pos, float uniqCellSeed)\n{\n    vec2 cellOffset = mix(\n      getRandomCellOffsetFunction(pos, hash12(vec2(OFFSET_FUNTCION_SEED, offsetFunctionTick     )), uniqCellSeed),\n      getRandomCellOffsetFunction(pos, hash12(vec2(OFFSET_FUNTCION_SEED, offsetFunctionTick + 1.)), uniqCellSeed),\n      offsetFunctionTransition);\n   float halfGridCellSideLength = 0.4999;\n   return clamp(cellOffset, -halfGridCellSideLength, halfGridCellSideLength);\n}\nvec4 voronoiGrid(vec2 pixelCoord, out float outCellSeed)\n{\n    vec2 centerOfCellFromGridOffset = vec2(0.5, 0.5);\n    vec2 gridLocation = floor(pixelCoord);\n    vec2 normalizedLocalGridCoord = fract(pixelCoord);\n\n    float minimumDistanceToCenter = GRID_SIZE;\n    vec2 minimumgridOffset, minimumVectorToAdjacentVoronoiCellCenter;\n    // first pass min distance from cell center\n    for(int j=-2; j<=2; j++)\n    for(int i=-2; i<=2;  i++)\n    {\n       vec2 gridOffset = vec2(float(i), float(j));\n        \n       vec2 adajacentCell = gridLocation + gridOffset;\n        \n       float cellSeed = hash12(adajacentCell);\n        \n       vec2 offset = getCellOffsetFunction(adajacentCell, cellSeed) + centerOfCellFromGridOffset;\n        \n       vec2 vectorToAdjacentVoronoiCellCenter = (gridOffset + offset) - normalizedLocalGridCoord;\n       float distanceToCenter = length(vectorToAdjacentVoronoiCellCenter);\n       if (distanceToCenter < minimumDistanceToCenter) {\n           outCellSeed = cellSeed;\n           minimumDistanceToCenter = distanceToCenter;\n           minimumgridOffset = gridOffset;\n           minimumVectorToAdjacentVoronoiCellCenter = vectorToAdjacentVoronoiCellCenter;\n       }\n    }\n    // second pass min distance to border\n    float minimumDistanceToBorder = GRID_SIZE;\n    vec2 minimumVectorToVoronoiCellBorder;\n    for(int j=-2; j<=2; j++)\n    for(int i=-2; i<=2; i++)\n    {\n       vec2 gridOffset = minimumgridOffset + vec2(float(i), float(j));\n        \n       vec2 adajacentCell = gridLocation + gridOffset;\n        \n       float cellSeed = hash12(adajacentCell);\n        \n       vec2 offset = getCellOffsetFunction(adajacentCell, cellSeed) + centerOfCellFromGridOffset;\n        \n       vec2 vectorToAdjacentVoronoiCellCenter = (gridOffset + offset) - normalizedLocalGridCoord;\n        \n       // skip if same point\n       if( dot(minimumVectorToAdjacentVoronoiCellCenter - vectorToAdjacentVoronoiCellCenter,\n               minimumVectorToAdjacentVoronoiCellCenter - vectorToAdjacentVoronoiCellCenter) > 0.00001)\n       {\n          vec2 segmentNormal = normalize(vectorToAdjacentVoronoiCellCenter - minimumVectorToAdjacentVoronoiCellCenter);\n          float scalarProjection = dot(0.5 * (minimumVectorToAdjacentVoronoiCellCenter + vectorToAdjacentVoronoiCellCenter),\n                      segmentNormal);\n          if (scalarProjection < minimumDistanceToBorder) {\n              vec2 vectorProjection = segmentNormal * scalarProjection;\n              minimumVectorToVoronoiCellBorder = vectorProjection;\n              minimumDistanceToBorder = scalarProjection;\n          }\n       }\n    }\n    return vec4(minimumVectorToVoronoiCellBorder, minimumVectorToAdjacentVoronoiCellCenter);\n}\n\nvec2 rotate(vec2 pixelCoord)\n{\n    float aspect = (iResolution.y / iResolution.x);\n    vec2 centerShift = vec2(0.5, 0.5 * aspect);\n    float speed = 0.15;\n    pixelCoord -= centerShift;\n    pixelCoord = rotate2d(rotateSequence * PI * speed) * pixelCoord;\n    pixelCoord += centerShift;\n    return pixelCoord;\n}\nvec2 pan(vec2 pixelCoord)\n{ \n  float seed = floor(iTime / 20.);\n  float speed = mix(0., 1.0, panSequence);\n  return pixelCoord + normalize(vec2(hash21(seed)) + 0.0001) * speed;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    sequence();\n    \n    vec2 pixelCoord = (gl_FragCoord.xy - 0.5 * iResolution.xy)/iResolution.xy;\n    pixelCoord.x *= iResolution.x/ iResolution.y;\n\n    pixelCoord = rotate(pixelCoord);\n    pixelCoord = pan(pixelCoord);\n    pixelCoord *= GRID_SIZE;\n    \n    float uniqCellSeed;\n    vec4 voronoiResult = voronoiGrid(pixelCoord, uniqCellSeed);\n\n    fragColor = vec4(getVoronoiColor(voronoiResult, uniqCellSeed), 1.0f);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}