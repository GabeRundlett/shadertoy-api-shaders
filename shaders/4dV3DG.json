{
    "Shader": {
        "info": {
            "date": "1456200586",
            "description": "A modified version of the slow Carousel #1. This version is based on Inigo Quilez' \"Raymarching Primitives\" code.",
            "flags": 64,
            "hasliked": 0,
            "id": "4dV3DG",
            "likes": 2,
            "name": "Carousel 2: horsPwr++; shiny--;",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "modeling"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 1259
        },
        "renderpass": [
            {
                "code": "/*\n \tCarousel 2 : horsepower++ ; shiny--;\n \t\tby wjbgrafx\n \t\t\n \tThis code is a slightly modified version of\n \tRaymarching Primitives\n\thttps://www.shadertoy.com/view/Xds3zN\t\n \tCreated by inigo quilez - iq/2013\n \tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported \n\t\n\tAdditional sources:\n\n\tAntialiasing code in the castRay() function\n \tFrom \"Edge AA\"   Uploaded by Trisomie21 on 2014-Jul-29\n\thttps://www.shadertoy.com/view/MsfXDS\n\t\n\tgetRayDir() function\n\tFrom \"Distance Functions Playground, by Ruslan Shestopalyuk, 2014/15\n\thttps://www.shadertoy.com/view/MtXGDr\n\n\tcreateCamRotMatrix() function\n\tFrom\t\"Simple test/port of Mercury's SDF library to WebGL\"\n \thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh on 2015-Dec-16\n\n\t\"4-tap\" calcNormal() function\n\thttp://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n    Author - Gary \"Shane\" Warne\n\t\n\tUnsigned Triangle function by Inigo Quilez\t\n\thttps://iquilezles.org/articles/distfunctions\n\n\tSmooth Minimum blending function by Otavio Good\n\thttps://www.shadertoy.com/view/XtjXWD\n\n\tHG_SDF GLSL Library for building signed distance bounds by MERCURY\n\thttp://mercury.sexy/hg_sdf\n\t\n\t--------------------------------\n\tEditing and modification by wjb. \n\t\n\tThe modeling code within the map() function is licensed under a Creative\n\tCommons Attribution-NonCommercial-ShareAlike 4.0 International License.\n*/\n//==============================================================================\n\n#define PI \t\t\t\t\t3.1415926535897932384626433832795\n\n#define CAM_DIST \t\t\t75.0\n#define MAX_RAY_DIST\t\t150.0\n#define LOOK_AT  \t\t\tvec3( 0.0, 2.0, 0.0 )\n#define CAM_FOV_FACTOR\t\t4.0\n#define NUM_RAY_STEPS\t\t100\n\nvec3 lightPos = vec3( 0.0 );\n\n//------------------------------------------------------------------------------\n// Function declarations\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ); \nmat4 createCamRotMatrix();\nvec3 applyTexture( vec4 hitPosAndID );\nvec3 texture1( vec3 pos );\nvec3 texture2( vec3 pos );\nvec3 texture3( vec3 pos );\nvec3 texture4( vec3 pos );\nvec3 texture5( vec3 pos );\nvec3 texture6( vec3 pos );\nvec3 texture7( vec3 pos );\n\n// Comments here are from the HG_SDF Library.\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions);\nfloat fSphere(vec3 p, float r);\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius);\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height);\n// Cone with correct distances to tip and base circle. \n// Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height);\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c );\nfloat snoise(vec3 v);\nfloat smin(float a, float b);\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map( vec3 p ) \n{\n\t// Copy p before repetition domain operation.\n\tvec3 p0 = p;\n\n\t// Ground Plane\n\tfloat objID = 1.0;\n\tvec2 ground = vec2( fPlane( p - vec3( 0.0, -1.0, 0.0 ),\n\t                      normalize( vec3( 0.0, 1.0, 0.0 ) ), 1.0 ), objID );\t\n\t\n\t// Ground ring for inner structure frame.\n\tobjID = 2.0;\n\tvec2 inGrndRing = vec2( fTorus( p - vec3( 0.0, -1.85, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\t\t\n\t// Top ring for inner structure frame.\n\tvec2 inUprRing = vec2( fTorus( p - vec3( 0.0, 9.7, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\t\n\t// Ground ring for outer structure frame.\n\tobjID = 3.0;\n\tvec2 outGrndRing = vec2( fTorus( p - vec3( 0.0, -1.85, 0.0 ), 0.15, 20.0 ), \n\t                                                                   objID );\t\n\t// Top ring for outer structure frame.\n\tvec2 outUprRing = vec2( fTorus( p - vec3( 0.0, 10.0, 0.0 ), 0.15, 20.0 ), \n\t                                                                   objID );\t\n\t// Roof\n\tobjID = 4.0;\n\tvec2 roof = vec2( fCone( p - vec3( 0.0, 10.0, 0.0 ), 20.0, 5.0 ), objID );\n\t\n\t// Repetition : \n\t//------------------------------------\n\tfloat segNum = pModPolar( p.xz, 6.0 );\n\t//------------------------------------\n\t\n\t// Inner ring poles\n\tobjID = 2.0;\n\tvec2 inrPole = vec2( fCylinder( p - vec3( 10.0, 0.0, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\n\t// Outer ring poles\n\tobjID = 3.0;\n\tvec2 outrPoleA = vec2( fCylinder( \n\t                       p - vec3( 19.3, 0.0, -5.0 ), 0.15, 10.0 ), objID );\n\t                                                                   \n\tvec2 outrPoleB = vec2( fCylinder( \n                           p - vec3( 19.3, 0.0,  5.0 ), 0.15, 10.0 ), objID );\n\t                                                                   \n\t// Roof dividers\n\tvec2 rfDivA = vec2( fCapsule( p, vec3( 19.3, 10.0, 5.0 ),\n\t                                 vec3(  0.0, 15.0, 0.0 ), 0.1 ), objID );\n\t\n\tvec2 rfDivB = vec2( fCapsule( p, vec3( 19.3, 10.0, -5.0 ),\n\t                                 vec3(  0.0, 15.0, 0.0 ), 0.1 ), objID );\n\t\n\t//------------------------------------\t\n\t// Calculating horse up/down movement.\n\t//------------------------------------\n\t// From the HG_SDF Library:\n\t// \"Many of the operators partition space into cells. An identifier\n\t// or cell index is returned, if possible. This return value is\n\t// intended to be optionally used e.g. as a random seed to change\n\t// parameters of the distance functions inside the cells.\"\n\t\n\t// I used the variable segNum for the return values, but they were not the\n\t// simple values I'd expected. The ranges or exact values returned for each \n\t// segment ( direction ) are listed below. So it wasn't just simply a matter\n\t// of testing for an individual value, it required testing in a certain\n\t// order: NW, NE, E, SE, W, SW, S, else N \n\t\n\t// nothing >3 or <-2\n\t// NW,W >2 and <=3\n\t// SW,W,NW >1 and <=2\n\t// nothing >1 and <2\n\t// NE,E,SE = 1\n\t// nothing >0 and <1\n\t// NE,E = 0\n\t// nothing >-1 and <0\n\t// NE = -1\n\t// nothing >-2 and <-1\n\t// NW = -2\n\t// nothing <-2\n\n\t// Assign varying y-coords for each horse copy.\n\tfloat bodyPosY = 0.0;\n\n\tif ( segNum <= -2.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime );\n\t}\n\telse if ( segNum < -1.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 150.0 );\n\t}\n\telse if ( segNum < 0.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 300.0 );\n\t}\n\telse if ( segNum < 1.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 450.0 );\n\t}\n\telse if ( segNum < 2.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 600.0 );\n\t}\n\telse if ( segNum < 3.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 750.0 );\n\t}\n\telse\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 900.0 );\n\t}\n\t\t\n\t//--------------------------------------------\n\t// Horse body\n\tobjID = 5.0;\n\tfloat y = 1.25; // Initial ground offset for horse body\n\t\n\tfloat body1= fSphere( p - vec3( 15.0, y + bodyPosY, -0.9 ), 0.9 );\n\tfloat body2 = fSphere( p - vec3(15.0, y + bodyPosY,  0.9 ), 0.9 );\n\tvec2 body = vec2( smin( body1, body2 ), objID );\n\n\t//--------------------------------------------\n\t// Legs\n\t// Front left leg in two parts\n\tfloat x = 14.3,\n\t      z = -1.2,\n\t      legFLa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t   \n\t                            vec3( x, -0.25 + bodyPosY, z - 0.61 ), 0.2 );\n\n\tvec2 legFLb = vec2( smin( body1, legFLa ), objID );\n\n\tvec2 legFL = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z - 0.61 ),\n\t                                vec3( x, -1.26 + bodyPosY, z - 0.6 ), \n\t                                0.16 ), objID );\n\t//--------------------------------------------\n\t// Front right leg in two parts\n\tx = 15.7;\n\tz = -1.2;\n\tfloat legFRa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t         \n\t                            vec3( x, -0.25 + bodyPosY, z + 0.13 ), 0.2 );\n\n\tvec2 legFRb = vec2( smin( body1, legFRa ), objID );\n\n\tvec2 legFR = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z + 0.12 ),\n\t                                vec3( x, -1.26 + bodyPosY, z + 0.9 ), \n\t                                0.16 ), objID );\t\n\t\n\t//--------------------------------------------\n\t// Back left leg in two parts\n\tx = 14.5;\n\tz = 1.2;\n\tfloat legBLa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t  \n\t                            vec3( x, -0.25 + bodyPosY, z - 0.75 ), 0.2 );\n\n\tvec2 legBLb = vec2( smin( body2, legBLa ), objID );\n\n\tvec2 legBL = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z - 0.75 ),\n\t                                vec3( x, -1.26 + bodyPosY, z - 0.6 ), \n\t                                0.16 ), objID );\n\t\n\t//--------------------------------------------\n\t// Back right leg in two parts\n\tx = 15.7;\n\tz = 1.2;\n\tfloat legBRa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t\n\t                            vec3( x, -0.25 + bodyPosY, z + 0.13 ), 0.2 );\n\n\tvec2 legBRb = vec2( smin( body2, legBRa ), objID );\n\n\tvec2 legBR = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z + 0.12 ),\n\t                                vec3( x, -1.26 + bodyPosY, z + 0.75 ), \n\t                                0.16 ), objID );\n\t\n\t//--------------------------------------------\n\t// Neck\n\tfloat neckA = fCapsule( p, vec3( 15.0, 2.0 + bodyPosY, -1.8 ),\n\t                          vec3( 15.0,  3.0 + bodyPosY, -2.3 ), 0.35 );\n\t                          \n\tvec2 neck = vec2( smin( neckA, body1 ), objID );\t\n\t\n\t//--------------------------------------------\n\t// Head\n\tfloat headA = fCapsule( p, vec3( 15.0, 3.1 + bodyPosY, -2.5 ),\n\t                           vec3( 15.0, 2.1 + bodyPosY, -3.25 ), 0.275 );\n\t \n\tvec2 head = vec2( smin( neckA, headA ), objID );\t\n\t\n\t//---------------------------------------------\t\n\t// Tail\n\tvec2 tail = vec2( fCapsule( p, vec3( 15.0,  1.6 + bodyPosY, 1.7 ),\n\t                                vec3( 15.0, -0.5 + bodyPosY, 2.5 ), \n\t                                0.125 ), objID );\n\t\n\t//---------------------------------------------\n\t// Ears\n\tvec2 earL = vec2( fCapsule( p, vec3( 14.6, 3.2 + bodyPosY, -2.2 ),\n\t                               vec3( 14.6, 3.9 + bodyPosY, -2.2 ),\n\t                               0.1 ), objID );  \n\t\n\tvec2 earR = vec2( fCapsule( p, vec3( 15.4, 3.2 + bodyPosY, -2.2 ),\n\t                               vec3( 15.4, 3.9 + bodyPosY, -2.2 ),\n\t                               0.1 ), objID );  \n\t\n\t//---------------------------------------------\n\t// Horse pole\n\tobjID = 2.0;\n\tvec2 hPole = vec2( fCylinder( \n\t                        p - vec3( 15.0, 0.0, 0.0 ), 0.05, 10.0 ), objID );\t\n\t// Flag pole\n\tvec2 flagPole = vec2( fCylinder(\t\n\t                        p - vec3( 0.0, 15.0, 0.0 ), 0.05, 3.0 ), objID );\n\t\n\t// Flag in non-repeated space: p0\n\tobjID = 6.0;\n\tfloat wind = sin( iTime );\n\tvec2 flag = vec2( udTriangle( p0, vec3(  0.0, 16.5, 0.0 ), \n\t                                  vec3(  0.0, 18.0, 0.0 ),\n\t                          vec3( -4.0, 17.0 + wind, wind * 2.0 ) ), objID );\n\t// Pole top spheres\n\tvec2 poleTopA = vec2( fSphere( p - vec3( 19.3, 10.5, -5.0 ), 0.4 ), objID );\n\tvec2 poleTopB = vec2( fSphere( p - vec3( 19.3, 10.5,  5.0 ), 0.4 ), objID );\n\t\n\t// Flag sphere\n\tobjID = 3.0;\n\tvec2 flagSphere = vec2( fSphere( p - vec3( 0.0, 15.4, 0.0 ), 0.4 ), objID );\n\t\n\t// Outer ring spheres\n\tobjID = 2.0;\n\tvec2 outRingA = vec2( fSphere( p - vec3( 19.3, -1.65, -5.0 ), 0.6 ), objID );\n\tvec2 outRingB = vec2( fSphere( p - vec3( 19.3, -1.65,  5.0 ), 0.6 ), objID );\n\n\t// Center sphere\n\tobjID = 7.0;\t\n\tvec2 cntrSphere = vec2( \n\t                      fSphere( p - vec3( 0.0, -9.0, 0.0 ), 10.0 ), objID );\n\t\n\t// Center ring spheres\n\tobjID = 4.0;\n\tvec2 cntrRingSphere = vec2( \n\t                      fSphere( p - vec3( 9.0, -1.25, 0.0 ), 0.75 ), objID ); \n\t                      \n\t//-------------------------------------------\n\t// Distance comparisons for minimum distance.\n\t\n\tvec2 closest = ground.s < inGrndRing.s ? ground : inGrndRing;\n\tclosest = closest.s < inUprRing.s ? closest : inUprRing;\n\tclosest = closest.s < outGrndRing.s ? closest : outGrndRing;\n\tclosest = closest.s < outUprRing.s ? closest : outUprRing;\n\tclosest = closest.s < roof.s ? closest : roof;\n\tclosest = closest.s < inrPole.s  ? closest : inrPole;\n\tclosest = closest.s < outrPoleA.s  ? closest : outrPoleA;\n\tclosest = closest.s < outrPoleB.s  ? closest : outrPoleB;\n\tclosest = closest.s < rfDivA.s  ? closest : rfDivA;\n\tclosest = closest.s < rfDivB.s  ? closest : rfDivB;\n\n\tclosest = closest.s < body.s ? closest : body;\n\tclosest = closest.s < legFLb.s ? closest : legFLb ;\n\tclosest = closest.s < legFL.s ? closest : legFL;\n\tclosest = closest.s < legFRb.s ? closest : legFRb ;\n\tclosest = closest.s < legFR.s ? closest : legFR;\n\tclosest = closest.s < legBLb.s ? closest : legBLb ;\n\tclosest = closest.s < legBL.s ? closest : legBL;\n\tclosest = closest.s < legBRb.s ? closest : legBRb ;\n\tclosest = closest.s < legBR.s ? closest : legBR;\n\tclosest = closest.s < neck.s ? closest : neck;\n\tclosest = closest.s < head.s ? closest : head;\n\tclosest = closest.s < tail.s ? closest : tail;\n\tclosest = closest.s < earL.s ? closest : earL;\n\tclosest = closest.s < earR.s ? closest : earR;\n\t\n\tclosest = closest.s < hPole.s ? closest : hPole;\n\tclosest = closest.s < flagPole.s ? closest : flagPole;\n\tclosest = closest.s < flag.s ? closest : flag;\n\tclosest = closest.s < poleTopA.s ? closest : poleTopA;\n\tclosest = closest.s < poleTopB.s ? closest : poleTopB;\n\tclosest = closest.s < flagSphere.s ? closest : flagSphere;\n\tclosest = closest.s < outRingA.s ? closest : outRingA;\n\tclosest = closest.s < outRingB.s ? closest : outRingB;\n\tclosest = closest.s < cntrSphere.s ? closest : cntrSphere;\n\tclosest = closest.s < cntrRingSphere.s ? closest : cntrRingSphere;\n\t\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// CALC NORMAL\n// -----------\n// http://raymarching.com/WebGL/WebGL_ShadowsReflections.htm\n// Author - Gary \"Shane\" Warne\n// If speed is an issue, here's a slightly-less-accurate, 4-tap version.  \n// Visually speaking, it's virtually the same    \n\nvec3 calcNormal( in vec3 p )\n{\n\n\tfloat eps = 0.005;\n\tfloat ref = map( p ).s;\n\tvec2 e = vec2( eps, 0.0 );\n\treturn normalize( vec3( map( vec3( p.x + eps, p.y, p.z ) ).s - ref,\n\t\t                    map( vec3( p.x, p.y + eps, p.z ) ).s - ref,\n\t\t                    map( vec3( p.x, p.y, p.z + eps ) ).s - ref ) ); \n}\n\n// end calcNormal()\n\n//------------------------------------------------------------------------------\n// This is a modified version of the lighting section of the render function in \n// IQ's Raymarching Primitives code\n\n// GET COLOR\n// ---------\n\nvec3 getColor( vec3 rayOrig, vec3 rayDir, float objDist, float objID )\n{\n    vec3 pos = rayOrig + objDist * rayDir;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rayDir, nor );\n    \n    vec3 clr = vec3( 1.0 );\n\tclr = mix( applyTexture( vec4( pos, objID ) ), clr, 0.5 );\n\t\n    // lighting        \n\tvec3  lig = normalize( lightPos );\n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), \n                                          0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rayDir),0.0,1.0), 2.0 );\n\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),6.0);\n\n\tvec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n    lin += 0.20*amb*vec3(0.50,0.70,1.00);\n    lin += 0.30*dom*vec3(0.50,0.70,1.00);\n    lin += 0.30*bac*vec3(0.25,0.25,0.25);\n    lin += 0.40*fre*vec3(1.00,1.00,1.00);\n\tclr = clr*lin;\n\n\treturn clamp( clr, 0.0, 1.0 );\t\n}\t\n\n// end getColor()\n\n//------------------------------------------------------------------------------\n// From \tEdge AA   Uploaded by Trisomie21 in 2014-Jul-29\n//\t\t    https://www.shadertoy.com/view/MsfXDS\n\nvec4 blend( vec4 fg, in vec4 bg ) \n{\n\tfloat alpha = 1.0 - fg.a;\n\treturn fg + bg * alpha;\n}\n\n//------------------------------------------------------------------------------\n// From \tEdge AA   Uploaded by Trisomie21 in 2014-Jul-29\n//\t\t    https://www.shadertoy.com/view/MsfXDS\n\n// CAST RAY\n// --------\n\nvec3 castRay( in vec3 rayOrig, in vec3 rayDir )\n{\n\tvec4 clr = vec4(0.0);\t// Forground (pre-multiplied)\n\t \n\t      // Minimum distance considered an object hit\n\tfloat minHitDist = 0.001,   \n          // Distance to surface returned by map() from the most recent\n          // ray position\n          curDist = 0.0,\n          // The smallest of any distance returned from map() \t\n    \t  minCurDist = 1e20,\n          // The accumulation of all step distances returned from map()\n          sumDist = 0.0, \n          // The smallest value sumDist has held so far\n          minSumDist = 0.0,\n          // The objectID number of the current closest object\n          objID = -1.0, \t\n\t      // Keep track of the most recent object's ID number\n\t      storedObjID = -1.0,\n\t\t  // Keep track if moving closer to or away from a surface\n\t      movingCloserFlag = 1.0;\t\n\n    // Raymarch loop\n    for( int i = 0; i < NUM_RAY_STEPS; i++ )\n\t{\n        // Update the cumulative distance ray has traveled.\n        sumDist += curDist;\n\t    \n\t    // Find current closest distance and ID of closest object\n\t    vec2 res = map( rayOrig + rayDir * sumDist );\n        curDist = res.x;\n\t    objID = res.y;\n\n\t\t// If current closest distance is within hit distance, or\n\t\t// cumulative distance ray has travelled is beyond back plane\n\t\tif( abs( curDist ) < minHitDist || sumDist > MAX_RAY_DIST ) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// If the ray is closer than it's been to any object so far...\n\t\tif( curDist < minCurDist ) \n\t\t{ \n\t\t\t// then it's moving closer to an object\n\t\t\tmovingCloserFlag = 1.0;\n\t\t\t\n\t\t\t// Set the least distance to any object as the current distance\n\t\t\tminCurDist = curDist;\n\t\t\t\n\t\t\t// Set the current ray length as the minimum of any ray length\n\t\t\tminSumDist = sumDist;\n\t\t\t\n\t\t\t// Store the ID number of this closest object\n\t\t\tstoredObjID = objID;\n\t\t} \n\t\t// Otherwise the ray is moving away from the nearest object. Enter this\n\t\t// section only if the ray was most recently moving towards an object.\n\t\telse if( movingCloserFlag > 0.0 ) \n\t\t{ \n\t\t\t// moving away\n\t\t\tmovingCloserFlag = 0.0;\n\t\t\t\n\t\t\t// The outline pixel size is normalized to the screen height, based\n\t\t\t// on the length of the shortest ray length so far.\n\t\t\t// Changing pixSize changes the width of the antialiased 'outline'.\t\t\t\n\t\t\tfloat pixSize = ( minSumDist + 1.0 ) / iResolution.y;\n\n\t\t\t//----------------------------------------------------------------\n\t\t\t// This fragment of code can be used as a replacement for the code\n\t\t\t// just below, to enlarge the width of the antialiasing outline. It\n\t\t\t// will make the object edge appear fuzzier.\n\t\t\t//if ( minCurDist < pixSize * 4.0 ) \n\t\t\t//{\n\t\t\t//\t  float alpha = 1.0 - ( minCurDist / pixSize * 0.25 );\n\t\t\t//----------------------------------------------------------------\n\t\t\t\n\t\t\t// If the minimum ray-to-object length of any ray so far is less \n\t\t\t// than the pixel size\n\t\t\tif( minCurDist < pixSize ) \n\t\t\t{\n\t\t\t\t// The color transparency is based on the ratio of shortest\n\t\t\t\t// distance so far, to pixel size\n\t\t\t\tfloat alpha = 1.0 - ( minCurDist / pixSize );\n\t\t\t\t\t\t\n\t\t\t\t// Color of the closest object to the current ray position.\n\t\t\t\tvec3 rgb = getColor( rayOrig, rayDir, minSumDist, storedObjID );\n\t\t\t\tclr = blend( clr, vec4( rgb * alpha, alpha ) );\n\n\t\t\t\t// To view \"outlined\" pixels in white, uncomment this line:\n\t\t\t\t//clr = vec4(1.0);\n\t\t\t}\n\t\t\n\t\t} // end else if (... )\n    \n    } // end for( i... ) raymarch loop\n\t\t\t\n\t//---------------------------------------------------------\n\t// Toggle antialiasing: Turn off by uncommenting this line:\n\t//clr = vec4(0.0);\n\n\t//----------------------------------------------------------------\n\t// Toggle Color and Opacity: Turn off by uncommenting these lines:\n\t//if( objID > 1.0 ) \t{\tclr.a = 1.0;\t}\n\t//return vec3( pow( clr.a, 2.2 ) );\n\t\n\t//----------------------------------------------------------------\n\t\n\t// This gets the color of the object that was hit.\n\t// To show only the antialias outline, comment out these two lines.\n\tclr = blend( clr, \n\t                vec4( getColor( rayOrig, rayDir, sumDist, objID ), 1.0 ) );\n\t\n    return clr.rgb;\n}\n\n// end castRay()\n\n//------------------------------------------------------------------------------\n\n// RENDER \n// ------\n\nvec3 render( in vec3 rayOrig, in vec3 rayDir )\n{ \n    vec3 clr = castRay( rayOrig, rayDir );\n\treturn vec3( clamp( clr, 0.0, 1.0 ) );    \n}\n\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\t// -1 to 1 screen\n\t// --------------\n\t// Adjust aspect ratio, normalize coords, center origin in xy-plane.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\t\n    vec2 m = iMouse.xy / iResolution.xy;\n\t\t \n \tmat4 camMat = createCamRotMatrix();\n\tvec3 camPos = vec3( camMat * vec4( 0.0, 2.0, -CAM_DIST, 1.0 ) );\t    \n    vec3 rayDir = getRayDir( camPos, normalize( LOOK_AT - camPos ), p );       \n\tvec3 rayOrig = camPos;\n\tlightPos = camPos;\n\n    vec3 clr = render( rayOrig, rayDir );\n\tclr = pow( clr, vec3(0.8) );\n\t\n    fragColor = vec4( clr, 1.0 );\n}\n\n//------------------------------------------------------------------------------\n// From\t\"Simple test/port of Mercury's SDF library to WebGL\"\n// https://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = iTime * 0.2;\n\t}\n\telse\n\t{\n\t\t// wjb added the 180 degree rotation ( PI ) because the objects were\n\t\t// being created on the negative side of the x-axis ( mirrored position\n\t\t// across z-plane ) instead of the positive side, where they should be.\n\t\tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange + PI;\n\t}\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = 0.25 * ( sin( iTime * 0.1 ) + 1.0 );\n\t}\n\telse\n\t{\n\t\t// Scale iMouse.y so x-axis rotation range is only from partway overhead\n\t\t// to just about level with ground.\n\t\tang = ( 0.4825 * iMouse.y - iResolution.y * 0.5 ) * rotRange; \n\t}\n\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n// From \"Distance Functions Playground, by Ruslan Shestopalyuk, 2014/15\n// https://www.shadertoy.com/view/MtXGDr\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// APPLY TEXTURE\n// -------------\n\nvec3 applyTexture( vec4 hitPosAndID )\n{\n\tvec3 baseColor = vec3( 0.0 ),\n\t     pos = hitPosAndID.xyz;\n\t\n\tint objNum = int( hitPosAndID.w );\n\n\t// ground\n\tif ( objNum == 1 )\n\t{\t\t\n\t\tbaseColor = texture1( pos );\n\t}\t\n\t// inner rings, inner pillars\n\telse if ( objNum == 2 )\n\t{\n\t\tbaseColor = texture2( pos );\n\t}\t\n\t// outer rings, outer pillars\n\telse if ( objNum == 3 )\n\t{\n\t\tbaseColor = texture3( pos );\n\t}\t\n\t// roof\t\n\telse if ( objNum == 4 )\n\t{\n\t\tbaseColor = texture4( pos );\n\t}\n\t// horse\t\t\t\n\telse if ( objNum == 5 )\n\t{\n\t\tbaseColor = texture5( pos );\n\t}\t\n\t// pole top sphere\n\telse if ( objNum == 6 )\n\t{\n\t\tbaseColor = texture6( pos );\n\t}\t\n\t// center sphere\n\telse if ( objNum == 7 )\n\t{\n\t\tbaseColor = texture7( pos );\n\t}\t\n\t\n\treturn baseColor;\n}\n\n// end applyTexture()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 1\n// ---------\n\nvec3 texture1( vec3 pos )\n{\n\t//vec3 objClr = vec3( 0.0, 0.2, 0.7 );\t\n\tvec3 objClr = vec3( 0.0, 1.0, 1.0 );\t\n\t\t\n\tfloat scale = 1.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.5;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Marble( triangular ) #1\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture1()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 2\n// ---------\n\nvec3 texture2( vec3 pos )\n{\n\tvec3 objClr = vec3( 1.0, 1.0, 0.0 );\t\n\t\t\n\tfloat scale = 4.0,\n\t\t  complexity = 2.5,\n\t\t  mixVal = 0.6;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Combination Marble( triangular) with Marble( sharp ) #10\n\t// Marble( triangular )\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n\t// Marble ( sharp )  :  wjb added variable complexity factor\n\tt = (v.x + 2.0*v.y + 3.0*v.z);\n\tt +=  snoise(v) * complexity;\n\tvalue =  abs(sin(t));\n\tcolor /= vec3(sqrt(value)); // modified to divide    \t\t    \n\treturn mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture2()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 3\n// ---------\n\nvec3 texture3( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.75, 0.0, 1.0 );\t\n\t\t\n\tfloat scale = 1.0,\n\t\t  complexity = 1.0,\n\t\t  mixVal = 0.5;\t  \n\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Marble( triangular ) #1\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture3()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 4\n// ---------\n\nvec3 texture4( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0, 0.15, 1.0 );\t\n\t\t\n\tfloat scale = 2.0,\n\t\t  complexity = 0.5,\n\t\t  mixVal = 0.6;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #19 )\n\t// With complexity = 1.0, squiggly lines in objColor on white\n\tvec3 v = pos * scale;\n\tfloat value = log( pow( snoise( v ), 2.0 ) ) * complexity; \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture4()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 5\n// ---------\n\nvec3 texture5( vec3 pos )\n{\n\treturn vec3( 0.0 );\n//\tvec3 objClr = vec3( 0.0 );\t\n//\t\n//\tfloat scale = 1.0,\n//\t\t  //complexity = 5.0,\n//\t\t  mixVal = 0.5;\t  \n//\t\n//\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n//\t// Marble( triangular ) #1\n//\tvec3 v = pos * scale;\n//\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n//\tt += snoise(v);\t\n//\tfloat value = t - floor(t);\t\t\t\n//\t// smooth out the discontinuity\n//\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n//\tvalue = 0.333 + value*0.667;\n//\tvec3 color = vec3(value);\t\t    \n//    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture5()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 6\n// ---------\n\nvec3 texture6( vec3 pos )\n{\n\tvec3 objClr = vec3( 1.0, 0.0, 0.0 );\t\n\t\n\tfloat scale = 2.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.9;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #21 )\n\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t// on white background\n\tvec3 v = pos * scale;\n\tfloat value = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\t\n}\n\n// end texture6()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 7\n// ---------\n\nvec3 texture7( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0 ),//( 1.0, 0.0, 1.0 ),\n\t     color = vec3( 0.0 );\t\n\t\n\tfloat scale = 2.0,\n\t\t  mixVal = 0.5;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Checkerboard 3D #6\n\tvec3 v = pos * scale;\n\tfloat a = floor( v.x );\n\tfloat b = floor( v.y );\n\tfloat c = floor( v.z );\n\tif ( mod( a + b + c, 2.0 ) > 0.5 ) \n\t{  // a+b+c is odd\n\t    color = vec3( 0.3 ); // the dark value\n\t}\n\telse \n\t{  // a+b+c is even\n\t    color = vec3( 1.0 ); // the light value\n\t}    \t\t\n\treturn mix( color, objClr, mixVal );        \t\t\t\t\t\t\t\t\t\t\t\t\n}\n\n// end texture7()\n\n//------------------------------------------------------------------------------\n\n// TRIANGLE - unsigned\n// --------\n// https://iquilezles.org/articles/distfunctions\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n//------------------------------------------------------------------------------\n\n// SMOOTH MINIMUM\n// --------------\n// https://www.shadertoy.com/view/XtjXWD\t-Otavio Good\n// smooth blending function; k should be negative. -4.0 works nicely.\nfloat smin(float a, float b)\n{\n\tfloat k = -4.0;\n\treturn log2( exp2( k * a ) + exp2( k * b ) ) / k;\n}\n\n//==============================================================================\n// The code below is excerpted from :\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n#define clamp(x,a,b) min(max(x,a),b)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D  Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ------------------------------------------\n    \n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n\n//------------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 2204,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/reichmarshall/gladiolus-rag-on-pipe-organ"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}