{
    "Shader": {
        "info": {
            "date": "1514674145",
            "description": "a truchet shader in 550 chars\nmany of the variable names are just randomly chosen from the alphabet",
            "flags": 0,
            "hasliked": 0,
            "id": "ll2fz1",
            "likes": 11,
            "name": "golfed truchet (550 chars)",
            "published": 3,
            "tags": [
                "3d",
                "1k",
                "truchet"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 797
        },
        "renderpass": [
            {
                "code": "/**/\n//torus sdf\n#define v vec3\n#define r(i) length(v(0,length(t[i].xy)-1.,s[i]))-.1\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    v p = iTime*v(.5),\n    \t F = iResolution,\n         d = normalize(v((U.xy * 2.0 - F.xy) / F.y,1)),s,q,f;\n    float D = 0.,\n          l,\n          Q;\n    for (int i = 0; i < 99; i++) {\n        \n        F = floor(p*.5);\n        f =\tv(sign(sin(F.y*F.z+F.zx+.1)),1);\n        s = (mod(p,2.)-1.)*f;\n        \n        v a = v(1,-1,0);\n        mat3 t = mat3(\n            s.yzx+a.xxz,\n            s.zxy-a.xxz,\n            s+a\n        );\n\n        l = min(min(r(0),r(1)),r(2));\n\t\t\n        //position of the nearest torus\n        q = t[ int(r(1)<=l) + 2*int(r(2)<=l) ];\n        \n        p += d*l;\n        D += l;\n    }\n    //coloring the truchet in a rainbow pattern\n    O.xyz = (sin(((mod(F.x+F.y,2.)*2.-1.)\n            *(atan(q.x,q.y)*6.+atan(q.z,length(q.xy)-1.)*f.x*f.y)*1.9+iTime*4.) //+3.14*10.0*atan(q.z,length(q.xy))\n            *2.1+v(1,2,3))*0.5+0.5)\n            /(D*D*.02+1.);\n    \n    //O.xyz = q*0.5+0.5;\n    //O /= (D*D*.02+1.);\n}\n/**/\n\n//341 chars. minimal with boring shading\n/**\n#define r(p,l) length(vec2(length(p)-1.,l))-.1\n\n#define mainImage(O, U)\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 p = iTime*vec3(.5),\t\t\t\t\t\t\t\t\t\\\n         F = iResolution,\t\t\t\t\t\t\t\t\t\t\\\n         d = normalize(vec3((U.xy * 2.0 - F.xy) / F.y,1)),f;\t\\\n    float D = 0., j = 0., l;\t\t\t\t\t\t\t\t\t\\\n    while (j++ < 99.) {\t\t\t\t\t\t\t\t\t\t\t\\\n        F = floor(p*.5);\t\t\t\t\t\t\t\t\t\t\\\n        f = (p-F*2.-1.)*vec3(sign(sin(F.y+F.z*F+1.)));\t\t\t\\\n        l = min(min(\t\t\t\t\t\t\t\t\t\t\t\\\n            r(f.yz+1.,f.x),\t\t\t\t\t\t\t\t\t\t\\\n            r(f.zx-1.,f.y)),\t\t\t\t\t\t\t\t\t\\\n            r(f.xy+vec2(1,-1),f.z));\t\t\t\t\t\t\t\\\n        p += d*l;\t\t\t\t\t\t\t\t\t\t\t\t\\\n        D += l;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    O = vec4(1./(D*D*.02+1.));\t\t\t\t\t\t\t\t\t\\\n/**/\n\n//469 char. same as under with more random flipping\n/**\n#define r(i) length( vec2( length(t[i].xy)-1., s[i] ) ) -.1  //torus sdf\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 p = vec3(iTime*.5),\n         R = iResolution,\n         d = normalize(vec3(U+U - R.xy, R.y)),   F,s,q;\n    float D = 0., l;\n\n    for (int i = 0; i < 99; i++) {       \n        F = floor(p*.5),        \n        s = (mod(p,2.) - 1.)*vec3(sign(sin(F.yz*F.xy)+.01),1); //randomizing truchet direction\n        //i can't have perfect flow with fully random truchets  so i set f.z to 1\n              \n        mat3 t = mat3( s.yzx - 1.,\n                       s.zxy + 1.,\n                       s + vec3(-1,1,0)\n                     );\n\n        l = min(min(r(0),r(1)),r(2)),\n        q = t[ l==r(1) ? 1 : l==r(2) ? 2 : 0 ], //position of the nearest torus\n\t\t   \n        p += d*l,\n        D += l;\n    }\n    \n    l = (mod(F.x+F.y,2.)*2.-1.) * atan(q.x,q.y) * 1.9 + iTime; //the truchet flow\n    O = ( sin( l* vec4(1,2,3,0)*2.1) + 1. ) / (D*D*.04+2.);\n}\n/**/\n\n//467 char. by FabriceNeyret2\n/**\n#define r(i) length( vec2( length(t[i].xy)-1., s[i] ) ) -.1  //torus sdf\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 p = vec3(iTime*.5),\n         R = iResolution,\n         d = normalize(vec3(U+U - R.xy, R.y)),   F,s,q;\n    float D = 0., l;\n\n    for (int i = 0; i < 99; i++) {       \n        F = floor(p*.5),        \n        s = mod(p,2.) - 1.,\n        s.xy *= sin(F.x*F.y*F.z) > 0.? 1. :-1.; //randomizing truchet direction\n        //i can't have perfect flow with fully random truchets  so i set f.z to 1\n              \n        mat3 t = mat3( s.yzx - 1.,\n                       s.zxy + 1.,\n                       s + vec3(-1,1,0)\n                     );\n\n        l = min(min(r(0),r(1)),r(2)),\n        q = t[ l==r(1) ? 1 : l==r(2) ? 2 : 0 ], //position of the nearest torus\n\t\t   \n        p += d*l,\n        D += l;\n    }\n    \n    l = (mod(F.x+F.y,2.)*2.-1.) * atan(q.x,q.y) * 1.9 + iTime; //the truchet flow\n    O = ( sin( l* vec4(1,2,3,0)*2.1) + 1. ) / (D*D*.04+2.);\n}\n/**/\n//472 char. by FabriceNeyret2\n/**\n#define r(i) length( vec2(length(t[i].xy)-1.,s[i]) )-.1  //torus sdf\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec3 p = vec3(iTime*.5),\n         R = iResolution,\n         d = normalize(vec3(U+U - R.xy, R.y)),   F,s,q;\n    float D = 0., l, Q;\n\n    for (int i = 0; i < 99; i++) {       \n        F = floor(p*.5);        \n        s = mod(p,2.) - 1.;\n        s.xy *= sin(F.x*F.y*F.z) > 0.? 1. :-1.; //randomizing truchet direction\n        //i can't have perfect flow with fully random truchets  so i set f.z to 1\n              \n        mat3 t = mat3( s.yzx - 1.,\n                       s.zxy + 1.,\n                       s + vec3(-1,1,0)\n                     );\n\n        l = min(min(r(0),r(1)),r(2));\t\n        q = t[ l==r(1) ? 1 : l==r(2) ? 2 : 0 ]; //position of the nearest torus\n\t\t   \n        p += d*l;\n        D += l;\n    }\n    \n    Q = (mod(F.x+F.y,2.)*2.-1.) * atan(q.x,q.y) * 1.9 + iTime; //the truchet flow\n    O = ( sin(Q*vec4(1,2,3,0)*2.1) + 1. ) / (D*D*.04+2.);\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}