{
    "Shader": {
        "info": {
            "date": "1657553600",
            "description": "Tiling the sphere with triangle voronoi patterns",
            "flags": 32,
            "hasliked": 0,
            "id": "fsKBRR",
            "likes": 37,
            "name": "HardSurface Sphere",
            "published": 3,
            "tags": [
                "voronoi",
                "geodesic"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 826
        },
        "renderpass": [
            {
                "code": "//#define SHOW_DATA\n\n#if HW_PERFORMANCE==1\n#define AA 2\n#endif\n\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Rotate on axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\n// --------------------------------------------------------\n// Icosahedral domain mirroring\n// knighty https://www.shadertoy.com/view/MsKGzw\n// \n// Also get the face normal, and tangent planes used to\n// calculate the uv coordinates later.\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid init() {\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);\n    pbc=vec3(scospin,0.,0.5);\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc);\n    pca=normalize(pca);\n\tpab=vec3(0,0,1);\n    pca *= 0.794654;\n    pab *= 0.850651;\n}\n\nvoid fold(inout vec3 p) {\n\tfor(int i=0;i<Type;i++){\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2. * min(0., dot(p,nc)) * nc;\n\t}\n}\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float d;\n    vec3 col;\n};\n\nModel map(vec3 p) {\n\n    #ifdef LOOP\n        p = erot(p, normalize(pca), fract(iTime / 10.) * PI * 2. * (1./3.));\n    #endif\n\n    float r = 2.;\n\n    float bound = length(p) - r - .2;\n    if (bound > .01) {\n        return Model(bound, vec3(0));\n    }\n\n    vec3 col = normalize(p) * .5 + .5;\n    \n    vec3 face, ab, atob;\n\n    fold(p);\n    face = pca;\n    atob = pbc - pab;\n    ab = pab;\n    \n    vec3 vv = normalize(face - ab);\n    vec3 uu = normalize(atob);\n    vec3 ww = face;\n    mat3 m = mat3(uu,vv,ww);\n       \n    vec3 pp = p / dot(p, face);\n    \n    vec3 uvw = pp * m;\n\n    col = vec3(uvw.xy * vec2(1,-1), 0);\n   \n    \n    float d = length(p) - 2.;\n    \n    vec4 data = texture(iChannel0, uvw.xy * vec2(1,-2));\n\n    float kk = mix(-.5, 1., smoothstep(.4, .6, data.a));\n\n    float vd0 = data.r * 6.;\n    \n    vec2 rn0 = data.gb;\n    float rn = rn0.x;\n    float rn1 = rn0.y;\n    \n    float inn = mix(.01, .6, floor(rn1*3.)/3.);\n    float h = min(vd0, inn) * .4;\n\n    if (rn1 < .3) {\n        h -= max(0., (vd0 - .3) * .2);\n    }\n        \n    h *= kk;\n        \n    d = length(p) - r - h;\n    \n    col = vec3(.5);\n\n    float ws = .5;\n    float w = mix(.0, .1, floor(rn * 3.)/3.) * ws;\n    col = mix(col, vec3(.15), (1.-smoothstep(.01 * ws*1.5, .03*ws*1.5, abs(vd0 - inn))));\n    if (rn1 < .3) {\n        col = mix(col, vec3(.2), smoothstep(.01, .03, (vd0 - .3)));\n        col = mix(col, vec3(.05), (1.-smoothstep(.01, .04, abs(vd0 - .3))));\n    }\n    col = mix(col, vec3(0), (1.-smoothstep(w, w + .0, abs(vd0))));\n    \n    return Model(d, col);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nfloat vmul(vec2 v) {\n    return v.x * v.y;\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvec3 render( vec2 p )\n{\n\n    vec3 camPos = vec3(0,0,9);\n    \n    vec2 im = iMouse.xy / iResolution.xy - .5;\n    \n    if (iMouse.x <= 0.)\n    {\n        im = vec2(0);\n    }\n    \n    im += vec2(.66,.3);\n    \n    pR(camPos.yz, (.5 - im.y) * PI / 2.);\n    pR(camPos.xz, (.5 - im.x) * PI * 1.5);\n    \n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0), vec3(0,1,0));\n    \n    float focalLength = 3.;\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, focalLength));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    Model model;\n    float dist = 0.;\n    bool bg = false;\n    vec3 bgcol = vec3(.8);\n    vec3 col = bgcol;\n\n    for (int i = 0; i < 100; i++) {\n        rayLength += dist * .8;\n        rayPosition = camPos + rayDirection * rayLength;\n        model = map(rayPosition);\n        dist = model.d;\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 15.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        col = model.col;\n        vec3 nor = calcNormal(rayPosition);\n        col *= dot(vec3(0,1,0), nor) * .75 + 1.;\n        float fog = 1. - exp((rayLength - 6.) * -1.5);\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    #ifdef SHOW_DATA\n        vec4 data = texture(iChannel0, fragCoord.xy / iResolution.xy);\n        data.x = fract(data.x * 100.);\n        fragColor = data;\n        return;\n    #endif\n    \n    init();\n    \n    vec2 o = vec2(0);\n    vec3 col = vec3(0);\n\n    // AA from iq https://www.shadertoy.com/view/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \t// time coordinate (motion blurred, shutter=0.5)\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    #endif\n\t\t\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.y;\n    \tcol += render(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n    \n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//#define LOOP\n\n#define PI 3.14159265359\n\nmat3 scaleM(float s) {\n    return mat3(\n        s, 0, 0,\n        0, s, 0,\n        0, 0, 1\n    );\n}\n\nmat3 rotM(float a) {\n    return mat3(\n        cos(a), sin(a), 0,\n        -sin(a), cos(a), 0,\n        0, 0, 1\n    );\n}\n\nmat3 transM(vec2 v) {\n    return mat3(\n        1, 0, v.x,\n        0, 1, v.y,\n        0, 0, 1\n    );\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\nmat3 gridTransformation(out float scale) {\n    float time = iTime * .06;\n    \n    scale = 6.;\n\n    mat3 m = scaleM(scale);\n    m *= rotM(PI * .3 * time);\n    m *= transM(time * vec2(0, -7.8));\n    return m;\n}\n\nmat3 gridTransformationLoop(out float scale) {\n    float time = fract(iTime / 10.);\n    \n    scale = 6.;\n\n    mat3 m = scaleM(scale);\n    m *= transM(time * vec2(0, -10.));\n    return m;\n}\n\n\nfloat effectMask(vec2 uv) {\n    return sin(length(uv) * 12. + 1.) * .5 + .5;\n}\n\n// --------------------------------------------------------\n// Triangle Voronoi https://www.shadertoy.com/view/ss3fW4\n// --------------------------------------------------------\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nconst float s3 = sin(PI / 3.);\n\nvec3 sdTriEdges(vec2 p) {\n    return vec3(\n        dot(p, vec2(0,-1)),\n        dot(p, vec2(s3, .5)),\n        dot(p, vec2(-s3, .5))\n    );\n}\n\nfloat sdTri(vec2 p) {\n    vec3 t = sdTriEdges(p);\n    return max(t.x, max(t.y, t.z));\n}\n\nfloat sdTri(vec3 t) {\n    return max(t.x, max(t.y, t.z));\n}\n\nvec3 primaryAxis(vec3 p) {\n    vec3 a = abs(p);\n    return (1.-step(a.xyz, a.yzx))*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBorder(vec3 tbRel, vec2 pt1, vec2 pt2) {\n    \n    vec3 axis = primaryAxis(-tbRel);\n    bool isEdge = axis.x + axis.y + axis.z < 0.;\n\n    vec2 gA = vec2(0,-1);\n    vec2 gB = vec2(s3, .5);\n    vec2 gC = vec2(-s3, .5);\n    \n    vec2 norA = gC * axis.x + gA * axis.y + gB * axis.z;\n    vec2 norB = gB * -axis.x + gC * -axis.y + gA * -axis.z;\n    \n    vec2 dir = gA * axis.x + gB * axis.y + gC * axis.z;\n    vec2 corner = dir * dot(dir, pt1 - pt2) * 2./3.;\n        \n    vec2 ca, cb;\n    float side;\n    \n    if (isEdge) {\n        corner = pt2 + corner;\n        ca = corner + max(0., dot(corner, -norB)) * norB;\n        cb = corner + min(0., dot(corner, -norA)) * norA;\n    } else {\n        corner = pt1 - corner;\n        ca = corner + max(0., dot(corner, -norA)) * norA;\n        cb = corner + min(0., dot(corner, -norB)) * norB;\n    }\n    \n    side = step(dot(corner, dir * mat2(0,-1,1,0)), 0.);\n    corner = mix(ca, cb, side);\n    \n    float d = length(corner);\n\n    return d;\n}\n\n\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nvec2 cellPoint(vec2 n, vec2 f, vec2 cell, out vec2 coord) {\n    coord = n + cell;\n    #ifdef LOOP\n        vec2 e = vec2(2,9);\n        float rep = 10.;\n        coord = mod(coord+e, rep)-e;\n    #endif\n    vec2 o = hash2( coord );\n    if (hash2(o.yx * 10.).y > .5) {\n        return vec2(1e12);\n    }\n    #ifdef ANIMATE\n        o = 0.5 + 0.5*sin( time * PI * 2. + 6.2831*o );\n    #endif\t\n    vec2 point = cell + o - f;\n    return point;\n}\n\nvec4 voronoi(vec2 x)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 closestCell, closestPoint, closestCoord;\n\n    const int reach = 3;\n\n    float closestDist = 8.0;\n    for( int j = -reach; j <= reach; j++ )\n    for( int i = -reach; i <= reach; i++ )\n    {\n        vec2 cell = vec2(i, j);\n        vec2 coord;\n        vec2 point = cellPoint(n, f, cell, coord);\n        float dist = vmax(sdTriEdges(point));\n\n        if( dist < closestDist )\n        {\n            closestDist = dist;\n            closestPoint = point;\n            closestCoord = coord;\n            closestCell = cell;\n        }\n    }\n\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    closestDist = 8.0;\n    for( int j = -reach-1; j <= reach+1; j++ )\n    for( int i = -reach-1; i <= reach+1; i++ )\n    {\n        vec2 cell = closestCell + vec2(i, j);\n        vec2 coord;\n        vec2 point = cellPoint(n, f, cell, coord);\n\n        vec3 triEdges = sdTriEdges(closestPoint - point);\n        float dist = vmax(triEdges);\n\n        if( dist > 0.00001 ) {\n            closestDist = min(closestDist, sdBorder(triEdges, closestPoint, point));\n        }\n    }\n\n    return vec4(closestDist, closestCoord, 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= vec2(1,-.5);\n    \n    if (uv.x > uv.y * -2.) {\n        fragColor = vec4(0);\n        return;\n    }    \n    \n    float scl;\n    #ifdef LOOP\n        mat3 m = gridTransformationLoop(scl);\n    #else\n        mat3 m = gridTransformation(scl);\n    #endif\n    \n    uv = mul(uv, m);\n\n    vec4 v = voronoi(uv);\n   \n    float d = v.x / scl;\n    vec2 localPt = v.yz;\n    vec2 worldPt = mul(localPt, inverse(m));\n    \n    vec2 seed = hash2(localPt * 5. / scl);\n\n    float mask = effectMask(worldPt);\n\n    fragColor = vec4(d, seed, mask);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}