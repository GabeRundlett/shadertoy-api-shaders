{
    "Shader": {
        "info": {
            "date": "1716037153",
            "description": "Using some modulus functions to stretch and elongate a truchet tile pattern, with pretty glass and reflections.",
            "flags": 0,
            "hasliked": 0,
            "id": "McySDd",
            "likes": 31,
            "name": "Glass Stretched Truchet Tiles",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "refraction",
                "truchet",
                "tiles"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Glass Stretched Truchet Tiles\n    pseudo reflection/refraction test with elongated truchet tile pattern\n    \n    05/18/24 @byt3_m3chanic\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265\n#define PI2 6.28318530\n\nvec3 hit,hitPoint;\n\nconst float sz = 1.5;\nconst float hf = sz/2.;\n\nvec3 hue(float t) { return .3 + .25*cos(PI2*t*(vec3(.985,.98,.95)+vec3(0.961,0.576,0.220))); }\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat hash(in float n) {return fract(sin(n)*43.54); }\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.-2.*f);\n    float n = p.x + p.y*57.;\n    float res = mix(mix( hash(n+  0.1), hash(n+  1.1),f.x),\n                    mix( hash(n+ 57.1), hash(n+ 58.1),f.x),f.y);\n    return res;\n}\n\n//@iq extrude sdf \nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 p) {  \n\n\tvec2 res = vec2(1e5,0);\n\n    vec2 id = floor((p.xz+hf)/sz);\n    vec2 uv = mod(p.xz+hf,sz)-hf;\n\n    float m = floor(mod(id.y,3.)+1.);\n    float n = floor(mod(id.x,3.)+1.);\n\n    vec2 cd=vec2(mod(id.x,n),mod(id.y,m))*2.-1.;\n    \n    float tc = .1;\n    float hs = hash21(id);\n    if(hs>.5) uv.x = -uv.x;\n    \n    vec2 gx = length(uv-hf)<length(uv+hf) ? vec2(uv-hf) : vec2(uv+hf);\n\n    float d = length(gx)-hf;\n    d = abs(d)-tc;\n    \n    if(cd.x>.5 ) { d = length(uv.y)-tc;}\n    if(cd.y>.5 ) { d = length(uv.x)-tc;}\n    if(cd.y>.5 && cd.x>.5) { d = 1.; }\n\n    d = min(abs(d)-.01,d);\n    \n    float fw =  .6+.5*sin(p.x*.825);\n          fw += .6+.5*cos(p.z*.755);\n          \n    d = opx(d , p.y+1.15-fw,fw);\n\n    if(d<res.x) res=vec2(d,1.);\n    \n    float f = p.y+1.365;\n    if(f<res.x) {\n        res=vec2(f,3.);\n        hit = p;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.);\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\n//@Shane AO\nfloat getao(in vec3 p, in vec3 n) {\n    float sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.05/1.5; \n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n        sca *= .9;\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1.-occ, 0., 1.);\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(25,35,-25);\n    vec3 l = normalize(lpos);\n\n    float diff = clamp(dot(n,l),.1,1.);\n \n    float ao = getao(p,n);\n    diff = mix(diff,diff*ao,.7);\n    \n    vec3 h = vec3(.001,.008,.002);\n\n    if(m==3.) {\n        const float sc = .5;\n        const float f = sc/2.;\n        const float sx = sc/3.5;\n        float px = 4./R.x;\n\n        vec2 uv = mod(hitPoint.xz+f,sc)-f;\n        vec2 id = floor((hitPoint.xz+f)/sc);\n        \n        float hs = noise((T+id*.35)*.5);\n        float d = box(uv,vec2(.001+hs*sx))-.1;\n\n        h = mix(vec3(.65),hue(hs*.5),smoothstep(px,-px,d));\n    };\n    \n    return diff * h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,11.5),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) || M.z < 0. ? 0. : -(M.y/R.y * .2 - .1) * PI;\n    float y = M.xy == vec2(0) || M.z < 0. ? 0. : -(M.x/R.x * 1. - .5) * PI;\n    \n    mat2 rx = rot(1.18-x), ry = rot(.3+y+(.2*sin(T*.1)));\n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n    \n    ro.x += T*.65;\n    \n    vec3 C = vec3(0);\n    vec3  p = ro + rd;\n    float atten = 1.,k = 1.,b = 0.,d,m;\n    \n    // loop inspired/adapted from @blackle\n    // https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<225;i++)\n    {\n        vec3 n=vec3(0);\n        vec2 ray = map(p);\n        \n        m = ray.y;\n        d = i<32? ray.x*.25:ray.x*.8;\n        p += rd * d *k;\n\n\n        if (d*d < 1e-6) {\n            b++;\n            hitPoint = hit;\n\n            C+=render(p,rd,ro,d,ray.y,n)*atten;\n            \n            if(b>7.)break; // break loop after 7 bounces.\n            \n            p += rd*1e-1;\n            k = sign(map(p).x);\n\n            if(int(F.x)%2 != int(F.y)%2 || m == 3.) {\n                atten *= .625;\n                rd=reflect(-rd,n);\n                p+=n*.1;\n            }else{\n                atten *= .750;\n                rd=refract(rd,n,.92);\n            }\n\n        } \n        \n        if(distance(p,rd)>ro.x+35.) {break;}\n    }\n\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}