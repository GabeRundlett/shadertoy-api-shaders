{
    "Shader": {
        "info": {
            "date": "1591290424",
            "description": "A blob made from the smooth union of two spheres with three lights: blue fixed directional, green moving direction and red moving point. \nBy taking the derivative of the distance field, we can calculate the normals at any point.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsyzr",
            "likes": 3,
            "name": "Sdf blob",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "sdf",
                "light"
            ],
            "usePreview": 0,
            "username": "stlsnk",
            "viewed": 695
        },
        "renderpass": [
            {
                "code": "// position of the green/yellow light\nvec3 gpos;\n\nfloat dot2(in vec3 v) { return dot(v, v); }\n\nfloat sdf_sph(in vec3 p, in float r) {\n  return length(p) - r;\n}\n\n// the main blob made from two sphere\nfloat sdf_min(in vec3 p) {\n    float a = sdf_sph(p - vec3(-0.3, 0.0, 0.0), 0.3);\n    float b = sdf_sph(p - vec3(0.2, 0.0, -0.2), 0.5);\n    float res = exp2( -32.*a ) + exp2( -32.*b );\n    return -log2( res ) / 32.;\n}\n\n// added a new sphere at the position of the purple light\nfloat sdf_uni(in vec3 p) {\n    return min(sdf_min(p), sdf_sph(p - gpos, 0.05));\n}\n\nfloat sdf(in vec3 p) {\n    return sdf_uni(p);\n}\n\n// normal vector, gradient of sdf at p\nvec3 d_sdf(in vec3 p) {\n    return vec3(\n               (sdf(p) - sdf(p - vec3(0.0001, 0., 0.))) / 0.0001, \n               (sdf(p) - sdf(p - vec3(0., 0.0001, 0.))) / 0.0001,\n               (sdf(p) - sdf(p - vec3(0., 0., 0.0001))) / 0.0001\n           );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates to y in (-1, 1), origo in (0, 0), aspect is correct\n    vec2 uv = fragCoord / iResolution.y * 2.0 - vec2(iResolution.x / iResolution.y, 1);\n   \n    \n    // moving light point\n    gpos = vec3(-0.2, sin(iTime*1.414), 0.6);\n    // rotation around the y axis\n    mat3 rot = mat3(cos(iTime), 0., -sin(iTime), \n                            0., 1.,          0., \n                    sin(iTime), 0., cos(iTime));\n   \tvec3 p = rot * vec3(uv, 1.);\n    vec3 dir = rot * vec3(0., 0., -1.);\n    \n    for(int i = 0; i < 16; ++i) {\n        p = p + dir * sdf(p) * 1.0;// * sign(dot(d_sdf(p), -dir));\n    }\n    \n    /* // Debug position\n    if(abs(sdf(p)) < 2.0) {\n   \t    fragColor = vec4(p * 0.5 + 0.5, 1.);\n        return;\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    //*/\n    \n    \n    /* // Debug final sdf value\n    if(sdf(p) > 0.1) {\n        fragColor = vec4(1.0);\n        return;\n    } else {\n        fragColor = vec4(sdf(p) * 10., -sdf(p) * 10., 0., 0.);\n        return;\n    } //*/\n    \n   \n    // normal vector\n    vec3 n = normalize(d_sdf(p));\n    \n    // blue color, from a fix direction\n    vec3 bdir = normalize(vec3(-0.3, 0.4, -0.3));\n   \tfloat bcol = dot(n, bdir);\n    \n    \n    // green color, from a moving direction\n    vec3 gdir = normalize(gpos - p);\n    float gcol = dot(n, normalize(gdir));\n    \n    // red color, from a moving point, with distance\n    vec3 rdir = normalize(gpos - p);\n   \tfloat rcol = pow(max(dot(n, rdir), 0.), 4.);\n    \n    \n    \n    if(sdf(p) > 0.1) { \n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n    else {\n        fragColor = vec4(rcol, gcol, bcol, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}