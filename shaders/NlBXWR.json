{
    "Shader": {
        "info": {
            "date": "1627546608",
            "description": "Fast Catmull-Rom using 4 texture fetches with checkerboard inverted source texture. Requires at least 512x512 viewing window.  Other upscalers: https://www.shadertoy.com/playlist/WcKXWW",
            "flags": 32,
            "hasliked": 0,
            "id": "NlBXWR",
            "likes": 12,
            "name": "4 tap Catmull-Rom upsampling",
            "published": 3,
            "tags": [
                "catmull",
                "upsampling",
                "lanczos"
            ],
            "usePreview": 1,
            "username": "goingdigital",
            "viewed": 2278
        },
        "renderpass": [
            {
                "code": "/*\nFour tap Catmull-Rom upsampling\n\nNote: Render window must be at least 512x512. This is because the texture is\npreprocessed at source texture resolution, but Shadertoy buffers are always\nat render window size. If the texture is cut off, go fullscreen.\n\nBy default, right hand side is nearest neighbour sampling.\nChange iChannel1 filter mode to 'linear' to compare against bilinear filtering.\n\nThis takes the ideas from:\nhttps://vec3.ca/bicubic-filtering-in-fewer-taps/\n    9 taps\nhttps://research.activision.com/publications/archives/filmic-smaasharp-morphological-and-temporal-antialiasing\n    5 taps, with 4 removed sidelobes\n\nThis example:\n    4 taps, with 0 removed sidelobes (but checkerboard preprocessing)\n\nBy inverting the source texture in a checkerboard style (which can be baked into\nthe texture or previous render pass) and utilising existing bilinear filtering,\nCatmull-Rom reduces from 16 to 4 texture reads.\n\nEvery other pixel of the source texture is inverted in a checkerboard pattern.\nThis matches the positive/negative flips of the Catmull-Rom lobes.\n\noffset works out the position where bilinear filtering will get the correct ratio of\nsidelobes. This allows 1 texture fetch to read 4 taps. This needs to be a 4th order\npolynomial to preserve partition of unity, but only 2dp of precision is needed.\nThe polynomial coefficients were derived using Excel's trendline function. X and Y\nnegative and positive sides are evaluated simultaneously in the vec4.\n\nw is the appropriate final weighting of the reads, assuming each read is 2D lerp of 4\ntaps. The some weights are inverted to compensate for the source texture checkerboard.\n\nThis checkerboard strategy only works where each sidelobe is of opposing sign.\nSo it works for Catmull-Rom and Lanczos-2, but not Mitchellâ€“Netravali.\n\nI have chosen Catmull-Rom over Lanczos-2 as it has a partition of unity, which induces\nless ripple in solid colours where local clamping can't be easily done.\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Split into whole pixel and subpixel position\n    vec2 src_subpixel = fragCoord * iChannelResolution[1].xy / iResolution.xy + .5;\n    vec2 src_pixel = floor(src_subpixel);\n    src_subpixel -= src_pixel;\n\n    // Map texel offsets and weights\n    vec4 f=vec4(src_subpixel,1.-src_subpixel);\n    // Offset adds the correct ratio of each lobe using texture bilinear interpolation\n    //vec4 offset = (((-.94117*f+1.67489)*f-1.2601)*f+.52875)*f+.49921; // Catmull Rom\n    vec4 offset = (((-.94*f+1.68)*f-1.26)*f+.53)*f+.5; // Catmull Rom\n    vec4 texpos = (src_pixel.xyxy + vec4(-offset.xy, offset.zw)) / iChannelResolution[0].xyxy;\n    // Weight adds textures in correct ratio, and corrects for checkerboard across kernel.\n    vec4 w = ((2.*f-3.5)*f+.5)*f+1.; // Catmull Rom\n\n    // Texture lookup\n    fragColor.xyz = w.x * w.y * texture(iChannel0, texpos.xy).xyz;\n    fragColor.xyz -= w.z * w.y * texture(iChannel0, texpos.zy).xyz;\n    fragColor.xyz += w.z * w.w * texture(iChannel0, texpos.zw).xyz;\n    fragColor.xyz -= w.x * w.w * texture(iChannel0, texpos.xw).xyz;\n\n    // De-checkerboard\n    float z = mod(src_pixel.x + src_pixel.y, 2.);\n    if (z>.5) fragColor.xyz = -fragColor.xyz;\n\n    // Catmull-Rom can ring, so clamp.\n    // It would be nice to clamp to local min/max, but that would require additional\n    // texture reads. If texture reads are done as a textureGather, this would be\n    // possible.\n    fragColor.xyz = clamp(fragColor.xyz, 0., 1.);\n\n    // Comparison\n    float div = 0.5 + 0.5*sin(0.3*iTime);\n    if (iMouse.z > 0.) {\n        div = iMouse.x / iResolution.x;\n    }\n    div = fragCoord.x / iResolution.x - div;\n    if (div > -.002) {\n        if (div > .002) {\n            vec2 p = fragCoord * iChannelResolution[1].xy / iResolution.xy;\n            // Leave commented to compare against bilinear\n            // Uncomment to compare against nearest-neighbour\n            // p = floor(p)+.5;\n            fragColor.xyz = texture(iChannel1, p/iChannelResolution[1].xy).xyz;\n        } else fragColor.xyz = vec3(0);\n    }\n\n    fragColor.w = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* Checkerboard invert half the texture pixels\n\nThis could be baked into the tone mapping of the previous render pass.\n\nThe checkerboarding allows bilinear filtering to be used to read 4 taps\nsimultaneously at the correct ratios, by strategic selection of the subpixel\nposition. 16 taps are read as 4 texture reads.\n\nThis buffer should be the same size as the source image.\nShadertoy doesn't allow buffer sizes to be set, so it is assumed the\nrender size is larger than the source texture (512x512 pixels).\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel number, integer\n    vec2 pixel = floor(fragCoord);\n    \n    // Get texture, 1:1 pixel ratio, sampling at centre of texel.\n    vec3 c = texture(iChannel0, (pixel + 0.5)/iChannelResolution[0].xy).xyz;\n    \n    // Checkerboard flip\n    float flip = (pixel.x + pixel.y)*.5;\n    flip = flip - floor(flip);\n    if (flip > .25) c = -c;\n\n    fragColor = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}