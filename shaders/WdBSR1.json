{
    "Shader": {
        "info": {
            "date": "1552837741",
            "description": "Just an experiment.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdBSR1",
            "likes": 6,
            "name": "PUMA CELL",
            "published": 3,
            "tags": [
                "cell",
                "puma"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 403
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\nvec4 map(vec3 p){\n    p *= matRotateZ(radians(iTime*5.0));\n    p.y-= iTime*0.3;\n    vec3 pref = p;\n    \n    float animateH = sin(iTime*3.0)*0.02;\n    \n    pref.x = mod(pref.x,0.4)-0.2;\n    pref.y = mod(pref.y,0.7)-0.35;\n    pref*= matRotateZ(radians(30.0));\n    float d0 = sdHexPrism(pref+ vec3(0.0,0.0,-1.0),vec2(0.17,0.06+animateH));\n    float d01 = sdHexPrism(pref+ vec3(0.0,0.0,-1.0),vec2(0.2,0.05+animateH));\n    d0 = max(-d0,d01);\n    pref = p;\n    \n    animateH =  sin(iTime*2.0)*0.02;\n    pref += vec3(0.2,-0.35,-1.0);\n    pref.x = mod(pref.x,0.4)-0.2;\n    pref.y = mod(pref.y,0.7)-0.35;\n    pref*= matRotateZ(radians(30.0));\n    float d1 = sdHexPrism(pref,vec2(0.17,0.06+animateH));\n    float d11 = sdHexPrism(pref,vec2(0.2,0.05+animateH));\n    d1 = max(-d1,d11);\n    pref = p;\n    \n    return vec4(vec3(0.0,0.7,0.0),opSmoothUnion(d0,d1,0.07));\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tmat3 camRotY = matRotateY(radians(sin(iTime)*3.0));\n    \n\tvec3 ro=vec3(0.,0.0,0.0);\n    vec3 rd=normalize(vec3(p,1.0));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 30; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t)*camRotY;\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n        vec3 V = distPos;\n        vec3 L = normalize(lightDir-V);\n        \n        vec3 E = normalize(-V);\n        vec3 R = normalize(-reflect(L, normal));\n        \n\t\t// difuse color\n        float diffuseVal = 2.7;\n        float diffuse = diffuseVal * max(dot(normal, L), 0.0);\n        diffuse = clamp(diffuse, 0.0, 1.0);\n        \n\t\tfloat specVal = 0.9;\n\t\tfloat shininess = 10.0;\n\t\tfloat spec = specVal * pow(max(dot(R, E), 0.0), 0.3*shininess);\n        spec = clamp(spec, 0.0, 1.0);\n\t\t\t\t\n        float AmbientVal = 1.5;\n        vec3 AmbientColor = vec3(0.5);\n        vec3 DiffuseColor = vec3(0.3,0.3,0.3);\n        vec3 SpecularColor = vec3(0.9);\n\t\tvec3 ambient = AmbientVal * AmbientColor;        \n        \n\t\tfloat lambert = max(.0, dot( normal, light));\n\n\t\t// result\n\t\tcolor = (distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        color *= ambient +(DiffuseColor * diffuse)+ (SpecularColor*spec);\n\t}else{\n        color =.84*max(mix(vec3(0.1,0.11,0.15)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n    vec3 white = vec3(1.0);\n    vec3 logoCol = vec3(0.0);\n    vec2 logoPos = vec2(0.4,0.0);\n    \n    p.x+=(mod(iTime,2.0)<0.3)?sin(floor(p.y*20.0)*iTime*30.)*0.03:0.0;\n    \n\tlogoCol = line( logoCol, vec2(0.0, 0.07), vec2(0.0, -0.07), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n\tlogoCol = line( logoCol, vec2(0.0, -0.1), vec2(0.12, -0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.0, 0.1), vec2(0.12, 0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    \n    logoCol = line( logoCol, vec2(0.2, 0.07), vec2(0.2, -0.07), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n\tlogoCol = line( logoCol, vec2(0.2, -0.1), vec2(0.32, -0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.2, 0.1), vec2(0.32, 0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.24, 0.0), vec2(0.32, 0.0), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    \n\tlogoCol = line( logoCol, vec2(0.4, 0.1), vec2(0.4, -0.07), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.4, -0.1), vec2(0.52, -0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.6, 0.1), vec2(0.6, -0.07), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    logoCol = line( logoCol, vec2(0.6, -0.1), vec2(0.72, -0.1), p+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    \n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = color*brightness;\n\tfragColor = vec4(dst+logoCol, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}