{
    "Shader": {
        "info": {
            "date": "1630703005",
            "description": "sdggs",
            "flags": 32,
            "hasliked": 0,
            "id": "sls3Ds",
            "likes": 14,
            "name": "basic pt direct light 27",
            "published": 3,
            "tags": [
                "sdfsg"
            ],
            "usePreview": 0,
            "username": "MinimilisticBits",
            "viewed": 460
        },
        "renderpass": [
            {
                "code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv).xyzw;\n    vec3 col = c.xyz/float(iFrame+1);\n    col = vec3(1.)-exp(-3.6*col);\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.7,0.7)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.3,1.4,1.7);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\n    c = c * pi/180.;\n    //pythagoras theorem\n    float l = length(a);\n    a/=l;\n  \n    float ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\n    ang += c;\n   \n    return vec2(cos(ang),sin(ang))*l;\n}\n\n\nfloat box(vec3 p, vec3 s){\n    vec3 a = abs(p)-s;\n    return max(max(a.x,a.y),a.z);\n}\nfloat escape;\nfloat DE(vec3 p0){\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    for(int i = 0; i < 8; i++){\n        p.xyz = mod(p.xyz-1., 2.)-1.;\n        p*=(1.2/dot(p.xyz,p.xyz));\n//the higher the dot product of p is, the less will be added to escape        \n                escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //normalization\n    p/=p.w;\n    return abs(p.x)*0.25;\n}\n\nfloat DE2(vec3 p0){\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    for(int i = 0; i < 8; i++){\n        p.xyz = mod(p.xyz-1., 2.)-1.;\n        \n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        p = abs(p);\n        //p.xy = rot(p.xy, 5.);\n        //p*=(1.1/dot(p.xyz,p.xyz));\n        //p*=0.4;\n                escape += exp(-0.2*dot(p.xyz,p.xyz));\n        p*=1.2;\n    }\n    p/=p.w;\n    return abs(p.z)*0.25;\n}\n\nvec3 pal(float t, vec3 a, vec3 b){\nreturn 0.5+0.5*cos(2.*3.14159*t*a + b);\n}\n\n/////////////////////////////////\n\nvec3 fold(vec3 p0){\nvec3 p = p0;\n//if(abs(p.x) > 1.)p.x = 1.0-p.x;\n//if(abs(p.y) > 1.)p.y = 1.0-p.y;\n//if(abs(p.z) > 1.)p.z = 1.0-p.z;\nif(length(p) > 1.)return p;\np = mod(p,2.)-1.;\n\nreturn p;\n}\n\n\n\n\nfloat es2;\nfloat DE1(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    es2 = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.8/clamp(dot(p.xyz,p.xyz),-1.0,1.));\n        p.xyz-=vec3(0.3,1.9,0.4);\n        //p*=1.4;\n\n        es2 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\nfloat DEe(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n      // p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.0,1.));\n        p.xyz-=vec3(0.3,4.5,0.7);\n        //p*=1.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\nfloat esp;\nfloat DEe2(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    esp = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n      // p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.0,1.));\n        p.xyz-=vec3(0.3,4.5,0.7);\n        //p*=1.4;\n\n        esp += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\n\nfloat esp2;\nfloat DEe3(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    esp2 = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n      // p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.0,1.));\n        p.xyz-=vec3(0.3,4.5,0.7);\n        //p*=1.4;\n\n        esp2 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\n\nfloat escape6;\nfloat DE45(vec3 p0){\n//p0 = mod(p0, 4.)-2.;\n    vec4 p = vec4(p0, 1.);\n    escape6 = 0.;\n        p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        \n        p=abs(p);\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),-0.1,1.));\n        p.xyz-=vec3(.5,1.3,0.2);\n        escape6 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEbox(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        p.xyz = -abs(p.xzy);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.25/clamp(dot(p.xyz,p.xyz),-1.0,1.));\n        p.xyz-=vec3(0.3,1.6,0.5);\n        //p*=1.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\nfloat DEg(vec3 p0){\nescape = 999999.;\n    vec4 p = vec4(p0, 1.);\n        p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n        p*=(1.6/clamp(dot(p.xyz,p.xyz),.0,1.));\n        p.xyz-=vec3(0.7,1.8,0.5);\n        p*=1.2;\n        escape = min(escape, dot(p.xyz,p.xyz));\n    }\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEgg(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.8/clamp(dot(p.xyz,p.xyz),.0,1.));\n        p.xyz-=vec3(3.6,1.9,0.5);\n       //p*=1.1;\n\n        //escape = min(escape, dot(p.xyz,p.xyz));\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\n\nfloat DEx(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.6/clamp(dot(p.xyz,p.xyz),.0,1.));\n        p.xyz-=vec3(1.5,2.2,0.6);\n       //p*=1.1;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\n    return length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\nfloat escape2;\nfloat DEex(vec3 p0){\np0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n                                p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.5/clamp(dot(p.xyz,p.xyz),0.6,1.));\n        p.xyz-=vec3(0.7,1.8,0.5);\n        p*=1.2;\n\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DExx(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n        p.xyz=abs(p.xyz);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(2.15/clamp(dot(p.xyz,p.xyz),.4,1.));\n        p.xyz-=vec3(0.3,0.2,1.6);\n       //p*=1.1;\n\n        escape = exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\n    return length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\n\nfloat DExx2(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n        p.xyz=abs(p.xyz);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(2.1/clamp(dot(p.xyz,p.xyz),.4,1.));\n        p.xyz-=vec3(0.3,0.2,1.6);\n       //p*=1.1;\n\n        escape = exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\n    return length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\n\nfloat dis2(vec3 p){\nreturn DExx2((vec3(3.3,2.5,8.6)-p)/10.)*10.;\n}\n\nfloat DEeex(vec3 p0){\n//p0 = mod(p0, vec3(4.,4.,20.))-vec3(4.,4.,20.)*0.5;\n    vec4 p = vec4(p0, 1.);\n    escape = 999999.;\n                                p.xyz=-abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xzy);\n\n        p*=(1.48/clamp(dot(p.xyz,p.xyz),0.6,1.));\n        p.xyz-=vec3(0.7,1.8,0.5);\n        p*=1.1;\n\n        escape = min(escape,dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEef(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=-abs(p.xzy);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.zxy);\n\n        p*=(1.6/clamp(dot(p.xyz,p.xyz),0.8,1.));\n        p.xyz-=vec3(0.8,.8,.4);\n        p*=1.2;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n\n//NOT MY CODE///////////////\nuint wang_hash(inout uint seed)\n{\n//dunno, not mine\n//bit operations that give you a number between 0 and the maximum uint size which is\n//4294967296, dividing by the maximum gives you a number between 0 and 1\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n///////////////////////////\n\n\nfloat DEe22(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 99.;\n                                p.xyz=abs(p.xyz);\n                                uint seed = uint(p.x+p.y+p.z);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=((1.6+rndf(seed)*0.1)/clamp(dot(p.xyz,p.xyz),0.6,1.));\n        p.xyz-=vec3(0.7+rndf(seed)*0.4,1.0,0.5);\n        p*=1.3-rndf(seed)*0.2;\n\n        //escape += exp(-0.2*dot(p.xyz,p.xyz));\n        vec3 norm = normalize(p.xyz);\n        float theta = acos(norm.z/length(norm.xyz));\n        float phi = atan(norm.y/norm.x);\n        escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEe33(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 999.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(2.1/clamp(dot(p.xyz,p.xyz),0.4,1.));\n        p.xyz-=vec3(2.3,3.8,5.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.1;\n\n        //escape += exp(-0.2*dot(p.xyz,p.xyz));\nvec3 norm = normalize(p.xyz);\n        float theta = acos(norm.z/length(norm.xyz));\n        float phi = atan(norm.y/norm.x);\n        escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n\nfloat DEe44(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 14; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.24/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(1.6,2.8,5.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.1;\n\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEe55(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(1.6,1.8,1.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.2;\n\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEe66(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=-abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 22; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.15/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(.6,.8,.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.2;\nescape = min(escape, dot(p.xyz,p.xyz));\n       // escape += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEe77(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(1.3/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(1.+rndf(seed),1.0,2.2);\n        p.xyz = -abs(p.xyz+rndf(seed));\n        //p*=1.2;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n//NOT MY CODE////////\n \t\n\n \nfloat de(vec3 p){\n    p.xz=abs(.5-mod(p.xz,1.))+.01;\n    float DEfactor=1.;\n    for (int i=0; i<14; i++) {\n        p = abs(p)-vec3(0.,2.,0.);  \n        float r2 = dot(p, p);\n        float sc=2./clamp(r2,0.4,1.);\n        p*=sc; \n        DEfactor*=sc;\n        p = p - vec3(0.5,1.,0.5);\n    }\n    return length(p)/DEfactor-.0005;\n}\n\n\nfloat de2(vec3 p){\n    p=1.-abs(abs(p+sin(p))-1.);\n    p=p.x < p.y?p.zxy:p.zyx;\n    float s=5., l;\n    for(int j=0;j++<4;)\n        s*=l=2./min(dot(p,p),1.5),\n        p=abs(p)*l-vec3(2,1,3);\n    return length(p.yz)/s;\n}\nfloat de3(vec3 p){\np = mod(p,2.)-1.;\n    p=1.-abs(abs(p+sin(p))-1.);\n    p=p.x < p.y?p.zxy:p.zyx;\n    float s=5., l;\n    for(int j=0;j++<4;)\n        s*=l=2.7/min(dot(p,p),1.5),\n        p=abs(p)*l-vec3(2,1,3);\n    return length(p.yz)/s;\n}\n\nfloat dee(vec3 p){\n    p.xz=abs(.5-mod(p.xz,1.))+.01;\n    float DEfactor=1.;\n    escape = 0.;\n    for (int i=0; i<14; i++) {\n        p = abs(p)-vec3(0.,2.,0.);  \n        float r2 = dot(p, p);\n        float sc=2./clamp(r2,0.4,1.);\n        p*=sc; \n        DEfactor*=sc;\n        p = p - vec3(0.1,1.2,0.5);\n        escape += exp(-0.2*dot(p,p));\n    }\n    return length(p)/DEfactor-.0005;\n}\nmat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));    \n}\nvec4 formula(vec4 p) {\n    p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n    p=p*2./clamp(dot(p.xyz,p.xyz),.15,1.)-vec4(0.5,0.5,0.8,0.);\n    p.xy*=rot(.5);\n    return p;\n}\nfloat screen(vec3 p) {\n    float d1=length(p.yz-vec2(.25,0.))-.5;    \n    float d2=length(p.yz-vec2(.25,2.))-.5;    \n    return min(max(d1,abs(p.x-.3)-.01),max(d2,abs(p.x+2.3)-.01));\n}\nfloat de23(vec3 pos) {\n    vec3 tpos=pos;\n    escape = 0.;\n    tpos.z=abs(2.-mod(tpos.z,4.));\n    vec4 p=vec4(tpos,1.5);\n    float y=max(0.,.35-abs(pos.y-3.35))/.35;\n\n    for (int i=0; i<19; i++) {\n    p=formula(p);\n    escape += exp(-0.2*dot(p,p));\n    }\n    float fr=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-3.)))/p.w);\n\n    float sc=screen(tpos);\n    return min(sc,fr);    \n}\n\n \t\n\nfloat de12(vec3 p){\n  float s=4.;\n  float l=0.;\n  p.z-=.9;\n  vec3 q=p;\n  s=2.;\n  for(int j=0;j++<12;)\n    p-=clamp(p,-1.,1.)*2.,\n    p=p*(l=8.8*clamp(.72/min(dot(p,p),2.),0.,1.))+q,\n    s*=l;\n  return length(p)/s;\n}\n\n////////////\nfloat de22(vec3 p0){\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n    p=abs(p);\n    if(p.x < p.z)p.xz = p.zx;\n    if(p.z < p.y)p.zy = p.yz;\n    if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        p = abs(p);\n        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.1,1.));\n        p.xyz-=vec3(0.2,1.9,0.6);\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz)); \n    }\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\n    return (length(p.xyz)/p.w);\n}\n\n\n\n\n//JB's Collection of fractals + code\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\nfloat smin_op(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float fixed_radius2 = 1.9;\n  float min_radius2 = 0.1;\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp; dz *= temp;\n  }else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp; dz *= temp;\n  }\n}\nvoid box_fold(inout vec3 z, inout float dz) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nfloat de222(vec3 z) {\n  vec3 offset = z;\n  float scale = -2.8;\n  float dr = 1.0;\n  escape = 0.;\n  for(int n = 0; n < 15; ++n) {\n    box_fold(z, dr);\n    sphere_fold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n    escape += exp(-0.2*dot(z.xyz,z.xyz));\n  }\n  float r = length(z);\n  return r / abs(dr);\n}\nvoid box_fold(inout vec3 z) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nfloat DEer(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n        //p.xyz=1.0-abs(abs(p.xyz+sin(p.xyz)*1.)-1.);\n\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n\n    for(int i = 0; i < 12; i++){\n        //if(p.x > p.z)p.xz = p.zx;\n       //if(p.z > p.y)p.zy = p.yz;\n       if(p.y > p.x)p.yx = p.xy;\n               // p.xyz = abs(p.xyz);\n\n        //box_fold(p.xyz);\n        sphere_fold(p.xyz,p.w);\n        //p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.,1.0));\n        p.xyz=abs(p.xyz)-vec3(3.5,.5,3.3);\n       //p*=1.2;\np.yxz -= sin(float(i)*1.)*0.9;\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n   p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n//===============================\nfloat rota = 83.;\nfloat rotb = 10.;\nfloat dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob){\n    c = vec3(0.9);\n    a2 = 0.01;\n    prob = 0.;\n    l = 0.;\n    //float a = box(vec3(0.,4.,-5.)-p, vec3(10.,10.,0.2));\n    //float b = box(vec3(0.,4.,5.)-p, vec3(10.,10.,0.2));\n    //float c1 = box(vec3(7.,4.,0.)-p, vec3(0.2,10.,10.));\n    //float c2 = box(vec3(-7.,4.,0.)-p, vec3(0.2,10.,10.));\n    //float c3 = box(vec3(0.,9.,0.)-p, vec3(10.,0.2,10.));\n    //float b2 = box(vec3(-5.,-59.5,15.)-p, vec3(22.,0.00000000000004,22.));\n    //    vec3 p = vec3(11.9,12.5, 0.);\n\n    //float aa = DEe77((vec3(-0.,0.,4.0)-p)/10.)*10.;\n        float aa2 = DEer((vec3(-0.,28.,-0.0)-p)/10.)*10.;\n       \n    float plane = p.z + (5.+((sin(p.x + cos(p.y))+cos(p.y+sin(p.x)))*0.03+\n    //float plane = length(vec3(15.,0.,0.)-p)-4.;\n\n    (sin(p.x*5.+cos(p.y)) + cos(p.z*5.+sin(p.x*2.)))*0.005  ) );\n    //float final = min(min(min(min(min(aa,plane),aaa),aa5),aa4),aa44);\n   // float final = min(min(min(min(aa,aaaa),a22),aa44),plane);\n    float final = aa2;\n    vec3 color = vec3(0.5,0.5,0.8);\n   // if(final == aa){a2 = 0.1;prob=0.9;c=vec3(0.5);}\n       if(final == aa2){a2 = 0.1;prob=0.9;c=pal(escape, vec3(0.9), vec3(0.2,0.2,0.9));}\n    \n\n    return final;\n}\n\nvec3 anglephong(float a,vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float t = pow(r2, 2./(1.+a));\n    float x = cos(2.*3.14159*r1)*sqrt(1.-t);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-t);\n    float z = sqrt(t);\n//same explanation as above:\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat denn = 0.03;\nbool trac(inout vec3 p, vec3 d, inout float dd, inout float l,\ninout vec3 c, inout float a, inout float prob, inout uint r, inout float k){\n    for(int i = 0; i < 160; i++){\n        dd = dis(p,l,c,a,prob);\n        if(dd<0.01)return true;\n        if(rndf(r) < denn){\n           d = anglephong(1000., d, r);\n        }\n        k+=exp(-dd*20.);\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    vec3 c;\n    float l,a,prob;\n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.01, p.yz),l,c,a,prob) - dis(vec3(p.x-0.01, p.yz),l,c,a,prob),\n            dis(vec3(p.x, p.y+0.01, p.z),l,c,a,prob) - dis(vec3(p.x, p.y-0.01, p.z),l,c,a,prob),\n            dis(vec3(p.x, p.y,p.z+0.01),l,c,a,prob) - dis(vec3(p.x, p.y,p.z-0.01),l,c,a,prob)\n        )\n    );\n}\n\nfloat noise(vec3 uv){\n//uv += 1000.;\n//numbers so large that looks like random noise\n    return fract(sin(uv.x*23. + uv.y*345. + uv.z *200.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\n\n\nvec3 angledircos(vec3 n, inout uint r){\n//2 random numbers between 0 and 1\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    float z = sqrt(r2);\n//nice trick, basically pick a random vector W, doesn't matter, as long as it's not equal to N\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n//Get the perpendicular of the T and N, which will give you the y axis    \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nvec3 angledircos2(vec3 n, inout uint r){\n//2 random numbers between 0 and 1\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float theta = acos(sqrt(r2));\n    float phi = 2.*3.14159*r1;\n    //phi is an angle between 0 and 2pi, using the cos(phi),sin(phi), gives us the \n    //full rotation on the x and y axis, but we need to scale it down depending on z\n    //if z is pointing up, then sin(theta) will return 0, if theta is equal to pi/2, then it will\n    //return 1.. and finally to get z axis, simply return cos(theta), which will return 1 at angle 0\n    //this is because cos and sin simply return the coordinates of x and y depending on a certain angle\n    //you can see this if you construct a right angle triangle inside of the circle\n    //cos(x) would be equal to the horizontal length divided by the length of the diagonal side\n    //I need to learn mathematical jargon\n    float x = cos(phi)*sin(theta);\n    float y = sin(phi)*sin(theta);\n    float z = cos(theta);\n    \n    //float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    //float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    //float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));  \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat powerh(float a, float pdf1, float b, float pdf2){\n    pdf1*=a;\n    pdf2*=b;\n    return (pdf1*pdf1)/(pdf1*pdf1 + pdf2*pdf2);\n\n}\n\n\nvec3 F(float costheta, float y, vec3 A, vec3 B, vec3 C, vec3 D, vec3 E){\nreturn (1.+A*exp(B/costheta))*(1.0+C*exp(D*y) + E*cos(y)*cos(y));\n}\n//Preetham sky model implemented by me, using the research paoer\nvec3 skyp2(vec3 d, vec3 lig){//my code to begin with\nvec3 zenith = vec3(0.,0.,1.);\nfloat costheta = max(dot(d,zenith),0.);\nfloat costhetas = max(dot(lig,zenith),0.);\nfloat cosy = max(dot(lig,d),0.);\nfloat y = acos(cosy);\n//return vec3(0.1);\n//if(costheta<0.01)return vec3(0.);\n//simple cie sky\nfloat T = 3.;\nfloat X = (4./9. - T/120.)*(3.14159-2.*acos(costhetas));\nfloat Yz = (4.0453*T - 4.9710)*tan(X)-0.2155*T+2.4192;\n\n//vec3 template = vec3(*T+,*T+,*T+);\nvec3 AYxy = vec3(0.1787*T-1.4630, -0.0193*T-0.2592,-0.0167*T-0.2608);\nvec3 BYxy = vec3(-0.3554*T+0.4275,-0.0665*T+0.0008,-0.0950*T+0.0092);\nvec3 CYxy = vec3(-0.0227*T+5.3251,-0.0004*T+0.2125,-0.0079*T+0.2102);\nvec3 DYxy = vec3(0.1206*T-2.5771,-0.0641*T-0.8989,-0.0441*T-1.6537);\nvec3 EYxy = vec3(-0.0670*T+0.3703,-0.0033*T+0.0452,-0.0109*T+0.0529);\n\nfloat ts = acos(costhetas);\nfloat ts2 = ts*ts;\nfloat ts3 = ts*ts*ts;\nvec3 xz0 = vec3(0.00166*ts3 -0.00375*ts2 + 0.00209*ts,\n-0.02903*ts3 + 0.06377*ts2 - 0.03202*ts + 0.00394,\n0.11693*ts3 - 0.21196*ts2 + 0.06052*ts + 0.25886\n);\n\nvec3 yz0 = vec3(0.00275*ts3 -0.00610*ts2 + 0.00317*ts,\n-0.04214*ts3 + 0.08970*ts2 - 0.04153*ts + 0.00516,\n0.15346*ts3 - 0.26756*ts2 + 0.06670*ts + 0.26688\n);\n\nfloat xz = xz0.x*T*T + xz0.y*T + xz0.z;\nfloat yz = yz0.x*T*T + yz0.y*T + yz0.z;\n\nvec3 Yxyz = vec3(Yz,xz,yz);\n//test\n//vec3 test1 = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Ftop = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Fbottom = F(1., ts, AYxy, BYxy, CYxy, DYxy, EYxy);\n\nvec3 finalYxy = Yxyz*(Ftop/Fbottom);\n\nvec3 XYZ = vec3(\n(finalYxy.y*finalYxy.x)/finalYxy.z,\nfinalYxy.x,\n((1.-finalYxy.y - finalYxy.z)*finalYxy.x)/finalYxy.z\n);\n\nvec3 rgb = vec3(\n3.2404542*XYZ.x -1.5371385*XYZ.y -0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\n\n//return test1*0.1;\nreturn rgb*0.034 + exp(-y*20.)*vec3(0.9,0.6,0.2);\n}\n\nfloat beckmann_D2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,4.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.001);\n}\n\nfloat beckmann_pdf2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,3.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.0001);\n}\n\nvec3 beckmann_S(vec3 n, inout uint r, float a){\n        float r1 = rndf(r);\n        float r2 = rndf(r);\n    \n        float theta = atan(sqrt(-a*a*log(1.-r1)));\n        //float theta = acos(sqrt((1.-r1)/(r1*(a*a-1.)+1.) ));\n        float phi = 2.*3.14159*r2;\n        \n        float x = cos(phi)*sin(theta);\n        float y = sin(phi)*sin(theta);\n        float z = cos(theta); \n         \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nfloat beckmann_pdf(vec3 m, vec3 n, float a){\nfloat angle = acos(max(dot(m,n),0.));\nfloat a1 = 1./(3.14159*a*a*pow(max(dot(m,n),0.),3.)); // should be the pdf over a solid angle\nfloat b1 = exp(-((tan(angle)*tan(angle))/(a*a)));\nreturn max(a1*b1,0.0001);\n}\n\nfloat ggx_G(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat g1 = (2.*max(dot(n,h),0.)*max(dot(n,-wi),0.))/max(dot(-wi,h),0.);\nfloat g2 = (2.*max(dot(n,h),0.)*max(dot(n,l),0.))/max(dot(-wi,h),0.);\nfloat G = min(1.,min(g1,g2));\nreturn G;\n}\n\nfloat ggx_G2(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat top = 2.*max(dot(n,-wi),0.);\nfloat bottom = max(dot(n,-wi),0.)+sqrt(a*a + (1.-a*a)*pow(max(dot(n,-wi),0.),2.));\nreturn top/bottom;\n}\n\nvec3 ggx_F(vec3 Fo, float cost){\nreturn Fo + (1.-Fo)*pow(1.-cost,5.);\n}\n\nvec3 renderpixel(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 p2 = p;\n    vec3 d2 = d;\n    float dd;\n    vec3 prevp = p;\n    vec3 lig = normalize(vec3(0.2,0.2,.9));\n    vec3 tt = vec3(1.);\n    float l = 0.;\n    vec3 c = vec3(0.9);\n    float a = 0.;\n    float probability=0.;\n    const int bounces = 6;\n    float k = 0.;\n    for(int i = 0; i < bounces; i++){\n        if(trac(p,d,dd,l,c,a,probability,r,k)){\n            vec3 n = norm(p-d*0.01,dd);\n            p+=n*0.05;\n            vec3 wi = d;\n            //float a = 100000.;\n//explained above\nfloat rough = a;\n            d = angledircos(n,r);\n        \n            float number = rndf(r);\n            if(number < probability){\n               d = beckmann_S(reflect(wi,n), r, rough);\n            }\n//\n            bool bo = (int(fragCoord.x)/64 + int(fragCoord.y)/64)%2==0;\n           //bo = true;\n          //bo = fragCoord.x < iResolution.x*0.5;\n            if(l>0.01){\n                col += tt*vec3(0.9,0.5,0.5);\n                break;\n            }\n            //vec3(0.,4.,4.)-p, vec3(1.,1.\n            //vec3(0.,-4.,0.)-p, vec3(8.,0.00000000000004,8.))\n            vec3 lpos = vec3(-5.,-59.5,15.);\n            float area = 44.*44.;\n            float r1 = rndf(r)*2.0-1.0;\n            float r2 = rndf(r)*2.0-1.0;\n\n            lpos.x += r1*22.;\n            lpos.z += r2*22.;\n            vec3 ldir = lpos-p;\n            float dist2 = length(lpos-p)*length(lpos-p);\n            ldir = normalize(lig);\n          \n            vec3 brdf = c/3.14159 ;\n            \n            \n            float hemipdf = max(dot(d,n),0.)/3.14159;\n            hemipdf = max(hemipdf, 0.0000000000000001);\n        \n            vec3 brdf2 = c/3.14159 ;\n            float hemipdf2 = max(dot(d,n),0.)/3.14159;\n            hemipdf2 = max(hemipdf2, 0.0000000000000001);\n            vec3 h = normalize(d+ -wi);\n            vec3 h2 = normalize(ldir+-wi);\n             float D;\n           D=beckmann_D2(reflect(wi,n), d, rough);\n           \n               float G = ggx_G2(h,n,wi,d,rough);//cook torrance based geometry term\n           vec3 F = ggx_F(c, max(dot(-wi, n), 0.));//schlicks approx to the fresnel term\n           vec3 specular = (D*G*F)/max(4.*max(dot(-wi,n),0.)*max(dot(d,n),0.6),0.0001);\n        \n        \n        float D2; \n   D2 = beckmann_D2(reflect(ldir,n), wi, rough);\n  \n   float G2 =ggx_G2(h2,n,wi,ldir,rough);\n   vec3 F2 = ggx_F(c, dot(-wi, h2));\n   vec3 specular2 = (D2*G2*F2)/max(4.*dot(-wi,n)*dot(ldir,n),0.0001);\n   \n        \n            if(number < probability){\n                brdf = specular;\n                hemipdf = beckmann_pdf2(reflect(wi,n),d,rough);\n                hemipdf = max(0.000000001, hemipdf);\n\n                brdf2 = specular2;\n                hemipdf2 = beckmann_pdf2(reflect(ldir,n),wi,rough);\n                \n                hemipdf2 = max(hemipdf2,0.00000001);\n            }\n            \n                                           brdf *=  (1.0+2.*probability*max(dot(d,n),0.));\n                                brdf2 *=  (1.0+2.*probability*max(dot(d,n),0.));\n\n            \n            vec3 curr = p;\n            float l2;\n            float a2,prob2;\n            float k2;\n            vec3 lightdir = anglephong(100000., lig, r);\n            if(!trac(curr, lightdir,dd,l2,c,a2,prob2,r,k2) && dot(lightdir,n)>0.){\n                //if(i==0)tt *= brdf*(max(dot(d,n),0.00001)/hemipdf);\n                col += tt*brdf2*vec3(0.9,0.7,0.5)*dot(lightdir,n);\n                //break;\n            }\n            \n            /*if(bo){\n               if(i == 0 && l > 0.01){\n                   col+=tt*l;\n                   break;\n               }\n               if(l > 0.01){\n                   break;\n               }\n           \n               float l2;\n               vec3 lpp = p;\n               float a2,prob2;\n               if(trac(lpp,ldir,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(lpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n                   if(l2>0.01 && i < bounces-1 && dot(ln, -ldir) > 0.0 && dot(n, ldir) > 0.0){\n                  \n                       float pdf = dist2/(max(dot(ln, -ldir),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       float brpdf = max(dot(ldir, n),0.)/3.14159;\n                       brpdf = max(brpdf, 0.00000001);\n                       if(number < probability){\n                           brpdf = hemipdf2;\n                       }\n                       //power heuristics as explained above, on the high specular parts,\n                       //the weight will return a number closer to 0, so that the direct light sampling\n                       //wouldn't sample in an area where it's useless \n                       float weight = powerh(1., pdf, 1., brpdf);\n                       col += (tt*brdf2*l2*weight)*(max(dot(n, ldir),0.000001)/pdf);\n                   }\n               }\n           \n           //brdf sampling for mis \n               vec3 bpp = p;\n               if(trac(bpp,d,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(bpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n        \n                   if(l2>0.01 ){\n                  \n                       float dist3 = length(bpp-p)*length(bpp-p);\n                       float pdf = dist3/(max(dot(ln, -d),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       //float hemipdf = max(dot(d,n),0.)/3.14159;\n                       //hemipdf = max(hemipdf, 0.00000001);\n                       float weight = powerh(1., hemipdf, 1., pdf);\n                       col += (tt*brdf*weight*l2)*(max(dot(d,n),0.000001)/hemipdf);\n                   }\n               }\n            }*/        \n            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n            \n            if(i > 3){\n                float t_max = max(tt.x, max(tt.y, tt.z));\n                if(rndf(r) > t_max){\n                    break;\n                }\n                tt *= 1./t_max;\n            }\n\n           /*if(i == 0){\n             //   col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lightdir,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.2;\n            }else{\n                                //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n            }*/\n        }else{\n        float k2;\n        //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n\n           /*if(i == 0){\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                vec3 lightdir = anglephong(1000., lig, r);\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lightdir,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.2;\n            }*/\n            if(i==0){\n                col = tt*skyp2(d, lig)*0.3;\n            }else{\n                col += tt*skyp2(d, lig)*0.7;\n            }\n            //col += tt*texture(iChannel1,d.xzy).xyz;\n            break;\n        }\n    }\n    \n    /*vec3 glow;\n    float l2,a2,prob2;\n    vec3 c2;\n    for(int i = 0; i < 40; i++){\n        float dist2 = abs(dis2(p2))+0.001;\n        p2 += d2*dist2;\n        if(dis(p2,l2,c2,a2,prob2) < 0.01)break;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*pal(escape, vec3(0.9,0.9,0.9),vec3(0.4,0.4,0.9));\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }*/\n    //col += glow*0.0*vec3(0.4,0.7,0.8)*texture(iChannel1, (p.xz-p.y)*0.9).x;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //NOT MY CODE//////////////////////////////\n    uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////\n\n    int tiles = 2;\n    int samples = 10;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    \n   // if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n   // if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n\n    int jk = iFrame%samples;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 diff = ((1.)/iResolution.xy);\n    uv *= 0.9;\n    //uv.x += 0.1;\n    uv = uv * 2.0 - 1.0;\n    float r1 = rndf(r)*2.0-1.0;\n    float r2 = rndf(r)*2.0-1.0;\n    uv += diff*(vec2(r1,r2))*1.;\n\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //uv*=1.5;\n  //  uv*=0.7;\n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n   // d.xz = rot(d.xz, 30.);\n    \n    \n    vec3 p = vec3(0.,-0.0, -3.0);\n    \n    \n    //d.xz = rot(d.xz,90.);\n    //d.yz = rot(d.yz,rota);\n    d.yz = rot(d.yz,rota);\n    d.xy = rot(d.xy, rotb);\n    float focaldist = 6.4;\n    float radius = 0.02;\n\n    vec3 camdirection = vec3(0.,1.,0.);\n    camdirection.yz = rot(camdirection.yz, rota);\n    camdirection.xy = rot(camdirection.xy, rotb);\n    vec3 sidex = vec3(1.,0.,0.);\n    vec3 sidey = vec3(0.,0.,1.);\n   // sidex.yz = rot2(sidex.yz,rota);\n    //sidex.xz = rot(sidex.xz, -20.);\n   // sidex.yz = rot(sidex.yz,rota);\n    sidex.xy = rot(sidex.xy,rotb);\n    \n    //sidey.xz = rot(sidey.xz,-20.);\n    sidey.yz = rot(sidey.yz,rota);\n    //sidey.xy = rot(sidey.xy,rotb);\n    \n    float ang = rndf(r)*2.0*3.14159;\n    float dist = min(length((vec2(0.0,-0.4)-uv)*0.2),1.);\n    float scale = sqrt(rndf(r))*radius;\n   //vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 offset = vec2(scale*cos(ang), scale*(sin(ang)));\n    //NOT MY CODE////////////////////////\n    vec3 focuspoint = p + ((d*focaldist) / dot(d,camdirection)); //these will lie on the focal plane\n    /////////////////////////////////////\n    \n   // vec3 focuspoint = p+(d*focaldist);\n    //p.xz += offset;\n   p = p + sidex*offset.x;\n    p = p + sidey*offset.y;\n    d = normalize(focuspoint - p);\n    \n    \n    vec3 col = renderpixel(p,d, r, fragCoord);\n    col = clamp(col,0.,1.);\n   // if(jk != 0){\n    col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n   // }\n    // Output to screen\n    fragColor = vec4(col,float(jk));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}