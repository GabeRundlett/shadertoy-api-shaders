{
    "Shader": {
        "info": {
            "date": "1673008471",
            "description": "HexTorus dance\nMake sure music is playing",
            "flags": 96,
            "hasliked": 0,
            "id": "mlB3Rw",
            "likes": 23,
            "name": "HexTorus Dance",
            "published": 3,
            "tags": [
                "raymarching",
                "sound",
                "torus",
                "spiral",
                "hexagons",
                "buffers"
            ],
            "usePreview": 1,
            "username": "NivBehar",
            "viewed": 593
        },
        "renderpass": [
            {
                "code": "/*\n    I wanted to try a new tool I made which produce a smooth sound based on 3 basic bands: bass, middle and treble.\n    You can find it here: https://www.shadertoy.com/view/mtl3Rj\n    So I took an old shader, https://www.shadertoy.com/view/wlG3Wy and pushed these sound parameters where ever I could.\n*/\n\n# define time iTime\n# define PI 3.141592654\n# define MaxSteps 200 // max steps for ray marching\n\nfloat bass;\nfloat mid;\nfloat treb;\nfloat sound;\nfloat bass_cont;\nfloat mid_cont;\nfloat treb_cont;\nfloat sound_cont;\n\nvec4 mouse;\n\nfloat halDist;\nbool init;\nbool stop;\n\nvec3 HalCol() {return vec3(bass,0.4,treb);}\nvec3 FogCol() {return vec3(bass*0.6,treb*0.4,0.21);}\n\nvec3 torus1Pos() {return vec3(0.,0.,0.);}\nvec2 torus1Size() {return vec2(45.3,17.5);} //45.3 17.5\n\nvec2 torusRotSpeed() {return vec2(-sound_cont - time*0.5, sound_cont + time*0.4);}\nfloat inOut = -1.; // -1 inside torus, 1 outside torus\n\nvec2 hexCoordsMul = 1.*vec2(1.9,1.184)*2.*PI;// + 0.*vec2(2.4,1.24)*6. + 0.*vec2(1.5,1.24)*6. + 0.*vec2(6.,3.03);\nfloat hexCoordsAdd = 1000.;\n\nvec3 spherePos() {\n    return vec3(10. * sin(time*0.381), 10. * cos(time*0.452), 40.);\n}\nfloat sphereRad() {return 5.;}\nvec3 spherePosNew(vec3 p, vec3 spherePos)\n{\n    p = p - spherePos;\n    p = RotZ(p, time);\n    p = RotX(p, time);\n    return p;\n}\n\nvec3 camerapos() {return vec3(0., 2.5, 60.);}\nvec3 cameralookat() \n{\n    return spherePos();\n}\nvec3 LightPos()\n{\n    return camerapos() + vec3(10.,4.,0.) + 0.*vec3(70.*cos(0.5*PI + 0.25*PI*sin(bass_cont*0.3)),25.*sin(treb_cont*1.5),70.*sin(0.5*PI + 0.25*PI*sin(mid_cont*0.3)));\n} \n\nvec4 Hive(vec2 UV, bool calc_flowers)\n{\n    vec3 col = vec3(0);\n    vec4 hc = HexCoords(UV);\n    float c = smoothstep(0.08, 0.11, hc.y); // inside each hexagon (without the edges)\n    float edges = 1.-c;\n    float id1 = hc.z;\n    float id2 = hc.w;\n    \n    // masking 3 horizontal bands based on hexagon's ID\n    float num_of_tiles = 6.;\n    float b11;\n    if(mod(floor(id2 / (num_of_tiles/2.)), 3.) == 0.)\n    {\n        b11 = 0.;\n    }\n    else\n    {\n        b11 = 1.;\n    }\n    \n    float b12;\n    if(mod(floor(id2 / (num_of_tiles/2.)), 3.) == 1.)\n    {\n        b12 = 0.;\n    }\n    else\n    {\n        b12 = 1.;\n    }\n    \n    \n    float b13;\n    if(mod(floor(id2 / (num_of_tiles/2.)), 3.) == 2.)\n    {\n        b13 = 0.;\n    }\n    else\n    {\n        b13 = 1.;\n    }\n    \n    float a1 = b12 * b11;\n    float a2 = b11 * b13;\n    float a3 = b12 * b13;\n    b11 = a1;\n    b12 = a2;\n    b13 = a3;\n    \n    float band1 = b11;\n    float band2 = b12;\n    float band3 = b13;\n    \n    // flowers on each hexagon\n    float flowers = 1.;\n    if( calc_flowers)\n    {\n        vec4 ehc = HexCoords((hc.xy+0.1*vec2(0., time))*vec2(2.3,7.) + vec2(100.) + vec2(4.,0.));\n        flowers = fract(ehc.w);\n        flowers += smoothstep(0.,0.6, ehc.y);\n        flowers = clamp(flowers, 0., 1.);\n\n    }\n\n    vec3 A1 = vec3(0.5, 0.5, 0.5);\n    vec3 B1 = vec3(0.75, 0.55, 0.85);\n    vec3 D1 = vec3(0.0, 0.1, 0.2);\n    \n    vec3 A2 = vec3(1., 1., 1.);\n    vec3 B2 = vec3(1., 1., 1.);\n    vec3 D2 = vec3(1., 1., 1.);\n    \n    vec3 C = vec3(-treb_cont*1.5*0. + hc.z*0.15 + hc.w*0.15);\n    vec3 spinning_light_mask = A2 + B2 * cos(2.*PI*(D2 + C));\n\n    col =  \n          // white band\n          + 1.*band1*flowers*(1.-edges)*vec3(1.,1.,0.9) * 4. * treb * treb\n          \n          // blue band\n          + 1.*band2*(flowers)*(1.-edges)*vec3(0.34,0.5,1.) * 4. * mid * mid * mid\n          \n          // orange band\n          + 1.*band3*flowers*(1.-edges)*vec3(1.,0.6,0.2)*1. * bass * bass * bass\n          \n          // spinning band - when music is high\n          + mix(vec3(0.), vec3(0.995,0.749,0.847)*spinning_light_mask *(1.-edges) , min(1.,0. + treb*treb*treb*3.)) * 1.3\n          // spinning band - when music is low\n          + mix(vec3(0.995,0.749,0.847)*spinning_light_mask *(edges), vec3(0.) , min(1.,0. + treb*treb*treb*3.)) * 0.5;\n\n    return vec4(col, edges);\n}\n\nfloat sdTorus1(vec3 p, vec2 r) {\n    float torusDist = length( vec2(length(p.xz) - r.x, p.y) ) - r.y; \n    \n    vec2 tUV = GetTorusUV(p, torus1Size());   \n    vec4 h = HexCoords(tUV*hexCoordsMul + hexCoordsAdd + torusRotSpeed());\n    float hive = 0.25*smoothstep(0.,0.2,h.y) + 0.0000*smoothstep(0.1,0.2,h.y);\n    float hexTorus = torusDist + hive;\n\n    float holesTorus = max(-hexTorus,torusDist);\n    float hiveTorus = inOut*hexTorus;\n    \n    return hiveTorus*0.8;\n}\n\nvec2 GetDist(vec3 p)\n{\n    vec2 distToReturn; \n\n    // torus\n    vec3 torusPosNew = RotY(p - torus1Pos(), time);\n    float torusDist = sdTorus1(p - torus1Pos(), torus1Size());\n    float torusID = 1.;\n   \n    // an object inside the torus\n    float sphereID = 3.;\n    vec3 spherePosNew = p-spherePos();//spherePosNew(p, spherePos());\n    float sphere_rad = 9.5;\n    float sphereDist = sdSphere(spherePosNew, sphere_rad);\n    float click = mouse.z > 0. ? 1. : 0.;\n    float rotZMouse = (click > 0. ? mouse.x*0.01 : 0.);\n    float rotXMouse = (click > 0. ? mouse.y*0.01 : 0.);\n    vec3 box_pos = RotY(RotX(RotZ(spherePosNew, (1.-click)*treb_cont*1.2 + click*rotZMouse), (1.-click)*bass_cont*1.2 + click*rotXMouse), (1.-click)*mid_cont*1.2);\n    float boxDist = box(box_pos, vec3(0.788*sphere_rad));\n    sphereDist = smoothIntersectSDF(boxDist, sphereDist, .3);\n    vec3 cylPos = box_pos;\n    float max_h = 11.;\n    float cyls_rad = sphereRad()*0.6;\n    float cyl1 = cappedCylinder(cylPos, min(mid*17., max_h), cyls_rad);\n    float cyl2 = cappedCylinder(RotZ(cylPos, PI/2.), min(bass*bass*10., max_h), cyls_rad);\n    float cyl3 = cappedCylinder(RotX(cylPos, PI/2.), min(treb*17., max_h), cyls_rad);\n    float cyls = smoothUnionSDF(cyl1, smoothUnionSDF(cyl2, cyl3, 1.), 1.);\n    sphereDist = smoothUnionSDF(sphereDist, cyls, 6.);\n    \n    /*\n    define Halation around the object\n    idea: keep marching until we get to a point when the previous distance \n          from the object was smaller then the current point.\n          we need the stopping mechanism beacuse if we will not stop,\n          we will get artifacts caused by the torus.\n          its still not accurate but we can get nice results.\n          marching --> --> --> [a point close to the object] --> stop marching\n    */\n    if(init)\n    {\n        // initiate the distance from the object\n        halDist = sphereDist;\n        init = false;\n    }\n    else if(!stop)\n    {\n        \n        if(sphereDist >= halDist)\n        {\n            stop = true;\n        }\n        else\n            // keep updating\n            halDist = sphereDist;\n    }\n\n    float dist = min(torusDist, sphereDist);\n    if(dist == torusDist)\n        distToReturn = vec2(dist, torusID);   \n\n    if(dist == sphereDist)\n        distToReturn = vec2(dist, sphereID);\n        \n    return distToReturn;// * vec2(0.8,1.);\n}\nvec3 RayMarch(vec3 ro, vec3 rd, int steps) \n{\n    vec2 dS;\n    float dO;\n    vec3 p;\n    for(int i = 0; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        dS = GetDist(p);\n        if(dS.x < 0.0001) {break;}\n        dO += dS.x;\n    }     \n    return vec3(dO,dS);\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).x;\n    vec2 e = vec2(.01, 0);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy).x, \n                        GetDist(p-e.yxy).x, \n                        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\nfloat GetLight(vec3 p, vec3 normal, vec3 lightpos, float lightpower, float shadowstrength, int steps)\n{\n    vec3 l = normalize(lightpos - p);\n    //vec3 n = GetNormal(p);\n    float dif = clamp(dot(normal, l*lightpower), 0., 1.);\n    if(steps > 0) // shadows\n    {\n        float d = RayMarch(p + normal*0.2, l, steps).x;\n        if(d < length(lightpos-p))\n            dif *= shadowstrength;\n    }\n    return dif;\n}\n\nfloat GetSpotLight(vec3 p, vec3 normal, vec3 lightpos, vec3 lightDir, float alpha, float light_exp)\n{\n    vec3 l = normalize(lightpos - p);\n    float beta = abs(dot(-l, lightDir));\n    if( beta < cos(alpha))\n        return 0.;\n    float dot_product = beta;\n    dot_product = pow(dot_product, light_exp);\n    float dif = clamp(dot_product, 0., 1.);\n    return dif;\n}\n\nfloat specularReflection(vec3 p, vec3 normal, vec3 rd, vec3 lightPos, float steps, float intensity, float shininessVal)\n{\n    vec3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, normal), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0 ) {\n        vec3 R = reflect(-L, normal);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\nfloat calcOcclusion(vec3 p, vec3 normal) // calcOcclusion by iq\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = p + h*normal;\n        float d = GetDist(opos).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 torusCol(vec3 p, vec3 normal, float dif, float spRef, bool calc_flowers)\n{\n    vec3 ret;\n    vec2 tUV = GetTorusUV(p - torus1Pos(), torus1Size());\n    vec4 hive = Hive(tUV*hexCoordsMul+hexCoordsAdd+torusRotSpeed(), calc_flowers);\n    vec3 hive_col = hive.xyz;\n    ret = vec3(dif);\n    float occ = calcOcclusion(p, normal);\n    ret = dif*hive_col*occ;\n    ret *= ret*1.5;\n    ret += vec3(spRef) * HalCol();\n    //ret *= vec3(occ*occ*occ);\n    return ret;\n}\n\nvec3 sphereCol(vec3 p, float dif, float spRef)\n{\n    vec3 ret;\n    vec3 spherePosNew = spherePosNew(p, spherePos());\n    vec2 sUV = GetSphereUV(spherePosNew, sphereRad());\n    vec3 hive_col = Hive(sUV*vec2(6.,3.3) + 100., true).xyz;\n    ret = hive_col*dif;\n    ret *= ret*1.5;\n    return ret;\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance, // camera to point distance\n               float b) // density\n{\n    // only fog out distances above 10.\n    distance = smoothstep(10., 160., distance)*distance;\n    b = 0.05;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor  = FogCol();\n    return mix( rgb, fogColor, fogAmount );\n    return rgb;\n}\n\nvec3 GetCol(vec3 ro, vec3 rd, vec3 p, vec3 d) \n{\n    vec3 ret;\n    vec3 n = GetNormal(p);\n\tfloat dif = GetLight(p, n, LightPos(), 1., 0.7,  0); //***\n    float spRef = specularReflection(p, n, rd, LightPos(), 100., 0.7, 25.);\n\n    if(d.z == 1.) //torus painting\n    {        \n        ret = torusCol(p, n, dif, spRef, true);\n    }\n\n    // reflection for the object\n    if(d.z == 3.) // sphere col + reflection\n    {\n        rd = normalize(reflect(rd,n)); // reflect does: rd - 2.0 * dot(n, rd) * n\n        ro = p + rd*0.001;\n        d = RayMarch(ro, rd, int(float(MaxSteps) * 0.5));\n        p = ro + rd*d.x;\n        n = GetNormal(p);\n        float reflectDif = GetLight(p, n, LightPos(), 1., 0.7, 0);\n\n        if(d.z == 1.) // torus reflection painting\n        {        \n            ret = torusCol(p, n, reflectDif, 0., false);\n            ret = vec3(ret.z,ret.y,ret.x);\n        }\n        float sphere_rad = 9.5;\n        \n        float a = smoothstep(0.,30.,length(0.7*(p-spherePos())));\n        //a *= a;\n        a = clamp(a, 0., 1.);\n        ret -= HalCol()*0.9*vec3(a);\n    }\n\n    return ret;\n    \n}\nvec3 applyHal(vec3 colToHal)\n{\n    // main halation\n    float a = 1.-halDist*0.1;\n    a *= a * a;\n    a = clamp(a, 0., 1.);\n    //float inside_sphere = smoothstep(5.,0.,halDist);\n    colToHal += HalCol()*vec3(a);\n\n    // sinusoidal halation\n    float b = smoothstep(0.,1.,halDist*0.1);\n    b = smoothstep(-1.,2.,0.5 + 0.5*sin(halDist*2.8));//smoothstep(0.,1.,0.5 + 0.5*sin(a*75.));\n    b = clamp(b,0.,1.);\n    b *= smoothstep( -3.,1., 1.-halDist); // masking outside of the object\n    b *= smoothstep(0., 1., halDist); // masking inside of the object\n    b = clamp(b,0.,1.) *sound*sound*sound ;\n    colToHal += vec3(b);\n    \n    return colToHal;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    init = true;\n    stop = false;\n    halDist = 10000.;\n    \n    bass = GET_BASS;\n    mid = GET_MID;\n    treb = GET_TREB;\n    sound = GET_SOUND;\n    bass_cont = GET_BASS_CONT;\n    mid_cont = GET_MID_CONT;\n    treb_cont = GET_TREB_CONT;\n    sound_cont = GET_SOUND_CONT;\n    \n    mouse = iMouse;\n\n\n    vec3 ret = vec3(0);\n    \n    vec3 lookat = cameralookat();\n    float zoom = 0.5 + 0.15*sin(time*0.4);//0.5 + 0.3*sin(time*0.326);\n    vec3 ro = camerapos();\n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n    \n    vec3 d = RayMarch(ro,rd, MaxSteps);\n    vec3 p = ro + rd*d.x;\n    \n    ret = GetCol(ro, rd, p, d);\n    ret = applyFog(ret, d.x,0.05);\n    ret = applyHal(ret); // add halation around the object\n\n    fragColor = vec4(ret,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define BufA(x, y) texture(iChannel2, (vec2(x, y) + 0.5) / iResolution.xy)\n#define GET_BASS_PURE BufA(0.,0.).x\n#define GET_BASS BufA(0.,3.).x\n#define GET_BASS_CONT BufA(0.,2.).x\n#define GET_MID_PURE BufA(1.,0.).x\n#define GET_MID BufA(1.,3.).x\n#define GET_MID_CONT BufA(1.,2.).x\n#define GET_TREB_PURE BufA(2.,0.).x\n#define GET_TREB BufA(2.,3.).x\n#define GET_TREB_CONT BufA(2.,2.).x\n#define GET_SOUND_PURE (GET_BASS_PURE + GET_MID_PURE + GET_TREB_PURE)/3.\n#define GET_SOUND (GET_BASS + GET_MID + GET_TREB)/3.\n#define GET_SOUND_CONT (GET_BASS_CONT + GET_MID_CONT + GET_TREB_CONT)/1.5\n\n# define time iTime\n# define PI 3.141592654\n# define MaxSteps 200 // max steps for ray marching\n\nvec3 saturate(vec3 col)\n{\n    float gray = 0.2989 * col.x + 0.5870 * col.y + 0.1140 * col.z;\n    return vec3(gray);\n}\n\nvec3 RotX (vec3 p, float speed)\n{\n    return vec3(p.x, p.y*cos(speed) + p.z*-sin(speed),  p.y*sin(speed) + p.z*cos(speed));\n}\nvec3 RotY (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed) + p.z*sin(speed), p.y, p.x*-sin(speed) + p.z*cos(speed));\n}\nvec3 RotZ (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed)  + p.y*-sin(speed), p.x*sin(speed) + p.y*cos(speed), p.z);\n}\n\nvec2 GetTorusUV(vec3 p, vec2 torusSize)\n{\n    float x = atan(p.x, p.z);\n    float y = atan(length(p.xz)-torusSize.x, p.y);\n    return vec2(x,y);    \n}\n\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z)/(2.*PI) + 0.5;\n    float y = 0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r)\n{\n    float sphereDist = length(p)-r;\n    return sphereDist;\n}\n\n// by IQ\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/(k2.x*k2.x + k2.y*k2.y), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min((ca.x*ca.x + ca.y*ca.y),(cb.x*cb.x + cb.y*cb.y)) );\n}\n\n\n// Hexagon Dist by BigWings\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.732050808)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\n// Hexagon Coords by BigWings\n// ID's by Shane\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1., 1.732050808);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    \n    vec4 hC = floor(vec4(UV, UV - vec2(.5, 1))/r.xyxy) + vec4(.5, .5, 1, 1.5);\n    vec2 final_hC = dot(a, a) < dot(b,b) ? hC.xy : hC.zw;\n    //angle, dist from center, id_x, id_y\n    return vec4(x, y, final_hC);\n}\n\n// from https://timcoster.com/2020/02/13/raymarching-shader-pt3-smooth-blending-operators/\nfloat cappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat box( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nfloat smoothIntersectSDF(float distA, float distB, float k ) \n{\n    float h = clamp(0.5 - 0.5*(distA-distB)/k, 0., 1.);\n    return mix(distA, distB, h ) + k*h*(1.-h); \n}\nfloat smoothUnionSDF(float distA, float distB, float k ) {\n    float h = clamp(0.5 + 0.5*(distA-distB)/k, 0., 1.);\n    return mix(distA, distB, h) - k*h*(1.-h); \n}\nfloat smoothDifferenceSDF(float distA, float distB, float k) {\n    float h = clamp(0.5 - 0.5*(distB+distA)/k, 0., 1.);\n    return mix(distA, -distB, h ) + k*h*(1.-h); \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "# define time iTime\n\n// bass bands\n# define BASS_START 0\n# define BASS_END 14\n// middle bands\n# define MID_START 15\n# define MID_END 143\n// treble bands\n# define TREBLE_START 144\n# define TREBLE_END 511\n\n/*------------ Tuning ------------*/\n\n/*---- Smooth Sound values ----*/\n// lower value - less time for the smooth sound stay on top of the pure sound\n#define DECREASE_MIN 0.001\n// lower value - lower decrease time. should be above 1.\n#define DECREASE_MUL 5.\n\n/*---- Smooth Sound Continues values ----*/\n/* play with this to get smaller\\bigger \"acceleration\" for the circles\n   lower value - more deceleration\n   should be below 1 */\n#define DELTA_INCREASE 0.1\n\n/* should be a value between 0 and 1\n   play with this to get smaller\\bigger \"deceleration\" for the circles\n   lower value - less acceleration */\n#define DELTA_MUL 0.9\n\n/* bigger DELTA_COUNT_MAX value will take into account more of the \"acceleration\"\n   lower value will restrain the acceleration\n   in other words - saturate it */\n#define DELTA_COUNT_MAX 8.\n\nfloat getSound(int start, int end)\n{\n    float ret = 0.;\n    for(int i = start; i <= end; i++)\n    {\n        float samp = texelFetch(iChannel0, ivec2(i, 0), 0).x;\n        \n        samp = samp*samp + 0.5*samp;\n        if(samp > 0.8)\n            samp *= 0.8; // just to reduce the magnitude of the low frequencies\n        ret += samp;\n    }\n    \n    ret /= float(end - start + 1);\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float fpsInv = 60./iFrameRate;\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    vec2 operation = fragCoord - 0.5;\n\n    int start, end;\n    \n    float sound; // pure sound samples average\n    float prev_sound; // previous sound\n    float smooth_sound; // smooth sound\n    float prev_smooth_sound; // previous smooth sound\n    float decrease;\n    float smooth_sound_cont; // smooth sound continues\n    float prev_smooth_sound_cont; // previous smooth sound continues\n    float delta;\n    float delta_count;\n\n    // Initialize values\n    if(iFrame == 0)\n    {\n        sound = 0.;\n        prev_sound = 0.;\n        smooth_sound = 0.;\n        prev_smooth_sound = 0.;\n        decrease = 0.;\n        smooth_sound_cont = 0.;\n        prev_smooth_sound_cont = 0.;\n        delta = 0.;\n        delta_count = 0.;\n    }\n    \n    // fragCoord.x determines to calculate bass\\mid\\treble\n    if(operation.x == 0.) { start = BASS_START; end = BASS_END;}\n    if(operation.x == 1.) { start = MID_START; end = MID_END;}\n    if(operation.x == 2.) { start = TREBLE_START; end = TREBLE_END;}\n    \n    // prev sound\n    sound = getSound(start, end);\n    prev_sound = BufA(operation.x, 0.).x;\n    \n    // sound type 2\n    prev_smooth_sound_cont = BufA(operation.x, 2.).x;\n    prev_smooth_sound = BufA(operation.x, 3.).x;;\n    decrease = BufA(operation.x, 4.).x;\n    if(sound > prev_smooth_sound)\n    {\n        smooth_sound = sound;\n        decrease = DECREASE_MIN;\n    }\n    else\n    {\n        smooth_sound = prev_smooth_sound - decrease;\n        decrease *= 1. + iTimeDelta * DECREASE_MUL;\n    }\n    \n    // smooth_sound_cont - circles motion\n    delta = BufA(operation.x, 5.).x;\n    delta_count = BufA(operation.x, 6.).x;\n    if(sound > prev_sound)\n    {\n        // this statement is to prevent exreme acceleration, when bass\\middle\\treble goes higher very quickly.\n        // in other words - saturate it.\n        // bigger value - accept a bigger acceleration.\n        // to notice the difference, just comment the if statement and reset the shader,\n        // then look at the blue circle which represent the treble\n        if(delta_count < DELTA_COUNT_MAX)\n        {\n            //delta += DELTA_INCREASE;\n            delta += iTimeDelta * DELTA_INCREASE;\n            delta_count += 1.; // for each delta increase\n        }\n    }\n    else\n    {\n        delta_count = 0.; // reset the counting\n        delta *= DELTA_MUL;\n    }\n    smooth_sound_cont = smooth_sound*iTimeDelta + delta + prev_smooth_sound_cont; \n    \n    // to prevent the value to go extremely high, can be useful in some cases when we only care about the fraction value\n    //if(smooth_sound_cont > 50.)\n    //    smooth_sound_cont -= floor(smooth_sound_cont);\n    \n    // fragCoord.y determines to calculate sound\\smoth_sound\\etc..\n    if(operation.y == 0.)\n        fragColor = vec4(sound, 0.,0.,1.0);\n    if(operation.y == 2.)\n        fragColor = vec4(smooth_sound_cont, 0.,0.,1.0);\n    if(operation.y == 3.)\n        fragColor = vec4(smooth_sound, 0.,0.,1.0);\n    if(operation.y == 4.)\n        fragColor = vec4(decrease, 0.,0.,1.0);\n    if(operation.y == 5.)\n        fragColor = vec4(delta, 0.,0.,1.0);\n    if(operation.y == 6.)\n        fragColor = vec4(delta_count, 0.,0.,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 31800,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/giraffage/feels"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}