{
    "Shader": {
        "info": {
            "date": "1609789940",
            "description": "Failed attempt at a buddhabrot that I think is nice. This is zoomed into the coordinates -0.1575, 1.034",
            "flags": 32,
            "hasliked": 0,
            "id": "tsVBzK",
            "likes": 1,
            "name": "Mandelbrot Set Variation",
            "published": 3,
            "tags": [
                "mandelbrot",
                "variation"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 332
        },
        "renderpass": [
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// Constants (I mean you could change these, but there is no point.)\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\n//vec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\n//vec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n\n// Fractal Density\nint randexpiter(float iter){return int(round((rand()*iter)+iter))+1;}\nfloat iterchannel(vec2 coord, int iter){\n    bool march = false;\n    vec2 z2 = vec2((rand2()-0.5)*2.0);\n    //vec2 c = vec2(coord/32.0)+vec2(-0.1575,1.034);\n    vec2 c = vec2(coord*4.0);\n    vec2 testz2 = z2;\n    vec2 testc = c;\n    float col = 0.0;\n    for(int i=1; i<=iter; i++){\n        testz2 = vec2(testz2.x*testz2.x-testz2.y*testz2.y, 2.0*testz2.x*testz2.y);\n        testz2 += testc;\n        if(distance(testz2, vec2(0.0)) < 4.0){march = true;}}\n    vec2 newz2 = vec2(0.0);\n    if(march){\n        for(int i=1; i<=iter; i++){\n            z2 = vec2(z2.x*z2.x-z2.y*z2.y, 2.0*z2.x*z2.y);\n            z2 += c;\n            if(distance(z2, c) < 1e-3){col += 100.0;}}\n        return col;}\n}\n\nvec3 mandelbrot(vec2 coord, vec3 iter){\n    ivec3 iterations = ivec3(randexpiter(iter.x), randexpiter(iter.y), randexpiter(iter.z));\n    return vec3(iterchannel(coord, iterations.x), iterchannel(coord, iterations.y), iterchannel(coord, iterations.z))/vec3(iterations);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB: I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    INIT_RNG;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord+(nrand2(1.0, vec2(0.0))))-0.5*iResolution.xy)/iResolution.x;\n    //vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec3 iter = vec3(16, 8, 4);\n    vec3 col = mandelbrot(uv, iter);\n    fragColor += vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This is for Exporting a 32-Bit Floating Point OpenEXR Image using the Button on the Bottom of the Editor\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}