{
    "Shader": {
        "info": {
            "date": "1684278425",
            "description": "2d terrain map with rivers\nclick + drag to move view",
            "flags": 32,
            "hasliked": 0,
            "id": "dtGGzK",
            "likes": 5,
            "name": "biome generator",
            "published": 3,
            "tags": [
                "procedural",
                "2d"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 284
        },
        "renderpass": [
            {
                "code": "struct Biome {\n    float biomeSize;\n    vec3 biomeColor;\n};\n\nstruct BiomeType {\n    float heightMin;\n    float heightMax;\n    Biome[3] biomes;\n};\n\n//biomes\nconst Biome forest = Biome(1.0,vec3(0,0.5,0));\nconst Biome desert = Biome(0.5,vec3(1.0,0.9,0.5));\nconst Biome grassy_plain = Biome(1.0,vec3(0.2,1.0,0.1));\nconst Biome frozen_peak = Biome(1.0,vec3(1));\nconst Biome stone_peak = Biome(1.0,vec3(0.6));\nconst Biome mesa_peak = Biome(1.0,vec3(0.8,0.6,0.2));\nconst Biome normal_river = Biome(1.0,vec3(0,0,1));\nconst Biome sandy_beach = Biome(1.0,vec3(1.0,0.9,0.5));\nconst Biome stone_beach = Biome(0.5,vec3(0.4));\nconst Biome black_sand_beach = Biome(0.5,vec3(0.1));\nconst Biome normal_ocean = Biome(1.0,vec3(0.0,0.4,1));\nconst Biome bog = Biome(1.0,vec3(0.1,0.6,0.1));\nconst Biome mangrove = Biome(1.0,vec3(0.1,0.7,0.2));\nconst Biome delta = Biome(1.0,vec3(0.4,1.0,0.4));\nconst Biome high_taiga = Biome(1.0,vec3(0.2,0.5,0.3));\nconst Biome meadow = Biome(1.0,vec3(0.3,1.0,0.6));\nconst Biome rock_clearing = Biome(1.0,vec3(0.6,0.7,0.6));\n\n//biome types\nconst BiomeType river = BiomeType(-0.05,0.0,Biome[](normal_river,normal_river,normal_river));\nconst BiomeType mountain = BiomeType(0.7,5.0,Biome[](frozen_peak,stone_peak,mesa_peak));\nconst BiomeType plain = BiomeType(0.1,0.35,Biome[](forest,desert,grassy_plain));\nconst BiomeType taiga = BiomeType(0.35,0.7,Biome[](high_taiga,meadow,rock_clearing));\nconst BiomeType ocean = BiomeType(-2.0,-0.05,Biome[](normal_ocean,normal_ocean,normal_ocean));\nconst BiomeType swamp = BiomeType(0.01,0.1,Biome[](bog,mangrove,delta));\nconst BiomeType beach = BiomeType(0.0,0.01,Biome[](sandy_beach,stone_beach,black_sand_beach));\n\nconst BiomeType biomeTypes[] = BiomeType[](river,mountain,plain,swamp,taiga,ocean,beach);\n\n//noise functions\n\n//https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract((2.0*abs(p/3.14 - 2.0*floor(p/(2.0*3.14)) - 1.0) - 1.0)*43758.5453123);\n}\n\n//https://www.shadertoy.com/view/Msf3WH\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) )/2.0+0.5;\n}\n\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat voronoi2dedges(vec2 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            float d = distance(floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y)),uv);\n            if (d < d1) {\n                d2 = d1;\n                d1 = d;\n            } else if (d < d2){\n                d2 = d;\n            }\n        }\n    }\n    return abs(d1-d2);\n}\n\nvec2 vorronoiCellNoise(vec2 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    float c1 = 0.0;\n    float c2 = 0.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            vec2 r = (hash(floor(uv) + vec2(x,y)) + 1.0)/2.0;\n            float d = distance(floor(uv) + vec2(x,y) + r,uv);\n            if (d < d1) {\n                d2 = d1;\n                d1 = d;\n                c2 = c1;\n                c1 = r.x;\n            } else if (d < d2){\n                d2 = d;\n                c2 = r.x;\n            }\n        }\n    }\n    return vec2(c1,c2);\n}\n\n//////////////////////////\n// main\n//////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*20.0;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    uv -= draggedPos/iResolution.y*20.0;\n    \n    //calculate noises\n    float rivernoise = abs(noise(0.5 * uv + 3167.0)*0.5 + noise(0.05*uv - 1279.0)*2.0 - 1.25);\n    float mountainnoise = pow(noise(uv*0.1 + 3812.0),6.0)*4.0 + noise(uv*0.5 + rivernoise*0.5 + 7843.0)*0.5;\n    float oceannoise = noise(0.05*uv - 1279.0);\n    //generate heightmap\n    float heightmap = mix(rivernoise-0.05 - smoothstep(0.5,1.0,oceannoise), mountainnoise - smoothstep(0.2,1.0,oceannoise), rivernoise);\n    vec3 col = vec3(0);\n    //get biometype\n    for (int i = 0; i < biomeTypes.length(); i++){\n        if (biomeTypes[i].heightMin <= heightmap && heightmap < biomeTypes[i].heightMax){\n            //choose biome\n            float dist = min(abs(biomeTypes[i].heightMin - heightmap),abs(biomeTypes[i].heightMax - heightmap));\n            vec2 cell = vorronoiCellNoise(uv+dist+noise(uv));\n            //set color based on biome\n            col = biomeTypes[i].biomes[int(cell.x*3.0)].biomeColor;\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}