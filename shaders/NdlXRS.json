{
    "Shader": {
        "info": {
            "date": "1630068469",
            "description": "nothing much, just an sdf that returns a beer bottle i had laying around and tried modeling.\nplanning on making a scene in a bar later using this with random attributes.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdlXRS",
            "likes": 2,
            "name": "Beer Bottle Sdf",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf"
            ],
            "usePreview": 0,
            "username": "Pelegefen",
            "viewed": 333
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100.\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n\n\n\nfloat seed = 22155.;\nfloat GetDist(vec3 p) {\n\n    \n    float d  = 1.;\n    //Bar goes here lol\n    \n    //float sdBeerBottle(vec3 p, float width, float highet, float neckS, float lip, float labelS){\n    float t = floor(iTime*.8);\n    float h = hash11(t);\n        float h1 = hash11(t+214312.);\n    float h2 = hash11(floor(t+2142.));\n    float h3 = hash11(floor(t+12431.));\n    float h4 = hash11(floor(t+21334.));\n\n    d = sdBeerBottle(p,\n    \n    h * .2,\n    //^ float width,\n    \n    h1* .2,\n    //^ float highet,\n    \n    h2,\n    //^ float neckS,\n    \n    h3* .8,\n    //^ float lip,\n    \n    h4\n    //^ float labelSh, \n    \n    )\n    ;\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\t\n    float dv =0.;\n    float dO=dv;\n    \n    \n    for(float i=0.; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n \n        dO += dS;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    dv = dO;\n    return dv;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 2, -5);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,1.0,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n    float glow = 0.;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(.1,dif*.5,.1);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n\nfloat Union( float d1, float d2 ) { return min(d1,d2); }\n\nfloat Sub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat Intrs( float d1, float d2 ) { return max(d1,d2); }\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s) {\n\n\treturn length(p ) - s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdBeerBottle(vec3 p, float width, float highet, float neckS, float lip, float labelS){\n  float d  = 1.;\n  float body = sdRoundedCylinder(p, .35 + width,.8,0.7 - highet);\n    \n\n\n    float neck = sdRoundedCylinder(p - vec3(0,1.0 + highet,0),.25+ width ,.32,1.4+ highet);\n    neck += p.y * .1;\n    \n    float nb = body+neck;\n   \n    \n    \n    float mp = sdRoundedCylinder(p - vec3(0,2.35+ highet,0),.14+ width ,.04,0.08)*.8; //mouthpiece\n    float mph = sdRoundedCylinder(p - vec3(0,2.35+ highet,0),.12+ width,.1,2.38) * .8; //mouthpiece hole\n    mp -= abs(p.y - (2.4+ highet)) *.2 ;//shaping the mouthpiece\n    d = min(nb , min(neck,mp));\n    d = max(d,-p.y - .7);\n    \n    \n    \n    float elp = sdEllipsoid(p - vec3(0,-.7,0)  ,vec3(.5 + width,.1,.5 + width));\n    \n    float label = sdCappedCylinder(p- vec3(0,.3,0), 0.65- width,0.7- highet);\n    label = label * 1.4 + neck;\n    d = Sub (elp,d);\n    d = min(d,label);\n    \n    d = min(label * .5,d);\n    d = Sub(mph,d) ;\n\n    \n    d *= .9;\n    return d;\n   \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}