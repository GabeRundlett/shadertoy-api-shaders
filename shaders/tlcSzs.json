{
    "Shader": {
        "info": {
            "date": "1581685832",
            "description": "Idea for rendering light scattered through gas: rather than having a separate bounce loop, the marcher randomly changes directions (with a probability proportional to the gas density), to trace radiosity bounces between gasses of different densities.",
            "flags": 32,
            "hasliked": 0,
            "id": "tlcSzs",
            "likes": 168,
            "name": "Photoreal Clouds",
            "published": 3,
            "tags": [
                "scatter"
            ],
            "usePreview": 1,
            "username": "TekF",
            "viewed": 7334
        },
        "renderpass": [
            {
                "code": "// Tone Mapping by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\nconst float exposure = .75;\n\n// Exposure curve parameters\n//#define SHOW_CURVE 1\nconst vec3 gradient = vec3(1.4,1.5,1.6);\nconst vec3 whiteSoftness = vec3(.5);\nconst vec3 blackClip = vec3(.0,.1,.2);\nconst vec3 blackSoftness = vec3(.65,.5,.35);\n\nvec3 LinearToSRGB ( vec3 col )\n{\n    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );\n}\n\nvec3 SRGBToLinear ( vec3 col )\n{\n    return mix( col/12.92, pow((col+.055)/1.055,vec3(2.4)), step(.04045,col) );\n}\n\nvec3 HDRtoLDR( vec3 col )\n{\n    col *= exposure;\n\n#if (1)\n    // soft cut off near black to enhance contrast\n   \t// this is good for correcting for atmospheric fog\n\tcol = max(col-blackClip,0.); \n    col = sqrt(col*col+blackSoftness*blackSoftness)-blackSoftness;\n\n    col *= gradient;\n    \n    // soft clamp to white (oh this is so good)\n    vec3 w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n#else\n    // skip tone mapping\n\tcol*=.4;\n#endif\n    \n\treturn LinearToSRGB(col);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    fragCoord /= vec2(RESOLUTION_REDUCTION);\n    // smooth out the transition between pixels\n//    fragCoord -= 1.*sin(fragCoord*6.283185)/6.283185;\n    fragColour = SampleTextureCatmullRom4Samples(iChannel0,fragCoord/iResolution.xy,iResolution.xy);\n#else    \n    ivec2 ifragCoord = ivec2(fragCoord);\n    fragColour = texelFetch(iChannel0,ifragCoord,0);\n\n#ifdef MOSAIC_PREVIEW\n    const float targetCount = 1536.;\n    if ( fragColour.a < targetCount )\n    {\n        // blend a square big enough to hit targetCount\n        int kernelSize = int(ceil(sqrt(targetCount/fragColour.a)));\n        const int maxKernel = 16;\n        kernelSize = min(kernelSize,maxKernel);\n        ivec2 blockuv = (ifragCoord/kernelSize)*kernelSize;\n        for ( int i=0; i < maxKernel; i++ )\n        {\n            if ( i > kernelSize ) break;\n            for ( int j=0; j < maxKernel; j++ )\n            {\n                if ( j > kernelSize ) break;\n                fragColour += texelFetch(iChannel0,blockuv+ivec2(i,j),0);\n            }\n        }\n    }\n#endif\n#endif\n    fragColour /= fragColour.a;\n \n    fragColour.rgb = HDRtoLDR( fragColour.rgb );\n    \n#ifdef SHOW_CURVE\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 f = HDRtoLDR(vec3( uv.x*3. ));\n    f = SRGBToLinear(f); // show curve without gamma correction (comment this out to see actual HDR->colour value mapping)\n    f -= (uv.y*1.04-.02);\n    fragColour.rgb = SRGBToLinear(fragColour.rgb);\n    fragColour.rgb = mix( vec3(1), fragColour.rgb, smoothstep( 0., 1.4, abs(f)/max(dFdx(f),vec3(1)/iResolution.y) ) );\n    fragColour.rgb = LinearToSRGB(fragColour.rgb);\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Photoreal Clouds by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n// scene parameters\nconst float cloudiness = .6;\n\nconst vec3 groundColour = vec3(.1,.15,.05); // grassy\n//const vec3 groundColour = vec3(.1); // dark grey (looks a bit brown because of tone mapping)\n//const vec3 groundColour = vec3(1); // snow\n\nconst vec3 lightDirection = normalize(vec3(1,2,3));\nconst vec3 lightColour = vec3(3);\n\n\n// control the ray marcher\nconst float minStepLength = .15;\nfloat stepLength = minStepLength;\nconst float shadowDrawDistance = 8.;\n\nconst float directLightProportion = 1./6.; // proportion of scattered rays used to sample direct light (balance graininess of god rays vs graininess of radiosity)\n//^ this shouldn't be affecting radiosity brightness, but it is! Bah!\n\nstruct ScatterData\n{\n\tfloat scatter; // proportion of rays scattered per metre - must be less than 1.0\n\tvec3 tint; // what proportion of RGB light remains after 1m - must be more than 0.0 - applies independent of scatter, so if this is 1,1,1 we still have reduction in visibility caused by scatter\n    vec3 emission; // amount of light added per 1m - should work for values > 1 but I'm not sure\n\tvec3 scatterTint; // particles can have one colour when light bounces off them and a different colour when light is absorbed by them - this can be [0,1]\n    float eccentricity; // bias the direction of scattering toward/away from (+ve/-ve) incident light direction\n};\n\nScatterData Mix( ScatterData a, ScatterData b, float c )\n{\n\t// this isn't perfect - interpolated media can have values that look different either of the two being blended\n    // e.g. this can cause a halo around very dense objects when they interpolate to the colour of the sky\n    // to reduce this effect, premultiply by scatter, to prioritise the parameters of the denser media\n    ScatterData m = \n        ScatterData(\n            mix( a.scatter, b.scatter, c ),\n            mix( a.tint*a.scatter, b.tint*b.scatter, c ),\n            mix( a.emission*a.scatter, b.emission*b.scatter, c ),\n            mix( a.scatterTint*a.scatter, b.scatterTint*b.scatter, c ),\n            mix( a.eccentricity*a.scatter, b.eccentricity*b.scatter, c )\n        );\n    return\n        ScatterData(\n            m.scatter,\n            m.tint/m.scatter,\n            m.emission/m.scatter,\n            m.scatterTint/m.scatter,\n            m.eccentricity/m.scatter\n        );\n}\n\n\n// signed distance field (SDF) for a torus\n// returned value is distance of pos from the surface (negative if inside)\nfloat Torus( vec3 position, vec3 axis, float majorRadius, float minorRadius )\n{\n    axis = normalize(axis);\n    float perp = dot(axis,position);\n    position -= perp*axis;\n    return length( vec2( perp, length(position) - majorRadius ) ) - minorRadius;\n}\n\n    \nScatterData SampleMedia( vec3 pos )\n{\n    ScatterData air = ScatterData( .03, vec3(1,.996,.99), vec3(0), vec3(.6,.8,1), .3 );\n\n    // a curve through 0, steeper on the underside of clouds so they have flat bottoms\n\tfloat cloudSDF = pos.y*pos.y/mix(1.,12.,step(0.,pos.y));\n    \n\t// columns of cloud (shadow draw distance is too short to catch shadows from these, but they look cool despite this)\n\t//cloudSDF = min(cloudSDF,(length((fract((pos.xz-vec2(0,-2))/12.+.5)-.5)*12.)-3.)*.5);\n    \n    // add layers of noise to the clouds\n    vec3 cloudNoisePos = pos;\n#ifdef ANIMATE\n    cloudNoisePos += iTime*vec3(0,.01,.06);\n#endif\n    cloudSDF += 1.5*Noise(cloudNoisePos/3.+9.); // lowest frequency defines the boundaries of the clouds\n    cloudSDF += .7*(Noise(cloudNoisePos*2.)-.5) + .25*(Noise(cloudNoisePos*6.)-.5) + .16*(Noise(cloudNoisePos*18.)-.5); // higher freqs make the edges lumpy\n    cloudSDF -= cloudiness; // offset the SDF to give more/less cloud coverage\n    \n    ScatterData cloud = ScatterData( .99, vec3(1), vec3(0), vec3(1), .3 /* directionality of scatter - silver lining vs reflected light */ );\n\n    // ground is a very dense gas\n\tfloat groundSDF = pos.y+4.+1.*(Noise(pos/3.+1.)-.5);\n    ScatterData ground = ScatterData( 1., vec3(1), vec3(0), groundColour, .0 );\n    \n    // \"solid\" test objects\n    float objSDF = length(pos-vec3(0,-2,0)) - 2.;\n//    objSDF = min(objSDF,length(pos-vec3(0,2,-3)) - 2.); // 2nd ball in the sky\n    objSDF = min( objSDF, Torus(pos-vec3(4,1.5,-9),vec3(.1,1,.2),12.,1.) ); // giant torus in the sky\n//    objSDF += (Noise(pos*1.4)-.5)*.2; // bumpy surface\n//    objSDF += sin(Noise(pos*1.3)*20.)*.1; // ripply surface\n//    objSDF = max(objSDF,(Noise(pos*3.5)-.65)*10.); // random holes/dents\n//    objSDF *= exp2(-8.*smoothstep(.3,.7,Noise(pos*.4))); // soften the edge of the object in random places\n\n    ScatterData obj = ScatterData( 1., vec3(1), vec3(0), vec3(.4,.19,.13), .0 ); // brown\n\n    return\n        Mix(Mix(Mix(\n            air,\n            cloud,\n            smoothstep( 1., -1., cloudSDF/.1 ) ),\n            obj,\n            smoothstep( 1., -1., objSDF/.01 ) ),\n            ground,\n            smoothstep( 1., -1., groundSDF/.01 )\n        );\n}\n\nconst float tau = 6.283185;\n\nvec3 SphereMap( vec2 uv )\n{\n    // uv is in the range [0,1)\n    // map this range onto a unit sphere, with a uniform distribution of points\n    \n    // use the fact that the surface area of a slice of a sphere is the same\n    // as the surface area of a cylinder with the height of the slice and the\n    // radius of the sphere\n    \n    // wrap the 2D space around a cylinder\n    float h = uv.y*2.-1.; // height up cylinder\n    float a = uv.x*tau; // angle around the circle\n    \n    // position on the circular slice of the cylinder at this height\n    vec2 v = vec2(sin(a),cos(a));\n    \n    // project onto the corresponding slice of the sphere\n    // by multiplying by width of sphere at this height\n    v = v * sqrt(1.-h*h);\n    \n    return vec3(v,h);\n}\n\n/* obsfuscated version:\nvec3 SphereMap( vec2 uv )\n{\n    return vec3( sin((uv.xx+vec2(0,.25))*6.283185)*2.*sqrt(uv.y*(1.-uv.y)), uv.y*2.-1. );\n}*/\n\n                 \nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    ivec2 pixelIndex = ivec2(fragCoord);\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    fragCoord *= vec2(RESOLUTION_REDUCTION);\n    if ( fragCoord.x > iResolution.x || fragCoord.y > iResolution.y )\n    {\n        fragColour = vec4(.5,.5,.5,1);\n        return;\n    }\n#endif\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // slightly ugly hack: remap the range of mouse movements to give better camera control without re-adjusting all the magic numbers below.\n    mouse.y = pow(mouse.y,.5)*.6+.1;\n    mouse.x = mouse.x*1.3;\n    \n    if ( iMouse.x < 1. && iMouse.y < 1. )\n        mouse = vec2(.845,.608);\n    \n    vec2 camAngle = (mouse-.5)*6.283185*vec2(1.,-.4999);\n\n#ifdef ANIMATE\n    camAngle.x+=iTime*.05;\n#endif\n    \n    float mouseH = .608 - mouse.y; // make high camera positions frame the whole torus\n    \n    vec3 camTarget = vec3(-1.5,-1.,0) + vec3(5.5,2.5,-9)*1.6*mouseH;\n    float camDistance = 10.;\n    float camZoom = 1.1;\n\n\tcamDistance *= exp2(3.*mouseH); // move camera in/out\n    \n    vec3 camPos = camDistance*vec3(-vec2(sin(camAngle.x),cos(camAngle.x))*cos(camAngle.y),sin(camAngle.y)).xzy;\n    vec3 camK = normalize( camTarget-camPos );\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n\n    const int maxPasses = 100;\n    \n    int sampleCountMul = sampleCountMultiplier;\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    sampleCountMul *= (RESOLUTION_REDUCTION*RESOLUTION_REDUCTION);\n    sampleCountMul = (sampleCountMul*7)/8; // not sure why but without this res reduction always slows it down\n#endif        \n\n    // there's a bug here where it's making things translucent if it's > 1!?\n    int numPasses = 1;//max(1,sampleCountMul*(320*180)/int(iResolution.x*iResolution.y));\n\n    fragColour = vec4(0);\n    for ( int pass=0; pass < maxPasses; pass++ )\n    {\n        if ( pass >= numPasses ) break;\n\n        SeedRand( iFrame*numPasses+pass, fragCoord );\n\n        vec2 jitter = vec2(rand2())-.5;\n        vec3 ray = normalize( vec3( (fragCoord+jitter-iResolution.xy*.5)/iResolution.y, camZoom ) );\n\n        ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n\n        // First, march through space, allowing the ray to be deflected randomly by scatter\n        vec3 pos = camPos;\n        pos += ray * rand() * stepLength; // randomize initial step to hide aliasing errors (doesn't fix them, but hides them really well)\n        float lastH = stepLength;\n        vec3 lastTint = SampleMedia(pos).tint;\n        vec3 tint = vec3(1);\n        vec3 emission = vec3(0);\n\t\tbool lightRay = false;\n\t    int bounceCount = 0;\n        float t = 0.;\n        for ( int i=0; i < 150; i++ )\n        {\n            //if ( max(max(tint.r,tint.g),tint.b) <= .01 ) break; // early out when rays have almost no effect - this doesn't seem to improve performance\n            \n            // step through media [step size modified by probability]\n            ScatterData scatter = SampleMedia(pos);\n\n            float h = stepLength*(1. + .9*(rand()*2.-1.)); // adjust steps randomly to hide aliasing errors\n\n            // experimenting with variable step size\n            // at the moment it just increases with distance, so rays can travel further but become less accurate\n\t\t\t// I could do this adaptively, but that's more complicated\n\t\t\tstepLength *= 1.01;\n\n            // accumulate average tint\n            tint *= pow(mix(scatter.tint,lastTint,.5),vec3(lastH));\n\n            float pointH = mix(lastH,h,.5); // length of step represented by this scatter sample        \n\n            // accumulate emission with current tint applied        \n            emission += tint*(scatter.emission * pointH);  // pretty sure emission should be multiplied not pow'd, so it's additive not exponential\n\n            if ( pow(1.-scatter.scatter, pointH) < rand() )// [modified by average of last/next step size]\n            {\n                if ( rand() < directLightProportion ) // proportion of rays which become direct light rays\n                {\n                \t// direct light\n                    // apply the scatter tint and point the ray at the light\n\n                    // correct brightness by proportion of rays not scattered this way\n                    tint /= directLightProportion;\n\t                tint *= scatter.scatterTint;\n\n                    // apply a curve for eccentricity\n                    // this uses the derivative of the curve used for the random scatter\n                    // we want to say \"how much light is scattered in this direction\" rather than \"what direction should this light be scattered in\"\n                    float cos0 = dot(ray,lightDirection);\n                    float ae = abs(scatter.eccentricity);\n                    \n                    float se = (scatter.eccentricity<0.)?-1.:1.; // sign(eccentricity) but without 0.0\n\t\t\t\t\t//float cos1 = (pow(cos0*se*.5+.5,1.-ae)*2.-1.)*se;\n\t\t\t\t\t// dcos1/dcos0 (computed by wolframalpha.con)\n                    float dcos1dcos0 = (1. - ae)*pow( max(.00000001,0.5 - se*0.5*cos0), -ae );\n\n                    // hack to reduce speckly artefacts caused by lighting amplified by multiple bounces\n                    // these speckles are technically correct, but they occur as a result of highly unlikely combinations of bounces\n                    // so it will take a very long time for them to average out\n\t\t\t\t\tif ( bounceCount > 0 ) dcos1dcos0 = clamp(dcos1dcos0,0.,10.);\n                    \n                    tint *= dcos1dcos0;\n\n                    // break out of this loop so we can do a separate shadow-tracing loop which doesn't scatter\n\t\t            ray = lightDirection;\n                    lightRay = true;\n                    break;\n                }\n                else\n                {\n                    vec3 newRay = SphereMap( vec2(rand2()) );\n\n                    // eccentricity - push & scale the sphere along the view ray to bias rays in same/opposite direction\n                    // amount of push such that at -1 or 1 the near side of the spheroid hits 0 and the far side hits infinity\n                    float cos0 = dot(newRay,ray);\n\n                    // Apply a curve to the distribution of rays.\n                    // This isn't ideal, it tends to create a sharp bright spot around the light rather than a softer blob\n                    // but it has the advantage that it reduces to 1-dimension which makes it easier to compute the derivative, \n                    // which is needed for direct light.\n                    // We can do this in 1D because a slice through the surface of a sphere has the same area for a given\n                    // thickness of slice, regardless of where the slice is positioned. (napkin ring problem)\n                    float ae = 1.-abs(scatter.eccentricity);\n                    float se = (scatter.eccentricity<0.)?-1.:1.;\n                    float cos1 = (pow(cos0*se*.5+.5,ae*ae)*2.-1.)*se;\n                    newRay = normalize(newRay - cos0*ray);\n                    newRay = ray*cos1 + newRay*sqrt(1.-cos1*cos1);\n                    ray = newRay;\n\n                    // correct brightness by proportion of rays not scattered this way\n                    // to conserve energy (this seems to have a bug, as the image changes significantly when I change directLightProportion)\n                    tint /= 1.-directLightProportion;\n\n                    // break energy conservation to prevent speckles caused by rare multiply scattered rays\n                    // technically they are correct, but they're so rare the speckles they cause are unlikely\n                    // to ever be corrected.\n                    // reduce this amount for faster convergence but less radiosity\n\t\t\t\t\ttint = clamp(tint,0.,5.);\n                    \n                    tint *= scatter.scatterTint;\n                }\n                \n                bounceCount++;\n            }\n\n            pos += ray*h;\n            t += h;\n            lastH = h;\n            lastTint = scatter.tint;\n        }\n                \n        \n        if ( lightRay )\n        {\n            // haven't balanced this for variable step size, so use a const step\n\t\t\tconst float shadowStepLength = minStepLength*1.;\n            \n            vec3 lastAbsorption;\n            float shadowT = 0.;\n            for ( int i=0; i < int(shadowDrawDistance/shadowStepLength); i++ )\n            {\n                // step through media [step size modified by probability]\n                ScatterData scatter = SampleMedia(pos);\n\n                float h = shadowStepLength; // todo: port the random stuff here too, and change the loop the same way\n                \n                // accumulate average tint\n               \t// don't scatter, just count the proportion of scattered rays as a darkening tint\n                vec3 absorption = scatter.tint*(1.-scatter.scatter);\n                if ( i > 0 )\n                {\n                \ttint *= pow(mix(absorption,lastAbsorption,.5),vec3(lastH));\n                }\n\n                pos += ray*h;\n                shadowT += h;\n                lastH = h;\n                lastAbsorption = absorption;\n            }\n            \n            emission += lightColour*tint;\n        }\n        fragColour.rgb += emission;\n\n        fragColour.a += 1.;\n    }\n    \n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    // precompute checkerboard of negative/positive values\n    // required by SampleTextureCatmullRom4Samples\n    fragColour = (pixelIndex.x&1)==(pixelIndex.y&1) ? fragColour : -fragColour;\n#endif\n    \n    if ( iFrame > 0 && iMouse.z <= 0. )\n    {\n        fragColour += texelFetch(iChannel0,pixelIndex,0)\n#ifdef ANIMATE\n            *.97\n#endif\n            ;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// quality adjustments - to improve fps\nconst int sampleCountMultiplier = 11; // increase this until fps drops\n#define MOSAIC_PREVIEW 1\n//#define RESOLUTION_REDUCTION 2\n\n//#define ANIMATE 1\n\n\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\n// sequential rand functions - return a different value each time\nuint seed = 1u;\n\nvoid SeedRand( int frame, vec2 fragCoord )\n{\n    seed = coord3(uvec3(frame,fragCoord));\n}\nfloat rand() { return hash1(coord1(seed++)); }\nvec2 rand2() { return hash2(coord1(seed++)); }\nvec3 rand3() { return hash3(coord1(seed++)); }\nvec4 rand4() { return hash4(coord1(seed++)); }\n\n\n// continuous noise\n// cheaper and uglier than perlin\nfloat Noise( vec3 pos )\n{\n    uvec3 p = uvec3(ivec3(floor(pos))+0x8000000);\n    vec3 f = smoothstep(.0,1.,fract(pos));\n    uvec2 d = uvec2(0,1);\n    \n    return\n        mix(\n        \tmix(\n                mix( hash1(coord3(p+d.xxx)), hash1(coord3(p+d.yxx)), f.x ),\n                mix( hash1(coord3(p+d.xyx)), hash1(coord3(p+d.yyx)), f.x ),\n                f.y\n            ),\n        \tmix(\n                mix( hash1(coord3(p+d.xxy)), hash1(coord3(p+d.yxy)), f.x ),\n                mix( hash1(coord3(p+d.xyy)), hash1(coord3(p+d.yyy)), f.x ),\n                f.y\n            ),\n            f.z\n        );\n}\n\n\n// catmull-rom texture sampler, from https://www.shadertoy.com/view/4tyGDD by Giliam de Carpentier\nvec4 SampleTextureBilinearlyAndUnpack(sampler2D tex, vec2 uv)\n{\n    vec4 sample_color = texture(tex, uv, 0.0);\n#ifdef PACK_SIGNED_TO_UNSIGNED\n    sample_color = 2.0 * sample_color - 1.0;\n#endif // PACK_SIGNED_TO_UNSIGNED\n    return sample_color;\n}\n \nvec4 SampleTextureCatmullRom4Samples(sampler2D tex, vec2 uv, vec2 texSize)\n{\n    // Based on the standard Catmull-Rom spline: w1*C1+w2*C2+w3*C3+w4*C4, where\n    // w1 = ((-0.5*f + 1.0)*f - 0.5)*f, w2 = (1.5*f - 2.5)*f*f + 1.0,\n    // w3 = ((-1.5*f + 2.0)*f + 0.5)*f and w4 = (0.5*f - 0.5)*f*f with f as the\n    // normalized interpolation position between C2 (at f=0) and C3 (at f=1).\n \n    // half_f is a sort of sub-pixelquad fraction, -1 <= half_f < 1.\n    vec2 half_f     = 2.0 * fract(0.5 * uv * texSize - 0.25) - 1.0;\n \n    // f is the regular sub-pixel fraction, 0 <= f < 1. This is equivalent to\n    // fract(uv * texSize - 0.5), but based on half_f to prevent rounding issues.\n    vec2 f          = fract(half_f);\n \n    vec2 s1         = ( 0.5 * f - 0.5) * f;            // = w1 / (1 - f)\n    vec2 s12        = (-2.0 * f + 1.5) * f + 1.0;      // = (w2 - w1) / (1 - f)\n    vec2 s34        = ( 2.0 * f - 2.5) * f - 0.5;      // = (w4 - w3) / f\n \n    // positions is equivalent to: (floor(uv * texSize - 0.5).xyxy + 0.5 +\n    // vec4(-1.0 + w2 / (w2 - w1), 1.0 + w4 / (w4 - w3))) / texSize.xyxy.\n    vec4 positions  = vec4((-f * s12 + s1      ) / (texSize * s12) + uv,\n                           (-f * s34 + s1 + s34) / (texSize * s34) + uv);\n \n    // Determine if the output needs to be sign-flipped. Equivalent to .x*.y of\n    // (1.0 - 2.0 * floor(t - 2.0 * floor(0.5 * t))), where t is uv * texSize - 0.5.\n    float sign_flip = half_f.x * half_f.y > 0.0 ? 1.0 : -1.0;\n \n    vec4 w          = vec4(-f * s12 + s12, s34 * f); // = (w2 - w1, w4 - w3)\n    vec4 weights    = vec4(w.xz * (w.y * sign_flip), w.xz * (w.w * sign_flip));\n \n    return SampleTextureBilinearlyAndUnpack(tex, positions.xy) * weights.x +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zy) * weights.y +\n           SampleTextureBilinearlyAndUnpack(tex, positions.xw) * weights.z +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zw) * weights.w;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}