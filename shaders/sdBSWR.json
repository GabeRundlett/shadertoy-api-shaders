{
    "Shader": {
        "info": {
            "date": "1619986806",
            "description": "Tangled?\n[url=https://mathworld.wolfram.com/Tanglecube.html]https://mathworld.wolfram.com/Tanglecube.html[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "sdBSWR",
            "likes": 13,
            "name": "Tanglesquare and Tanglecube",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "tanglesquare",
                "tanglecube"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 201
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float unit = 2.0 / iResolution.y;\n\n    // Offset to left side and shrink to fit\n    uv.x += 0.4;\n    uv *= 5.0;\n\n    float d = dot(16.0 * uv * uv, uv * uv) - dot(20.0 * uv, uv) + 5.0; // -6 to produce similar visual results\n    vec2 grad = 64.0 * uv * uv * uv - 40.0 * uv;\n    d /= max(length(grad), 20.0); // Distance estimate\n    d *= 0.2; // Undo shrinking in the distance field\n\n    fragColor.rgb += 0.125 + 0.125 * sin(d * 1000.0); // Isolines\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.5 + 0.01 * grad, 0.0), smoothstep(unit, 0.0, d)); // Fill\n\n    // Unshrink to fit and offset to right side\n    uv /= 5.0;\n    uv.x -= 0.8;\n\n    // Ray\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Double rotation\n    float c = cos(iTime), s = sin(iTime);\n    mat3 mat = mat3(  c, -s * s, -s * c,\n                    0.0,      c,     -s,\n                      s,  s * c,  c * c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        p *= mat;\n\n        vec3 grad = 64.0 * p * p * p - 40.0 * p; // Gradient\n        float g = length(grad);\n\n        float d = dot(16.0 * p * p, p * p) - dot(20.0 * p, p) + 11.0;\n        d /= max(g, 20.0); // This turns raymarching into Newton-Raphson, hacked to prevent too large of steps\n\n        if (abs(d) < 0.001) {\n            vec3 nor = grad / g * transpose(mat);\n            vec3 light = -rd;\n\n            float diff = abs(dot(nor, light));\n            float checkers = 0.5 + 0.5 * mod(dot(floor(p * 5.0), vec3(1.0)), 2.0);\n            fragColor = mix(vec4(checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, nor)), 0.25);\n            fragColor.rgb *= diff;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += d;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}