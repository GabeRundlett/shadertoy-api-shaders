{
    "Shader": {
        "info": {
            "date": "1532687915",
            "description": "mat3(1,1,-1,1) is a scaling eight-rotation, useful to mirror something along a diagonal.\nbut likely not too usefu, tue to the sqrt(.5) scaling that comes with this matrix, save to assume some precision loss?\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XltcD4",
            "likes": 1,
            "name": "arrow heart mirror",
            "published": 3,
            "tags": [
                "heart",
                "mirror",
                "arrow"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "\n//https://www.shadertoy.com/view/XdtBD7\n\n\n//library of often used functions: //ounting,index starts at 0!\n#define pi acos(-1.)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u5(a)(a*.5+.5)\n#define u2(a)(a*2.-1.)\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n//max of vector\n#define miv(a)-mav(-a)\n//triangle wave //euclidean grid\n#define tri(a)abs(u2(fract(a)))\n#define grid(a)mav(tri(a))\n//clamp().special clamp.general;//clamp().pseudo.inverse\n#define sat(a)clamp(a,0.,1.)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//stretch;mirror_centric,most common,atomic\n#define stretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretchMinus;positive values do not change;stretchPlus;negatives do not change.\n#define stretchM(u,m)stretch((u*2.+m),m)*.5\n#define stretchP(u,m)stretch((u*2.-m),m)*.5\n//return squared length of a()\n#define dd(a)dot(a,a)\nv1 perp(v1 a){return v1(-a.y,a.x);}//perpendicular ==90deg rotation\nv0 dotp(v1 a,v1 b){return dot(perp(a),b);}//return [perpendicular dot product],can be useful for distance to line with niormalizedd input\nv0 dLine(v1 p,v1 a,v1 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}//return squared distance of [u] from segment,from [a] to [b]\nvec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n//not sure if aXorB()is correct,but looks useful. //https://en.wikipedia.org/wiki/Alpha_compositing\nvec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n//---trigonometry,rotations and(distance to)Quadratic functions.\n//(distance to quadratic is a cubic with less than 2 intersections==roots)\n#define cs(a)vec2(cos(a),sin(a))\n//mirror p at half rotated axis==cheap SINGLE 2d rotation.\n#define rs(r)mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//golden ratios are the best factors for hashes because;phi.xy-1.=1/phi.xy\n\nconst float PI=3.14159,\n   size=.2,\n   period=1.5;\nvec2 R;\n\n#define rot(a)   mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat easeInOut(float t){ return t<.5 ? 2.*t*t : -1.+(4.-2.*t)*t;}\nfloat angle(float t) { return(floor(t)+ easeInOut(fract(t)))*PI/2.;}\n\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;float k=dot(m,u.yx);return k;}\n\nfloat segment(vec2 p,vec2 a,vec2 b){\n vec2 ab=b-a,ap=p-a;\n return length(ap-ab*clamp(dot(ab,ap)/dot(ab,ab),0.0,1.0));\n}\n\nfloat one(vec2 u){return -dot(u-.5,vec2(sqrt(2.)))*.5;}\nfloat two(vec2 u){return u.y-.5;}//neck of afrow\nfloat three(vec2 u){return .25-u.x;}//rectangle stem of arrow\nfloat four(vec2 u){return u.y;}//gradient for central base of arrow\n\n\n//rounded box,simple branch m interpolates from euclidean to taxicap.\n//turned into an owl-face-gradient\nfloat o3_(vec2 p,float m){p.x=abs(p.x);p.y-=1.\n ;float n=mav(p)\n //;return smoothstep(0.,m,n+m-abs(p.x-p.y))*(length(p-m)+m-n)+n//smoothstep contstants made an owl\n ;return step(miv(p),m)*(length(p-m)+m-n)+n\n //;return step(m,n-abs(p.x-p.y))*(length(p-m)+m-n)+n//rounded box,not owl\n ;return mix(n,length(p-m)+m,step(m,miv(p)));//branchless //rounded box,not owl\n //if(-mav(-p)>m)return length(p-m)+m;else return mav(p)\n ;}\n\nfloat raybox(vec2 u){//taxicap distance to ray\n ;u.x=abs(u.x)\n ;return mav(u)\n;}\n\n//v0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}v0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\n//sphere,mStretch()ed to a \"rounded box\" by [b]\nfloat mac(float a){return max(a,0.);}vec2 mac(vec2 a){return max(a,vec2(0.));}//component wise bound,for applolonean2Euclidean \nvec3 mac(vec3 a){return max(a,vec3(0.));}vec4 mac(vec4 a){return max(a,vec4(0.));}//... via mStretch incooperation\n#define mic(a)-mac(-a)\nvec2 boxB(vec2 u,vec2 b){return abs(u)-b;}\nvec2 boxRayB(vec2 u,vec2 b){u.x=abs(u.x);return u-b;}\n//RoundMstretch takes a [box*B output] to return a [rounded box]. Seems to be the simplest incooperation of \"mStretch()\"\n//intuitively can be used to turn the taxicap upper bound into a(mnuch more)euclidean distance field.\n#define RoundMstretch(u)(length(mac(u))+mav(mic(u)))\n#define fBox(u,b)mav(boxB(u,b))\n#define fRay(u,b)mav(boxRayB(u,b))\n//[r] is appolonean rounded borders,[f] is a faster upper taxicap-bound\n#define rBox(u,b)RoundMstretch(boxB(u,b))\n#define rRay(u,b)RoundMstretch(boxRayB(u,b))\n//sawcos is a VERY good gradient \n#define fsaa 5./iResolution.y\nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c);[mix(,,constant)] seperates inside drom outside \"brightness\" [/abs(c)] diminishes\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.75)/(abs(c)+.5)\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}//smooth and fast\n\nvec4 Arr(vec2 u\n){//u=fract(u)\n ;float x=abs(u.x-.5),y=u.y,p=1./R.y/size\n ;vec4 r=vec4(1)\n ;u*=mat2(1,1,-1,1)//eight rotation(also scales by sqrt(2))\n ;u.y=abs(u.y)//of course this simple mirror adds a cusp-laplachian-discontinuity.\n ;u=mat2(1,1,-1,1)*u//eight rotation(also scales by 1/sqrt(2))\n ;u-=1.//offset to show stuff\n ;r.y=rBox(u.yx,iMouse.xy/iResolution.xy)\n ;r.y-=.5;//gradient offset for a \"heart outline\"\n //;float f=fract(r.y*4.);\n ;r.xyz=sawCos3(r.xyz*2.,.9)\n ;return r;}\n\n\nfloat arrow(vec2 u){\n u=fract(u);\n float x=abs(u.x-.5),y=u.y,p=1./R.y/size;\n return  smoothstep(-p,p,y<.5 || x<.25 ? y : y-.5) // bases\n   *smoothstep(p,-p,y<.5 ? x-.25 : x-1.+y);// sides\n}\n\nfloat drawArrow(vec2 coords,vec2 offset,float a){\n\n coords=rot(a)*(coords);\n vec2 origin=vec2(.5,.5);\n coords=(coords-origin)*rot(a)+ origin;\n coords=fract(coords);\n coords=rot(a)*(coords-origin) + origin;\n //coords*=rot(a);\n float r=arrow(coords-offset);\n return r;\n}\n\nfloat cell(vec2 U,float a){\n float v=0.;\n v+=drawArrow(U,vec2(0),a);\n //for(int i=0;i<6;i++)\n // v+=drawArrow(U,vec2(i%3-1,i/3),a);\n return v;\n}\n\nvoid mainImage(out vec4 O,vec2 U\n){R=iResolution.xy;\n ;U=3.*(U-.5*vec2(R.x,0))/R.y;\n ;float t=iTime/period,a=angle(t);\n ;int i=int(t)% 4;\n //;if(i%2==1)U+=.5;if(i%2==1)U=-U\n //;O=vec4(cell(U,a))\n ;O=vec4(Arr(U))\n //;O=vec4(cell(U,a))\n //;if(i%2==1)O.xyz=1.-O.xyz\n;}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}