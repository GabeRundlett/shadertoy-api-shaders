{
    "Shader": {
        "info": {
            "date": "1552330967",
            "description": "A test I wrote at class for my students at ENTI (University of Barcelona).\nThe shader is profusely commented in spanish.",
            "flags": 32,
            "hasliked": 0,
            "id": "wdfXWX",
            "likes": 5,
            "name": "Mirror spheres/cube",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "cube",
                "spheres",
                "reflections"
            ],
            "usePreview": 0,
            "username": "merry",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 texelSize = vec2(1) / iResolution.xy;\n    \n    if (0 == (iFrame % 2) && ((0 == int(fragCoord.x) % 2) || (1 == int(fragCoord.y) % 2)))\n    {\n        discard;\n        return;\n    }\n    else\n    if (1 == (iFrame % 2) && ((1 == int(fragCoord.x) % 2) || (0 == int(fragCoord.y) % 2)))\n    {\n        discard;\n        return;\n    }    \n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//==============================================================================\n//\tCONFIGURACIÓN\n//==============================================================================\n\n//\tCFG_USING_ENHANCED_RAYMARCHING utiliza una versión mejorada del algoritmo de trazado de rayos, que implementa\n//\tlas optimizaciones \"over-relaxation raymarching\" y \"screen-space aware intersection point selection\" descritas en\n//\tel paper \"Enhanced Sphere Tracing\" de Benjamin Kelinert et al. (http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf).\n\t#define CFG_USING_ENHANCED_RAYMARCHING\n\n//  CFG_USING_DISCONTINUITY_REDUCTION corrige el patrón esférico derivado de la discontinuidad entre el espacio de\n//\tpantalla (proyección 2D) y el espacio de mundo (posición del rayo y distancia a la superficie). Dicha discontinuidad\n//  aparece debido a la proyección del espacio esférico (que tiene profundidad) en el espacio de pantalla.\n//\tEl algoritmo está descrito en el mismo paper \"Enhanced Sphere Tracing\" indicado anteriormente.\n  \t#define CFG_USING_DISCONTINUITY_REDUCTION\n\n//#define CFG_SHOW_WORLDPOS\t// Descomentar para mostrar posiciones en mundo.\n//#define CFG_SHOW_NORMALS\t// Descomentar para mostrar normales.\n//#define CFG_SHOW_STEPS\t// Descomentar para mostrar pasos del Raymarcher.\n//#define CFG_SHOW_DISTANCE\t// Descomentar para mostrar distancias.\n//#define CFG_NO_SHADOWS    // Descomentar para desactivar las sombras.\n//#define CFG_NO_AO         // Descomentar para desactivar la oclusión ambiental.\n\nconst float kNearPlaneDist =   0.1;\t// Distancia al plano cercano.\nconst float kFarPlaneDist  =  50.0;\t// Distancia al plano lejano.\nconst float kEpsilon       = 0.001;\t// Valor de epsilon para comparaciones de distancia.\nconst float kPi\t\t\t   = 3.14159265359;\nconst int   kMaxSteps      =    64;\t// Número máximo de pasos del trazado de rayos.\nconst int   kMaxLightSteps =    16; // Número máximo de pasos del trazado de rayos de iluminación.\n\n\n//==============================================================================\n//\tFUNCIONES DE DISTANCIA\n//==============================================================================\n\n//\tPrimitivas de ejemplo.\n//\tOtras primitivas disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://www.pouet.net/topic.php?which=7931&page=1\nfloat sdPlaneY(vec3 p) { return p.y; }\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\nfloat sdBox   (vec3 p, vec3  b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//\tOperadores de ejemplo.\n//\tOtros operadores disponibles en: https://iquilezles.org/articles/distfunctions y\n//\thttp://mercury.sexy/hg_sdf/\nfloat opUnion       (float d1, float d2) { return min( d1, d2); }\nfloat opIntersection(float d1, float d2) { return max( d1, d2); }\nfloat opSubstraction(float d1, float d2) { return max(-d1, d2); }\nvec3  opRepetition  (vec3 pos, vec3 frq) { return mod(pos, frq) - 0.5 * frq; } \n\n//  Smooth minimum (polynomial smin())\n//  Ver https://iquilezles.org/articles/smin para más información.\nfloat opBlend(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n//==============================================================================\n//\tESCENA\n//==============================================================================\n\n#define MIN(dst, src) dst = mix(src, dst, step(dst.x, src.x))\nvec2 mapScene(vec3 pos)\n{\n    float t = iTime * 2.;\n    vec2  a = vec2(kFarPlaneDist, 0), b = a;\n\n    float q = abs(sin(iTime));\n   \n    b = vec2(sdBox(pos + vec3(sin(pos.y + iTime), sin(pos.z + iTime * 2.2), sin(pos.x + iTime * 3.3)), vec3(2)), 1.); MIN(a, b);\n\n    float e = b.x;\n    b = vec2(\n        opBlend(\n\t        opBlend(\n    \t    \topBlend(\n\t    \t    \tsdSphere(opRepetition(pos, vec3(5)), 0.5), \n\t    \t\t\tsdBox   (opRepetition(pos, vec3(5)), vec3(.1, 5, .1)), q\n    \t        \t),\n\t        \tsdBox(opRepetition(pos, vec3(5)), vec3(5, .1, .1)), q\n    \t    ),\n            sdBox(opRepetition(pos, vec3(5)), vec3(.1, .1, 5)), q\n        ),  0.);\n    MIN(a, b);\n    float tt = iTime * .3;\n    for (float i = 0.; i < kPi*2.; i+=kPi*.25)\n    {\n\t    b = vec2(opBlend(sdSphere(pos + vec3(sin(tt + i * 2.) * 4., cos(tt * 3. + i) * 4., sin(tt * 2.5 + i) * 3.), 1.0), e, 1.), 1.);\n    \tMIN(a, b);\n    }\n\n\treturn a;\n}\n\n//==============================================================================\n//\tTRAZADO DE RAYOS\n//==============================================================================\n\n//\tcastRay() traza un rayo con origen en \"ro\" en dirección \"rd\" desde el plano cercano kNearPlaneDist \n//  hasta encontrar una superficie contra la que chocar o hasta superar la distancia del plano lejano kFarPlaneDist.\n//\tEl rayo se mueve en pasos discretos hasta un máximo de kMaxSteps (lo que sirve para determinar la precisión).\n//\tEl rayo se desplaza a lo largo de un dominio de distancia: dada una posición en mundo (la del rayo), preguntamos\n//\ta la función mapScene(), que representa la escena, cuál es la distancia al objeto más cercano. Avanzamos entonces\n//\ten la dirección del rayo dicha distancia, y volvemos a preguntar hasta que se dé alguna de las condiciones\n//\tanteriormente indicadas.\n//\tEntradas:\tro - Origen del rayo.\n//\t\t\t\trd - Dirección del rayo.\n//\tSalida:\t\tvec4(totalDistance, lastStepDistance, materialID, steps). \n#ifndef CFG_USING_ENHANCED_RAYMARCHING\nvec4 castRay(vec3 ro, vec3 rd)\n{\n    float  t   = kNearPlaneDist;\n    vec2   res = vec2(kFarPlaneDist, 0);\n    int    i   = 0;\n    for (; i < kMaxSteps; ++i)\n    {\n\t    res    = mapScene(ro + rd * t);\n        if ((res.x < kEpsilon) || (t > kFarPlaneDist))\n            break;\n        t += res.x;\n    }\n    return vec4(t, res.xy, i);\n}\n#else// CFG_USING_ENHANCED_RAYMARCHING\nvec2  gTexelSize  ; // Pixel size   (screen domain).\nfloat gTexelRadius; // Pixel radius (screen domain).\n\nvec4 castRay(vec3 ro, vec3 rd)\n{\n\tgTexelSize    = 1. / iResolution.xy;\n\tgTexelRadius  = length(gTexelSize) ;\n    \n    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;\n    vec2  res = vec2(kFarPlaneDist, 0);\n\tint   i   = kMaxSteps;\n    for (; (i >= 0) && (t < kFarPlaneDist); --i)\n    {\n        res = mapScene(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {//\tError detectado, deja de aplicar la optimización \"over-relaxation raymarching\".\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {// Actualiza el error.\n            if (err < prevErr     ) { res.x = t; prevErr = err; }\n            if (err < gTexelRadius) break; // Aplica \"screen-space aware intersection point selection\".\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, kMaxSteps - i);\n}\n#endif//CFG_USING_ENHANCED_RAYMARCHING\n\n//==============================================================================\n//\tUTILIDADES\n//==============================================================================\n\n//\tCalcula el sombreado para la superficie. Para ello, traza un rayo desde la superficie hasta la luz, y determina\n//\tsi es posible llegar hasta la luz sin encontrar otra superficie antes. Si es posible llegar hasta la luz, el\n//\tpunto estará iluminado. En caso contrario, el punto estará sombreado.\n//\tAdemás, para cada paso del rayo computa la distancia mínima al objeto más cercano y utiliza ese valor para calcular\n//\tla penumbra.\n//\tMás información sobre el algoritmo en https://iquilezles.org/articles/rmshadows\n//\tEntradas:\tro   - Posición en mundo de la superficie.\n//\t\t\t\trd   - Dirección desde \"ro\" hasta la luz para la cual queremos calcular el sombreado.\n//\t\t\t\ttmin - Distancia desde \"ro\" hasta el inicio del rayo (evita arterfactos por precisión de flotante).\n//\t\t\t\ttmax - Distancia entre \"ro\" y la luz (permite descartar cuando llegamos a la luz).\n//\t\t\t\tk    - Factor de penumbra (cuanto más mayor, la sombra es más dura).\n//\tSalida: \tFactor de sombreado (0 para sombreado, 1 para iluminado, valores intermedios representan penumbra).\n#ifndef\tCFG_NO_SHADOWS\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    float res = 1.0;\n    float ph  = 1e20;\n    for( float t = tmin; t < tmax;)\n    {\n        float h = mapScene(ro + rd*t).x;\n        if( h < 0.001)\n            return 0.;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h - y*y);\n        res = min(res, k*d / max(0.0,t - y));\n        ph  = h;\n        t  += h;\n    }\n    return res;\n}\n#else\nfloat computeSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) { return 1.0; }\n#endif//CFG_NO_SHADOWS\n\n//\tCalcula la oclusión ambiental de la superficie. Para ello, muestrea a distintas distancias desde la posición en \n//\tmundo para la superficie, y calcula la oclusión ambiental aplicando un filtro de paso bajo: los valores de\n//  distancia obtenidos más cercanos a la superficie tienen más peso, y a medida que nos alejamos tienen menos.\n//\tEl proceso que se sigue es el siguiente:\n//\t\t- Para cada iteración, calcula una posición en mundo alejada de la superficie 1/N del total de muestras.\n//\t\t- Calcula la distancia desde esa posición a la superficie más cercana.\n//\t\t- Cuanto más cercana sea esa distancia a la distancia original entre la superficie de entrada y la calculada\n//\t\t  en la iteración actual, menos oclusión hay.\n//\tEntradas:\tpos\t- Posición en mundo para la superficie.\n//\t\t\t\tnor - Normal de la superficie.\n//\tSalida:\t\tFactor de oclusión (0 para totalmente ocluido, 1 para totalmente visible).\n#ifndef CFG_NO_AO\nfloat computeAO(vec3 pos, vec3 nor)\n{\n\tfloat  occ = 0.0;\n    float  sca = 1.0;\n    for( int i = 0; i < 5; ++i)\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3  aopos = nor * hr + pos;\n        float dd = mapScene(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);    \n}\n#else\nfloat computeAO(vec3 pos, vec3 nor) { return 1.0; }\n#endif//CFG_NO_AO\n\n//  Calcula la normal de la superficie en \"pos\" mediante derivación del gradiente de la función de distancia.\n//\tEntradas:\tpos - Posición en mundo de la superficie.\n//\tSalida:\t\tVector normal de la superficie.\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(kEpsilon, 0, 0);\n\treturn normalize(vec3(mapScene(pos + epsilon.xyy).x - mapScene(pos - epsilon.xyy).x, mapScene(pos + epsilon.yxy).x - mapScene(pos - epsilon.yxy).x, \n        mapScene(pos + epsilon.yyx).x - mapScene(pos - epsilon.yyx).x));\n}\n\n//\tcomputeCameraMatrix() calcula la matriz de cámara.\n//\tEntradas:\tro - Posición de la cámara (eye).\n//\t\t\t\tta - Posición en mundo a la que mira la cámara (lookAt).\n//\t\t\t\tcr - Rotación del vector front, de 0 a 2*π radianes.\n//\tSalida:\t\tMatriz de cámara.\nmat3 computeCameraMatrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3 (sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n//\tMateriales, luces y colores.\nvec3[] gMaterials  = vec3[](vec3(1, 0, 0), vec3( 1, 1,.9));\nvec3[] gLightPos   = vec3[](vec3(4, 4, 4), vec3(-4, 4,-4));\nvec3[] gLightCol   = vec3[](vec3(1,.9,.5), vec3(.5,.9, 1));\nvec3   gAmbientCol = vec3(.1,.2,.3);\n\n//\tcomputeShading() calcula la iluminación con difusa de Lambert y especular de Blinn-Phong.\n//\tEntradas:\tpos - Posición en mundo de la superficie.\n//\t\t\t\tnor - Normal de la superficie.\n//\t\t\t\tviewVector - Vector vista.\n//\t\t\t\tmatID      - Índice de material en gMaterials.\n//\t\t\t\tlightID    - Índice de luz en gLightPos y gLightCol.\n//  Salida:\t\tColor resultante.\nvec3 computeShading(vec3 pos, vec3 nor, vec3 viewVector, int matID, int lightID)\n{\n\tvec3  col = vec3(0), halfVec  = normalize(-viewVector + normalize(gLightPos[lightID] - pos));\n\tcol = col + gLightCol[lightID] * gMaterials[matID] * clamp(dot(nor, -viewVector), 0., 1.); // Cálculo de difusa.\n\tcol = col + gLightCol[lightID] * pow(clamp(dot(nor, halfVec), 0., 1.), 5.); // Cálculo de especular.\n\treturn \tcol;\n}\n\n\n//==============================================================================\n//\tENTRYPOINT\n//==============================================================================\n\n//  Función principal.\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // Coordenadas UV en el rango [0,1].\n\tvec2 p  = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // Coordenadas UV en el rango [0,1] con Aspect Ratio aplicado.\n    \n    vec3 pos, nor, col; // Posición, normal, color.\n    vec4 res; // Resultados del trazado de rayos.\n\n    if (0 == (iFrame % 2) && ((0 == int(fragCoord.x) % 2) || (1 == int(fragCoord.y) % 2)))\n    {\n        discard;\n        return;\n    }\n    else\n    if (1 == (iFrame % 2) && ((1 == int(fragCoord.x) % 2) || (0 == int(fragCoord.y) % 2)))\n    {\n        discard;\n        return;\n    }\n    \n\t// Configura la cámara.\n    vec3 ro = vec3(sin(iTime * .35) * 5. * (4. + sin(iTime)), 5., cos(iTime * .35) * 5. * (3. + cos(iTime)));\n    vec3 ta = vec3(0);\n    mat3 ca = computeCameraMatrix(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,  2.0));\n    \n    // Traza el rayo y calcula la posición en mundo de la superficie impactada.\n    res = castRay(ro, rd);\n    pos = ro + rd * res.x;    \n    \n#\tifdef   CFG_USING_DISCONTINUITY_REDUCTION\n  \t// Aplica la optimización \"discontinuity reduction\" para mejorar la adaptación del espacio esférico al de pantalla.\n    float coneSize  = tan(kPi / 6.) / (iResolution.y);\n    float error     = 0.;\n    for (int  i = 0; i < 3; ++i)\n    {\n        pos    -= rd *    (error - mapScene(pos).x);\n        error   = coneSize * length(ro  - pos);\n    }\n#\tendif//\tCFG_USING_DISCONTINUITY_REDUCTION\n\n    // Calcula la normal.\n    nor = computeNormal(pos);\n    \n    // Para cada luz, computa la iluminación y el sombreado.\n    for (int i = 0; i < gLightPos.length(); ++i)\n    {\n\t\tcol+= computeShading(pos, nor, rd, int(res.z), i) * computeSoftShadow(pos, normalize(gLightPos[i] - pos), .025, length(gLightPos[i] - pos), 25.);\n    }\n    \n    float dist = res.x;\n    if (res.z == 1.)\n    {\n        ro = pos + nor * .1;\n        rd = reflect(rd, nor);\n\n\t    res = castRay(ro, rd);\n    \tpos = ro + rd * res.x;    \n    \tnor = computeNormal(pos);\n\n        vec3 col2 = vec3(0);\n        for (int i = 0; i < gLightPos.length(); ++i)\n    \t{\n\t\t\tcol2+= computeShading(pos, nor, rd, int(res.z), i) * computeSoftShadow(pos, normalize(gLightPos[i] - pos), .025, length(gLightPos[i] - pos), 25.);\n    \t}\n        col=mix(col,col2,abs(sin(iTime)));\n    }\n    \n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    col = col + gAmbientCol * gMaterials[int(res.z)] * mix(computeAO(pos, nor), 1., dot(col, W));\n\n#   ifdef   CFG_SHOW_WORLDPOS\n    col = pos;\n#   endif// CFG_SHOW_WORLDPOS\n\n#   ifdef   CFG_SHOW_NORMALS\n    col = nor;\n#   endif// CFG_SHOW_NORMALS\n\n#   ifdef   CFG_SHOW_STEPS\n    col = mix(vec3(0, 1, 0), vec3(1, 0, 0), res.w / float(kMaxSteps));\n#   endif// CFG_SHOW_STEPS\n\n#   ifdef   CFG_SHOW_DISTANCE\n    col = vec3(res.x / (kFarPlaneDist - kNearPlaneDist));\n#   endif// CFG_SHOW_DISTANCE\n    \n    col = mix(col, vec3(.3), pow(dist/50.0,.5));\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}