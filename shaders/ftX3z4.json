{
    "Shader": {
        "info": {
            "date": "1621607082",
            "description": "zoooom",
            "flags": 0,
            "hasliked": 0,
            "id": "ftX3z4",
            "likes": 0,
            "name": "Into the triverse",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "maeln",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415\n#define MAXSTEPS 128\n#define MINDIST  0.0005\n#define MAXDIST  20.0\n#define saturate(x) (clamp(0.0, 1.0, x))\n#define f1(x) (clamp(x, 0.0, 1.0))\n#define rep(p, r) (mod(p - r*.5, r) - r*.5)\n\nvec3 hi = vec3(0.0, 0.0, 0.0)/255.0;\nvec3 lo = vec3(0.0, 0.0, 0.0)/255.0;\n\nstruct pLight {\n    vec3 position;\n    vec3 ambiant;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n    \nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p);\n    return sqrt(max(0.0, dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\n// Compute the position of particle {i} at the time {iTime}.\nvec3 calcPos(int i) {\n    float fi = float(i);\n    float dx = sin((fi/4.0)+iTime) + mix(2.0, 0.0, f1(iTime-4.0));\n    float dy = sin(2.0*PI*(fi/10.0) + iTime) - mix(0.0, sin(2.0*PI*(fi/10.0) + iTime), f1(iTime/1.5-20.0));\n    float dz = cos(2.0*PI*(fi/10.0) + iTime) - mix(0.0, cos(2.0*PI*(fi/10.0) + iTime), f1(iTime/1.5-20.0));\n    \n    vec3 dir = vec3(dx, dy, dz);\n    vec3 p = dir;\n    \n    return p;\n}\n\nfloat sdTriangle(vec3 ray) {\n    vec3 p1 = vec3(0.0);\n    vec3 p2 = vec3(0.0, 0.0, 1.0);\n    vec3 p3 = vec3(0.0, sqrt(1.0), 0.5);\n    return min(min(sdCapsule(ray, p1, p2, 0.01), sdCapsule(ray, p2, p3, 0.01)), sdCapsule(ray, p3, p1, 0.01));\n}\n\n\nvec2 enter(vec3 ray) {\n    float mi = 0.0;\n    float de = MAXDIST;\n    for(int i=1; i<50; ++i) {\n        float fi = float(i);\n        float zr = 2. - random(vec2(fi, 5.0)) * 4.0;\n        float yr = 2. - random(vec2(fi, 2.0)) * 4.0;\n        float xr = -10.0 + mix((fi/50.0*10.0), 0.0, saturate(iTime/20.0)) + mod(iTime*2.0+(random(vec2(fi, 1.0))*20.0), 20.0);\n        vec3 q = ray - vec3(xr, yr, zr);\n        float rx = 2. - random(vec2(fi, 5.0)) * 4.0;\n        q = (rotationMatrix(vec3(rx, yr, zr), iTime) * vec4(q, 1.0)).xyz;\n        float di = sdTriangle(q);\n        if(de > di) {\n            de = di;\n            mi = fi;\n        }\n    }\n    return vec2(de, mi);\n}\n\nvec2 dancingSphere(vec3 ray) {\n    float mi = 0.0;\n    float de = MAXDIST;\n    for(int i=0; i<10; ++i) {\n        float di = sdSphere(ray-calcPos(i), 0.1);\n        if(de > di) {\n            de = di;\n            mi = float(i)+1.0;\n        }\n    }\n    \n    return vec2(de, mi);\n}\n\n// Draw all the particles\nvec3 scene(vec3 ray)\n{\n    vec2 init = enter(ray);\n    vec2 spheres = dancingSphere(ray);\n    \n    float kmi = init.y;\n    float kde = init.x;\n    float koi = 0.0;\n    \n    if(spheres.x < init.x) {\n        kmi = spheres.y;\n        kde = spheres.x;\n        koi = 1.0;\n    }\n    \n    return vec3(kde, kmi, koi);\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.0, MINDIST);\n\treturn normalize(vec3(\n    scene(pos + eps.yxx).x - scene(pos - eps.yxx).x,\n    scene(pos + eps.xyx).x - scene(pos - eps.xyx).x,\n    scene(pos + eps.xxy).x - scene(pos - eps.xxy).x));\n}\n\nvec4 raymarch(vec3 from, vec3 direction)\n{\n    float t = 1.0*MINDIST;\n    int i = 0;\n    vec3 march = vec3(MAXDIST, -1.0, -1.0);\n    for(int steps=0; steps<MAXSTEPS; ++steps)\n    {\n        ++i;\n        march = scene(from + t * direction);\n        if(march.x < MINDIST || t >= MAXDIST) break;\n        t += march.x;\n    }\n    return vec4(t, t > MAXDIST ? -1.0 : march.y, march.z, float(i));\n}\n\nvec3 phong(vec3 hit, vec3 eye, vec3 N, pLight light, float ks) {\n    vec3 L = normalize(light.position - hit);\n    vec3 V = normalize(eye - hit);\n    vec3 R = reflect(L, N);\n    vec3 ambiant = light.ambiant;\n    vec3 diffuse = max(dot(L,N), 0.0)*light.diffuse;\n    vec3 specular = pow(max(dot(R,V), 0.0), ks)*light.specular;\n    return ambiant + 0.5*(diffuse+specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pLight l1 = pLight(vec3(sin(iTime/3.0), sin(iTime/4.0), cos(iTime/6.0)),\n                       vec3(0.0), vec3(0.0), vec3(1.8));\n    \n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 target  = vec3(0.0, 0.0, 0.0);\n\tvec3 eye     = vec3(2.0, 0.0, 0.0);\n    vec3 up      = vec3(0.0, 1.0, 0.0);\n    \n    vec3 eyeDir   = normalize(target - eye);\n    vec3 eyeRight = normalize(cross(up, eye));\n    vec3 eyeUp    = normalize(cross(eye, eyeRight));\n    \n    vec3 rayDir = normalize(eyeRight * uv.x + eyeUp * uv.y + eyeDir);\n       \n    vec3 skyCol = mix(lo, hi, gl_FragCoord.y/iResolution.y);\n    vec3 color = skyCol;\n    \n    vec4 march = raymarch(eye, rayDir);\n    color = vec3(0.3, 0.0, 1.0) * march.w / float(MAXSTEPS) * 4.0;\n    if(march.y>0.0) {\n        color = vec3(1.0);\n        if(march.z>0.0) {\n            vec3 hit = eye+march.x*rayDir;\n            vec3 norm = normal(hit);\n            color *= phong(hit, eye, norm, l1, 16.0);\n        }\n    }\n    \n    \n    // LOGO\n    // left-down circle\n    float d = sdCircle(uv + vec2(1.25, 0.5), 0.1);\n    color = mix(color, vec3(1.0), smoothstep(3.0/iResolution.y, 0.0, d));\n    \n    // left down arc\n    float ta = PI/2.0 * iTime*2.0;// 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n    float tb = PI/4.0 * (1.0-sin(iTime)/2.0); //3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    d = sdArc(uv + vec2(1.25, 0.5),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.2, 0.02);\n    color = mix(color, vec3(1.0), smoothstep(4.0/iResolution.y, 0.0, d));\n\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}