{
    "Shader": {
        "info": {
            "date": "1690883134",
            "description": "3D cellular automaton - updated for larger (8x) grid",
            "flags": 32,
            "hasliked": 0,
            "id": "dlXyzB",
            "likes": 23,
            "name": "Cellular Sculpture 2",
            "published": 3,
            "tags": [
                "life",
                "cell",
                "automaton"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "// \"Cellular Sculpture 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n 3D cellular automaton related to the game of Life. Cell alive if 13 or 15+\n live neighbors (out of 27, including itself), otherwise dead.\n Use mouse to halt process and rotate/zoom; click in ring to restart\n (else automatic).\n Grid cells are packed 8 per texel; grid size limited by texture (window) size.\n Cell-marching from \"Mandelcity\".\n Step counter and live cell count (/1000) shown.\n (Note 1: only single compute buffer used here; could use more for speedup.)\n (Note 2: changes to rules and initial state are currently exercises for\n the reader. :)\n*/\n\n#define AA   1   // optional antialiasing\n\n#define BIG  1   // (same in all shaders)\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec3 HsvToRgb (vec3 c);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec4 Loadv4 (int idVar);\nfloat Fbm2 (vec2 p);\n\nvec3 gCel, ltDir, gsv;\nfloat dstFar, tCur, gSizeH;\nint nFrame;\nconst float pi = 3.1415927;\n\nbool Occ (vec3 g)\n{\n#if BIG\n  return (((int (Loadv4 (int (dot (floor (g / 2.), gsv))).x) >>\n     int (dot (mod (g, 2.), vec3 (1., 2., 4.)))) & 1) != 0);\n#else\n  return (int (Loadv4 (int (dot (g, gsv))).x) != 0);\n#endif\n}\n\nvec4 CellRay (vec3 ro, vec3 rd)\n{\n  vec3 ig, fcHit, gb, s, cp, rdi;\n  float g1, g2;\n  int stepLim;\n  bool occ;\n  rdi = 1. / rd;\n  gCel = floor (ro);\n  gb = (max (sign (rd), vec3 (0.)) - ro) * rdi;\n  occ = false;\n  stepLim = int (1.9 * gSizeH);\n  for (int i = VAR_ZERO; i < stepLim; i ++) {\n    s = gb + gCel * rdi;\n    cp = step (s, s.yzx);\n    fcHit = cp * (1. - cp.zxy);\n    gCel += sign (rd) * fcHit;\n    ig = gCel + 0.5 * gSizeH;\n    g1 = Minv3 (ig);\n    g2 = Maxv3 (ig);\n    if (g1 < -1. || g2 > gSizeH) break;\n    if (g1 >= 0. && g2 < gSizeH) {\n      occ = Occ (ig);\n      if (occ) break;\n    }\n  }\n  return (occ) ? vec4 (dot (s - abs (rdi), fcHit), fcHit) : vec4 (dstFar, 0., 0., 0.);\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec2 BlkHitQ (vec3 ro, vec3 rd, vec3 p, float bSize)\n{\n  vec3 v, tm, u, fcBlk;\n  v = (ro - p) / rd;\n  tm = - bSize / abs (rd) - v;\n  fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = (v + Maxv3 (tm)) * rd;\n  return vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col, skCol;\n  vec2 u;\n  float el, f;\n  skCol = vec3 (0.1, 0.15, 0.6);\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 32.;\n  col = mix (skCol, vec3 (0.9, 0.9, 0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, skCol, smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return 0.9 * col;\n}\n\n#define COL 1\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 dc4;\n  vec3 col, vn, cm;\n  float dBlk, sh, nDotL, b;\n  rd += 1e-5;\n  dBlk = BlkHit (ro, rd, vec3 (0.5 * gSizeH + 1.));\n#if COL\n  col = BgCol (rd);\n#else\n  col = vec3 (0.);\n#endif\n  if (dBlk < dstFar) {\n    ro += dBlk * rd;\n    dc4 = CellRay (ro, rd);\n    if (dc4.x < dstFar) {\n      cm = gCel + 0.5;\n      ro += dc4.x * rd;\n      vn = - dc4.yzw * sign (rd);\n      b = Maxv2 (abs (BlkHitQ (ro, rd, cm, 0.5)));\n#if COL\n      col = HsvToRgb (vec3 (1. - 0.8 * fract (length (cm) / (0.5 * gSizeH)), 0.8, 1.));\n      //col = vec3 (1.); // b/w\n      col *= mix (1., 0.7, step (0.4, b));\n      sh = 0.5 + 0.5 * smoothstep (0.1, 0.6, CellRay (ro + 0.01 * vn, ltDir).x / gSizeH);\n      nDotL = max (dot (ltDir, vn), 0.);\n      col = col * (0.3 + 0.2 * max (dot (- ltDir, vn), 0.) + 0.7 * sh * nDotL * nDotL) +\n         0.2 * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n#else\n      col = mix (col, vec3 (1.), step (0.4, b));\n      col *= 0.3 + 0.7 * max (- dot (vn, rd), 0.);\n#endif\n    }\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, wgBxC;\n  vec2 canvas, uv;\n  float asp, dVu, sr, el, az, zmFac, gSize, nStep;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  nFrame = iFrame;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, 0.46, 0.022);\n  nStep = Loadv4 (0).z;\n  mPtr.xy = Loadv4 (1).zw;\n  mPtr.z = Loadv4 (2).z;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) > wgBxC.z) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.01 * tCur;\n  }\n  zmFac = 4.5 - 9. * (cos (el) - 1.);\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  az -= 0.3 * pi;\n  el -= 0.1 * pi;\n  vuMat = StdVuMat (el, az);\n  gSize = Loadv4 (0).w;\n#if BIG\n  gSizeH = 2. * gSize;\n#else\n  gSizeH = gSize;\n#endif\n  gsv = vec3 (1., gSize, gSize * gSize);\n  dVu = 3. * gSizeH;\n  ro = vuMat * vec3 (0., 0., - dVu);\n  dstFar = dVu + 2. * gSizeH + 3.;\n  ltDir = vuMat * normalize (vec3 (0.6, 1.1, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = mix (vec3 (1., 1., 0.7), col, smoothstep (2., 2.2,\n     abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y));\n  col = mix (col, vec3 (0.2), ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.45),\n     vec2 (0.06 * asp, 0.03), 4., floor (Loadv4 (1).y / 1000. + 0.5)));\n  if (true) col = mix (col, vec3 (0.2), ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.4),\n     vec2 (0.06 * asp, 0.03), 4., 10. * floor ((max (nStep, 0.) + 9.) / 10.)));\n  if (false) col = mix (col, vec3 (0.2), ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.35),\n     vec2 (0.06 * asp, 0.03), 4., gSizeH));\n  if (false) col = mix (col, vec3 (0.2), ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.3),\n     vec2 (0.06 * asp, 0.03), 4., txSize.x));\n  fragColor = vec4 (col, 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val + 0.01) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txSize.x), floor (fi / txSize.x)) + 0.5) / txSize);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Cellular Sculpture 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define BIG  1   // (same in all shaders)\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 gsv;\nfloat todCur, gSize, nStep;\nint nFrame;\n\nbool InOcc (vec3 g)\n{\n  return (fract (Hashfv3 (vec3 (1.11, 1.13, 1.17) * g + fract (todCur))) > 0.499);\n}\n\nfloat CInit (vec3 gCel)\n{\n  vec3 g;\n  int iv;\n  iv = 0;\n#if BIG\n  for (int k = 0; k < 8; k ++) {\n    g = gCel - 0.5 * gSize;\n    if (sqrt (length (g * g)) < 0.5 * gSize && InOcc (gCel)) iv += 1 << k;\n  }\n#else\n  g = gCel - 0.5 * gSize;\n  if (sqrt (length (g * g)) < 0.5 * gSize && InOcc (gCel)) iv = 1;\n#endif\n  return float (iv);\n}\n\nbool Rule (int ns)\n{\n  return (ns == 13 || ns >= 15);\n}\n\nbool Occ (vec3 g)\n{\n#if BIG\n  return (((int (Loadv4 (int (dot (floor (g / 2.), gsv))).x) >>\n     int (dot (mod (g, 2.), vec3 (1., 2., 4.)))) & 1) != 0);\n#else\n  return (int (Loadv4 (int (dot (g, gsv))).x) != 0);\n#endif\n}\n\nfloat CUpdate (vec3 gCel)\n{\n  int iv, ns;\n  iv = 0;\n#if BIG\n  vec3 ig;\n  for (int k = 0; k < 8; k ++) {\n    ig = 2. * gCel + mod (vec3 (k, k / 2, k / 4), 2.);\n    ns = 0;\n    for (int iz = -1; iz <= 1; iz ++) {\n      for (int iy = -1; iy <= 1; iy ++) {\n        for (int ix = -1; ix <= 1; ix ++) {\n           if (Occ (ig + vec3 (ix, iy, iz))) ++ ns;\n        }\n      }\n    }\n    if (Rule (ns)) iv += 1 << k;\n  }\n#else\n  ns = 0;\n  for (int iz = -1; iz <= 1; iz ++) {\n    for (int iy = -1; iy <= 1; iy ++) {\n      for (int ix = -1; ix <= 1; ix ++) {\n        if (Occ (gCel + vec3 (ix, iy, iz))) ++ ns;;\n      }\n    }\n  }\n  if (Rule (ns)) iv = 1;\n#endif\n  return float (iv);\n}\n\nfloat CCopy (vec3 gCel)\n{\n  return Loadv4 (int (dot (gCel, gsv))).x;\n}\n\nvoid CCount (vec3 gCel, inout float sv)\n{\n  int state, iv, nv;\n  state = int (mod (nStep, 10.));\n  nv = int (sv);\n  if (state == 1) {\n    if (gCel.x == 0.) {\n      nv = 0;\n      for (int ix = 0; ix < int (gSize); ix ++) {\n        iv = int (Loadv4 (int (dot (gCel + vec3 (ix, 0., 0.), gsv))).x);\n#if BIG\n        for (int k = 0; k < 8; k ++) {\n          if ((iv & (1 << k)) != 0) ++ nv;\n        }\n#else\n        nv += iv;\n#endif\n      }\n    }\n  } else if (state == 2) {\n    if (gCel.xy == vec2 (0.)) {\n      nv = 0;\n      for (int iy = 0; iy < int (gSize); iy ++) {\n        nv += int (Loadv4 (int (dot (gCel + vec3 (0., iy, 0.), gsv))).y);\n      }\n    }\n  } else if (state == 3) {\n    if (gCel == vec3 (1., 0., 0.)) {\n      nv = 0;\n      for (int iz = 0; iz < int (gSize); iz ++) {\n        nv += int (Loadv4 (int (dot (vec3 (0., 0., iz), gsv))).y);\n      }\n    }\n  }\n  sv = float (nv);\n}\n\n#define MAX_GRID  120  // (limit set by numerical precision)\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 gCel, wgBxC;\n  vec2 canvas, iFrag;\n  float v, sv, ip, nsi, frSkip, asp;\n  int pxId;\n  bool init, doStep;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  ip = floor (iFrag.x + txSize.x * iFrag.y);\n  pxId = int (ip);\n  init = (nFrame <= 2);\n  gSize = min (floor (floor (pow (txSize.x * txSize.y, 1./3.)) / 2.) * 2., float (MAX_GRID));\n  if (! init  && gSize != Loadv4 (0).w) init = true;\n  if (ip >= gSize * gSize * gSize) discard;\n  frSkip = 2.;   // set = 1 for max speed, else slow down [(txSize.x <= 128.) ? 5. : 2.;]\n  doStep = (mPtr.z <= 0. && mod (float (nFrame), frSkip) == 0.);\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, 0.46, 0.022);\n  gsv = vec3 (1., gSize, gSize * gSize);\n  gCel = mod (floor (vec3 (ip) / gsv), vec3 (gSize));\n  nStep = Loadv4 (0).z;\n  if (! init && (nStep > 30. * gSize || nStep > 40. && Loadv4 (1).y == 0.)) init = true;\n  mPtrP.z = Loadv4 (2).z;\n  if (mPtr.z > 0.) {\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) < wgBxC.z) {\n      if (mPtrP.z <= 0.) init = true;\n    }\n  }\n  v = 0.;\n  if (init) nStep = -20.;\n  else if (doStep) ++ nStep;\n  if (Minv3 (gCel) > 0. && Maxv3 (gCel) < gSize - 1.) {\n    if (init) v = CInit (gCel);\n    else if (doStep && nStep > 0.) v = CUpdate (gCel);\n    else v = CCopy (gCel);\n  }\n  stDat = vec4 (v, Loadv4 (pxId).y, 0., 0.);\n  if      (pxId == 0) stDat.zw = vec2 (nStep, gSize);\n  else if (pxId == 1) stDat.zw = mPtr.xy;\n  else if (pxId == 2) stDat.z = mPtr.z;\n  if (doStep) CCount (gCel, stDat.y);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txSize.x), floor (fi / txSize.x)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txSize.x), floor (fi / txSize.x)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}