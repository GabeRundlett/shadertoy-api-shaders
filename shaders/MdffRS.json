{
    "Shader": {
        "info": {
            "date": "1496677079",
            "description": "Voxel tracing with truncated octahedra",
            "flags": 0,
            "hasliked": 0,
            "id": "MdffRS",
            "likes": 20,
            "name": "Mandel Oct Vox",
            "published": 3,
            "tags": [
                "mandelbrot",
                "voxel",
                "octahedron",
                "trunacted"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 954
        },
        "renderpass": [
            {
                "code": "// \"Mandel Oct Vox\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Truncated octahedral voxel tracer distilled from culdevu's shader.\n// Architecture from \"Mandel City\" which used a cubic voxel tracer.\n\nvec3 ltDir, cMid;\nfloat dstFar, fcId;\nconst float pi = 3.14159;\n\nbool HitMand (vec3 p)\n{\n  vec3 q;\n  vec2 v, w;\n  float h;\n  h = 0.;\n  p.xz *= 0.03;\n  p.x -= 0.85;\n  q = 0.01 * floor (100. * p);\n  if (length (q.xz + vec2 (0.25, 0.)) > 0.45 &&\n     length (q.xz + vec2 (1., 0.)) > 0.2 &&\n     (q.x < 0. || abs (q.z) > 0.04)) {\n    v = q.xz;\n    h = 80.;\n    for (int j = 0; j < 80; j ++) {\n      w = v * v;\n      if (w.x + w.y > 4.) {\n        h = float (j + 1);\n        break;\n      } else v = q.xz + vec2 (w.x - w.y, 2. * v.x * v.y);\n    }\n  }\n  return (0.3 * h > q.y);\n}\n\nvec3 FcVec (float k)\n{\n  vec3 u;\n  const vec3 e = vec3 (1., 0., -1.);\n  if (k <= 3.) u = (k == 1.) ? e.xyy : ((k == 2.) ? e.yxy : e.yyx);\n  else if (k <= 5.) u = 0.5 * ((k == 4.) ? e.xxx : e.zxx);\n  else u = 0.5 * ((k == 6.) ? e.xzx : e.xxz);\n  return u;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cm, fv;\n  float dHit, d, dd, s;\n  cMid = sign (ro) * floor (abs (ro) + 0.5);\n  cm = mod (cMid, 2.);\n  s = cm.x + cm.y + cm.z;\n  if (s == 1. || s == 2.)\n     cMid += step (abs (cm.yzx - cm.zxy), vec3 (0.5)) * sign (ro - cMid);\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    p = cMid - (ro + dHit * rd);\n    fcId = 0.;\n    d = dstFar;\n    for (float k = 1.; k <= 7.; k ++) {\n      fv = FcVec (k);\n      s = dot (fv, rd);\n      if (s != 0.) {\n        dd = dot (p + sign (s) * fv, fv)  / s;\n        if (dd < d) {\n          d = dd;\n          fcId = sign (s) * k;\n        }\n      }\n    }\n    cMid = floor (cMid + 2. * sign (fcId) * FcVec (abs (fcId)) + 0.5);\n    dHit += d;\n    if (HitMand (cMid) || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj;\n  dstObj = ObjRay (ro, rd);\n  ro += rd * dstObj;\n  if (length (ro.xz - vec2 (8., 0.)) > 50.) dstObj = dstFar;\n  if (dstObj < dstFar) {\n    vn = - normalize (sign (fcId) * FcVec (abs (fcId)));\n    col = HsvToRgb (vec3 (mod (0.039 * cMid.y, 1.), 1., 1.));\n    col = col * (0.1 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    col = pow (clamp (col, 0., 1.), vec3 (0.5));\n  } else {\n    col = vec3 (0.9, 0.9, 1.) * (0.6 + 0.4 * rd.y);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, tCur;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 1.5 * pi * mPtr.x;\n    el = -0.3 * pi + 0.7 * pi * mPtr.y;\n  } else {\n    az = 0.6 * pi * sin (0.03 * pi * tCur);\n    el = -0.3 * pi + 0.1 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, -0.05 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.2));\n  ro = vuMat * vec3 (0., -5., -120.);\n  ltDir = vuMat * normalize (vec3 (1., 2.5, -1.));\n  dstFar = 200.;\n  if (0.5 * abs (uv.x) < canvas.y / canvas.x) {\n    ro.xy += vec2 (8., 5.);\n    col = ShowScene (ro, rd);\n  } else col = vec3 (0.9, 0.9, 1.) * (0.6 + 0.4 * rd.y);\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}