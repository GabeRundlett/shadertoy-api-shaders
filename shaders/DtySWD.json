{
    "Shader": {
        "info": {
            "date": "1686086763",
            "description": "Sound reactive repetition time based pattern derived from this tutorial by Kishimisu https://www.youtube.com/watch?v=f4s1h2YETNY and the sound reactivity from Kishimisu's audio visualizer shader https://www.shadertoy.com/view/dtl3Dr\n\nMusic : Me",
            "flags": 4,
            "hasliked": 0,
            "id": "DtySWD",
            "likes": 4,
            "name": "Fork Sound Cand NikolaErce 743",
            "published": 3,
            "tags": [
                "2d",
                "psychedelic",
                "colourfulsound"
            ],
            "usePreview": 0,
            "username": "NikolaErceg",
            "viewed": 325
        },
        "renderpass": [
            {
                "code": "//Based on https://www.youtube.com/watch?v=f4s1h2YETNY\n//inline comments may not be completely accurate.\n\n/* Audio-related functions \nFrom audio visualizer shader by Kishimisu https://www.shadertoy.com/view/dtl3Dr\n*/\n#define st(t1, t2, v1, v2) mix(v1, v2, smoothstep(t1, t2, iTime))\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\n\nfloat logisticAmp(float amp){\n   float c = st(0., 10., .8, 1.), a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\n// Gold Noise ©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated fractional seeding method. \n\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvec3 palette (float dist)\n{\n    //make a distance based colour gradient\n    vec3 a = vec3(0.5,0.0,0.5);\n    vec3 b = vec3(0.25,0.25,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a+b*cos(6.28318*(c*dist*d) );\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //speed of ring movement (0.1 - 1.0 are good values)\n    float speed = 0.1;\n    //multiplier for number of colour rings (more rings more complex pattern)\n    float ringmultiplier = 2.0;\n    //width of colour regions (too high and you'll just get white as it uses additive colouring)\n    float ringwidth = 64.0;\n    //sort of smoothing between black and colour (0.1-0.4 are good)\n    float smoothing = 0.4;\n    //Iterations of fract (repeat of the pattern, set to 1 to see the basic pattern)\n    float iter = 6.0;\n    //Zoom amount, smaller = more zoomed in.\n    float zoom = 2.0;\n    //noise seed\n    float seed = 6502.;\n    \n    float vol = getVol(8.0);\n\n    float myTime = (iTime*0.5) + 0.0 + vol;\n    zoom +=vol*0.1;\n    // Centered aspect corrected normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y);\n\n    //copy of uv before we mess with it in fract.\n    vec2 uv0 = uv;\n    float noise = gold_noise(fragCoord, seed) - ((sin(myTime * 0.5)*0.5) + 0.5);\n    \n    uv *= (zoom * sin(myTime*0.05));\n    //initialise output colour (we add to this in the loop)\n    vec3 outCol = vec3(0.0);\n\n    for(float i = 0.0; i < iter; i++)\n    {\n        //repeat pattern\n        uv = fract(uv * (1.25 + (sin((myTime * 0.1) * i))))-0.5;\n        //uv = fract(uv)-0.5;\n\n        //distance from centre \n        float dist = sdHexagon(uv, 0.2 * (vol+i));\n\n        // Time varying simple pixel color\n        //vec3 col = 0.5 + 0.5 * cos((myTime*i*0.1) + uv.xyx + vec3(0,2,4));\n\n        //distance/time varying pixel colour gradient\n        vec3 col = palette(length(uv0) + myTime + (vol*4.)); //* (i*0.01));\n\n        //time based distance with modifiers for speed, width, and number of rings\n        dist = sin((dist - (myTime * speed)) * ringmultiplier * 2.0) / ringwidth;\n\n        //absolute the distance to invert negative values\n        dist = abs(dist);\n\n        //take the inverse of the distance (effectively inverts what gets coloured in);\n        dist = pow(0.00015 / dist,1.05);\n\n        //smoothstep colour to give clean edges.\n        col = col * (smoothstep(0.0, 0.5-smoothing, dist) * noise)*2.0;\n\n        outCol += col + dist;\n    }\n    \n    // Output to screen\n    fragColor = vec4(outCol,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}