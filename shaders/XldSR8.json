{
    "Shader": {
        "info": {
            "date": "1478106424",
            "description": "First of many uploads, porting the work I've done on Synesthesia into Shadertoy. Actually written for \"SSF\" (Synesthesia Shader Format) for user inputs and audio reactivity. As such the code has some quirks. Feel free to ask for any clarifications.",
            "flags": 32,
            "hasliked": 0,
            "id": "XldSR8",
            "likes": 25,
            "name": "Glitch-Syn",
            "published": 3,
            "tags": [
                "glitch",
                "audioreactive",
                "synesthesia",
                "pixelsort",
                "ssf"
            ],
            "usePreview": 1,
            "username": "Meebsie",
            "viewed": 1918
        },
        "renderpass": [
            {
                "code": "/** \n* Thanks to the authors who created the noise algorithms used here \n* (Iq, Ashima, nameless talent from GLSLSandbox). \n* Triangles originated here, thanks to XOR for his permission: https://www.shadertoy.com/view/Mtj3Rh\n*/\n\n\n/**\n * Clusters values into larger \"Pixels\"\n */\nfloat _pixelate(float x, float amount) {\n  return floor(x*amount)/amount;\n}\nvec2 _pixelate(vec2 x, float amount) {\n  return floor(x*amount)/amount;\n}\nvec3 _pixelate(vec3 x, float amount) {\n  return floor(x*amount)/amount;\n}\n\nfloat _rand(float seed){return fract(sin(seed) * 43758.5453123);}\nfloat _rand(vec2 seed) {\n  return fract(sin(dot(seed, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat _noise(float seed){\n  float _floor = floor(seed);\n  float _remainder = fract(seed);\n  return mix(_rand(_floor), _rand(_floor + 1.0), _remainder);\n}\n\nfloat _noise(vec2 seed) {\n  const vec2 d = vec2(0.0, 1.0);\n  vec2 _floor = floor(seed);\n  vec2 _remainder = smoothstep(vec2(0.0), vec2(1.0), fract(seed));\n  return mix(mix(_rand(_floor), _rand(_floor + d.yx), _remainder.x), mix(_rand(_floor + d.xy), _rand(_floor + d.yy), _remainder.x), _remainder.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rgbZoomAmt = pow(sin(fract(iTime*2.0)+iTime)*cos(iTime)*1.0,2.0)*0.25;\n    float time = iTime;\n    float syn_FadeInOut = 1.0;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 col;\n    vec2 posBL = uv;\n\n    float rgbZoomAmtMod = rgbZoomAmt;\n    rgbZoomAmtMod *= _noise(_pixelate(uv.y,50.0)*100.0);\n    vec2 modifiedCenter = vec2(cos(time), sin(time))*0.5;\n    vec2 rPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmtMod*0.31*sin(time*0.23)))+modifiedCenter;\n    vec2 gPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmtMod*0.398*sin(time*0.2)))+modifiedCenter;\n    vec2 bPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmtMod*0.33*sin(time*0.3)))+modifiedCenter;\n\n    rPos = abs(rPos);\n    if (rPos.x >= 0.9999){\n      rPos.x = 0.9999-rPos.x;\n    }\n    if (rPos.y >= 0.9999){\n      rPos.y = 0.9999-rPos.y;\n    }\n\n    gPos = abs(gPos);\n    if (gPos.x >= 0.9999){\n      gPos.x = 0.9999-gPos.x;\n    }\n    if (rPos.y >= 0.9999){\n      gPos.y = 0.9999-gPos.y;\n    }\n\n    bPos = abs(bPos);\n    if (bPos.x >= 0.9999){\n      bPos.x = 0.9999-bPos.x;\n    }\n    if (rPos.y >= 0.9999){\n      bPos.y = 0.9999-bPos.y;\n    }\n\n    col.r = texture(iChannel0, rPos).r;\n    col.g = texture(iChannel0, gPos).g;\n    col.b = texture(iChannel0, bPos).b;\n\n    col *= syn_FadeInOut;\n    \n    fragColor = vec4(col,1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Data only pass, \n\nfloat triggerNewImg(){\n  float trigger = 0.0;\n  /*if(constant_jumps>0.5){\n      if ((syn_BPMSin2/syn_BPMConfidence >= 0.45)&&(syn_BPMSin2/syn_BPMConfidence <= 0.55)){\n        trigger = 1.0;\n      }\n    } else {\n      if (syn_OnBeat > 0.9){\n        trigger = 1.0;\n      }\n    }*/\n  if(fract(iTime*0.5)<0.05){\n    trigger = 1.0;\n  }\n  return trigger;\n}\n\nvec4 dataPass(){\n    vec4 oldTimeData = texture(iChannel0, vec2(0,0));\n    if (iFrame <= 5){\n        oldTimeData = vec4(0.0);\n    }\n    float timeSinceReset = oldTimeData.r;\n    timeSinceReset += 1.0/60.0;\n    if (triggerNewImg() == 1.0){\n      timeSinceReset = 0.0;\n    }\n\n    float incrementOnReset = oldTimeData.g;\n    if (triggerNewImg() == 1.0){\n      incrementOnReset += 1.0;\n    }\n    // oldTimeData += pow(vec4(syn_BassLevel, syn_MidLevel, syn_MidHighLevel, syn_HighLevel),vec4(2.0))*0.1;\n    return vec4(timeSinceReset, incrementOnReset, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = dataPass();\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define syn_BassPresence 0.5\n#define syn_HighPresence 0.5\n\nfloat rando(float n)\n{\n  return fract(abs(sin(n*55.753)*367.34));   \n}\nfloat rando(vec2 n)\n{\n    return rando(dot(n,vec2(2.46,-1.21)));\n}\nfloat cycle(float n)\n{\n  return cos(fract(n)*2.0*3.141592653)*0.5+0.5;\n}\nvec4 genTris(vec2 _uv, float size, vec2 motion)\n{\n  float a = radians(60.0);\n  float zoom = size;\n  vec2 c = (_uv*iResolution.xy + motion * vec2(sin(a),1.0));\n  \n  c = ((c+vec2(c.y,0.0)*cos(a))/zoom)+vec2(floor((c.x-c.y*cos(a))/zoom),0.0);\n  \n  float n = cycle(rando(floor(c*4.0))*0.2+rando(floor(c*2.0))*0.3+rando(floor(c))*0.5+iTime*0.125);\n  \n  float briTris = 0.1*exp(0.03*(pow(n,-1.)));\n\n  vec4 finalCol = vec4(0.0, n*(1.0-syn_BassPresence), pow(n, 2.0), 1.0)+vec4(0.6,0.3,0.0,0.0)*pow(briTris,2.0-syn_HighPresence*1.5);\n\n\n  return clamp(finalCol,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = genTris(fragCoord.xy/iResolution.xy, 46.0, vec2(sin(iTime)*96.0*3.0, cos(iTime)*96.0)*3.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define logo_on 1.0\n#define movingLines 0.0\n#define linesOn 0.0\n#define invert_white 0.0\n#define auto_slicer 1.0\n\n#define syn_FadeInOut 1.0\n#define syn_Presence 0.8\n#define PI 3.14159\n#define syn_Time iTime/2.0\n#define syn_BassTime iTime/2.0\n\n/**\n * Clusters values into larger \"Pixels\"\n */\nfloat _pixelate(float x, float amount) {\n  return floor(x*amount)/amount;\n}\nvec2 _pixelate(vec2 x, float amount) {\n  return floor(x*amount)/amount;\n}\nvec3 _pixelate(vec3 x, float amount) {\n  return floor(x*amount)/amount;\n}\n\nfloat _rand(float seed){return fract(sin(seed) * 43758.5453123);}\nfloat _rand(vec2 seed) {\n  return fract(sin(dot(seed, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n/**\n* Rotates a vector around the point (0, 0)\n*/\nvec2 _rotate(vec2 v, float t) {\n    mat2 T = mat2(cos(t), -sin(t), sin(t), cos(t));\n    return T*v;\n}\n\n/**\n * Creates 1D, 2D or 3D noise based on a seed\n * @name _noise\n * @param  {float|vec2|vec3} seed Random number seed\n * @returns {float} Noise in form of float\n */\nfloat _noise(float seed){\n  float _floor = floor(seed);\n  float _remainder = fract(seed);\n  return mix(_rand(_floor), _rand(_floor + 1.0), _remainder);\n}\n\n\nfloat _noise(vec2 seed) {\n  const vec2 d = vec2(0.0, 1.0);\n  vec2 _floor = floor(seed);\n  vec2 _remainder = smoothstep(vec2(0.0), vec2(1.0), fract(seed));\n  return mix(mix(_rand(_floor), _rand(_floor + d.yx), _remainder.x), mix(_rand(_floor + d.xy), _rand(_floor + d.yy), _remainder.x), _remainder.y);\n}\n\n#define _NUM_OCTAVES 5\n/**\n * Creates 1D, 2D or 3D smoothed fractal noise\n */\n float _fbm(float position) {\n   float v = 0.0;\n   float a = 0.5;\n   float shift = float(100);\n   for (int i = 0; i < _NUM_OCTAVES; ++i) {\n     v += a * _noise(position);\n     position = position * 2.0 + shift;\n     a *= 0.5;\n   }\n   return v;\n }\n\n float _fbm(vec2 position) {\n   float v = 0.0;\n   float a = 0.5;\n   vec2 shift = vec2(100);\n   // Rotate to reduce axial bias\n   mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n   for (int i = 0; i < _NUM_OCTAVES; ++i) {\n     v += a * _noise(position);\n     position = rot * position * 2.0 + shift;\n     a *= 0.5;\n   }\n   return v;\n }\n/*\n float _fbm(vec3 position) {\n   float v = 0.0;\n   float a = 0.5;\n   vec3 shift = vec3(100);\n   for (int i = 0; i < _NUM_OCTAVES; ++i) {\n     v += a * _noise(position);\n     position = position * 2.0 + shift;\n     a *= 0.5;\n   }\n   return v;\n }*/\n\nfloat triggerNewImg(){\n  float trigger = 0.0;\n  /*if(constant_jumps>0.5){\n      if ((syn_BPMSin2/syn_BPMConfidence >= 0.45)&&(syn_BPMSin2/syn_BPMConfidence <= 0.55)){\n        trigger = 1.0;\n      }\n    } else {\n      if (syn_OnBeat > 0.9){\n        trigger = 1.0;\n      }\n    }*/\n  if(fract(iTime*0.5)<0.05){\n    trigger = 1.0;\n  }\n  return trigger;\n}\n\n\nvec3 hash3( vec2 p ) //By iq !\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n           dot(p,vec2(269.5,183.3)), \n           dot(p,vec2(419.2,371.9)) );\n  return fract(sin(q)*43758.5453);\n}\n\nvec4 dripGlitch(vec2 fragCoord) {\n  vec2 _uv = fragCoord.xy/iResolution.xy;\n  vec2 _uvc = fragCoord / iResolution.y - vec2(iResolution.x/iResolution.y/2.0, 0.5);\n  float TIME = iTime;\n    \n  vec4 timeData = texture(iChannel0, vec2(0,0));\n  float timeSinceReset = timeData.r;\n  float incrementOnReset = timeData.g;\n\n  // timeSinceReset = slice;\n\n  float timeModderY = smoothstep(0.0,0.25,timeSinceReset)-smoothstep(0.35, 1.0,timeSinceReset);\n  timeModderY = pow(timeModderY, 1.5);\n  timeModderY *= 0.0025;\n\n  float timeModderX = smoothstep(0.2,2.0,timeSinceReset)-smoothstep(2.0, 3.0,timeSinceReset);\n  // timeModderX += timeSinceReset*0.1;\n  timeModderX = pow(timeModderX, 1.5);\n  timeModderX *= 0.0005;\n\n  float slicerAngleCor = 0.0;\n  /*if (auto_slicer < 0.5){\n    slicerAngleCor = slicerAngle;\n  }\n\n  vec2 rotPos = _rotate(_uv, slicerAngleCor*PI); */\n   vec2 rotPos = _uv;\n\n\n  vec4 refreshImg = texture(iChannel1, _uv);\n\n  float columns = _pixelate(rotPos.x, 100.0);\n  columns = (-0.5+_rand(columns+incrementOnReset))*2.0;\n\n  float rows = _pixelate(rotPos.y, 500.0);\n  rows = (-0.5+_rand(rows+incrementOnReset))*2.0;\n\n  vec2 posModder = vec2(rows*timeModderX,columns*timeModderY);\n\n  vec2 constantX = vec2(rows*0.0005*clamp(timeSinceReset-2.0, 0.0, 1.0) ,0.0)*syn_FadeInOut;\n\n  vec2 drippedPos = _rotate(_uv, slicerAngleCor*PI)+(posModder)*(0.2+syn_Presence*1.5)+constantX;\n\n  drippedPos = _rotate(drippedPos, -slicerAngleCor*PI);\n\n  vec4 oldDripImg = texture(iChannel2, _uv);\n  vec4 newDripImg = texture(iChannel2, drippedPos);\n\n  if (length(oldDripImg)>length(newDripImg)){\n    newDripImg = oldDripImg;\n  }\n    #ifdef USER_IMAGE\n    vec4 logoImg = _loadCorrectedImageAsMask(syn_UserImage, syn_UserImage_size);\n    vec4 logoImgColored = _loadCorrectedImage(syn_UserImage, syn_UserImage_size, vec2(0.0,0.005));\n    #else\n    vec4 logoImg = vec4(step(max(abs(_uvc.x*_pixelate(_fbm(TIME*10.0+_uv.y*100.0), 10.0)), abs(_uvc.y*_pixelate(_fbm(TIME*10.0+_uv.x*100.0), 10.0))),0.05));\n    vec4 logoImgColored = vec4(step(max(abs(_uvc.x*_pixelate(_fbm(TIME*10.0+_uv.y*100.0), 10.0)), abs(_uvc.y*_pixelate(_fbm(TIME*10.0+_uv.x*100.0), 10.0))),0.05));\n    #endif\n\n  if (triggerNewImg()==1.0){\n    newDripImg = refreshImg;\n    vec2 posModded = _uv*0.8+normalize(clamp(_uvc,0.1,1.0))*sin(TIME*0.1)*0.5+0.5*vec2(sin(TIME*0.25),cos(TIME*0.33));\n    vec4 picture = texture(iChannel3, posModded);\n    if (mod(incrementOnReset,2.0)==0.0){\n      picture = 1.0-texture(iChannel3, posModded);\n    }\n    picture = vec4(_pixelate(picture.r,10.0),_pixelate(picture.g,10.0),_pixelate(picture.b,10.0),_pixelate(picture.a,10.0));\n\n    newDripImg = min(newDripImg,pow(picture,vec4(3.0)));\n    newDripImg += pow(newDripImg, vec4(0.5)).rgba*0.2;\n\n\n    if (invert_white >= 0.5){\n      logoImg = 0.9-logoImg;\n      logoImgColored = 0.9-logoImgColored;\n    }\n    if (logo_on >= 0.5){\n      newDripImg = max(newDripImg*1.3, logoImg*0.9);\n      newDripImg += logoImgColored;\n      // newDripImg -= tritex*syn_HighHits*pow(logoImg,vec4(5.0))*20.0;\n    }\n  }\n    \n  return newDripImg;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 _uv = fragCoord.xy/iResolution.xy;\n    fragColor = dripGlitch(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Useless for now, will be put to use later.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec4 backbuffer = texture(iChannel0, fragCoord.xy/iResolution.xy);\n  fragColor = backbuffer;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}