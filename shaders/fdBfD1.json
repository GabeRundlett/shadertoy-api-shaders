{
    "Shader": {
        "info": {
            "date": "1646138746",
            "description": "Another Aliens-themed shader, motivated by me watching this clip from the movie: https://youtu.be/3HbkcRAQhew",
            "flags": 0,
            "hasliked": 0,
            "id": "fdBfD1",
            "likes": 25,
            "name": "Aliens (Scanner scene)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "glow",
                "alien",
                "laser",
                "movie",
                "glint",
                "frost",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 4769
        },
        "renderpass": [
            {
                "code": "// 'Aliens (Scanner scene)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/fdBfD1 (YouTube: https://youtu.be/yimsQfjK8es)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Another Aliens-themed shader, motivated by me watching\n// this clip from the movie: https://youtu.be/3HbkcRAQhew\n// I try to add add something new each time I make a shader,\n// and this time it was the 'frost' effect on the cryo pod.\n// Definitely an effect I want to come back to in the future!\n//\n// Tricks to get the performance:\n//   - No 'max dist' raymarch check needed, as the room is enclosed.\n//   - Reflective helmet glass and laser effect calculated using\n//     ray-sphere ray-plane intersections, allowing me to keep\n//     the raymarching loop simple.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n//\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t.0015\n#define MAX_STEPS\t120.0\n#define SHADOW_STEPS\t30.0\n\n#define LIGHT_RGB\tvec3(0.1, 0.6, 1.4)\n#define FOG_RGB\tvec3(0.03, 0.04, 0.05)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0.0, 1.0, a)\n\nfloat t,\n      g = 0.0;\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat fbm(vec3 p) {\n\tfloat a = 0.0,\n\t      b = 0.5, i;\n\tfor (i = Z0; i < 4.0; i++) {\n\t\ta += b * n31(p);\n\t\tb *= 0.5;\n\t\tp *= 2.0;\n\t}\n    \n\treturn a * 0.5;\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\nfloat max2(vec2 v) { return max(v.x, v.y); }\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nbool intPlane(vec3 p0, vec3 n, vec3 ro, vec3 rd, out float d) {\n\tfloat denom = dot(n, rd);\n\tif (abs(denom) > 0.0001) {\n\t\td = dot(p0 - ro, n) / denom;\n\t\treturn d >= 0.0;\n\t}\n\n\treturn false;\n}\n\nbool intSph(vec3 p0, float r, vec3 ro, vec3 rd, out float d) {\n\tvec3 oc = ro - p0;\n\tfloat a = dot(rd, rd),\n          b = dot(oc, rd),\n          c = dot(oc, oc) - r * r,\n          e = b * b - a * c;\n\tif (e <= 0.0) return false;\n    d = b > 0.0 ? (-b + sqrt(e)) / a : (-b - sqrt(e)) / a;\n    return true;\n}\n\nmat2 rot(float a) {\n\t// Thanks Fabrice.\n\treturn mat2(cos(a + vec4(0, 11, 33, 0)));\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat hatch(vec3 p, float ex) {\n\tfloat d = box(p, vec3(2, 2.5, ex + .3));\n\tp.xy *= rot(3.1415 / 4.);\n\treturn max(d, box(p, vec2(2.7, 2.7 + ex).xxy));\n}\n\n#define LP\tvec3(0, -0.4, 3.5)\n\nvec3 rigP() {\n\tfloat tt = t;\n\tif (tt > 47.0) tt = 16.0 - tt + 47.0;\n\treturn vec3(0, 0.5, 6) +\n\t  S(vec3(0.5, 0.7, 1), vec3(0.0, 0.2, 0.3), vec3(S(1.0, 13.0, tt))) * vec3(-2.4, 1.6, 5);\n}\n\nfloat map(vec3 p) {\n\t// Walls.\n\tfloat d = abs(box(p, vec3(8, 4, 10)) - 0.5) - 0.5;\n\td = max(d, -hatch(p - vec3(0, 0, 8), 3.));\n\td = min(d, 20. - p.z);\n\n\t// Wall posts.\n\tvec3 tp = p;\n\ttp.x = abs(tp.x);\n\ttp.xz -= vec2(7, 9);\n\td = min(d, box(tp, vec3(1. + p.y * 0.15, 4, 0.5)));\n\td = min(d, abs(p.y) * -0.15 - tp.x);\n\n\t// Hatch.\n\ttp = p - vec3(0.8, -3.4, 7);\n\ttp.yz *= rot(1.4);\n\ttp.xy *= rot(0.2);\n\td = min(d, hatch(tp, 0.0));\n\n\t// Laser rig.\n\ttp = p - rigP();\n\td = min(d, cyl(tp, vec2(0.05, .1))); // Nozzle.\n\ttp.yz += vec2(0.15, -1.0);\n\td = min(d, box(tp, vec3(0.3, 0.3, 1))); // Barrel.\n\td = min(d, box(tp - vec3(0, 0.15, 0), vec3(0.25, 0.25, 0.9))); // Heat sinks.\n\ttp.y += 0.3;\n\td = min(d, max(box(tp, vec3(0.4, 0.45, 0.4)), -box(tp, vec3(0.3, 0.4, 0.5))));\n\ttp.xz += vec2(.5, 0.4);\n\td = min(d, cap(tp.yzx, 1.2, S(0.0, -0.1, tp.y - 0.8) * 0.04 + .02));\n\ttp -= vec3(0.0, -0.24, 2.4);\n\td = min(d, max(box(tp, vec3(0.2, 0.15, 2)), -tp.x - tp.z - 2.)); // Front support.\n\tvec3 mp = tp.zyx + vec3(1.5, 0, 0.22);\n\tmp.y = abs(mp.y) - 0.06;\n\td = min(d, cap(mp, 2., .1)); // Pipes.\n\ttp.z -= 4. - 1.8;\n\ttp.xz *= rot(1.);\n\ttp.z -= 1.8;\n\td = min(d, box(tp, vec3(0.2, 0.3, 2))); // Rear support.\n    \n\t// Panel-thing.\n\ttp = p + vec3(0, 3, 2.5);\n\ttp.xz = abs(tp.xz);\n\ttp.z -= 3.;\n\td = min(d, max(box(tp, vec3(3, 1.5, 1)), tp.x + tp.y * 0.5 - 3.2));\n\n\t// Lighty-boxes.\n\ttp -= vec3(1.5, 2, -.2);\n\td = min(d, box(tp, vec3(0.6)));\n\ttp.x = abs(abs(tp.x) - 0.12 - .12) - 0.12;\n\ttp.y = abs(tp.y) - 0.12;\n\tfloat f = box(tp - vec3(0, 0, 0.58), vec3(0.06));\n\tg += S(0.8, 0.96, p.z) * 0.003 / (0.003 + abs(f)) * S(0.8, 0., f);\n\td = min(d, f);\n\n\t// Helmet table.\n\ttp = p + vec3(0.5, 2, -2);\n\td = min(d, box(tp + vec3(0, 1.4, 0), vec3(1, 1, 0.5)));\n\n\t// Helmet.\n\tfloat l = length(tp);\n\tf = abs(l - 0.47) - 0.02;\n\tf -= step(abs(abs(tp.z) - .1), 0.05) * 0.006 + step(abs(tp.y), 0.08) * 0.01;\n\td = min(d, max(f, -box(tp + vec3(0.6, -0.3, 0), vec3(0.5))));\n\n\t// Pod.\n\ttp = p + vec3(4.2, 3.2, -1);\n\tl = S(2., 0.0, tp.z) * 0.5 + S(1.2, 2., tp.z) * 0.4;\n\tfloat b = box(tp, vec3(0.6, 0.6, 2));\n\tf = mix(cyl(tp + vec3(0, tp.z * 0.1, 0), vec2(0.7, 2)), b - 0.2, l);\n\treturn min(d, mix(b - 0.15, f, S(.6, .65, tp.y + 0.5)));\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * 0.4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat s = 1.,\n\t      t = .02, d,\n          mxt = length(p - lp);\n\tvec3 ld = normalize(lp - p);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = map(t * ld + p);\n\t\ts = min(s, 15. * d / t);\n\t\tt += d;\n\t\tif (mxt - t < 0.5 || s < 0.001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick ambient occlusion.\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p) / h); }\n\nfloat fog(float d) { return exp(d * d * (t < 16. ? -0.01 : -0.02)); }\n\nfloat L_On() { return 0.01 + step(9.5, t) * step(t, 51.0); }\n\nfloat dtc(vec2 p) {\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return 0.0;\n\tif (step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.)\n\t\treturn 0.6;\n\n\tfloat dc = step(.5, -p.x), f;\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\treturn step(0.1, dc);\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n) {\n\tvec3 ld = normalize(LP - p),\n\t     c = vec3(0.25, 0.05, 0.04);\n         \n    c += dtc((p.xy + vec2(4, -0.8)) * 0.5) * 0.04 * step(0.0, p.z);\n\n\t// Scanner.\n\tfloat s = step(5., p.z);\n\tc.rg += vec2(.5, .1) * step(max2(abs(p.xy)), 1.8 * s);\n\n\t// Helmet.\n\tfloat f = .12 * step(length(p - vec3(-0.5, -2, 2)), .502);\n\tc = mix(c, 1. / LIGHT_RGB, f);\n\tn.yz -= n31(p * 40.) * .12 * .3 * (1. - s);\n\n\t// Pod frost.\n\tif (p.x < -3.5 && abs(p.z) < 4. && s < 1.0) {\n\t\tvec3 pp = p * vec3(105, 86, 53);\n\t\tfloat glint = n21(pp.xz) * (0.5 + 0.5 * h21(pp.yx));\n\t\tc = mix(c, 1. / LIGHT_RGB, S(0.85, 1., glint) + 0.13);\n\t}\n\n\tfloat ao = mix(aof(p, n, .2), aof(p, n, 2.), .7),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (0.3 + 0.7 * shadow(p, LP)) * (0.3 + 0.7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.) * 2.,\n\t      fre = S(.7, 1., 1. + dot(rd, n)) * 0.2,\n          lig = l1 + l2 * ao;\n\treturn mix(lig * c * LIGHT_RGB, FOG_RGB, fre) * L_On();\n}\n\nvec3 beam(vec3 p, vec3 ro, vec3 rd, float d, float plane) {\n\tvec3 lp = rigP() - vec3(0, 0, 0.1),\n         pn = vec3(1, 0, 0);\n\tfloat r = 0.0;\n\tif (t < 35.0)\n        r = mix(-1.8, 0.6, sin(max(0.0, t - 16.) * 0.15) * 0.5 + 0.5);\n\telse if (t < 47.0) {\n\t\tr = mix(-0.5, 0.35, sin(max(0.0, t - 35.) * 0.3) * 0.5 + 0.5);\n\t\tlp.x -= 3.5;\n\t}\n\n\tpn.xz *= rot(r);\n\tfloat u;\n\tif (intPlane(lp, pn, ro, rd, u) && u < d) {\n\t\tvec3 op = p;\n\t\tp = ro + rd * u;\n\t\tfloat tt = step(t, 16.0) + step(47., t);\n\t\tif (abs(p.y - lp.y) * tt < lp.z - p.z) {\n\t\t\tvec3 q = p * vec3(0.2, 2.5, 2.5);\n\t\t\tq.yz = vec2(fbm(q), fbm(q + vec3(0.23, 1.23, 4.56)) + t * 0.04);\n\t\t\tfloat edge = S(0.02, 0.0, abs(length(p - op) - 0.01));\n\t\t\tedge += 0.5 * tt * max3(S(vec3(0.02), vec3(0), abs(p.y - 0.5 - sin(t + vec3(0, 3, 5)) * (lp.z - p.z))));\n\t\t\tfloat beam = 0.5 * min(edge, 1.0);\n\t\t\tbeam += fbm(p + q * 10.) * plane;\n\t\t\tbeam *= S(4.5, -3.0, op.y) * fog(u * 1.3);\n\t\t\treturn beam * shadow(p, lp) * vec3(0.3, 1.2, 2.4);\n\t\t}\n\t}\n\n\treturn vec3(0);\n}\n\nfloat addFade(float a) { return min(1.0, abs(t - a)); }\n\nvec3 scene(vec3 ro, vec3 rd) {\n\t// March the scene.\n\tfloat d = 0.0, i, h;\n\tvec3 p = ro, col;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\th = map(p);\n\t\tif (abs(h) < MIN_DIST) break;\n\t\td += h;\n\t\tp += h * rd;\n\t}\n\n\tcol = mix(FOG_RGB, g * vec3(0.76, 0.16, .08) + lights(p, rd, N(p, d)), fog(d));\n\n\t// Ground fog.\n\tcol = mix(FOG_RGB, col, S(-4., -3.5, p.y - abs(p.x * 0.1)));\n\tfloat ns = fbm(p + t * vec3(0.2, -0.4, 0.1)) * 5.;\n\tcol += mix(0.5, 1.0, L_On()) * FOG_RGB * ns * (0.1 + S(-2., -4., p.y + ns * 0.6 - 2. * step(6., p.z)));\n\n\t// LAZERS!\n\tif (L_On() > 0.1) {\n\t\tcol += beam(p, ro, rd, d, 0.25 + 0.75 * step(t, 16.));\n\n\t\t// Helmet glass.\n\t\tfloat u;\n\t\tif (intSph(vec3(-0.5, -2, 2), 0.45, ro, rd, u) && u < d) {\n\t\t\tp = ro + rd * u;\n\t\t\tvec3 n = normalize(p - vec3(-0.5, -2, 2));\n\t\t\tcol *= 0.6; // Darken a bit.\n            \n            // Add highlights.\n\t\t\tcol += pow(sat(dot(n, vec3(-0.1, 1, 0))), 10.0) * 0.1;\n\t\t\tcol += S(0.5, 1.0, 1. + dot(rd, n)) * 0.05;\n\t\t\tcol += pow(sat(dot(n, vec3(-1, 1, 1)) - 0.95), 15.0) * 5.;\n\t\t\tcol += beam(p, ro, rd, u, 0.1);\n\n\t\t\t// Reflect button lights.\n\t\t\tg *= 0.28;\n\t\t\th = map(p + n);\n\t\t\tcol += g * vec3(76, 16, 8);\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tt = mod(iTime, 61.);\n\tfloat fade = addFade(0.0) * addFade(16.0) * addFade(35.0) * addFade(47.0) * addFade(61.0);\n\n    // Door/scanner entry.\n\tvec3 ro = vec3(-2, 0, 2),\n         lookAt = vec3(0, -0.9 * S(16.0, 0.0, t), 10);\n\tif (t < 47.0) {\n\t\tif (t > 35.0) {\n\t\t\t// Pod scan.\n\t\t\tro = vec3(-5, -2, 3);\n\t\t\tlookAt = vec3(2, -6, -5);\n\t\t}\n\t\telse if (t > 16.0) {\n\t\t\t// Helmet/room scan.\n\t\t\tro = vec3(-1.6, -1.4, 3) + S(16., 30., t) * vec3(-0.8, 0.2, 0.8);\n\t\t\tlookAt = vec3(4, -4, -10);\n\t\t}\n\t}\n\n    // Keep camera moving a tad.\n\tro.x += 0.1 * sin(t * 0.3);\n    \n\tvec3 col = scene(ro, rayDir(ro, lookAt, uv));\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = vec4(pow(max(vec3(0), col), vec3(.45)) * fade, 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}