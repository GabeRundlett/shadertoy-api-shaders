{
    "Shader": {
        "info": {
            "date": "1703097703",
            "description": "I wanted to exeperiment again with light raymarching and do pretty stuff with neon and reflections",
            "flags": 0,
            "hasliked": 0,
            "id": "lcfGDN",
            "likes": 10,
            "name": "Neon Party",
            "published": 3,
            "tags": [
                "reflection",
                "neon",
                "raynarching"
            ],
            "usePreview": 0,
            "username": "rcargou",
            "viewed": 157
        },
        "renderpass": [
            {
                "code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n\nvec3 getcol(float x1) {\n//return vec3(0.120,0.737,0.737);\n//return vec3(.0, 1., .0);\n//float x2= mod(iTime / 3., 7.) + 0.;\nfloat x2 = 0.;\nfloat x = fract(x1 / 1.);\n//x2=0.;\n    vec3 cols[7] = vec3[7] (pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) ),\n    pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) ),\n    pal( x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )\n    );\n    return mix( cols[int(x2)], cols[int(mod(x2, 7.)) + 1] , fract(x2));\n}\n\n//------------------------------------------------------------------\n#define ANIMATE\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat o2(){\nreturn 0.;\n#ifndef ANIMATE\nreturn 0.;\n#endif\n    return .5 + sin(iTime / 12.) * .5;\n}\n\nfloat o(){\n#ifndef ANIMATE\nreturn 1.;\n#endif\n//return 1.;\nreturn .5 + sin(iTime) * .5;\n}\n\nvec3 kal(vec3 p) {\nreturn p;\np = abs(p);\np.xy*=rotate2d(iTime / 8.);\np=abs(p);p.xy*=rotate2d(iTime / 18.);\np=abs(p);\nreturn p;\np.xy*=rotate2d(iTime / 1.);\n    p.y = abs(p.y);\n    p.x = abs(p.x);\n    p.xy*=rotate2d(iTime / 2.);\n        p.y = abs(p.y);\n    p.x = abs(p.x);\n    p.x-=.3;\n    p.xy*=rotate2d(-iTime / 4.);\np.x-=.3;\n    p.y = abs(p.y);\n    p.x = abs(p.x);\n    p.xy*=rotate2d(iTime / 6.);\n//p.x-=.1;\n    p.y -= .2;\n    p.y+=.1;\n    return p;\n}\nvec3 neon_col(float id) {\n    return getcol(id);\n    vec3 c =  .5*pal( id, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    return normalize(c);\n}\n\nfloat mapPillars(in vec3 p) {\n    float r = 15.;\n    \n    float r3 = 15.;\n    float r2=.4;\n    vec3 p2  = p;\n    p2.z += 5.;\n    float id = hash( floor(p.z/r) *r );\n    p.xy *= rotate2d(iTime + id * 6.28);\n\n    p.z = mod(p.z, r) - r / 2.;\n    p2.z = mod(p2.z, r3) - r3 / 2.;\n    \n       float ds =  sdTorus(p2.xzy, vec2(.4, .05));\n \n    p.x = mod(p.x, r2) - r2/2.;\n    return min(length(p.xz) -.05, ds);\n}\n\nfloat mapBalls(in vec3 p, out vec3 lightCol) {\n    return 1e10;\n    float r = .5;\n    p.z += iTime * 6.;\n    vec3 id = floor(p/r) *r;\n    float h = hash( hash(id.x) + hash(id.y)+hash(id.z) );\n    float s = .02;\n    p = mod(p, r) - r/2.;\n    lightCol = 2.*pal( hash(h), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if (h < .9)\n        return 1.;\n    return length(p) - s;\n}\nfloat mapHexagonLight(in vec3 p, out vec3 lightCol) {\n    float r = 5.;\n    p.y-=iMouse.x/200.;\n    float t = p.z;\n    \n    lightCol = vec3(1., 0., 0.);\n    float id = hash( floor( (p.z + -15.*iTime) / r) * r); // 5\n    float a = 3.14 / 6.;\n    p.z = mod(p.z,r)-r/2.;\n    lightCol = neon_col(id * 12.);\n        float h = mix(.66, 1.05, o());\n    float s = .02;\n    \n    vec2 sh = vec2(s, h);\n    float d1 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    \n    float d2 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    float d3 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    float d4 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    float d5 = sdCylinder(p, sh);\n    p.xy *= rotate2d(a);\n    float d6 = sdCylinder(p,sh);\n    float u = min (min(d1, d3), min( min(d2, d6), min(d4, d5)) );\n    \n    return u;\n}\nfloat mapLight(in vec3 p, out vec3 lightCol) {\n   // return mapHexagonLight(p,lightCol);\n  float r = 5.;\n  float t = p.z;\n  lightCol = vec3(1., 0., 0.);\n      float id = hash( floor( (p.z + -15.*iTime) / r) * r); // 5\n  //p.xy *= rotate2d(p.z + iTime + id);\n//p.xy *= 5.5;\n    p.z = mod(p.z,r)-r/2.;\n    lightCol = neon_col(id * 12.);\n//    return length(p) - .1;\n    float a = mix(3.15, 2.6, o());\n    \n    float h = mix(.66, 1.05, o());\n    float s = .02;\n    float ox = mix(.65, .5, o());\n    float of = .81;\n    float of2 = 0.196;\n    vec2 sh = vec2(s, h);\n    float d1 = sdCylinder(p.yxz + vec3(-of, 0., 0.), sh);\n    float d4 = sdCylinder(p.yxz + vec3(.45 + o() / 1., 0., 0.), sh);\n    vec3 p2 = p;\n    p.xy *= rotate2d(a);\n    float d2 = sdCylinder(p.xyz + vec3(-ox, of2, 0.), sh);\n    p2.xy *= rotate2d(-a);\n    float d3 = sdCylinder(p2.xyz + vec3(ox, of2, 0.), sh);\n\n    float dt= min(min(d4, d2), min(d1, d3));\n    return dt;\n    float ds = sdTorus(p.xzy, vec2(.9, .01) );\n    return min(ds, dt);\n    return mix(dt, ds, sin(iTime) * .5 + .5);\n   /*\n        pos.y *= -1.;\n    pos.y+=.2;\n//    float a = 2.1;\n    float a = mix(1.55, 2.1, o());\n\n    float d4 = sdCylinder(pos * vec3(1., -1., 1.) + vec3(0., 0.6 * o(), 0.),vec2(.02, 1.9));\n    float d1 = sdCylinder(pos,vec2(.02, 1.9));\n    vec3 p2 = pos;\n    pos.xy *= rotate2d(a);\n    float d2 = sdCylinder(pos,vec2(.02, 1.9));\n    p2.xy *= rotate2d(-a);\n    float d3 = sdCylinder(p2,vec2(.02, 1.9));\n    return min(d1, min(d2, min(d3, d4))) ;*/\n}\n\n\nvec3 get_light(in vec3 p, out float l, bool rm) {\n    vec3 lc;\n    float s;\n    p = kal(p);\n    s = mapLight(p, lc);\n    l=s;\n    if (rm) {\n        pow(s, 3.);\n        return lc * (.0002 / (.001 + s *s));\n    }\n    return lc * (.2 / (.001+s * s * s * s));\n}\n\nvec3 rmLight(in vec3 ro, vec3 rd, float d) {\n    vec3 out_col = vec3(0.);\n//return vec3(0.);\n    float t = 0.;\n    float oui = 0.;\n    for (int i = 0; i < 40; ++i) {\n        vec3 p = ro + rd * t;\n        p = kal(p);\n        //if (d<t)\n        out_col += get_light(p,oui, true);\n        vec3 lb;\n        //float ii = mapBalls(p, lb);\n       // out_col += lb * (.0005 / (.001 + ii*ii));\n        t += .15;\n    }\n    return vec3(out_col);\n}\n\nfloat mapPlan(in vec3 pos, out float mat) {\n    pos.y-=.3;\n  //  pos.y += sin(pos.z * 2.) / 112.;\n    float d1 = pos.y + 1.;\n    vec3 p2 = pos;\n    float r = .4;\n    float h = .05;\n    vec2 id = floor(pos.xz / r) * r;\n    float ha = hash(id.x + id.y);\n    mat = ha < .7 ? 0. : 1.;\n    p2.x = mod(pos.x, r) - r / 2.;\n    float d2 = abs(p2.x);\n    d2 = max(d2, abs(p2.y+1.) - h );\n   \n    vec3 p3 = pos;\n    p3.z = mod(pos.z, r) - r / 2.;\n    float d3 = abs(p3.z);\n    d3 = max(d3, abs(p3.y+1.) - h );\n    return min(d1,min(d2, d3));\n}\n\n\n\nfloat mapTrianglePlan(in vec3 pos, out float id) {\n   // pos.xy *= rotate2d(iTime / 4.);\n    pos.y *= -1.;\n    pos.y+=.2;\n  //  pos.z-=iTime * 2.;\n//    float a = 2.1;\n    float a = mix(1.55, 2.1, o());\n\n    float d4 = mapPlan(pos * vec3(1., -1., 1.) + vec3(0., 0.8 * o(), 0.) , id);\n    float d1 = mapPlan(pos, id);\n    vec3 p2 = pos;\n    pos.xy *= rotate2d(a);\n    float d2 = mapPlan(pos, id);\n    p2.xy *= rotate2d(-a);\n    float d3 = mapPlan(p2, id);\n    return min(d1, min(d2, min(d3, d4))) ;\n}\n\nfloat mapHexagon(in vec3 pos, out float id) {\n\n    float a = 3.14 / 3.;\n    float d1 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d2 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d3 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d4 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d5 = mapPlan(pos, id);\n    pos.xy *= rotate2d(a);\n    float d6 = mapPlan(pos, id);\n    return min (min(d1, d3), min( min(d2, d6), min(d4, d5)) );\n}\n\nfloat mapTunnel(in vec3 pos, out float id) {\n//    pos.xy *= rotate2d(pos.z + iTime);\n//    pos.xy *= rotate2d( mod(iTime, 6.28) * 1. );\n    float d1 =  mapHexagon(pos, id);\n    float d2 = mapTrianglePlan(pos, id);\n    return mix(d1, d2, smoothstep(-.1, .0, sin(pos.z / 12.)));\n}\nvec2 map( in vec3 pos, out vec3 lightCol, out float id)\n{\n    pos = kal(pos);\n    vec2 res = vec2( 1e10, 0.0 );\n    float d;\n    if ((res.x = length(pos) - .5f) < .0f)\n        res.y = 1.0f;\n    if ( (d = mapTunnel(pos, id) ) < res.x ) {\n        res.x = d;\n        res.y = 1.;\n    }\n    vec3 clight;\n    vec3 lightColtmp;\n    if ( (d = mapLight(pos, clight) ) < res.x ) {\n        res.x = d;\n        res.y = 2.;\n        lightCol = clight;\n    }\n    if ( (d = mapBalls(pos, clight) ) < res.x ) {\n        res.x = d;\n        res.y = 3.;\n        lightCol = clight;\n    }\n    if ( (d = mapPillars(pos) ) < res.x ) {\n        res.x = d;\n        res.y = 1.;\n    }\n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 lightCol, bool ref, out float mat)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    int num_step = ref ? 30 : 50;\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<num_step && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t , lightCol, mat);\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 a;\n    float b;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy,a,b ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ,a,b).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ,a ,b).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ,a,b).x );\n \n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 light_equation(vec3 p, vec3 n, vec3 albedo, vec3 lc, float l, float ref) {\n    vec3 light_pos = p + l * vec3(.0, .0, 1.);\n    float ndotl = max(.1, dot(-n, normalize(light_pos - p) ));\n    return (lc+.3) * albedo * 3. * abs(n.y);\n    return  (200.*lc*ndotl+1.5)*albedo;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(.0f);\n    vec3 lc;\n    float mat = 0.;\n    vec2 res = castRay(ro,rd, lc,false, mat);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 p = ro + rd * t;\n    vec3 p1 = p;\n    vec3 n = calcNormal(ro + rd*t);\n    //vec3 albedo = tex3D(iChannel0, ro+rd*t + .0*vec3(iTime, iTime, iTime)*n.yzx,n).xxx * vec3(.1, 11., 0.1);\n    vec3 albedo = pow(tex3D(iChannel1, ro+rd*t,n).xxx, vec3(2.));\n    float l;\n    bool le = false;\n    float ref_str = 1.;\n    vec3 amb = vec3(0.);\n    if (mat == 1. && false){ \n        ref_str = .1;\n       amb = vec3(.0, .3, .1) / 12.;\n        albedo *= 2.;\n   }\n    vec3 closest_lc = get_light(p, l, false);\n    if (res.x > .0f) {\n//    return closest_lc;\n        if (res.y == 1.) { \n            vec3 ref = reflect(rd, n);\n            res = castRay(p, ref, lc, true, mat);\n            p = p + ref * res.x;\n            n = calcNormal(p);\n            closest_lc = get_light(p, l, false) * ref_str;\n            le = true;\n        }\n        if (res.y == 2.) {\n            col = lc * 2.;\n        } else if (res.y == 3.){\n            col = lc;\n        }else {\n            col = amb + light_equation(p, n, albedo, closest_lc, l, 0.);\n            if (mat == 1.)\n                col *= 2.;\n        }\n    }\n//    col = vec3(0.);\n    col += 4.*rmLight(ro, rd, res.x);\n//  col = mix(col, vec3(0.), min(1., res.x * res.x / 500. ) );\n  \n   \treturn vec3(col);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, .0f, -4.0f + iTime * 4.);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = normalize( vec3(p.xy,2.) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);   \n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}