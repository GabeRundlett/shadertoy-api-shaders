{
    "Shader": {
        "info": {
            "date": "1671035826",
            "description": "个人练习",
            "flags": 0,
            "hasliked": 0,
            "id": "ddjSWc",
            "likes": 3,
            "name": "Coloring of objects",
            "published": 3,
            "tags": [
                "3dshadowcolour"
            ],
            "usePreview": 0,
            "username": "CodeJUN",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.14159265\n\nvec2 fixUV(in vec2 c)\n{\n    return(2.*c-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n}\n\nfloat sdfSphere(in vec3 p)//球体\n{\n    return length(p) - 0.8 ;\n}\n\nfloat sdfRect(in vec3 p, in vec3 b)//方形\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,-.1))+min(max(d.x,max(d.y,d.z)),0.);//奇奇怪怪的\n\n}\nfloat sdfBox(in vec3 p, in vec3 r)\n{\n    vec3 b=abs(p)-r;\n    return length(max(b,0.))+min(max(max(b.x,b.y),b.z),0.);\n\n}\n\n/*float sdfPlane(in vec3 p)\n{\n    return p.y;    \n}*/\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nvec2 map(in vec3 p)//合并\n{\n    vec2 d=vec2(sdfSphere(p-vec3(0.,.8,0.)),2.);//球体位置\n    //d =opU(d,vec2(sdfPlane(p+vec3(0.,1.,0.)),1.));\n    /*float h=sdfRect(p,vec3(0.));\n    d =min(d,sdfPlane(p+vec3(0.,1.,0.))+(h,sdfRect(p,vec3(1.))));*/\n    d=opU(d,vec2(sdfBox(p-vec3(2.,1.,0.),vec3(1.,1.,1.)),3.));//box Transfrem\n    d=opU(d,vec2(sdfRect(p-vec3(-2.,.5,2.),vec3(.5,.5,1.)),4.));//方形 位置\n    return d;\n\n}\nvec2 rayMarch(in vec3 ro, in vec3 rd)//射线方向和源头\n{\n    float t=0.1;\n    float tmax=40.;\n    vec2 res=vec2(-1.);\n    if(rd.y<0.)\n    {\n        float tp=-ro.y/rd.y;\n        tmax=min(tmax,tp);\n        res=vec2(tp,1.);\n    }\n    for(int i=0;i<RAYMARCH_TIME &&t<tmax;i++)\n    {\n        vec3 p=ro+t*rd;\n        //float d=sdfSphere(p);//输出球体\n        //float d=sdfRect(p,vec3(.8+.1*sin(iTime),.3+.2*cos(iTime),.3));//输出方形\n        vec2 d=map(p);\n        if(d.x<PRECISION)\n        {\n            //return t;\n            res =vec2(t,d.y);\n            break;\n           \n        }\n        t += d.x;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p)//光照\n{\n    const float h=0.0001;;\n    const vec2 k= vec2 (1,-1);\n  /* return normalize(k.xyy * sdfSphere(p + k.xyy * h) +\n        k.yyx * sdfSphere(p + k.yyx * h) +\n        k.yxy * sdfSphere(p + k.yxy * h) +\n        k.xxx * sdfSphere(p + k.xxx * h));*/ \n     return normalize(k.xyy * map(p + k.xyy * h).x +\n        k.yyx * map(p + k.yyx * h).x +\n        k.yxy * map(p + k.yxy * h).x +\n        k.xxx * map(p + k.xxx * h).x);\n}\n\nmat3 setCamera(vec3 ta,vec3 ro,float cr)//摄像机围绕球体旋转\n{\n    vec3 z=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr) , cos(cr),0.);\n    vec3 x= normalize(cross(z,cp));\n    vec3 y=cross(x,z);\n    return mat3(x,y,z);\n\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro,in vec3 rd,float k)//软阴影\n{\n    float res=1.0;\n    float ph=1e20;\n    float tmin=.1;\n    float tmax = 10.;\n    for(float t=tmin;t<tmax;)\n    {\n        \n        float h =map(ro+rd*t).x;\n        if(h<.001)//光线过度，h越小，过度越平滑\n            return 0.0;\n        float y =h*h/(2.0*ph);\n        float d=sqrt(h*h-y*y);\n        res=min(res,k*d/max(0.0,t-y));\n        ph=h;\n        t+=h;\n    }\n    return res;\n}\nvec2 tri (in vec2 x)\n{\n    vec2 h=fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n\nfloat checkersGrad(in vec2 uv,in vec2 ddx, in vec2 ddy)\n{\n    vec2 w =max(abs(ddx),abs(ddy))+0.01;\n    vec2 i=(tri(uv+0.5*w)-tri(uv-0.5*w))/w;\n    return 0.5-0.5*i.x*i.y;\n} \n\nvec3 render(in vec2 uv ,in vec2 px, in vec2 py)\n{\n    float ca=3.f;\n    //vec3 color =vec3(.05);//背景颜色\n    vec3 ro =vec3 (4.*cos(.1*iTime),ca,4.*sin(.1*iTime));//球体旋转\n    if(iMouse.z>0.01)//鼠标控制\n    {\n        float theta=iMouse.x/iResolution.x*2.*PI;\n        ro=vec3(2.*cos(theta),ca+0.2*cos(iTime),2.*sin(theta));  \n    } \n    vec3 ta=vec3(0.,1.,0.);//摄像机位置\n    mat3 cam=setCamera(ta,ro,.1*sin(iTime));//摄像机运动\n    float fl=1.;\n    vec3 rd =normalize(cam*vec3 (uv,fl));//球体大小\n    vec3 bg=vec3(.7,.7,.9);\n    vec3 color = bg-rd.y*vec3(.1);//背景颜色\n    vec2 t=rayMarch(ro,rd);\n    if(t.y>0.)\n    {\n        vec3 p=ro+t.x*rd;\n        vec3 n= (t.y<1.1)?vec3(0.,1.,0.):calcNormal(p);\n        // vec3 light =vec3 (2.*cos(iTime),2.,2.*sin(iTime+2.));//光线移动\n        vec3 light =vec3 (5.,5.,2.);\n        float dif=clamp(dot(normalize(light-p),n),0.,1.);\n        p+=PRECISION*n;\n       // float st = softShadow(p,normalize(light-p),2.);//明显交界线\n        \n        dif *=softShadow(p,normalize(light-p),2.);//光线平滑\n       /*float st=rayMarch(p,normalize(light-p));\n        if(st<TMAX)//假阴影\n        {\n            dif*=.1; \n        }*/\n\n        float amd=0.5+0.5*dot(n,vec3(0.,1.,0));//环境灯光亮度\n        vec3 c=vec3(0.);\n        if(t.y>1.9&&t.y<2.1)\n        {\n            c=vec3(1.,0.,0.);//Sphere\n\n        }else if (t.y>2.9&&t.y<3.1)\n        {\n            c=vec3(1.,1.,0.);//box\n        }\n        else if(t.y>0.9&&t.y<1.1)\n        {\n           /* vec2 grid =floor(p.xz);\n            c=vec3(.23)+.2*mod(grid.x+grid.y,2.);//Plane*/\n            vec3 rdx = normalize(cam*vec3 (px,fl));\n            vec3 rdy = normalize(cam *vec3(py, fl));\n            vec3 ddx=ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 ddy=ro.y*(rd/rd.y-rdy/rdy.y);\n            c=vec3(.3)+vec3(0.2)*checkersGrad(p.xz,ddx.xz,ddy.xz);\n            \n\n        }\n        else if(t.y>3.9&&t.y<4.1)\n        {\n            c=vec3(0.,1.,0.);//Rect\n        }\n\n        color=amd*c+dif*vec3(.6);\n\n    }\n    return sqrt(color);//幂\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec3 color=vec3(0.);\n    for(int m =0;m<AA;m++)\n    {\n        for(int n=0; n<AA;n++)\n        {\n            vec2 offset=2.*(vec2(float(m),float(n))/float(AA)-0.5);\n            //vec2 uv = fixUV(fragCoord+offset)+offset;\n            vec2 uv = fixUV(fragCoord+offset+offset);\n            vec2 px=fixUV (fragCoord+vec2(1.,0.)+offset);\n            vec2 py=fixUV (fragCoord+vec2(0.,1.)+offset);\n            color += render(uv,px,py);\n        }\n    }\n    fragColor=vec4(color/float(AA*AA),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}