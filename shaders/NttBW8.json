{
    "Shader": {
        "info": {
            "date": "1663072093",
            "description": "just a little detour, it won't take long",
            "flags": 0,
            "hasliked": 0,
            "id": "NttBW8",
            "likes": 55,
            "name": "Back to Fractal City",
            "published": 3,
            "tags": [
                "city",
                "buildings",
                "concrete"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 970
        },
        "renderpass": [
            {
                "code": "\n// Back to Fractal City\n// welcome to intricate concrete jungle\n// there are some lipschitz discontinuity turbulences ahead\n//\n// previous fractal city iterations:\n// https://www.shadertoy.com/view/7slcRX\n// https://www.shadertoy.com/view/ftG3D1\n// https://www.shadertoy.com/view/NdyXDt\n// https://www.shadertoy.com/view/WdlyWH\n\n// parameters\nconst float speed = .05;\nconst float falloff = 1.75;\nconst float range = .5;\nconst float count = 11.;\n\n// globals\nvec3 pp, ppp;\nfloat mat, glow;\n\nfloat map (vec3 p)\n{\n    float dist = 100.;\n    float shape = 100.;\n    vec3 pos = p;\n    pp = p;\n    ppp = p;\n    \n    // travel\n    float px = p.x-iTime*speed;\n    float ix = floor(px);\n    p.x = repeat(px,1.);\n    \n    // city\n    float a = 1.;\n    float angle = 196.+ix;\n    for (float i = 0.; i < count; ++i)\n    {\n        p.xz *= rot(angle/a);\n        p = abs(p)-range*a;\n        shape = max(p.x,max(p.y,p.z));\n        mat = shape < dist ? i : mat;\n        pp = i == 7. ? p : pp;\n        ppp = i == 6. ? p : ppp;\n        dist = min(dist, shape);\n        a /= falloff;\n    }\n    dist = -dist;\n    \n    // columns\n    shape = max(length(pp.xz)-.001, dist - .005);\n    dist = min(dist, shape);\n\n    // lights\n    shape = max(length(ppp.xy)-.001, dist - .001);\n    glow += .0001/max(.0005,shape);\n    \n    // crop\n    dist = max(dist, abs(pos.y-.1)-.2);\n    \n    return dist;\n}\n\n// from Inigo Quilez\nfloat shadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 1.;\n    float t = .002;\n    for (float i = 0.; i <= 1.; i += 1./30.) {\n        float dist = map(pos + dir * t);\n        if (dist < .001) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,0);\n    \n    const float frames = 3.;\n    for (float frame = 0.; frame < frames; ++frame)\n    {\n        // coordinates\n        vec2 uv = fragCoord/R.xy;\n        vec2 p = 2.*(fragCoord-R.xy/2.)/R.y;\n        \n        // anti aliasing\n        float aa = 6.28*frame/frames;\n        p += vec2(cos(aa),sin(aa))/R.xy;\n        \n        vec3 pos = vec3(.04,-.02,.09);\n        vec3 ray = look(pos, vec3(0,0,0), p, 4.);\n        vec3 rng = hash(uvec3(fragCoord, float(iFrame) + frame*196.));\n\n        // init globals\n        glow = 0.;\n        mat = 0.;\n\n        // raymarch\n        float total = 0.;\n        float steps = 0.;\n        const float count = 100.;\n        const float max_dist = 4.;\n        for (steps = count; steps > 0.; --steps) {\n            float dist = map(pos);\n            if (dist < .001 * total || total > max_dist) break;\n            dist *= .9 + .1 * rng.z;\n            total += dist;\n            pos += ray * dist;\n        }\n        \n        vec4 result;\n\n        if (total < max_dist)\n        {\n            // lighting\n            float shade = steps/count;\n            vec3 sun = normalize(vec3(0,1,.2));\n            vec3 palette = .5+.5*cos(vec3(1,2,3)*5. + pos.z * 6. + pos.y * 6.);\n            vec3 color = vec3(1.5);\n            color *= sin(mat+1.)*.25+.75;\n            color *= step(.01, ppp.z)*.25+.75;\n            color *= step(pp.y, -.005)*.25+.75;\n            color += palette*clamp(.1/abs(mat-10.), 0., 1.)*.9;\n            color += palette*glow;\n            color *= shade;\n            color *= .4+.6*shadow(pos, sun, 100.);\n            result = vec4(color, 1);\n        }\n        else\n        {\n            // sky\n            vec3 color = .5+.5*cos(vec3(1,2,3)*5.+uv.y*2.+2.);\n            result = vec4(color, 1);\n        }\n        \n        // sum it up\n        fragColor += result/frames;\n    }        \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 look (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = cross(x, z);\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n\n// Victor Shepardson + Inigo Quilez \n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}