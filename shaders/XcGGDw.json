{
    "Shader": {
        "info": {
            "date": "1712825365",
            "description": "eyah",
            "flags": 0,
            "hasliked": 0,
            "id": "XcGGDw",
            "likes": 1,
            "name": "LUCE_N2",
            "published": 3,
            "tags": [
                "hell"
            ],
            "usePreview": 0,
            "username": "marcellix",
            "viewed": 112
        },
        "renderpass": [
            {
                "code": "#define pixelWidth 1.0/iResolution.x\n#define offset_a pixelWidth * 0.5\n#define offset_b pixelWidth * 0.8\n//\nstruct Light {\n    vec3 color;\n    vec2 pos;\n    float min;\n    float max;\n    float brightness;\n};\n \n//Line is used to define lines and boxes\nstruct Line {\n    vec2 start;\n    vec2 end;\n};\n\n//Define box to obstruct light   \nLine box= Line(vec2(0.7, 0.5), vec2(0.8, 0.6));\n\n//Two Lights, light0 is controlled by the mouse, light1 moves in a sine wave\n//                   { Color },          {Position},    {Min},{Max},{Brightness}\nLight light0 = Light(vec3(1.0, 1.0, 1.0), vec2(0.85, 0.5), 0.0, 1.5, 0.7);\n\n/////////////////////////////////////////////////////////////\n\nfloat hyperstep(float min, float max, float x) {\n    if (x < min) {\n        return 1.0;\n    } else if (x > max) {\n        return 0.0;\n    } else {\n        // Adjusted steepness for a softer transition\n        float value = (x - min) / (max - min);\n        float steepness = 2.0; // Lowered from 10.0 for a softer effect\n        return 1.0 - smoothstep(0.0, 1.0, steepness * (value - 0.25));\n    }\n}\n\n\nvec2 intersectPoint(Line line_0, Line line_1) {\n    \n    float slope_0, slope_1, x, y;\n    \n    if (line_0.start.x == line_0.end.x) {\n        \n        //slope_0 is infinite\n        slope_1= (line_1.start.y - line_1.end.y) / (line_1.start.x - line_1.end.x);\n        \n        x= line_0.start.x;\n        y= slope_1 * x + line_1.start.y;\n        \n    }\n    else if (line_1.start.x == line_1.end.x) {\n        \n        //slope_1 is infinite\n        slope_0= (line_0.start.y - line_0.end.y) / (line_0.start.x - line_0.end.x);\n        \n        x= line_1.start.x;\n        y= slope_0 * (x - line_0.start.x) + line_0.start.y;\n        \n    }\n    else {\n    \n        slope_0= (line_0.start.y - line_0.end.y) / (line_0.start.x - line_0.end.x);\n        slope_1= (line_1.start.y - line_1.end.y) / (line_1.start.x - line_1.end.x);\n\n        if (slope_0 != slope_1) {\n\t\t\t\n            //calculate y-intercept of line_1 based on line_0.start\n            float b= slope_1 * (line_0.start.x - line_1.start.x) + line_1.start.y;\n            \n            x= (b - line_0.start.y) / (slope_0 - slope_1);\n            y= slope_0 * x + line_0.start.y;\n            x= x + line_0.start.x;\n            \n\n        }\n        //lines are parallel\n        else return vec2(-1.0);\n    }\n    \n    \n    return vec2(x, y);\n}\n\nbool inside(Line box, vec2 point) {\n    \n    vec2 minValues = vec2( min(box.start.x, box.end.x), min(box.start.y, box.end.y) );\n    vec2 maxValues = vec2( max(box.start.x, box.end.x), max(box.start.y, box.end.y) );\n    \n    if (point.x < minValues.x) return false;\n    if (point.x > maxValues.x  ) return false;\n    if (point.y < minValues.y) return false;\n    if (point.y > maxValues.y  ) return false;\n    return true;\n    \n}\n\nbool intersects(Line a, Line b) {\n    \n    vec2 point = intersectPoint(a, b);\n    \n    return inside(a, point) && inside(b, point);\n}\n\nvec3 calculateLighting(vec2 pixel, Light light) {\n    \n    Line LoS= Line(pixel, light.pos);\n    \n    if ( intersects(LoS, Line(box.start, vec2(box.end.x, box.start.y))) ||\n         intersects(LoS, Line(box.start, vec2(box.start.x, box.end.y))) ||\n         intersects(LoS, Line(box.end, vec2(box.start.x, box.end.y)))   ||\n         intersects(LoS, Line(box.end, vec2(box.end.x, box.start.y))) ) {\n        \n        return vec3(0.0);\n    }\n    else {\n               \n        return hyperstep(light.min, light.max,  distance(pixel, light.pos)) * light.brightness * light.color;\n    }\n}\n\nvec3 multisample(vec2 pixel) {\n \n    vec2 points[4];\n    \n    points[0] = pixel + vec2(offset_a, offset_b);\n    points[1] = pixel + vec2(-offset_a, -offset_b);\n    points[2] = pixel + vec2(offset_b, -offset_a);\n    points[3] = pixel + vec2(-offset_b, -offset_a);\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i= 0; i < 4; i++) {\n        color+= calculateLighting(points[i], light0);\n    }\n    \n    return color / 4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 pixel = fragCoord / iResolution.y;\n    \n    // Update the box position to be controlled by the mouse\n    vec2 boxCenter = iMouse.xy / iResolution.y;\n    vec2 boxSize = vec2(0.1, 0.1); // Adjustable size\n    box.start = boxCenter - boxSize * 0.5;\n    box.end = boxCenter + boxSize * 0.5;\n    \n    // Background color\n    vec3 color = vec3(0.1, 0.1, 0.1);\n      \n    // Anti-aliasing\n    color += multisample(pixel);\n    \n    // Without anti-aliasing\n    // color += calculateLighting(pixel, light0);\n    \n    if (inside(box, pixel)) {\n        // Box color\n        color = vec3(0.6, 0.6, 0.6);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}