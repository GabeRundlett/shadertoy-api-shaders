{
    "Shader": {
        "info": {
            "date": "1625994762",
            "description": "Rainbow Tunnel",
            "flags": 0,
            "hasliked": 0,
            "id": "7lsXRS",
            "likes": 0,
            "name": "Fork Solidtux R toby80 739",
            "published": 3,
            "tags": [
                "tunnel"
            ],
            "usePreview": 0,
            "username": "toby80",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "\n\n#define TIME mod(iTime, float(20.425))\n\nprecision highp float;\n\nconst float MIN_DEPTH = float(1);\nconst float MAX_DEPTH = float(40);\nconst int MAX_ITER = 600;\nconst float EPS = float(0.01);\nconst float SHADOW = float(0);\nconst float SHADOW_EPS = float(0.01);\nconst float SHADOW_DEPTH = float(2);\nconst float SHADOW_SMOOTH = float(15);\nconst float PI = 3.14159265359;\nconst float KEYFRAME_0 = float(0);\nconst float KEYFRAME_1 = float(5);\nconst float KEYFRAME_2 = float(6);\nconst float KEYFRAME_3 = float(15);\nconst float KEYFRAME_4 = float(20);\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\nstruct RayResult {\n    float depth;\n    int object;\n    vec3 norm;\n};\nstruct SdfResult {\n    float distance;\n    vec3 pos;\n    vec2 uv;\n    int object;\n};\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    vec3 up;\n    float zoom;\n};\nfloat rand(float n){\n    return fract(sin(n) * 43758.5453123);\n}\nvec2 norm_coord(in vec2 coord, in vec2 res) {\n    vec2 uv = coord.xy/res.xy;\n    uv = 2.*uv - 1.;\n    if (res.x > res.y) {\n        uv.x *= res.x/res.y;\n    } else {\n        uv.y *= res.y/res.x;\n    }\n    return uv;\n}\nvec3 ray_direction(in Camera cam, in vec2 coord, in vec2 res) {\n    vec2 uv = norm_coord(coord, res);\n    vec3 dir = normalize(cam.target - cam.position);\n    vec3 right = normalize(cross(dir, cam.up));\n    vec3 u = normalize(cross(right, dir));\n    vec3 target = cam.position + normalize(dir)/cam.zoom + uv.x*right + uv.y*u;\n    return normalize(target - cam.position);\n}\nRay get_ray(in Camera cam, in vec2 coord, in vec2 res) {\n    return Ray(cam.position, ray_direction(cam, coord, res));\n}\nvec2 sphere_map(in vec3 pos) {\n    // TODO\n    return vec2(0.);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\nSdfResult sdf_union(in SdfResult a, in SdfResult b) {\n    if (a.distance < b.distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\nmat3 rotx(in float a) {\n    return mat3(\n            1., 0., 0.,\n            0., cos(a), -sin(a),\n            0., sin(a), cos(a)\n            );\n}\nmat3 roty(in float a) {\n    return mat3(\n            cos(a), 0., -sin(a),\n            0., 1., 0.,\n            sin(a), 0., cos(a)\n            );\n}\nmat3 rotz(in float a) {\n    return mat3(\n            cos(a), -sin(a), 0.,\n            sin(a), cos(a), 0.,\n            0., 0., 1.\n            );\n}\nSdfResult sdf(in vec3 pos) {\n    SdfResult res = SdfResult(MAX_DEPTH, vec3(0.), vec2(0.), -1);\n    vec3 p = pos;\n    \n    p.xz = vec2(atan(p.x, p.z), length(p.xz) - 2.7 + 0.5*(exp(-TIME*0.1) + exp((TIME - 20.425)*0.1))*sin(0.5*p.y));\n    p.y -= 5.*(TIME - 11.);\n    p.xy = mod(p.xy, vec2(0.3, 3.));\n    p.y += p.x;\n    res = SdfResult(box(p, vec3(float(0.35), float(0.2), float(2))), p, vec2(0., 0.), 0);\n    return res;\n}\nvec3 norm(in vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPS, p.y, p.z)).distance - sdf(vec3(p.x - EPS, p.y, p.z)).distance,\n        sdf(vec3(p.x, p.y + EPS, p.z)).distance - sdf(vec3(p.x, p.y - EPS, p.z)).distance,\n        sdf(vec3(p.x, p.y, p.z + EPS)).distance - sdf(vec3(p.x, p.y, p.z - EPS)).distance\n    ));\n}\nRayResult raymarcher(in Ray ray) {\n    float depth = MIN_DEPTH;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < EPS) {\n            return RayResult(depth, res.object, norm(pos));\n        }\n        depth += res.distance;\n        if (depth > MAX_DEPTH) {\n            return RayResult(MAX_DEPTH, -1, vec3(0.));\n        }\n    }\n    return RayResult(MAX_DEPTH, -1, vec3(0.));\n}\nfloat lightmarch(in Ray ray, in float maxd, in float k) {\n    float depth = 0.;\n    float r = 1.;\n    for (int i=0; i<MAX_ITER; i++) {\n        vec3 pos = ray.origin + depth*ray.direction;\n        SdfResult res = sdf(pos);\n        if (res.distance < SHADOW_EPS) {\n            return 0.;\n        }\n        r = min(r, k*res.distance/depth);\n        depth += res.distance;\n        if (depth >= (maxd - SHADOW_DEPTH)) {\n            return r;\n        }\n    }\n    return r;\n}\nvec4 color(in vec2 coord, in vec2 resolution) {\n    Camera cam = Camera(mix(mix(mix(mix(vec3(float(0), float(0), float(40)), vec3(float(0), float(5), float(0)), smoothstep(KEYFRAME_0, KEYFRAME_1, TIME)), vec3(float(0), float(5), float(0)), smoothstep(KEYFRAME_1, KEYFRAME_2, TIME)), vec3(float(0), float(5), float(0)), smoothstep(KEYFRAME_2, KEYFRAME_3, TIME)), vec3(float(0), float(0), float(40)), smoothstep(KEYFRAME_3, KEYFRAME_4, TIME)), vec3(float(0.1), float(0), float(0)), mix(mix(mix(mix(vec3(float(0), float(1), float(0)), vec3(float(1), float(5), float(0)), smoothstep(KEYFRAME_0, KEYFRAME_1, TIME)), vec3(cos(0.75*sin(TIME - 11.)), 0., sin(0.75*sin(TIME - 11.))), smoothstep(KEYFRAME_1, KEYFRAME_2, TIME)), vec3(cos(0.75*sin(TIME - 11.)), 0., sin(0.75*sin(TIME - 11.))), smoothstep(KEYFRAME_2, KEYFRAME_3, TIME)), vec3(float(0), float(1), float(0)), smoothstep(KEYFRAME_3, KEYFRAME_4, TIME)), float(0.4));\n    Ray ray = get_ray(cam, coord, resolution);\n    RayResult res = raymarcher(ray);\n    vec3 pos = ray.origin + res.depth*ray.direction;\n    vec3 col;\n    if (res.object == 0) {\n        vec3 amb = vec3((sin(pos) + 1.)/2.);\n        vec3 spec = vec3(0.);\n        vec3 diff = vec3(0.);\n        vec3 h;\n        vec3 l;\n        vec3 lpos;\n        vec3 ldir;\n        float bright = 1.;\n        lpos = vec3(float(0), float(5), float(0));\n        l = normalize(lpos - pos);\n        h = normalize(-ray.direction + l);\n        spec += vec3(float(1), float(1), float(1))*pow(dot(res.norm, h), float(1));\n        diff += amb*dot(l, res.norm);\n        if (SHADOW > 0.) {\n            Ray light_ray = Ray(lpos, -l);\n            float s = SHADOW*lightmarch(light_ray, length(lpos - pos), SHADOW_SMOOTH) + 1. - SHADOW;\n            spec *= s;\n            diff *= s;\n        }\n        col = float(0)*amb + float(1)*diff + float(0)*spec;\n    }\n    if (res.object == -1) {\n        col = vec3(float(0.1), float(0.1), float(0.2));\n    }vec2 nc = abs(2.*coord/resolution - 1.); col = mix(vec3(0.), col, smoothstep(1.1, 1.05, max(nc.x, nc.y) + 0.1*length(nc)));\n    col = clamp(col, 0., 1.);\n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = color(fragCoord, iResolution.xy);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}