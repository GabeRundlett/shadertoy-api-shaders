{
    "Shader": {
        "info": {
            "date": "1665430354",
            "description": "visualization of sound with bouncing light and spheres. If it doesn't play pause and start again.",
            "flags": 32,
            "hasliked": 0,
            "id": "ftGfDc",
            "likes": 2,
            "name": "sphere light bounce",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "ilia87",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "const vec3 spherePos = vec3(0.);\n//const vec3 lightSrc = vec3(-6.0,6,25.0);\nconst vec3 ambientColor = vec3(1.0,1.0,1.0);\n//const vec3 specularColor = vec3(1.0,1.0,1.0);\nconst float shininessVal = 15.0;\nconst float Ka = 0.1;\nconst float Kd = 0.6;\nconst float Ks = 0.4;\nconst float periodicity = 10.0;\nconst float lightDistPow = .6;\nconst float lightDistFact = 1.0/20.0;\n\nvec3 camPos;\nvec3 lightSrc;\n\n//float LightSphereDistFunc(vec3 pos, vec3 lightSrc)\n//{\n//    return length(pos - lightSrc);\n//}\n\nvec3 Phong(vec3 pos, vec3 N, vec3 camPos, vec3 diffuseColor, float lightIntensity)\n{\n    vec3 L = lightSrc-pos;\n    float lightDist = length(L);\n    L /= lightDist;\n    float lambertian = max(dot(N, L), 0.0);\n    float specular = 0.0;\n    if(lambertian > 0.0) {\n      vec3 R = reflect(-L, N);      // Reflected light vector\n      vec3 V = normalize(camPos-pos); // Vector to viewer\n      // Compute the specular term\n      float specAngle = max(dot(R, V), 0.0);\n      specular = pow(specAngle, shininessVal);\n    }\n    vec3 color = Ka * ambientColor +\n                   (Kd * lambertian * diffuseColor +\n                   Ks * specular * diffuseColor)*(lightIntensity*pow(lightDist * lightDistFact,-lightDistPow));                  \n    color = clamp(color,vec3(0.),diffuseColor);\n    return color;\n}\n\nvec3 GetSpherePos(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    vec4 texel = texelFetch(iChannel1,ivec2(32,ycoord),0);\n    float a = texel.y;\n    a *= sin(frame*0.001)*0.001;\n    vec3 v = spherePos - camPos;\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c,s,-s,c);\n    v.xy *= m;\n    return v + camPos;\n}\n\nfloat GetDist(vec3 pos)\n{\n    float pp = length(round((pos -spherePos)/periodicity) - lightSrc/periodicity);\n    int i = int(mod(float(iFrame) - pp*5.2, iResolution.y));\n    //float s = texelFetch(iChannel0, ivec2(0,i),0).x;\n    //float s = texelFetch(iChannel0, ivec2(10,i),0).y + texelFetch(iChannel0, ivec2(20,i),0).y + texelFetch(iChannel0, ivec2(30,i),0).y;\n    float s = texelFetch(iChannel1, ivec2(0,i),0).x;\n    //float s = texelFetch(iChannel0, ivec2(1,i),0).z;\n    //s = max(s,texelFetch(iChannel0, ivec2(20,i),0).z);\n    //s = max(s,texelFetch(iChannel0, ivec2(30,i),0).x);\n    //s = max(s,texelFetch(iChannel0, ivec2(40,i),0).y);\n    //s = smoothstep(0.0,3.,s);\n    s = smoothstep(0.0,0.15,s);\n    s = pow(s,4.);\n    s*=.2;\n    //s*=s*s*2.;\n    //s = smoothstep(0.1,1.0,s*3.);\n    //s = pow(s)*3.;\n    \n    //vec3 pp = pos/periodicity;\n    //vec3 si;\n    //vec3 sf = modf(pp,si);\n    vec3 p = mod(pos+vec3(periodicity*0.5),periodicity)-vec3(periodicity*0.5);\n    //TODO: Need to take into account the next cell in the periodicity.\n    p -= spherePos;\n    //p.y += 0.6 * texelFetch( iChannel0, ivec2(i,1), 0 ).x;\n    float sphereRadius = 1.0;\n    sphereRadius += s;//*s*120.6;\n    //sphereRadius += 0.3 * texelFetch( iChannel0, ivec2(i,1), 0 ).x; \n    float dist = length(p-spherePos) - sphereRadius;\n    //float dist = length(p-GetSpherePos(float(iFrame) - length(p-camPos)*5.5)) - sphereRadius;\n    \n    //float a = atan(p.y,p.x);\n    //float b = atan(p.z,length(p.xy));\n    //float sb = cos(b);\n    //dist -= cos(a*5.) *0.2 * sb*sb;\n    \n    return dist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001,0.);\n    return normalize(GetDist(p) - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)));\n}\n\nfloat GetWaterCoeff(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    vec4 texel = texelFetch(iChannel1,ivec2(64,ycoord),0);\n    return texel.y;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, float dist0)\n{\n    vec3 pos = ro + rd*dist0;\n    for (int iStep = 0;iStep < 150;++iStep)\n    {\n        float ddist = GetDist(pos);\n        //float rotFactor = GetWaterCoeff(float(iFrame)-(pos.z-camPos.z)*6.) * sin(iTime - (pos.z-camPos.z)*4.5)*0.001*ddist;\n        //float rotFactor = GetWaterCoeff(float(iFrame)) * sin(iTime - (pos.z-camPos.z)*4.5)*0.001*ddist;\n        //float rotFactor = GetWaterCoeff(float(iFrame) - (pos.z-camPos.z)*20.)*0.001*ddist;\n        //float r = GetWaterCoeff(float(iFrame) - (pos.z-camPos.z)*4.)*0.001;\n        //rd.xy *= 1.-r;\n        //float c = cos(rotFactor);\n        //float s = sin(rotFactor);\n        //mat2 m = mat2(c,-s,s,c);\n        //rd.xy *= m;\n        pos += rd * ddist;\n        //if (ddist < 0.001)\n        //    break;\n        //else if (ddist > 1000.0)\n        //    break;\n    }\n    return pos;\n}\n\nvec3 GetLightColor(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    \n    //float timePeriodic = fract(iTime*0.04);\n    //vec4 lightSphereColor = vec4(hsv2rgb(vec3(timePeriodic,1.,1.)),1.);\n    float hue = 0.2*texelFetch(iChannel1,ivec2(0,ycoord),0).w;\n    vec3 c = vec3(hsv2rgb(vec3(hue,1.,1.)));\n    return c;\n}\n\nfloat GetLightIntensity(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    \n    //float timePeriodic = fract(iTime*0.04);\n    //vec4 lightSphereColor = vec4(hsv2rgb(vec3(timePeriodic,1.,1.)),1.);\n    //float l= texelFetch(iChannel1,ivec2(32,ycoord),0).y;\n    float l1 =texelFetch(iChannel0,ivec2(64,ycoord),0).w;\n    //float l2 = texelFetch(iChannel1,ivec2(32,ycoord),0).y;\n    float l2 = texelFetch(iChannel1,ivec2(32,ycoord),0).y;\n    float l = l1*0.4 + l2*0.6;\n    return l*l;\n}\n\nvec3 GetLightPos(float frame)\n{\n    int ycoord = int(mod(frame, iResolution.y));\n    \n    //float timePeriodic = fract(iTime*0.04);\n    //vec4 lightSphereColor = vec4(hsv2rgb(vec3(timePeriodic,1.,1.)),1.);\n    //float t = texelFetch(iChannel1,ivec2(0,ycoord),0).w;\n    //vec3 lightSrc;\n    //lightSrc.xy = (iMouse.xy*2.0 - iResolution.xy) / iResolution.x;\n    //lightSrc.x = cos(t);\n    //lightSrc.y = 0.3*sin(t);\n    //lightSrc.z = 1.0;\n    \n    vec3 lightSrc = texelFetch(iChannel1,ivec2(1,ycoord),0).xyz;\n    lightSrc.z += 1.3;\n    lightSrc.z *=2.*lightSrc.z;\n    lightSrc *= 12.5;\n    lightSrc.xy *= 0.5;\n    lightSrc += camPos;\n    return lightSrc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camPos = vec3(-2,-2,-5.) + 2.*(iTime - 5. * cos(iTime*0.1)) * vec3(-1.5,1.2,0.8);\n    lightSrc = GetLightPos(float(iFrame));\n    vec3 rd;\n    rd.xy = (fragCoord*2.0 - iResolution.xy) / iResolution.x;\n    rd.z = 1.0;\n    //rd.xz *= R;\n    vec3 ro = rd + camPos;\n    rd = normalize(rd);\n    vec3 p = RayMarch(ro,rd,0.);\n    vec3 pc = p - camPos;\n    vec3 lc = lightSrc - camPos;\n    vec3 pl = p - lightSrc;\n    float finalDist = GetDist(p);\n    if (finalDist<0.01)\n    {\n        vec3 n = GetNormal(p);\n        float colorFrame = float(iFrame) - length(pl)*0.5;\n        vec3 diffuseColor = GetLightColor(colorFrame);\n        float lightIntensity = 0.7 * GetLightIntensity(colorFrame) + 0.3;\n        fragColor = vec4(Phong(p,n,camPos,diffuseColor,lightIntensity),1.);\n    }\n    else\n    {\n        fragColor = vec4(0,0,0,1);\n    }\n    \n    //fragColor = mix(fragColor,vec4(0.1,0.1,0.1,1.0),length(pos)/1000.0);\n    fragColor.xyz *= smoothstep(0.,1.,pow(length(pc)/100.0,-0.5));\n    \n    //fragColor.z += pow(lightCloseness/8.0,5.0);\n    //if (length(lightSrc) < length(p))\n    \n    //if ( length(lc) < length(pc) )\n    \n    if ( lc.z < pc.z )\n    {\n        vec4 lightSphereColor = vec4(GetLightColor(float(iFrame)),1.);\n        float lightIntensity = GetLightIntensity(float(iFrame));\n        //lightSphereColor = mix(lightSphereColor,vec4(1.),lightIntensity*.6);\n        float minLightDist = length(cross(pc,lc))/length(pc);\n        minLightDist = smoothstep(.4*(lightIntensity*.4+.6),4.5,minLightDist);\n        //fragColor.xy *= 1.0-lightDistFact;\n        //fragColor.z += lightDistFact;\n        fragColor = mix(lightSphereColor*(.9 + 0.1*lightIntensity),fragColor,pow(minLightDist,(.1+.3*lightIntensity)*(0.1*lightIntensity + .5)));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define windowWidth 8\n#define windowWidth2 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n\n    int soundBuffLen = textureSize(iChannel1,0).x;\n    \n    float soundBuffTime = float(soundBuffLen) / iSampleRate;\n    int ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n    if (int(fragCoord.x) >= soundBuffLen )\n        return;\n    int pixelX = int(fragCoord.x);\n    float s  = texelFetch(iChannel1,ivec2(pixelX,0),0).x;\n    float sums = s;\n    float maxs = s;\n    for ( int i=1;i<windowWidth;++i)\n    {\n        float s  = texelFetch(iChannel1,ivec2(pixelX + i, 0),0).x;\n        sums += s;\n        maxs = max(maxs,s);\n    }\n    float maxs2 = maxs;\n    for ( int i=windowWidth;i<windowWidth2;++i)\n    {\n        float s  = texelFetch(iChannel1,ivec2(pixelX + i, 0),0).x;\n        maxs2 = max(maxs2,s);\n    }\n    sums /= float(windowWidth);\n    //vec2 s  = texelFetch(iChannel1,ivec2(int(uv.x * float(soundBuffLen)),1),0).xy;\n    fragColor.x = s;\n    fragColor.y = sums;\n    fragColor.z = maxs;\n    fragColor.w = maxs2;    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 20,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define soundBuffLen 512\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);    \n    int ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n    //vec2 uv = fragCoord / iResolution.xy;\n    \n    if (int(fragCoord.x) >= soundBuffLen )\n        return;\n    vec4 xn  = texelFetch(iChannel1,ivec2(int(fragCoord.x), ycoord),0);\n    int prevYCoord = ycoord - 1;\n    if (prevYCoord < 0)\n        prevYCoord += int(iResolution.y);\n    vec4 xnm1  = texelFetch(iChannel1,ivec2(int(fragCoord.x), prevYCoord),0);\n    //vec4 ynm1 = texelFetch(iChannel0,ivec2(int(fragCoord.x), prevYCoord),0);\n    //float alpha = 0.5;\n    //vec4 yn = alpha*(ynm1 + xn - xnm1);\n    vec4 yn = xn-xnm1;\n    \n    fragColor = yn;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int windowStarts[2] = int[2](0,64);\nconst int windowEnds[2] = int[2](16,128);\n#define COMPONENT x\n\nint iDiv32, iBase32, iMod32, ycoord;\n\nvoid func2(out vec4 fragColor, in vec2 fragCoord)\n{\n    if ( iMod32 >0)\n        return;\n    float s = 0.;\n    for (int i=0;i<512;++i)\n    {\n        s += texelFetch(iChannel1,ivec2(i, ycoord),0).x;\n    }\n    s /= 512.;\n    int prevYCoord = ycoord - 1;\n    if (prevYCoord < 0)\n        prevYCoord += int(iResolution.y);\n    vec4 prevPixel = texelFetch(iChannel0,ivec2(iBase32,prevYCoord),0);\n    vec2 speed = vec2(\n        prevPixel.y * 0.95 + pow(smoothstep(0.06,0.1,s),2.0),\n        prevPixel.z * 0.5 + pow(smoothstep(0.04,0.06,s),4.0)\n    );\n    speed = clamp(speed,0.,1.);\n    //speed.x = 0.9*speed.x + 0.1;\n    vec2 delta = iTimeDelta * speed;\n    \n    if ( int(iMod32) == 0 )\n    {\n        fragColor.x = s;\n        if ( iFrame < 5)\n        {\n            fragColor.yzw = vec3(0.);\n        }\n        else\n        {\n            fragColor.yz = speed;\n            fragColor.w = prevPixel.w + delta.x;\n        }\n    }\n}\n\nvoid func1(out vec4 fragColor, in vec2 fragCoord)\n{\n    if ( iMod32 >2)\n        return;\n    float mx = 0.;\n    int windowStart = windowStarts[iDiv32];\n    int windowEnd = windowEnds[iDiv32];\n    for ( int i=windowStart;i<windowEnd ; ++i)\n    {\n        mx = max(mx,texelFetch(iChannel1,ivec2(i, ycoord),0).COMPONENT);\n    }\n    int prevYCoord = ycoord - 1;\n    if (prevYCoord < 0)\n        prevYCoord += int(iResolution.y);\n    vec4 prevPixel = texelFetch(iChannel0,ivec2(iBase32,prevYCoord),0);\n    \n    vec2 speed = vec2(\n        prevPixel.y * 0.95 + pow(smoothstep(0.05,0.1,mx),2.0),\n        prevPixel.z * 0.9 + pow(smoothstep(0.05,0.15,mx),4.0)\n    );\n    speed = clamp(speed,0.,1.);\n    //speed.x = 0.9*speed.x + 0.1;\n    vec2 delta = iTimeDelta * speed;\n\n    \n    if ( int(iMod32) == 0 )\n    {\n        fragColor.x = mx;\n        if ( iFrame < 5)\n        {\n            fragColor.yzw = vec3(0.);\n        }\n        else\n        {\n            fragColor.yz = speed;\n            fragColor.w = prevPixel.w + delta.x;\n        }\n    }\n    else\n    {\n        vec3 P = texelFetch(iChannel0,ivec2(iBase32 + 1,prevYCoord),0).xyz; //position\n        vec3 T = texelFetch(iChannel0,ivec2(iBase32 + 2,prevYCoord),0).xyz; //tangential vector\n        \n        float lp = length(P);\n        float lt = length(T);\n        if (lp<0.9 || lp>1.1 || lt < 0.9 || lt > 1.1 || iFrame < 5 )\n        {\n            //initializing.\n            if ( int(iMod32) == 1 )\n            {\n                fragColor.xyz = vec3(1.,0.,0.);\n            }\n            else\n            {\n                fragColor.xyz = vec3(0.,1.,0.);\n            }\n            return;\n        }\n\n        float kinkAngle = 100.0 * delta.y;\n        vec3 N = cross(P,T);\n        N = N * cos(kinkAngle) + P * sin(kinkAngle);\n        N = normalize(N);\n        \n        float velocity = 1.0;\n        float deltaPos = velocity * (0.9 * delta.x + 0.1*iTimeDelta);\n        vec3 Pn = normalize(P + T * deltaPos);\n        vec3 Tn = normalize(cross(N,Pn));\n        \n        if ( int(iMod32) == 1 )\n        {\n            fragColor.xyz = Pn;\n        }\n        else\n        {\n            fragColor.xyz = Tn;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    iDiv32 = int(fragCoord.x) >> 5;\n    iBase32 = iDiv32 << 5;\n    iMod32 = int(fragCoord.x) - iBase32;\n    ycoord = iFrame % int(iResolution.y);\n    if (ycoord != int(fragCoord.y))\n        return;\n    \n    if ( iDiv32 <=1)\n        func1(fragColor,fragCoord);\n    else if (iDiv32 == 2)\n        func2(fragColor,fragCoord);\n    else\n        return;\n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float ThresholdDecay( float t )\n{\n    return pow(0.8,t);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}