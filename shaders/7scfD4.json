{
    "Shader": {
        "info": {
            "date": "1675665128",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "7scfD4",
            "likes": 1,
            "name": "spqr: street map",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "spqr",
            "viewed": 177
        },
        "renderpass": [
            {
                "code": "\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return max(max(q.x,q.y),q.z);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat a = 3.141592;\n\n\nfloat tick(float t,float n){\n    float i = floor(t);\n    float r = pow(fract(t),n);\n    return i+r;\n}\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\nvec3 moda ( vec3 p, float rep ) {\n    vec2 rp = vec2(atan(p.z,p.x)/(2.*PI), length(p.xz));\n    rp.x =(fract(rp.x*rep-0.5)-0.5)/rep;\n    rp.x *= 2. *PI;\n    return vec3(cos(rp.x)*rp.y, p.y, sin(rp.x)*rp.y);\n}\n\n\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(in vec3 p){\n    float res = 0.;\n    vec3 q = p;\n    float amp = 1.0;//\n    for(int i=0;i<7;i++){\n\t\tfloat fi = float(i);\n        res += amp*noise(q);\n        amp *= 0.53;//\n        q*=2.1;\n    }\n    return res;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\n\n\nfloat pi = 3.141592;\nfloat surge (float t) {\n\n   float i = floor(t);\n   float r = fract(t);\n   r = smoothstep(0.,1.,r);\n   r = pow(r, 3.);\n   \n   return i + r;\n   \n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\n\n\n\nfloat pulse ( float x, float t ){\n    x *= .1;\n    \n    float f1 = 11.;\n    t = -t;\n    float u = atan(f1 * sin((sin(x) + t * 2.))/atan(f1)) * .5 + .5;\n \n    return u;\n\n}\n\n\nint matter;\n\n\n\nfloat rnd(float t) {\n  return fract(sin(t*754.652)*652.642);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  float dd = p.z*0.02;\n  dd *= 1.7;\n  off.x += sin(dd)*13.;\n  off.x += cos(dd*2.1)*6.1;\n  off.y += sin(dd*0.7)*26.;\n  off.y += cos(dd*1.5)*11.;\n  \n  \n  return off;\n}\nfloat glow = 0.;\nfloat map (vec3 p){\n\n    \n    float ground = -p.y;\n  \n    return ground ;\n   \n  \n\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <6.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv*.8);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\n\nfloat m2(vec2 uv) {\n \n  vec2 uv2 = uv;\n  float q = 1.4;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n   \n    uv.x *= q;\n    \n   \n    \n    uv *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off);\n    z = min(z,a1);\n  \n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 2.1);\n  float u = length(uv2  + arm) -2.;\n  \n  glow += .01/(.02 + u);\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.); // kilroy\n           \n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.0));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p) {\n\n    float a = hash31(vec3(p.x, p.y,cos(32.) * 77.191));\n    float b = hash31(vec3(p.y, p.x,cos(21.) * 45.432));\n    return fract(a+b);\n    //float a = fract( sin(p.x*5612.431) * 937.442 + sin(p.y*2489.289) * 818.632);\n    //float b = fract(sin(a * 2093.441) * 9433.313);\n    //return b;\n}\nvec2 kifs(vec2 p) {\n    for ( float i=0.; i < 3.;i++) {\n        p *= rot((i + iTime * .3) * pi/2.);\n        p = abs(p) - 60.;\n        p *= 1.2;\n    }\n    return p;\n}\n// ink\nconst float domain_width = 197.;\nconst float domain_height = 41.;\nconst vec3 domain = vec3(domain_width,domain_height,domain_width);\nfloat decal(vec3 p, vec3 domain) {\n\n  \n  vec3 id = floor(p/(domain));\n  float f1 = fract(hash31(id) + iTime/23.1 + hash31(id));\n\n  p = mod(p,domain) - domain/2.;\n  \n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(400.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n \n\n  // nav\n  \n\n\n vec3 source = vec3(0,-350,1);\n vec3 target = vec3(0);\n\n float time = iTime;\n float advance = time * 14. ;\n source.z += advance;\n target.z += advance;\n\n\n \n \n\n  \n\n  \n  vec3 cz=normalize(target-source);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  \n  vec3 cy=normalize(cross(cz,cx));\n  \n\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz * .8);\n  // fisheye\n  //r.z+=.1*length(uv);\n \n  \n  // march\n  \n  \n  float dd;\n  vec3 p = source;\n  float i;\n  float d;\n  bool hit = false;\n  for(float z=0.; z <500.; ++z) {\n    i = z;\n    d=map(p);\n    if(d<0.001) {\n      hit = true;\n    \n      break;\n    }\n    if ( dd > 700.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  \n\n    \n  vec3 alt_domain = domain ;\n  //alt_domain.x -= 253.1;\n\n  float decal_val = decal(p,alt_domain);\n  vec3 col;\n  if ( decal_val < 0.) {\n     col = vec3(.8,.4,.3)*1.4;\n  }\n  \n\n\n\n\n\n  vec3 n = norm(p);\n  vec3 light =normalize(vec3(0,-1,0));\n\n  \n\n \n  float fren = pow(1. + dot(n,r),4.);\n  float spec =pow(max(dot(reflect(-light,n),-r),1.),2.);\n  vec3 fog = vec3(1);\n   \n  //col += spec * .15;\n  col += fren * 1.65;\n\n \n\n \n    \n  if (! hit) {\n      col = mix(vec3(.6), vec3(.4), pow(abs(r.y),.3));\n  }\n  fragColor = vec4(col, 1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}