{
    "Shader": {
        "info": {
            "date": "1575085565",
            "description": "A very biological shader. Coded live on my twitch stream, watch the recording and tune in fridays to watch live! https://www.twitch.tv/videos/515076146",
            "flags": 0,
            "hasliked": 0,
            "id": "3dGSD3",
            "likes": 18,
            "name": "Twitch: Get Your Flu Shot",
            "published": 3,
            "tags": [
                "noise",
                "molecule",
                "health",
                "biology",
                "twitchstream"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 652
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat rand(float k) {\n  int x = FK(k);int y = FK(cos(k));\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 rand3(float k) {\n  float t1 = rand(k);\n  float t2 = rand(k+t1);\n  float t3 = rand(t1+t2);\n  return vec3(t1,t2,t3);\n}\n\nvec3 spherecords(vec2 p) {\n  float phi = acos(p.x);\n  float lamb = p.y*acos(-1.);\n  return vec3(cos(phi), sin(phi)*cos(lamb), sin(phi)*sin(lamb));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat comp(vec3 p, vec3 off, vec3 rot) {\n  float scale = 0.6 + sqrt(sin(iTime*2.)*0.5+0.5)*0.1;\n  vec3 ax = spherecords(rot.xy);\n  p = erot(p, ax, rot.z*acos(-1.));\n  p+=off;\n  p = (fract(p/scale)-0.5)*scale;\n  return length(p) - scale*0.3;\n}\n\nvec3 mapp(vec3 p) {\n  for (int i = 0; i < 8; i++) {\n    vec3 off = spherecords(rand3(2.4*cos(float(i))).xy);\n    vec3 rot = rand3(5.1*float(i));\n    vec3 ax = spherecords(rot.xy);\n    off = erot(off, ax, iTime*0.1);\n    float offscale = 1. + sin(iTime*0.5);\n    p+=off*offscale;\n    p -= min(dot(off,p),0.)*off*2.; \n    p-=off*offscale;\n  }\n  return p;\n}\n\nfloat jort = 0.;\nfloat scene(vec3 p) {\n  p = mapp(p);\n  \n  float dist = 100000.;\n  for (int i = 0; i < 5; i++) {\n    float d = comp(p, rand3(float(i)), rand3(cos(float(i))));\n    if (d < dist) jort = float(i);\n    dist = smin(d,dist,0.1);\n  }\n  return (dist + max(length(p)-1.5,0.)*0.25);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat sharp(float k) {\n  return smoothstep(0.0,1.,k);\n}\n\nfloat fakereflection(vec3 p, vec3 cam) {\n  vec3 n = norm(p);\n  vec3 inc = reflect(cam, n);\n  float s1 = scene(p);\n  float avg = 0.;\n  float cum = 0.;\n  \n  for (int i = 0; i < 3; i++) {\n    float stp = 0.045*(float(i)+1.);\n    vec3 stped = p+inc*stp;\n    vec3 n2 = norm(stped);\n    stped = mapp(stped);\n    float brt = min(length(stped),2.)/2.;\n    avg += mix(0., mix(dot(n2,normalize(mapp(p)))*0.5+0.5,1.,brt*0.8), brt*0.3+0.7);//((s2-s1)/stp)*0.5+0.5\n    cum += 1.;\n  }\n  return sharp(avg/cum*0.95);\n}\n\nvec3 RED = vec3(0.9,0.2,0.2);\nvec3 BLUE = vec3(0.2,0.6,0.9);\n\nbool cros(vec2 p) {\n  p *= asin(sin(iTime/60.*140.*4.))*0.15+1.15;\n  p = abs(p);\n  vec2 p2 = vec2(min(p.y,p.x),max(p.y,p.x));\n  float sc = 1.5;\n  if (p2.x < 0.05*sc && p2.y < 0.15*sc) return true;\n  return false;\n}\n\nvec3 backgroundcol(vec2 uv) {\n  uv*=4.;\n  vec2 sc = vec2(0.4,0.7)*2.;\n  vec2 id = floor(uv/sc);\n  float off = iTime;\n  if (mod(id.x,2.)==mod(floor(off*0.5),2.)) {\n    uv.y+=0.5*sc.y;\n  } else {\n    uv.y;\n  }\n  uv = (fract(uv/sc)-0.5)*sc;\n  \n  return cros(uv) ? RED : vec3(1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 cam = normalize(vec3(0.5,uv));\n  vec3 init = vec3(-8.+sin(iTime*0.7),0.,0.)+cam*0.8;\n  float ro = iTime;\n  cam = erot(cam, vec3(0,1,0), sin(ro)/7.);\n  init = erot(init, vec3(0,1,0), sin(ro)/7.);\n  cam = erot(cam, vec3(0,0,1), ro/3.);\n  init = erot(init, vec3(0,0,1), ro/3.);\n  vec3 p = init;\n  bool hit = false;\n  float k = 1.;\n  for (int i = 0; i < 200; i++) {\n    float dist = scene(p);\n    if (i == 0) k = sign(dist);\n    dist *= k;\n    if (abs(dist) < 0.001) { hit = true; break; }\n    if (distance(p, init) > 100.) {hit=false;break;}\n    p += dist*cam;\n  }\n  float j = jort;\n  vec3 col = vec3(1);\n  \n\n  if (j == 0.) {\n    col = RED;\n  }\n  if (j == 1.) {\n    col = BLUE;\n  }\n  //hit = false;\n\n  fragColor.xyz = hit ? col*vec3(fakereflection(p, cam)) : backgroundcol(uv);\n  \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}