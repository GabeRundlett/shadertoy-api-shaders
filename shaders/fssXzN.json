{
    "Shader": {
        "info": {
            "date": "1618344282",
            "description": "mandelbulb-by neozhaoliang",
            "flags": 0,
            "hasliked": 0,
            "id": "fssXzN",
            "likes": 8,
            "name": "mandelbulb-by neozhaoliang",
            "published": 3,
            "tags": [
                "mandelbulbbyneozhaoliang"
            ],
            "usePreview": 0,
            "username": "jorge2017a1",
            "viewed": 392
        },
        "renderpass": [
            {
                "code": "//by neozhaoliang\n//https://www.shadertoy.com/user/neozhaoliang\n\n#define AA                 1//2\n#define FOV_DIST           3.0\n#define BULB_ITERATIONS    7//8\n#define SPONGE_ITERATIONS  9\n#define MAX_TRACE_STEPS    200//200\n#define MIN_TRACE_DIST     0.01\n#define MAX_TRACE_DIST     10.0\n#define PRECISION          1e-4\n#define PI                 3.14159265358979323\n#define T                  (iTime * 0.1)\n\n// view to world transformation\nmat3 viewMatrix(vec3 camera, vec3 lookat, vec3 up)\n{\n    vec3 f = normalize(lookat - camera);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    return mat3(r, u, -f);\n}\n\n// 2D rotatation\nvoid R(inout vec2 p, float a)\n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat mandelbulb(vec3 p)\n{\n    p /= 1.192;\n    p.xyz = p.xzy;\n    vec3 z = p;\n    vec3 dz = vec3(0.0);\n    float dr = 1.0;\n    float power = 8.0;\n    float r, theta, phi;\n    for (int i = 0; i < BULB_ITERATIONS; i++)\n    {\n        r = length(z);\n        if (r > 2.0)\n            break;\n        float theta = atan(z.y / z.x);\n        float phi = asin(z.z / r);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n        r = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        z = r * vec3(cos(theta) * cos(phi), cos(phi) * sin(theta), sin(phi)) + p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat sdSponge(vec3 z)\n{\n    for(int i = 0; i < SPONGE_ITERATIONS; i++)\n    {\n        z = abs(z);\n        z.xy = (z.x < z.y) ? z.yx : z.xy;\n        z.xz = (z.x < z.z) ? z.zx : z.xz;\n        z.zy = (z.y < z.z) ? z.yz : z.zy;\t \n        z = z * 3.0 - 2.0;\n        z.z += (z.z < -1.0) ? 2.0 : 0.0;\n    }\n    z = abs(z) - vec3(1.0);\n    float dis = min(max(z.x, max(z.y, z.z)), 0.0) + length(max(z, 0.0)); \n    return dis * 0.6 * pow(3.0, -float(SPONGE_ITERATIONS)); \n}\n\nfloat DE(vec3 p)\n{\n    float d1 = mandelbulb(p);\n    float d2 = sdSponge(p);\n    return max(d1, d2);\n    \n}\n\nvec3 calcNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n\t\t\t  DE(p + e.xyy) - DE(p - e.xyy),\n\t\t\t  DE(p + e.yxy) - DE(p - e.yxy),\n\t\t\t  DE(p + e.yyx) - DE(p - e.yyx)));\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    float h;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++)\n    {\n        h = DE(ro + rd * t);\n        if (h < PRECISION * t || t > MAX_TRACE_DIST)\n            return t;\n        t += h;\n    }\n    return -1.0;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 10; i++)\n    {\n        float h = DE(ro + rd * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.1);\n        if (h < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = DE(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.9;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 lig)\n{\n    vec3 background = vec3(0.08, 0.16, 0.32);\n    vec3 col = background;\n    float t = trace(ro, rd);\n    if (t >= 0.0)\n\t{\n        col = vec3(0.9);\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        float occ = calcAO(pos, nor);\n        float amb = 0.3;\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0);\n        dif *= softShadow(pos, lig, 0.02, 5.0, 16.0);\n\n        vec3 lin = vec3(0.3);\n        lin += 1.8 * dif * vec3(1.0, 0.8, 0.55);\n        lin += 2.0 * spe * vec3(1.0, 0.9, 0.7) * dif;\n        lin += 0.3 * amb * vec3(0.4, 0.6, 1.0) * occ;\n        lin += 0.25 * fre * vec3(1.0) * occ;\n\n        col *= lin;\n\n        float atten = 1.0 / (1.0 + t * t * 0.1);\n\t    col *= atten * occ;\n\t    col = mix(col, background, smoothstep(0.0, 0.95, t / MAX_TRACE_DIST));\n    }\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 tot = vec3(0.0);\n    for (int ii = 0; ii < AA; ii ++)\n\t{\n\t    for (int jj = 0; jj < AA; jj++)\n\t\t{\n\t\t    // map uv to (-1, 1) and adjust aspect ratio\n\t\t    vec2 offset = vec2(float(ii), float(jj)) / float(AA);\n\t\t    vec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n\t\t    uv = 2.0 * uv - 1.0;\n\t\t    uv.x *= iResolution.x / iResolution.y;\n\t\t    vec3 camera = vec3(4.0) / (min(3.5, 1.0 + pow(2.0, T)));\n\t\t    vec3 lookat = vec3(0.0);\n\t\t    vec3 up = vec3(0.0, 1.0, 0.0);\n\t\t    // set camera\n\t\t    vec3 ro = camera;\n            R(ro.xz, T);\n\t\t    mat3 M = viewMatrix(ro, lookat, up);\n\t\t    // put screen at distance FOV_DISt in front of the camera\n\t\t    vec3 rd = M * normalize(vec3(uv, -FOV_DIST));\n            vec3 lig = normalize(vec3(1.0, 2.0, 1.0));\n\t\t    vec3 col = render(ro, rd, lig);\n\t\t    tot += col;\n\t\t}\n\t}\n    tot /= float(AA * AA);\n    fragColor = vec4(tot, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}