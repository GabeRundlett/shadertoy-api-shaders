{
    "Shader": {
        "info": {
            "date": "1639622285",
            "description": "Port of GLSL_PathTracer from @knightcrawler25. Tried to abstract the content as good as possible into the Common tab.",
            "flags": 32,
            "hasliked": 0,
            "id": "sltXRl",
            "likes": 70,
            "name": "Disney Principled BSDF",
            "published": 3,
            "tags": [
                "pathtracer",
                "disney",
                "bsdf",
                "principled"
            ],
            "usePreview": 1,
            "username": "markusm",
            "viewed": 3012
        },
        "renderpass": [
            {
                "code": "/*\n * Port of https://github.com/knightcrawler25/GLSL-PathTracer\n * Copyright(c) 2019-2021 Asif Ali\n *\n * v0.1 - Initial Release\n *\n */\n\nfloat Luminance(vec3 c)\n{\n    return 0.212671 * c.x + 0.715160 * c.y + 0.072169 * c.z;\n}\n\nvec3 Tonemap(in vec3 c, float limit)\n{\n    return c * 1.0 / (1.0 + Luminance(c) / limit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    fragColor.rgb = Tonemap(fragColor.rgb, 1.5);\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI         3.14159265358979323\n#define INV_PI     0.31830988618379067\n#define TWO_PI     6.28318530717958648\n#define INV_TWO_PI 0.15915494309189533\n#define INV_4_PI   0.07957747154594766\n#define EPS 0.001\n#define INF 1000000.0\n\n#define QUAD_LIGHT 0\n#define SPHERE_LIGHT 1\n#define DISTANT_LIGHT 2\n\n#define LIGHTS\n//#define RR\n#define RR_DEPTH 2\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec3 baseColor;\n    vec3 emission;\n    float anisotropic;\n    float metallic;\n    float roughness;\n    float subsurface;\n    float specularTint;\n    float sheen;\n    float sheenTint;\n    float clearcoat;\n    float clearcoatRoughness;\n    float specTrans;\n    float ior;\n    float atDistance;\n    vec3 extinction;\n};\n\nstruct Light\n{\n    vec3 position;\n    vec3 emission;\n    vec3 u;\n    vec3 v;\n    float radius;\n    float area;\n    int type;\n};\n\nstruct State\n{    \n    int depth;\n    float eta;\n    float hitDist;\n\n    vec3 fhp;\n    vec3 normal;\n    vec3 ffnormal;\n    vec3 tangent;\n    vec3 bitangent;\n\n    bool isEmitter;\n\n    vec2 texCoord;\n    int matID;\n    Material mat;\n};\n\n#define NUM_LIGHTS 17\nLight lights[NUM_LIGHTS];\n\nvoid initLights() {\n\n    for(int i = 0; i < NUM_LIGHTS; i +=1) {\n        float f = float(i);\n        \n        vec3 p = vec3(-2.04973, 5., -8. + f);\n  \n        vec3 u = vec3(2.040, 5., -8. + f) - p;\n        vec3 v = vec3(-2.04973, 5., -7.5 + f) - p;\n        \n\n        float area = length(cross(u, v));\n        \n        lights[i] = Light( p,         // Position\n                           vec3(5),   // Emission\n                           u,         // u, only for rect lights\n                           v,         // v, only for rect lights\n                           0.,        // Radius for sphere light, \n                           area,      // area  \n                           0);        // type: 0 - rect, 1 - sphere, 2 - dist\n    \n    }\n}\n\n// Get the camera position and lookAt\nvoid getCameraPos(inout vec3 origin, inout vec3 lookAt) {\n    origin = vec3(15., 15, 0.);\n    lookAt = vec3(0., 0., 0.);\n}\n\n// Get the scene background color\nvec3 getBackground(Ray ray) {\n    return vec3(0);\n}\n\n// Map\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 opU(vec2 o1, vec2 o2) {\n    return (o1.x < o2.x) ? o1 : o2;\n}\n\nvec2 map(vec3 p) {\n    \n    vec2 obj = vec2(sdBox(p - vec3(0, 0.4, 0), vec3(5, 0.3, 9)), 2.);\n    \n    // Silver\n    obj = opU(vec2(length(p - vec3(-0.57, 2.2, 6.55)) - 1.2, 5), obj);\n\n    // Ping\n    obj = opU(vec2(length(p - vec3(2.6, 1.4, 3.6)) - 0.8, 4), obj);\n\n    // Orange\n    obj = opU(vec2(length(p - vec3(-0.8, 1.86, -3.59)) - 1., 3), obj);\n\n    // Glass\n    obj = opU(vec2(length(p - vec3(1.8, 2.6, -6.59)) - 1.3, 1), obj);\n\n    // Marble\n    obj = opU(vec2(length(p - vec3(3.5, 1.2, -1.5)) - 0.6, 6), obj);\n    \n    return obj;\n}\n\nvec3 calculateNormal(vec3 p) {\n \n    vec3 epsilon = vec3(0.001, 0., 1.);\n    \n    vec3 n = vec3(map(p + epsilon.xyy).x - map(p - epsilon.xyy).x,\n                  map(p + epsilon.yxy).x - map(p - epsilon.yxy).x,\n                  map(p + epsilon.yyx).x - map(p - epsilon.yyx).x);\n    \n    return normalize(n);\n}\n\n// Get the scene hit record\nbool getSceneHit(Ray ray, bool shadowRay, inout State state) {\n                    \n    float t = 0.001;\n    \n    // Analytical floor\n    float groundDist = (0. - ray.origin.y) / ray.direction.y;\n    float matId = -1.;\n\n    bool hit = groundDist > 0. ? true : false;\n\n    // Raymarch the rest \n    for(int i = 0; i < 120; ++i) {\n        vec3 p = ray.origin + ray.direction * t;\n        \n        vec2 d = map(p);\n        float ad = abs(d.x);\n\n        if (ad < (0.0001)) {\n            hit = true;\n            matId = d.y;\n            break;\n         }\n            \n         t += ad;\n         \n         if (t>27.0) { break; }\n    }\n    \n    if (hit) {\n\n        if ( (groundDist > 0. && groundDist < t) || matId < 0.5 ) {\n\n            // Ground\n            state.mat.baseColor = vec3(1, 0, 0);\n            state.mat.roughness = 0.5;\n            state.mat.metallic = 0.2;\n                \n            state.fhp = ray.origin + ray.direction * groundDist;\n            state.normal = vec3(0, 1, 0);\n\n            // 70s Wallpaper from Shane, https://www.shadertoy.com/view/ls33DN\n            vec2 p = state.fhp.xz;\n            p.x *= sign(cos(length(ceil(p /= 2.))*99.));\n    \n            float f = clamp(cos(min(length(p = fract(p)), length(--p))*44.), 0., 1.);\n            \n            f = clamp(f, 0., 1.);\n            \n            state.mat.clearcoat = f;\n            state.mat.clearcoatRoughness = f;\n            state.mat.baseColor = mix(state.mat.baseColor, \n                        vec3(1.0, 0.71, 0.29), f);\n                        \n            state.hitDist = groundDist;\n        } else {\n        \n            state.fhp = ray.origin + ray.direction * t;\n        \n            // Glass\n            if (matId > 0.5 && matId < 1.5) {\n                state.mat.baseColor = vec3(2);\n                state.mat.specTrans = 1.;\n                state.mat.roughness = 0.0;\n\n            } else\n            // Red\n            if (matId > 1.5 && matId < 2.5) {\n                state.mat.baseColor = vec3(1, 0, 0);\n                state.mat.roughness = 0.5;\n                state.mat.metallic = 0.2;\n            } else\n            // Orange\n            if (matId > 2.5 && matId < 3.5) {\n                state.mat.baseColor = vec3(1, 0.186, 0.);\n                state.mat.roughness = 0.001;\n                state.mat.clearcoat = 1.0;\n                state.mat.clearcoatRoughness = 1.0;\n            } else\n            // Ping\n            if (matId > 3.5 && matId < 4.5) {\n                state.mat.baseColor = vec3(0.93, 0.89, 0.85);\n                state.mat.roughness = 1.;\n                state.mat.subsurface = 1.0;\n            } else\n            // Silver\n            if (matId > 4.5 && matId < 5.5) {\n                state.mat.baseColor = vec3(0.9, 0.9, 0.9);\n                state.mat.roughness = 0.0;\n                state.mat.metallic = 1.;\n            } else\n            // Marble\n            if (matId > 5.5 && matId < 6.5) {\n                state.mat.baseColor = vec3(0.099, 0.24, 0.134);\n                state.mat.roughness = 0.001;\n                state.mat.clearcoat = 1.0;\n                state.mat.clearcoatRoughness = 1.0;\n            }\n            \n            if (shadowRay == false) {\n                state.normal = calculateNormal(state.fhp);\n            }\n            \n            state.hitDist = t;\n        }\n        \n        // Hack for enabling transparent reflections\n        if (shadowRay == true && state.mat.specTrans > 0.5) hit = false;\n    }\n    \n    return hit;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Port of https://github.com/knightcrawler25/GLSL-PathTracer\n// Copyright(c) 2019-2021 Asif Ali\n\n// Headers\n\nstruct BsdfSampleRec\n{\n    vec3 L;\n    vec3 f;\n    float pdf;\n};\n\nstruct LightSampleRec\n{\n    vec3 normal;\n    vec3 emission;\n    vec3 direction;\n    float dist;\n    float pdf;\n};\n\nuvec4 seed;\nivec2 pixel;\n\nint numOfLights;\n\nvoid InitRNG(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n    seed = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\nvoid pcg4d(inout uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n    v = v ^ (v >> 16u);\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n}\n\nfloat rand()\n{\n    pcg4d(seed); return float(seed.x) / float(0xffffffffu);\n}\n\nvec3 FaceForward(vec3 a, vec3 b)\n{\n    return dot(a, b) < 0.0 ? -b : b;\n}\n\nfloat Luminance(vec3 c)\n{\n    return 0.212671 * c.x + 0.715160 * c.y + 0.072169 * c.z;\n}\n\n// Camera\n\nRay getCameraRay(vec2 offset) {\n    vec3 origin = vec3(0);\n    vec3 lookAt = vec3(0);\n    \n    getCameraPos(origin, lookAt);\n\n    vec2 uv = (gl_FragCoord.xy + offset) / iResolution.xy - .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( lookAt - origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 direction = normalize( uv.x * ix + uv.y * iy + .85 * iz );\n\n    return Ray(origin, direction);\n}\n\n\n// Sampling\n\nfloat GTR1(float NDotH, float a)\n{\n    if (a >= 1.0)\n        return INV_PI;\n    float a2 = a * a;\n    float t = 1.0 + (a2 - 1.0) * NDotH * NDotH;\n    return (a2 - 1.0) / (PI * log(a2) * t);\n}\n\nvec3 SampleGTR1(float rgh, float r1, float r2)\n{\n    float a = max(0.001, rgh);\n    float a2 = a * a;\n\n    float phi = r1 * TWO_PI;\n\n    float cosTheta = sqrt((1.0 - pow(a2, 1.0 - r1)) / (1.0 - a2));\n    float sinTheta = clamp(sqrt(1.0 - (cosTheta * cosTheta)), 0.0, 1.0);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\nfloat GTR2(float NDotH, float a)\n{\n    float a2 = a * a;\n    float t = 1.0 + (a2 - 1.0) * NDotH * NDotH;\n    return a2 / (PI * t * t);\n}\n\nvec3 SampleGTR2(float rgh, float r1, float r2)\n{\n    float a = max(0.001, rgh);\n\n    float phi = r1 * TWO_PI;\n\n    float cosTheta = sqrt((1.0 - r2) / (1.0 + (a * a - 1.0) * r2));\n    float sinTheta = clamp(sqrt(1.0 - (cosTheta * cosTheta)), 0.0, 1.0);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\nvec3 SampleGGXVNDF(vec3 V, float rgh, float r1, float r2)\n{\n    vec3 Vh = normalize(vec3(rgh * V.x, rgh * V.y, V.z));\n\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * inversesqrt(lensq) : vec3(1, 0, 0);\n    vec3 T2 = cross(Vh, T1);\n\n    float r = sqrt(r1);\n    float phi = 2.0 * PI * r2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n    return normalize(vec3(rgh * Nh.x, rgh * Nh.y, max(0.0, Nh.z)));\n}\n\nfloat GTR2Aniso(float NDotH, float HDotX, float HDotY, float ax, float ay)\n{\n    float a = HDotX / ax;\n    float b = HDotY / ay;\n    float c = a * a + b * b + NDotH * NDotH;\n    return 1.0 / (PI * ax * ay * c * c);\n}\n\nvec3 SampleGTR2Aniso(float ax, float ay, float r1, float r2)\n{\n    float phi = r1 * TWO_PI;\n\n    float sinPhi = ay * sin(phi);\n    float cosPhi = ax * cos(phi);\n    float tanTheta = sqrt(r2 / (1.0 - r2));\n\n    return vec3(tanTheta * cosPhi, tanTheta * sinPhi, 1.0);\n}\n\nfloat SmithG(float NDotV, float alphaG)\n{\n    float a = alphaG * alphaG;\n    float b = NDotV * NDotV;\n    return (2.0 * NDotV) / (NDotV + sqrt(a + b - a * b));\n}\n\nfloat SmithGAniso(float NDotV, float VDotX, float VDotY, float ax, float ay)\n{\n    float a = VDotX * ax;\n    float b = VDotY * ay;\n    float c = NDotV;\n    return 1.0 / (NDotV + sqrt(a * a + b * b + c * c));\n}\n\nfloat SchlickFresnel(float u)\n{\n    float m = clamp(1.0 - u, 0.0, 1.0);\n    float m2 = m * m;\n    return m2 * m2 * m;\n}\n\nfloat DielectricFresnel(float cosThetaI, float eta)\n{\n    float sinThetaTSq = eta * eta * (1.0f - cosThetaI * cosThetaI);\n\n    // Total internal reflection\n    if (sinThetaTSq > 1.0)\n        return 1.0;\n\n    float cosThetaT = sqrt(max(1.0 - sinThetaTSq, 0.0));\n\n    float rs = (eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI);\n    float rp = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);\n\n    return 0.5f * (rs * rs + rp * rp);\n}\n\nvec3 CosineSampleHemisphere(float r1, float r2)\n{\n    vec3 dir;\n    float r = sqrt(r1);\n    float phi = TWO_PI * r2;\n    dir.x = r * cos(phi);\n    dir.y = r * sin(phi);\n    dir.z = sqrt(max(0.0, 1.0 - dir.x * dir.x - dir.y * dir.y));\n    return dir;\n}\n\nvec3 UniformSampleHemisphere(float r1, float r2)\n{\n    float r = sqrt(max(0.0, 1.0 - r1 * r1));\n    float phi = TWO_PI * r2;\n    return vec3(r * cos(phi), r * sin(phi), r1);\n}\n\nvec3 UniformSampleSphere(float r1, float r2)\n{\n    float z = 1.0 - 2.0 * r1;\n    float r = sqrt(max(0.0, 1.0 - z * z));\n    float phi = TWO_PI * r2;\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nfloat PowerHeuristic(float a, float b)\n{\n    float t = a * a;\n    return t / (b * b + t);\n}\n\nvoid Onb(in vec3 N, inout vec3 T, inout vec3 B)\n{\n    vec3 up = abs(N.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    T = normalize(cross(up, N));\n    B = cross(N, T);\n}\n\nvoid SampleSphereLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec)\n{\n    float r1 = rand();\n    float r2 = rand();\n\n    vec3 sphereCentertoSurface = surfacePos - light.position;\n    float distToSphereCenter = length(sphereCentertoSurface);\n    vec3 sampledDir;\n\n    // TODO: Fix this. Currently assumes the light will be hit only from the outside\n    sphereCentertoSurface /= distToSphereCenter;\n    sampledDir = UniformSampleHemisphere(r1, r2);\n    vec3 T, B;\n    Onb(sphereCentertoSurface, T, B);\n    sampledDir = T * sampledDir.x + B * sampledDir.y + sphereCentertoSurface * sampledDir.z;\n\n    vec3 lightSurfacePos = light.position + sampledDir * light.radius;\n\n    lightSampleRec.direction = lightSurfacePos - surfacePos;\n    lightSampleRec.dist = length(lightSampleRec.direction);\n    float distSq = lightSampleRec.dist * lightSampleRec.dist;\n\n    lightSampleRec.direction /= lightSampleRec.dist;\n    lightSampleRec.normal = normalize(lightSurfacePos - light.position);\n    lightSampleRec.emission = light.emission * float(numOfLights);\n    lightSampleRec.pdf = distSq / (light.area * 0.5 * abs(dot(lightSampleRec.normal, lightSampleRec.direction)));\n}\n\nvoid SampleRectLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec)\n{\n    float r1 = rand();\n    float r2 = rand();\n\n    vec3 lightSurfacePos = light.position + light.u * r1 + light.v * r2;\n    lightSampleRec.direction = lightSurfacePos - surfacePos;\n    lightSampleRec.dist = length(lightSampleRec.direction);\n    float distSq = lightSampleRec.dist * lightSampleRec.dist;\n    lightSampleRec.direction /= lightSampleRec.dist;\n    lightSampleRec.normal = normalize(cross(light.u, light.v));\n    lightSampleRec.emission = light.emission * float(numOfLights);\n    lightSampleRec.pdf = distSq / (light.area * abs(dot(lightSampleRec.normal, lightSampleRec.direction)));\n}\n\nvoid SampleDistantLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec)\n{\n    lightSampleRec.direction = normalize(light.position - vec3(0.0));\n    lightSampleRec.normal = normalize(surfacePos - light.position);\n    lightSampleRec.emission = light.emission * float(numOfLights);\n    lightSampleRec.dist = INF;\n    lightSampleRec.pdf = 1.0;\n}\n\nvoid SampleOneLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec)\n{\n    int type = int(light.type);\n\n    if (type == QUAD_LIGHT)\n        SampleRectLight(light, surfacePos, lightSampleRec);\n    else if (type == SPHERE_LIGHT)\n        SampleSphereLight(light, surfacePos, lightSampleRec);\n    else\n        SampleDistantLight(light, surfacePos, lightSampleRec);\n}\n\n\nvec3 EmitterSample(in Ray r, in State state, in LightSampleRec lightSampleRec, in BsdfSampleRec bsdfSampleRec)\n{\n    vec3 Le;\n\n    if (state.depth == 0)\n        Le = lightSampleRec.emission;\n    else\n        Le = PowerHeuristic(bsdfSampleRec.pdf, lightSampleRec.pdf) * lightSampleRec.emission;\n\n    return Le;\n}\n\n// Disney\n\nvec3 ToWorld(vec3 X, vec3 Y, vec3 Z, vec3 V)\n{\n    return V.x * X + V.y * Y + V.z * Z;\n}\n\nvec3 ToLocal(vec3 X, vec3 Y, vec3 Z, vec3 V)\n{\n    return vec3(dot(V, X), dot(V, Y), dot(V, Z));\n}\n\nfloat FresnelMix(Material mat, float eta, float VDotH)\n{\n    float metallicFresnel = SchlickFresnel(VDotH);\n    float dielectricFresnel = DielectricFresnel(VDotH, eta);\n    return mix(dielectricFresnel, metallicFresnel, mat.metallic);\n}\n\nvec3 EvalDiffuse(Material mat, vec3 Csheen, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    pdf = 0.0;\n    if (L.z <= 0.0)\n        return vec3(0.0);\n\n    // Diffuse\n    float FL = SchlickFresnel(L.z);\n    float FV = SchlickFresnel(V.z);\n    float FH = SchlickFresnel(dot(L, H));\n    float Fd90 = 0.5 + 2.0 * dot(L, H) * dot(L, H) * mat.roughness;\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n\n    // Fake Subsurface TODO: Replace with volumetric scattering\n    float Fss90 = dot(L, H) * dot(L, H) * mat.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (L.z + V.z) - 0.5) + 0.5);\n\n    // Sheen\n    vec3 Fsheen = FH * mat.sheen * Csheen;\n\n    pdf = L.z * INV_PI;\n    return (INV_PI * mix(Fd, ss, mat.subsurface) * mat.baseColor + Fsheen) * (1.0 - mat.metallic) * (1.0 - mat.specTrans);\n}\n\nvec3 EvalSpecReflection(Material mat, float eta, vec3 specCol, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    pdf = 0.0;\n    if (L.z <= 0.0)\n        return vec3(0.0);\n\n    float FM = FresnelMix(mat, eta, dot(L, H));\n    vec3 F = mix(specCol, vec3(1.0), FM);\n    float D = GTR2(H.z, mat.roughness);\n    float G1 = SmithG(abs(V.z), mat.roughness);\n    float G2 = G1 * SmithG(abs(L.z), mat.roughness);\n    float jacobian = 1.0 / (4.0 * dot(V, H));\n\n    pdf = G1 * max(0.0, dot(V, H)) * D * jacobian / V.z;\n    return F * D * G2 / (4.0 * L.z * V.z);\n}\n\nvec3 EvalSpecRefraction(Material mat, float eta, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    pdf = 0.0;\n    if (L.z >= 0.0)\n        return vec3(0.0);\n\n    float F = DielectricFresnel(abs(dot(V, H)), eta);\n    float D = GTR2(H.z, mat.roughness);\n    float denom = dot(L, H) + dot(V, H) * eta;\n    denom *= denom;\n    float G1 = SmithG(abs(V.z), mat.roughness);\n    float G2 = G1 * SmithG(abs(L.z), mat.roughness);\n    float jacobian = abs(dot(L, H)) / denom;\n\n    pdf = G1 * max(0.0, dot(V, H)) * D * jacobian / V.z;\n\n    vec3 specColor = pow(mat.baseColor, vec3(0.5));\n    return specColor * (1.0 - mat.metallic) * mat.specTrans * (1.0 - F) * D * G2 * abs(dot(V, H)) * abs(dot(L, H)) * eta * eta / (denom * abs(L.z) * abs(V.z));\n}\n\nvec3 EvalClearcoat(Material mat, vec3 V, vec3 L, vec3 H, out float pdf)\n{\n    pdf = 0.0;\n    if (L.z <= 0.0)\n        return vec3(0.0);\n\n    float FH = DielectricFresnel(dot(V, H), 1.0 / 1.5);\n    float F = mix(0.04, 1.0, FH);\n    float D = GTR1(H.z, mat.clearcoatRoughness);\n    float G = SmithG(L.z, 0.25)\n        * SmithG(V.z, 0.25);\n    float jacobian = 1.0 / (4.0 * dot(V, H));\n\n    pdf = D * H.z * jacobian;\n    return vec3(0.25) * mat.clearcoat * F * D * G / (4.0 * L.z * V.z);\n}\n\nvoid GetSpecColor(Material mat, float eta, out vec3 specCol, out vec3 sheenCol)\n{\n    float lum = Luminance(mat.baseColor);\n    vec3 ctint = lum > 0.0 ? mat.baseColor / lum : vec3(1.0f);\n    float F0 = (1.0 - eta) / (1.0 + eta);\n    specCol = mix(F0 * F0 * mix(vec3(1.0), ctint, mat.specularTint), mat.baseColor, mat.metallic);\n    sheenCol = mix(vec3(1.0), ctint, mat.sheenTint);\n}\n\nvoid GetLobeProbabilities(Material mat, float eta, vec3 specCol, float approxFresnel, out float diffuseWt, out float specReflectWt, out float specRefractWt, out float clearcoatWt)\n{\n    diffuseWt = Luminance(mat.baseColor) * (1.0 - mat.metallic) * (1.0 - mat.specTrans);\n    specReflectWt = Luminance(mix(specCol, vec3(1.0), approxFresnel));\n    specRefractWt = (1.0 - approxFresnel) * (1.0 - mat.metallic) * mat.specTrans * Luminance(mat.baseColor);\n    clearcoatWt = mat.clearcoat * (1.0 - mat.metallic);\n    float totalWt = diffuseWt + specReflectWt + specRefractWt + clearcoatWt;\n\n    diffuseWt /= totalWt;\n    specReflectWt /= totalWt;\n    specRefractWt /= totalWt;\n    clearcoatWt /= totalWt;\n}\n\nvec3 DisneySample(State state, vec3 V, vec3 N, out vec3 L, out float pdf)\n{\n    pdf = 0.0;\n    vec3 f = vec3(0.0);\n\n    float r1 = rand();\n    float r2 = rand();\n\n    vec3 T, B;\n    Onb(N, T, B);\n    V = ToLocal(T, B, N, V); // NDotL = L.z; NDotV = V.z; NDotH = H.z\n\n    // Specular and sheen color\n    vec3 specCol, sheenCol;\n    GetSpecColor(state.mat, state.eta, specCol, sheenCol);\n\n    // Lobe weights\n    float diffuseWt, specReflectWt, specRefractWt, clearcoatWt;\n    // TODO: Recheck fresnel. Not sure if correct. VDotN produces fireflies with rough dielectric.\n    // VDotH matches Mitsuba and gets rid of all fireflies but H isn't available at this stage\n    float approxFresnel = FresnelMix(state.mat, state.eta, V.z);\n    GetLobeProbabilities(state.mat, state.eta, specCol, approxFresnel, diffuseWt, specReflectWt, specRefractWt, clearcoatWt);\n\n    // CDF for picking a lobe\n    float cdf[4];\n    cdf[0] = diffuseWt;\n    cdf[1] = cdf[0] + specReflectWt;\n    cdf[2] = cdf[1] + specRefractWt;\n    cdf[3] = cdf[2] + clearcoatWt;\n\n    if (r1 < cdf[0]) // Diffuse Reflection Lobe\n    {\n        r1 /= cdf[0];\n        L = CosineSampleHemisphere(r1, r2);\n\n        vec3 H = normalize(L + V);\n\n        f = EvalDiffuse(state.mat, sheenCol, V, L, H, pdf);\n        pdf *= diffuseWt;\n    }\n    else if (r1 < cdf[1]) // Specular Reflection Lobe\n    {\n        r1 = (r1 - cdf[0]) / (cdf[1] - cdf[0]);\n        vec3 H = SampleGGXVNDF(V, state.mat.roughness, r1, r2);\n\n        if (H.z < 0.0)\n            H = -H;\n\n        L = normalize(reflect(-V, H));\n\n        f = EvalSpecReflection(state.mat, state.eta, specCol, V, L, H, pdf);\n        pdf *= specReflectWt;\n    }\n    else if (r1 < cdf[2]) // Specular Refraction Lobe\n    {\n        r1 = (r1 - cdf[1]) / (cdf[2] - cdf[1]);\n        vec3 H = SampleGGXVNDF(V, state.mat.roughness, r1, r2);\n\n        if (H.z < 0.0)\n            H = -H;\n\n        L = normalize(refract(-V, H, state.eta));\n\n        f = EvalSpecRefraction(state.mat, state.eta, V, L, H, pdf);\n        pdf *= specRefractWt;\n    }\n    else // Clearcoat Lobe\n    {\n        r1 = (r1 - cdf[2]) / (1.0 - cdf[2]);\n        vec3 H = SampleGTR1(state.mat.clearcoatRoughness, r1, r2);\n\n        if (H.z < 0.0)\n            H = -H;\n\n        L = normalize(reflect(-V, H));\n\n        f = EvalClearcoat(state.mat, V, L, H, pdf);\n        pdf *= clearcoatWt;\n    }\n\n    L = ToWorld(T, B, N, L);\n    return f * abs(dot(N, L));\n}\n\nvec3 DisneyEval(State state, vec3 V, vec3 N, vec3 L, out float bsdfPdf)\n{\n    bsdfPdf = 0.0;\n    vec3 f = vec3(0.0);\n\n    vec3 T, B;\n    Onb(N, T, B);\n    V = ToLocal(T, B, N, V); // NDotL = L.z; NDotV = V.z; NDotH = H.z\n    L = ToLocal(T, B, N, L);\n\n    vec3 H;\n    if (L.z > 0.0)\n        H = normalize(L + V);\n    else\n        H = normalize(L + V * state.eta);\n\n    if (H.z < 0.0)\n        H = -H;\n\n    // Specular and sheen color\n    vec3 specCol, sheenCol;\n    GetSpecColor(state.mat, state.eta, specCol, sheenCol);\n\n    // Lobe weights\n    float diffuseWt, specReflectWt, specRefractWt, clearcoatWt;\n    float fresnel = FresnelMix(state.mat, state.eta, dot(V, H));\n    GetLobeProbabilities(state.mat, state.eta, specCol, fresnel, diffuseWt, specReflectWt, specRefractWt, clearcoatWt);\n\n    float pdf;\n\n    // Diffuse\n    if (diffuseWt > 0.0 && L.z > 0.0)\n    {\n        f += EvalDiffuse(state.mat, sheenCol, V, L, H, pdf);\n        bsdfPdf += pdf * diffuseWt;\n    }\n\n    // Specular Reflection\n    if (specReflectWt > 0.0 && L.z > 0.0 && V.z > 0.0)\n    {\n        f += EvalSpecReflection(state.mat, state.eta, specCol, V, L, H, pdf);\n        bsdfPdf += pdf * specReflectWt;\n    }\n\n    // Specular Refraction\n    if (specRefractWt > 0.0 && L.z < 0.0)\n    {\n        f += EvalSpecRefraction(state.mat, state.eta, V, L, H, pdf);\n        bsdfPdf += pdf * specRefractWt;\n    }\n\n    // Clearcoat\n    if (clearcoatWt > 0.0 && L.z > 0.0 && V.z > 0.0)\n    {\n        f += EvalClearcoat(state.mat, V, L, H, pdf);\n        bsdfPdf += pdf * clearcoatWt;\n    }\n\n    return f * abs(L.z);\n}\n\n// Intersection\n\nfloat SphereIntersect(float rad, vec3 pos, Ray r)\n{\n    vec3 op = pos - r.origin;\n    float eps = 0.001;\n    float b = dot(op, r.direction);\n    float det = b * b - dot(op, op) + rad * rad;\n    if (det < 0.0)\n        return INF;\n\n    det = sqrt(det);\n    float t1 = b - det;\n    if (t1 > eps)\n        return t1;\n\n    float t2 = b + det;\n    if (t2 > eps)\n        return t2;\n\n    return INF;\n}\n\nfloat RectIntersect(in vec3 pos, in vec3 u, in vec3 v, in vec4 plane, in Ray r)\n{\n    vec3 n = vec3(plane);\n    float dt = dot(r.direction, n);\n    float t = (plane.w - dot(n, r.origin)) / dt;\n\n    if (t > EPS)\n    {\n        vec3 p = r.origin + r.direction * t;\n        vec3 vi = p - pos;\n        float a1 = dot(u, vi);\n        if (a1 >= 0.0 && a1 <= 1.0)\n        {\n            float a2 = dot(v, vi);\n            if (a2 >= 0.0 && a2 <= 1.0)\n                return t;\n        }\n    }\n\n    return INF;\n}\n\n\n// DirectLight\nvec3 DirectLight(in Ray r, in State state)\n{\n    vec3 Li = vec3(0.0);\n    vec3 surfacePos = state.fhp + state.normal * EPS;\n\n    BsdfSampleRec bsdfSampleRec;\n\n//#define ENVMAP\n    // Environment Light\n#ifdef ENVMAP\n#ifndef CONSTANT_BG\n    {\n        vec3 color;\n        vec4 dirPdf = SampleEnvMap(color);\n        vec3 lightDir = dirPdf.xyz;\n        float lightPdf = dirPdf.w;\n\n        Ray shadowRay = Ray(surfacePos, lightDir);\n        bool inShadow = AnyHit(shadowRay, INF - EPS);\n\n        if (!inShadow)\n        {\n            bsdfSampleRec.f = DisneyEval(state, -r.direction, state.ffnormal, lightDir, bsdfSampleRec.pdf);\n\n            if (bsdfSampleRec.pdf > 0.0)\n            {\n                float misWeight = PowerHeuristic(lightPdf, bsdfSampleRec.pdf);\n                if (misWeight > 0.0)\n                    Li += misWeight * bsdfSampleRec.f * color / lightPdf;\n            }\n        }\n    }\n#endif\n#endif\n\n    // Analytic Lights \n#ifdef LIGHTS\n    {\n        LightSampleRec lightSampleRec;\n\n        //Pick a light to sample\n        int index = int(rand() * float(numOfLights));\n\n        Light light = lights[index];\n\n        light = Light(light.position, light.emission, light.u, light.v, light.radius, light.area, light.type);\n        SampleOneLight(light, surfacePos, lightSampleRec);\n\n        if (dot(lightSampleRec.direction, lightSampleRec.normal) < 0.0) // Required for quad lights with single sided emission\n        {\n            Ray shadowRay = Ray(surfacePos, lightSampleRec.direction);\n            bool inShadow = getSceneHit(shadowRay, true, state);//AnyHit(shadowRay, lightSampleRec.dist - EPS);\n\n            if (!inShadow) {\n                bsdfSampleRec.f = DisneyEval(state, -r.direction, state.ffnormal, lightSampleRec.direction, bsdfSampleRec.pdf);\n\n                float weight = 1.0;\n                if(light.area > 0.0) // No MIS for distant light\n                    weight = PowerHeuristic(lightSampleRec.pdf, bsdfSampleRec.pdf);\n\n                if (bsdfSampleRec.pdf > 0.0)\n                    Li += weight * bsdfSampleRec.f * lightSampleRec.emission / lightSampleRec.pdf;\n            }\n        }\n    }\n#endif\n\n    return Li;\n}\n\n// Path tracer\n\nvec3 PathTrace(Ray r)\n{\n    vec3 radiance = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    State state;\n    LightSampleRec lightSampleRec;\n    BsdfSampleRec bsdfSampleRec;\n    vec3 absorption = vec3(0.0);\n    \n    // Initial material values\n    state.mat.anisotropic  = 0.0;\n\n    state.mat.metallic     = 0.0;\n    state.mat.roughness    = 0.5;\n    state.mat.subsurface   = 0.0;\n    state.mat.specularTint = 0.0;\n            \n    state.mat.sheen        = 0.0;\n    state.mat.sheenTint    = 0.0;\n    state.mat.clearcoat    = 0.0;\n    state.mat.clearcoatRoughness = 0.0;\n            \n    state.mat.roughness    = 0.;\n    state.mat.ior          = 1.45;\n    state.mat.extinction   = vec3(1);\n    state.mat.atDistance   = 1.;\n\n\n    initLights();\n    numOfLights = NUM_LIGHTS;\n\n    const int maxDepth = 4;\n    for (int depth = 0; depth < maxDepth; depth++)\n    {\n        state.depth = depth;\n        bool hit = getSceneHit(r, false, state);\n\n        if (!hit) {\n            radiance += getBackground(r) * throughput;\n        } else {        \n            state.ffnormal = dot(state.normal, r.direction) <= 0.0 ? state.normal : -state.normal;\n            Onb(state.normal, state.tangent, state.bitangent);\n            state.mat.roughness = max(state.mat.roughness, 0.001);\n            state.eta = dot(state.normal, state.ffnormal) > 0.0 ? (1.0 / state.mat.ior) : state.mat.ior;\n        }\n        \n        // Lights\n        for (int i = 0; i < numOfLights; i++)\n        {\n            Light light = lights[i];\n            \n            // Intersect rectangular area light\n            if (light.type == 0)\n            {\n                vec3 u = light.u;\n                vec3 v = light.v;\n                vec3 normal = normalize(cross(light.u, light.v));\n                //if (dot(normal, r.direction) > 0.) // Hide backfacing quad light\n                    //continue;\n                vec4 plane = vec4(normal, dot(normal, light.position));\n                u *= 1.0f / dot(u, u);\n                v *= 1.0f / dot(v, v);\n\n                float d = RectIntersect(light.position, u, v, plane, r);\n                if (d < 0.)\n                    d = INF;\n                    \n                if (d < state.hitDist)\n                {\n                    state.hitDist = d;\n                    float cosTheta = dot(-r.direction, normal);\n                    float pdf = (d * d) / (light.area * cosTheta);\n                    lightSampleRec.emission = light.emission;\n                    lightSampleRec.pdf = pdf;\n                    state.isEmitter = true;\n                }\n            } else\n            // Intersect spherical area light\n            if (light.type == 1)\n            {\n                float d = SphereIntersect(light.radius, light.position, r);\n                if (d < 0.)\n                    d = INF;\n                if (d < state.hitDist)\n                {\n                    state.hitDist = d;\n                    float pdf = (d * d) / light.area;\n                    lightSampleRec.emission = light.emission;\n                    lightSampleRec.pdf = pdf;\n                    state.isEmitter = true;\n                }\n            }\n        }\n        \n        // Reset absorption when ray is going out of surface\n        if (dot(state.normal, state.ffnormal) > 0.0)\n            absorption = vec3(0.0);\n\n        radiance += state.mat.emission * throughput;\n\n#ifdef LIGHTS\n        if (state.isEmitter)\n        {\n            radiance += EmitterSample(r, state, lightSampleRec, bsdfSampleRec) * throughput;\n            break;\n        }\n#endif\n\n        // Add absoption\n        throughput *= exp(-absorption * state.hitDist);\n\n        radiance += DirectLight(r, state) * throughput;\n\n        bsdfSampleRec.f = DisneySample(state, -r.direction, state.ffnormal, bsdfSampleRec.L, bsdfSampleRec.pdf);\n\n        // Set absorption only if the ray is currently inside the object.\n        if (dot(state.ffnormal, bsdfSampleRec.L) < 0.0)\n            absorption = -log(state.mat.extinction) / state.mat.atDistance;\n\n        if (bsdfSampleRec.pdf > 0.0)\n            throughput *= bsdfSampleRec.f / bsdfSampleRec.pdf;\n        else\n            break;\n\n#ifdef RR\n        // Russian roulette\n        if (depth >= RR_DEPTH)\n        {\n            float q = min(max(throughput.x, max(throughput.y, throughput.z)) + 0.001, 0.95);\n            if (rand() > q)\n                break;\n            throughput /= q;\n        }\n#endif\n\n        r.direction = bsdfSampleRec.L;\n        r.origin = state.fhp + r.direction * EPS;\n    }\n\n    return radiance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitRNG(fragCoord, iFrame);\n\n    // Camera\n    Ray ray = getCameraRay(vec2(rand(), rand()));\n\n    // Pathtrace\n    vec3 col = PathTrace(ray);\n    col = clamp(col, 0., 5.);\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel1, uv) * (1. - 1./float(iFrame+1)) + texture(iChannel0, uv) * 1./float(iFrame + 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}