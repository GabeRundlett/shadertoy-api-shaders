{
    "Shader": {
        "info": {
            "date": "1683696141",
            "description": "Rigid body dice colliding with the ground (not each other [yet!]). An ode to games and chance.\n\nFeaturing:\nfizzer's Simple and Cheap Dice SDF: https://shadertoy.com/view/csySDG\nwnu's sparkle commented: https://www.shadertoy.com/view/Ndlczs\n\n*mouse: grab*",
            "flags": 32,
            "hasliked": 0,
            "id": "dsySDK",
            "likes": 20,
            "name": "Physical Dice",
            "published": 3,
            "tags": [
                "simulation",
                "interactive",
                "shadows",
                "physics",
                "dice",
                "multipass",
                "rigidbody"
            ],
            "usePreview": 1,
            "username": "fenix",
            "viewed": 399
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Rigid body dice colliding with the ground (not each other [yet!]). An ode to games\n//  and chance. Featuring code from:\n//\n//  The inspiration for this shader, fizzer's excellent\n//\n//      Simple and Cheap Dice SDF:      https://shadertoy.com/view/csySDG\n//\n//  wnu's beautiful\n//\n//      sparkle commented:              https://shadertoy.com/view/Ndlczs\n// \n//  Card suit SDFs were made using my own tool:\n//\n//      Polygon SDF Modelling Tool:     https://shadertoy.com/view/dtBSDw\n//\n//  Dipping my toes into rigid body physics simulation. Contact constraints are resolved\n//  via an iterative accumulation solver, and feature warm starting, restitution,\n//  friction, and position correction.\n//\n//  Dont's miss: mouse can grab and drag/throw dice!\n//\n//  The rendering is a fairly typical voronoi system, from both the camera and light\n//  source perspectives (the latter, for shadows). The shadows were somewhat tricky to\n//  get lined up correctly, and once I did I found a perspective projection was causing\n//  large shadows to be cast by dice passing close to the light source. So I switched to\n//  an orthographic projection and had to line the shadows up again. :P\n//\n//  Continuing with the theme of \"chance\", I figured there was a chance users might not\n//  notice, at least right away, that the dice don't collide with each other. :)\n//\n//  I do intend to keep going on research in this direction, and getting the bodies to\n//  collide against each other is a top priority. I think I just need to figure out some\n//  clever way to address the contact impulses for body pairs. If anyone know of any\n//  papers, shaders, or other prior art I would be very interested.\n//\n//  I have attempted to write clear code and detailed comments. Please let me know if I\n//  should explain anything in more detail.\n//\n// ---------------------------------------------------------------------------------------\n\n#define MSAA 1 // 1 to disable (for more speed), 2 for 2x2, 3 for 3x3, etc.\n\n// from fizzer's Simple and Cheap Dice SDF: https://shadertoy.com/view/csySDG\n// Distance to hemisphere-shaped hole in a plane.\nfloat hole(vec3 p, float r)\n{\n    float c = min(0., length(p.xz) - r);\n    return (p.y > 0.) ? length(vec2(c, p.y)) : r - length(p);\n}\n\n// Die SDF.\nfloat sdDie(vec3 p)\n{\n    // Get index of closest face on die, and local point b.\n    vec3 q = abs(p);\n\n    bvec3 dots = sign(p.z) > 0. ? bvec3(false, true, true) : bvec3(true, true, false);\n    vec3 b = p.xzy * sign(p.z);\n\n    if(q.x > q.y && q.x > q.z)\n    {\n        b = p.zxy * sign(p.x);\n        b.z = -b.z;\n        dots = sign(p.x) > 0. ? bvec3(false, true, false) : bvec3(true, true, true);\n    }\n    else if(q.y > q.z)\n    {\n        b = p.zyx * sign(p.y);\n        dots = sign(p.y) > 0. ? bvec3(false, false, true) : bvec3(false, false, false);\n    }\n    \n    // Some parameteric constants.\n    float r = .02, r2 = .04 ,r3 = .13;\n\n    b.y -= .5 - r;\n    \n    float d;\n\n    if(all(not(dots)))\n    {\n        // Special case for side 6.\n        b.x = abs(b.x);\n        b.z = mod(b.z + .3 / 2., .3) - .3 / 2.;\n        d = hole(b - vec3(.2, 0, 0), r3);\n    }\n    else\n    {\n        // The sides other than 6 have reflective symmetry in two lines.\n        if(b.x > -b.z)\n            b.xz = -b.zx;\n\n        if(b.x > b.z)\n            b.xz = b.zx;\n\n        // Thanks to this symmetry, the presence of only three dots account\n        // for all of the sides. So the effective LUT contains 3 bits per face.\n        if(b.z - b.x > .25)\n            d = dots.y ? hole(b - vec3(-1, 0, +1) / 4., r3) : b.y;\n        else if(-b.x - b.z > .25)\n            d = dots.x ? hole(b - vec3(-1, 0, -1) / 4., r3) : b.y;\n        else\n            d = dots.z ? hole(b, r3): b.y;\n    }\n    \n    // Use sdRoundBox to bevel the outer edges of the die.\n    return max(d - r, sdRoundBox(p, vec3(.5) - r2, r2));\n}\n\n// transform point from world space to body space\nvec3 bodyTrans(fxRigidBody b, vec3 p)\n{\n    return rotateVectorByQuat(p - b.pos, b.rot);\n}\n\nfloat sdBody(fxRigidBody b, vec3 p)\n{\n    p = bodyTrans(b, p);\n    return sdDie(p);\n}\n\nvec3 normBody(fxRigidBody b, vec3 p)\n{\n    float d = sdBody(b, p);\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        float d2d;\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdBody(b,p+0.000001*e);\n    }\n    return normalize(n);\n}\n\nvec3 dieColor(fxRigidBody b, vec3 p)\n{\n    p = bodyTrans(b, p);\n    return mix(vec3(0), vec3(1), smoothstep(.01, .02, sdRoundBox(p, vec3(.38), .1)));\n}\n\nfloat shadow(mat4 invMat, vec3 pos, vec3 lightPos, vec3 lightLeft, vec3 lightUp, int exception)\n{\n    vec3 sp = (invMat * vec4(pos, 1)).xyz;\n    sp.xy /= SHADOW_RES;\n    lightPos -= (lightLeft * sp.x + lightUp * sp.y) * SHADOW_RES;\n\n    vec2 r = iResolution.xy;\n    ivec2 coord = ivec2((sp.xy * vec2(r.y / r.x, 1) + .5) * r.xy);\n    if (coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y)) return 1.;\n\n    ivec4 old = fxGetClosestLight(coord);\n    float maxS = 0.;\n    for (int i = 0; i < 4; ++i)\n    {\n        int id = old[i];\n        if (id < 0) break;\n        if (id == exception) continue;\n        \n        vec3 bodyPos = fxGetBodyData(id, POS).xyz;\n        if (dot(bodyPos - pos, LIGHT_DIR) < 0.) continue;\n\n        vec4 bodyRot = fxGetBodyData(id, ROT);\n        vec3 localDir = rotateVectorByQuat(-LIGHT_DIR, bodyRot);\n        vec3 localOrigin = rotateVectorByQuat(lightPos - bodyPos, bodyRot);\n        float t = boxIntersection(localOrigin, localDir, vec3(.5));\n\n        if (t >= 0.)\n        {\n            maxS = max(maxS, smoothstep(8., 4., bodyPos.y)); // blend in shadows only near the ground\n        }\n    }\n    \n    return 1. - maxS;\n}\n\nvoid renderDie(int id, vec3 ro, vec3 rd, vec3 lightPos, vec3 lightLeft, vec3 lightUp, inout vec3 col, inout float maxT, mat4 invMat)\n{\n    fxRigidBody b = fxGetBody(id);\n    float t = 0.;\n    for(int i = 0; i < 100; ++i)\n    {\n        float d = sdBody(b, ro + rd * t);\n        if(abs(d) < 1e-4 || t > FAR_CLIP)\n            break;\n        t += d;\n    }\n\n    vec3 rp = ro + rd * t;\n        \n    if(t < maxT)\n    {\n        maxT = t;\n        \n        vec3 n = normBody(b, rp);\n        vec3 baseColor = dieColor(b, rp);\n        vec3 rr = reflect(rd, n);\n        vec3 spec = vec3(pow(dot(rr, LIGHT_DIR), 8.));\n        vec3 diff = vec3(0.5 + 0.5 * dot(n, LIGHT_DIR)) + vec3(0.5 + 0.5 * -n.y) * vec3(.1, .1, .2) * 1.5;\n        float fresnel = mix(0.01, .4, pow(clamp(1. + dot(rd, n), 0., 1.), 2.));\n\n        col = mix(baseColor * diff, spec, fresnel);\n\n        col *= shadow(invMat, rp, lightPos, lightLeft, lightUp, id) * .6 + .4;\n    }\n}\n\nconst int NUM_SPADE_VERTS = 11;\nconst vec2 SPADE_VERTS[NUM_SPADE_VERTS] = vec2[](\n    vec2(.0000,-.1333),\n    vec2(.1332,-.1720),\n    vec2(.1933,-.1690),\n    vec2(.2433,-.1353),\n    vec2(.2860,-.0811),\n    vec2(.2968, .0002),\n    vec2(.2738, .0715),\n    vec2(.2293, .1463),\n    vec2(.1500, .2117),\n    vec2(.0588, .2611),\n    vec2(.0000, .3944)\n);\n\nconst int NUM_TAIL_VERTS = 6;\nconst vec2 TAIL_VERTS[NUM_TAIL_VERTS] = vec2[](\n    vec2(.0000,-.3500),\n    vec2(.2077,-.3500),\n    vec2(.1118,-.2711),\n    vec2(.0589,-.2087),\n    vec2(.0158,-.1333),\n    vec2(.0000,-.1033)\n);\n\nconst int NUM_DIAMOND_VERTS = 7;\nconst vec2 DIAMOND_VERTS[NUM_DIAMOND_VERTS] = vec2[](\n    vec2(.0000,-.3655),\n    vec2(.0950,-.2267),\n    vec2(.1982,-.1086),\n    vec2(.3100,-.0011),\n    vec2(.1928, .1059),\n    vec2(.1074, .2135),\n    vec2(.0000, .3522)\n);\n\nconst int NUM_HEART_VERTS = 13;\nconst vec2 HEART_VERTS[NUM_HEART_VERTS] = vec2[](\n    vec2(.0000,-.3722),\n    vec2(.0369,-.3084),\n    vec2(.0724,-.2555),\n    vec2(.1203,-.2160),\n    vec2(.3477,-.0444),\n    vec2(.3898, .0161),\n    vec2(.4069, .0875),\n    vec2(.4051, .1644),\n    vec2(.3766, .2455),\n    vec2(.3350, .3174),\n    vec2(.2614, .3631),\n    vec2(.1659, .3701),\n    vec2(.0000, .3099)\n);\n\n// https://iquilezles.org/articles/distfunctions2d/\n#define DEFINE_POLYGON(X) \\\nfloat sdPolygon(int num, vec2 verts[X], vec2 p) \\\n{ \\\n    float d = dot(p-verts[0],p-verts[0]); \\\n    float s = 1.0; \\\n    for( int i=0, j=num-1; i<num; j=i, i++ ) \\\n    { \\\n        vec2 e = verts[j] - verts[i]; \\\n        vec2 w =    p - verts[i]; \\\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 ); \\\n        d = min( d, dot(b,b) ); \\\n        bvec3 cond = bvec3( p.y>=verts[i].y, \\\n                            p.y <verts[j].y, \\\n                            e.x*w.y>e.y*w.x ); \\\n        if( all(cond) || all(not(cond)) ) s=-s; \\\n    } \\\n    return s*sqrt(d); \\\n}\n\nDEFINE_POLYGON(NUM_SPADE_VERTS)\nDEFINE_POLYGON(NUM_TAIL_VERTS)\nDEFINE_POLYGON(NUM_DIAMOND_VERTS)\nDEFINE_POLYGON(NUM_HEART_VERTS)\n\nfloat sdSpade(vec2 p)\n{\n    p.x = abs(p.x);\n    return min(sdPolygon(NUM_SPADE_VERTS, SPADE_VERTS, p), sdPolygon(NUM_TAIL_VERTS, TAIL_VERTS, p));\n}\n\nfloat sdClub(vec2 p)\n{\n    p.x = abs(p.x);\n    float d = sdPolygon(NUM_TAIL_VERTS, TAIL_VERTS, p);\n    d = min(d, distance(p, vec2(0, .28)) - .18);\n    d = min(d, distance(p, vec2(.15, 0)) - .18);\n    d = min(d, distance(p, vec2(-.15, 0)) - .18);\n    return d;\n}\n\nfloat sdDiamond(vec2 p)\n{\n    p.x = abs(p.x);\n    p.y *= .9;\n    return sdPolygon(NUM_DIAMOND_VERTS, DIAMOND_VERTS, p);\n}\n\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x) * 1.5;\n    return sdPolygon(NUM_HEART_VERTS, HEART_VERTS, p);\n}\n\nfloat sdGround(vec2 p)\n{\n    ivec2 id = ivec2(mod(p, 4.));\n    p = (fract(p) - .5) * vec2(1, 1);\n\n    if (id.y == 0)\n    {\n        if (id.x == 0) return sdHeart(p);\n        if (id.x == 2) return sdClub(p);\n        return sdDiamond(p.yx * vec2(6, 1));\n    }\n    else if (id.y == 2)\n    {\n        if (id.x == 0) return sdSpade(p);\n        if (id.x == 2) return sdDiamond(p);\n        return sdDiamond(p.yx * vec2(6, 1));\n    }\n    if (id.x == 0 || id.x == 2) return sdDiamond(p * vec2(6, 1));;\n    return 1e6;\n}\n\nvec2 noise( in vec3 x )\n{\n    vec3 ip = floor(x);\n    vec3 fp = fract(x);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec4 rz = textureLod( iChannel3, (tap+0.5)/256.0, 0.0 );\n\treturn mix( rz.yw, rz.xz, fp.z );\n}\n\n// from sparkle commented by wnu: https://www.shadertoy.com/view/Ndlczs\nvec3 glitter(vec3 rayHit, vec3 normal, vec3 camDir, float sh)\n{\n    float t = iTime;\n    vec3 n = normal;\n\n    /////BASE COLOR\n\n    //FRESNEL \n\n    float fre = clamp(1. + dot(camDir,normal),-1.,1.);\n    float edge = sqrt(1.2-pow(fre,1./4.2));\n\n    //PICK YOUR COLOR\n\n    vec3 colorPick = vec3(1);\n\n    //COLOR FROM NORMALS AND FRESNEL\n\n    vec3 c = 2.25*-sin(sin(t*0. + n.x*1.+ 1.57 + sin(n.z*1. + 0.76)) + n.z + t*0.+  colorPick);\n    float ss = min(.5 - edge, smoothstep(.45 - edge, 1., edge));\n    c *= ss;\n\n    ///////GLINTS/GLITTER COMPUTATION\n\n    #define PRIMARY_INTENSITY 1.3\n    #define PRIMARY_CONCENTRATION 2.\n    #define SECONDARY_INTENSITY 8.\n    #define SECONDARY_CONCENTRATION 1.\n\n    // HOW BIG THE GLITTER SPECKS ARE ; BIGGER -> SMALLER SPECKS\n    // (7 is probably the smallest I would go)\n\n    float scale = 20.;\n    rayHit = floor(rayHit*scale)/scale;\n\n    vec3 h = normalize(LIGHT_DIR-camDir);\n    float nl = dot(n,LIGHT_DIR);\n\n    vec3 coord = rayHit*.5;\n    coord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n    coord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n    vec3 coord2 = coord;\n\n    //first layer (inner glints)\n    float pw = .5*((iResolution.x));\n    vec3 aniso = vec3( noise((coord*pw)), noise((coord.yzx*pw)) )*2.0-1.0;\n    aniso -= n*dot(aniso,n);\n    float anisotropy = min(1.,length(aniso));\n    aniso /= anisotropy;\n    anisotropy = .55;\n    float ah = abs(dot(h,aniso));\n    float nh = abs(dot(n,h));\n    float qa = exp2((1.1-anisotropy)*1.5);\n    nh = pow( nh, qa*PRIMARY_CONCENTRATION );\n    nh *= pow( 1.-ah*anisotropy, 10.0 );\n    vec3 glints = c*nh*exp2((1.2-anisotropy)*PRIMARY_INTENSITY);\n\n    //second layer (outer glints)\n    pw = .145*((iResolution.x));\n    vec3 aniso2 = vec3( noise(coord2*pw), noise(coord2.yzx*pw).x )*2.0-1.0;\n    anisotropy = .6;\n    float ah2 = abs(dot(h,aniso2));\n    float nh2 = abs(dot(n,h));\n    float q2 = exp2((.1-anisotropy)*3.5);\n    nh2 = pow( nh, q2*SECONDARY_CONCENTRATION );\n    nh2 *= pow( 1.-ah2*anisotropy, 150.0 );\n    vec3 glints2 = c*nh2*((1.-anisotropy)*SECONDARY_INTENSITY);\n\n    ///// ADD BASE COLOR AND GLINTS/GLITTER LAYERS   \n\n    vec3 col = vec3(c)/4.;\n    col += (glints+glints2) * .5 * sh + .3;\n\n    return col*col;\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvec3 renderScene(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    fxState state = fxGetState();\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCameraPath(cameraPos, cameraLookAt, iTime);\n    fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 lightFwd, lightLeft, lightUp, lightPos, lightLookAt;\n    fxLightPath(cameraLookAt, cameraFwd, lightPos, lightLookAt);\n    fxCalcCamera(lightPos, lightLookAt, lightFwd, lightLeft, lightUp);\n\n    mat4 lightMat = fxCalcCameraMat(iResolution, lightLeft, lightUp, lightFwd, lightPos);\n    mat4 invMat = inverse(lightMat);\n\n    float maxT = FAR_CLIP;\n    vec3 col = vec3(0);\n    \n    // render dice\n#if 1 // disable to skip voronoi and render all bodies (slow, ground truth)\n    ivec2 ifc = ivec2(fragCoord);\n    ivec4 old = fxGetClosestCamera(ifc);      \n\n    for (int i = 0; i < 4; ++i)\n    {\n        int id = old[i];\n        if (id < 0) break;\n#else\n    for (int id = 0; id < NUM_BODIES; ++id)\n    {\n#endif\n        renderDie(id, cameraPos, rayDir, lightPos, lightLeft, lightUp, col, maxT, invMat); \n    }\n   \n    // render ground if we missed all the dice\n    if (maxT == FAR_CLIP)\n    {\n        float t = -cameraPos.y / rayDir.y;\n        vec3 hit = cameraPos + rayDir * t;\n        float d = sdGround(hit.xz * .5);\n        const vec3 GREEN = vec3(.05, .2, .05);\n        float sh = shadow(invMat, hit, lightPos, lightLeft, lightUp, -1);\n        const vec3 GOLD = vec3(1, .9, .1);\n        if (d <= .01)\n        {\n            vec3 g = glitter(hit, vec3(0, 1, 0), rayDir, sh) * GOLD;\n            col = mix(g, GREEN, smoothstep(0., .01, d));\n        }\n        else\n        {\n            col = GREEN;\n        }\n        \n        col *= sh * .6 + .4;\n    }\n\n    // render small blue sphere at grab point, if any\n    if (state.grabId >= 0)\n    {\n        fxRigidBody b = fxGetBody(state.grabId);\n\n        vec3 grabPoint = rotateVectorByQuat(state.localGrabPos, quatInverse(b.rot)) + b.pos;\n        float i1 = sphIntersect(cameraPos, rayDir, vec4(grabPoint, .1));\n        if (i1 > 0. && i1 < maxT)\n        {\n            col = vec3(0, 0, 1);\n        }\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n#if MSAA <= 1\n    vec3 col = renderScene(fragCoord);\n#else\n    vec3 col = vec3(0);\n    \n    for (int x = 0; x < MSAA; ++x)\n    for (int y = 0; y < MSAA; ++y)\n    {\n        vec2 offset = (vec2(x, y) / float(MSAA - 1)) - .5;\n        col += renderScene(fragCoord + offset);\n    }\n    \n    col /= float(MSAA * MSAA);\n#endif\n\n    fragColor.xyz = pow(ACESFilm(col), vec3(1./2.2));\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float FAR_CLIP = 100.;                       // don't render beyond this t value\nconst vec3 LIGHT_DIR = normalize(vec3(1, 1, 1.5)); // fixed light direction (sunlight)\nconst float SHADOW_RES = 40.;                      // resolution/coverage of shadow buffer\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float resolution;  // res.x * res.y to detect changes, negative for one frame when change is detected\n    int grabId;        // which body we're grabbing with the mouse\n    float grabDist;    // how far away the grab point is from the camera\n    vec3 localGrabPos; // where on the grabbed body we're grabbing\n};\n\n// retrieve persistent state information\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.localGrabPos = data1.xyz;\n    state.grabId = int(data0.y);\n    state.grabDist = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel0)\n\nbool fxIsStatePixel(ivec2 ifc)\n{\n    return ifc == ivec2(0, 0) || ifc == ivec2(1, 0);\n}\n\nconst int NUM_STATE_PIXELS = 2;\n\n// store persistent state information\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0, 0))\n        return vec4(state.resolution, state.grabId, 0, 0);\n    else\n        return vec4(state.localGrabPos, state.grabDist);\n}\n\n// RIGID BODIES\n\nconst int NUM_BODIES = 300; // only uses a small part of the buffer for this shader\n\nstruct fxRigidBody\n{\n    vec3 pos;         // world space CG position\n    vec4 rot;         // rotation expressed as quaternion\n    vec3 vel;         // linear velocity\n    vec3 angVel;      // angular velocity\n    vec3 impulses[8]; // retained impulses per contact (one per box corner); x - normal impulse, yz - friction impulse\n};\n\n#define POS 0\n#define ROT 1\n#define VEL 2\n#define ANG_VEL 3\n#define IMPULSES00 5\n#define IMPULSES01 6\n#define IMPULSES02 7\n#define IMPULSES03 8\n#define IMPULSES04 9\n#define IMPULSES05 10\n#define IMPULSES06 11\n#define IMPULSES07 12\n#define NUM_DATA_TYPES 13\n\n//returns the location of the body within the body buffer corresponding with the input id \nivec2 fxLocFromIDImpl(int width, int id, int dataType)\n{\n    int index = id * NUM_DATA_TYPES + dataType + NUM_STATE_PIXELS;\n    return ivec2(index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDImpl(int(iResolution.x), X, Y)\n\n//get the body corresponding to the input id\nfxRigidBody fxGetBodyImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 bodyData0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS), 0);\n    vec4 bodyData1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, ROT), 0);\n    vec4 bodyData2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, VEL), 0);\n    vec4 bodyData3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, ANG_VEL), 0);\n    vec4 bodyData4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES00), 0);\n    vec4 bodyData5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES01), 0);\n    vec4 bodyData6 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES02), 0);\n    vec4 bodyData7 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES03), 0);\n    vec4 bodyData8 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES04), 0);\n    vec4 bodyData9 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES05), 0);\n    vec4 bodyData10 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES06), 0);\n    vec4 bodyData11 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES07), 0);\n\n    fxRigidBody body;\n    body.pos = bodyData0.xyz;\n    body.rot = bodyData1;\n    body.vel = bodyData2.xyz;\n    body.angVel = bodyData3.xyz;\n    body.impulses[0] = bodyData4.xyz;\n    body.impulses[1] = bodyData5.xyz;\n    body.impulses[2] = bodyData6.xyz;\n    body.impulses[3] = bodyData7.xyz;\n    body.impulses[4] = bodyData8.xyz;\n    body.impulses[5] = bodyData9.xyz;\n    body.impulses[6] = bodyData10.xyz;\n    body.impulses[7] = bodyData11.xyz;\n    \n    return body;\n}\n\n#define fxGetBody(X) fxGetBodyImpl(iChannel0, int(iResolution.x), X)\n\n// write out the correct data member to fragColor\nvec4 fxSaveBody(fxRigidBody b, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS:\n        return vec4(b.pos, 0);\n    case ROT:\n        return vec4(b.rot);\n    case VEL:\n        return vec4(b.vel, 0);\n    case ANG_VEL:\n        return vec4(b.angVel, 0);\n    case IMPULSES00:\n        return vec4(b.impulses[0], 0);\n    case IMPULSES01:\n        return vec4(b.impulses[1], 0);\n    case IMPULSES02:\n        return vec4(b.impulses[2], 0);\n    case IMPULSES03:\n        return vec4(b.impulses[3], 0);\n    case IMPULSES04:\n        return vec4(b.impulses[4], 0);\n    case IMPULSES05:\n        return vec4(b.impulses[5], 0);\n    case IMPULSES06:\n        return vec4(b.impulses[6], 0);\n    case IMPULSES07:\n        return vec4(b.impulses[7], 0);\n    }\n}\n\n// get just one body member (untyped)\nvec4 fxGetBodyDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetBodyData(X, Y) fxGetBodyDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// returns the ids of the four closest bodies from the input coords\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosestCamera(X) fxGetClosestImpl(iChannel1, X)\n#define fxGetClosestLight(X) fxGetClosestImpl(iChannel2, X)\n\n// UTILITY\n\nconst float PI = 3.141592653589793;\nconst vec4 QUAT_IDENT = vec4(0, 0, 0, 1);\n\nfloat length2(vec2 v) { return dot(v, v); }\n\n// rotate vector by quaternion\nvec3 rotateVectorByQuat(vec3 v, vec4 q)\n{\n    vec3 u = q.xyz;\n    float s = q.w;\n\n    return 2. * dot(u, v) * u\n          + (s*s - dot(u, u)) * v\n          + 2. * s * cross(u, v);\n}\n\n// multiply quaternions\nvec4 quatMult(vec4 Q1, vec4 Q2)\n{\n   return vec4( \n       Q2.x*Q1.w + Q2.y*Q1.z - Q2.z*Q1.y + Q2.w*Q1.x,\n      -Q2.x*Q1.z + Q2.y*Q1.w + Q2.z*Q1.x + Q2.w*Q1.y,\n       Q2.x*Q1.y - Q2.y*Q1.x + Q2.z*Q1.w + Q2.w*Q1.z,\n      -Q2.x*Q1.x - Q2.y*Q1.y - Q2.z*Q1.z + Q2.w*Q1.w\n   );\n}\n\n// construct quaternion from euler angles\nvec4 quatFromRot(vec3 rot)\n{\n    float cr = cos(rot.x * 0.5);\n    float sr = sin(rot.x * 0.5);\n    float cp = cos(rot.y * 0.5);\n    float sp = sin(rot.y * 0.5);\n    float cy = cos(rot.z * 0.5);\n    float sy = sin(rot.z * 0.5);\n\n    vec4 q;\n    q.w = cr * cp * cy + sr * sp * sy;\n    q.x = sr * cp * cy - cr * sp * sy;\n    q.y = cr * sp * cy + sr * cp * sy;\n    q.z = cr * cp * sy - sr * sp * cy;\n\n    return q;\n}\n\n// quaternion inverse\nvec4 quatInverse(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n// compute matrix from quaternion\nmat3 matFromQuat(vec4 Q)\n{\n    float q0 = Q[0];\n    float q1 = Q[1];\n    float q2 = Q[2];\n    float q3 = Q[3];\n     \n    float r00 = 2. * (q0 * q0 + q1 * q1) - 1.;\n    float r01 = 2. * (q1 * q2 - q0 * q3);\n    float r02 = 2. * (q1 * q3 + q0 * q2);\n     \n    float r10 = 2. * (q1 * q2 + q0 * q3);\n    float r11 = 2. * (q0 * q0 + q2 * q2) - 1.;\n    float r12 = 2. * (q2 * q3 - q0 * q1);\n     \n    float r20 = 2. * (q1 * q3 - q0 * q2);\n    float r21 = 2. * (q2 * q3 + q0 * q1);\n    float r22 = 2. * (q0 * q0 + q3 * q3) - 1.;\n     \n    return mat3(r00, r01, r02,\n                r10, r11, r12,\n                r20, r21, r22);\n}\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nfloat boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return -1.; // no intersection\n    \n    return tN;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// CAMERA\n\n// camera animation based on time\nvoid fxCameraPath(out vec3 cameraPos, out vec3 cameraLookAt, float t)\n{\n    t += 200.;\n    cameraPos = vec3(200. * sin(t * .02), 16, 200. * cos(t * .02));\n    cameraLookAt = vec3(14. * cos(t * .02), -16, -14. * sin(t * .02)) + cameraPos;\n}\n\n// light animation based on time (light position determines the center of focus for shadow voronoi buffer)\nvoid fxLightPath(vec3 cameraLookAt, vec3 cameraFwd, out vec3 lightPos, out vec3 lightLookAt)\n{\n    lightLookAt = cameraLookAt + vec3(cameraFwd.x, 0, cameraFwd.z) * 20.;\n    lightPos = lightLookAt + LIGHT_DIR * 50.;\n}\n\n// compute lookat basis vectors\nvoid fxCalcCamera(vec3 cameraPos, vec3 cameraLookAt, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(vec3(-cameraFwd.z, 0, cameraFwd.x));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\n// compute matrix from basis vectors\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\n// compute ray from camera basis\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\n// VORONOI\n\nfloat distance2Body(sampler2D bodyData, int resolutionWidth, int id, vec3 ro, vec3 rd)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    vec3 worldPos = fxGetBodyDataImpl(bodyData, resolutionWidth, id, POS).xyz;\n    vec4 worldRot = fxGetBodyDataImpl(bodyData, resolutionWidth, id, ROT);\n    \n    vec3 localDir = rotateVectorByQuat(rd, worldRot);\n    vec3 localOrigin = rotateVectorByQuat(ro - worldPos, worldRot);\n\n    float t = boxIntersection(localOrigin, localDir, vec3(.6)); // n.b.: slightly bigger than box\n    \n    if (t < 0.) return 1e6; // boxIntersection gives us a -1 if we miss, but we need something that sorts to the end\n    \n    return t;\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// online algorithm to compute the closest bodies to each raster position\nivec4 voronoi(sampler2D bodyData, int resolutionWidth, sampler2D cameraClosest, vec2 fragCoord, vec3 cameraPos, vec3 rayDir, int iFrame, uint searchRange, uint searchCount)\n{\n    ivec4 new = ivec4(-1);\n    if (iFrame == 0) return new;\n\n    vec4 dis = vec4(1e6);\n    ivec2 ifc = ivec2(fragCoord);\n    \n    // reinsert existing closest to compute distances\n    ivec4 old = fxGetClosestImpl(cameraClosest, ifc);      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        float dis2 = distance2Body(bodyData, resolutionWidth, id, cameraPos, rayDir);\n        insertion_sort( new, dis, id, dis2 );\n    }\n\n    // search nearby voronoi cells for bodies that should move into our cell\n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n        ivec4 old = fxGetClosestImpl(cameraClosest, ifc + ( ivec2(h0.xy % searchRange) - ivec2(searchRange / 2u) ));      \n\n        for (int j = 0; j < 1; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Body(bodyData, resolutionWidth, id, cameraPos, rayDir);\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n\n    // random searching to kick start the process\n    int searchIterations = iFrame < 5 ? 20 : 1;\n    for(int k = 0; k < searchIterations; k++)\n    {\n        int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % NUM_BODIES;\n        insertion_sort(new, dis, id, distance2Body(bodyData, resolutionWidth, id, cameraPos, rayDir));\n    }\n    \n    return new;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// -------------------------------------------------------------------------------------------\n// Rigid body simulation and persistent state...an array of fxRigidBodies following an fxState\n// -------------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0, -.01, 0);            // velocity change per frame caused by gravity\nconst float FRIC_COEF = .03;                      // Coulomb friction constant\nconst float ALLOWED_PENETRATION = .001;           // object floats up to this high above surface to maintain contact coherence\nconst float RESTITUTION_COEF = .5;                // how much to bounce (elasticity); 1. == perfect elasticity 0. == perfect inelasticity\nconst float INVERSE_MASS = 80.;                   // one over the mass\nconst mat3 INV_INERTA_LOCAL = mat3(INVERSE_MASS); // box inertia, used for impulse calculations\n\n// maintains the status of each contact point during iterations\nstruct fxContact\n{\n    vec3 relPos;       // world space position of contact relative to body CG\n    vec3 norm;         // contact normal\n    float depth;       // collision depth, positive needs position correction\n    float targetVel;   // used by restitution to aim us towards to bigger velocity than zero\n    vec3 jacDiagABInv; // the relationship between impulse and velocity for x (normal) and yz (friction) directions\n};\n\n// get the linear velocity of a point on the body\nvec3 getLocalVelocity(fxRigidBody b, vec3 relPos)\n{\n    return b.vel + cross(relPos, b.angVel);\n}\n\n// rotate the inertia tensor into world space\nmat3 getInvInertiaTensorWorld(fxRigidBody b)\n{\n    mat3 basis = matFromQuat(b.rot);\n    return basis * INV_INERTA_LOCAL * transpose(basis);\n}\n\n// make arbitrary (but consistent) basis vectors given a direction\nvoid makeOrthonormals(vec3 v, out vec3 v1, out vec3 v2)\n{\n    v1 = cross(v, vec3(1, 0, 0));\n    if (length(v1) < 1e-6)\n    {\n        v1 = cross(v, vec3(0, 1, 0));\n    }\n    \n    v1 = normalize(v1);\n    v2 = normalize(cross(v, v1));\n}\n\n// how much impulse is needed to achieve a change in velocity in each direction (x - normal, yz - friction)\nvec3 computeImpulseDenominator(fxRigidBody b, vec3 relPos, vec3 norm)\n{\n    vec3 tangent, binormal; makeOrthonormals(norm, tangent, binormal);\n    mat3 invInertiaTensorWorld = getInvInertiaTensorWorld(b);\n    \n    vec3 c0 = cross(relPos, norm);\n    vec3 v0 = cross(c0 * invInertiaTensorWorld, relPos);\n\n    vec3 c1 = cross(relPos, tangent);\n    vec3 v1 = cross(c1 * invInertiaTensorWorld, relPos);\n\n    vec3 c2 = cross(relPos, binormal);\n    vec3 v2 = cross(c2 * invInertiaTensorWorld, relPos);\n\n    return INVERSE_MASS + vec3(dot(norm, v0), dot(tangent, v1), dot(binormal, v2));\n}\n\n// change the velocity of a body via an impulse at an offset from CG in world space\nvoid applyImpulse(inout fxRigidBody b, vec3 impulse, vec3 relPos)\n{\n    b.vel += impulse * INVERSE_MASS;\n    b.angVel += getInvInertiaTensorWorld(b) * cross(impulse, relPos);\n}\n\nvoid initRigidBody(inout fxRigidBody b, int id, vec3 cameraPos)\n{\n    // setup random initial position, rotation, velocity, angVel\n    vec4 h = hash44(vec4(iFrame, id, id, id));\n    b.pos = (h.xyz - vec3(.5, 0, .5)) * 16. * vec3(5, 30, 5) + vec3(0, 20, 0) + cameraPos;\n    vec4 h2 = hash44(vec4(iFrame, h.w, iDate.z, id));\n    b.rot = quatFromRot(vec3(h2.xyz * 3. * PI));\n\n    vec4 h3 = hash44(vec4(iFrame, h2.w, iDate.z, id));\n    b.vel = vec3(h3.x - .5, 0, h3.y - .5) * .3;\n    b.angVel = vec3((h2.xyz - .5) * 2. * PI) * .01;\n}\n\n// constraint math adapted from Erwin Coumans' Bullet:\n// https://github.com/bulletphysics/bullet3/blob/master/src/BulletDynamics/ConstraintSolver/btContactConstraint.cpp\nvoid prepareContact(inout fxRigidBody b, float warmStartImpulse, inout fxContact c)\n{\n    // compute the component of the jacobian in three directions (normal, tangent, binormal)\n\tvec3 denom = computeImpulseDenominator(b, c.relPos, c.norm);\n\tc.jacDiagABInv = 1. / denom;\n    \n    // precompute the target velocity necessary to achieve the desired restitution\n  \tvec3 vel = getLocalVelocity(b, c.relPos);\n\tfloat relVel = dot(c.norm, vel);\n    c.targetVel = min(0., relVel * RESTITUTION_COEF + .01);\n\n    // compute and apply the Baumgarte impulse (position correction) to prevent sinking\n    float positionalError = c.depth * .01;\n    float penetrationImpulse = positionalError / denom.x;\n    \n    // combine the Baumgarte with warm start impulse and apply\n    float prepareImpulse = penetrationImpulse + warmStartImpulse;\n    applyImpulse(b, c.norm * prepareImpulse, c.relPos);\n}\n\n// perform one iteration, computing impulses for one contact to resolve velocity error\nvoid resolveContact(inout fxRigidBody b, inout vec3 accumImpulse, inout fxContact c)\n{\n\tvec3 vel = getLocalVelocity(b, c.relPos); // the velocity at the contact point (world space)\n\tfloat relVel = dot(c.norm, vel); // the component of the local velocity in the normal direction\n\n\tfloat velocityError = -relVel - c.targetVel; // how much velocity error we need to correct\n\tfloat normalImpulse = velocityError * c.jacDiagABInv.x; // the impulse needed to correct the error\n\n    float totalImpulse = accumImpulse.x + normalImpulse; // the full normal impulse applied so far\n\ttotalImpulse = max(0., totalImpulse); // complementarity condition (can't apply negative total impulse)\n    float normalImpulseAdjustment = totalImpulse - accumImpulse.x; // how much correction to apply to the impulse\n    accumImpulse.x = totalImpulse; // save the normal impulse for next time (warm start)\n\n\tapplyImpulse(b, c.norm * normalImpulseAdjustment, c.relPos); // apply normal impulse\n\n\tvel = getLocalVelocity(b, c.relPos); // update the velocity after applying normal impulse\n    \n    vec3 tangent, binormal; makeOrthonormals(c.norm, tangent, binormal); // compute friction directions\n    \n    vec2 frictionVel = vec2(dot(vel, tangent), dot(vel, binormal)); // compute the velocity in the friction directions\n\tvec2 frictionImpulse = -frictionVel * c.jacDiagABInv.yz; // compute the impulse necessary to stop all sliding\n\n    vec2 totalFrictionImpulse = accumImpulse.yz + frictionImpulse; // compute the total friction impulse applied\n    \n    // clamp total friction based on friction constant times normal force to allow dynamic friction\n\ttotalFrictionImpulse = clamp(totalFrictionImpulse, -FRIC_COEF * totalImpulse, FRIC_COEF * totalImpulse);\n    vec2 frictionImpulseAdjustment = totalFrictionImpulse - accumImpulse.yz; // how much correction to apply to friction impulse\n    accumImpulse.yz = totalFrictionImpulse; // save the friction impulse for next time (warm start)\n\n    vec3 worldFrictionImpulse = totalFrictionImpulse.x * tangent + totalFrictionImpulse.y * binormal; // combine friction impulses\n\tapplyImpulse(b, worldFrictionImpulse, c.relPos); // apply friction impulses\n}\n\n// advance one body's state by one frame\nvoid updateRigidBody(int id, inout fxRigidBody b, fxState state)\n{\n    // integrate velocity\n    b.vel += GRAVITY;\n    const float MAX_Y_SPEED = .2;\n    if (abs(b.vel.y) > MAX_Y_SPEED)\n    {\n        b.vel.y = MAX_Y_SPEED * sign(b.vel.y);\n    }\n    \n    // collision detection (very simple, just corners vs. plane)\n    const int MAX_NUM_CONTACTS = 8;\n    fxContact contacts[MAX_NUM_CONTACTS];\n    int numContacts = 0;\n    \n    for (int x = 0; x < 2; x++)\n    for (int y = 0; y < 2; y++)\n    for (int z = 0; z < 2; z++)\n    {\n        int index = x * 4 + y * 2 + z;\n        vec3 localPos = (vec3(x, y, z) * 2. - 1.)  * .5;\n        vec3 relPos = rotateVectorByQuat(localPos, quatInverse(b.rot));\n        \n        vec3 worldPos = relPos + b.pos;\n        if (worldPos.y < ALLOWED_PENETRATION)\n        {\n            // prepare contact found below plane\n            contacts[index].relPos = relPos;\n            contacts[index].norm = vec3(0, 1, 0);\n            contacts[index].depth = ALLOWED_PENETRATION - worldPos.y;\n            prepareContact(b, b.impulses[index].x, contacts[index]);\n        }\n        else\n        {\n            // not touching, reset contact\n            contacts[index].depth = 0.;\n            b.impulses[index] = vec3(0);\n        }\n    }\n\n    // mouse grab impulse\n    if (iMouse.z > 0. && iMouse.w < 0. && state.grabId == id)\n    {\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCameraPath(cameraPos, cameraLookAt, iTime);\n        fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n        vec3 rayDir = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n        vec3 mouseGrabPos = cameraPos + rayDir * state.grabDist;\n        vec3 localPos = rotateVectorByQuat(state.localGrabPos, quatInverse(b.rot));\n        vec3 boxGrabPos = localPos + b.pos;\n        const float SPRING_K = .0003;\n        const float SPRING_DAMP = .001;\n        vec3 localVel = getLocalVelocity(b, localPos);\n        applyImpulse(b, SPRING_K * (mouseGrabPos - boxGrabPos) - localVel * SPRING_DAMP, boxGrabPos - b.pos);\n    }\n    \n    // constraint solve\n    for (int iter = 0; iter < 3; ++iter)\n    for (int index = 0; index < 8; ++index)\n    {\n        if (contacts[index].depth > 0.)\n        {\n            resolveContact(b, b.impulses[index], contacts[index]);\n        }\n    }\n    \n    // integrate position\n    b.pos += b.vel;\n    \n    // integrate rotation\n    vec4 rq = quatFromRot(b.angVel);\n    b.rot = quatMult(rq, b.rot);\n}\n\n// handle persistent state info\nvoid updateState(inout fxState state)\n{\n    if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n    }\n\n    if (iMouse.z > 0.)\n    {\n        if (iMouse.w > 0.)\n        {\n            state.grabId = -1;\n            float minT = 1e6;\n            for (int i = 0; i < NUM_BODIES; ++i) // seems like this should be slow, and could use voronoi buffer here, but ¯\\_(ツ)_/¯\n            {\n                fxRigidBody b = fxGetBody(i);\n                vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n                fxCameraPath(cameraPos, cameraLookAt, iTime);\n                fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n                vec3 rayDir = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n                vec3 localDir = rotateVectorByQuat(rayDir, b.rot);\n                vec3 localOrigin = rotateVectorByQuat(cameraPos - b.pos, b.rot);\n\n                float t = boxIntersection(localOrigin, localDir, vec3(.5));\n                if (t > 0. && t < minT)\n                {\n                    minT = t;\n                    state.grabId = i;\n                    state.grabDist = t;\n                    state.localGrabPos = localOrigin + localDir * t;\n                }\n            }\n        }\n    }\n    else\n    {\n        state.grabId = -1;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    fxState state = fxGetState();\n    \n    // handle state pixels\n    if (fxIsStatePixel(ifc))\n    {\n        updateState(state);\n        fragColor = fxPutState(state, ifc);\n        return;\n    }\n    \n    // locate which body we're in, and determine the data member we're computing\n    int index = ifc.x + ifc.y*int(iResolution.x) - NUM_STATE_PIXELS;\n    int id = index / NUM_DATA_TYPES;\n    int dataType = index - id * NUM_DATA_TYPES;\n    if(id>=NUM_BODIES) return;\n    \n    fxRigidBody b = fxGetBody(id);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCameraPath(cameraPos, cameraLookAt, iTime);\n    fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n\n    if (iFrame == 0 || // reset on frame zero...\n        state.resolution < 0. || // ...or if the resolution changed...\n        distance(b.pos.xz, cameraPos.xz) > 40. || // ...or if too far from the camera...\n        dot(b.pos - cameraPos, cameraFwd) < 0.) // ...or if behind the camera\n    {\n        initRigidBody(b, id, cameraPos);\n    }\n    else\n    {\n        updateRigidBody(id, b, state);\n    }\n    \n    fragColor = fxSaveBody(b, dataType);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer from camera position\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCameraPath(cameraPos, cameraLookAt, iTime);\n    fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    const uint searchRange = 128u; // larger ranges allow faster movement, but require larger counts\n    const uint searchCount = 12u; // larger counts find more correct ids, but cost more\n    ivec4 new = voronoi(iChannel0, int(iResolution.x), iChannel1, fragCoord, cameraPos, rayDir, iFrame, searchRange, searchCount);\n    \n    fragColor = vec4(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer from light position (orthographic)\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 cameraLookAt, cameraPos;\n    fxCameraPath(cameraPos, cameraLookAt, iTime);\n    \n    vec3 lightPos, lightLookAt, lightFwd, lightLeft, lightUp;\n    fxLightPath(cameraLookAt, normalize(cameraLookAt - cameraPos), lightPos, lightLookAt);\n    fxCalcCamera(lightPos, lightLookAt, lightFwd, lightLeft, lightUp);\n\tvec2 screenPos = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    lightPos -= (lightLeft * screenPos.x + lightUp * screenPos.y) * SHADOW_RES; // move light pos intead of ray dir (orthographic projection)\n\n    vec3 rayDir = -LIGHT_DIR;\n    const uint searchRange = 64u; // larger ranges allow faster movement, but require larger counts\n    const uint searchCount = 12u; // larger counts find more correct ids, but cost more\n    ivec4 new = voronoi(iChannel0, int(iResolution.x), iChannel2, fragCoord, lightPos, rayDir, iFrame, searchRange, searchCount);\n    \n    fragColor = vec4(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}