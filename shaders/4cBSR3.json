{
    "Shader": {
        "info": {
            "date": "1708041781",
            "description": "Mouse to look around",
            "flags": 32,
            "hasliked": 0,
            "id": "4cBSR3",
            "likes": 32,
            "name": "GCLH Dark Palace Studio",
            "published": 3,
            "tags": [
                "fractal",
                "truchet",
                "kifs"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 316
        },
        "renderpass": [
            {
                "code": "\n/*\nchanges:\n- made relflect only apply to one color\n- added max to diffuse to get reid of the green\n- added mouse to both of the rotation constants\n\n*/\nmat2 rot45(){\n    float s = 0.8509035245, c = 0.52532198881;\n    return mat2(c, -s, s, c);\n}\nfloat glow = 0.;\nvec2 tile(vec3 p){\n     //p.zx *= rot(iTime);\n     //Black Block\n     vec2 t = vec2(roundedSdBox(p,vec3(2.5,0.1+0.1*(abs(fract(p.z*4.)-0.5)+abs(fract(p.x*4.)-0.5)),4.5),0.04),3.);\n     //cut the black block\n     //t.x = max(t.x,-sdBox(p,vec3(3.,1.3,0.3)));\n     //gold block\n     vec2 h = vec2(roundedSdBox(p-vec3(0.,0.12,0.),vec3(1.2,0.2,5.), 0.02),1.);\n     //h.x = max(h.x,-sdBox(abs(abs(p-vec3(0.,0.,0.8))-vec3(0.,0.,1.8))-vec3(0.,0.,0.9),vec3(2.,1.3,0.7)));\n     addH;\n     h = vec2(roundedSdBox(p-vec3(0.,-0.4,0.),vec3(3.,0.2,5.3), 0.02),4.);\n     addH;\n     //gold doubles\n     h = vec2(roundedSdBox(abs(p)-vec3(2.9,0.,0.),vec3(.1,1.,5.), 0.02),1.);\n     addH;\n     //white layer doubles\n     h = vec2(roundedSdBox(abs(p)-vec3(3.1,0.,0.),vec3(.05,1.,5.), 0.02),4.);\n     addH;\n     //bottom rings\n     h = vec2(sdTorus(abs(p.yxz)-vec3(0.,3.3,3.),vec2(0.6,0.1)),4.);\n     addH;\n     h = vec2(length(abs(p)-vec3(3.3,0.,3.))-0.6,2.);\n     addH;\n     /*h = vec2(length(abs(p)-vec3(3.45,0.,3.))-0.5,3.);\n     addH;\n     h = vec2(length(abs(p)-vec3(3.68,0.,3.))-0.3,2.);\n     addH;*/\n     \n     h = vec2(sdTorus(p-vec3(0.,.4,-3.9),vec2(0.9,0.1)),4.);\n     addH;\n     h = vec2(length(p-vec3(0.,.4,-3.9))-0.9,2.);\n     addH;\n     \n     return t;\n}\n\n\nvec2 map(vec3 p){\n    p.xz = mod(p.xz,40.)-20.;\n    for(int i=0;i<5;i++){//3,4 or 5 are all good bros\n    \t\n        p.xz*=rot(0.5*float(i));\n        p.xy*=rot((0.44)*float(i));\n        p=abs(p)-vec3(4.8,5.,5.5);\n       // p=p.yxz;\n       //p=abs(p)-vec3(4.,5.2,3.9);//this one is cool\n     //p=abs(p)-vec3(3.6,5.2,5.1);//this idk\n    }\n    //p.xy*=rot(2.5);\n     vec2 t = vec2(tile(p));\n     return t;\n}\nvec2 mapUV(vec3 p,vec3 n){\n    p.xz = mod(p.xz,40.)-20.;\n    \n    for(int i=0;i<5;i++){//3,4 or 5 are all good bros\n    \t\n        p.xz*=rot(0.5*float(i));\n        p.xy*=rot((0.44)*float(i));\n        p=abs(p)-vec3(4.8,5.,5.5);\n    }\n    n = n*0.5+0.5;\n    p = fract(p*0.3)-0.5;\n    return (p.xy*n.z + p.xz*n.y + p.yz*n.z)/(n.x+n.y+n.z);  \n    //return p;\n}\n\n\nvec2 trace(vec3 ro, vec3 rd){\n   \tvec2 t = vec2(0.),dist;\n    for(int i=0; i<96; i++)\n    {\n         dist = map(ro + rd*t.x);\n         \n         if(dist.x<0.001 || t.x > 70.){break;}\n         t.x += dist.x*0.85;\n         t.y = dist.y;\n       // glow += 0.1/(0.1+dist.x+20.)*float(dist.y>3.);\n       // glow += 0.001/exp(-dist.x*2.);\n    }\n return t;   \n}\n\nvec2 rtrace(vec3 ro, vec3 rd){\n   \tvec2 t = vec2(0.),dist;\n    for(int i=0; i<48; i++)\n    {\n         dist = map(ro + rd*t.x);\n         if(dist.x<0.001 || t.x > 50.){break;}\n         t.x += dist.x;\n    }\n return t;\n}\nvec3 normal6(vec3 sp){\n    //we swizzel a vec2 epsilon to get vec3\n    vec2 e = vec2(.0001, 0.0);\n    return normalize (\n    vec3(map(sp+e.xyy).x - map(sp-e.xyy).x,\n         map(sp+e.yxy).x - map(sp-e.yxy).x,\n         map(sp+e.yyx).x - map(sp-e.yyx).x)\n    );\n}\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    vec3 n = map(p).x - \n        vec3(\n            map(p-e.xyy).x, \n            map(p-e.yxy).x,\n            map(p-e.yyx).x\n            );\n    \n    return normalize(n);\n}\n\nfloat calculateAO(in vec3 pos, in vec3 nor){\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec2 getUV(vec3 p, vec3 n){\n   n = n*0.5+0.5;\n   return (p.xy*n.z + p.xz*n.y + p.yz*n.z)/(n.x+n.y+n.z);  \n}\n\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd, float id){\n    vec3 color;\n   // sn = normalize(sn);//\n    //vector from hit position to light position\n    vec3 lv = lp - sp;\n    //length of that vector\n    float ldist = max(length(lv), 0.001);\n    //direction of that vector\n    vec3 ldir = lv/ldist;\n    //attenuation\n    float atte = 1.0/(1. + 0.02*ldist*ldist );\n    //diffuse color\n    float diff = max(dot(ldir, sn),0.);\n    //specular reflection\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);\n    //fresnel\n    float fres = pow(max(dot(rd, sn) + 1., 0.0), 1.);\n\t//ambient occlusion\n    float ao = calculateAO(sp, sn);\n    //reflecton\n    vec3 refl = reflect(rd, sn);\n    //id for random tile color\n    //sp.yz*=rot(+iTime)*float(id<1.);\n\n    float rndTile = rnd(floor(sp.xz));\n    \n    //color options\n    float rough = 0.6;\n    vec3 color2 = vec3(0.99,0.55,0.1);\n    if(id > 1.){\n                float tex = texture(iChannel1,mapUV(sp,sn)).b;\n                rough = smoothstep(0.6,0.1,tex)*0.2;\n                color2 = vec3(0.)+tex*0.1;\n                }\n    if(id > 2.){color2 = mix(vec3(0.,0.7,0.99),vec3(0.9,0.45,0.3),pow((sin(sp.y)+sin(sp.z))+2.,0.9));rough = 0.;}\n    if(id > 3.){\n                float tex = texture(iChannel1,mapUV(sp,sn)).b;\n                color2 = vec3(tex*0.99,tex*0.45,tex*0.1);//vec3(0.5)+tex;\n                rough = smoothstep(0.6,0.1,tex)*0.8;\n                }//vec3(.1,0.8,0.9);}\n    if(id > 4.){color2 = vec3(1.);rough = 0.4;}\n    //getting reflected and refracted color froma cubemap, only refl is used\n    vec4 reflColor = texture(iChannel0, refl);\n    //orage specular\n    vec3 hotSpec = vec3(0.9,0.5, 0.2);\n    //apply color options and add refl/refr options\n    color = color2*0.1+(diff*color2 +  spec*hotSpec +reflColor.xyz*rough )*atte;\n    color = clamp(color,0.,1.);\n    //apply ambient occlusion and return.\n    return color*ao;   \n}\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\nvec3 path(in float z){ \n    float tt=mod(iTime,62.82);\n    vec3 ro=vec3(0., 2., iTime*2.);\n    //ro=vec3(0.,5.,-15.);\n    return ro;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    //fisheye\n\t//uv = normalize(uv) * tan(asin(length(uv) *1.));\n    \n\t//Camera Setup.\n\tvec3 lk = path(0.);//+vec3(61., -20., 0.);  \n    //lk.xy += path(lk.z);\n\tvec3 ro = lk + vec3(0, .05, -.25);\n \tvec3 lp = ro + vec3(0, 3.75, 10);\n    vec2 m = (iMouse.xy - iResolution.xy*.5)/iResolution.y;\n    //camera\n    float FOV = 1.57;\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt); \n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);    \n\t\n    if(iMouse.z < 0.5){\n        //rd.xy *= rot( path(lk.z).z/128.);\n        //rd.xz *= rot( lk.z/64.);\n    }\n    else{\n        rd.yz *= rot(-m.y*2.);\n        rd.xz *= rot(-m.x*4.);\n    }\n    \n    //distance to closest hit\n    vec2 t = trace(ro, rd);\n    //normalized distance\n    float far = smoothstep(0.0, 1.0, t.x/70.);\n    //hit point\n    vec3 sp = ro + rd*t.x;\n    //normal\n    vec3 sn = normal(sp);\n    \n    vec4 cubeColor = texture(iChannel0, rd);\n    //lighting\n    vec3 color = lighting(sp, sn, lp, rd, t.y);\n    /*\n    if(t.y < 2.5){\n        //reflection based on shanes reflection shader\n        vec3 refRay = reflect(rd, sn);\n        \n        //trace reflection\n        vec2 rt = rtrace(sp+sn*0.01, refRay);\n\n        //relection hit point\n        vec3 rsp = (sp+refRay*0.01) + refRay*rt.x;\n\n        //reflection surfact normal\n        vec3 rsn = normal(rsp);\n        \n        float tex = texture(iChannel1,mapUV(sp,sn)).r;\n        float rough = smoothstep(0.6,0.1,tex);\n                \n        //add reflection lighting\n        color += lighting(rsp, rsn, lp, refRay, t.y)*rough;\n    }*/\n    //accidental solar halo\n    vec3 sky = vec3(0.01);//mix(vec3(0.9, 0.5, 0.2)*4., vec3(0.0)-0.4, pow(abs(rd.y), 1./3.))*(1./pow(abs(length(rd.xy)-0.4), 1./3.))/8.;\n    //*(2.+mix(vec3(0.,0.7,0.99),vec3(0.9,0.45,0.3),pow((sin(sp.y)+sin(sp.z))+2.,.3)));\n    //add cube color\n    //sky += cubeColor.xyz*0.1;\n    \n   // color += mix(vec3(0.,0.7,0.99),vec3(0.9,0.45,0.3),sin(sp.z+sp.y)*0.4+0.5)*glow;\n   // color = clamp(color,0.,1.);\n    color = mix(color, sky, far);\n    \n    \n    \n    color = pow(color,vec3(0.65));\n    \n    //naive vignette\n    //float vig = 1.0-smoothstep(1.0,3.5, length(uv));\n    //color.xyz *= mix( 0.8, 1.0, vig);\n    //\n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926\n#define addH t.y = t.x < h.x ? t.y : h.y;  t.x = min(t.x,h.x)\nfloat rnd(vec2 p){\n    vec2 seed = vec2(13.234, 72.1849);\n    return fract(sin(dot(p,seed))*43251.1234);    \n}\nfloat rb(vec3 p, vec3 b, float r){\n    return length(max(abs(p)-b,0.0))-r;   \n}\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat roundedSdBox(vec3 p, vec3 s, float r) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nmat2 rot(float a){\n     float c = cos(a),s = sin(a);\n     return mat2(c, -s, s, c);\n}\n        ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n\n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 10.*fragCoord/iResolution.x;\n    \n    //the 30 60 90 triangle with sides 1, 2 and sqrt(3)\n    //sqrt(3) is 1.731: https://www.redblobgames.com/grids/hexagons/\n    vec2 s = vec2(1.,1.732);\n    \n    //we create two grids. Both have the dimentions of s.\n    //mod with s gives us the coordinates like fract does\n    vec2 a = mod(u,s)*2.-s;//stuff after mod just changes value not cell dimention\n    //floor of u/s gives us an id system that is strechted to the s dimentions\n    vec2 idA = floor(u/s);\n    //get a random value for each id for coloring if I wanted\n   // float A = rnd(idA);\n    \n    //we do the same again but with +s*0.5 so we move this system up\n    //diagonally by half the dimentions of s\n    vec2 b = mod(u+s*.5,s)*2.-s;//stuff after mod just changes value not cell dimention\n    vec2 idB = floor((u+s*.5)/s);\n    //I add +4 to give B some randomness\n   // float B = rnd(idB+4.);\n    \n    \n    //we take the lengths because a comparison for a given pixel\n    //between length (within a given grid rectangle) will tell us\n    //the coordinate system where the pixel is closest to 0.,0.\n    //this tells us then which system (and which hexagon) to use.\n    float la = length(a);\n    float lb = length(b);\n  //  float C = la < lb ? A*la : B*lb;\n    \n    //choose which hex system to use\n    u = la < lb ? a : b;\n    //we go a step further, get abs u so whatever we do\n    //in the top right quadrant will be mirrored in top left, bottom left,\n    //and bottom right\n    vec2 st = abs(u);\n    //what we do with this is get the dopt product.\n    //if you remove the max(st.x portion you get a diamond.\n    //This is percentage every pixel's vector (st) is aligned with\n    //the normalized dimention vector (s). and that vector being 1.,1.732\n    //is on a 60 degree angle already from the x axis. All these ratios\n    //act as distances since s is normalized, and that give us that diamond shape.\n    //on top of that max(st.x...) cut's things off whenever x > than the dot\n    //dot product. That gives us an even hex shape.\n    //(in the chosen system)\n    float q = max(st.x, dot(st,normalize(s)));\n    \n\n    //Then I jut add a color pallette\n\tfragColor = vec4(0.5+0.5*cos(vec3(1.,2.,4.)/10. + floor(q*8.) ), 1.);//vec4(1.0-floor(C*8.)/8.*.75);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define LEVELS 3.\n#define EPS 2./iResolution.y\n#define EPS_N 10./iResolution.y\n\n#define SCALE 3.\n\n/*\n\nThe checkerboard shifting: Deciding which of the two\ncircles in a cell will be on top and below. You start\nwith always the upper right circle ontop and \nthe lower left below. Then view the cells as a checker\nboard and flip the order of all the white squares on \nthe board.\n\nThe part that almost had me was shading because you\nhave to rotate the coordinate systems back the other\nway but only after you do the checkerboard shifting and\ncreation of the circles. \n\nAnd THEN it still matters how you use atan since odd \nmultiples of the result will show a discontinuity at \nthe cell borders when passed through sin.\n\n*/\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n\n\nvec2 concentricCircles(vec2 st, float r, float num, float type, vec2 checker,float scale){\n    float d1 = \n            smax(dot(st,vec2(0.7,-0.7)),\n            smax(dot(st,vec2(-0.7,0.7)),\n            smax(dot(st,-vec2(0.7,0.7)),\n            smax(dot(st,vec2(0.7,0.7)),\n            smax(abs(st.x),\n            abs(st.y),0.1),0.1),0.1),0.1),0.1);\n    float d2 = length(st);\n    \n    float d = type < 0.50 \n              ? mix(d1,d2,sin(iTime*1.9)*0.5+0.5)\n              : mix(d2,d1,cos(iTime*1.99 + type)*0.5+0.5);\n    //d *=  length(st)*cos(atan(st.y,st.x)*3.+PI*0.5)*0.21;\n    float cutoff = smoothstep(r+EPS,r-EPS,d*(1.0+0.02*(scale-0.5)));\n    float circles = sin(d*num*PI);//-0.1*(mod(checker.x+1.,2.)*mod(checker.y,2.));\n    return vec2(smoothstep(0.,1.,abs(circles*cutoff))+0.2*cutoff,d);\n}\n\nfloat overlappingConcentricCircles(vec2 st, float r, float num, vec2 checker, float a, float scale){\n    float type = a;\n    vec2 sp1 = st-vec2(1.,1.)+vec2(2.,2.)*checker;\n    vec2 group_1 = concentricCircles(sp1, r, num,type,checker,scale);\n    //sp1 = st*rot(-a)-vec2(1.,1.)+vec2(2.,2.)*checker;\n    sp1 *= rot(-a);\n    float light_1 = 0.; //sin(atan(sp1.y,sp1.x)*2.+iTime)*0.5+0.5;\n   // group_1.x -= smoothstep(0.8,0.9,group_1.y);\n    \n    \n    vec2 sp2 = st+vec2(1.,1.)-vec2(2.,2.)*checker;\n    vec2 group_2 = concentricCircles(sp2, r, num, type,checker,scale);\n    //sp2 = st*rot(-a)+vec2(1.,1.)-vec2(2.,2.)*checker;\n    sp2 *= rot(-a);\n    float light_2 = 0.;//sin(atan(sp2.y,sp2.x)*2.+iTime)*0.5+0.5;\n    //float shadow = 0.;//(1.-smoothstep(0.5,0.6,group_2.y*0.25));\n    \n    float total = mix(group_1.x-light_1*0.2, group_2.x-light_2*0.2, smoothstep(0.1,0.2,group_2.x));\n    \n    \n    return total;\n}\nfloat quadTree(vec2 st){\n\n    float s = 1.;\n    float seed;\n    vec2 fr, fl;\n    float circle_num =  4.;\n    for(float i = 0.; i <= LEVELS; i ++){\n        fr = fract(st)-0.5;\n        fl = floor(st);\n      /*  if(abs(fr.x)>0.5-0.02*s || abs(fr.y) > 0.5-0.04*s){\n            return smoothstep(0.5,0.5-0.04*s,max(abs(fr.x),abs(fr.y)));\n        } */\n        seed = rnd(fl); \n        seed = seed + 0.2*mod(fl.x,2.) + 0.2*mod(fl.y,2.);\n        if( seed > 0.7 || LEVELS - i == 1.){\n            float a =  (floor(rnd(fl*325.2435)*4.)/4.)*PI*2.;\n            fr *= rot(a);\n            return overlappingConcentricCircles(fr*2.,\n                                                2., \n                                                circle_num,\n                                                mod(fl,2.),\n                                                a,\n                                                s);\n        }\n        \n        s *= 2.;\n        st *= 2.;\n        circle_num /= 2.;\n    }\n    return 1.;\n}\nvec2 getNormal(vec2 p){\n    return vec2(quadTree(p+vec2(EPS_N,0.))-quadTree(p-vec2(EPS_N,0.)),\n                quadTree(p+vec2(0.,EPS_N))-quadTree(p-vec2(0.,EPS_N))\n                );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    //vec3\n    // Time varying pixel color\n    vec3 col;// = vec3(quadTree(uv*8.));\n    vec3 ld1 = normalize( vec3(1., sin(iTime)*0.9, -1.) - vec3(uv*SCALE, 0.) );\n    vec3 ld2 = normalize( vec3(-1., -.9, -1.) - vec3(uv*SCALE, 0.) );\n    vec3 rd = normalize(vec3(uv*SCALE,1.));\n    \n    //uv.xy += vec2(iTime*0.075,iTime*0.05);\n    //col = vec3(concentricCircles(uv*2.,1., 12.,1.,vec2(1.,1.)).x);\n    //col = vec3(quadTree(uv*5.));\n    float d = quadTree(uv*SCALE);\n    vec3 n = normalize(vec3(-getNormal(uv*SCALE),-d*.25));\n    float spec = pow(max(dot(reflect(n,-ld1),rd),0.),10.)*1.;\n    float spec2 = pow(max(dot(reflect(n,-ld2),rd),0.),10.)*3.;\n    float diff = max(dot(n,ld1),0.)*1.4;\n    float diff2 = max(dot(n,ld2),0.)*1.4;\n    \n    float fres = pow(max(0., dot(n, normalize(vec3(uv*SCALE, 1.)))),200.)*10.;\n    \n    float stripes = smoothstep(0.25,0.255,abs(fract(uv.x*75.-uv.y*90.)-0.5));\n    col = mix(vec3(0.,0.,0.), vec3(0.7,0.1,0.1)*1.3,  smoothstep(0.59,.6,d)); \n    //col = mix(col, vec3(0.7,0.13,0.4), stripes*1.9);\n    \n    //OR vec3(0.9,0.,0.);\n    col = mix(col, vec3(0.15,0.13,0.35)*2.7-stripes*0.2, d*2.);\n   \n  //  col = mix(col, vec3(0.1,0.6,0.1), smoothstep(.93,.65,d));\n    col = mix(col, vec3(0.45,0.3,0.1)*0.8, smoothstep(0.3,0.299,d));\n    \n    col = mix(col, vec3(0.), smoothstep(.1,1.9,d*0.9));\n //   col = pow(col, vec3(1.0));\n    //col = mix(col, vec3(cos(vec3(1.,2.,4.)/2. + uv.x*0.06.1 + (uv.y-0.5)*1.6 + d*1.937*PI)) + stripes*0.2, d*.9);\n    \n    col = col*0.5\n          + vec3(1.3,0.7,0.1)*(diff*0.15 +spec*0.3) \n          + vec3(0.2,0.9,0.6)*(diff2*0.15 +spec2*0.3);\n    col *= 1.36;\n    col += 0.4*texture(iChannel0,reflect(rd,n)).xyz;\n    col = mix(col, vec3(0.0,0.0,0.0), smoothstep(.3,.2,abs(d-0.6)));\n   // col.xz *= rot(iTime);\n    col = pow(col, vec3(1.));\n    // Output to screen\n    //col = vec3(stripes);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}