{
    "Shader": {
        "info": {
            "date": "1408911921",
            "description": "What would it look like if more distant objects appeared bigger than closer ones? Use the mouse to move the slider past the white stripe (the inflection point, i.e. orthographic projection).",
            "flags": 0,
            "hasliked": 0,
            "id": "4djXRh",
            "likes": 72,
            "name": "Inverse Perspective",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "inverse",
                "perspective",
                "orthographic",
                "fov"
            ],
            "usePreview": 0,
            "username": "HLorenzi",
            "viewed": 2759
        },
        "renderpass": [
            {
                "code": "// Inverse Perspective by HLorenzi\n// (Distance Functions by iquilezles.org)\n\nfloat marchDistance;\nfloat marchMaterial;\nvec3  marchPosition;\nfloat fieldDistance;\nfloat fieldMaterial;\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n void opUnion(inout float df1, inout float mat1, float df, float mat)          {if (df < df1) {df1 = df; mat1 = mat;}}\n void opInters(inout float df1, inout float mat1, float df, float mat)         {if (df > df1) {df1 = df; mat1 = mat;}}\nfloat dfBox(vec3 p, vec3 size, float rad)   {return length(max(abs(p) - size + vec3(rad), 0.0)) - rad;}\nfloat dfSphere(vec3 p, float rad)           {return length(p) - rad;}\nfloat dfPlane(vec3 p, vec3 n, float d)      {return dot(p, n) + d;}\nfloat dfCapsule(vec3 p, vec3 a, vec3 b, float r) {vec3 pa = p - a, ba = b - a; float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0); return length(pa - ba * h) - r;}\n vec3 dtRotateZ(vec3 p, float ang)          {return vec3(mat2(cos(ang),-sin(ang),sin(ang),cos(ang)) * p.xy, p.z);}\n vec3 dtRotate(vec3 p, float c, float s)    {return vec3(mat2(c, -s, s, c) * p.xy, p.z);}\n\nfloat distanceField(vec3 p)\n{\n\tfieldDistance = 10000.0;\n\tfieldMaterial =    -1.0;\n    \n    float roundness = 0.1;\n\t\n\topUnion(fieldDistance, fieldMaterial, dfPlane(p, vec3(0, 0, 1), 0.0), 1.0);\n\topUnion(fieldDistance, fieldMaterial, dfBox(p - vec3(3, 1, 1.05), vec3(1), roundness), 2.0);\n\topUnion(fieldDistance, fieldMaterial, dfBox(p - vec3(-3, 1, 1.05), vec3(1), roundness), 2.0);\n\topUnion(fieldDistance, fieldMaterial, dfBox(p - vec3(0, -3, 1.05), vec3(1), roundness), 2.0);\n\t\n\treturn fieldDistance;\n}\n\nvec3 normal(vec3 p)\n{\n\tconst vec2 eps = vec2(0.01, 0);\n\tfloat nx = distanceField(p + eps.xyy) - distanceField(p - eps.xyy);\n\tfloat ny = distanceField(p + eps.yxy) - distanceField(p - eps.yxy);\n\tfloat nz = distanceField(p + eps.yyx) - distanceField(p - eps.yyx);\n\treturn normalize(vec3(nx, ny, nz));\n}\n\n\nvoid raymarch(vec3 from, vec3 increment)\n{\n\tconst int   kMaxIterations = 60;\n\tconst float kHitDistance   = 0.01;\n\t\n\tmarchDistance    = -15.0;\n\tmarchMaterial    = -1.0;\n\t\n\tfor(int i = 0; i < kMaxIterations; i++)\n\t{\n\t\tdistanceField(from + increment * marchDistance);\n\t\tif (fieldDistance > kHitDistance)\n\t\t{\n\t\t\tmarchDistance += fieldDistance;\n\t\t\tmarchMaterial  = fieldMaterial;\n\t\t}\n\t}\n\t\n\tmarchPosition = from + increment * marchDistance;\n    if (marchDistance > 32.0)\n        marchMaterial = -1.0;\n}\n\nfloat shadow(vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 0.25;\n\tfor(int i = 0; i < 10; i++)\n    {\n        float h = distanceField(from + increment * t);\n        \n\t\tres = min(res, 4.0 * h / t);\n        t += 0.25;\n    }\n    return res;\n}\n\nfloat perspective = 0.0;\nfloat cameraHeight = 0.0;\n\nvoid camera(vec2 uv, vec3 eye, vec3 at, vec3 up, out vec3 from, out vec3 increment)\n{\t\n\tvec3 cw = normalize(at - eye);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu,cw));\n\t\n    float fov = acos(dot(cw, normalize(cu * uv.x)));\n    float screenSize = (10.0 / (2.0 * tan(abs(fov) / 2.0)));\n    vec3 virtscreen = eye + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\n    from = eye + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\n\tincrement = normalize(virtscreen - from);\n}\n\nvec3 pixel(vec2 uv)\n{\n    float dist = 4.0;\n\tvec3 at  = vec3(0, 0, 1);\n\tvec3 eye = at + vec3(cos(iTime / 2.0) * dist, sin(iTime / 2.0) * dist, 0.25 + cameraHeight * 2.0);\n\tvec3 up  = vec3(0,0,1);\n\tvec3 from, increment;\n\tcamera(uv, eye, at, up, from, increment);\n\traymarch(from, increment);\n\t\n    vec3 lightdir = normalize(vec3(1, 2, 3) * 3.0 - marchPosition);\n    \n\tif (marchMaterial == 1.0)\n    {\n\t\tvec3 n = normal(marchPosition);\n\t\tfloat diffuse = max(dot(n, normalize(vec3(1, 2, 3))), 0.0) * 0.5 + 0.5;\n        float shade = shadow(marchPosition, lightdir) * 0.5 + 0.5;\n\t\treturn texture(iChannel1, marchPosition.xy / 4.0).rgb * diffuse * shade;\n\t}\n\telse if (marchMaterial == 2.0)\n    {\n        vec3 tex = texture(iChannel0, (marchPosition.xy + marchPosition.zx) / 2.0).rgb;\n\t\tvec3 n = normal(marchPosition);\n\t\tfloat diffuse = max(dot(n, normalize(vec3(1, 2, 3))), 0.0) * 0.5 + 0.5;\n        \n        float specular = 0.0;\n\t\tif (dot(n, lightdir) > 0.0)\n        {\n\t\t\tspecular = min(1.0, pow(max(0.0,\n\t\t\t\t\tdot(reflect(-lightdir, n), normalize(from - marchPosition))), 50.0));\n\t\t}\n\t\treturn mix(\n            tex * diffuse,\n            vec3(1, 1, 1),\n            specular * 0.75);\n\t}\n\telse return vec3(0,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - vec2(1);\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    perspective = clamp(-0.2 + 1.4 * (iMouse.x / iResolution.x * 2.0), 0.0, 2.0);\n    cameraHeight = 2.0 - clamp(-0.2 + 1.4 * (iMouse.y / iResolution.y * 2.0), 0.0, 2.0);\n\t\n\tfragColor = vec4(pixel(uv), 1);\n    \n    float meterSize = 200.0;\n    float meterX = (iResolution.x - meterSize) / 2.0;\n    float meterY = 32.0;\n    \n    if (fragCoord.x >= meterX + meterSize * 0.7 &&\n            fragCoord.x <= meterX + meterSize * 0.7 + 2.0 &&\n            fragCoord.y >= meterY - 18.0 &&\n            fragCoord.y <= meterY + 2.0)\n    {\n        fragColor = vec4(1, 1, 1, 1);\n    }\n    else if (fragCoord.x >= meterX + 2.0 &&\n        fragCoord.x <= meterX + 2.0 + (perspective / 2.0) * (meterSize - 4.0) &&\n        fragCoord.y >= meterY - 14.0 &&\n        fragCoord.y <= meterY - 2.0)\n    {\n        fragColor = vec4(1, 0, 0, 1);\n    }\n    else if (fragCoord.x >= meterX &&\n            fragCoord.x <= meterX + meterSize &&\n            fragCoord.y >= meterY - 16.0 &&\n            fragCoord.y <= meterY)\n    {\n     \tfragColor = vec4(0, 0, 0, 1);   \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}