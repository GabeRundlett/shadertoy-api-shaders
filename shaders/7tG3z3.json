{
    "Shader": {
        "info": {
            "date": "1638065091",
            "description": "[url=https://twitter.com/joe_ryba/status/1464712353614860293]Inspiration[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "7tG3z3",
            "likes": 39,
            "name": "Shadertoy Spinner 2",
            "published": 3,
            "tags": [
                "shadertoy",
                "spinner"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2021 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned with Noodlesplate (https://github.com/aiekick/NoodlesPlate)\n\n// Inspired by the twit of @Joe_Ryba \n// https://twitter.com/joe_ryba/status/1464712353614860293\n\n// Use the code from mattz in his \"glyphspinner\" shader, for font sdf extraction \n// https://www.shadertoy.com/view/XsVcDy\n\n// fork of my Shadertoy Spinner\n// https://www.shadertoy.com/view/wdtXzn\n\n#define CHAR_WIDTH 6.\n#define CHAR_DEPTH (0.05 + 0.15 * (sin(iTime * 0.5) * 0.5 + 0.5))\n//#define CHAR_DEPTH 0.2\n#define ANGLE_OFFSET 1.74\n//#define COUNT_WORDS ((cos(iTime * 0.5) * 0.5 + 0.5) * 5.0)\n#define COUNT_WORDS 2.0\n#define RADIUS 0.6\n#define TWISTING_ANGLE 1.0\n\n// for have the good angle as time 0 for the thumbnail\n#define THUMBNAIL_TWISTING_ANGLE_OFFSET -0.5\n\n//#define WIRE_CHARS\n#define WIRE_CHARS_THICK 0.02\n\n// sdf thick when not in wire\n#define SDF_THICk_OFFSET 0.03\n\n#define COUNT_CHARS 10\n//                 S  H  A  D  E  R  T  O  Y  _\nint[] text = int[](67,56,49,52,53,66,68,63,73,0);\n\t\t\t\n// common part used by the map and mat functions\n// return the two sdf's, the torus with squared section, the font letters\nvoid common_map(vec3 p, out float dtorus, out float dfont) {\n    // rotation sheme\n\tconst float a = -ANGLE_OFFSET;\n\tp.xz *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\t\n    // circular path\n    vec2 path = vec2(length(p.xz) - RADIUS, p.y);\n    \n\t// rotation\n\tfloat an = atan(p.x,p.z) * TWISTING_ANGLE + \n        THUMBNAIL_TWISTING_ANGLE_OFFSET + iTime;\n\tpath *= mat2(cos(an), -sin(an), sin(an), cos(an));\n\t\n    // torus sdf\n    dtorus = length(max(abs(path) - vec2(CHAR_DEPTH,0.15),0.0));\n\t\n    // texture uv based on angle\n    vec2 uv = vec2(-atan(p.x,p.z)/3.14159 * COUNT_WORDS, -path.y) * CHAR_WIDTH * 0.5;\n    \n    // char case\n\tfloat cs = CHAR_WIDTH/float(COUNT_CHARS);\n    float idx = floor(uv.x/cs); // idx\n\tuv.x = mod(uv.x, cs) - cs * 0.5;\n    \n    // limit id for avoid array overflow\n\tint id = int(mod(idx,float(COUNT_CHARS)));\n    \n    // font sdf\n\tdfont = approx_font_dist(iChannel0, uv, 16 + text[id]) - 0.005;\n\t\n    #ifdef WIRE_CHARS\n    \tdfont = abs(dfont) - WIRE_CHARS_THICK;\n    #else\n    \tdfont -= SDF_THICk_OFFSET;\n    #endif\n    \n    // white space\n    if (text[id] == 0) dfont = 0.1;\n}\n\n// return the final SDF\nfloat map(vec3 p) {\n    float dtorus, dfont;\n    common_map(p, dtorus, dfont);\n    \n    // final df\n\treturn max(dtorus, dfont);\n}\n\n// same code as map but with decomposition of the last max()\n// for return the material id\nfloat mat(vec3 p) {\n\tfloat dtorus, dfont;\n    common_map(p, dtorus, dfont);\n    \n    // max() decomposition for get df id\n\tif (dtorus > dfont)\n\t\treturn 1.0;\n\treturn 0.0;\n}\n\n// get normal for the surface point and a precision\nvec3 getNormal(vec3 p, float prec) {\n\tvec3 e = vec3(prec, 0, 0);\n\treturn normalize(vec3(\n\t\tmap(p+e.xyz)-map(p-e.xyz),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\n// IQ Occ\nfloat getAmbiantOcclusion(vec3 p, vec3 n, float k) {\n    const float aoStep = 0.1; \n\tfloat occl = 0.;\n    for(int i = min(iFrame,0); i < 6; ++i)\n    {\n        float diff = float(i)*aoStep;\n        float d = map(p + n*diff);\n        occl += (diff - d) * pow(2., float(-i));\n    }\n    return min(1., 1. - k*occl);\n}\n\n// IQ Shadow\nfloat getShadow(vec3 ro, vec3 rd, float minD, float maxD, float k) {\n    float res = 1.0;\n    float d = minD;\n\tfloat s = 0.;\n    for(int i = min(iFrame,0); i < 20; ++i) {\n        s = map(ro + rd * d);\n        if( abs(s)<d*d*1e-5 ) return 0.0;\n        res = min( res, k * s / d );\n\t\td += s;\n        if(d >= maxD) break;\n    }\n    return res;\n}\n\n// get the perpsective camera\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float fov) {\n\tvec3 cu = normalize(vec3(0,0,1));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \treturn normalize(z + fov*uv.x*x + fov*uv.y*y);\n}\n\n// from IQ https://www.shadertoy.com/view/MsS3Wc\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord.xy-si)/si.y;\n    \n\tvec3 ro = vec3(0, 2.2, 0);\n  \tvec3 cv = vec3(0);\n\tvec3 rd = cam(uv, ro, cv, 0.4);\n\t\n    vec3 col = vec3(0.1);\n\n    float s = 1., d = 0., md = 100.;\n\tfor (int i = 0; i < 500; i++) {\n\t\tif (abs(s)<0.01 || d > 100.) break;\n\t\ts = map(ro + rd * d);\n\t\td += s * 0.1;\n\t}\n\t\n\tif (d < md) {\n\t\tvec3 p = ro + rd * d;\n\t\tvec3 n = getNormal(p, 0.01);\n\t\t\n\t\t// light pos\n\t\tvec3 lp = vec3(0,5,0);\n\t\t\n\t\t// light dir\n\t\tvec3 ld = normalize(lp - p);\n\t\t\t\t\t\t\t\t\n        // diffuse, ambiant occlusion, shadow, specular\n\t\tfloat diff = pow(dot(n, ld) * .5 + .5,2.0);\n\t\tfloat ao = getAmbiantOcclusion(p, n, 40.0);\n\t\tfloat sha = clamp(getShadow(p, ld, 0.01, 150.0, 5.0), 0. ,0.9);\n\t\tfloat spe = pow(max(dot(-rd, reflect(-ld, n)), 0.0), 32.0);\n\t\t\n\t\tif (mat(p) < 0.5) { \n\t\t\t// smooth hsv for letters body\n            vec3 base = hsv2rgb_smooth(vec3(atan(p.x,p.z)/3.14159*0.5 - iTime * 0.1, 0.8, 0.8)); \n            // vary base color according to ao\n\t\t\tcol = mix(base, vec3(1), ao) * 0.5;\n\t\t} else { \n            // reflected gold for letters section\n            col = vec3(1.0, 0.85, 0.0) * \n                texture(iChannel1, reflect(rd, n)).rgb;\t\n        }\n\t\t\n\t\tcol += diff * sha * 0.5 + spe;\n\t\tcol = clamp(col, 0., 1.);\n\t}\n\t\n\tcol = sqrt(col*col*1.5); // gamma correction\n\tfragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////////////\n// from mattz \"glyphspinner\" shader: https://www.shadertoy.com/view/XsVcDy\n// texture is 1024x1024\nconst float TEX_RES = 1024.;\n// texture is 16x16 glyphs\nconst float GLYPHS_PER_UV = 16.;\n// since the texture is uint8 it has a bias to represent 0\nconst float TEX_BIAS = 127./255.;\n// get font UV coords from screen coords\nvec2 font_from_screen(vec2 tpos, vec2 char_pos) \n{    \n    return (tpos + char_pos + 0.5)/GLYPHS_PER_UV;\n}\nfloat sample_dist_gaussian(sampler2D sam, vec2 uv) \n{\n    float dsum = 0.;\n    float wsum = 0.;\n    const int nstep = 3;\n    const float w[3] = float[3](1., 2., 1.);\n    for (int i=0; i<nstep; ++i) \n\t{\n        for (int j=0; j<nstep; ++j) \n\t\t{    \n            vec2 delta = vec2(float(i-1), float(j-1))/TEX_RES;   \n            float dist = textureLod(sam, uv-delta, 0.).w - TEX_BIAS;\n            float wij = w[i]*w[j];\n            dsum += wij * dist;\n            wsum += wij;\n        }\n    }\n    return dsum / wsum;\n}\nfloat approx_font_dist(sampler2D sam, vec2 p, int cidx) \n{\n    vec2 cpos = vec2(float(cidx%16), float(cidx/16));\n    vec2 uv = font_from_screen(p, cpos);\n    float fd = sample_dist_gaussian(sam, uv); \n    return fd;   \n}\n//////////////////////////////////////////////////////////////////////////////\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}