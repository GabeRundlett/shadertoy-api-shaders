{
    "Shader": {
        "info": {
            "date": "1634924295",
            "description": "I wanted to make the river i made earlier interactive.",
            "flags": 32,
            "hasliked": 0,
            "id": "NsKXRK",
            "likes": 6,
            "name": "Interactive river",
            "published": 3,
            "tags": [
                "simulation",
                "interactive",
                "refraction",
                "fluid",
                "river",
                "navier",
                "stokes"
            ],
            "usePreview": 0,
            "username": "intrakits",
            "viewed": 352
        },
        "renderpass": [
            {
                "code": "//Navier-Stokes reference:      https://www.shadertoy.com/view/tt3yzn\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n    uv=fragCoord/iResolution.xy;\n    vec4 trans = texture(iChannel1,uv);\n    vec3 col = trans.xyz;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURFACE_DIST 0.01\n#define AA 1\n\n\n\nfloat drawSphere(in vec2 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec2(.166));\n    \n}\n\nfloat cellTile(in vec2 p){\n    \n    float c = .25; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec2(.81, .62)));\n    c = min(c, drawSphere(p - vec2(.39, .2)));\n    \n    c = min(c, drawSphere(p - vec2(.62, .24)));\n    c = min(c, drawSphere(p - vec2(.2, .82)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec2(.48, .29)));\n    c = min(c, drawSphere(p - vec2(.06, .87)));\n\n    c = min(c, drawSphere(p - vec2(.6, .86)));\n    c = min(c, drawSphere(p - vec2(.18, .44)));\n        \n    return (c*4.);\n    \n}\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n   // p*=.00025;\n   //p+=iTime;\n    float f = 0.5000 * cellTile(p.xz);\n    p = m * p;\n    f += 0.2500 * cellTile(p.xz);\n    p = m * p;\n    f += 0.1666 * cellTile(p.xz);\n    p = m * p;\n    f += 0.0834 * cellTile(p.xz);\n    \n    return f;\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec3 lightPos = vec3(0,20,0);\nvec3 camPos = vec3(0,5,5.);\n\nconst float dt = 2.0f;\nconst float dx = 1.00f;\nconst float nu = 0.00001f;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 GetDist(vec3 p, vec2 uv){\n    float box = dBox(p-vec3(0,0,-1), vec3(10,.1,1));\n    float off = fbm(p*.1+iTime*.1);\n    vec4 c = texture(iChannel2, p.xz/10.-vec2(-.5,-.5));\n    /*vec4 cCol;\n    cCol.rgb = .6 + .6 * cos(6.3 * atan(c.y,c.x)/(2.*3.14159) + vec3(0,23,21)); // velocity\n\tcCol.rgb *= c.w/5.; // ink\n\tcCol.rgb += clamp(c.z - 1., 0., 1.)/10.; // local fluid density\n    cCol.a = 1.;\n    cCol.rgb=vec3(smoothstep(.1,.2,length(cCol.rgb)));\n   */// off=smoothstep(.1,.3,off)*.1;\n    //float off2 = fbm(vec3(p.x*.1+iTime*.1,0,0));\n    //vec2 res = vec2(p.y-sin(p.z+iTime*4.)*.4-sin(p.x+iTime*4.)*.4,1);\n    vec2 res = vec2(p.y-off*c.w*5.-off,1);\n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd,vec2 uv){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p,uv);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p, vec2 uv){\n    //distance to point being analyzed\n    float d = GetDist(p, uv).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy, uv).x,\n         GetDist(p-e.yxy, uv).x,\n         GetDist(p-e.yyx, uv).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p, vec2 uv){\n    //position of the light source\n    \n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p, uv);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l, uv).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\n\nvec4 Render (inout vec3 ro, inout vec3 rd, inout float reflVal, vec2 uv){\n//------------------\n    vec2 d = RayMarch(ro,rd, uv);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p, uv)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p, uv);\n    float angle = dot(n,vec3(0,1,0));\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n      //  uv.x*=.5;\n       // uv+=.5;\n        col=vec3(0,0.3,.5);\n        \n        vec3 op = texture(iChannel1,uv-vec2(noise(uv)*smoothstep(1.,.5,angle))).xyz;\n        col = mix(col,op,.03*smoothstep(.0,.1,length(op)));\n        //col*=refl*.3;\n        col*=vec3(fresnel);\n        col=min(col,vec3(.5));\n        //col+=vec3(0,0.,.6);\n        reflVal = 0.5;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb;\n      //  col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n     float dist = length(p);\n     if(dist>1000.){\n         dist = 1000.;\n     }\n    return vec4(col,dist);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    \n    float time = iTime*.5;\n    float exp1 = cos(time);\n    float exp22 = pow(sin(time)+1.5,exp1);\n   // float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 0, 0, 0);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + camPos+vec3(mo*3.,0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    vec3 p = vec3(0);\n    uv=fragCoord/iResolution.xy;\n    vec3 n=GetNormal(p, uv);\n    vec3 refr = refract(rd,n,1./1.4);\n    \n    float reflVal = 1.;\n    vec4 col = Render(ro,rd,reflVal,uv);\n    float dist = col.a;\n    vec4 bounce = .3*reflVal*Render(ro,refr,reflVal,uv);\n    \n    \n\n \n    col.xyz += bounce.xyz;\n    vec4 bounce2 = reflVal*Render(ro,rd,reflVal,uv);\n    col.xyz += bounce2.xyz;\n    uv=fragCoord/iResolution.xy;\n    vec4 op = texture(iChannel1,uv);\n    float zTest;\n    if(op.a < dist){\n   // col = op;\n    }\n    //col = op;\n   // col.xyz=min(op.,col);\n    fragColor = vec4(col.xyz,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 GetDist(vec3 p){\n    p.y+=1.;\n    float box = dBox(p-vec3(0,0,-3), vec3(.5));\n    vec2 res = vec2(box,1);\n    vec2 box2 = vec2(dBox(p-vec3(2,0,-3), vec3(.5)),2);\n    res = colMin(res,box2);\n    vec2 box3 = vec2(dBox(p-vec3(-2,0,-3), vec3(.5)),3);\n    res = colMin(res,box3);\n    \n    vec2 box4 = vec2(dBox(p-vec3(2,0,0), vec3(.5)),2);\n    res = colMin(res,box4);\n    vec2 box5 = vec2(dBox(p-vec3(-2,0,0), vec3(.5)),3);\n    vec2 grnd = vec2(p.y+10.,4);\n    res = colMin(res,grnd);\n    res = colMin(res,box5);\n    \n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n   // vec3 lightPos = vec3(40,100,0);\n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff*10.;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\n\nvec4 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 2.){\n        col *= vec3(0,1,0);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 3.){\n        col *= vec3(0,0,1);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 4.){\n        col *= vec3(.7,.3,0.);\n        //col*=refl*.4;\n       // col*=vec3(fresnel);\n        reflVal = 0.0;\n    }\n    else{\n      //  col=vec3(0,0.,0.);\n       // col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.0;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    float dist = length(p);\n     if(dist>1000.){\n         dist = 1000.;\n     }\n    return vec4(col,dist);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    float time = iTime*.5;\n    \n   // float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 0, 0, 0);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + camPos+vec3(mo*3.,0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    float reflVal = 1.;\n    vec4 col = Render(ro,rd,reflVal);\n    vec4 bounce = .3*reflVal*Render(ro,rd,reflVal);\n    col.xyz += bounce.xyz;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    //uv = (fragCoord)/iResolution.y;\n    \n    fragColor = vec4(col.xyz,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// advection & boundary & control\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o = texelFetch(iChannel0, ivec2(fragCoord), 0);  \n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    \n    // advection\n    vec4 a = texture(iChannel0, (fragCoord-o.xy*dt)/iResolution.xy);\n    fragColor = a;\n\n    \n    // interaction\n    vec2 mPos= vec2(iMouse.x,iResolution.y-iMouse.y);\n    if(sign(iMouse.z)==1.0f)\n    {\n        vec2 d = fragCoord-mPos;\n        float r = length(d);\n        vec2 d2 = mPos-abs(iMouse.zw);\n        float r2 = length(d2);\n        if(r2>0.0f)\n        {\n            fragColor.xy += d2/r2*exp(-r*r*0.01f);\n            fragColor.w += 0.5f*exp(-r*r*0.01f);\n            fragColor.w = min(fragColor.w, .8f);\n        }\n    }\n    \n    // boundary condition\n    if(fragCoord.x == 0.5f)\n    {\n        fragColor.xy = -e.xy;\n        fragColor.z = e.z;\n        fragColor.w = 0.0f;\n    }\n    \n    if(fragCoord.y == 0.5f)\n    {\n        fragColor.xy = -n.xy;\n        fragColor.z = n.z;\n        fragColor.w = 0.0f;\n    }\n    \n    if(fragCoord.x == iResolution.x-0.5f)\n    {\n        fragColor.xy = -w.xy;\n        fragColor.z = w.z;\n        fragColor.w = 0.0f;\n    }\n    \n    if(fragCoord.y == iResolution.y-0.5f)\n    {\n        fragColor.xy = -s.xy;\n        fragColor.z = s.z;\n        fragColor.w = 0.0f;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// pressure poisson\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    \n    // float divergence of the velocity\n    float div = (e.x - w.x + n.y - s.y) / (2.0f * dx * dx);\n    \n    // one jacobi iteration\n    float a = 1.0f / ( dx * dx);\n    float p = 1.0f / ( -4.0f * a ) * ( div - a * (n.z + e.z + s.z + w.z));\n\n    fragColor = vec4(o.xy, p, o.w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}