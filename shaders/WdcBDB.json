{
    "Shader": {
        "info": {
            "date": "1605963081",
            "description": "A random weave pattern on a hexagonal isometric grid, rendered in an impossible-geometry style.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdcBDB",
            "likes": 47,
            "name": "Isometric Weave Pattern",
            "published": 3,
            "tags": [
                "hexagon",
                "geometry",
                "isometric",
                "impossible",
                "weave"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 839
        },
        "renderpass": [
            {
                "code": "/*\n\n\tIsometric Weave Pattern\n    -----------------------\n\n\tUsing a subdivided hexagon grid to produce a random weave, rendered\n    in an impossible geometry style.\n\n\tSince I hadn't seen a randomized isometric weave before, I thought \n    it'd be interesting to programatically produce one. There's a bit of \n    code here, but a lot of it is window dressing. The principle behind\n\tits constuction is pretty simple:\n\n    Partition space into a hexagonal grid. With each hexagonal cell, \n    partition it into three rhomboids which will each make up a cube face. \n    Choosing the SHOW_HEX_GRID define will make it more clear, since you \n    can see the three rhomboid partitionings in the background.\n\n    With each rhomboid quad, render two straight lines between the mid \n    side edges, or one line over the other to form a cross. Cut each line \n    down the middle and assign a normal, depending upon whether it's \n    facing in the X, Y or Z directions.\n\n    The process is very similar to a hexagonal Truchet weave, but with \n\tthe lines having a straight edge isometric quality. This is just one\n\tof many styles, and just one way to produce this particular \n    arrangement -- This is a weave, but you could include cross beams and\n    so forth for way more variation. I'd imagine there'd be more elegant \n    solutions... which I'll leave to anyone bored enough to give it a go. :)\n\n\n\n    Related examples:\n\n    // Cool, clever and concise.\n\tisometric textured 3-story-map - FabriceNeyret2 \n    https://www.shadertoy.com/view/WdsXW4\n\n    // An oldschool isometric tiling example. One of my favorites on here.\n    Isometric City 2.5D - knarkowicz\n    https://www.shadertoy.com/view/MljXzz\n\n    // I'm pretty sure BigWIngs was the first to put a hexagonal weave\n    // on Shadertoy. He also has other weave examples that are worth\n    // looking up.\n    Hexagonal Truchet Weaving - BigWIngs\n    https://www.shadertoy.com/view/llByzz\n\n    // Awesome impossible geometry example... I probably should have \n    // consulted it before writing mine, as the code is much cleaner. :)\n    Impossible Chainmail - BigWIngs\n    https://www.shadertoy.com/view/td23zV\n \n    // Another impossible geometry example done in a different way.\n    Impossible Geometric Lattice - Shane\n    https://www.shadertoy.com/view/wd3XRj\n\n*/ \n \n\n\n// Hexagon cell routine. It's a shortened version of a 4-tap 3D routine, so it's\n// not as consise as it should be. If you're after that, try this version:\n//\n// Minimal Hexagonal Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\nvec4 hexCell(vec2 q){\n\n    // Block dimension: Length to height ratio with additional scaling.\n    //const vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = GSCALE*2.;\n    \n    // Two initial tile positions for a hexagon with a pointed top.\n    //vec2[2] ps4 = vec2[2](vec2(-1, .5), vec2(0, -.5));\n    vec2[2] ps4 = vec2[2](vec2(-.5, .5), vec2(.5, -.5));\n  \n    //Local coordinates of the closest hexagon cell and cell ID\n    vec2 lP, id;\n    \n        // Distance.\n    float minD = 1e5;\n    \n    // You definitely don't need a loop here, but as mentioned above, this\n    // has been cut down from a 3D routine.\n    for(int i = 0; i<2; i++){\n\n        // Cell center.\n        vec2 cntr = ps4[i]/2.; \n         \n        vec2 p = q.xy; // Local coordinates.\n        vec2 ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n           \n        // The hexagon cell distance or bound.... Kind of... Technically, it's \n        // \"max(abs(p.x)*.8660256 + abs(p.y)*.5, abs(p.y)),\" but this will work.\n        float d = dot(p, p);\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and object ID. \n        if(d<minD){\n            \n            minD = d;\n            // Setting the local coordinates and ID.\n            lP = p;\n            // Individual tile ID.\n            id = ip + cntr; // Multiply by \"s\" for scaling.\n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(lP, id);\n}\n\n\n// A swap without the extra declaration, but involves extra operations -- \n// It works fine on my machine, but if it causes trouble, let me know. :)\n#define swap(a, b){ a = a + b; b = a - b; a = a - b; }\n/*\n// Object swapping.\nvoid swap(inout float a, inout float b){ float tmp = a; a = b; b = tmp; }\nvoid swap(inout vec2 a, inout vec2 b){ vec2 tmp = a; a = b; b = tmp; }\nvoid swap(inout vec3 a, inout vec3 b){ vec3 tmp = a; a = b; b = tmp; }\n*/\n\n\nvec3 colorSurf(vec3 rd, vec3 ld, vec3 sn){\n   \n    vec3 col = vec3(.6, .25, .1)*(max(dot(sn, ld), 0.) + .25);\n    col += vec3(1, .6, .2)*pow(max(dot(reflect(sn, ld), rd), 0.), 4.); \n    //col += abs(sn)/2.;\n    return col;\n}\n\nvec3 UVToXYZ(vec2 p) {\n    return vec3(p.x + p.y, p.x, p.y);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n     // Global scale. Rendundant here.\n    const float gSc = 1.;\n    // Smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Scaled than transalated coordinates.\n    vec2 p = uv*gSc + vec2(0, .5)*iTime/8.;\n  \n    // The hexagon information for the current cell. This returns the\n    // local coordinates (h4.xy), and the unique central position ID (h4.zw).\n    vec4 h4 = hexCell(p);\n    vec2 svP = h4.xy; // Local coordinates.\n    \n    vec2 ap = abs(svP);\n    float hexDist = max(ap.y*.8660256 + ap.x*.5, ap.x) - (GSCALE).x;\n    \n    // The offset vertex information.\n    // Hexagon vertices with scaling to enable rendering back in normal space. \n    vec2 dim = GSCALE;\n    vec2[6] svV = vec2[6](vID[0]*dim, vID[1]*dim, vID[2]*dim, vID[3]*dim, vID[4]*dim, vID[5]*dim);\n\n    \n    // Containers for the midpoint edges and corresponding\n    // normals for the string and string shadows.\n    vec4 svEP[6];\n    \n    \n    \n    // The two line distance fields.\n    float ln = 1e5, ln2 = 1e5;\n    // Line edge width.\n    #ifdef SHOW_HEX_GRID\n    // Thinner lines when the hexagonal cell grid is displayed, just to \n    // make it easier to see things.\n    const float ew = .02;\n    #else\n    const float ew = .03;\n    #endif\n    \n    // The quad distace field. There are 3 rhomboidal quads per hexagon cell.\n    float qDist = 1e5;\n    // The minimum quad ID, based on the minimum quad central position.\n    vec2 qID = vec2(0);\n    // The box quad ID.\n    int bID = 0;\n    \n    \n    // The face surface normals. The first is for upward facing surfaces, and the others are\n    // for left and right facing. As an aside, it'd be possible to code hexagon, octagon\n    // surface cross sections too, but that'd be pretty painful, so I'm sticking to squares. :)\n    vec3 nr1 = vec3(0, 1, 0), nr2 = normalize(vec3(0, 0, -1)), nr3 = normalize(vec3(1, 0, 0));\n    //swap(nr1, nr2); // Swapping face normals.\n    // The two surface normals -- Initially to the left edge, but probably don't need to be.\n    vec3 sn = nr2, sn2 = nr2; \n   \n    \n    // For each hexagon, partition into three rhomboids then render two lines through \n    // each whilst assigning normals.\n    \n    for(int j = 0; j<6; j+=2){\n        \n        // Constructing the edge midpoints and normals at those\n        // points for both the string and corresponding shadows.\n        vec2[4] v = vec2[4](svV[(j + 1)%6], svV[(j + 2)%6], svV[(j + 3)%6], vec2(0));\n \n        // Quad center and local quad ID.\n        vec2 ctr = (v[0] + v[1] + v[2] + v[3])/4.;\n        vec2 lID = h4.zw + ctr;\n        \n        // Some random numbers for this particular quad.\n        float rndI = hash21(lID + .327);\n        float rndI2 = hash21(lID + .493);\n       \n        // Mid edge points. You can offset the lines from the mid point\n        // slightly (<.25) to create warped patterns. You could also \n        // offset on an edge by edge basis, but I wanted to keep things\n        // simple.\n        float offs = 0.;//sin(iTime)*.05;\n        vec2 e0 = mix(v[0], v[1], .5 + offs);\n        vec2 e1 = mix(v[1], v[2], .5 - offs);\n        vec2 e2 = mix(v[2], v[3], .5 + offs);\n        vec2 e3 = mix(v[3], v[0], .5 - offs);\n     \n\n        float quad = sdPoly4(svP, v);\n        \n        // If this particular quad is closer, calculate some lines. By the way, \n        // the \"quad<1e-3\" line is there, so that we mostly calculate the \n        // following just once. Normally, you'd just find the nearest quad, \n        // save the edge points and perform this outside the loop, but I'm trying\n        // to keep things more compact.\n        if(quad<qDist && quad<1e-3){\n            \n            \n            qDist = quad; // Minimum distance.\n            qID = lID; // Minimum quad ID.\n            bID = j/2; // Cube or box ID -- There are 3 in all.\n \n            // Swapping end points is a way to switch from two parallel quad lines\n            // to ones that cross over.\n            if(rndI<.5) { \n                 swap(e2, e3); \n            }\n            \n            // Line one and two tangents.\n            vec2 tn = normalize(e2 - e0);\n            vec2 tn2 = normalize(e3 - e1);\n            \n            // The distance fields for line one and two. Note that I've extended the\n            // mid edge points beyond the quad boundaries. This will get rid of\n            // border seam lines.\n            const float ndg = .5; // Change to \"-.02,\" or something to shorten the lines.\n            ln = lBox(svP, e0 - tn*ndg, e2 + tn*ndg, ew);\n            ln2 = lBox(svP, e1 - tn2*ndg, e3 + tn2*ndg, ew); \n            \n            // Determine which side of the center line we're on for each\n            // line segment.\n            float line02 = line(svP, e0, e2);\n            float line13 = line(svP, e1, e3);\n            \n            // Setting the face normal: This is dependent on the quad we're\n            // in (top or two sides) which side of the central line of each\n            // line segment we're in and the normal orientation (up, sloping\n            // down, etc). By the way, there's probably a more elegant way\n            // to go about setting the face normals, but these calculations\n            // are only performed once, so it doesn't matter too much... I'll\n            // leave the more elegant solution to Fabrice. :)\n            //\n            if(j==0){ // Top rhomboidal quad.\n            \n                 // Straight up and down line segment one.\n                if(abs(tn.x)<.1) {\n                    // Left side of the line, X-dominant normal.\n                    if(line02<0.) sn = nr3;\n                    else sn = nr2; // Right side of the line, Z-dominant normal.\n                }\n                else{ // Left or right line one.\n                    if(line02<0.) sn = nr3; // Bottom side of the line, X-dominant normal.\n                    else sn = nr1; // Top side of the line, Y-dominant normal.\n                }\n                \n                // Straight up and down line segment two.\n                if(abs(tn2.x)<.1) {\n                    if(line13<0.) sn2 = nr3; // Left side of the line, X-dominant normal.\n                    else  sn2 = nr2; // Right side of the line, Z-dominant normal.\n                }\n                else{  // Left or right line two.\n                    if(line13<0.) sn2 = nr1;  // Top side of the line, Y-dominant normal.\n                    else sn2 = nr2;  // Bottom side of the line, Z-dominant normal.\n                }\n                \n            }\n             \n            if(j==2){  // Bottom right rhomboidal quad.\n            \n                // Similar logic to above (See \"j==0\").\n                if(abs(tn.x)<.2) {\n                    \n                    if(line02<0.) sn = nr2;\n                    else sn = nr3;\n                }\n                else{\n                    \n                    if(line02<0.) sn = nr1;\n                    else {                        \n                        if(tn.y>.0) sn = nr3;\n                        else sn = nr2;\n                    }\n                }\n                \n                if(abs(tn2.x)<.2) {\n                    if(line13<0.) sn2 = nr2;\n                    else sn2 = nr3;\n                }\n                else{\n                    if(line13<0.) sn2 = nr1;\n                    else sn2 = nr3;\n                }\n                \n            }  \n            \n            \n             if(j==4){ // Bottom right rhomboidal quad.\n            \n                // Similar logic to above (See \"j==0\").\n                if(abs(tn.x)<.2){\n                    if(line02<0.) sn = nr2;\n                    else sn = nr3;\n                }\n                else{\n                    if(line02<0.) sn = nr2;\n                    else sn = nr1;\n                }\n                 \n                \n                if(abs(tn2.x)<.2) {\n                    if(line13<0.) sn2 = nr2;\n                    else sn2 = nr3;\n                }\n                else{\n                    if(line13<0.){\n                        if(tn2.y>.0) sn2 = nr2;\n                        else sn2 = nr3;\n                    }\n                    else sn2 = nr1;\n                }\n                \n            }           \n \n            // Randomly swapping the rendering order of the lines for\n            // more variation.\n            if(rndI2<.5){\n                swap(ln, ln2);\n                swap(sn, sn2);\n            }\n \n            \n            \n        }\n \n    }\n    \n    \n    // Rendering.\n \n    // At this point, you have access to the two line distance field values, and\n    // their respective normals. You also have the quad distance field values and\n    // normals, so at this point, you can render whatever you want in as simple\n    // or as complex a manner as you'd like.\n    \n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1));\n    // Fake point light... Very fake, but it's only used to create a bit of\n    // gradient shine within the scene, so it doesn't matter.\n    vec3 ld = normalize(vec3(.5, 3, -3) - UVToXYZ(uv));\n    //vec2 xy = rot2(3.14159/3.)*uv;\n    //vec3 ld = normalize(vec3(.5, 3, -3) - vec3(xy.x, uv.y, xy.y));\n    vec3 ld2 = -ld.zxy; // Another light.\n\n    \n        \n    // Initializing the scene color to the background color.\n    vec3 col = vec3(1);\n    \n    // The two line distance field colors.\n    vec3 lnCol = vec3(1);\n    vec3 lnCol2 = vec3(1);\n    \n    \n    \n    // Face IDs. One for each pylon, or line.\n    int faceID1 = abs(sn.x)>.8? 0 : abs(sn.y)>.8? 1 : 2;\n    int faceID2 = abs(sn2.x)>.8? 0 : abs(sn2.y)>.8? 1 : 2;\n \n    #ifdef FLAT_SHADING\n        // Flat shading option.\n    \n        // The three face colors. I've arranged for the lightest side to face up.\n        const vec3 cc = vec3(1, .8, .55);\n        //vec3 aCol[3] = vec3[3](cc*cc*cc*.5, cc, cc*cc*.8);\n        //vec3 aCol[3] = vec3[3](vec3(1, .15, .3), vec3(1, .5, .85), vec3(.6, .1, 1));\n        vec3 aCol[3] = vec3[3](vec3(1, .1, .01), vec3(1, .6, .1), vec3(1, .2, .0));\n        // The two line colors.\n        lnCol = aCol[faceID1];\n        lnCol2 = aCol[faceID2];\n    #else    \n        // Using the face normal to lighting the surface.\n    \n        lnCol = colorSurf(rd, ld, sn); \n        lnCol2 = colorSurf(rd, ld, sn2); \n        //lnCol = vec3(1)*dot(lnCol, vec3(.299, .587, .114));\n        //lnCol2 = vec3(1)*dot(lnCol2, vec3(.299, .587, .114));\n        //lnCol += pow(colorSurf(rd, ld2, sn).zyx, vec3(2))/16.; \n        //lnCol2 += pow(colorSurf(rd, ld2, sn2).zyx, vec3(2))/16.; \n    #endif\n\n    // The cross hatching pattern on each face. Oriented to match the face.\n    vec3 aR = vec3(-3.14159/3., 0, 3.14159/3.) + 3.14159/1.;\n    vec2 qUV = rot2(aR[faceID1])*p;\n    vec2 qUV2 = rot2(aR[faceID2])*p;\n    float freq = 150.;\n    float pat = abs(fract(qUV.y*freq) - .5)*2. - .1;\n    float pat2 = abs(fract(qUV2.y*freq) - .5)*2. - .1;\n    pat = smoothstep(0., sf*freq*2., pat);\n    pat2 = smoothstep(0., sf*freq*2., pat2);\n    #ifdef HATCHING\n    // Applying the hatch pattern to each line.\n    lnCol *= pat*.4 + .7;\n    lnCol2 *= pat2*.4 + .7;\n    #endif\n    \n    // The background cubes consist of the three face quads. The top quad has\n    // an upward facing normal, and the sides have X or Z faceing normals. \n    vec3 cN = bID == 0? nr3 : bID == 1? nr2 : nr1;\n\n    // The cube cross hatch pattern.\n    freq = 150.;\n    vec2 qUV3 = rot2(aR[(bID + 1)%3])*p;\n    float pat3 = abs(fract(qUV3.y*freq) - .5)*2. - .1;\n    pat3 = smoothstep(0., sf*freq*2., pat3);\n    \n    #ifndef FLAT_SHADING\n    //vec3 cCol = colorSurf(rd, ld, cN);\n    vec3 cCol = vec3(1, .95, .9);\n    // Add some blue light to the cube faces.\n    cCol += pow(colorSurf(rd, ld2, cN).zyx, vec3(2))/2.; \n    #else \n    vec3 cCol = vec3(.25, .2, .15);\n    col = cCol;\n    #endif\n    \n    // Random blinking.\n    float rnd = hash21(qID + .13);\n    rnd = smoothstep(.9, .95, sin(6.2831*rnd + iTime*2.)*.5 + .5);\n    // Shading the background with one of the normals.\n    float sh3 = dot(colorSurf(rd, ld, nr1), vec3(.299, .587, .114));\n    \n    // Hexagonal cell background shade.\n    //float sh = max(.5 - qDist/.1, 0.);\n    float sh = max(.5 - hexDist/.1, 0.);\n    \n    #ifdef FLAT_SHADING\n    sh = 1., sh3 = 1.; rnd = 0.;\n    #endif\n    // Border highlight color.\n    vec3 hiCol = cCol*vec3(.3, .4, 1)*4.*sh3;\n   \n    // Applying shade and hatching to the cube background.\n    cCol *= sh3*sh;\n    #ifdef HATCHING\n    cCol *= (pat3*.4 + .7);\n    #endif\n   \n    // Rendering the hexagonal quad segment in the background -- Dark edge and coloring.\n    col = mix(col, cCol, (1. - smoothstep(0., sf, qDist + .0035)));\n    #ifndef FLAT_SHADING\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., abs(qDist) - .0035/2.*6.))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.*6.))); \n    col = mix(col, mix(vec3(sh3), hiCol, rnd), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.*3.))); \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.)));\n    #else\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.*5.)));\n    //col = mix(col, vec3(.25, .2, .15)*2., (1. - smoothstep(0., sf, abs(qDist) - .0035/2.*3.)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.)));\n    #endif\n   \n    // Shading the lines.\n    sh = max(.5 - ln/.03, 0.);\n    float sh2 = max(.5 - ln2/.03, 0.);\n    \n    #ifdef FLAT_SHADING\n    sh2 = 1.;\n    #endif\n\n     \n    // Rendering the first line layer -- Drop shadow, edges, color and center line.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., ln))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    //col = mix(col, vec3(.5)*sh, 1. - smoothstep(0., sf, ln + .005));\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln + .005 + .0035));\n    col = mix(col, lnCol*sh, 1. - smoothstep(0., sf, ln + .005)); // + .005 + .0035\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln + ew - .0015));\n \n    // Doing the same for the second line layer \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., ln2))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2)); \n    //col = mix(col, vec3(.5)*sh2, 1. - smoothstep(0., sf, ln2 + .005));\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2 + .005 + .0035));\n    col = mix(col, lnCol2*sh2, 1. - smoothstep(0., sf, ln2 + .005)); // + .005 + .0035\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2 + ew - .0015));\n \n \n    #ifdef SHOW_HEX_GRID\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(hexDist) - .005/2.*3.))*.5); \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(hexDist) - .005/2.*3.))); \n    col = mix(col, vec3(1, .95, .9), (1. - smoothstep(0., sf, abs(hexDist) - .005/2.))); \n    #endif\n \n    // Mixing in a bit of gradient color.\n    col = mix(col, col.xzy, length(uv)*.25);\n    \n    //col = mix(col.zyx, col.yxz, .8); // Other colors.\n    \n    // Applying a subtle silhouette, for art's sake.\n\tuv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n                          \n\n    // Rough gamma correction, and we're done.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Display the individual hexagon grid cells.\n//#define SHOW_HEX_GRID\n    \n// Flat shading. No lighting.\n//#define FLAT_SHADING\n \n// Apply hatching\n#define HATCHING\n\n// Tile scale.\n#define GSCALE vec2(1./5.)*vec2(.5, .8660254)\n\n\n//  Vertices and edge midpoints: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-.5, -1./3.)/vec2(.5, 1), vec2(-.5, 1./3.)/vec2(.5, 1), vec2(0, 2./3.)/vec2(.5, 1), \n                      vec2(.5, 1./3.)/vec2(.5, 1), vec2(.5, -1./3.)/vec2(.5, 1), vec2(0, -2./3.)/vec2(.5, 1));\n//vec2[6] eID = vec2[6](vec2(-.5, 0)/vec2(.5, 1), vec2(-.25, .5)/vec2(.5, 1), vec2(.25, .5)/vec2(.5, 1), vec2(.5, 0)/vec2(.5, 1), \n                      //vec2(.25, -.5)/vec2(.5, 1), vec2(-.25, -.5)/vec2(.5, 1));\n\n \n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ \n    \n    p = mod(p, 256.);\n    // An annoying, but necessary, hack for systems with less sin\n    // function accuracy. If anyone knows a way around it, feel \n    // free to let me know.\n    //p = floor(p*1048576.)/1048576.;\n    return fract(sin(mod(dot(p, vec2(27.649, 57.583)), 6.2831859))*43758.5453); \n}\n*/\n\n/*\n// UE4 random function: I like this because it incorporates a modulo\n// 128 wrap, so in theory, things shouldn't blow up with increasing input.\n// Also, in theory, you could tweak the figures by hand to get a really\n// scrambled output... When I'm feeling less lazy, I might do that.\nfloat hash21(vec2 p) {\n\n    p = fract(p/128.)*128. - vec2(59.340627, 73.465623);\n    return fract(dot(p.xyx*p.xyy, vec3(20.390625, 80.703127, 12.4281203)));\n    \n}\n*/\n\n\n\n// This is IQ's WebGL 2 hash formula: I've modified it slightly to \n// take in the normal decimal floats that we're used to passing. It \n// works here, I think, but I'd consult the experts before using it.\n//\n// I remember reading through a detailed explanation of the C++ hash \n// we all used to use many years ago (which the following would be\n// similar to), but have long since forgotten why it works. By the \n// way Nimitz and Dave Hoskins have formulae on Shadertoy that's worth\n// looking up.\n//\n// Integer Hash - III - IQ\n// https://www.shadertoy.com/view/4tXyWN\nfloat hash21(vec2 p){\n    \n    uvec2 q = floatBitsToUint(p);\n\tq = 1103515245U*((q>>1U)^q.yx);\n    uint n = 1103515245U*(q.x^(q.y>>3U));\n    return float(n)/float(0xffffffffU);\n}\n \n\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV2 4\n//\nfloat sdPoly4(in vec2 p, in vec2[NV2] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// Determines which side of a line a pixel is on. Zero is the threshold.\nfloat line(vec2 p, vec2 a, vec2 b){\n     return ((b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x));\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}