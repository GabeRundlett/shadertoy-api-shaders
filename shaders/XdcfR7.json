{
    "Shader": {
        "info": {
            "date": "1525097710",
            "description": "Arcane Lands. My first attempt at coding 'God Rays'\nI've used the depth value and some 3D cloud effect for the light ray intensity, it seems to look OK on tunnels...\n",
            "flags": 32,
            "hasliked": 0,
            "id": "XdcfR7",
            "likes": 97,
            "name": "Arcane Lands",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "terrain",
                "grass",
                "godrays",
                "cave",
                "lands",
                "arcane"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 4810
        },
        "renderpass": [
            {
                "code": "// Render Sun Rays over landscape from 'B\n// by David Hoskins. April 30th, 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec3 sunPos;\n\n//----------------------------------------------------------------------------------------\nvec4 getStore(int num)\n{\n\treturn  texelFetch(iChannel0, ivec2(num, 0), 0);\n}\n\n//----------------------------------------------------------------------------------------\nmat3 getStoreMat33(int num)\n{\n    vec3 m0 = texelFetch(iChannel0, ivec2(num, 0),   0).xyz;\n    vec3 m1 = texelFetch(iChannel0, ivec2(num+1, 0), 0).xyz;\n    vec3 m2 = texelFetch(iChannel0, ivec2(num+2, 0), 0).xyz;\n    return mat3(m0, m1, m2);\n}\n//----------------------------------------------------------------------------------------\nfloat noise( in vec3 p )\n{\n    vec3 f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\t \n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+ 0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//----------------------------------------------------------------------------------------\nfloat getMist(vec3 dir, vec2 uv, vec3 pos)\n{\n    vec3 clou = dir * 1.5 + pos*.02;\n\tfloat t = noise(clou);\n    t += noise(clou * 2.1) * .4;\n    t += noise(clou * 4.3) * .2;\n    t += noise(clou * 7.9) * .1;\n \n    return t;\n}\n\nfloat obscurePartsOfSun(vec2 p)\n{\n    float a = 0.0, z;\n    float e = .08;\n\n    vec2 asp = vec2(iResolution.y/iResolution.x,1.0);\n   \tvec2 texUV = .5+.5*p*asp;\n   \tz = texture(iChannel3, texUV).w;\n    if (z >= FAR) a +=.5;\n    \n    texUV = .5+.5*(p+vec2(e, e))*asp;\n   \tz = texture(iChannel3, texUV).w;\n    if (z > FAR) a +=.125;\n\n    texUV = .5+.5*(p+vec2(e, -e))*asp;\n   \tz = texture(iChannel3, texUV).w;\n    if (z > FAR) a +=.125;\n\n    texUV = .5+.5*(p+vec2(-e, -e))*asp;\n   \tz = texture(iChannel3, texUV).w;\n    if (z > FAR) a +=.125;\n    \n    texUV = .5+.5*(p+vec2(-e, e))*asp;\n   \tz = texture(iChannel3, texUV).w;\n    if (z > FAR) a +=.125;\n\n    return a;\n}    \n\n\n//----------------------------------------------------------------------------------------\nfloat godRays(vec2 uv)\n{\n   \tfloat ra =0.0;\n\tvec2 sunPos = vec2(dot( sunLight, camMat[0] ),dot( sunLight, camMat[1] ) )-vec2(0.05,-.15);\n   \tvec2 p = uv-sunPos;\n    float add = hash12(uv*4000.)*.02;\n    \n    \n \tfor (float x = .1; x < 1.; x+=.02)\n\t{\n\t\tfloat z = max(textureLod(iChannel3,(sunPos+(p*(x+add))+1.)*.5, 0.).w, 300.0)-300.;\n\t\tra+= z*x;\n\t}\n   \n    return ra*.00001;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 lenseFlare(vec2 uv,vec3 dir, mat3 camMat)\n{\n\n    vec3 col = vec3(0);\n    \n    mat3 inv = transpose(camMat);\n    vec3 cp = inv * - sunPos;\n    //\n\tif (cp.z < 0.0)\n\t{\n\n        vec2 sun2d = zProj * cp.xy / cp.z;\n        if (sun2d.x < -2.0 || sun2d.x > 2. || sun2d.y < -2.0 || sun2d.y > 2.) return col;\n\n        float z = obscurePartsOfSun(sun2d);\n    \t\n        if (z > 0.0)\n        {\n            float bri = max(dot(dir, sunLight)*.5, 0.0);\n            bri = pow(bri, 3.)*5.*z;\n\n            vec2 uvT = uv - sun2d;\n\n            float glare1 = max(dot(dir,sunLight),0.0);\n\n            uvT = mix (uvT, uv, -2.3);\n            float glare2 = max(1.7-length(uvT+sun2d*3.)*4.0, 0.0);\n            float glare3 = max(1.7-pow(length(uvT+sun2d*3.5)*14., 200.), 0.0)*.7;\n\n            col += bri * vec3(1.0, .0, .0)  * pow(glare1, 10.5)*2.;\n            col += bri * vec3(.5, .05, .0) * pow(glare2, 3.);\n            col += bri * vec3(.1, .1, .6) * pow(glare3, 3.)*3.0;\n        }\n\t}\n    return col*.8;\n}\n \n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 xy = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    fragColour\t= texelFetch(iChannel3, ivec2(fragCoord), 0);\n    vec3 col \t= fragColour.xyz;\n    sunLight \t= getStore(SUN_DIRECTION).xyz;\n    camPos\t\t= getStore(CAMERA_POS).xyz;\n    camMat \t\t= getStoreMat33(CAMERA_MAT0);\n    zProj = projectZ(uv);\n\n    vec3 dir \t= camMat * normalize( vec3(uv, zProj));\n    sunPos = sunLight * 20000.;\n    \n    float t = getMist(dir, uv, camPos);\n    t = mix(1.0, t, exp(-0.00005*fragColour.w));\n    float gr  = godRays(xy);\n    //col = clamp(col, 0.0, 1.0);\n    \n   \tcol += gr*t * SUN_COLOUR;\n    col += lenseFlare(uv, dir, camMat);\n\n \n    float vig = smoothstep(4.2,.5, dot(uv,uv)); \n    col*= vig;\n    col *= smoothstep(.0, 4.0, iTime);\n    col = min(col*vec3(1.1,1.,.8), 1.0);\n    \n    fragColour = vec4(sqrt(col), 1.0);\n\n\n    \n}\n    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Common functions and defines...\n\n// Make a high def version for Youtube\n//#define MOVIE\n\n// These are indices into the variable data in Buf A...\n\n#define CAMERA_POS\t\t0\n#define CAMERA_TAR\t\t1\n#define CAMERA_MAT0\t\t2\n#define CAMERA_MAT1\t\t3\n#define CAMERA_MAT2\t\t4\n\n#define SUN_DIRECTION \t5\n#define LAST \t\t\t6\n\n\n#define FAR 1100.\n\n#define TAU 6.28318530718\n#define SUN_COLOUR vec3(1., .8, .7)\n#define FOG_COLOUR vec3(.4, .4, .4)\n\nvec3 sunLight, camPos;\nvec3 camera;\nfloat specular;\nmat3 camMat;\nfloat zProj;\n\n//----------------------------------------------------------------------------------------\nvec3 cameraPath( float z )\n{\n\treturn vec3(200.*sin(z * .0045)+190.*cos(z *.001),\n                43.*(cos(z * .0047)+sin(z*.0013)) + 53.*(sin(z*0.003)),\n                z);\n}\n// Set up a camera matrix\n\n//--------------------------------------------------------------------------\nmat3 setCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n//--------------------------------------------------------------------------\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n//---------------------------------------------------------------------------------------------------------------\nfloat sMax(float a, float b, float s)\n{\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n//--------------------------------------------------------------------------\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( hash12(p), hash12(p+ vec2(1.0, 0.0)),f.x),\n                    mix( hash12(p+ vec2(.0, 1.0)), hash12(p+ vec2(1.0, 1.0)),f.x),f.y);\n    return res;\n}\n\nfloat projectZ(vec2 uv)\n{\n\treturn .6;\n//   return cos(length(uv*.75));\n}\n\n\n#define HASHSCALE1 .1031\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// by David Hoskins.\n\n// This is the Data buffer, holds everything that only uses one pixel to calculate.\n// I don't know if it efficient to do this but it appears to work well with complex shaders...\n\n\n//----------------------------------------------------------------------------------------\nfloat grabTime()\n{\n  \tfloat m = (iMouse.x/iResolution.x)*80.0;\n\treturn (iTime+m+410.)*32.;\n}\n\n//----------------------------------------------------------------------------------------\nint StoreIndex(ivec2 p)\n{\n\treturn p.x + 64 * p.y;\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord);\n    vec4 col = vec4(0.);\n\tfloat gTime = grabTime();\n    \n    int num = StoreIndex(pos);\n    if (num >= LAST) discard;\n    \n    float r = gTime / 63.;\n    vec3 camPos, camTar;\n    mat3 camMat;\n    if (num <= CAMERA_MAT2)\n    {\n    \tcamPos = cameraPath(gTime)+vec3(sin(r*.4 )*24., cos(r*.3)*24., 0.);\n    \tcamTar = cameraPath(gTime + 30.);\n        camMat = setCamMat(camPos, camTar, (camTar.x-camPos.x)*.02);\n    }\n\n    switch (num)\n    {\n        case CAMERA_POS:\n        \tcol.xyz = camPos;\n    \t\tbreak;\n        case CAMERA_TAR:\n            col.xyz = camTar;\n        \tbreak;\n        case CAMERA_MAT0:\n\t       \tcol.xyz = camMat[0];\n        \tbreak;\n\t\tcase CAMERA_MAT1:\n        \tcol.xyz = camMat[1];\n        \tbreak;\n        case CAMERA_MAT2:\n        \tcol.xyz = camMat[2];\n        \tbreak;\n        case SUN_DIRECTION:\n        \tcol.xyz  = normalize( vec3(  0.3, .75, .4 ) );\n    \t\tbreak;\n    }\n    fragColour = col;\n \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Render the lanscape and sky...\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n//========================================================================\n// Utilities...\n\n//----------------------------------------------------------------------------------------\n// Grab value of variable, indexed 'num' from buffer_ A...\n// Useful because each pixel doesn't need to do a whole bunch of math/code over and over again.\n// Like camera positions and animations...\nvec4 getStore(int num)\n{\n\treturn  texelFetch(iChannel0, ivec2(num, 0), 0);\n}\n\nmat3 getStoreMat33(int num)\n{\n    vec3 m0 = texelFetch(iChannel0, ivec2(num, 0),   0).xyz;\n    vec3 m1 = texelFetch(iChannel0, ivec2(num+1, 0), 0).xyz;\n    vec3 m2 = texelFetch(iChannel0, ivec2(num+2, 0), 0).xyz;\n    return mat3(m0, m1, m2);\n}\n\n//----------------------------------------------------------------------------------------\nfloat  sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n \n//--------------------------------------------------------------------------\n\n//--------------------------------------------------------------------------\nfloat noise( in vec3 p )\n{\n    vec3 f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+ 0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#define VOR_SCALE .01\nfloat voronoi( vec3 p)\n{\n    p*= VOR_SCALE;\n    vec2 f = fract(p.xz);\n    p.xz = floor(p.xz);\n    float d = 1000.7, d2;\n    float ret = 0.;\n    vec2 tp;\n    \n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            vec2 g = vec2(xo, yo);\n            vec2 q = g + p.xz;\n \n            vec2 n = textureLod(iChannel3,(q)/256.0, -100.0).xy;\n            tp = g + n  - f + sin(p.y-n.y*37.)*.2;\n            d2 = dot(tp, tp);\n            \n            if (d2 < d)\n            {\n                d = d2;\n                ret = sqrt(d) / VOR_SCALE;\n                ret-= 10.;\n            }\n\t\t}\n\t}\n \n    return ret;\n}\n\n\n//--------------------------------------------------------------------------\n// This uses mipmapping with the incoming ray distance.\n// I think it also helps with the texture cache, but I don't know that for sure...\nfloat map( in vec3 p, float di)\n{\n  \n    // Grab texture based on 3D coordinate mixing...\n \tfloat te = textureLod(iChannel1, p.xz*.0017 + p.xy * 0.0019-p.zy*.0017, di).y*80.0;\n    // Make a wibbly wobbly sin/cos dot product..\n    float h = dot(sin(p*.019),(cos(p.zxy*.017)))*100.;\n    \n    // Rock Plateaus...\n    float g = p.y*.33 + textureLod(iChannel1, p.xz*.0003, 4.).x*40.0;\n    float c = 60.0;\n    g /= c;\n    float s = fract(g);\n    g = floor(g)*c+pow(s, 20.)*c;\n    // Add them all together...\n    float d =  h+te + g;\n    \n    //d = min(d, voronoi(p));\n    //...Then subtract the camera tunnel...\n    vec2 o = cameraPath(p.z).xy;\n    p.xy -= o;\n    float tunnel = 40. - length(p.xy); \n     \n    d = sMax(d, tunnel, 140.);\n\n\n    return d;\n}\n\n//--------------------------------------------------------------------------\n\nvec3 getSky(vec3 dir, vec2 uv, vec3 pos)\n{\n    vec3 col;\n\tcol = mix(vec3(FOG_COLOUR), vec3(0.05, 0.14,.5),abs(dir.y));\n \n    return col;\n}\n\n\n//--------------------------------------------------------------------------\n\nvec3 getNormal(vec3 p, float e)\n{\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), e) - map(p-vec3(e,0.0,0.0), e),\n                            map(p+vec3(0.0,e,0.0), e) - map(p-vec3(0.0,e,0.0), e),\n                            map(p+vec3(0.0,0.0,e), e) - map(p-vec3(0.0,0.0,e), e) ) );\n}\n\n//--------------------------------------------------------------------------\n\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n    float halfwayT;\n  \n    for (int i = 0; i < 8; i++)\n    {\n\n        halfwayT = dot(t, vec2(.5));\n        float d = map(rO + halfwayT*rD, halfwayT*.002); \n        t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.01, d));\n    }\n\n\treturn halfwayT;\n}\n\n//--------------------------------------------------------------------------\nfloat marchScene(in vec3 rO, in vec3 rD, vec2 co)\n{\n\tfloat t = 5.+10.*hash12(co);\n    float oldT = 0.;\n\tvec2 dist = vec2(1000);\n\tvec3 p;\n    bool hit = false;\n    \n    #ifdef MOVIE\n\n    for( int j=0; j < 1000; j++ )\n    #else\n    for( int j=0; j < 200; j++ )\n    #endif\n\t{\n\t\tif (t >= FAR) break;\n\t\tp = rO + t*rD;\n\n\t\tfloat h = map(p, t*0.002);\n \t\tif(h < 0.01)\n\t\t{\n            dist = vec2(oldT, t);\n            break;\n\t     }\n        oldT = t;\n        #ifdef MOVIE\n        t += h * .2;\n        #else\n        t += h * .35 + t*.001;\n        #endif\n\t}\n    if (t < FAR) \n    {\n       t = BinarySubdivision(rO, rD, dist);\n    }\n    return t;\n}\n\n//--------------------------------------------------------------------------\nfloat noise2d(vec2 p)\n{\n    vec2 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( hash12(p),  \t\t    hash12(p + vec2(1,0)),f.x),\n                    mix( hash12(p + vec2(0,1)), hash12(p + vec2(1,1)),f.x),f.y);\n    return res;\n}\n\n//--------------------------------------------------------------------------\nfloat findClouds2D(in vec2 p)\n{\n\tfloat a = 1.0, r = 0.0;\n    p*= .0015;\n    for (int i = 0; i < 5; i++)\n    {\n        r+= noise2d(p*=2.2)*a;\n        a*=.5;\n    }\n\treturn max(r-1., 0.0);\n}\n\n//--------------------------------------------------------------------------\n// Use the difference between two cloud densities to light clouds in the direction of the sun.\nvec4 getClouds(vec3 pos, vec3 dir)\n{\n    if (dir.y < 0.0) return vec4(0.0);\n    float d = (1600. / dir.y);\n    vec2 p = pos.xz+dir.xz*d;\n    float r = findClouds2D(p);\n    float t = findClouds2D(p+normalize(sunLight.xz)*15.);    \n    t = sqrt(max((r-t)*20., .2))*.8;\n    vec3 col = vec3(t) * SUN_COLOUR;\n    // returns colour and alpha...\n    return vec4(col, r);\n}\n\n//--------------------------------------------------------------------------\n// Turn a 2D texture into a six sided one...\nvec3 texCube(in sampler2D tex, in vec3 p, in vec3 n )\n{\n\tvec3 x = textureLod(tex, p.yz, 0.0).xyz;\n\tvec3 y = textureLod(tex, p.zx, 0.0).xyz;\n\tvec3 z = textureLod(tex, p.xy, 0.0).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(1e-20+abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//--------------------------------------------------------------------------\n// Grab the colour...\nvec3 albedo(vec3 pos, vec3 nor)\n{\n    specular  = .8;\n    vec3 alb  = texCube(iChannel2, pos*.017, nor).yxz;\n\n    // Brown the texture in places for warmth...\n    float f = noise(pos*.01);\n    alb *= vec3(.75+f, 1., .9);\n    \n\t// Do grass on flat areas..\n    float grass = smoothstep(0.1, .8, nor.y)* (noise(pos*.07)+.1);\n\t\n    float v = (noise(pos*.05) + noise(pos*.1)*.5)*.5;\n    \n    vec3 col = texture(iChannel2,pos.xz*.01).xyz;\n    col += texture(iChannel3,pos.xz*.01).x-.3;\n    alb = mix(alb, col* vec3(.1+v, 0.8,.1), grass); \n    alb = clamp(alb, 0.0, 1.0);\n    specular= max(specular-grass, 0.0);\n    \n    return pow(alb, vec3(1.3));\n}\n\n\n//--------------------------------------------------------------------------\nfloat shadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    \n    float t = .1;\n    for( int i = 0; i < 10; i++ )\n    {\n\t\tfloat h = map(ro + rd*t, 1.);\n\n        res = min( res, 4.*h/t );\n        t += h + t*.01;\n        if (res < .3) break;\n    }\n    return clamp( res, 0.3, 1.0 );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = .1 + 1.*float(i);\n        float d = map( pos+h*nor, 0.);\n        occ += (h-d)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0-1.0*occ, 0.0, 1.0 );\n}\n\n\n//--------------------------------------------------------------------------\nvec3 lighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n  \n\tfloat sh = shadow(pos+normal*.2,  sunLight);\n    vec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0))*sh;\n    float occ = calcOcc(pos, normal);\n\n    \n    // Ambient...\n\tcol += mat * SUN_COLOUR  * abs(-(normal.y*.14)) * occ;\n    \n    normal = reflect(eyeDir, normal); // Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 12.0)  * SUN_COLOUR * sh * specular* occ;\n    \n\n\treturn min(col, 1.0);\n}\n\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    specular = 0.0;\n  \tvec3 col;\n\n    sunLight \t= getStore(SUN_DIRECTION).xyz;\n    camPos = getStore(CAMERA_POS).xyz;\n    camMat = getStoreMat33(CAMERA_MAT0);\n\n    vec3 dir = camMat * normalize( vec3(uv, projectZ(uv)));\n\n    vec3 sky = getSky(dir, uv, camPos);\n    //March it...\n    float dhit = marchScene(camPos, dir, fragCoord);\n    // Render at distance value...\n    if (dhit < FAR)\n    {\n\t   \tvec3  p = camPos+dhit*dir;\n        float pixel = iResolution.y;\n       \tvec3 nor =  getNormal(p, dhit/pixel);\n       \tvec3 mat = albedo(p, nor);\n\t\tvec3  temp = lighting(mat, p, nor, dir, dhit);\n\t\t// Distance fog...\n       \t//temp = mix(sky, temp , exp(-dhit*.0006));\n       \tcol = temp;\n    }else\n\t{\n \n        // Clouds and Sun...\n        col = sky;\n        vec4 cc = getClouds(camPos, dir);\n       \n        col = mix(col, cc.xyz, cc.w);\n\n        col+= pow(max(dot(sunLight, dir), 0.0), 200.0)*SUN_COLOUR;\n        col = min(col, 1.0);\n    }\n    col = clamp(col, 0.0, 1.0);\n\t//col = mix( col, vec3(dot(col,vec3(0.333))), 0.4 );\n    col = col*.6+col*col*(3.0-2.0*col);\n    \n\tfragColour = vec4(col, dhit);\n    //fragColor = vec4(poo);\n    \n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}