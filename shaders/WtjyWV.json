{
    "Shader": {
        "info": {
            "date": "1595487533",
            "description": "Niantic Airship, with Balloon Pikachu and Harry Potter flying as escorts through the clouds.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtjyWV",
            "likes": 17,
            "name": "Niantic Airship",
            "published": 3,
            "tags": [
                "pikachu",
                "niantic",
                "airship",
                "harrypotter"
            ],
            "usePreview": 0,
            "username": "emmasteimann",
            "viewed": 539
        },
        "renderpass": [
            {
                "code": "vec2 witch(vec3 pos) {\n    vec3 pr1 = pos;\n    pr1 = tX(pr1, vec3(0,0,0));\n    float pointy = sdCone(pr1, vec2(0.5, 0.2), 0.15);\n    \n    pr1 = tX(pr1, vec3(0,-0.15,0));\n    float cappypart = sdCappedCylinder(pr1,vec2(0.2, 0.01));    \n    pointy = min(pointy,cappypart);\n    \n    pr1 = tX(pr1, vec3(0,-0.05,0));\n    float head = sdSphere(pr1, .1);\n    pointy = min(pointy,head);\n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.05);\n    pr1 = tX(pr1, vec3(0,-0.5,0));\n    float body = sdRoundCone(pr1, 0.14,0.05, 0.2);\n    pointy = min(pointy,body);\n    \n    pr1 = pos;\n    pr1 = tX(pr1, vec3(0,-0.55,0.1));\n    pr1.yz = rX(pr1.yz,-0.5);\n    float broom = sdCappedCylinder(pr1,vec2(0.02, 0.4));    \n    pointy = min(pointy,broom);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.05,-0.5,.05));\n    pr1.yz = rX(pr1.yz,0.25);\n    pr1.xy = rX(pr1.xy,0.075);\n    float arm = sdCappedCylinder(pr1,vec2(0.02, 0.125));\n   \tpointy = min(pointy,arm);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.05,-0.6,-.15));\n    pr1.yz = rX(pr1.yz,-0.35);\n    pr1.xy = rX(pr1.xy,0.075);\n    float leg = sdCappedCylinder(pr1,vec2(0.02, 0.125));\n   \tpointy = min(pointy,leg);\n    \n    vec2 witchBody = vec2(pointy*.5, 7.0);\n    \n    pr1 = pos;\n    pr1.xz *= .5;\n    pr1 = tX(pr1, vec3(0,-0.55,-.25));\n    pr1.yz = rX(pr1.yz,-0.5);\n    float sweep = sdRoundCone(pr1, 0.075,0.05, 0.05);\n    pointy = min(pointy,sweep);\n    add(witchBody, vec2(sweep*.5, 8.0));\n    return witchBody;\n}\n\nvec2 balloonPika(vec3 pos) {\n    vec3 pr1 = tX(pos, vec3(0,0,-.1));\n    pr1.yz = rX(pr1.yz, -0.5);\n    vec2 body = vec2(sdRoundCone(pr1, 0.125,0.075, 0.2)*.5, 10.0);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n  \tpr1 = tX(pr1, vec3(.1,0,0.1));\n    pr1.xz = rX(pr1.xz, -0.25);\n    vec2 arm = vec2(sdEllipsoid(pr1,vec3(.15,.05,.055))*.5, 10.0);\n    add(body, arm);\n    \n    pr1 = pos;\n    pr1 = tX(pr1, vec3(0,0.06,.17));\n    vec2 head = vec2(sdSphere(pr1, .11)*.5, 10.0);\n    add(body,head);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n  \tpr1 = tX(pr1, vec3(.1,0,-0.15));\n    pr1.xz = rX(pr1.xz, 0.4);\n    vec2 leg = vec2(sdEllipsoid(pr1,vec3(.15,.05,.065))*.5, 10.0);\n    add(body, leg);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n  \tpr1 = tX(pr1, vec3(.05,0.15,0.2));\n    pr1.xy = rX(pr1.xy, 0.6);\n    pr1.xz = rX(pr1.xz, 0.15);\n    vec2 ears = vec2(sdEllipsoid(pr1,vec3(.15,.025,.025))*.5, 11.0);\n    add(body, ears);\n    \n    pr1 = pos;\n    pr1 = tX(pr1, vec3(.0,0.18,-0.175));\n    pr1.xz = rX(pr1.xz, 0.5);\n    pr1.xy = rX(pr1.xy, 0.15);\n    float tail = sdHexPrism(pr1, vec2(.1,.015));\n    float tailRm = sdHexPrism(tX(pr1, vec3(.1,0.,-0.)), vec2(.11,.03));\n    diff(tail, tailRm);\n    vec2 tailPiece = vec2(tail*.5, 10.);\n    add(body,tailPiece);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n    pr1.z = abs(pr1.z);\n    pr1.xy = rX(pr1.xy, 0.075+.02*abs(cos(iTime*.5)));\n    pr1.yz = rX(pr1.yz, -0.1+.02*abs(sin(iTime*.3)));\n    pr1 = tX(pr1, vec3(0,0.3,0.0));\n    vec2 string = vec2(sdCappedCylinder(pr1,vec2(0.005, 0.2))*.5, 6.);    \n    add(body,string);\n    \n    pr1 = tX(pr1, vec3(0,0.1,0.));\n    vec2 exit = vec2(sdCone(pr1, vec2(0.5, 0.15), 0.1)*.5, 12.);\n    add(body,exit);\n    \n    vec2 balloom = vec2(sdRoundCone(pr1, 0.05,0.095, 0.05)*.5, 12.);\n    add(body,balloom);\n    \n\treturn body; \n}\n\n// Thank you @blackle for the balloon seed!!\nfloat hotair(vec3 p) {\n  p.z -= .4;\n  float ht = length(p)-.8;\n  float dimpl = linedist(p, vec3(0,0,0), vec3(0,0,-0.95))-.18;\n  float hollow = linedist(p, vec3(0), vec3(0,0,-1.2))-.18;\n  p.xy = abs(p.xy);\n  float lines = linedist(p, vec3(0.1,0.1,-.5), vec3(.1,.1,-1.3))-.01;\n  return -smin(-smin(ht, dimpl, 0.3),hollow,.01);\n}\n\nvec2 balloon(vec3 pos) {\n    float offsetTwist = 3.1459*2.;\n    \n    pos.xy = rX(pos.xy, -.2);\n    vec3 pA = tX(pos, vec3(0,0.02,.5));\n    vec2 ring1 = vec2(sdTorus(erot(pA,vec3(1,0,0),1.), vec2(1.2,0.05)), 2.0);\n    \n    vec3 pB = tX(pos, vec3(0,-0.01,.4));\n    vec2 ring2 = vec2(sdTorus(erot(pB,vec3(1,0,0),-1.65), vec2(1.1,0.05)), 2.0);\n    pos.xy = rX(pos.xy, .2);\n    pos.xy = rX(pos.xy, offsetTwist);\n    vec3 pC = tX(pos, vec3(0,-0.0,.4));\n    vec2 ropeTop1 = vec2(sdTorus(erot(pC,vec3(0,0,1),-0.), vec2(0.825,0.03)), 2.0);\n    vec2 ropeSlice = vec2(sdPlane(tX(pos,vec3(0,0.,-0.10)), normalize(vec4(0,0,1,0))), 4.0);\n    diff(ropeTop1, ropeSlice);\n    \n    vec3 pD = tX(pos, vec3(0,-0.0,.4));\n    vec2 ropeTop2 = vec2(sdTorus(erot(pD,vec3(0,0,1),1.5708), vec2(0.825,0.03)), 2.0);\n    ropeSlice = vec2(sdPlane(tX(pos,vec3(0,0.,-0.10)), normalize(vec4(0,0,1,0))), 4.0);\n    diff(ropeTop2, ropeSlice);\n    \n    //vec2 hA = vec2(99999.0, 2.0);\n    vec2 hA = vec2(hotair(pos), 3.0);\n    \n    vec3 pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.4,-0.9,-0.));\n    pr1.xy = rX(pr1.xy, 0.1);\n    vec2 rope = vec2(sdCappedCylinder(pr1, vec2(0.03,0.9)), 2.0);\n    add(hA, rope);\n   \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1.xz = rX(pr1.xz,-0.5);\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.4,-0.9,-0.));\n    pr1.xy = rX(pr1.xy, 0.1);\n    rope = vec2(sdCappedCylinder(pr1, vec2(0.03,0.9)), 2.0);\n    add(hA, rope);\n\n    add(hA, ring1);\n    add(hA, ring2);\n    \n    add(hA, ropeTop1);\n    add(hA, ropeTop2);\n    \n    // reset\n    pos.xy = rX(pos.xy, -offsetTwist);\n    \n \tpr1 = pos;\t\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1 = tX(pr1, vec3(0.0,-1.75,-.1));\n    vec2 bigSail = vec2(onion(sdEllipsoid(pr1, vec3(0.25,0.5,0.6)), 0.015), 4.0);\n\tvec2 sliced = vec2(sdPlane(tX(pos,vec3(0,0.,-1.4)), normalize(vec4(0,-1,0.2,0))), 2.0);\n    diff(bigSail, sliced);\n    sliced = vec2(sdPlane(tX(pos,vec3(0,-0.1,-1.8)), normalize(vec4(0,.2,1,0))), 2.0);\n    diff(bigSail, sliced);\n    add(hA, bigSail);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\t\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1 = tX(pr1, vec3(0.2,-1.7,-0.3));\n    vec2 smallSail = vec2(onion(sdEllipsoid(pr1, vec3(0.15,0.3,0.3)), 0.015), 4.0);\n\tsliced = vec2(sdPlane(tX(pr1,vec3(0,0.,-0.0)), normalize(vec4(0,1,0.1,0))), 2.0);\n    diff(smallSail, sliced);\n    sliced = vec2(sdPlane(pr1, normalize(vec4(0,0.1,1,0))), 2.0);\n    diff(smallSail, sliced);\n    add(hA, smallSail);\n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1 = tX(pr1, vec3(0.0,-2.,-0.25));\n    vec2 backThing = vec2(sdRoundCone(pr1, 0.125, 0.275, 0.2), 2.0);\n    sliced = vec2(sdPlane(tX(pr1,vec3(0,0.2,-0.0)), normalize(vec4(0,-1,-.2,0))), 2.0);\n    diff(backThing, sliced);\n    sliced = vec2(sdPlane(pr1, normalize(vec4(0,0,-1,0))), 2.0);\n    diff(backThing, sliced);\n    add(hA, backThing);\n    \n    pr1 = pos;\n    pr1 = tX(pr1, vec3(0.0,-0.2,-1.9));\n    backThing = vec2(sdRoundCone(pr1, 0.25, 0.325, .2), 2.0);\n    sliced = vec2(sdPlane(tX(pr1,vec3(0,0.2,-0.0)), normalize(vec4(0,-1,-.2,0))), 2.0);\n    sliced = vec2(sdPlane(tX(pr1,vec3(0,0.,0.)), normalize(vec4(0,0,-1,0))), 2.0);\n    diff(backThing, sliced);\n    add(hA, backThing);\n    \n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,0.075);\n    pr1 = tX(pr1, vec3(0.0,-0.2,-2.));\n    backThing = vec2(sdRoundCone(pr1, 0.015, 0.045, 0.25), 2.0);\n    add(hA, backThing);\n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.4);\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.1,-1.75,-0.7));\n    pr1.xy = rX(pr1.xy, 0.1);\n    vec2 pillar = vec2(sdCappedCylinder(pr1, vec2(0.04,0.2)), 2.0);\n    add(hA, pillar);\n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.6);\n    pr1 = tX(pr1, vec3(0.,-1.7,0.8));\n\n    pillar = vec2(sdCappedCylinder(pr1, vec2(0.04,0.2)), 2.0);\n    add(hA, pillar);\n    \n    return hA;\n}\n\n// Thank you @evvvvil for the cloudy day!!\nfloat t,tt,b,de,cr=1.;vec3 np,bp,cp,po;vec4 cc,su=vec4(0);\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec2 fb(vec3 p)\n{\n  vec2 h,g=vec2(bo(abs(p)-vec3(4.3,0,0),vec3(3.5,0.4,0.4)),3);\n  h=vec2(bo(abs(p)-vec3(4.,0,0),vec3(3.,0.2,0.6)),5);\n  h.x=min(bo(abs(p)-vec3(0,0,1.),vec3(30,0.2,0.2)),h.x);\n  h.x=min(bo(p,vec3(30,0.2,0.2)),h.x);\n  h.x=min(bo(abs(p)-vec3(6,0,0),vec3(0.2,100.,0.2)),h.x);\n  g=(g.x<h.x)?g:h;\n  g.x*=0.7;\n  return g;\n}\n\nfloat noise(vec3 p){\n  vec3 ip=floor(p),s=vec3(7,157,113);\n  p-=ip; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\n\nfloat c_noise(vec3 p)\n{\n    float f = 0.0;\n    p = p + vec3(0.0,1.0,0.0)*tt*0.3;    \n    f += 0.5*noise(p);\n    p=2.1*p;\n    f+=0.25*noise(p+1.);\n    p=2.2*p;\n    f += 0.125*noise(p+2.); \n    p=2.3*p;\n    f+=0.0625*noise(p);\n    return f;\n}\n\nvec2 scene(vec3 point) {\n    vec2 base;\n    \n    vec3 pikePoint = tX(point, vec3(-1.+.25*cos(iTime*.7),0.75*sin(iTime*.2),.5*sin(iTime*.5)));\n    pikePoint.yz = rX(pikePoint.yz, 0. + .1 *cos(iTime*.2));\n    pikePoint.xy = rX(pikePoint.xy, 0. + .1 *cos(iTime*.3));\n    vec2 pika = balloonPika(pikePoint/.5);\n    \n    vec3 witchPoint = tX(point, vec3(1.+.25*sin(iTime*.5),.5*cos(iTime*.5),.5*sin(iTime*.5)));\n    witchPoint.yz = rX(witchPoint.yz, 0. + .1 *sin(iTime*.5));\n    base = witch(witchPoint/.5);    \n    \n    point = tX(point, vec3(0,1.5+0.1*cos(iTime),0));\n    point.yz = rX(point.yz, 0.5);\n    point.xz = rX(point.xz, 0.025*cos(iTime));\n    vec2 goose = balloon(point);\n    \n    add(base, goose);\n    add(base, pika);\n    return base;\n}\n\nvec3 GetNormal(vec3 hitPoint) {\n    vec3 e=vec3(1e-2,0,0);\n    float d = scene(hitPoint).x;\n    return normalize(vec3(scene(hitPoint + e.xyy).x - d,\n                          scene(hitPoint + e.yxy).x - d,\n                          scene(hitPoint + e.yyx).x - d));\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; ++i)\n    {\n        float h = scene(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n    \n}\n\nvec3 GetColorFromSDF(vec2 distAndMaterial, vec3 hitPoint) {\n    vec3 hitNormal = GetNormal(hitPoint);\n    float mat = 0.0;\n    mat = distAndMaterial.y;\n    \n    vec3 lightPos = vec3(25,3,-5);\n    float light = dot(hitNormal, normalize(lightPos))*.5+.5;\n    \n    vec3 baseColor = vec3(0,0,0);\n    vec3 color = baseColor;\n    if (mat == 3.0) {\n        if (light*2. > 1.8) {\n        \tbaseColor = vec3(120./255.,120./255.,90./255.)*light*2.;\n        }\n    }else if (mat == 4.0) {\n       \tbaseColor = vec3(120./255.,120./255.,90./255.)*light*1.25;\n    } else if (mat == 8.0) {\n        baseColor = vec3(100./255.,73./255.,23./255.)*light;\n    } else if (mat == 10.0) {\n        baseColor = vec3(100./255.,64./255.,0./255.)*light;\n    } else if (mat == 11.0) {\n       \tbaseColor = vec3(90./255.,54./255.,0./255.)*light;\n    } else if (mat == 12.0) {\n       \tbaseColor = vec3(90./255.,0./255.,0./255.)*light;\n    }\n    \n    color = baseColor;\n    \n    return color;\n}\n\nvec3 GetColorFromBackground(vec2 uv) {\n    return vec3(0,1,0);\n}\n\nvec2 Trace(vec2 uv, vec3 cam, vec3 dir) {\n    float h =  MIN_HIT_DIST * 2.0;\n    float t = 0.0;\n    float finalDist = -1.0;\n    float id = -1.0;\n    \n    for(int i = 0; i < MAX_NUM_STEPS; ++i)\n    {\n        if(h < MIN_HIT_DIST || t > MAX_TRACE_DIST) break;\n        \n        vec2 distToClosest = scene(cam + dir * t);\n        h = distToClosest.x;\n        id = distToClosest.y;\n        t += h;\n    }\n    \n    if(t < MAX_TRACE_DIST) finalDist = t;\n    if(t > MAX_TRACE_DIST) id = -1.0;\n    return vec2(finalDist, id);\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv)\n{\n    float ssDistToCenter = length(uv);\n    vec3 bgColor1 = vec3(0.6, 0.2, 0.9);\n    vec3 bgColor2 = vec3(0.0, 0.2, 0.8);\n    vec3 surfaceColor = vec3(0.7, 0.9, .7) + rd.y * 0.8;\n    \n    vec2 results = Trace(uv, ro, rd);\n    float t = results.x;\n    float id = results.y;\n    \n    if(t > -0.5)\n    {\n        vec3 lightPos = vec3(0.0, 2.0, 0.0);\n        vec3 pos = ro + rd * t;\n        \n        vec3 n = GetNormal(pos);\n        vec3 diffColor = GetColorFromSDF(results, pos);\n\n        vec3 l = normalize(lightPos - pos);\n        float diffStrength = max(dot(n, l), 0.4);\n        float ambientStrength = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n        vec3 ambientColor = vec3(0.50,0.50,0.50);\n        \n        \n        ambientColor *= ambientStrength * 0.3;\n        \n        surfaceColor = diffStrength * diffColor + ambientColor;\n        surfaceColor /= 0.75;\n    }\n    \n    return surfaceColor;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cam = vec3(0,0.85,-4.5);\n    vec3 dir = normalize(vec3(uv,1));\n    mat3 rot = rotationXY(vec2(0.0,0.42-iTime*.5));\n    \n    if (iMouse.z > 0.0) {\n        rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n    }\n    \n    dir = rot * dir;\n    cam = rot * cam;\n    \n    vec3 color = vec3(0);\n    \n    vec2 results = Trace(uv, cam, dir);\n    float t = results.x;\n    float id = results.y;\n    \n    if(t > -0.5)\n    {\n        vec3 pos = cam + dir * t;\n        color = GetColorFromSDF(results, pos);\n    }\n    \n    color = render(cam, dir, uv);\n    \n    for (int i=0;i<60;i++) {\n    \tcp=cam+dir*(cr+=(0.3-length(cp-cam)*0.01));\n        cp.xz*=r2(sin(cp.y*0.1+iTime)*.5);\n        if (su.a>0.99||cr<=t) break;\n        de=clamp(-1.5+2.8*c_noise(cp*.5),0.,1.);\n        cc=vec4(mix(vec3(1),color,de*.9)*de,de);\n        su+=cc*(1.-su.a);\n    } \n    \n    su=clamp(su,0.,1.);\n   \tfragColor=vec4(pow(mix(su.xyz,color,(1.-su.r)*smoothstep(-1.,1.,length(cp-po))),vec3(.45)),1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float MAX_TRACE_DIST = 20.0;\nconst float MIN_HIT_DIST = 0.001;\nconst int MAX_NUM_STEPS = 100;\nconst float PI = acos(-1.);\n\nvec3 tX(vec3 p, vec3 d) {\n    return p - d;\n}\n\nmat3 rotationXY( vec2 angle ) {\n    vec2 c = cos( angle );\n    vec2 s = sin( angle );\n    \n    return mat3(\n                c.y      ,  0.0, -s.y,\n                s.y * s.x,  c.x,  c.y * s.x,\n                s.y * c.x, -s.x,  c.y * c.x\n                );\n}\n\nvec2 rX(const in vec2 p, const in float ang) {\n    float newAng = ang * PI;\n    float c = cos(newAng), s = sin(newAng);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nvoid diff(inout vec2 d1, in vec2 d2) {\n    if (-d2.x > d1.x) {\n        d1.x = -d2.x;\n        d1.y = d2.y;\n    }\n}\n\nvoid diff(inout float d1, in float d2) {\n    if (-d2 > d1) {\n        d1 = -d2;\n    }\n}\n\nvoid add(inout vec2 d1, in vec2 d2) {\n    if (d2.x < d1.x) d1 = d2;\n}\n\nvoid intersect(inout vec2 d1, in vec2 d2) {\n    if (d1.x < d2.x) d1 = d2;\n}\n\nfloat opSmoothUnion(inout float d1, inout float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdGround(vec3 p) {\n    return p.y+1.5;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n    \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)-.1));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(0.,k-abs(b-a))/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}