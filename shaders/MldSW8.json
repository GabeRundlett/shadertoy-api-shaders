{
    "Shader": {
        "info": {
            "date": "1479727498",
            "description": "A hollow glass box with a mirrored ball inside it, mirrored about multiple axes using a smoother equivalent to abs().",
            "flags": 0,
            "hasliked": 0,
            "id": "MldSW8",
            "likes": 33,
            "name": "Daily Shade day 14-18: Metaglass",
            "published": 3,
            "tags": [
                "raymarch",
                "glass",
                "kaleidoscope",
                "mirror",
                "daily"
            ],
            "usePreview": 0,
            "username": "psonice",
            "viewed": 1459
        },
        "renderpass": [
            {
                "code": "/* \nDay 14: Postponed: bugs.\nDay 15: Postponed: out all day, knackered.\nDay 16: Postponed: bugs again. Not going well this, is it?\nDay 17: Bugs fixed, just needs a few more minutes… crap, time to catch a flight!\nDay 18: Such a long flight. Let’s make up for the last few days :)\n*/\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 120\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n\n#define kFLOORCOLOUR vec4(0.7, 0.65, 0.6, 1.0)\n#define kGLASSCOLOUR vec4(1.0, 0.5, 0.1, 1.0)\n#define kMIRRORCOLOUR vec4(1.0, 0.3, 0.3, 1.0)\n    \n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 texrand(in vec2 n) {\n    return texture(iChannel2, n).xyz;\n}\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Union of two unsigned distances\nfloat unionOpU(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Intersection of two unsigned distances\nfloat intersectOpU(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n// Difference of two unsigned distances\nfloat differenceOpU(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    \n    // Mess with the ray\n    vec2 offset = vec2(\n        sin(iTime * 0.34), \n        cos(iTime * 0.55)\n    );\n    float r = 2.0;\n    \n    ray.origin.xz += offset;\n    R(ray.origin.xz, iTime * 0.34);\n    ray.origin = smoothBlend(ray.origin, offset.xyx, r);\n    ray.origin.zy += offset;\n    R(ray.origin.zy, iTime * 0.55);\n    ray.origin = smoothBlend(ray.origin, offset.yxy, r);\n    ray.origin.yx += offset;\n    R(ray.origin.yx, iTime * 0.55);\n    ray.origin = smoothBlend(ray.origin, offset.yyx, r);\n\n    ray.origin.xz -= offset;\n    \n    Box box = Box(vec3(0), vec3(5), 0.4);\n    Box innerBox = Box(vec3(0), vec3(4), 0.4);\n    \n    // get the distance \n    float distToBox = differenceOpU(\n        boxDist(ray, box),\n        boxDist(ray, innerBox)\n        );\n    \n    Sphere ball = Sphere(vec3(0), 2.0);\n    \n    float distToBall = sphereDist(ray, ball);\n    \n    //Find the neares of the floor and box0\n    result.d = unionOp(distToBox, distToBall);\n    //result.d = distToHouse;\n    result.material = result.d == distToBox ? kGLASSMATERIAL : kMIRRORMATERIAL;\n    \n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d - baseDist\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n \tray.origin += n * d;\n \td = sceneDist(ray).d;\n \tn = normal(ray);\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\nfloat occlusion(in Ray ray, in vec3 n) {\n    float o = 0.0;\n    ray.dir = n;\n    float x = 0.1;\n    for (int i=0; i<5; i++) {\n    \tray.origin += x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0);\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o * 0.5;;\n}\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec4 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec4 impact = vec4(1.0); // This decreases each time the ray passes through glass, darkening colours\n\n#ifdef DEBUG   \nvec4 debugColour = vec4(1, 0, 0, 1);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = inside ? abs(result.d) : result.d;\n            //result.material == kGLASSMATERIAL ? abs(result.d) : result.d;\n        ray.origin += ray.dir * stepDistance * 0.5;\n        if (length(ray.origin) > 30.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n//debugColour = vec4(-n*1.0, 1);\n//debugStep++;\n//if (debugStep == 3) break;\n          //  break;\n//if (mod(ray.origin.y, 1.0) > 0.5) break;\n//debugValue += 0.25;\n#endif\n            \n            if ( result.material == kFLOORMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(ray.origin.xz * 0.4);\n                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);\n                \n                // Colour is just grey with crappy fake lighting...\n                colour += mix(\n                    kFLOORCOLOUR, \n                    vec4(0,0,0,1), \n                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)\n                ) * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 2.0;\n                \n                // Mix in the mirror colour\n                impact *= kMIRRORCOLOUR;\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  clamp(distance(glassStartPos, ray.origin) / 1.0, 0., 1.);\n                    \n                    // Get a random colour\n                \timpact *= mix(vec4(1), kGLASSCOLOUR, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 2.0);\n    \t\t\t\tcolour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n    colour += texture(iChannel0, ray.dir) * impact;\n    \n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\ndebugColour.rgb = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    float r = 10.0;\n    return vec3(sin(time) * r, sin(time*2.) * 3.0, cos(time) + r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime / 4.0;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = vec3(0);\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec4 col = vec4(0.0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}