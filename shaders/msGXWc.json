{
    "Shader": {
        "info": {
            "date": "1720718331",
            "description": "Uses a bunch of math to ray trace a triangle. If it hits a triangle, it finds the corresponding texture coordinate and samples the texture.",
            "flags": 0,
            "hasliked": 0,
            "id": "msGXWc",
            "likes": 2,
            "name": "Ray traced icosahedron",
            "published": 3,
            "tags": [
                "raytracing",
                "icosahedron"
            ],
            "usePreview": 0,
            "username": "sbg97",
            "viewed": 108
        },
        "renderpass": [
            {
                "code": "// Icosahedron points\nvec3 p1 = vec3(1.,0.,0.);\nvec3 p2 = vec3(-1.,0.,0.);\nvec3 p3 = vec3(0.4472,0.8944,0.);\nvec3 p4 = vec3(-0.4472,-0.8944,0.);\nvec3 p5 = vec3(0.4472,0.2764,0.8507);\nvec3 p6 = vec3(0.4472,0.2764,-0.8507);\nvec3 p7 = vec3(-0.4472,-0.2764,0.8507);\nvec3 p8 = vec3(-0.4472,-0.2764,-0.8507);\nvec3 p9 = vec3(0.4472,-0.7236,0.5257);\nvec3 p10 = vec3(0.4472,-0.7236,-0.5257);\nvec3 p11 = vec3(-0.4472,0.7236,0.5257);\nvec3 p12 = vec3(-0.4472,0.7236,-0.5257);\n\nvec3 nohit = vec3(0.,0.,0.);\n\n// Returns 0,0,0 if no intersection, otherwise returns normal direction\nvec3 intersectsSphere( in vec3 sph_pos, in float sph_siz, in vec3 ray_pos, in vec3 ray_dir)\n{\n    // Adjust ray_pos so sph_pos is effectively 0 0 0\n    ray_pos -= sph_pos;\n    //float a = dot(ray_dir, ray_dir);\n    float b = 2.*dot(ray_pos, ray_dir);\n    float c = dot(ray_pos, ray_pos)-sph_siz*sph_siz;\n    float D=b*b-4./**a*/*c;\n    if(D<=0.){\n        return vec3(0.,0.,0.);\n    }\n    float t = (-b-sqrt(D))/(2./**a*/);\n    if(t<=0.){\n        return vec3(0.,0.,0.);\n    }\n    vec3 hit_pos = t*ray_dir + ray_pos;\n    vec3 normal_dir = vec3(2.*hit_pos.x, 2.*hit_pos.y, 2.*hit_pos.z);\n    return normalize(normal_dir);\n}\n\n// Returns 0,0,0 if no intersection, otherwise returns normal direction\nvec3 intersectsTriangle(in vec3 p0, in vec3 p1, in vec3 p2, in vec3 ray_pos, in vec3 ray_dir)\n{\n    // calculate normal vector of the plane of the triangle\n    vec3 N = cross(p1-p0,p2-p0);\n    \n    // backface culling\n    if(dot(N,ray_dir)>=0.){\n        return nohit;\n    }\n    \n    vec4 L = vec4(N, -dot(N,p0));\n    \n    // see when the ray would intersect this plane\n    float t = -dot(L,vec4(ray_pos, 1.))/dot(L,vec4(ray_dir, 0.));\n    if(t<=0.){\n        return nohit;\n    }\n    \n    // intersection location\n    vec3 p = t*ray_dir + ray_pos;\n    vec3 R=p-p0;\n    vec3 Q1=p1-p0;\n    vec3 Q2=p2-p0;\n    \n    float Q1Q1 = dot(Q1,Q1);\n    float Q1Q2 = dot(Q1,Q2);\n    float Q2Q2 = dot(Q2,Q2);\n    float RQ1 = dot(R,Q1);\n    float RQ2 = dot(R,Q2);\n    \n    vec2 w1w2 = mat2(Q2Q2, -Q1Q2, -Q1Q2, Q1Q1)*vec2(RQ1,RQ2)/(Q1Q1*Q2Q2-Q1Q2*Q1Q2);\n    \n    float w1 = w1w2.x;\n    float w2 = w1w2.y;\n    float w0 = 1.-w1-w2;\n    \n    if(w1>0. && w2>0. && w0>0.){\n        return vec3(w0, w1, w2);\n    }\n    return nohit;\n    \n}\n\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 colorTheWorld(in vec3 start, in vec3 dir)\n{\n    if(intersectsSphere(vec3(0,0,0), 1., start, dir).x==0.){\n        return vec3(1.,0.,0.);\n    }\n    //return intersectsSphere(vec3(0,0,0), 1., start, dir);\n    vec2 uv0 = vec2(0.,0.);\n    vec2 uv1 = vec2(1.,0.);\n    vec2 uv2 = vec2(0.,1.);\n    \n    vec3 weights;\n    if((weights=intersectsTriangle(p7, p11, p2, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p7, p2, p4, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p7, p4, p9, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p7, p9, p5, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p7, p5, p11, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p12, p3, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p3, p1, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p1, p10, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p10, p8, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p6, p8, p12, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p11, p12, p2, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p11, p3, p12, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p5, p3, p11, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p1, p3, p5, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p9, p1, p5, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p9, p10, p1, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p9, p4, p10, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p10, p4, p8, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p4, p2, p8, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else if((weights=intersectsTriangle(p2, p12, p8, start, dir))!=nohit){\n        return texture(iChannel0, weights.x*uv0+weights.y*uv1+weights.z*uv2).xyz;\n    }\n    else{\n        return vec3(1.,0.,0.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xyPositionOfPixelInWindow = \n        ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    \n    \n    vec3 eyePosition = vec3( 3.*sin(iTime), 0., 3.*cos(iTime));\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n    mat3 eyeTransformationMatrix = \n        calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. );\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( xyPositionOfPixelInWindow , 2. ) );\n\tvec3 color = colorTheWorld( eyePosition , rayComingOutOfEyeDirection );\n\tfragColor = vec4(color,1.0);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}