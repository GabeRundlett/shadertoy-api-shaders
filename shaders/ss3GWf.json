{
    "Shader": {
        "info": {
            "date": "1630728942",
            "description": "Mouse Enabled\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ss3GWf",
            "likes": 4,
            "name": "Ray-Circle-Relfection 03-sept-21",
            "published": 3,
            "tags": [
                "ad",
                "autodiff",
                "autodiff",
                "automaticdifferentiation",
                "dualnumbers",
                "autodifferentiation",
                "dn"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 250
        },
        "renderpass": [
            {
                "code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 03-09-2021                                  //\n// Status: On Going                                        //\n// Topic: Ray-Circle Reflections                           //\n// Sources:                                                //\n// https://rootllama.wordpress.com/2014/06/20/ray-         //\n//                  line-segment-intersection-test-in-2d/  //\n// Listening to: UFO361 - so wie wir                       //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n/*\n\nI don't follow the proper ray-segment intersection actually\nthe goal of this is to become more familiar with ray tracing\narchitecture so I've just taken an intersection model\nI had laying around and added a proper(and basic) ray-trace \narchitecture to it. \n\nWhat I really want eventually is:\nhttps://www.shadertoy.com/view/WsBGRz\nor\nhttps://www.shadertoy.com/view/ltXBz7\n\nThe main hiccups here ended up being such small things\nlike the normal being flipped the wrong way\nand well I was drawing some things I didn't need to be \nit's when it came to adding more bounces that things\nfell apart and I was forced to question my assumptions\nabout what I had written.\n\n\nArchitecturial features/functions:\n\n- time and animation \n- draw ray\n- draw intersection point\n- scene intersections\n- bounces\n- ray trace\n- segment structure\n\nAdjustables in Common Tab:\n\n- number of rays\n- number of bounces (good with more objects)\n- number of segments (if you wan to add more segments you need\nto increase this before adding them to segmentList)\n\nPossible expansions:\n\n- materials(refractions/diffuse/lambert/roughness)\n- more objects (triangle, AABB, circle, ellipse)\n- movement (I'd love to make the segments rotate for starters)\n\nI definitly feel like programming the architecture\nis a different mindset from doing the math (intersections \nfor example). I might want to work on only one of these\naspects in any given coding session. Not sure.\n\n*/\n//objects //global hit list, just two points for one line\n\nstruct Segment{\n    vec2 A;\n    vec2 B;\n    int id;\n};\n\nstruct Circle{\n    vec2 pos;\n    float r;\n    vec3 col;\n    int id;\n};\n\nSegment segmentList[] = Segment[Seg_N](\n    Segment(vec2(3., -3.),vec2(4., 3.), 0),\n    Segment(vec2(-5., -3.),vec2(-3., 3.), 1)\n);\n\nCircle CircleList[] = Circle[Circle_N](\n    Circle(vec2(0.,0.), 4., vec3(1.), 0),\n    Circle(vec2(-2.,-2.), 1., vec3(1.,.3,.3), 1)\n);\n\nvec3 background_grid(vec2 st, vec2 uv){\n    vec3 col = vec3(0.1);;\n     col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    return col;\n\n}\n\nvec2 time_and_animation(){\n\n    float speed = 1.;\n    float time = 12.;//clamp(abs(fract(iTime*speed-0.5)-0.5)*2.,0.1,1.)*12.;\n\n    return vec2(time,0.);\n    }\n    \nvec3 draw_ray(vec2 A1, vec2 B1, vec3 col, vec2 uv){\n\n    //line 1\n    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n    col = mix(col, vec3(1.,.2,.5), f);//0.5\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);\n    col = mix(col, line1Col, f);\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);\n    col = mix(col, line1Col, f);\n    return col;\n}\n\nvec3 draw_iPoint(vec3 col, vec2 pointOnLine, vec2 uv){\n\n    float f = 1.-smoothstep(0.02,0.04,abs(length(uv-pointOnLine)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-pointOnLine)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    return col;\n}\n\nfloat iSphere(vec2 ro, vec2 rd, vec2 cPos, float r){\n\n    vec2 O_C = ro-cPos;\n    \n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,O_C);\n    float c = dot(O_C,O_C) - r*r;\n    \n    float disc = b*b-4.*a*c;\n    \n    if(disc < 0.) return -1.;\n    \n    //I finally forgot brackets around the numerator\n    //it finally happened\n    //it's the things that I did yesterday that are hurting me today\n\n    float t1 = (-b - sqrt(disc))/(2.*a); \n    float t2 = (-b + sqrt(disc))/(2.*a);\n    \n    if(t1 >= 0.){return t1;}\n    else if(t2 >= 0.){return t2;}\n    else return -1.;\n}\n\nvec2 circle_intersections(vec2 ro, vec2 rd){\n\n    float min_t = 100.;\n    float t;\n    float idf = -1.;\n    \n    for(int i = 0; i < 1; i++){\n        \n        t = iSphere(ro, rd, CircleList[i].pos, CircleList[i].r);\n        \n        if(t < min_t){\n        \n            min_t = t;\n            idf = float(i);\n            \n        } \n    }\n    \n    return vec2(t, idf);\n}\n\n\nvec3 bounces(vec2 bounce_ro, vec2 rd, float time, vec2 uv, vec3 col){\n\n    vec3 ray_color = line1Col;\n    for(float j = 0.; j < float(BOUNCE_N); j++){\n        \n            //time instead of t_and_a.y!\n            \n            vec2 A1 = bounce_ro;\n            vec2 B1 = bounce_ro + rd*time;\n            \n            //check all objects (just one line here)\n            int id = -1;\n            \n            vec2 ct_and_id = circle_intersections(bounce_ro,rd);\n            float ct = ct_and_id.x;\n            id = int(ct_and_id.y);\n            \n\n            \n            if(ct > 0.){\n\n                \n                //new ro is hit point\n                bounce_ro = bounce_ro + rd*ct;//s_t_iPoint.zw;\n                \n                //normal is orthogonal to the line facing left\n                vec2 n = normalize(bounce_ro - CircleList[id].pos);//normalize(vec2( -(segB.y-segA.y), segB.x-segA.x ));\n                \n                //a good couple of hours spent here\n                //until I decided to just show the normals \n                //which I should have done from the start\n                if(dot(n, rd) <= 0.){\n                    n = -n;\n                }\n                \n                n = -n;\n                //reflected rd is...\n                rd = reflect(rd,n);\n                \n                //use the same \"time\" variable to go back along the reflected ray\n                //vec2 reflected_a = bounce_ro;\n                //vec2 reflected_b = bounce_ro + rd*time;\n                \n                //draw the ray to the hit point\n                //col = draw_ray(A1, bounce_ro, col, uv);\n                float f = 1.0-smoothstep(0.02,0.06,\n                abs(distToLine(A1, bounce_ro, uv)));\n                \n                col = mix(col, ray_color, f);\n                \n                //draw normal\n                f = 1.0-smoothstep(0.02,0.06,\n                abs(distToLine(bounce_ro,bounce_ro + n*0.5, uv)));\n                \n                col = mix(col, vec3(0.,1.,0.5), f);\n                \n                col = draw_iPoint(col, bounce_ro, uv);\n   \n                //this is so important!!!\n                bounce_ro += n*0.01;\n                ray_color = 0.5+0.5*cos(vec3(1.,2.,4.)/1. + j*300.);\n            }\n            \n            else{\n            //draw the ray \n            //col = draw_ray(A1, B1, col, uv);\n            \n            float f = 1.0-smoothstep(0.02, 0.06,\n            abs(distToLine(A1, B1, uv)));\n            col = mix(col, ray_color, f);\n            \n            break;\n            }\n            \n    }\n    \n    return col;\n}\nvec3 ray_trace(vec2 uv, vec2 ro, vec3 col){\n    \n    vec2 t_and_a = time_and_animation();\n    //rays\n    for(float i = 0.; i<fov; i += fov/float(RAY_N)){\n    \n        vec2 rd = vec2(1.,0.)*rot(i-pi*sin(iTime/6.));\n        vec2 bounce_ro = ro;\n        //bounces\n        col = bounces(bounce_ro, rd, t_and_a.x, uv, col);\n        }\n        \n    \n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  BACKGROUND GRID DESIGN             //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = background_grid(st, uv);\n\n   float f;\n   \n   for(int i = 0; i < 1; i++){\n       f = clamp(1.0-abs(length(uv - CircleList[i].pos)-CircleList[i].r),0.,1.);\n       f = smoothstep(0.9,0.95,f);\n       col = mix(col, vec3(1.), f);\n   }\n   vec2 ro = vec2(2.);\n       if(iMouse.z > 0.5) ro = vec2((iMouse.xy-iResolution.xy*0.5)/iResolution.y)*8.;\n    \n   col = ray_trace(uv, ro, col);\n\n  \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    //Output to screen\n    fragColor = vec4(col*vig,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi 3.14159265\n#define RAY_N 24\n#define BOUNCE_N  3\n#define line1Col vec3(1.,.2,.5)\n#define line2Col vec3(1.,.3,.3)\n#define Seg_N 2\n#define Circle_N 2\n#define fov pi*0.37\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n}\n\nmat2 rot(float a){\n\n    \n    float si = sin(a);\n    float cs = cos(a);\n    return mat2(cs,-si,si,cs);\n   }   \n    \nmat2 trigless_rot(vec2 v, vec2 vr){\n    float si = length(cross(vec3(v,0.),vec3(vr,0.)));\n    float cs = dot(v,vr);\n    return mat2(cs,-si,si,cs);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}