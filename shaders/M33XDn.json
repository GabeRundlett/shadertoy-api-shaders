{
    "Shader": {
        "info": {
            "date": "1719054095",
            "description": "This is a very configurable, glitchy, old school music visualizer. It has lots of options that behave unpredictably which is good for happy accidents. I made it with ChatGPT, this is not my field of expertise. I made this to make music more entertaining.",
            "flags": 32,
            "hasliked": 0,
            "id": "M33XDn",
            "likes": 1,
            "name": "Shader Remix",
            "published": 3,
            "tags": [
                "sound",
                "audio",
                "psychedelic",
                "visualizer",
                "bars",
                "eq"
            ],
            "usePreview": 0,
            "username": "multiphonic",
            "viewed": 71
        },
        "renderpass": [
            {
                "code": "#define LFO_RATE_MS 22500.0 // LFO Rate in milliseconds\n#define TOP_ZOOM 10.5 // Value corresponding to 10x zoom out\n#define BOTTOM_ZOOM 0.50 // Default to zero for 1x1 zoom, higher values zoom out\n#define ELASTICITY .9 // Soft clipping elasticity control (0 for sine, 1 for square)\n#define WRAP_OR_MIRROR_FLAG -1 // Set to 1 to enable mirroring of the zoomed area, -1 to enable wrapping\n#define DIRECTION_ROTATION 1.0 // Set to -1.0 for full left, 1.0 for full right\n#define ROTATION_LFO_MS 25007.0 // LFO for a full 360-degree rotation in milliseconds\n#define POST_ROTATION_DIRECTION -1.0 // Set to -1.0 for full left, 1.0 for full right post rotation\n#define POST_ROTATION_LFO_MS 20000.0 // LFO for a full 360-degree rotation in milliseconds for post rotation\n\nfloat softClip(float x, float k) {\n    return (1.0 + k) * x / (1.0 + k * abs(x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Calculate the time in seconds\n    float time = iTime;\n\n    // Calculate the LFO based on the specified rate in milliseconds\n    float lfo = 0.5 * (1.0 + sin(2.0 * 3.141592 * (1.0 / (LFO_RATE_MS / 1000.0)) * time));\n\n    // Apply soft clipping to the LFO to simulate the elasticity effect\n    lfo = softClip(2.0 * lfo - 1.0, ELASTICITY) * 0.5 + 0.5;\n\n    // Normalize TOP_ZOOM to correspond to 10x zoom out when it's 250\n    float normalizedTopZoom = TOP_ZOOM / .5; // New normalization factor\n\n    // Adjust zoom factor based on BOTTOM and normalized TOP\n    float bottomZoomFactor = .2 + BOTTOM_ZOOM /.521 ;\n    float topZoomFactor = 1.0 / normalizedTopZoom;\n    float zoomFactor = mix(bottomZoomFactor, topZoomFactor, lfo);\n\n    // Rotate the interior LFO\n    float rotationAngle = DIRECTION_ROTATION * 2.0 * 3.141592 * (time / (ROTATION_LFO_MS / 1000.0));\n    mat2 rotationMatrix = mat2(cos(rotationAngle), -sin(rotationAngle), sin(rotationAngle), cos(rotationAngle));\n    vec2 rotatedUv = (rotationMatrix * (uv - 0.5)) + 0.5;\n\n    // Apply zoom to UV coordinates\n    vec2 zoomedUv = (rotatedUv - 0.5) / zoomFactor + 0.5;\n\n    // Apply wrapping or mirroring to the zoomed UV coordinates based on the flag\n    if (WRAP_OR_MIRROR_FLAG == 1) {\n        zoomedUv = abs(fract(zoomedUv * 0.5) * 2.0 - 1.0);\n    } else {\n        zoomedUv = fract(zoomedUv);\n    }\n\n    // Sample the output from Buffer B\n    vec3 color = texture(iChannel2, zoomedUv).rgb;\n\n    // Apply post-rotation\n    float postRotationAngle = POST_ROTATION_DIRECTION * 2.0 * 3.141592 * (time / (POST_ROTATION_LFO_MS / 1000.0));\n    mat2 postRotationMatrix = mat2(cos(postRotationAngle), -sin(postRotationAngle), sin(postRotationAngle), cos(postRotationAngle));\n    vec2 postRotatedUv = (postRotationMatrix * (zoomedUv - 0.5)) + 0.5;\n\n    // Apply final wrapping or mirroring\n    if (WRAP_OR_MIRROR_FLAG == 1) {\n        postRotatedUv = abs(fract(postRotatedUv * 0.5) * 2.0 - 1.0);\n    } else {\n        postRotatedUv = fract(postRotatedUv);\n    }\n\n    // Sample the final output\n    vec3 postRotatedColor = texture(iChannel2, postRotatedUv).rgb;\n\n    fragColor = vec4(postRotatedColor, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define COLOR1 vec3(1.9, 1.5, 1.25) // Color of the first set of squares\n#define COLOR2 vec3(2.23, 0.2, 0.2) // Color of the second set of squares\n#define GLOW_COLOR vec3(.2, .22, .2) // Color of the glow\n#define GLOW_RADIUS .7 // Radius control for the glow\n#define GLOW_INTENSITY 2.6 // Intensity control for the glow\n#define LFO_PERIOD_MS 18000.0 // LFO period in milliseconds\n#define INVERT_COLOR_FLAG 0 // Set to 1 to invert colors, 0 to keep colors as is\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //***********    Basic setup    **********\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Calculate LFO value for checker size\n    float time = iTime * 1000.0; // Convert time to milliseconds\n    float lfo = 0.5 * (1.0 + sin(2.0 * 3.141592 * time / LFO_PERIOD_MS)); // LFO oscillates between 0 and 1\n    float checkerSize = mix(4.0, 12.0, lfo); // Map LFO value to range 1 to 16\n\n    // Scale UV coordinates to checkerboard size\n    vec2 checkUv = uv * checkerSize;\n    \n    // Calculate checkerboard pattern\n    float checker = mod(floor(checkUv.y) + floor(checkUv.x), 2.0);\n    \n    // Determine the color of the checkerboard cell\n    vec3 baseColor = mix(COLOR1, COLOR2, checker);\n    \n    // Position of fragment relative to center of the checkerboard cell\n    vec2 cellCenter = (floor(checkUv) + 0.5) / checkerSize;\n    vec2 pos = uv - cellCenter;\n    \n    // Adjust y by aspect for uniform transforms\n    pos.y *= iResolution.y / iResolution.x;\n    \n    //**********         Glow        **********\n    \n    // Hyperbolic falloff for the glow\n    float dist = length(pos);\n    float glowDist = GLOW_RADIUS / dist;\n    \n    // Dampen the glow to control the radius\n    glowDist *= 0.1;\n    \n    // Intensity control for the glow\n    glowDist = pow(glowDist, GLOW_INTENSITY);\n    \n    // Color the glow\n    vec3 glowColor = glowDist * GLOW_COLOR;\n    \n    // Combine the base color and the glow\n    vec3 color = baseColor + glowColor;\n    \n    // Tonemapping\n    color = 1.0 - exp(-color);\n\n    // Invert colors if the flag is set\n    if (INVERT_COLOR_FLAG == 1) {\n        color = vec3(1.0) - color;\n    }\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define BARS_COUNT 16\n#define COLOR_POLARITY_FLAG 9\n#define BAR_HEIGHT 0.1\n#define BAR_ASPECT_RATIO 51.4 // Aspect ratio for the bars\n#define BAR_SPACING_PERCENTAGE 0.45\n#define BAR_COLOR vec3(.5,1.1,.0)\n#define BACKGROUND_COLOR vec3(0.15, 0.415, 0.2)\n#define MIRROR_FLAG 1\n#define ORIENTATION_FLAG 1\n#define CENTER_OVERLAP 10.01595 // Nudge control for the interior\n#define BAR_MARGIN .6 // Buffer control for mirroring or wrapping\n#define GRADIENT_START_COLOR vec3(.6, 1.0, 0.0)\n#define GRADIENT_END_COLOR vec3(0.0, .0, 1.0)\n#define GRADIENT_INTENSITY 1.32\n#define GRADIENT_CONTRAST 3.2\n#define MIRROR_Y_BOTTOM_FLAG 0\n#define MIRROR_Y_TOP_FLAG 1\n#define LOUDNESS_EXPONENT 1.7\n#define TRAIL_COUNT 3\n#define TRAIL_SCALE 0.979\n#define TRAIL_DECAY .225\n#define BASS_WARP .9\n#define AUDIO_ELASTICITY 2.2\n#define FLIP_VERTICAL 1\n#define TRAIL_DELAY_MS 00.0 // Delay for trails in milliseconds\n#define RMS_TIME_WINDOW 10.1 // Time window for RMS calculation in milliseconds\n\n// Zoom control\n#define ZOOM_BASE 1.0\n#define BKGD_ELASTICITY 1.8\n#define ZOOM_RANGE 3.2\n#define ZOOM_POLARITY -1 // 1 for zoom in with amplitude, -1 for zoom out with amplitude\n#define ZOOM_WRAP_FLAG 0 // Set to 1 to enable wrapping of the zoomed area\n#define ZOOM_MIRROR_FLAG 1 // Set to 1 to enable mirroring of the zoomed area\n#define CUTOFF_FREQ 150.0 // Low-pass filter cutoff frequency in Hz\n\n// Composite control\n#define DIFFERENCE_COMPOSITE_FLAG 1 // Set to 1 for difference mode for bars\n#define DIFFERENCE_BACKGROUND_COMPOSITE_FLAG 1 // Set to 1 for difference mode for background\n#define BACKGROUND_TRANSPARENCY 0.5 // Transparency level for unzoomed background\n#define BACKGROUND_MOTION_PERCENTAGE 0.5 // Percentage of zoom applied to the stationary background\n\n#define LOWEST_BAR 250.0 // Lowest bar frequency in Hz\n\nfloat previousAmplitude = 0.0;\n\n// Precompute constants\nconst float totalBars = float(BARS_COUNT) * (MIRROR_FLAG == 1 ? 2.0 : 1.0);\nconst float barWidth = 1.0 / (totalBars + (totalBars - 1.0) * BAR_SPACING_PERCENTAGE);\nconst float barSpacing = barWidth * BAR_SPACING_PERCENTAGE;\n\n// Function to get the frequency for a given band index\nfloat getFrequency(int index) {\n    float normIndex = float(index) / float(BARS_COUNT);\n    float warpedIndex = pow(normIndex, mix(1.0, 0.5, BASS_WARP));\n    float maxFreq = 22050.0; // Assuming 22.05 kHz as the highest frequency\n    float minFreq = LOWEST_BAR;\n    float freqRange = maxFreq - minFreq;\n    float frequency = minFreq + warpedIndex * freqRange;\n\n    if (ORIENTATION_FLAG == 1) {\n        frequency = maxFreq - (frequency - minFreq);\n    }\n\n    return frequency;\n}\n\n// Function to get the band value from the texture\nfloat getBand(int index) {\n    float freq = getFrequency(index) / 22050.0; // Normalize to the range 0.0 to 1.0\n    return texture(iChannel0, vec2(freq, 0.0)).r;\n}\n\n// Function to calculate RMS for a given time window in milliseconds\nfloat calculateRMS(float timeWindowMs) {\n    float rms = 0.0;\n    float sum = 0.0;\n    float sampleRate = 44100.0; // Assuming audio sample rate of 44100 Hz\n    int sampleCount = int(timeWindowMs * sampleRate / 1000.0);\n    int sampleStep = max(1, sampleCount / 128); // Reduce the number of samples to 64\n\n    // Sum the squares of the audio texture samples\n    for (int i = 0; i < sampleCount; i += sampleStep) {\n        float sampleIndex = float(i) / sampleRate;\n        float amplitude = texture(iChannel0, vec2(0.5, sampleIndex)).r;\n        sum += amplitude * amplitude;\n    }\n\n    // Calculate the mean of the squares\n    float meanSquare = sum / float(sampleCount / sampleStep);\n\n    // Calculate the RMS value as the square root of the mean square\n    rms = sqrt(meanSquare);\n\n    return rms;\n}\n\n// Function to get gradient color based on height and gradient parameters\nvec4 getGradientColor(float t) {\n    t = pow(clamp(t, 0.0, 1.0), GRADIENT_CONTRAST) * GRADIENT_INTENSITY;\n    vec3 color = mix(GRADIENT_START_COLOR, GRADIENT_END_COLOR, t);\n    return vec4(color, 1.0);\n}\n\n// Function to apply trail effect with perspective scaling, luminosity decay, and delay\nvec4 applyTrailEffect(vec4 color, float trailIndex, float delayTime) {\n    float timeFactor = delayTime * float(trailIndex) / TRAIL_DELAY_MS;\n    float scale = pow(TRAIL_SCALE, trailIndex);\n    float decayFactor = mix(1.0, 0.0, TRAIL_DECAY) + (1.0 - TRAIL_DECAY) * (1.0 - trailIndex / float(TRAIL_COUNT));\n    color.rgb *= decayFactor * scale;\n    color.a *= decayFactor;\n    return mix(color, vec4(0.0), step(timeFactor, mod(iTime, TRAIL_DELAY_MS) / TRAIL_DELAY_MS));\n}\n\n// Function to draw bars\nvoid drawBars(inout vec4 color, vec2 uv, float barWidth, float barSpacing, float scaleX, float rmsAmplitude) {\n    for (int i = 0; i < BARS_COUNT; i++) {\n        float bandValue = pow(getBand(i) * BAR_HEIGHT, LOUDNESS_EXPONENT) * rmsAmplitude;\n\n        for (int t = 0; t < TRAIL_COUNT; t++) {\n            float trailScale = pow(TRAIL_SCALE, float(t));\n            float scaledBandValue = bandValue * trailScale;\n            float barX = (barWidth + barSpacing) * float(i) * trailScale * scaleX + 0.5 * (1.0 - trailScale * scaleX) + (BAR_MARGIN / 1000.0);\n\n            // Draw bars on the left side\n            if (uv.x > barX && uv.x < barX + barWidth * trailScale * scaleX) {\n                float barTop = 0.5 + (scaledBandValue / 2.0 * AUDIO_ELASTICITY) * BAR_ASPECT_RATIO;\n                float barBottom = 0.5 - (scaledBandValue / 2.0 * AUDIO_ELASTICITY) * BAR_ASPECT_RATIO;\n                if (uv.y > barBottom && uv.y < barTop) {\n                    float gradientFactor = (uv.y - barBottom) / (barTop - barBottom);\n                    vec4 barColor = applyTrailEffect(getGradientColor(gradientFactor), float(t), TRAIL_DELAY_MS);\n                    color = mix(color, barColor, barColor.a); // Blend using alpha\n                }\n            }\n\n            // Draw mirrored bars on the right side\n            if (MIRROR_FLAG == 1) {\n                float overlap = (CENTER_OVERLAP / 1000.0);\n                barX = 1.0 - (barWidth + barSpacing) * float(i + 1) * trailScale * scaleX - 0.5 * (1.0 - trailScale * scaleX) + overlap - (BAR_MARGIN / 1000.0);\n                if (uv.x > barX && uv.x < barX + barWidth * trailScale * scaleX) {\n                    float barTop = 0.5 + (scaledBandValue / 2.0 * AUDIO_ELASTICITY) * BAR_ASPECT_RATIO;\n                    float barBottom = 0.5 - (scaledBandValue / 2.0 * AUDIO_ELASTICITY) * BAR_ASPECT_RATIO;\n                    if (uv.y > barBottom && uv.y < barTop) {\n                        float gradientFactor = (uv.y - barBottom) / (barTop - barBottom);\n                        vec4 barColor = applyTrailEffect(getGradientColor(gradientFactor), float(t), TRAIL_DELAY_MS);\n                        color = mix(color, barColor, barColor.a); // Blend using alpha\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Low-pass filter function\nfloat applyLowPassFilter(float amplitude, float cutoffFreq) {\n    float rc = 1.0 / (2.0 * 3.141592 * cutoffFreq);\n    float dt = 1.0 / 60.0; // Assuming 60 FPS for the time step\n    float alpha = dt / (rc + dt);\n\n    // Apply the low-pass filter to smooth the amplitude\n    float filteredAmplitude = previousAmplitude + alpha * (amplitude - previousAmplitude);\n    previousAmplitude = filteredAmplitude;\n    return filteredAmplitude;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Flip the screen vertically for phone displays\n    if (FLIP_VERTICAL == 1) {\n        uv = vec2(uv.y, 1.0 - uv.x);\n    }\n\n    // Calculate RMS amplitude for a time window\n    float rmsAmplitude = calculateRMS(RMS_TIME_WINDOW);\n\n    // Apply low-pass filter to the RMS amplitude for zoom factor calculation\n    float filteredAmplitude = applyLowPassFilter(rmsAmplitude, CUTOFF_FREQ);\n\n    // Calculate zoom factor based on filtered amplitude\n    float zoomFactor = ZOOM_BASE + ZOOM_RANGE * pow(filteredAmplitude, BKGD_ELASTICITY);\n    zoomFactor = (ZOOM_POLARITY == 1) ? 1.0 / zoomFactor : zoomFactor;\n\n    // Apply zoom to UV coordinates for background\n    vec2 zoomedUv = (uv - 0.5) / zoomFactor + 0.5;\n\n    // Apply wrapping or mirroring to the zoomed UV coordinates\n    if (ZOOM_WRAP_FLAG == 1) {\n        zoomedUv = fract(zoomedUv);\n    } else if (ZOOM_MIRROR_FLAG == 1) {\n        zoomedUv = abs(fract(zoomedUv * 0.5) * 2.0 - 1.0);\n    }\n\n    // Pull the zoomed background from Buffer A\n    vec3 backgroundColor = texture(iChannel1, zoomedUv).rgb;\n\n    // Apply motion percentage to the unzoomed background\n    vec2 motionUv = (uv - 0.5) / (1.0 + (zoomFactor - 1.0) * BACKGROUND_MOTION_PERCENTAGE) + 0.5;\n    if (ZOOM_WRAP_FLAG == 1) {\n        motionUv = fract(motionUv);\n    } else if (ZOOM_MIRROR_FLAG == 1) {\n        motionUv = abs(fract(motionUv * 0.5) * 2.0 - 1.0);\n    }\n    vec3 motionBackgroundColor = texture(iChannel1, motionUv).rgb;\n\n    // Combine the motion background with the zoomed background using the specified composite mode\n    if (DIFFERENCE_BACKGROUND_COMPOSITE_FLAG == 1) {\n        backgroundColor = abs(motionBackgroundColor - backgroundColor);\n    } else {\n        backgroundColor = mix(backgroundColor, motionBackgroundColor, BACKGROUND_TRANSPARENCY);\n    }\n\n    // Initial color based on background from Buffer A\n    vec4 finalColor = vec4(backgroundColor, 1.0);\n\n    // Draw bars\n    vec4 barColor = vec4(0.0, 0.0, 0.0, 0.0);\n    drawBars(barColor, uv, barWidth, barSpacing, 1.0, rmsAmplitude);\n\n    // Buffer the bar calculations\n    vec4 bufferedColor = barColor;\n\n    // Apply post-process mirroring effect to the buffered color\n    if (MIRROR_Y_BOTTOM_FLAG == 1) {\n        vec2 mirroredUv = uv;\n        mirroredUv.y = 1.0 - uv.y;\n        vec4 mirrorColor = vec4(0.0, 0.0, 0.0, 0.0);\n        drawBars(mirrorColor, mirroredUv, barWidth, barSpacing, 1.0, rmsAmplitude);\n        bufferedColor.rgb = mix(bufferedColor.rgb, mirrorColor.rgb, step(0.5, uv.y));\n    }\n\n    if (MIRROR_Y_TOP_FLAG == 1) {\n        vec2 mirroredUv = uv;\n        mirroredUv.y = 1.0 - uv.y;\n        vec4 mirrorColor = vec4(0.0, 0.0, 0.0, 0.0);\n        drawBars(mirrorColor, mirroredUv, barWidth, barSpacing, 1.0, rmsAmplitude);\n        bufferedColor.rgb = mix(bufferedColor.rgb, mirrorColor.rgb, step(uv.y, 0.5));\n    }\n\n    // Combine final background and buffered bar colors with the chosen composite mode\n    if (DIFFERENCE_COMPOSITE_FLAG == 1) {\n        finalColor.rgb = abs(finalColor.rgb - bufferedColor.rgb);\n    } else {\n        finalColor.rgb = mix(finalColor.rgb, bufferedColor.rgb, bufferedColor.a);\n    }\n\n    if (COLOR_POLARITY_FLAG == 1) {\n        finalColor.rgb = vec3(1.0) - finalColor.rgb;\n    }\n\n    fragColor = finalColor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}