{
    "Shader": {
        "info": {
            "date": "1461899005",
            "description": "Perlin Noise. Rand() code is based off something I found at  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl \n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MdtSWf",
            "likes": 0,
            "name": "Perlin Noise!",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "allegrocm",
            "viewed": 1050
        },
        "renderpass": [
            {
                "code": "\nfloat noise(vec2 co)\n{\n    return fract(sin(dot(co ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec2 co, float scale)\n{\n    vec2 pos = co;\n    ivec2 ipos = ivec2(co / scale);\n    pos = vec2(ipos) * scale;\n    float r = noise(pos);\n    return r;\n}\n\nfloat cubicInterpolate(vec4 p, float x)\n{\n\treturn p.y + 0.5 * x*(p.z - p.x + x*(2.0*p.x - 5.0*p.y + 4.0*p.z - p.w + x*(3.0*(p.y - p.z) + p.w - p.x)));\n}   \n\n\nfloat bicubicNoise(vec2 co, float scale)\n{\n     //16!! points to interpolate across\n    mat4 m;\n    ivec2 ipos = ivec2(co/scale);\n    for(int x = 0; x < 4; x++)\n    {\n    \tfor(int y = 0; y < 4; y++)\n        {\n         \tm[x][y] = noise(vec2(ipos + ivec2(x, y)) * scale);   \n        }\n        \n    }\n    \n\t//find our t-values by subtracting pos from quantized pos\n    vec2 qpos = vec2(ipos) * scale;\n    vec2 t = (co-qpos) / scale;\n    float t1 = t.x;\n    t1 = t.y;\n    //do cubic interpolation four times, and then one more time\n    vec4 cubix = vec4(\n        cubicInterpolate(m[0], t1),\n        cubicInterpolate(m[1], t1),\n        cubicInterpolate(m[2], t1),\n        cubicInterpolate(m[3], t1));\n   \treturn cubicInterpolate(cubix, t.x);\n\t\n}\n\nfloat smoothedNoise(vec2 co, float scale)\n{\n    //four values to interpolate across\n    vec2 pos = co;\n    ivec2 ipos = ivec2(co / scale);\n    \n    //four points to interpolate across\n    float p00 = noise(vec2(ipos + ivec2(0, 0)) * scale);\n    float p10 = noise(vec2(ipos + ivec2(1, 0)) * scale);\n    float p01 = noise(vec2(ipos + ivec2(0, 1)) * scale);\n    float p11 = noise(vec2(ipos + ivec2(1, 1)) * scale);\n    \n    //find our t-values by subtracting pos from quantized pos\n    vec2 qpos = vec2(ipos) * scale;\n    vec2 t = (pos-qpos) / scale;\n    \n    //bilinear interpolation\n    float px0 = p00 * (1.0-t.x) + p10 * t.x;\n    float px1 = p01 * (1.0-t.x) + p11 * t.x;\n    return px0 * (1.0 - t.y) + px1 * t.y;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n  \n    float p = 0.0;\n\tfor(int i = 0; i < 6; i++)\n    {\n        float amplitude = pow(0.5, float(i)+1.0);\n      \tp +=  amplitude * bicubicNoise(fragCoord.xy + vec2((iTime*-1.0 + 9000.0) * 10.0, 0.0), 128.0 * amplitude);\n    }\n   \n  //  p = smoothedNoise(fragCoord.xy, 32.0);\n    fragColor.xyz = vec3(p);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}