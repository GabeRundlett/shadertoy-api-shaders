{
    "Shader": {
        "info": {
            "date": "1620217474",
            "description": "left: Channel0: smooth     right: Channel1: HF random    extremes: red/green = under/overflow\ntop to bottom : \nreference laplacian, hardware laplacian, error ",
            "flags": 0,
            "hasliked": 0,
            "id": "fsSSDD",
            "likes": 15,
            "name": "compare laplacian approx",
            "published": 3,
            "tags": [
                "bench",
                "laplacing",
                "hardwarederivative"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 487
        },
        "renderpass": [
            {
                "code": "float size = 256.;  // scale of left texture\n#define lapl1    ( ( Txy(-1,0)+ Txy(1,0)+ Txy(0,-1)+ Txy(0,1) ) /4. - T(U,0.) )\n#define lapl2    9./8.* ( T(U,1.) - T(U,0.) )    // approx Laplacian using MIPmap LOD difference\n                                                 // 9/8 because T(1) includes a bit of T(0) ;-)\n#define T(U,l)   ( left ? texture( iChannel0, (U)*R/size, l+0. ) : texture( iChannel1, (U)*R/1024., l+0. ) )\n//#define T(U,l) ( left ? texture( iChannel0, U, l+0. ) : texelFetch( iChannel1, (ivec2((U)*R)%1024)>>int(l), int(l) ) )\n#define Txy(x,y)   T( U+vec2(x,y)/R, 0. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  U = u/R;\n    bool  left = U.x < .5;\n    int l = int(U.y*3.);\n    \n    float s =  left ? size / 64. : .7,\n          k =  left ? 2.1 : 1.,                  // left: l2/l1 ~ 1.6(size=64) to 2.1(size=256) why ?  ( and not for right )\n         l1 = lapl1.x*s*k, l2 = lapl2.x*s, \n          err = ( l2 - l1 ); //   / l1;          // relative not convenient since l1 get close to 0\n     \n    O =  vec4( l==2 ? l1 : l==1 ? l2 : err );\n    if (left) O *= 5.;\n    O = .5 + 1.*O;                               // show abs(err) and abs(lapl)\n // O =  1.*abs(O);                              // show signed err and lapl\n    if ( abs(U.x-.5) > .25 ) {\n        if (O.x < 0.) O = vec4(1,0,0,0);         // overflow\n        if (O.x > 1.) O = vec4(0,1,0,0);\n    }\n    \n    if ( abs( fract(U.y*3.)/3.*R.y -.5) < .5 ) O = vec4(0,0,1,0); // separators\n    if ( abs( fract(U.x*4.)/4.*R.x -.5) < .5 ) O = vec4(0,0,1,0);\n // O = T(U,0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}