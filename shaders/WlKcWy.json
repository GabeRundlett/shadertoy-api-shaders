{
    "Shader": {
        "info": {
            "date": "1611693894",
            "description": "A sphere and a cube are rendered via raymarching and beautified by phong lighting",
            "flags": 0,
            "hasliked": 0,
            "id": "WlKcWy",
            "likes": 1,
            "name": "raymarching with phong lighting",
            "published": 3,
            "tags": [
                "raymarching",
                "lighting",
                "phonglighting"
            ],
            "usePreview": 0,
            "username": "rskabin",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "#define MAX_RAY_STEPS 100\n#define EPSILON       0.00001f\n#define MIN_DEPTH     0.0f\n#define MAX_DEPTH     100.0f\n\n#define OBJECT_ID_SPHERE 0u\n#define OBJECT_ID_CUBE   1u\n\nstruct GetMinDistResult\n{\n    float dist;\n    uint  object_id;\n};\n\nGetMinDistResult GetMinDist(vec3 ray_pos, vec4 sphere, vec4 cube)\n{\n    float dist_to_sphere = length(sphere.xyz - ray_pos) - sphere.w;\n    float dist_to_cube   = length(max(abs(cube.xyz - ray_pos) - cube.w, 0.0f));\n\n    GetMinDistResult result;\n    result.dist = min(dist_to_sphere, dist_to_cube);\n\n    /**/ if (result.dist == dist_to_sphere) result.object_id = OBJECT_ID_SPHERE;\n    else if (result.dist == dist_to_cube)   result.object_id = OBJECT_ID_CUBE;\n\n    return result;\n}\n\nmat4 LookAtLH(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 z_axis    = normalize(target - camera);\n    vec3 x_axis    = normalize(cross(up, z_axis));\n    vec3 y_axis    = cross(z_axis, x_axis);\n    vec3 translate = vec3(-dot(x_axis, camera),\n                          -dot(y_axis, camera),\n                          -dot(z_axis, camera));\n\n    return mat4(x_axis.x,    y_axis.x,    z_axis.x,    0.0f,\n                x_axis.y,    y_axis.y,    z_axis.y,    0.0f,\n                x_axis.z,    y_axis.z,    z_axis.z,    0.0f,\n                translate.x, translate.y, translate.z, 1.0f);\n}\n\nmat4 PerspLH(float aspect, float fov, float near, float far)\n{\n    float tanfov2 = tan(radians(fov / 2.0f));\n    return mat4(1.0f/(aspect*tanfov2),         0.0f,                        0.0f, 0.0f,\n                                 0.0f, 1.0f/tanfov2,                        0.0f, 0.0f,\n                                 0.0f,         0.0f,       (far+near)/(far-near), 1.0f,\n                                 0.0f,         0.0f, -(2.0f*near*far)/(far-near), 0.0f);\n}\n\nmat3 RotationY(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(   c, 0.0f,   -s,\n                0.0f, 1.0f, 0.0f,\n                   s, 0.0f,    c);\n}\n\nmat3 RotationX(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(1.0f, 0.0f, 0.0f,\n                0.0f,    c,    s,\n                0.0f,   -s,    c);\n}\n\nvec3 GetNormal(GetMinDistResult mdr, vec3 ray_pos, vec4 sphere, vec4 cube)\n{\n    if (mdr.object_id == OBJECT_ID_SPHERE)\n    {\n        vec3 normal = normalize(ray_pos - sphere.xyz);\n        normal.z *= -1.0f;\n        return normal;\n    }\n    else if (mdr.object_id == OBJECT_ID_CUBE) // @NOTE: Awful\n    {\n        vec3 v1 = vec3(ray_pos.x - (cube.x - cube.w), 0.0f, 0.0f);\n        vec3 v2 = vec3(0.0f, ray_pos.y - (cube.y - cube.w), 0.0f);\n        vec3 v3 = vec3(0.0f, 0.0f, ray_pos.z - (cube.z - cube.w));\n        vec3 v4 = vec3(ray_pos.x - (cube.x + cube.w), 0.0f, 0.0f);\n        vec3 v5 = vec3(0.0f, ray_pos.y - (cube.y + cube.w), 0.0f);\n        vec3 v6 = vec3(0.0f, 0.0f, ray_pos.z - (cube.z + cube.w));\n\n        float l1 = length(v1);\n        float l2 = length(v2);\n        float l3 = length(v3);\n        float l4 = length(v4);\n        float l5 = length(v5);\n        float l6 = length(v6);\n\n        float min_length1 = min(min(l1, l2), l3);\n        float min_length2 = min(min(l4, l5), l6);\n        float min_length  = min(min_length1, min_length2);\n\n        /**/ if (min_length == l1) return vec3(-1.0f,  0.0f,  0.0f);\n        else if (min_length == l2) return vec3( 0.0f, -1.0f,  0.0f);\n        else if (min_length == l3) return vec3( 0.0f,  0.0f,  1.0f);\n        else if (min_length == l4) return vec3( 1.0f,  0.0f,  0.0f);\n        else if (min_length == l5) return vec3( 0.0f,  1.0f,  0.0f);\n        else if (min_length == l6) return vec3( 0.0f,  0.0f, -1.0f);\n    }\n    return vec3(0.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = ((fragCoord / iResolution.xy) - 0.5f) * 2.0f;\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec2 mouse_pos = ((iMouse.xy / iResolution.xy) - 0.5f) * 2.0f;\n    mouse_pos.y *= iResolution.y / iResolution.x;\n    \n    // @NOTE: Centralize on start.\n    if (iMouse.xy == vec2(0.0f)) mouse_pos = vec2(0.0f);\n\n    vec3 cam_pos = RotationX(-mouse_pos.y) * RotationY(mouse_pos.x) * vec3(0.0f, 0.0f, -0.4f);\n    vec3 target  = vec3(0.0f, 0.0f, 0.6f);\n\n    mat4 persp   = PerspLH(iResolution.x / iResolution.y, 90.0f, abs(cam_pos.z), 100.0f);\n    mat4 look_at = LookAtLH(cam_pos, target, vec3(0.0f, 1.0f, 0.0f));\n\n    vec3 light_pos = vec3(-1.0f, 1.0f, -0.7f);\n    vec4 sphere    = vec4( 0.4f, 0.0f,  0.4f, 0.3f);\n    vec4 cube      = vec4(-0.4f, 0.0f,  0.5f, 0.3f);\n\n    vec4 inter_sphere_pos = persp * look_at * vec4(sphere.xyz, 1.0f);\n    vec4 inter_cube_pos   = persp * look_at * vec4(cube.xyz, 1.0f);\n\n    if (inter_sphere_pos.w != 0.0f) inter_sphere_pos /= inter_sphere_pos.w;\n    if (inter_cube_pos.w   != 0.0f) inter_cube_pos   /= inter_cube_pos.w;\n\n    sphere.w *= length(inter_sphere_pos.xyz) / length(sphere.xyz);\n    cube.w   *= length(inter_cube_pos.xyz)   / length(cube.xyz);\n\n    sphere.xyz = inter_sphere_pos.xyz;\n    cube.xyz   = inter_cube_pos.xyz;\n\n    vec3 object_colors[2];\n    object_colors[OBJECT_ID_SPHERE] = vec3(0.9f, 0.0f, 0.0f);\n    object_colors[OBJECT_ID_CUBE]   = vec3(0.0f, 0.0f, 0.9f);\n\n    vec3 light_color  = vec3(0.7f, 0.8f, 0.8f);\n\n    vec3 ray_dir = normalize(vec3(uv, target.z) - cam_pos);\n\n    float depth = MIN_DEPTH;\n    for (int step = 0; step < MAX_RAY_STEPS && depth < MAX_DEPTH; ++step)\n    {\n        vec3 ray_pos = cam_pos * depth + ray_dir;\n\n        GetMinDistResult min_dist_res = GetMinDist(ray_pos, sphere, cube);\n\n        if (min_dist_res.dist < EPSILON)\n        {\n            vec3 view_dir  = normalize(ray_pos - cam_pos);\n            vec3 light_dir = normalize(ray_pos - light_pos);\n            vec3 normal    = GetNormal(min_dist_res, ray_pos, sphere, cube);\n            vec3 light_ref = reflect(-light_dir, normal);\n\n            float ambient_strength = 0.1f;\n            vec3  ambient          = ambient_strength * light_color;\n\n            float diff    = max(dot(normal, -light_dir), 0.0f);\n            vec3  diffuse = diff * light_color;\n\n            float spec_strength = 0.6f;\n            float shininess     = 32.0f;\n            float spec          = pow(max(dot(view_dir, light_ref), 0.0f), shininess);\n            vec3  specular      = spec_strength * spec * light_color;\n\n            fragColor = vec4((ambient + diffuse + specular) * object_colors[min_dist_res.object_id], 1.0f);\n            return;\n        }\n\n        depth += min_dist_res.dist;\n    }\n\n    fragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}