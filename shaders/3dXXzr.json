{
    "Shader": {
        "info": {
            "date": "1550419770",
            "description": "Try to make it looks like one of the key visual from Japanese animation called the Fate Stay Night.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dXXzr",
            "likes": 6,
            "name": "Unlimited Blade Works",
            "published": 3,
            "tags": [
                "fate"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 535
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sword(vec3 p){\n    float sc = 4.0;\n    vec3 refP = (p+vec3(0.0,-0.17*sc,0.0))*matRotateX(radians(90.0));\n    vec2 h = vec2(0.02*sc,0.01*sc);\n  \tvec2 d = abs(vec2(length(refP.xz),refP.y)) - h;\n    float d0 = sdBox(p,vec3(0.01*sc,0.17*sc,0.01*sc));\n    float d1 = sdBox(p+vec3(0.0,-0.08*sc,0.0),vec3(0.06*sc,0.01*sc,0.01*sc));\n    float d2 = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    return opSmoothUnion(opSmoothUnion(d0,max(-(length(p)-0.085*sc),d1),0.01*sc),d2,0.001*sc); \n}\n\nfloat sdGear( vec3 p, vec2 h )\n{\n    float r = (length(p)-0.65);\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float len = 0.93;\n\tfloat resd = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    float res2d = max(-r,resd);\n    float b = sdBox(p,vec3(0.07,0.015,len));\n    float b2 = sdBox(p,vec3(len,0.015,0.07));\n    float b3 = sdBox(p*matRotateY(radians(30.0)),vec3(len,0.015,0.07));\n    float b4 = sdBox(p*matRotateY(radians(-30.0)),vec3(len,0.015,0.07));\n    \n    float b5 = sdBox(p*matRotateY(radians(60.0)),vec3(len,0.015,0.07));\n    float b6 = sdBox(p*matRotateY(radians(-60.0)),vec3(len,0.015,0.07));\n    \n    float res3d = max(-b,res2d);\n    float res4d = max(-r,min(min(min(min(min(b,b2),b3),b4),b5),b6));\n  \treturn min(res3d,res4d);\n}\n\nvec4 map(vec3 p){\n    float animateZ = iTime*0.5;\n    vec3 refP = p;\n    refP.z += animateZ;\n    refP.y += 2.5;\n    refP.x = mod(refP.x,3.0)-1.5;\n    refP.z = mod(refP.z,3.0)-1.5;\n    \n    float sd = sword((refP+vec3(0.0,(sin(p.x)*cos(p.z))*0.15,-0.5))*matRotateY(radians(20.0))*matRotateZ(radians(10.0)));\n    \n    refP = p;\n    refP.z += 1.5+animateZ;\n    refP.y += 2.5;\n    refP.x += 1.0;\n    refP.x = mod(refP.x,3.0)-1.5;\n    refP.z = mod(refP.z,3.0)-1.5;\n    float sd2 = sword((refP+vec3(0.0,(sin(p.x)*cos(p.z))*0.15,-0.5))*matRotateY(radians(-20.0))*matRotateZ(radians(-10.0)));\n    refP = p;\n    \n    refP.z += animateZ;\n    refP.y -= 0.7;\n    refP.x -= 1.5;\n    refP.x = mod(refP.x,4.0)-2.0;\n    refP.z = mod(refP.z,4.0)-2.0;\n    \n    mat3 rotX = matRotateX(radians(90.0));\n    float rad = radians(iTime*30.0);\n    float gear0 = sdGear(((refP+vec3(0.0,-0.3,-0.6))*rotX)*matRotateY(rad),vec2(0.8,0.015));\n    refP = p;\n    \n\trefP.z += 1.5+animateZ;\n    refP.y -= 2.5;\n    refP.x += 2.0;\n    refP.x = mod(refP.x,6.0)-3.0;\n    refP.z = mod(refP.z,6.0)-3.0;\n    float gear1 = sdGear(((refP+vec3(0.0,-0.5,-0.9))*rotX)*matRotateY(-rad),vec2(0.8,0.015));\n    \n    p.z += animateZ;\n    float n = cnoise(p.xz*1.5)*0.6;\n    vec3 floorCol = (vec3(n)+vec3(0.8,0.7,0.2))*0.9;\n    if(n<0.1){\n        p.y +=n*0.03;\n    \tfloorCol = vec3(0.8,0.7,0.2)+(n*0.2);\n    }\n    \n    p.y += (sin(p.x)*cos(p.z))*0.15;\n\n    vec4 res0 = vec4(floorCol*vec3(0.8,0.5,0.0),min(gear0,gear1));\n    vec4 res1 = vec4(floorCol,min(min(p.y+3.0,sd),sd2));\n    vec4 render = combine(res0,res1);\n    \n    return render;\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tmat3 camRotY = matRotateY(radians(sin(iTime)*30.0));\n    \n\tvec3 ro=vec3(0.,0.0,0.0);\n    vec3 rd=normalize(vec3(p,1.0));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 30; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t);\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(0.8,0.55,0.15)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0)+(noise(p.x*p.y*iTime*0.1))*0.12;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}