{
    "Shader": {
        "info": {
            "date": "1498845039",
            "description": "Work-in-progress of a 2D, line-based, tree generation algorithm for an in-development shader. Yes, it is incomplete and unoptimized, hence the work-in-progress, but thought I would share it.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldlBWf",
            "likes": 10,
            "name": "Tree Generation (WIP)",
            "published": 3,
            "tags": [
                "2d",
                "wip",
                "tree"
            ],
            "usePreview": 0,
            "username": "ssell",
            "viewed": 551
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Basic algorithm outline:\n *\n *     * Tree consists of branches, with the root branch being the trunk.\n *     * Each branch has one less segment than it's parent branch.\n *     * Each segment has a new branch.\n *     * Each branch has half the total thickness and length of it's parent branch.\n *     * Each branch has an adjusted angle of +/- MajorBranchAngle\n *     * Each segment has an adjusted angle of +/- MinorBranchAngle\n *\n * Not sure if this is the best way to generate a tree, but it's what popped into my head.\n * Implemented using a stack since recursive functions are not allowed.\n */\n\n//------------------------------------------------------------------------------------------\n// Global Properties\n//------------------------------------------------------------------------------------------\n\n// Tree Properties\n\n      float Seed              = 337.0;     // Seed used for PRNG hash\nconst int   TrunkSegments     = 5;         // Number of segments in the trunk branch\nconst float TrunkLength       = 0.7;       // Length of the trunk branch\nconst float TrunkThickness    = 0.025;     // Thickness of the trunk branch\nconst float MajorBranchAngle  = 0.125;     // +/- angle deviation of branches\nconst float MinorBranchAngle  = 0.0625;    // +/- angle deviation of segments\nconst int   StackDepth        = 16;        // Maximum stack depth\n\n// Math Constants\n\nconst float PI                = 3.14156;\nconst float E                 = 2.71828;\n\n//------------------------------------------------------------------------------------------\n// Math Functions\n//------------------------------------------------------------------------------------------\n\nfloat StepValue(float a, float b, float ra, float rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\nfloat hash11(float p)\n{\n    // Credit Dave_Haskins\n\tvec3 p3  = fract(vec3(p) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Noise(float s, float m)\n{\n    float r = (hash11((s + Seed)) * 2.0) - 1.0;\n\treturn (r * m);   \n}\n\nvec2 Rotate(vec2 v, float a)\n{\n    float cosa = cos(a);\n    float sina = sin(a);\n    \n    return vec2((v.x * cosa) - (v.y * sina), (v.x * sina) + (v.y * cosa));\n}\n\nfloat Factorial(float n)\n{\n\tfloat v = 1.0;\n    for(; n > 1.0; --n) { v *= n; }\n    return v;\n}\n\nfloat CalcNumSegments(int trunkSegments)\n{\n    // http://oeis.org/A007526\n    // Example: Trunk has 3 segments, each Branch0 has 2 segments, each Branch1 has 1 segment for 15 total.\n\n\treturn floor(E * Factorial(float(trunkSegments)) - 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Line Drawing\n//------------------------------------------------------------------------------------------\n\nvec2 DistToLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float frac = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return vec2(length(pa - (ba * frac)), frac);\n}\n\nfloat Sharpen(in float dist, in float thickness, float blur)\n{\n    float r = (1.0 / min(iResolution.y, iResolution.x)) * blur;\n    return smoothstep(r, -r, dist - thickness);\n}\n\nfloat LineTaper(vec2 uv, vec2 a, vec2 b, float thickness0, float thickness1, float blur)\n{\n    vec2 d = DistToLine(uv, a, b);\n    return Sharpen(d.x, mix(thickness0, thickness1, d.y), blur);\n}\n\n//------------------------------------------------------------------------------------------\n// Tree Structure\n//------------------------------------------------------------------------------------------\n\nstruct Segment\n{\n    vec2 o;      // Origin\n    vec2 d;      // Normal / Direction\n    \n    float bl;    // Total length of the Branch the segment is part of\n    float sl;    // Length of the individual segment\n    float t0;    // Starting thickness of the segment\n    float t1;    // Ending thickness of the segment\n    \n    int s;       // # of Segments a child branch of the segment would have\n    int si;      // Index  of the segment along it's branch\n};\n\nSegment Segments[StackDepth];\n\nvoid Push(inout int i, Segment s)\n{\n    i = min(i + 1, StackDepth);\n    Segments[i] = s;\n}\n\nSegment Pop(inout int i)\n{\n    Segment s = Segments[i];\n    i = max(i - 1, 0);\n    \n    return s;\n}\n    \n//------------------------------------------------------------------------------------------\n// Tree Drawing\n//------------------------------------------------------------------------------------------\n\nfloat DrawSegment(vec2 uv, Segment s)\n{\n    return LineTaper(uv, s.o, (s.o + (s.d * s.sl)), s.t0, s.t1, 1.0);\n}\n\nvoid AddBranch(inout int si, vec2 origin, vec2 dir, float lngth, float thickness, int segments)\n{\n    float tstep = thickness / float(segments);\n    float lstep = lngth / float(segments);\n\n    vec2 sorigin    = origin;\n    vec2 sdirection = dir;\n\n    float t0   = thickness;\n    float t1   = t0 - tstep;\n    float rand = 0.0;\n    \n    for(int j = 0; j < segments; ++j)\n    {\n        Push(si, Segment(sorigin, sdirection, lngth, lstep, t0, t1, (segments - 1), j));\n\n       \trand       = float(si + j + 1);\n        sorigin    = sorigin + (sdirection * lstep);\n        sdirection = Rotate(sdirection, Noise(rand, PI * MinorBranchAngle * StepValue(rand, 0.0, 1.0, -1.0)));\n        \n        t0 = t1;\n        t1 = t0 - tstep;\n    }\n}\n\nfloat Tree(vec2 uv, vec2 origin, vec2 direction, float lngth, int segments, float thickness)\n{\n    float f = 0.0;\n    \n    int totalSegments = int(CalcNumSegments(segments));\n    int si = -1;\n    \n    AddBranch(si, origin, direction, lngth, thickness, segments);\n    \n    for(int i = 0; i < totalSegments; ++i)\n    {\n        Segment root = Pop(si);                // Root segment of this branch\n        f = max(f, DrawSegment(uv, root));     // Draw the root segment\n        \n  \t\tif(root.s > 0 && root.si > 0)          // Add a branch to this segment if valid\n        {\n            AddBranch(si, root.o,  Rotate(root.d, Noise(float(i + root.s), PI * MajorBranchAngle)), root.bl * 0.5, root.t0, root.s);\n        }\n    }\n    \n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Seed = 337.0 + floor(iTime * 1.5);\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float f = Tree(uv, vec2(0.5, 0.05), vec2(0.0, 1.0), TrunkLength, TrunkSegments, TrunkThickness);\n    \n    fragColor.rgb = vec3(f);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}