{
    "Shader": {
        "info": {
            "date": "1696512954",
            "description": "A little experiment around stylized shading and using a cool displacement technique I had found ( https://www.shadertoy.com/view/4scSW4 )",
            "flags": 0,
            "hasliked": 0,
            "id": "DlsyRj",
            "likes": 18,
            "name": "BC - Water Sphere",
            "published": 3,
            "tags": [
                "raymarching",
                "displacement",
                "water",
                "fx",
                "stylized"
            ],
            "usePreview": 0,
            "username": "BackwardsCap",
            "viewed": 327
        },
        "renderpass": [
            {
                "code": "// https://www.shadertoy.com/view/4scSW4\t\nfloat displacement(vec3 p)\n{\n    vec2 d1 = p.xy * 0.3;\n    vec2 d2 = d1 * 0.2;\n    d1.x+=d1.y*2.;\n    d1.x += iTime*0.05;\n    d2.x += iTime *0.1;\n    d2.y -= iTime * 0.025;\n    d2.x += d2.y*2.;\n    \n    float h1 = texture(iChannel0, d2).x;\n    float h2 = texture(iChannel0, d1).x;\n    \n    return h1 * .6 + h2 * 0.1* (1.0 - h1 );\n}\n\nvec2 map(vec3 p)\n{\n    vec2 r;\n    \n\n    float d = displacement(p);\n    float warp = cos(p.y*.3*cos(iTime/10.+1.56));\n    float column1 = sphere(p * warp,3.0) + d;\n        \n    r = vec2(column1, 1.0);\n    return r ;\n}\n\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    float t=0.,m;\n    for(int i=0;i<128;i++)\n    {\n        vec3 p = ro+rd*t;\n        vec2 s = map(p);\n        m=s.y;\n        if(s.x<0.001)break;\n        t+=s.x;\n        if(t>MAX_DIST){t=-1.;break;}\n    }\n    return vec2(t,m);\n}\n\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.01,0);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        ));\n}\nfloat fresnel(vec3 n, vec3 dir, float power)\n{\n    return pow(1.0+dot(dir, n), power);\n}\nfloat shine(vec3 p, vec3 n)\n{\n    p.y = 0.;\n    float d = (dot(normalize(p), n));\n    \n    float r = 0.0;\n    if(d >= .99)\n        r += 0.2*d;\n    return r;\n}\nvec3 down(vec3 c, float s)\n{\n    c.rg*=s;\n    c.rg = floor(c.rg);\n    c.rg/=s;\n    return c;\n}\n\nvoid mainImage( out vec4 c, in vec2 f)\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.067,0.502,0.933)*(((cos(uv.x)+cos(uv.y))))/2.75;\n    col = down(col,60.);\n    vec3 bg = col;\n    float t = cos(iTime/5.)/3.;\n    float d = 9.5+(1.0+cos(iTime/2.));\n    vec3 ro = vec3(0,sin(t/.1),cos(t)*d);\n    vec3 ta = vec3(0);\n    vec3 rd = cam(ro,ta,uv);\n    \n    vec2 r = ray(ro,rd);\n    \n    if(r.x>0.0)\n    {\n        vec3 p = ro+rd*r.x;\n        vec3 n = normal(p);\n        \n        \n        vec3 mate=vec3(.0,.5,1.0);\n        vec3 sun = normalize(vec3(0.5,.5,.5));\n        vec3 backlight = normalize(vec3(-0.5,-.5,-.5));\n        float dif = clamp(dot(sun,n),0.,1.);\n        float bdif = clamp(dot(backlight,n),0.,1.);\n        float sky = clamp(dot(n,vec3(0,1,0)),0.,1.);\n        float bou = clamp(dot(n,vec3(0,-1,0)),0.,1.);\n        float sha = clamp(ray(p+n*.001,sun).x,0.,1.);\n        \n        \n        col=dif * mate;\n        col+=bdif * mate;\n        col+=sky * mate;\n        col+=bou * mate;\n        col += fresnel(n, rd, 3.) * vec3(0.6,0.9,1.0);\n        \n        vec3 ref = texture(iChannel1, n).rgb;\n        float s = shine(p,n);\n        col = mix(col, ref, 0.5 + s);\n        col = mix(col, bg, fresnel(n,rd,2.)*1.5);\n        col=down(col,8.);\n        col = mix(col, bg, clamp(r.x/MAX_DIST,0.,1.));\n    }\n    \n\n    \n    c.rgb=col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_DIST 60.0\n#define PI 3.1415927\n\nvec3 cam(vec3 ro, vec3 ta, vec2 uv)\n{\n    vec3 cf = normalize(ta-ro);\n    vec3 cu = normalize(cross(cf,vec3(0,1,0)));\n    vec3 cr = normalize(cross(cu,cf));\n    return normalize(uv.x*cu+uv.y*cr+2.*cf);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}