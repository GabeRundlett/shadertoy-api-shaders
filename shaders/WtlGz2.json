{
    "Shader": {
        "info": {
            "date": "1556937534",
            "description": "Use mouse to look around.\n\nFirst attempt at pbr based lighting with ibl.  Relevant links:\nhttps://learnopengl.com/PBR/Theory\nhttps://www.unrealengine.com/en-US/blog/physically-based-sh.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtlGz2",
            "likes": 4,
            "name": "White Fractal",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "mouse",
                "sdf",
                "kali",
                "ibl",
                "pbr"
            ],
            "usePreview": 0,
            "username": "zackpudil",
            "viewed": 566
        },
        "renderpass": [
            {
                "code": "// Author: zackpudil\n// My First attempt at using Physical Based Rendering (pbr)\n//  \tand Image Based Lighting (ibl).\n// I feel like the look could be coerced from simpler, more efficient techniques,\n// but I wanna build a memeory of the lighting to have a general go to technique.\n\n//--------------------GEOMETRY functions-------------------\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return max(q.x, max(q.y, q.z));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return max(q.x, q.y);\n}\n\n// A plastic box with metal edges.\nvec2 shape(vec3 p) {\n    float a = box(p, vec3(1)); // plastic box.\n    \n    p = -abs(p) + vec3(1); // mirror space to save on distance evaluations\n    float ce = 0.2;\n\t// edges.\n    float b = box(p - vec3(1, 0, 0), vec3(1.0 + ce, ce, ce));\n    float c = box(p - vec3(0, 0, 1), vec3(ce, ce, 1.0 + ce));\n    float d = box(p - vec3(0, 1, 0), vec3(ce, 1.0 + ce, ce));\n    \n    vec2 s = vec2(a, 2.0); // 2.0 == material id for white plastic.\n    vec2 t = vec2(min(min(b, c), d), 1.0); // 1.0 == material id for metal.\n    \n    return s.x < t.x ? s : t;\n}\n\n// path function is used to carve out the path the camera and light takes.\nvec2 path(float z) {\n    return vec2(0, 4.0*cos(0.3*z));\n}\n\n// Yet Another low iteration Kali (AbsBox) fractal from me.\nvec2 de(vec3 p) {\n    vec3 op = p;\n    p = mod(p + 2.0, 4.0) - 2.0; // repeat space infinitly on all axises.\n    vec4 q = vec4(p, 1);\n    \n    // very basic absbox, or \"kali\" fractal.\n    // See this to get better ideas of it's potential: \n\t// https://www.shadertoy.com/user/Kali - THE GOAT\n    q.xyz -= 1.0;\n    for(int i = 0; i < 4; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q /= clamp(dot(q.xyz, q.xyz), 0.5, 1.0);\n        q.xz *= rot(0.9);\n        q.xy *= rot(-0.3);\n        q.yz *= rot(0.1);\n        q *= 1.04;\n    }\n    \n    vec2 s = shape(q.xyz)/vec2(q.w, 1);\n    s.x = max(s.x, -box(op.xy - path(op.z), vec2(0.1)));\n    \n    return s;\n}\n\n// straight forward sphere tracing, got from IQ (the legend).\nvec2 trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0, m = -1.0;\n    for(int i = 0; i < 100; i++) {\n        vec2 d = de(ro + rd*t);\n        if(d.x < 0.001 || t >= mx) break;\n        t += d.x*0.85;\n        m = d.y;\n    }\n    return vec2(t, t < mx ? m : -1.0);\n}\n\n// central difference based normal, got from again IQ.\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.0001, 0.0);\n    vec3 n = vec3(\n        de(p + h.xyy).x - de(p - h.xyy).x,\n        de(p + h.yxy).x - de(p - h.yxy).x,\n        de(p + h.yyx).x - de(p - h.yyx).x);\n    \n    return normalize(n);\n}\n\n// pbr == Physical Based Rendering.  This better mimics how real world light\n// interacts with surfaces. See full explanation of algorithm here:\n// https://learnopengl.com/PBR/Lighting\nvec3 pbr(vec3 p, vec3 n, vec3 l, vec3 rd, vec3 a, float r, float m,\n         inout vec3 f0, inout float hov, inout float nov) {\n    \n    // set up view and halfway vector.\n    vec3 v = normalize(-rd);\n    vec3 h = normalize(l + v);\n    \n    // get angles needed for calculation.\n    float nol = clamp(dot(n, l), 0.0, 1.0);\n    float noh = clamp(dot(n, h), 0.0, 1.0);\n    nov = clamp(dot(n, v), 0.0, 1.0);\n    hov = clamp(dot(h, v), 0.0, 1.0);\n    \n    // F == The fresnel term (pronounced Freh-nel).  \n    // This is the Schlick approximation.\n    f0 = mix(vec3(0.04), a, m);\n    vec3 F = f0 + (1.0 - f0)*pow(1.0 - hov, 5.0);\n    \n    // The \"Normal Distrubution Function\".\n    // approximates the \"microfacets\" of the surface.\n    float a2 = pow(r, 4.0);\n    float D = a2/(3.141*pow(noh*noh*(a2 - 1.0) + 1.0, 2.0));\n    \n    // The \"Geometry Function\" approximates self shadowing of microfaces on material.\n    // This is the \"Smith\" approximation.\n    float k = 0.5*pow(0.5*r + 0.5, 2.0);\n    float kl = nol*(1.0 - k) + k;\n    float kv = nov*(1.0 - k) + k;\n    float V = 1.0/(4.0*kl*kv);\n    \n    // Normal Distrubution Function * Geometry Function * Fresnel term = specular term.\n    vec3 spe = F*D*V; // spe aka BRDF (bidirectional reflective distribution function)\n    \n    // diffuse (metal meterials don't have a diffuse term).\n    vec3 dif = (1.0 - F)*(1.0 - m);\n\n    return (a*dif/3.141 + spe)*nol; // all times the normal dot light\n}\n\n// Image Based Lighting.  This models the indirect light coming from iChannel0\nvec3 ibl(vec3 p, vec3 n, vec3 r, vec3 a, float ro, float m,\n         vec3 f0, float hov, float nov) {\n    \n    // Fresnel term modification based on Sebastien Lagarde.  Includes roughness to fix edge problem.\n    vec3 F = f0 + (max(vec3(1.0 - ro), f0) - f0)*pow(1.0 - hov, 5.0);\n    vec3 irr = texture(iChannel0, n, 10.0).rgb; // irradiance from environment.\n    vec3 dif = (1.0 - F)*(1.0 - m)*irr*a; // indirect diffuse lighting.\n    \n    // prefiltered specular color.\n    vec3 pc = textureLod(iChannel0, r, ro*15.0).rgb;\n    \n    // === this code is an approximation to the environment BRDF function describe in learnopengl.com.\n    // find explanation here: https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\n    vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 cr = ro*c0 + c1;\n    float a004 = min(cr.x*cr.x, exp2(-9.28*nov))*cr.x + cr.y;\n    vec2 ab = vec2(-1.04, 1.04)*a004 + cr.zw;\n    \n    // indirect brdf is prefilteredColor*(Fresnel*brdf.x + brdf.y)\n    vec3 spe = pc*(F*ab.x + ab.y);\n    \n    // very quick and dirty ambient occlusion.\n    // Got this from evvvil_ (https://www.shadertoy.com/user/evvvvil) What up Broski.\n    float occ = exp2(-pow(max(0.0, 1.0 - de(p + n*0.05).x/0.05), 2.0));\n    \n    // full indirect lighting based on environment (or image from cube map in Channel0).\n    return (dif + spe)*occ;\n}\n\n// Triplaniar blending of 2d materials to 3d surfaces.\n// Got this from Shane (THE GOAT).\nvec3 tex3D(vec3 p, vec3 n, sampler2D s) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    m /= dot(m, vec3(1));\n    \n    vec3 x = texture(s, p.yz).rgb;\n    vec3 y = texture(s, p.xz).rgb;\n    vec3 z = texture(s, p.xy).rgb;\n    \n    return m.x*x*x + m.y*y*y + m.z*z*z;\n}\n\n// Normal bumping based on material. Also got this from Shane.\nvec3 bump(vec3 p, vec3 n, float bf, float f) {\n    p *= f;\n    vec2 h = vec2(0.001, 0.0);\n    vec3 g = mat3(\n        tex3D(p + h.xyy, n, iChannel1) - tex3D(p - h.xyy, n, iChannel1),\n        tex3D(p + h.yxy, n, iChannel1) - tex3D(p - h.yxy, n, iChannel1),\n        tex3D(p + h.yyx, n, iChannel1) - tex3D(p - h.yyx, n, iChannel1))\n        *vec3(0.299, 0.584, 0.114); // grey scale.\n    \n    g -= n*dot(n, g);\n    \n    return normalize(n + bf*g);\n}\n\n// calculate the material for each material id in the scene.\n// very simple since we have 1 white plastic, 1 white metal.\nvoid material(float mid, vec3 p, inout vec3 n,\n              inout vec3 a, inout float r, inout float m) {\n    if(mid == 1.0) { // metal material.\n        a = vec3(0.7, 1, 1); // white.\n        n = bump(p, n, 0.4, 0.4); // minimal bumping.\n        r = 0.3; // low roughness.\n        m = 1.0; // metal.\n    } else if(mid == 2.0) { // plastic material.\n        a = vec3(0.7, 1, 1); // all white.\n        n = bump(p, n, 1.0, 1.0); // lots of bumping. \n        r = 0.1; // as smooth as you can get.\n        m = 0.0; // not metal.\n    }   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 mo = (3.0*iMouse.xy - 1.5*iResolution.xy)/iResolution.y;\n    if(iMouse.z <= 0.0) mo = vec2(0);\n    // camera animation.\n    float at = iTime*0.3;\n    vec3 ro = vec3(path(at), at);\n    vec3 la = vec3(path(at + 1.0) + mo, at + 1.0);\n    \n    // ray direction setup.\n    vec3 ww = normalize(la-ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 0.5));\n    \n    vec3 col = texture(iChannel0, rd).rgb;\n    \n    vec3 lp = la; // light position is the same as lookat vector.\n    \n    vec2 t = trace(ro, rd, 50.0);\n    if(t.y > 0.0) {\n        // geometry.\n        vec3 p = ro + rd*t.x;\n        vec3 n = normal(p);\n        vec3 l = normalize(lp - p); // light direction.\n\n        // initialize material props.\n        vec3 a = vec3(1);\n        float ro = 0.1, m = 0.0;\n        \n        material(t.y, p, n, a, ro, m); // assign material props.\n        \n        // some calculated variables that we can reuse for ibl.\n        vec3 f0;\n        float hov, nov;\n        col = pbr(p, n, l, rd, a, ro, m, f0, hov, nov); // direct lighting.\n        \n        vec3 r = reflect(rd, n); \n        col += ibl(p, n, r, a, ro, m, f0, hov, nov); // indirect lighting.\n    }\n    \n    col = mix(col, vec3(0), 1.0 - exp(-0.1*t.x)); // some black fog.  lazy attenuation.\n    col = 1.0 - exp(-0.8*col); // contrast/tone mapping.\n    fragColor = vec4(pow(col, vec3(0.454545)), 1); // some gamma correction, and that's it.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}