{
    "Shader": {
        "info": {
            "date": "1635356908",
            "description": "figure 8 uses complex number distance fields in s3.\nThis extreme distortion comes with extreme marching challenge.\na naive approach to that is logeps(), as in this shader.\na a smarter approach is to calculate the matrix of differentials to rescale lipschi",
            "flags": 0,
            "hasliked": 0,
            "id": "fdyXW3",
            "likes": 6,
            "name": "Figure8 logeps in s3",
            "published": 3,
            "tags": [
                "3d",
                "4d",
                "knot",
                "projective",
                "s3",
                "seifert"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "#define doLogEps\n// logeps break condition of https://www.shadertoy.com/view/tdXXzl\n\n//Daniel Piker 2021\n/* \nChanged to get the Seifert surface using (1/4πi) log (Q/Q∗)\n(added complex log line 85 and new field expression line 163)\n\nTrying here to show different valued Seifert fibers like in \nhttps://twitter.com/KangarooPhysics/status/1381380025568616459\n\n// Inigo Quilez 2021\n/*\n\nAn (appoximated) SDF that has a Figure-8 knot shape. It's not very\nsymmetric or pretty, but it counts (topologically).\n\nThe idea is described here https://arxiv.org/pdf/1610.02463.pdf and\ngoes like this:\n\nFrom R3, our regular 3D space, we do an inverse stereographic\nprojection to land in a 4D hyper sphere S3, a subset of R4.\n\nIn R4 we define a function F that returns a R2 field (or\ntwo scalar fields, if you want). We find the zero isosurface\n(the nodal set, or roots) of F by zeroing its two components.\n\nBecause we are only evaluating the subset of R4 that lays on S3,\nwe are really computing the intersection of the isosurfce of F\nwith the surface of the sphere S3. This creates a curve on the surface\nof the sphere, which thanks to the stereographic projection we started\nwith becomes a curve in R3, our 3D space. That's the curve we are\nraymarching.\n\nThe R4 parameter to F can be grouped as two complex numbers u and v.\nAnd in the case of this shader I'm using\n\nF(u,v) = 64v³ − 12v(3+2u²−2u*²) − (14u²+14u*²+u⁴-u*⁴)\n\nwhere u* is the conjugate of u. This curve is a figure 8 shape, as\ndescribed in the paper. You can change the SHAPE define below to\nsee another shape (a torus knot).\n\nLastly, there's more than one way to convert F into a R1 scalar field\nthan taking it's length |F|. For example, you can pass F through any\n2D SDF formula you want, such a square. Change the PROFILE define\nbellow to explore that.\n\n\nSee: https://www.shadertoy.com/view/tsBGzt\nSee: https://www.shadertoy.com/view/7sGSRd\n\n*/\n\n#define AA 1\n\n// 0: circular\n// 1: square\n#define PROFILE 0\n\n// 0: figure 8\n// 1: torus 5-2\n// 2: something i made\n#define SHAPE 0\n\n//------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n//------------------------------------------------------------\n// complex number operations\n//------------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 clog( vec2 z) {return vec2 (log(sqrt(z.x*z.x+z.y*z.y)),atan(z.y,z.x));}\n//------------------------------------------------------------\n// https://en.wikipedia.org/wiki/Stereographic_projection\nvec4 inversestereographic(vec3 p)\n{\n    float r2 = 1.0+dot(p,p);\n    return vec4(2.0*p,r2-2.0)/r2;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/articles/biplanar\nvec3 tex( sampler2D sam, in vec4 p, in vec4 n )\n{\n    n = n*n;\n    n = n*n;\n    vec3 col = vec3(0.0);\n    col += n.x*texture(iChannel0,p.yz).xyz;\n    col += n.y*texture(iChannel0,p.zw).xyz;\n    col += n.z*texture(iChannel0,p.wx).xyz;\n    col += n.w*texture(iChannel0,p.xy).xyz;\n    return col / (n.x+n.y+n.z+n.w);\n}\n//===============================================================================================\n\nvec4 r3_to_s3( in vec3 p )\n{\n    vec4 q = inversestereographic(p);\n    \n    // rotate in yw\n    float a = iTime*6.283185/24.0;\n    //float a = 0.0;\n    q.yw *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    \n    return q;\n}\n\nvec2 F( in vec2 u, vec2 v )\n{\n    #if SHAPE==0\n    // figure-8\n    vec2 a = vec2(3.0,0.0) - 2.0*csqr(v) + 2.0*csqr(conj(v));\n    vec2 q = 64.0*cmul(u,csqr(u)) \n           - 12.0*cmul(u,a) \n           + 14.0*cmul(v,v) \n           + 14.0*csqr(conj(v)) \n           -      csqr(csqr(v)) \n           +      csqr(csqr(conj(v)));\n    return q;\n    #endif\n    \n    #if SHAPE==1\n    // torus\n    return 20.0*(cmul(u,csqr(csqr(u))) + csqr(v));\n    #endif    \n\n    #if SHAPE==2\n    // something I made\n    return    64.0*cmul(v,csqr(csqr(u)))\n           + 32.0*cmul(u,csqr(v))\n           + 32.0*csqr(v) \n           + 8.0;\n    #endif    \n\n}\n\nfloat field( in vec4 q )\n{\n    vec2 phi = F(q.xy,q.zw);\n    \n    #if PROFILE==0\n    //return length(phi) - 10.0;  \n    \n    //(1/4πi) log (Q/Q∗)  \n  //  return (length(cmul(vec2(0,0.785398163),clog(cdiv(phi,conj(phi))))));    \n    return abs(mod(((cmul(vec2(0,0.785398163),clog(cdiv(phi,conj(phi))))).x + iTime/3.14159265359),6.28318530718) - 0.5);\n    \n    \n    #else\n    return sdRoundSquare( phi, 8.0, 0.5 );\n    #endif\n}\n\n// only used for texturing, not for distance-estimation\nvec4 field_grad( in vec4 q )\n{\n    float f = field(q);\n    const vec2 e = vec2(0.001,0.0);\n    return normalize(vec4(\n        field(q+e.xyyy),\n        field(q+e.yxyy),\n        field(q+e.yyxy),\n        field(q+e.yyyx))-f );\n}\n\nfloat map( in vec3 p )\n{\n\n    float d = field(r3_to_s3(p));\n\n    // could do some automatic differentiation here...\n    float eps = 0.0001;\n    vec3 g = (vec3(field(r3_to_s3(p+vec3(eps,0.0,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,eps,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,0.0,eps))))-d)/eps;\n    \n    // distance estimator\n    return d/length(g);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    const float tmax = 5.0;\n    float t = 0.001;\n    float sh = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos);\n        sh = min( sh, clamp(k*h/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        t += clamp(h,0.001,0.1);\n        if( t>tmax ) break;\n    }\n    return sh;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = frand();\n        vec3 kv = normalize( vec3(frand(), frand(), frand()) );\n        kv *= sign(dot(kv,nor));\n\t\tao += clamp( map(pos+nor*0.001+kv*h*2.0)*1.0, 0.0, 1.0 );\n\t}\n\tao /= 32.0;\n\t\n\treturn clamp( ao*1.5-0.1, 0.0, 1.0 );\n}\n\n\n//logEps() put into subroutine\n//, to toggle between various LOD-scales (distance field zoom levels)\n//, to make it toggleAble (sometimes a simpler end condition is better)\nbool logEps(float d,float s//t=distanceToCamera s=numberOfmarchingIterations\n){if(1./exp(d)<.01)return s<.001;//better for short distance reflections\n  //above line fails within a tensor-distorted gradient...\n  return log(d*d/s/1e5)>0. //long distance logeps for spinor /tdXXzl\n ;}\n\n\nfloat marchLog(inout vec3 pos, inout vec3 dir  ,float tmax     \n){\n ;float s=0.\n ;float d=0.;\n ;vec3 p=pos//+1.*dir\n //pos//+1.*dir is optional zNear, logeps is a bit bad when camera is close to a wall\n //, this is easily avoided\n //logeps() shines in LONG distances, not as much in short distances (within large lipschitz)\n //i have plans for a [logNeps], which should be better ingeneral average fractals\n ;for(float i=0.;i<2000.;i++ //logeps is fine with 4x as many iterations, it unlikely needs half of them.\n //r3_to_s3():  could need more than 40000 iterations, but will have much lower framerates on it.\n ){if(logEps(d,s))return d\n  ;s=map(p)\n  ;d+=s*.02\n  //smaller value for r3_to_s3(): https://www.shadertoy.com/view/7sVXWK\n  //than for 2 spinors: https://www.shadertoy.com/view/tdXXzl\n  ;p=pos+dir*d\n ;}return 0.;}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n    // camera movement\t\n    float an = -0.0*iTime/20.0;\n    vec3 ro = vec3( 5.0*sin(6.283185*an), 4.0, 5.0*cos(6.283185*an) );\n    #if SHAPE>0\n    ro.xz *= 1.5;\n    ro.y = 0.0;\n    #endif\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n        \n\n        // raymarch\n        const float tmax = 15.0;\n        #ifdef doLogEps\n        float t=marchLog(ro,rd,tmax);//child march loop function.\n        #else\n        float t = 0.0;\n        for( int i=0; i<8192; i++ ){ //parent march loop;\n            vec3 pos = ro + rd*t;\n            float d = map(pos);\n            if( d<0.001 ) break;\n            d = min(d*0.8,0.1);\n            t += d;\n            if( t>tmax ) break;} \n        #endif\n        \n        vec3 col = vec3(0.0);\n        col = vec3(0.05 + 0.05*rd.y);\n        #ifdef doLogEps\n        if(map(ro+rd*t)<0.001 && t<tmax)//because logeps may end up in empty space on this much distortion\n       //t<tmax seems to NEVER be true for logeps, which is kinda sad.\n        #else\n        if( t<tmax)\n        #endif\n        {\n            vec3  pos = ro + rd*t;\n            vec3  nor = calcNormal( pos, 0.0001 );\n            float occ = calcAO( pos+nor*0.001, nor );\n\n            // we do texturing in R4\n            vec4 pos4 = r3_to_s3(  pos );\n            vec4 nor4 = field_grad( pos4 );\n            vec3 mate = tex(iChannel0,pos4,nor4);\n            mate = mate*mate;\n            mate *= 0.3;\n\n            // sun\n            {\n            vec3 lig = normalize(vec3(1.0,1.0,0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            if( dif>0.001 ) dif *= shadow(pos+nor*0.001, lig, 48.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = pow(clamp(dot(nor,hal),00.,1.0),32.0);\n            spe *= 0.04 + 0.96*pow( clamp(1.0-dot(lig,hal), 0.0, 1.0), 5.0 );\n            spe *= 10.0;\n\n            col  = 0.6*mate*vec3(9.0,8.0,7.0)*dif;\n            col += spe*dif*mate.x*10.0;\n            \n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            col += mate*fre*1.0*(0.25+0.75*dif)*vec3(1.0,0.7,0.4);\n            }\n            \n            // sky\n            {\n            vec3 ref = reflect(rd,nor);\n            float dif = 0.5+0.5*nor.y;\n            float spe = smoothstep(0.3,0.5,ref.y);\n            spe *= dif;\n            spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n            if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref, 8.0);\n            col += 3.0*occ*mate*dif*vec3(0.5,0.6,1.0)*1.5;\n            col += 1.0*spe;\n            }\n\n            // sun bounce\n            col += mate*(1.0-occ)*vec3(1.2,0.5,0.2)*0.2;\n        }\n        \n        // gain\n        col = col*1.5/(1.0+col);\n        \n        // to gamma space\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // remove color banding through dithering\n    tot += (1.0/255.0)*frand();\n \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}