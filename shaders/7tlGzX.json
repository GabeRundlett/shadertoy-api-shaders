{
    "Shader": {
        "info": {
            "date": "1622728123",
            "description": "A simple polar pattern rendered in a faux 3D monochromatic ink sketch style.",
            "flags": 0,
            "hasliked": 0,
            "id": "7tlGzX",
            "likes": 22,
            "name": "Geometric Polar Pattern",
            "published": 3,
            "tags": [
                "2d",
                "repetition",
                "pattern",
                "polar",
                "faux"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 641
        },
        "renderpass": [
            {
                "code": "/*\n\n\tGeometric Polar Pattern\n\t-----------------------\n\n\tI'm sure people have seen variations on this particular faux 3D pattern all \n    over the place. Artsy folk producing tangle patterns and so forth sketch \n    these out on paper all the time. For anyone looking for a reference image,\n    I believe the pattern is referred to as an optical art (op art) bullseye.\n    \n    Anyway, here it is in 2D procedural form. Not a lot of effort went into it\n    at all, so I'm sure there'd be better ways to get the job done. In any case,\n    it works well enough and was very easy to make. In case it isn't obvious, \n    the background is partitioned into polar cells, then the stripes are rendered \n    using angular and radial coordinates. Fake shading is applied, etc, to finish \n    things off. I'll leave the shortened version to the code golfing crowd. :)\n    \n    By the way, you could render this pretty easily using 3D techniques too. I \n    might do that at some stage, just for the fun of it, unless someone else \n    feels like giving it a go. :)\n\n\n    Related examples:\n\n    // An unlisted bare bones polar coordinate example, for \n\t// anyone who's not quite sure how the polar thing works.\n    Polar Repetition - Shane\n\thttps://www.shadertoy.com/view/wdtGDM\n\n\n*/\n\n\n// Number of cells. Only intergers will work properly.\n#define CELL_NUM 10.\n\n// Monochrome or alternating color.\n#define MONOCHROME\n\n// Faux sunset styled colored lighting.\n#define COLORED_LIGHTING\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// Repeat 2x2 hash algorithm.\nvec2 hash22G(vec2 p, vec2 repScale) {\n\n    p = mod(p, repScale);\n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(1, 113)));\n    return fract(vec2(2097152, 262144)*n)*2. - 1.;\n    \n    //p = fract(vec2(2097152, 262144)*n)*2. - 1.;\n    //return sin(p*6.283 + iTime*8.);\n\n}\n\n// Gradient noise: Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f, vec2 repScale){\n  \n   f *= repScale;\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    //vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22G(p + e.xx, repScale), f - e.xx), dot(hash22G(p + e.yx, repScale), f - e.yx), w.x),\n                  mix(dot(hash22G(p + e.xy, repScale), f - e.xy), dot(hash22G(p + e.yy, repScale), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec2 p, vec2 repScale){\n    \n    // Four layers.\n    return gradN2D(p, repScale)*.57 + gradN2D(p, repScale*2.)*.28 + gradN2D(p, repScale*4.)*.15;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float iRes = iResolution.y;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/iRes;\n \n    // Falloff factor: Sometimes,  we might have to use \"fwidth(d),\" \n    // a numeric solution, or use a constant.\n    float sf = 1./iRes; \n    \n    // Scaling... Trivial in this case.\n    vec2 p = uv - vec2(-1./4., -1./16.) - vec2(cos(iTime/4.)/12., sin(iTime/3.)/16.);\n    \n     \n    // Canvas rotation.\n    p *= r2(-iTime/16.);\n    \n    // Slight noise coordinate perturbation for that sketchy look.\n    p += (vec2(gradN2D(p, vec2(40)), gradN2D(p + .36, vec2(40))) - .5)*.005;\n    \n    vec2 op = p;\n    \n    \n    // Background noise to be mixed in later.\n    float ns = fBm(p, vec2(128));\n\t\n    // Polar angle.\n    float a = atan(p.y, p.x);\n    \n    \n    // Partitioning the angle into the number of cells.\n    float ia = floor(a/6.2831853*CELL_NUM);\n \n    \n    // Variable to determine alternate cells... Only useful for even cell numbers.\n    float dir = mod(ia, 2.)<.5? -1. : 1.;\n\n    \n    // Converting square coordinates to polar ones. I.e. Angular and radial.\n    p *= r2(a);\n    // Above is equivalent to:\n    //p = vec2(p.x*cos(ia) + p.y*sin(ia), p.y*cos(ia) - p.x*sin(ia));\n    \n\n    // RENDERING  \n\n    \n    // Used for things like shading.\n    float sinFunc = sin(a*CELL_NUM/2.);\n    \n    // Radial rings.\n    const float rNum = 5.;\n    float wf = dir<0.? .1 : .05; // Ring warp factor.\n    //\n    // Cell stripes: There'd be other ways to do this, but this works well enough.\n    float ring = mod(p.x + sinFunc*length(p)*wf + .25/rNum*dir, 1./rNum) - 1./rNum/2.;\n    ring = abs(ring) - 1./rNum/4.;//*min(.65 + length(p)*.4, 1.5);\n    \n    \n    // Alternate cell shading.\n    vec3 col1 = vec3(1, .95, .9)/6., col2 = vec3(1, .95, .9);\n    //\n    // Black and white, or is it white and black? :)\n    if(dir>0.) {\n        col1 = vec3(1, .95, .9)/8.;\n        #ifdef MONOCHROME\n        col2 = vec3(1, .95, .9);\n        #else\n        col2 = mix(vec3(1, .3, .2), vec3(.3, .4, 1), p.x);\n        #endif\n    }\n\n    \n    // Rendering alternating stripes.\n    vec3 col = mix(col1, vec3(0),  (1. - smoothstep(0., sf*16., ring - .005))*.7);\n    col = mix(col, col2*1.5,  1. - smoothstep(0., sf*2., ring));\n    col = mix(col, col2,  1. - smoothstep(0., sf*2., ring + .008));\n    \n    // Tweaking.\n    col = col*.92 + .03;\n    \n    \n    // Angular shading between cells to give a fake rounded appearance.\n    col *= smoothstep(0., .25, abs(sinFunc));\n    col *= smoothstep(0., 1., abs(sinFunc))*.9 + .1;\n\n    // Polar noise.\n    vec2 pol = vec2(a/6.2831*32. - iTime/18., p.x*2.);\n    float pns = fBm(pol, vec2(32., 4));\n    pns = smoothstep(0., .05/clamp(length(p), .001, .5), pns - .49); \n    //\n    // Using the polar noise to put dark sketch noise at the cell edges and \n    // white in the centers.\n    col = mix(col, max(col - pns, 0.), 1. - smoothstep(0., 1., abs(sinFunc)));\n    col = mix(col, col + col*pns*2., 1. - smoothstep(0., .1, 1. - abs(sinFunc)));\n    \n    // More overall gradient FBM noise.\n    col *= smoothstep(0., .85, ns) + .4;\n   \n    // Extra coloring.\n    col *= vec3(1, .98, .95);\n    #ifdef COLORED_LIGHTING\n    // Colored blue and orange angular shading for the fake environmental sunset look.\n    col *= mix(vec3(.3, .6, 1), vec3(1, .5, .2), sin(a*CELL_NUM - .7))*.7 + .4;\n    #endif\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.) + .05;\n    // Colored variation.\n    //col = mix(col.xzy, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}