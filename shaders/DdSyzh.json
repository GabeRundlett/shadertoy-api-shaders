{
    "Shader": {
        "info": {
            "date": "1687383470",
            "description": "Ball bearing. PBR code in common was taken from https://www.shadertoy.com/view/ld3SRr. Replaced 2d roughness texture with 3d to make it stick to the surface.",
            "flags": 0,
            "hasliked": 0,
            "id": "DdSyzh",
            "likes": 13,
            "name": "Ball bearing",
            "published": 3,
            "tags": [
                "sdf",
                "metal",
                "pbr",
                "bearing"
            ],
            "usePreview": 0,
            "username": "AndrewB330",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "const float M_PI = 3.1415926535;\nconst vec3 L = normalize(vec3(1.0, 1.0, 1.0));\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec2 rot(vec2 v, float a)\n{\n    return vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a));\n}\n\nconst mat3 m1 = mat3(0.61, 0.12, 0.78, 0.04, 0.98, -0.18, -0.79, 0.14, 0.59);\nconst mat3 m2 = mat3(0.44, 0.87, 0.2, -0.74, 0.23, 0.63, 0.50, -0.43, 0.75);\n   \nfloat texture_metal(vec3 p)\n{\n    float r = 0.0;\n    p *= 2.0;\n    float rr = noise(p * 4.0) + noise(p * 8.0) * 0.5 + noise(p * 16.0) * 0.25;\n    r += pow(saturate(rr * 0.7 - 0.2), 4.0);\n    vec3 scale = vec3(15, 3, 3);\n    for (int i = 0; i < 5; i++)\n    {\n        scale *= 1.5;\n        p += 0.2;\n        r = max(r, pow(noise(p * scale), 24.0) * 0.7);\n        p *= m2;\n        r = max(r, pow(noise(p * scale), 24.0) * 0.5);\n        p *= m1;\n        r = max(r, pow(noise(p * scale), 24.0) * 0.6);\n        p *= m2;\n        r = max(r, pow(noise(p * scale), 24.0) * 0.8);\n    }\n    return saturate(r);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdShell(vec3 p, float d, float r, float r1)\n{\n    vec2 pp = vec2(length(p.xy) - r, p.z);\n    return max(min(sdBox(pp + vec2(r1, 0), vec2(r1 * 0.3, d)),\n                   sdBox(pp - vec2(r1, 0), vec2(r1 * 0.3, d))),\n                   -(length(pp) - r1));\n}\n\nconst float r = 1.0, r1 = 0.2;\nconst float w0 = 0.8;\nconst float w2 = 0.3;\nconst float wc = ((w2 * (r + r1) + w0 * (r - r1)) * 0.5) / r;\nconst float wcc = ((w2 * (r + r1) - w0 * (r - r1) ) * 0.5) / r1;\n\nvec2 calc_w(vec2 w)\n{\n    w *= vec2(r - r1, r + r1);\n    return vec2(w.y + w.x, w.y - w.x) * 0.5 / vec2(r, r1);\n}\n\nvec3 camera(vec3 p)\n{\n    p.xz = rot(p.xz, sin(iTime) * 0.8);\n    p.yz = rot(p.yz, 0.6);\n    return p;\n}\n\nvec2 get_w()\n{\n    float a = 0.22;\n    return vec2((1.5 * iTime + 2. * cos(a * iTime) / a + 0.25 * cos(2. * a * iTime) / a) * 2.0, cos(iTime) * 0.5);\n}\n\n#define setup() vec2 w = get_w();vec2 wc = calc_w(w);p = camera(p);\n\nfloat map_scene(vec3 p)\n{\n    setup();\n    \n    float sdf = sdShell(p, 0.2, r, r1);\n    p.xy = rot(p.xy, wc.x);\n    for (int i = 0; i < 12; i++)\n    {\n        p.xy = rot(p.xy, 2. * M_PI / 12.0);\n        sdf = min(sdf, sdSphere(p + vec3(1, 0, 0), r1 * 0.95));\n    }\n    \n    return sdf;\n}\n\nfloat map_roughness(vec3 p)\n{\n    setup();\n    \n    float sdf = sdShell(p, 0.2, r, r1);\n    float res = texture_metal(vec3(rot(p.xy, (length(p.xy) < r ? w.x : w.y)), p.z));\n    \n    p.xy = rot(p.xy, wc.x);\n    for (int i = 0; i < 12; i++)\n    {\n        p.xy = rot(p.xy, 2. * M_PI / 12.0);\n        vec3 pp = p + vec3(1, 0, 0);\n        pp.xy = rot(pp.xy, wc.y);\n        float sd = sdSphere(pp, r1 * 0.95);\n        res = mix(res, texture_metal(pp), step(sd, sdf));\n    }\n    \n    return res;\n}\n\nvec2 trace(vec3 origin, vec3 dir)\n{\n    float t = 0.;\n    for (int i = 0; i < 48 && origin.z > -6.0; i++)\n    {\n        float h = map_scene(origin);\n        origin += dir * h;\n        t += h;\n        if (h < 0.01)\n        {\n            return vec2(map_roughness(origin), t);\n        }\n    }\n\n    return vec2(-1.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.005;\n    return normalize(e.xyy*map_scene(pos + e.xyy) +\n\t\t\t\t\t e.yyx*map_scene(pos + e.yyx) +\n\t\t\t\t\t e.yxy*map_scene(pos + e.yxy) +\n\t\t\t\t\t e.xxx*map_scene(pos + e.xxx));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = normalize(vec3(fragCoord - .5* iResolution.xy, -iResolution.y ));\n    vec3 origin = vec3(0, -0.3, 2.1);\n    fragColor = texture(iChannel2, dir);\n    \n    \n    vec2 res = trace(origin, dir);\n    if (res.y > 0.)\n    {\n        vec3 p = origin + res.y * dir;\n        vec3 v = normalize(p - origin);\n        vec3 n = calcNormal(p);\n        fragColor.rgb = pow(MAT_apply(p, res.y, dir, n, res.x, \n                                      MATERIALID_SPHERE, iChannel2, iChannel3) * 2.0 * vec3(1, 0.9, 0.7),vec3(1./2.2));\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define saturate(x) clamp(x,0.0,1.0)\n\n// PBR Code from https://www.shadertoy.com/view/ld3SRr\nconst int MATERIALID_SKY    = 2;\nconst int MATERIALID_SPHERE = 3;\nconst vec3  F_ALU_N  = vec3(1.600,0.912,0.695); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst vec3  F_ALU_K  = vec3(8.010,6.500,5.800); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nfloat ROUGHNESS_AMOUNT       = 0.85;//Valid range : [0-1] 0=shiny, 1=rough map\nfloat SKY_COLOR              = 0.0; //[0.0=Red, 1.0=Blue)\nfloat ABL_LIGHT_CONTRIBUTION = 0.0; //[0-1] Additional ABL Light Contribution\n\nvec3 PBR_Equation(vec3 V, vec3 L, vec3 N, float roughness, const vec3 ior_n, const vec3 ior_k, const bool metallic, const bool bIBL)\n{\n    float cosT = saturate( dot(L, N) );\n    float sinT = sqrt( 1.0 - cosT * cosT);\n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n    //Distribution Term\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = 1.0; //Distribution term is externalized from IBL version\n    if(!bIBL)\n        D = (NdotH>0.)?alpha2/(PI*den*den):0.0; //GGX Distribution.\n\t\n    //Fresnel Term\n\tvec3 F;\n    if(metallic)\n    {\n        float cos_theta = 1.0-NdotV;\n        F =  ((ior_n-1.)*(ior_n-1.)+ior_k*ior_k+4.*ior_n*pow(1.-cos_theta,5.))\n\t\t    /((ior_n+1.)*(ior_n+1.)+ior_k*ior_k);\n    }\n    else //Dielectric (Note: R/G/B do not really differ for dielectric materials)\n    {\n        float F0 = pow((1.0 - ior_n.x) / (1.0 + ior_n.x),2.0);\n  \t\tF = vec3(F0 + (1.-F0) * pow( 1. - VdotH, 5.));\n    }\n    \n    //Geometric term (Source: Real Shading in Unreal Engine 4 2013 Siggraph Presentation p.3/59)\n    //k = Schlick model (IBL) : Disney's modification to reduce hotness (point light)\n    float k = bIBL?(roughness*roughness/2.0):(roughness+1.)*(roughness+1.)/8.; \n    float Gl = max(NdotL,0.)/(NdotL*(1.0-k)+k);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-k)+k);\n    float G = Gl*Gv;\n    \n    float softTr = 0.1; // Valid range : [0.001-0.25]. Transition softness factor, close from dot(L,N) ~= 0\n    float angleLim = 0.;//2.75; // Valid range : [0-0.75]. Compensates for IBL integration suface size.\n    //sinT = 1.;\n    if(bIBL)\n        return (F*G*(angleLim+sinT)/(angleLim+1.0) / (4.*NdotV*saturate(NdotH)*(1.0-softTr)+softTr));\n    else\n        return D*F*G / (4.*NdotV*NdotL*(1.0-softTr)+softTr);\n}\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    vec3 cRedSky   = mix(c,1.3*vec3(4.5,2.5,2.0),fHDR);\n    vec3 cBlueSky  = mix(c,1.8*vec3(2.0,2.5,3.0),fHDR);\n    return mix(cRedSky,cBlueSky,SKY_COLOR);\n}\n\nvec3 PBR_HDRCubemap(vec3 sampleDir, float LOD_01, samplerCube iChannel2, samplerCube iChannel3)\n{\n    vec3 linearGammaColor_sharp = PBR_HDRremap(pow(texture( iChannel2, sampleDir ).rgb,vec3(2.2)));\n    vec3 linearGammaColor_blur  = PBR_HDRremap(pow(texture( iChannel3, sampleDir ).rgb,vec3(1)));\n    vec3 linearGammaColor = mix(linearGammaColor_sharp,linearGammaColor_blur,saturate(LOD_01));\n    return linearGammaColor;\n}\n\n//Arbitrary axis rotation (around u, normalized)\nmat3 PBR_axisRotationMatrix( vec3 u, float ct, float st ) //u=axis, co=cos(t), st=sin(t)\n{\n    return mat3(  ct+u.x*u.x*(1.-ct),     u.x*u.y*(1.-ct)-u.z*st, u.x*u.z*(1.-ct)+u.y*st,\n\t              u.y*u.x*(1.-ct)+u.z*st, ct+u.y*u.y*(1.-ct),     u.y*u.z*(1.-ct)-u.x*st,\n\t              u.z*u.x*(1.-ct)-u.y*st, u.z*u.y*(1.-ct)+u.x*st, ct+u.z*u.z*(1.-ct) );\n}\n\nvec3 PBR_importanceSampling(vec3 sampleDir, float roughness, float e1, float e2, out float range)\n{\n    const float PI = 3.14159;\n    range = atan( roughness*sqrt(e1)/sqrt(1.0-e1) );\n    float phi = 2.0*PI*e2;\n    //Improve this? https://blog.selfshadow.com/2011/10/17/perp-vectors/\n    vec3 notColinear   = (abs(sampleDir.y)<0.8)?vec3(0,1,0):vec3(1,0,0);\n    vec3 othogonalAxis = normalize(cross(notColinear,sampleDir));\n\tmat3 m1 = PBR_axisRotationMatrix(normalize(othogonalAxis), cos(range), sin(range));\n\tmat3 m2 = PBR_axisRotationMatrix(normalize(sampleDir),     cos(phi),   sin(phi));\n\treturn sampleDir*m1*m2;\n}\n\nvec3 PBR_visitSamples(vec3 V, vec3 N, float roughness, bool metallic, vec3 ior_n, vec3 ior_k, samplerCube iChannel2, samplerCube iChannel3)\n{\n    const float MIPMAP_SWITCH  = 0.29; //sampling angle delta (rad) equivalent to the lowest LOD.\n    const ivec2 SAMPLE_COUNT = ivec2(05,15); //(5 random, 15 fixed) samples\n    const vec2 weight = vec2(1./float(SAMPLE_COUNT.x),1./float(SAMPLE_COUNT.y));\n    float angularRange = 0.;    \n    vec3 vCenter = reflect(-V,N);\n    \n    //Randomized Samples : more realistic, but jittery\n    float randomness_range = 0.75; //Cover only the closest 75% of the distribution. Reduces range, but improves stability.\n    float fIdx = 0.0;              //valid range = [0.5-1.0]. Note : it is physically correct at 1.0.\n    vec3 totalRandom = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[0]; ++i)\n    {\n        //Random noise from DaveHoskin's hash without sine : https://www.shadertoy.com/view/4djSRW\n        vec3 p3 = fract(vec3(fIdx*10.0+vCenter.xyx*100.0) * vec3(.1031,.11369,.13787)); \n    \tp3 += dot(p3.zxy, p3.yzx+19.19);\n    \tvec2 jitter = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x*randomness_range, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH, iChannel2, iChannel3);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[0];\n    \ttotalRandom += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    //Fixed Samples : More stable, but can create sampling pattern artifacts (revealing the sampling pattern)\n    fIdx = 0.0;\n    vec3 totalFixed = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[1]; ++i)\n    {\n        vec2 jitter = vec2( clamp(weight[1]*fIdx,0.0,0.50), fract(weight[1]*fIdx*1.25)+3.14*fIdx); //Fixed sampling pattern.\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH, iChannel2, iChannel3);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[1];\n        totalFixed += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    return (totalRandom*weight[1]+totalFixed*weight[0])/(weight[0]+weight[1]);\n}\n\n//The main material function.\nvec3 MAT_apply(vec3 pos, float rayLen, vec3 rayDir, vec3 N, float roughness, int matID, samplerCube iChannel2, samplerCube iChannel3)\n{\n    vec3 V = normalize(-rayDir);\n    vec3 L = normalize(vec3(1,1,0));\n    vec3 col = PBR_visitSamples(V,N,roughness, true, F_ALU_N, F_ALU_K, iChannel2, iChannel3);\n    vec3 L0  = PBR_Equation(V,L,N,roughness+0.01, F_ALU_N, F_ALU_K, true, false);\n    col     += PBR_HDRremap(vec3(1))*L0*ABL_LIGHT_CONTRIBUTION;\n    \n    //Anti-aliasing trick (normal-based)\n    vec3 backgroundColor = pow(texture( iChannel2, rayDir ).xyz,vec3(2.2));\n    float aaAmount = 0.095;\n    float smoothFactor = 1.0-clamp(-dot(N,rayDir)/(aaAmount), 0.0, 1.0);\n    col = (dot(N,-rayDir)<aaAmount)? mix(col, backgroundColor, smoothFactor) : col;\n    \n    return matID==MATERIALID_SKY?backgroundColor:col;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}