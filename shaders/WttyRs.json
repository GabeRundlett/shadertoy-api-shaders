{
    "Shader": {
        "info": {
            "date": "1609723363",
            "description": "experimental SDF\nmouse rotates form",
            "flags": 0,
            "hasliked": 0,
            "id": "WttyRs",
            "likes": 2,
            "name": "Gantz Galaga 007",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "experimental",
                "white"
            ],
            "usePreview": 0,
            "username": "MacroMachines",
            "viewed": 248
        },
        "renderpass": [
            {
                "code": "//__________________________________________________\n/////////////////////////      SDF RAY MARCHING 1.2  \n////////////////////////////////////////////////////\n//varying lowp vec4 colorVarying;\n//varying vec2 tc;\n//varying vec4 glPos;\n//uniform float time;\n//uniform vec2 Rotate;\n//uniform vec3 Warp;\n//uniform float size;\n//uniform vec2 touchCoordinates[10];\n//touchCoordinates[0];\n//#define tc gl_FragCoord\n//#define res iResolution\n//vec2( 1366., 1024. );\n//#define uvscale res.x/res.y\n//#define uv vec2(((tc.x * 2.0 - 1.0)*res.x/res.y),tc.y * 2.0 - 1.0);\n\n\nprecision highp float;\nfloat size = 1.0;\n#define time iTime*0.33\n#define touch iMouse.xy\n#define ti time * 0.1\n\n#define BPM 128.0\n#define SEC_PER_MIN 60.0\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define v3 vec3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstruct RAY{\n   vec3 origin, direction;\n};\nstruct HIT{\n   bool intersect;\n   vec3 point, color, normal;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {   return (x<0.)?-1.:1.;}\nvec2 sgn(vec2 v) {   return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);}\nfloat square (float x) {   return x*x;}\nvec2 square (vec2 x) {   return x*x;}\nvec3 square (vec3 x) {   return x*x;}\nfloat lengthSqr(vec3 x) {   return dot(x, x);}\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {   return max(v.x, v.y);}\nfloat vmax(vec3 v) {   return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {   return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {   return min(v.x, v.y);}\nfloat vmin(vec3 v) {   return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {   return min(min(v.x, v.y), min(v.z, v.w));}\n\n\n//......................................... transform \n/////////////////////////////////////////////////////\nmat2 rotate( float a ) {\n   float cs = cos(a);\n   float si = sin(a);\n   return mat2(cs, -si, si, cs);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n   return length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n   return dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n   return vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n   vec3 d = abs(p) - b;\n   return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n   return vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n   vec2 d = abs(p) - b;\n   return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n   return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n   p = abs(p);\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   float b = max(max(max(\n      dot(p, normalize(vec3(1., 1., 1.))),\n      dot(p.xz, normalize(vec2(PHI+1., 1.)))),\n      dot(p.yx, normalize(vec2(1., PHI)))),\n      dot(p.xz, normalize(vec2(1., PHI))));\n   float l = length(p);\n   return l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n   float d = length(p.xz) - r;\n   d = max(d, abs(p.y) - height);\n   return d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n   return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n   vec3 ab = b - a;\n   float t = saturate(dot(p - a, ab) / dot(ab, ab));\n   return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n   return fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n   return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n   vec3 q = abs(p);\n   return max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n   //this is mathematically equivalent to this line, but less efficient:\n   //return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n   return fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n   vec2 q = vec2(length(p.xz), p.y);\n   vec2 tip = q - vec2(0, height);\n   vec2 mantleDir = normalize(vec2(height, radius));\n   float mantle = dot(tip, mantleDir);\n   float d = max(mantle, -q.y);\n   float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n   \n   // distance to tip\n   if ((q.y > height) && (projected < 0.)) {\n      d = max(d, length(tip));\n   }\n   \n   // distance to base ring\n   if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n      d = max(d, length(q - vec2(radius, 0.)));\n   }\n   return d;\n}\n\n//......................................... 3d forms \n////////////////////////////////////////////////////\nfloat sphere (vec3 p, float s){\n   return length(p) - s;\n}\nfloat box(vec3 p, vec3 b){\n   return length(max(abs(p)-b, 0.0));\n}\nfloat rbox(vec3 p, vec3 b, float r){\n   return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//........................................... deform \n////////////////////////////////////////////////////\nfloat displace(vec3 p){\n   float d1 = rbox(p, v3(0.25), 0.20);\n   //float d2 = sphere(p, 0.5);\n   float sz = 8.0;\n   float d2 = sin(sz*p.x)*sin(sz*p.y)*sin(sz*p.z);\n   return d1+d2;\n}\n//............................................ domain \n/////////////////////////////////////////////////////\nfloat rep( vec3 p, vec3 c){\n   vec3 q = mod(p, c) -0.5*c;\n   q.xy *= rotate(time);\n   vec3 c2 = c*3.0*cos(time*0.33);\n   vec3 q2 = mod(p, c2) -0.5*c2;\n   vec3 q3 = mod(p, c*0.25) - 0.125*c;\n   //return displace(p);//\n   float rp = min(box(q2, vec3(cos(time+q3.z)*2.0, cos(p.z+time*0.5)*0.5, 1.0)),\n         rbox(q, fract(p.y+time*.1)*v3(size*0.125,0.05,0.1), 0.05));\n   rp = min(rp, sphere(q3, sin(p.x+time)*0.05));\n   return rp;\n}\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n   p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n   p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize,size) - halfsize;\n   p *= mod(c, 2.0)*2. - 1.;\n   return c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   if (p >= 0.)\n      p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p+halfsize, size) - halfsize;\n   if (c > stop) { //yes, this might not be the best thing numerically.\n      p += size*(c - stop);\n      c = stop;\n   }\n   if (c <start) {\n      p += size*(c - start);\n      c = start;\n   }\n   return c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n   float angle = 2.*PI/repetitions;\n   float a = atan(p.y, p.x) + angle/2.;\n   float r = length(p);\n   float c = floor(a/angle);\n   a = mod(a,angle) - angle/2.;\n   p = vec2(cos(a), sin(a))*r;\n   // For an odd number of repetitions, fix cell index of the cell in -x direction\n   // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n   if (abs(c) >= (repetitions/2.)) c = abs(c);\n   return c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5,size) - size*0.5;\n   return c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n   vec2 halfsize = size*0.5;\n   vec2 c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   p *= mod(c,vec2(2.))*2. - vec2(1.);\n   return c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   p *= mod(c,vec2(2))*2. - vec2(1.);\n   p -= size/2.;\n   if (p.x > p.y) p.xy = p.yx;\n   return floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n   vec3 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   return c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n   float s = sgn(p);\n   p = abs(p)-dist;\n   return s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n   vec2 s = sgn(p);\n   pMirror(p.x, dist.x);\n   pMirror(p.y, dist.y);\n   if (p.y > p.x)\n      p.xy = p.yx;\n   return s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n   float t = dot(p, planeNormal)+offset;\n   if (t < 0.) {\n      p = p - (2.*t)*planeNormal;\n   }\n   return sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n   return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n   return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n   return fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r - a,r - b), vec2(0.));\n   return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r + a,r + b), vec2(0.));\n   return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n   return fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n      pR45(p);\n      p.x -= sqrt(2.)/2.*r;\n      p.x += columnradius*sqrt(2.);\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      // At this point, we have turned 45 degrees and moved at a point on the\n      // diagonal that we want to place the columns on.\n      // Now, repeat the domain along this direction and place a circle.\n      pMod1(p.y, columnradius*2.);\n      float result = length(p) - columnradius;\n      result = min(result, p.x);\n      result = min(result, a);\n      return min(result, b);\n   } else {\n      return min(a, b);\n   }\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n   a = -a;\n   float m = min(a, b);\n   //avoid the expensive computation where not needed (produces discontinuity though)\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/n/2.0;\n      columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n      pR45(p);\n      p.y += columnradius;\n      p.x -= sqrt(2.)/2.*r;\n      p.x += -columnradius*sqrt(2.)/2.;\n\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      pMod1(p.y,columnradius*2.);\n\n      float result = -length(p) + columnradius;\n      result = max(result, p.x);\n      result = min(result, a);\n      return -min(result, b);\n   } else {\n      return -m;\n   }\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n   return fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n   float s = r/n;\n   float u = b-r;\n   return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n   float e = max(r - abs(a - b), 0.);\n   return min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n   return length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n   return max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n   return max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n   return min(a, max(a - ra, abs(b) - rb));\n}\n\n\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n\n\n\n//............................................. piston \n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nfloat piston(vec3 p) {\n   float sc, sc2, sc3, sc4, sc5;\n   vec3 p2 = p, p3 = p;\n   pModPolar(p2.yz, 3.0);\n   sc = fCylinder(p2, 0.25, 0.25);\n   sc2 = fCylinder(p2+v3(sin(time)*0.25, 0.0, 0.0), 0.125, 0.5);\n   //sc3 = fOpUnionChamfer(sc, sc2, 0.125);\n   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);\n   pR(p3.xy, 1.5);\n   sc4 = fCylinder(p3, 0.25, 0.5);\n   sc5 = fOpDifferenceColumns( sc3, sc4, 0.05, 4.0);\n   sc5 = fOpGroove(sc5, sc2, 0.1, 0.1);\n   return sc5;\n}\n\n\n//.............................................nut \n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nfloat nut(vec3 p) {\n   \n   float sc, sc2, sc3, sc4, sc5;\n   vec3 p2 = p, p3 = p;\n   pModPolar(p2.yz, 6.0);\n   sc = fBox(p2, v3(0.25));\n   sc2 = fBox(p2-v3(0.125, 0.0, 0.0), v3(0.125, 0.5, 0.250));\n   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);\n   pR(p3.xy, 1.5);\n   sc4 = fCylinder(p3, 0.25, 0.5);\n   sc5 = fOpDifferenceColumns( sc3, sc4, 0.05, 4.0);\n   sc5 = fOpGroove(sc5, sc2, 0.1, 0.1);\n   return sc5;\n}\n\n//............................................. scene \n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nfloat scene(vec3 p) {\n   //pR45(p.xz);\n   pR(p.xz, touch.x*0.01); //time);\n   pR(p.yz, touch.y*0.01);\n   float sc, sc2, sc3, sc4, sc5;\n   vec3 p2 = p, p3 = p;\n   //p2.y+=cos(time);\n   \n   float decayExp = fract(time*4.0)*fract(time);\n   decayExp = pow(decayExp,3.0);\n   float decayExp2 = fract(time*1.125);\n   decayExp = pow(decayExp,2.0);\n   \n   pMirrorOctant(p2.yz, vec2(decayExp*0.250,-decayExp2*0.25));\n   pModPolar(p2.yz, 6.0);\n   p2 += v3(0.0, cos(time)*0.25, 0.0);\n   sc = piston(p2);\n   sc2 = nut(p);\n   //sc /= fCylinder(p2, 0.25, 0.5);\n   //sc2 = fCylinder(p2+v3(0.25, 0.0, 0.0), 0.125, 0.5);\n   //sc3 = fOpUnionChamfer(sc, sc2, 0.125);\n   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);\n   pR(p3.xy, 1.5);\n   sc4 = fCylinder(p3, 0.25, 0.05);\n   sc5 = fOpEngrave( sc3, sc4, 0.25);\n   p*= 2.0;\n   vec3 p4 = pMod3(p,v3(1.0,2.0,0.50));\n   float sco = fOpPipe(sc3, fBox(p,abs(fract(p2))), 0.01);//0.1);\n   sco = min(sco, sco*1.25);\nsco = min(sco, sco*1.25);\nsco = min(sco, sco*1.25);\nsco = min(sco, sco*1.25);\n\n\nreturn sco;\n}\n\n//............................................. render \n//////////////////////////////////////////////////////\nfloat map(vec3 p) {\n   return scene(p);\n}\nvec3 grad(vec3 p) {\n   vec2 q = vec2 (0.0, EPS);\n   return vec3(map(p + q.yxx) - map(p - q.yxx),\n               map(p + q.xyx) - map(p - q.xyx),\n               map(p + q.xxy) - map(p - q.xxy));\n}\nvec3 shade(vec3 origin, vec3 ray, float traced) {\n   return normalize(grad(origin+traced*ray));\n}\n\nfloat trace(vec3 origin, vec3 ray, \n      inout vec3 normal, inout float shadow){ \n\n   float intersect = 0.1;\n   //if( distance(origin, ray) < ){//scene(origin+ray) > 0.5 ){\n   for(int i = 0; i < STEPS; i++){\n\n      vec3 pos = origin + ray * intersect;\n      if (fSphere(pos-v3(0.0,0.0,1.01),1.5)>0.0){return 0.0;}\n\n      float dist = scene(pos);\n      if(dist < 0.01){\n         normal = shade(origin, ray, intersect);\n         return intersect;\n         return float(i) / float(STEPS);\n         //return intersect;\n      }\n      //if(dot(pos, v3(0.10))>0.1) {return 0.0;}\n      intersect += dist * 0.50;\n   }\n\n   normal = vec3(0.0);\n   return 0.0;\n}\n/*\nfloat trace(vec3 position, vec3 direction){\n    float traced = 0.0;\n    for(int i = 0; i < STEPS; i++){\n        float distance = scene(position);\n        if(distance<EPS) {return  float(i) / float(STEPS);}\n        position += distance * direction;\n    }\n    return traced;\n}\n*/\n\n#define gl_FragColor fragColor\n//............................................. main \n////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 color = vec3(0.094,0.027,0.192);//, 1.0);\n   \n   // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord/iResolution.xy;\n   uv = uv*2.0-1.0;\n   \n   vec3 o;// = vec3(0.,0.,-2.);\n   o = vec3(0.0, 0.0, 1.0);\n   \n   vec3 r = (vec3(uv, -1.0));\n\n   //move camera\n   //r.xz *= rotate(Rotate.x*ti);//ti);\n   //o.z  += ti*4.0;\n   //o.xy += sin(time*.05267)*8.0-4.0;\n   //o.xy += touch.xy*8.0-4.0;\n   //r += sin(vec3(0.2*time)*Warp);\n\n   //o.xy +=  10.0*(touchCoordinates[0]);\n   \n   vec3 normal = vec3(0.0);\n   float shadow;\n   float t = trace(o, r, normal, shadow);\n\n   float fog = 1.0 / (1.0 + t*t* 0.1);\n   vec3 fc = vec3(fog);\n   \n   vec3 lightPos = vec3(-3.15008,-0.02,-1.051);\n   \n   pR(lightPos.xz, tan(fract(time)*8.0));\n\n   float light = dot( lightPos, normal);\n   float spec = fract(pow(light,0.080));\n   \n\n   //fractal(gl_FragColor, tc*vec2(1.0,res.x/res.y));\n   gl_FragColor.rgb = vec3(t>0.0?1.0:0.0);//light+t); \n   gl_FragColor.a = 1.0;\n\n   gl_FragColor = vec4( \n               vec3(fc + fc * (color-fog)) * \n                   0.5*light + \n                   0.5*(1.0-fog) + \n                   0.04*spec, \n                   1.0) \n                   + vec4(1.50-fog);\n   //gl_FragColor = glPos;\n   //gl_FragColor += vec4(vec3(dot(abs(color),vec3(0.5))),1.0);\n   \n\n\n    // Output to screen\n   // fragColor = vec4(col,1.0);\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n\n\n\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}