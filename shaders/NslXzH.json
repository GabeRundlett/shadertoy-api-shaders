{
    "Shader": {
        "info": {
            "date": "1619246295",
            "description": "several firsts for me: AO, more than one reflection bounce, local coords, fancier materials.",
            "flags": 32,
            "hasliked": 0,
            "id": "NslXzH",
            "likes": 7,
            "name": "more things",
            "published": 3,
            "tags": [
                "reflections",
                "ao",
                "texturing"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 296
        },
        "renderpass": [
            {
                "code": "\n\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nvec3 sky(in vec3 rd);\nmat2 rot2(in float theta);\nvec3 directionToColor(in vec3 dir);\n\nfloat opUnion(in float a, in float b);\nfloat opMinus(in float a, in float b);\nfloat opIntsc(in float a, in float b);\nfloat opUnion2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b);\nfloat opMinus2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b);\nfloat opIntsc2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b);\n\nfloat sdSphere(in vec3 p, in float r);\nfloat sdCylZ(in vec3 p, in float r);\nfloat sdCylY(in vec3 p, in float r);\nfloat sdBox( vec3 p, vec3 b );\n\nfloat gMapCalls;\n\nvec3  gSph1Pos;\nfloat gSph1Rad;\nmat2  gSPh1Rot;\nvec3  gSph2Pos;\nfloat gSph2Rad;\nmat2  gSPh2Rot;\nvec3  gSph3Pos;\nfloat gSph3Rad;\nfloat gSphMod;\nmat2  gChannelRot;\n\nvoid configScene() {\n    // move a bunch of trig etc out of the core map() routine and into once-per-fragment globals.\n    gSph1Pos    = vec3( 1.1, sin(gTime * 0.343) * 0.9, 0.0);\n    gSph1Rad    = smoothstep(0.5, 10.0, gTime) * 0.7 + 0.01;\n    gSPh1Rot    = rot2(gTime * 0.81);\n    gSph2Pos    = vec3(-1.1, sin(gTime * 0.443) * 0.9, 0.0);\n    gSph2Rad    = smoothstep(1.0, 4.0, gTime) * 0.7 + 0.01;\n    gSPh2Rot    = rot2(abs(sin(gTime * 0.443 * 0.5 - PI/4.0)) * 15.0);\n    gSphMod     = sin(gTime * 0.231) * 25.0 + 25.0;\n\n    gSph3Rad    = 30.0;\n    gSph3Pos    = vec3(0.0, gSph3Rad + 1.7, 0.0);\n}\n\n#define FOO                                               \\\n    int bMat = 0;                                         \\\n    gMapCalls += 1.0;                                     \\\n    float d = 1e9;                                        \\\n    p.y *= -1.0;                                          \\\n    vec3 P;                                               \\\n                                                          \\\n    /* ball 3 */                                          \\\n    bMat = 3;                                             \\\n    P = p - gSph3Pos;                                     \\\n /*   P.y += sin(dot(p.xz, p.xz) * 0.3 - gTime) * 0.1; */ \\\n    d = UN(VARIABLE_ARGS, sdSphere(P, gSph3Rad));         \\\n     \\\n    P = p - vec3(0.0, 1.0, 0.0); \\\n    d = MI(VARIABLE_ARGS, -0.2 + sdBox(P, vec3(1.0, 1.0, 30.0))); \\\n    d = MI(VARIABLE_ARGS, -0.2 + sdBox(P, vec3(30.0, 1.0, 1.0))); \\\n/*    P = vec3(mod(p.x - gTime * 0.321 + 0.0, 2.5) - 1.0, p.y - 3.0, p.z); \\\n    d = MI(VARIABLE_ARGS, -0.2 + sdSphere(P, 0.25)); \\\n    P = vec3(mod(p.z - gTime * 0.321 + 1.25, 2.5) - 1.0, p.y - 3.0, p.x).zyx; \\\n    d = MI(VARIABLE_ARGS, -0.2 + sdSphere(P, 0.25)); \\ */ \\\n    \\\n    bMat = 0;                                             \\\n                                                          \\\n    /* ball 1 */                                          \\\n    bMat = 1;                                             \\\n    P = p - gSph1Pos;                                     \\\n    P.yz *= gSPh1Rot;                                     \\\n    float sphPerturb = 0.004 * (-1.0 + 2.0 * smoothstep(-0.8, 0.8, (sin(P.y * gSphMod) + sin(P.x * gSphMod) + sin(P.z * gSphMod)))); \\\n    d = UN(VARIABLE_ARGS, sdSphere(P, gSph1Rad) + sphPerturb); \\\n    /* ball 2 */                                          \\\n    bMat = 2;                                             \\\n    P = p - gSph2Pos;                                     \\\n    P.zx *= gSPh2Rot;                                     \\\n    d = UN(VARIABLE_ARGS, sdSphere(P, gSph2Rad));         \\\n    /* Blank Line */\n\n\nfloat map(in vec3 p) {\n#define UN opUnion\n#define MI opMinus\n#define IN opIntsc\n#define VARIABLE_ARGS d\n    FOO\n    return d;\n}\n\nvec3 localCoords(in vec3 p, out int mat) {\n#undef UN\n#undef MI\n#undef IN\n#undef VARIABLE_ARGS\n#define UN opUnion2\n#define MI opMinus2\n#define IN opIntsc2\n#define VARIABLE_ARGS localSpace, P, mat, bMat, d\n    mat = -1;\n    vec3 localSpace = vec3(0.0);\n    FOO\n    return localSpace;\n}\n\n// IQ: https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.002;      // replace by an appropriate value\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h);\n    }\n    return normalize(n);\n}\n\n\nconst float closeEps = 0.002;\n\nfloat march(in vec3 ro, in vec3 rd) {\n    const int maxSteps = 100;\n\n    float d1 = map(ro);\n\n    vec3 p = ro;\n    float t = 0.0;\n    for (int n = 1; n <= maxSteps; ++n) {\n        float d = map(ro + rd * t);\n        float closeEnoughEps = (n == maxSteps ? 0.2 : closeEps);\n        if (d < closeEnoughEps) {\n            return t;\n        }\n        t += d;\n        if (t > 200.0) {\n            return t;\n        }\n    }\n    return t;\n}\n\nvec3 lightDirection = normalize(vec3(-2.0, -1.0, 0.2));\n\nfloat calcDiffuseAmount(in vec3 p, in vec3 n) {\n    return clamp(dot(n, -lightDirection), 0.0, 1.0);\n}\n\nconst float AOFactorMin = 0.2;\nconst float AOFactorMax = 1.0;\nfloat calcAOFactor(in vec3 p, in vec3 n) {\n    const float sampleDist = 0.4;\n    float dist = smoothstep(0.0, sampleDist, map(p + n * sampleDist));\n    return mix(AOFactorMin, AOFactorMax, (dist));\n}\n\nfloat calcShadowLight(in vec3 p) {\n    float t = march(p - lightDirection * 0.05, -lightDirection);\n    return t > 40.0 ? 1.0 : 0.0;\n}\n\nfloat maxPart(in vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nstruct pol3 {\n    float rho;\n    float tht;\n    float phi;\n};\n\npol3 sphericalFromCartesian(in vec3 cartesian) {\n    pol3 ret;\n\n    ret.tht = atan(cartesian.z, cartesian.x);\n    ret.phi = acos(dot(normalize(cartesian), vec3(0.0, 1.0, 0.0))) - PI/2.0;\n    ret.rho = length(cartesian);\n\n    return ret;\n}\n\nconst vec3 albedo1 = vec3(0.0, 0.6, 1.0);\nconst vec3 albedo2 = vec3(0.7, 0.2, 0.3);\nconst vec3 albedo3 = vec3(0.5, 0.1, 0.2);\nconst vec3 albedo4 = vec3(1.0, 1.0, 0.2);\nconst vec3 albedo5 = vec3(1.0, 0.2, 0.2);\n\n\nvoid calcMaterialCommons(in int material, in vec3 pCrt, in pol3 pPol) {\n}\n\n\nvec3 getAlbedo(in int material, in vec3 pCrt, in pol3 pPol) {\n    if (material == 1 || material == 2) {\n        float dots = smoothstep(0.005, -0.005, length(vec2(pPol.phi * 2.5 * 2.0, sin((pPol.tht + 2.2) * 5.0 / 1.0))) - 0.4);\n        vec3 alb = albedo1;\n        alb = mix(alb, albedo3, 0.7 * smoothstep(0.25, 0.3, abs((pPol.phi) * 2.0 + cos(pPol.tht * 5.0) * 0.3)));\n        alb = mix(alb, material == 1 ? albedo4 : albedo5, dots);\n        return alb;\n    }\n    else if (material == 0) {\n        return vec3(0.7);\n    }\n    else if (material == 3) {\n        return vec3(0.1, 0.1, 0.1);\n    }\n    else {\n        discard;\n    }\n}\n\nvec3 getReflectivity(in int material, in vec3 pCrt, in pol3 pPol) {\n\n    if (material == 0) {\n        return vec3(0.0);\n    }\n    else if (material <= 2) {\n        vec3 reflectAmount = vec3(1.0, 0.8, 0.5) * (sin(gTime * 0.3) * 0.45 + 0.55);\n\n        float vertStripes = smoothstep(-0.02, 0.02, sin(pPol.tht * 5.0 + pPol.phi * 4.0) - 0.7);\n\n        float lid = smoothstep(0.27, 0.269, abs(pPol.phi) * 0.2);\n\n        if (material == 0) {\n            reflectAmount *= 0.0;\n        }\n        reflectAmount *= 0.2 + 0.8 * ((1.0 - vertStripes) * lid);\n        return reflectAmount;\n    }\n    else if (material <= 3) {\n        return vec3(0.0, 0.2, 0.7);\n    }\n    else {\n        discard;\n    }\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n\n    vec3 col = vec3(0.0);\n\n    int bouncesLeft = 4;\n\n    vec3 contributionLeft = vec3(1.0);\n\n    while (bouncesLeft >= 0 && maxPart(contributionLeft) > 0.001) {\n        bouncesLeft -= 1;\n        float t = march(ro, rd);\n        vec3 p = ro + t * rd;\n        if (length(p) > 150.0) {\n            col += sky(rd) * contributionLeft;\n            break;\n        }\n\n        vec3 normal = calcNormal(p);\n\n        int material;\n        vec3 ptCrt = localCoords(p, material);\n        pol3 ptSph = sphericalFromCartesian(ptCrt);\n\n\n        float incomingLight = 1.0;\n        incomingLight = min(incomingLight, calcDiffuseAmount(p, normal));\n        incomingLight = min(incomingLight, calcShadowLight(p));\n        float ambient = 0.05 * calcAOFactor(p, normal);\n        incomingLight += ambient;\n\n        float fres = 0.4 + 0.8 * clamp(pow(1.0 - abs(dot(rd, normal) - 0.1), 2.0), 0.0, 1.0);\n\n        calcMaterialCommons(material, ptCrt, ptSph);\n\n        vec3 reflectivity = fres * getReflectivity(material, ptCrt, ptSph);\n        vec3 diffuse = incomingLight * getAlbedo(material, ptCrt, ptSph);\n        \n        col += diffuse * (1.0 - reflectivity) * contributionLeft;\n        contributionLeft *= reflectivity;\n          \n        ro = p + normal * 0.05;\n        rd = reflect(rd, normal);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec4 persistedInfo = texelFetch(iChannel0, ivec2(0, 0), 0);\n    setupCoords(iResolution.xy, 0.97);\n    setupTime(persistedInfo[2]);\n    vec2  uv        = worldFromScreen(XY);\n    float luv       = length(uv);\n    vec2  ms        = worldFromScreen(iMouse.xy);\n    float smoothEps = gWorldFromScreenFac * 2.0;\n\n    configScene();\n\n    // look-from and look-to points\n    // right-handed system where x is right, y is up, z is forward.\n    float dt = 0.5;\n    float t = gTime * 0.23;\n    vec3 trgPt = vec3(0.0);\n    \n    float lookChoice = smoothstep(-0.1, 0.1, sin(t * 0.41));\n    trgPt = mix(gSph1Pos, gSph2Pos, lookChoice);\n    trgPt.y *= -1.0;\n\n    vec3 col = vec3(0.0);\n\n    float camTheta = t + ms.x * 1.5;\n    float camAlttd = sin(t * 0.32) * 0.2 + ms.y * 0.4;\n    vec3 camPt = vec3(cos(camTheta), camAlttd, sin(camTheta)) * -2.2;\n    \n    // camera's forward, right, and up vectors. right-handed.\n    vec3 camFw = normalize(trgPt - camPt);\n    vec3 camRt = cross(camFw, vec3(0.0, 1.0, 0.0));\n    vec3 camUp = cross(camRt, camFw);\n    \n    \n\n    // mess with camPt, just for fun\n    float messAmt = luv < 1.0 ? 0.0 : 0.2 * (luv - 1.0);\n    camPt += camRt * messAmt;\n\n    // ray origin and direction\n    vec3 ro    = camPt;\n    vec3 rd    = normalize(camFw + uv.x * camRt / (1.0 + messAmt * 2.0) + uv.y * camUp / (1.0 + messAmt * 2.0));\n    \n    const int maxSteps = 100;\n    \n    gMapCalls = 0.0;\n\n    col += render(ro, rd);\n\n    float outCircle = smoothstep(-smoothEps, smoothEps, luv - 1.0);\n    col *= 1.0 - 0.1 * outCircle * pow(luv, 1.5);\n    col = mix(col, vec3(col.x + col.y + col.z) / 6.0, outCircle * clamp(0.0, 1.0, 2.0 * (luv - 1.0)));\n    col *= 1.0 + smoothstep(smoothEps, -smoothEps, abs(luv - 1.0));\n\n  //  col.r = gMapCalls / 200.0;\n  \n    col = pow(col, vec3(1.0 / 2.2));\n    \n    RGBA = vec4(col, 1.0);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 sky(in vec3 rd) {\n    float tht = atan(rd.z, rd.x);\n    float phi = acos(dot(normalize(rd), vec3(0.0, 1.0, 0.0)));\n    vec3 col = rd * 0.5 + 0.5;\n    col *= smoothstep(0.002, -0.002, sin(tht       * 4.0)) * -0.3 + 1.0;\n    col *= smoothstep(0.002, -0.002, sin(phi * 2.0 * 4.0)) * -0.3 + 1.0;\n    col = mix(col, col / max(col.r, max(col.g, col.b)), 0.2);\n    col *= rd.y < 0.0 ? 0.5 : 1.0;\n    return col;\n}\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n    \n}\n\n// dir is unit-length\nvec3 directionToColor(in vec3 dir) {\n    vec3 ret = dir * 0.5 + 0.5;\n    return ret;\n}\n\n\nfloat opUnion(in float a, in float b) {\n    return min(a, b);\n}\n\nfloat opMinus(in float a, in float b) {\n    return max(a, -b);\n}\n\nfloat opIntsc(in float a, in float b) {\n    return max(a, b);\n}\n\nfloat opUnion2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b) {\n    if (a < b) {\n        return a;\n    }\n    else {\n        localSpace = bSpace;\n        material = bMaterial;\n        return b;\n    }\n}\n\nfloat opMinus2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b) {\n    return opMinus(a, b);\n}\n\nfloat opIntsc2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b) {\n    return opIntsc(a, b);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCylZ(in vec3 p, in float r) {\n    return length(p.xy) - r;\n}\n\nfloat sdCylY(in vec3 p, in float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdPlaneY(in vec3 p)\n{\n    return p.y;\n}\n// IQ:\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-04-05 18:18:15\n\nconst float PI  = 3.14159265359;\nconst float TAO = PI * 2.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n\n// to prevent loop-unrolling\n#define ZERO (min(0, int(iFrame)))\n\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\n// 0, 0:\n// [0] = is mouse down\n// [1] = is time frozen\n// [2] = current time\n// [3] = timescale\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n\n    RGBA = texelFetch(iChannel0, IJ, 0);\n\n    if (iFrame == 0 || IJ.x != 0 || IJ.y != 0) {\n        RGBA = vec4(0.0, 0.0, iTime, 1.0);\n        return;\n    }\n\n    bool  mouseWasDown = RGBA[0] == 1.0;\n    bool  timeIsFrozen = RGBA[1] == 1.0;\n    float time         = RGBA[2];\n    float timeScale    = RGBA[3];\n\n    bool mouseIsDown = iMouse.z > 0.0;\n\n    timeIsFrozen = timeIsFrozen ^^ (!mouseIsDown && mouseWasDown);\n    \n    timeIsFrozen = mouseIsDown;\n\n    timeScale = clamp(timeScale + (timeIsFrozen ? -0.01 : 0.01) * 60.0 / iFrameRate, 0.0, 1.0);\n    time += iTimeDelta * timeScale;\n\n    RGBA[0] = mouseIsDown  ? 1.0 : 0.0;\n    RGBA[1] = timeIsFrozen ? 1.0 : 0.0;\n    RGBA[2] = time;\n    RGBA[3] = timeScale;\n\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}