{
    "Shader": {
        "info": {
            "date": "1521081196",
            "description": "Mouse controls the camera ",
            "flags": 0,
            "hasliked": 0,
            "id": "4dGyRz",
            "likes": 2,
            "name": "CaterpillarOne",
            "published": 3,
            "tags": [
                "sdf",
                "modeling"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 572
        },
        "renderpass": [
            {
                "code": "#define EPS 0.0001\n#define STEPS 1028\n#define FAR  100.0\n\nconst float halfpi = acos( -1.0 ) * 0.5;\nconst float pi = acos( -1.0 );\n\n//fbm and sdf functions by iq\n\nfloat hash( float n )\n{\n\n    return fract( sin( n ) * 45843.349 );\n    \n}\n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n               );\n\n}\n\nfloat noise( in vec3 x )\n{\n\n    vec3 p = floor( x );\n    vec3 k = fract( x );\n    \n    k *= k * k * ( 3.0 - 2.0 * k );\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0; \n    \n    float a = hash( n );\n    float b = hash( n + 1.0 );\n    float c = hash( n + 57.0 );\n    float d = hash( n + 58.0 );\n    \n    float e = hash( n + 113.0 );\n    float f = hash( n + 114.0 );\n    float g = hash( n + 170.0 );\n    float h = hash( n + 171.0 );\n    \n    float res = mix( mix( mix ( a, b, k.x ), mix( c, d, k.x ), k.y ),\n                     mix( mix ( e, f, k.x ), mix( g, h, k.x ), k.y ),\n                     k.z\n    \t\t\t\t );\n    \n    return res;\n    \n}\n\nfloat fbm( in vec3 p )\n{\n\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p *= 2.02;\n    f += 0.2500 * noise( p ); p *= 2.03;\n    f += 0.1250 * noise( p ); p *= 2.01;\n    f += 0.0625 * noise( p );\n    f += 0.0125 * noise( p );\n    return f / 0.9375;\n    \n}\n\n// https://www.shadertoy.com/view/ldcyW4\n\nvec4 RotationToQuaternion(vec3 axis, float angle)\n{\n    float half_angle = angle * halfpi / 180.0;\n    vec2 s = sin(vec2(half_angle, half_angle + halfpi));\n    return vec4(axis * s.x, s.y);\n}\n\nvec3 Rotate(vec3 pos, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n\tvec4 q = RotationToQuaternion(axis, angle);\n    return pos + 2.0 * cross(q.xyz, cross(q.xyz, pos) + q.w * pos);\n}\n\nfloat smin( float a, float b )\n{\n#if 0\n\tfloat k = 32.0;\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n#else\n    float k = 0.1;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n#endif\t\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n\nfloat opBlend( float d1, float d2 )\n{\n    return smin( d1, d2 );\n}\n\nvec3 opRepZ( vec3 p0 )\n{\n\treturn vec3(p0.x,p0.y, mod(p0.z,1.0)-0.5*1.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n\n    return length( p ) - r;\n   \n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n\nvec2 map( vec3 p )\n{\n\n    /*float a = 2.0;\n    float r = 0.3 + 0.15 * cos( a * p.x + iTime ) * cos( a * p.y + iTime ) * cos( p.z );\n    float cap = sdCapsule( Rotate( p, vec3( 1.0, 0.0, 0.0 ), 100.0 ), vec3( 2.0 ), vec3( -2.0 ), r );\n    */\n    \n    \n    \n    // Set size of the domain\n    float til = 5.0;\n    \n    // Get id for each of the domains\n    vec3 id = vec3( int( p.x / til ), int( p.y / til ), int( p.z / til ) );\n    \n    p.x = mod( p.x, til ) - til * 0.5;\n    \n    //p.xy *= rot( id.x + id.y + id.z + iTime);\n    \n    p.z -= hash( id.x ) + iTime;\n    \n    float tilS = 7.5;\n    \n    p.z = mod( p.z, tilS ) - tilS * 0.5;\n    \n    float s   = sdEllipsoid( p - vec3( -0.2, 0.0, -0.1 ), vec3( 0.3, 0.4, 0.3 ) );\n    float sO  = sdEllipsoid( p - vec3( 0.3, 0.0, -0.1 ), vec3( 0.3, 0.4, 0.3 ) );\n    vec2 mou = vec2( sdEllipsoid( p - vec3( 0.04, -0.3, 0.0 ), vec3( 0.3, 0.2, 0.2 ) ), 1.0 );\n    vec2 hea = vec2( opBlend( s, sO ), 0.0 );\n    if( hea.x < mou.x ) mou = hea;\n    vec2 bod[ 11 ];\n    float r = 0.6 + 0.15 * cos( 3.0 * p.z );\n    float rO = 0.8 + 0.07 * cos( 1.0 * p.z * 2.0 );\n    bod[ 0 ] = vec2( sdEllipsoid( p - vec3( 0.0, 0.1, -0.6 ), vec3( r ) ), 2.0 );\n    bod[ 0 ] = vec2( opBlend( hea.x, bod[ 0 ].x ), 2.0 );\n    bod[ 1 ] = vec2( sdEllipsoid( p - vec3( 0.0, 0.1, -0.9 ), vec3( 0.6, 0.7, 0.6 ) ), 3.0 );\n    bod[ 1 ] = vec2( opBlend( bod[ 1 ].x, bod[ 0 ].x ), 2.0 );\n    bod[ 2 ] = vec2( sdEllipsoid( p - vec3( 0.0, 0.2, -0.9 ), vec3( 0.7, 0.8, 0.7 ) ), 4.0 );\n    bod[ 2 ] = vec2( opBlend( bod[ 2 ].x, bod[ 1 ].x ), 2.0 );\n    bod[ 3 ] = vec2( sdEllipsoid( p - vec3( 0.0, 0.15, -1.4 ), vec3( 0.67, 0.77, 0.67 ) ), 4.0 );\n    bod[ 3 ] = vec2( opBlend( bod[ 3 ].x, bod[ 2 ].x ), 2.0 );\n    bod[ 4 ] = vec2( sdEllipsoid( p - vec3( 0.0, 0.1, -1.7 ), vec3( 0.6, 0.7, 0.6 ) ), 5.0 );\n    bod[ 4 ] = vec2( opBlend( bod[ 3 ].x, bod[ 4 ].x ), 2.0 );\n    bod[ 5 ] = vec2( sdEllipsoid( p - vec3( 0.0, 0.1, -2.0 ), vec3( 0.6, 0.7, 0.6 ) ), 5.0 );\n    bod[ 5 ] = vec2( opBlend( bod[ 5 ].x, bod[ 4 ].x ), 2.0 ); \n    bod[ 6 ] = vec2( sdEllipsoid( p - vec3( 0.0, 0.0, -2.4 ), vec3( 0.5, 0.6, 0.5 ) ), 5.0 );\n    bod[ 6 ] = vec2( opBlend( bod[ 6 ].x, bod[ 5 ].x ), 2.0 ); \n    bod[ 7 ] = vec2( sdEllipsoid( p - vec3( 0.0, -0.1, -2.7 ), vec3( 0.4, 0.5, 0.4 ) ), 5.0 );\n    bod[ 7 ] = vec2( opBlend( bod[ 6 ].x, bod[ 7 ].x ), 2.0 );\n    bod[ 8 ] = vec2( sdEllipsoid( p - vec3( 0.0, 0.0, -2.8 ), vec3( 0.4, 0.3, 0.4 ) ), 5.0 );\n    bod[ 8 ] = vec2( opBlend( bod[ 8 ].x, bod[ 7 ].x ), 2.0 );\n    bod[ 9 ] = vec2( sdEllipsoid( p - vec3( 0.0, 0.0, -2.9 ), vec3( 0.4, 0.35, 0.4 ) ), 5.0 );\n    bod[ 9 ] = vec2( opBlend( bod[ 8 ].x, bod[ 9 ].x ), 2.0 );\n    bod[ 10 ] = vec2( sdEllipsoid( p - vec3( 0.0, -0.2, -3.0 ), vec3( 0.4, 0.4, 0.7 ) ), 5.0 );\n    bod[ 10 ] = vec2( opBlend( bod[ 9 ].x, bod[ 10 ].x ), 2.0 );\n    if( bod[ 10 ].x < mou.x ) mou = bod[ 10 ];\n    /*for( int i = 0; i < 11; ++i )\n        \n    {\n    \n        if( bod[ i ].x < mou.x ) mou = bod[ i ];\n        \n    }*/\n    \n    \n    vec2 leg[ 14 ];\n    leg[ 0 ] = vec2( sdEllipsoid( p - vec3( 0.2, -0.25, -0.35 ), vec3( 0.2, 0.35, 0.2 ) ), 6.0 );\n    leg[ 0 ] = vec2( opBlend( mou.x, leg[ 0 ].x ), 1.0 ); \n    leg[ 1 ] = vec2( sdEllipsoid( p - vec3( 0.2, -0.23, -0.7 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 1 ] = vec2( opBlend( leg[ 1 ].x, leg[ 0 ].x ), 1.0 ); \n    leg[ 2 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), 5.0 ) - vec3( 0.2, -0.23, -1.5 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 2 ] = vec2( opBlend( leg[ 2 ].x, leg[ 1 ].x ), 1.0 ); \n    leg[ 3 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), 6.0 ) - vec3( 0.1, -0.23, -1.9 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 3 ] = vec2( opBlend( leg[ 2 ].x, leg[ 3 ].x ), 1.0 );\n    leg[ 4 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), 6.0 ) - vec3( 0.0, -0.23, -2.3 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 4 ] = vec2( opBlend( leg[ 4 ].x, leg[ 3 ].x ), 1.0 );\n    leg[ 5 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), 6.0 ) - vec3( -0.1, -0.23, -2.8 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 5 ] = vec2( opBlend( leg[ 4 ].x, leg[ 5 ].x ), 1.0 );\n    leg[ 6 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), 6.0 ) - vec3( -0.1, -0.23, -3.1 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 6 ] = vec2( opBlend( leg[ 6 ].x, leg[ 5 ].x ), 1.0 );\n\n    leg[ 7 ] = vec2( sdEllipsoid( p - vec3( -0.25, -0.25, -0.35 ), vec3( 0.2, 0.35, 0.2 ) ), 6.0 );\n    leg[ 7 ] = vec2( opBlend( leg[ 7 ].x, leg[ 6 ].x ), 1.0 ); \n    leg[ 8 ] = vec2( sdEllipsoid( p - vec3( -0.3, -0.23, -0.7 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 8 ] = vec2( opBlend( leg[ 7 ].x, leg[ 8 ].x ), 1.0 ); \n    leg[ 9 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), -5.0 ) - vec3( -0.2, -0.23, -1.5 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 9 ] = vec2( opBlend( leg[ 8 ].x, leg[ 9 ].x ), 1.0 ); \n    leg[ 10 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), -6.0 ) - vec3( -0.15, -0.23, -1.9 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 10 ] = vec2( opBlend( leg[ 9 ].x, leg[ 10 ].x ), 1.0 );\n    leg[ 11 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), -6.0 ) - vec3( -0.1, -0.23, -2.3 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 11 ] = vec2( opBlend( leg[ 10 ].x, leg[ 11 ].x ), 1.0 );\n    leg[ 12 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), -2.0 ) - vec3( -0.15, -0.23, -2.8 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 12 ] = vec2( opBlend( leg[ 11 ].x, leg[ 12 ].x ), 1.0 );\n    leg[ 13 ] = vec2( sdEllipsoid( Rotate( p, vec3( 0.0, 1.0, 0.0 ), -2.0 ) - vec3( -0.15, -0.23, -3.1 ), vec3( 0.2, 0.4, 0.2 ) ), 6.0 );\n    leg[ 13 ] = vec2( opBlend( leg[ 12 ].x, leg[ 13 ].x ), id.x + id.y + id.z );\n    \n    vec3 pos = vec3( p.x, p.y + 0.8, p.z );\n    vec2 tub = vec2( length( pos.xy ) - 0.3, 7.0 );\n    \n\tif( leg[ 13 ].x < tub.x ) tub = leg[ 13 ];\n    \n    return tub;\n\n}\n\nvec3 nor( vec3 p )\n{\n\n    vec2 e = vec2( 0.0, EPS );\n    \n    return normalize( vec3( map( p + e.xyy ).x - map( p - e.xyy ).x,\n                            map( p + e.yxy ).x - map( p - e.yxy ).x,\n                            map( p + e.yyx ).x - map( p - e.yyx ).x\n                          ) );\n\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t ).x;\n        if( h < EPS ) 0.0;\n        res = min( res, 8.0 * h / t );\n        \n    }\n    \n    return res;\n\n}\n\nvec3 sha( vec3 ro, vec3 rd, float t )\n{\n\n    vec3 p = ro + rd * t;\n\tvec3 n = nor( p );\n    vec3 lig = normalize( vec3( 1.0, 0.8, 0.6 ) );\n    vec3 blig = normalize( vec3( -lig.x, -lig.y, -lig.z ) );\n    vec3 col = vec3( 0.0 );\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float dif = max( 0.0, dot( lig, n ) );\n    float bac = max( 0.0, 0.2 + 0.8 * dot( blig, n ) );\n    float sha = softShadows( p, lig );\n    \n    col += amb * sha;\n    col += 0.1 * dif; //* bac;\n    col += 2.0 * bac;\n    \n    if( map( p ).y < 4.0 ) col *= mix( vec3( 0.8, sin( 10.0 * p.z + iTime * 2.0 ), 0.0 ), vec3( 0.2, 0.9, 0.6 ), fbm( p + iTime * 0.2 ) );\n    if( map( p ).y == 7.0 ) col *= mix( vec3( 0.4, 0.2, 0.0 ), vec3( 0.1, 0.1, 0.0 ), fbm( p * fbm( p ) ) );\n    if( map( p ).y == 2.0 ) col *= mix( vec3( 0.8, sin( 10.0 * p.z + iTime * 2.0 ), 0.0 ), vec3( 0.5, 0.9, 0.6 ), fbm( p + iTime * 0.2 ) );\n    if( map( p ).y == 1.0 ) col *= mix( vec3( 0.8, sin( 10.0 * p.z + iTime * 2.0 ), 0.0 ), vec3( 0.5, 0.5, 0.6 ), fbm( p + iTime * 0.2 ) );\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    \n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    if( mou.x == 0.0 ) mou = vec2( 0.6, 0.8 );\n    \n    vec3 ro = 4.0 * vec3( sin( mou.x * 2.0 * pi ), ( mou.y ), cos( -mou.x * 2.0 * pi ) );\n    //vec3 ro = 2.0 * vec3( ( mou.x * pi ) , ( mou.y * pi ), 1.0 );\n    //vec3 ro = vec3( 3.0 * mou.x, 0.0, 2.0 * mou.y );\n    vec3 ww = normalize( vec3( -1.0 ) - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = normalize( uv.x * uu + uv.y * vv + 1.5 * ww );\n    //vec3 rd = normalize( vec3( uv, -1.0 ) );\n    \n    float t = 0.0, d = EPS;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        d = 0.5 * map( ro + rd * t ).x;\n        if( d < EPS || t > FAR ) break;\n        t += d;\n    \n    }\n    \n    // Time varying pixel color\n    vec3 col = d < EPS ? sha( ro, rd, t ) : texture( iChannel0, rd ).rgb;// mix( vec3( 0.5, 0.2, 0.4 ), vec3( 0.2, 0.1, 0.2 ), uv.y );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}