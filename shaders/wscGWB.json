{
    "Shader": {
        "info": {
            "date": "1569265858",
            "description": "In this one I actually dared to distort an SDF with an FBM! =o\nIt does result in the marching loop getting stuck in some cases... so I detect those with the 120 limit and cut them out.\n\nHope you like it! :)",
            "flags": 32,
            "hasliked": 0,
            "id": "wscGWB",
            "likes": 16,
            "name": "BEEPLE COVER: MONOLITH ASTRONAUT",
            "published": 3,
            "tags": [
                "sdf",
                "fbm",
                "distortion",
                "space",
                "spheremarching",
                "monolith",
                "astronaut",
                "beeple",
                "spaceman"
            ],
            "usePreview": 1,
            "username": "toomuchvoltage",
            "viewed": 765
        },
        "renderpass": [
            {
                "code": "/***********************************************************\n\n   And ANOTHER beeple cover: MONOLITH ASTRONAUT!\n   In this one I actually dared to distort an SDF with an FBM! =o\n   Reference: https://c.wallhere.com/photos/71/8e/beeple_render_men_landscape_astronaut_rocks_Monolith_neon-1292371.jpg!d\n   All your SDFs are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2019 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    const vec4 lightColor = vec4 (1.0, 0.0, 0.0, 1.0);\n    \n    fragColor = texture (iChannel0, uv) + texture (iChannel1, uv) * lightColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/***********************************************************\n\n   And ANOTHER beeple cover: MONOLITH ASTRONAUT!\n   In this one I actually dared to distort an SDF with an FBM! =o\n   Reference: https://c.wallhere.com/photos/71/8e/beeple_render_men_landscape_astronaut_rocks_Monolith_neon-1292371.jpg!d\n   All your SDFs are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2019 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define M_PI 3.1415926535\n#define DRAW_DISTANCE 400.0\n\nmat4 rotationMatrix(vec3 axis, float cosA, float sinA) {\n    float s = sinA;\n    float c = cosA;\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float cosA, float sinA)\n{\n\tmat4 m = rotationMatrix(axis, cosA, sinA);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length2(q)-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n\tp.x = abs(p.x);\n\tfloat k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n\treturn sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat astronautLegs(vec3 p)\n{\n\tp.x = abs(p.x);\n    p += vec3 (-1.1, 5.0, 2.0);\n    float rightLegTop = sdCapsule (p, vec3 (0.0, 4.0, 0.0), vec3 (0.1, 2.0, -0.1), 1.0);\n    float rightLegBottom = sdCapsule (p, vec3 (0.1, 2.0, -0.1), vec3 (0.0, 0.0, 0.0), 1.0);\n    return opSmoothUnion (rightLegTop, rightLegBottom, 0.2);\n}\n\nfloat astronautArms(vec3 p)\n{\n    float rightBicep = sdCapsule (p, vec3 (-2.0, 4.0, -2.0), vec3 (-2.7, 3.0, -2.0), 0.6);\n    float rightArm = sdCapsule (p, vec3 (-2.7, 3.0, -2.0), vec3 (-2.9, 1.0, -3.0), 0.6);\n\n    float leftBicep = sdCapsule (p, vec3 (2.0, 4.0, -2.0), vec3 (2.7, 3.0, -1.0), 0.6);\n    float leftArm = sdCapsule (p, vec3 (2.7, 3.0, -1.0), vec3 (2.9, 1.0, -2.0), 0.6);\n\n    return min (min (rightBicep, rightArm), min (leftBicep, leftArm));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat astronautHelmet(vec3 p, inout vec4 material)\n{\n    vec3 newP = p + vec3 (0.0, -5.75, 2.5);\n    float helmet = length(newP) - 1.25;\n    float shield = length (newP) - 1.2;\n    newP = rotate (newP, vec3 (0.0, 1.0, 0.0), 0.0, 1.0); // cos/sin (M_PI * 0.5)\n    newP = -newP + vec3 (1.5, -0.5, 0.0);\n    helmet = max (helmet, -sdTriPrism (newP, vec2 (1.5, 3.0)));\n    if ( helmet < shield )\n    {\n        material = vec4 (vec3 (1.0), 0.0);\n        return helmet;\n    }\n    else\n    {\n        material = vec4 (1.0, 1.0, 1.0, 1.0);\n        return shield;\n    }\n}\n\nfloat astronautLeftPalm(in vec3 p)\n{\n    vec3 q2 = p + vec3 (2.75, -0.5, 3.5);\n    p += vec3 (2.75, -0.3, 3.5);\n    p = rotate (p, vec3 (0.0, 0.0, 1.0), 0.0, 1.0); // cos/sin (M_PI * 0.5)\n    p = rotate (p, vec3 (0.0, 1.0, 0.0), 0.89100652418, -0.45399049974); // cos/sin (M_PI * -0.15)\n    q2 = rotate (q2, vec3 (0.0, 0.0, 1.0), 0.0, -1.0); // cos/sin (M_PI * -0.5)\n    q2 = rotate (q2, vec3 (0.0, 1.0, 0.0), 0.89100652418, 0.45399049974); // cos/sin (M_PI * 0.15)\n    vec3 h = vec3 (0.0, 0.0, 0.2);\n\tvec3 q = p - clamp( p, -h, h );\n    return min (sdCappedTorus (q, vec2 (1.0, 0.1), 0.3, 0.25), sdCappedTorus (q2, vec2 (1.0, 0.1), 0.2, 0.125));\n}\n\nfloat astronautRightPalm(in vec3 p)\n{\n    p.x = -p.x;\n    vec3 q2 = p + vec3 (2.75, -0.5, 2.3);\n    p += vec3 (2.75, -0.3, 2.3);\n    p = rotate (p, vec3 (0.0, 0.0, 1.0), 0.0, 1.0);\n    p = rotate (p, vec3 (0.0, 1.0, 0.0), 0.89100652418, -0.45399049974);\n    q2 = rotate (q2, vec3 (0.0, 0.0, 1.0), 0.0, -1.0);\n    q2 = rotate (q2, vec3 (0.0, 1.0, 0.0), 0.89100652418, 0.45399049974);\n    vec3 h = vec3 (0.0, 0.0, 0.2);\n\tvec3 q = p - clamp( p, -h, h );\n    return min (sdCappedTorus (q, vec2 (1.0, 0.1), 0.3, 0.25), sdCappedTorus (q2, vec2 (1.0, 0.1), 0.2, 0.125));\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat torsoWires (vec3 p, inout vec4 material)\n{\n    p.x = abs(p.x);\n    p += vec3 (-1.25, -1.0, 2.4);\n    p = rotate (p, vec3 (0.0, 0.0, 1.0), 0.921060994, -0.3894183423); // cos/sin (-0.4)\n    float wire1 = sdTorus82 (p, vec2 (0.85, 0.1));\n    float wire2 = sdTorus82 (p + vec3 (0.3, -0.7, 0.0), vec2 (0.85, 0.1));\n    float wires = min (wire1, wire2);\n    float button = sdCappedCylinder (p + vec3 (0.8, 0.0, 0.0), vec3 (0.0, 0.0, 0.0), vec3 (0.0, 0.0, -0.75), 0.2);\n    button = min (button, sdCappedCylinder (p + vec3 (1.1, -0.7, 0.0), vec3 (0.0, 0.0, 0.0), vec3 (0.0, 0.0, -0.75), 0.2));\n    button = min (button, sdCappedCylinder (p + vec3 (1.6, -1.3, 0.0), vec3 (0.0, 0.0, 0.0), vec3 (0.0, 0.0, -0.75), 0.2));\n    \n    if ( wires < button )\n    {\n        material = vec4 (vec3 (1.0), 0.0);\n        return wires;\n    }\n    else\n    {\n        material = vec4 (0.0);\n        return button;\n    }\n}\n\nfloat astronaut(vec3 p, inout vec4 material)\n{\n    p.z = -p.z;\n    p.y += 1.5;\n    float radio = sdCappedCylinder (p, vec3 (-1.7, 3.0, -1.4), vec3 (-1.7, 6.0, -1.4), 0.1);\n    float astroLegs = astronautLegs(p);\n    float astroAbs = sdRoundBox(p + vec3 (0.0, -2.0, 2.0), vec3 (1.0, 2.0, 0.1), 1.0);\n    float astroArms = astronautArms(p);\n    float astroPalms = min (astronautLeftPalm (p), astronautRightPalm(p));\n    float astroArmsPalms = min (astroPalms, astroArms);\n    vec4 astroMat = vec4 (0.0);\n    vec4 torsoMat = vec4 (0.0);\n    float astroHelmet = astronautHelmet(p, astroMat);\n    float retVal = opSmoothUnion (opSmoothUnion (astroLegs, astroAbs, 0.5), opSmoothUnion (astroArms, astroHelmet, 0.5), 0.4);\n    float torsoEval = torsoWires (p, torsoMat);\n    retVal = min (min (retVal, radio), min (astroArmsPalms, torsoEval));\n    if (retVal == astroHelmet)\n        material = astroMat;\n    else if ( abs (retVal - astroPalms) < 0.0001 )\n        material = vec4 (0.0);\n    else if ( retVal == torsoEval )\n        material = torsoMat;\n    else if ( retVal == radio )\n        material = vec4 (0.0);\n\telse\n        material = vec4 (vec3 (1.0), 0.0);\n    return retVal;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat pebblesSpace (in vec3 p, float pebbleScale)\n{\n    vec3 c = vec3 (7.0);\n    vec3 q = mod(p,c)-0.5*c;\n    return length( q ) - pebbleScale;\n}\n\nfloat pebbleSet (in vec3 p, float pebbleScale)\n{\n    float retVal;\n    retVal = pebblesSpace (p, pebbleScale);\n    return max (retVal, -sdPlane (p, vec4 (0.0, -1.0, 0.0, 0.0)));\n}\n\nfloat pebbleBunch (in vec3 p, float groundOffset)\n{\n    float set1 = pebbleSet(p + vec3 (0.0, groundOffset, 0.0), 0.5);\n    float set2 = pebbleSet(p + vec3 (0.5, groundOffset, 0.1), 0.25);\n    float set3 = pebbleSet(p + vec3 (1.8, groundOffset, -1.92), 0.3);\n    float set4 = pebbleSet(p + vec3 (2.85, groundOffset, 1.33), 0.4);\n    float wholeBunch = min (opSmoothUnion (set1, set2, 0.4), opSmoothUnion (set3, set4, 0.4));\n    float slice1 = max (wholeBunch, -length(p) + 20.0);\n    float slice2 = max (slice1, -length(p + vec3 (8.0, 0.0, -2.0)) + 20.0);\n    float slice3 = max (slice2, -length(p + vec3 (-8.0, 0.0, -2.0)) + 20.0);\n    float slice4 = max (slice3, -length(p + vec3 (-8.0, 0.0, 18.0)) + 22.0);\n    return slice4;\n}\n\nfloat pebbles (in vec3 p, float groundOffset)\n{\n    float bunch1 = pebbleBunch (p, groundOffset);\n    p = rotate (p, vec3 (0.0, 1.0, 0.0), 0.87758256189, 0.4794255386); // cos/sin ( 0.5 )\n    float bunch2 = pebbleBunch (p, groundOffset);\n    return opSmoothUnion (bunch1, bunch2, 0.5);\n}\n\nfloat sineField (vec2 p)\n{\n    return (sin(p.x) + sin(p.y));\n}\n\nfloat fBm (in vec3 p)\n{\n    p.xz *= 0.25;\n    mat2 rot = mat2 (0.54030230586, 0.8414709848, -0.8414709848, 0.54030230586);\n    float res = 0.0;\n\tres += abs (sineField(p.xz)) * 0.5;\n    p.xz = rot * p.xz;\n\tres += abs (sineField(p.xz * 2.0)) * 0.25;\n    p.xz = rot * p.xz;\n\tres += abs (sineField(p.xz * 4.0)) * 0.125;\n    p.xz = rot * p.xz;\n\tres += abs (sineField(p.xz * 8.0)) * 0.0625;\n    p.xz = rot * p.xz;\n\tres += abs (sineField(p.xz * 16.0)) * 0.03125;\n    return res;\n}\n\nfloat mountains (vec3 p, inout vec4 material)\n{\n    vec3 origP = p;\n\tfloat floorDist = sdPlane (p + vec3 (0.0, 7.0, 0.0), vec4 (0.0, 1.0, 0.0, 0.0));\n    p.xz *= 0.06;\n    p.xz -= vec2 (-0.5, 0.25);\n    floorDist += (1.0 - sin(min (dot(p.xz, p.xz), M_PI * 0.5))) * 4.0;\n    p.xz += vec2 (-1.0, 0.0);\n    floorDist += (1.0 - sin(min (dot(p.xz, p.xz), M_PI * 0.5))) * 4.0;\n    p.xz += vec2 (0.2, 1.25);\n    floorDist += (1.0 - sin(min (dot(p.xz, p.xz), M_PI * 0.5))) * 4.0;\n    float waterLevel = sdPlane (p + vec3 (0.0, 6.0, 0.0), vec4 (0.0, 1.0, 0.0, 0.0));\n    float mountainOffset = fBm (p) * length(p.xz) * 2.0;\n    float groundAndWater = min (floorDist - mountainOffset, waterLevel);\n    float portal = sdBox (origP + vec3 (0.0, 0.0, 2.0), vec3 (5.0, 22.0, 0.1));\n    float retVal = min (min (groundAndWater, pebbles(origP, -mountainOffset * 0.7 + 2.25)), portal);\n    if ( retVal == waterLevel )\n    {\n        material = vec4 (1.0);\n    }\n    else if ( retVal == portal )\n    {\n        material = vec4 (vec3 (1.0), -1.0);\n    }\n    else\n    {\n        material = vec4 (vec3 (1.0), 0.0);\n    }\n    return retVal;\n}\n\nfloat scene (vec3 p, inout vec4 material, out bool hitAstronaut)\n{\n    vec4 astroMat = vec4 (0.0);\n    vec4 groundMat = vec4 (0.0);\n    float astroDist = astronaut (p, astroMat);\n    float mountainDist = mountains (p, groundMat);\n    if ( mountainDist < astroDist )\n    {\n        material = groundMat;\n        hitAstronaut = false;\n        return mountainDist;\n    }\n    else\n    {\n        material = astroMat;\n        hitAstronaut = true;\n        return astroDist;\n    }\n}\n\nvec3 sceneNorm (vec3 p)\n{\n    vec4 mat = vec4(0.0);\n    bool hitAstro = false;\n    float gradD = 0.01;\n    float gradX = scene (p + vec3 (gradD, 0.0, 0.0), mat, hitAstro) - scene (p - vec3 (gradD, 0.0, 0.0), mat, hitAstro);\n    float gradY = scene (p + vec3 (0.0, gradD, 0.0), mat, hitAstro) - scene (p - vec3 (0.0, gradD, 0.0), mat, hitAstro);\n    float gradZ = scene (p + vec3 (0.0, 0.0, gradD), mat, hitAstro) - scene (p - vec3 (0.0, 0.0, gradD), mat, hitAstro);\n\n    return normalize (vec3 (gradX, gradY, gradZ));\n}\n\nfloat luminance(vec3 rgb)\n{\n    return dot(rgb, vec3(0.2125, 0.7154, 0.0721));\n}\n\nvec3 sampleSpaceSuitTexture (vec3 p, vec3 norm)\n{\n    p *= 0.2;\n    float lumVal;\n    if ( abs (norm.z) > 0.7 )\n        lumVal = luminance (texture (iChannel0, p.xy).rgb);\n    else if ( abs (norm.y) > 0.7 )\n        lumVal = luminance (texture (iChannel0, p.xz).rgb);\n    else\n        lumVal = luminance (texture (iChannel0, p.yz).rgb);\n    return vec3 (lumVal);\n}\n\nvec3 sampleStoneTexture (vec3 p, vec3 norm)\n{\n    p *= 0.002;\n    float lumVal;\n    if ( abs (norm.z) > 0.7 )\n        lumVal = luminance (texture (iChannel1, p.xy).rgb);\n    else if ( abs (norm.y) > 0.7 )\n        lumVal = luminance (texture (iChannel1, p.xz).rgb);\n    else\n        lumVal = luminance (texture (iChannel1, p.yz).rgb);\n    return vec3 (lumVal);\n}\n\nfloat whiteNoise(vec3 n)\n{ \n\treturn fract(sin(dot(n, vec3(12.9898, 4.1414, -31.43425))) * 43758.5453);\n}\n\nfloat starAtPos (vec3 uvw)\n{\n    return max (whiteNoise (floor (uvw * 500.0) * 0.02) - 0.996, 0.0);\n}\n\nvec4 mainCubemap (vec3 rayDir)\n{\n    vec4 fragColor = vec4 (0.0);\n    \n    for (int i = -1; i != 2; i++)\n\t    for (int j = -1; j != 2; j++)\n\t\t    for (int k = -1; k != 2; k++)\n\t\t\t    fragColor.rgb += starAtPos (rayDir + vec3 (float(i), float(j), float(k))*0.0001);\n        \n\tfragColor.rgb *= 0.037037037;\n    fragColor.rgb *= vec3 (0.5, 0.5, 1.0) * 130.0;\n    fragColor.rgb += starAtPos (rayDir) * vec3 (0.85, 0.85, 1.0) * 130.0;\n\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 curEye = vec3 (sin(iTime), 0.2, cos(iTime)) * 45.0;\n    vec3 sampleLook = normalize (-curEye);\n    \n    vec3 side = cross (vec3 (0.0, -1.0, 0.0), sampleLook);\n    vec3 up = cross (side, sampleLook);\n    if ( dot (up, vec3 (0.0, 1.0, 0.0)) < 0.0 ) up = -up;\n    \n    const float drawDistSq = DRAW_DISTANCE*DRAW_DISTANCE;\n    vec3 sampleDir = normalize (sampleLook + side * uv.x + up * uv.y);\n    vec3 samplePt = curEye + sampleDir;\n    vec3 colorAccum = vec3 (1.0);\n\n    samplePt = curEye + sampleDir;\n    bool samplingLight = false;\n    vec3 lightDir = normalize (vec3 (1.0, 1.0, 0.0));\n    vec3 norm;\n    float jj = 0.0;\n    const vec3 moonBlue = vec3 (0.118, 0.239, 0.463) * 2.0;\n    bool hitLuminare = false;\n\n    for (jj = 0.0; jj != 120.0; jj += 1.0) // Sometimes you just gotta give...\n    {\n        vec3 samplePtToEye0 = samplePt - curEye;\n        float distToSamplePtSq0 = dot (samplePtToEye0,samplePtToEye0);\n        vec4 sceneMat = vec4 (1.0);\n        bool hitAstro = false;\n        float curDist = scene (samplePt, sceneMat, hitAstro);\n        if (abs(curDist) < 0.001 )\n        {\n            if ( samplingLight )\n            {\n                // Hit an obstacle...\n                // ... don't lighten-up/darken as much... give a sense of G.I.\n                colorAccum *= (dot (sampleDir, norm) + 1.0) * 0.15 * moonBlue;\n                break;\n            }\n            else\n            {\n                norm = sceneNorm(samplePt);\n                colorAccum *= sceneMat.rgb;\n                if ( colorAccum == vec3 (0.0) ) break;\n                if ( hitAstro ) \n                {\n                    if ( sceneMat.a == 0.0 ) // Diffuse hit... space suit\n                    {\n                        colorAccum *= sampleSpaceSuitTexture (samplePt, norm);\n                        samplingLight = true;\n                        sampleDir = lightDir;\n                        samplePt += sampleDir * 0.01;\n                    }\n                    else // Specular hit... helmet visor/shield\n                    {\n                        sampleDir = reflect (sampleDir, norm);\n                        samplePt += sampleDir * 0.01;\n                    }\n                }\n                else\n                {\n                    if ( sceneMat.a == 0.0 ) // Diffuse hit... ground/pebbles\n                    {\n                        colorAccum *= sampleStoneTexture (samplePt, norm);\n                        samplingLight = true;\n                        sampleDir = lightDir;\n                        samplePt += sampleDir * 0.01;\n                    }\n                    else if (sceneMat.a == 1.0) // Specular hit... water\n                    {\n                        vec3 waterJitter = (texture (iChannel1, samplePt.xz * vec2 (0.1, 0.05)).rgb - vec3(0.5)) * 0.2;\n                        sampleDir = normalize (reflect (sampleDir, norm) + waterJitter);\n                        samplePt += sampleDir * 0.01;\n                    }\n                    else // Luminare hit...\n                    {\n                        float gradientAmount = 1.0 - clamp (abs (22.0 - samplePt.y)/29.0, 0.0, 1.0);\n                        gradientAmount = sqrt (gradientAmount);\n                        colorAccum *= mix (vec3 (1.0, 0.0, 1.0), vec3 (1.0, 1.0, 1.0), gradientAmount);\n                        hitLuminare = true;\n                        break;\n                    }\n                }\n            }\n        }\n        samplePt += curDist*sampleDir;\n        vec3 samplePtToEye = samplePt - curEye;\n        if ( dot (samplePtToEye,samplePtToEye) > drawDistSq )\n        {\n            if ( !samplingLight ) colorAccum = mainCubemap(sampleDir).rgb;\n            else colorAccum *= (dot (sampleDir, norm) + 1.0) * 0.5 * moonBlue;\n            break ;\n        }\n    }\n    \n    if ( jj == 120.0 ) colorAccum = vec3 (0.0); // We got stuck in SDF distortions, just cut it out...\n\n    fragColor = vec4 (colorAccum, hitLuminare ? 1.0 : 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/***********************************************************\n\n   And ANOTHER beeple cover: MONOLITH ASTRONAUT!\n   In this one I actually dared to distort an SDF with an FBM! =o\n   Reference: https://c.wallhere.com/photos/71/8e/beeple_render_men_landscape_astronaut_rocks_Monolith_neon-1292371.jpg!d\n   All your SDFs are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2019 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixelWH = 1.0/iResolution.xy;\n\n    float finalRes = 0.0;\n    float totalW = 0.0;\n    for (int i = -50; i != 51; i++)\n    {\n        vec4 neighFetch = texture (iChannel0, uv + vec2 (float(i) * pixelWH.x, 0.0));\n        float x_b = abs (float(i) * 0.02);\n        float curWeight = exp (x_b*x_b * -10.0);\n        finalRes += neighFetch.a * curWeight;\n        totalW += curWeight;\n    }\n\tfinalRes /= totalW;\n    \n    fragColor = vec4 (finalRes);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/***********************************************************\n\n   And ANOTHER beeple cover: MONOLITH ASTRONAUT!\n   In this one I actually dared to distort an SDF with an FBM! =o\n   Reference: https://c.wallhere.com/photos/71/8e/beeple_render_men_landscape_astronaut_rocks_Monolith_neon-1292371.jpg!d\n   All your SDFs are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2019 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixelWH = 1.0/iResolution.xy;\n\n    float finalRes = 0.0;\n    float totalW = 0.0;\n    for (int i = -50; i != 51; i++)\n    {\n        vec4 neighFetch = texture (iChannel0, uv + vec2 (0.0, float(i) * pixelWH.y));\n        float x_b = abs (float(i) * 0.02);\n        float curWeight = exp (x_b*x_b * -10.0);\n        finalRes += neighFetch.a * curWeight;\n        totalW += curWeight;\n    }\n\tfinalRes /= totalW;\n    \n    fragColor = vec4 (finalRes);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}