{
    "Shader": {
        "info": {
            "date": "1531096682",
            "description": "Scene used in \"Digiverse\"",
            "flags": 0,
            "hasliked": 0,
            "id": "Xd3BW2",
            "likes": 97,
            "name": "Digiverse - worms (a.ka pasta)",
            "published": 3,
            "tags": [
                "raymarching",
                "intro"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 5681
        },
        "renderpass": [
            {
                "code": "/* \n\n    Worms from \"Digiverse\" (demoscene producion)\n\t\n    https://www.youtube.com/watch?v=p5p_qWKrKj0\n    http://www.pouet.net/prod.php?which=76719\n\n\n*/\n\n\n/*\n\thttp://bit.ly/shadertoy-plugin\n*/\n\n\n\n\n\n#pragma optimize(off)\n\n\n\n\n\n\n#define FAR 10.\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 80.0\n#define FOG .4\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nvec3 light = vec3(0.0);\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCross(vec3 p, vec3 size) {\n\treturn min(fBox(p, size), min(fBox(p, size.zxy), fBox(p, size.yzx)));\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// pasta\nfloat spi(vec3 p, bool hole) {\n    vec3 op = p;\n\n    pR(p.yz, p.x * .4);    \n    \n    float y = pModPolar(p.zy, 3.);\n    \n    p.z -= .09 + sin(p.z) * .07;\n    \n    pR(p.yz, p.x * 5.);    \n    \n    float x = pModPolar(p.zy, 5.);\n\t\n    p.z -= .01;\n    p.z -= (.03 + x / 65. + sin(p.z * 3. + y / 34.) * .43) * .3;\n\t\n    op.x -= y * .01 + x * .01;\n    \n \tfloat l = length(p.zy) - .01 - sin(p.z) * 0.03;\n    if (hole) return l;\n\treturn max(l, op.x - iTime * .3 + .15);\n        \n}\n\n// scene\nvec3 map(vec3 p) {\n    vec3 op = p;\n    vec3 obj = vec3(0, 1., 1.0), \n        obj2 = vec3(FAR, 2., 0.);\n\n    vec3 orgP = p;\n \n    p = opRep(orgP, vec3(.5));\n    \n    vec3 size = vec3(0.2, .32, .1 );\n    \n    #define C size *= 1.1; p = opRep(orgP, vec3(0.35) + size.y + size.z); obj = opS2(obj, vec3(fCross(p, size) + .05, 0.0, 1.));\n    \n    // add or remove C :)\n    C C C\n    \n    vec3 p2 = op;\n    \n    p2.y -= .4;\n    p2.z -= 4.8;\n\t\n    op.yz -= vec2(.4, 4.8);\n    \n    if (length(op.zy) - .15 < 0.1) {\n        obj.x = max(obj.x, -spi(p2, true) + .02);\n        obj2.x = spi(p2, false);\n    } else { \n     \tobj2.x = length(op.zy) - .15;   \n    }\n    \n    return opU2(obj, obj2);\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 t = vec3(0., -1., 0.0), d;\n    for (int i = 0; i < 70; i++) {\n        d = map(ro + rd * t.x);\n        if (abs(d.x) < 0.001 || t.x > FAR) break;\n        t.x += d.x * .7; \n    }\n    t.yz = d.yz;\n    return t;\n}\n\nvec3 traceRef(vec3 ro, vec3 rd) {\n    vec3 t = vec3(0., 1., 0.), d;\n\n    for (int i = 0; i < 36; i++) {\n        d = map(ro + rd * t.x);\n        if (abs(d.x) < 0.001 || t.x> FAR) break;\n        t.x += d.x;\n    }\n    t.yz = d.yz;\n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 18;\n    vec3 rd = (lp - ro);\n\n    float shade = 1.0;\n    float dist = .01;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.55), 1.0);\n}\n\nvec3 getNormal(in vec3 pos) {\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 normal = vec3(\n        map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n        map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n        map(pos + eps.yyx).x - map(pos - eps.yyx).x);\n    return normalize(normal);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal) {\n    float dist = .05;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).x;\n    return clamp(sdist / dist, 0.4, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, vec2 mat) {\n    if (mat.x == 0.0) return vec3(.0, .0, .1) + vec3(0., 1., 1.) * smoothstep(0.1, .0, fract(p.y * 9.));\n    if (mat.x == 2.0) return vec3(.8, .0, .4) + floor(.1 + fract(p.x * 14. - 3. * iTime));\n    \n    return vec3(.0);\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec2 mat) {\n\tvec3 ld = lp - sp; \n    float lDist = max(length(ld), 0.001);\n    ld /= lDist; \n\n    float atten = 2.0 / (1.0 + lDist * 0.525 + lDist * lDist * 0.05);\n\tfloat diff = max(dot(sn, ld), .1);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.0), 1.0);\n\n    vec3 objCol = getObjectColor(sp, sn, mat);\n\n    if (mat.x == 2.) spec = 0.;\n    \n    return (objCol * (diff + 0.15) + vec3(.1, .1, .1) * spec * .8) * atten;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    \n    uv *= tan(radians (FOV) / 2.0) * 2.;\n    uv.y += sin(t * 3. + cos(4.*-t)) * 0.03;\n    \n    float \n        sk = sin(t * .3) * 22.0,\n        ck = cos(t * .3) * 22.0,\n        \n        mat = 0.;\n        \n    light = vec3(0., 1., 1.);        \n    \n    vec3 sceneColor = vec3(0.);\n    \n    vec3 \n        vuv = normalize(vec3(0., 1., sin(iTime) * .3)), // up\n    \tro = vec3(t * .3 , 0.4 , 5.12 ), \n        oro,\n    \tvrp =  vec3(t * .3 - 18. + ck, 0.4, -43. + sk ),\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n                \n\n    vec3 lp = light + ro;\n\n    vec3 tr = trace(ro, rd), otr = tr;    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x * 3.);\n    \n    ro += rd * tr.x;\n    float d = tr.x;\n\n    vec3 sn = getNormal(ro);\t\n    float ao = getAO(ro, sn);\n    \n    sceneColor += doColor(ro, rd, sn, lp, tr.yz) * 4.;\n    float sh = softShadow(ro, lp, 1.);\n    \n    rd = reflect(rd, sn);\n    \n    tr = traceRef(ro + rd * .015, rd);\n\tro += rd * tr.x;\n    \n    sn = getNormal(ro);\n   \n    sceneColor += doColor(ro, rd, sn, lp, tr.yz);        \n    sceneColor *= sh * fog * ao;\n\n    fragColor = vec4(clamp(sceneColor, 0.0, 1.0), d);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}