{
    "Shader": {
        "info": {
            "date": "1627348622",
            "description": "fork of: https://www.shadertoy.com/view/tdSXzD",
            "flags": 0,
            "hasliked": 0,
            "id": "fl2Szm",
            "likes": 10,
            "name": "Sun sky clouds aurora",
            "published": 3,
            "tags": [
                "reflection",
                "sunset",
                "clouds",
                "aurora",
                "atmosphere",
                "sunrise"
            ],
            "usePreview": 1,
            "username": "nide",
            "viewed": 1085
        },
        "renderpass": [
            {
                "code": "// fork of: https://www.shadertoy.com/view/tdSXzD\n/* \n Changes: \n - tweaked constants\n - replaced ambigous macro named t with tAdj\n - removed simple sun and rain drops\n*/\n\n\n// The sun, the sky and the clouds. By StillTravelling\n// https://www.shadertoy.com/view/tdSXzD\n// Very much a messy hack sorry!!\n\n// Many Thank yous go to the below for their amazing work\n// Day and night sky cycle. By László Matuska (@BitOfGold)\n// Creates a sky texture for a skydome\n// https://www.shadertoy.com/view/ltlSWB\n\n// Weather. By David Hoskins, May 2014.\n// https://www.shadertoy.com/view/4dsXWn\n\n// Edge of atmosphere\n// created by dmytro rubalskyi (ruba)\n// https://www.shadertoy.com/view/XlXGzB\n\n// Auroras\n// created by nimitz\n// https://www.shadertoy.com/view/XtGGRt\n\n// Sorry to those I've missed out!!\n\n//#define tAdj (iTime*4.3)\n#define tAdj (2140.+iTime*0.35)\n\n#define ORIG_CLOUD 0\n#define NICE_HACK_SUN 1\n#define SOFT_SUN 1\n#define cloudy  (sin(tAdj*0.1)*sin(tAdj*0.42)*0.35+0.55) //0.0 clear sky\n#define haze  0.002 * (cloudy*50.)\n#define rainmulti (sin(tAdj*0.2+1.)*0.35+0.35)*16. // makes clouds thicker\n#define rainy (20.0 -rainmulti)\n#define fov tan(radians(50.0))\n#define S(x, y, z) smoothstep(x, y, z)\n#define cameraheight 15e1 //50.\n#define mincloudheight 5e3 //5e3\n#define maxcloudheight 8e3 //8e3\n#define xaxiscloud tAdj*2e2 //t*5e2 +t left -t right *speed\n#define yaxiscloud 0. //0.\n#define zaxiscloud tAdj*3e2 //t*6e2 +t away from horizon -t towards horizon *speed\n#define cloudnoise 18e-5 //2e-4\n\n//#define cloud2\n\n\n//Performance\nconst int steps = 16; //16 is fast, 128 or 256 is extreme high\nconst int stepss = 16; //16 is fast, 16 or 32 is high \n\n//Environment\nconst float R0 = 6360e3; //planet radius //6360e3 actual 6371km\nconst float Ra = 6380e3; //atmosphere radius //6380e3 troposphere 8 to 14.5km\nconst float I = 10.; //sun light power, 10.0 is normal\nconst float SI = 10.; //sun intensity for sun\nconst float g = 0.5; //light concentration .76 //.45 //.6  .45 is normaL\nconst float g2 = g * g;\n\nconst float ts= (cameraheight / 2.5e5);\n\nconst float s = 0.9999; //light concentration for sun\n#if SOFT_SUN\nconst float s2 = s;\n#else\nconst float s2 = s * s;\n#endif\nconst float Hr = 8e3; //Rayleigh scattering top //8e3\nconst float Hm = 1.2e3; //Mie scattering top //1.3e3\n\nvec3 bM = vec3(21e-6); //normal mie // vec3(21e-6)\n//vec3 bM = vec3(50e-6); //high mie\n\n//Rayleigh scattering (sky color, atmospheric up to 8km)\nvec3 bR = vec3(5.8e-6, 13.5e-6, 33.1e-6); //normal earth\n//vec3 bR = vec3(5.8e-6, 33.1e-6, 13.5e-6); //purple\n//vec3 bR = vec3( 63.5e-6, 13.1e-6, 50.8e-6 ); //green\n//vec3 bR = vec3( 13.5e-6, 23.1e-6, 115.8e-6 ); //yellow\n//vec3 bR = vec3( 5.5e-6, 15.1e-6, 355.8e-6 ); //yeellow\n//vec3 bR = vec3(3.5e-6, 333.1e-6, 235.8e-6 ); //red-purple\n\nvec3 C = vec3(0., -R0, 0.); //planet center\nvec3 Ds = normalize(vec3(0., 0., -1.)); //sun direction?\n\nfloat cloudyhigh = 0.05; //if cloud2 defined\n\n#if ORIG_CLOUD\nfloat cloudnear = 1.0; //9e3 12e3  //do not render too close clouds on the zenith\nfloat cloudfar = 1e3; //15e3 17e3\n#else\nfloat cloudnear = 1.0; //15e3 17e3\nfloat cloudfar = 41e3; //160e3  //do not render too close clouds on the horizon 160km should be max for cumulus\n#endif\n\n\n\n\n//AURORA STUFF\nmat2 mm2(in float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\n\nfloat tri(in float x){\n    return clamp(abs(fract(x)-.5),0.01,0.49);\n}\n\nvec2 tri2(in vec2 p){\n    return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));\n}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(tAdj*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= 1.45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    ro *= 1e-5;\n    float mt = 10.;\n    for(float i=0.;i<5.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i*mt);\n        float pt = ((.8+pow((i*mt),1.2)*.001)-rd.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = (ro) + pt*rd;\n        vec2 p = bpos.zx;\n        //vec2 p = rd.zx;\n        float rzt = triNoise2d(p, 0.1);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+(i*mt)*0.053)*(0.5*mt))*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2((-i*mt)*0.04 - 2.5)*smoothstep(0.,5., i*mt);\n\n    }\n\n    col *= (clamp(rd.y*15.+.4,0.,1.2));\n    return col*2.8;\n}\n\n//END AURORA STUFF\n\nfloat noise(in vec2 v) { \n    return textureLod(iChannel0, (v+.5)/256., 0.).r; \n}\n\n// by iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fnoise( vec3 p, in float t )\n{\n\tp *= .25;\n    float f;\n\n\tf = 0.5000 * Noise(p); p = p * 3.02; p.y -= t*.1; //t*.05 speed cloud changes\n\tf += 0.2500 * Noise(p); p = p * 3.03; p.y += t*.06;\n\tf += 0.1250 * Noise(p); p = p * 3.01;\n\tf += 0.0625   * Noise(p); p =  p * 3.03;\n\tf += 0.03125  * Noise(p); p =  p * 3.02;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n\nfloat cloud(vec3 p, in float t ) {\n\tfloat cld = fnoise(p*cloudnoise,t) + cloudy*0.1 ;\n\tcld = smoothstep(.4+.04, .6+.04, cld);\n\tcld *= cld * (5.0*rainmulti);\n\treturn cld+haze;\n}\n\nvoid densities(in vec3 pos, out float rayleigh, out float mie) {\n\tfloat h = length(pos - C) - R0;\n\trayleigh =  exp(-h/Hr);\n\tvec3 d = pos;\n    d.y = 0.0;\n    float dist = length(d);\n    \n\tfloat cld = 0.;\n\tif (mincloudheight < h && h < maxcloudheight) {\n\t\t//cld = cloud(pos+vec3(t*1e3,0., t*1e3),t)*cloudy;\n        cld = cloud(pos+vec3(xaxiscloud,yaxiscloud, zaxiscloud),tAdj)*cloudy; //direction and speed the cloud movers\n\t\tcld *= sin(3.1415*(h-mincloudheight)/mincloudheight) * cloudy;\n\t}\n\t#ifdef cloud2\n        float cld2 = 0.;\n        if (12e3 < h && h < 15.5e3) {\n            cld2 = fnoise(pos*3e-4,tAdj)*cloud(pos*1.*14.0+vec3(2.3, 0.001,2.0)*vec3(xaxiscloud,yaxiscloud, zaxiscloud), tAdj);\n            cld2 *= sin(3.1413*(h-12e3)/12e3) * cloudyhigh;\n            cld2 = clamp(cld2,0.0,1.0);\n        }\n    \n    #endif\n\n    #if ORIG_CLOUD\n    if (dist<cloudfar) {\n        float factor = clamp(1.0-((cloudfar - dist)/(cloudfar-cloudnear)),0.0,1.0);\n        cld *= factor;\n    }\n    #else\n\n    if (dist>cloudfar) {\n\n        float factor = clamp(1.0-((dist - cloudfar)/(cloudfar-cloudnear)),0.0,1.0);\n        cld *= factor;\n    }\n    #endif\n\n\tmie = exp(-h/Hm) + cld + haze;\n\t#ifdef cloud2\n\t\tmie += cld2;\n\t#endif\n    \n}\n\n\n\nfloat escape(in vec3 p, in vec3 d, in float R) {\n\tvec3 v = p - C;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n// this can be explained: http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvoid scatter(vec3 o, vec3 d, out vec3 col, out vec3 scat, in float t) {\n    \n\tfloat L = escape(o, d, Ra);\t\n\tfloat mu = dot(d, Ds);\n\tfloat opmu2 = 1. + mu*mu;\n\tfloat phaseR = .0596831 * opmu2;\n\tfloat phaseM = .1193662 * (1. - g2) * opmu2 / ((2. + g2) * pow(1. + g2 - 2.*g*mu, 1.5));\n    float phaseS = .1193662 * (1. - s2) * opmu2 / ((2. + s2) * pow(1. + s2 - 2.*s*mu, 1.5));\n\t\n\tfloat depthR = 0., depthM = 0.;\n\tvec3 R = vec3(0.), M = vec3(0.);\n\t\n\tfloat dl = L / float(steps);\n\tfor (int i = 0; i < steps; ++i) {\n\t\tfloat l = float(i) * dl;\n\t\tvec3 p = (o + d * l);\n\n\t\tfloat dR, dM;\n\t\tdensities(p, dR, dM);\n\t\tdR *= dl; dM *= dl;\n\t\tdepthR += dR;\n\t\tdepthM += dM;\n\n\t\tfloat Ls = escape(p, Ds, Ra);\n\t\tif (Ls > 0.) {\n\t\t\tfloat dls = Ls / float(stepss);\n\t\t\tfloat depthRs = 0., depthMs = 0.;\n\t\t\tfor (int j = 0; j < stepss; ++j) {\n\t\t\t\tfloat ls = float(j) * dls;\n\t\t\t\tvec3 ps = ( p + Ds * ls );\n\t\t\t\tfloat dRs, dMs;\n\t\t\t\tdensities(ps, dRs, dMs);\n\t\t\t\tdepthRs += dRs * dls;\n\t\t\t\tdepthMs += dMs * dls;\n\t\t\t}\n\n\t\t\tvec3 A = exp(-(bR * (depthRs + depthR) + bM * (depthMs + depthM)));\n\t\t\tR += (A * dR);\n\t\t\tM += A * dM ;\n\t\t} else {\n\t\t}\n\t}\n\n\t//col = (I) * (R * bR * phaseR + M * bM * (phaseM ));\n    col = (I) *(M * bM * (phaseM )); // Mie scattering\n    #if NICE_HACK_SUN\n    col += (SI) *(M * bM *phaseS); //Sun\n    #endif\n    col += (I) *(R * bR * phaseR); //Rayleigh scattering\n    scat = 0.1 *(bM*depthM);\n    //scat = 0.0 + clamp(depthM*5e-7,0.,1.); \n}\n\n\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*2.5;\n\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat AR = iResolution.x/iResolution.y;\n    float M = 1.0; //canvas.innerWidth/M //canvas.innerHeight/M --res\n    \n    \n    vec2 uvMouse = (iMouse.xy / iResolution.xy);\n    uvMouse.x *= AR;\n    \n    \n   \tvec2 uv0 = (fragCoord.xy / iResolution.xy);\n    uv0 *= M;\n\t//uv0.x *= AR;\n    \n    vec2 uv = uv0 * (2.0*M) - (1.0*M);\n    uv.x *=AR;\n    \n  \n    if (uvMouse.y == 0.) uvMouse.y=(0.7-(0.05*fov)); //initial view \n    if (uvMouse.x == 0.) uvMouse.x=(1.0-(0.05*fov)); //initial view\n    \n    vec2 spos = uvMouse.xy;\n    float tPos = tAdj*0.02;\n    spos.y=(1.0-(0.4*fov)*(sin(tPos)*0.5+0.5)); //initial view \n    spos.y*=spos.y;\n    spos.x=0.8-sin(tPos*4.0)*0.5;\n    \n\n\tDs = normalize(vec3(spos.x-((0.6*AR)), spos.y*0.3-0.1, (fov/-2.0)));\n    \n    \n\tvec3 O = vec3(0., cameraheight, 0.);\n\tvec3 D = normalize(vec3(uv, -(fov*M)));\n\n\tvec3 color = vec3(0.);\n    vec3 scat = vec3(0.);\n\n    //float scat = 0.;\n\tfloat att = 1.;\n    float staratt = 1.;\n    float scatatt = 1.;\n\tvec3 star = vec3(0.);\n    vec4 aur = vec4(0.);\n\n    float fade = smoothstep(0.,0.01,abs(D.y))*0.5+1.4;\n\n\n    \n    staratt = 1. -min(1.0,(spos.y*2.0));\n    scatatt = 1. -min(1.0,(spos.y*2.2));\n\n\tif (D.y < -ts) {\n\t\tfloat L = - O.y / D.y;\n\t\tO = O + D * L;\n        D.y = -D.y;\n\t\tD = normalize(D+vec3(0,.003*sin(tAdj+6.2831*noise(O.xz+vec2(0.,-tAdj*5e2))),0.));\n\t\tatt = .55;\n        star = stars(D);\n        spos.y < 0.5 ? aur = smoothstep(0.0,2.5,aurora(O,D)):aur = aur;\n\t}\n    else{\n     \tfloat L1 =  O.y / D.y;\n\t\tvec3 O1 = O + D * L1;\n\n    \tvec3 D1 = vec3(1.);\n    \tD1 = normalize(D+vec3(1.,0.0009*sin(tAdj+6.2831*noise(O1.xz+vec2(0.,tAdj*0.8))),0.));\n    \tstar = stars(D1);\n        spos.y < 0.5 ? aur = smoothstep(0.,1.5,aurora(O,D))*fade:aur = aur;\n    }\n\n    star *= att;\n    star *= staratt;\n\n    scatter(O, D, color, scat, tAdj);\n    color *= att;\n    scat *=  att;\n    scat *= scatatt;\n\n    \n    color += scat;\n    color += star;\n    //color=color*(1.-(aur.a)*scatatt) + (aur.rgb*scatatt);\n    color += aur.rgb*scatatt;\n    \n\t//float env = pow( smoothstep(.5, iResolution.x / iResolution.y, length(uv*0.8)), 0.0);\n\tfragColor = vec4(pow(color, vec3(1.0/1.2)), 1.); //gamma correct\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}