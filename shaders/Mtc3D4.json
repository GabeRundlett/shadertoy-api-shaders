{
    "Shader": {
        "info": {
            "date": "1469381340",
            "description": "good old marble madness - not perfect but its kind of working...\n",
            "flags": 48,
            "hasliked": 0,
            "id": "Mtc3D4",
            "likes": 20,
            "name": "[SH16C] marble madness",
            "published": 3,
            "tags": [
                "game",
                "marble",
                "madness",
                "sh16c"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 2148
        },
        "renderpass": [
            {
                "code": "vec3 getVal(vec3 pos)\n{\n    vec3 c=texture(iChannel0,pos.xy/iResolution.xy).xyz;\n    if(pos.x+pos.y<6.) return vec3(-100,0,0);\n    c.x+=dot((fract(pos.xy)-.5),c.zy*vec2(-1,1));\n    c.x*=.2;\n    return c;\n}\n\nvec3 nextCellPos(vec3 pos, vec3 dir)\n{\n    vec3 s=vec3(sign(dir.xy),1);\n    //pos+=dir*0.00001;\n    pos*=s;\n    dir*=s;\n    // upper and right edge\n    vec2 c = (ceil(pos.xy)-pos.xy)/dir.xy;\n    return (pos+min(c.x,c.y)*dir)*s;\n}\n\nvec3 getDistance(vec3 pos)\n{\n    vec3 posC = floor(pos)+.5;\n    vec3 c = getVal(posC);\n    posC.z=c.x;\n    vec3 n = normalize(vec3(-.2*c.zy*vec2(-1,1),1));\n    vec3 d=n*dot(n,pos-posC);\n    vec3 posn,dn,nn;\n    nn = vec3( 1,0,0); posn = posC-nn*.501; posn.z=pos.z; dn = nn*dot(nn,pos-posn);\n    if(getVal(posn).x>pos.z && length(dn)<length(d) ) d=dn;\n    nn = vec3(-1,0,0); posn = posC-nn*.501; posn.z=pos.z; dn = nn*dot(nn,pos-posn);\n    if(getVal(posn).x>pos.z && length(dn)<length(d) ) d=dn;\n    nn = vec3(0, 1,0); posn = posC-nn*.501; posn.z=pos.z; dn = nn*dot(nn,pos-posn);\n    if(getVal(posn).x>pos.z && length(dn)<length(d) ) d=dn;\n    nn = vec3(0,-1,0); posn = posC-nn*.501; posn.z=pos.z; dn = nn*dot(nn,pos-posn);\n    if(getVal(posn).x>pos.z && length(dn)<length(d) ) d=dn;\n    return d;\n}\n\nvoid getPosNormal(inout vec3 pos, vec3 dir, out vec3 n)\n{\n    vec3 oldpos=pos;\n    vec3 c;\n    for(int i=0;i<100;i++)\n    {\n   \t\tc = getVal(pos);\n        if(c.x>pos.z) { /*pos=oldpos; c=getVal(pos);*/ break; }\n        oldpos = pos;\n\t    pos=nextCellPos(pos+dir*0.0011,dir)-dir*0.001;\n    }\n    float step=0.5;\n    float d=1000.;\n    float side=0.;\n    for(int i=0;i<100;i++)\n    {\n        vec3 c=getVal(oldpos+dir*.0011);\n        if(c.x>oldpos.z) { side=1.; pos=oldpos; break; }\n   \t\t/*c = getVal(pos);\n        if(sign(c.x-pos.z)!=sign(d))\n        {\n            step*=-.7;\n        }\n        d=c.x-pos.z;*/\n        step=0.7*length(getDistance(pos));\n        pos -= dir*step;\n        if(abs(step)<0.001) break;\n        //if(c.x<pos.z) break;\n    }\n    n=normalize(vec3(c.zy*vec2(-1,1)*.5,1.));\n    //if(abs(step)>=0.0001) n=vec3(0);\n    if(c.x<-16.) n=vec3(0);\n    if(side>0.5) if(fract(pos.x)>fract(pos.y)) n=vec3(1,0,0); else n=vec3(0,1,0);\n}\n\n#define Radius .65\nstruct Ball {\n    vec3 pos;\n    vec3 vel;\n};\n    \n#define InRes iChannelResolution[0].xy\n#define readSampler iChannel0\n    \nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\nvoid writeBall(Ball ball, inout vec4 fragColor, vec2 fragCoord)\n{\n    if(isPixel(0,0,fragCoord)) fragColor.xyz=ball.pos;\n    if(isPixel(1,0,fragCoord)) fragColor.xyz=ball.vel;\n}\n\nvoid readBall(out Ball ball)\n{\n    ball.pos=getPixel(0,0).xyz;\n    ball.vel=getPixel(1,0).xyz;\n}\n\nint getDigitMask(int d)\n{\n    if(d==0x0) return 0x00EAAAE;\n    if(d==0x1) return 0x004C444;\n    if(d==0x2) return 0x00E2E8E;\n    if(d==0x3) return 0x00E2E2E;\n    if(d==0x4) return 0x00AAE22;\n    if(d==0x5) return 0x00E8E2E;\n    if(d==0x6) return 0x00E8EAE;\n    if(d==0x7) return 0x00E2222;\n    if(d==0x8) return 0x00EAEAE;\n    if(d==0x9) return 0x00EAE2E;\n    if(d==0xa) return 0x004AAEA;\n    if(d==0xb) return 0x00CACAC;\n    if(d==0xc) return 0x0068886;\n    if(d==0xd) return 0x00CAAAC;\n    if(d==0xe) return 0x00E8C8E;\n    if(d==0xf) return 0x00E8C88;\n    return -1;\n}\n\n\n#define O_ 0x10\n#define I_ 0x11\n#define Z_ 0x12\n#define M_ 0x13\n#define H_ 0x14\n#define S_ 0x15\n#define G_ 0x16\n#define L_ 0x17\n#define X_ 0x18\n#define Q_ 0x19\n#define A_ 0x1A\n#define B_ 0x1B\n#define C_ 0x1C\n#define D_ 0x1D\n#define E_ 0x1E\n#define F_ 0x1F\n#define J_ 0x21\n#define N_ 0x22\n#define W_ 0x23\n#define K_ 0x24\n#define U_ 0x25\n#define P_ 0x26\n#define V_ 0x27\n#define T_ 0x28\n#define Y_ 0x29\n#define R_ 0x2A\n#define dot_ 0x30\n#define dot2_ 0x31\n#define space_ 0x32\n#define minus_ 0x33\n\nint getLetterMask(int d)\n{\n    if(d==O_) return 0x004AAA4; // O\n    if(d==I_) return 0x00E444E; // I\n    if(d==Z_) return 0x00E248E; // Z\n    if(d==M_) return 0x00AEEAA; // M\n    if(d==H_) return 0x00AAEAA; // H\n    if(d==S_) return 0x00E8E2E; // S\n    if(d==G_) return 0x00E8AAE; // G\n    if(d==L_) return 0x008888E; // L\n    if(d==X_) return 0x00EAEAE; // X\n    if(d==Q_) return 0x004AAA6; // q\n    if(d==A_) return 0x004AAEA; // A\n    if(d==B_) return 0x00CACAC; // B\n    if(d==C_) return 0x0068886; // C\n    if(d==D_) return 0x00CAAAC; // D\n    if(d==E_) return 0x00E8C8E; // E\n    if(d==F_) return 0x00E8C88; // F\n    if(d==J_) return 0x00E222C; // J\n    if(d==N_) return 0x00CAAAA; // N\n    if(d==W_) return 0x00AAEEA; // W\n    if(d==K_) return 0x00AACAA; // K\n    if(d==U_) return 0x00AAAAE; // U\n    if(d==P_) return 0x00CAAC8; // P\n    if(d==V_) return 0x00AAAA4; // V\n    if(d==T_) return 0x00E4444; // T\n    if(d==Y_) return 0x00AAE44; // Y\n    if(d==R_) return 0x00CAACA; // R\n    if(d==dot_) return 0x0000004; // .\n    if(d==dot2_) return 0x0004004; // :\n    if(d==space_) return 0x0000000; // _\n    if(d==minus_) return 0x0000E00; // _\n    return getDigitMask(d);\n}\n\n\nvoid drawLetter(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getLetterMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nvoid drawText(mat4 str, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    for(int i=0;i<4;i++)\n    {\n        bool breakIt=false;\n        for(int j=0;j<4;j++)\n        {\n            if(int(str[i][j])<0) { breakIt=true; break; }\n            drawLetter(int(str[i][j]),pos+size*vec2(4.0*float(i*4+j),0),size,fragColor,fragCoord);\n        }\n        if(breakIt) break;\n    }\n}\n\nvoid drawDigit(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getDigitMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nint getDigit(int n, int d)\n{\n    return int(mod(float(n)/pow(10.0,float(d)),10.0));\n}\n\nint getDigitF(float f, int d)\n{\n    if(d<0) return int(mod(f/pow(0.1,float(-d)),10.0));\n    return int(mod(f/pow(10.0,float(d)),10.0));\n}\n\nvoid drawInt(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    for(int i=0;i<100;i++) { if(n2-1>=n) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        if(i==dn) break;\n        drawDigit(getDigit(n,dn-1-i), pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\n\nvoid drawFloat(float f, int dotnum, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    if(f<0.0) { f=-f; drawLetter(minus_, pos, size, fragColor, fragCoord); pos+=vec2(4.0*size,0); }\n    for(int i=0;i<100;i++) { if(float(n2-1)>=f) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        int d;\n        if      (i<dn)  d=getDigitF(f,dn-1-i);\n        else if (i==dn) d=dot_;\n        else if (i>dn)  d=getDigitF(f,dn-1-i+1);\n        if(i==dn+dotnum+1) break;\n        drawLetter(d, pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\nvec3 readScoreStates()\n{\n  \treturn getPixel(2,0).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ball ball;\n    readBall(ball);\n\n    vec3 n;\n    vec3 dir=normalize(vec3(-1,-1,-.8));\n    vec3 bx=normalize(vec3(-1,1,0));\n    vec3 by=normalize(cross(bx,dir));\n    vec2 sc=(2.*fragCoord-iResolution.xy)/iResolution.x;\n    \n    vec3 pos0 = sqrt(.5)*(ball.pos.x+ball.pos.y)*normalize(vec3(1,1,0))+vec3(0,0,ball.pos.z);\n    vec3 pos=pos0-50.*dir+(sc.x*bx+sc.y*by)*17./sqrt(2.);\n    //pos+=vec3(1,1,0)*100.*fract(0.1*iTime);\n    getPosNormal(pos,dir,n);\n    vec3 l = normalize(vec3(-1,1,2));\n    vec3 diffCol=mix(vec3(0.3),vec3(0.7),\n        \tsmoothstep(.05,.1,fract(pos.x))*\n        \tsmoothstep(.05,.1,fract(pos.y))*\n        \t(1.-smoothstep(.9,.95,fract(pos.x)))*\n        \t(1.-smoothstep(.9,.95,fract(pos.y)))\n             \t);\n    if(n==vec3(0,1,0)) \n    { \n        diffCol=mix(vec3(.3),vec3(1,1,0),\n        \tsmoothstep(.05,.1,fract(pos.y))*\n        \t(1.-smoothstep(.9,.95,fract(pos.y))));\n        n=vec3(0,1,.5);\n    }\n    if(n==vec3(1,0,0)) \n    { \n        diffCol=mix(vec3(.3),vec3(1,0,0),\n        \tsmoothstep(.05,.1,fract(pos.x))*\n        \t(1.-smoothstep(.9,.95,fract(pos.x))));\n        n=vec3(1,0,.5);\n    }\n        \n    \n    float diff = max(0.5,dot(l,n));\n    \n    fragColor = vec4(diffCol*diff,1);\n    \n    drawText(mat4(G_,O_,A_,L_, -1,0,0,0, 0,0,0,0, 0,0,0,0), vec2(-73.7,-61), 0.4, fragColor, -pos.xy);\n    \n    vec3 spos = pos-ball.pos-dir*dot(pos-ball.pos,dir);\n    if(dot(ball.pos,dir)<dot(pos,dir) && length(spos)<Radius )\n    {\n        diffCol = vec3(1,0,0);\n        diff = .7-spos.y;\n\t    fragColor = vec4(diffCol*diff,1);\n    }\n        \n    \n    vec3 ss=readScoreStates();\n#define IS_IN(Coord,x1,y1,x2,y2) (Coord.x>float(x1) && Coord.y>float(y1) && Coord.x<float(x2) && Coord.y<float(y2))\n \n    vec2 tl=vec2(0,iResolution.y);\n    float scale=iResolution.x/350.;\n    if(ss.z>.5 && ss.y>0.)\n    \tdrawText(mat4(T_,I_,M_,E_, space_,B_,O_,N_, U_,S_,-1,0, 0,0,0,0), tl+vec2(10,-60)*scale, 3.*scale, fragColor,fragCoord);\n    drawInt(int(ss.x), tl+vec2(10,-30)*scale, 3.*scale, fragColor, fragCoord );\n    drawInt(int(ss.y), tl+vec2(100,-30)*scale, 3.*scale, fragColor, fragCoord );\n    //drawFloat(ball.pos.x, 2, vec2(10,50), 3., fragColor, fragCoord );\n    //drawFloat(ball.pos.y, 2, vec2(10,30), 3., fragColor, fragCoord );\n    \n    //vec3 d=getDistance(ball.pos);\n    //drawFloat(d.x, 2, vec2(10,50), 3., fragColor, fragCoord );\n    //drawFloat(d.y, 2, vec2(10,30), 3., fragColor, fragCoord );\n    //drawFloat(d.z, 2, vec2(10,10), 3., fragColor, fragCoord );\n    \n    //fragColor = vec4(0.5*n+.5,1);\n    //fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keyTex iChannel1\n#define KEY_LEFT  texture(keyTex,vec2(37.5/256.0,(0.5+0.0)/3.0)).x\n#define KEY_UP    texture(keyTex,vec2(38.5/256.0,(0.5+0.0)/3.0)).x\n#define KEY_RIGHT texture(keyTex,vec2(39.5/256.0,(0.5+0.0)/3.0)).x\n#define KEY_DOWN  texture(keyTex,vec2(40.5/256.0,(0.5+0.0)/3.0)).x\n\nvec3 getVal(vec3 pos)\n{\n    vec3 c=texture(iChannel0,pos.xy/iResolution.xy).xyz;\n    if(pos.x+pos.y<6.) return vec3(-100,0,0);\n    c.x+=dot((fract(pos.xy)-.5),c.zy*vec2(-1,1));\n    c.x*=.2;\n    return c;\n}\n\nvoid createLevel1( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c=vec3(-100.,0,0);\n\n    //vec2 coord=(vec2(0,iResolution.y)+fragCoord*vec2(1,-1))/1.;\n    vec2 coord=fragCoord.yx-1.;\n    \n    if(coord.x<33. && coord.y<33. && coord.x>6. && coord.y>6. )\n        c=vec3(0,0,0);\n    if(coord.x>30. && coord.y>30. && coord.x<45. && coord.y<46. )\n        c=vec3(0,0,0);\n    if(coord.x>45. && coord.y>38. && coord.x<51. && coord.y<46. )\n        c=vec3(0,0,0);\n    if(coord.x>47. && coord.y>38. && coord.x<51. && coord.y<56. )\n        c=vec3(0,0,0);\n    if(coord.x>51. && coord.y>52. && coord.x<57. && coord.y<56. )\n        c=vec3(0,0,0);\n    if(coord.x>57. && coord.y>52. && coord.x<61. && coord.y<73. )\n        c=vec3(0,0,0);\n\n    if(coord.x>0. && coord.y>0. && coord.x<30. && coord.y<30. )\n    {\n        vec2 coordC = ceil(coord/3.)*3.-vec2(1.5);\n        vec2 d=coord-coordC;\n        vec2 coord2=fract(coord/6.);\n        float h=13.5*((28.5-coordC.x)/27.)+13.5*((28.5-coordC.y)/27.);\n        if(coord2.x<0.5 && coord2.y<0.5)\n        \tc=vec3(h-(d.x+d.y),-1,1);\n        else if(coord2.x>=0.5 && coord2.y<0.5)\n        \tc=vec3(h-d.y,0,1);\n        else if(coord2.x<0.5 && coord2.y>=0.5)\n        \tc=vec3(h-d.x,-1,0);\n        else if(coord2.x>=0.5 && coord2.y>=0.5)\n        \tc=vec3(h,0,0);\n    }\n    \n    if(coord.x>24. && coord.y>24. && coord.x<33. && coord.y<33. )\n        c=vec3(0,0,0);\n    if(coord.x>21. && coord.y>21. && coord.x<27. && coord.y<27. )\n        c=vec3(0,0,0);\n    \n\n    if(coord.x>0. && coord.y>0. && coord.x<12. && coord.y<6. )\n        c=vec3(-100.,0,0);\n    if(coord.x>0. && coord.y>0. && coord.x<6. && coord.y<12. )\n        c=vec3(-100.,0,0);\n\n    if(coord.x>18. && coord.y>6. && coord.x<21. && coord.y<9. )\n        c=vec3(-100.,0,0);\n    if(coord.x>6. && coord.y>18. && coord.x<9. && coord.y<21. )\n        c=vec3(-100.,0,0);\n    if(coord.x>18. && coord.y>18. && coord.x<21. && coord.y<21. )\n        c=vec3(-100.,0,0);\n    if(coord.x>24. && coord.y>18. && coord.x<27. && coord.y<21. )\n        c=vec3(-100.,0,0);\n    if(coord.x>18. && coord.y>24. && coord.x<21. && coord.y<27. )\n        c=vec3(-100.,0,0);\n    \n    //towers\n    if(coord.x>21. && coord.y>24. && coord.x<23. && coord.y<27. )\n        c=vec3(6,0,0);\n    if(coord.x>24. && coord.y>21. && coord.x<27. && coord.y<23. )\n        c=vec3(6,0,0);\n    if(coord.x>20. && coord.y>23. && coord.x<22. && coord.y<25. )\n        c=vec3(9,0,0);\n    if(coord.x>23. && coord.y>20. && coord.x<25. && coord.y<22. )\n        c=vec3(9,0,0);\n    if(coord.x>18. && coord.y>21. && coord.x<21. && coord.y<24. )\n        c=vec3(12,0,0);\n    if(coord.x>21. && coord.y>18. && coord.x<24. && coord.y<21. )\n        c=vec3(12,0,0);\n\n#define IS_IN(Coord,x1,y1,x2,y2) (Coord.x>float(x1) && Coord.y>float(y1) && Coord.x<float(x2) && Coord.y<float(y2))\n#define FILL(x1,y1,x2,y2,val) if(IS_IN(coord,x1,y1,x2,y2)) c=val+vec3((coord.x-float(x1+x2)*.5)*val.y-(coord.y-float(y1+y2)*.5)*val.z,0,0);\n#define FILLYX(x1,y1,x2,y2,val) FILL(y1,x1,y2,x2,val)\n    \n   \tFILL( 29,49, 42,60, vec3(0,0,0) );\n   \tFILL( 28,59, 51,69, vec3(0,0,0) );\n   \tFILL( 51,65, 55,67, vec3(0,0,0) );\n   \tFILL( 53,67, 55,68, vec3(0,0,0) );\n   \tFILL( 53,68, 57,70, vec3(0,0,0) );\n   \tFILL( 61,68, 66,70, vec3(0,0,0) );\n   \tFILL( 64,54, 66,70, vec3(0,0,0) );\n   \tFILL( 64,44, 77,56, vec3(0,0,0) );\n   \tFILL( 54,34, 68,47, vec3(0,0,0) );\n   \tFILL( 48,30, 56,36, vec3(0,0,0) );\n   \tFILL( 38,18, 45,25, vec3(0,0,0) );\n   \tFILL( 18,38, 25,45, vec3(0,0,0) );\n   \tFILL( 36,23, 40,27, vec3(0,0,0) );\n   \tFILL( 23,36, 27,40, vec3(0,0,0) );\n   \tFILL( 37,24, 39,26, vec3(5,0,0) );\n   \tFILL( 24,37, 26,39, vec3(5,0,0) );\n    \n    FILL( 12,30, 15,33, vec3(7.5,-1,0) );\n    FILL( 15,30, 18,33, vec3(6.0,0,0) );\n    FILL( 18,30, 21,33, vec3(4.5,-1,0) );\n    FILL( 21,30, 24,33, vec3(1.5,-1,0) );\n    FILL( 21,27, 24,30, vec3(1.5,-1,0) );\n    \n    FILLYX( 12,30, 15,33, vec3(7.5,0,1) );\n    FILLYX( 15,30, 18,33, vec3(6.0,0,0) );\n    FILLYX( 18,30, 21,33, vec3(4.5,0,1) );\n    FILLYX( 21,30, 24,33, vec3(1.5,0,1) );\n    FILLYX( 21,27, 24,30, vec3(1.5,0,1) );\n    \n    //fragColor = vec4(c/vec3(30,1,1),1.);\n    fragColor = vec4(c,1.);\n}\n\n\n#define Radius .65\nstruct Ball {\n    vec3 pos;\n    vec3 vel;\n};\n    \n#define InRes iResolution.xy\n#define readSampler iChannel0\n    \nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\nvoid writeBall(Ball ball, inout vec4 fragColor, vec2 fragCoord)\n{\n    if(isPixel(0,0,fragCoord)) fragColor.xyz=ball.pos;\n    if(isPixel(1,0,fragCoord)) fragColor.xyz=ball.vel;\n}\n\nvoid readBall(out Ball ball)\n{\n    ball.pos=getPixel(0,0).xyz;\n    ball.vel=getPixel(1,0).xyz;\n}\n\nvoid writeScoreStates(vec3 ss, inout vec4 fragColor, vec2 fragCoord)\n{\n    if(isPixel(2,0,fragCoord)) fragColor.xyz=ss;\n}\n\nvec3 readScoreStates()\n{\n  \treturn getPixel(2,0).xyz;\n}\n\nvec3 getDistance(vec3 pos)\n{\n    vec3 posC = floor(pos)+.5;\n    vec3 c = getVal(posC);\n    posC.z=c.x;\n    vec3 n = normalize(vec3(-.2*c.zy*vec2(-1,1),1));\n    vec3 d=n*dot(n,pos-posC);\n    vec3 posn,dn,nn;\n    nn = vec3( 1,0,0); posn = posC-nn*.501; posn.z=pos.z; dn = nn*dot(nn,pos-posn);\n    if(getVal(posn).x>pos.z && length(dn)<length(d) ) d=dn;\n    nn = vec3(-1,0,0); posn = posC-nn*.501; posn.z=pos.z; dn = nn*dot(nn,pos-posn);\n    if(getVal(posn).x>pos.z && length(dn)<length(d) ) d=dn;\n    nn = vec3(0, 1,0); posn = posC-nn*.501; posn.z=pos.z; dn = nn*dot(nn,pos-posn);\n    if(getVal(posn).x>pos.z && length(dn)<length(d) ) d=dn;\n    nn = vec3(0,-1,0); posn = posC-nn*.501; posn.z=pos.z; dn = nn*dot(nn,pos-posn);\n    if(getVal(posn).x>pos.z && length(dn)<length(d) ) d=dn;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ball ball;\n    if(iFrame<10) \n    {\n        createLevel1(fragColor,fragCoord);\n        ball.vel=vec3(0);\n        ball.pos=vec3(12,12,5);\n\t    writeBall(ball,fragColor,fragCoord);\n        writeScoreStates(vec3(0,60.,0),fragColor,fragCoord);\n        return;\n    }\n \tfragColor=texture(iChannel0,fragCoord/iResolution.xy);\n\t//createLevel1(fragColor,fragCoord);\n    readBall(ball);\n    vec3 ss=readScoreStates();\n    vec3 dv = getDistance(ball.pos);\n    vec3 acc = vec3(0,0,-5);\n    acc+=\n        + KEY_LEFT *vec3( 1,-1,0)\n        + KEY_RIGHT*vec3(-1, 1,0)\n        + KEY_UP   *vec3(-1,-1,0)\n        + KEY_DOWN *vec3( 1, 1,0);\n    float ldv=length(dv);\n    if(ldv<Radius)\n    {\n    \tacc -= 150.*(ldv-Radius)*dv/ldv;\n        ball.vel -= 1.9*dv*dot(ball.vel,dv)/ldv/ldv;\n\t}\n    //acc -= 0.01*ball.vel;\n    if(length(ball.vel)>0.001)\n    ball.vel-=normalize(ball.vel)*(ss.z<.5?.01:.03);\n    float dt=min(2.*iTimeDelta,0.06);\n    ball.vel+=acc*dt;\n    ball.pos+=ball.vel*dt;\n    if(IS_IN(ball.pos,65,57,73,61))\n    {\n        if(ss.z<.5) { ss.z=1.; ss.x+=1000.; }\n    }\n    if(ss.z>.5 && ss.y>0.)\n    {\n    \tss.x+=iTimeDelta*10.*100.;\n    \tss.y-=iTimeDelta*10.;\n    }\n    if(ss.z<.5)\n    {\n    \tss.y=max(ss.y-iTimeDelta,0.);\n        ss.x+=iTimeDelta*length(ball.vel)*10.;\n    }\n\twriteScoreStates(ss,fragColor,fragCoord);\n\n    writeBall(ball,fragColor,fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}