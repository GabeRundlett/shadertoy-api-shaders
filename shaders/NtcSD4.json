{
    "Shader": {
        "info": {
            "date": "1649689747",
            "description": "Hitomezashi is a kind of sashiko stitching, used to reinforce and patch together cloth in a simple but aesthetically pleasing way. Here I present a few patterns which I like.",
            "flags": 0,
            "hasliked": 0,
            "id": "NtcSD4",
            "likes": 3,
            "name": "Hitomezashi",
            "published": 3,
            "tags": [
                "2d",
                "simple",
                "pattern",
                "stitching",
                "hitomezashi",
                "2colorable",
                "sashiko",
                "threadwork"
            ],
            "usePreview": 0,
            "username": "AJFarmar",
            "viewed": 202
        },
        "renderpass": [
            {
                "code": "#define MAX_PATTERN_LENGTH 10\n\n\n// We define the patterns here\n// This version of GL doesn't allow for lists of lists, so we have to do it this way.\nconst int[] v_edges_0 = int[](1, 1, 0, 1, 0, 0, 1, 0);\nconst int[] h_edges_0 = int[](1, 0, 0, 1, 0, 1);\n\nconst int[] v_edges_1 = int[](1, 1, 0, 0);\nconst int[] h_edges_1 = int[](1, 1, 0);\n\nconst int[] v_edges_2 = int[](1, 1, 0, 0, 1, 0, 0);\nconst int[] h_edges_2 = int[](1, 1, 0, 0, 1, 0, 0);\n\nconst int[] v_edges_3 = int[](1, 1, 1, 0, 0, 0);\nconst int[] h_edges_3 = int[](1, 1, 0);\n\n// Integer modulo (%) in glsl is a joke! This one works properly.\nint intmod(int a, int m) {\n\tint res = a - (a/m)*m;\n\treturn res < 0 ? res + m : res;\n}\n\n// Is the low vertical edge on the cell (x,y) on?\nbool hitomezashi_edge_v(int x, int y, int pattern)\n{\n\t// Fetch the right pattern. Default 0.\n\tint v_edge = v_edges_0[intmod(x, v_edges_0.length())];\n\tif (pattern == 1) v_edge = v_edges_1[intmod(x, v_edges_1.length())];\n    if (pattern == 2) v_edge = v_edges_2[intmod(x, v_edges_2.length())];\n    if (pattern == 3) v_edge = v_edges_3[intmod(x, v_edges_3.length())];\n    return intmod(v_edge + y, 2) != 1;\n}\n\n// Is the low horizontal edge on the cell (x,y) on?\nbool hitomezashi_edge_h(int x, int y, int pattern)\n{\n\t// Fetch the right pattern. Default 0.\n\tint h_edge = h_edges_0[intmod(y, h_edges_0.length())];\n\tif (pattern == 1) h_edge = h_edges_1[intmod(y, h_edges_1.length())];\n    if (pattern == 2) h_edge = h_edges_2[intmod(y, h_edges_2.length())];\n    if (pattern == 3) h_edge = h_edges_3[intmod(y, h_edges_3.length())];\n    return intmod(h_edge + x, 2) != 1;\n}\n\n// The SDF for a hitomezashi pattern with a given cell size.\nfloat hitomezashi_SDF(float cell_size, vec2 coord, int pattern)\n{\n// Work out what cell we're in, and whereabouts in it we are.\n    vec2 coord_ = coord/cell_size,\n         cell_f = fract(coord_);\n\tint  cell_x = int(floor(coord_.x)),\n\t\t cell_y = int(floor(coord_.y));\n    \n    // Every corner is populated, so the distance is bounded above\n    // by the distances to each of the corners. We will reduce it from here.\n    float dist = min(\n        min( length(vec2(0.0, 0.0) - cell_f), length(vec2(0.0, 1.0) - cell_f) ),\n        min( length(vec2(1.0, 0.0) - cell_f), length(vec2(1.0, 1.0) - cell_f) )  );\n    \n    // Fetch +ve or -ve for every vertical/horizontal edge:\n    if (hitomezashi_edge_v(cell_x + 0, cell_y + 0, pattern)) dist = min(dist,       cell_f.x);\n    if (hitomezashi_edge_v(cell_x + 1, cell_y + 0, pattern)) dist = min(dist, 1.0 - cell_f.x);\n    if (hitomezashi_edge_h(cell_x + 0, cell_y + 0, pattern)) dist = min(dist,       cell_f.y);\n    if (hitomezashi_edge_h(cell_x + 0, cell_y + 1, pattern)) dist = min(dist, 1.0 - cell_f.y);\n\t\n\t// We're done!\n    return dist * cell_size;\n}\n\n// Check if a given square has the same color as the (0,0) square.\nbool hitomezashi_color(float cell_size, vec2 coord, int pattern)\n{\n\t// Fetch the right pattern's measurements. Default 0.\n\tint v_edges = v_edges_0.length();\n\tint h_edges = h_edges_0.length();\n\tif (pattern == 1)\n\t{\n\t\tv_edges = v_edges_1.length();\n\t\th_edges = h_edges_1.length();\n\t}\n    if (pattern == 2)\n\t{\n\t\tv_edges = v_edges_2.length();\n\t\th_edges = h_edges_2.length();\n\t}\n    if (pattern == 3)\n\t{\n\t\tv_edges = v_edges_3.length();\n\t\th_edges = h_edges_3.length();\n\t}\n\t\n    // Some hitomezashi patterns need to be repeated to tile the colors correctly.\n\t# define X_REPEATS 2\n    # define Y_REPEATS 2\n\tvec2 coord_ = coord/cell_size;\n\tint cell_x = intmod(int(floor(coord_.x)), X_REPEATS * v_edges),\n\t\tcell_y = intmod(int(floor(coord_.y)), Y_REPEATS * h_edges);\n\t\n\tbool same = true;\n\t\n    // We count the number of bold edges we cross going right\n\tint i;\n\tfor (i = 0; i < X_REPEATS * MAX_PATTERN_LENGTH; i++)\n\t{\n\t\tif (i == cell_x) break;\n\t\tif (hitomezashi_edge_v(i+1, 0, pattern)) same = !same;\n\t}\n\n\t// We count the number of bold edges we cross going up\n\tfor (int j = 0; j < Y_REPEATS * MAX_PATTERN_LENGTH; j++)\n\t{\n\t\tif (j == cell_y) break;\n\t\tif (hitomezashi_edge_h(i, j+1, pattern)) same = !same;\n\t}\n\t\n\treturn same;\n}\n\t\nvec3 hitomezashi_image(float cell_size, vec2 coord, int pattern,\n                       vec3 tile1, vec3 tile2, vec3 grouting)\n{\n    vec3 color = hitomezashi_color(cell_size, coord, pattern) ? tile1 : tile2;\n    float b = smoothstep(1.5, 2.5, hitomezashi_SDF(cell_size, coord, pattern));\n    color = mix(color, grouting, 1.0 - b);\n    return color;\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// I've chosen some colours I think are nice :)\n    vec3 p0 = hitomezashi_image(25.0, fragCoord + 40.0*iTime*vec2(1.0, 1.0), 0,\n        vec3(0.75, 0.7, 1.0), vec3(1.0), vec3(0.0));\n    vec3 p1 = hitomezashi_image(90.0, fragCoord + 80.0*iTime*vec2(1.0,-1.0), 1,\n        vec3(1.0, 0.8, 0.8), vec3(0, 0.3, 0.85), vec3(1.0));\n    vec3 p2 = hitomezashi_image(50.0, fragCoord + 50.0*iTime*vec2(1.25,0.5), 2,\n        vec3(fragCoord.x/iResolution.x), vec3(1.0 - fragCoord.x/iResolution.x), vec3(1.0));\n    float wobble = sin(5.0*fragCoord.x/iResolution.x);\n    vec3 p3 = hitomezashi_image(45.0, fragCoord + 20.0*iTime*vec2(0.5,-1.5), 3,\n        vec3(0.95, 0.95, 0.9), vec3(0.8, 0.7, 0.5-0.1*wobble), vec3(0.4 - 0.2*wobble));\n    vec3 pattern_img[] = vec3[](p0, p1, p2, p3);\n    \n    \n    // Cycle every 8 seconds\n    float transition_timing = iTime/8.0;\n    int cycle = intmod(int(transition_timing), pattern_img.length());\n    int next_cycle = intmod(cycle + 1, pattern_img.length());\n    float f = fract(transition_timing);\n    \n    vec3 color = mix(pattern_img[cycle], pattern_img[next_cycle], smoothstep(0.9, 1.0, f));\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}