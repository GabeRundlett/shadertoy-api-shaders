{
    "Shader": {
        "info": {
            "date": "1701899675",
            "description": "Part of my #ShadeCember series on linkedIn where I post one new shader every day.",
            "flags": 64,
            "hasliked": 0,
            "id": "mlVBzD",
            "likes": 3,
            "name": "Shadecember Horizon ",
            "published": 3,
            "tags": [
                "blackhole"
            ],
            "usePreview": 0,
            "username": "workingclasshacker",
            "viewed": 321
        },
        "renderpass": [
            {
                "code": "float hue2rgb(float p, float q, float t) {\n  if(t < 0.0) t += 1.0;\n  if(t > 1.0) t -= 1.0;\n  if(t < 1.0/6.0) return p + (q - p) * 6.0 * t;\n  if(t < 1.0/2.0) return q;\n  if(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;\n  return p;\n}\nvec3 hsl2rgb(float h, float s, float l) {\n  float r, g, b;\n\n  if (s == 0.0) {\n    r = g = b = l; // Achromatic\n    } else {\n    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n    float p = 2.0 * l - q;\n    r = hue2rgb(p, q, h + 1.0/3.0);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1.0/3.0);\n  }\n\n  return vec3(r, g, b);\n}\n\n\n// Function to create a 2D rotation matrix\nmat2 rotate2D(float angle){\n  float cosAngle = cos(angle);\n  float sinAngle = sin(angle);\n  return mat2(cosAngle, -sinAngle, sinAngle, cosAngle);\n}\n\nfloat noise(vec2 uv) {\n  return fract(sin(dot(uv.xy, vec2(112.9898, 78.233))) * 43758.5453);\n}\nfloat noise23(vec2 uv) {\n  return fract(sin(dot(uv.xy, vec2(13.9898, 121783.233))) * 1758.5453);\n}\nvec2 noise2(vec2 uv){\n  return vec2(noise(uv), noise23(fract(uv*12312.123123)+vec2(11234.2, 112123.4343110)));\n}\n\nfloat perlinNoise(vec2 c){\n  vec2 i = floor(c);\n  vec2 f = fract(c);\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(dot( noise2(i + vec2(0.0, 0.0) ), f - vec2(0.0, 0.0)), \n  dot( noise2(i + vec2(1.0, 0.0) ), f - vec2(1.0, 0.0)), u.x),\n  mix( dot( noise2(i + vec2(0.0, 1.0) ), f - vec2(0.0, 1.0)), \n  dot( noise2(i + vec2(1.0, 1.0) ), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n// Modified FBM function for smoother output\nfloat fbm(vec2 p) {\n  float total = 0.0;\n  float persistence = 0.5;\n  float amplitude = 1.0;\n  float maxValue = 0.0;  // Used for normalizing result to 0.0 - 1.0\n  for(int i = 0; i < 12; i++) {\n    total += perlinNoise(p) * amplitude;\n    maxValue += amplitude;\n    \n    amplitude *= persistence;\n    p *= 2.0;\n  }\n  return total/maxValue;\n}\n\n// Function to calculate brightness factor based on distance to event horizon\nfloat calculateBrightnessFactor(float distance, float eventHorizonRadius, float influenceZoneRadius) {\n  if (distance <= eventHorizonRadius) {\n    return 1.0; // Maximum brightness inside event horizon\n    } else if (distance <= influenceZoneRadius) {\n    float normalizedDistance = (distance - eventHorizonRadius) / (influenceZoneRadius - eventHorizonRadius);\n    return pow(1.0 - normalizedDistance, 3.0); // Cubic falloff for smoothness\n    } else {\n    return 0.0; // No additional brightness outside influence zone\n  }\n}\n\n// Modified nebulaColor function to include brightness factor calculation\nvec3 nebulaColor(float fbmValue, float hue, float distanceToEventHorizon, float eventHorizonRadius) {\n  // Define the radius of the influence zone where the nebula will start to brighten\n  float influenceZoneRadius = eventHorizonRadius + 2.1; // Adjust this value as needed\n\n  // Calculate the brightness factor\n  float brightnessFactor = calculateBrightnessFactor(distanceToEventHorizon, eventHorizonRadius, influenceZoneRadius);\n\n  // Calculate the final lightness based on FBM value and brightness factor\n  float lightness = mix(fbmValue/1.4, 2.5, fbmValue * brightnessFactor); // Mix to avoid exceeding 1.0\n\n\n  // Convert HSL to RGB using the given hue and calculated lightness\n  vec3 color = hsl2rgb(hue, 1.0, lightness);\n  color += brightnessFactor * 0.1; // Add a bit of brightness to the nebula\n  return color;\n}\n\n// Function to create an anisotropic scaling matrix\nmat2 anisotropicScale(float xScale, float yScale) {\n  return mat2(xScale, 0.0, 0.0, yScale);\n}\n\nfloat Star(vec2 uv, float flare){\n  float d = length(uv);\n  float m = .02/d;\n  float rays = max(0., 1.-abs(uv.x*uv.y*1000.))*0.1;\n  m+=rays * flare;\n  uv *= rotate2D(3.1415/4.);\n  rays = max(0., 1.-abs(uv.x*uv.y*100000.))*0.9;\n  m += rays*0.3*flare;\n  m *= smoothstep(0.6,.01, d);\n  return m;\n}\n\nvec3 starLayer(vec2 uv, float time, float scale, vec2 off){\n  \n  uv += off;\n  uv *= scale;\n  vec3 color = vec3(0);\n  vec2 gv = fract(uv) - 0.5;\n  vec2 id = floor(uv);\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 offset = vec2(x, y);\n      float n = noise(id + offset);\n      float size = fract(n * 1343.32*250.);\n      float star = Star(gv - offset - vec2(n, fract(n * 3334.)) + 0.5, smoothstep(.3, 0.9, size));\n      vec3 starColor = sin(vec3(0.5, 0.5, .5) * fract(n * 2345.2) * 123.12) * .5 + .5;\n      starColor *= vec3(.4, 0.4, .1 + size);\n      star *= sin(time * n * 6.3) * 0.5 + 1.;\n      color += star * size * starColor;\n    }\n  }\n  return color;\n}\n\nvec2 lensingEffect(vec2 uv, vec2 center, float radius, float strength) {\n  vec2 toCenter = center - uv;\n  float distance = length(toCenter);\n  float effect = smoothstep(radius, radius * 0.5, distance) * strength;\n\n  // This will distort the UVs to create a stretching effect towards the center\n  toCenter = normalize(toCenter) * effect;\n  uv += toCenter;\n\n  return uv;\n}\n\nvec2 gravitationalLensing(vec2 uv, vec2 blackHoleCenter, float mass) {\n  vec2 delta = uv - blackHoleCenter;\n  float r = length(delta)*2.0;\n  float lensingStrength = mass / (r * r);\n  return uv + lensingStrength * normalize(delta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord-iResolution.xy) / min(iResolution.x, iResolution.y);\n  uv *= rotate2D(3.14159/3.0);\n     float time = iTime * 0.2;\n  // Set the black hole parameters\n  vec2 blackHoleCenter = vec2(0.0, 0.0); // Center of the black hole in UV space\n  float blackHoleRadius = 0.5; // Radius of black hole effect in UV space\n  float lensStrength = 2.0; // Strength of the lensing effect\n\n  // Apply gravitational lensing to UV coordinates\n  vec2 lensedUv = uv;\n  lensedUv = lensingEffect(uv, blackHoleCenter, blackHoleRadius, lensStrength);\n  lensedUv += gravitationalLensing(uv, blackHoleCenter, 0.42);\n\n  lensedUv.y += time;\n  blackHoleCenter.y += time;\n  float distanceToEventHorizon = length(lensedUv - blackHoleCenter);\n  // Calculate the distance from the center of the black hole\n  float distanceFromCenter = length(lensedUv - blackHoleCenter);\n\n  // Calculate the angle between the UV coordinates and a reference direction (e.g., x-axis)\n  float angle = atan(lensedUv.y - blackHoleCenter.y, lensedUv.x - blackHoleCenter.x);\n\n  // Define scaling factors for the X and Y axes (adjust as needed)\n  float xScale = 1.0; // No stretching in the X-axis\n  float yScale = 1.0; // No stretching in the Y-axis\n  \n  // Apply angle-based bias to the stretching (e.g., stretching more in the vertical direction)\n  float angleBias = sin(angle * 5.0); // Adjust the factor for the desired bias\n  vec2 nebulaUv = lensedUv;\n  // Apply the anisotropic scaling to the UV coordinates\n  nebulaUv = (anisotropicScale(xScale, yScale + angleBias) * (nebulaUv - blackHoleCenter)) + blackHoleCenter;\n\n  float fbmValue = fbm(nebulaUv * 0.5 + iTime * 0.1); // You can play with these values\n  vec3 nebula = nebulaColor(fbmValue, 1.0*.3+.8, distanceToEventHorizon, blackHoleRadius);\n  fbmValue = fbm(nebulaUv * 0.25 + iTime * 0.05); // You can play with these values\n  vec3 nebula2 = nebulaColor(fbmValue, .6, distanceToEventHorizon, blackHoleRadius);\n  // red nebulae\n  fbmValue = fbm(nebulaUv * 0.5 + iTime * 0.1+4.0); // You can play with these values\n  vec3 nebula3 = nebulaColor(fbmValue, 0.01, distanceToEventHorizon, blackHoleRadius);\n  vec3 color = vec3(0);\n  color += nebula2*4.;\n  color += starLayer(lensedUv*rotate2D(3.14159/4.0), time, 4.0, vec2(time * 0.1, 0.0))*vec3(1., 1.2, sin(time*0.1)*0.5+0.5);\n  color += nebula;\n  color += starLayer(lensedUv+vec2(0.5, 0.5), time*3.0, 8.0, vec2(time * 0.08, 0.0))*vec3(1.6, 1.1, 0.02*sin(time*0.1)*0.5+0.5);\n  color += nebula3;\n  color += starLayer(lensedUv, time*2.0, 12.0, vec2(time * 0.05, 0.0))*vec3(1.5, 1., sin(time*0.01)*0.5+0.5);\n  //color = nebula3;\n  // create black hole\n  float hole = length(uv);\n  hole = smoothstep(0.33, 0.34, hole);\n  color *= vec3(hole);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 35456,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/espen-sande-larsen-365984601/black-hole-horizon"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}