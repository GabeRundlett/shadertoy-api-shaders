{
    "Shader": {
        "info": {
            "date": "1496337448",
            "description": "Truncated Octohedron voxel tracer proof-of-concept shader",
            "flags": 0,
            "hasliked": 0,
            "id": "XssfDN",
            "likes": 20,
            "name": "Truncated Octohedron Voxel Scene",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "polyhedra"
            ],
            "usePreview": 0,
            "username": "culdevu",
            "viewed": 1091
        },
        "renderpass": [
            {
                "code": "/* \n    Author: Daniel Taylor\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tOn the recent post made by Shane (https://www.shadertoy.com/view/4dsBz4) he mentioned how\n\the was wanting to see different types of voxel tracers, and that inspired me to build this.\n\n\tThere are exactly 5 convex polyhedra (with regular polygonal faces) that fill 3D space:\n\t\t\n\t\t-Triangular Prism      (possibly being worked on?)\n\t\t-Hexagonal Prism       (https://www.shadertoy.com/view/ldBcDd)\n\t\t-Cube                  (done many times before)\n\t\t-Truncated Octohedron  (this shader)\n\t\t-Gyrobifastigium       (https://www.shadertoy.com/view/4lcBWX)\n\n\tThis is just a proof-of-concept. It runs kinda slow, the shadows are messy. There's no\n\ttexturing or AO or any fancy stuff. Just... tracing.\n\n\tThe code itself is pretty simple. It's just cube marching, but with truncated octohedrons.\n\tThe only part that's interesting is the code for finding the cell centers, which is needed\n\tto start the tracing algo.\n\n\tThis thing needs a lot of work, so suggestions are welcome!\n\n\tUPDATE (6 June 2017): AO is kinda working now. Also, for a a reduced version of this shader,\n\t\tsee dr2's Mandelbrot tracer (https://www.shadertoy.com/view/MdffRS)\n\t\n\tUPDATE (6 Sept 2017): That annoying flickering is gone now. Please refer to the updated\n\t\tfindCenter function. It may be the case the dr2 already figured that out a while \n\t\tback, but trying to read his code gave me eye cancer.\n    \n\t(Also, for whatever reason, Shadertoy keeps eating this comment block. No idea why...)\n*/\n\n#define PI 3.14159 \n\n// Plane-Ray intersection\nfloat fp(vec3 p, vec3 r, vec3 n)\n{\n    if (dot(n, r) < 0.001)\n        return -1.;\n    return dot(n, p) / dot(n, r);\n}\n\n// Ulities\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat sgn(int a)\n{\n    return (a > 0) ? 1. : -1.;;\n}\nfloat sgn(float a)\n{\n    return (a > 0.) ? 1. : -1.;\n}\nint isgn(int a)\n{\n    return int(sgn(a));\n}\nvoid round1(inout vec3 r)\n{\n    r.xyz = floor(r.xyz + 0.5);\n}\n\n// Determines which cells are solid based on their centers\nbool isSolid(vec3 center)\n{\n    if (center.y <= 0.)\n        return true;\n    if (length(center) < 8.)\n        return true;\n    if (abs(center.z) < 2. && abs(length(center.xy) - 20.) < 5.)\n        return true;\n    \n    return false;\n}\n\n//---------------------------------------------------\n// Intersection and tracing code\n//---------------------------------------------------\nconst vec3 Fv[7] = vec3[](\n    vec3(1, 0, 0),\n    vec3(0, 1, 0),\n    vec3(0, 0, 1),\n\n    vec3(1, 1, 1 ) / 2.,\n    vec3(-1, 1, 1) / 2.,\n    vec3(1, -1, 1) / 2.,\n    vec3(1, 1, -1) / 2.\n);\n\n// This just tests against a bunch of planes\n// Side note: the planes defined by the Mercury SDF library\n// are incorrect\nfloat truncOctInner(vec3 p, vec3 ray, out int best_norm)\n{\n    float best_d = 1000.0;\n    best_norm = -1;\n    \n    vec3 offset, n;\n    float d;\n    \n    for (int i = 0; i < 7; ++i)\n    {\n        offset = Fv[i];\n        n = normalize(offset);\n        d = fp(p + offset, ray, n);\n        if (d < best_d && d > 0.)\n        {\n            best_d = d;\n            best_norm = i + 1;\n        }\n        \n        offset = -Fv[i];\n        n = normalize(offset);\n        d = fp(p + offset, ray, n);\n        if (d < best_d && d > 0.)\n        {\n            best_d = d;\n            best_norm = -i - 1;\n        }\n    }\n    \n    return best_d;\n}\n\n/* this is an improved findCenter function (much better than the more\n   brute-force previous version)\n   here's how it works:\n     the square faces oriented along the axes are of unit length, and the\n     hexagonal faces are oriented at (+-1, +-1, +-1)/2. Since the centers \n     of neighboring cells are reflections of the current one across the\n     cooresponding plane, the separations are just permutations of (+-2, 0, 0)\n     and (+-1, +-1, +-1).\n  \n     So, the end result of all of this is that every cell center (x,y,z) must \n     obey parity(x) = parity(y) = parity(z). Also, every integer triplet that\n     obeys this is also a center of a cell in this tesselation. So, all that's\n     left to do is to find the closest point to the point given which obeys this\n     property.\n*/\nvec3 findCenter(vec3 o)\n{\n    vec3 p = o;\n    vec3 tempSign = sign(p.xyz);\n    p = abs(p.xyz);\n    p = tempSign.xyz * floor(p.xyz + 0.5);\n    \n    vec3 parity = abs(mod(p.xyz, 2.0));\n    \n    if (abs(dot(parity, parity) - 1.5) > 1.0) // they all have the same parity\n    {\n        return p;\n    }\n    \n    // if not, then it must be the case that 2 of them have the same parity (pidgeonhole principle)\n    // so just add or subtract one to the last one to achieve that parity, whichever one is closer\n    \n    if (abs(parity.x - parity.y) < 0.5)\n    {\n        p.z += sgn(o.z - p.z);\n    }\n    if (abs(parity.x - parity.z) < 0.5)\n    {\n        p.y += sgn(o.y - p.y);\n    }\n    if (abs(parity.y - parity.z) < 0.5)\n    {\n        p.x += sgn(o.x - p.x);\n    }\n    \n    // for any point, there are 2 neighboring candidate centers that all have the same parity.\n    // so we need to pick the one that's closer\n    vec3 shift = vec3(sgn(o.x - p.x), sgn(o.y - p.y), sgn(o.z - p.z));\n    vec3 p2 = p + shift;\n\n    if (length(o - p) > length(o - p2))\n        return p2;\n    return p;\n}\n\n// This is just a modification of cube marching\nfloat traceTruncOct(vec3 o, vec3 ray, out vec3 norm, out vec3 center, int depth)\n{\n    center = findCenter(o);\n    \n    norm = vec3(0);\n    float d = 0.;\n    vec3 p = center - o;\n    \n    int normId;\n    \n    // keeps track of the total distance traveled\n    float totalD = 0.;\n    \n    for (int i = 0; i < depth; ++i)\n    {\n        d = truncOctInner(p, ray, normId);\n        o = o + ray * d;\n        center += float(sign(normId)) * 2. * Fv[abs(normId - sign(normId))];\n        p = center - o;\n        \n        totalD += d;\n        \n        if (isSolid(center))\n        {\n            norm = -float(sign(normId)) * normalize(Fv[abs(normId - sign(normId))]);\n            return totalD;\n        }\n    }\n    \n    return -1.;\n}\n\n// Okay, so this AO isn't at all as clever as the solution\n// I had originally planned. In fact, this is kinda gross.\n// It looks ugly and broken and someone should really fix it.\n// Don't use this unless there's no other option.\nfloat aoDist(vec3 o, vec3 center, vec3 norm)\n{\n    vec3 trash;\n    \n    float best = 0.;\n    vec3 r;\n    \n    for (int i = 0; i < 7; ++i)\n    {\n        vec3 p = normalize(Fv[i]);\n        vec3 q = p - norm * dot(norm, p);\n        \n        if (dot(o - center, q) > best && dot(norm, p) < 0.95 && dot(norm, p) > 0.05)\n        {\n            r = q;\n            best = dot(o - center, q);\n        }\n        \n        q = -q;\n        if (dot(o - center, q) > best && dot(norm, p) < 0.95 && dot(norm, p) > 0.05)\n        {\n            r = q;\n            best = dot(o - center, q);\n        }\n    }\n    \n    return traceTruncOct(o, normalize(r), trash, trash, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(iResolution.x/iResolution.y/2., 0.5);\n    float mouseU = 2. * (iMouse.x / iResolution.x - 0.5);\n    vec3 trash;\n    \n    vec3 cam = vec3(0,8,20);\n    vec3 screenPos = vec3(uv, -0.5);\n    \n    pR(cam.xz, mouseU * 2. * PI);\n    pR(screenPos.xz, mouseU * 2. * PI);\n    \n    vec3 ray = normalize(screenPos);\n    \n    vec3 norm, center;\n    float d = traceTruncOct(cam, ray, norm, center, 80);\n    vec3 pt = cam + ray * d;\n    center = findCenter(cam + d * ray);\n    \n    if (d < 0.)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    //--------------------------------------------------\n    // Lighting Time!\n    //--------------------------------------------------\n    float ambient = 0.15;\n    float ao = aoDist(pt, center, norm);\n    if (ao < 0.0)\n        ao = 5.0;\n    if (ao/3. < 0.1)\n        ambient = ao/3. + 0.05;\n    \n    // Lighting\n    vec3 light = 10. * vec3(sin(iTime), 1, cos(iTime));\n    vec3 lightDir = pt - light;\n    float lightIntensity = 10.0;\n    \n    // These shadows look really ugly.\n    // I'm not all that knowledged about how cube marching people do shadows,\n    // but it's probably *not* something like this... oh well.\n    // If you have any suggestions, please tell me!\n    float lightDist = traceTruncOct(light, normalize(lightDir), trash, trash, 40);\n    float shadow = 0.;\n    if (abs(lightDist - length(lightDir)) < 0.2)\n        shadow = 1.;\n    \n    // Yeah, that's right, I used linear falloff. Sue me.\n    fragColor = 0.6 * shadow * lightIntensity * vec4(dot(norm, -normalize(lightDir) )) / length(lightDir);\n    fragColor += vec4(ambient) + 0.6 * vec4(abs(dot(norm, -normalize(lightDir)) )) / length(lightDir);\n    //fragColor = vec4(ao/(ao + 1.));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}