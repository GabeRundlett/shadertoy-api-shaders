{
    "Shader": {
        "info": {
            "date": "1476393512",
            "description": "Reset time to see the holes in the original image.\nDiffusion from [url=https://www.shadertoy.com/view/XdKGDW]jamriska[/url].\nUsed techniques in [url=https://pdfs.semanticscholar.org/2407/5ab482f70ffd1137abb3a533dfe551210c6f.pdf]Jeschke et al. 09[/url].",
            "flags": 32,
            "hasliked": 0,
            "id": "4ty3Dy",
            "likes": 10,
            "name": "Image Inpainting",
            "published": 3,
            "tags": [
                "diffusion",
                "laplacian",
                "inpainting"
            ],
            "usePreview": 0,
            "username": "starea",
            "viewed": 2275
        },
        "renderpass": [
            {
                "code": "/** \n * Image Inpainting\n * Ruofei Du\n *\n * Click on the image to see the input.\n * \n * Used the Laplacian Solver from [url=https://www.shadertoy.com/view/XdKGDW]jamriska[/url].\n * Used techniques in [url=https://pdfs.semanticscholar.org/2407/5ab482f70ffd1137abb3a533dfe551210c6f.pdf]Jeschke et al. 09[/url].\n * To be simplified, there is no support for resizing the rendering buffer.\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    if (iMouse.z > 0.0) {\n        fragColor = texture(iChannel0, uv); \n    } else {\n    \tfragColor = texture(iChannel2, uv);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n * Laplacian Solver For Image Completion\n * Forked from [url=https://www.shadertoy.com/view/XdKGDW]jamriska[/url].\n * Used techniques in [url=https://pdfs.semanticscholar.org/2407/5ab482f70ffd1137abb3a533dfe551210c6f.pdf]Jeschke et al. 09[/url].\n * To be simplified, I removed the support for resizing the rendering buffer.\n */\n\n// buffer A holds the original image\n//#define TEST_GRID\n\nvoid drawGrid(vec2 coord, inout vec3 col) {\n    const vec3 COLOR_AXES = vec3(0.698, 0.8745, 0.541);\n    const vec3 COLOR_GRID = vec3(1.0, 1.0, 0.702);\n    const float tickWidth = 0.1;\n    \n    for (float i = -2.0; i < 2.0; i += tickWidth) {\n\t\tif (abs(coord.x - i) < 0.004) col = COLOR_GRID + coord.y / 4.0+ coord.x / 4.0;\n\t\tif (abs(coord.y - i) < 0.004) col = COLOR_GRID + coord.y / 4.0+ coord.x / 4.0;\n\t}\n\tif( abs(coord.x) < 0.006 ) col = COLOR_AXES;\n\tif( abs(coord.y) < 0.007 ) col = COLOR_AXES;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy); \n    // render the first frame\n    if (iFrame < 5)\n    {\n        // set this pixel unknown\n        fragColor = vec4(vec3(-1.0), 1);\n        // return the image with holes\n        vec3 col = texture(iChannel3, fragCoord.xy/iResolution.xy).xyz;\n        if (length(col) > 0.5) fragColor = vec4(texture(iChannel2, fragCoord.xy/iResolution.xy).xyz, 1.0); \n#ifdef TEST_GRID\n        col = vec3(0.0); \n        vec2 coord = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        drawGrid(coord, col); \n        if (length(col) > 0.0) fragColor = vec4(col, 1.0); else fragColor = vec4(-1.0); \n#endif\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// buffer B stores the distance map of the curves along with an intial guess of the solution\nconst int LEVEL_OF_PYRAMID = 4;\n\n// short cut for texturing\n#define A(X,Y) (tap(iChannel0,vec2(X,Y)))\n#define B(X,Y) (tap(iChannel1,vec2(X,Y)))\nfloat tap(sampler2D tex,vec2 coord) { return texture(tex, coord / iResolution.xy).x; }\n\n\n#define LAST_RESOLUTION texture(iChannel1, vec2(0.5,0.5) / iResolution.xy).yz\n#define FRAME_RESET texture(iChannel1, vec2(1.5,0.5) / iResolution.xy).y\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x;\n    float y = fragCoord.y;  \n    \n    if (A(x,y) > -0.5 || iFrame < 3) { \n    \tfragColor = vec4(vec3(0.0), 1.0);\t// d = 0.0; \n        return; \n    };  \n        \n    float d = 100000.0;\n    float r = pow(2.0, float(LEVEL_OF_PYRAMID - 1));\n    // get the minimum value from buffer B\n    // init d = 0.0;\n    for (int i = 0; i < LEVEL_OF_PYRAMID; i++)\n    {          \n        d = min(d, B(x - r, y    ) + r);\n        d = min(d, B(x + r, y    ) + r);\n        d = min(d, B(x    , y - r) + r);\n        d = min(d, B(x    , y + r) + r);\n        r = r / 2.0;\n    }\n    \n        \n\n    fragColor = vec4(vec3(d), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// short cut for texturing\n#define GAMMA_CORRECTION\n#define A(X,Y) (tap(iChannel0,vec2(X,Y)))\n#define B(X,Y) (tap(iChannel1,vec2(X,Y)).x)\n#define C(X,Y) (tap(iChannel2,vec2(X,Y)))\n\nvec3 tap(sampler2D tex,vec2 xy) { return texture(tex,xy/iResolution.xy).xyz; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x, y = fragCoord.y;\n    \n    vec3 a = A(x,y);\n    if (a.x > -0.5) { \n        fragColor = vec4(a, 1); \n        return; \n    };  \n        \n        \n    float r = min(B(x,y), mix(512.0, 1.0, clamp(max(float(iFrame) / 64.0 - 1.0,0.0), 0.0, 1.0)));\n\n#ifdef GAMMA_CORRECTION\n    vec3 c = pow((pow(C(x - r, y  ), vec3(2.2)) +\n                  pow(C(x + r, y  ), vec3(2.2)) +\n                  pow(C(x    , y-r), vec3(2.2)) +\n                  pow(C(x    , y+r), vec3(2.2))) / 4.0, vec3(1.0 / 2.2));\n#else  \n    vec3 c = (C(x - r, y  ) +\n              C(x + r, y  ) +\n              C(x    , y-r) +\n              C(x    , y+r)) / 4.0;\n#endif\n    \n    fragColor = vec4(c, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}