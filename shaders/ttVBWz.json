{
    "Shader": {
        "info": {
            "date": "1614604453",
            "description": "Distributing the integration error in screen space via a shuffled+scambled Sobol LDS.\nImplements \"Screen-Space Blue-Noise Diffusion of Monte Carlo Sampling Error via Hierarchical Ordering of Pixels\"\n\nCamera controls via mouse + shift key",
            "flags": 48,
            "hasliked": 0,
            "id": "ttVBWz",
            "likes": 29,
            "name": "MC Error Blue Noise Diffusion",
            "published": 3,
            "tags": [
                "noise",
                "blue",
                "montecarlo",
                "bluenoise",
                "monte",
                "carlo",
                "lds"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 1230
        },
        "renderpass": [
            {
                "code": "\n/*\n    All the stuff is in Buffer A.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 uv0)\n{\n    ivec2 uv = ivec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n   #if 0\n   {\n       // high-pass filter (helps to find structures in the error noise)\n       col = (col*4.0 - (texelFetch(iChannel0, uv+ivec2(1,0),0)+\n                         texelFetch(iChannel0, uv+ivec2(0,1),0)+\n                         texelFetch(iChannel0, uv-ivec2(1,0),0)+\n                         texelFetch(iChannel0, uv-ivec2(0,1),0)).rgb)/8.0;\n       //col = abs(col);\n       col*= 12.0;                         \n   }\n  #endif\n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n// https://twitter.com/Mirko_Salm\n\n/*\n\nDistributing the integration error in screen space via a shuffled+scambled Sobol low-discrepancy sequence.\n\nCtrl  - toggle split-screen off/on (white noise | blue noise - initialized Sobol sequence)\nTab   - toggle between white and blue noise if split-screen is off\nSpace - toggle progessive accumulation of samples on/off\n        -> progressive accumulation actually works much better with the white noise initialized LDS;\n           the blue noise variant produces blocky artifacts.\n           This is because with the white noise version every pixel uses its own sequence while\n           the blue noise variant just shifts the one sequence that is used by the whole screen\n\n\nThis is a basic implementation of [1] using the scrambling method for the Sobol sequence described in [2].\n\n[1] \"Screen-Space Blue-Noise Diffusion of Monte Carlo Sampling Error via Hierarchical Ordering of Pixels\"\n    - https://repository.kaust.edu.sa/bitstream/10754/666257/1/papers_437s4-file1.pdf\n\n[2] \"Practical Hash-based Owen Scrambling\"\n    - http://www.jcgt.org/published/0009/04/01/\n\nThe idea presented in [1] is to linearize the screen pixel coordinates in a locality/adjacency preserving manner and \nuse the resulting pixel id to generate samples with a Sobol sequence. \nThe Sobol LDS is used because of its property that given a power-of-2 long sequence it can be\nrecursively split in half so that each of the resulting sub-sequences will itself be a valid LDS.\n\nUsing the scrambling approach from [2] in combination with a simple Morton order pixel id is already pretty effective:~~\n\n    uint pxId = EncodeMorton2(uv);\n    vec2 s = Float11(shuffled_scrambled_sobol_2d(pxId, seed));// 2d LDS sample for the current pixel\n\n[1] suggests to scramble the Morton order to get rid of structural patterns in the resulting Monte Carlo integration noise.\nI found that scrambling only some of the lower bits of the mortor order is sufficient since the Sobol scrambling of [2] \nis already doing a great job at reducing those artifacts. \nIn particular I replace the 4 least significant bits of the pixel id with the bits of a 4x4 pixels large Hilbert curve tile: \n\n    uint pxId = EncodeMorton2(uv);\n    {\n        // use a 4x4 Hilbert curve tile for the lower bits of pxId \n        // to break up structural patterns in the resulting MC noise:\n        const uint N = 2u;// 2^N == tile dimension\n        uint h = EvalHilbertCurve(uv, N);\n        \n        h += WeylHash(uv >> N);// add a random offset per tile\n\n        const uint M = (1u << (2u*N))-1u;// bit mask\n        pxId = (pxId & (~M)) ^ (h & M);// replace lower bits in pxId\n    }\n\nUsing larger Hilbert curve tiles is more expensive and can introduce structured low-frequency artifacts in the noise.\n\nGenerating multiple samples per pixel is straightforward:\n\n    uint count = 16u;// sample count must be a power-of-4 \n                     // since we (implicitly) hierarchically order our pixels in blocks of 4 to generate pxId\n                     // this is what makes this work with the Sobol LDS (since every pow-of-4 is also a pow-of-2)\n    for(uint i = 0u; i < count; ++i)\n    {\n        ...\n        vec2 s = Float11(shuffled_scrambled_sobol_2d(pxId*count+i, seed));\n        ...\n        // generate direction using s and trace\n    }\n\nThe shuffling of the Sobol sequence allows us to generate higher dimensional samples via padding.\nAll we need is to provide different seeds to the routine:\n\n    vec4 s = Float11(uvec4(shuffled_scrambled_sobol_2d(pxId*count+i, seedA),\n                           shuffled_scrambled_sobol_2d(pxId*count+i, seedB)));\n  \n  \nMove the camera inside the sphere to get a good look at the noise beneath it.\nCamera controls via mouse + shift key.\n*/\n\n\n#define SAMPLE_COUNT 4\n// needs to be a power-of-4 to work well with the diffusion scheme\n// 1, 4, 16, 64, 256, 1024, ...\n\n\n// linearizes uv using a Hilbert curve; tile dimension = 2^N\nuint EvalHilbertCurve(uvec2 uv, uint N)\n{\n    uint C = 0xB4361E9Cu;// cost lookup\n    uint P = 0xEC7A9107u;// pattern lookup\n    \n    uint c = 0u;// accumulated cost\n    uint p = 0u;// current pattern\n\n    for(uint i = N; --i < N;)\n    {\n        uvec2 m = (uv >> i) & 1u;// local uv\n\n        uint n = m.x ^ (m.y << 1u);// linearized local uv\n\n        uint o = (p << 3u) ^ (n << 1u);// offset into lookup tables\n\n        c += ((C >> o) & 3u) << (i << 1u);// accu cost (scaled by level)\n\n        p = (P >> o) & 3u;// update pattern\n    }\n    \n    return c;\n}\n\n\n// scene intersection routine (a bit messy but I dont feel like cleaning it since it's not really important here)\nfloat Intersect_Scene(\nvec3 rp, vec3 rd,\nout float t, out vec3 n, out vec3 a)\n{\n     float hit = 0.0;\n   \n    // ground plate thingy:\n    {\n        vec3 c0p = vec3(0.0, -0.8, 0.0);\n        vec3 c0d = vec3(2.0, 0.125*0.5, 2.0);\n        \n        vec3 c1p = vec3(0.0, -0.64, 0.0);\n        vec3 c1d = vec3(2.5, 0.125, 1.5);\n        float c1dxz = 0.4;\n         c1d = vec3(c1dxz, 0.125, c1dxz);\n        \n        float c1ps = 0.85;\n        \n        c1p.xz = (floor(rp.xz*c1ps+0.5))/c1ps;\n        \n        bool isInsideC0 = IsInsideCube(rp, c0p, c0d);\n        bool isInsideC1 = IsInsideCube(rp, c1p, c1d);\n        \n        if(isInsideC0 && isInsideC1)\n        {\n            float t0; vec3 n0;\n            Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n            \n            if(IsInsideCube(rp+rd*t0, c0p, c0d))\n            {\n                hit = 1.0;\n                t = t0;\n                n = n0;\n            }\n        }\n        else\n        {\n            vec2 tt; vec3 n0, n1;\n            float th = Intersect_Ray_Cube(rp, rd, c0p, c0d, /*out:*/ tt, n0, n1);\n\n            hit = th > 0.0 ? 1.0 : 0.0;\n            t = tt.x;\n            n = n0;\n            a = vec3(1.0, 0.005, 0.005) * 0.8;\n            \n            if(hit==1.0) c1p.xz = (floor((rp.xz+rd.xz*t)*c1ps+0.5))/c1ps;\n            if(hit==1.0 && IsInsideCube(rp+rd*t, c1p, c1d))\n            {\n                float t0; vec3 n0;\n                Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n\n                if(IsInsideCube(rp+rd*t0, c0p, c0d))\n                {\n                    t = t0;\n                    n = n0;                \n                }\n                else\n                {\n                    hit = 0.0;\n                }\n            }\n        }\n    }\n \n    // top sphere:\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x);\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    // bottom sphere:\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0, -2.25, 0.0), 2.0, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x - vec3(0.0, -2.25, 0.0));\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    return hit;\n}\n\n\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    uvec2 uv = uvec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    uint frame = uint(iFrame);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    // camera setup:\n    vec2 ang = vec2(Pi * 0.0, Pi * 0.12);\n    ang += mouseAccu.xy * 0.008;\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(0.45 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n\n    float focalLen = 0.8;// = 0.5 * tan(Pi05 - fov * 0.5)\n    \n    float txlSize = 1.0 / iResolution.x * 2.0;\n\n\n    // linearize uv in a locality preserving way:\n    uint pxId = EncodeMorton2(uv);\n    \n   #if 1\n    {\n        // use a 4x4 Hilbert curve tile for the lower bits of pxId \n        // to break up structural patterns in the resulting MC noise:\n        const uint N = 2u;// 2^N == tile dimension\n        uint h = EvalHilbertCurve(uv, N);\n        \n        h += WeylHash(uv >> N);// add a random offset per tile\n\n        const uint M = (1u << (2u*N))-1u;// bit mask\n        pxId = (pxId & (~M)) ^ (h & M);// replace lower bits in pxId\n    }\n   #endif\n   \n    if(ReadKeyToggle(KEY_CTRL) == 0.0)\n    {\n        // fill pxId with white noise:\n        if(tex.x < 0.5) pxId = WeylHash(uv);// split-screen\n    }\n    else if(ReadKeyToggle(KEY_TAB) != 0.0)\n    {\n        // fill pxId with white noise:\n        pxId = WeylHash(uv); \n    }\n    \n    if(ReadKeyToggle(KEY_SPACE) != 0.0) pxId += frame;// shift sequence if we accumulate samples over time\n    \n    \n    vec3 col = vec3(0.0);\n    \n    float t; vec3 n; vec3 a;\n    vec3 pos = cpos;\n\n    float ao = 0.0;\n    \n    uint count = uint(SAMPLE_COUNT);\n    for(uint i = 0u; i < count; ++i)\n    {\n        vec2 uv2 = uv0;\n        \n        // sample reconstruction filter:\n        #if 1\n        {\n           #if 0\n           // tent filter\n            vec2 s = Float11(shuffled_scrambled_sobol_2d(pxId*count+i, 0x06EE471Bu));\n             //s = Float11(shuffled_scrambled_sobol_2d(i, 0x06EE471Bu));\n            \n            s.x = Sample_Triangle(s.x);\n            s.y = Sample_Triangle(s.y);\n            \n           #else\n           // box filter\n            vec2 s = Float01(shuffled_scrambled_sobol_2d(pxId*count+i, 0x06EE471Bu)) - 0.5;\n             //s = Float01(shuffled_scrambled_sobol_2d(i, 0x06EE471Bu)) - 0.5;\n            \n           #endif\n           \n            uv2 += s;\n        }\n        #endif\n        \n        // construct ray direction:\n        vec2 tc = uv2 * txlSize - vec2(1.0, iResolution.y / iResolution.x);\n        vec3 rd = normalize(cmat * vec3(tc, focalLen)); \n\n        if(Intersect_Scene(pos, rd, /*out:*/ t, n, a) > 0.0)\n        {\n            vec3 p = pos + rd * t;\n            p += n * (1.0/1024.0);// always use pow-of-2 scalings for your small offsets\n            \n            \n            // sample a cosine weighted direction:\n            vec2 s = Float11(shuffled_scrambled_sobol_2d(pxId*count+i, 0xD0430963u));\n            //s = Float11(sobol_2d(pxId*count+i));\n            \n           #if 1\n            // sample sphere -> offset sphere along normal so it is tangential to the surface (i.e. the typical cosine lobe shape) -> normalize\n            // LDS sample distribution is worse around the poles (which is why using Sample_Sphere(s).yxz or .yzx performs worse here)\n            vec3 cosDir = normalize(Sample_Sphere(s) + n);\n           #else\n            // sample disk using concentric mapping -> build local frame around normal -> project points from disk to hemisphere defined by local frame\n            // introduces low-frequency content and adds a discontinuity to the correlated noise (due to https://en.wikipedia.org/wiki/Hairy_ball_theorem)\n            vec3 cosDir = Sample_ClampedCosineLobe_Conc(s.x, s.y, n);\n           #endif\n           \n            ao += Intersect_Scene(p, cosDir, /*out:*/ t, n, a) > 0.0 ? 0.0 : 1.0;\n        } \n    }\n    \n    ao /= float(count);\n    \n    col = vec3(ao);\n    \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    if(ReadKeyToggle(KEY_SPACE) != 0.0)\n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));// progressive accumulation\n   \n    \n    outCol = vec4(col, 0.0);\n    \n    // program state:\n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        anyK = anyK || ReadKey(KEY_TAB) != 0.0;\n        anyK = anyK || ReadKey(KEY_SHIFT) != 0.0;\n        anyK = anyK || ReadKey(KEY_SPACE) != 0.0;\n        anyK = anyK || ReadKey(KEY_CTRL) != 0.0;\n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==========================================================================================================//\n// \"Shuffled Scrambled Sobol (2D)\" - https://www.shadertoy.com/view/3lcczS\n//  code taken from \"Practical Hash-based Owen Scrambling\" - http://www.jcgt.org/published/0009/04/01/\nuint reverse_bits(uint x) {\n    x = (((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1));\n    x = (((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2));\n    x = (((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4));\n    x = (((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8));\n    return ((x >> 16) | (x << 16));\n}\n\nuint laine_karras_permutation(uint x, uint seed) {\n    x += seed;\n    x ^= x*0x6c50b47cu;\n    x ^= x*0xb82f1e52u;\n    x ^= x*0xc7afe638u;\n    x ^= x*0x8d22f6e6u;\n    return x;\n}\n\nuint nested_uniform_scramble(uint x, uint seed) {\n    x = reverse_bits(x);\n    x = laine_karras_permutation(x, seed);\n    x = reverse_bits(x);\n    return x;\n}\n\n// lifted from boost\nuint hash_combine(uint seed, uint v) {\n    return seed ^ (v + 0x9e3779b9u + (seed << 6u) + (seed >> 2u));\n}\n\n// from https://www.shadertoy.com/view/3ldXzM\nuvec2 sobol_2d(uint index) {\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; index != 0u; index >>= 1u) {\n        if((index & 1u) != 0u) {\n            p ^= d;\n        }\n\n        d.x >>= 1u;  // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\nuvec2 shuffled_scrambled_sobol_2d(uint index, uint seed) {\n    index = nested_uniform_scramble(index, seed);\n    uvec2 p = sobol_2d(index);\n    \n   #if 0\n    p.x = nested_uniform_scramble(p.x, (hash_combine(seed, 0u)));\n    p.y = nested_uniform_scramble(p.y, (hash_combine(seed, 1u)));\n   #else\n    p.x = nested_uniform_scramble(p.x, (hash_combine(seed, 0x6F0672B5u)));\n    p.y = nested_uniform_scramble(p.y, (hash_combine(seed, 0x37322FD2u)));\n   #endif\n   \n    return p;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//======================================================================================//\n// https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\nuint Part1By1(uint x)\n{\n  x &= 0x0000ffffu;                   // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  x = (x ^ (x <<  8u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x <<  4u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x <<  2u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x <<  1u)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  return x;\n}\n\nuint EncodeMorton2(uint x, uint y)\n{\n  return (Part1By1(y) << 1u) + Part1By1(x);\n}\n\nuint EncodeMorton2(uvec2 p)\n{\n  return (Part1By1(p.y) << 1u) + Part1By1(p.x);\n}\n//======================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////\n\n\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_TAB 9\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nbvec2 minmask(vec2 v)\n{\n    bool x = v.x < v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec2 maxmask(vec2 v)\n{\n    bool x = v.x >= v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec3 minmask(vec3 v)\n{    \n    return bvec3(v.x <= v.y && v.x <= v.z,\n                 v.y <  v.z && v.y <  v.x,\n                 v.z <  v.x && v.z <= v.y);\n}\n\nbvec3 maxmask(vec3 v)\n{\n    return bvec3(v.x >= v.y && v.x >= v.z,\n                 v.y >  v.z && v.y >  v.x,\n                 v.z >  v.x && v.z >= v.y);\n}\n\nbvec3 minmask2(vec3 v)\n{\n    bool x = !(v.x >  v.y || v.x >  v.z) && !isnan(v.x);\n    bool y = !(v.y >= v.z || v.y >= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nbvec3 maxmask2(vec3 v)\n{\n    bool x = !(v.x <  v.y || v.x <  v.z) && !isnan(v.x);\n    bool y = !(v.y <= v.z || v.y <= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n\tvec3 o = -cth * os;\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n    bvec3 mb = minmask2(ub);\n    \n    N = os * vec3(mb);\n    \n    t = mb.x ? ub.x : mb.y ? ub.y : ub.z;\n}\n\nbool IsInsideCube(vec3 p, vec3 cp, vec3 cd)\n{\n    vec3 b = abs(p - cp);\n    \n    return b.x < cd.x && b.y < cd.y && b.z < cd.z;\n}\n\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\nvec3 Sample_Sphere(vec2 s) { return Sample_Sphere(s.x, s.y); }\n\n// Improved code for concentric map\n// http://psgraphics.blogspot.de/2011/01/improved-code-for-concentric-map.html\n// Peter Shirley, Dave Cline \nvec2 Sample_Disk_Conc(vec2 v) \n{\n\tfloat phi, r;\n    \n\tif (v.x*v.x > v.y*v.y) \n\t{\n\t\tr   = v.x;\n\t\tphi = v.y / v.x;\n\t} \n    else \n    {\n\t\tr   = v.y;\n\t\tphi = v.x / v.y + 2.0;\n\t}\n    \n    phi *= Pi*0.25;\n    \n\treturn vec2(cos(phi), sin(phi)) * r;\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_ClampedCosineLobe_Conc(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk_Conc(vec2(s0, s1));\n    float y = sqrt(clamp01(1.0 - dot(d, d)));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s0 [uniform smpl on unit circle], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(vec2 s0, float s1, vec3 normal)\n{\t \n    vec2 d  = s0 * sqrt(s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}