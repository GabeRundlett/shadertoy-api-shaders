{
    "Shader": {
        "info": {
            "date": "1515263240",
            "description": "Practicing basic shaping functions. ",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml2fzm",
            "likes": 15,
            "name": "Shaping Exercise",
            "published": 3,
            "tags": [
                "vectorart",
                "shapingexcerises"
            ],
            "usePreview": 0,
            "username": "ircss",
            "viewed": 834
        },
        "renderpass": [
            {
                "code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 PalletToRGB(vec3 col01, vec3 col02, vec3 col03, vec3 col04, vec3 colorToConvert){\n \t\n    vec3 toReturn = col04;\n    toReturn = mix(toReturn, col01, colorToConvert.x);\n    toReturn = mix(toReturn, col02, colorToConvert.y);\n    toReturn = mix(toReturn, col03, colorToConvert.z);\n    \n    return vec4(toReturn, 1.0);\n}\n\n\n\n//  Function from IÃ±igo Quiles\n//  iquilezles.org/articles/functions\nfloat impulse( in float k, in float x ){\n    float h = k*x;\n    return h*exp(1.0-abs(h));\n}\n\nvoid DrawACircle(inout vec3 color, in vec3 circleColor, in vec2 pos, in vec2 coord, in float radius){\n    float distanceToCenter = distance(coord, pos);\n    \n    color = mix(circleColor, color, step(radius, distanceToCenter));\n    \n}\n\nvoid DrawRectangle(inout vec3 color, in vec3 recantgleColor, in vec2 pos, in vec2 coord, in vec2 dimensions){\n    vec2 distanceVector = abs(coord - pos);\n    float shilloute = step(0.5, (step(dimensions.x, distanceVector.x) +step(dimensions.y, distanceVector.y))/2.0);\n    color = mix(recantgleColor, color, shilloute);\n}\n\n\nvoid DrawClouds( inout vec3 color, in vec3 cloudcolor, in vec2 pos, in vec2 coord,  in vec2 dimensions, in float cloudsHeight){\n    \n    float randomSeed= rand(vec2 (pos.y));\n    \n    float waveyHeight = (sin((coord.x - dimensions.x) * 20.0 ) * pow(coord.x, randomSeed*2.0)/cloudsHeight) + pos.y;\n    vec2 distanceVector = abs(coord - pos);\n    float drawingBox = step(0.5, (step(dimensions.x, distance( coord, vec2(pos.x, pos.y - dimensions.x*0.7))) +\n                                  step(dimensions.y, distanceVector.y))/2.0);\n    \n    float finalLerpFactor =  (1.0 - drawingBox) *  ( 1.0 - step(waveyHeight , coord.y));\n    \n    color = mix(cloudcolor, color, 1.0- finalLerpFactor);\n    \n}\n\nvoid DrawAPole( inout vec3 color, in vec3 poleColor, in vec2 pos, in vec2 coord){\n    \n    DrawRectangle(color, poleColor, vec2(0.0, 0.18), coord ,vec2(6.5, 0.012));\n    \n    for(int i = 0; i<20; i++){\n      DrawRectangle(color, poleColor, vec2(pos.x - 2.0 + float(i)*0.3, pos.y), coord ,vec2(0.026, 0.14));\n    }\n\n    \n    \n}\n\nvoid DrawTwoSidedTriangle(inout vec3 Color, in vec3 toDrawColor, in vec2 pos, in vec2 coord, in float height, in float width){\n \tfloat functionIn = coord.x - pos.x;\n    float heightValue = height * (1.0 - abs(width * functionIn));\n    \n    float shilloute = 1.0 - step((heightValue + pos.y), coord.y);\n    shilloute *=  step(pos.y, coord.y);\n    \n    Color = mix(toDrawColor, Color, 1.0 - shilloute);\n    \n    \n    \n}\n\nvoid DrawACar( inout vec3 color, in vec2 coord){\n    \n    vec3 backColorIn = color;\n    float yOffset = abs( 2.0 * fract(iTime) - 1.0) * 0.010;\n    DrawRectangle(color, vec3(0.14, 0.03, 0.0), vec2(0.6, 0.2+ yOffset), coord ,vec2(0.3, 0.15));\n    DrawRectangle(color, backColorIn, vec2(0.80, 0.28 + yOffset), coord, vec2(0.11, 0.07));\n     DrawRectangle(color, backColorIn, vec2(0.35, 0.31 + yOffset), coord, vec2(0.1, 0.07));\n    \n    \n    DrawTwoSidedTriangle(color, vec3(0.14, 0.03, 0.0), vec2(0.68, 0.21 + yOffset), coord, 0.142, 10.00001);\n    \n    \n    DrawACircle(color, vec3(0.14, 0.03, 0.0), vec2(0.42, 0.06 + yOffset * 1.4), coord, 0.08);\n     DrawACircle(color, vec3(0.14, 0.03, 0.0), vec2(0.78, 0.05 + yOffset * 1.4), coord, 0.08);\n\n    \n    \n}\n\nvoid DrawMountain(in vec2 coord, inout vec3 color, float buttonHeight, vec3 mountainColor, float manualOffset){\n \t\n    float randomSeed= rand(vec2 (buttonHeight));\n    float offset =  sin(coord.x *2.0 +manualOffset + (pow(randomSeed, randomSeed)) )/\n        (14.0 - pow(randomSeed, randomSeed)/10.0) + abs(cos(sin( (fract(cos(coord.x  + pow(randomSeed, randomSeed) ) *2.0 -1.0 )* \n                  (fract(cos(coord.x * randomSeed+ 0.5) * randomSeed * 20.0))*2.0 -1.0))))/ 4.0;\n    \n    float randomTreeHeight = rand(vec2( floor(coord.x *25.0)));\n    float trees = (pow(abs((2.0* fract(coord.x*0.9 * randomTreeHeight * randomSeed))-1.0),2.0))/\n        (20.0- 10.0 * randomTreeHeight  *pow(randomSeed,2.0)) ;\n    \n    float sillhoute = clamp(step(buttonHeight + offset+ trees, coord.y) + step(buttonHeight-0.1, coord.y) -1.0 , 0.0, 1.0);\n    \n    \n    color = mix(mountainColor, color, sillhoute);\n    \n\t     \n    \n}\n\n\n\nvoid DrawMountainGradient(in vec2 coord, inout vec3 color, float buttonHeight, vec3 mountainColor, vec3 color02, float manualOffset){\n \t\n    float randomSeed= rand(vec2 (buttonHeight));\n    float offset =  sin(coord.x *2.0 +manualOffset + (pow(randomSeed, randomSeed * 4.0)) )/\n        (14.0 - pow(randomSeed, randomSeed)/10.0) + abs(cos(sin( (fract(cos(coord.x  + pow(randomSeed, randomSeed) ) *2.0 -1.0 )* \n                  (fract(cos(coord.x * randomSeed+ 0.5) * randomSeed * 20.0))*2.0 -1.0))))/ 4.0;\n    \n    float randomTreeHeight = rand(vec2( floor(coord.x *25.0)));\n    float trees = (pow(abs((2.0* fract(coord.x*0.9 * randomTreeHeight * randomSeed))-1.0),2.0))/\n        (20.0- 10.0 * randomTreeHeight  *pow(randomSeed,2.0)) ;\n    \n    float sillhoute = clamp(step(buttonHeight + offset+ trees, coord.y) + step(buttonHeight-0.1, coord.y) -1.0 , 0.0, 1.0);\n    \n    float gradientFactor =  clamp( coord.y - buttonHeight/ 120.0, 0.0, 1.0);\n    vec3 colorToUse = mix(mountainColor, color02, 1.0 - gradientFactor);\n    \n    color = mix(colorToUse, color, sillhoute);\n    \n\t     \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Settomg up the UV coordinates\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // Declernation\n    \n    vec3 backGround = vec3( abs (2.0 * fract(iTime*0.05) - 1.0), 0.101, 0.270);\n    vec3 color01 = vec3(0.360, 0.2, abs (2.0 * fract(iTime*0.05) - 1.0));\n    vec3 color02 = vec3(abs(cos(iTime/10.0) + cos(iTime*0.8 +2.215)), 0.827, abs( cos(iTime)+ cos(iTime*0.76 +52.21)) );\n    vec3 color03 = vec3(0.8, 0.9, 0.8);\n    \n    vec3 colorToReturn = vec3(0.0, 0.0, 0.0);\n    \n    \n    // Start of the Painting. \n    \n    // Background color \n    \n    float backGroundGradientBlend = impulse( 2.1, uv.y );\n    \n    colorToReturn = backGround + 1.0- backGroundGradientBlend;\n    \n    //Draw Sun \n    \n    DrawACircle(colorToReturn, vec3(0.8, 0.5, 0.9), vec2(1.3, 0.8), uv, 0.2);\n    \n    //Clouds\n    \n    float cloudMovementSpeed = 0.01;\n    \n    DrawClouds( colorToReturn, vec3(0.3, 0.6, 0.7), vec2(0.5, 0.94),\n               vec2(uv.x - 1.5 + 2.4* fract((iTime + 40.0) *cloudMovementSpeed), uv.y),\n               vec2(0.4,0.13), 10.0);\n    \n     DrawClouds( colorToReturn, vec3(0.2, 0.4, 0.6), vec2(1.0, 0.7),\n               vec2(uv.x - 1.0 + 2.4* fract((iTime +18.0 )*cloudMovementSpeed* 0.5), uv.y),\n                vec2(0.7,0.13), 30.0);\n    \n    DrawClouds( colorToReturn, vec3(0.3, 0.6, 0.7), vec2(0.0, 0.8),\n               vec2(uv.x - 2.0 + 2.4* fract(iTime *cloudMovementSpeed * 2.0 ), uv.y),\n                vec2(0.1,0.04), 40.0);\n    \n    \n    \n    \n    //First Mountains\n    \n    float mountainMovementSpeed = 0.3;\n    \n    DrawMountainGradient(vec2(uv.x + iTime * mountainMovementSpeed * 0.2, uv.y),\n                         colorToReturn, 0.3262, vec3(0.1, 0.9, 0.5), vec3(0.1, 0.9, 0.6),0.0);\n    DrawMountainGradient(vec2(uv.x + iTime * mountainMovementSpeed * 0.5, uv.y),\n                         colorToReturn, 0.2, vec3(0.9, 0.5, 0.2), vec3(0.9, 0.5, 0.4), .2);\n    DrawMountainGradient(vec2(uv.x + iTime * mountainMovementSpeed , uv.y),\n                         colorToReturn, 0.0433, vec3(0.9, 0.1, 0.0), vec3(0.9, 0.1, 0.3),1.8);\n        \n    \n    // Telephone Poles\n    \n    float poleMovementSpeed= 1.6;\n    \n    DrawAPole(colorToReturn, vec3(0.03, 0.3, 0.0), vec2(0.2, 0.07),\n              vec2(uv.x + 2.0 *fract(iTime) -1.0, uv.y) );\n    \n    // Draw The Car \n    \n    DrawACar(colorToReturn, uv);\n    \n    \n   \n    \n    \n\tfragColor = PalletToRGB(color01, color02, color03, backGround, colorToReturn);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}