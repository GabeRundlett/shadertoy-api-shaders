{
    "Shader": {
        "info": {
            "date": "1514267192",
            "description": "Archimedes Sprial,ugly one",
            "flags": 0,
            "hasliked": 0,
            "id": "MtBfRz",
            "likes": 1,
            "name": "Archimedes Sprial,ugly one",
            "published": 3,
            "tags": [
                "archimedessprial",
                "uglyone"
            ],
            "usePreview": 0,
            "username": "PaperColor",
            "viewed": 514
        },
        "renderpass": [
            {
                "code": "//I make this in unity3d first,then implement it here\n//Twitter:@LowpolySun\n\n//Got to translate cg to glsl\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define frac fract\n#define lerp mix\n\n#define pi 3.141592654\n#define tao 2.0*pi\n\n//This macro is always the same,the last two opreractions are to adjust the center\n#define SetUVAndMoveToCenter vec2 uv = fragCoord.xy/iResolution.xy;uv.x*=iResolution.x/iResolution.y;uv.x -= 0.35;uv.y+=0.1;\n\n#define sprialRadius 0.5\n#define sprialLineWidth 0.025\n\n//Utilities\nbool IsInRangeReturnBool(float2 p1,float2 p2,float range)\n{\n\treturn length(p1-p2)<range;\n}\n\nfloat IsInRangeReturnFloat(float2 p1,float2 p2,float range)\n{\n\tif(IsInRangeReturnBool(p1,p2,range))\n\t\treturn 1.0;\n\treturn 0.0;\n}\n\n//Core\n\nfloat FindPointAtWhichSprialCircleThereMayBeEfficientWaysButThisOneIsTheSamplestToMe(float pointToCenterLength)\n{\n\t//I need to be careful when play with infinite loops,cuz it sometimes crush unity\n\t//for(float index=0.0;;index +=1.0)\n\t//{\n\t//\tif(pointToCenterLength<=index*tao*sprialRadius)\n\t//\t\treturn index;\n\t//}\n\n    //According to the result on the left,I know that,this function is wrong,\n    //for like three days,I can not figure out how to get the correct turns of point in Archimedes sprial\n\t//maybe I fill fix this latter,your solution is welcome\n    return ceil(pointToCenterLength/sprialRadius);\n}\n\nfloat SprialPattern(float2 uv)\n{\n\t//Change center from float2(0,0) to float2(0.5,0.5)\n\tuv = uv*2.0 - 1.0;\t//I want to keep every single pattern function seperate from global values,not so efficient,but I can see clearly what's going here\n    uv*=2.0;\n\t\n    //uv*=0.0;\n    \n    float pointToCenterLength = length(uv)*10.0;\n  \tfloat pointAtWhichCircle = FindPointAtWhichSprialCircleThereMayBeEfficientWaysButThisOneIsTheSamplestToMe(pointToCenterLength);\n\n  \tfloat angleInRad = atan(uv.y,uv.x); //for unity atan2(uv.x,uv.y)\n\tfloat angleInDegree = angleInRad*180.0/pi;\n    \n  \t//float lengthOfThisAngleUsingSprialEquation =pointAtWhichCircle*tao*sprialRadius+ angleInRad*sprialRadius;\n\tfloat lengthOfThisAngleUsingSprialEquation =angleInRad*sprialRadius;\n\n  \tfloat2 pointOfThisAngleUsingSprialEquation = float2(lengthOfThisAngleUsingSprialEquation*cos(angleInRad),lengthOfThisAngleUsingSprialEquation*sin(angleInRad));\n\n  \tfloat IsInSprialLineWidthRange = IsInRangeReturnFloat(pointOfThisAngleUsingSprialEquation,uv,sprialLineWidth);\n\n  \treturn IsInSprialLineWidthRange;\n}\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tSetUVAndMoveToCenter\n\n\tfloat finalValue = SprialPattern(uv);\n\n\tfragColor = float4(finalValue,finalValue,finalValue,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}