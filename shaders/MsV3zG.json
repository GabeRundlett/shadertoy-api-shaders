{
    "Shader": {
        "info": {
            "date": "1455190411",
            "description": " all the code under come from the famous shader from shane https://www.shadertoy.com/view/ldyGWm with texture displace\n i have just modified the map func for adding the tri planar displace at line 117\n also modify the little hole size at line 136 ",
            "flags": 0,
            "hasliked": 0,
            "id": "MsV3zG",
            "likes": 16,
            "name": "Menger Sponge Var With Displace",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "displace",
                "menger",
                "reflections",
                "wood",
                "sponge",
                "shane"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 1240
        },
        "renderpass": [
            {
                "code": "//all the code under come from the famous shader from \"shane\" https://www.shadertoy.com/view/ldyGWm with texture displace\n// i have just modified the map func for adding the tri planar displace at line 117\n// also modify the little hole size at line 136 (.3/6. instead of .5/6. )\n/*\n\n    Menger Sponge Variation\n    -----------------------\n\n\tI got bored and dusted off some old Menger Sponge related code. There's a lot of \n\texamples on this site, so I'm not bringing anything new to the table. This particular\n\tobject was constructed via a slight variation on the formula.\n\n\tThe lighting was made up as I went along, so I wouldn't pay too much attention to it. \n\tHowever, the cheap reflections might be worth looking at.\n\n\tFor anyone who's never put a Menger Sponge together, here's a very, very short, overly \n\tgeneralized explanation:\n\t\n\tConstruct a Void Cube (or repeat Void Cubes, as the case may be), which is analogous \n\tto a Rubix Cube with the center mechanism removed. Create Void Cubes from the 20 cubies \n\t(the remaining\tsmaller cubes), and continue to iterate ad infinitum.\n\t\n\tIn code:\n\n\t// Repeat Void Cubes - A Void Cube is a Level-1 Menger Sponge.\n\tfloat map(vec3 p){\n    \tp = abs(mod(p, 3.) - 1.5); // Repeat space.\n    \treturn min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.; // Void Cube.\n\t}\n\n\t// More than one level Menger Sponge - Infinitely repeated, in this case.\n\tfloat map(vec3 q){\n        \n\t\tvec3 p; float d = 0.;\n        \n        // One Void Cube.\n    \tp = abs(mod(q, 3.) - 1.5);\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.);\n\n        // Subdividing into more Void Cubes.    \n    \tp = abs(mod(q, 1.) - 0.5); // Dividing above by 3.\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3.);\n        \n        // And so on.\n    \tp = abs(mod(q, 1./3.) - 0.5/3.); // Dividing above by 3.\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3./3.);\n        \n\t\t// Continue on in this manner. For more levels, you'll want to loop it. There's\n\t\t// a commented out example in the code somewhere. Also, you can experiment with \n\t\t// the code to create more interesting variants.\n\n\t\treturn d;\n\t}\n\t\n\tFor a more formal explanation, look up \"Menger Sponge,\" \"Cantor Sets,\" \"Void Cube,\" \n\tetc., on the web, or better yet, refer to the countless Menger Sponge examples\n\ton this site.\t\n\n\tExamples:\n\n\tMenger Journey - Syntopia (A favorite of mine, and everyone else.)\n\thttps://www.shadertoy.com/view/Mdf3z7\n\n*/\n\n#define FAR 40.\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, 0.001); // n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n \n    \n}\n\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// https://iquilezles.org/articles/smin\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp( 0.5+0.5*(b-a)/smoothing, 0.0, 1.0 );\n    return mix( b, a, h ) - smoothing*h*(1.0-h);\n}\n\n\n/*\n// Regular Menger Sponge formula. Very simple, but if you're not sure, look it\n// up on Wikipedia, and look up a Void Cube image.\nfloat map(vec3 q){\n    \n    vec3 p;\n\t// Scale factor, and distance.\n    float s = 3., d = 0.;\n    \n    for(int i=0; i<3; i++){\n \t\t// Repeat space.\n        p = abs(fract(q/s)*s - s/2.); // Equivalent to: p = abs(mod(q, s) - s/2.);\n\t\t// Repeat Void Cubes. Cubes with a cross taken out.\n \t\td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.);\n    \ts /= 3.; // Divide space (each dimension) by 3.\n    }\n \n \treturn d;    \n}\n*/\n\n// Variation on a Menger Sponge (See the formula above). This one has four layers. The \n// easiest way to understand this is to comment out layers, then add them back in to \n// see what each does.\nfloat map(vec3 q){\n    \n    // basic tri planar add\n    float dsp = 0.02;\n    q.z += dot(texture(iChannel1, q.xy).rgb, vec3(dsp));\n\tq.x += dot(texture(iChannel1, q.yz).rgb, vec3(dsp));\n\tq.y += dot(texture(iChannel1, q.xz).rgb, vec3(dsp));\n\t\n    // Layer one. The \".05\" on the end varies the hole size.\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\n    \n    // Layer two.\n    p =  abs(fract(q) - .5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\n   \n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    p =  abs(fract(q*2.)*.5 - .25);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \n\n    // Layer four. The little holes, for fine detailing.\n    p =  abs(fract(q*3./.5)*.5/3. - .3/6.);\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\n    //return max(d, max(max(p.x, p.y), p.z) - 1./18. - .024);\n    //return max(d, length(p) - 1./18. - .048);\n    \n    //p =  abs(fract(q*3.)/3. - .5/3.);\n \t//return max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./9. - .04);\n}\n\n\n\n// Very basic raymarching equation. Menger Sponge objects raymarch reasonably well. Not all surfaces do.\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    for(int i=0; i< 64; i++){        \n        d = map(ro + rd*t);\n        if (d <.0025*t || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n// The reflections are pretty subtle, so not much effort is being put into them. Only a few iterations.\nfloat refTrace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for(int i=0; i< 16; i++){\n        d = map(ro + rd*t);\n        if (d <.0025*t || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO(in vec3 p, in vec3 n){\n    \n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.;\n    \n    const float maxDist = 1.;\n    for(float i=1.; i<nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 16; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.02, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.5, 1.0); \n}\n\n/*\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// It gives you a scalar curvature value for an object's signed distance function, which \n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n// calculations, I'm assuming. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p){\n\n    //const float eps = 0.05, amp = 4.0, ampInit = 0.5;\n    const float eps = 0.15, amp = 2.5, ampInit = 0.0;\n\n    vec2 e = vec2(-1., 1.)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit direction ray vector: Note the absence of a divide term. I came across this via a comment \n    // Shadertoy user \"Coyote\" made. I'm pretty happy with this.\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); // Normalizing below.\n    \n    // Barrel distortion. Looks interesting, but I like it because it fits more of the scene in.\n    // If you comment this out, make sure you normalize the line above.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(0, 1.57079632) + iTime/4.);\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\n    \n    \n    // Ray origin, set off in the Z direction.\n    vec3 ro = vec3(0.0, 0.0, iTime);\n    vec3 lp = ro  + vec3(0.0, 1.0, 0.0); // Light, near the ray origin.\n    \n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    // Scene hit, so do some lighting.\n    if(t<FAR){\n    \n        vec3 sp = ro + rd*t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n        vec3 ref = reflect(rd, sn); // Reflected ray.\n\n\t\tconst float ts = 2.; // Texture scale.\n        vec3 oCol = tex3D(iChannel0, sp*ts, sn); // Texture color at the surface point.\n        \n \t\t\n        // Darker toned wood paneling. Very fancy. :)\n        vec3 q = abs(mod(sp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z) < 1.063) oCol = oCol*vec3(.7, .85, 1.); \n\n        // Bringing out the texture colors a bit.\n        oCol = smoothstep(0.0, 1.0, oCol);\n \n        float sh = softShadow(sp, lp, 16.); // Soft shadows.\n        float ao = calculateAO(sp, sn); // Self shadows.\n\n        vec3 ld = lp - sp; // Light direction.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); // Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 12.); // Specular.\n        //float fres = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n\n        float atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*.1); // Attenuation.\n        \n        \n        // Secondary camera light, just to light up the dark areas a bit more. It's here just\n        // to add a bit of ambience, and its effects are subtle, so its attenuation \n        // will be rolled into the attenuation above.\n        diff += max(dot(-rd, sn), 0.)*.45;\n        spec += pow(max(dot(reflect(rd, sn), -rd), 0.), 12.)*.45;\n        \n        // Based on Eiffie's suggestion. It's an improvement, but I've commented out, \n        // for the time being.\n        //spec *= curve(sp); \n\n\n\t\t// REFLECTION BLOCK.\n        //\n        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n        // effort is being put in.\n        float rt = refTrace(sp + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n        vec3 rsp = sp + ref*rt; // Reflected surface hit point.\n        vec3 rsn = normal(rsp); // Normal at the reflected surface.\n        \n        vec3 rCol = tex3D(iChannel0, rsp*ts, rsn); // Texel at \"rsp.\"\n        q = abs(mod(rsp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z)<1.063) rCol = rCol*vec3(.7, .85, 1.);  \n        // Toning down the power of the reflected color, simply because I liked the way it looked more. \n        rCol = sqrt(rCol); \n        float rDiff = max(dot(rsn, normalize(lp-rsp)), 0.); // Diffuse at \"rsp\" from the main light.\n        rDiff += max(dot(rsn, normalize(-rd-rsp)), 0.)*.45; // Diffuse at \"rsp\" from the camera light.\n        \n        float rlDist = length(lp - rsp);\n        float rAtten = 1./(1.0 + rlDist*0.25 + rlDist*rlDist*.1);\n        rCol = min(rCol, 1.)*(rDiff + vec3(.5, .6, .7))*rAtten; // Reflected color. Not accurate, but close enough.\n        //\n    \t// END REFLECTION BLOCK.\n        \n\n        // Combining the elements above to light and color the scene.\n        col = oCol*(diff + vec3(.5, .6, .7)) + vec3(.5, .7, 1)*spec*2. + rCol*0.25;\n\n\n        // Shading the scene color, clamping, and we're done.\n        col = min(col*atten*sh*ao, 1.);\n        \n        \n        \n        \n        \n         \n    }\n    \n    // Working in a bit of a blue fadeout in the distance. Totally fake. I chose blue to counter all\n    // that walnut. Seemed like a good idea at the time. :)\n    col = mix(col, vec3(.55, .75, 1.), smoothstep(0., FAR - 15., t));////1.-exp(-0.01*t*t)\n\n    \n\tfragColor = vec4(col, 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}