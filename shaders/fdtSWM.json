{
    "Shader": {
        "info": {
            "date": "1633363001",
            "description": "HOLHO holographic renderer with a fish. See HOLHO viewers https://holhocollection.com",
            "flags": 32,
            "hasliked": 0,
            "id": "fdtSWM",
            "likes": 5,
            "name": "HOLHO Fish",
            "published": 3,
            "tags": [
                "fish",
                "holho"
            ],
            "usePreview": 0,
            "username": "shau",
            "viewed": 344
        },
        "renderpass": [
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n * Simple animation of fish for a HOLHO viewer \n * Official HOLHO 4 viewer used to test this animation\n * https://holhocollection.com/#group_4177-1\n * Tested on official iPhone Shadertoy App using High Quality settings\n * Adjust BOXWIDTH,BOXHEIGHT and CENTERBOX (offset) to suite your device\n * Make your own HOLHO viewer \n * https://www.youtube.com/watch?v=Xhu-XjXa4p4\n */\n\n//THIS BUFFER TRANSLATES OUTPUT OF BUFFERS TO 4 VIEWS\n//Most examples I have seen use a single scene projected onto 4 faces of viewer\n//Set below to 1 to use individual (front,right,rear,left) projected views \n//onto each face of viewer\n#define USE_PROJECTIONS 1\n\nvec3 renderBox(sampler2D tx, ivec2 iU, vec2 uv, ivec2 u)\n{\n    if (uv.y>0.0 && abs(uv.x)<uv.y)\n    {\n        return texelFetch(tx,u,0).xyz; \n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0);\n    ivec2 iU = ivec2(U),\n          imageBox = imageDimensions(R);\n    vec2 uv = (U - R*.5) / R.y;\n    \n    //TOP BOX\n    ivec4 box = ivec4(int(R.x)/2-imageBox.x/2,\n                      int(R.x)/2+imageBox.x/2, \n                      int(R.y)/2+CENTERBOX/2,\n                      int(R.y)/2+CENTERBOX/2+imageBox.y);\n    #if USE_PROJECTIONS==1 \n    //projected rear view\n    col += renderBox(iChannel2,\n                     iU,\n                     uv,\n                     ivec2(iU.x-box.x,\n                           iU.y-box.z));\n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     iU,\n                     uv,\n                     ivec2(iU.x-box.x,\n                           iU.y-box.z));\n    #endif\n    \n    //RIGHT BOX\n    box = ivec4(int(R.x)/2+CENTERBOX/2,\n                int(R.x)/2+CENTERBOX/2+imageBox.y, \n                int(R.y)/2-imageBox.x/2,\n                int(R.y)/2+imageBox.x/2);\n    #if USE_PROJECTIONS==1 \n    //projected right view\n    col += renderBox(iChannel1,\n                     iU,\n                     vec2(uv.y,uv.x),\n                     ivec2(box.w-iU.y,\n                           iU.x-box.x)); \n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     iU,\n                     vec2(uv.y,uv.x),\n                     ivec2(box.w-iU.y,\n                           iU.x-box.x)); \n    #endif\n    \n    //BOTTOM BOX\n    box = ivec4(int(R.x)/2-imageBox.x/2,\n                int(R.x)/2+imageBox.x/2, \n                int(R.y)/2-CENTERBOX/2-imageBox.y,\n                int(R.y)/2-CENTERBOX/2);\n    //default front view - also default projection\n    col += renderBox(iChannel0,\n                     iU,\n                     vec2(uv.x,-uv.y),\n                     ivec2(box.y-iU.x,\n                           box.w-iU.y));\n    \n    //LEFT BOX                        \n    box = ivec4(int(R.x)/2-CENTERBOX/2-imageBox.y,\n                int(R.x)/2-CENTERBOX/2, \n                int(R.y)/2-imageBox.x/2,\n                int(R.y)/2+imageBox.x/2);\n    #if USE_PROJECTIONS==1 \n    //projected left view\n    col += renderBox(iChannel3,\n                     iU,\n                     vec2(uv.y,-uv.x),\n                     ivec2(iU.y-box.z,\n                           box.y-iU.x)); \n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     iU,\n                     vec2(uv.y,-uv.x),\n                     ivec2(iU.y-box.z,\n                           box.y-iU.x)); \n    #endif\n\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-------\n\n#define PI 3.141592\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 100.0\n#define FL 2.6\n\n//WIDTH OF RENDERING\n#define BOXWIDTH 1250\n//SIZE OF CENTER OFFSET IN X AND Y\n#define CENTERBOX 100\n\n//RAYMARCHING AND SHADER IN COMMON TO HANDLE CASES THAT NEED\n//MULTIPLE CAMERA ANGLES (ALSO MULTIPLE BUFFERS)\n\n/* MODEL START */\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//SDF functions IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.y, max(abs(p.z)-le,0.0), p.x );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nvec2 near(vec2 a, vec2 b)\n{\n    float s = step(a.x,b.x);\n    return s*a + (1.0-s)*b;\n}\n\n//fishy\nvec2 map(vec3 p, float T) \n{\n    p.z += sin(p.x*0.5+T*1.7)*0.5;\n    vec3 q = p;\n    float nz = n3D(p*7.0)*0.03*\n               smoothstep(1.3,0.0,abs(p.y))*\n               smoothstep(2.4,0.0,abs(p.x+2.0));\n    float body = max(sdEllipsoid(p,vec3(4.8,1.2,0.6+nz)),p.x);\n    body = min(body,sdEllipsoid(p,vec3(2.2,1.2,0.6+nz)));\n    //mouth\n    body = smin(body,sdLink(p-vec3(2.18,-0.1,0.0),0.08,0.14,0.1),0.1);    \n    //vertical fins\n    //top bottom fins\n    q.z += sin(q.y*3.0+T*3.0)*0.1*smoothstep(0.8,2.0,abs(q.y));\n    float fins = max(sdCappedCylinder(q.xzy-vec3(-1.8,0.0,0.0),2.2,0.02),\n                    -sdCappedCylinder(q.xzy-vec3(-4.6,0.0,0.0),3.4,0.1)); \n    //tail\n    fins = min(fins,sdCappedCylinder(q.xzy-vec3(-6.0,0.0,0.0),1.6,0.02));\n    fins = max(fins,-sdCappedCylinder(q.xzy-vec3(-7.8,0.0,0.0),2.8,0.2)); \n    q = p;\n    q.z = abs(q.z); \n    //gills\n    body = smax(body,-sdEllipsoid(q-vec3(0.4,0.0,0.4),vec3(0.5,0.7,0.26)),0.1);\n    body = smin(body,sdEllipsoid(q-vec3(0.6,0.0,0.38),vec3(0.6,0.8,0.26)),0.1);\n    //eyes\n    //bulge\n    vec2 xy = vec2(1.2,0.4);\n    body = smin(body,sdSphere(q-vec3(xy,0.0),0.6),0.3);\n    //cutout\n    body = smax(body,-length(p.xy-xy)+0.26,0.04);\n    //eyeball\n    float eye = sdSphere(q-vec3(xy,0.4),0.3);\n    float iris = sdSphere(q-vec3(xy,0.5),0.22);\n    //horizontal fins\n    q.yz *= rot(0.5);\n    q.y += sin(q.z*3.0+T*2.0)*0.1*smoothstep(0.6,1.6,abs(q.z));\n    float hFins = max(sdCappedCylinder(q-vec3(-3.0,0.0,0.0),1.6,0.02),\n                     -sdCappedCylinder(q-vec3(-5.6,0.0,0.0),3.0,0.1));\n    vec2 nr = near(vec2(body,1.0),vec2(fins,2.0));\n    nr = near(nr,vec2(hFins,3.0));\n    nr = near(nr,vec2(eye,4.0));\n    nr = near(nr,vec2(iris,5.0));\n    return nr;\n}\n\n/* MODEL END */\n\n/* COMMON RENDERING FOR ALL BUFFERS */\n\nvec3 normal(vec3 p, float T) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=0; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz,T).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n, float T) \n{\n    float ra = 0., w = 1., d = 0.;\n    for (int i=0; i<5; i++){\n        d = float(i) / 5.;\n        ra += w * (d - map(p + n*d,T).x);\n        if (ra>1.) break;\n        w *= .5;\n    }\n    return 1. - clamp(ra,0.,1.);\n}\n\n//IQ\n//https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( vec3 ro, vec3 rd, float mint, float tmax, int technique, float T )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, T ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec2 march(vec3 ro, vec3 rd, float T)\n{\n    float t = 0.0, id = 0.0;\n    for (int i=0; i<100; i++)\n    {\n        vec2 ns = map(ro+rd*t,T);\n        if (abs(ns.x)<EPS)\n        {\n            id = ns.y;\n            break;\n        }\n        t += ns.x;\n        if (t>FAR)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    return vec2(t,id);\n}\n\n//colour me in\nvec3 render(vec3 ro, vec3 rd, float T)\n{\n    vec3 col = vec3(0),\n         lp = vec3(4.0,5.0,-3.0);\n    \n    vec2 ns = march(ro,rd,T);\n    if (ns.x>0.0)\n    {\n        vec3 p = ro+rd*ns.x; \n        vec3 n = normal(p,T);\n        vec3 ld = normalize(lp-p);\n        \n        vec3 sc = vec3(0.0);\n        if (ns.y==1.0)\n        {\n            //body\n            float m = (smoothstep(1.4,0.4,length(p-vec3(-1.4,0.0,0.0)))+\n                       smoothstep(1.0,0.0,abs(p.y))) *\n                       smoothstep(3.0,0.0,abs(p.x+1.6));\n            m += n3D(p*4.0)*0.2;\n                      \n            sc = mix(vec3(0.5,0.1,0.0),vec3(0.8,0.6,0.2),m);\n        }\n        if (ns.y==2.0)\n        {\n            //vfins\n            float m = smoothstep(1.3,0.0,length(p.xy-vec2(-5.4,0.0))); \n            m += smoothstep(2.2,0.0,length(p.xy-vec2(-1.8,0.0)));\n            m += n3D(p*4.0)*0.2;\n            sc = mix(vec3(0.5,0.1,0.0),vec3(0.8,0.6,0.2),m);\n        }\n        if (ns.y==3.0)\n        {\n            //hfins\n            float m = n3D(p*4.0)*0.2;\n            sc = mix(vec3(0.5,0.1,0.0),vec3(0.8,0.6,0.2),m);\n        }\n        if (ns.y==4.0)\n        {\n            sc = vec3(1.0,0.8,0.6);\n        }\n        \n        float ao = AO(p,n,T);\n        float sh = calcSoftshadow(p+n*EPS,ld,EPS,FAR,1,T);\n        float spec = pow(max(dot(reflect(-ld,n),-rd),0.0),8.0);\n\n        col = sc * max(0.0,dot(ld,n));\n        col += vec3(0.7,0.9,1.0)*0.4*spec;\n        col *= ao*sh;\n        col += vec3(0.0,0.1,0.3)*0.04*max(0.0,-n.y);\n    }\n    return pow(col,vec3(0.3545));\n}\n\nivec2 imageDimensions(vec2 r)\n{\n    int a = min(BOXWIDTH,min(int(r.x),int(r.y)));\n    return ivec2(a,a/2);\n}\n\nvec3 camera(vec2 U, vec2 r, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - r*.5) / r.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER FRONT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         la = vec3(0.0),\n         ro = vec3(0.0,0.0,-6.5);\n    ro.xz *= rot(iTime*-0.2);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = render(ro,camera(U,vec2(imageBox),ro,la,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER RIGHT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         la = vec3(0.0),\n         ro = vec3(0.0,0.0,-6.5);\n    ro.xz *= rot(iTime*-0.2+PI*0.5);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = render(ro,camera(U,vec2(imageBox),ro,la,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER REAR VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         la = vec3(0.0),\n         ro = vec3(0.0,0.0,-6.5);\n    ro.xz *= rot(iTime*-0.2+PI);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = render(ro,camera(U,vec2(imageBox),ro,la,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER LEFT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         la = vec3(0.0),\n         ro = vec3(0.0,0.0,-6.5);\n    ro.xz *= rot(iTime*-0.2+PI*1.5);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = render(ro,camera(U,vec2(imageBox),ro,la,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}