{
    "Shader": {
        "info": {
            "date": "1503932706",
            "description": "Inspired from: https://www.youtube.com/watch?v=yxNnRSefK94",
            "flags": 0,
            "hasliked": 0,
            "id": "4tXczM",
            "likes": 3,
            "name": "Stellar dance floor",
            "published": 3,
            "tags": [
                "raymarching",
                "newbe"
            ],
            "usePreview": 0,
            "username": "ageron",
            "viewed": 1330
        },
        "renderpass": [
            {
                "code": "/*\nThis shader implements the Ray Marching algorithm.\n*/\n\n/*\nmap() takes a point p and returns the distance to the closest object from that\npoint in any direction. In this implementation, there's a ball at every integer\ncoordinates. Each ball's radius varies according to its position.\nIf you want to change the contents of the scene, this is the function to modify.\n*/\nfloat map(vec3 p)\n{\n    float r = 0.1 * (1.0 + sin(float(floor(p))));\n    vec3 q = fract(p) * 2.0 - 1.0;\n    return length(q) - r;\n}\n\n/*\ntrace() sends out a ray from the observer's position o in the direction of\nvector r (a unit 3D vector), and it returns the distance to the closest object\nin that direction.\nIt works using the Ray Marching algorithm: at every step it makes, it looks at\nthe distance of the closest object (in any direction, using the map() function)\nand that tells it the size of the next step it can make without hitting any\nobject (it divides that step size by two for more precision). So it will slow\ndown when it comes close to any object (even ones that are not on its path) and\nit will accelerate when there's no nearby object. Usually, after just 32\niterations it will be very close to the target object (never actually hitting\nit), and we just return the total distance d from the observer.\n*/\nfloat trace(vec3 o, vec3 r)\n{\n    float d = 0.0;\n    for (int i = 0; i < 32; i++)\n    {\n        vec3 p = o + r * d;\n        d += map(p) * 0.5;\n    }\n    return d;\n}\n\n/*\nThe mainimage() function is called once for each pixel in the image by the\nshader engine and it must set that pixel's color fragColor, given its\ncoordinates fragCoord.\nThe general idea is to imagine that the screen is held up in front of the\nobserver (in 3D space), and we will shoot out a ray from the observer out\nto the 3D scene, through the current pixel. We use the trace() function to find\nthe distance to the closest object in that direction. Then we assume there's\na bright colored object at that point, and we determine the color of the pixel\nby assuming there's a more or less dense fog on the way (the density\noscillates just for fun): the closer the object is, the brighter it will\nappear. Far away objects are too dark to see. (the pixel is black).\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // Screen coord to [0,1[ range.\n    uv = uv * 2.0 - 1.0;                     // To [-1, 1[ range.\n    uv.x *= iResolution.x / iResolution.y;   // Fix aspect ratio.\n\n    vec3 o = vec3(iTime, cos(iTime), sin(iTime)); // Observer's position    \n    \n    // r is the unit vector giving the direction from the observer\n    // to the current pixel. 1.7 is the distance from the observer to the\n    // screen. Try tweaking this value to see the effect.\n    vec3 r = normalize(vec3(uv, 1.7));\n    float a = iTime / 5.0; // Observer's rotation angle\n    r.xz *= mat2(cos(a), -sin(a), sin(a), cos(a)); // Rotate the observer\n    float d = trace(o, r); // Shoot the ray!\n    float fog = 10.0 / (1.0 + d * d * 0.05); // Compute the fog's effect.\n    // Compute the color of the objects:\n    vec3 col = vec3(cos(iTime) * 0.5 + 0.5, // Red\n                    0.5 * sin(iTime) + 0.5, // Green\n                    sin(iTime / 3.1243));   // Blue\n    fragColor = vec4(fog * col, 1.0); // apply the fog to that color.\n}\n// The end. Hope you enjoyed the tour!\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}