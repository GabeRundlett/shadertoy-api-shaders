{
    "Shader": {
        "info": {
            "date": "1699875747",
            "description": "Ray Marching if you have tipps leave a comment\nTap on the Frame to move the Camera ",
            "flags": 0,
            "hasliked": 0,
            "id": "DdVcWR",
            "likes": 1,
            "name": "Ray Marching Color Work in progr",
            "published": 3,
            "tags": [
                "raymarching",
                "rmc"
            ],
            "usePreview": 0,
            "username": "simplexqwe",
            "viewed": 119
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv   = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 mouse=(iMouse-.5*iResolution.xyxy)/iResolution.xyxy*vec4(2,1,2,1);\n    vec3 col  = Controler(uv,iTime,mouse);\n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 75.\n#define SURF_DIST .01\n\nfloat pi=radians(200.);\n\nvec3 ref(vec3 r,vec3 n){\n    return r-2.*dot(r,n)*n;\n}\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat SmoothMax(float a,float b,float c){\n    return log(exp(a*c)+exp(b*c))/c;\n}\n\nfloat SmoothMin(float a,float b,float c){\n    return -SmoothMax(-a,-b,c);\n}\n\nfloat capsuleDist(vec3 p,vec3 a,vec3 b,float r){\n    vec3 ba = b-a;\n    vec3 pa = p-a;\n    float t = dot(ba,pa)/dot(ba,ba);\n    t=clamp(t,0.,1.);\n    vec3 c  = a+t*ba;\n    return length(p-c)-r;\n    \n}\n\nfloat torusDist(vec3 p, vec2 r,vec3 a){\n    float x =length(p.xz-a.xz)-r.x;\n    return length(vec2(x,p.y-a.y))-r.y;\n}\n\nfloat boxDist(vec3 p,vec3 s){\n    vec3 d=vec3(0.);\n    d.x=(max(vec3(0).x,abs(p.x)-s.x));\n    d.y=(max(vec3(0).y,abs(p.y)-s.y));\n    d.z=(max(vec3(0).z,abs(p.z)-s.z));\n\n    return length(d);\n}\n\nvec4 GetDist(vec3 p){\n    vec4 s=vec4(0.,1.,6.,1.);\n    vec4 c=vec4(2.5,1.,6.,1.);\n    vec3 C=vec3(2.5,3.,6.);\n    vec3 pn=vec3(0,1,0);\n    \n    vec3 pc=vec3(0.,0.,0.);\n    vec3 sc=vec3(0.,1.,0.);\n    vec3 cc=vec3(0.,0.,1.);\n    vec3 bc=vec3(1.,1.,0.);\n    vec3 tc=vec3(1.,0.,1.);\n    \n    float sphereDist= length(p-s.xyz)-s.w;\n    float planeDist = dot(p,normalize(pn))+15.;\n    float cDist     = capsuleDist(p,c.xyz,C,c.w);\n    float TorusDist = torusDist(p,vec2(3.,1.),vec3(-5.5,0,6.));\n    float BoxDist   = boxDist(p-vec3(-3.,3.5,8.5),vec3(1.));\n    \n    vec4 d =vec4(1.);\n\n    if(d.w>sphereDist)d.xyz=sc;\n    d=vec4(d.xyz,min(d.w,sphereDist));\n\n    if(d.w>planeDist)d.xyz=pc;\n    d=vec4(d.xyz,min(d.w,planeDist));\n\n    if(d.w>TorusDist)d.xyz=tc;    \n    d=vec4(d.xyz,min(d.w,TorusDist));\n    \n    if(d.w>cDist)d.xyz=cc;    \n    d=vec4(d.xyz,min(d.w,cDist));\n\n    if(d.w>BoxDist)d.xyz=bc;    \n    d=vec4(d.xyz,min(d.w,BoxDist));\n    \n    return d;\n}\n\nvec4 RayMarch(vec3 ro,vec3 rd){\n  float dO=0.;\n  vec4 ds;    \n  for(int i=0;i<MAX_STEPS;i++){\n    vec3 p = ro+rd*dO;\n    ds=GetDist(p);\n    dO+=ds.w;\n\n    if(dO>MAX_DIST || abs(ds.w)<SURF_DIST) {\n    break;\n    }\n  }  \n  return vec4(ds.xyz,dO);\n}\n\nvec3 GetNormal (vec3 p){\n    float d = GetDist(p).w;\n    vec2  e = vec2(.01,0.);\n    \n    vec3  n =d-vec3(\n    GetDist(p-e.xyy).w,\n    GetDist(p-e.yxy).w,\n    GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec3 GetLight (vec3 p,vec3 n,vec3 LightPos,vec2 Shift,vec3 ton,vec3 vd){\n    LightPos.xz  += Shift;\n    vec3 l        = normalize(LightPos-p);    \n    vec3 dif = vec3(clamp(dot(n,l),0.,1.))*ton;\n    vec4 d   = RayMarch(p+n*SURF_DIST*2.,l);\n    float t   = length(LightPos+p);\n    if(d.w<t)dif*=.1;\n    dif/=t/15.;\n    return dif;\n\n}\n\n\nvec3 refl(vec3 ro,vec3 rd,float w1,vec3 lpo,vec2 shift,float boun){\n    \n    vec4 d=RayMarch(ro,rd);\n    vec3 p=ro+rd*d.w;\n    vec3 n=GetNormal(p);\n    vec3 dif=GetLight(p,n,lpo,shift,vec3(boun),rd);\n    \n    vec4 col=d;\n\n    \n    for(float i=2.;i<boun+2.;i++){\n        d=RayMarch(ro,rd);\n        p=ro+rd*d.w;\n        n = GetNormal(p);\n        \n        vec3 dif1=GetLight(p,n,lpo,shift,vec3(boun),rd);\n        \n        float aw=(i-1.)/i;\n        float nw=1.-(i-1.)/i;\n        \n        col=(col*aw+d*nw);\n        dif=(dif*aw+dif1*nw);\n        \n        rd =ref(rd,n);\n        ro =p+n*SURF_DIST;\n    }\n    \n    return dif*col.xyz*boun;\n}\n\nvec3 Controler (vec2 uv,float iTime,vec4 mouse){\n    \n    vec3 ro  = vec3(0,0,-8);\n    vec3 rd  = normalize(vec3(uv.x,uv.y,1));\n    \n    vec3 ce=vec3(0.,1.,6.);\n    \n    rd.yz*=Rot(mouse.y*pi);\n    ro.yz=(ro.yz-ce.yz)*Rot(mouse.y*pi)+ce.yz;\n    \n    rd.xz*=Rot(mouse.x*pi);\n    ro.xz=(ro.xz-ce.xz)*Rot(mouse.x*pi)+ce.xz;\n    \n    vec3 lpo=vec3(1,15,1);\n    vec2 shift=lpo.xy*Rot(iTime);\n    \n    vec3 col=refl(ro,rd,0.,lpo,shift,2.);\n    \n    return col;\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}