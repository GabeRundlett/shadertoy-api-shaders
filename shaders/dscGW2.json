{
    "Shader": {
        "info": {
            "date": "1677855222",
            "description": "Mediterran reef and waves with volumetric clouds.\nSome code borrowings from IQ clouds.\nUse mouse X to change camera angle, key x to change clouds sharpness",
            "flags": 16,
            "hasliked": 0,
            "id": "dscGW2",
            "likes": 8,
            "name": "Mediterran reef and clouds",
            "published": 3,
            "tags": [
                "sea",
                "clouds"
            ],
            "usePreview": 0,
            "username": "guil",
            "viewed": 322
        },
        "renderpass": [
            {
                "code": "            \n\n//reef/waves combined field\nvec3 map(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n    vec3 q=p,r=p;\n    vec3 n = vec3(0);\n\tvec2 l = vec2(2.);\n\tfor(e=f=p.y;s<5e1;s*=1.3)\n            p.xz*=m2,\n            n.xy*=m2,\n            q=p*s+n,\n            r=p*s+n,\n            r.x+=iTime*.5*s,\n            e+=.25*abs(dot(sin(r.xz*.1)/s,.8*l)),\n            f+=.2+.2*(dot(sin(q.xz*.5)/s,l)),\n            n-=cos(q);\n    e+=1.7;\n    return vec3(min(e,f),f,e);\n}\n\nvec3 normalRocks(in vec3 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).y - map(p - e.xyy).y,\n        .008,\n\t\tmap(p + e.yyx).y - map(p - e.yyx).y\n\t\t));\n}\n\nvec3 normalSea(in vec3 p)\n{\n\tconst vec2 e = vec2(0.005, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).z - map(p - e.xyy).z,\n        .02,\n\t\tmap(p + e.yyx).z - map(p - e.yyx).z\n\t\t));\n}\n\nconst float sc =1.;\nconst float low = 7.;\nconst float high = 12.;\nconst float rt = 6e3;\n\nfloat f(vec3 p)//clouds\n{\n    p *= sc;    \n    p.y += rt;\n    p.y = length(p)-rt;\n    p.z +=.2*iTime;\n    float d =fbm2(p,iTime)/sc;\n    return d+exp(2.*(low-p.y))+exp(p.y-high);\n}\n\nvec2 marchsky( vec3 ro, vec3 rd)\n{\n    int st = 64;\n    if(rd.y<0.001)return vec2(0.); \n    float t=low/(.07+rd.y),h=(high-low)/(.1+rd.y)/float(st),d,c=1.,dt=1.,k=1.5,e,a=0.;\n    vec3 p;\n    for(int i=0;i<st;++i)\n    {\n        p=ro+rd*t;\n        d=f(p); \n        e=sharp ? smoothstep(.4, .7, .6*d) : 1.-exp(-d*d);      \n        c*=e;\n        t+=k*h*e;\n        if(t>400.)return vec2(0.); \n        a+=((f(p+sundir*dt)-d)/dt+.5)*(1.-e)*c;\n        k*=1.015;\n    }\n    \n    return vec2(a*.7,(1.-c)*1.2);\n}\n\nvec3 sky( in vec3 ro, in vec3 rd )//modified from IQ clouds\n{\n    // background sky         \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );    \n    vec3 col = vec3(0.6,0.6,0.78) - rd.y*0.5*vec3(1.0,0.4,.05) ;    \n    col += 0.4*suncol*pow( sun, 8.0 ); \n    col *=.9;\n    // clouds        \n    vec2 res = marchsky( ro, rd);\n    float k = res.x, c=res.y;\n    if(c>.0)\n       col *= 1.-.1*c,\n       col += (.2+k)*c*suncol,\n       col += vec3(0.2,0.08,0.04)*pow( sun, 3.0 )*c;    \n    return col;\n}\n\n\nvec3 march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 50.0;\n\tconst float precis = 0.001;\n    float h = 0.0;\n    float t = 0.0;\n    float dt = .2;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t).x;\n        t += h*dt;\n        dt *= 1.015;\n    }\n    if(t < maxd) res = t;\n    return vec3(res,map(ro + rd * t).yz);\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel1, ivec2(key,2),0).x != 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n\tvec3 col = vec3(0.);   \t\n    vec3 li = sundir;\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n\n    float zoom=1.; \n    sharp = true;\n    if(keypress(88))sharp = !sharp;\n    vec3 ro=1.*vec3(sin(3.*m.x),0.*m.y+2.,cos(3.*m.x));\n    vec3 rd=normalize(vec3(uv.xy,zoom));\n    vec3 target=vec3(0,2.,0);\n\n    vec3 w=normalize(target-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=normalize(cross(w,-u));\n\n    rd=mat3(u,v,w)*rd;\n    \n    \n    vec3 a = march(ro, rd);\n    float t = a.x;\n    float dh = a.z-a.y;\n    \n    vec3 skyCol = sky(ro,rd);\n    col = skyCol;\n    \n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;       \n        float k=map(pos).z*1.+1.3;       \n        vec3 nor = normalRocks(pos);\n        float r = max(dot(nor, li),0.1)/2.5;\n        col =r*vec3(k*k, k, .8)+.2*exp(-50.*dh*dh)+.05;\n        if(dh<0.1){\n        \tvec3 nor = normalSea(pos+dh*rd);\n        \tnor = reflect(rd, nor);\n            col +=vec3(0.9,.2,.05)*dh*.5;\n        \tcol += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.7);\n            uv.y*=-1.;\n            col*=.5;\n        \tcol +=.6* sky(ro,nor);\n            \n        }\n\t    col = .1+col;\n        \n\t}\n    float maxd = 50.;\n    col = mix(col, skyCol, smoothstep(.6, .99, min(t, maxd)/maxd));\n\n    \n   \tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 sundir = normalize( vec3(-1.,.5,-1.) );\nconst vec3 suncol = vec3(1.,.8,.5);\n\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 ); \n\nbool sharp=true;\n\nmat2 r2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nfloat fbm(vec2 p)//ground\n{\n    float s=.3;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.);\n    for(int i=0;i<7;i++)r+=sin(p), p=m*(p*s+.2*r+.1),s*=1.6;\n    return r.x+r.y;\n}\n\nfloat fbm1(vec2 p)//grass\n{\n    float s=2.;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.);\n    for(int i=0;i<8;i++)r+=(sin(p.yx+.5))/s, p=m*p*s+cos(r.yx*s), s*=1.02;\n    return (r.x+r.y)/s;\n}\n\n\nfloat fbm2(vec3 p, float t)//clouds\n{\n    float s=1., r= -4.3;\n    p += 4.*cos(.07*p)+5.*sin(.05*p.zyx+1.);\n    p*=.4;\n    p.xz *=.4;\n    vec3 n = vec3(1);\n    for(int i=0;i<8;i++)\n        p = m3*p.zxy,      \n        n+=.8*cos(p*s+.05*t), \n        r+=abs(dot(sin(p*s+n.zxy-1.)/s,vec3(1.))),\n        s*=1.9;    \n    \n    return -r;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}