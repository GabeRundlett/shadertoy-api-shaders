{
    "Shader": {
        "info": {
            "date": "1652547821",
            "description": "This is a fake GI. I call this \"Normal Oriented Color Bleeding\".\nThis time, I added roughly multi bounced indirect light.\nIt looks like a path tracing. But it's very rough.",
            "flags": 0,
            "hasliked": 0,
            "id": "7t2fWD",
            "likes": 19,
            "name": "Normal Oriented Color Bleeding",
            "published": 3,
            "tags": [
                "gi",
                "global",
                "illumination",
                "lighting",
                "bleeding"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 536
        },
        "renderpass": [
            {
                "code": "//#define DEBUG_VIEW\n//#define AA\n#define PIXEL_NOISE\nconst float MAX_SAMP = 16.;\nconst float BOUNCE = 4.;\n\nstruct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n    vec3 bleed;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\nRay ray;\nLight lit0;\n\n#define MIN_DIST 0.001\n#define MAX_DIST 20.0\n#define ITERATION 50\n\n#define MAT_VOID vec3(-1)\n#define MAT_WHITE vec3(0.85)\n#define MAT_BLACK vec3(0.03)\n#define MAT_RED vec3(.850,0.149,0.000)\n#define MAT_BLUE vec3(0.000,0.667,.850)\n#define MAT_GREEN vec3(0.000,.850,0.165)\n#define MAT_YELLOW vec3(.850,.850,0.149)\n#define MAT_PURPLE vec3(.850,0.078,.850)\n#define AMB_COL vec3(0.486,0.655,0.996)\n#define AMB_COL2 vec3(0.000,0.157,0.941)\n#define AMB_STRENGTH 0.3\n#define FOG_COL AMB_COL\n#define FOG_START 0.0\n#define FOG_POW 1.85\n\n#define LIGHT_STRENGTH 2.\n\nfloat sdBox( vec3 p, vec3 b ) {\n    const float r = .01;\n\tvec3 d = abs(p) - b+r;\n\treturn min(0.,max(d.x,max(d.y,d.z))) + length(max(d,0.)) - .01;\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat map(in float dist, in float c, in float l, in float q)\n{\n    return 1. - 1. / (c + l * dist + q * pow(dist,2.5));\n}\n\nfloat opIntS(float a,float b,float r){\n  float h = max( r-abs(a-b), 0. )/r;\n  return max( a, b ) + h*h*h*r*(1./6.);\n}\n\nvec4 v4OpSub(in vec4 a,in vec4 b){\n\treturn a.x>b.x?a:b;\n}\n\nfloat txGrid(vec2 uv, float size){\n    if(ceil(sin(iTime*.6)*5.)>2.5)return 1.;\n    return float(abs(ceil(fract(uv.x*size)-.5)+ceil(fract(uv.y*size)-.5)-1.));\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n    \n    // room box\n    vec3 bs = vec3(.025,1.025,1.025);\n    float grds = 0.5;\n    grds = abs(floor(sin(iTime*1.)*4.));\n    \n    bool v = (ceil(sin(iTime*.2)*2.)>1.);\n    bool bw = (ceil(cos(iTime*.8)*2.)>1.);\n    \n    vec4 w0 = vec4(sdBox(p+vec3(1,0,0),bs), mix(MAT_WHITE, MAT_GREEN, txGrid(p.yz, grds)));\n    vec4 w1 = vec4(sdBox(p+vec3(-1,0,0),bs), mix(MAT_WHITE, MAT_RED, txGrid(p.yz, grds)));\n    vec4 w2 = vec4(sdBox(p+vec3(0,1,0),bs.yxz), mix(MAT_WHITE, v?MAT_PURPLE:bw?MAT_BLACK:MAT_WHITE, txGrid(p.xz, grds)));\n    vec4 w3 = vec4(sdBox(p+vec3(0,0,-1),bs.zyx), MAT_WHITE);\n    vec4 w4 = vec4(sdBox(p+vec3(0,-1,0),bs.yxz), mix(MAT_WHITE, v?MAT_BLUE:bw?MAT_WHITE:MAT_BLACK, txGrid(p.xz, grds)));\n    res = v4OpUnion(w0,res);\n    res = v4OpUnion(w1,res);\n    res = v4OpUnion(w2,res);\n    res = v4OpUnion(w3,res);\n    res = v4OpUnion(w4,res);\n    \n    vec3 q = p;\n    q += vec3(.3,.75*.5-.15,-.5);\n    R(q.xz,PI*.125);\n    \n    vec4 o0 = vec4(sdBox(q,vec2(.3+abs(cos(q.y*40.))*.0,.75).xyx), MAT_WHITE);\n    vec4 o1 = vec4(length(p-vec3(.35,-.7+.07,-.2))-.35, MAT_YELLOW); //\n    vec4 o2 = vec4(length(p-vec3(sin(iTime*.5)*.8,.3+cos(iTime)*.3,-.3))-.15, MAT_WHITE);\n    res = v4OpUnion(o0,res);\n    res = v4OpUnion(o1,res);\n    res = v4OpUnion(o2,res);\n    \n\treturn res;\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = ZERO; i < ITERATION; i++){\n\t\tvec4 res = sdScene(ray.origin + d * ray.direction);\n\t\tm = res.yzw;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p){\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 n){\n    o+=n*.01;\n\tfloat t=.01;\n\tfor( int i=ZERO; i < 70; i++){\n\t\tfloat res = sdScene(o + lit0.direction*t).x;\n\t\tt += res;\n\t\tif(res<0.01)return 0.;\n        if(t>15.) break;\n\t}\n\treturn 1.;\n}\n\nfloat shadowLow(vec3 o, vec3 n){\n    o+=n*.01;\n\tfloat t=.01;\n\tfor( int i=ZERO; i < 40; i++){\n\t\tfloat res = sdScene(o + lit0.direction*t).x;\n\t\tt += res;\n\t\tif(res<0.01)return 0.;\n        if(t>10.) break;\n\t}\n\treturn 1.;\n}\n\nfloat aoSeed = 0.;\n\nvec2 c = vec2(0);\nvec3 amb = vec3(0);\nvec4 fakeGI(vec3 p, vec3 n, float radius) {\n  float ao = 0.;\n  float tbnc = 0.;\n  vec3 bleed = vec3(0);\n  bleed = renDat.albedo;\n  float mskDirect=0., litIndirect=1., roughness = 1.;\n  for(float i = 0.; i <= MAX_SAMP; i++) {\n    vec2 rnd = hash21(i + aoSeed++ + length(c));\n    \n    float scale = (i + 1.) / (MAX_SAMP+1.);\n    scale = mix(0., 1., pow(scale, .5));\n\n    rnd.x = (rnd.x * 2. - 1.) * PI*.05*roughness;\n    rnd.y = (rnd.y * 2. - 1.) * PI*roughness;\n    vec2 rnd1 = hash21(i + aoSeed++ + length(c))*roughness;\n    vec2 rnd2 = hash21(i + aoSeed++ + length(c))*roughness;\n    vec3 rd = normalize(n + vec3(rnd1.xy, rnd2.x));\n    rd.xz *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n    rd.xy *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n    rd *= sign(dot(rd, n));\n    //sign(-dot(n, r.d))\n    rd = normalize(n + rd);\n    \n    float raylen = radius * scale;\n    vec3 rndp = p + rd * raylen;\n    vec4 res = sdScene(rndp);\n    vec3 vp = p+rd*res.x;\n    \n    // ao\n    float rndao = distance(p,vp) / raylen;\n    ao += rndao;\n    \n    vec3 vn = n;\n    // color bleeding and bounce light\n    vec3 tot = res.yzw;\n    vec3 mask = vec3(1);\n    for(float j=float(ZERO);j<BOUNCE;j++){\n        \n        vec2 rnd3 = hash21(j + aoSeed++ + length(c));\n        //float scale = (i+j + 1.) / (MAX_SAMP+1.);\n        //scale = mix(MIN_DIST, 1., pow(scale, 1.));\n\n        rnd3.x = (rnd3.x * 2. - 1.) * PI*.025*roughness;\n        rnd3.y = (rnd3.y * 2. - 1.) * PI*roughness;\n        vec2 rnd4 = hash21(i+j + aoSeed++ + length(c))*roughness;\n        vec2 rnd5 = hash21(i+j + aoSeed++ + length(c))*roughness;\n        vec3 rd = normalize(vn + vec3(rnd4.xy, rnd5.x));\n        rd.xz *= mat2(cos(rnd3.x), sin(rnd3.x), -sin(rnd3.x), cos(rnd3.x));\n        rd.xy *= mat2(cos(rnd3.y), sin(rnd3.y), -sin(rnd3.y), cos(rnd3.y));\n        rd *= sign(dot(rd, vn));\n        rd = normalize(vn + rd);\n        \n        vp = vp+rd*res.x;\n        res = sdScene(vp);\n        vn = normal(vp);\n        float direct = sat(dot(vn, lit0.direction));\n        float shadow = shadowLow(vp, vn);\n        float mskDirect = direct*shadow;\n        \n        if(res.x>radius){tot+=AMB_STRENGTH*AMB_COL+mskDirect*lit0.color*LIGHT_STRENGTH*mask;break;}\n        tot+=res.yzw*mskDirect*lit0.color*LIGHT_STRENGTH*mask;\n        mask*=res.yzw;\n        // https://www.shadertoy.com/view/4sfGDB\n        // acc += mask * obj.e * E + mask * obj.c * e;\n\t\t// mask *= obj.c;\n        \n    }\n    bleed += tot/(BOUNCE+1.);\n  }\n    \n  //return vec4(bleed/(MAX_SAMP+1.), ao / float((MAX_SAMP+1.)));\n  return vec4(bleed/(MAX_SAMP+1.), ao / float((MAX_SAMP+1.)));\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n    #ifdef PIXEL_NOISE\n    aoSeed=fract(iTime)+10.;\n    \n    #endif\n    if (res.x>=MAX_DIST){\n        amb = mix(AMB_COL, AMB_COL2, smoothstep(-.75, .75, ray.direction.y));\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = amb;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = amb;\n\t}\n\telse{\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n        \n        renDat.diffuse = sat(dot(renDat.normal, lit0.direction));\n\t\trenDat.shadow = shadow(p, renDat.normal);\n        \n        vec4 ind0 = fakeGI(p, renDat.normal, 2.);\n        renDat.ao = ind0.w;\n        renDat.bleed = ind0.rgb;\n        renDat.result = vec3(0);\n\t\t//renDat.result = mix(vec3(0), lit0.color*LIGHT_STRENGTH, renDat.diffuse*renDat.shadow);\n        \n        amb = mix(AMB_COL, AMB_COL2, smoothstep(-.75, .75, renDat.normal.y));\n\t\t\n\t\t\n        renDat.result = max(mix(vec3(0), lit0.color*LIGHT_STRENGTH, renDat.diffuse*renDat.shadow), renDat.bleed);\n        //renDat.result = renDat.bleed;\n        //renDat.result += mix(vec3(0), amb, AMB_STRENGTH*renDat.ao);\n        renDat.result *= renDat.albedo;\n\t}\n}\n\nvoid light(){\n\tlit0.direction = normalize(vec3(0, .75, -1.5));\n    \n    R(lit0.direction.xz, cos(iTime*.25)*PI*.25);\n\t\n    lit0.color = vec3(1.000,0.957,0.722);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n}\n\nvoid camera(vec2 uv)\n{\n    const float cL = 8.;\n    const vec3 forcus = vec3(0,0,0);\n    const float fov = .25;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,0,-8);\n    if(iMouse.z>.5){\n        pos.x += sin((iMouse.x/iResolution.x-.5)*TAU)*cL;\n        pos.y += sin((iMouse.y/iResolution.y-.5)*TAU)*cL;\n    }\n    \n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    ray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ray.origin = pos;\n}\n\n//https://www.shadertoy.com/view/XlKSDR\nvec3 ACESFilm(vec3 x) {\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n#ifdef AA\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#endif\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    //uv += offset; //\n#ifdef PIXEL_NOISE\n    c = fragCoord*20.;\n#endif\n\n#ifdef DEBUG_VIEW\n    uv*=3.;\n    vec2 iuv = floor(uv);\n    uv.x=mod(uv.x,1.);\n    uv*=.333;\n    uv.x+=.4;\n#endif\n\n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n\tlight();\n\tcamera(uv);\n\trender();\n    fragColor = vec4(renDat.result, 1.);\n    \n#ifdef DEBUG_VIEW\n    if(iuv.x==0.)d3V(pow(renDat.albedo*renDat.diffuse*renDat.shadow, vec3(2.2))); //L: Direct\n    if(iuv.x==1.)d3V(renDat.bleed);                                               //C: Bleeded color\n    if(iuv.x==2.)d3V(pow(renDat.result, vec3(2.2)));                              //R: Direct + Bleeded \n#endif\n    fragColor.rgb = ACESFilm(fragColor.rgb);\n    fragColor.rgb = pow(fragColor.rgb, vec3(.4545));\n    drawDebug(fragColor);\n}\n\n#ifdef AA\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n  mainImage0(O, U);\n  if(fwidth(length(O)) > .01) {  // difference threshold between neighbor pixels\n    vec4 o;\n    for(int k = 0; k < 9; k += k == 3 ? 2 : 1) {\n      mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.);\n      O += o;\n    }\n    O /= 9.;\n    // O.r++;                        // uncomment to see where the oversampling occurs\n  }\n}\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 dbC=vec4(0);\nvoid d1F(float v){dbC=vec4(v,v,v,1);}\nvoid d2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid d3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(sat(dbC),vec4(.4545));}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec2 hash21(float p) {\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}