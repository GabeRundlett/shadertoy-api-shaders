{
    "Shader": {
        "info": {
            "date": "1513120591",
            "description": "Just an exercise from texture and modeling.  ",
            "flags": 0,
            "hasliked": 0,
            "id": "4tfBz2",
            "likes": 13,
            "name": "A Lonely Palm",
            "published": 3,
            "tags": [
                "3d",
                "island",
                "palm"
            ],
            "usePreview": 1,
            "username": "revers",
            "viewed": 710
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Kamil Kolaczynski (revers) - 2017\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * \n * Just an exercise from texture and modeling. As always, most of general raymarching\n * ingredients (raymarch loop, geometric primitives, lighting/shadowing, noise)\n * is based on iq's shaders and articles. Thanks for sharing your knowledge, iq!\n *\n * Referenced shaders:\n * - \"Raymarching - Primitives\" by iq [ https://www.shadertoy.com/view/Xds3zN ]\n * - \"Noise - value - 2D\" by iq [ https://www.shadertoy.com/view/lsf3WH ]\n *\n * Referenced articles:\n * - \"modeling with distance functions\" by iq [ https://iquilezles.org/articles/distfunctions ]\n * - \"free penumbra shadows for raymarching distance fields\" by iq [ https://iquilezles.org/articles/rmshadows ]\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\nconst vec3 LightDir = vec3(0.057800323, -0.5716256, -0.81847644);\nconst float MarchDumping = 0.9;\nconst float Far = 32.0;\nconst int MaxSteps = 156;\nconst float PalmCocoRadius = 0.206;\nconst float PalmLeafLength = 1.4476738;\nconst vec2 PalmLeafHash = vec2(0.494, 0.485);\nconst float PalmParaAmp = 2.005;\nconst float PalmParaShiftX = -0.32558393;\nconst float PalmParaShiftY = -0.34907204;\nconst float PalmSawAngle = 1.270597;\nconst float PalmSawFreq = 0.15;\nconst float PalmSawShift = 3.355552;\nconst mat3 PalmLeavesRot = mat3(0.43584922, 0.08419673, -0.8960726, -0.50385904, 0.8477993, -0.16541581, 0.7457622, 0.52359074, 0.41193599);\nconst float PalmTrunkSkew = 0.008;\nconst float PalmTrunkLength = 5.0;\nconst float TrunkPower = 1.7391294;\nconst float TrunkPowerFactor = 0.009565654;\nconst vec3 CoconutColor = vec3(0.3529412, 0.16862746, 0.05882353);\n\n#define M_NONE     -1.0\n#define M_SAND      1.0\n#define M_TRUNK     2.0\n#define M_LEAF      3.0\n#define M_COCONUTS  4.0\n#define M_WATER     5.0\n\n#define PI      3.141592\n#define TWO_PI  6.2831852\n\n#define INF     1e7\n\n#define POINTS 8\n\nvec2 LeafAngles[POINTS];\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n//\treturn mix(a, b, step(b.x, a.x));\n}\n\nvec3 min3(vec3 a, vec3 b) {\n\treturn a.x < b.x ? a : b;\n//\treturn mix(a, b, step(b.x, a.x));\n}\n\n/**\n * Hash function by David Hoskins.\n * https://www.shadertoy.com/view/4djSRW\n */\nvec2 hash21(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n\tp2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\n/**\n * hash by iq.\n */\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\n/**\n * hash by iq.\n */\nfloat hash(vec2 n) {\n\treturn fract(sin(dot(n, vec2(1.0, 113.0))) * 43758.5453123);\n}\n\n/**\n * Procedural Value Noise 2D, by iq.\n * https://www.shadertoy.com/view/lsf3WH\n */\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\tvec2 a = vec2(0.0, 0.0);\n\tvec2 b = vec2(1.0, 0.0);\n\tvec2 c = vec2(0.0, 1.0);\n\tvec2 d = vec2(1.0, 1.0);\n\n\tfloat n0 = hash(i + a);\n\tfloat n1 = hash(i + b);\n\tfloat n2 = hash(i + c);\n\tfloat n3 = hash(i + d);\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\n\treturn mix(ix0, ix1, u.y);\n}\n\nvec3 rotateX(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(p.x, ca * p.y + sa * p.z, ca * p.z - sa * p.y);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca * p.x + sa * p.z, p.y, ca * p.z - sa * p.x);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca * p.x + sa * p.y, ca * p.y - sa * p.x, p.z);\n}\n\nvec2 rotate(vec2 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec2(ca * p.x - sa * p.y, sa * p.x + ca * p.y);\n}\n\n/**\n * https://iquilezles.org/articles/distfunctions\n */\nfloat sdEllipsoid(vec3 p, vec3 r) {\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat leafParabola(float x) {\n\tx = clamp(x * 0.35, 0.0, 1.0);\n\tx -= PalmParaShiftX;\n\n\treturn -PalmParaAmp * x * (x - 1.0) + PalmParaShiftY;\n}\n\nfloat leafSawtooth(vec3 p) {\n\tp.z = -abs(p.z);\n\tvec2 nor = vec2(cos(PalmSawAngle), sin(PalmSawAngle));\n\n\tp.z += PalmSawShift;\n\n\tp.y = mod(p.y, PalmSawFreq) - PalmSawFreq * 0.5;\n\n\tfloat d = nor.x * p.z + nor.y * p.y - 1.0;\n\td = max(d, -p.y);\n\n\treturn d;\n}\n\nfloat sdLeaf(vec3 p) {\n\tvec3 q = p;\n\tp.z = abs(p.z);\n\tp.xz = rotate(p.xz, PI - PI * 0.35);\n\n\tp.z += leafParabola(p.y);\n\tp.y -= PalmLeafLength + 0.05;\n\n\tfloat d = sdEllipsoid(p, vec3(0.25, PalmLeafLength, 0.04));\n\treturn max(d, -leafSawtooth(q));\n}\n\nvoid initLeafAngles() {\n\tfor (int i = 0; i < POINTS; i++) {\n\t\tvec2 rnd = hash21(float(i) * PalmLeafHash.x + PalmLeafHash.y);\n\n\t\tfloat a = float(i) / float(POINTS) * TWO_PI + (rnd.x * 2.0 - 1.0) * 0.2;\n\t\tLeafAngles[i] = vec2(a, -(rnd.y * PI * 0.25 + 1.25));\n\t}\n}\n\nvec3 sdLeaves(vec3 p) {\n\tp *= PalmLeavesRot;\n\tfloat d = INF;\n\tfloat index = 0.0;\n\n\tconst float len = 0.5;\n\tp.y -= len;\n\n\tfor (int i = 0; i < POINTS; i++) {\n\n\t\tvec3 q = p + vec3(0.0, len, 0.0);\n\n\t\tvec2 ang = LeafAngles[i];\n\t\tq = rotateY(q, ang.x);\n\t\tq = rotateZ(q, ang.y);\n\n\t\tfloat d2 = sdLeaf(q);\n\n\t\t// same as:\n\t\t// if (d2 < d) { index = float(i); }\n\t\tindex = mix(index, float(i), step(d2, d));\n\t\td = min(d, d2);\n\t}\n\treturn vec3(d, M_LEAF, index);\n}\n\nvec2 sdTrunk(vec3 p) {\n\tvec3 q = p;\n\tp.x -= 1.0;\n\tp.y += PalmTrunkLength - 0.15;\n\n\tfloat a = 0.05;\n\tfloat x = p.y;\n\n\tp.xy = rotate(p.xy, -x * x * PalmTrunkSkew);\n\n\tfloat f = clamp(p.y / PalmTrunkLength, 0.0, 1.0);\n\n\t// cylinder with distortions\n\tfloat d = length(p.xz) - 0.18 + pow(f, TrunkPower) * TrunkPowerFactor * 10.0;\n\n\td = max(d, -p.y); // trim bottom\n\td = max(d, (p.y - PalmTrunkLength)); // trim top\n\n\treturn vec2(d, M_TRUNK);\n}\n\nvec2 sdCoconuts(vec3 p) {\n\tp *= PalmLeavesRot;\n\tp.y *= 0.9;\n\tp += vec3(0.1, 0.15, 0.0);\n\tfloat d = dot(p, p);\n\n\tp += vec3(-0.3, 0.0, 0.2);\n\td = min(d, dot(p, p));\n\n\tp += vec3(0.0, 0.0, -0.4);\n\td = min(d, dot(p, p));\n\n\td = sqrt(d) - PalmCocoRadius;\n\treturn vec2(d, M_COCONUTS);\n}\n\nvec2 sdPalmTree(vec3 p) {\n\tvec3 q = p;\n\tq.y -= PalmTrunkLength;\n\tvec2 res = sdLeaves(q).xy;\n\n\tres = min2(res, sdTrunk(q));\n\tres = min2(res, sdCoconuts(q));\n\n\treturn res;\n}\n\nvec2 sdIsland(vec3 p) {\n\tp.x = p.x * 0.8 + p.z * 0.2;\n\n\tp.y -= 0.1 * sin(p.x * 2.0) + 0.6 * cos(p.z * 0.5 - 1.6);\n\n\tp += vec3(-0.7, 3.0, 0.7);\n\n\tfloat d = length(p) - 4.0;\n\n\treturn vec2(d, M_SAND);\n}\n\nvec2 sdWater(vec3 p) {\n\tfloat d = p.y - 0.5 * noise(p.xz + iTime) * 0.3;\n\treturn vec2(d, M_WATER);\n}\n\nvec2 smin(vec2 a, vec2 b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b.x - a.x) / k, 0.0, 1.0);\n\treturn vec2(mix(b.x, a.x, h) - k * h * (1.0 - h), mix(b.y, a.y, h));\n}\n\nvec3 map(vec3 p) {\n\tvec3 q = p;\n\tq.y -= PalmTrunkLength;\n\tvec2 res = sdTrunk(q);\n\n\tres = min2(res, sdCoconuts(q));\n\n\tres = smin(res, sdIsland(p), 0.3);\n\tres = min2(res, sdWater(p));\n\n    return min3(sdLeaves(q), vec3(res, 0.0));\n}\n\nvec3 castRay(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = M_NONE;\n\tfloat s = 0.0;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec3 res = map(ro + rd * t);\n\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t\ts = res.z;\n\t}\n\tif (t > tmax) {\n\t\tm = M_NONE;\n\t}\n\treturn vec3(t, m, s);\n}\n\n/**\n * https://iquilezles.org/articles/rmshadows\n */\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n\tfloat res = 1.0;\n\tfor (float t = mint; t < maxt;) {\n\n\t\tfloat h = map(ro + rd * t).x;\n\n\t\tif (h < 0.001) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tres = min(res, k * h / t);\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(\n\t\t\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat luma(vec3 col) {\n\t// BT.709\n\treturn dot(col, vec3(0.2126, 0.7152, 0.0722));\n}\n\n/**\n *  Three plannar texture mapping by iq.\n */\nvec3 texcube(sampler2D sa, vec3 p, vec3 n) {\n\tvec3 x = texture(sa, p.yz).xyz;\n\tvec3 y = texture(sa, p.zx).xyz;\n\tvec3 z = texture(sa, p.xy).xyz;\n\n\treturn x * abs(n.x) + y * abs(n.y) + z * abs(n.z);\n}\n\nvec3 bumpMap(sampler2D tex, vec3 pos, vec3 nor, float amount) {\n\tfloat e = 0.001;\n\n\tfloat ref = luma(texcube(tex, pos, nor));\n\n\tvec3 gra = -vec3(luma(texcube(tex, vec3(pos.x + e, pos.y, pos.z), nor)) - ref,\n\t\t\t\t\t luma(texcube(tex, vec3(pos.x, pos.y + e, pos.z), nor)) - ref,\n\t\t\t\t\t luma(texcube(tex, vec3(pos.x, pos.y, pos.z + e), nor)) - ref) / e;\n\n\tvec3 tgrad = gra - nor * dot(nor, gra);\n\treturn normalize(nor - amount * tgrad);\n}\n\nvec3 trunkColor(vec3 pos);\n\nvec3 trunkBumpMap(vec3 pos, vec3 nor, float amount) {\n\tfloat e = 0.001;\n\n\tfloat ref = luma(trunkColor(pos));\n\n\tvec3 gra = -vec3(luma(trunkColor(vec3(pos.x + e, pos.y, pos.z))) - ref,\n\t\t\t\t\t luma(trunkColor(vec3(pos.x, pos.y + e, pos.z))) - ref,\n\t\t\t\t\t luma(trunkColor(vec3(pos.x, pos.y, pos.z + e))) - ref) / e;\n\n\tvec3 tgrad = gra - nor * dot(nor, gra);\n\treturn normalize(nor - amount * tgrad);\n}\n\nvec3 trunkColor(vec3 pos) {\n\tpos.y *= 1.2;\n\tvec3 brown = vec3(0.48, 0.29, 0.070) * 0.7;\n\n\tfloat ang = atan(pos.z, pos.x) * 14.0 + pos.y * 12.0;\n\tfloat y = pos.y + cos(ang) * 0.02;\n\n\tfloat x = cos(y * 14.0);\n\tx *= x;\n\tx *= x;\n\n\treturn mix(brown, brown * 0.6, x);\n}\n\nvec3 leafColor(vec3 pos, float index) {\n\n\t{ // Move leaf to its untransformed coordinates.\n\t\tvec2 ang = LeafAngles[int(index)];\n\n\t\tpos.y -= PalmTrunkLength;\n\t\tpos *= PalmLeavesRot;\n\n\t\tpos = rotateY(pos, ang.x);\n\t\tpos = rotateZ(pos, ang.y);\n\t}\n\tvec3 col = vec3(0.13, 0.46, 0.07);\n\n\tfloat x = pos.y * 1.9 - abs(pos.z) * 0.2;\n\tx = x + hash(x * 0.0005) * 0.12;\n\n\tfloat t = sin(x * 10.0);\n\tt *= t;\n\n\treturn mix(col, col * 0.6, t);\n}\n\nvec3 coconutColor(vec3 pos, vec3 nor) {\n\tpos *= PalmLeavesRot;\n\tvec3 col = CoconutColor * (0.2 + 0.8 * texcube(iChannel1, pos * vec3(1.0, 0.2, 0.5), nor));\n\n\treturn col;\n}\n\nfloat clouds(vec3 rd) {\n\tvec2 uv = rd.xz / (rd.y + 0.2);\n\tuv *= 70.0;\n\n\tuv *= vec2(3.0, 3.0) * 0.005;\n\tvec2 st = uv;\n\n\tfloat t = iTime * 0.3;\n\tuv.x += t * 0.2;\n\n\tfloat f = 0.5 * noise(uv);\n\tuv *= 2.04;\n\tf += 0.25 * noise(uv);\n\tuv *= 2.01;\n\tf += 0.125 * noise(uv);\n\tfloat res = f;\n\tres = smoothstep(0.4, 1.0, res);\n\n\tst += vec2(12.0, 34.5);\n\tst.x += t * 0.3;\n\tfloat g = 0.5 * noise(st);\n\tst *= 2.00;\n\tg += 0.25 * noise(st);\n\tst *= 2.03;\n\tg += 0.125 * noise(st);\n\tst *= 2.04;\n\tg += 0.0625 * noise(st);\n\n\tres += 0.5 * smoothstep(0.5, 0.9, g);\n\n\treturn res * 0.8;\n}\n\nvec3 background(vec3 rd, float sun) {\n\tfloat t = abs(rd.y + 0.4) * 0.9;\n\tt = min(t, 0.8);\n\n\t// sky\n\tvec3 col = mix(vec3(0.9132, 1.002, 1.2), vec3(0.0, 0.3, 1.2), t) * 1.2;\n\n\t// sun\n\tcol = mix(col, vec3(1.0, 1.0, 0.549) * 1.2, pow(sun, 512.0));\n\n\t// clouds\n\tfloat clo = clouds(rd);\n\tcol = mix(col, vec3(1.0), clo);\n\n\treturn min(col, 1.0);\n}\n\n#define _dist(v)  ((v).x)  /* distance */\n#define _mate(v)  ((v).y)  /* material */\n#define _styl(v)  ((v).z)  /* style    */\n\nvec3 render(vec3 ro, vec3 rd) {\n\tinitLeafAngles();\n\n\tvec3 lig = normalize(-LightDir);\n\tfloat sun = clamp(dot(lig, rd), 0.0, 1.0);\n\n\tvec3 bg = background(rd, sun);\n\tvec3 col = bg;\n\n\tvec3 res = castRay(ro, rd);\n\n\tif (_mate(res) > M_NONE) {\n\t\tvec3 pos = ro + _dist(res) * rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\tbool isWater = false;\n\t\tfloat spe = 0.0;\n\n\t\tif (_mate(res) == M_WATER) {\n\t\t\tisWater = true;\n\n\t\t\tvec3 rrd = reflect(rd, nor);   // reflected ray direction\n\t\t\tvec3 rro = pos + rrd * 0.01;   // reflected ray origin\n\t\t\tvec3 rres = castRay(rro, rrd); // reflected result\n\n\t\t\tif (_mate(rres) == M_NONE || _mate(rres) == M_WATER) {\n\t\t\t\tcol = background(rrd, sun);\n\t\t\t} else {\n\t\t\t\tro = rro;\n\t\t\t\trd = rrd;\n\t\t\t\tres = rres;\n\t\t\t\tpos = ro + _dist(res) * rd;\n\t\t\t\tnor = calcNormal(pos);\n\t\t\t}\n\t\t}\n\t\tif (_mate(res) <= M_SAND + 0.3) {\n\n\t\t\tvec3 p = pos * 0.3 * 0.9;\n\t\t\tcol = vec3(1.0, 0.827, 0.129) * (1.0 - 0.15 * texcube(iChannel0, p, nor));\n\n\t\t\tnor = bumpMap(iChannel0, p, nor, 0.0008);\n\t\t\tvec3 ref = reflect(rd, nor);\n\t\t\tspe = pow(clamp(dot(ref, lig), 0.0, 1.0), 4.0);\n\n\t\t} else if (_mate(res) <= M_TRUNK) {\n\n\t\t\tcol = trunkColor(pos);\n\t\t\tnor = trunkBumpMap(pos, nor, 0.35);\n\n\t\t} else if (_mate(res) <= M_LEAF) {\n\n\t\t\tcol = leafColor(pos, _styl(res));\n\t\t\tvec3 ref = reflect(rd, nor);\n\t\t\tspe = pow(clamp(dot(ref, lig), 0.0, 1.0), 2.0);\n\n\t\t} else if (_mate(res) <= M_COCONUTS) {\n\n\t\t\tcol = coconutColor(pos, nor);\n\t\t}\n\n\t\t// lighting\n\t\tfloat occ = calcAO(pos, nor);\n\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n\t\tdif *= softshadow(pos, lig, 0.02, PalmTrunkLength * 2.0, 240.0);\n\n\t\tvec3 brdf = vec3(0.0);\n\n\t\tbrdf += 1.00 * dif * vec3(1.00, 0.90, 0.60);\n\t\tbrdf += 0.40 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\t\tbrdf += 0.50 * amb * vec3(0.50, 0.70, 1.00) * occ;\n\t\tbrdf += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n\t\tcol = col * brdf;\n\n\t\tif (isWater) {\n\t\t\tcol = mix(vec3(0.0, 0.345, 0.612), col, 0.5);\n            //col = mix(vec3(0.157, 0.718, 0.922), col, 0.5);\n\t\t\tfloat t = _dist(res);\n\t\t\tcol = mix(col, bg, 1.0 - exp(-0.00007 * t * t * t));\n\t\t}\n\t}\n\tcol += 0.15 * vec3(1.0, 0.898, 0.0) * pow(sun, 32.0);\n\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nvoid getCamera(vec2 pix, out vec3 ro, out vec3 rd) {\n\tconst float fov = 0.64;\n\n\tvec2 coord = (-iResolution.xy + 2.0 * pix) / iResolution.y;\n\tcoord *= fov;\n\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tfloat t = iTime * 0.2 + mo.x * 4.0;\n\n\tvec3 target = vec3(0.0, 3.0, 0.0);\n\tro = vec3(0.0, 2.0, 8.0);\n\n\tfloat s = -0.1 + clamp(mo.y, 0.0, 1.0);\n\tro = rotateX(ro, s);\n\tro = rotateY(ro, t);\n\n\tvec3 dir = normalize(target - ro);\n\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tup = rotateX(up, s);\n\tup = rotateY(up, t);\n\n\tup = normalize(up);\n\n\tvec3 right = normalize(cross(dir, up));\n\n\trd = normalize(dir + coord.x * right + coord.y * up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro, rd;\n\tgetCamera(fragCoord, ro, rd);\n\n\tvec3 col = render(ro, rd);\n\n\tcol = pow(col, vec3(0.4545));\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}