{
    "Shader": {
        "info": {
            "date": "1541506430",
            "description": "mouse.xz sets domain of constant height\ni didnt like the contextualization of the most common smoothBump() = smoothstep()*smoothstep()\nhull, and how its not too intuitive\nand it became a sawcos() generalization",
            "flags": 0,
            "hasliked": 0,
            "id": "XtdfWl",
            "likes": 3,
            "name": "smoothBump 2",
            "published": 3,
            "tags": [
                "smoothstep",
                "smoothstep",
                "tween",
                "ease",
                "sawcos",
                "bumb"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 502
        },
        "renderpass": [
            {
                "code": "\n#define vec1 float\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define ViewZoom 4.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa(r) (min(r.x,r.y)/ViewZoom)\n#define fra(t,u,r,m)(u-.5*r.xy)*ViewZoom/r.y\n\n//https://www.shadertoy.com/view/4l2BRD\n//x sets start point of 50% \n//y sets easin and easeout time (from 0 to 1 and from 1 to 0)\n//z sets end   point of 50%\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n//i am not a fan of the smootzhbump above, it is not parallel, it is boun badly\n//it sure has its use cases, but for me it needs a context with more utility\n//by being vound to domain[0..1] and range[0..1]\nfloat smoothbump2(vec2 u,vec4 m//https://www.shadertoy.com/view/XtdfWl\n){//u/=4.//based on smothbump(), it ended as generalization of a sawCos()-like\n ;//m/=4.\n ;//domain [ 0. <= m.x < m.z < 1. ] is well defined \n ;//the m.z==1 case is shit, open intervals are harer to catch\n ;//the m.x==1 case is shit, open intervals are harer to catch\n ;if(abs(u.x-.5)>.5)return u.y/32.//optional outOfBounds shortcut\n ;//vec2 c=vec2(0)\n ;m.xz=sat(m.xz)\n ;m.xz=vec2(min(m.x,m.z),max(m.x,m.z))//sorting simplifies things? not here!\n //;m.xz=fract(m.xz)\n ;//if(m.x>m.z)m.xz=vec2(m.x+m.z)/2.//compromise sorting\n ;// i really dislike this open interval asymptote evading epsilon stuff, this is where math fails!\n ;if(m.z>.9999)m.z=.9999 //enforce bounds or else this else{} part is needed, and its not well done!\n ;if(m.x>.9999)m.x=.9999 //enforce bounds or else this else{} part is needed, and its not well done!\n ;if(m.x<.0001)m.x=.0001 //enforce bounds or else this else{} part is needed, and its not well done!\n ;m.z=max(m.x,m.z)//m.x dominates //faster and makes sense for decaying things\n ;//if(m.z<1.&&m.x>0.){\n     m.xy=vec2(u.x/m.x,(u.x-1.)/(-1.+m.z))//catch non-asymptotic case.\n //;}//else m.xy=vec2(mix(u.x,0.,step(1.,u.x)),1.)//asymptotic special case is not good for outOfBounds\n #if 1\n ;m.xy=smoothstep(vec2(0),vec2(1),m.xy)//2 smoothsteps in 1\n #else\n ;m.xy=sat(m.xy) //optionally to the above, just to linearEaseTween\n #endif     \n ;m.xy=-m.xy \n ;return max(m.x,m.y);}\n\n\nvec4 demoSmoothBump(vec2 u,vec4 m){\n ;vec4 c=vec4( smoothbump2(vec2(u.x   ,u.y),m   )+u.y)\n ;  // c=vec4((smoothbump2(vec2(u.x/2.,u.y),m/2.)+u.y)*2.)//scaling example\n ;c.x=smoothstep(.1,-.1,c.x)\n ;c.y=smoothstep(.1,-.1,c.y)\n ;c.z=smoothstep(.1,-.1,c.z)\n ;c.w=smoothstep(.1,-.1,c.w)\n ;c.xy+=c.w\n ;c.w=1.\n ;return c;\n ;//return vec4(smoothBump(0.,m.x-m.z*.5,m.z,u.x)-u.y)//meh this is rather dumb\n ;//return vec4(smoothBump(0.,m.x,m.z,u.x)-u.y)\n ;}\n\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec4 c=vec4(0)\n ;//t=0.//override time for vis\n ;float t=iTime\n ;vec3 r=iResolution.xyz\n ;vec4 m=iMouse.xyzw\n ;u   =fra(t,u   ,r,m)\n ;if(m.z>0.){\n  ;m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else{//iMouse is cos(hash41Aperiodic())\n   ;m=sqrt(vec4(5,2,3,1))-vec4(21,17,13,11) //QuadraticField: see: https://www.shadertoy.com/view/Xt3BDB\n   ;m=sin(m*t*.1)//time as seed for hash m.\n   ;m=(m/ViewZoom+1./ViewZoom)*1.5\n       \n   ;//m.xyzw=m.xyzw*.5+.5//mirror symmetry on y=0\n   ;//m.yw=m.yw*.3+.3//minimum key width\n   ;m*=ViewZoom*.4//view scale\n ;}\n ;c=demoSmoothBump(u,m)\n ;c.x=length(u-m.xy)-.1\n ;c.y=length(u-m.zw)-.1\n      ;c.x=smoothstep(.1,-.1,c.x)\n ;c.y=smoothstep(.1,-.1,c.y)\n ;o=c\n  ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}