{
    "Shader": {
        "info": {
            "date": "1444125093",
            "description": "Study in volumetrics & raymarching. Use mouse to look around.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtBXDw",
            "likes": 140,
            "name": "Horizon Clouds",
            "published": 3,
            "tags": [
                "raymarch",
                "clouds",
                "sky",
                "volumetric"
            ],
            "usePreview": 1,
            "username": "valentingalea",
            "viewed": 16968
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY\n\n/**** TWEAK *****************************************************************/\n#define COVERAGE\t\t.50\n#define THICKNESS\t\t15.\n#define ABSORPTION\t\t1.030725\n#define WIND\t\t\tvec3(0, 0, -u_time * .2)\n\n#define FBM_FREQ\t\t2.76434\n#define NOISE_VALUE\n//#define NOISE_WORLEY\n//#define NOISE_PERLIN\n\n//#define SIMULATE_LIGHT\n#define FAKE_LIGHT\n#define SUN_DIR\t\t\tnormalize(vec3(0, abs(sin(u_time * .3)), -1))\n\n#define STEPS\t\t\t25\n/******************************************************************************/\n\n#ifdef __cplusplus\n#define _in(T) const T &\n#define _inout(T) T &\n#define _out(T) T &\n#define _begin(type) type {\n#define _end }\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\n#endif\n\n#if defined(GL_ES) || defined(GL_SHADING_LANGUAGE_VERSION)\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\n#endif\n\n#ifdef HLSL\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) {\n#define _end }\n#define _mutable(T) static T\n#define _constant(T) static const T\n#define vec2 float2\n#define vec3 float3\n#define vec4 float4\n#define mat2 float2x2\n#define mat3 float3x3\n#define mat4 float4x4\n#define mix lerp\n#define fract frac\n#define atan(y, x) atan2(x, y)\n#define mod fmod\n#pragma pack_matrix(row_major)\ncbuffer uniforms : register(b0) {\n\tfloat2 u_res;\n\tfloat u_time;\n\tfloat2 u_mouse;\n};\nvoid mainImage(_out(float4) fragColor, _in(float2) fragCoord);\nfloat4 main(float4 uv : SV_Position) : SV_Target{ float4 col; mainImage(col, uv.xy); return col; }\n#endif\n\n#if defined(__cplusplus) || defined(SHADERTOY)\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n#endif\n\n#ifdef GLSLSANDBOX\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define u_res resolution\n#define u_time time\n#define u_mouse mouse\nvoid mainImage(_out(vec4) fragColor, _in(vec2) fragCoord);\nvoid main() { mainImage(gl_FragColor, gl_FragCoord.xy); }\n#endif\n\n#define PI 3.14159265359\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nstruct hit_t {\n\tfloat t;\n\tint material_id;\n\tvec3 normal;\n\tvec3 origin;\n};\n#define max_dist 1e8\n_constant(hit_t) no_hit = _begin(hit_t)\n\tfloat(max_dist + 1e1), // 'infinite' distance\n\t-1, // material id\n\tvec3(0., 0., 0.), // normal\n\tvec3(0., 0., 0.) // origin\n_end;\n\n// ----------------------------------------------------------------------------\n// Various 3D utilities functions\n// ----------------------------------------------------------------------------\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = _begin(ray_t)\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t\t_end;\n\treturn r;\n}\n\nmat2 rotate_2d(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat2(_cos, -_sin, _sin, _cos);\n}\n\nmat3 rotate_around_z(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\nmat3 rotate_around_y(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nmat3 rotate_around_x(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\nvec3 corect_gamma(\n\t_in(vec3) color,\n\t_in(float) gamma\n){\n\tfloat p = 1.0 / gamma;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\n#ifdef __cplusplus\nvec3 faceforward(\n\t_in(vec3) N,\n\t_in(vec3) I,\n\t_in(vec3) Nref\n){\n\treturn dot(Nref, I) < 0 ? N : -N;\n}\n#endif\n\nfloat checkboard_pattern(\n\t_in(vec2) pos,\n\t_in(float) scale\n){\n\tvec2 pattern = floor(pos * scale);\n\treturn mod(pattern.x + pattern.y, 2.0);\n}\n\nfloat band (\n\t_in(float) start,\n\t_in(float) peak,\n\t_in(float) end,\n\t_in(float) t\n){\n\treturn\n\tsmoothstep (start, peak, t) *\n\t(1. - smoothstep (peak, end, t));\n}\n// ----------------------------------------------------------------------------\n// Analytical surface-ray intersection routines\n// ----------------------------------------------------------------------------\n\n// geometrical solution\n// info: http://www.scratchapixel.com/old/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\nvoid intersect_sphere(\n\t_in(ray_t) ray,\n\t_in(sphere_t) sphere,\n\t_inout(hit_t) hit\n){\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n//\tif (tca < 0.) return;\n\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2)\n\t\treturn;\n\n\tfloat thc = sqrt(radius2 - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\n\tif (t0 < 0.) t0 = t1;\n\tif (t0 > hit.t)\n\t\treturn;\n\n\tvec3 impact = ray.origin + ray.direction * t0;\n\n\thit.t = t0;\n\thit.material_id = sphere.material;\n\thit.origin = impact;\n\thit.normal = (impact - sphere.origin) / sphere.radius;\n}\n\n// Plane is defined by normal N and distance to origin P0 (which is on the plane itself)\n// a plane eq is: (P - P0) dot N = 0\n// which means that any line on the plane is perpendicular to the plane normal\n// a ray eq: P = O + t*D\n// substitution and solving for t gives:\n// t = ((P0 - O) dot N) / (N dot D)\nvoid intersect_plane(\n\t_in(ray_t) ray,\n\t_in(plane_t) p,\n\t_inout(hit_t) hit\n){\n\tfloat denom = dot(p.direction, ray.direction);\n\tif (denom < 1e-6) return;\n\n\tvec3 P0 = vec3(p.distance, p.distance, p.distance);\n\tfloat t = dot(P0 - ray.origin, p.direction) / denom;\n\tif (t < 0. || t > hit.t) return;\n\t\n\thit.t = t;\n\thit.material_id = p.material;\n\thit.origin = ray.origin + ray.direction * t;\n\thit.normal = faceforward(p.direction, ray.direction, p.direction);\n}\n\n// ----------------------------------------------------------------------------\n// Noise function by iq from https://www.shadertoy.com/view/4sfGzS\n// ----------------------------------------------------------------------------\n\nfloat hash(\n\t_in(float) n\n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nfloat noise_iq(\n\t_in(vec3) x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n\n#if 0\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n#else\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n#endif\n}\n// ----------------------------------------------------------------------------\n// Noise function by iq from https://www.shadertoy.com/view/ldl3Dl\n// ----------------------------------------------------------------------------\n\nvec3 hash_w(\n\t_in(vec3) x\n){\n#if 0\n\tvec3 xx = vec3(dot(x, vec3(127.1, 311.7, 74.7)),\n\t\tdot(x, vec3(269.5, 183.3, 246.1)),\n\t\tdot(x, vec3(113.5, 271.9, 124.6)));\n\n\treturn fract(sin(xx)*43758.5453123);\n#else\n\treturn texture(iChannel0, (x.xy + vec2(3.0, 1.0)*x.z + 0.5) / 256.0, -100.0).xyz;\n#endif\n}\n\n// returns closest, second closest, and cell id\nvec3 noise_w(\n\t_in(vec3) x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tfloat id = 0.0;\n\tvec2 res = vec2(100.0, 100.0);\n\tfor (int k = -1; k <= 1; k++)\n\t\tfor (int j = -1; j <= 1; j++)\n\t\t\tfor (int i = -1; i <= 1; i++)\n\t\t\t{\n\t\t\t\tvec3 b = vec3(float(i), float(j), float(k));\n\t\t\t\tvec3 r = vec3(b) - f + hash_w(p + b);\n\t\t\t\tfloat d = dot(r, r);\n\n\t\t\t\tif (d < res.x)\n\t\t\t\t{\n\t\t\t\t\tid = dot(p + b, vec3(1.0, 57.0, 113.0));\n\t\t\t\t\tres = vec2(d, res.x);\n\t\t\t\t}\n\t\t\t\telse if (d < res.y)\n\t\t\t\t{\n\t\t\t\t\tres.y = d;\n\t\t\t\t}\n\t\t\t}\n\n\treturn vec3(sqrt(res), abs(id));\n}\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1, 1, 1); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1, 1, 1); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(.5, .5, .5, .5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0, 0, 0, 0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(.5, .5, .5, .5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0, 0, 0, 0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1, 1, 1), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1, 1, 1); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(.5, .5, .5, .5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0, 0, 0, 0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(.5, .5, .5, .5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0, 0, 0, 0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n#ifdef NOISE_VALUE\n#define noise(x) noise_iq(x)\n#endif\n#ifdef NOISE_WORLEY\n#define noise(x) (1. - noise_w(x).r)\n//#define noise(x) abs( noise_iq(x / 8.) - (1. - (noise_w(x * 2.).r)))\n#endif\n#ifdef NOISE_PERLIN\n#define noise(x) abs(cnoise(x))\n#endif\n// ----------------------------------------------------------------------------\n// Fractal Brownian Motion\n// ----------------------------------------------------------------------------\n\nfloat fbm(\n\t_in(vec3) pos,\n\t_in(float) lacunarity\n){\n\tvec3 p = pos;\n\tfloat\n\tt  = 0.51749673 * noise(p); p *= lacunarity;\n\tt += 0.25584929 * noise(p); p *= lacunarity;\n\tt += 0.12527603 * noise(p); p *= lacunarity;\n\tt += 0.06255931 * noise(p);\n\t\n\treturn t;\n}\n\n#ifdef HLSL\nTexture3D u_tex_noise : register(t1);\nSamplerState u_sampler0 : register(s0);\n#endif\nfloat get_noise(_in(vec3) x)\n{\n#if 0\n\treturn u_tex_noise.Sample(u_sampler0, x);\n#else\n\treturn fbm(x, FBM_FREQ);\n#endif\n}\n\n_constant(vec3) sun_color = vec3(1., .7, .55);\n\n_constant(sphere_t) atmosphere = _begin(sphere_t)\n\tvec3(0, -450, 0), 500., 0\n_end;\n_constant(sphere_t) atmosphere_2 = _begin(sphere_t)\n\tatmosphere.origin, atmosphere.radius + 50., 0\n_end;\n_constant(plane_t) ground = _begin(plane_t)\n\tvec3(0., -1., 0.), 0., 1\n_end;\n\nvec3 render_sky_color(\n\t_in(ray_t) eye\n){\n\tvec3 rd = eye.direction;\n\tfloat sun_amount = max(dot(rd, SUN_DIR), 0.0);\n\n\tvec3  sky = mix(vec3(.0, .1, .4), vec3(.3, .6, .8), 1.0 - rd.y);\n\tsky = sky + sun_color * min(pow(sun_amount, 1500.0) * 5.0, 1.0);\n\tsky = sky + sun_color * min(pow(sun_amount, 10.0) * .6, 1.0);\n\n\treturn sky;\n}\n\nfloat density(\n\t_in(vec3) pos,\n\t_in(vec3) offset,\n\t_in(float) t\n){\n\t// signal\n\tvec3 p = pos * .0212242 + offset;\n\tfloat dens = get_noise(p);\n\t\n\tfloat cov = 1. - COVERAGE;\n\t//dens = band (.1, .3, .6, dens);\n\t//dens *= step(cov, dens);\n\t//dens -= cov;\n\tdens *= smoothstep (cov, cov + .05, dens);\n\n\treturn clamp(dens, 0., 1.);\t\n}\n\nfloat light(\n\t_in(vec3) origin\n){\n\tconst int steps = 8;\n\tfloat march_step = 1.;\n\n\tvec3 pos = origin;\n\tvec3 dir_step = SUN_DIR * march_step;\n\tfloat T = 1.; // transmitance\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tfloat dens = density(pos, WIND, 0.);\n\n\t\tfloat T_i = exp(-ABSORPTION * dens * march_step);\n\t\tT *= T_i;\n\t\t//if (T < .01) break;\n\n\t\tpos += dir_step;\n\t}\n\n\treturn T;\n}\n\nvec4 render_clouds(\n\t_in(ray_t) eye\n){\n\thit_t hit = no_hit;\n\tintersect_sphere(eye, atmosphere, hit);\n\t//hit_t hit_2 = no_hit;\n\t//intersect_sphere(eye, atmosphere_2, hit_2);\n\n\tconst float thickness = THICKNESS; // length(hit_2.origin - hit.origin);\n\t//const float r = 1. - ((atmosphere_2.radius - atmosphere.radius) / thickness);\n\tconst int steps = STEPS; // +int(32. * r);\n\tfloat march_step = thickness / float(steps);\n\n\tvec3 dir_step = eye.direction / eye.direction.y * march_step;\n\tvec3 pos = //eye.origin + eye.direction * 100.; \n\t\thit.origin;\n\n\tfloat T = 1.; // transmitance\n\tvec3 C = vec3(0, 0, 0); // color\n\tfloat alpha = 0.;\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tfloat h = float(i) / float(steps);\n\t\tfloat dens = density (pos, WIND, h);\n\n\t\tfloat T_i = exp(-ABSORPTION * dens * march_step);\n\t\tT *= T_i;\n\t\tif (T < .01) break;\n\n\t\tC += T * \n#ifdef SIMULATE_LIGHT\n\t\t\tlight(pos) *\n#endif\n#ifdef FAKE_LIGHT\n\t\t\t(exp(h) / 1.75) *\n#endif\n\t\t\tdens * march_step;\n\t\talpha += (1. - T_i) * (1. - alpha);\n\n\t\tpos += dir_step;\n\t\tif (length(pos) > 1e3) break;\n\t}\n\n\treturn vec4(C, alpha);\n}\n\nvoid mainImage(\n\t_out(vec4) fragColor,\n#ifdef SHADERTOY\n\tvec2 fragCoord\n#else\n\t_in(vec2) fragCoord\n#endif\n){\n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\tfloat fov = tan(radians(45.0));\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n#ifdef HLSL\n\tpoint_ndc.y = 1. - point_ndc.y;\n#endif\n\tvec3 point_cam = vec3((2.0 * point_ndc - 1.0) * aspect_ratio * fov, -1.0);\n\n#if 0\n\tfloat n = saturate(get_noise(point_cam));\n\tfragColor = vec4(vec3(n, n, n), 1);\n\treturn;\n#endif\n\n\tvec3 col = vec3(0, 0, 0);\n\n\t//mat3 rot = rotate_around_x(abs(sin(u_time / 2.)) * 45.);\n\t//sun_dir = mul(rot, sun_dir);\n\n\tvec3 eye = vec3(0, 1., 0);\n\tvec3 look_at = vec3(0, 1.6, -1);\n\tray_t eye_ray = get_primary_ray(point_cam, eye, look_at);\n\n\teye_ray.direction.yz = mul(rotate_2d(+u_mouse.y * .13), eye_ray.direction.yz);\n\teye_ray.direction.xz = mul(rotate_2d(-u_mouse.x * .33), eye_ray.direction.xz);\n\n\thit_t hit = no_hit;\n\tintersect_plane(eye_ray, ground, hit);\n\n\tif (hit.material_id == 1) {\n\t\tfloat cb = checkboard_pattern(hit.origin.xz, .5);\n\t\tcol = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), cb);\n\t} else {\n#if 1\n\t\tvec3 sky = render_sky_color(eye_ray);\n\t\tvec4 cld = render_clouds(eye_ray);\n\t\tcol = mix(sky, cld.rgb/(0.000001+cld.a), cld.a);\n#else\n\t\tintersect_sphere(eye_ray, atmosphere, hit);\n\t\tvec3 d = hit.normal;\n\t\tfloat u = .5 + atan(d.z, d.x) / (2. * PI);\n\t\tfloat v = .5 - asin(d.y) / PI;\n\t\tfloat cb = checkboard_pattern(vec2(u, v), 50.);\n\t\tcol = vec3(cb, cb, cb);\n#endif\n\t}\n\n\tfragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}