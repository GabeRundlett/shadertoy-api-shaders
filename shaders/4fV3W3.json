{
    "Shader": {
        "info": {
            "date": "1713361283",
            "description": "Anisotropic Specular Image-Based Lighting Based on BRDF Major Axis Sampling.\n\nProject page: https://xavierchermain.github.io/publications/aniso-ibl",
            "flags": 32,
            "hasliked": 0,
            "id": "4fV3W3",
            "likes": 4,
            "name": "Anisotropic Image-Based Lighting",
            "published": 3,
            "tags": [
                "ibl",
                "anisotropy"
            ],
            "usePreview": 0,
            "username": "iota97",
            "viewed": 155
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Giovanni Cocco\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Raytracing from https://www.shadertoy.com/view/ftt3RH\n// UI from https://www.shadertoy.com/view/XsySzG\n\n                                 //==========//\n                                // WARNING! //\n                               //==========//\n                               \n// Shadertoy only supports box filtering for the cubemap pre-integration,\n// as such this demo does NOT match our implementation in the forumula\n// for the LOD selection that had to be empirically changed!\n// We still provide the original formula in a comment.\n\n\n//==================================================================================//\n//==================================================================================//\n//                Anisotropic Specular Image-Based Lighting Based on                //\n//                           BRDF Major Axis Sampling                               //\n//==================================================================================//\n//==================================================================================//\n//                                                                                  //                                       \n//                                  UI parameters                                   //\n//                                                                                  //\n// - Method: set to a value > 0.5 for our method, <= 0.5 for the bent normal one    //\n// - Roughness: perceptive-roughness (alpha_lin)                                    //\n// - Anisotropy: controls the amount of anisotropy (eta)                            //\n// - Direction: rotates the main direction of anisotropy (\\overline{U})              //\n//                                                                                  //\n//==================================================================================//\n//==================================================================================//\n\n//==================================================================================//\n//============================== Macro-parameters ==================================//\n//==================================================================================//\n//       SAMPLE_COUNT (N) controls the number of enviroment sample per pixel        //\n//==================================================================================//\nconst float SAMPLE_COUNT = 16.;\n\n\n//==================================================================================//\n//              Compute the extrema using our closed form solution                  //\n//==================================================================================//\n//                                                                                  //\n//  The view vector, wo, must be expressed in normal space                          //\n//                                                                                  //\n//  Return 2 extrema in slope space, to obtain all 4:                               //\n//   - the further extrema are 'farExtremum' and '-farExtremum'                     //\n//   - the closest extrema are 'closeExtremum' and '-closeExtremum                  //\n//                                                                                  //\n//==================================================================================//\nvoid extremumPoints(float radius_x, float radius_y, vec3 wo, float anisotropyAngle, out vec2 closeExtremum, out vec2 farExtremum, out vec2 roots)\n{\n    //==============================================================================//\n    //================== Closed-form solution - Appendix A =========================//\n    //==============================================================================//\n    mat2 R = mat2(cos(anisotropyAngle), -sin(anisotropyAngle), sin(anisotropyAngle), cos(anisotropyAngle));\n    vec2 o = wo.xy*R;\n    \n    vec2 o2 = o.xy*o.xy;\n    float r2x = radius_x*radius_x;\n    float r2y = radius_y*radius_y;\n    float p0 = 2.*o.x*o.y*radius_x*radius_y;\n    float p1 = o2.x*(r2x*r2y + r2y) - o2.y*(r2x*r2y + r2x) + r2x -r2y;\n    float p2 = -p0*(r2y + 1.);\n    float p3 = p0*p2*(r2x + 1.);\n    float t0 = p2 == 0. ? step(0., p1)*PI/2. : atan((p1+sqrt(p1*p1-p3))/p2);\n    float t1 = p2 == 0. ? t0+PI/2. : atan((p1-sqrt(p1*p1-p3))/p2);\n    \n    //==============================================================================//\n    //==================== Return the slope space extrema ==========================//\n    //==============================================================================//\n    \n    closeExtremum = R*vec2(radius_x*cos(t0), radius_y*sin(t0));\n    farExtremum = R*vec2(radius_x*cos(t1), radius_y*sin(t1));\n    roots = vec2(t0, t1);\n}\n\n//==================================================================================//\n//                            Clamp the futher extrema                              //\n//==================================================================================//\n//                                                                                  //\n//  Update the 2 extrema in normal space and return tau_0 and tau_1                 //\n//                                                                                  //\n//==================================================================================//\nvoid clampExtrema(inout vec3 farNormal0, inout vec3 farNormal1, vec3 wo, out vec2 tau)\n{\n    //==============================================================================//\n    //================== Closed-form solution - Appendix B =========================//\n    //==============================================================================//\n    float p0 = farNormal1.x*wo.x + farNormal1.y*wo.y;\n    float p1 = wo.z*(1.-farNormal1.z*farNormal1.z);\n    float p3 = sqrt(p0*p0 + wo.z*p1);\n    float t0 = max(0.5+farNormal1.z*(p0-p3)/(2.*p1), 0.);\n    float t1 = min(0.5+farNormal1.z*(p0+p3)/(2.*p1), 1.);\n    \n    vec3 tmp = farNormal0;\n    farNormal0 = normalize(mix(farNormal0, farNormal1, t0));\n    farNormal1 = normalize(mix(farNormal0, farNormal1, t1));\n    tau = vec2(t0, t1);\n}\n\n\n//==================================================================================//\n//        Shift the further extrema and return the LOD to sample the cubemap        //\n//==================================================================================//\n//                                                                                  //\n//  Update the 2 extrema in normal space and return the LOD                         //\n//                                                                                  //\n//  NOTE: Shadertoy does not support GGX kernel pre-integration of the cubemap,     //\n//        the returned LOD is different from the one in the paper.                  //\n//                                                                                  //\n//==================================================================================//\nvoid shiftExtrema(float radius_x, float radius_y, vec3 wo, float anisotropyAngle, vec2 roots, vec2 tau, inout vec3 farNormal0, inout vec3 farNormal1, out float level)\n{\n    //==============================================================================//\n    //============== Update the closest extrema - Appendix C =======================//\n    //==============================================================================//\n    mat2 R = mat2(cos(anisotropyAngle), -sin(anisotropyAngle), sin(anisotropyAngle), cos(anisotropyAngle));\n    float angleDelta = (tau.x > 0. ? tau.x : tau.y-1.)*(roots.x-roots.y);\n    float min0t = roots.x+angleDelta;\n    float min1t = roots.x-angleDelta+PI;\n    vec2 close0Slope = R*vec2(radius_x*cos(min0t), radius_y*sin(min0t));\n    vec2 close1Slope = R*vec2(radius_x*cos(min1t), radius_y*sin(min1t));\n    vec3 close0Normal = slopeToNormal(close0Slope);\n    vec3 close1Normal = slopeToNormal(close1Slope);\n    \n    //==============================================================================//\n    //======================== Shift the furthest extrema ==========================//\n    //==============================================================================//\n    float minLength = length(reflect(-wo, close0Normal)-reflect(-wo, close1Normal));\n    float maxLength = length(reflect(-wo, farNormal0)-reflect(-wo, farNormal1));\n    float rateo = (maxLength-minLength)/maxLength;\n    vec3 axisCenter = normalize(farNormal0+farNormal1);\n    farNormal0 = normalize(axisCenter + rateo*(farNormal0-axisCenter));\n    farNormal1 = normalize(axisCenter + rateo*(farNormal1-axisCenter));\n    \n    //==============================================================================//\n    //============================== Compute the LOD ===============================//\n    //==============================================================================//\n    \n    // LOD formula for GGX\n    // level = log2(float(textureSize(cubeMap, 0).x))*sqrt(max(minLength, 2.3*maxLength/SAMPLE_COUNT)/2.);\n    \n    // THIS LOD CALCULATION IS ONLY FOR THE BOX FILTERED CUBEMAP OF SHADERTOY!\n    level = log2(float(textureSize(iChannel1, 0).x)*max(minLength/2., 2.5*maxLength/SAMPLE_COUNT));\n}\n\n//==================================================================================//\n//                    Compute the integrated enviroment map                         //\n//==================================================================================//\n//                                                                                  //\n//  The paramenters 'view' and 'normal' are to be expressed in world space          //\n//  Anisotropic roughness is computed from 'roughness' and 'anisotropy'             //\n//                                                                                  //\n//==================================================================================//\nvec3 sampleEnviroment(vec3 view, vec3 normal, mat3 normalToWorld,\n                          float anisotropyAngle, float roughness, float anisotropy)\n{\n    //==============================================================================//\n    //================ Define the confidence region boundary =======================//\n    //==============================================================================//\n    \n    // We use Kulla and Conty 2017 parametrization for the anisotropic roughness\n    float radius_x = roughness*roughness/2. * (1. + anisotropy);\n    float radius_y = roughness*roughness/2. * (1. - anisotropy);\n    \n    //==============================================================================//\n    //============== Get the extrema with the closed-form solution =================//\n    //==============================================================================//\n    \n    vec3 wo = view*normalToWorld;\n    vec2 closeExtremum;\n    vec2 farExtremum;\n    vec2 roots;\n    extremumPoints(radius_x, radius_y, wo, anisotropyAngle, closeExtremum, farExtremum, roots);\n    \n    vec3 farNormal0 = slopeToNormal(farExtremum);\n    vec3 farNormal1 = slopeToNormal(-farExtremum);\n   \n    //==============================================================================//\n    //======================== Clamp and shift the extrema =========================//\n    //==============================================================================//\n    vec2 tau;\n    clampExtrema(farNormal0, farNormal1, wo, tau);\n    \n    float level;\n    shiftExtrema(radius_x, radius_y, wo, anisotropyAngle, roots, tau, farNormal0, farNormal1, level);\n     \n    //==============================================================================//\n    //========================= Sample the enviroment map  =========================//\n    //==============================================================================//\n    \n    vec3 farNormal0WS = normalToWorld*farNormal0;\n    vec3 farNormal1WS = normalToWorld*farNormal1;\n    vec3 environment = vec3(0.0);\n    for (float i = 0.; i < SAMPLE_COUNT; i++) {\n        vec3 wm = normalize(mix(farNormal0WS, farNormal1WS, i/(SAMPLE_COUNT-1.)));\n        environment += pow(textureLod(iChannel1, reflect(-view, wm), level).rgb, vec3(2.2));\n    }\n    environment /= SAMPLE_COUNT;\n    \n    return environment;\n}\n\n\n//==============================================================================//\n//=============== Bend normal alterative implementation ========================//\n//==============================================================================//\nvec3 sampleEnviroment_bendNormal(vec3 view, vec3 normal, mat3 normalToWorld,\n                                 float anisotropyAngle, float roughness, float anisotropy)\n\n{\n    vec2 anisotropyDirection = vec2(cos(anisotropyAngle), sin(anisotropyAngle));\n    vec3 tangent = normalToWorld*vec3(anisotropyDirection, 0);\n    vec3 bitangent = normalToWorld*vec3(anisotropyDirection.y, -anisotropyDirection.x, 0);\n   \n    //==============================================================================//\n    //============= Bend the normal [Lagarde and Golubev 2018]  ====================//\n    //==============================================================================//\n    \n    vec3 grainDirWs = anisotropy >= 0.0 ? bitangent : tangent;\n    float stretch = abs(anisotropy) * clamp(1.5*sqrt(roughness), 0., 1.);\n    vec3 B = cross(grainDirWs, view);\n    vec3 grainNormal = cross(B, grainDirWs);\n    vec3 iblN = normalize(mix(normal, grainNormal, stretch));\n    float roughIBL = roughness*clamp(1.2-abs(anisotropy), 0., 1.);\n\n    //==============================================================================//\n    //======================= Sample the enviroment map ============================//\n    //==============================================================================//\n    \n    float level = log2(float(textureSize(iChannel1, 0).x)*roughIBL*roughIBL);\n    vec3 environment = pow(textureLod(iChannel1, reflect(-view, iblN), level).rgb, vec3(2.2));\n    \n    return environment;\n}\n\nfloat uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //==============================================================================//\n    //======================= Define and raytrace the scene ========================//\n    //==============================================================================//\n    \n    // [0, 1]^2\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // [-0.5, 0.5]^2\n    uv -= 0.5;\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Incomming radiance\n    vec3 Li = vec3(0.);\n    \n    float cameraAngle = cos(iTime*0.7) * PI / 4. + PI / 2.;\n\n    Ray ray;\n    // Ray origin\n    ray.o = vec3(cos(cameraAngle), 0., sin(cameraAngle));\n    // The camera look at position lookAt\n    vec3 lookAt = vec3(0.);\n    // Zoom of the camera\n    float zoom = 1. + (cos(iTime*0.7)+1.)*0.2;\n    // Forward direction of the camera\n    vec3 camForward = normalize(lookAt - ray.o);\n    // Right direction of the camera\n    vec3 camRight = cross(camForward, vec3(0, 1, 0));\n    // Up direction of the camera\n    vec3 camUp = cross(camRight, camForward);\n    // Center of the screen\n    vec3 screenCenter = ray.o + camForward * zoom;\n    // Intersection point of the screen\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    // Ray direction\n    ray.d = normalize(screenIntersection - ray.o);\n    \n    // Initialize sphere\n    Sphere sphere;\n    sphere.radius = 0.5;\n    sphere.worldToObject = mat4(1.);\n    mat4 scale = createInvScaleTransformation(vec3(0.9, 0.9, 0.9));\n    mat4 rotateX = createInvRotateXTransformation(-0.15*PI);\n    mat4 rotateY = createInvRotateYTransformation(0.1*PI);\n    sphere.worldToObject = rotateY * rotateX * scale * sphere.worldToObject;\n    \n    // Trace the ray   \n    float tHit;\n    SurfaceInteraction si;\n    if (intersectSphere(sphere, ray, tHit, si)) {\n    \n        //==============================================================================//\n        //============================ We hit the sphere ===============================//\n        //==============================================================================//\n        \n        // Get the parameters from UI\n        bool useOurMethod = uiSlider(0) > 0.5;\n        float roughness = clamp(uiSlider(1), 0.03, 1.);\n        float anisotropy = clamp(uiSlider(2), 0., 0.95);\n        float anisotropyAngle = clamp(uiSlider(3), 0., 1.)*PI;\n\n        //==============================================================================//\n        //======================= Sample the enviroment map ============================//\n        //==============================================================================//\n        \n        vec3 enviromentLight;\n        if (useOurMethod) {\n            enviromentLight = sampleEnviroment(si.wo, si.n, si.normToWorld, anisotropyAngle, roughness, anisotropy);\n        } else {\n            enviromentLight = sampleEnviroment_bendNormal(si.wo, si.n, si.normToWorld, anisotropyAngle, roughness, anisotropy);\n        }\n        \n        //==============================================================================//\n        //=========== Apply BRDF preintegration [Pesce and Iwanicki 2015] ==============//\n        //==============================================================================//\n        float F = 1.0; // hard code Fresnel to 1 for better visualization\n        float NoV = dot(si.wo, si.n);\n        float bias = pow(2., -7.*(NoV+4.*roughness*roughness));\n        float scale = 1. - bias - roughness*roughness * max(bias, min(roughness, 0.739+0.323*NoV)-0.434);\n        Li = (F * scale + bias) * enviromentLight;\n\n    } else {\n        // If no intersection, then hit the environment map\n        Li = pow(texture(iChannel1, ray.d).rgb, vec3(2.2));\n    }\n    \n    // Exposition\n    Li = Li / (Li + vec3(.4));\n    // Gamma correction\n    Li = pow(Li, vec3(0.4545));\n    \n    //UI integration\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec4 ui = texture(iChannel0, q);\n    Li = mix(Li, ui.rgb, ui.a*.8);\n        \n    fragColor = vec4(vec3(Li), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//From https://www.shadertoy.com/view/ftt3RH\n//! Common functions\n\n#define PI 3.141592\n#define TWOPI 6.283185\n\n//! Solve a quadratic equation of the form at^2 + bt + c = 0\n//! If solutions were found, t0 is always smaller or equal to t1\n//! \\return true is solutions were found\nbool solveQuadraticEquation(in float a, in float b, in float c, out float t0, out float t1){\n    // Find quadratic discriminant\n    float discrim = b*b - 4. * a * c;\n    if(discrim < 0.) return false;\n    float rootDiscrim = sqrt(discrim);\n    // Compute quadratic t values\n    float q;\n    if(b < 0.) q = -0.5 * (b - rootDiscrim);\n    else       q = -0.5 * (b + rootDiscrim);\n    t0 = q / a;\n    t1 = c / q;\n    if(t0 > t1){\n        // Swap t0 and t1\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    return true;\n}\n\nvec3 slopeToNormal(vec2 p) {\n    return normalize(vec3(-p, 1));\n}\n\nmat4 createInvTranslationTransformation(vec3 delta){\n    mat4 m = mat4(1.);\n    m[3] = vec4(-delta, 1.);\n    return m;\n}\n\nmat4 createInvScaleTransformation(vec3 s){\n    mat4 m = mat4(1.);\n    m[0][0] = 1./s[0];\n    m[1][1] = 1./s[1];\n    m[2][2] = 1./s[2];\n    return m;\n}\n\nmat4 createInvRotateXTransformation(float theta){\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    mat4 m = mat4(vec4(1., 0.,        0.,       0.),\n                  vec4(0., cosTheta, -sinTheta, 0.),\n                  vec4(0., sinTheta,  cosTheta, 0.),\n                  vec4(0., 0.,        0.      , 1.));\n    return m;\n}\n\nmat4 createInvRotateYTransformation(float theta){\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    mat4 m = mat4(vec4(cosTheta, 0., sinTheta, 0.),\n                  vec4(0., 1, 0, 0.),\n                  vec4(-sinTheta, 0, cosTheta, 0.),\n                  vec4(0., 0., 0., 1.));\n    return m;\n}\n\n//! Structure of a ray\nstruct Ray{\n    //! Origin of the ray\n    vec3 o;\n    //! Direction of the ray\n    vec3 d;\n};\n\n//! Compute the point at a particular position along a ray\n//! The ray is a function of a single parameter t\nvec3 computePointAlongRay(in Ray r, float t){\n    return r.o + r.d * t;\n}\n\n//! Transform a point p with a transformation t. The function converts\n//! the point to homogeneous coordinates, then transforms the point and convert back\n//! to a nonhomogeneous point representation\n//! \\param p Point with nonhomogeneous representation\n//! \\param t 4x4 transformation matrix\n//! \\return The transformed point with nonhomogeneous representation\nvec3 transformPoint(in vec3 p, in mat4 t){\n    // Homogeneous point representation\n    vec4 homogeneousPoint = vec4(p, 1.);\n    vec4 transformedPoint = t * homogeneousPoint;\n    // We assume homogeneous weight = 1, i.e.,\n    // t[0][3] = t[1][3] = t[2][3] = 0.\n    return transformedPoint.xyz;\n}\n\n//! Transform a vector v with a transformation t. The function converts\n//! the vector to homogeneous coordinates, then transforms the vector and convert back\n//! to a nonhomogeneous vector representation\n//! \\param v Vector with nonhomogeneous representation\n//! \\param t 4x4 transformation matrix\n//! \\return The transformed vector with nonhomogeneous representation\nvec3 transformVector(in vec3 v, in mat4 t){\n    // Homogeneous vector representation\n    vec4 homogeneousVector = vec4(v, 0.);\n    vec4 transformedVector = t * homogeneousVector;\n    return transformedVector.xyz;\n}\n\n//! Transform a normal n with a transformation t.\n//! \\param n Normal\n//! \\param t 4x4 transformation matrix\n//! \\return The transformed normal\nvec3 transformNormal(in vec3 n, in mat4 t){\n    // Homogeneous normal representation\n    vec4 homogeneousNormal = vec4(n, 0.);\n    vec4 transformedNormal = transpose(inverse(t)) * homogeneousNormal;\n    return transformedNormal.xyz;\n}\n\n//! Transform a ray with a transformation\nRay transformRay(in Ray ray, in mat4 t){\n    Ray transformedRay;\n    transformedRay.o = transformPoint(ray.o, t);\n    transformedRay.d = transformVector(ray.d, t);\n    return transformedRay;\n}\n\n//! The SurfaceInteraction abstraction supplies information about\n//! the surface point to allow the shading to be implemented\nstruct SurfaceInteraction{\n    //! The intersection point\n    vec3 p;\n    //! The time associated to the intersection point\n    float time;\n    //! The negative ray direction (observation direction for the first intersection)\n    vec3 wo;\n    //! The surface normal at the point\n    vec3 n;\n    //! The (u,v) coordinates from the parameterization of the surface\n    vec2 uv;\n    //! Partial derivatives of the point\n    vec3 dpdu, dpdv;\n    //! normal to world transformation matrix\n    mat3 normToWorld;\n};\n\n//! Structure of a sphere\nstruct Sphere{\n    //! The radius of the sphere\n    float radius;\n    //! The world to object transformation of the sphere\n    mat4 worldToObject;\n};\n\n// Inspiration: pbrt-v3\nbool intersectSphere(in Sphere s, in Ray r, out float tHit, out SurfaceInteraction si){\n    // Initialize tHit\n    tHit = 0.;\n    // Transform ray to object space\n    Ray ray = transformRay(r, s.worldToObject);\n    // Compute quadratic sphere coefficients\n    float a = ray.d.x * ray.d.x + ray.d.y * ray.d.y + ray.d.z * ray.d.z;\n    float b = 2. * (ray.d.x * ray.o.x + ray.d.y * ray.o.y + ray.d.z * ray.o.z);\n    float c = ray.o.x * ray.o.x + ray.o.y * ray.o.y + ray.o.z * ray.o.z - s.radius * s.radius;\n    float t0, t1;\n    if(!solveQuadraticEquation(a, b, c, t0, t1)){\n        return false;\n    }\n    // Check quadric shape t0 and t1 for nearest intersection\n    if(t1 <= 0.)\n        return false;\n    float tShapeHit = t0;\n    if(tShapeHit <= 0.){\n        tShapeHit = t1;\n    }\n    // Compute sphere hit\n    vec3 pHit = computePointAlongRay(ray, tShapeHit);\n    // Refine sphere intersection point\n    pHit *= s.radius / length(pHit);\n    // Compute sphere phi\n    float phi = atan(pHit.y, pHit.x);\n    if(phi < 0.) phi += TWOPI;\n    // Find parametric representation of sphere hit\n    float u = phi / TWOPI;\n    float theta = acos(clamp(pHit.z / s.radius, -1., 1.));\n    float v = theta / PI;\n    // Compute partial derivatives\n    float zRadius = sqrt(pHit.x * pHit.x + pHit.y * pHit.y);\n    float invZRadius = 1. / zRadius;\n    float cosPhi = pHit.x * invZRadius;\n    float sinPhi = pHit.y * invZRadius;\n    vec3 dpdu = vec3(-TWOPI * pHit.y, TWOPI * pHit.x, 0.);\n    vec3 dpdv = PI * vec3(pHit.z * cosPhi, pHit.z * sinPhi, -s.radius * sin(theta));\n    // Initialize surface interaction\n    mat4 objectToWorld = inverse(s.worldToObject);\n    si.p = transformPoint(pHit, objectToWorld);\n    si.time = tShapeHit;\n    si.wo = -r.d;\n    si.n = normalize(transformNormal(normalize(pHit), objectToWorld));\n    si.uv = vec2(u,v);\n    si.dpdu = transformVector(dpdu, objectToWorld);\n    si.dpdv = transformVector(dpdv, objectToWorld);\n    si.normToWorld = mat3(normalize(cross(cross(si.n, si.dpdu), si.n)), normalize(cross(cross(si.n, si.dpdv), si.n)), si.n);\n    // Update tHit\n    tHit = tShapeHit;\n    return true;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Thx to :\n// Smooth HSV - iq : https://www.shadertoy.com/view/MsS3Wc\n// Rounded box - iq : https://www.shadertoy.com/view/4llXD7\n// 96-Bit 8x12 font - Flyguy : https://www.shadertoy.com/view/Mt2GWD\n\n\n// NO MINIFIED VERSION : https://www.shadertoy.com/view/XsySzG\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.3,1.,.3)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.z>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.z<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.z>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.z<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    _slider(10,20, 0, 1.) _M _e _t _h _o _d\n    _slider(10,40, 1, .4) _R _o _u _g _h _n _e _s _s\n    _slider(10,60, 2, 1.) _A _n _i _s _o _t _r _o _p _y\n    _slider(10,80, 3, 0.) _D _i _r _e _c _t _i _o _n\n\n    fragColor = min(col.rgba,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}