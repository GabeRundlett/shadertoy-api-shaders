{
    "Shader": {
        "info": {
            "date": "1578437736",
            "description": "Trying to do the escher spiraling painting effect without looking at other shader code.\n\nIt is far from perfect but I'm not confident in the lead i've been following :)\n\nInspired by www.shadertoy.com/view/tl3GW2",
            "flags": 0,
            "hasliked": 0,
            "id": "tlKGzW",
            "likes": 15,
            "name": "ShaderDojo 042",
            "published": 3,
            "tags": [
                "escher"
            ],
            "usePreview": 0,
            "username": "antonOTI",
            "viewed": 479
        },
        "renderpass": [
            {
                "code": "#define TAU 6.28318\n\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nvec2 spiralize(vec2 uv)\n{\n    float len = length(uv);\n    \n\tuv *= 128.;\n    float r = .045;\n    mat2 mr = rot(r);\n    \n    float a;\n    float acc = 1.;\n    \n    a = atan(uv.y, uv.x) / TAU + .5;\n    a = fract(a + iTime * .05);\n    \n//    a *= (sin( iTime) * .5 + .5);\n    uv *= 1. - a * .50;\n  \n    for(int i = 0; i < 7; ++i)\n    {\n\t\t\n        if(abs(uv.x) < 1. && abs(uv.y) < 1.)\n//        if(length(uv) < 1.)\n        {\n            break;\n        }\n        \n        uv *= .5;\n        \n        /*\n        uv.x += 1.;\n        uv *= mr;\n        uv.x -= 1.;\n        */\n    }\n    \n    return uv;\n}\n\n\nfloat fbm(vec2 p)\n{\n  mat2 m = mat2(.8,-.6,.6,.8);\n  float acc = 0.;\n  p *= -m * m * .5;\n  for(float i = 1.; i < 6.; ++i)\n  {\n    p += vec2(i * 12.675, i * 65.457) + vec2(iTime * .15);\n    p *= m;\n    acc += (sin(p.x * i) + cos(p.y * i)) * 1./(i * .5);\n  }\n\n  return acc;\n}\n\nfloat sdCube(vec3 p)\n{\n  vec3 q = abs(p) - vec3(1.);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p)\n{\n    vec3 cp = p;\n    \n    \n    float dist = p.y + fbm(p.xz *1.5) * .1 + 3.;\n    \n    p = cp;\n    \n    p.xy *= .515;\n    float cu = sdCube(p) - .1;\n    \n    dist = min(dist,cu);\n    \n    p = cp;\n    \n    float r = 4.;\n    p.xz = mod(p.xz + r *.5, r) - r * .5;\n    p.y -= 20.;\n    cu = sdCube(p);\n    dist = min(dist,cu);\n    \n    return dist;\n}\n\nfloat ray(vec3 ro, vec3 rd, out float st)\n{\n    float cd = 0.;\n    float FAR = 100.;\n    for(st = 0.; st < 1.; st += 1. / 128.)\n    {\n    \tfloat d = map(ro + rd * cd);\n        if(abs(d) < .01)\n            break;\n        cd += d * .85;\n    }\n    \n    return cd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    \n     uv = spiralize(uv);\n    \n    float f = max(abs(uv.x),abs(uv.y));\n    f = smoothstep(.0,0.05, abs(f - 1.));\n    f = iMouse.z < 0. ? 1. : f;\n    \n    vec3 ro = vec3(0.,0.,-5.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float st;\n    float dist = ray(ro, rd, st);\n    \n    vec3 col = vec3(0.);\n    if(st < 1.)\n    {\n        vec3 cp = ro + rd * dist;\n        \n        col = mix(vec3(1.), vec3(9.,.4,.8), sin(cp.z * .1) * .5 + .5) * (1. - pow(st, 1.5));\n        \n        vec3 lp = vec3(4. * sin(iTime *.25),3. + 1.* cos(iTime * .125),-5. );\n        vec3 ld = normalize(lp - cp);\n        cp += ld * .1;\n        float ldist = ray(cp, ld, st);\n        \n    \n        if(ldist < length(cp - ld))\n        {\n            col *= .1025;\n        }\n    }\n    \n    uv = (uv +1.) * .5;\n    // col = texture(iChannel0,uv).rgb;\n    \n    fragColor = vec4(col, 0.) * f;\n    fragColor = pow(fragColor,vec4(.4545));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}