{
    "Shader": {
        "info": {
            "date": "1502234426",
            "description": "mouse is important here.\n\nhoping i could inverse the polar transformation for length() in polar coordinates easily. \nbut it seems to be not worth it.\nnot as expected.\nthis can be done simpler.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdjBWK",
            "likes": 0,
            "name": "j cane space warp fail",
            "published": 3,
            "tags": [
                "snake",
                "j",
                "cane"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 714
        },
        "renderpass": [
            {
                "code": "#define frame(u) (u-.5*iResolution.xy)*5./iResolution.y\n\n\n//#define stretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//above is special case that can include the sat() generalization below +u.x;\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nfloat sat(float a,vec2 m){    \n a=.5*(sign(a)+m.x)*a+m.y;\n a=(sign(2.-a)+1.)*(a-2.)+2.; \n return a*.5;}\nfloat sat(float a){return sat(a,vec2(1));}//return clamp(a,0.,1.); \n\n/*\n//explicit atan2(y,x), hopefully slightly more worksave?\nfloat ata(float x,float y){\n //return atan(x/y);//not quite as work save as below? or rautological either way?\n float a=.5*(1.-sign(x));//pi and -pi are equally valid. doesnt matter which way you rotate?\n float b=atan(x/y);//division by 0 is poblematic, unless multiplied by 0.\n float s=step(y,0.)+step(0.,y)-1.;\n //why do i end u in this tautology?\n //my solution is that equality is an ideal fiction.\n //while the reality is heuristic gradients.\n //the ideal is tautological, art, with null utility.\n return mix(b,a,s);}\n*/\n\n//carthesian to polar\nvec2 c2p(vec2 c){return vec2(length(c),atan(c.y,c.x));}\n//polar to carthesian\nvec2 p2c(vec2 c){return vec2(c.x*cos(c.y),c.x*sin(c.y));}\n\n\nvec2 warpN(vec2 u){\n  u=vec2(-u.y,-u.x);\n    if(u.x<0.){\n        u.x-=acos(-1.);\n        u= vec2(u.y,u.x);\n        return u;\n    }\n    if(u.y<0.){\n       u=vec2(-length(u),atan(u.y,u.x));\n        return u;}\n   \n\n    return vec2(-u.x,u.y);\n/**/    \n    //if(u.x>0.)return vec2 (-u.y,u.x);\n    //if(u.y<0.)return u;\n    //return vec2(-length(u),atan(u.y,u.x));\n    /*\n    u.x=-u.x;\n    if(u.y>0.){\n        u= c2p(u);//vec2(length(u),atan(u.y,u.x));\n        //u.y*=acos(-1.)*.5;\n        return u;\n    }\n    if(u.x<0.){\n    u.x=-u.x;\n    u.y=acos(-1.)-u.y;\n    }*/\n return u;\n}\n\nvoid mainImage(out vec4 O,in vec2 U){\n vec2 u=frame(U);\n vec4 m=vec4(frame(iMouse.xy),frame(iMouse.zw));\n float a=atan(u.x,u.y);\n float g=(a+sign(u.y)*acos(0.))/acos(-1.)+.5;\n g=g*.5+.25;//scale visible range.\n //above is explicit atan2 wrapper over atan()\n\n \n float b=max(u.x,u.y)-1.;\n    \n    // u.y=abs(u.y);\n    \n u=warpN(u);\n\n// m.x=abs(m.x);\n //float d=m.x;\n m.xy=warpN(m.xy);\n// u.x-=m.x;\n u.x+=1.;\n u.y-=m.x;\n u.y=mStretchM(u.y,-m.y);\n \n    \n //u.x-=1.;\n \n float r=length(u)-.3;\n    \n //u=warpN(u);\n\n //r=fract(r);\n u=fract(u);\n vec3 c=vec3(r,u);\n \n c.rb=smoothstep(.01,-.01,c.rb);\n O= vec4(c,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}