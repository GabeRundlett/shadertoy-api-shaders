{
    "Shader": {
        "info": {
            "date": "1569073260",
            "description": "Constructing a jigsaw pattern with minimal instruction count.",
            "flags": 0,
            "hasliked": 0,
            "id": "wddGzj",
            "likes": 22,
            "name": "Minimal Jigsaw",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "diamond",
                "pattern",
                "tile",
                "minimal",
                "puzzle",
                "jigsaw"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1322
        },
        "renderpass": [
            {
                "code": "/*\n\n\tMinimal Jigsaw\n\t--------------\n\n\tI put together a square 3D jigsaw pattern a while back, and Fizzer \n\tnoticed that the planar version could be constructed with less effort \n    when considering one diagonal (instead of the four sides I was \n    comparing), then put together a cool example demonstrating that. The \n    link is below, for anyone interested.\n\n    Anyway, that idea got me wondering just how little code you could\n\tuse to construct a basic colored jigsaw pattern, so this is my take\n\ton it. \n\n\tFizzer took a clever space segmented approach. My mind isn't as \n\tsophisticated, so I usually have to code things in a brute force \n\tfashion, then look for optimization opportunities via patterns and\n\tsymmetry, and so forth, so that's the method I applied here. Either way, \n\tI was pleasantly surprised by how much it was possible to cut things \n    down. Having said that, I still left enough code in there to give the \n\tcode golfers something to work with. :)\n\n    \n\tOther Examples:\n\n\t// Cleverly constructed, as always.\n\tJigsaw Pattern - Fizzer\n\thttps://www.shadertoy.com/view/3tlXR4\n\n\t// Jigsaw patterns are possible with all kinds of shapes.\n\tIsosceles Jigsaw Strips - Shane\n\thttps://www.shadertoy.com/view/3sd3Rj\n\n*/\n\n\n// IQ's vec2 to float hash, with some decimals taken out. Obviously,\n// you wouldn't use these figures for more important things.\nfloat h21(vec2 p){  return fract(sin(dot(p, vec2(27.3, 57.7)))*1e4); }\n\n// A basic diamond shape -- Shuffled a little. \nfloat di(vec2 p){ p = abs(p); return (p.x + p.y - 1.)*.7 + .05; }\n\n// The jigsaw pattern algorithm -- cut down considerably.\n//\n// Each cell consists of a diagonal partitioning with one jigsaw piece \n// color on one side and its neighboring color on the other. In addition \n// the diagonals are oriented in such a way that they form diamonds, or\n// squares, depending on perspective. The nodule logic involves rendering \n// a circle over a random side of the line and updating the color ID \n// accordingly. \n//\n// Trust me, none of it is that hard. The only thing left to do after \n// that was to look for symmetrical patterns in order to minimize \n// instruction count, streamline the syntax, etc.\n//\nvec3 jigsaw(vec2 p){\n    \n    // Local cell ID and coordinates.\n    vec2 ip = floor(p); p -= ip + .5; \n \n    // Directional helper vectors.\n    vec2 m = fract(ip/2.)*2. - .5; // Orientation vector.   \n    vec2 dirV = dot(m, p)<0.? -m : m; // Direction vector.\n    vec2 rD = (h21(ip) - .5)*dirV;///m; // Random vector.\n    \n    // Temporary fix for the zero case, which seems to confuse\n    // the GPU on occasion, resulting in an absent nodule.\n    //if(rD.x == 0.) rD += dirV; \n    \n    // The distance functions -- A diamond, and offset nodule.\n    float d = di(p - dirV), c = length(p - dirV*.2) - .2;\n    \n\n    // Add the nodules to a random side of the diagonal.\n    if(rD.x<0.){  \n        d = max(d, .1 - c);\n        if(c<d) ip -= dirV*2.;\n    }  \n     \n    // Return the distance field and ID.\n    return vec3(min(d, c), ip + dirV);    \n}\n\nvoid mainImage(out vec4 fC, in vec2 u){    \n\n    // Aspect correct screen coordinates.\n    vec2 R = iResolution.xy;\n    \n    // Resizing and scaling.\n    u = (u - R*.5)/R.y*8. + vec2(1, .5)*iTime;\n  \n    // The jisaw pattern.\n    vec3 d = jigsaw(u);\n\n    // Some ID-based coloring.\n    //vec3 col = vec3(1, h21(d.yz)*.65 + .35, h21(d.yz + .5)*.7 + .3);\n    //col = mix(col.yzx, col, h21(d.yz + .2));\n    // Fabrice's addition, which uses IQ's palette formula: It's a subtly \n    // pleasant pastel palette. \n    vec3 col = .8 + .2*cos(6.3*h21(d.yz) + vec3(0, 23, 21));\n    // Etc.\n    //vec3 col = .5 + .4*cos(6.3*h21(d.yz) + vec3(0, 1, 2));\n    //vec3 col = .6 + .4*cos(6.*h21(d.yz) + vec3(1, 3, 5));\n\n\n    // Apply the jigsaw pattern.\n    col = mix(col, vec3(0), smoothstep(0., 8./R.y, d.x));   \n     \n    // Rough gamma correction.\n    fC = vec4(sqrt(col), 1);    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}