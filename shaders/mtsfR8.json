{
    "Shader": {
        "info": {
            "date": "1692626339",
            "description": "Water and air are continuous volumetric material, but many are made of opaque particles ( pigments, foliage... ).\nTrap: transparency in and out are correlated for in-out angles less than the angular size of occluders.\nFor real, T_tot = conditional proba",
            "flags": 0,
            "hasliked": 0,
            "id": "mtsfR8",
            "likes": 12,
            "name": "volumetric trap #2: \"Ti*ùõô*To\"",
            "published": 3,
            "tags": [
                "volumetric",
                "tuto",
                "short",
                "hotspot"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 278
        },
        "renderpass": [
            {
                "code": "// === volumetric trap: incoming and outcoming transparencies = not-independant probabilities\n//     ‚Üí hot spot effect. see https://www.google.com/search?q=hot+spot+BRDF&tbm=isch\n//       Or more precisely, opposition effect https://en.wikipedia.org/wiki/Opposition_surge\n//       E.g., visible on aerial views at antisolar locations, \n//             or in photos of forest/grass/sand/gravel at dusk/dawn in the antisolar direction.\n//       Not to be confused with Heiligenschein hotspot effect (droplet backscatter) https://en.wikipedia.org/wiki/Heiligenschein\n\n// see also    volumetric trap #1: \"density\":   https://shadertoy.com/view/mllBR8\n//             volumetric trap #3: dens vs occl https://www.shadertoy.com/view/clsfRN\n\n\n#define S(v,r)  smoothstep( 2./R.y, -2./R.y, length(v) - r )    // draw AA line\n#define C(r)    smoothstep( 6./R.y, 0., abs( length(C) - r ) )  // draw AA curve\n\nvec2 L(vec2 p, float a ) {                                      // distance vector to line (0,0) - (2cos(a),2sin(a))\n    vec2   b = 2.*sin( a +vec2(0,33));\n    return p - b * clamp(dot(p, b) / dot(b, b), 0., 1.); \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, A = R/R.y, F,I,\n          U = ( u+u - R ) / R.y,\n          C = U + vec2(.5*A.x, 1),                    // center of left referential\n          D = C; D.x = mod(U.x, A.x) - .5*A.x;        // center of left&right referentials ( for in/out rays )\n\n    float  i = 4., \n           r = .2/i,                                  // occluder radius\n           t = .8,                                    // medium transparency per unit length\n          ai = .6*sin(iTime),                         // incoming angle\n          ao = -.3;                                   // outgoing angle\n    \n    O = vec4( S( L( D, ao ) , .01 ) ,                 // red: outgoing ray\n              S( L( D, ai ) , .01 ) ,                 // green: incoming ray\n             0,0);\n    O += U.x < 0. && length(C) < 1.5                  // --- left: show configuration\n                ?  F = fract(U*i), I = floor(U*i),    // draw particles\n                   S( ( F -.8 + .6*fract(1e4*sin(I*mat2(R,71.-R)+i)) ) /i, .2/i )  \n                :  0. ; \n                \n    C.x -= R.x/R.y;                                   // --- right: show total transmittance\n    O.gb += C( pow(t,2.) );                           // cyan: assuming no correlation, Ttot = Tin*Tout = t¬≤\n    i = abs( atan(C.x,C.y) - ao ) / r,                // in-out occluding correlation\n    O.rg += C( pow(t, 2. - exp(-.5 *i*i ) ));         // yellow: Ttot = P( light in ) * P ( light out | could in ).\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}