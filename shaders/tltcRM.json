{
    "Shader": {
        "info": {
            "date": "1624005089",
            "description": "3d",
            "flags": 8,
            "hasliked": 0,
            "id": "tltcRM",
            "likes": 16,
            "name": "Fractal 59_gaz",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "gaz",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "// soundin shader by FabriceNeyret2\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n} // EOL soundin shader\n\n\n// +++++++++++++++++++++++\n\nvoid rot(inout vec3 p,vec3 a,float r){\n\ta=normalize(a);\n\tp=mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)  ;\n}\n\n#define sabs(p) sqrt((p)*(p)+1e-5)\n#define smin(a,b) (a+b-sabs(a-b))*.5\n#define smax(a,b) (a+b+sabs(a-b))*.5\n\nfloat dodec(vec3 p,float r){\n\tfloat G=sqrt(5.)*.5+.5;\n\tvec3 n=normalize(vec3(G,1,0));\n\tfloat d=0.;\n    p=sabs(p);\n    d=smax(d,dot(p,n));\n    d=smax(d,dot(p,n.yzx));\n    d=smax(d,dot(p,n.zxy));\n\treturn d-r;\n}\n\nfloat icosa(vec3 p,float r){\n\tfloat G=sqrt(5.)*.5+.5;\n\tvec3 n=normalize(vec3(G,1./G,0));\n\tfloat d=0.;\n    p=sabs(p);\n    d=smax(d,dot(p,n));\n    d=smax(d,dot(p,n.yzx));\n    d=smax(d,dot(p,n.zxy));\n\td=smax(d,dot(p,normalize(vec3(1))));\n    return d-r;\n}\n\n#define hash(p)fract(sin(p*12345.5))\n\nfloat stone(vec3 p)\n{\n  p.y-=iTime;\n    float c=2.;\n    vec3 e=floor(p/c);\n    e = sin(11.0*(2.5*e+3.0*e.yzx+1.345)); \n    p-=e*.6;\n    p=mod(p,c)-c*.5;\n    rot(p,hash(e+166.887)-.5,iTime*1.5); \n    if(hash(dot(e,vec3(.234,.24,98))+16776.887)<.5)\n    {\n        return min(.6,icosa(p,.12));    \n    }else{\n        return min(.6,dodec(p,.12));    \n    \n    }\n}\n\nfloat Scale;\nfloat obj(vec3 p){\n\trot(p,vec3(.5*cos(iTime*.2),2.*sin(iTime)*.4,sin(iTime*.5)),iTime*.5);\n\tfloat s=3.5;\n\tp=abs(p);\n\tvec3  off=p*mix(3.,45.,smoothstep(-.5,.97,cos(iTime*.5)));\n\tfor (int i=0; i<7; i++){\n        p=1.-abs(abs(p-2.)-1.); \n    \tfloat r=-3.*clamp(.68*max(1.2/dot(p,p),.7),0.,3.);\n        s*=r;\n\t\tp*=r;\n        p+=off;\n    }\n    s=abs(s);\n    Scale=s;\n    float a=18.;\n    p-=clamp(p,-a,a);\n\treturn length(cross(p,normalize(vec3(1,3,10))))/s;\n}\n\nfloat map(vec3 p){\n    float d=dot(p-vec3(0,-3,0),vec3(0,1,0))-1.5;\n    d=min(d,dot(p-vec3(0,0,-5),vec3(0,0,1)));\n    d= min(d,stone(p));\n    return min(d,obj(p));\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.005;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<200;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvec3 randVec(float s)\n{\n    vec2 n=hash(vec2(s,s+215.3));\n    return vec3(cos(n.y)*cos(n.x),sin(n.y),cos(n.y)*sin(n.x));\n}\n\nvec3 randCurve(float t,float n)\n{\n    vec3 p = vec3(0);\n    for (int i=0; i<3; i++){\n        p+=randVec(n+=365.)*sin((t*=1.3)+sin(t*.6)*.5);      \n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // call soundin shader \n\tif (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(0.05,0.1))*10.0);if(c>=0.){fragColor=vec4(c);return;}}\n\t\n    // ++++++++++\n\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,0,4.);\n    vec3 rd = normalize(vec3(uv,-2.0));\n    vec3 col = vec3(.7,.1,.0)*hash(dot(uv*3.,vec2(.1234,.566)));\n\tconst float maxd = 30.0;\n    float t = march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=cos(vec3(1,5,9)+log(Scale)*.5)*3.5+0.5;\n        col=vec3(1);\n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(5,28,10)*.5;\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li),.5,1.);\n        float sha = calcShadow(lightPos,-li,len);\n        col *= max(sha*dif, 0.4);\n        float rimd = pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn = rimd+2.2*(1.-rimd);\n    \tcol *= frn*.9;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += 2.*vec3(0.9,0.5,0.1)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 80.0);      \n        col = mix(vec3(.2,.3,.6),col,exp(-t*t*.002));\n    }\n    \n    vec3 pos;\n    for(float i=1.;i<250.;i++)\n    {\n        vec3 p=(vec3(hash(i*23.1234),hash(i*56.1234),hash(i*78.1234))*2.-1.)*vec3(5,1,3);\n        p+=randCurve(iTime*.5+hash(i*2256.1234)*1000.,(i+67.234)*345.99)*.5;\n        if(dot(rd,p-ro)<t)\n        {\n            float L=length(cross(rd,p-ro));\n            float weight=exp(-L*L*5.)*exp(-t*t*.01);\n            col = mix(col, vec3(1), weight*.4);\t\t\t\n        }\n    }\n    \n    col = pow(col,vec3(2.));\n    fragColor.xyz = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// +++++++++++++++++++++++\n\n#define bpm 95.\n#define key D\n#define scale Major_scale\n\n// == seqence == +++++++++++++\n\nfloat NOTETIME;\nint NUMBER;\nfloat VEROCITY;\n\nfloat BEAT = 30. / bpm; // 8 Beat\nfloat SUM;\nfloat TIME;\n\nvoid seq(int number, float noteValue, float velocity){\n    float tmp = noteValue * BEAT;\n    if(SUM <= TIME){\n        NOTETIME = min(tmp, TIME - SUM);\n        NUMBER = number;\n        VEROCITY = velocity;\n        if(number == 255){\n            NOTETIME = 100.;\n            NUMBER = 0;\n        }\n    }\n    SUM += tmp;\n}\n\n#define Q(p,v) seq(p,float(v), 1.);\n#define S(p,v,s) seq(p,float(v), s);\n#define T(v) seq(0,float(v), 1.);\n#define U(v,s) seq(0,float(v), s);\n#define R(v) seq(255,float(v), 1.);\n\n#define REP(n) TIME=mod(time, BEAT * float(n));\n#define FOR(n) for(int i=0;i<n;i++){\n#define END }\n#define RESET SUM = 0.;\n\n// \n\n// ++ Chord fuctions +++++++++++++++++++++\nint packChord(int root, ivec3 t, int inv)\n{\n    int[3] a;\n    for(int i=0;i<3;i++){\n       a[i]=root+int[](t[1]-12,t[2]-12,t[0],t[1],t[2])[i+2-inv];\n    }\n    return a[0]+(a[1]<<7)+(a[2]<<14)+(127<<21);\n}\n\nint packChord(int root, ivec4 t, int inv)\n{\n    int[4] a;\n    for(int i=0;i<4;i++){\n       a[i]=root+int[](t[1]-12,t[2]-12,t[3]-12,t[0],t[1],t[2],t[3])[i+3-inv];\n    }\n    return a[0]+(a[1]<<7)+(a[2]<<14)+(a[3]<<21);\n}\n\n#define unpack4x7(i) ivec4(i&127,i>>7&127,i>>14&127,i>>21&127)\n\n// +++++++++++++++++++++\n\n// OSC\n#define osc_sin(x) sin((x)*6.2832)\n#define osc_saw(x) (1.0-fract(x)*2.0)\n#define osc_sqr(x) sign(0.5-fract(x))\n#define osc_tri(x) asin(sin((x)*6.2832))/1.5708\n\nfloat note2freq(int n){\n  return 440.*exp2((float(n)-69.)/12.);\n}\n\n// Note numbers\n#define C  60\n#define Cs 61\n#define D  62\n#define Ds 63\n#define E  64\n#define F  65\n#define Fs 66\n#define G  67\n#define Gs 68\n#define A  69\n#define As 70\n#define B  71\n#define UP +12\n#define DN -12\n\n\n//Chord types\n#define _M    ivec3(0,4,7)\n#define _m    ivec3(0,3,7)\n#define _6    ivec4(0,4,7,9)\n#define _7    ivec4(0,4,7,10)\n#define _M7   ivec4(0,4,7,11)\n#define _m7   ivec4(0,3,7,10)\n#define _add9 ivec4(0,4,7,14)\n#define _sus2 ivec3(0,2,7)\n#define _sus4 ivec3(0,5,7)\n#define _dim  ivec3(0,3,6)\n// #define _dim  ivec4(1,4,7,_)\n#define _aug  int[](0,4,8)\n\n// Scale\n#define Major_scale          int[](0,2,4,5,7,9,11)\n#define Minor_scale          int[](0,2,3,5,7,8,10)\n#define Natural_minor_scale  int[](0,2,3,5,7,8,10)\n#define Harmonic_minor_scale int[](0,2,3,5,7,8,11)\n#define Melodic_minor_scale  int[](0,2,3,5,7,9,11)\n\n#define P(n) key + scale[(n-1)%7] + (n-1)/7*12\n#define H(r,t,i) packChord(key+scale[r-1],t,i)\n\n// ++ sound srouce ++++++++++++++++\n// FM operator -> vec4(Level,Maltiple,Detune,Envelope),operator\n#define FM(a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p) mat4 DAT=mat4(a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p);\n\n#define OP(a,i) a.x*osc_sin(a.y*exp2(log2(f)+a.z/12.)*t+i)*exp(-t*5./a.w)\n\n#define O1(i) OP(DAT[0], i)\n#define O2(i) OP(DAT[1], i)\n#define O3(i) OP(DAT[2], i)\n#define O4(i) OP(DAT[3], i)\n    \n#define A0(F) O4(O3(O2(O1(F*O1(0.)))))\n#define A1(F) O4(O3(O2(0.)+O1(F*O1(0.))))\n#define A2(F) O4(O3(O2(0.))+O1(F*O1(0.)))\n#define A3(F) O4(O3(0.)+O2(O1(F*O1(0.))))\n#define A4(F) O4(O3(0.))+O2(O1(F*O1(0.)))\n#define A5(F) O4(O1(F*O1(0.)))+O3(O1(F*O1(0.)))+O2(O1(F*O1(0.)))\n#define A6(F) O4(0.)+O3(0.)+O2(O1(F*O1(0.)))\n#define A7(F) O4(0.)+O3(0.)+O2(0.)+O1(F*O1(0.))\n\n \nfloat gNoize(float t, float a, float b, float c){\n    float g=fract(sin((t+exp2(a))*exp2(b))*exp2(c))+6.0;\n    return exp(-0.08*g*g) *40.0-1.;\n}\n\nfloat kick(float t){\n   return (sin(pow(1.0-min(1.0,t*3.5),15.0)*55.0+1.2)*exp(-t*3.0)\n    +0.3*sign(0.5-fract(70.0*t))*exp(-t*25.0))\n    *cos(120.0*exp(-t*2.0));\n}\n\nfloat snare(float t){\n    float n=gNoize(t,0.,10.,10.)*exp(-t*10.);\n    float f=t*160.;\n    float m2=.3*osc_tri(1.2*f)*exp(-t*3.);\n    float m1=.05*osc_sin(10.*f+m2)*exp(-t*3.);\n    float c=osc_sin(f+m1)*exp(-t*15.);\nreturn n+c;\n}\n\nfloat hihat(float t)\n{\n    return gNoize(t,0.,10.,18.)*exp(-t*15.);\n}\n\nfloat lead(float t, float f)\n{\n    FM(\n      .2, 1., 0., 2.,\n      .4, 2., .1, 3.,\n      .5, 3., 0., 3.,\n      .7, 1., 0., 3.\n    );\n    return A4(5.0);\n}\n\nfloat piano(float t,float f){\n    float g=0.,a,b=0.;\n    f*=t;\n    for(float j=1.;j<8.;j++){\n        b+=a=exp(-j*.5);\n        g+=a*osc_sin(f*j)*exp(-t*1.5/(1.-j*.1));\n    }\n    g*=1.+1.5*exp(-5.*t);\n    return g/b;\n}\n\nfloat base(float t,float f)\n{\n\tf *= t;\n  \treturn clamp((\n        5.0*osc_sin(f)\n        + 2.0*osc_sin(f*2.0)\n        + osc_tri(f*3.0)\n    \t)/4.0,-1.0,1.0)*exp(-5.0*t);\n}\n\n\n// ++ tracks +++++++++++++++++++++++++\n\n// kick\nfloat track1(float time){\n    RESET\n    REP(8)\n    T(2)T(2)T(2)T(2)\n    \n    return kick(NOTETIME);  \n}\n\n// snare\nfloat track2(float time){\n  RESET\n  REP(8*4)\n  FOR(7)\n    R(2)T(2)\n  END\n  R(1)T(1)T(1)T(1)\n  \n  return snare(NOTETIME);  \n}\n\n// hihat\nfloat track3(float time){\n  RESET\n  REP(8)\n  T(1)T(1)U(1, 2.)T(1)\n  T(1)T(1)U(1, 2.)T(1)\n  \n  return hihat(NOTETIME);  \n}\n\nfloat track4(float time, out ivec4 chord){\n    \n  RESET\n  REP(8*4)\n  Q(H(4,_M7,0),8)\n  Q(H(5,_7,0),8)\n  Q(H(3,_m7,0),8)\n  Q(H(6,_m7,0),8)\n  \n  chord = unpack4x7(NUMBER);\n  float gain=0.;\n  for(int i=0;i<4;i++){\n    if(chord[i]<127)\n        gain += 0.3*piano(NOTETIME,note2freq(chord[i]-12));\n  }\n  return gain;  \n}\n\nfloat track5(float time, ivec4 chord){\n    RESET\n    REP(4)\n    Q(chord[0]-24, 1)\n    Q(chord[0]-12, 1)\n    Q(chord[0]-24, 1)\n    Q(chord[0]-12, 1)\n\n    return base(NOTETIME,note2freq(NUMBER));\n}\n\nfloat track6(float time){\n    RESET\n    REP(32)\n    Q(1,1)\n    Q(5,2)\n    Q(6,1)\n    Q(8,1)\n    Q(2,2)\n    Q(3,1)\n    Q(4,1)\n    Q(1,1)\n    Q(5,2)\n    Q(6,1)\n    Q(8,1)\n    Q(2,2)\n    Q(3,1)\n    Q(5,1) \n    Q(1,1)\n    Q(5,2)\n    Q(6,1)\n    Q(8,1)\n    Q(2,2)\n    Q(3,1)\n    Q(4,1)\n    Q(1,1)\n    Q(5,2)\n    Q(6,1)\n    Q(8,1)\n    Q(2,2)\n    Q(6,1)\n    Q(3,1)\n \n    return lead(NOTETIME, note2freq(P(NUMBER)));\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 gain = vec2(0);\n    gain += vec2(.2)* track1(time); // kick\n    gain += vec2(.2)* track2(time); // snare\n    gain += vec2(.2)* track3(time); // hihat\n    ivec4 chord;\n    gain += vec2(.2)* track4(time, chord); // chord\n    gain += vec2(.15)* track5(time, chord); // base\n    gain += vec2(.1)* track6(time); // lead\n    \n    return gain;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}