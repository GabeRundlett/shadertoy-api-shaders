{
    "Shader": {
        "info": {
            "date": "1579127718",
            "description": "I stream shader creation live, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/536586403[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wlVGDm",
            "likes": 43,
            "name": "[twitch] Four Regular Solids",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "escher",
                "polyhedra",
                "twitch"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 1189
        },
        "renderpass": [
            {
                "code": "/*\n    This shader was created live on stream!\n    You can watch the VOD here: https://www.twitch.tv/videos/536586403\n\n    I use the Bonzomatic tool by Gargaj/Conspiracy:\n    https://github.com/Gargaj/Bonzomatic\n\n    I stream at https://twitch.tv/lunasorcery\n    Come and watch a show!\n\n    ~yx\n*/\n\nfloat phi = (1.+sqrt(5.))*.5;\n#define spinSpeed (iTime*.5)\n\nmat2 rotate(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts,c\n\t);\n}\n\nfloat sdIcosahedron(vec3 p, float r)\n{\n\tfloat q = (sqrt(5.)+3.)/2.;\n\n\tvec3 n1 = normalize(vec3(q,1,0));\n\tvec3 n2 = vec3(sqrt(3.)/3.);\n\n\tp = abs(p/r);\n\tfloat a = dot(p, n1.xyz);\n\tfloat b = dot(p, n1.zxy);\n\tfloat c = dot(p, n1.yzx);\n\tfloat d = dot(p, n2.xyz)-n1.x;\n\treturn max(max(max(a,b),c)-n1.x,d)*r;\n}\n\nfloat sdDodecahedron(vec3 p, float r)\n{\n\tp = abs(p);\n\tp += phi*p.zxy;\n\treturn (max(max(p.x,p.y),p.z)-r*phi) / sqrt(phi*phi+1.);\n}\n\n\nfloat sdRhombicTriacontahedron(vec3 p, float r)\n{\n    float l = phi*2.;\n    \n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z);\n    p += (p+p.yzx)*phi+p.zxy;\n    return max(a, max(p.x,max(p.y,p.z))/l)-r;\n}\n\nfloat sdHexahedron(vec3 p, float r)\n{\n    p = abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdOctahedron(vec3 p, float r)\n{\n    return (dot(abs(p),vec3(1))-r)/sqrt(3.);\n}\n\nfloat sdRhombicDodecahedron(vec3 p, float r)\n{\n    p = abs(p);\n    p += p.yzx;\n    return (max(max(p.x,p.y),p.z)-r) * sqrt(.5);\n}\n\n\nint mat,matHack;\nfloat scene1(vec3 p)\n{\n\tp.xz *= rotate(spinSpeed);\n\t\n\tfloat dodec = sdDodecahedron(p,1.);\n\tfloat icos = sdIcosahedron(p.zyx,1.);\n\t\n\tfloat unity = min(dodec,icos);\n\tfloat intersect = max(dodec,icos);\n\t\n\tfloat innerEdges = max(intersect-.004, -unity);\n\tfloat outerEdges = max(unity-.001, -sdRhombicTriacontahedron(p.zyx,1.));\n\t\n\tfloat best = unity;//min(union,min(outerEdges, innerEdges));\n\tif (best == dodec)\n\t\tmatHack = 0;\n\telse if (best == icos)\n\t\tmatHack = 1;\n\telse if (best == outerEdges)\n\t\tmatHack = 2;\n\telse\n\t\tmatHack = 3;\n\treturn best;\n}\n\nfloat scene2(vec3 p)\n{\n\tp.xz *= rotate(spinSpeed);\n\t\n\tfloat hexa = sdHexahedron(p,.5);\n\tfloat octa = sdOctahedron(p,1.);\n\t\n\tfloat unity = min(hexa, octa);\n\tfloat intersect = max(hexa, octa);\n\t\n\tfloat innerEdges = max(intersect-.004, -unity);\n\tfloat outerEdges = max(unity-.001, -sdRhombicDodecahedron(p.zyx,1.));\n\t\n\tfloat best = unity;//min(union,min(outerEdges, innerEdges));\n\tif (best == hexa)\n\t\tmatHack = 4;\n\telse if (best == octa)\n\t\tmatHack = 5;\n\telse if (best == outerEdges)\n\t\tmatHack = 6;\n\telse\n\t\tmatHack = 7;\n\treturn best;\n}\n\nvec3 hatching(vec2 uv, vec2 dir, vec3 n, vec3 darkCol, vec3 lightCol, float density, float fade, float ao)\n{\n\tuv *= density;\n\tfloat light = dot(n,normalize(vec3(1,3,1)))*.5+.5;\n\tlight *= ao;\n\tlight += fade;\n\t//return vec3(light);\n\tlightCol = mix(lightCol,vec3(1),fade);\n\tfloat p = dot(uv, normalize(dir));\n\tfloat d = abs(fract(p)-.5)+(light*.5-.5);\n\tfloat e = dFdy(uv.y);//(density/80.)*.1;\n\treturn darkCol + smoothstep(-e,e,d) * (lightCol-darkCol);\n}\n\nfloat screenHatching(vec2 uv, vec2 dir, float light)\n{\n\tfloat p = dot(uv, normalize(dir));\n\tfloat d = abs(fract(p)-.5)+(light*.5-.5);\n\tfloat e = dFdy(uv.y);//.1;\n\treturn smoothstep(-e,e,d);\n}\n\nvec3 shade(vec2 uv, vec3 n, float ao)\n{\n\tfloat fade = sin(iTime*.5)*.5+.5;\n\t\n\tif (mat == 3) {\n\t\treturn mix(vec3(0),vec3(1),fade);\n\t} else if (mat == 2) {\n\t\treturn vec3(1);\n\t} else if (mat == 1) {\n\t\treturn hatching(uv, vec2(1,.5), n, vec3(0), vec3(1), 80., fade, ao);\n\t} else if (mat == 0) {\n\t\treturn hatching(uv, vec2(.5,-1), n, vec3(0), vec3(1/*,.7,.5*/), 80., fade, ao);\n\t} else if (mat == 7) {\n\t\treturn vec3(1,0,0);\n\t} else if (mat == 6) {\n\t\treturn vec3(1,0,0);\n\t} else if (mat == 5) {\n\t\treturn hatching(uv, vec2(1,-.1), n, vec3(1,0,0), vec3(1), 200., (1.-fade)*.3, ao);\n\t} else if (mat == 4) {\n\t\treturn hatching(uv, vec2(.1,1), n, vec3(1,0,0), vec3(1), 200., (1.-fade)*.3, ao);\n\t}\n}\n\nvec3 trace1(vec3 cam, vec3 dir, vec2 uv)\n{\n\tfloat t=0.;\n\tfloat k=0.;\n\tfor(int i=0;i<100;++i) {\n\t\tk = scene1(cam+dir*t);\n\t\tt += k;\n\t\tif (abs(k)<.001)\n\t\t\tbreak;\n\t}\n\tmat = matHack;\n\t\n\tif (abs(k)<.001)\n\t{\n\t\tvec3 h = cam+dir*t;\n\t\tconst vec2 o = vec2(0.001,0);\n\t\tvec3 n = normalize(vec3(\n\t\t\tscene1(h+o.xyy)-scene1(h-o.xyy),\n\t\t\tscene1(h+o.yxy)-scene1(h-o.yxy),\n\t\t\tscene1(h+o.yyx)-scene1(h-o.yyx)\n\t\t));\n\t\t\n\t\tfloat aoDist = scene1(h+n*.2);\n\t\tfloat ao = pow(aoDist/.2,.8);\n\t\t\n\t\treturn shade(uv, n, ao);\n\t}\n\treturn vec3(1);\n}\n\nvec3 trace2(vec3 cam, vec3 dir, vec2 uv)\n{\n\tfloat t=0.;\n\tfloat k=0.;\n\tfor(int i=0;i<100;++i) {\n\t\tk = scene2(cam+dir*t);\n\t\tt += k;\n\t\tif (abs(k)<.001)\n\t\t\tbreak;\n\t}\n\tmat = matHack;\n\t\n\tif (abs(k)<.001)\n\t{\n\t\tvec3 h = cam+dir*t;\n\t\tconst vec2 o = vec2(0.001,0);\n\t\tvec3 n = normalize(vec3(\n\t\t\tscene2(h+o.xyy)-scene2(h-o.xyy),\n\t\t\tscene2(h+o.yxy)-scene2(h-o.yxy),\n\t\t\tscene2(h+o.yyx)-scene2(h-o.yyx)\n\t\t));\n\t\t\n\t\tfloat aoDist = scene2(h+n*.2);\n\t\tfloat ao = pow(aoDist/.2,.5);\n\t\t\n\t\treturn shade(uv, n, ao);\n\t}\n\treturn vec3(1);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 cam = vec3(0,0,-5);\n\tvec3 dir = normalize(vec3(uv,1.5));\n\t\n\tcam.yz *= rotate(0.2);\n\tdir.yz *= rotate(0.2);\n\t\n\tvec3 color1 = trace1(cam, dir, uv);\n\tvec3 color2 = trace2(cam, dir, uv);\n\t\n\tfragColor.rgb = clamp(color1*color2,0.,1.);\n\tfragColor.rgb *= mix(vec3(0), vec3(1), screenHatching(uv*80., vec2(1,4), 1.3-dot(uv,uv)*.5));\n\tfragColor.rgb = mix(vec3(.2), vec3(1,.9,.8), fragColor.rgb);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}