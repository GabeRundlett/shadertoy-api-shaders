{
    "Shader": {
        "info": {
            "date": "1647889812",
            "description": "Porting [url=https://stackoverflow.com/a/70846528/230851]Robert Bruce's C++ math[/url] to GLSL.\nExcept for the local function it basically a copy-paste.  Check out what's going on with #define, in the Common tab!",
            "flags": 0,
            "hasliked": 0,
            "id": "7lXcW8",
            "likes": 13,
            "name": "sphere from 4 points",
            "published": 3,
            "tags": [
                "sphere",
                "points",
                "fit"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "// Fitting a sphere to four points.\n// Copy of Robert Bruce's math on SO:\n// https://stackoverflow.com/a/70846528/230851\n//\n// I was mostly curious to see how the novel use of #define\n// would port into GLSL, and it ported just fine.\n//\n// See sphereFromFourPoints() in the \"Common\" tab.\n//\n//////////////////////////////////////////////////\n\n// Fork of \"Ordinary Glass, with Comments\" by elenzil. https://shadertoy.com/view/7dlBRf\n// 2022-03-19 02:59:18\n\n\n// the maximum number of simultaneous rays in the backlog.\n// the number of rays per pixel can be more than this.\nconst uint  gMaximumRaysInQueue = 10u;\n\n// a ray must have at least this much contribution left to be enqueued.\nconst float gMinimumRayContribution = 0.005f;\n\n// #define HEATMAP\n\n\nstruct ray_t {\n    // origin\n    vec3  ro;\n    \n    // direction\n    vec3  rd;\n    \n    // what amount of the pixel this ray is contributing. [0, 1]\n    float contribution;\n    \n    // whether this ray is on the inside of the SDF.\n    bool  internal;\n};\n\n\n////////////////////////////////////////////////////////////////////////////\n// This section of code implements a ring-buffer queue for holding rays.\n// Using a queue of rays instead of a stack\n// because earlier child-rays are more important than later.\n// ie, if we used a stack, the less-contributing rays would get processed\n// earlier than the more-contributing rays, eating up our budgets.\n// This is a pretty standard implementation of a ring-buffer, not special to GLSL.\n// The only difference from an implementation in say C++ is no error-checking!\n\n// my kingdom for templates in GLSL..\n#define QTYPE ray_t\nconst uint gQCapacity = gMaximumRaysInQueue;\nconst uint gQNumSlots = gQCapacity + 1u;\nQTYPE gQ[gQNumSlots];\nuint gQHead = 0u;\nuint gQTail = 0u;\n\n// the number of items in the queue\nuint QCount() {\n\tif (gQHead >= gQTail) {\n\t\treturn gQHead - gQTail;\n\t}\n\telse {\n\t\treturn gQNumSlots - (gQTail - gQHead);\n\t}\n}\n\n// the remaining capacity of the queue\nuint QSpaceLeft() {\n\treturn gQCapacity - QCount();\n}\n\nbool QIsFull() {\n\treturn QSpaceLeft() == 0u;\n}\n\nbool QIsEmpty() {\n\treturn QCount() == 0u;\n}\n\n// add an item to the head of the queue.\n// only call this if the queue is not empty !\nvoid QEnqueue(QTYPE item) {\n\tgQHead = (gQHead + 1u) % gQNumSlots;\n\tgQ[gQHead] = item;\n}\n\n// pull an item off the tail of the queue.\n// only call this if the queue is not empty !\nQTYPE QDequeue() {\n\tgQTail = (gQTail + 1u) % gQNumSlots;\n\treturn gQ[gQTail];\n}\n\n// conditionally add a ray to the queue\nbool addRay(in ray_t ray) {\n    if (QIsFull()) {\n        return false;\n    }\n    if (ray.contribution < gMinimumRayContribution) {\n        return false;\n    }\n    QEnqueue(ray);\n    return true;\n}\n\n// do not call this if the queue is empty !\nray_t popRay() {\n    return QDequeue();\n}\n\n// this section has a bunch of globals which are configured once per pixel per frame,\n// and then re-used multiple times.\n// for example, rotation matrices used in the core map() function.\n// I haven't noticed other people doing this, perhaps there's a reason..\nfloat gViewTheta = 0.0;\nvec3  gSceneCenter = gVy * 8.0;\nfloat gRounding = 0.075;\nvec3  gLightDirection = normalize(vec3(1.0, -2.0, 1.0));\nfloat gUnderStepFactor = 1.0;\nvec2  gRes;\nbool  gDoStereo = false;\nfloat gMouseTargetRad = 50.0;\n\nfloat gSSZoom;\nvec2  gM;\n\n// map globals\nvec3  gBallPositions[4];\nfloat gBallRad;\nvec3  gCenterBallPos;\nfloat gCenterBallRad;\n\n\n\n// the maximum number of steps to raymarch.\nint   gMaxMarchStepsExternal = 250;\nint   gMaxMarchStepsInternal = 200;\n\n// more configuration.\nvoid configGlobals0() {\n    gMouseTargetRad = 50.0;\n}\n\nvoid configGlobals1() {\n    gSSZoom = 1.5;\n\n    gT = iTime * PI / 10.0;\n    gSSEps  = 3.0/MINRES/gSSZoom;\n    gSSLw   = 2.0/MINRES/gSSZoom;\n\n    vec2 M = iMouse.xy;\n    if (gDoStereo || length(M) < gMouseTargetRad) {\n        M = (vec2(cos(gT * 0.751) * 0.8, cos(gT * 0.631)) * 0.4 + 0.4) * gRes.xy;\n    };\n    gM = M / gRes.xy;\n    gViewTheta = gM.x * PI * 2.0 + 2.0;\n}\n\n// a variable to track the number of calls to map().\n// this can be displayed as a 'heat map'.\nfloat gMapCalls = 0.0;\n\n// pre-calculate values which are used in the core map() sdf function.\nvoid configMap() {\n    \n    gBallRad = 0.5;\n        \n    for (int n = 0; n < gBallPositions.length(); ++n) {\n        float height = float(n + 4) * 2.123;\n        float v0     = sqrt(2.0 * height);\n        float period = 2.0 * v0;\n        float t      = mod(gT * 3.0 + period / 2.0, period);\n        float y      = v0 * t - t * t / 2.0;\n        y += gBallRad;\n        \n        vec3 p = vec3(float(n / 2), 0.0, float(n % 2));\n        p   -= 0.5;\n        p   *= 6.0;\n        p.y  = y;\n        gBallPositions[n] = p;\n    }\n    \n    vec4 sphere = sphereFromFourPoints(\n        gBallPositions[0],\n        gBallPositions[1],\n        gBallPositions[2],\n        gBallPositions[3]);\n        \n    gCenterBallPos = sphere.xyz;\n    gCenterBallRad = sphere.w;\n}\n\nvec2 selMin(in vec2 A, in vec2 B) {\n    return A.x < B.x ? A : B;\n}\n\n// the core signed-distance-function routine.\nvec2 map(vec3 p) {\n    gMapCalls += 1.0;\n    \n    float ballMinY = 1e9;\n    float d2 = 1e9;\n    for (int n = 0; n < gBallPositions.length(); ++n) {\n        float l = length(gBallPositions[n] - p);\n        d2 = min(d2,   l - gBallRad);\n        d2 = max(d2, -(l - gBallRad * 0.94));\n        ballMinY = min(ballMinY, gBallPositions[n].y);\n    }\n    \n    float d1 = p.y;\n    d1 += 0.2 * smoothstep(gBallRad * 1.5, gBallRad * 1.0, ballMinY);\n    \n    \n    float d3 = 1e9;\n    float l = length(gCenterBallPos - p);\n    d3 = min(d3,   l - gCenterBallRad);\n    d3 = max(d3, -(l - gCenterBallRad * 0.98));\n\n    \n    vec2 ret = vec2(1e9);\n    \n    ret = selMin(ret, vec2(d1, 1.0));\n    ret = selMin(ret, vec2(d2, 2.0));\n    ret = selMin(ret, vec2(d3, 3.0));\n    \n    return ret;\n}\n\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*gWSEps).x;\n    }\n    return normalize(n);\n}\n\n// return a ray from the camera through our pixel and into the scene.\n// uv should be 0 in the center of the viewport, not 0.5.\nray_t getCamRay(vec2 uv, bool isLeftEye) {\n\n    ray_t ray;\n    \n    float stereoSep = -0.9 * (isLeftEye ? -1.0 : 1.0);\n    \n    // this seed ray is the whole contribution of the pixel!\n    // .. or at least it is until I add anti-aliasing.\n    ray.contribution = 1.0;\n\n    float zoomFac = 0.7;\n\n    // look-from and look-to.\n    vec3  lookSrc = vec3(cos(gViewTheta), (1.4 - gM.y * 1.3) * 4.0/3.0, sin(gViewTheta)) * 20.0;\n    vec3  lookDst = gSceneCenter;\n    \n    // construct an orthobasis for the camera. altho I don't turn it into an actual matrix.\n    vec3  camFw   = normalize(lookDst - lookSrc);\n    vec3  camRt   = normalize(cross(camFw, gVy));\n    vec3  camUp   = cross(camRt, camFw);\n    \n    lookSrc += camRt * stereoSep;\n    camFw   = normalize(lookDst - lookSrc);\n    camRt   = normalize(cross(camFw, gVy));\n    camUp   = cross(camRt, camFw);\n    \n\n    \n    // determine a 'look to' point for this specific pixel.\n    // gV0 is vec3(0).\n    vec3  p       = gV0;\n    p            += lookSrc;\n    p            += camFw;\n    p            += camRt * uv.x * zoomFac;\n    p            += camUp * uv.y * zoomFac;\n    \n    // copy it to the ray.\n    ray.ro        = lookSrc;\n    ray.rd        = normalize(p - ray.ro);\n    \n    // if the camera is initially inside an object, things are going to look weird,\n    // but at least this gives them a shot at correctness.\n    ray.internal  = map(p).x < 0.0;\n    \n    return ray;\n}\n\n// ordinary raymarching.\n// return distance along ray to nearest intersection.\n// also returns the minimum distance from the ray to a surface. ie, often 0.\nvec2 marchExternal(vec3 ro, vec3 rd, out float minD) {\n    float t = 0.0;\n    minD = 1e9;\n    \n    vec3 p;\n    for (int n = 0; n < gMaxMarchStepsExternal && (dot(p, p) < 1e4); ++n) {\n        p = ro + rd * t;\n        vec2 mr = map(p);\n        float d = mr.x;\n        minD = min(minD, d);\n        if (d < gWSEps) {\n            minD = 0.0;\n            return vec2(t, mr.y);\n        }\n        \n        t += d * gUnderStepFactor;\n    }\n    \n    return vec2(1e9);\n}\n\n// raymarching in the negative side of the SDF.\nvec2 marchInternal(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    \n    for (int n = 0; n < gMaxMarchStepsInternal && t < 1e2; ++n) {\n        vec3  p = ro + rd * t;\n        vec2 mr = map(p);\n        float d = mr.x;\n        if (d > -gWSEps) {\n            return vec2(t, mr.y);\n        }\n\n        t -= d * gUnderStepFactor;\n    }\n    \n    return vec2(1e9);\n}\n\n// a function for some 'sky'. takes direction only, no positon.\n// could be replaced with a cubemap.\nvec3 sky(vec3 dir) {\n    float theta = atan(dir.z, dir.x);\n    vec3 rgb = abs(dir);\n    float absst = abs(sin(theta * 10.0 ));\n    rgb = mix(rgb, vec3(1.0), 0.2 * smoothstep(0.05, 0.0, absst - 0.2));\n    rgb *= mix(1.0, smoothstep(-0.1, 0.1, dir.y), 0.7);\n    rgb = mix(rgb, vec3(rgb.x + rgb.y + rgb.z) / 3.0, absst);\n    return rgb;\n}\n\n// takes a ray off the queue, marches it, potentially adds children to the queue.\n// repeats indefinitely until either the queue is empty or we pass a limit.\n// in a recursive implementation this would be \"processRay()\", and would call itself.\nvec3 processRays() {\n\n    // rgb is the output pixel color. start with black.\n    vec3 rgb = gV0;\n    \n    // track how many rays we've processed.\n    // stop when either that number is too large,\n    // or when the queue is empty.\n    uint processingIter;\n    for (processingIter = 0u;\n        processingIter < gQCapacity * 3u && !QIsEmpty();\n        ++processingIter) {\n        \n        // take the oldest ray out of the queue.\n        // on the first call to this method, there is only one ray in the queue,\n        // so the queue is empty after this call.\n        ray_t ray = popRay();\n        \n        // march either external or internal, depending on the ray.\n        vec2 mr;\n        if (ray.internal) {\n            mr = marchInternal(ray.ro, ray.rd);\n        }\n        else {\n            float _unused;\n            mr = marchExternal(ray.ro, ray.rd, _unused);\n        }\n        \n        float distanceAlongRayToSurface = mr.x;\n        \n        // if the returned distance is \"near\", call it a surface.\n        // if it's \"far\", call it the sky.\n        if (distanceAlongRayToSurface < 1e4) {\n        \n            // the position of the intersection\n            vec3  p    = ray.ro + distanceAlongRayToSurface * ray.rd;\n            vec3  grad = getNormal(p);\n            vec3  n    = grad;\n            \n            // If the ray is internal,\n            // we need to adjust the normal to point inwards.\n            // We also attenuate the ray's contribution according\n            // to how much material the ray passed through.\n            if (ray.internal) {\n                // surface normal is from the gradient, so flip it.\n                n = -n;\n                \n                // attenuation\n                ray.contribution *= exp(-1.0 * distanceAlongRayToSurface);\n            }\n            \n            bool isFloor = mr.y == 1.0;\n            \n            // diffuse component\n            float diffAmt = 1.0;\n            diffAmt = mr.y == 1.0 ? 0.9 : diffAmt;\n            diffAmt = mr.y == 2.0 ? 0.9 : diffAmt;\n            diffAmt = mr.y == 3.0 ? 0.1 : diffAmt;            \n            \n            // dot the surface normal with our light direction\n            float diff = max(0.0, dot(n, -gLightDirection));\n            \n            // shadows\n            // only do these if there's a point.\n            if (diff * diffAmt * ray.contribution > 0.01) {\n                // for shadows we march towards the light\n                // and take advantage of the ease with which raymarching\n                // tells you approximately how close you came to any surface,\n                // and use that for a little soft shadowing.\n                // Soft shadowing tends to being out the artifacts in raymarching,\n                // so we understep significantly.\n                // Don't forget to offset the initial point from the surface by a bit,\n                // and not to use 'n' for that, because for internal rays it points inward.\n                float minD;\n                const float penumbra = 0.1;\n                float saveUnderStep = gUnderStepFactor;\n                int   saveMaxSteps  = gMaxMarchStepsExternal;\n                gMaxMarchStepsExternal = 200;\n                gUnderStepFactor *= 0.3;\n                marchExternal(p + grad * (penumbra + 0.01), -gLightDirection, minD);\n                diff *= smoothstep(0.0, penumbra, minD);\n                gUnderStepFactor = saveUnderStep;\n                gMaxMarchStepsExternal = saveMaxSteps;\n            }\n            \n            // almost done with diffuse shading.\n            // calculate albedo, the inherent color of the surface.\n            // it's white for glass, and patterned for the floor.\n            // note this is still modulated by the 'diffAmt' factor.\n            vec3 albedo = gV1 * 0.5;\n            if (isFloor) {\n                float x = abs(cos(p.z)) - 0.5 * -cos(p.x * 1.5);\n                x = sqrt(x);\n                albedo = gV1 * 0.4 * smoothstep(0.49, 0.51, x) + 0.05;\n                albedo *= 0.3;\n                albedo.r *= 0.5;\n            }\n            \n            // ambient light.\n            // it's good to add in some of this\n            // so that albedo texture that's in shadow isn't lost.\n            diff = max(0.04, diff);\n            \n            // add the diffuse lighting to the pixel.\n            rgb += diff * ray.contribution * diffAmt * albedo;\n            \n            // add rays for reflection and transmission\n\n            // \"eta\" is the greek letter Î·.\n            // it's the ratio of the two indices of refraction of the mediums.\n            // eg, air to glass.\n            // we animate the index of refraction a little,\n\n            const float ior_air     = 1.0003;\n            const float ior_water   = 1.333;\n            const float ior_quartz  = 1.46;\n            const float ior_diamond = 2.42;\n\n            float eta = ior_air / ior_diamond;\n\n            // if we're transitioning from inside to outside,\n            // eta should be inverted.\n            if (ray.internal) {\n                eta = 1.0 / eta;\n            }\n\n            // The next chunk of code determines the contributions\n            // of the reflected and refracted rays.\n\n            // this is the portion of the ray contribution left for\n            // reflection and refraction, after whatever diffuse used up.\n            float reflectAndRefractAmt = 1.0 - diffAmt;\n\n            // this is what portion of the reflect/refract portion is reflect vs. refract.\n            // 0 = all reflection, no transmission\n            // 1 = all transmission, no reflection\n            float reflectVsRefract = 0.0;\n            reflectVsRefract = mr.y == 1.0 ? 0.0 : reflectVsRefract;\n            reflectVsRefract = mr.y == 2.0 ? 0.0 : reflectVsRefract;\n            reflectVsRefract = mr.y == 3.0 ? 0.9 : reflectVsRefract;\n            \n\n            // glsl conveniently provides these helpers:\n            vec3  reflectDir = reflect(ray.rd, n);\n            vec3  refractDir = refract(ray.rd, n, eta);\n\n            // refract() returns 0 if there's total internal reflection.\n            // it's critical to handle this case because it's common.\n            bool totalInternal = dot(refractDir, refractDir) == 0.0;\n\n            // no transmission if total internal reflection.\n            // no transmission for the floor\n            if (isFloor || totalInternal) {\n                reflectVsRefract = 0.0;\n            }\n\n            // The portion of the contribution for reflection and transmission\n            float reflectAmt = reflectAndRefractAmt * (1.0 - reflectVsRefract);\n            float refractAmt = reflectAndRefractAmt * reflectVsRefract;\n            float reflectContribution = ray.contribution * reflectAmt;\n            float refractContribution = ray.contribution * refractAmt;\n\n            // the origin of the ray for reflection should be offset from the surface a bit.\n            // the origin for transmission should be inset into the surface a bit.\n            vec3  reflectSrc = p + n * gWSEps * 2.0;\n            vec3  refractSrc = p - n * gWSEps * 2.0;\n\n\n            // enqueue the reflected ray. it copies the parent ray's internal-ness\n            if (!addRay(ray_t(reflectSrc, reflectDir, reflectContribution,  ray.internal))) {\n                // ray was not enqueued, either the queue was full or the contribution was too small.\n                rgb += sky(ray.rd) * reflectContribution;\n            }\n\n            // enqueue the transmitted ray. it inverts the parent ray's internal-ness\n            if (!addRay(ray_t(refractSrc, refractDir, refractContribution, !ray.internal))) {\n                // ray was not enqueued, either the queue was full or the contribution was too small.\n                rgb += sky(ray.rd) * refractContribution;\n            }\n            \n        }\n        else {\n            // this ray did not hit a surface. it's the sky!\n            // ray contribution is still super important here,\n            // as that's handling all the attenuation due to transmission, reflection.\n            rgb += sky(ray.rd) * ray.contribution;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid addCircle(inout vec3 rgb, in vec2 p, float rad) {\n    float lp = length(p);\n    rgb = mix(rgb, gV0, 0.1 * smoothstep(2.0, 0.0,     lp - rad));\n    rgb = mix(rgb, gV1, 0.2 * smoothstep(2.0, 0.0, abs(lp - rad)));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    configGlobals0();\n    \n    vec2 xy = XY;\n    \n    gDoStereo = length(vec2(iMouse.x, RES.y - iMouse.y)) < gMouseTargetRad;    \n    gRes = gDoStereo ? vec2(RES.x / 2.0, RES.y) : RES.xy;    \n    bool isLeftEye = XY.x < gRes.x;    \n    if (gDoStereo && !isLeftEye) {\n        xy.x -= gRes.x;        \n    }\n    \n    // set up some things we'll re-use\n    configGlobals1();\n    \n    // configure the geometry of the scene.\n    // this is called once per pixel here,\n    // but map() is called hundreds of times.\n    configMap();\n    \n    // screen-space coordinates with 0,0 at the center\n    vec2 uv = (xy - gRes.xy / 2.0) / MINRES * 2.0 / gSSZoom;\n    \n    // kick things off with a single ray for this pixel\n    addRay(getCamRay(uv, isLeftEye));\n\n    // march the ray and all its children\n    vec3 rgb = processRays();\n    \n    // gamma\n    rgb = pow(rgb, vec3(1./2.2));\n    \n    // \"UI\"\n    addCircle(rgb, XY, gMouseTargetRad);\n    addCircle(rgb, vec2(XY.x, iResolution.y - XY.y), gMouseTargetRad);\n\n    #ifdef HEATMAP\n    float pixelExpense = clamp(gMapCalls/1000.0, 0.0, 1.0);\n    rgb   *= 0.2;\n    rgb.r += pixelExpense;\n    #endif\n    \n    RGBA = vec4(rgb, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Sphere Fit\n// Fit a sphere to four points.\n// By Robert Bruce - Public Domain.\n// https://stackoverflow.com/a/70846528/230851\n\n#define _SF_U(a,b,c,d,e,f,g,h) (a.z - b.z)*(c.x*d.y - d.x*c.y) - (e.z - f.z)*(g.x*h.y - h.x*g.y)\n#define _SF_D(x,y,a,b,c) (a.x*(b.y-c.y) + b.x*(c.y-a.y) + c.x*(a.y-b.y))\n#define _SF_E(x,y) ((ra*_SF_D(x,y,b,c,d) - rb*_SF_D(x,y,c,d,a) + rc*_SF_D(x,y,d,a,b) - rd*_SF_D(x,y,a,b,c)) / uvw)\n\n// returns xyz = center, w = radius\nvec4 sphereFromFourPoints(in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    float u = _SF_U(a,b,c,d,b,c,d,a);\n    float v = _SF_U(c,d,a,b,d,a,b,c);\n    float w = _SF_U(a,c,d,b,b,d,a,c);\n    float uvw = 2.0 * (u + v + w);\n    if (abs(uvw) < 1e-3) {\n        // Oops.  The points are coplanar.\n        // Replace with some epsilon appropriate for your project.\n        vec4 ret = vec4(0.0);\n        ret.xyz += a;\n        ret.xyz += b;\n        ret.xyz += c;\n        ret.xyz += d;\n        ret.xyz /= 4.0;\n        ret.w   += length(a - ret.xyz);\n        ret.w   += length(b - ret.xyz);\n        ret.w   += length(c - ret.xyz);\n        ret.w   += length(d - ret.xyz);\n        ret.w   /= 4.0;\n        return ret;\n    }\n    \n    float ra = dot(a, a);\n    float rb = dot(b, b);\n    float rc = dot(c, c);\n    float rd = dot(d, d);\n    \n    vec4 ret;\n    ret.x = _SF_E(y, z);\n    ret.y = _SF_E(z, x);\n    ret.z = _SF_E(x, y);\n    ret.w = length(a - ret.xyz);\n    return ret;\n}\n\n#undef _SF_U\n#undef _SF_D\n#undef _SF_E\n\n\n///////////////////////////////////////////////////////////////////////\n\n\n\n\n#define RES    iResolution\n#define MINRES min(RES.x, RES.y)\n#define ZERO   (min(iFrame, 0))\n\nconst float PI = 3.14159265359;\n\n// WS = world space SS = screen space\nfloat gWSEps = 0.001;  // WS epsilon for surfaces\nfloat gSSEps;          // SS epsilon for smoothstep\nfloat gSSLw;           // SS line width\nfloat gT;\n\nconst vec3 gV0 = vec3(0.0);\nconst vec3 gV1 = vec3(1.0);\nconst vec3 gVx = vec3(1.0, 0.0, 0.0);\nconst vec3 gVy = vec3(0.0, 1.0, 0.0);\nconst vec3 gVz = vec3(0.0, 0.0, 1.0);\n\nconst vec3 gMagenta = vec3(1.0, 0.0, 1.0);\nconst vec3 gGreen   = vec3(0.0, 1.0, 0.0);\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat opU(float A, float B) {\n    return min(A, B);\n}\nfloat opS(float A, float B) {\n    return -min(-A, B);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCylX(vec3 p, float r) {\n    return length(p.yz) - r;\n}\n\nfloat sdCylY(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdCylZ(vec3 p, float r) {\n    return length(p.xy) - r;\n}\nfloat sdPlnY(vec3 p) {\n    return p.y;\n}\nfloat sdSlabX(vec3 p, float r) {\n    return abs(p.x) - r;\n}\nfloat sdSlabY(vec3 p, float r) {\n    return abs(p.y) - r;\n}\nfloat sdSlabZ(vec3 p, float r) {\n    return abs(p.z) - r;\n}\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}