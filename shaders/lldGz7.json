{
    "Shader": {
        "info": {
            "date": "1468546156",
            "description": "Varying the shape of an object by manipulating the domain repetitions at multiple stages in the object definition.",
            "flags": 0,
            "hasliked": 0,
            "id": "lldGz7",
            "likes": 12,
            "name": "MorphingSporeThing",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "domainrepetition"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 663
        },
        "renderpass": [
            {
                "code": "/*\n\t\"MorphingSporeThing\" by wjbgrafx\n\t\n\tBased on \"Playing with Symmetries - Torus\" by PauloFalcao\n\t\n\thttp://glslsandbox.com/e#29755.0\n\t\n*/\n//==============================================================================\n\n// From \"Raymarching Primitives\" - // Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//------------------------------------------------------------------------------\n//Util Start\n\nfloat PI=3.14159265;\n\nvec3 sim(vec3 p,float s)\n{\n   vec3 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s)\n{\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//Util End\n//------------------------------------------------------------------------------\n\n//Scene Start\n//------------------------------------------------------------------------------\n\nvec2 obj0Def( in vec3 p )\n{\n\treturn vec2( sdEllipsoid( p, vec3( 0.1 ) ), 0.0 );\t\n}\nvec2 obj1Def( in vec3 p )\n{\n\treturn vec2( sdBox( p, vec3( 1.0, 0.02, 0.02 ) ), 1.0 );\t\n}\nvec2 obj2Def( in vec3 p )\n{\n\treturn vec2( sdBox( p, vec3( 0.02, 1.25, 0.02 ) ), 2.0 );\t\n}\n\n//------------------------------------------------------------------------------\n\nvec3 obj0_c(in vec3 p)\n{\n\treturn vec3( abs( sin( iTime * 0.03 ) ), \n\t\t\t\t abs( sin( iTime * 0.05 ) ),\n\t\t\t\t abs( sin( iTime * 0.07 ) ) );\n}\nvec3 obj1_c(in vec3 p)\n{\n\treturn vec3( abs( sin( iTime * 0.07 ) ), \n\t\t\t\t abs( sin( iTime * 0.03 ) ),\n\t\t\t\t abs( sin( iTime * 0.05 ) ) );\n}\nvec3 obj2_c(in vec3 p)\n{\n\treturn vec3( abs( sin( iTime * 0.05 ) ), \n\t\t\t\t abs( sin( iTime * 0.07 ) ),\n\t\t\t\t abs( sin( iTime * 0.03 ) ) );\n}\n//------------------------------------------------------------------------------\n\nvec2 map(in vec3 p) // orange\n{\t\n\t// Rotate space around the z-axis.\n\t//-------------------------------------------- \n\t// x-axis is now up-down, y-axis is right-left\n\tp.xy = rot( p.xy, PI * 0.5 );\n\t//-------------------------------------------- \n\n\t// Animation\n\t//---------------------------------------\n\t// Animate object rotating around x-axis:\n\tp.yz = rot( p.yz, iTime * 0.23 );\n\n\t// Animate object rotating around y-axis:\n\tp.xz = rot( p.xz, iTime * 0.17 );\n\n\t// Animate object rotating around z-axis:\n\tp.xy = rot( p.xy, iTime * 0.13 );\n\t//---------------------------------------\n\n\t// Domain repetitions\n\t// ---------------------------------------------------\n\n\t// Copy sphere in the xy-plane via symmetry around the z-axis.\n\tp.xy = rotsim( p.xy, 8.0 + 6.0 * sin( iTime * 0.11 ) );\n\t// Offset sphere along the y-axis by a small amount.\n\tp.y -= 0.35;\n\n\t// Copy sphere in yz plane via symmetry around x-axis.\n\t// numCopies = 6.0\n\t//p.yz = rotsim( p.yz, 8.0 );\t\n\tp.yz = rotsim( p.yz, 8.0 + 6.0 * sin( iTime * 0.05 ) );\t\n\t// Offset sphere along z-axis to separate the copies wider apart.\n\tp.z -= 2.0;\t\n\t\n\t// Copy sphere in the xz-plane via symmetry around the y-axis.\n\t//p.xz = rotsim( p.xz, 8.0 );\n\tp.xz = rotsim( p.xz, 8.0 + 6.0 * sin( iTime * 0.07 ) );\n\t// Offset sphere along the z-axis to separate copies.\n\tp.z -= 3.0;\n\n\t// Adding this provides a background for the object.\n\tp = sim( p, 6.0 );\n\n\t// Copy sphere in the xy-plane via symmetry around the z-axis.\n\t//p.xy = rotsim( p.xy, 3.0 );\n\tp.xy = rotsim( p.xy, 8.0 + 6.0 * sin( iTime * 0.09 ) );\n\t// Offset sphere along the y-axis by a small amount.\n\tp.y -= 0.55;\n\n\t// Copy sphere in the xy-plane via symmetry around the z-axis.\n\tp.xy = rotsim( p.xy, 8.0 + 6.0 * sin( iTime * 0.03 ) );\n\t// Offset sphere along the y-axis by a small amount.\n\tp.y -= 0.35;\n\n\t// ---------------------------------------------------\n\n\t// Objects\n\t//----------------------------------\n\t\n\t// spheres\t\n\tvec2 obj0 = obj0Def( p );\n\t\n\t// vertical box connectors in xz-plane\n\tvec2 obj1 = obj1Def( p );\n\t\n\t// horizontal box connectors in xy-plane\n\tvec2 obj2 = obj2Def( p );\n\t//----------------------------------\n\t\n\t// Distance comparisons to find closest object\n\t//--------------------------------------------\n\tvec2 closest = obj0.s < obj1.s ? obj0 : obj1;\n\tclosest = closest.s < obj2.s ? closest : obj2;\n\t\n\treturn closest;\t\n}\n\n//Scene End\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Note that original code does not perform aspect ratio adjustment here,\n\t// but below in the \"vec3 scrnCoord =\" equation.\n\t// vec2 vPos=-1.0+2.0*fragCoord.xy/scrnRes.xy;\n\t\n\t// wjb modified to include aspect ratio adjustment here.\n\t// Adjust aspect ratio, normalize coords, center origin in xy-plane.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 vPos = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n\t\n\t//----------------\n\t//Camera animation\n\tvec3 vuv=vec3(0,1,0);//Change camere up vector here\n\tvec3 vrp=vec3(0,0,0); //Change camere view here\n\t\n\t// camera rotate around y-axis in xz plane\n\t//vec3 prp=vec3(cos(iTime * 0.5),0.1,sin(iTime* 0.5))*8.0; //camera pos\n\t//vec3 prp=vec3(cos(iTime * 0.37),-sin( iTime * 0.41 ),sin(iTime* 0.43))*12.0; \n\t// camera rotate around x-axis in yz plane\n\t//vec3 prp=vec3(0.1,cos(iTime * 0.5),sin(iTime* 0.5))*8.0; //camera pos\n\t// camera rotate around z-axis in xy plane\n\t//vec3 prp=vec3(cos(iTime * 0.5),sin(iTime* 0.5),0.1)*8.0; //camera pos\n\t// Still camera from x units out of screen\n\tvec3 prp=vec3(0.0,0.0,-10.0); //For viewing individual components from front\n\t//-----------------\n\t\n\tfloat vpd=1.5;  // fov\n\t\n\t//Camera setup\n\tvec3 vpn=normalize(vrp-prp);\n\tvec3 u=normalize(cross(vuv,vpn));\n\tvec3 v=cross(vpn,u);\n\t\n\t// Original code does aspect ratio adjustment here.\n\t//vec3 scrCoord=prp+vpn*vpd+vPos.x*u*scrnRes.x/scrnRes.y+vPos.y*v;\n\t\n\t// wjb modified, since asp rat is done in vPos equation above.\n\tvec3 scrCoord=prp+vpn*vpd+vPos.x*u+vPos.y*v;\n\t\n\tvec3 scp=normalize(scrCoord-prp);\n\t\n\t//Raymarching\n\tconst vec3 e=vec3(0.1,0,0);\n\tconst float maxd=60.0; //Max depth\n\t\n\tvec2 s=vec2(0.1,0.0);\n\tvec3 c,p,n;\n\t\n\tfloat f=1.0;\n\tfor(int i=0;i<256;i++)\n\t{\n\t\tif (abs(s.x)<.001||f>maxd) break;\n\t\tf+=s.x;\n\t\tp=prp+scp*f;\n\t\t//s=inObj(p);\n\t\ts=map(p);\n\t}\n\t\n\tif (f<maxd)\n\t{\n\t\t// Determine color of object\n\t\t//--------------------------\n\t\tif (s.y==0.0)\t\n\t\t  \tc = obj0_c( p );\n\t\telse if ( s.y == 1.0 )\n\t\t    c = obj1_c( p );\n\t\telse\n\t\t\tc = obj2_c( p );\n\t\t\t\n\t\t//--------------------------\n\t\t\n\t\t//tetrahedron normal\n\t\tconst float n_er=0.01;\n\t\tfloat v1=map(vec3(p.x+n_er,p.y-n_er,p.z-n_er)).x;\n\t\tfloat v2=map(vec3(p.x-n_er,p.y-n_er,p.z+n_er)).x;\n\t\tfloat v3=map(vec3(p.x-n_er,p.y+n_er,p.z-n_er)).x;\n\t\tfloat v4=map(vec3(p.x+n_er,p.y+n_er,p.z+n_er)).x;\n\t\tn=normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n\t\t\n\t\tfloat b=dot(n,normalize(prp-p));\n\t\t//simple phong LightPosition=CameraPosition\n\t\tfragColor=vec4((b*c+pow(b,8.0))*(1.0-f*.01),1.0);\n\t}\n\telse fragColor=vec4(0,0,0.1,1); //background color\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}