{
    "Shader": {
        "info": {
            "date": "1585907455",
            "description": "Poncelet's Porism: [url]https://en.wikipedia.org/wiki/Poncelet%27s_closure_theorem[/url] or a nice talk by Joe Harris: [url]https://www.youtube.com/watch?v=P7E_YOiuDvI[/url] (not that I follow all the details).\n\nMouse changes the conics.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dfcDX",
            "likes": 7,
            "name": "Poncelet's Porism",
            "published": 3,
            "tags": [
                "projective",
                "poncelet",
                "porism"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 333
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Poncelet's Porism\n// Matthew Arcus, 2020.\n//\n// Another gem of projective geometry. Given a pair of conics, if an\n// n-gon can be inscribed in one such that it circumscribes the other,\n// then there are an infinite number of such n-gons. It's difficult in\n// general to find such an n-gon in the first place, but here's an\n// easy special case.\n//\n// Inscribe a regular m/n-gon in a circle, find the incircle of the\n// polygon and then apply a projective transformation. Here, we map\n// points (-1,0),(0,1) and (0,-1) on the unit circle to themselves,\n// and the point (1,0) to the mouse position.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat N = 11.0, M = 5.0; // Polygon parameters\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Geometric constructions\n//\n// Homogeneous coordinates used throughout (so the lines and points are\n// \"projective\"):\n// (x,y,z) represents the point (x/z,y/z) for z != 0\n// (x,y,0) represents a \"point at infinity\" which acts like a direction.\n// (a,b,c) represents the line ax + by + cz = 0\n// (0,0,c) represents the \"line at infinity\"\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.14159;\n\n// The line between two projective points, or the intersection of two\n// projective lines, is just their cross product.\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  vec3 p3a = m*p3;\n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3a[0];\n  m[1] /= p3a[1];\n  m[2] /= p3a[2];\n  m = transpose(m);\n  return m;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distance functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float s = dot(p,m*p);\n  vec3 ds = 2.0*m*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\nmat3 circlemat(vec4 c) {\n  // (x-a)^2 + (y-b)^2 = r^2\n  // x2 -2ax + a2 + y2 -2by + b2 -r2 = 0\n  vec3 q = c.xyz;\n  float r2 = c.w;\n  q /= q.z;\n  return mat3(1,0,-q.x,\n              0,1,-q.y,\n              -q.x,-q.y,dot(q.xy,q.xy)-r2);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 diagram(vec3 p, vec3 P) {\n  vec3 A = vec3(0,-1,1), B = vec3(-1,0,1), C = vec3(0,1,1);\n  mat3 X = rproject(A,B,C,P), Y = rproject(A,B,C,vec3(1,0,1));\n  mat3 T = inverse(X)*Y, S = inverse(T);\n  float theta = PI/N; // Segment half angle\n  float lmin = 0.005, lmax = 0.008+fwidth(p.x);\n  float pmin = 0.01, pmax = 0.02;\n  float r = cos(M*theta);\n  mat3 c1 = circlemat(vec4(0,0,1,1));\n  mat3 c2 = circlemat(vec4(0,0,1,r*r));\n  vec3 col = vec3(1,1,0.8);\n  col = mix(vec3(0.5),col,0.75+0.75*smoothstep(lmin,lmax,conic(p,c1)));\n  //col = mix(vec3(0,0,1),col,0.5+0.5*smoothstep(lmin,lmax,conic(p,c2)));\n  col = mix(vec3(1,0,0),col,smoothstep(lmin,lmax,conic(p,transpose(S)*c1*S)));\n  col = mix(vec3(0,0,1),col,smoothstep(lmin,lmax,conic(p,transpose(S)*c2*S)));\n  float t = 0.2*iTime;\n  for (float i = 0.0; i < N; i++) {\n    vec3 p0 = vec3(cos(2.0*i*theta+t),sin(2.0*i*theta+t),1);\n    vec3 p1 = vec3(cos(2.0*(i+M)*theta+t),sin(2.0*(i+M)*theta+t),1);\n    //col = mix(vec3(0,0.5,0),col,0.5+0.5*smoothstep(lmin,lmax,line(p,p0,p1)));\n    col = mix(vec3(0,1,0),col,0.5+0.5*smoothstep(lmin,lmax,line(p,T*p0,T*p1)));\n  }\n  for (float i = 0.0; i < N; i++) {\n    vec3 p0 = vec3(cos(2.0*i*theta+t),sin(2.0*i*theta+t),1);\n    //col = mix(vec3(0.5),col,smoothstep(pmin,pmax,point(p,p0)));\n    col = mix(vec3(0),col,smoothstep(pmin,pmax,point(p,T*p0)));\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 1.2;\n  vec3 p = vec3(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y,1.0);\n  vec3 P = iMouse.x <= 0.0 ? vec3(-0.5,0,1)\n    : vec3(scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y,1);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}