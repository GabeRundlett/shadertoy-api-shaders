{
    "Shader": {
        "info": {
            "date": "1661631828",
            "description": "A fully featured, parameterized Catmull-Rom Spline demonstration, revealing that this can in fact work as a shader, even though it is computationally expensive.  Multiple optimizations where implemented to continue to fit running at 60 fps on an older GPU",
            "flags": 0,
            "hasliked": 0,
            "id": "flKcDw",
            "likes": 1,
            "name": "Catmull-Roms!",
            "published": 3,
            "tags": [
                "splinehp"
            ],
            "usePreview": 0,
            "username": "HeavyPaws",
            "viewed": 190
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////////////////////////////\n//\n// Cathmul-Rom Spline Demo                   by:  HeavyPaws\n//\n///////////////////////////////////////////////////////////////\n//\n// Changelog:\n//\n// Release 1.0 - Initial experiment completion\n// Release 1.1 - Further optimization to save callstack and\n//               some mul/div instructions, and an entire for\n//               loop!  Now entirely stable at 60 FPS. \n//\n///////////////////////////////////////////////////////////////\n//\n// Original shadertoy from which this was expanded:\n//     https://www.shadertoy.com/view/tdGcRh\n//\n///////////////////////////////////////////////////////////////\n//\n// Released under the DBAD License as open source code:\n//     https://dbad-license.org/\n//\n// You may use, modify, or redistrobute code as long as credit\n// to the original author is provided, and you are not being\n// a dick in terms with the license!\n//\n// If you would like to help improve this project as it is now\n// fully open source, you can do so and let me know!\n//\n///////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////\n//\n// Params\n//\n///////////////////////////////////////////////////////////////\n\n#define time (iTime/1.0)\n#define VEC2D_UP vec2(0.0,1.0)\n#define LINES 8\n#define STEP 1.0/float(LINES)\n#define POINTS 10\n#define MAX_POINTS POINTS\n#define ALPHA 1.0f\n#define TENSION 0.0f\n#define SUBDIVISIONS 20\n#define LENGTH_PRECISION 0.1f\n#define PI acos(-1.0)\n#define TAU acos(-1.0)*2.0f\n\n// Updated each iteration.  Don't mess with these.\nvec2 pixel_uv;\nfloat spline_length, segment_length;\nvec2 pin_block[MAX_POINTS];\nfloat position;\n\n///////////////////////////////////////////////////////////////\n//\n// Math\n//\n///////////////////////////////////////////////////////////////\n\nfloat point(vec2 o) { return smoothstep(10.0/iResolution.y,7.5/iResolution.y,length(pixel_uv-o)); }\n\nvec2 rotate2d(vec2 point, float degree, vec2 pivot)\n{\n    float radAngle = -radians(degree);\n    float x = point.x;\n    float y = point.y;\n    float rX = pivot.x + (x - pivot.x) * cos(radAngle) - (y - pivot.y) * sin(radAngle);\n    float rY = pivot.y + (x - pivot.x) * sin(radAngle) + (y - pivot.y) * cos(radAngle);\n    return vec2(rX, rY);\n}\n\nfloat cross2D(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }\n\nfloat line(vec2 a, vec2 b) {\n\tvec2 v  = b-a;\n    vec2 p0 = pixel_uv-a;\n    float k = min(length(p0)/length(v),1.0);\n    return smoothstep(4.0/iResolution.y,0.0,length(p0-k*v));\n}\n\nvec2[MAX_POINTS] deformedCircle(int count) {\n    vec2 p[MAX_POINTS];\n    for (int i = 0; i < count; i++) {\n        float a = float(i) / float(count) * TAU;\n        p[i] = vec2(3.0, 1.5) * vec2(cos(a), sin(a)) * (0.30 + 0.03 * sin(iTime) + 0.03 * sin(a * PI + iTime));\n    }\n    return p;\n}\n\nfloat sinewarp(float speed) {\n    float p = sin(iTime) * speed;\n    return p;\n}\n\n///////////////////////////////////////////////////////////////\n//\n// Cathmul-Rom Spline\n//\n///////////////////////////////////////////////////////////////\n\n// Commented functions are previously working code that\n// has been commented but not removed for documentation-sake.\n\n/*\nvec2 splineStartTangent(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    \n    float t01 = pow(distance(p0, p1), ALPHA);\n\tfloat t12 = pow(distance(p1, p2), ALPHA);\n    \n\tvec2 m1 = (1.0f - TENSION) *\n    \t(p2 - p1 + t12 * ((p1 - p0) / t01 - (p2 - p0) / (t01 + t12)));\n    return m1;\n}\n*/\n\n/*\nvec2 splineEndTangent(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    \n\tfloat t12 = pow(distance(p1, p2), ALPHA);\n\tfloat t23 = pow(distance(p2, p3), ALPHA);\n\n\tvec2 m2 = (1.0f - TENSION) *\n    \t(p2 - p1 + t12 * ((p3 - p2) / t23 - (p3 - p1) / (t12 + t23)));\n    return m2;\n}\n*/\n\n// UPDATE:  Packing in splineStartTangent and splineEndTangent\n//          to reduce callstack and number of muls.\nvec2 splinePosition(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)\n{\n    float t01 = pow(distance(p0, p1), ALPHA);\n\tfloat t12 = pow(distance(p1, p2), ALPHA);\n  \tfloat t23 = pow(distance(p2, p3), ALPHA);\n    float tt = t * t;\n\tfloat ttt = tt * t;\n    \n\tvec2 m1 = (1.0f - TENSION) *\n    \t(p2 - p1 + t12 * ((p1 - p0) / t01 - (p2 - p0) / (t01 + t12)));\n\tvec2 m2 = (1.0f - TENSION) *\n    \t(p2 - p1 + t12 * ((p3 - p2) / t23 - (p3 - p1) / (t12 + t23)));\n\n\tvec2 a = 2.0f * (p1 - p2) + m1 + m2;\n\tvec2 b = -3.0f * (p1 - p2) - m1 - m1 - m2;\n\tvec2 c = m1;\n\tvec2 d = p1;\n\n\treturn a * ttt +\n           b * tt +\n           c * t +\n           d;\n}\n\nvec2 splineTangent(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n\tfloat tt = t * t;\n    \n    float q1 = (-3.0f * tt + 4.0f * t - 1.0f);\n    float q2 = (9.0f * tt - 10.0f * t);\n    float q3 = (-9.0f * tt + 8.0f * t + 1.0f);\n    float q4 = (3.0f * tt - 2.0f * t);\n\n\tfloat tx = 0.5f * (p0.x * q1 + p1.x * q2 + p2.x * q3 + p3.x * q4);\n\tfloat ty = 0.5f * (p0.y * q1 + p1.y * q2 + p2.y * q3 + p3.y * q4);\n\n    return vec2 (tx, ty);\n}\n\nvec2 splineRotator(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    vec2 a = splineTangent(p0, p1, p2, p3, t);\n    float angle = atan(-a.y, a.x);\n    return vec2(sin(angle), cos(angle));\n}\n\n\n/*\n// WARNING: Do not calculate more than once per spline per frame, is expensive.\nfloat splineLength(vec2 points[MAX_POINTS]) {\n    float l = 0.0f;\n    for (int i = 1; i < points.length() - 3; i++) {\n        vec2 p0 = points[i-1];\n        vec2 p1 = points[i];\n        vec2 p2 = points[i+1];\n        vec2 p3 = points[i+2];   \n        vec2 a = p1, b;\n        for (float j = 0.0f; j <= 1.0f; j += LENGTH_PRECISION) { \n            vec2 b = splinePosition(p0, p1, p2, p3, j);\n            l += pow(distance(a, b), ALPHA);\n            a = b;\n        }\n    }\n    return l;\n}\n*/\n\n/* vec2 splineRealPosition(vec2 points[MAX_POINTS], float l) {\n    float adjusted_maxIndex = float(points.length()) - 3.0f;\n    int pointIndex = int(floor(adjusted_maxIndex * ( l / spline_length)));\n    float pointOffset = \n        clamp((adjusted_maxIndex * ( l / spline_length)) - float(pointIndex), 0.0f, 1.0f);\n    \n    vec2 result = splinePosition(\n        points[pointIndex], \n        points[pointIndex+1], \n        points[pointIndex+2], \n        points[pointIndex+3], \n        pointOffset);\n    return result;\n} */\n\n/*\nvec2 splineRealRotator(vec2 points[MAX_POINTS], float l) {\n    float adjusted_maxIndex = float(points.length()) - 3.0f;\n    int pointIndex = 1 + int(floor(adjusted_maxIndex * ( l / spline_length)));\n    float pointOffset =\n        clamp((1.0f + (adjusted_maxIndex * ( l / spline_length))) - float(pointIndex), 0.0f, 1.0f);\n    vec2 result = splineRotator(\n        points[pointIndex-1],    \n        points[pointIndex], \n        points[pointIndex+1], \n        points[pointIndex+2],\n        pointOffset);\n    return result;\n} */\n\n// UPDATE:  Pack in splineRealPosition and splineRealRotator\n//          to reduce callstack and number of muls/divs.\nfloat draw_spline_marker(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float marker;\n    float pointTime = (segment_length * t) / segment_length;\n    vec2 r = splineRotator(p0, p1, p2, p3, pointTime);\n    vec2 qp = splinePosition(p0, p1, p2, p3, pointTime);\n    vec2 f = -0.1f * r + qp;\n    vec2 h = 0.1f * r + qp;\n    marker = mix(marker, 1.0f, point(f));\n    marker = mix(marker, 1.0f, point(h));\n    marker = mix(marker, 1.0f, line(f,h));\n    return marker;\n}\n\n///////////////////////////////////////////////////////////////\n//\n// Datablocks\n//\n///////////////////////////////////////////////////////////////\n\n// UPDATE:  Spline length is now calculated in splineRenderBlock\n//          to save an additional for loop and callstack.\nvoid splineGetPinBlock(void) {\n    pin_block = deformedCircle(POINTS);\n    // spline_length = splineLength(pin_block);\n}\n\n// UPDATE:  Spline length now happening in core loop.\nvec3 splineRenderBlock(void) {\n    vec3 color, drawColor;\n    spline_length = 0.0f;\n    vec2 p0, p1, p2, p3, a, b, c;\n    for (int i = 0; i < (MAX_POINTS - 3); i++) {\n        p0 = pin_block[i];\n        p1 = pin_block[i+1];\n        p2 = pin_block[i+2];\n        p3 = pin_block[i+3];          \n\n        a = p1; c = a; segment_length = 0.0f;\n        for (int j = 1; j <= LINES; j++) {\n            b = splinePosition(p0, p1, p2, p3, STEP*float(j));\n            segment_length += abs(distance(a, b));\n\n            // Draw control lines\n            if (j == LINES - 1) {\n                drawColor = vec3(0.2,0.2,0.2);\n                color = mix(color, drawColor, line(c, b));\n                drawColor = vec3(1.0,1.0,0.0);\n                color = mix(color, drawColor, point(c));    \n            }\n            \n            if (j == LINES) {\n                drawColor = vec3(1.0,1.0,0.0);\n                color = mix(color, drawColor, point(p2)); \n                float t = 0.0f;\n                while (t <= 1.0f) {\n                   drawColor = vec3(0.0,0.0,1.0);\n                   color = mix(color, drawColor, draw_spline_marker(p0, p1, p2, p3, t));\n                   t += 1.0f / float(SUBDIVISIONS);\n                }\n            }\n\n            // Draw curve\n            drawColor = vec3(1.0,1.0,1.0);\n            color = mix(color, drawColor, line(a, b));\n            a = b;\n        }     \n    }\n    \n    return color;\n}\n\n///////////////////////////////////////////////////////////////\n//\n// Main\n//\n///////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    pixel_uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0.94);\n    \n    splineGetPinBlock();\n    color = splineRenderBlock();\n\n\tfragColor = vec4(color ,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}