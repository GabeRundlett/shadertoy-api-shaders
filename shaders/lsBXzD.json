{
    "Shader": {
        "info": {
            "date": "1409604763",
            "description": "I started this trying to improve the performance of the bit field in https://www.shadertoy.com/view/lssGDj\n\nI ended up getting 24 bit from the mantissa part of the float and the sign bit as well for 25 bits which was perfect for size 5 x 5 characters.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "lsBXzD",
            "likes": 25,
            "name": "It's ASCII bitch!",
            "published": 3,
            "tags": [
                "2d",
                "text",
                "field",
                "ascii",
                "bit",
                "art",
                "packing"
            ],
            "usePreview": 0,
            "username": "CeeJayDK",
            "viewed": 4275
        },
        "renderpass": [
            {
                "code": "// -- Settings --\n#define pixelation 2 //A multiplier for the pixel size - use positive integers\n//Go ahead and use negative integers though - it flips and mirrors the chars ;)\n//I decided to add this because at 4K characters are very hard to see.\n\n// -- Code begins --\n\n//We need precision or the bit extraction might not be correct\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n//It's important that your Intel graphics driver settings for 3D is set to Quality,\n//as the Performance setting will likely force lower precision in the shaders.\n\n//This is mainly something you need to be aware of when using Intel GPU drivers,\n//as modern AMD or Nvidia drivers don't even have an option for lower 3D quality\n\n//A fork of https://www.shadertoy.com/view/lssGDj \n\n\nfloat character(float n, vec2 p) // some compilers have the word \"char\" reserved\n{\n    p = floor(p * vec2(8.0,-8.0) + (vec2(-4.0,4.0) + vec2(1.0)) );\n\n\tif (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n\t{\n        //test values\n        //n = -(exp2(24.)-1.0); //-(2^24-1) All bits set - a white 5x5 box\n        \n        //24 bits and a multiplier (exponent)\n        //Set the highest bit and use log2 to get the exponent that could respresent that\n        //adjust the mantissa and get the remaining bits\n        \n \n        //p = floor(p);\n    \tfloat x = (5.0 * p.y + p.x);\n        //x = floor(x);\n        \n\n        \n        float signbit = (n < 0.0)\n          ? 1.0 \n          : 0.0 ;\n        \n        signbit = (x == 0.0) \n          ? signbit\n          : 0.0 ;\n        \n        \n        //Tenary Multiply exp2\n        return ( fract( abs( n*exp2(-x-1.0))) >= 0.5) ? 1.0 : signbit; //works on AMD and intel\n        \n\t}\t\n\t\n    return 0.0;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord /= float(pixelation);\n\tvec2 uv = fragCoord.xy;\n    vec2 cursor_position = (floor(uv/8.0)*8.0+(0.5/float(pixelation)))/(iResolution.xy / float(pixelation)); //slight blur\n\tvec3 col = texture(iChannel0, cursor_position).rgb; \n    //vec3 col = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n\t\n    \n    //Greenscreen\n    #define graytype 4\n    \n\t#if graytype == 1\n\t  float luma = (col.r + col.b) * 0.5; // skip green component\n\t#elif graytype == 2\n\t  float luma = (col.r + col.g + col.b)/3.0;\n\t#elif graytype == 3\n      float luma = dot(col,vec3(0.2126, 0.7152, 0.0722));\n    #else \n        vec3 colortarget = vec3(0.,255.,0.)/255.0;\n        vec3 diff = col - colortarget;\n        vec3 square_diff = diff * diff;\n        vec3 distance_coefs = vec3((0.5 * diff.r + 2.0), 4.0, (-0.5 * diff.r + 3.0));\n\n        float colordistance = 0.28 * sqrt( dot(square_diff,distance_coefs) );\n    \t\n    \tcol = (colordistance > 0.35 ) ? col : vec3(0.0); \n    \tfloat luma = dot(col,vec3(0.2126, 0.7152, 0.0722));\n    \n\t#endif\n    \n    \n    float gray = smoothstep(0.0,1.0,luma); //increase contrast\n    //gray = smoothstep(0.0,1.0,gray); //increase contrast\n    \n    \n    //test patterns\n    //gray = (floor(uv.x/8.0)*8.0)/iResolution.x;\n    //gray = (floor(uv.y/8.0)*8.0)/iResolution.y;\n    //gray = ((floor(uv.x/8.0)*8.0)/iResolution.x + (floor(uv.y/8.0)*8.0)/iResolution.y) *0.5; \n    //gray = ((floor(uv.x/8.0)*8.0)/iResolution.x * (floor(uv.y/8.0)*8.0)/iResolution.y) * 1.5; \n    \n    //maybe try levels here ?\n    \n    //float gray = luma;\n    //gray = 1.0 - gray;\n    \n\n    /*\n    //Original method from movAX13h\n\t//Serial - uses as many cycles as comparisons\n    //Fine as long as you keep the number of different characters low\n\t//but gets expensive when you add a lot of different characters\n\n\tfloat n =  65536.0;             // .\n\tif (gray > 0.2) n = 65600.0;    // :\n\tif (gray > 0.3) n = 332772.0;   // *\n\tif (gray > 0.4) n = 15255086.0; // o \n\tif (gray > 0.5) n = 23385164.0; // &\n\tif (gray > 0.6) n = 15252014.0; // 8\n\tif (gray > 0.7) n = 13199452.0; // @\n\tif (gray > 0.8) n = 11512810.0; // #\n\t*/\n    \n    /*\n    //Conditional assignment method - expanded to use all 17 chars\n    //fast on hardware that can do this without branching (PC and Mac, unsure about mobile)\n    //TODO add Q and move space to special case like with the signbit\n    //and maybe add dithering\n    float num_of_chars = 16. ; // Using a gradient of [ .:^\"~cvo*wSO80#] (Not including brackets)\n    \n    float n12   = (gray < (1./num_of_chars))  ? 0.        : 4194304. ; //   or .\n\tfloat n34   = (gray < (3./num_of_chars))  ? 131200.   : 324.     ; // : or ^\n    float n56   = (gray < (5./num_of_chars))  ? 330.      : 283712.  ; // \" or ~\n    float n78   = (gray < (7./num_of_chars))  ? 12650880. : 4532768. ; // c or v\n    float n910  = (gray < (9./num_of_chars))  ? 13191552. : 10648704.; // o or *\n    float n1112 = (gray < (11./num_of_chars)) ? 11195936. : 15218734.; // w or S\n    float n1314 = (gray < (13./num_of_chars)) ? 15255086. : 15252014.; // O or 8 \n    float n1516 = (gray < (15./num_of_chars)) ? 15324974. : 11512810.; // 0 or # //forgot about Q\n    \n    float n1234     = (gray < (2./num_of_chars))  ? n12   : n34;\n    float n5678     = (gray < (6./num_of_chars))  ? n56   : n78;\n    float n9101112  = (gray < (10./num_of_chars)) ? n910  : n1112;\n    float n13141516 = (gray < (14./num_of_chars)) ? n1314 : n1516;\n    \n    float n12345678 = (gray < (4./num_of_chars)) ? n1234 : n5678;\n    float n910111213141516 = (gray < (12./num_of_chars)) ? n9101112 : n13141516;\n    \n    float n = (gray < (8./num_of_chars)) ? n12345678 : n910111213141516;\n    */\n    \n    //Suggested by FabriceNeyret2 - Now possible in WebGL2\n    float n = float[]( 0.,4194304.,131200.,324.,330.,283712.,12650880.,4532768.,\n                       13191552.,10648704.,11195936.,15218734.,15255086.,15252014.,15324974.,11512810.\n                     )[int(gray * 16.)]; \n    \n    \n    vec2 p = fract(uv * 0.125);\n    \n    col = pow(col,vec3(0.55));\n    col = col*character(n, p);\n        \n    col = mix(vec3(character(n, p)),col, 1.0 - iMouse.x / iResolution.x);\n\n\tfragColor = vec4(col,1.0);\n}\n\n\n// -- Notes and reference --\n/*\nThis shader can use 25 bits in a float.\nTo use the last few bits in a float you will need ldexp and frexp.\n\nldexp and frexp are available in GLSL with OpenGL 4.0 and up,\nin HLSL with SM2.x and up,\nbut not in OpenGL ES / WebGL.\n\nBut we can make our own:\n\nfloat ldexp (float mantissa, float exponent)\n{\n\treturn exp2(exponent) * mantissa;\n}\n\n\nfloat frexp (float f, out float exponent)\n{\n\texponent = ceil(log2(f));\n\tfloat mantissa = exp2(-exponent) * f;\n\treturn mantissa;\n}\n\nI didn't bother doing more than 25 bits - left as an exercise for the reader ;)\n*/\n\n\n/* Gradients:\n\n\n .'~:;!>+=icjtJY56SXDQKHNWM\n .':!+ijY6XbKHNM\n .:%oO$8@#M\n .:+j6bHM\n .:coCO8@\n .:oO8@\n .:oO8\n :+#\n\n .:^\"~cvo*wSO80#\n .:^\"~cso*wSO8Q0#\n .:^\"~csoCwSO8Q0#\n .:^\"~c?o*wSO8Q0#\n\nA mistake many people make is assuming all characters work fine for ASCII shading. They don't.\nGood characters have most of their \"weight\" or pixels in the center of the character.\nImbalanced characters like _ are bad because they leave annoying gaps in the image.\nGood characters also don't have distinct lines that create obvious patterns,\nthey instead resemble a gradient pattern like # or a nice round shape like O o 0.\n\nI've picked characters with most of their weight in the center and rounded shapes where possible,\nI've also drawn the characters with this in mind.\n\nAnother mistake people make it to divide the greyscale range into equal segments,\nbut not use characters that have equal brightness gaps.\n\nHere I've created a font that has from 0 to 16 pixels lit.\nI forgot the Q so you can notice a small brightness band from the 0 to # chars in the image.\nI've fixed this in the SweetFX/Reshade version of this effect and when I can be bothered I'll fix it here too.\n\nYou can get even more shades by also using dithering. I do this in the Reshade version as well.\n\nAnother rookie mistake you sometimes see people doing is mapping a square part of the screen to a non-square character,\nwhich obviously messes with the aspect ration of the image.\nI use a square 5x5 pixel font here but you can do non-square fonts as long as you map the right sized area to that font.\n\n\nCharacters I created and tried with this:\n\nn value // # of pixels // character\n-----------//----//-------------------\n4194304.   //  1 // . (bottom aligned) \n131200.    //  2 // : (middle aligned) \n4198400.   //  2 // : (bottom aligned)\n2228352.   //  3 // ;\n4325504.   //  3 // i (short)\n14336.     //  3 // - (small)\n324.       //  3 // ^\n4329476.   //  4 // i (tall)\n330.       //  4 // \"\n31744.     //  5 // - (larger)\n283712.    //  5 // ~\n10627072.  //  5 // x\n145536.    //  5 // * or + (small and centered) \n6325440.   //  6 // c (narrow - left aligned)\n12650880.  //  6 // c (narrow - center aligned)\n9738240.   //  6 // n (left aligned)\n6557772.   //  7 // s (tall)\n8679696.   //  7 // f\n4532768.   //  7 // v (1st)\n4539936.   //  7 // v (2nd)\n4207118.   //  7 // ?\n-17895696. //  7 // %\n6595776.   //  8 // o (left aligned)\n13191552.  //  8 // o (right aligned)\n14714304.  //  8 // c (wide)\n12806528.  //  9 // e (right aligned)\n332772.    //  9 // * (top aligned)\n10648704.  //  9 // * (bottom aligned)\n4357252.   //  9 // +\n-18157904. //  9 // X\n11195936.  // 10 // w\n483548.    // 10 // s (thick)\n15218734.  // 11 // S \n31491134.  // 11 // C   \n15238702.  // 11 // C (rounded)\n22730410.  // 11 // M (more like a large m)\n10648714.  // 11 // * (larger)\n4897444.   // 11 // * (2nd larger)\n14726438.  // 11 // @ (also looks like a large e)\n23385164.  // 11 // &\n15255086.  // 12 // O\n16267326.  // 13 // S (slightly larger)\n15252014.  // 13 // 8\n15259182.  // 13 // 0  (O with dot in the middle)\n15517230.  // 13 // Q (1st)\n-18405232. // 13 // M\n-11196080. // 13 // W\n32294446.  // 14 // Q (2nd)\n15521326.  // 14 // Q (3rd)\n32298542.  // 15 // Q (4th)\n15324974.  // 15 // 0 or Ã˜\n16398526.  // 15 // $\n11512810.  // 16 // #\n-33061950. // 17 // 5 or S (stylized)\n-33193150. // 19 // $ (stylized)\n-33150782. // 19 // 0 (stylized)\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}