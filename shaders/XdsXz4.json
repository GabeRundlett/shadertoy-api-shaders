{
    "Shader": {
        "info": {
            "date": "1397584630",
            "description": "SPACE= no zoom\n3 way to display the distribution of primes.\nafter \"discovering numbers structures through images\" by Jean-Paul Delahaye\nin \"Pour la Science\", French edition of Scientific American, Feb 2014\nhttp://www.lifl.fr/~delahaye/pls/2014/243.pdf",
            "flags": 0,
            "hasliked": 0,
            "id": "XdsXz4",
            "likes": 9,
            "name": "Primes structure",
            "published": 3,
            "tags": [
                "primes"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2181
        },
        "renderpass": [
            {
                "code": "// 3 way to display the distribution of primes\n\n// after \"discovering numbers structures through images\" by Jean-Paul Delahaye\n// in \"Pour la Science\", French edition of Scientific American, Feb 2014\n// http://www.lifl.fr/~delahaye/pls/2014/243.pdf\n\n#define PI 3.14159265359\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\nint DISPLAY  = 3; // display method :\n\t\t\t\t\t// 1: i = length along a squared spiral \n\t\t\t\t\t// 2: i = length along a squared spiral \n\t\t\t\t\t// 3: i = length along an Archimedial spiral \n\t\n\nfloat isPrime( float x );\nfloat prime (int n) {\n\n#define MODE 3\n\n#if MODE == 0 // the simpler the better... but unrolling kills on windows\n\tint imax = int(sqrt(float(n)));\n\tfor (int i=2; i<1400; i++ ) {\n\t\tif (i>imax) return 1.;\n\t\tif ( n-i*(n/i) == 0) return 0.;\n\t}\n\n#elif MODE == 1  // i^2-i+41  gives primes with 50% probability\n\tfloat d = sqrt(1.-4.*(41.-float(n)));\n\tif (d<0.) return 0.;\n\tif (fract((1.+sqrt(d))/2.)> 1e-5) return 0.;\n\treturn 1.;\n\t\n#elif MODE == 2 // stochastic test, but needs long longs.\n\tfloat err = mod(pow(2.,float(n)-1.),float(n)) - 1.; \n\tif (abs(err)> 1e-5) return 0.;\n\treturn 1.;\n\t\n#elif MODE == 3 // IQ compact loop\n\treturn isPrime(float(n));\n#endif\t\n}\n\nfloat truemod(float x,float y) { float v = mod(x,y); return (v==y)? 0. : v; }\n\n// isPrime:  Created by inigo quilez - iq/2013 https://www.shadertoy.com/view/4slGRH\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Info on prime hunting: https://iquilezles.org/blog/?p=1558\nfloat isPrime( float x )\n{\n\tif( x==1. ) return 0.;\n\tif( x==2. ) return 1.;\n\tif( x==3. ) return 1.;\n\tif( x==5. ) return 1.;\n\tif( x==7. ) return 1.;\n\t\n\tif( mod(x,2.)==0. ) return 0.;\n\tif( mod(x,3.)==0. ) return 0.;\n\tif( mod(x,5.)==0. ) return 0.;\n\n\tfloat y = 7.;\n\tbool flip =   true; // (mod(iTime*4.,1.)>.5);\n\tfloat xmax = (flip) ? sqrt(x)+1. : x;\n\t//int max =  (flip) ? 2000:200;\n\n\tfor( int i=0; i<200; i++ ) // count up to 6000\n\t{ \n\t    // if (i>max) {  return 1.; }\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 4.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 2.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 4.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 2.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 4.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 6.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 2.; if( y>=xmax ) return 1.;\n\t\tif( truemod(x,y)==0. )  return 0.;\n\t\ty += 6.; if( y>=xmax ) return 1.;\n\t}\n\t\n\treturn 1.;\n}\n\n// ---------------------------------------------------------\n\n#define myInt(x)  (int(x)+(((x)<0.)?0:1) )\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat zoom = (keyToggle(32)) ? 1. : clamp(.5*(1.-cos(iTime)),0.,1.);\n\tDISPLAY = 1;//+int(mod(iTime/(2.*PI),3.));\n\t\n\tvec2 uv;\n\tuv.x = float(int(fragCoord.x)-int(iResolution.x/2.))*zoom;\n\tuv.y = float(int(fragCoord.y)-int(iResolution.y/2.))*zoom;\n\tint i;\t\n\t\n\tif (DISPLAY == 1) \n\t{ \t\t\t\t\t\t// i = col + line*WIDTH\n\t\tuv += iResolution.xy/2.;\n\t\ti = int(uv.x)+int(iResolution.x)*int(uv.y);\n\t}\n\telse if (DISPLAY == 2) \n\t{ \t\t\t\t\t\t // i = length along a squared spiral \n\t\tint   x = myInt(uv.x),\n\t\t\t  y = myInt(uv.y);\n\t\tfloat ax = abs(float(x)),\n\t\t\t  ay = abs(float(y));\n\t\tint   r = int (max(ax,ay));\n\t\tint quadran = ( ax > ay ) ? ( (x>0) ? 1 : 3 ) : ( (y>0) ? 2 : 4 );\n\t\t\n\t\ti = (r-1)*r; \n\t\tif      (quadran==1) i +=                 r+y;     // right\n\t\telse if (quadran==2) i += 2*r           + r-x;     // top\n\t\telse if (quadran==3) i += 4*(r-1)       + r-y;     // left\n\t\telse                 i += 4*(r-1) + 2*r + r+x;     // bottom\n\t\t//fragColor = vec4(mod(float(i),2.)); return;\t\n\t\t//fragColor = vec4(float(i)/40000.); return;\t\n\t}\t\n\telse \n\t{ \t\t\t\t\t\t//  i = length along an Archimedial spiral \n#       define RAD 1. // 4. // zoom\n    \tfloat r = length(uv)/RAD, a = atan(uv.y, uv.x),\n\t  \t\t  s = r - a/(2.*PI),\n\t    \t  t = floor(s)+a/(2.*PI), // turns\n\t\t\t  l = t*t;// int (a/2PI da)\n\t\t//fragColor = vec4(sin(2.*PI*s)); return;\n\t\t//fragColor = vec4(sin(l/4.))+vec4(max(0.,sin(s)),0.,0.,0.);return;\n \t\ti = int(l);\n\t}\n\n\t\tfragColor = vec4(prime(i));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}