{
    "Shader": {
        "info": {
            "date": "1638970075",
            "description": "10,000 bowls of oatmeal? \nhow about some proccesed oats instead?\n\nA Procedurally generated assortment of beer bottles.\nYou can change the defines in the Image buffer to change amount of bottles and the seed.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dtXRj",
            "likes": 5,
            "name": "PCG Beer Bottles",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "sdf",
                "wip",
                "beer",
                "bottle"
            ],
            "usePreview": 0,
            "username": "Pelegefen",
            "viewed": 239
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100.\n#define MAX_DIST 40.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define NUM_BOTTLES 3.\n#define NUM_ROWS 3.\n\n\n\n\nconst float seed = 22155.;\n\n\n\nfloat GetDist(vec3 p) {\n p.x -= NUM_BOTTLES * .5;\n p.y += NUM_ROWS * .5;\n    \n    float d  = 1.;\n    \n    //float sdBeerBottle(vec3 p, float width, float highet, float neckS, float lip, float labelS){\n  \n    \n    float NumBottles = NUM_BOTTLES * .75;\n    float NumRows = NUM_ROWS * .75;\n        \n    for(float x = 0.;x < NumRows; x+= .75){\n        \n     // d = min(d,sdBox(p - vec3(-15.5,-2.8,0), vec3(18.,2.,2.5)));\n\n        for(float i = 0.;i < NumBottles; i+= .75){\n    \n              float t = floor(iTime*.8 + seed);\n            float h = hash11(t + i + x);\n                float h1 = hash11(t     +214312./*salt*/ + i + x);\n            float h2 = hash11(floor(t   +2142.  /*salt*/ + i + x));\n            float h3 = hash11(floor(t   +12431. /*salt*/ + i + x));\n            float h4 = hash11(floor(t   +21334. /*salt*/ + i + x));\n\n\n\n            d = min(d, sdBeerBottle(p + vec3(3. * i,-3. * x,3.*x),\n\n            h * .15 ,\n            //^ float width,\n\n            h1* .5,\n            //^ float highet,\n\n            h2,\n            //^ float neckS,\n\n            h3* .8,\n            //^ float lip,\n\n            h4 *2.-1.\n            //^ float labelSh, \n\n            ))\n            ;\n    \n    \n        }\n    }\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\t\n    float dv =0.;\n    float dO=dv;\n    \n    \n    for(float i=0.; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n \n        dO += dS;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    dv = dO;\n    return dv;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(-5, 2, -5);\n      //  ro +=  vec3(5.,0.,0.);\n\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro , vec3(0,1.0,0), 1.);\n    vec3 col = texture(iChannel0,rd).rgb;\n    //vec3 col = vec3(0);\n    float d = RayMarch(ro, rd);\n    float glow = d * .005;\n    \n    \n\n    const float reflectV = .1;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd , n);\n            vec3 blending = getTriPlanarBlend(n);\n\n        \n        vec4 texRef = texture(iChannel0,r);\n\n      //  r *= tex.rgb;\n      \n      float scale = 0.1;\n      float t = floor(iTime*.8 + seed);\n              \n      vec2 off = vec2(t,-t);\n        vec3 texX = texture(iChannel1  ,p.yz- off *scale).rgb;\n        vec3 texY = texture(iChannel1  ,p.xz- off *scale).rgb;\n        vec3 texZ = texture(iChannel1  ,p.xy- off *scale).rgb;\n\n        vec3 normalTex = texX * blending.x + texY * blending.y + texZ * blending.z;\n        \n        \n\n        vec3 T = vec3(0.3,1.,0.);\n        vec3 BT = normalize( cross( n, T ) * 1.0 );\n\n        mat3 tsb = mat3( normalize( T ), normalize( BT ), normalize( n ) );\n        vec3 N = tsb * normalTex.rgb;\n        \n\n\n        float dif = dot(max(N.rgb,.3),n);\n        \n        \n        \n        \n        col = min(col , vec3(dif*.2,dif*.7   ,dif*.2));\n        col += min(texRef.rgb ,dif) * .4;//add reflections\n      \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec3 getTriPlanarBlend(vec3 _wNorm){\n\t// in wNorm is the world-space normal of the fragment\n\tvec3 blending = abs( _wNorm );\n\tblending = normalize(max(blending, 0.00001)); // Force weights to sum to 1.0\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= vec3(b, b, b);\n\treturn blending;\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n\nfloat Union( float d1, float d2 ) { return min(d1,d2); }\n\nfloat Sub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat Intrs( float d1, float d2 ) { return max(d1,d2); }\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s) {\n\n\treturn length(p ) - s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdBeerBottle(vec3 p, float width, float highet, float neckS, float lip, float labelS){\n  float d  = 0.;\n  float label = smoothstep(neckS - labelS,.14+ labelS,p.y)*(labelS * .125);\n\n  float body = sdRoundedCylinder(p, .35 + width- label,.8,0.7 + highet);\n    \n\n\n    float neck = sdRoundedCylinder(p - vec3(0,1.0 + highet,0),.25+ width - label  ,.32,1.4+ highet);\n    neck += p.y * .1;\n    \n    float nb = body+neck;\n   \n    \n    \n    float mp = sdRoundedCylinder(p - vec3(0,2.35+ highet,0),.14+ width - label ,.04,0.08)*.8; //mouthpiece\n    float mph = sdRoundedCylinder(p - vec3(0,2.35+ highet,0),.12+ width- label,.1,2.38) * .8; //mouthpiece hole\n    mp -= abs(p.y - (2.4+ highet)) *.2 ;//shaping the mouthpiece\n    d = min(nb , min(neck,mp));\n    d = max(d,-p.y - .7);\n    \n    \n    \n    float elp = sdEllipsoid(p - vec3(0,-.7,0)  ,vec3(.5 + width,.1,.5 + width));\n    \n  \n    d = Sub (elp,d);\n\n    d = Sub(mph,d) ;\n\n    \n    d *= .9;\n    return d;\n   \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}