{
    "Shader": {
        "info": {
            "date": "1705480926",
            "description": "Uses three points and simulated gravity to create a chaotic system",
            "flags": 0,
            "hasliked": 0,
            "id": "McsXR2",
            "likes": 3,
            "name": "3-Body Gravity Fractal",
            "published": 3,
            "tags": [
                "fractal",
                "math",
                "chaos",
                "motion",
                "physics",
                "gravity"
            ],
            "usePreview": 0,
            "username": "Falafel",
            "viewed": 191
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n#define res iResolution.xy\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    \n    // The zoom. Set to 1. to view the entire screen\n    uv /= 2.;\n    \n    // The point to zoom in to.\n    uv += vec2(.713, .34);\n    \n    \n    // The attractors. Replace .0 with iTime to make them spin.\n    const vec3 a = vec3(cos(.0 * .45 + 2.*pi/3.) * .5, sin(.0 * .45 + 2.*pi/3.) * .5, .2);\n    const vec3 b = vec3(cos(.0 * .45 + 4.*pi/3.) * .5, sin(.0 * .45 + 4.*pi/3.) * .5, .2);\n    const vec3 c = vec3(cos(.0 * .45) * .5, sin(.0 * .45) * .5, .2);\n    \n    \n    // All points are in three dimension yet are set to the same z value. Change that if you want to simulate depth of a point.\n    \n    vec3 uv3 = vec3(uv.x, uv.y, 0.);\n    vec3 momentum = vec3(.0, .0, .0);\n    vec3 uv3c;\n    \n    for (float i = 0.; i < 100.; i+= 1.) {\n        \n        // Take the previous point -> add the previous momentum vector -> add vectors towards the attractors (which are longer if the position is closer to a point).\n        uv3c = uv3 + momentum + (a - uv3) * (.0005 * iTime / pow(length(a - uv3), 2.)) + (b - uv3) * (.0005 * iTime / pow(length(b - uv3), 2.)) + (c - uv3) * (.0005 * iTime / pow(length(c - uv3), 2.));\n        \n        // Set the new momentum to the vector of total difference to previous step.\n        momentum = (uv3c - uv3);\n        \n        // Overwrite the old position.\n        uv3 = uv3c;\n    }\n    \n    // Takes the total distance to each point and throughs it into a palette.\n    float dist = length(a - uv3) + length(b - uv3) + length(c - uv3);\n    \n    // Colors based on distance to each single point.\n    vec3 dist3 = vec3(length(a - uv3), length(b - uv3), length(c - uv3));\n    \n    vec3 col = pal(dist * .3, vec3(.7,.5,.5), vec3(.5,.5,.5), vec3(1.,1.,1.), vec3(.0,.33,.67));\n    \n    // Interpolates between the two colors.\n    col = (clamp(col, 0., 1.) + 5. * clamp(vec3(dist3.x, dist3.y, dist3.z), 0., 1.)) / 6.;\n    \n    O = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}