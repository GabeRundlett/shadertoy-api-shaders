{
    "Shader": {
        "info": {
            "date": "1533475881",
            "description": "Loosely inspired by an album cover. Music is Dink by Dave Monolith. Any tips to reduce the compile times are welcome!",
            "flags": 96,
            "hasliked": 0,
            "id": "XltyRf",
            "likes": 103,
            "name": "[SH18] The Olympian",
            "published": 3,
            "tags": [
                "3d",
                "space",
                "human",
                "sh18"
            ],
            "usePreview": 1,
            "username": "Klems",
            "viewed": 5606
        },
        "renderpass": [
            {
                "code": "// Common contains the sequencer, camera parameters, and a few useful functions.\n// Buffer A contains the music FFT and playback time.\n// Buffer B contains the human geometry, as well as skeletal animations.\n// It's a regular SDF made of boxes, capsules, ellipsoids and smin.\n// The SDF itself is cone traced. RGBA is normal + opacity.\n// Image buffer contains the space background, starfield, lighting, planets, etc.\n// The space background may look volumetric, but it's completely fake.\n// It's essentialy triplanar mapping, but with moving textures instead.\n// X and Y has scrolling textures. Z has an infinite zoom effect.\n// This gives the impression of movement in the Z direction.\n// The starfield uses 6 cylinders raytraced around the camera. No particles\n// were used. I used the same technique in my Star Trek shader.\n// Planets are raytraced spheres. The atmosphere lighting is done by returning\n// the closest point to the planet, and using that for lighting.\n// An exponential fallof is used for the atmosphere itself.\n// I used a 3D texture to be able to profit from the automatic filtering.\n// I used that same texture for the rings as well, for the same reason.\n\n#define PLANETS_COUNT 20\n#define PLANETS_COUNT_REFL 5\n#define PLANETS_DISTANCE 1000.0\n#define PLANETS_SPEED 50.0\n#define PLANETS_OFFSET 30.0\n\n// smooth 3D noise\nvec4 snoise( in vec3 uv ) {\n    const float textureResolution = 32.0;\n\tuv = uv*textureResolution + 0.5;\n\tvec3 iuv = floor( uv );\n\tvec3 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\n\tuv = (uv - 0.5)/textureResolution;\n\treturn texture( iChannel3, uv );\n}\n\n// smooth procedural noise, used when we need better derivatives\nvec4 snoiseProc( in vec3 x ) {\n    x *= 32.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix( hash43(p+vec3(0,0,0)), \n                        hash43(p+vec3(1,0,0)),f.x),\n                   mix( hash43(p+vec3(0,1,0)), \n                        hash43(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash43(p+vec3(0,0,1)), \n                        hash43(p+vec3(1,0,1)),f.x),\n                   mix( hash43(p+vec3(0,1,1)), \n                        hash43(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// from iq filterable procedurals\nfloat grid( in vec3 p ) {\n    const float N = 50.0;\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    vec3 w = max(abs(dpdx), abs(dpdy));\n    vec3 a = p + 0.5*w;                        \n    vec3 b = p - 0.5*w;           \n    vec3 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return 1.0-(1.0-i.x)*(1.0-i.y)*(1.0-i.z);\n}\n\n// planets palette, as HSV\nvec3 palette( in vec3 h ) {\n    vec3 rgb = cos(2.0*PI*h.x + 2.0*PI/3.0*vec3(3,2,1))*0.5+0.5;\n\treturn h.z * mix(vec3(1.0), rgb, h.y);\n}\n\n// used for an infinite zoom effect\nvec4 texZoom( in sampler2D sam, in vec2 uv, in float time, in float seed ) {\n    float frac = fract(time);\n    float id = floor(time);\n    float blend = 0.5 - cos(2.0*PI*frac)*0.5;\n    vec3 rand = hash32( vec2(id, seed) );\n    uv *= rot(rand.x*2.0*PI);\n    uv *= frac;\n    uv += rand.yz;\n    return vec4(texture(sam, uv).rgb, blend);\n}\n\n// used for parallax scrolling\nvec4 texTrans( in sampler2D sam, in vec2 uv, in float time, in float seed ) {\n    vec3 rand = hash31( seed );\n    uv.x += time;\n    uv *= rot(rand.x*2.0*PI);\n    uv += rand.yz;\n    return vec4(texture(sam, uv).rgb, 1);\n}\n\n// infinite zoom effect\nvec3 infiniteZoom(in sampler2D sam, in vec2 uv, in float time, in float seed ) {\n    vec4 acc = vec4(0);\n    for (int i = 0 ; i < 6 ; i++) {\n        float ii = float(i);\n        float phase = ii / 6.0;\n        vec4 tex = texZoom(sam, uv, time+phase, seed+ii);\n        acc.rgb += tex.rgb*tex.a;\n        acc.a += tex.a;\n    }\n    return acc.rgb/acc.a;\n}\n\n// parallax scrolling effect\nvec3 parallaxScroll(in sampler2D sam, in vec2 uv,\n                    in float time, in float seed ) {\n    vec4 acc = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        float ii = float(i);\n        vec4 tex = texTrans(sam, uv, time/(ii+1.0), seed+ii);\n        acc.rgb += tex.rgb*tex.a;\n        acc.a += tex.a;\n    }\n    return acc.rgb/acc.a;\n}\n\n// flying through space effect\nvec3 flythrough( in sampler2D sam, in vec3 dir, in float time, in float freq ) { \n    vec3 colX = parallaxScroll(sam, dir.zy*freq, time*freq, 10.0);\n    vec3 colY = parallaxScroll(sam, dir.zx*freq, time*freq, 20.0);\n    float sig = step(dir.z, 0.0)*2.0-1.0;\n    vec3 colZ = infiniteZoom(sam, dir.xy*3.0*freq, time*sig*0.4, 30.0);\n    dir *= dir;\n    return (colX*dir.x + colY*dir.y + colZ*dir.z) / (dir.x+dir.y+dir.z);\n}\n\n// filtered starfield\nvec3 starfield( in vec3 dir, float position, float speed, in bool reflected ) {\n    vec3 ret = vec3(0);\n    // do less stars when it's reflected off the character\n    float maxRadius = 6.5;\n    if (reflected)\n        maxRadius = 2.5;\n    for (float radius = 1.0 ; radius < maxRadius ; radius += 1.0) {\n        // raytrace a cylinder\n        float x = atan(dir.x, dir.y)/PI;\n        float y = dir.z * radius / length(dir.xy);\n        // map coordinates around that cylinder\n        vec2 uv = vec2(x*3.0*radius, y + position);\n        // rotate each sections by a random angle\n        uv.x += 3.0*radius*hash12(vec2(radius, floor(uv.y)));\n        // use a grid partioning, then add a random offset\n        vec2 cen = floor(uv)+0.5;\n        cen += (hash23(vec3(cen, radius))-0.5)*0.7;\n        // figure out the size of stars, then fix the deformation on y\n        vec2 dim = vec2(0.01);\n        if (reflected)\n            dim *= 4.0;\n        dim.y += speed/radius;\n        dim.y /= sin(atan(radius/abs(y)));\n        // apply a bit of chromatic aberration\n        float redshift = 0.01+speed/radius;\n        cen.y -= redshift;\n        for (int i = 0 ; i < 3 ; i++) {\n            cen.y += redshift;\n            // now add actual stars\n            vec2 inStar = uv-cen;\n            float ellipsis = (length(inStar/dim) - 1.0) * dim.y;\n            // apply distance based filtering on them\n            float dist = (radius*radius+y*y);\n            if (reflected)\n                dist *= 4.0;\n            ret[i] += s(0.02, -0.02, ellipsis) / dist;\n        }\n    }\n    return ret;\n}\n\n// raytrace a planet\nvoid raytracePlanet(in vec3 from, in vec3 dir, in vec3 pos,\n                    in float radius, in float atmosStrength,\n                    out vec3 n, out float atmos, out float aa) {\n    // usual raytrace routine\n    vec3 d = from - pos;\n    float b = dot(dir, d);\n    float c = dot(d, d) - radius*radius;\n    float t = b*b-c;\n    t = -b-sqrt(max(0.0, t));\n    \n    // do some stuff with the angle\n    float dist = length(d);\n    float cosAlpha = max(0.0, -b / dist);\n    float sinAlpha = sin(acos(cosAlpha));\n    // blend atmosphere\n    atmos = 0.0;\n    if (atmosStrength > 0.0)\n    \tatmos = min(1.0, exp((radius-sinAlpha*dist)/atmosStrength*5.0));\n    // anti-aliasing for planets with no atmosphere\n    float aaAngle = length(fwidth(from))*0.1;\n    aa = s(0.002+aaAngle, -0.002, sinAlpha-radius/dist);\n    \n    if (t > 0.0) {\n        // we hit the planet, set position on the surface\n        n = normalize(from + dir*t - pos);\n        // and tweak the atmosphere\n        if (atmosStrength > 0.0)\n        \tatmos *= exp(dot(dir, n)/atmosStrength);\n    } else {\n        // set the position to the closest point to the surface\n        n = normalize(from + dir*cosAlpha*dist - pos);\n    }\n}\n\n// raytrace a plane, used for ringed planets\nfloat raytracePlane(in vec3 from, in vec3 dir,\n                    in vec3 planePos, in vec3 planeNormal ) {\n    float originDist = -dot(planePos, planeNormal);\n    float t = -(dot(planeNormal, from)+originDist)/dot(planeNormal, dir);\n    if ( t > 0.0 )\n        return t;\n    return -1.0;\n}\n\n// colorize planets\nvec3 colorizePlanet(in vec3 diffLight, in vec3 specLight,\n                    in vec3 planetNormal, in vec3 planetAxis,\n                    in float planetRotation, in float atmosphereStrength,\n                    in float volcanic, in float water, in float life,\n                    in float baseHue, in float seed) {\n    // express the planet position around the axis\n    const vec3 up = normalize(vec3(1, 2, PI));\n    vec3 ortho1 = normalize(cross(planetAxis, up));\n    vec3 ortho2 = cross(planetAxis, ortho1);\n    vec3 planetPos = vec3(dot(planetAxis, planetNormal),\n        dot(ortho1, planetNormal), dot(ortho2, planetNormal));\n    vec3 origPos = planetPos;\n    planetPos.yz *= rot(planetRotation);\n    \n    // classic fractal noise\n    planetPos += hash31(seed*2.0);\n    planetPos *= 0.1;\n    vec4 noiseA = snoiseProc(planetPos);\n    // add some swirly\n    planetPos += (noiseA.yzw-0.5)*0.1;\n    planetPos *= 4.0;\n    planetPos.xy *= rot(1.974);\n    planetPos.yz *= rot(2.131);\n    vec4 noiseB = snoise(planetPos);\n    planetPos *= 6.0;\n    planetPos.xy *= rot(0.312);\n    planetPos.yz *= rot(1.037);\n    vec4 noiseC = snoise(planetPos);\n    vec4 noise = (noiseA + noiseB*0.5 + noiseC * 0.25)/(1.0+0.5+0.25);\n    \n    // get the color of the planet, mix it with brown when volcanic\n    vec3 color = vec3(0);\n    color.x = baseHue + (noise.x-0.5)*0.5;\n    color.y = mix(0.3, 1.0-noise.x, volcanic);\n    color.z = mix(1.0-noise.x*0.8, noise.x*0.5, volcanic);\n    vec3 planetColor = palette(color);\n    \n    // add lava on the surface\n    float n = noiseB.y*noiseC.y;\n    vec3 volcanColor = mix(vec3(0.95, 0.06, 0.03), vec3(0.95, 0.75, 0.06),\n                           s(0.8-volcanic*0.3, 1.0, n));\n    vec3 emissive = s(0.6-volcanic*0.5, 1.0, n)*volcanColor*volcanic*0.5;\n    \n    // add water\n    vec4 noiseW = (noiseA.x+noiseB*0.5)/(1.0+0.5);\n    float waterLevel = s(1.0-water, 1.2-water, noiseW.x);\n    vec3 waterColor = palette(vec3(baseHue, 0.9, 0.7));\n    planetColor = mix(planetColor, waterColor, waterLevel);\n    \n    // add life\n    if (life > 0.0) {\n        float lifeLevel = s(0.0+life, -0.2+life, noise.x);\n        lifeLevel = s(0.7*life+0.1, 0.0, noise.x);\n        lifeLevel *= 1.0 - waterLevel;\n        planetColor = mix(planetColor, vec3(0, 1, 0), lifeLevel);\n        // add intelligent life\n        float extend = clamp(1.0-(life-0.9)/0.1, 0.0, 1.0);\n        float smartLife = s(1.0-extend, 0.8-extend, noiseW.x);\n        smartLife *= grid(planetPos*15.0);\n        smartLife *= s(0.5, 0.4, waterLevel);\n        smartLife *= s(0.3, 0.0, length(diffLight)); // HACK!\n        smartLife = clamp(smartLife, 0.0, 1.0);\n        emissive += vec3(0.99, 0.7, 0.4)*smartLife;\n    }\n    \n    // add polar caps\n    float polar = s(1.1-water*0.3, 1.15-water*0.3,\n                    abs(origPos.x) + (noiseW.x-0.5)*0.1);\n    planetColor = mix(planetColor, vec3(2), polar);\n    \n    // and add specular\n    float specular = mix(waterLevel, 1.0, polar);\n    \n    // now do final lighting calculations\n    planetColor *= diffLight;\n    planetColor += specLight*specular;\n    planetColor += emissive;\n    \n    // and finally, add clouds on top of the whole thing\n    if (atmosphereStrength > 0.0) {\n        vec3 cloudPos = origPos;\n        cloudPos.yz *= rot(planetRotation*0.5);\n        cloudPos.yz *= rot(cloudPos.x*1.5);\n        float cloudsStrips = sin(8.0*atan(cloudPos.y, cloudPos.z))*0.5+0.5;\n        cloudsStrips *= s(1.0, 0.9, abs(cloudPos.x));\n        cloudPos += hash31(seed*2.0+1.0);\n        cloudPos *= 0.01;\n        cloudPos += (snoiseProc(cloudPos).xyz-0.5)*0.3;\n        cloudPos *= 4.0;\n        vec4 cloudsN = snoise(cloudPos)*(noiseA*0.5+0.5);\n        float clouds = s(0.3, 1.5, cloudsN.x*1.3+cloudsStrips*0.2);\n        clouds = clamp(clouds*atmosphereStrength*1.5, 0.0, 1.0);\n        vec3 cloudsColor = palette(vec3(baseHue, 0.2, 1.0));\n        cloudsColor *= 1.0 - volcanic*0.8;\n        planetColor = mix(planetColor, cloudsColor*diffLight*2.5, clouds);\n    }\n    \n    // return the color\n    return planetColor;\n}\n\n// colorize atmosphere\nvec3 colorizeAtmosphere(in vec3 atmosLight, in vec3 planetNormal,\n                    \tin float atmosphereStrength,\n                    \tin float volcanic, in float baseHue) {\n    // volcanic planets tend to have a reddish atmosphere\n    vec3 atmosColor = palette(vec3(baseHue, 1, 1));\n    atmosColor = mix(atmosColor, vec3(0.95, 0.26, 0.13), volcanic*0.8);\n    atmosColor *= atmosLight;\n    return atmosColor;\n}\n\n// colorize rings, return rings color and alpha\nvec4 colorizeRings(in float ringsDist, in float planetRadius,\n                   in float baseHue, in float seed) {\n    // this is to avoid filtering issues\n    if (ringsDist > planetRadius*4.0)\n        return vec4(0);\n    vec4 ringsColor = vec4(0);\n    // use a texture to profit from the filtering\n    vec2 rndPos = hash21(seed);\n    vec4 rndRings3 = texture(iChannel3, vec3(ringsDist*0.1, rndPos));\n    // colorize the rings\n    float hue = baseHue + (rndRings3.x-0.5)*0.2;\n    vec3 color = vec3(hue, 0.2+rndRings3.y*0.6, 0.2+rndRings3.z*0.6);\n    ringsColor.rgb = palette(color);\n    // then the alpha\n    float d = fwidth(ringsDist)*0.5;\n    ringsColor.a = s(planetRadius*1.1+0.2-d, planetRadius*1.1+0.4+d, ringsDist);\n    ringsColor.a *= s(planetRadius*2.0+0.2+d, planetRadius*2.0-d, ringsDist);\n    // randomize it a bit\n    ringsColor.a *= rndRings3.w*0.4+0.6;\n    return ringsColor;\n}\n\n// blend in a planet in font of a background\nvec3 addPlanet(in vec3 from, in vec3 dir, in vec3 backColor,\n               in vec3 lightColor, in vec3 lightDir,\n               in vec3 planetPos, in float planetRadius, \n               in vec3 planetAxis, in float planetRotation,\n               in float atmosphereStrength, in bool hasRings,\n               in float volcanic, in float water, in float life,\n               in float baseHue, in float seed, in float baseAlpha) {\n    \n    vec3 toPlanet = planetPos-from;\n    float toPlanetSq = dot(toPlanet, toPlanet);\n    \n    // starts by doing some computations on the rings\n    bool doRings = hasRings;\n    bool ringsBehind = false;\n    vec3 ringsColor = vec3(0);\n    float ringsAlpha = 0.0;\n    \n    if (hasRings) {\n        float distToRings = raytracePlane(from, dir, planetPos, planetAxis);\n        if (distToRings > 0.0) {\n            vec3 onRings = from+dir*distToRings;\n            float ringsDist = length(onRings-planetPos);\n            ringsBehind = distToRings*distToRings > toPlanetSq;\n            // raytrace the planet from the rings, for the shadows\n            vec3 dump1 = vec3(0);\n            float dumpAtmos = 0.0;\n            float dumpAA = 0.0;\n            raytracePlanet(onRings, lightDir, planetPos, planetRadius,\n                           atmosphereStrength, dump1, dumpAtmos, dumpAA);\n            float ringsShadows = (1.0 - dumpAtmos)*(1.0 - dumpAA);\n            // get rings color and alpha\n            vec4 newColor = colorizeRings(ringsDist, planetRadius,\n                                          baseHue, seed);\n            // light the rings, and set the values\n            ringsColor = newColor.rgb;\n            ringsColor *= ringsShadows * lightColor;\n            ringsAlpha = newColor.a;\n        } else {\n            // can't see the rings\n            doRings = false;\n        }\n    }\n    \n    // blend in the rings behind the planet\n    if (doRings && ringsBehind) {\n        backColor = mix(backColor, ringsColor, ringsAlpha*baseAlpha);\n    }\n    \n    // now raytrace the planet, getting its atmosphere and all\n    vec3 planetNormal = vec3(0);\n    float planetAtmos = 0.0;\n    float planetAA = 0.0;\n    raytracePlanet(from, dir, planetPos, planetRadius, atmosphereStrength,\n                   planetNormal, planetAtmos, planetAA);\n    \n    // compute the shadows from the rings\n    float ringsShadows = 1.0;\n    if (hasRings) {\n        vec3 onPlanet = planetPos + planetNormal*planetRadius;\n        float distToRings = raytracePlane(onPlanet, lightDir,\n                                          planetPos, planetAxis);\n        if (distToRings > 0.0) {\n            vec3 onRings = onPlanet + lightDir*distToRings;\n            float ringsDist = length(onRings-planetPos);\n            ringsShadows *= 1.0 - colorizeRings(ringsDist, planetRadius,\n                                                baseHue, seed).a;\n        }\n    }\n    \n    // do lighting calculations\n    float baseLight = dot(planetNormal, lightDir);\n    float atmosLight = baseLight*0.5+0.5;\n    atmosLight *= atmosLight;\n    atmosLight *= atmosLight;\n    baseLight = max(0.0, baseLight);\n    float specTerm = max(0.0, dot(lightDir, reflect(dir, planetNormal)));\n    vec3 diffuse = baseLight * lightColor * ringsShadows;\n    vec3 atmosphere = atmosLight * lightColor;\n    vec3 specular = pow(specTerm, 10.0) * lightColor * ringsShadows * baseLight;\n    vec3 planetColor = vec3(0);\n    vec3 atmosColor = vec3(0);\n    \n    // colorize planets\n    if (planetAA > 0.001) {\n        planetColor = colorizePlanet(diffuse, specular, planetNormal,\n                                     planetAxis, planetRotation,\n                                     atmosphereStrength, volcanic,\n                                     water, life, baseHue, seed);\n    }\n    \n    // and their atmosphere\n    if (planetAtmos > 0.001) {\n        atmosColor = colorizeAtmosphere(atmosphere, planetNormal,\n                                        atmosphereStrength,\n                                        volcanic, baseHue);\n    }\n    \n    // add the planet\n    backColor = mix(backColor, planetColor, planetAA*baseAlpha);\n    // then the atmosphere\n    backColor = mix(backColor, atmosColor, planetAtmos*baseAlpha);\n    \n    // and finally blend in the rings in front of the planet\n    if (doRings && !ringsBehind) {\n        backColor = mix(backColor, ringsColor, ringsAlpha*baseAlpha);\n    }\n    \n    return backColor;\n}\n\n// add random planets passing by\nvec3 addRandomPlanets( in vec3 dir, in float time,\n                      in vec3 backColor, in bool reflected ) {\n    const float delta = PLANETS_DISTANCE / float(PLANETS_COUNT);\n    float posi = time / (PLANETS_DISTANCE/PLANETS_SPEED);\n    posi *= float(PLANETS_COUNT);\n    float frac = fract(posi);\n    float floo = floor(posi);\n    \n    // render less planets in the reflection\n    int start = 0;\n    if (reflected)\n        start = PLANETS_COUNT-PLANETS_COUNT_REFL;\n    \n    // add a bunch of planets\n    for (int i = start ; i < PLANETS_COUNT ; i++) {\n        int temp = PLANETS_COUNT - i;\n        if (i % 2 == 0)\n            temp = -temp+1;\n        \n        float ii = float(temp)+1.0;\n        float dist = ii*delta;\n        dist -= frac*delta*2.0;\n        float seed = ii + floo*2.0;\n        // fade in/out the planets\n        float alpha = s(PLANETS_DISTANCE, PLANETS_DISTANCE*0.8, abs(dist));\n        \n        // get a bunch of random numbers\n        vec4 rnd1 = hash41(seed*3.0+0.0);\n        vec4 rnd2 = hash41(seed*3.0+1.0);\n        vec4 rnd3 = hash41(seed*3.0+2.0);\n        \n        // base hue\n        float hue = rnd1.x;\n        // get a random radius\n        float radius = 1.0 + rnd1.y*8.0;\n        // get a random offset\n        float angle = rnd1.z*2.0*PI;\n        vec2 off = vec2(cos(angle), sin(angle));\n        off *= PLANETS_OFFSET*rnd1.w+radius*1.5;\n        vec3 planetPos = vec3(off, dist);\n        // random axis, tilt it slightly horizontally\n        vec3 planetAxis = vec3(0, 1, 0);\n        planetAxis.xz += (rnd2.xy-0.5)*0.5;\n        planetAxis.z -= 0.5;\n        planetAxis = normalize(planetAxis);\n        // random rotation\n        float rota = time*(0.2+rnd2.z*0.2);\n        // random atmosphere\n        float atmos = rnd2.w;\n        if (atmos < 0.2)\n            atmos = 0.0;\n        if (radius < 3.0)\n            atmos = 0.0;\n        \n        // random stuff\n        bool hasRings = false;\n        float volcanic = 0.0;\n        float water = 0.0;\n        if (rnd3.x < 0.3) {\n            // small chance of a volcanic planet\n            volcanic = rnd3.y;\n        } else {\n            // if the planet isn't volcanic, it may have water\n            water = rnd3.z;\n            if (water < 0.2)\n                water = 0.0;\n            if (atmos < 0.3)\n                water = 0.0;\n        }\n        \n        // when the planet isn't too volcanic or too small, it may have rings\n        if (volcanic < 0.5 && radius > 3.0)\n            hasRings = rnd3.w < 0.3;\n        \n    \tconst vec3 lightDir = normalize(vec3(6, 4, -2));\n        backColor = addPlanet(vec3(0), dir, backColor, vec3(1), lightDir,\n                              planetPos, radius, planetAxis, rota, atmos,\n                              hasRings, volcanic, water, 0.0, hue,\n                              seed, alpha);\n    }\n    \n    return backColor;\n    \n}\n\n// colored cloud/nebula\nvec3 cloud( in vec3 dir, in float hue ) {\n    // deformed circle\n    vec2 ab = dir.xy;\n    ab.x *= (abs(ab.y)+0.1)*5.0;\n    ab.y *= abs(step(ab.y, 0.0)*0.7+0.7);\n    \n    // use the fft from the soundtrack to add more flavor\n    const vec2 df1 = vec2(0.02, 0);\n    const vec2 df2 = vec2(0.1, 0);\n    float ffta = textureGrad(iChannel0, vec2(abs(dir.x)*2.0, 0), df1, df1).r;\n    float fftb = textureGrad(iChannel0, vec2(abs(ab.y)*2.0, 0), df2, df2).r;\n    \n    // base formula from an exponential\n    float len = length(ab);\n    float base = exp(-len*8.0 + 5.0 )*0.1;\n    base *= s(0.3, -0.3, dir.z);\n    base *= ffta;\n    base *= fftb;\n    \n    // and return a color from the palette\n    return palette(vec3(hue+base*0.04, 0.8, 1.0))*base;\n}\n\n// get the background color, with nebulas/stars/planets passing by\nvec3 getBackground(in vec3 dir, in bool reflected,\n                   in int seqID, in float seqTime, in float time) {\n    \n    float position = time*0.1;\n    float speed = 0.0;\n    \n    if (seqID == 1 || seqID == 3 || seqID == 6) {\n        // flying through space\n        position = time*1.5;\n        speed = 0.04;\n    } else if (seqID == 2) {\n        // closeup\n        position = time*3.0;\n        speed = 0.08;\n    }\n    \n    // weird shapes flying around\n    vec3 nebula = flythrough(iChannel2, dir, position*0.2, 0.2);\n    nebula = 1.0 - nebula;\n    nebula *= nebula;\n    nebula *= nebula;\n    // colorize those shapes\n    vec3 colPos = dir*0.07;\n    colPos.z += position*0.01;\n    colPos.xy *= rot(0.741);\n    colPos.yz *= rot(1.164);\n    vec3 color = snoise(colPos).rgb;\n    color = color*1.3+0.2;\n    color *= color;\n    // compositing\n    vec3 baseColor = nebula*color*0.3;\n    baseColor *= baseColor;\n    // add stars passing by\n    baseColor += starfield(dir, position, speed, reflected)*2.0;\n    \n    // add nebulas/clouds reacting to music\n    vec3 dirA = dir;\n    dirA.xz *= rot(0.3);\n    dirA.yz *= rot(0.1);\n    float cloudA = 0.0;\n    vec3 dirB = dir;\n    dirB.xz *= rot(-0.2);\n    float cloudB = 0.0;\n    if (seqID == 0) {\n        cloudB = 1.0;\n    } else if (seqID == 1) {\n        cloudA = s(18.0, 20.0, seqTime)-s(20.0, 22.0, seqTime);\n        cloudB = s(22.0, 24.0, seqTime)-s(24.0, 26.0, seqTime);\n    } else if (seqID == 4) {\n        dirA = dir;\n        cloudA = 1.0;\n    } else if (seqID == 6) {\n        dirB = dir;\n        dirB.z = -dirB.z;\n        cloudB = 1.0;\n    }\n    \n\t// lower tone\n    baseColor += cloud( dirA, 0.6 )*0.15*cloudA;\n    // higher tone\n    baseColor += cloud( dirB, 0.9 )*0.2*cloudB;\n    \n    if (seqID == 0) {\n        // do nothing\n    } else if (seqID == 3) {\n        // zig zag between planets\n        vec3 from = vec3(0, 0.5, 0);\n        from.x += sin(seqTime*0.5)*4.0;\n        from.z += seqTime*10.0;\n        const vec3 axis = normalize(vec3(-2, 15, -1));\n        const vec3 lightDir = normalize(vec3(6, 4, -2));\n        baseColor = addPlanet(from, dir, baseColor, vec3(1), lightDir,\n                              vec3(0, 0, PI*50.0), 2.0, axis, seqTime*0.6,\n                              0.2, false, 0.8, 0.0, 0.0, 0.1, 0.0, 1.0);\n        baseColor = addPlanet(from, dir, baseColor, vec3(1), lightDir,\n                              vec3(0, 0, PI*30.0), 3.0, axis, seqTime*0.6,\n                              0.5, true, 0.0, 0.7, 0.0, 0.3, 1.0, 1.0);\n        baseColor = addPlanet(from, dir, baseColor, vec3(1), lightDir,\n                              vec3(0, 0, PI*10.0), 1.5, axis, seqTime*0.6,\n                              0.5, false, 0.0, 0.0, 0.0, 0.6, 2.0, 1.0);\n    } else if (seqID == 4) {\n        // add a single ringed planet\n        const vec3 axis = normalize(vec3(-2, 15, -1));\n        const vec3 lightDir = normalize(vec3(-10, 4, 16));\n        vec3 planetPos = vec3(10, -1, 0);\n        baseColor = addPlanet(vec3(0), dir, baseColor, vec3(1), lightDir,\n                              planetPos, 7.0, axis, seqTime*0.1,\n                              0.8, true, 0.0, 0.0, 0.0, 0.65, 3.0, 1.0);\n    } else if (seqID == 5) {\n        // add a sun\n        float sun = s(11.0, 6.0, seqTime);\n        vec3 sunColor = mix(vec3(0.99, 0.9, 0.8), vec3(0.99, 0.3, 0.2), sun);\n        vec3 sunPos = vec3(2, 1, 5);\n        vec3 sunPosN = normalize(sunPos);\n        // make the sun look a bit more interesting\n        vec3 sunPosNA = normalize(cross(sunPosN, vec3(0, 1, 0)));\n        vec3 sunPosNB = cross(sunPosN, sunPosNA);\n        float a = dot(dir, sunPosNA);\n        float b = dot(dir, sunPosNB);\n        vec2 ab = vec2(a, b);\n        ab = exp(-abs(ab)*20.0)*(sun*0.9+0.1);\n        float sunA = acos(dot(sunPosN, dir));\n        sunA = exp(-sunA*10.0 + ab.x + ab.y + 1.3)*0.2;\n        baseColor += sunA*sunColor;\n        // add a earth like planet\n        const vec3 axis = normalize(vec3(2, 8, -4));\n        vec3 planetPos = vec3(-2.5, 0, 3);\n        vec3 lightDir = normalize(sunPos-planetPos);\n        float rota = seqTime*0.1;\n        // earth gets colder, then water and life appear\n        float volc = s(20.0, 10.0, seqTime);\n        float water = s(14.0, 24.0, seqTime)*0.6;\n        float life = s(24.0, 38.0, seqTime);\n        baseColor = addPlanet(vec3(0), dir, baseColor, sunColor, lightDir,\n                              planetPos, 1.6, axis, rota, 0.3,\n                              false, volc, water, life, 0.6, 3.0, 1.0);\n    } else {\n        // otherwise, add planets passing by\n    \tbaseColor = addRandomPlanets(dir, position, baseColor, reflected);\n    }\n    \n    return baseColor;\n}\n\n// lighting/highlight color for the dude\nvec3 getLighting( in vec3 dir ) {\n    const vec3 ori1 = normalize(vec3(1, 2, -3));\n    const vec3 ori2 = normalize(vec3(1, -2, 2));\n    float lig1 = dot(dir, ori1)*0.5+0.5;\n    float lig2 = dot(dir, ori2)*0.5+0.5;\n    vec3 ret = vec3(0);\n    ret += vec3(0.95, 0.6, 0.1)*pow(lig1+0.25, 12.0);\n    ret += vec3(0.6, 0.1, 0.9)*pow(lig2+0.08, 48.0);\n    return ret;\n}\n\n// apply direction deformation\nvec2 deformDir( in vec2 uv, in int seqID, in float seqTime ) {\n    \n    // do some bubble deformation in the intro\n    if (seqID == 0) {\n        float len = length(uv);\n        vec2 dir = uv / len;\n        float f = fract(seqTime*2.0);\n        f = s(0.0, 0.8, f) - s(0.8, 1.0, f);\n        f *= seqTime/7.0;\n        f *= step(seqTime, 7.0);\n        float b = s(6.5, 7.5, seqTime) - s(8.0, 8.2, seqTime);\n        uv += dir*sqrt(len)*f*0.2;\n        uv -= dir*sqrt(len)*b*0.5;\n    }\n    \n    // otherwise do nothing\n    return uv;\n}\n\n// do some funky effects when the dude appears\nfloat deformAlpha( in vec2 uv, in int seqID, in float seqTime ) {\n    \n    // spiral like apparition in the intro\n    if (seqID == 0) {\n        float move = s(6.5, 9.5, seqTime);\n        float len = length(uv);\n        float base = cos(len*120.0)*0.5+0.5;\n        base *= move;\n        base *= len;\n        base += s(1.0, 0.0, len+4.0-move*6.0);\n        base = clamp(base, 0.0, 1.0);\n        return base;\n    }\n    \n    // otherwise do nothing\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // fetch the playback time\n    float time = texelFetch(iChannel0, ivec2(0), 0).a;\n    // get the sequence and the time in it\n    int seqID = 0;\n    float seqTime = 0.0;\n    getSequence(time, seqID, seqTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord-iResolution.xy*0.5;\n    uv /= iResolution.y;\n    uv = deformDir(uv, seqID, seqTime);\n    // get the direction and position\n    vec3 dir = vec3(0);\n    vec3 from = vec3(0);\n    getCamera(uv, seqID, seqTime, dir, from);\n    fragColor = vec4(deformAlpha(uv, seqID, seqTime));\n    \n    // get our dude in front of the background\n    vec4 dude = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    dude.a *= deformAlpha(uv, seqID, seqTime);\n    \n    // blend between the reflected dir, and the actual direction\n    vec3 normal = dude.xyz;\n    vec3 backDir = reflect(dir, normal);\n    backDir = mix(dir, backDir, dude.a);\n    \n    // get background color from direction\n    fragColor.rgb = getBackground(backDir, dude.a > 0.5, seqID, seqTime, time);\n    \n    // mix our dude with the background, add some lighting\n    vec3 lighting = getLighting(backDir);\n    float fresnel = max(0.0, -dot(normal, dir));\n    fresnel *= fresnel;\n    vec3 baseColor = mix(lighting, fragColor.rgb, fresnel);\n    baseColor *= fresnel;\n    fragColor.rgb = mix(fragColor.rgb, baseColor, dude.a);\n    \n    // gamma correction, dithering, vignette, etc\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    fragColor.rgb += (hash33(vec3(fragCoord, iFrame))-0.5)*0.02;\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n    vec2 vig = (fragCoord-iResolution.xy*0.5)/iResolution.xy;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(vig, vig)*0.2);\n    \n    // fade in/out\n    float fadeIn = s(0.0, 2.0, time);\n    fragColor.rgb = mix(vec3(0), fragColor.rgb, fadeIn);\n    float fadeOut = s(153.0, 157.0, time);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), fadeOut);\n    \n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n#define s(a, b, x) smoothstep(a, b, x)\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n#define Z min(0, iFrame)\n\n// simpler, easier version to compile of the dude\n// #define SIMPLE_HUMAN\n\n// hash functions by Dave_Hoskins\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat hash11( in float p ) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12( in vec2 p ) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13( in vec3 p3 ) {\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21( in float p ) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22( vec2 p ) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23( in vec3 p3 ) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash31( in float p ) {\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash32( in vec2 p ) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash33( in vec3 p3 ) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash41( in float p ) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash42( in vec2 p ) {\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash43( in vec3 p ) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash44( in vec4 p4 ) {\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// 1D perlin, between -1 and 1\nfloat perlin( in float x, in float seed ) {\n    x += hash11(seed);\n    float a = floor(x);\n    float b = a + 1.0;\n    float f = fract(x);\n    a = hash12(vec2(seed, a));\n    b = hash12(vec2(seed, b));\n    f = f*f*(3.0-2.0*f);\n    return mix(a, b, f)*2.0-1.0;\n}\n\n// return sequence id and time in this sequence\nvoid getSequence( in float time, out int seqID, out float seqTime ) {\n    \n    seqID = 0;\n    seqTime = time;\n    \n    if (time < 34.0) {\n        seqID = 0;\n        seqTime = time;\n    } else if (time < 64.0) {\n        seqID = 1;\n        seqTime = time-34.0;\n    } else if (time < 74.0) {\n        seqID = 2;\n        seqTime = time-64.0;\n    } else if (time < 94.0) {\n        seqID = 3;\n        seqTime = time-74.0;\n    } else if (time < 104.0) {\n        seqID = 4;\n        seqTime = time-94.0;\n    } else if (time < 144.0) {\n        seqID = 5;\n        seqTime = time-104.0;\n    } else {\n        seqID = 6;\n        seqTime = time-144.0;\n    }\n\n}\n\n// return vertical fov\nfloat getFOV( in int seqID, in float seqTime ) {\n    \n    if (seqID == 2) {\n        // slightly higher fov in the closeup\n        return 1.5;\n    } else if(seqID == 4) {\n        // zoom in on the dude passing by a planet\n        return 1.0 - s(5.0, 9.0, seqTime)*0.98;\n    }\n    \n    return 1.0;\n}\n\n// camera direction and position\nvoid getCamera(in vec2 uv, in int seqID, in float seqTime,\n               out vec3 dir, out vec3 from ) {\n    \n    // look at and up vector\n    vec3 up = vec3(0, 1, 0);\n    vec3 lookAt = vec3(0);\n    from = vec3(0, 0, -1);\n    \n    if (seqID == 0) {\n        // rotate around our dude\n        up = normalize(vec3(1, 10, 2));\n        lookAt = vec3(0);\n        float rota = seqTime*0.1;\n        from = vec3(cos(rota), 0, sin(rota))*5.0;\n        // send our dude flying\n        from.z -= s(31.7, 37.0, seqTime)*200.0;\n        from.z -= s(30.5, 34.0, seqTime)*5.0;\n        // makes the camera a bit more interesting\n        lookAt.x += perlin(seqTime*0.3, 0.0)*0.3;\n        lookAt.y += perlin(seqTime*0.3, 1.0)*0.3;\n        lookAt.z += perlin(seqTime*0.3, 2.0)*0.3;\n    } else if (seqID == 1) {\n        // rotate around our dude\n        up = normalize(vec3(2, 12, 3));\n        lookAt = vec3(0);\n        float rota = seqTime*0.2 + 3.5;\n        from = vec3(cos(rota), 0.2, sin(rota))*4.0;\n    } else if (seqID == 2) {\n        // closeup on the dude\n        up = vec3(0, 1, 0);\n        lookAt = vec3(0, 0.7, 0);\n        // add a bit of shaking\n        lookAt.x += perlin(seqTime*5.0, 0.0)*0.1;\n        lookAt.y += perlin(seqTime*5.0, 1.0)*0.1;\n        // zoom in on his face\n        from = vec3(0, 0.8, 4.0 - seqTime*0.13);\n    } else if (seqID == 3) {\n        // zigzag around planets\n        up = normalize(vec3(2, 12, 3));\n        float devia = sin(seqTime*0.5);\n        float sqDevia = devia*devia;\n        sqDevia *= sqDevia;\n        lookAt = vec3(0, 0.5, 1);\n        lookAt.x += perlin(seqTime*10.0, 0.0)*0.1*sqDevia;\n        lookAt.y += perlin(seqTime*10.0, 1.0)*0.1*sqDevia;\n        lookAt.z += perlin(seqTime*10.0, 2.0)*0.1*sqDevia;\n        from = vec3(devia*6.0, 2, -6);\n    } else if (seqID == 4) {\n        // starts near a planet, look at the dude passing by\n        up = normalize(vec3(4, 12, -3));\n        lookAt = vec3(0);\n        float move = (seqTime - 5.0)*50.0;\n        from = vec3(-20, 0, 0);\n        from.z -= move;\n    } else if (seqID == 5) {\n        \n        // look at the dude flying and braking\n        up = normalize(vec3(1, 12, -2));\n        // look in front of the dude\n        lookAt = s(1.0, 4.0, seqTime)*vec3(0, 0.5, 3);\n        \n        // look toward the sun\n        float rota = 0.8;\n        // then look toward the earth\n        rota += s(9.0, 13.0, seqTime)*1.7;\n        vec2 off = vec2(cos(rota), sin(rota))*7.0;\n        from = lookAt + vec3(-off.x, 0, -off.y);\n        // at the beginning, look at the dude in the distance\n        from.z += s(4.0, -4.0, seqTime)*150.0;\n        \n        // makes the camera a bit more interesting\n        lookAt.x += perlin(seqTime*0.3, 0.0)*0.3;\n        lookAt.y += perlin(seqTime*0.3, 1.0)*0.3;\n        lookAt.z += perlin(seqTime*0.3, 2.0)*0.3;\n        \n        // zoom on the planet\n        float f1 = s(21.0, 28.0, seqTime);\n        const vec3 planet = vec3(-2.5, 0, 3);\n        from = mix(from, vec3(-3, 0, 5), f1);\n        lookAt = mix(lookAt, from+planet, f1);\n\n    } else if (seqID == 6) {\n        // dude passing by\n        up = normalize(vec3(2, 12, 3));\n        lookAt = vec3(0, 0, 1);\n        from = vec3(-4, -1, 15);\n        from.z -= s(-1.0, 20.0, seqTime)*100.0;\n    }\n    \n    vec3 forward = normalize(lookAt - from);\n    vec3 right = normalize(cross(forward, up));\n    vec3 upward = cross(right, forward);\n    float fov = getFOV(seqID, seqTime);\n    float dist = 0.5 / tan(fov*0.5);\n    \n    dir = normalize(forward*dist + right*uv.x + upward*uv.y);\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// store FFT in a buffer, store playback in alpha channel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \tfloat x = fragCoord.x/iResolution.x;\n    vec2 uv = vec2(x, 0.25);\n    fragColor.rgb = texture(iChannel0, uv).rgb;\n    fragColor.a = iChannelTime[0];\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 15599,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/dave-monolith/dink"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// iq distance functions\nfloat sdBox( in vec3 p, in vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat smin( in float a, in float b, in float s ) {\n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0.0, 1.0 );\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// skeleton, represented as pitch/yaw/roll rotations\nvec3 skel[16];\n\n// rotate a limb\nvec3 rotateLimb( in vec3 p, in int i ) {\n    vec3 pitchYawRoll = skel[i];\n    p.xz *= rot(pitchYawRoll.y);\n    p.yz *= rot(pitchYawRoll.x);\n    p.xz *= rot(pitchYawRoll.z);\n    return p;\n}\n\n// rotate an arm\nvec3 rotateArm(vec3 p, int i ) {\n    vec3 pitchYawRoll = skel[i];\n    p.xz *= rot(pitchYawRoll.y);\n    p.xy *= rot(pitchYawRoll.x);\n    p.yz *= rot(pitchYawRoll.z);\n    return p;\n}\n\n// 0  = upper body\n// 1  = lower body\n// 2  = neck\n// 3  = head\n// 4  = right shoulder\n// 5  = right elbow\n// 6  = right hand\n// 7  = left shoulder\n// 8  = left elbow\n// 9  = left hand\n// 10 = right hip\n// 11 = right knee\n// 12 = right foot\n// 13 = left hip\n// 14 = left knee\n// 15 = left foot\n\n// initialize skeleton\nvoid initSkel( in int seqID, in float seqTime, in float time ) {\n    \n    for (int i = 0 ; i < skel.length() ; i++) {\n        skel[i] = vec3(0);\n    }\n    \n    float pTime = time*0.3;\n    float p0 = perlin(pTime, 0.0)*0.2;\n    float p1 = perlin(pTime, 1.0)*0.2;\n    float p2 = perlin(pTime, 2.0)*0.2;\n    float p3 = perlin(pTime, 3.0)*0.2;\n    float p4 = perlin(pTime, 4.0)*0.2;\n    float p5 = perlin(pTime, 5.0)*0.2;\n    float p6 = perlin(pTime, 6.0)*0.2;\n    float p7 = perlin(pTime, 7.0)*0.2;\n    \n    if (seqID == 0) {\n        \n        // appear\n        skel[2] = vec3(0.1, 0, 0);\n        skel[3] = vec3(0.2, 0, 0);\n        skel[4] = vec3(0.2, 0, 0);\n        skel[7] = vec3(0.2, 0, 0);\n        skel[10] = vec3(0.3, 0.7, 0);\n        skel[13] = vec3(0.3, 0.7, 0);\n        \n        // float around\n        float f1 = s(8.0, 10.0, seqTime);\n        skel[1] = mix(skel[1], vec3(-0.1, 0, 0), f1);\n        skel[2] = mix(skel[2], vec3(0.1, 0, 0), f1);\n        skel[3] = mix(skel[3], vec3(0.1, 0, 0), f1);\n        skel[4] = mix(skel[4], vec3(1.2 + p0, 0, -0.7), f1);\n        skel[5] = mix(skel[5], vec3(0, -0.3 + p1, 0), f1);\n        skel[6] = mix(skel[6], vec3(0, -0.2, 0), f1);\n        skel[7] = mix(skel[7], vec3(1.2 + p2, 0, -0.2), f1);\n        skel[8] = mix(skel[8], vec3(0, -0.5 + p3, 0), f1);\n        skel[9] = mix(skel[9], vec3(0, -0.2, 0), f1);\n        skel[10] = mix(skel[10], vec3(0.8 + p4, 0.2, 0), f1);\n        skel[11] = mix(skel[11], vec3(-0.6 + p5, 0, 0), f1);\n        skel[12] = mix(skel[12], vec3(-0.6, 0, 0), f1);\n        skel[13] = mix(skel[13], vec3(0.7 + p6, 0.2, 0), f1);\n        skel[14] = mix(skel[14], vec3(-0.6 + p7, 0, 0), f1);\n        skel[15] = mix(skel[15], vec3(-0.6, 0, 0), f1);\n        \n        // look at his arms\n        float f2 = s(10.0, 16.0, seqTime) - s(15.0, 20.0, seqTime);\n        skel[2] = mix(skel[2], vec3(-0.3, 0, 0), f2);\n        skel[3] = mix(skel[3], vec3(-0.4, -0.5, 0), f2);\n        skel[4] = mix(skel[4], vec3(0.8, -0.9, 0), f2);\n        skel[5] = mix(skel[5], vec3(0.0, -1.0, 0), f2);\n        skel[6] = mix(skel[6], vec3(0.0, -0.3, 0), f2);\n        float f3 = s(18.0, 22.0, seqTime) - s(26.0, 28.0, seqTime);\n        skel[2] = mix(skel[2], vec3(-0.3, 0, 0), f3);\n        skel[3] = mix(skel[3], vec3(-0.4, 0.5, 0), f3);\n        skel[7] = mix(skel[7], vec3(0.8, -0.9, 0), f3);\n        skel[8] = mix(skel[8], vec3(0.0, -1.0, 0), f3);\n        skel[9] = mix(skel[9], vec3(0.0, -0.3, 0), f3);\n        \n        // go into flying\n        float f4 = s(31.5, 34.0, seqTime);\n        skel[0] = mix(skel[0], vec3(-1.2, 0, 0), f4);\n        skel[1] = mix(skel[1], vec3(-0.4, 0, 0), f4);\n        skel[2] = mix(skel[2], vec3(0.3, 0, 0), f4);\n        skel[3] = mix(skel[3], vec3(0.4, 0, 0), f4);\n        skel[4] = mix(skel[4], vec3(1.2, 0.3, 0), f4);\n        skel[7] = mix(skel[7], vec3(1.2, 0.3, 0), f4);\n        skel[10] = mix(skel[10], vec3(-0.3, -0.3, 0.3), f4);\n        skel[11] = mix(skel[11], vec3(-0.1, 0, 0), f4);\n        skel[12] = mix(skel[12], vec3(-0.6, 0, 0), f4);\n        skel[13] = mix(skel[13], vec3(-0.2, -0.3, 0.3), f4);\n        skel[14] = mix(skel[14], vec3(-0.2, 0, 0), f4);\n        skel[15] = mix(skel[15], vec3(-0.6, 0, 0), f4);\n        \n    } else if (seqID == 1 || seqID == 3 || seqID == 4 || seqID == 6) {\n        \n        // for the zigzag sequence, rotate the body\n        float rot = 0.0;\n        if (seqID == 3)\n            rot = sin(seqTime*0.5-0.5);\n        else if (seqID == 4)\n            rot = -0.5;\n        \n        // fly around\n        skel[0] = vec3(-1.3, 0, rot);\n        skel[1] = vec3(-0.1, 0, 0);\n        skel[2] = vec3(0.3, 0, 0);\n        skel[3] = vec3(0.4, 0, 0);\n        skel[4] = vec3(1.3+p0, 0.3, 0);\n        skel[5] = vec3(0, -0.2+p6, 0);\n        skel[7] = vec3(1.3+p1, 0.3, 0);\n        skel[8] = vec3(0, -0.2+p7, 0);\n        skel[10] = vec3(-0.1+p2, -0.3, 0.3);\n        skel[11] = vec3(-0.1+p3, 0, 0);\n        skel[12] = vec3(-0.6, 0, 0);\n        skel[13] = vec3(-0.1+p4, -0.3, 0.3);\n        skel[14] = vec3(-0.2+p5, 0, 0);\n        skel[15] = vec3(-0.6, 0, 0);\n        \n    } else if (seqID == 2) {\n        \n        // look at the camera\n        skel[0] = vec3(-1.1, 0, 0);\n        skel[1] = vec3(-0.4, 0, 0);\n        skel[2] = vec3(0.5, 0, 0);\n        skel[3] = vec3(0.5, 0, 0);\n        skel[4] = vec3(1.2+p0, 0.3, 0);\n        skel[5] = vec3(0.0, -0.3+p1, 0);\n        skel[7] = vec3(1.2+p2, 0.3, 0);\n        skel[8] = vec3(0.0, -0.3+p3, 0);\n        skel[10] = vec3(-0.6+p4, -0.7, 0.6);\n        skel[12] = vec3(-0.6+p5, 0, 0);\n        skel[13] = vec3(-0.6+p6, -0.7, 0.6);\n        skel[15] = vec3(-0.6+p7, 0, 0);\n        \n    } else if (seqID == 5) {\n        \n        // start flying, and brake near the camera\n        skel[0] = vec3(-1.2, 0, 0);\n        skel[1] = vec3(-0.2, 0, 0);\n        skel[2] = vec3(0.3, 0, 0);\n        skel[3] = vec3(0.4, 0, 0);\n        skel[4] = vec3(1.3+p0, 0.3, 0);\n        skel[7] = vec3(1.3+p1, 0.3, 0);\n        skel[10] = vec3(-0.1+p2, -0.3, 0.3);\n        skel[11] = vec3(-0.1+p3, 0, 0);\n        skel[12] = vec3(-0.6, 0, 0);\n        skel[13] = vec3(-0.1+p4, -0.3, 0.3);\n        skel[14] = vec3(-0.2+p5, 0, 0);\n        skel[15] = vec3(-0.6, 0, 0);\n        \n        // float around\n        float f1 = s(1.0, 4.0, seqTime);\n        skel[0] = mix(skel[0], vec3(0, 0, 0), f1);\n        skel[1] = mix(skel[1], vec3(0, 0, 0), f1);\n        skel[2] = mix(skel[2], vec3(0.1, 0, 0), f1);\n        skel[3] = mix(skel[3], vec3(0.2, 0, 0), f1);\n        skel[4] = mix(skel[4], vec3(1.3 + p0, 0, 0), f1);\n        skel[5] = mix(skel[5], vec3(0, -0.3 + p1, 0), f1);\n        skel[6] = mix(skel[6], vec3(0, -0.2, 0), f1);\n        skel[7] = mix(skel[7], vec3(1.3 + p2, 0, 0), f1);\n        skel[8] = mix(skel[8], vec3(0, -0.5 + p3, 0), f1);\n        skel[9] = mix(skel[9], vec3(0, -0.2, 0), f1);\n        skel[10] = mix(skel[10], vec3(0.3 + p4, 0.2, 0), f1);\n        skel[11] = mix(skel[11], vec3(-0.6 + p5, 0, 0), f1);\n        skel[12] = mix(skel[12], vec3(-0.8, 0, 0), f1);\n        skel[13] = mix(skel[13], vec3(0.2 + p6, 0.2, 0), f1);\n        skel[14] = mix(skel[14], vec3(-0.6 + p7, 0, 0), f1);\n        skel[15] = mix(skel[15], vec3(-0.8, 0, 0), f1);\n        \n        // point toward the sun\n        float f2 = s(3.0, 7.0, seqTime);\n        float f22 = s(6.0, 10.0, seqTime);\n        skel[0] = mix(skel[0], vec3(0.0, -0.7, 0), f2);\n        skel[3] = mix(skel[3], vec3(0.1, 0.7, 0), f2);\n        skel[7] = mix(skel[7], vec3(-0.2, -0.4, 0.8), f2);\n        skel[8] = mix(skel[8], vec3(0, -0.6, 0), f2);\n        skel[9] = mix(skel[8], vec3(0, -1.3, 0), f22);\n\n        // look at the earth\n        float f3 = s(10.0, 12.0, seqTime);\n        skel[3] = mix(skel[3], vec3(0, 0, 0), f3);\n        skel[7] = mix(skel[7], vec3(1.2 + p2, 0, 0), f3);\n        skel[8] = mix(skel[8], vec3(0, -0.5 + p3, 0), f3);\n        skel[9] = mix(skel[9], vec3(0, -0.2, 0), f3);\n        \n        // move the arms up\n        float f4 = s(17.0, 20.0, seqTime);\n        skel[4] = mix(skel[4], vec3(0, -1.2, 1.7), f4);\n        skel[5] = mix(skel[5], vec3(0, -0.5, 0), f4);\n        skel[6] = mix(skel[6], vec3(0, -0.5, 0), f4);\n        skel[7] = mix(skel[7], vec3(0, -1.2, 1.7), f4);\n        skel[8] = mix(skel[8], vec3(0, -0.5, 0), f4);\n        skel[9] = mix(skel[9], vec3(0, -0.5, 0), f4);\n        \n        // and back down\n        float f5 = s(21.0, 23.0, seqTime);\n        skel[4] = mix(skel[4], vec3(1.3, 0.0, -0.4), f5);\n        skel[5] = mix(skel[5], vec3(0, -0.2, 0.0), f5);\n        skel[6] = mix(skel[6], vec3(0, 0, 0), f5);\n        skel[7] = mix(skel[7], vec3(1.3, 0.0, -0.4), f5);\n        skel[8] = mix(skel[8], vec3(0, -0.2, 0), f5);\n        skel[9] = mix(skel[9], vec3(0, 0, 0), f5);\n        \n    }\n    \n}\n\nfloat getTorso( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdBox(p - vec3(0, 0.25, 0.0), vec3(0.3, 0.25, 0.1))-0.15;\n    #endif\n    \n    vec3 mainDim = vec3(0.35, 0.15, 0.05);\n    mainDim.x -= cos(p.y*2.0+0.8)*0.19;\n    mainDim.y -= cos(p.x*7.0)*0.05;\n    vec3 inTorso = p - vec3(0, 0.15, 0.05);\n    inTorso.z += s(-0.2, 0.5, inTorso.y)*0.2;\n    float torso = sdBox(inTorso, mainDim) - 0.15;\n    \n    vec3 trapDim = vec3(0.15, 0.13, 0);\n    vec3 inTrap = inTorso - vec3(0.2, 0.33, -0.07);\n    inTrap.xy *= rot(0.4);\n    inTrap.yz *= rot(-0.2);\n    float trap = sdBox(inTrap, trapDim)-0.13;\n    \n    vec3 pecDim = vec3(0.11, 0.08, 0.0);\n    pecDim.y += sin(inTorso.x*7.5)*0.05;\n    vec3 inPec = inTorso - vec3(0.19, 0.2, 0.12);\n    float pec = sdBox(inPec, pecDim) - 0.1;\n    float pecMore = length(inPec)-0.15;\n    pec = smin(pec, pecMore, 0.25);\n    \n    float spine = s(0.13, 0.0, p.x)*s(0.1, -0.3, p.z);\n    \n    float d = torso;\n    d = smin(d, trap, 0.1);\n    d = smin(d, pec, 0.05);\n    d += spine*0.02;\n    return d;\n}\n\nfloat getPelvis( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdBox(p - vec3(0, -0.45, 0.08), vec3(0.13, 0.3, 0))-0.2;\n    #endif\n    \n    vec3 mainDim = vec3(0.17, 0.3, 0);\n    mainDim.x += sin(p.y*6.0)*0.04;\n    vec3 inMain = p - vec3(0, -0.45, 0.07);\n    inMain.z -= cos(inMain.y*6.0)*0.02;\n    \n    float main = sdBox(inMain, mainDim) - 0.2;\n    \n    vec3 absDim = vec3(0.13, 0.29, 0.0);\n    absDim.z -= cos(p.x*30.0)*0.007;\n    absDim.z -= cos(p.y*36.0)*0.007;\n    vec3 inAbs = inMain - vec3(0, 0.1, 0.13);\n    float absD = sdBox(inAbs, absDim)-0.1;\n    \n    vec3 penisDim = vec3(0.03, 0.05, 0.05);\n    penisDim.x -= sin(p.y*10.0)*0.03;\n    vec3 inPenis = p - vec3(0, -0.9, 0.13);\n    inPenis.z += inPenis.y*0.2;\n    float penis = sdBox(inPenis, penisDim)-0.12;\n    \n    float butt = sdEllipsoid(p - vec3(0.17, -0.75, -0.03),\n                             vec3(0.2, 0.28, 0.2));\n    \n    float spine = s(0.1, 0.0, p.x)*s(0.1, -0.1, p.z);\n    \n    float d = main;\n    d = smin(d, absD, 0.1);\n    d = smin(d, penis, 0.1);\n    d = smin(d, butt, 0.1);\n    d += spine*0.02;\n    return d;\n}\n\nfloat getNeck( in vec3 p ) {\n    return sdCapsule(p, vec3(0), vec3(0, 0.24, 0.07), 0.15);\n}\n\nfloat getHead( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdBox(p - vec3(0, 0.18, 0.05), vec3(0.1, 0.19, 0.14))-0.1;\n    #endif\n    \n    vec3 brainDim = vec3(0.2, 0.23, 0.22);\n    vec3 inBrain = p - vec3(0, 0.27, 0.0);\n    float brain = sdEllipsoid(inBrain, brainDim);\n    \n    vec3 faceDim = vec3(0.04, 0.19, 0.03);\n    faceDim.x += sin(p.y*5.0)*0.05;\n    faceDim.z += cos(p.x*15.0)*0.02;\n    faceDim.z += sin(p.y*6.0)*0.03;\n    vec3 inFace = p - vec3(0, 0.18, 0.11);\n    float face = sdBox(inFace, faceDim) - 0.1;\n    \n    float d = brain;\n    d = smin(d, face, 0.1);\n    return d;\n}\n\nfloat getUpperArm( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdCapsule(p, vec3(0), vec3(0.89, 0, 0), 0.1);\n    #endif\n    \n    vec3 shoulderDim = vec3(0.23, 0.15, 0.18);\n    float shoulder = sdEllipsoid(p - vec3(0.05, 0.05, 0.0), shoulderDim);\n    \n    float muscle1Rad = 0.09;\n    muscle1Rad -= cos(p.x*8.0)*0.02;\n    vec3 muscle1Pos1 = vec3(0.0, 0.05, 0.03);\n    vec3 muscle1Pos2 = vec3(0.74, 0.05, 0.03);\n    float muscle1 = sdCapsule(p, muscle1Pos1, muscle1Pos2, muscle1Rad);\n    \n    float muscle2Rad = 0.09;\n    muscle2Rad += sin(p.x*7.0)*0.02;\n    vec3 muscle2Pos1 = vec3(0.0, -0.04, -0.03);\n    vec3 muscle2Pos2 = vec3(0.78, -0.02, -0.03);\n    float muscle2 = sdCapsule(p, muscle2Pos1, muscle2Pos2, muscle2Rad);\n    \n    float d = shoulder;\n    d = smin(d, muscle1, 0.03);\n    d = smin(d, muscle2, 0.03);\n    return d;\n}\n\nfloat getForearm( in vec3 p ) {\n    const vec3 handPos = vec3(0.58, 0, 0);\n    \n    #ifdef SIMPLE_HUMAN\n    return sdCapsule(p, vec3(0), handPos, 0.1);\n    #endif\n    \n    float rad = 0.06 + sin(p.x*9.0)*0.01;\n    float muscle1 = sdCapsule(p, vec3(0.06, 0.06, 0.0),\n                              handPos+vec3(0, 0.05, 0), rad);\n    float muscle2 = sdCapsule(p, vec3(0.04, -0.02, 0.03),\n                              handPos+vec3(0, -0.01, 0), rad);\n    \n    float elbow = length(p)-0.08;\n    \n    float d = muscle1;\n    d = smin(d, muscle2, 0.03);\n    d = smin(d, elbow, 0.05);\n    return d;\n}\n\nfloat getHand( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdBox(p - vec3(0.25, 0.02, 0.0), vec3(0.14, 0.07, 0.0)) - 0.05;\n    #endif\n    \n    vec3 handDim = vec3(0.08, 0.07, 0.01);\n    float cu1 = cos(p.y*11.0-0.3);\n\thandDim.x += cu1*0.06;\n    handDim.z += cu1*0.03;\n    handDim.z -= sin(p.x*4.0)*0.05;\n    \n    float hand = sdBox(p - vec3(0.25, 0.02, 0.0), handDim) - 0.05;\n    float thumb = sdCapsule(p, vec3(0.1, 0.02, 0.03),\n                            vec3(0.15, 0.18, 0.06), 0.04);\n    \n    float d = hand;\n    d = smin(d, thumb, 0.07);\n    return d;\n}\n\nfloat getUpperLeg( in vec3 p ) {\n    const vec3 kneePos = vec3(0, -1.01, 0);\n    \n    #ifdef SIMPLE_HUMAN\n    return sdCapsule(p, vec3(0), kneePos, 0.15);\n    #endif\n    \n    float muscle1Rad = 0.15 - sin(p.y*4.0)*0.03;\n    float muscle1 = sdCapsule(p, vec3(0.03, 0.0, 0.1), kneePos, muscle1Rad);\n    float muscle2 = sdCapsule(p, vec3(-0.12, 0.0, -0.05), kneePos, muscle1Rad);\n    \n    float knee = sdEllipsoid(p - vec3(0, -0.95, 0.03), vec3(0.12, 0.2, 0.12));\n    \n    float d = muscle1;\n    d = smin(d, muscle2, 0.02);\n    d = smin(d, knee, 0.03);\n    \n    return d;\n}\n\nfloat getLowerLeg( in vec3 p ) {\n    const vec3 footPos = vec3(0, -1.06, -0.08);\n    \n    #ifdef SIMPLE_HUMAN\n    return sdCapsule(p, vec3(0), footPos, 0.15);\n    #endif\n    \n    float muscle1Rad = 0.1 - sin(p.y*4.0)*0.03;\n    float muscle1 = sdCapsule(p, vec3(0.02, 0.0, 0.0), footPos, muscle1Rad);\n    \n    float muscle2Rad = 0.09 - sin(p.y*5.3)*0.05;\n    float muscle2 = sdCapsule(p, vec3(-0.02, 0.04, -0.08),\n                              footPos + vec3(0.0, 0.04, -0.02), muscle2Rad);\n    \n    float d = muscle1;\n    d = smin(d, muscle2, 0.02);\n    return d;    \n}\n\nfloat getFoot( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdBox(p - vec3(0.0, -0.13, 0.15), vec3(0.08, 0.0, 0.25))-0.05;\n    #endif\n    \n    vec3 footDim = vec3(0.04, 0.0, 0.19);\n    footDim.x -= cos(p.z*13.0-0.4)*0.04;\n    footDim.z += cos(p.x*14.0+0.2)*0.05;\n    vec3 inFoot = p - vec3(0.03, -0.13, 0.19);\n    float foot = sdBox(inFoot, footDim)-0.05;\n    \n    float ankle = sdEllipsoid(inFoot - vec3(0.0, 0.07, -0.13),\n                              vec3(0.1, 0.08, 0.18));\n    \n    float d = foot;\n    d = smin(d, ankle, 0.1);\n    return d;\n}\n\n\n// main distance function\nfloat de( in vec3 p ) {\n    \n    p.y += 0.5;\n    \n    // main pivot point is upper body\n    vec3 inUpperBody = p;\n    inUpperBody = rotateLimb(inUpperBody, 0);\n    \n    inUpperBody -= vec3(0, 1.3, 0);\n    vec3 inLowerBody = inUpperBody;\n    inLowerBody = rotateLimb(inLowerBody, 1);\n    \n    // keep upper body unflipped for the head\n    vec3 inUpperBodyNoFlip = inUpperBody;\n    // do some flipping\n    int upperOffset = int(inUpperBody.x > 0.0)*3;\n    int lowerOffset = int(inLowerBody.x > 0.0)*3;\n    inUpperBody = vec3(abs(inUpperBody.x), inUpperBody.yz);\n    inLowerBody = vec3(abs(inLowerBody.x), inLowerBody.yz);\n    \n    // do the torso\n    float torso = getTorso(inUpperBody);\n    \n    // do the pelvis\n    float pelvis = getPelvis(inLowerBody);\n    \n    // do the neck and head\n    vec3 inNeck = inUpperBodyNoFlip - vec3(0, 0.68, -0.1);\n    inNeck = rotateLimb(inNeck, 2);\n    float neck = getNeck(inNeck);\n    vec3 inHead = inNeck - vec3(0, 0.24, 0.07);\n    inHead = rotateLimb(inHead, 3);\n    float head = getHead(inHead);\n    \n    // do the arms\n    vec3 inShoulder = inUpperBody - vec3(0.4, 0.48, -0.12);\n    inShoulder = rotateArm(inShoulder, 4+upperOffset);\n    float shoulder = getUpperArm(inShoulder);\n    vec3 inElbow = inShoulder - vec3(0.79, 0, 0);\n    inElbow = rotateArm(inElbow, 5+upperOffset);\n    float elbow = getForearm(inElbow);\n    vec3 inHand = inElbow - vec3(0.56, 0, 0);\n    inHand = rotateArm(inHand, 6+upperOffset);\n    float hand = getHand(inHand);\n    \n    // do the legs\n    vec3 inHip = inLowerBody - vec3(0.25, -0.79, 0);\n    inHip = rotateLimb(inHip, 10+lowerOffset);\n    float hip = getUpperLeg(inHip);\n    vec3 inKnee = inHip - vec3(0, -1.01, 0);\n    inKnee = rotateLimb(inKnee, 11+lowerOffset);\n    float knee = getLowerLeg(inKnee);\n    vec3 inFoot = inKnee - vec3(0, -1.06, -0.08);\n    inFoot = rotateLimb(inFoot, 12+lowerOffset);\n    float foot = getFoot(inFoot);\n    \n    // blend the body together\n    float d = torso;\n    d = smin(d, pelvis, 0.2);\n    d = smin(d, neck, 0.15);\n    d = smin(d, head, 0.04);\n    // blend the arms together\n    float arms = shoulder;\n    arms = smin(arms, elbow, 0.05);\n    arms = smin(arms, hand, 0.05);\n    // blend the legs together\n    float legs = hip;\n    legs = smin(legs, knee, 0.05);\n    legs = smin(legs, foot, 0.1);\n    // blend everything and return the value\n    d = smin(d, arms, 0.1);\n    d = smin(d, legs, 0.05);\n    return d;\n}\n\n// normal function, call de() in a for loop for faster compile times.\nvec3 getNormal(vec3 p) {\n    vec4 n = vec4(0);\n    for (int i = Z ; i < 4 ; i++) {\n        vec4 s = vec4(p, 0);\n        s[i] += 0.001;\n        n[i] = de(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // fetch the playback time\n    float time = texelFetch(iChannel0, ivec2(0), 0).a;\n    // get the sequence and the time in it\n    int seqID = 0;\n    float seqTime = 0.0;\n    getSequence(time, seqID, seqTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord-iResolution.xy*0.5;\n    uv /= iResolution.y;\n    // get the direction and position\n    vec3 dir = vec3(0);\n    vec3 from = vec3(0);\n    getCamera(uv, seqID, seqTime, dir, from);\n    \n    // initialize skeleton\n    initSkel(seqID, seqTime, time);\n\t\n    // extent of a pixel, depends on the resolution\n    float fov = getFOV(seqID, seqTime);\n    float sinPix = sin(fov/iResolution.y)*2.0;\n    // keep best position\n    vec3 bestPos = vec3(0);\n    float bestPosDist = 999.9;\n    // accumulated opacity\n    float accAlpha = 1.0;\n    // raymarch distance\n    float totdist = 0.0;\n    totdist += de(from)*hash13(vec3(fragCoord, iFrame));\n    \n\tfor (int steps = Z ; steps < 100 ; steps++) {\n\t\tvec3 pos = from + totdist * dir;\n        \n        // bounding sphere optimisation\n        float dist = length(pos) - 4.0;\n        if (dist < 1.0) {\n            // get actual distance\n            dist = de(pos);\n            // and cone trace it\n            float r = totdist*sinPix;\n            float alpha = s(-r, r, dist);\n            accAlpha *= alpha;\n            // since the legs and arms are very susceptible\n            // to overstepping, clamp to a maximum value\n            dist = min(0.2, dist);\n        }\n        \n        // keep the closest point to the surface\n        if (dist < bestPosDist) {\n            bestPos = pos;\n            bestPosDist = dist;\n        }\n        \n        // hit a surface, stop and break\n\t\tif (dist < 0.001) {\n\t\t\taccAlpha = 0.0;\n            break;\n\t\t}\n\t\t\n        // continue forward\n        totdist += min(999.9, dist*0.9);\n        \n\t}\n    \n    fragColor.rgb = vec3(0);\n    fragColor.a = 1.0 - accAlpha;\n    \n    // no need for the normal if the opacity is 0\n    if (fragColor.a > 0.001) {\n        fragColor.rgb = getNormal(bestPos);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}