{
    "Shader": {
        "info": {
            "date": "1695668324",
            "description": "Big thanks to IQ for the smooth distance function   (https://iquilezles.org/articles/msetsmooth/)",
            "flags": 36,
            "hasliked": 0,
            "id": "DdccWX",
            "likes": 1,
            "name": "Eye of the Jellybean Dragon",
            "published": 3,
            "tags": [
                "fractal",
                "chaos",
                "strangeattractor",
                "microphone",
                "escapemap"
            ],
            "usePreview": 0,
            "username": "DigitalShadow",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 1e-10;\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvF = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y;\n    float cycle = mod(iTime, 3.)/3.;\n    fragColor = texture(iChannel0, vec2(1.0-uv.x, 1.0-uv.y));  \n\n\n    //cycle hue\n    vec3 hsv=RGBtoHSV(fragColor.rgb);\n    hsv.r = mod(hsv.r + iTime / 10. + pow((0.5+0.5*cos(iTime/4.)),16.) + length(uvF)/24., 1.0);\n    hsv = HSVtoRGB(hsv);\n    fragColor.rgb = hsv;   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define itr 50          //number of iterations\n#define maxL 1000.      //maxiumum escape length\n#define fade .33        //new to old image update ratio\n#define eqBands 12.     //number of equalizer bands to track\n#define freqPerBand 20. //subdivision of equalizer bandss\n#define reactAmt 0.02   //audio react ammount\n#define sweepAmt 1.0    //cofficient sweep ammount\n#define useMax 0        //equalizer band method; 0=average, 1=maximum\n\n//rotation matrix\nmat2 rotM(float a)\n{\n\ta *= 3.14159 / 180.0;\n    float s=sin(a), c=cos(a);\n    return mat2( c, -s, s, c );\n}\n\n//get value of EQ band\nfloat getBand(float x)\n{\n    float band = floor(x*eqBands);\n    float coarseSpacing = 1.0 / eqBands;\n    float fineSpacing = coarseSpacing / freqPerBand;\n    float start = coarseSpacing * band;\n    float val = 0.0;\n    float c;\n    for(float i=0.0; i < freqPerBand; i++)\n    {\n        c=(start + fineSpacing * i);\n        c = c*c; //better frequency response curve\n        #if useMax\n            val = max(val, texture(iChannel0, vec2(c, 0.25)).r);\n        #else\n            val += texture(iChannel0, vec2(c, 0.25)).r;\n        #endif\n    }\n    \n    if (useMax==0) val /= freqPerBand;\n    return val;\n}\n\n\n//iterate formula\nint iterate(vec2 p, out float minD, out float maxD, out vec2 lastP){\n    //coefficients\n    float a1 =  -0.1 + reactAmt * getBand(0.0 / 12.0);\n    float a7 =  -0.9 + reactAmt* getBand(1.0 / 12.0);\n    float a2 =  -1.5  + reactAmt * getBand(2.0 / 12.0) + sweepAmt * sin(iTime/5.);\n    float a8 =   0.9 + reactAmt * getBand(3.0 / 12.0) + sweepAmt * cos(iTime/7.);   \n    float a3 =  -0.5 + reactAmt * getBand(4.0 / 12.0);\n    float a9 =   0.1 + reactAmt * getBand(5.0 / 12.0) + sweepAmt *cos(iTime/11.);   \n    float a4 =   0.1+ reactAmt * getBand(6.0 / 12.0) + sweepAmt * sin(iTime/17.);\n    float a10 = -0.3+ reactAmt * getBand(7.0 / 12.0);  \n    float a5 =  -0.8 + reactAmt * getBand(8.0 / 12.0);\n    float a11 = -1.5 + reactAmt * getBand(9.0 / 12.0);\n    float a6 =   0.2+ reactAmt * getBand(10.0 / 12.0);\n    float a12 =  0.0 + reactAmt * getBand(11.0 / 12.0)+ sweepAmt * cos(iTime/13.); \n    float x2, y2, xy;\n    vec2 o = p;  //point origin\n    float d;     //distance from origin\n    minD=1.0;    //max distance\n    maxD=0.0;    //min distance \n    int i=0;\n    while (i < itr){\n        x2 = p.x * p.x;\n        y2 = p.y * p.y;\n        xy = p.x * p.y;\n        p = vec2\n        (\n            a1 + a2*p.x + a3 *x2 + a4 *xy + a5 *p.y + a6 *y2, \n            a7 + a8*p.x + a9 *x2 + a10*xy + a11*p.y + a12*y2\n        ); \n        if (dot(p,p) > maxL*maxL) break;\n        d = (o.x-p.x)*(o.x-p.x) + (o.y-p.y)*(o.y-p.y);   //dot product works for smooth values, but doesn't produce sharp bands\n        minD = min(d, minD);\n        maxD = max(d, maxD);\n        i++;\n    }\n    minD = sqrt(minD);\n    maxD = sqrt(maxD);\n    lastP = p;\n    return i;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvF = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y* rotM(500.*sin(iTime / 23.));\n    vec2 lastP;\n    \n    float zoom = 20. + 3.5* getBand(0.) + 20.*pow(0.5 + .5* cos(iTime/3.),1.5);\n    float minD, maxD;\n    \n    //Measure how many iterations it takes to escape bounds\n    int i = iterate((uvF*20.0 - vec2(0.0,10.0))/zoom, minD, maxD, lastP);\n    \n    \n    //smoothing function\n    float t = float(i) - log2(log2(dot(lastP,lastP))) + 4.0;\n    t = t/float(itr);\n    \n    //mix existing image and new to temporally smooth pixel values\n    vec3 ghost = texture(iChannel1, uv).rgb;\n    ghost=max(vec3(0.),ghost);\n    \n    //color outside of fractal\n    vec3 col = 0.5 - 0.5 * sin(0. + 26. * t + (vec3(0.1,0.6,1.0) + maxD/maxL*smoothstep(0.1,0.8,max(0.0,getBand(1.)))));\n    \n    //use alternate black and white coloring inside fractal bounds\n    if(i >= itr-1) col = 0.5 + 0.5*cos(maxD/minD*vec3(1.0)); \n    \n    fragColor = vec4(mix(ghost, col, fade),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}