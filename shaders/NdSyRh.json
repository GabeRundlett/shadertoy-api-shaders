{
    "Shader": {
        "info": {
            "date": "1643039110",
            "description": "Challenge: Using the rules in the code can you end the game in a tie?\nBigger challenge: Create an AI that can beat you. (unless random Xs can beat you, then welcome to the club).",
            "flags": 8,
            "hasliked": 0,
            "id": "NdSyRh",
            "likes": 9,
            "name": "TicTacUbe",
            "published": 3,
            "tags": [
                "tictactoe",
                "rubiks"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 302
        },
        "renderpass": [
            {
                "code": "//tictacube demo by eiffie\n//A fun little tictactoe game with a Rubik's cube and dry erase marker.\n//Each turn consists of one optional rotation and then an X/O mark.\n//To win, by getting 3 in a row, you can only rotate OR mark, not both.\n\n//An AI with a look ahead of 4 turns would have to analyze 5,226,454,388,736\n//moves so you get a crappy demo instead.\n\n#define rez iResolution\n#define pi 3.14159\nvec2 vmax(vec2 v1,vec2 v2){return (v1.x>v2.x)?v1:v2;}\nvec2 vmin(vec2 v1,vec2 v2){return (v1.x<v2.x)?v1:v2;}\nfloat sgn(float x){return x<0.?0.:1.;}\nmat2 rmat(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec3 mcol=vec3(-1.0);\nint R[14]=int[14](0,0,0,2,1,2,4,6,0,0,1,5,1,3);\nint F[14]=int[14](25,22,44,6,46,45,41,4,5,43,1,42,27,0);\nfloat DE(in vec3 p){\n  vec3 pS=p-vec3(sign(p.x),0.,0.);\n  float tim=iTime*.125+1.;\n  int n=int(min(15.,floor(tim)));\n  for(int i=0;i<n;i++){\n    float t=(i<n-1)?1.:min(fract(tim)*6.,1.);\n    if(R[i]>0){\n      if(R[i]<4){\n        float a=pi;\n        if(R[i]==1)a=-pi/2.;else if(R[i]==2)a=pi/2.;\n        p.yz=p.yz*rmat(a*t);\n      }else{\n        float a=0.;\n        if(p.x<0.){\n          if(R[i]==5)a=-pi/2.;\n          else if(R[i]==6)a=pi/2.;\n        }else if(R[i]==4)a=pi/2.;\n        pS.yz=pS.yz*rmat(a*t);\n      }\n    }\n    \n  }\n  vec2 v=vec2(abs(p.x)-.5,sgn(p.x));\n  v=vmax(v,vec2(abs(p.y)-1.5,2.+sgn(p.y)));\n  v=vmax(v,vec2(abs(p.z)-1.5,4.+sgn(p.z)));\n  vec2 v2=vec2(abs(pS.x)-.5,sgn(pS.x));\n  v2=vmax(v2,vec2(abs(pS.y)-1.5,2.+sgn(pS.y)));\n  v2=vmax(v2,vec2(abs(pS.z)-1.5,4.+sgn(pS.z)));\n  v=vmin(v,v2);\n  if(mcol.x>-1.){\n    int k=20;\n    if(v.x==v2.x){k+=(p.x<0.)?-20:20;p=pS;}\n    pS=p;pS.y=-pS.y;\n    if(v.y<2.){mcol+=vec3(1.,(sign(p.x)+1.)*.25,0.);pS.xy=pS.yz+5.;}\n    else if(v.y<4.){\n      pS.xy=pS.xz;if(p.y<0.){k+=6;mcol+=vec3(0,1,0);}else mcol+=vec3(0,0,1);\n    }else {\n      k+=p.z>0.?3:9;mcol+=vec3(1.,(sign(p.z)+1.)*.5,1.);\n    }\n    k+=int(floor(pS.y+2.5));\n    p=pS;if(abs(p.y)>.5)p.y-=sign(p.y);\n    for(int i=0;i<n;i++){\n      float t=(i<n-1)?1.:min(fract(tim),.5)*2.;\n      if(t<1.)continue;\n      if(F[i]==k){\n        float g=1.;\n        if(i%2>0){g=abs(length(p.xy)-.3);\n        }else{\n          p=abs(p);\n          g=abs(p.x-p.y)+max(0.,max(p.x,p.y)-.3);\n        }\n        mcol*=smoothstep(0.0,0.02,g);\n      }\n    }\n    pS=fract(pS)-.5;\n    pS=abs(pS);\n    mcol*=pow(min(pS.x,pS.y)*2.,.1);\n  }\n  return v.x;\n}\n\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nfloat bounce=1.;\nvec3 sky(vec3 rd, vec3 L){\n  vec3 c= abs(rd)*.2+0.3*dot(rd,L)+0.3;\n  for(float i=0.;i<5.;i+=1.){\n    vec2 p=vec2(sin(i*.1+iTime),sin(i*.1+1.+iTime*.7));\n    c+=bounce*5.*vec3(0,1,0)*exp(-abs(dot(p,rd.xz))*1000.);\n  }\n  return clamp(c,0.,1.);\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(iTime+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd,in float dL){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n  if(d>dL)break;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,pd,os,px=1./rez.y;\n  vec3 L=normalize(vec3(0.4,0.5,0.5)),C=vec3(0);\n  float refl=1.;\n  for(int j=0;j<4;j++){\n    mcol=vec3(0);d=1.0,pd=10.0,os=0.0; //estimated,prev distance, overstep\n    for(int i=0;i<30;i++){\n      d=DE(ro+rd*t);\n      if(d>os){  //we have NOT stepped over anything \n        os=0.5*d*d/pd;//calc overstep based on ratio of this step to last \n        t+=d+os; //add in the overstep \n        pd=d; //save this step length for next calc \n      }else{  //we MAY have stepped over something \n        os*=0.5; //bisect overstep \n        t-=os; //back up \n        if(os>0.001)d=px*t*2.; //don't bail unless the overstep was small (and d of course) \n        else t+=d+os;//we are going to bail so add in this last distance \n      }\n      if(t>70.0 || d<px*t)break;\n    }\n    if(d<px*t && t<70.){\n      mcol.x=0.0;\n      vec3 so=ro+rd*t;\n      vec3 N=normal(so,d);\n      mcol*=.25;\n      refl*=.25;\n      vec3 scol=mcol;mcol.x=-1.;\n      float dif=0.75+0.25*dot(N,L);\n      float vis=clamp(dot(N,-rd),0.05,1.0);\n      float fr=pow(1.-vis,5.0);\n      float shad=0.5+0.5*ShadAO(so,L,1.);\n      bounce*=bounce*bounce*bounce+8.;\n      scol=(scol*dif+fr*sky(reflect(rd,N),L))*shad;\n      C=clamp(C+scol*refl,0.,1.);\n      ro+=rd*(t-px*t);rd=reflect(rd,N);t=px*t*2.;\n    }\n  }\n  return C+sky(rd,L)*refl;\n}\nvec3 path(float t){float a=t*pi/2.-1.,x=cos(a)*5.;return vec3(x+1.,-sin(a)*5.,max(0.5,10.-iTime*.125)+abs(x));}\nmat3 lookat(vec3 fw){vec3 up=vec3(0.0,1.0,0.0),rt=-normalize(cross(fw,up));return mat3(rt,normalize(cross(rt,fw)),fw);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randomize(fragCoord);\n vec3 ro=path(iTime*.5),fw=normalize(-ro);\n vec3 rd=lookat(fw)*normalize(vec3((iResolution.xy-2.0*fragCoord)/iResolution.y,3.0));\n fragColor=vec4(scene(ro,rd),2.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define bps 8.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n= 5.0; \n  else if(n<2.0)n= 2.0; \n  else if(n<3.0)n= -1.0; \n  else if(n<4.0)n= 0.0; \n  else if(n<5.0)n= -5.0; \n  else if(n<6.0)n= -4.0; \n  else if(n<7.0)n= 4.0; \n  else n=0.0;\n  return vec2(n,r); \n}\nfloat harm(float t){//a harmonic progression series\n  t=mod(t/32.,6.);\n  if(t<1.)t=7.;\n  else if(t<2.)t=3.;\n  else if(t<3.)t=4.;\n  else if(t<4.)t=8.;\n  else if(t<5.)t=5.;\n  else t=2.;\n  return t;\n}\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.05,1.5,0.1,2.333,0.001);//silly fm synth instruments \n //instr sitar=instr(30.0,1.,4.0,0.0,0.2525,0.0025); \n //instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n //instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n //instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+72.0,time,t0,epiano)*n0.y;\n   //if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+60.0+harm(tim),time,t1,epiano)*n1.y; \n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+48.0,time,t2,epiano)*n2.y; \n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/48.0,-1.,1.); \n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}