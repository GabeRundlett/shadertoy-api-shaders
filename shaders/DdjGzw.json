{
    "Shader": {
        "info": {
            "date": "1667778069",
            "description": "click and drag mouse along x-axis for more or less blur, \nif you want to challange your GPU, change the variable `n_max_kernel_size` to 1000.0, and enjoy the frame freeze ;)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "DdjGzw",
            "likes": 1,
            "name": "blur with a kernal size by mouse",
            "published": 3,
            "tags": [
                "mouse",
                "blur",
                "kernel"
            ],
            "usePreview": 0,
            "username": "jonasfrey",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "float f_n_distance(\n    float n_x, \n    float n_y, \n    float n_x2, \n    float n_y2\n){\n\n    float n_delta_x = n_x - n_x2;\n    float n_delta_y = n_y - n_y2;\n    \n    float n_distance_pow = pow(n_delta_x,2.0) + pow(n_delta_y,2.0);\n    float n_distance_sqrt = sqrt(n_distance_pow); \n    return n_distance_sqrt;\n}\n\nvec4 f_a_n_blurred(\n    float n_scale_x_kernel, \n    float n_scale_y_kernel, \n    float n_x_kernel, \n    float n_y_kernel\n){\n    \n    vec4 a_n_rgba_sum = vec4(0.0,0.0,0.0,0.0);\n    int n_x = 0; \n    int n_y = 0; \n    for(int n_y; n_y < int(n_scale_y_kernel); n_y+=1){\n        for(int n_x; n_x < int(n_scale_x_kernel); n_x+=1){\n            //int n_x_current = n_x - int(float(n_scale_x_kernel)/2.0);\n            //int n_x_current = n_y - int(float(n_scale_y_kernel)/2.0);\n            vec2 n_coords_normalized_kernel = vec2(\n                float(n_x) + n_x_kernel - float(n_scale_x_kernel)/2.0, \n                float(n_y) + n_y_kernel - float(n_scale_y_kernel)/2.0\n            )/iResolution.xy;\n            a_n_rgba_sum+=texture(\n                iChannel0,\n                n_coords_normalized_kernel \n                \n            );\n        }\n    }\n    return a_n_rgba_sum / (n_scale_x_kernel * n_scale_y_kernel);\n}\nvec4 f_a_n_blurred_ignore_out_of_bounds(\n    float n_scale_x_kernel, \n    float n_scale_y_kernel, \n    float n_x_kernel, \n    float n_y_kernel\n){\n    \n    vec4 a_n_rgba_sum = vec4(0.0,0.0,0.0,0.0);\n    int n_x = 0; \n    int n_y = 0; \n    int n_count =0;\n    for(int n_y; n_y < int(n_scale_y_kernel); n_y+=1){\n        for(int n_x; n_x < int(n_scale_x_kernel); n_x+=1){\n            float n_x_target = float(n_x) + n_x_kernel - float(n_scale_x_kernel)/2.0;\n            float n_y_target = float(n_y) + n_y_kernel - float(n_scale_y_kernel)/2.0;\n            if(\n                n_x_target >= 0.0  && n_x_target <= float(iResolution.x\n)                &&\n                n_y_target >= 0.0  && n_y_target <= float(iResolution.y)\n                \n            ){\n                //int n_x_current = n_x - int(float(n_scale_x_kernel)/2.0);\n                //int n_x_current = n_y - int(float(n_scale_y_kernel)/2.0);\n                vec2 n_coords_normalized_kernel = vec2(n_x_target, n_y_target)/iResolution.xy;\n                a_n_rgba_sum+=texture(\n                    iChannel0,\n                    n_coords_normalized_kernel \n\n                );\n                n_count +=1;\n            }\n\n        }\n    }\n    return a_n_rgba_sum / float(n_count);\n}\nvec4 f_a_n_blurred_ignore_out_of_bounds_gaussian(\n    float n_scale_x_kernel, \n    float n_scale_y_kernel, \n    float n_x_kernel, \n    float n_y_kernel\n){\n    float n_distance_to_kernel_max = f_n_distance(\n        0.0, \n        0.0, \n        n_scale_x_kernel, \n        n_scale_y_kernel\n    );\n    \n    vec2 n_coords_kernel_normalized = vec2(n_x_kernel, n_y_kernel) / iResolution.xy;\n    vec4 a_n_rgba_sum = vec4(0.0,0.0,0.0,0.0);\n    int n_x = 0; \n    int n_y = 0; \n    int n_count =0;\n    for(int n_y; n_y < int(n_scale_y_kernel); n_y+=1){\n        for(int n_x; n_x < int(n_scale_x_kernel); n_x+=1){\n            float n_x_target = float(n_x) + n_x_kernel - float(n_scale_x_kernel)/2.0;\n            float n_y_target = float(n_y) + n_y_kernel - float(n_scale_y_kernel)/2.0;\n            if(\n                n_x_target >= 0.0  && n_x_target <= float(iResolution.x\n)                &&\n                n_y_target >= 0.0  && n_y_target <= float(iResolution.y)\n                \n            ){\n                vec2 n_coords_target_normalized = vec2(n_x_target, n_y_target) / iResolution.xy;\n                float n_distance_to_center = f_n_distance(\n                    n_coords_target_normalized.x, \n                    n_coords_target_normalized.y, \n                    n_coords_kernel_normalized.x, \n                    n_coords_kernel_normalized.y\n                );\n                \n                vec2 n_coords_normalized_kernel = vec2(n_x_target, n_y_target)/iResolution.xy;\n                a_n_rgba_sum+=(texture(\n                    iChannel0,\n                    n_coords_normalized_kernel \n                ))*(1.0-(n_distance_to_center/n_distance_to_kernel_max));\n                n_count +=1;\n            }\n\n        }\n    }\n    return a_n_rgba_sum / float(n_count);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 a_n_coords_normalized_mouse = iMouse.xy / iResolution.xy;\n    vec2 a_n_coords_normalized_pixel = fragCoord.xy / iResolution.xy; \n    \n\n    float n_max_kernel_size = 100.0;\n    float n_kernel = n_max_kernel_size * a_n_coords_normalized_mouse.x;\n    vec4 a_n_rgba_blurred = vec4(0.0,0.0,0.0,0.0);\n    if(a_n_coords_normalized_pixel.x < 1.0/3.0){\n      fragColor = f_a_n_blurred(\n            n_kernel,\n            n_kernel,\n            fragCoord.x,\n            fragCoord.y\n       );\n       return;\n     }\n    if(a_n_coords_normalized_pixel.x < 2.0/3.0){\n        fragColor = f_a_n_blurred_ignore_out_of_bounds(\n            n_kernel,\n            n_kernel,\n            fragCoord.x,\n            fragCoord.y\n       );\n       return;\n    }\n    if(a_n_coords_normalized_pixel.x < 3.0/3.0){\n        fragColor = f_a_n_blurred_ignore_out_of_bounds_gaussian(\n            n_kernel,\n            n_kernel,\n            fragCoord.x,\n            fragCoord.y\n       );\n       return;\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}