{
    "Shader": {
        "info": {
            "date": "1578927207",
            "description": "\nCode is messy btw.",
            "flags": 8,
            "hasliked": 0,
            "id": "3lcGWs",
            "likes": 7,
            "name": "Day 25 - Jupeia",
            "published": 3,
            "tags": [
                "sound",
                "audio"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 413
        },
        "renderpass": [
            {
                "code": "\n\n// The very awesome IRR bass is from https://www.shadertoy.com/view/XljSD3\n\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)\n#define tau (2.*pi)\n  \n#define tempo 174.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (beat*4.*4.)\n#define hmsr  (measure*0.5)\n\n#define P(x) t/measure < x\n#define PL(x) t/measure > x\n   \n\n// here's 11 noise functions\n// thanks to people i got them from xd\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\nfloat hash(float i){\n\treturn fract(sin(114.121*i)*11252.11242512);\n}\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat rnd(float i){\n\treturn fract(sin(i)*1235.41252156);\n}\nfloat nois(float t){\n    float n = 0.;\n    n = fract(rnd(t)*rnd(t*2.41));\n    vec2 p = vec2(fract(rnd(t*14.11)),fract(rnd(t*124.1)*rnd(t*3.15)));\n    vec2 q = vec2(fract(rnd(t*14.124)*rnd(t*41.15)), n*0.15);\n    n = fract(dot(p,q));\n    \n\treturn n;\n}   \nfloat random(float st){\n    \n\treturn fract(sin(114.121*st)*11252.11242512);\n\t//return fract(sin(st*651.5524)*4.4214);\n}\n\n\nfloat notVeryRandom(float st){\n    return fract(sin(st*451.5524));\n}\nfloat rand(float t) {\n\treturn fract(sin(t*3211251.325235325));\n}\nfloat random( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat noiseB(vec2 p) { // thx to whoever I got this from!\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\n\nfloat arp(float t, float period, float scale) {\n\tfloat n = 0. ;\n    float r = random( mod( floor(t/period), 50.));\n    r *= 7.;\n    r = floor(r);\n    (r == 0.) ? n = note(9., 0.) :\n    (r == 1.) ? n = note(9., 0.) :\n    (r == 2.) ? n = note(9. + 3., 0.) :\n    (r == 3.) ? n = note(9., 0.) :\n    (r == 4.) ? n = note(9. + 5., 0.) :\n    (r == 5.) ? n = note(9. + 7., 0.) :\n    (r == 6.) ? n = note(9. + 12., 0.) :\n    (r == 7.) ? n = note(9., 1.) : 0.;\n    //);\n    return n;\n}\nfloat arpB(float t, float period, float scale, float rep, float seed) {\n\tfloat n = 0. ;\n    float r = random( mod( floor(t/period), rep) + seed);\n    r *= 7.;\n    r = floor(r);\n    (r == 0.) ? n = note(9., 0.) :\n    (r == 1.) ? n = note(9. + 3., 0.) :\n    (r == 2.) ? n = note(9. + 2., 0.) :\n    (r == 3.) ? n = note(9. + 7., 0.) :\n    (r == 4.) ? n = note(9. + 10., 0.) :\n    (r == 5.) ? n = note(9. + 10., 1.) :\n    (r == 6.) ? n = note(9. + 9., 1.) :\n    (r == 7.) ? n = note(9., 1.) : 0.;\n    //);\n    return n;\n}\n\n\n\nvec2 snare(float t) {\n\tvec2 s = vec2(0);\n\tt = mod(t + hbeat, beat);\n    \n    float env = exp(-t*20.);\n    float noise = noise(vec2(t))*env;\n    //s.x += ;\n    s.x += sin((180. + env*150. + noise*20.)*tau*t )*env;\n    s.y = s.x;\n    \n    return s;\n}\nvec2 kickSecond(float t, float phase) {\n    vec2 s = vec2(0);\n    float r = notVeryRandom( mod(floor(t/ hbeat), 26.));\n    float rB = notVeryRandom( mod(floor((t)/ hbeat) + 4., 26.));\n    \n    float limit = 0.26;\n    if (P(4.)){\n  \t\tlimit = 0.02;   \n    }\n    \n    if (rB < limit) {\n        r *= 3.99;\n\t\tr = floor(r);\n        r += 1.;\n        float offs = hbeat * 1./r;\n        if (offs == hbeat) {\n        \toffs -= hbeat/4.;\n        }\n        t = mod(t + offs, hbeat);\n\n        float env = exp(-t*10.);\n        if (phase == 1.) {\n        \ts.x += sin( (140. * env+ 10. ) *tau*t) * env ;\n        } else if (phase == 2.) {\n        \ts.x += sin( (240. * env+ 10. ) *tau*t) * env ;\n        }\n\t\n    \t//s.x += sin( (random(t)) *tau*t) * env*2. ;\n        \n        s.x = clamp(s.x*1.6,-1., 1.);\n\n        \n        s.y = s.x;\n    \n    }\n    \n\treturn s;\n}\nvec2 lead(float t) {\n\tvec2 s = vec2(0);\n    \n    float note;\n    if (P(4.)){\n    \t//note = arpB(t, beat, 1., 4., 14.2);\n        note = arpB(t, beat, 1., 8., 39.9);\n    \tt = mod(t,beat);\n    } else if (P(5. + 3.)){\n    \tnote = arpB(t, beat, 1., 8.,  20.9);\n    \tt = mod(t,beat);\n    } else if (P(8.)){\n    \tnote = arpB(t, beat, 1., 8.,  20.9);\n    }\n    float env = exp(-t*9.);\n    \n    float iterations = 5.;\n    float freq = note;\n    float scale = 1.;\n    for (float i = 0.; i < iterations; i++) {\n        float r = random(i)*10.;\n    \ts.x += sin((note + r)*tau*t )*env*scale;\n    \ts.x += sin(note*tau*(t + 0.05) )*env*scale;\n    \ts.x += sin(0.5*note*tau*(t + 0.06) )*env*scale;\n        scale *= 0.8;\n        s.x * 0.33;\n        note *= 2.01;\n    }\n    s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\nvec2 echoChannel(float t) {\n\tvec2 s = vec2(0);\n\n    float fb = 0.85, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += lead(t) * cf; cf *= fb; \n    \n    s += lead(t) * cf; cf *= fb; \n    // tap 2\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}\n\n\n\nvec2 synthLead (float t) {\n\tvec2 s = vec2(0);\n    \n    float note = arp(t, qnote, 1.);\n    t = mod(t,qnote);\n    float env = exp(-t*20.);\n    \n    float iterations = 5.;\n    float freq = note;\n    float scale = 1.;\n    for (float i = 0.; i < iterations; i++) {\n        float r = random(i)*10.;\n    \ts.x += sin((note + r)*tau*t )*env*scale;\n    \ts.x += sin(note*tau*(t + 0.05) )*env*scale;\n    \ts.x += sin(0.5*note*tau*(t + 0.06) )*env*scale;\n        scale *= 0.8;\n        s.x * 0.33;\n        note *= 2.01;\n    }\n    s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\n\n\nvec2 hats (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat);\n    float env = exp(-t*20.);\n    \n    float r = random(t);\n    s.x = sin(470.*t*tau + sin(2040.*t*tau + r*4500.)*4. + r*7.*env ) * env;\n    s.y = s.x;\n    \n    return s;\n}\n\nvec2 hatsTwo (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat/2.);\n    float env = exp(-t*50.);\n    \n    float r = random(t);\n    s.x = sin(570.*t*tau + sin(2040.*t*tau + r*1500.)*4. + r*4. ) * env;\n    s.y = s.x;\n    \n    return s;\n\n}\n\nvec2 hatsThree(float time){\n    \n\tfloat s;\n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate*2.);\n    float currentMeasure = floor(time/(measure));\n    time = mod(time, qbeat);\n    //time = mod(time, beat);\n\n    t = t % ((t >>3) % t*2);\n    s =float(t & 0xff - 128)/ 128.;\n    s *= pow(exp(-mod(time,qbeat*20.)), 10.);\n    s = (s + (s*noise(time * mod(time, 0.001)*300.).x)*2.*exp(-time));\n    s *= 3.;\n\n\n    \n    return vec2(float(s));\n}\n\n\n\nvec2 makeAmb(float t) {\n\tvec2 s = vec2(0);\n\n    float freqA = note(9., 0.);\n    float freqB = note(9., 1.);\n    float freqC = note(9. + 7., 1.);\n    float scale = 1.;\n    float iters = 6.;\n    for (float i = 0.; i < iters; i++) {\n    \n        s.x += sin(tau*t*freqA    )*scale * 0.5;\n        s.x += sin(tau*t*freqB    )*scale * 0.2;\n        s.x += sin(tau*t*freqC  + smoothstep(0.,1.,sin(t) * noise(vec2(t))*0.5)  )*scale * 0.4;\n    \tfreqA *= 2.002 +random(i)*0.3 + sin(t + i)*0.002;\n    \tfreqC *= 2.002 +random(i)*0.3 + sin(t + i)*0.002;\n    \tfreqB *= 1.501;\n        scale *= 0.2 + smoothstep(0.,1., t*0.2)*0.3 + cos(t * 0.2)*0.1;\n    }\n    s.y = s.x;\n    \n    return s;\n}\n\n// The awesome IRR bass is from https://www.shadertoy.com/view/XljSD3\nfloat Hash( float n )\n{\n\treturn fract( (1.0 + cos(n)) * 415.92653);\n}\n\n//we can use jitter for analog driftness\nfloat genSaw(float time, float freq, bool useJitter)\n{\n    float jitter1 = 0.0;\n    float jitter2 = 0.0;\n\n    if(useJitter)\n    {\n      jitter1 = texture(iChannel0, vec2(time,0.2)*0.01).x;\n      jitter2 = texture(iChannel0, vec2(time-0.01,0.2)*0.01).x;\n    }\n    \n    float val = fract(time*(freq + (jitter1+jitter2)*0.2));\n    return val;\n}\n\nfloat genNiceSaw(float time, float freq, bool useJitter)\n{\n    return (genSaw(time,freq,useJitter) - 0.5) * 2.0;\n}\n#define maxTaps 40\n/* Reso lowpass saw... truncated IIR #yoloswag */\nfloat resoLpSaw(float time, float freq, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 0.1;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < maxTaps; i++)\n    {\n          float history = float(maxTaps-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = genNiceSaw(t,freq,false);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\nvec2 makeBass (float t) {\n\tvec2 s = vec2(0);\n    \n    float tB = t;\n    float freq = arp(t, qnote, 1.);\n    t = mod(t,qnote);\n    float env = exp(-t*8.);\n    \n    float iterations = 5.;\n    float scale = 1.;\n\n    \n      s.x += resoLpSaw(t, freq, abs(cos(t*5.)*(0.25 + 0.55*smoothstep(0.,1., ((tB/measure)-4.)*0.5)))) * env * scale ;\n    /*\n    if (P(4.)){\n        s.x += resoLpSaw(t, freq, abs(cos(t*5.)*0.25)) * env * scale ;\n        \n    } else {\n        s.x += resoLpSaw(t, freq, abs(cos(t*5.)*(0.25 + 0.75*smoothstep(0.,1., (tB/measure)-4.)))) * env * scale ;\n    }*/\n    //s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\n\nvec2 makeBells(float t, float freq, float scale) {\n    vec2 s = vec2(0);\n    float r = random( mod(floor(t/ hbeat), 26.) + 4.);\n    float rC = r;\n    float rB = random( mod(floor((t + 4.)/ hbeat) + 4., 26.));\n        float env = exp(-t*15.);\n        \n        float iters = 3.;\n    \tfor (float i = 0.; i < iters; i++) {\n            s.x += sin(freq *tau*t) * scale * (2. + sin(t));\n            \n            freq *= 2.01;\n        }\n        s.y = s.x;\n    \n    return s;\n}\n  \n\nvec2 reverbChannelB(float t) {\n\tvec2 s = vec2(0);\n    \n    vec2 reverb = vec2(0);\n    float st = 0.001; float iters = 20.;\n    for (float i = 0.; i < iters; i++) {\n    \treverb += ((makeBells(t - i*st + random(i )*0.4, note(9.,1.), 0.4 ))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st + sin(t)*0.01 + random(i )*0.4, note(16.,1.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st - sin(t*0.8)*0.01 + random(i )*0.4, note(19.,1.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st + 0.02 - sin(t*0.8)*0.01 + random(i )*0.4, note(12.,2.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st - 0.01 + sin(t*0.5 + sin(t*note(16.,2.)*tau*0.5 + sin(t*note(16. + 7.,1.)))*0.13*sin(t*0.8))*0.01 + random(i )*0.4, note(16.,2.), 0.3))/iters) *(1. - i/iters) ;\n    }\n\n    s += ((makeBells(t , note(9.,1.), 0.4 ))/iters)*0.001;\n    s += ((makeBells(t  , note(12.,2.), 0.1))/iters)*0.001;\n    s += ((makeBells(t  , note(18.,2.), 0.5))/iters)*0.001;\n    \n    s += reverb*5.5;\n\treturn s;\n}\n\n\nvec2 chorusChannel(float t){\n\n\tfloat iters = 5.;\n    vec2 s = vec2(0);\n    \n    \n    for(float i = 0.; i < iters; i++){\n        float r = random(i);\n        float rB = fract(r*124.52412);\n    \ts += reverbChannelB(t + r*0.1 + 0.02*r + sin(t*(1. - rB*0.05))*(0. + r*0.01));\n    }\n    s += reverbChannelB(t)*0.5;\n    \n    s /= iters;\n    s*= 0.125;\n    return s;\n}\nvec2 sAmbG(float t, float freq){\n\tvec2 s = vec2(0);\n    t = mod(t, hmsr);\n    float iters = 3. + clamp( exp(-t/2.)*5., 0., 30.);\n    for (float i = 1.;i < iters ; i++){\n    \ts += sin(t*tau*freq*i)/i;\n    }\n    vec2 n = noise(t);\n    vec2 sOrig = s;\n    float tMod = sin(t*8.)*(1. + exp(t/2.- 1.)*0.3);\n    float tMod2 = cos(t*2.)*0.5;\n    s = sOrig*sin(freq*4.*t*tau + n.x*0.4  + tMod          );\n    s += sOrig*sin(freq*2.*t*tau + n.y*0.4 + tMod2        );\n    s += sOrig*(fract(freq*8.*t*tau + n.y*0.4 -tMod + tMod2  ));\n\n    s /= 4.;\n    \n    return s;\n}\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s = vec2(0); \n\n    //t += measure*4.;\n    vec2 sEchno = echoChannel(t)*1.5;\n    vec2 sHats = hats(t)*0.5;\n    vec2 sHatsTwo = hatsTwo(t)*0.4;\n    vec2 sHatsTwoEcho = hatsTwo(t + 0.1)*0.3;\n    vec2 sHatsThree = hatsTwo(t)*1.2;\n    vec2 sChorus = chorusChannel(t);\n    vec2 sBass = makeBass(t);\n    vec2 sKick = kickSecond(t, 1.)*1.5;\n    vec2 sSnare = snare(t)*1.5; \n    \n    vec2 sAmbA = (sAmbG(t, note(9. + 3. ,3.))+sAmbG(t, note(9. ,3.)))*0.3;\n    vec2 sAmbB = (sAmbG(t, note(9. + 0. ,2.))+sAmbG(t, note(9. + 7. ,2.)))*0.3;\n    vec2 sAmbC = (sAmbG(t, note(9. + 3. ,3.))+sAmbG(t, note(9. ,3.)))*0.3;\n    vec2 sAmbD = (sAmbG(t, note(9. + 6. ,3.))+sAmbG(t, note(9. + 6. ,2.)))*0.3;\n    \n\n        \n    if (P(1.)){\n\t\t//s += gIntroAmb(t)*1.;\n        s += sChorus;\n        s += sHats;\n    } else if (P(2.)){\n        s += (sAmbG(t, note(9. + 3. ,3.))+sAmbG(t, note(9. ,3.)))*0.2*smoothstep(1., 0., mod(t/measure,1.));\n \t\ts += sChorus;\n        s += sHats;\n        s += sHatsTwo;\n        s += sHatsTwoEcho;\n    } else if (P(3.)){\n \t\ts += sChorus;\n        s += sHats;\n        s += sHatsTwo;\n        s += sHatsTwoEcho;\n        s += sKick;\n        //s += makeBass(t)*1.;\n        s += sEchno;\n        //s += snare(t)*1.5;        \n    } else if (P(4.)){\n \t\ts += chorusChannel(t + (1. - exp(-mod(t,hbeat)))*noise(t).x*0.0002);\n        s += sHats;\n        s += sHatsTwo;\n        s += sHatsTwoEcho;\n        s += sBass;\n        s += sEchno;\n        //s += snare(t)*1.5;\n    \t\n    } else if (P(5. + 2.)){ \n        s += sHats;\n        s += sHatsThree;\n        s += sHatsTwoEcho;\n        s += sKick;\n        s += sBass;\n        s += sEchno;\n        s += sSnare;\n        if (PL(6. + 0.75)) {\n            s += sAmbA;\n            s += sAmbB;\n            s += sAmbD;\n        } else if (PL(6. + 0.25)){\n            s += sAmbA;\n            s += sAmbB;\n        } else if (PL(6.)){\n            s += sAmbA;\n        }  \n\n\n    } else  if (P(8.)){\n        s += sEchno;\n    } else  if (P(9.)){\n        s += sEchno;\n    }\n    \n    \n\n    s *= 0.2;\n    \n    s = clamp(s, vec2(-1.), vec2(1.));\n    \n    s *= smoothstep(0.,1., t*0.6);\n    \n    s *= 0.1;\n    \n    return s;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}