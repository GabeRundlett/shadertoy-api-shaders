{
    "Shader": {
        "info": {
            "date": "1597566984",
            "description": "Lighting test\nMouse: Control camera",
            "flags": 0,
            "hasliked": 0,
            "id": "WlffWB",
            "likes": 22,
            "name": "Balls of various materials",
            "published": 3,
            "tags": [
                "3d",
                "pbr"
            ],
            "usePreview": 0,
            "username": "kaneta",
            "viewed": 746
        },
        "renderpass": [
            {
                "code": "#define MAT_FLOOR 0.0\n#define MAT_SPHERE 1.0\n\nconst float pi = acos(-1.);\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 plane = vec2(p.y + 1.0, MAT_FLOOR);\n    p -=  vec3(0.0, -0.5, 0.0);\n    vec3 l = vec3(5.0, 0.0, 5.0);\n    vec3 q = p-clamp(round(p),-l,l);\n    vec2 d = vec2(length(q) - 0.49, MAT_SPHERE);\n    return opU(d, plane);\n}\n\nvec3 normal( vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*(map( pos + e.xyy ).x) +\n\t\t\t\t\t  e.yyx*(map( pos + e.yyx ).x) +\n\t\t\t\t\t  e.yxy*(map( pos + e.yxy ).x) +\n\t\t\t\t\t  e.xxx*(map( pos + e.xxx ).x) );\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (pi * denom * denom);\n}\n\nfloat gaSchlickG1(float cosTheta, float k)\n{\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick(vec3 F0, float cosTheta)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 fresnelSchlickWithRoughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 skyColor(vec3 rd, float roughness)\n{\n    vec3 baseColor = mix(vec3(0.3,0.5,0.8)*0.8, vec3(0.3,0.5,0.8) * 0.5, rd.y);\n    baseColor = mix( baseColor, vec3(0.2,0.5,0.85)*0.5, 1.0 - pow(1.0-max(-rd.y,0.0), 1.5));\n    vec3 skyColor = baseColor;\n    skyColor = mix( skyColor, vec3(0.9,1.1,1.2) * 1.5, pow( 1.0-max(rd.y,0.0), 8.0 ) );\n    skyColor = mix( skyColor, vec3(0.2,0.5,0.85)*0.2, 1.0 - pow(1.0-max(-rd.y,0.0), 6.0));\n    \n    return mix(skyColor, baseColor, pow(roughness, 0.1)) * 10.0;\n}\n\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.01;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 128; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\nvec3 ambientLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float aoRange)\n{\n    vec3 diffuseIrradiance = skyColor(N, 1.0);\n    vec3 diffuseAmbient = diffuseIrradiance * albedo * (1.0 - metalness);\n\n    vec3 R = reflect(-V, N);\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlickWithRoughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 specularIrradiance = skyColor(R, roughness);\n    vec3 specularAmbient = specularIrradiance * F;\n\n    float ambientOcclusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tambientOcclusion = min(exp2( -.8 * pow(ambientOcclusion, 2.0) ), 1.0) * min(1.0, 1.0+0.5*N.y);\n    diffuseAmbient *= ambientOcclusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), ambientOcclusion, roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 directLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 lightColor)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n    float HdotL = max(0.0, dot(H, L));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick(F0, HdotL);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n    vec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\tvec3 diffuseBRDF = kd * albedo / pi;\n\t\n\tfloat shadow = shadow(pos + N * 0.01, L);\n    vec3 irradiance = lightColor * NdotL * shadow;\n\n\treturn (diffuseBRDF + specularBRDF) * irradiance;\n}\n\n\nvec3 sunDir = normalize(vec3(.3, .45, .5));\n\n#define repid(p, r) (floor((p + r*.5) / r))\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 sky = skyColor(ray, 0.0);\n    vec3 albedo = vec3(1.0, 0.5, 0.1), emissive = vec3(0.0);\n    \n    vec2 id = repid(p.xz, vec2(1.0, 1.0)) / 10.0 + 0.5;\n    float metalness = 1.0 - max(id.y, 0.0);\n    float roughness = max(1.0 - id.x, 0.05);\n    albedo *= mix(0.4, 1.0, metalness);\n    \n    if (depth > 200.0) {\n        return sky;\n    } else if (mat.y == MAT_FLOOR) {\n        float checker = mod(floor(p.x) + floor(p.z), 2.0);\n        albedo = vec3(0.4) * checker + 0.05;\n        roughness = (0.2 + (1.0 - checker) * 0.45);\n        metalness = 0.0;\n    }\n    vec3 n = normal(p, 0.005);\n    \n    col += directLighting(p, albedo, metalness, roughness, n, -ray, normalize(sunDir), vec3(1.0, 0.98, 0.95) * 100.);\n    col += ambientLighting(p, albedo, metalness, roughness, n, -ray, depth / 30.0);\n    col += emissive;\n    \n    float fo = exp(-0.006*depth);\n    col = mix( sky, col, fo );\n\n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.1;\n    vec3 pos;\n    vec2 mat;\n    for (int i = 0; i < 128; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x < 0.001) {\n        \tbreak;\n        }\n        t += abs(mat.x);\n    }\n    return materialize(pos, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    float time2 = iTime * 3.0;\n    vec3 ro = vec3(cos(time2*0.1) * 15.0, 15.75 * iMouse.y / iResolution.y, sin(time2*0.1) * 15.0);\n    vec3 ta = vec3(0.0, -1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.0 + 8.5 * iMouse.x / iResolution.x));\n    return trace(ro, ray);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n\n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 3; y++) {\n        for(int x = 0; x < 3; x++) {\n            vec2 off = vec2(float(x),float(y))/3.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \t//col += reinhard(render(xy), .12, 100.0)/9.;\n            col += acesFilm(render(xy) * .065)/9.;\n        }\n    }\n    \n    //col = render(p) * 0.1;\n    \n    //col = reinhard(col, .3, 100.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    vec2 p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 30.0;\n    vig = pow(vig, 0.1);\n    \n    fragColor = vec4(col * vig, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}