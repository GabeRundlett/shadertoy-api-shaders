{
    "Shader": {
        "info": {
            "date": "1596993137",
            "description": "Another scene featuring 'god rays'.\nImproving their quality hurts my GPU too much - I might have to spend some time thinking of a more efficient technique.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtsBzM",
            "likes": 43,
            "name": "Sanctum",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "light",
                "godrays",
                "ruins"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 1314
        },
        "renderpass": [
            {
                "code": "// 'Sanctum'\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others\n// for sharing their knowledge!\n\n#define MIN_DIST .0015\n\n#define MISS_ID   .5\n#define FLOOR_ID  1.5\n#define WALL_ID   2.5\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\nvec2 cappedMod(vec2 p, float c, vec2 rr) {\n    return p - c * clamp(round(p / c), -rr, rr);\n}\n\nmat2 rot(float a) {\n    float c = cos(a),\n          s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, q.y), 0.);\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h,r);\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdFlower(vec2 xy, float r, float a, float peaks) {\n    return length(xy) - r + a * sin(atan(xy.y * 2.34 / xy.x) * peaks);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro),\n         right = normalize(cross(vec3(0, 1, 0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdArch(vec3 p, const float plinthDepth) {\n    // Main wall.\n    vec3 s = vec3(2, 3, .4);\n    const float gapWidth = .5;\n    float holeOffset = (s.x + gapWidth) / 2.;\n    vec3 pp = p;\n    pp.x = abs(pp.x);\n    pp.y -= s.y;\n    float d = sdBox(pp, s);\n\n    // Arch holes.\n    d = max(d, -length(pp.xy - vec2(0, 1.5)) + gapWidth);\n    d = max(d, -length(pp.xy - vec2(holeOffset, 1)) + gapWidth);\n\n    // Arch gaps.\n    pp.y += s.y;\n    d = max(d, -sdBox(pp.xy, vec2(gapWidth, s.y + 1.5)));\n    d = max(d, -sdBox(pp.xy - vec2(holeOffset, 0), vec2(gapWidth, s.y + 1.)));\n\n    // Support decoration.\n    d = min(d, sdBox(pp - vec3(s.x / 3. - .035, s.y + .75, 0.), vec3(.15, .05, s.z + .05)) - .05);\n\n    // Short wall.\n    pp.z = abs(pp.z) + .7;\n    pp.y -= .6;\n    d = min(d, sdCylinder(pp.yxz, 1., s.x - gapWidth / 2.));\n\n    // Plinth.\n    d = min(d, sdBox(p - vec3(0, .2, 0), vec3(s.x - gapWidth / 2., .1, s.z + plinthDepth)) - .1);\n\n    // Backing wall.\n    pp = p;\n    s *= vec3(1.18, 1, .25);\n    pp -= vec3(0, s.y, 3);\n    d = min(d, sdBox(pp, s));\n\n    // Backing roof.\n    float hole = .6,\n          bar = .03;\n    pp.y -= 1.;\n    pp.xy = cappedMod(pp.xy, hole + bar * 2., vec2(1));\n    d = max(d, -sdBox(pp, vec3(hole / 2., hole / 2., .5)));\n\n    return d;\n}\n\nvec2 map(vec3 p) {\n    float surface = texture(iChannel0, (p.xy + p.yz + p.xz) * .1).r * .01,\n\n    // 'Collapse'.\n          collapse = sdFlower(p.xy - vec2(1, 11), 5., .2, 8.);\n    collapse = max(collapse, 10. - p.z);\n    collapse = min(collapse, sdFlower(p.xy - vec2(.9, 10), 3., .2, 4.));\n\n    // 'Fold space' to duplicate the arches.\n    for (int i = 0; i < 9; i++) {\n        p.xz *= rot(-.1);\n        p.x -= 1.04;\n        p.x = abs(p.x);\n    }\n\n    // Top arches.\n    float d = sdArch(p - vec3(0, 5.7, 10), 0.);\n    d = max(d, -collapse);\n\n    // Bottom arches.\n    d = min(d, sdArch(p - vec3(0, 0, 10), 1.));\n    d -= surface;\n\n    return min2(vec2(abs(p.y), FLOOR_ID), vec2(d, WALL_ID));\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1., -1.) * .5773 * .0001;\n    return normalize(e.xyy * map(p + e.xyy).x +\n\t\t\t\t\t e.yyx * map(p + e.yyx).x +\n\t\t\t\t\t e.yxy * map(p + e.yxy).x +\n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcAO(vec3 p, vec3 n, float d) {\n    return clamp(map(p + n * d).x / d, 0., 1.);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    vec3 rd = normalize(lightPos - p);\n\n    float res = 1.,\n          t = .1;\n    for(float i = 0.; i < 30.; i++)\n    {\n        float h = map(p + rd * t).x;\n        if (h < .03)\n            return 0.; // Hit an object - Full shadow.\n\n        res = min(res, 8. * h / t);\n        t += h;\n\n        if (t > 20.)\n            break; // Marched far enough - Stop.\n    }\n\n    return res;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n    return col;\n}\n\nvec3 sunPos = vec3(10, 8, 20),\n     sunCol = vec3(2, 1.9, 1.5);\n\nvec3 getMaterial(vec3 p, vec3 rd, float id) {\n    if (id == MISS_ID)\n        return vec3(0);\n\n    vec3 sunDir = normalize(sunPos - p),\n         n = calcNormal(p);\n\n    vec3 mat;\n    if (id == FLOOR_ID) {\n        mat = vec3(texture(iChannel0, p.xz * .01).r);\n    } else if (id == WALL_ID) {\n        mat = texture(iChannel0, (n.xy + n.yz) * .05).rgb;\n    }\n\n    // Diffuse color.\n    float diff = max(0., dot(sunDir, n)),\n\n    // Fake ambient occlusion.\n          occ = min(1., .2 + calcAO(p, n, 1.) * calcAO(p, n, .4));\n\n    // Shadows.\n    float sha = calcShadow(p, sunPos);\n\n    // Primary light (Sun).\n    vec3 lig = diff * sha * sunCol;\n\n    // Seconary light (Sky);\n    lig += max(0., .5 + .5 * n.y) * vec3(.7, .8, 1) * .2 * occ;\n\n    // Third light - Ambient.\n    lig += max(0., dot(sunDir * vec3(-1., 0., -1.), n)) * sunCol * .02 * occ;\n\n    return mat * lig;\n}\n\nvoid march(vec3 ro, vec3 rd, out vec3 p, out vec2 h) {\n    float d = .01;\n    for (float steps = 0.; steps < 96.; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n\n        if (abs(h.x) < MIN_DIST) return; // We've hit a surface - Stop.\n        d += h.x * .9; // No hit, so keep marching.\n    }\n\n    h.y = MISS_ID;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    // Camera.\n    float ft = fract(iTime / 8.),\n          phase = mod(floor(iTime / 8.), 3.);\n\n    vec3 ro,\n         lookAt = vec3(0, 6, 12);\n\n    if (phase == 0.) {\n        ro = vec3(5. - ft, 1.5, -5.);\n        lookAt.x -= ft;\n        sunPos.x *= mix(.82, 1.62, ft);\n        sunPos.y *= mix(2.375, .90, ft);\n    } else if (phase == 1.) {\n        ro = vec3(-5. + ft, 1.5, 2.);\n        lookAt = vec3(0, 3, 12);\n        sunPos.x *= mix(.02, 1.99, ft);\n        sunPos.y *= mix(.375, .90, ft);\n    } else if (phase == 2.) {\n        ro = vec3(mix(-5., -.0625, ft), 4.7, 5.);\n        sunPos.y *= 1.625;\n    }\n\n    vec3 rd = getRayDir(ro, lookAt, uv);\n\n    // Raymarch.\n    vec2 h = vec2(1e7, MISS_ID);\n    vec3 p;\n\tmarch(ro, rd, p, h);\n\n    // Materials and lighting.\n    vec3 col = getMaterial(p, rd, h.y);\n\n    // Volumetric lighting ('God rays')\n    const float maxSteps = 35.;\n    float dp = distance(ro, p);\n    vec3 beamStep = rd * dp / maxSteps;\n    float illum = 0.;\n    float jit = hash(uv) * .6;\n    for (float i = 0.; i < maxSteps; i++) {\n        vec3 sp = ro + beamStep * (i + jit); // Jitter so smooth sampling point. (Thanks BigWings!)\n        illum += smoothstep(0., 1., calcShadow(sp, sunPos));\n    }\n\n    illum /= maxSteps;\n    col = mix(col, sunCol, pow(illum, .7));\n\n    // Fog.\n    col = mix(vec3(1), col, vec3(exp(-pow(dp / 50., 3.) * 5.)));\n\n    // Output to screen.\n    col = vignette(pow(col, vec3(.4545)), fragCoord);\n    fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}