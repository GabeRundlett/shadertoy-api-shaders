{
    "Shader": {
        "info": {
            "date": "1722090041",
            "description": "source  https://www.shadertoy.com/view/lcjyzw https://glslsandbox.com/e#103693.0",
            "flags": 0,
            "hasliked": 0,
            "id": "lfjyzm",
            "likes": 2,
            "name": "RGB distributor",
            "published": 3,
            "tags": [
                "fractal",
                "light",
                "cinshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 96
        },
        "renderpass": [
            {
                "code": "#define M iMouse\n#define R iResolution\n#define aspect R.x/R.y\n#define PI 3.14159\n\n#define iter 12\n#define fraciter 7\n#define thickness 3.\n#define centerscale 0.1\n#define zoom 3.\n#define usefractal 1.\n#define usetex 1.\nvec2 r2d (float a) {\n    return vec2(sin(a), cos(a));\n}\n\nvec2 fractaluv (in vec2 uv, in float angle) {\n    uv *= vec2(aspect, 1.) * zoom;\n    \n    float a = (5./6.) * PI; // side angle\n    // sides\n    \n    for (int i = 0; i < fraciter; i++) { \n        uv.x = abs(uv.x); // mirror\n        uv.y += tan(a)*centerscale; // find offset\n        float siderot = dot(uv-vec2(centerscale, 0.), r2d(a)); // rotate\n        uv -= r2d(a)*max(0.,siderot)*2.; // mirror the mirrored side\n    }\n    float s = 1.;\n    uv.x += 0.5;\n    \n    for (int i = 0; i < iter; i++) {\n        // reset uv coords\n        uv = (uv*3.)-vec2(1.5,0.);\n        s *= 4.75;\n        // mirror\n        uv.x = abs(uv.x) - 0.5;\n        // dot rotates line // min makes the negative values reflect\n        uv -= r2d(angle) * min(0., dot(uv,r2d(angle))) * 2.;\n    }\n    \n    uv.x /= aspect;\n    uv /= s;\n    \n    return uv;\n}\n\nvec3 fractalcolor (in vec3 col, in vec2 uv, in float a) {\n    \n    // dist of line\n    float dist = length(uv - vec2(clamp(uv.x, -1., 1.), 0.));\n    // make line less uhh idk (and color it)\n    // 1./R.y makes it always 1 pixel thick\n    col = mix(col, vec3(1), smoothstep(1./R.y*thickness, .0, dist));\n    return col;\n}\n#define time iTime\n#define resolution iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   \n    \n\n    // UV\n    vec2 uv = (I/R.xy) - 0.5;\n    vec2 uv1 = uv;\n    float a = (2./3.) * PI * mix(0.,0.59,abs(-1.*0.1+iTime*0.5));\n    uv = mix(uv+0.1, fractaluv(uv, a), usefractal);\n\n\n\n    \n    float angle = atan((gl_FragCoord.y - resolution.y / 2.0) / (gl_FragCoord.x - resolution.x / 2.0));\n    \n    float d = length(uv);\n    float d1 = abs(sin(d * 5.0 + angle + time));\n    d1 = 0.2 / d1;\n    float d2 = abs(sin(d * 5.0 + angle + time + 7.1));\n    d2 = 0.2 / d2;\n    float d3 = abs(sin(d * 4.0 + angle + time + 1.2));\n    d3 = 0.2 / d3;\n    float d4 = abs(sin(d * .0 - angle + time + 3.2));\n    d4 = 0.2 / d4;\n\n    // Output to screen\n    vec3 ft= vec3(d3,d2,d1+d4);\n    // Grabpass\n    vec3 col = mix( vec3(0.), ft, usetex * smoothstep(0.5, 1.,abs(1.5-iTime)) );\n    \n    // Col\n    col = mix(col, fractalcolor(col, uv, a), 1.);\n    \n    O = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}