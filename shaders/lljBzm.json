{
    "Shader": {
        "info": {
            "date": "1515510690",
            "description": "My first shader with shadows. i read some of iq's articles and used his soft shadow function.",
            "flags": 0,
            "hasliked": 0,
            "id": "lljBzm",
            "likes": 4,
            "name": "learning lighting",
            "published": 3,
            "tags": [
                "softshadows",
                "ambientocclusion"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 717
        },
        "renderpass": [
            {
                "code": "#define rot(A) mat2(sin(A),cos(A),cos(A),-sin(A))\n#define square(a) a*a\n\n#define minstep 0.05\n\n#define ambientlight     0.1\n#define ambientocclusion 0.03\n\n#define antialiasing\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// hash without sine by Dave_Hoskins\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Taken from one of Shane's shaders\n// https://www.shadertoy.com/view/4lSBzm\n// modified slightly\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n    mat3 tex = mat3(\n        texture(t, p.yz).xyz,\n        texture(t, p.zx).xyz,\n        texture(t, p.xy).xyz);\n    \n    tex = matrixCompMult(tex,tex);\n    \n    return tex*n;\n}\n\nfloat map(vec3 p)\n{\n    float len = 0.0;\n    for (float i = 1.0; i > 0.02; i/=3.0) {\n        vec3 p2 = abs(mod(p/i,3.0)-1.5);\n        \n        p2 = max(p2,p2.yzx);\n        len = max(len,(min(min(p2.x,p2.y),p2.z)-1.0)*i);\n    }\n    vec3 p2 = abs(p);\n    \n    return max(len,max(max(p2.x,p2.y),p2.z)-1.5);\n}\n\nvec3 findnormal(vec3 p, float len) {\n    vec2 eps = vec2(0,0.001);\n    \n    vec3 normal = vec3(\n        map(p+eps.yxx),\n        map(p+eps.xyx),\n        map(p+eps.xxy))\n       -len;\n    return normalize(normal);\n}\n\n//soft shadown function by iq\n//https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.002 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        t += h;\n    }\n    return res;\n}\n\nvec4 shade(vec3 ro, vec3 rd, float len) {\n    vec4 fragColor = vec4(1);\n    vec3 normal = findnormal(ro, len);\n        \n    float occlusion = clamp(map(ro+normal*ambientocclusion)/ambientocclusion,0.0,1.0);\n    float ambient = ambientlight*occlusion;\n\n    vec3 color = tex3D(iChannel1, ro, normal);\n    //color = fract(ro);\n    vec3 light = normalize(vec3(cos(iTime*0.2),-1,sin(iTime*0.2)));\n    float diffusion = dot(-light,normal)*2.0;\n\n    float shadow = softshadow(ro,-light,0.05,10.0,10.0);\n\n    float lighting = clamp(min(diffusion,shadow),ambient,1.0);\n\n    fragColor.xyz = min(color*lighting,1.0);\n    return (fragColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0,0,-2.7);\n    vec3 rd = normalize(vec3(uv,1));\n    \n    rd.yz *= rot(-iMouse.y/iResolution.y*3.14+3.14);\n    rd.xz *= rot(iMouse.x/iResolution.x*6.28);\n    ro.yz *= rot(-iMouse.y/iResolution.y*3.14+3.14);\n    ro.xz *= rot(iMouse.x/iResolution.x*6.28);\n    \n    //distlen.x is ray distance, distlen.y is the distance field length \n    \n    float dist = 0.0;\n    float len;\n    float lastlen = 1e2;\n    float borderlen = 1e2;\n    \n    vec3 hit2 = vec3(-1);\n    float hit2len = -1.0;\n    float hit2dist = -1.0;\n    for (int i = 0; i < 1000; i++)\n    {\n        len = map(ro);\n        \n        if (len > lastlen && hit2len < 0.0) {\n            if (lastlen/max(dist-lastlen,0.01)*iResolution.y < 2.0) {\n                hit2 = ro-rd*lastlen;\n                hit2len = lastlen;\n                hit2dist = dist-lastlen;\n            }\n        }\n        \n        if (dist > 10.0 || len/max(dist,0.01)*iResolution.y < 1.0)\n        {\n            break;\n        }\n        ro += rd*len;\n        dist += len;\n        lastlen = len;\n    }\n    \n    if(len/(dist+0.01) < 1.0/iResolution.y) {\n        fragColor = shade(ro,rd,len);\n    } else {\n\t\tfragColor = square(texture(iChannel0,rd));\n    }\n    \n    #ifdef antialiasing\n    \n    float hi = floor((sin(iTime*0.1)*0.5+0.5)*iResolution.x-fragCoord.x);\n    if (hi < 0.0) {\n    \tif (hit2len > 0.0) {\n            fragColor = mix(shade(hit2,rd,hit2len),fragColor, clamp(hit2len/max(hit2dist,0.01)*iResolution.y-1.0,0.0,1.0));\n        }\n    } else if (hi <= 3.0) {\n        fragColor = vec4(hit2len > 0.0);\n        return;\n    }\n\n    #endif\n    \n    fragColor = sqrt(fragColor);\n    //fragColor = vec4(hit2len > 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}