{
    "Shader": {
        "info": {
            "date": "1637973854",
            "description": "Based on: blueNoiseTemporal2019_slides.pdf\nReorders white noise to produce blue noise.\nThis can be used to modify the per-pixel seed of a ray tracer, to produce blue noise instead of white noise artifacts.",
            "flags": 32,
            "hasliked": 0,
            "id": "7ty3RK",
            "likes": 2,
            "name": "Distributing errors as blue nois",
            "published": 3,
            "tags": [
                "as",
                "errors",
                "bluenoise",
                "distributing"
            ],
            "usePreview": 0,
            "username": "Tara",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "const int block_size = 4;\nconst int pixels_in_block = block_size * block_size;\n\nfloat luma(vec3 color)\n{\n    return(color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722);\n    return((color.r + color.g + color.b) / 3.0);\n}\n\nvoid sort_array(inout float array[pixels_in_block])\n{\n    for(int k=0; k<pixels_in_block; ++k)\n    {\n        for(int j=0; j<pixels_in_block-1; ++j)\n        {    \n            if(array[j] > array[j + 1])\n            {\n                float temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid sort_array(inout vec3 array[pixels_in_block])\n{\n    for(int k=0; k<pixels_in_block; ++k)\n    {\n        for(int j=0; j<pixels_in_block-1; ++j)\n        {    \n            if(luma(array[j]) > luma(array[j + 1]))\n            {\n                vec3 temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Each pixel figures out which block it's in, and then \n    // orts its own block and picks the correct value for itself.\n    // This could be massively sped up using a compute shader.\n\n    ivec2 block_resolution = ivec2(iResolution.xy) / block_size;\n    ivec2 block_id = ivec2(fragCoord.xy) / block_size;\n    \n    int block_index = block_id.y * block_resolution.x + block_id.x;\n    ivec2 block_min = ivec2(block_index % block_resolution.x, block_index / block_resolution.x);\n    ivec2 block_max = block_min + block_size;\n\n    vec3 sorted_values[pixels_in_block];\n    float sorted_blue_noise_values[pixels_in_block];\n    \n    int value_index = 0;\n    \n    for(int y=block_min.y; y<block_max.y; ++y)\n    for(int x=block_min.x; x<block_max.x; ++x)\n    {\n        ivec2 pos = ivec2(x, y);\n        \n        //vec2 coord = (vec2(pos) + 0.5) / vec2(block_resolution);\n        \n        //vec3 val = texture(iChannel0, coord).rgb;\n        vec3 col = texture(iChannel0, (vec2(pos) + 0.5) / iResolution.xy).rgb;\n        float noise = texture(iChannel1, (vec2(pos) + 0.5) / iChannelResolution[1].xy).r;\n        \n        sorted_values[value_index] = col;\n        sorted_blue_noise_values[value_index] = noise;\n        ++value_index;\n    }\n    \n    // Sort colors:\n    sort_array(sorted_values);\n    \n    // Sort blue noise:\n    //sort_array(sorted_blue_noise_values);\n    \n    \n    //fragColor.rgb = sorted_values[15];\n    fragColor.rgb = sorted_values[pixels_in_block - 1];\n    fragColor.rgb = vec3(sorted_blue_noise_values[pixels_in_block - 1]);\n    \n    // Correlate samples:\n    float noise = texture(iChannel1, fragCoord.xy / iChannelResolution[1].xy).r;\n    fragColor.rgb = vec3(noise);\n    \n    \n    int remapped_index = int((float(pixels_in_block - 1) + 0.5) * noise);\n    fragColor.rgb = sorted_values[remapped_index];\n\n#ifdef SHOW_BLOCKS\n    fragColor *= vec4(fract(float(block_index) / 13.0));\n#endif\n\n\n    //fragColor = texture(iChannel1, fragCoord / iResolution.xy).rrrr;\n    //fragColor = texture(iChannel0, fragCoord / iChannelResolution[0].xy).rrrr;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = fragCoord / iChannelResolution[0].xy;\n\n    fragColor = texture(iChannel0, uv);\n    fragColor = texture(iChannel0, uv).rrrr;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}