{
    "Shader": {
        "info": {
            "date": "1685913567",
            "description": "Simple fract repetition time based pattern derived from this tutorial by Kishimisu https://www.youtube.com/watch?v=f4s1h2YETNY",
            "flags": 64,
            "hasliked": 0,
            "id": "clySR1",
            "likes": 3,
            "name": "Candy Six",
            "published": 3,
            "tags": [
                "2d",
                "psychedelic",
                "colourful"
            ],
            "usePreview": 0,
            "username": "Pink",
            "viewed": 182
        },
        "renderpass": [
            {
                "code": "//Based on https://www.youtube.com/watch?v=f4s1h2YETNY\n//inline comments may not be completely accurate.\n\n// Gold Noise ©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated fractional seeding method. \n\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nvec3 palette (float dist)\n{\n    //make a distance based colour gradient\n    vec3 a = vec3(0.5,0.0,0.5);\n    vec3 b = vec3(0.25,0.25,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a+b*cos(6.28318*(c*dist*d) );\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //speed of ring movement (0.1 - 1.0 are good values)\n    float speed = 0.1;\n    //multiplier for number of colour rings (more rings more complex pattern)\n    float ringmultiplier = 4.0;\n    //width of colour regions (too high and you'll just get white as it uses additive colouring)\n    float ringwidth = 8.0;\n    //sort of smoothing between black and colour (0.1-0.4 are good)\n    float smoothing = 0.4;\n    //Iterations of fract (repeat of the pattern, set to 1 to see the basic pattern)\n    float iter = 8.0;\n    //Zoom amount, smaller = more zoomed in.\n    float zoom = 1.;\n    //noise seed\n    float seed = 6502.;\n    \n    \n\n    float myTime = iTime*0.5;\n    \n    // Centered aspect corrected normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y);\n\n    //copy of uv before we mess with it in fract.\n    vec2 uv0 = uv;\n    float noise = gold_noise(fragCoord, seed) - ((sin(myTime * 0.5)*0.5) + 0.5);\n    \n    uv *= (zoom * sin(myTime*0.05));\n    //initialise output colour (we add to this in the loop)\n    vec3 outCol = vec3(0.0);\n\n    for(float i = 0.0; i < iter; i++)\n    {\n        //repeat pattern\n        uv = fract(uv * (1.25 + (sin((myTime * 0.1) * i))))-0.5;\n        //uv = fract(uv)-0.5;\n\n        //distance from centre \n        float dist = sdHexagon(uv, 0.25);\n\n        // Time varying simple pixel color\n        //vec3 col = 0.5 + 0.5 * cos((myTime*i*0.1) + uv.xyx + vec3(0,2,4));\n\n        //distance/time varying pixel colour gradient\n        vec3 col = palette(length(uv0) + myTime); //* (i*0.01));\n\n        //time based distance with modifiers for speed, width, and number of rings\n        dist = sin((dist - (myTime * speed)) * ringmultiplier * 2.0) / ringwidth;\n\n        //absolute the distance to invert negative values\n        dist = abs(dist);\n\n        //take the inverse of the distance (effectively inverts what gets coloured in);\n        dist = 0.001 / dist;\n\n        //smoothstep colour to give clean edges.\n        col = col * smoothstep(0.0, 0.5-smoothing, dist) * noise;\n\n        outCol += col + dist;\n    }\n    \n    // Output to screen\n    fragColor = vec4(outCol,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 33507,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/algoritmos666/tron-legacy-soundtrack-ost-03"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}