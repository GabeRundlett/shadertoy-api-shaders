{
    "Shader": {
        "info": {
            "date": "1644855310",
            "description": "a bit laggy tho",
            "flags": 0,
            "hasliked": 0,
            "id": "fdfBDN",
            "likes": 1,
            "name": "Colourful turbulence",
            "published": 3,
            "tags": [
                "noise",
                "color",
                "rgb",
                "colour",
                "smooth"
            ],
            "usePreview": 0,
            "username": "forprix",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "const float radius = 20.0;\nconst float PI = 3.1415926538;\n\n\n\nfloat rand(in vec2 p, in float s) {\n    return fract(sin(dot(vec3(p, s),vec3(12.9894,78.233,144.7272))) * 43758.5453);\n}\n\nvec3 noise(in vec2 coord, in float seed) {\n    vec3 a;\n    a.x = rand(coord, seed + 1.);\n    a.y = rand(coord, seed + 2.);\n    a.z = rand(coord, seed + 3.);\n\treturn a;\n}\n\nvec3 rgb2hsl( in vec3 c ){\n  float h = 0.0;\n\tfloat s = 0.0;\n\tfloat l = 0.0;\n\tfloat r = c.r;\n\tfloat g = c.g;\n\tfloat b = c.b;\n\tfloat cMin = min( r, min( g, b ) );\n\tfloat cMax = max( r, max( g, b ) );\n\n\tl = ( cMax + cMin ) / 2.0;\n\tif ( cMax > cMin ) {\n\t\tfloat cDelta = cMax - cMin;\n        \n\t\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\n        \n\t\tif ( r == cMax )\n\t\t\th = ( g - b ) / cDelta;\n\t\telse if ( g == cMax )\n\t\t\th = 2.0 + ( b - r ) / cDelta;\n\t\telse\n\t\t\th = 4.0 + ( r - g ) / cDelta;\n\n\t\tif ( h < 0.0)\n\t\t\th += 6.0;\n\t\th = h / 6.0;\n\t}\n\treturn vec3( h, s, l );\n}\nvec3 hsl2rgb(vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nfloat rand(float co) {\n    return fract(sin(dot(vec2(co, co + 20055552.), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 step4(vec2 vec) {\n    \n    float rTime = iTime * rand(vec, 0.) * 5.;\n    \n    float qb = float(int(rTime));\n    \n    vec3 a = noise(vec, float(int(rTime) - 1));\n    \n    return a + (noise(vec, qb) - a) * (rTime - qb);\n}\nvec3 step3(vec2 vec) {\n    vec3 sum = vec3(0, 0, 0);\n    int i = 0;\n    \n    for (int x = int(-radius); x <= int(radius); ++x)\n    \tfor (int y = int(-radius); y <= int(radius); ++y) {\n            float d = sqrt(float(x * x + y * y));\n            if (d <= radius) {\n                float k = 1. - d / radius;\n            \ti++;\n            \tsum += step4(vec2(vec.x + float(x), vec.y + float(y))) * k;\n\t\t\t}\n        }\n    \n    sum /= float(i);\n    \n    \n    return sum;\n}\n\n\nvec3 step2(vec2 vec) {\n    vec3 hsl = rgb2hsl(step3(vec));\n    hsl.y = 33333.;\n    return hsl2rgb(hsl);\n}\n\nvec3 step1(vec2 vec) {\n    return step2(vec);\n}\n\nconst int gaytest = 2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = step1(fragCoord.xy);\n    \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}