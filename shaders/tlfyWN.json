{
    "Shader": {
        "info": {
            "date": "1592081082",
            "description": "What you drop some LSD into your beer?\nRendering Beer using beer lamber law.",
            "flags": 64,
            "hasliked": 0,
            "id": "tlfyWN",
            "likes": 11,
            "name": "MX Psychedelic Lager",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "lambert",
                "beer",
                "audioreactive"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 482
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2020\n\n#define MAX_DIST\t\t5.\n#define PI              radians(180.)\n#define TAU             radians(360.)\n#define AA              0\n#define BIASED_NORMAL \t1\n#define MAX_BOUNCES     8\n\n#define BUBBLE1_BASE_SIZE\t0.005\n#define BUBBLE1_MUSIC_SIZE\t0.07\n#define BUBBLE2_BASE_SIZE\t0.008\n#define BUBBLE2_MUSIC_SIZE\t0.09\n\n#define ABSORB\t\t\tvec3(0., 0., 1.7)\n\n\nfloat low, mid, hig;\n\nmat3\tm0, m1;\n\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\n\nfloat sdSphere(in vec3 p, in float r)\n{\n  return length(p) - r;\n}\n\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nfloat sdfX1(in vec3 p)\n{\n    return opExtrussion(p, sd2dMX(p.xy), 0.5);\n\n}\n\nvec3 repeat(in vec3 p, in vec3 v, out vec3 fl)\n{\n    fl = floor((p + v / 2.) / v );\n    return mod(p + v / 2., v) - v / 2.;\n}\n\nfloat rand(vec3 n)\n{ \n    return fract(sin(dot(n, vec3(12.9898, 4.1414,14.6313))) * 43758.5453);\n}\n\nfloat sdBubbles(in vec3 p)\n{\n    vec3 f0;\n    vec3 d0 = repeat(m0 * (p - vec3(0, iTime * 0.13, 0)), vec3(0.52, 0.45, 0.44), f0);\n    vec3 f1;\n    vec3 d1 = repeat(m0 * (p - vec3(0, iTime * 0.06, 0)), vec3(0.72, 0.61, 0.53), f1);\n\treturn smin(sdSphere(d0, (BUBBLE1_MUSIC_SIZE * hig + BUBBLE1_BASE_SIZE) * rand(f0)), \n\t\t\t\tsdSphere(d1, (BUBBLE2_MUSIC_SIZE * low + BUBBLE2_BASE_SIZE) * rand(f1)), 20.0);\n}\n\n\nfloat map(in vec3 p)\n{\n  float dX1 = sdfX1(p);\n  float dBB = sdBubbles(p);\n\n  return opSubtraction(dBB, dX1);\n}\n\nfloat vv(float x, float y)\n{\n \tfloat angle = atan(y, x);\n    float att = max( 0.0, 2.0 * mid -  length(vec2(x, y)));\n\treturn cos(7.*angle) * att;\t   \n}\n\nfloat flower(vec2 uv, vec2 f)\n{\n\tfloat x = (uv.x - sin( iTime * f.x));\n   \tfloat y = (uv.y - cos( iTime * f.y) / 4.);\n    //\n    float v = 0.;\n    v += vv(x, y);\n    v += vv(x + 2., y);\n    v += vv(x - 2., y);\n\treturn v;\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    //return texture(iChannel1, rd).rgb;\n    vec2 uv = vec2(atan(rd.z, rd.x) / PI , tan(rd.y) / 2.);\n    float p = 0.;\t\n\tp += flower(uv, vec2(0.03, 0.06));\n\tp += flower(uv, vec2(0.07, 0.01));\n\tp += flower(uv, vec2(0.08, 0.02));\n\tp += flower(uv, vec2(0.09, 0.04));\n    return vec3((cos(p*1.25 + 0.3566 + iTime) + 1.) / 2., (cos(p*2.2255 + 1.524 + iTime) + 1.) / 2., (cos(p*3.258 + 5.325 + iTime) + 1.) / 2.);\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 60; i++)\n  {\n    float h = sgn * map(ro + rd*t);\n    t += h;\n    if (h < 0.0002 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float sgn = 1.;\n    float cref = 0.7;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.9;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        float t = rayMarch(sgn, ro, rd, 0.02);\n        if( t> MAX_DIST)\n        {\n            col += rel * getSkyColor(rd);\n            break;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * t);\n        vec3 p = ro + rd * t;\n        vec3 n = sgn * calcNormal(p);\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n\tcol = pow(col, vec3(1./2.2));\n\tcol = contrast(col, 1.2);\n\tcol = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 genMat(in vec3 dir,in vec3 up)\n{\n\tvec3 cw = normalize(dir);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mid = texture(iChannel0, vec2(0.5,0.25)).x;\n    low = texture(iChannel0, vec2(0.9,0.25)).x;\n    hig = texture(iChannel0, vec2(0.1,0.25)).x;\n    \n    m0 = genMat(vec3(1,2,3), vec3(0,1,1));\n    m1 = genMat(vec3(2,1,4), vec3(1,1,0));\n    \n    vec3 tot = vec3(0.0);\n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(90. + iTime*12.);\n        float phi\t= radians(90.);\n        \n        //float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        //float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        //float theta\t= radians(90.);\n        //float phi\t= radians(50.);\n        vec3 ro = 3.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd);\n        \n\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 23124,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/babelian/rob-hubbard-goldrunner-khatchadour-remix"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Oriented Box\nfloat sdOBox(vec2 p, vec2 c, vec2 b, vec2 d)\n{\n    mat2\tr;\n    r[0]\t= d;\n   \tr[1]\t= vec2(-d.y, d.x);\n    vec2\tlp = (p - c) * r;\n    vec2\tq = abs(lp) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);  \n}\n\n// Axis Aligned Box\nfloat sdAABox(vec2 p, vec2 c, vec2 b)\n{ \n    vec2\tq = abs(p - c) - b;\n    return\tlength(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\n// Circle\nfloat sdCircle(vec2 p, vec2 c, float r)\n{\n    return\tlength(p - c) - r;\n}\n\nfloat sd2dM(vec2 p)\n{\n    float d0 = sdAABox(p, vec2(-1.5990, -0.2965), vec2(0.2900, 0.7035));\n    float d1 = sdAABox(p, vec2(-0.8555, -0.2965), vec2(0.2905, 0.7035));\n    float d2 = sdAABox(p, vec2(-0.1135, -0.2965), vec2(0.2905, 0.7035));\n    float cl = sdCircle(p, vec2(-1.3349, 0.4478), 0.5545);\n    float cr = sdCircle(p, vec2(-0.3787, 0.4478), 0.5565);\n    float cb = opUnion(cl, cr);\n    float dl = opUnion(d0, opUnion(d1, d2));\n    cb = opIntersection(cb, 0.2 - p.y);\n    float hl = sdCircle(p, vec2(-1.2275, 0.2000), 0.0815);\n    float hr = sdCircle(p, vec2(-0.4845, 0.2000), 0.0815);\n    float hb = opUnion(hl, hr);\n    return opSubtraction(hb, opUnion(dl, cb));    \n}\n\nfloat sd2dX(vec2 p)\n{\n    float dd = sdOBox(p, vec2(1.0765, -0.0245), vec2(1.2410, 0.2679), vec2(-0.4634, 0.8861));\n    float du = sdOBox(p, vec2(1.0535, -0.0245), vec2(1.2480, 0.2532), vec2(0.4776, 0.8786));\n    float dx = opUnion(dd, du);\n    return opIntersection(sdAABox(p, vec2(1.0620, -0.0245), vec2(0.8270, 0.9755)), dx);\n}\n\nfloat sd2dMX(vec2 p)\n{\n    return opUnion(sd2dM(p), sd2dX(p));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}