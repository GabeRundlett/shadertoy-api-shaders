{
    "Shader": {
        "info": {
            "date": "1669291872",
            "description": "Made a rough recreation of Porter Robinson's Language, pretty happy with how it turned out :)",
            "flags": 40,
            "hasliked": 0,
            "id": "ddfXRX",
            "likes": 11,
            "name": "Porter Robinson - Language Cover",
            "published": 3,
            "tags": [
                "procedural",
                "sound",
                "music",
                "audio",
                "language",
                "synthesis",
                "synth",
                "saw",
                "sawtooth",
                "gpusound",
                "supersaw",
                "chords",
                "unison",
                "porterrobinson"
            ],
            "usePreview": 0,
            "username": "MysteryPancake",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "// From https://www.shadertoy.com/view/ltfSRr\nfloat message(vec2 uv) {\n\tuv -= vec2(1.0, 10.0);\n\tif ((uv.x < 0.0) || (uv.x >= 32.0) || (uv.y < 0.0) || (uv.y >= 3.0)) return -1.0;\n\tint i = 1, bit = int(exp2(floor(32.0 - uv.x)));\n\tif (int(uv.y) == 2) i = 928473456 / bit;\n\tif (int(uv.y) == 1) i = 626348112 / bit;\n\tif (int(uv.y) == 0) i = 1735745872 / bit;\n\treturn float(i - 2 * (i / 2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tif (iResolution.y < 2000.0) {\n\t\tfloat c = message(fragCoord / 8.0);\n\t\tif (c >= 0.0){\n\t\t\tfragColor = vec4(c);\n\t\t\treturn;\n\t\t}\n\t}\n    \n    // Lens distortion, see https://www.shadertoy.com/view/stdcRf\n    vec2 uv = fragCoord / iResolution.xy;\n    const vec2 center = vec2(0.5);\n\tfloat dist = distance(uv, center);\n\tvec2 dir = uv - center;\n    float time = mod(iTime, SPB * LOOPS);\n    float beat = mod(time, SPB);\n\tfloat lens = time >= SPB * 32.0 ? 0.3 / beat : max(0.0, 0.75 - beat);\n    vec4 color = vec4(uv, 0.5, 0.0) * dist * lens;\n\tfragColor = texture(iChannel0, uv - dist * dir * lens) + color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.1415926;\nconst float TAU = 6.28318530;\n\n#define NOTE(note, start, end) if (time >= start * SPB && time < end * SPB) result += note;\n#define NOTE_SAW(note, start, end) NOTE(superSaw(noteFreq(note), time, voices, detune) * amplitude, start, end);\n#define NOTE_SINE(note, start, end) NOTE(superSine(noteFreq(note), time - start * SPB, voices, detune) * amplitude, start, end);\n#define NOTE_BASS(note, start, end) NOTE(sine(noteFreq(note), time - start * SPB, 0.0, fade) * amplitude, start, end);\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn 440.0 * exp2((note - MIDIOFFSET) / 12.0);\n}\n\n// For sawtooth synths\nfloat saw(float freq, float time, float phase) {\n\treturn fract(phase + freq * time) * 2.0 - 1.0;\n}\n\n// For lead whistle\nfloat sine(float freq, float time, float phase, float fade) {\n\treturn sin(freq * (time + phase) * TAU) * exp(-fade * time);\n}\n\n// For cymbals\nvec2 noiseHit(float time, float fade) {\n\treturn (vec2(hash(time * 512.0), hash(time * 1024.0)) - 0.5) * exp(-fade * time);\n}\n\n// Multiple saws detuned to make a unison effect\nvec2 superSaw(float freq, float time, float voices, float detune) {\n    vec2 result = vec2(0.0);\n    // See https://www.shadertoy.com/view/mdlSRj\n    for (float i = -voices; i <= voices; i++) {\n        float frequency = freq + i * detune;\n        result.x += saw(frequency, time, hash(2.0 * i));\n        result.y += saw(frequency, time, hash(2.0 * i + 1.0));\n    }\n    return result / voices / 2.0;\n}\n\n// Multiple sines detuned to make a unison effect\nvec2 superSine(float freq, float time, float voices, float detune) {\n    vec2 result = vec2(0.0);\n    // See https://www.shadertoy.com/view/mdlSRj\n    for (float i = -voices; i <= voices; i++) {\n        float frequency = freq + i * detune;\n        result.x += sine(frequency, time, hash(2.0 * i) * PI, 1.5);\n        result.y += sine(frequency, time, hash(2.0 * i + 1.0) * PI, 1.5);\n    }\n    return result / voices / 2.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float Q) {\n    // Forgot to remap the hash to -1, 1, whoops\n    return sin(TAU * freq * fract(time)) * hash(time * Q);\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat kick(float time, float freq) {\n    const float df = 512.0, dftime = 0.01;\n    float phase = TAU * (freq * time - df * dftime * exp(-time / dftime));\n    float body = sin(phase) * smoothstep(0.15, 0.0, time) * 2.0;\n    float click = coloredNoise(time, 8000.0, 2000.0) * smoothstep(0.01, 0.0, time);\n    return body + click;\n}\n\n// Cheap snare or clap effect\nvec2 snare(float time, float freq, float fade) {\n    return noiseHit(time, fade) * abs(sin(freq * time * TAU));\n}\n\nvec2 leadBass(float time, float voices, float detune, float amplitude) {\n    time = mod(time, SPB * 16.0);\n    vec2 result = vec2(0.0);\n    NOTE_SAW(57.0, 0.0, 2.0);\n    NOTE_SAW(38.0, 0.0, 2.0);\n    NOTE_SAW(57.0, 2.5, 6.0);\n    NOTE_SAW(38.0, 2.5, 6.0);\n    NOTE_SAW(57.0, 6.5, 8.0);\n    NOTE_SAW(38.0, 6.5, 8.0);\n    NOTE_SAW(61.0, 8.0, 9.5);\n    NOTE_SAW(42.0, 8.0, 9.5);\n    NOTE_SAW(59.0, 9.5, 10.0);\n    NOTE_SAW(40.0, 9.5, 10.0);\n    NOTE_SAW(59.0, 10.5, 12.0);\n    NOTE_SAW(40.0, 10.5, 12.0);\n    NOTE_SAW(56.0, 12.0, 13.5);\n    NOTE_SAW(37.0, 12.0, 13.5);\n    NOTE_SAW(57.0, 13.5, 14.0);\n    NOTE_SAW(38.0, 13.5, 14.0);\n    NOTE_SAW(57.0, 14.5, 16.0);\n    NOTE_SAW(38.0, 14.5, 16.0);\n    return result;\n}\n\nvec2 leadChords(float time, float voices, float detune, float amplitude, float offset) {\n    time = mod(time, SPB * 16.0);\n    vec2 result = vec2(0.0);\n    \n    // Optimize since every 2nd note is the same\n    if (mod(time + SPB * offset, SPB) >= SPB * 0.5) {\n        result += superSaw(noteFreq(64.0), time, voices, detune) * amplitude;\n    }\n    \n    NOTE_SAW(66.0, 0.5, 1.0);\n    NOTE_SAW(66.0, 1.5, 2.0);\n    NOTE_SAW(66.0, 2.5, 3.0);\n    NOTE_SAW(66.0, 3.5, 4.0);\n    NOTE_SAW(69.0, 4.5, 5.0);\n    NOTE_SAW(69.0, 5.5, 6.0);\n    NOTE_SAW(69.0, 6.5, 7.0);\n    NOTE_SAW(69.0, 7.5, 8.0);\n    NOTE_SAW(69.0, 8.5, 9.0);\n    NOTE_SAW(68.0, 9.5, 10.0);\n    NOTE_SAW(68.0, 10.5, 11.0);\n    NOTE_SAW(68.0, 11.5, 12.0);\n    NOTE_SAW(73.0, 12.5, 13.0);\n    NOTE_SAW(66.0, 13.5, 14.0);\n    NOTE_SAW(66.0, 14.5, 15.0);\n    NOTE_SAW(66.0, 15.5, 16.0);\n    return result;\n}\n\nvec2 leadSine(float time, float voices, float detune, float amplitude) {\n    time = mod(time, SPB * 32.0);\n    vec2 result = vec2(0.0);\n    NOTE_SINE(88.0, 0.0, 1.5);\n    NOTE_SINE(100.0, 0.0, 1.5);\n    NOTE_SINE(93.0, 1.5, 7.0);\n    NOTE_SINE(81.0, 1.5, 7.0);\n    NOTE_SINE(102.0, 7.0, 8.0);\n    NOTE_SINE(90.0, 7.0, 8.0);\n    NOTE_SINE(88.0, 8.0, 9.5);\n    NOTE_SINE(100.0, 8.0, 9.5);\n    NOTE_SINE(85.0, 9.5, 11.0);\n    NOTE_SINE(97.0, 9.5, 11.0);\n    NOTE_SINE(92.0, 11.0, 12.5);\n    NOTE_SINE(80.0, 11.0, 12.5);\n    NOTE_SINE(93.0, 12.5, 13.5);\n    NOTE_SINE(81.0, 12.5, 13.5);\n    NOTE_SINE(90.0, 13.5, 16.0);\n    NOTE_SINE(78.0, 13.5, 16.0);\n    NOTE_SINE(88.0, 16.0, 17.5);\n    NOTE_SINE(100.0, 16.0, 17.5);\n    NOTE_SINE(81.0, 17.5, 23.0);\n    NOTE_SINE(93.0, 17.5, 23.0);\n    NOTE_SINE(90.0, 23.0, 24.0);\n    NOTE_SINE(102.0, 23.0, 24.0);\n    NOTE_SINE(88.0, 24.0, 25.5);\n    NOTE_SINE(100.0, 24.0, 25.5);\n    NOTE_SINE(85.0, 25.5, 28.0);\n    NOTE_SINE(97.0, 25.5, 28.0);\n    NOTE_SINE(88.0, 28.0, 29.0);\n    NOTE_SINE(100.0, 28.0, 29.0);\n    NOTE_SINE(90.0, 29.0, 29.5);\n    NOTE_SINE(102.0, 29.0, 29.5);\n    NOTE_SINE(81.0, 29.5, 32.0);\n    NOTE_SINE(93.0, 29.5, 32.0);\n    return result;\n}\n\nvec2 bass(float time, float fade, float amplitude) {\n    time = mod(time, SPB * 16.0);\n    vec2 result = vec2(0.0);\n    NOTE_BASS(38.0, 0.5, 1.0);\n    NOTE_BASS(38.0, 1.0, 1.5);\n    NOTE_BASS(38.0, 1.5, 2.0);\n    NOTE_BASS(38.0, 2.5, 3.0);\n    NOTE_BASS(38.0, 3.0, 3.5);\n    NOTE_BASS(38.0, 3.5, 4.0);\n    NOTE_BASS(38.0, 4.0, 4.5);\n    NOTE_BASS(38.0, 4.5, 5.0);\n    NOTE_BASS(38.0, 5.0, 5.5);\n    NOTE_BASS(38.0, 5.5, 6.0);\n    NOTE_BASS(38.0, 6.5, 7.0);\n    NOTE_BASS(38.0, 7.0, 7.5);\n    NOTE_BASS(38.0, 7.5, 8.0);\n    NOTE_BASS(42.0, 8.0, 8.5);\n    NOTE_BASS(42.0, 8.5, 9.0);\n    NOTE_BASS(42.0, 9.0, 9.5);\n    NOTE_BASS(40.0, 9.5, 10.0);\n    NOTE_BASS(40.0, 10.5, 11.0);\n    NOTE_BASS(40.0, 11.0, 11.5);\n    NOTE_BASS(40.0, 11.5, 12.0);\n    NOTE_BASS(37.0, 12.0, 12.5);\n    NOTE_BASS(37.0, 12.5, 13.0);\n    NOTE_BASS(37.0, 13.0, 13.5);\n    NOTE_BASS(38.0, 13.5, 14.0);\n    NOTE_BASS(38.0, 14.5, 15.0);\n    NOTE_BASS(38.0, 15.0, 15.5);\n    NOTE_BASS(38.0, 15.5, 16.0);\n    return result;\n}\n\nvec2 cymbals(float time, float amplitude) {\n    //vec2 pan = mod(time + STEP * 0.5, STEP * 2.0) > STEP ? vec2(0.5, 1.0) : vec2(1.0, 0.5);\n    vec2 pan = mod(time, SPB * 2.0) > SPB ? vec2(0.5, 1.0) : vec2(1.0, 0.5);\n    return noiseHit(mod(time + SPB * 0.5, SPB), 3.0) * amplitude * pan;\n}\n\n// For debugging\nvec2 metronome(float time) {\n    return vec2(sin(PI * 880.0 * time) * exp(-32.0 * time));\n}\n\nvec2 mainSound(int samp, float iTime) {\n    \n    float time = mod(iTime, SPB * LOOPS);\n    float beat = mod(time, SPB);\n    vec2 result = vec2(0.0);\n    float sidechain = 1.0;\n    \n    if (time >= SPB * 16.0) {\n        sidechain = 1.0 - exp(-6.0 * beat);\n        result += cymbals(time, 0.4);\n    }\n    \n    if (time >= SPB * 32.0) {\n        result += kick(beat, noteFreq(33.0)) * 0.4;\n        result += leadSine(time, 2.0, 4.0, 0.35);\n        result += snare(mod(time + SPB, SPB * 2.0), noteFreq(21.0), 4.0);\n        result += bass(time, 6.0, 0.6 * sidechain);\n    }\n    \n    if (time < SPB * 30.5 || time >= SPB * 32.0) {\n        result += leadBass(time, 1.0, 0.5, 0.4 * sidechain);\n    }\n    \n    // Make it more funky every 2nd loop\n    float funk = int(iTime / (SPB * LOOPS)) % 2 == 0 ? 0.5 : 0.0;\n    result += leadChords(time, 2.0, 0.5, 0.6 * sidechain, funk);\n    \n    //result += metronome(beat);\n    \n    return result;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float time = mod(iTime, SPB * LOOPS);\n    if (mod(time, SPB) < 0.05 || time >= SPB * 32.0) {\n        vec4 vid1 = texture(iChannel0, uv);\n        vec4 vid2 = texture(iChannel2, uv);\n        fragColor = mod(time * 0.5, SPB * 2.0) < SPB ? vid1 : vid2;\n    } else {\n        fragColor = texture(iChannel1, uv);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    },
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float BPM = 128.0;\nconst float SPB = 60.0 / BPM; // Seconds per beat\n\nconst float LOOPS = 96.0;\n\nconst float MIDIOFFSET = 69.0;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}