{
    "Shader": {
        "info": {
            "date": "1631584168",
            "description": "Mouse enabled\ncool harry potter themed functions\nInspired by https://www.shadertoy.com/view/lljSDy which I still don't understand completely",
            "flags": 0,
            "hasliked": 0,
            "id": "NsVGDD",
            "likes": 9,
            "name": "Quad Tree Plus Circle",
            "published": 3,
            "tags": [
                "sdf",
                "tutorial",
                "comments",
                "quadtree",
                "harrypotter",
                "wellcommented"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 347
        },
        "renderpass": [
            {
                "code": "//yore a wizard harry\n\n//a rotating vector\n#define wingardium_leviosa vec2(cos(iTime),sin(iTime))\n\n//from Fabrice,now I just need to find a spell for frame\n#define frame(p) vec2((p.xy*2.-iResolution.xy)/iResolution.y)\n\n//kind of like the open sesame of shadertoy\n#define alohamora frame(fragCoord)\n\n//kind of like what everyone thought Snape was doing but it was actually Quirl\n#define mobiliarbus frame(iMouse)\n\n//max layers of the quad tree\n#define max_layers 6\n\n//static factor to use each round\n#define scale_factor 2.\n\n//we use this to get the diagonal length of a quad in each layer\n//diagonal length of a square is side_length*sqrt(2) \n#define sqrt_of_2 1.41421356\n\n#define eps 1./iResolution.y\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n    \n    vec2 uv = alohamora; //uv from -1. to 1.\n    vec2 global_uv = alohamora; //do it again just for fun\n    float scale = 2.; //starting scale \n    float radius = 0.34; //circle radius\n    float dist = 100.; //starting distance to circle \n    vec2 circle_coords = wingardium_leviosa;//move the circle around\n    \n    //if mouse is pressed, then you control the circle\n    if(iMouse.z > 0.5) circle_coords = mobiliarbus;\n    \n    //starting color\n    O = vec4(0.0);\n    O.r = .25;\n    \n    //find distance estimation to circle \n    float circle_dist = length(uv-circle_coords) - radius;\n    \n    //the plan is simple\n    \n    for(int i = 0; i < max_layers; i++){\n    \n        //we get a scaling variable of 2^n where n is layer number\n        scale = pow(scale_factor,float(i));\n        //we scale the global uv by it so from -1 -> 1\n        //we go to -2 -> 2 and then -4 -> 4 and so on\n        vec2 local_uv = global_uv*scale;\n        //we get the floor coordinates of this system for an id\n        //each QUAD then is a cell from one integer to the next (in 2d)\n        \n        // x: 1 -> 2 and y: 1 -> 2 is one quad\n        vec2 id = floor(local_uv);\n        //we use that id to get the centers for each quad local space\n        //and then immediately convert to global space by dividing again\n        //by our scale\n        //now we have a center coordinate, in global space, for \n        //every quad created in this layer\n        vec2 global_quad_center = (id + 0.5)/scale;\n        //we then find the lenght of one side in global space\n        //which is 1./scale (for example, if scale is 1, we have\n        //only 1 quad, so length is one\n        //if scale is 2, we have 4 quads with these dimentions\n        //\n        // x:0->0.5, y:0.5->1.  x:0.5->0.5, y:0.5->1.\n        //\n        // x:0->0.5, y:0->0.5   x:0.5->1., y:0.->0.5\n        //\n        //and you can see the math works because 1./2. gives a length\n        //of 0.5 which each quad has\n        \n        float quad_length = 1./scale;\n        \n        //we get the diagonal the cool way\n        float diagonal = quad_length*sqrt_of_2;\n        \n        //half it\n        float half_diagonal = diagonal/2.;\n        \n        //we want to find if our circle intersects the quad \n        //based on our quad's id (used to get center, blah blah blah)\n        //and that is approximated by this:\n        //if the distance between the quad center and the circle center\n        //is less than the sum of half the quad's diangona and\n        //the circle's radius, then the circle intersects the quad\n        float max_dist = half_diagonal + radius;\n        \n        //distance between circle center and quad center\n        float dist_between = length(circle_coords - global_quad_center);\n       \n       \n       //adding a sort of white vignette from one\n       //of iq's tileing shaders based on xo\n        vec2 u01 = fract(local_uv);\n        float vig = pow((1.-u01.x*u01.y*(1.-u01.x)*(1.-u01.y)\n        *1.*(float(max_layers-i)/float(max_layers))),300.3);\n        \n       \n       //the check, if true, we stop at this layer for this quad\n       //not more subdivisions\n        if(dist_between > max_dist) \n        {\n        \n        O.rgb += vig;\n        break;\n        \n        \n        }\n        //here I create borders for each quad and the math\n        //could be prettier but I transform the coords in every \n        //quad to be from 0 to 1. It's just the quads local coords\n        //minus the id. (or fract could work too)\n        vec2 local_0_to_1 = local_uv - id;\n        //then I translate left 0.5 so it's -0.5 -> 0.5\n        //and then abs so it's 0.5 <- 0 -> 0.5\n        vec2 abs_local = abs(local_0_to_1-0.5);\n        //I get the max like in a square sdf and if \n        //the value for that coord is more than 0.49 I say it's a border\n        //so make it white and break\n        //I try to subtracta small fraction of layer num over max layers\n        //but it doesn't really add anythin\n        if(max(abs_local.x,abs_local.y) > 0.49 \n        - float(i)/(20.*float(max_layers))) {\n            O ++; //stolen from fabrice\n            O.rgb += vig;\n            break;\n        }\n        //at the end of each round increase the color value by some standard\n        //amount\n        O.rbg += vec3(0.05, 0.1,0.08);\n\n    }\n   \n   //I through another circle on top like it fabrice's version to hind \n   //how the borders become a problem later on.\n   float circle_mask = 1.00-smoothstep(radius -eps, radius +eps,  length(uv-circle_coords) - radius*0.01);\n   vec3 circle_color =vec3(0.9);\n   O.rgb += circle_color*circle_mask/1.;\n   \n   \n   }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}