{
    "Shader": {
        "info": {
            "date": "1426837649",
            "description": "My best attempt at making the space station from the movie 2001 a space odyssey.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lBGRh",
            "likes": 76,
            "name": "[NV15] 2001 Space Station",
            "published": 3,
            "tags": [
                "space"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 9745
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nSorry this code is pretty messy. I had to finish in time for the competition. :)\n\n-Otavio Good\n*/\n\nconst int MAX_MARCH_REPS = 100;\nconst float MARCH_DISTANCE_MULTIPLIER = 0.9;\nconst int MAX_SHADOW_MARCHES = 30;\n\nfloat localTime = 0.0;\nconst float earthRad = 6371.0;\nconst vec3 earthPos = normalize(vec3(-6500,-6400,2400)) * (earthRad + 300.0);\n\n// some noise functions\nfloat Hash(float f)\n{\n    return fract(cos(f)*7561.0);\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\n    float rand = fract(cos(f)*104729.0);\n    return rand;\n}\nvec2 Hash2(vec2 v)\n{\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nfloat mixS(float f0, float f1, float a)\n{\n    if (a < 0.5) return f0;\n    return f1;\n}\n\nfloat mixC(float f0, float f1, float a)\n{\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\n}\n\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nvec2 mixP2(vec2 v0, vec2 v1, float a)\n{\n    return mix(v0, v1, a*a*(3.0-2.0*a));\n}\n\nfloat mixSS(float f0, float f1, float a)\n{\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\n}\n\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2dVec(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\n    vec2 xMix = mixP2(h0, h1, fr.x);\n    return mixC(xMix.x, xMix.y, fr.y);\n}\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nvec3 GetStarColor(vec3 rayDir, vec3 sunDir)\n{\n    rayDir.xyz = rayDir.yzx;\n\tfloat dense = 16.0;\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = 0.2 / sunIntensity;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tsunIntensity = max(0.0, sunIntensity - 3.0);\n\n\tlocalRay.x = localRay.x + 1.0 - iTime * 0.1;\n\t//vec3 right = normalize(cross(sunDir, vec3(0.0,1.0,0.0)));\n\t//vec3 up = normalize(cross(sunDir, right));\n\tvec2 wrap = fract((localRay.xy)*dense);\n\tvec4 rand = texture(iChannel2, floor(localRay.xy*dense)/dense).xyzw;\n\tvec3 starColor = rand.xyz;\n\tstarColor = starColor * 0.75 + 0.25;\n\trand.xy = rand.xy * 2.0 - 1.0;\n\tvec2 center = vec2(0.5, 0.5) + rand.xy * 0.9;// floor(fract((localRay.xy)*8.0)) + 0.5;\n\tfloat star = length(wrap - center);\n\tfloat test = star;\n\tstar = saturate((1.0 - star));\n\tfloat blink = texture(iChannel2, localRay.xy + iTime * 0.03).x;\n\tfloat cluster = 0.3;// /*(localRay.x+0.5) */ (localRay.y+0.5) * 2.8 + 0.8;\n\tstar = pow(star, 60.0 + saturate(rand.z - 0.0) * 250.0 * cluster);\n\tstar *= blink;\n\t\n\tfloat milkyMask = saturate(0.25 - abs(localRay.x - 0.65));\n\tvec3 milkyway = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3)).yxz;\n\tvec3 milkyLOD = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3), 3.0).yxz;\n\tvec3 milkyDetail = texture(iChannel3, (-localRay.yx*8.0 )+vec2(0.65, 0.3)).yxz;\n\tmilkyway *= milkyDetail.xxx;\n\tmilkyway *= vec3(1.0, 0.8, 0.91)*1.5;\n\tmilkyway = pow(milkyway, vec3(2.0, 2.0, 2.0)*3.0);\n\tmilkyway += vec3(0.2, 0.0015, 1.001) * milkyLOD * 0.006;\n\t\n\tvec3 finalColor = milkyway /* milkyMask*/ * 10.0;\n\tfinalColor += /*environmentSphereColor + sunCol * sunIntensity +*/ starColor * star * 12.0 * cluster;\n\treturn finalColor;\n\t//return environmentSphereColor + sunCol * sunIntensity + starColor * star * 12000.0 * cluster;\n\t//return vec3(1.0,1.0,1.0)*cluster*1000.0;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 238.0, 210.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.93)*100.0;\n\n    //sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\n\treturn sunCol * sunIntensity*0.00125;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\nfloat cylCone(vec3 p)\n{\n    float d = length(p.xy) - 1.0;\n    d = min(d, length(p.xy - 1.0) - 0.1);\n    d = max(0.0, d + max(0.0, abs(p.z) - 1.9)*1.0);\n    return d;\n}\n\nfloat sbox(vec3 p, vec3 size)\n{\n    vec3 a = abs(p) - size;\n    float c = max(a.x, a.y);\n    c = max(c, a.z);\n    return (c);\n}\n\nfloat diamond(vec3 p, vec3 size)\n{\n    vec3 a = abs(p) - size;\n    float c = (a.x*0.5 + a.y*5.0);\n    c = (c + a.z*2.0);\n    return (c*0.25);\n}\n\nfloat cylinderInner(vec3 p, float len)\n{\n    float d = length(p.xy) - clamp(abs(p.z), 0.5, 0.8);\n    //d = min(d, sbox(abs(p) - vec3(1.0/1.414, 1.0/1.414, 0.0), vec3(0.1, 0.1, len)));\n    d = max(d, abs(p.z) - len);\n    // bars above and below hangar\n    vec3 p2 = vec3(p.x, abs(p.y), abs(p.z));\n    d = min(d, sbox(p2 - vec3(0.0, 0.3, 2.0), vec3(0.6, 0.05, 0.025)));\n    // little rings around hangar area\n    float d3 = length(p.xy) - 0.82;\n    float d2 = max(d3, abs(-p.z + 1.9) - 0.03);\n    d3 = max(d3, abs(p.z + 1.9) - 0.03);\n    return min(d3, min(d, d2));\n}\n\nfloat cylinderV(vec3 p)\n{\n    float rad = 0.15;\n    float len = 4.0;\n    float d = length(p.xz) - rad;\n    float sp = sin(p.y * 10.0);\n    sp = pow(max(0.0, sp - 0.7), 0.4);\n    float ridges = length(p.xz) - rad * abs(sp + 0.5);\n    d = min(d, ridges);\n    //d = min(d, length(p.xy - 1.0) - 0.1);\n    //d = min(d, sbox(abs(p) - vec3(0.25, 0.0, 0.25), vec3(0.03, len, 0.01)));\n    vec2 p2 = vec2(abs(p.x), p.z);\n    d = min(d, length(p2 - vec2(0.25, 0.0)) - 0.02 );\n    d = min(d, length(p2 - vec2(0.35, 0.0)) - 0.02 );\n    float rep = 0.7;\n    vec3 p3 = vec3(abs(p.x), mod(p.y, rep) - rep*0.5, p.z);\n    d = min(d, sbox(p3, vec3(0.35, 0.01, 0.02)));\n    d = max(d, abs(p.y) - len);\n    return d;\n}\n\nfloat outerRadius = 4.0;\nfloat cylinderOuter(vec3 p, float len)\n{\n    float radial = length(p.xy);\n    //float dents = sin(radial * 32.0) * 0.05;\n    //dents = pow(abs(dents), 3.0);\n    float d = -(radial - outerRadius);\n    d = max(d, (radial - (outerRadius + 0.6)));\n    float bevel = abs(radial - (outerRadius + 0.2)) * 0.2;\n    d = max(d, abs(p.z) - len + bevel);\n    return d;\n}\n\nfloat wheel(vec3 p)\n{\n    vec3 p2 = p;\n    if (abs(p2.x) > abs(p2.y)) p2.xy = p2.yx;\n    float d = cylinderV(p2);\n    d = min(d, cylinderOuter(p, 0.25));\n    d = min(d, sbox(vec3(p2.x, abs(p2.y), p2.z) - vec3(0.0, outerRadius, 0.0), vec3(0.4, 0.2, 0.275)));\n    return d;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat shipPosition;\nfloat SpaceShip(vec3 p)\n{\n    float d = length(p) - 1.5 + cos(p.z*1.02) * 1.0;\n    d *= 1.1;\n    d = max(d, -sbox(p + vec3(0.0, -0.6, 0.0), vec3(1.0,0.7,1.5)) );\n    d = smin(d, 0.7*diamond(p + vec3(0.0, 0.2, -0.5), vec3(0.1)),0.1);\n    d = max(d, sbox(p, vec3(0.9,4.2,2.5)) );\n    return d;\n}\n\nfloat ScaleShip(vec3 p, float s)\n{\n    return SpaceShip(p/s)*s;\n}\n\nfloat rotationSpeed = 0.2;\nvec2 DistanceToObject(vec3 p0)\n{\n    float material = 0.0;\n    float h = 0.0;\n    vec3 pr = RotateZ(p0, iTime * rotationSpeed);\n    float d = cylinderInner(pr, 2.0);\n    //p2.x = max(abs(p.x), abs(p.y));\n    //d = sbox(p, vec3(1.0, 1.0, 1.0));\n    vec3 p2 = vec3(pr.x, pr.y, abs(pr.z)) - vec3(0.0, 0.0, 1.5);\n    //p2.z = abs(p2.z);\n    d = min(d, wheel(p2));\n    d = max(d, -sbox(p2, vec3(0.6, 0.2, 0.7)));\t// ship docking bay - mirrored\n    d = min(d, ScaleShip(pr - vec3(0.0, 0.1, shipPosition), 0.4));\n    material = h;\n    float final = d;\n    return vec2(final, material);\n}\n\nfloat distFromSphere;\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvec4 cubicTex(vec2 uv)\n{\n    uv *= iChannelResolution[2].xy;\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel2, (uv + 0.5)/iChannelResolution[2].xy, 0.0);\t// use constant here instead?\n}\n\nvec4 tex3d(vec3 pos, vec3 normal)\n{\n\t// loook up texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel2, pos.yz);\n\tvec4 texY = texture(iChannel2, pos.xz);\n\tvec4 texZ = texture(iChannel2, pos.xy);\n\t//vec4 texX = cubicTex(pos.yz);\n\t//vec4 texY = cubicTex(pos.xz);\n\t//vec4 texZ = cubicTex(pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));//.zxyw;\n\treturn tex;\n}\n\nvec4 tex3d3(vec3 pos, vec3 normal)\n{\n\t// loook up texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel3, pos.yz);\n\tvec4 texY = texture(iChannel3, pos.xz);\n\tvec4 texZ = texture(iChannel3, pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));//.zxyw;\n\treturn tex;\n}\n\nfloat GrayPanel(vec2 uv)\n{\n    float grayPanels = texture(iChannel1, uv.xy * 0.25).z;\n    float grayPanels2 = texture(iChannel1, uv.xy * 0.333 + vec2(0.1, 0.3)).z;\n    grayPanels += grayPanels2;\n    float grayPanels3 = texture(iChannel1, uv.xy * 0.1777*vec2(1.0,5.0) + vec2(0.432, 0.765)).z;\n    grayPanels += grayPanels3;\n    return grayPanels;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.0;\n    uv /= zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625;\n\tfloat my=0.0;//-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2); \t// prp\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// ----------------------------------- Animate ------------------------------------\n    float repTime = 32.0;\t// repeat every x seconds\n    float t1 = mod(localTime-5.0, repTime) / repTime;\n    shipPosition = 9.5 - min(pow(t1, 0.7), 0.5) * 16.0;\n\t// --------------------------------------------------------------------------------\n\t// I put a bounding sphere around the whole object. If the ray is outside\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\n\t//vec3 iA, iB;\n\t//float hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\n\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.05, 0.0);\n\tfloat t = 7.0;\n\t//float inc = 0.02;\n\tfloat maxDepth = 22.0;\n\tvec3 pos = vec3(0,0,0);\n    // start and end the camera ray at the sphere intersections.\n    //camPos = 0.5;//iA;\n    //maxDepth = distance(iA, iB);\n\t// ray marching time\n\t//if (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\n\t{\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\n            pos = camPos + relVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\n        }\n    }\n    /*else\n    {\n\t\tt = maxDepth + 1.0;\n        distAndMat.x = 1.0;\n    }*/\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(0.93, 0.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n    float radial = length(pos.xy);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(distAndMat.x) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        vec3 posRot = RotateZ(pos, iTime * rotationSpeed);\n\n\t\tfloat grayPanels = GrayPanel(posRot.xy);\n\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n        \n        // bump map inner stuff\n        if (radial < outerRadius - 0.01)\n        {\n            normal += (texture(iChannel1, posRot.xy * 0.27).x - 0.4) * 0.0625;\n            normal.y += (grayPanels - 1.5) * 0.1;\n            normal = normalize(normal);\n        }\n        else\n        {\n            float ridge = sin(radial*16.0+0.3);\n            ridge = pow(abs(ridge), 16.0);\n            normal += ridge*normal.z;\n            normal = normalize(normal);\n        }\n\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.1;\n\t\tfor (int i = 0; i < MAX_SHADOW_MARCHES; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 8.0) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(0.35);// * grayPanels;\n\n        // texture outer ring\n        if (radial >= outerRadius - 0.01)\n        {\n            vec2 uvr = vec2(atan(posRot.x, posRot.y) * 8.0, length(posRot.xy) * 2.0);\n\t        if ((radial >= outerRadius  + 0.3) && (radial < outerRadius + 0.5))\n            {\n                float checker = texture(iChannel1, uvr).x;\n                float checkerL = texture(iChannel0, uvr*0.0625).x;\n                checker = pow(checker, 19.0);\n                checker *= saturate((checkerL - 0.7) * 94.0);\n                //texColor += vec3(15.0, 4.0, 2.0) * 5.0 * saturate(checker);\n                //texColor *= vec3(1.0) * saturate(checker);\n            }\n            float stripes = texture(iChannel1, uvr * vec2(0.0625, 1.0)).x;\n            texColor -= stripes * 0.03;\n        }\n        else\n        {\n            texColor = vec3(0.3) + grayPanels * 0.03;\n        }\n        if (length(normal.xy) > 0.95)\n        {\n            vec2 uvr = vec2(atan(posRot.x, posRot.y) * 1.0, posRot.z * 0.25);\n            //float checker = texture(iChannel1, uvr).x;\n            float checker = GrayPanel(uvr * vec2(1.0, 4.0));\n            texColor += vec3(0.05) * checker - vec3(0.025);\n        }\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*24.0;\n        // sky color, hemisphere light equation approximation, anbient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (dot(normal, normalize(earthPos)) * 0.5 + 0.5) * ambient * 0.4;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.01;\n        // Apply red glow to hangar\n        vec3 lightPos = vec3(0.0, 0.0, 1.75);\n        vec3 redGlow = vec3(1.0, 0.1, 0.2) * saturate(0.8 - length(pos - lightPos));\n        redGlow *= max(0.0, dot(normalize(-lightPos-pos), normal));\n        lightColor += redGlow * 43.0;\n        // Apply red glow to hangar (again. too tired to do mirror math.)\n        lightPos = vec3(0.0, 0.0, -1.75);\n        redGlow = vec3(1.0, 0.1, 0.2) * saturate(0.8 - length(pos - lightPos));\n        redGlow *= max(0.0, dot(normalize(-lightPos-pos), normal));\n        lightColor += redGlow * 43.0;\n\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // glowing windows\n        if (radial >= outerRadius - 0.01)\n        {\n            vec2 uvr = vec2(atan(posRot.x, posRot.y) * 8.0, length(posRot.xy) * 2.0);\n\t        if ((radial >= outerRadius  + 0.3) && (radial < outerRadius + 0.5))\n            {\n                float checker = texture(iChannel1, uvr).x;\n                float checkerL = texture(iChannel0, uvr*0.0625).x;\n                checker = pow(checker, 19.0);\n                checker *= saturate((checkerL - 0.7) * 94.0);\n                finalColor += vec3(10.0, 6.0, 2.0) * 1.0 * saturate(checker);\n                //texColor *= vec3(1.0) * saturate(checker);\n            }\n        }\n\n        // specular highlights - just a little\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog that fades to sun color so that fog is brightest towards sun\n    //    finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\n        //finalColor = vec3(40.0) * length(normalU);\n           // finalColor = normal * 0.5 + 0.5;\n\t}\n    else\n    {\n        //vec3 iA, iB;\n        //float hit = IntersectSphereAndRay(earthPos, earthRad, camPos, camPos+relVec, iA, iB);\n        float hit = SphereIntersect(camPos, normalize(relVec), earthPos, earthRad);\n        if (hit >= 0.0)\n        {\n\t\t\tvec3 intersection = camPos + relVec * hit;\n            vec3 normal = normalize(intersection - earthPos);\n            finalColor = texture(iChannel2, vec2(normal.z, normal.y)).xyz;\n            vec3 surface = vec3(0.01, 0.01, 0.1);\n            surface += tex3d(normal * 0.75, normal).yyy;\n            float d = dot(normal, normalize(camPos - intersection));\n\n            float atmosphere = 1.0 - d;\n            atmosphere = pow(atmosphere, 3.5);\n            atmosphere = atmosphere * 0.9 + 0.1;\n            surface = mix(surface, vec3(70.0, 130.0, 240.0)/355.0, atmosphere);\n\t\t\tfinalColor = surface;\n            //finalColor = vec3(1.0) * d;\n            //finalColor = normal * 0.5 + 0.5;\n        }\n        else\n        {\n\t\t\t//finalColor += GetStarColor(relVec, sunDir);\n            float stars = tex3d3(relVec*1.0, relVec).z;\n            stars = pow(stars,63.0);//63\n            finalColor += vec3(2.0) * stars;\n        }\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        //finalColor *=0.0;// mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\n        // add the sun\n    }\n    finalColor += GetSunColorReflection(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.95;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}