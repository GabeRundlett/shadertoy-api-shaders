{
    "Shader": {
        "info": {
            "date": "1580843755",
            "description": "Back to shaders.\nCritique & Comments are welcome.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlcXD8",
            "likes": 12,
            "name": "Motion Loop #001",
            "published": 3,
            "tags": [
                "2d",
                "loop",
                "motion",
                "ease"
            ],
            "usePreview": 0,
            "username": "lsdlive",
            "viewed": 628
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nMotion Loop #001\n\nCheckout the ISF port: https://github.com/theotime/isf_shaders/blob/master/shaders/motiongraphics_001.fs\n\nWith the help of https://thebookofshaders.com/examples/?chapter=motionToolKit\nWith the help of Flopine, FabriceNeyret2, Pixel Spirit Deck.\n\n*/\n\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\n#define bpm 120.\n#define speed .5\n#define ring_base_sz .0125\n#define ring_base_width .1\n\n#define AA 3.\n\n#define pi 3.141592\n#define time (speed*(bpm/60.)*iTime)\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d) {\n    return 1. - smoothstep(0., AA / iResolution.x, d);\n}\n\n// inspired by Pixel Spirit Deck: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n// + https://www.shadertoy.com/view/tsSXRz\nfloat stroke(float d, float width) {\n\treturn 1. - smoothstep(0., AA / iResolution.x, abs(d) - width * .5);\n}\n\nfloat flip(float value, float percent) {\n\treturn mix(value, 1. - value, percent);\n}\n\nfloat circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\n// https://thebookofshaders.com/edit.php?log=160909064320\nfloat easeInOutExpo(float t) {\n    if (t == 0. || t == 1.) {\n        return t;\n    }\n    if ((t *= 2.) < 1.) {\n        return .5 * exp2(10. * (t - 1.));\n    } else {\n        return .5 * (-exp2(-10. * (t - 1.)) + 2.);\n    }\n}\n\n// not used, but can be\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t;\n    } else {\n        return -.5 * ((t - 1.) * (t - 3.) - 1.);\n    }\n}\n\n// not used, but can be\nfloat easeInOutCubic(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t * t;\n    } else {\n        return .5 * ((t -= 2.) * t * t + 2.);\n    }\n}\n\n// https://thebookofshaders.com/edit.php?log=160909064528\n/*float ring(vec2 p, float radius, float width) {\n  \treturn abs(length(p) - radius * 0.5) - width;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    // rotation animation\n    float t = easeInOutExpo(fract(time));\n    uv *= r2d((pi / 2.) * (floor(time) + t));\n    \n    // ring size animation\n    float offs = .5;\n\tt = easeInOutExpo(fract(time + offs));\n    float anim_sz = .125 + .125 * sin(pi * .75 + pi * (floor(time + offs) + t));\n    \n    // old solution for anti-aliasing\n    /*\n\tfloat ring = ring(uv, ring_base_sz + anim_sz, ring_base_width);\n    float eps = abs(ring); // sharpen around the ring\n    float sdf = (2. * smoothstep(-eps, eps, uv.x) - 1.) * ring;\n    float mask = smoothedge(sdf, 3.); // cut sdf + AA\n\t*/\n    \n    // Better solution from pixel spirit deck\n    // pixelspiritdeck.com\n    float mask = flip(stroke(circle(uv, ring_base_sz + anim_sz), ring_base_width), fill(uv.x));\n    \n    vec3 col = mix(col1, col2, mask);\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}