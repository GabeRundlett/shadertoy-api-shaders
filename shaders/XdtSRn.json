{
    "Shader": {
        "info": {
            "date": "1457401059",
            "description": "diffuse illumination with occlusion and infinite bounces using a single 32^3 light propagation volume. Implemented after \"Light Propagation Volumes in CryEngine 3\", Kaplanyan",
            "flags": 32,
            "hasliked": 0,
            "id": "XdtSRn",
            "likes": 193,
            "name": "Light Propagation Volume",
            "published": 3,
            "tags": [
                "illumination",
                "bounce",
                "occlusion",
                "spherical",
                "harmonics",
                "radiosity",
                "lpv"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 13124
        },
        "renderpass": [
            {
                "code": "/*\n\nafter\nLight Propagation Volumes in CryEngine 3, Anton Kaplanyan\nhttp://advances.realtimerendering.com/s2009/Light_Propagation_Volumes.pdf\n\nalso helpful for reference:\nLight Propagation Volumes - Annotations, Andreas Kirsch (2010)\nhttp://blog.blackhc.net/wp-content/uploads/2010/07/lpv-annotations.pdf\n\n*/\n\nvec4 sample_lpv(vec3 p, float channel) {\n    p = clamp(p * lpvsize, vec3(0.5), lpvsize - 0.5);\n    float posidx = packfragcoord3(p, lpvsize) + channel * (lpvsize.x * lpvsize.y * lpvsize.z);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);    \n}\n\nvec4 fetch_lpv(ivec3 p, int channel) {\n    p = clamp(p, ivec3(0), lpvsizei - 1);\n    int posidx = packfragcoord3(p, lpvsizei) + channel * (lpvsizei.x * lpvsizei.y * lpvsizei.z);\n    ivec2 uv = unpackfragcoord2(posidx, ivec2(iChannelResolution[0].xy));\n    return texelFetch(iChannel0, uv, 0);    \n}\n\nvec3 fetch_lpv(ivec3 p, vec4 shn) {\n    vec4 shr = fetch_lpv(p, 0);\n    vec4 shg = fetch_lpv(p, 1);\n    vec4 shb = fetch_lpv(p, 2);\n    return vec3(\n        shade_probe(shr, shn),\n        shade_probe(shg, shn),\n        shade_probe(shb, shn));\n}\n\nfloat dot_weight(vec3 a, vec3 b) {\n\ta = vec3(\n        (a.x + a.y)*0.5,\n        a.y,\n        (a.y + a.z)*0.5);\n    return dot(a, b);\n}\n\nvec3 interpolate(vec3 a, vec3 b, vec3 c, float x) {\n\tfloat rx = 1.0 - x;\n    vec3 q = vec3(\n        rx*rx, \n        2.0*rx*x,\n    \tx*x);\n    return\n        vec3(\n            dot_weight(vec3(a.x,b.x,c.x), q),\n            dot_weight(vec3(a.y,b.y,c.y), q),\n            dot_weight(vec3(a.z,b.z,c.z), q));\n}\n\nvoid sample_lpv_nn(vec3 pf, out vec4 r, out vec4 g, out vec4 b) {\n    // use triquadratic interpolation\n    pf = pf * lpvsize;\n    ivec3 p = ivec3(pf + 0.5);\n    r = fetch_lpv(p, 0);\n    g = fetch_lpv(p, 1);\n    b = fetch_lpv(p, 2);    \n}\n\nvec3 sample_lpv_trilin(vec3 pf, vec4 shn) {\n#if USE_TRIQUADRATIC_INTERPOLATION\n    // use triquadratic interpolation\n    pf = pf * lpvsize;\n    ivec3 p = ivec3(pf);\n    ivec3 e = ivec3(-1, 0, 1);\n    vec3 p000 = fetch_lpv(p + e.xxx, shn);\n    vec3 p001 = fetch_lpv(p + e.xxy, shn);\n    vec3 p002 = fetch_lpv(p + e.xxz, shn);\n    vec3 p010 = fetch_lpv(p + e.xyx, shn);\n    vec3 p011 = fetch_lpv(p + e.xyy, shn);\n    vec3 p012 = fetch_lpv(p + e.xyz, shn);\n    vec3 p020 = fetch_lpv(p + e.xzx, shn);\n    vec3 p021 = fetch_lpv(p + e.xzy, shn);\n    vec3 p022 = fetch_lpv(p + e.xzz, shn);\n\n    vec3 p100 = fetch_lpv(p + e.yxx, shn);\n    vec3 p101 = fetch_lpv(p + e.yxy, shn);\n    vec3 p102 = fetch_lpv(p + e.yxz, shn);\n    vec3 p110 = fetch_lpv(p + e.yyx, shn);\n    vec3 p111 = fetch_lpv(p + e.yyy, shn);\n    vec3 p112 = fetch_lpv(p + e.yyz, shn);\n    vec3 p120 = fetch_lpv(p + e.yzx, shn);\n    vec3 p121 = fetch_lpv(p + e.yzy, shn);\n    vec3 p122 = fetch_lpv(p + e.yzz, shn);\n    \n    vec3 p200 = fetch_lpv(p + e.zxx, shn);\n    vec3 p201 = fetch_lpv(p + e.zxy, shn);\n    vec3 p202 = fetch_lpv(p + e.zxz, shn);\n    vec3 p210 = fetch_lpv(p + e.zyx, shn);\n    vec3 p211 = fetch_lpv(p + e.zyy, shn);\n    vec3 p212 = fetch_lpv(p + e.zyz, shn);\n    vec3 p220 = fetch_lpv(p + e.zzx, shn);\n    vec3 p221 = fetch_lpv(p + e.zzy, shn);\n    vec3 p222 = fetch_lpv(p + e.zzz, shn);\n\n    vec3 w = fract(pf);\n    \n    vec3 y00 = interpolate(p000, p001, p002, w.z);\n    vec3 y01 = interpolate(p010, p011, p012, w.z);\n    vec3 y02 = interpolate(p020, p021, p022, w.z);\n\n    vec3 y10 = interpolate(p100, p101, p102, w.z);\n    vec3 y11 = interpolate(p110, p111, p112, w.z);\n    vec3 y12 = interpolate(p120, p121, p122, w.z);\n\n    vec3 y20 = interpolate(p200, p201, p202, w.z);\n    vec3 y21 = interpolate(p210, p211, p212, w.z);\n    vec3 y22 = interpolate(p220, p221, p222, w.z);\n\n    vec3 x0 = interpolate(y00, y01, y02, w.y);\n    vec3 x1 = interpolate(y10, y11, y12, w.y);\n    vec3 x2 = interpolate(y20, y21, y22, w.y);\n\n    return interpolate(x0, x1, x2, w.x);\n\n#else\n    pf = pf * lpvsize - 0.5;\n    ivec3 p = ivec3(pf);\n    ivec2 e = ivec2(0,1);\n    vec3 p000 = fetch_lpv(p + e.xxx, shn);\n    vec3 p001 = fetch_lpv(p + e.xxy, shn);\n    vec3 p010 = fetch_lpv(p + e.xyx, shn);\n    vec3 p011 = fetch_lpv(p + e.xyy, shn);\n    vec3 p100 = fetch_lpv(p + e.yxx, shn);\n    vec3 p101 = fetch_lpv(p + e.yxy, shn);\n    vec3 p110 = fetch_lpv(p + e.yyx, shn);\n    vec3 p111 = fetch_lpv(p + e.yyy, shn);\n\n    vec3 w = fract(pf);\n    \n\n    vec3 q = 1.0 - w;\n\n    vec2 h = vec2(q.x,w.x);\n    vec4 k = vec4(h*q.y, h*w.y);\n    vec4 s = k * q.z;\n    vec4 t = k * w.z;\n        \n    return\n          p000*s.x + p100*s.y + p010*s.z + p110*s.w\n        + p001*t.x + p101*t.y + p011*t.z + p111*t.w;\n#endif\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.37) * 0.4;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )\n{\n    vec3 col = mal.rgb;\n    \n    vec3 tpos = ((pos - vec3(0.0,1.0,0.0)) / 2.5) * 0.5 + 0.5;\n#if 0\n    // lambert normal\n    vec4 shn = sh_project(-nor);\n#else\n    // specular normal\n    vec4 shn = sh_project(-reflect(rd, nor));\n#endif\n    \n    col *= sample_lpv_trilin(tpos, shn);\n\n    return col;\n}\n\nvec4 calcFog( in vec3 ro, in vec3 rd, float t1, float K)\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n\tfloat res = -1.0;\n    vec3 ft = vec3(0.0);\n    const int N = 10;\n    for( int i=0; i<=N; i++ )          // max number of raymarching iterations is 90\n    {\n        float x = float(i)/float(N);\n        float t = x*t1;\n        vec3 tpos = ((ro+rd*t - vec3(0.0,1.0,0.0)) / 2.5) * 0.5 + 0.5;\n        float w = 1.0 - exp(-t*K);\n        vec4 shn = sh_project(-rd)*2.0*vec4(vec3(4.0/3.0),0.2);\n        ft += sample_lpv_trilin(tpos, shn)*w;\n    }\n    return vec4(ft.rgb / float(N) * t1, exp(-t1*0.1*K));\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t, iTime ).x;\n\n            \n        t += h;\n    }\n    if( t<maxd ) res = t;\n    return res;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 spherical_map (vec2 uv) {\n    // pixels are uniformly distributed\n    float phi = 6.28318530718*uv.x;\n    float rho_c = 2.0 * uv.y - 1.0;\n    float rho_s = sqrt(1.0 - rho_c*rho_c);\n    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n    //doCamera( ro, ta, 3.0, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n#if 0\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        uv = uv*2.0 - 1.0;\n        uv.x *= iResolution.x/iResolution.y;\n        if (abs(uv.x) > 1.0)\n            return;\n        uv = uv*0.5 + 0.5;\n\n        //ro = vec3(-4.0, -1.1, 1.0);\n        ro = vec3(-0.95, 1.0, 0.95);\n        rd = spherical_map(uv).xzy * vec3(-1,1,1);\n        #if 1\n        vec3 tpos = ((ro - vec3(0.0,1.0,0.0)) / 2.5) * 0.5 + 0.5;\n        vec4 sh = sh_project(-rd);\n        //sh.xyz = vec3(0.0);\n        //sh.w = 0.0;\n        vec4 shr, shg, shb;\n        sample_lpv_nn(tpos, shr, shg, shb);\n        vec3 col;\n        col.r = max(0.0,dot(sh, shr));\n        col.g = max(0.0,dot(sh, shg));\n        col.b = max(0.0,dot(sh, shb));\n        col *= m3div4pi;      \n        col = linear_srgb(ACESFitted(col));\n        fragColor = vec4( col, 1.0 );\n        return;\n        #endif\n    }\n#endif\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n    //ro + rd*t = -w / n - ro\n    \n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, iTime);\n\n        // materials\n        vec4 mal = doMaterial( pos, iTime );\n\n        col = doLighting( pos, nor, rd, t, mal );\n        \n        #if 0\n        // doesn't look great with the default lighting\n        vec4 fog = calcFog(ro, rd, t, 1.0);\n        col = col*fog.w + fog.rgb;\n        #endif\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = linear_srgb(ACESFitted(col));\n\t   \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// geometry volume (stores occlusion coefficients)\n\n///////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float posidx = packfragcoord2(fragCoord.xy, iResolution.xy);\n    if (posidx < (lpvsize.x * lpvsize.y * lpvsize.z)) {\n\t    vec3 pos = unpackfragcoord3(posidx,lpvsize);\n        float offset = -0.5;\n        vec3 tpos = (pos + offset) / lpvsize;\n        vec3 wpos = (tpos * 2.0 - 1.0) * 2.5 + vec3(0.0,1.0,0.0);\n        float r = 1.0 * 1.7320508075689 / lpvsize.x;\n\t\tfloat d = doModel(wpos, iTime).x;\n        \n        if (d > r) {\n\t        fragColor = vec4(0.0);\n        } else {\n            float opacity = 1.0 - max(d, 0.0) / r;\n            fragColor = sh_project(calcNormal(wpos, iTime)) * opacity;\n        }\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// albedo volume for bounces\n\n///////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float posidx = packfragcoord2(fragCoord.xy, iResolution.xy);\n    if (posidx < (lpvsize.x * lpvsize.y * lpvsize.z)) {\n\t    vec3 pos = unpackfragcoord3(posidx,lpvsize);\n        float offset = -0.5;\n        vec3 tpos = (pos + offset) / lpvsize;\n        vec3 wpos = (tpos * 2.0 - 1.0) * 2.5 + vec3(0.0,1.0,0.0);\n        fragColor = doMaterial(wpos, iTime);\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// iterative light propagation, one step per frame\n\n///////////////////\n\nvec4 fetch_gv(vec3 p) {\n    if ((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (lpvsize.x - 0.5)))\n        return vec4(0.0);\n    float posidx = packfragcoord3(p, lpvsize);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);\n}\n\nfloat numvoxels;\nfloat channel;\nvec3 cmix;\n\nfloat fetch_av(vec3 p) {\n    if ((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (lpvsize.x - 0.5)))\n        return 0.0;\n    float posidx = packfragcoord3(p, lpvsize);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[1].xy) / iChannelResolution[1].xy;\n    return dot(texture(iChannel1, uv).rgb, cmix);\n}\n\nvec4 fetch_lpv(vec3 p) {\n    if ((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (lpvsize.x - 0.5)))\n        return vec4(0.0);\n    float posidx = packfragcoord3(p, lpvsize) + channel * numvoxels;\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[2].xy) / iChannelResolution[2].xy;\n    return texture(iChannel2, uv);\n}\n\n//#if USE_LPV_OCCLUSION || USE_LPV_BOUNCE\nvec4 gv4[6];\nvec4 gv[8];\n//#if USE_LPV_BOUNCE\nfloat bc4[6];\nfloat bc[8];\n//#endif // USE_LPV_BOUNCE\n//#endif // USE_LPV_OCCLUSION || USE_LPV_BOUNCE\n\n//angle = (4.0*atan(sqrt(11.0)/33.0));\nconst float solid_angle_front = 0.4006696846462392 * m3div4pi;\n//angle = (-M_PI/3.0+2.0*atan(sqrt(11.0)*3.0/11.0));\nconst float solid_angle_side = 0.4234313544367392 * m3div4pi;\n\n// 6 * (solid_angle_side * 4 + solid_angle_front) = 4 * PI\n\nvec4 accum_face(vec4 shcoeffs, int i, int j, int dim, int face_dim, \n                vec3 p, vec3 offset, vec3 face_offset,\n                vec4 gvcoeffs, vec4 gvrefcoeffs, float gvrefcolor) {\n    if (i == j) return vec4(0.0);\n\n    vec3 dirw = normalize(face_offset - offset);\n    \n    float solid_angle = (dim == face_dim)?solid_angle_front:solid_angle_side;\n    \n    vec4 outdirsh = sh_project(dirw);\n    vec4 indirsh = outdirsh;\n    vec4 invindirsh = sh_project(-dirw);\n    \n\t// how much flux has been received\n    float influx = sh_dot(shcoeffs, indirsh) * solid_angle;\n   \n    // how much flux will be occluded\n    #if USE_LPV_OCCLUSION\n    float occluded = sh_dot(gvcoeffs, indirsh);\n    #else\n    float occluded = 0.0;\n    #endif\n    \n    // how much flux will be passed on\n    float outflux = influx * (1.0 - occluded);\n    \n    vec4 result = outdirsh * outflux; \n    \n    // how much flux will be reflected\n    #if USE_LPV_BOUNCE\n    vec4 rvec = gvrefcoeffs;\n    float reflected = outflux * sh_dot(rvec, invindirsh);\n    if (reflected > 0.0) {\n        result += rvec * (reflected * gvrefcolor);\n    }\n    #endif    \n    \n    return result;\n}\n    \nvec4 sample_neighbors( int i, int dim, vec3 p, vec3 offset, vec4 gvcoeffs) {\n    vec4 shcoeffs = fetch_lpv(p + offset);\n\tvec4 shsumcoeffs = vec4(0.0);\n    \n    vec3 e = vec3(-0.5,0.5,0.0);\n    shsumcoeffs += accum_face(shcoeffs, i, 0, dim, 2, p, offset, e.zzx, gvcoeffs, gv4[0], bc4[0]);\n    shsumcoeffs += accum_face(shcoeffs, i, 1, dim, 2, p, offset, e.zzy, gvcoeffs, gv4[1], bc4[1]);\n    shsumcoeffs += accum_face(shcoeffs, i, 2, dim, 1, p, offset, e.zxz, gvcoeffs, gv4[2], bc4[2]);\n    shsumcoeffs += accum_face(shcoeffs, i, 3, dim, 1, p, offset, e.zyz, gvcoeffs, gv4[3], bc4[3]);\n    shsumcoeffs += accum_face(shcoeffs, i, 4, dim, 0, p, offset, e.xzz, gvcoeffs, gv4[4], bc4[4]);\n    shsumcoeffs += accum_face(shcoeffs, i, 5, dim, 0, p, offset, e.yzz, gvcoeffs, gv4[5], bc4[5]);\n    return shsumcoeffs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float posidx = packfragcoord2(fragCoord.xy, iResolution.xy);\n    numvoxels = lpvsize.x * lpvsize.y * lpvsize.z;\n    channel = floor(posidx / numvoxels);\n    posidx -= channel * numvoxels;\n    cmix = vec3(\n        float(channel == 0.0),\n        float(channel == 1.0),\n        float(channel == 2.0));\n    if ((iFrame != 0) && (posidx < numvoxels)) {\n\t    vec3 pos = unpackfragcoord3(posidx,lpvsize);\n        vec3 tpos = (pos + 0.5) / lpvsize;\n        vec3 wpos = (tpos * 2.0 - 1.0) * 2.5 + vec3(0.0,1.0,0.0);\n        float r = 1.0 * 1.7320508075689 / lpvsize.x;\n\t\tfloat d = doModel(wpos, iTime).x;        \n        const float L = 1.0;\n        if (d >= L) {\n            vec3 n = calcNormal(wpos, iTime);\n\t\t   \tfloat lightcolor = dot(cmix,vec3(1.0,0.9,0.85));\n        \tfragColor = sh_project(-n) * 20.0 * lightcolor;\n        } else {\n            vec4 shsumcoeffs = vec4(0.0);\n            vec3 e = vec3(-1.0,1.0,0.0);\n            \n            #if USE_LPV_OCCLUSION || USE_LPV_BOUNCE\n            vec2 w = vec2(0.0,1.0);\n            gv[0] = fetch_gv(pos + w.xxx);\n            gv[1] = fetch_gv(pos + w.xxy);\n            gv[2] = fetch_gv(pos + w.xyx);\n            gv[3] = fetch_gv(pos + w.xyy);\n            gv[4] = fetch_gv(pos + w.yxx);\n            gv[5] = fetch_gv(pos + w.yxy);\n            gv[6] = fetch_gv(pos + w.yyx);\n            gv[7] = fetch_gv(pos + w.yyy);\n\n            #if USE_LPV_BOUNCE\n            bc[0] = fetch_av(pos + w.xxx);\n            bc[1] = fetch_av(pos + w.xxy);\n            bc[2] = fetch_av(pos + w.xyx);\n            bc[3] = fetch_av(pos + w.xyy);\n            bc[4] = fetch_av(pos + w.yxx);\n            bc[5] = fetch_av(pos + w.yxy);\n            bc[6] = fetch_av(pos + w.yyx);\n            bc[7] = fetch_av(pos + w.yyy);\n            #endif    \n\n            gv4[0] = (gv[0]+gv[1]+gv[2]+gv[3])*0.25;\n            gv4[1] = (gv[4]+gv[5]+gv[6]+gv[7])*0.25;\n            gv4[2] = (gv[0]+gv[4]+gv[1]+gv[5])*0.25;\n            gv4[3] = (gv[2]+gv[6]+gv[3]+gv[7])*0.25;\n            gv4[4] = (gv[0]+gv[2]+gv[4]+gv[6])*0.25;\n            gv4[5] = (gv[1]+gv[3]+gv[5]+gv[7])*0.25;\n\n            #if USE_LPV_BOUNCE\n            bc4[0] = (bc[0]+bc[1]+bc[2]+bc[3])*0.25;\n            bc4[1] = (bc[4]+bc[5]+bc[6]+bc[7])*0.25;\n            bc4[2] = (bc[0]+bc[4]+bc[1]+bc[5])*0.25;\n            bc4[3] = (bc[2]+bc[6]+bc[3]+bc[7])*0.25;\n            bc4[4] = (bc[0]+bc[2]+bc[4]+bc[6])*0.25;\n            bc4[5] = (bc[1]+bc[3]+bc[5]+bc[7])*0.25;\n            #endif\n\n            #endif // USE_LPV_OCCLUSION || USE_LPV_BOUNCE \n            \n            \n            shsumcoeffs += sample_neighbors(0, 2, pos, e.zzx, gv4[0]);\n            shsumcoeffs += sample_neighbors(1, 2, pos, e.zzy, gv4[1]);\n            shsumcoeffs += sample_neighbors(2, 1, pos, e.zxz, gv4[2]);\n            shsumcoeffs += sample_neighbors(3, 1, pos, e.zyz, gv4[3]);\n            shsumcoeffs += sample_neighbors(4, 0, pos, e.xzz, gv4[4]);\n            shsumcoeffs += sample_neighbors(5, 0, pos, e.yzz, gv4[5]);\n        \n            fragColor = shsumcoeffs;\n        }\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define USE_LPV_OCCLUSION 1\n#define USE_LPV_BOUNCE 1\n#define USE_TRIQUADRATIC_INTERPOLATION 1\n\n#define LIGHT_Z 9.0\nconst ivec3 lpvsizei = ivec3(32);\nconst vec3 lpvsize = vec3(lpvsizei);\n\nfloat packfragcoord2 (vec2 p, vec2 s) {\n    return floor(p.y) * s.x + p.x;\n}\nvec2 unpackfragcoord2 (float p, vec2 s) {\n    float x = mod(p, s.x);\n    float y = (p - x) / s.x + 0.5;\n    return vec2(x,y);\n}\nivec2 unpackfragcoord2 (int p, ivec2 s) {\n    int x = p % s.x;\n    int y = (p - x) / s.x;\n    return ivec2(x,y);\n}\nfloat packfragcoord3 (vec3 p, vec3 s) {\n    return floor(p.z) * s.x * s.y + floor(p.y) * s.x + p.x;\n}\nint packfragcoord3 (ivec3 p, ivec3 s) {\n    return p.z * s.x * s.y + p.y * s.x + p.x;\n}\nvec3 unpackfragcoord3 (float p, vec3 s) {\n    float x = mod(p, s.x);\n    float y = mod((p - x) / s.x, s.y);\n    float z = (p - x - floor(y) * s.x) / (s.x * s.y);\n    return vec3(x,y+0.5,z+0.5);\n}\n\n\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, float s )\n{\n  return length(p.xz)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+1.0,4.0);\n}\n\nvec2 doModel( vec3 p, float iTime ) {\n\t\n    vec2 d = plane(p);\n    \n    vec2 q = vec2(sdSphere(p - vec3(0.0,0.0,-0.8), 1.0),1.0);\n    q = max2(q, vec2(-sdCylinder(p - vec3(0.0,0.0,-0.8), 0.5),2.0));\n    d = min2(d, q);\n    \n    d = min2(d, vec2(sdBox(p - vec3(0.0,0.0,2.2), vec3(2.0,4.0,0.3)),2.0));\n    d = min2(d, vec2(sdBox(p - vec3(0.0,0.0,-2.2), vec3(2.0,4.0,0.3)),3.0));\n    d = min2(d, vec2(sdBox(p - vec3(-2.2,0.0,0.0), vec3(0.3,4.0,2.0)),1.0));\n    \n    q = vec2(sdBox(p - vec3(-1.0,0.0,1.0), vec3(0.5,1.0,0.5)),1.0);\n    q = max2(q, vec2(-sdBox(p - vec3(-0.5,0.5,0.5), vec3(0.5,0.7,0.5)),3.0));\n    \n    d = min2(d, q);\n    \n    d = min2(d, vec2(sdTorus(p.yxz - vec3(-0.5 + sin(iTime*0.25),1.4,0.5), vec2(1.0, 0.3)),1.0));\n    \n    return d;\n}\nvec3 calcNormal( in vec3 pos, float iTime )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps, iTime ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps, iTime ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps, iTime ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps, iTime ).x );\n}\nvec4 doMaterial( in vec3 pos, float iTime )\n{\n    float k = doModel(pos, iTime).y;\n    \n    vec3 c = vec3(0.0);\n    \n    c = mix(c, vec3(1.0,1.0,1.0), float(k == 1.0));\n    c = mix(c, vec3(1.0,0.2,0.1), float(k == 2.0));\n    c = mix(c, vec3(0.1,0.3,1.0), float(k == 3.0));\n    c = mix(c, vec3(0.3,0.15,0.1), float(k == 4.0));\n    c = mix(c, vec3(0.4,1.0,0.1), float(k == 5.0));\n    \n    return vec4(c,0.0);\n}\n\n\nvec4 sh_project(vec3 n) {\n    return vec4(\n        n,\n        sqrt(1.0/3.0));\n}\n\nfloat sh_dot(vec4 a, vec4 b) {\n    return max(dot(a,b),0.0);\n}\n\n#define PI 3.14159265359\n\n// 3 / (4 * pi)\nconst float m3div4pi = 3.0 / (4.0 * PI);\nfloat sh_flux(float d) {\n\treturn d * m3div4pi;\n}\n\nfloat sh_shade(vec4 vL, vec4 vN) {\n    return sh_flux(sh_dot(vL, vN));\n}\n\n#define SHSharpness 0.7 // 2.0\nvec4 sh_irradiance_probe(vec4 v) {\n    const float sh_c0 = (2.0 - SHSharpness) * 1.0;\n    const float sh_c1 = SHSharpness * 2.0 / 3.0;\n    return vec4(v.xyz * sh_c1, v.w * sh_c0);\n}\n\nfloat shade_probe(vec4 sh, vec4 shn) {\n    return sh_shade(sh_irradiance_probe(sh), shn);\n}\n\n///////////////////////////////////////////////\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,2.4), x / 12.92, step(x,0.04045));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}