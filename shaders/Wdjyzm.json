{
    "Shader": {
        "info": {
            "date": "1586349483",
            "description": "The Poincaré disc model of 2d hyperbolic space. Lots of controls, see code header.\n\nInspired by discussion here: [url]https://www.shadertoy.com/view/3d2cz1[/url]",
            "flags": 16,
            "hasliked": 0,
            "id": "Wdjyzm",
            "likes": 12,
            "name": "Poincaré Disc Tilings",
            "published": 3,
            "tags": [
                "disc",
                "hyperbolic",
                "poincare"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 680
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Tiling the Poincare Disc\n//\n// Construct 2,P,Q hyperbolic triangle, centred at the origin, with\n// sides on the x and y axes, and a circular side making angles PI/P\n// and PI/Q with the first two sides. Fold into triangle by iterated\n// reflection in its sides (so the triangle is a fundamental region\n// for the group of reflections). Show resulting tiling.\n//\n// Lots of options:\n// 1,2,3: show different edge types\n// c: clip to unit disc\n// h: halfplane\n// i: use ideal triangle (2,inf,inf)\n// m: mouse isometry\n// n: null rotation\n// p: progressive folding\n// t: show parity\n// z: exponential zoom out (halfplane only)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint P = 7, Q = 4; // Triangle is (2,P,Q) with 1/P + 1/Q < 1/2\n\nbool dotwotone = true;      // Show parity of fundamental regions\nbool doedge1 = true;        // Show x-axis edge\nbool doedge2 = true;        // Show y-axis edge\nbool doedge3 = true;        // Show circular edge\nbool donullrotation = true; // Do a \"null rotation\"\nbool domouse = true;        // Invert origin to mouse position\nbool dozoom = false;        // Zoom out, in halfplane mode only\nbool dohalfplane = false;   // Show the halfplane model, instead of the disc\nbool doideal = false;       // Use ideal (2,inf,inf) triangle instead of (2,P,Q)\nbool doprogressive = false; // Progressively increase max number of folds\nbool doclip = true;        // Clip to unit disc\n\nfloat PI = 3.141592654;\n\n// Compute parameters for hyperbolic triangle, with angles 2,a,b. You\n// might want to draw a picture for this. Triangle sides are x=0,y=0\n// and a circular arc, centre (x,y) and radius r (with r2 = r*r). The\n// arc needs to be a \"straight line\" in the disc model, which means it\n// must intersect the unit disc at right angles. This results in\n// condition (i) by Pythagoras' Theorem. The arc must intersect the\n// x-axis at angle a, and the y-axis at angle b, which give conditions\n// (ii) and (iii).\n\nvec4 solve(float a, float b) {\n  // (i) r^2 + 1 = x^2 + y^2 - condition to be orthogonal to unit circle\n  // (ii) r cos(a) = x => x = r/cos(a)\n  // (iii) r cos(b) = y => y = r/cos(b)\n  float r2 = 1.0/(cos(a)*cos(a) + cos(b)*cos(b) - 1.0);\n  float r = sqrt(r2);\n  float x = r*cos(a);\n  float y = r*cos(b);\n  return vec4(x,y,r,r2);\n}\n\nfloat ds;\nvec3 diagram(vec2 z, vec2 m) {\t\n    ds = max(1.0,abs(1.0-dot(z,z)));\n    ds /= (0.5*iResolution.y);\n  vec4 T = doideal ? solve(PI/3.0,0.0) : solve(PI/float(P),PI/float(Q));\n  if (dohalfplane) {\n    z.y += 1.0;\n    if (dozoom) z *= exp(0.41*iTime);\n    z.y += 1.0;\n    z *= 2.0/dot(z,z);\n    z.y -= 1.0;\n  }\n  // Map origin to m with an inversion\n  if (domouse && m != vec2(0)) {\n    float k = 1.0/dot(m,m);\n    vec2 c = k*m; // m inverted in unit circle\n    float t = (k-1.0)/dot(z-c,z-c);\n    z = t*z+(1.0-t)*c;\n    z.x = -z.x; // Keep chirality\n  }\n  if (doclip && dot(z,z) > 1.0) return vec3(0);\n  if (donullrotation) {\n    // Can't do this with an inversion, so map to halfplane, where\n    // it's just a  translation.\n    vec2 c = vec2(0,-1);\n    z -= c;\n    z *= 2.0/dot(z,z);\n    z.x += 0.2*iTime;\n    z *= 2.0/dot(z,z);\n    z += c;\n  }\n  vec2 a = T.xy; float r = T.z, r2 = T.w;\n  int nsteps = !doprogressive ? 50 : min(50,int(iTime));\n  int i, folds = 0;\n  for (i = 0; i < nsteps; i++) {\n    int folds1 = int(z.x < 0.0) + int(z.y < 0.0);\n    z = abs(z);\n    float k = dot(z-a,z-a);\n    if (k < r2) {\n      folds1++;\n      z = r2*(z-a)/k + a;\n    }\n    if (folds1 == 0) break;\n    folds += folds1;\n  }\n  if (i == nsteps) return vec3(0);\n  // We have now folded the original point z into the fundamental\n  // region, now draw whatever should be in there. Things get smaller\n  // as we move outwards in the disc, so need a scale factor.\n  float scalefactor = abs(1.0 - dot(z,z));\n  vec3 col = vec3(1,1,0);\n  // Euclidean distances to edge of fundamental regions\n  float d1 = abs(z.x);\n  float d2 = abs(z.y);\n  float d3 = abs(length(z-a)-r);\n    //ds = fwidth(length(z));\n  // Desired widths, appropriately scaled.\n  float ewidth = scalefactor*0.00+ds;\n  float lwidth = scalefactor*0.005;\n  if (dotwotone) {\n    // Keep Fabrice happy with a smooth blend between tiles\n    // This is easy with only two tile colours.\n    float d = min(min(d1,d2),d3);\n    col *= 0.5+0.5*smoothstep(-ewidth,+ewidth, folds%2 == 0 ? d : -d);\n  }\n  if (doedge1 || doedge2 || doedge3) {\n    // Draw the edges of the region, if desired.\n    float d = 1e8;\n    if (doedge1) d = min(d,d1);\n    if (doedge2) d = min(d,d2);\n    if (doedge3) d = min(d,d3);\n    // But make him unhappy with a pixel-independent minimum line width.\n    col = mix(vec3(0),col,smoothstep(0.5*lwidth,lwidth+2.0*ds,d));\n    //if (fwidth(length(z)) > 0.1) col = vec3(0);\n  }\n  return col;\n}\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_C = 67;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_P = 80;\nconst int CHAR_T = 84;\nconst int CHAR_Z = 90;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  dotwotone = dotwotone != key(CHAR_T);\n  doedge1 = doedge1 != key(CHAR_0+1);\n  doedge2 = doedge2 != key(CHAR_0+2);\n  doedge3 = doedge3 != key(CHAR_0+3);\n  donullrotation = donullrotation != key(CHAR_N); \n  domouse = domouse != key(CHAR_M); \n  dozoom = dozoom != key(CHAR_Z); // halfplane only\n  dohalfplane = dohalfplane != key(CHAR_H);\n  doideal = doideal != key(CHAR_I);\n  doprogressive = doprogressive != key(CHAR_P);\n  doclip = doclip != key(CHAR_C);\n  \n  vec2 p = vec2((2.0*fragCoord-iResolution.xy)/iResolution.y);\n  vec2 P = iMouse.x <= 0.0 ? vec2(0)\n    : vec2((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}