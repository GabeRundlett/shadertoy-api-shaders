{
    "Shader": {
        "info": {
            "date": "1455220702",
            "description": "A slight variation from https://www.shadertoy.com/view/MsVGRy",
            "flags": 32,
            "hasliked": 0,
            "id": "MdVGzy",
            "likes": 3,
            "name": "Goorus",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "DrLuke",
            "viewed": 731
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nThanks to Inigo Quilez for the great distance functions showcase!\n*/\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//----------------------------------------------------------------------\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//----------------------------------------------------------------------\n\nfloat stepround(float a, float s)\t// See: https://www.wolframalpha.com/input/?i=x+-+modulo(x-0.2,+0.4)%2B0.2\n{\n\treturn a - mod(a-s, s*2.0)+s;\n}\n\nvec3 stepround(vec3 a, vec3 s)\t// See: https://www.wolframalpha.com/input/?i=x+-+modulo(x-0.2,+0.4)%2B0.2\n{\n\treturn a - mod(a-s, s*2.0)+s;\n}\n\nfloat map(vec3 p, mat3 rotMat)\n{\n\t//float r = sdPlane(p - vec3(0,-1.5,0));\t// Return distance\n    float r = 1000.0;\n\t\n    #define GS 0.1\n    //mat3 rotMat = rotationMatrix(vec3(1,1,0), iTime);\n    vec3 boxmod = mix(mod(p+vec3(GS),vec3(GS*2.0))-vec3(GS), p, step(0.55, sdTorus(rotMat*stepround(p, vec3(GS)), vec2(2,.5))) );\n    //vec3 boxmod = mod(p+vec3(GS),vec3(GS*2.0))-vec3(GS);\n    vec3 sizemod = mix(vec3(clamp(0.3-sdTorus(rotMat*stepround(p, vec3(GS)), vec2(2,0.5))*0.6, 0.0, GS) ), vec3(0), step(0.6, sdTorus(rotMat*stepround(p, vec3(GS)), vec2(2,.5))) );\n    \n    r = min(r, sdBox(boxmod, sizemod));\n    return r;\n}\n\nvec3 calcNormal( in vec3 pos, mat3 rotMat )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy, rotMat) - map(pos-eps.xyy, rotMat),\n\t    map(pos+eps.yxy, rotMat) - map(pos-eps.yxy, rotMat),\n\t    map(pos+eps.yyx, rotMat) - map(pos-eps.yyx, rotMat) );\n\treturn normalize(nor);\n}\n\n\nvec3 colorize(vec3 p, vec3 d, float dist)\n{\n \tvec3 col = vec3(0);\n    \n    mat3 rotMat = rotationMatrix(vec3(1,1,0), iTime*0.2);\n    vec3 boxsize = vec3(clamp(0.3-sdTorus(rotMat*stepround(p, vec3(GS)), vec2(2,0.5))*0.6, 0.0, GS) );\n    vec3 relp = mix(mod(p+vec3(GS),vec3(GS*2.0))-vec3(GS), p, step(0.6, sdTorus(rotMat*stepround(p, vec3(GS)), vec2(2,.5))) );\n    float a = smoothstep(boxsize.x*0.9, boxsize.x, abs(relp.x)) + smoothstep(boxsize.y*0.9, boxsize.y, abs(relp.y)) + smoothstep(boxsize.z*0.9, boxsize.z, abs(relp.z));\n    col = vec3(smoothstep(0.4,0.7,a/3.0)) * vec3(1.0,0.4,0) * length(boxsize)*2.0;\n    \n\n    vec3 n = calcNormal(p, rotMat);\n    col = mix(col, texture(iChannel1, reflect(normalize(d), n)).rgb, (1.0-length(col))*0.2);\n    //col = n;\n    \n    return mix(col, texture(iChannel0, d).rgb, step(10.0, dist));\n}\n\n#define MARCHLIMIT 500\n#define MARCHSTEPFACTOR mix(0.01,0.3,smoothstep(0.9,2.1, sdTorus(rotMat*stepround(s + d*dist, vec3(GS)), vec2(2,.5))))\nfloat march(vec3 s, vec3 d)\n{\n    mat3 rotMat = rotationMatrix(vec3(1,1,0), iTime*0.2);\n    float dist = 1.0;\t// distance\n    float distd = 0.1;\n    for(int i = 0; i < MARCHLIMIT; i++)\n    {\n        distd = map(s + d*dist, rotMat)*MARCHSTEPFACTOR;\n        if(distd < 0.00001 || dist > 10.0)\n        {\n            dist += distd;\n            break;\n        }\n        dist += distd;\n    }\n    \n\treturn min(dist, 100.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy * 2.0) / iResolution.xy) - vec2(1);\t// Make UV go from -1 to 1 instead of 0 to 1\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 s = vec3(sin(iTime*0.1)*5.0,sin(iTime*0.04)*4.0,cos(iTime*0.1)*5.0);\n    #define FOCALLEN 0.5\n    vec3 d = vec3(uv*FOCALLEN, 1.0);\n    mat3 rotMat = rotationMatrix(vec3(0,1,sin(iTime*3.14159*0.01)*0.1), -iTime*0.1 + 3.14159) * rotationMatrix(vec3(1,0,0), -0.7*sin(iTime*0.04) - 0.0);\n    d = rotMat * d;\n    \n    float marchdist = march(s, normalize(d));\n    \n    vec4 bufColor = vec4(0);\n    for(int i = 0; i < 5; i++)\n    {\n        for(int j = 0; j < 5; j++)\n        {\n            bufColor += texture(iChannel2, (fragCoord.xy + vec2(i-2, j-2)) / iResolution.xy);\n        }\n    }\n    \n\tfragColor = mix(vec4(colorize(s+normalize(d)*marchdist, normalize(d), marchdist), 1.0), bufColor/25.0, 0.3);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}