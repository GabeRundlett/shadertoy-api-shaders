{
    "Shader": {
        "info": {
            "date": "1567106604",
            "description": "This shader is a proof of concept to find out if I could create a \"typical\" Shadertoy shader, i.e. a shader that renders a non-trivial animated 3D scene, by using a ray tracer instead of the commonly used raymarching techniques. ",
            "flags": 0,
            "hasliked": 0,
            "id": "tlSSDV",
            "likes": 129,
            "name": "Robotic Arm Hunting Lights",
            "published": 3,
            "tags": [
                "raytracer",
                "ray",
                "tracer",
                "inverse",
                "kinematics",
                "inversekinematics"
            ],
            "usePreview": 1,
            "username": "reinder",
            "viewed": 5361
        },
        "renderpass": [
            {
                "code": "// Robotic Arm. Created by Reinder Nijhoff 2019\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tlSSDV\n//\n// This shader is a proof of concept to find out if I could \n// create a “typical” Shadertoy shader, i.e. a shader that renders \n// a non-trivial animated 3D scene, by using a ray tracer instead \n// of the commonly used raymarching techniques. \n//\n// Some first conclusions:\n// \n// - It is possible to visualize an animated 3D scene in a single \n//   shader using ray tracing.\n// - The compile-time of this shader is quite long.\n// - The ray tracer is not super fast, so it was not possible to cast\n//   enough rays per pixel to support global illumination or soft\n//   shadows. Here I miss the cheap AO and soft shadow algorithms that\n//   are available when raymarching an SDF.\n// - Modelling a 3D scene for a ray tracer in code is verbose. It was\n//   not possible to exploit the symmetries in the arm and the domain\n//   repetition of the sphere-grid that would have simplified the\n//   description of an SDF.\n// - I ran in GPU-dependent unpredictable precision problems. Hopefully,\n//   most problems are solved now. I’m not sure if they are inherent\n//   to ray tracing, but I didn’t have these kinds of problems using\n//   raymarching before.\n//\n\n#define AA 1 // Set AA to 1 if you have a slow GPU\n#define PATH_LENGTH 3\n#define MAX_DIST 60.\n#define MIN_DIST .001\n#define ZERO (min(iFrame,0))\n\n// Global variables\nfloat time;\nvec2[2] activeSpheres;\nvec2[3] joints;\nfloat joint0Rot;\nfloat jointYRot;\n\n//\n// Hash by Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\n//\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//\n// Ray-primitive intersection routines: https://www.shadertoy.com/view/tl23Rm\n//\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Plane \nfloat iPlane( const in vec3 ro, const in vec3 rd, in vec2 distBound, inout vec3 normal,\n              const in vec3 planeNormal, const in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\n// Sphere: https://www.shadertoy.com/view/4d2XWV\nfloat iSphere( const in vec3 ro, const in vec3 rd, const in vec2 distBound, inout vec3 normal,\n               const float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\nfloat iCylinder( const in vec3 oc, const in vec3 rd, const in vec2 distBound, inout vec3 normal,\n                 const in vec3 ca, const float ra, const bool traceCaps ) {\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    \n    if (h < 0.) return MAX_DIST;\n    \n    h = sqrt(h);\n    float d = (-b-h)/a;\n\n    float y = caoc + d*card;\n    if (y >= 0. && y <= caca && d >= distBound.x && d <= distBound.y) {\n        normal = (oc+d*rd-ca*y/caca)/ra;\n        return d;\n    } else if(!traceCaps) {\n        return MAX_DIST;\n    } else {\n        d = ((y < 0. ? 0. : caca) - caoc)/card;\n\n        if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\n            normal = normalize(ca*sign(y)/caca);\n            return d;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Capped Cone: https://www.shadertoy.com/view/llcfRf\nfloat iCone( const in vec3 oa, const in vec3 rd, const in vec2 distBound, inout vec3 normal,\n             const in vec3 pb, const in float ra, const in float rb ) {\n    vec3  ba = pb;\n    vec3  ob = oa - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps - only top cap needed for scene\n    if (m2 > 0. && dot2(ob*m3-rd*m2) < (rb*rb*m3*m3) ) {\n        float d = -m2 / m3;\n        if (d > distBound.x && d < distBound.y) {\n            normal = ba*inversesqrt(m0);\n            return d;\n        }\n    }\n    \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n\n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n\n    float h = k1*k1 - k2*k0;\n    if( h < 0. ) return MAX_DIST;\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {\n        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);\n        return t;\n    } else {   \n        return MAX_DIST;\n    }\n}\n\n// Box: https://www.shadertoy.com/view/ld23DV\nfloat iBox( const in vec3 ro, const in vec3 rd, const in vec2 distBound, inout vec3 normal, \n            const in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) {\n        //\tnormal = sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n//\n// Ray tracer helper functions\n//\nvec3 FresnelSchlick(vec3 SpecularColor, vec3 E, vec3 H) {\n    return SpecularColor + (1. - SpecularColor) * pow(1.0 - max(0., dot(E, H)), 5.);\n}\n\nvec2 randomInUnitDisk(const vec2 seed) {\n    vec2 h = hash22(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n//\n// Sphere functions\n//\nvec2 activeSphereGrid(float t) {\n  vec2 p = randomInUnitDisk(vec2(floor(t),.5));\n  return floor(p * 8.5 + 1.75*normalize(p));\n}\n\nvec3 sphereCenter(vec2 pos) {\n    vec3 c = vec3(pos.x, 0., pos.y)+vec3(.25,.25,.25);\n    c.xz += .5*hash22(pos);\n\treturn c;\n}\n\nvec3 sphereCol(in float t) {\n    return normalize(.5 + .5*cos(6.28318530718*(1.61803398875*floor(t)+vec3(0,.1,.2))));\n}\n\n//\n// Inverse Kinematics\n//\n// Very hacky, analytical,  inverse kinematics. I came up with the algorithm myself;\n// Íñigo Quílez can probably implement it without using trigonometry:\n// https://iquilezles.org/articles/noacos\n//\nvoid initDynamics() {\n    time = iTime * .25;\n\n    activeSpheres[0] = activeSphereGrid(time);\n    activeSpheres[1] = activeSphereGrid(time+1.);\n\n    vec3 ta0 = sphereCenter(activeSpheres[0]);\n    vec3 ta1 = sphereCenter(activeSpheres[1]);\n\n    float taa0 = atan(-ta0.z, ta0.x);  \n    float taa1 = atan(-ta1.z, ta1.x);\n\n    if (abs(taa0-taa1) > 3.14159265359) {\n        taa1 += taa1 < taa0 ? 2. * 3.14159265359 : -2. * 3.14159265359;  \n    }\n    jointYRot = mix(taa0, taa1, clamp(fract(time)*2.-.5,0.,1.));    \n\n    float tal = mix(length(ta0), length(ta1), clamp(fract(time)*2.5-1.,0.,1.));\n\n    vec2 target = vec2(tal,.5-.5*smoothstep(.35,.4,abs(fract(time)-.5)));  \n\n    float c0 = length(target);\n    float b0 = min(11., 4. + 2. * c0 / 11.);\n\n    vec2 sd = normalize(target);\n    float t0 = asin(sd.y)+acos(-(b0*b0-25.-c0*c0)/(10.*c0));\n\n    joints[0] = vec2(5. * cos(t0), 5.* sin(t0));\n    joint0Rot = t0;\n\n    sd = normalize(target-joints[0]);  \n    float c1 = min(6., distance(joints[0], target));\n    const float b1 = 2.;  \n\n    float t1 = asin(sd.y) * sign(sd.x) + acos(-(b1*b1-16.-c1*c1)/(8.*c1));\n    t1 += sd.x < 0. ? 3.1415 : 0.;\n    joints[1] = joints[0] + 4. * vec2(cos(t1),sin(t1));\n    joints[2] = target;\n}\n\n//\n// Scene description\n//\nvec3 opU( const in vec3 d, const in float iResult, const in float mat ) {\n\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\n}\n      \nvec3 iPlaneInt(vec3 ro, vec3 rd, float d) {\n    d = -(ro.y - d) / rd.y;\n    return ro + d * rd;\n}\n\nvec3 traceSphereGrid( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal, const int maxsteps ) {  \n\tfloat m = 0.;\n    if (ro.y < .5 || rd.y < 0.) {\n        vec3 ros = ro.y < .5 ? ro : iPlaneInt(ro, rd, .5);\n        if (length(ros.xz) < 11.) {\n            vec3 roe = iPlaneInt(ro, rd,rd.y < 0. ?0.:.5);\n            vec3 pos = floor(ros);\n            vec3 rdi = 1./rd;\n            vec3 rda = abs(rdi);\n            vec3 rds = sign(rd);\n            vec3 dis = (pos-ros+ .5 + rds*.5) * rdi;\n            bool b_hit = false;\n\n            // traverse grid in 2D\n            vec2 mm = vec2(0);\n            for (int i = ZERO; i<maxsteps; i++) {\n                float l = length(pos.xz+.5);\n                if (pos.y > .5 || pos.y < -1.5 || l > 11.) {\n                    break;\n                }\n                else if ( l > 2. && pos.y > -.5 && pos.y < 1.5 ) {\n                    float d = iSphere(ro-sphereCenter(pos.xz), rd, dist, normal, .25);\n                    if (d < dist.y) {\n                        m = 2.;\n                        dist.y = d;\n                        break;\n                    }\n                }\t\n                vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n                dis += mm*rda;\n                pos += mm*rds;\n            }\n        }\n    }\n\treturn vec3(dist, m);\n}\n\nvec3 rotateY( const in vec3 p, const in float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nvec3 worldhit( const in vec3 ro, const in vec3 rd, const in vec2 dist, out vec3 normal ) {\n    vec3 d = vec3(dist, 0.);\n    \n    d = traceSphereGrid(ro, rd, d.xy, normal, 10);\n    \n    d = opU(d, iPlane   (ro, rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\n    d = opU(d, iCone    (ro-vec3(0,.2,0), rd, d.xy, normal, vec3(0,.2,0), 1.5, 1.4), 4.);\n    d = opU(d, iCylinder(ro, rd, d.xy, normal, vec3(0,.2,0), 1.5, false), 4.);\n    \n    float dmax = d.y;\n    vec3 roa = rotateY(vec3(ro.x, ro.y-1., ro.z), jointYRot);    \n    vec3 rda = rotateY(rd, jointYRot); \n    \n    vec3 bb = vec3(.5*max(joints[1].x,joints[2].x), joints[0].y*.5, .0);\n    vec3 bbn;\n    \n    if (iBox(roa-bb, rda, vec2(0,100), bbn, bb+vec3(.75,.75,.8)) < 100.) {\n\t    vec3 dr = vec3(-sin(joint0Rot), cos(joint0Rot), 0);\n        vec2 j21 = joints[2]-joints[1];\n        \n        for (int axis=0; axis<=1; axis++) {\n            float a = axis == 0 ? -1. : 1.;\n            d = opU(d, iCylinder(roa-vec3(0,0,a*.67), rda, d.xy, normal, vec3(0,0,-a*.2),.55, true), 3.);\n            d = opU(d, iCylinder(roa-vec3(0,0,a*.58)-.4*dr, rda, d.xy, normal, vec3(joints[0],-a*.24)-.24*dr,.07, false), 4.);\n            d = opU(d, iCylinder(roa-vec3(0,0,a*.58)+.4*dr, rda, d.xy, normal, vec3(joints[0],-a*.24)+.24*dr,.07, false), 4.);\n            d = opU(d, iCylinder(roa-vec3(joints[0],a*.45), rda, d.xy, normal, vec3(0,0,-a*.2),.35, true), 3.);\n            d = opU(d, iCylinder(roa-vec3(joints[1],a*.29), rda, d.xy, normal, vec3(0,0,-a*.08),.25, true), 3.);\n            d = opU(d, iCylinder(roa-vec3(joints[1],a*.24), rda, d.xy, normal, vec3(j21,a*.08),.03, false), 4.);\n        }\n\n        vec2 j10 = joints[1]-joints[0];\n        d = opU(d, iCylinder(roa-vec3(0,0,-.72), rda, d.xy, normal, vec3(0,0,1.44),.5, true), 5.);\n        d = opU(d, iBox     (roa+vec3(0,.5,0), rda, d.xy, normal, vec3(.5,.5,.47)), 5.);\n        d = opU(d, iCone    (roa-vec3(joints[0],0), rda, d.xy, normal, vec3(j10,0),.25, .15), 5.);\n        d = opU(d, iCylinder(roa-vec3(joints[0],-.5), rda, d.xy, normal, vec3(0,0,1.),.3, true), 5.);\n        d = opU(d, iCylinder(roa-vec3(joints[1],-.35), rda, d.xy, normal, vec3(0,0,.7),.2, true), 5.);\n        d = opU(d, iCylinder(roa-vec3(joints[2],-.4), rda, d.xy, normal, vec3(0,0,.8),.2, true), 3.);\n        d = opU(d, iSphere  (roa-vec3(joints[2],0), rda, d.xy, normal, .32), 5.);\n        d = opU(d, iCylinder(roa-vec3(joints[2],0), rda, d.xy, normal, vec3(0,-.5,0),.06, true), 3.);\n\n        if (d.y < dmax) {\n            normal = rotateY(normal, -jointYRot);\n        }\n    }    \n    return d;\n}\n\nfloat shadowhit( const vec3 ro, const vec3 rd, const float dist) {\n    vec3 normal;\n    float d = traceSphereGrid( ro, rd, vec2(.3, dist), normal, 4).y;\n    d = min(d, iCylinder(ro, rd, vec2(.3, dist), normal, vec3(0,.2,0), 1.5, false));\n    return d < dist-0.001 ? 0. : 1.;\n}\n\n//\n// Simple ray tracer\n//\nfloat getSphereLightIntensity(float num) {\n    return num > .5 ?\n        clamp(fract(time)*10.-1., 0., 1.) :\n\t\tmax(0., 1.-fract(time)*10.); \n}\n\nfloat getLightIntensity( const vec3 pos, const vec3 normal, const vec3 light, const float intensity) {\n    vec3 rd = pos - light;\n    float i = max(0., dot(normal, -normalize(rd)) / dot(rd,rd));\n    i = i > 0.0001 ? i * intensity * shadowhit(light, normalize(rd), length(rd)) : 0.;\n    return max(0., i-0.0001);              \n}\n\nvec3 getLighting( vec3 p, vec3 normal ) {\n    vec3 l = vec3(0.);\n    \n    float i = getSphereLightIntensity(0.);\n    if (i > 0.) {\n\t    l += sphereCol(time) * (i * getLightIntensity(p, normal, sphereCenter(activeSpheres[0]), .375));\n    } else {    \n        i = getSphereLightIntensity(1.);\n        if (i > 0.) {\n            l += sphereCol(time+1.) * (i * getLightIntensity(p, normal, sphereCenter(activeSpheres[1]), .25));\n        }\n    }\n    \n    vec3 robot = mix(sphereCol(time), sphereCol(time-1.), getSphereLightIntensity(0.));\n    vec3 lp = rotateY(vec3(joints[2].x, joints[2].y+1.,0), -jointYRot);\n    i = getLightIntensity(p, normal, lp, .5);\n    i += getLightIntensity(p, normal, vec3(0,2,0), .25);\n    l += i * robot;\n    \n    return l;\n}\n\nvec3 getEmissive( in vec2 pos, in float mat ) {\n    if (mat > 2.5 ) {\n\t   return mix(sphereCol(time), sphereCol(time-1.), getSphereLightIntensity(0.));\n    } else if (mat > 1.5 ) {\n        float li0 = getSphereLightIntensity(0.);\n        float li1 = getSphereLightIntensity(1.);\n        if (li0 > 0. && pos == activeSpheres[0]) {\n            return sphereCol(time) * li0 * 1.25;\n        } else if (li1 > 0. && pos == activeSpheres[1]) {\n            return sphereCol(time+1.) * li1;\n        } else {\n            return vec3(0);\n        }\n    } else {\n        return vec3(0);\n    }\n}\n\nvec3 render( in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(1);\n    vec3 emitted = vec3(0);\n    vec3 normal;\n        \n    for (int i=ZERO; i<PATH_LENGTH; ++i) {\n    \tvec3 res = worldhit( ro, rd, vec2(MIN_DIST, MAX_DIST-1.), normal );\n\t\tif (res.z > 0.) {\n\t\t\tro += rd * res.y;\n\n            if (res.z < 3.5) { \n               \tvec3 F = FresnelSchlick(vec3(0.4), normal, -rd);\n                emitted += (col * (getEmissive(floor(ro.xz), res.z) + .5 * getLighting(ro, normal))) * (1.-F);\n                col *= .5 * F;\n            } else {\n                col *= .15;   \n            } \n            \n            rd = normalize(reflect(rd,normal));\n        } else {\n\t\t\treturn emitted;\n        }\n    }  \n    return emitted;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initDynamics();\n\n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.4,-.1) : abs(iMouse.xy)/iResolution.xy - .5;\n\n    vec3 ro = vec3(10.5*cos(1.5+6.*mo.x), 6.+10.*mo.y, 8.5*sin(1.5+6.*mo.x));\n    vec3 ta = vec3(ro.x*ro.y*.02, .8, 0);\n    mat3 ca = setCamera(ro, ta, 0.);    \n    \n    vec3 col = vec3(0);\n    \n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ ) {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \n        col += pow(8. * render(ro, rd), vec3(1./2.2));\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n    \n    col = clamp(col + ((hash22(fragCoord).x-.5)/64.), vec3(0), vec3(1));\n    \n\tfragColor = vec4(col , 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}