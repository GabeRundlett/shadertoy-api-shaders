{
    "Shader": {
        "info": {
            "date": "1685565114",
            "description": "Celtic weave based on some by fabrice",
            "flags": 0,
            "hasliked": 0,
            "id": "flcyW2",
            "likes": 27,
            "name": "CubeMap Celtic Weave Comp",
            "published": 3,
            "tags": [
                "template"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 503
        },
        "renderpass": [
            {
                "code": "/*\nYusef28\n6/8/2022 <- that's day, month, year so it's in August.\nIt's just a shorthand to save me from typing \nThe 6th of August 2022. Much shorter to just say 6/8/2022.\n\nRaymarching template for people who are\ntrying to live their lives or something.\n\n*/\n#define FAR 100.\n#define eps 10./iResolution.y\n#define R iResolution\n#define F fragCoord\n#define S smoothstep\n#define T iTime\n#define PI acos(-1.)\n#define TAU PI*2.\n#define M (iMouse.xy*2.-R.xy)/R.y\n#define Mz iMouse.z\n#define E 2./R.y\n#define ROT(a) mat2(cos(a + vec4(0,11,33,0)))\n#define F5(u) (fract((u))-0.5)\n#define aFract(u) abs(fract((u))-0.5)\n\n#define L(p,u) length(u-p)//max(abs(u.x-p.x),abs(u.y-p.y))//\n#define SOLID(shape,r) S(r+E,r-E,shape)\n\n//r=radius, t = thickness,  E=epsilon  //add t to shift to edge\n#define OUTLINE(shape,r,t) S(t+E,t-E,abs(shape-r+t))\n//double outline for ends of a shape\n    //  r = radius, ot = outline thickness\n    //  rt = orig ring thickness                      \n    //add rt to shift corrent\n    //subtract  (rt-ot) to sprad correct\n#define DOUTLINE(shape,r,ot,rt) S(ot+E*2.,ot-E*2.,abs(abs(shape-r+rt)-(rt-ot)))\n\n//r=radius, t = thickness, b = blur   //add t to shift to edge\n#define OLS(shape,r,t,b) S(t*1.25+b,t*1.25-b,abs(shape-r+t))\n#define OUTSHADOW(shape,r,l) S(r+l,r,shape)\n#define INSHADOW(shape,r,t,l) S(r+E,r-E,shape)*S(t+E,t-E-l,abs(shape-r+t/4.))\n#define GLOW(shape,r,t,l) S(t+E,t-E-l,abs(shape-r+t/4.))\n\n#define CKR(u) mod(floor((u).x)+mod(floor((u).y)+1.,2.),2.)\n#define CKRF(u) max(aFract(u).x,aFract(u).y)\n#define CKRO(u) S(0.47,0.48,max(aFract(u).x,aFract(u).y))\n\n#define TX0(u) texture(iChannel0,u).rgb\n#define TX1(u) texture(iChannel1,u).rgb\n#define TX2(u) texture(iChannel2,u).rgb\n#define TX3(u) texture(iChannel3,u).rgb\n\n#define WHITE vec3(1.,1.,1.)\n#define BLACK vec3(0.,0.,0.)\n#define GREY1 vec3(0.1,0.1,0.1)\n#define GREY3 vec3(0.3,0.3,0.3) \n#define GREY5 vec3(0.5,0.5,0.5)\n#define GREY7 vec3(0.7,0.7,0.7)\n#define GREY9 vec3(0.9,0.9,0.9) \n\n#define RED vec3(0.5,0.2,0.)\n#define GOLD vec3(0.9,0.5,0.3)\n#define BLUE vec3(0.1,0.4,0.5)\n\nfloat vig(vec2 uv){\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 200.0;\n    return pow(vig, 1.); \n}\n\nfloat hash(float p)\n{\n\t return fract(sin(p*324.341)*23402.43);\n}\n\nfloat hash21(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\nmat2 rot(float a) {\n    return mat2(cos(a - vec4(0,11,33,0)));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat Gyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n    float d = abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n\treturn d;\n}\n\n\nbool checkLogoBoundingBox(vec3 p){\n    \n    return (p.x < -4.5 || p.x > 4.5 || \n            p.y < -3. || p.y > 2. || \n            p.z < -4. || p.z > 4.);\n    \n}\n\n//float objID = 0.;\nfloat map(vec3 p) {\n    float d = length(p)-1.5;//sdBox(p, vec3(1));\n    \n    return d;//skull(p);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat t=0.;\n    \n    for(int i=0; i<100; i++) {\n    \tvec3 p = ro + rd*t;\n        float d = map(p);\n        t += d*0.7;\n        if(t>FAR || abs(d)<0.001) break;\n    }\n    \n    return t;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = map(p) - \n        vec3(\n            map(p-e.xyy), \n            map(p-e.yxy),\n            map(p-e.yyx)\n            );\n    \n    return normalize(n);\n}\n\n\nvec3 camRay(vec2 uv, vec3 o, vec3 target, float zoom){\n    \n    vec3 fwd = normalize(target - o);\n    vec3 uu = vec3(0.,1.,0.);\n    uu = dot(target,uu) < 0.01 ? vec3(0.,0.,1.) : uu;\n    vec3 right = normalize(cross(uu, fwd));\n    vec3 up = cross(fwd,right);\n    vec3 rd = right*uv.x + up*uv.y + fwd*zoom;\n    return normalize(rd);\n\n}\n\nvec2 map_from_sphere(vec3 p)\n{\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}\n\nvec3 checkers(vec2 u){\n   // u.x += T*0.1;\n    vec2 st = u;\n    u*=2.;\n    //u.x +=0.14;\n    u = F5(u*2.)*2.;\n    u = u.x*u.y < 0. ? abs(u.yx) : abs(u);\n    u = abs(u)-0.7155;//-0.8;//-0.1\n    u = abs(u)-0.5;//-0.3;//-0.6\n    \n    vec3 col = GREY5*0.35-CKR(st*20.)*0.15-CKRF(st*20.)*0.03;\n    col -= (CKRO(st*20.)*0.82-0.01 );\n    return col;\n    }\n    \nvec3 celtic(vec2 u){\n   // u.x += T*0.1;\n    vec2 st = u;\n    u*=2.;\n    //u.x +=0.14;\n    u = F5(u*2.)*2.;\n    u = u.x*u.y < 0. ? abs(u.yx) : abs(u);\n    u = abs(u)-0.7155;//-0.8;//-0.1\n    u = abs(u)-0.5;//-0.3;//-0.6\n    \n    vec3 col = GREY5*0.35-CKR(st*20.)*0.15-CKRF(st*20.)*0.03;\n    col -= (CKRO(st*20.)*0.82-0.01 );\n    float radius = 0.959;\n    float thick = 0.08;\n    float othick = 0.01;\n    float bthick = 0.013;\n    float blur = 0.06;\n    vec3 REDNEW = pow(RED*TX1(st*4.),vec3(1.4))*2.;\n    \n    col = mix(col,BLACK,OLS(L(vec2(0.5,-0.5),u),radius,thick,blur));\n    col = mix(col,REDNEW,OUTLINE(L(vec2(0.5,-0.5),u),radius,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(0.5,-0.5),u),radius,bthick,thick));\n    col = mix(col,GOLD*(0.1+TX0(st*2.)),DOUTLINE(L(vec2(0.5,-0.5),u),radius,othick,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(0.5,-0.5),u),radius,bthick*0.2,thick));\n   \n   \n    col = mix(col,BLACK,OLS(L(vec2(0.5,0.5),u),radius,thick,blur));\n    col = mix(col,REDNEW,OUTLINE(L(vec2(0.5,0.5),u),radius,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(0.5,0.5),u),radius,bthick,thick));\n    col = mix(col,GOLD*(0.1+TX0(st*2.)),DOUTLINE(L(vec2(0.5,0.5),u),radius,othick,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(0.5,0.5),u),radius,bthick*0.2,thick));\n    \n    col = mix(col,BLACK,OLS(L(vec2(-0.5,0.5),u),radius,thick,blur));\n    col = mix(col,REDNEW,OUTLINE(L(vec2(-0.5,0.5),u),radius,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(-0.5,0.5),u),radius,bthick,thick));\n    col = mix(col,GOLD*(0.1+TX0(st*2.)),DOUTLINE(L(vec2(-0.5,0.5),u),radius,othick,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(-0.5,0.5),u),radius,bthick*0.2,thick));\n    \n    return col;\n}\n\nvec3 triplanar(vec3 p, vec3 n){\n    n = abs(n);\n    return mix(mix(celtic(p.yz),celtic(p.xy),n.z),celtic(p.xz),n.y);\n}\n\n// returns cubemap coordinates (FROM BIGWINGS)\n// xy = uv coords for face of cube, z = cube index (-3,-2,-1, 1, 2, 3)\nvec3 WorldToCube(vec3 p) {\n\tvec3 ap = abs(p);\n    vec3 sp = sign(p);\n    float m = max(ap.x, max(ap.y, ap.z));\n    vec3 st;\n    if(m==ap.x)\n        st = vec3(p.zy, 1.*sp.x);\n    else if(m==ap.y)\n        st = vec3(p.zx, 2.*sp.y);\n    else\n        st = vec3(p.xy, 3.*sp.z);\n    \n    st.xy /= m;\n\n    // iq version, no trig, short and sweet\n   st.xy *= 3.0/(2.0+abs(st.xy));\n//st.xy *= (1.45109572583 - 0.451095725826*abs(st.xy));\n    return st;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 4, -1);\n    vec3 light = normalize(vec3(-1.,2.,1.));\n    vec3 light2 = normalize(vec3(1.,2.,-1.));\n  //  light = normalize(vec3(-1.,4.,1.));\n  //  ro.yz *= rot(-m.y*PI+1.+iTime);\n    //ro.xz *= rot(-m.x*TAU);\n   // light.yz *= rot(-m.y*PI+1.);\n   // light.xz *= rot(-m.x*TAU);\n    \n    vec3 rd = camRay(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = celtic(uv.xy+iTime*0.05)*vig((F.xy/R.xy))*vec3(0.7,0.5,0.3)*0.2;\n    col = mix(col,BLACK,smoothstep(0.,0.3,(1.-length(uv+vec2(-0.09,0.1))-0.5))*0.8);\n    float t = RayMarch(ro, rd);\n\n    if(t<FAR) {\n        vec3 p = ro + rd * t;\n        \n        \n        vec3 n = GetNormal(p);\n        \n        \n        \n        float ld = length(light-p);\n        float ld2 = length(light2-p);\n        \n        p.yz *= rot(-m.y*PI+1.+iTime*0.2);\n        p.xz *= rot(-m.x*TAU+iTime*0.2);\n        \n        vec3 cubeCoords = WorldToCube(p);\n        /*\n        vec3 CXA = WorldToCube(p) + vec3(0.,E,0.);\n        vec3 CXB = WorldToCube(p) + vec3(0.,-E,0.);\n        vec3 CYA = WorldToCube(p) + vec3(E,0.,0.);\n        vec3 CYB = WorldToCube(p) + vec3(-E,0.,0.);\n        vec3 bump = vec3(CXB-CXA,CYB-CYA,0.);*/\n        \n        float attn = 1./(0.3+ld*0.2+ld*ld);\n        float diff = max(0.,dot(n,light))*0.8+0.05;\n        float spec = pow(max(0.,dot(\n                     reflect(n,-light\n                     ),rd)),100.);\n         \n        \n        float attn2 = 1./(0.3+ld2*0.2+ld2*ld2);\n        float diff2 = max(0.,dot(n,light2))*0.8+0.05;\n        float spec2 = pow(max(0.,dot(\n                     reflect(n,-light2\n                     ),rd)),100.);\n                     \n        float ref = TX2(-reflect(n,rd)).x;   \n        vec3 tp_tex = triplanar(p*0.5,n);\n        vec3 sc_tex = celtic(map_from_sphere(p));\n        \n        vec3 cc_text = celtic((cubeCoords.xy*0.5+cubeCoords.z));//TX0(map_from_sphere(p)*3.);\n      //  col = mix(sc_tex,tp_tex,abs(n.z)) * diff;\n        vec3 col1 = 1.4*clamp(cc_text,0.,1.)*diff*1.6*attn + ref*0.0*diff*BLUE +  BLUE*spec*.08;\n        vec3 col2 = 1.4*clamp(cc_text,0.,1.)*diff2*1.6*attn2*RED + ref*0.0*diff2 +  RED*spec2*.08;\n        col = (col1+col2);\n    \n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\nfloat knochen(vec3 p, vec3 xyz, vec3 dim, float th, float phi, float ga, \n                float spiegel, float r){\n    \n    vec3 sp = p - xyz;\n    sp.x = abs(sp.x) - spiegel;\n    \n    float cs = cos(th), si = sin(th);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    cs = cos(phi), si = sin(phi);\n    sp.xz*= mat2(cs, si, -si, cs);\n    \n    cs = cos(ga), si = sin(ga);\n    sp.xy*= mat2(cs, si, -si, cs);\n        \n    sp = abs(sp) - dim;\n    return min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - r;    \n}\nfloat sdCircleCircle( in vec3 p, in int n, float zeichen){\nfloat a0 = float(n) / radians(360.); \nfloat a = round(atan(p.z, p.x) * a0) / a0;\nvec3 sp = p - vec3(cos(a), 0.0, sin(a));\n  \nfloat cs = cos(a), si = sin(a);//erste versuch!!!!\nsp.xz*=mat2(cs, si, -si, cs);\n  \ncs = cos(0.3*zeichen), si = sin(0.3*zeichen);//erste versuch!!!!\nsp.xy*=mat2(cs, si, -si, cs);\n    \nsp = abs(sp) - vec3(0.1 + cos(sp.y*8.)*0.03, 0.19, 0.07 + cos(sp.y*6.+ 1.4)*0.05*zeichen);\nreturn min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - 0.03;  \n\n    \n    //return sdCappedCylinder(sp, 0.05, 0.06) - 0.05; \n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\nfloat skull(vec3 p){\n    vec3 altp = p;\n    p.x+=1.;\n    p.x = mod(p.x, 2.) - 1.;\n    \n    float PosX, PosY;\n   // PosX = 0. + sin(iTime*20.)/4.;// - (iMouse.x)/iResolution.x;//0.2*2.*(rechts - links);\n  //  PosY = -0.1 + sin(iTime*2.)/4.;;//(iMouse.y)/iResolution.y*4.;\n    \n    //zufall \n    float cs = cos(PosX), si = sin(PosX);\n    //p.xy = mat2(cs, si, -si, cs)*p.xy;\n    if (altp.x > 0.75 || altp.x < -0.75){\n    p.xz = mat2(cs, si, -si, cs)*p.xz;}\n    else{\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;}\n    \n    //guckmal\n    float gu = -1.6;\n    cs = cos(gu), si = sin(gu);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n    \n    \n\tp*=0.6;\n    p.y-=0.2;// + sin(iTime)*0.1;\n    \n\n    \n    vec3 sp = p - vec3(0., 0., 0.03);\n    float k = length(sp*vec3(1.-sin(sp.z*6.-0.4)*0.05, \n                             0.95+sin(sp.z*6.+1.6)*0.05, \n                             0.87)) - 0.5;\n    float alle = k;\n    \n    //schadel unten schneiden\n    sp = p;\n    k = length(sp - vec3(0., -0.9, -0.5)) - 0.7;\n    alle = smax(alle, -k, 0.09);\n    \n    ///return alle;\n    \n    //schadel seite\n    sp = p  - vec3(0., -0.05, -0.28);\n    sp.x = abs(sp.x) - 0.65;\n    //length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.87))\n    k = length(sp) - 0.3;\n    //k = length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.6)) - 0.3;\n    //alle = smax(alle, -k, 0.09);\n\n    //schadel seite knochen schneiden versuch\n    sp = p;\n    k = knochen(p, vec3(0., -0.15 , -0.18 ), \n                vec3(0.005, \n                     0.17 + sin(sp.z*4.+2.4)*0.1, \n                     0.2+ sin(sp.y*4.+2.)*0.18), \n                -0.2, -0.4, 0.1, 0.42+ sin(sp.z*4.+2.4)*0.05, 0.03);\n    alle = smax(alle, -k, 0.09);\n    \n    //return alle;\n    \n    //oben augen knochen\n    sp = p;\n    k = knochen(p, vec3(0., \n                        0. + cos(abs(sp.x)*8. + 5.)*0.03*1. - 0.04*1. , \n                        -0.45 - cos(abs(sp.x)*8. + 5.8)*0.05), \n                vec3(0.12, 0.005, 0.005), \n                0., 0., -0., 0.14, 0.04);\n    alle = smin(alle, k, 0.07);\n    \n    //return alle;\n\n    \n    //oberest knochen\n    sp = p;\n    k = knochen(p, vec3(0., 0.055 , -0.37 ), vec3(0.005, 0.005, 0.12), \n                -1., -0.25, 0., 0.28, 0.02);\n    alle = smin(alle, k, 0.06);\n    \n    //augen seit knochen\n    sp = p;\n    k = knochen(p, vec3(0., -0.14 , -0.46+ cos(sp.y*8.+1.5)*0.07), \n                vec3(0.01, 0.08, 0.02), \n                0.0, 0.0, 0.35, 0.26+ cos(sp.y*12.+1.2)*0.06, 0.015);\n    alle = smin(alle, k, 0.06);\n    \n\n    \n    \n    //wangen knochen vor\n    sp = p;\n    k = knochen(p, vec3(0., -0.28, -0.42+cos(abs(sp.x)*8.+2.)*0.02), \n                vec3(0.13, 0.055+sin(abs(sp.x)*8.+2.)*0.02, 0.05), \n                -0.5, 0.2, -0.1, 0.12, 0.05);\n    alle = smin(alle, k, 0.09);\n    \n    //return alle;\n    \n    //wangen knochen seit sollte dasselb (gesamt)breit haben wie die augen seit!\n    //wangen knochen seit\n    sp = p;\n    k = knochen(p, vec3(0., -0.3, -0.28), \n                vec3(0.007, 0.02-cos(sp.z*8. + 1.7-cos(sp.z*20. + 1.7))*0.01, 0.16), \n                0., 0.1, 0., 0.27 + cos(sp.z*8. + 2.)*0.09, \n                0.03 + cos(sp.z*8. + 4.7)*0.015);\n    alle = smin(alle, k, 0.02);\n    \n    float keiferHohe = 0.01;\n    //wangen knochen zu keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.51+keiferHohe, -0.25 - cos(abs(sp.y)*12. + 3.)*0.04), \n                vec3(0.005-cos(sp.z*12.+4.5)*0.004 - cos(sp.y*6.+1.2)*0.017, \n                     0.125, \n                     0.1), \n                0.2+(-sp.y-0.5)*0.2, -0.35, -0.25, \n                0.29 , 0.01); //keifer ein bisschen mehr eng war hilfreich\n    float keifer = k;\n    \n    \n    \n    \n    //keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.67+keiferHohe, -0.35), vec3(0.005, 0.02, 0.16), \n                -0.3, -0.5, 0., 0.18+cos(sp.z*8.+3.14)*0.02, 0.045);\n    keifer = smin(keifer, k, 0.04);\n    \n    //wkk schneid\n    sp = p;\n    k = knochen(p, vec3(0., -0.58+keiferHohe, -0.28 - cos(abs(sp.y)*12. + 3.)*0.06), \n                vec3(0.001, 0.15, 0.055), \n                0.2+(-sp.y-0.5)*0.2, -0.45, -0.3, 0.34, 0.01);\n    keifer = smax(keifer, -k, 0.04);\n    \n    //wkk loch\n    sp = p;\n    sp.x = abs(sp.x) - 0.31;\n    k = length(sp - vec3(0., -0.38+keiferHohe, -0.23)) - 0.06;\n    keifer = smax(keifer, -k, 0.04);\n    \n    \n    //kinn\n    sp = p;\n    k = knochen(p, vec3(0., -0.73+keiferHohe, -0.45-cos(sp.x*8.)*0.1), vec3(0.09, 0.02, 0.015), \n                0., 0., 0., 0., 0.03);\n    keifer = smin(keifer, k, 0.09);\n    \n\n    //sollte siemlich schaf sein\n    //augen loche\n    sp = p;\n    sp.x = abs(sp.x) - 0.172;\n    k = length(sp - vec3(0., -0.14, -0.48)) - 0.084;\n    alle = smax(alle, -k, 0.075);\n    \n    //nase\n    sp = p;\n    k = knochen(p, vec3(0., -0.23, -0.51), vec3(0.03, 0.09, 0.08), \n                -0.3, 0., 0.3, 0., 0.039);\n    alle = smin(alle, k, 0.06);\n    \n    //nase scheiden\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.54), vec3(0.022, 0.08, 0.07), \n                -0.35, 0., 0.3, 0., 0.03);\n    alle = smax(alle, -k, 0.04);\n    \n    //nase linie\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.5), vec3(0.001, 0.12, 0.07), \n                -0.35, 0., 0., 0., 0.005);\n    alle = smin(alle, k, 0.03);\n    \n    \n    float zahnNum = 12.;\n    float th = 0.15;\n    sp = p;\n    cs = cos(th), si = sin(th);\n    \n    sp = sp - vec3(0., -0.43, -0.4);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    //cyl oben\n    \n    k = sdCappedCylinder(sp, 0.17 //nicht so breit\n                         + cos(sp.y*12. -5.)*0.015\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.005\n                         , 0.045 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.02\n                        - cos(sp.z*6.-1.75)*0.05\n                        );\n    alle = smin(alle, k, 0.06); //weniger smooth weil die echte schadel\n    \n    \n    //return alle;\n    \n    //cyl unten\n    sp = p - vec3(0., -0.65+keiferHohe, -0.42);\n    k = sdCappedCylinder(sp, 0.15\n                         + cos(sp.y*12. - 1.5)*0.03\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01\n                         , 0.05 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01);\n    keifer = smin(keifer, k, 0.06);\n    \n    \n    \n    \n  \n    //oben zhan\n    sp = p - vec3(0.0, -0.51, -0.41);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    k = sdCircleCircle(sp*6.6, 24, 1.); //nicht so breit\n    float zahn = k;\n    \n    //unten zahn\n    sp = p - vec3(0.0, -0.58+keiferHohe, -0.39);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    \n    k = sdCircleCircle(sp*6.6, 24, -1.);//nicht so breit\n    zahn = min(zahn, k);\n    \n    objID = vec4(zahn-0.05, alle, keifer, 0);\n    alle = smin(zahn,alle, 0.09);\n    alle = smin(alle, keifer, 0.09);\n    \n    //cyl schneiden\n    sp = p - vec3(0., -0.58, -0.15);\n    k = sdCappedCylinder(sp, 0.17, 0.24);\n    alle = smax(alle, -k, 0.06);\n    \n    //schonheit\n    sp = p;\n    sp.x = abs(sp.x) - 0.18;\n    k = length(sp - vec3(0., -0.32, -0.522)) - 0.012;\n    alle = smax(alle, -k, 0.01);\n    \n    return alle;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}