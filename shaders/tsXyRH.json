{
    "Shader": {
        "info": {
            "date": "1584123557",
            "description": "nightmare",
            "flags": 0,
            "hasliked": 0,
            "id": "tsXyRH",
            "likes": 10,
            "name": "I had a nightmare last night",
            "published": 3,
            "tags": [
                "eye",
                "nightmare"
            ],
            "usePreview": 0,
            "username": "tono",
            "viewed": 459
        },
        "renderpass": [
            {
                "code": "\n#define FAR 20.\n#define M(x,y) mod(x,y) - y/2.\n\n//If you want to make it worse, you need to make AA more than 2.\n#define GetsEvenWorse false\n#define AA 1\n\n#define OnlyEye false\n\nfloat pi = acos(-1.);\nfloat pi2 = acos(-1.) * 2.;\n\nfloat t,depth;\n\nvec3 cp = vec3(10.,5.,-11.);\n\nvec2 rot(vec2 p,float a){return vec2(mat2( cos(a),sin(a),-sin(a),cos(a))*p );}\n\nvec3 RotMat(vec3 p,vec3 axis, float angle)\n{\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return p * mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nvec2 random2(vec2 st){return -1.0 + 2.0*fract(sin( vec2( dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)) ))*43758.5453123);}\n\nfloat noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 v00 = random2(p+vec2(0,0));\n    vec2 v10 = random2(p+vec2(1,0));\n    vec2 v01 = random2(p+vec2(0,1));\n    vec2 v11 = random2(p+vec2(1,1));\n    return mix( mix( dot( vec2(v00), f - vec2(0,0) ), dot( vec2(v10), f - vec2(1,0) ), u.x ),\n                 mix( dot( vec2(v01), f - vec2(0,1) ), dot( vec2(v11), f - vec2(1,1) ), u.x ), \n                 u.y)+0.5;\n}\n\n// https://gam0022.net/blog/2019/06/25/unity-raymarching/\nfloat deMengerSponge2(vec3 p, vec3 offset, float scale) {\n    vec4 z = vec4(p, 1.0);\n    for (int i = 0; i < 3; i++) {\n        z = abs(z);\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        //if (z.y < z.z) z.yz = z.zy;\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0))) / z.w;\n}\n\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n    return rot(p,-a);\n}\n\nvec2 Polar(vec2 i)\n{\n    vec2 pl = vec2(0.);\n    pl.y = sqrt(i.x*i.x+i.y*i.y)*2.+1.;\n    pl.x = atan(i.y,i.x)/acos(-1.);\n    return pl;\n}\n\nvec3 eyemove(vec3 p)\n{\n    float tt = iTime;\n    \n    p = RotMat(p,vec3(0.3,0.2,0.6),noise(vec2(tt))/4.);\n    p = RotMat(p,vec3(0.1,0.7,0.9),noise(vec2(tt/2.))/4.);\n    p= RotMat(p,vec3(0.,1.,0.),pow(clamp(cos(tt/2.),-.2,.2)*3.,3.));\n    p= RotMat(p,vec3(1.,0.,0.),pow(clamp(sin(tt/3.5),-.3,.3)*1.,3.));\n    p = RotMat(p,vec3(1.,1.,0.),pow(clamp(sin(tt/1.5),-.17,.17)*4.,3.));\n    return p;\n}\n\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(0.);\n    vec3 ee = p;\n    p -= vec3(0.,1.7,7.5);\n    vec3 pp = p;\n    float w = length(ee) - 2.;\n    float w2 = length(ee) - 2.5;\n    float camera = length((ee - cp)/vec3(1.,1.,5.)) - 10.5;\n    ee = eyemove(ee);\n    ee += vec3(0.,0.,.67) ;\n    float soul = min(w,length(ee) - 1.5);\n    pp.xz = rot(pp.xz,t /17.);\n    \n    p = mod(p,18.)-9.;\n    for(int i = 0 ; i< 3; i++)\n    {\n        p.xz = abs(p.xz) - 1.6;\n        p.xy = rot(p.xy, 3. );\n        p.yz = rot(p.yz,5.);\n        p.zx = rot(p.zx,-1.);\n        \n        p.yx = abs(p.yx) - .9;\n        p.zy = rot(p.zy, -7. );\n        p.xz = rot(p.xz,5.);\n        p.xz = rot(p.xz,-1.);\n    }\n    p.xz = rot(p.xz,length(pp.xy) * 1.16 );\n    float menger = deMengerSponge2(p, vec3(1.), 3.);\n    menger = max(menger,-w2);\n    menger = max(menger,-camera);\n    if(OnlyEye)\n    {\n        d = vec2(soul,2.);;\n    }else{\n        \n        vec2 s = vec2(soul,2.);\n    \tvec2 m = vec2(menger * .3,1.);\n        d = (m.x < s.x)?m:s;\n    }\n    //d = m;\n    return d;\n}\nvec2 march(vec3 p,vec3 rd)\n{\n    depth = 0.;\n    vec2 d = vec2(.0);\n    for(int i = 0; i <55; i++)\n    {\n        d = map(p + rd * depth);\n        if(abs(d.x) < 0.001 || d.x > FAR){break;}\n        depth += d.x;\n    }\n\tif(d.x > FAR){d.x = -1.;}\n    return d;\n}\n\nvec3 eyecolor(vec3 p)\n{\n    p = eyemove(p);\n    vec3 w = vec3(.8,0.8,.8);\n    vec3 b = vec3(0.);\n    vec2 P = Polar(p.xy);\n    vec3 i = vec3(1.,1.,0.) * sin(P.y*2. - 3.5);\n    \n    b += i;\n    b *= vec3(1.,1.,1.) * noise(p.xy * 9.) * .5 +.5;\n    vec3 o = mix(w,b,step( length(p.xy),1.15) * step( p.z,.1));\n    return o;\n}\n\nvec3 mengcolor(vec3 p)\n{\n    vec3 b = vec3(0.,.5,1.);\n    b += mix(vec3(0.,0.,0.),b,step(sin(Polar(p.xy).y + p.z + t),0.));\n    return b;\n}\n\n float B(float nh, float roughness)\n{\n    nh *= nh;\n    roughness *= roughness;\n    return exp((nh - 1.) / (roughness * nh))/ (pi * roughness * nh * nh);\n}\n\nfloat C(float nl, float nv, float nh, float vh)\n{\n    return min(1. ,min(2. * nh * nv / vh,2. * nh * nl  / vh ));\n}\n\nfloat fresnelSchlick(float nv, float fresnel)\n{\n    return max(0.,fresnel + (1. - fresnel) * pow(1. - nv, 5.));\n}\n\n\nvoid scene(inout vec3 ocolor,in vec2 f)\n{\n    if( !GetsEvenWorse)cp = vec3(10.,5.,-11.);\n    if(OnlyEye)\n    {\n        cp.xz = rot(cp.xz,-pi/4.);\n    }else{\n    \tcp.z += clamp(sin(iTime/12.),-.9,.1)*10.;\n    \tcp.xz = rot(cp.xz,t/2. - cos(t/2.));\n    }\n    \n    vec2 p = (f.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(vec3(0.,1.,0.),cd));\n    vec3 cu = normalize(cross(cs,cd));\n    \n    float fov = 2.;\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov);\n    vec3 skycolor = vec3(.2,.4,.8);\n    vec3 color = skycolor;\n    \n    vec3 light = normalize(vec3(.8,.4,.2));\n    vec2 d = vec2(-1.);\n    d = march(cp,rd);\n    if(d.x > 0.)\n    {\n        vec2 e = vec2(0.0001,0.);\n        vec3 pos = depth * rd + cp;\n    \tvec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n\n     \n        color = mix(eyecolor(pos),mengcolor(pos),step(d.y,1.));\n        vec3 view = rd;\n        vec3 hlf = normalize(light + view);\n        float nl = dot(N,light);\n        float nv = dot(N,view);\n        float nh = dot(N,hlf);\n        float vh = dot(view,hlf);\n        \n        float fresnel = 2.;\n        float roughness = .1;\n        //vec2(fresnel,roughness)\n        vec2 para = mix(vec2(4.,.07),vec2(3.,.1),step(d.y,1.));\n        \n        float dte = B(nh , para.y);\n        float gte = C(nl,nv,nh,vh);\n        float fte = fresnelSchlick(nv,para.x);\n\n        float sp = max(0.,dte * gte * fte / (nl * nv * 4.) * nl);\n\n        float dif = pow( max(0.,dot(light,N))*.5+.5,2. );\n        color =color * dif + sp * vec3(1.,1.,1.);\n        \n        \n    }\n    ocolor += color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime/2.;\n    depth = 55.;\n    vec3 color = vec3(0.);\n    for(int i = 0;i < AA;i++ )\n    {\n        for(int j = 0; j < AA;j++)\n        {\n            vec2 d = vec2(float(i),float(j)) - vec2(float(i),float(j))/2.;\n            d /= float(AA);\n            scene(color,fragCoord.xy + d);\n        }\n    }\n    color /= float(AA * AA);\n    \n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}