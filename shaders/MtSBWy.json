{
    "Shader": {
        "info": {
            "date": "1520176687",
            "description": "My attempt at creating a gross blob that you can decapitate.\nDecapitate by clicking on the screen and chunks will be removed from the blob.",
            "flags": 32,
            "hasliked": 0,
            "id": "MtSBWy",
            "likes": 22,
            "name": "Blob Decapitation",
            "published": 3,
            "tags": [
                "procedural",
                "sdf",
                "sphere",
                "blob",
                "organic",
                "signeddistancefield",
                "cut",
                "cool",
                "substract",
                "gross",
                "decapitation"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 1120
        },
        "renderpass": [
            {
                "code": "// Decapitate the blob by clicking on the screen\n// Chunks will be taken out of the blob, revealing the insides\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = vec2(1.0) / iResolution.xy;\n\n   \tvec4 cSample = texture(iChannel0, uv);\n        \n\tfragColor = cSample;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 Read(in vec2 loc)\n{\n    return texelFetch(iChannel0, ivec2(loc), 0);\n}\n\nfloat IsInside( vec2 p, vec2 c ) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x,d.y);\n}\n\nvoid Write(in vec2 loc, in vec2 currentLoc, in vec4 data, inout vec4 writeBuffer)\n{\n\twriteBuffer = IsInside(currentLoc, loc) > 0.0 ? data : writeBuffer;\n}\n\nbool IsClick(in vec4 previous, in vec4 current)\n{\n    return previous.z < 0.1 && current.z > 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    vec4 previousMouseState = Read(vec2(0.0));\n    \n    // If we just clicked, write a new cylinder into the buffer\n    if(IsClick(previousMouseState, iMouse))\n    {\n        // Determine where we should write next\n        float count = Read(vec2(0.0, 1.0)).x * (iChannelResolution[0].x - 1.0);\n        count += 1.0;\n        \n        if(count <= iChannelResolution[0].x)\n        {\n            Write(vec2(0.0, 1.0), fragCoord, vec4(count / (iChannelResolution[0].x - 1.0)), fragColor);\n        \n            vec2 mouseUV = iMouse.xy / iResolution.xy;\n\n            float aspect = iResolution.x / iResolution.y;\n            vec2 screenSpace = mouseUV * 2.0 - 1.0;\n\n            vec3 o = vec3(0.0, 0.0, 0.0);\n            vec3 f = vec3(0, 0.0, 1.0);\n            vec3 u = vec3(0,1.0,0);\n            vec3 r = normalize(cross(f, u));\n\n            vec3 d = normalize(f + r * screenSpace.x * aspect + u * screenSpace.y);\n            \n            Write(vec2(count, 1.0), fragCoord, vec4(d, 1.0), fragColor);\n        }\n    }\n    \n    // Store the previous mouse state\n    Write(vec2(0.0), fragCoord, iMouse / vec4(iResolution.xy, iResolution.xy), fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float PI = 3.1415926535;\n\nvec4 Read(in vec2 loc)\n{\n    return texelFetch(iChannel0, ivec2(loc), 0);\n}\n\nfloat Sphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat Cylinder(in vec3 p, in vec3 n, float r)\n{\n    vec3 proj = dot(p, n) * n;\n    return distance(p, proj) - r;\n}\n\nfloat Plane(in vec3 p, in vec3 n, in float d)\n{\n    return  dot(p, n) + d;\n}\n\nfloat SDF(in vec3 p, out vec2 uv)\n{\n    float substract = 100000.0;\n    \n    vec3 sphereP = p - vec3(0.0, 0.0, 1.0);\n    vec3 normP = normalize(sphereP);\n    \n    float radius = 0.5 + sin(iTime * 2.5 + 100.0) * 0.005;\n    float theta = acos(normP.y / 1.0);\n    float phi = atan(normP.z, normP.x);\n    \n    uv = vec2(theta, phi);\n    \n    float height = texture(iChannel1, uv).r;\n    float height2 = texture(iChannel3, uv).g;\n    \n    float count = Read(vec2(0.0, 1.0)).x * (iChannelResolution[0].x - 1.0);\n    for(float i = 1.0; i <= count; i += 1.0)\n    {\n        vec3 d = Read(vec2(i, 1.0)).xyz;\n        substract = min(substract, Cylinder(p, d, 0.15 + height * 0.1));\n    }\n    \n\n    radius += height * (0.02 * (sin(iTime + theta) * 0.5 + 0.5) + 0.02) * max(height, 0.5);\n    \n    float organSDF = Sphere(sphereP, radius + height2 * 0.005);\n    organSDF = max(organSDF, -Sphere(sphereP, 0.4));\n    \n\n    float background = Plane(p, vec3(0.0, 0.0, -1.0), 10.0 + mix(height, height2, sin(iTime) * 0.25 + 0.5));\n    \n    return min(background, max(organSDF, -substract));\n}\n\nvec3 Norm(vec3 p, float s)\n{\n    const float cEps = 0.01;\n \tvec2 uv;\n    \n\treturn normalize\n\t(\tvec3\n\t\t(\tSDF(p + vec3(cEps, 0, 0), uv) - s,\n\t\t\tSDF(p + vec3(0, cEps, 0), uv) - s,\n\t\t\tSDF(p + vec3(0, 0, cEps), uv) - s\n\t\t)\n\t);\n}\n\nvec4 Scene(in vec3 o, in vec3 d)\n{\n    vec4 fc;\n    float s = 0.0;\n    for(float i = 0.0; i < 128.0; i+=1.0)\n    {\n        vec3 p = o + d * s;\n        \n        vec2 objUV;\n        float sdf = SDF(p, objUV);\n        \n        if(sdf < 0.01)\n        {\n            vec3 ld = normalize(vec3(0.707, 0.707,-0.3));\n           \tvec3 norm = Norm(p, sdf);\n           \tfloat l = max(dot(ld, norm),0.0)*0.95+0.05;\n            \n            float height = texture(iChannel1, objUV).r;\n            float swimmingHeight = texture(iChannel1, objUV - vec2(0.0, iTime * 0.01)).r;\n            \n            float spec = pow(dot(reflect(-ld, norm), -d) * 0.5 + 0.5, 50.0) * pow(height, 3.0);\n            spec *= max(8.0-p.z,1.0);\n            \n            vec3 refl = reflect(d, norm);\n            vec4 reflection = pow(texture(iChannel2, refl), vec4(2.2));\n            \n            vec4 specColor = spec * reflection;\n           \n            vec4 peakColor = mix(vec4(5.0, 0.0, 0.0, 1.0), reflection, 0.5 * swimmingHeight);\n            fc = mix(vec4(0.1,0.1,0.0,0.0), peakColor, height)/PI * l;\n            fc += specColor;\n            \n            vec4 backgroundColor = vec4(0.2, 0.6, 0.5, 1.0)/PI*0.7;\n            float isBackground = 1.0 - step(s / 20.0, 0.5);\n            \n            fc = mix(fc, (fc*backgroundColor) * (1.0 - s / 30.0), isBackground);\n            break;\n        }\n        s += sdf * 0.5;\n    }\n    return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\n\tvec3 o = vec3(0.0, 0.0, (cos(iTime * 0.5) * 0.5 + 0.5) * 0.2);\n    vec3 f = vec3(0, 0.0, 1.0);\n    float upTime = sin(iTime) * 0.1;\n    vec3 u = vec3(sin(upTime),cos(upTime),0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 d = normalize(f + r * screenSpace.x * aspect + u * screenSpace.y);\n    \n    vec4 fc = vec4(0.4, 0.5, 0.8, 1.0) * (1.0 + uv.x * uv.y);\n    float delta = 0.001;\n    \n\tfc = Scene(o, d);\n\n\tfragColor = pow(fc,vec4(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}