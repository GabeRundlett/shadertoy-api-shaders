{
    "Shader": {
        "info": {
            "date": "1657474292",
            "description": "an improvement with two less texture lookups of Catlike Coding's Direction Flow [url]https://catlikecoding.com/unity/tutorials/flow/directional-flow/ [/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "7dtBWl",
            "likes": 11,
            "name": "Directional Flow Square",
            "published": 3,
            "tags": [
                "wave",
                "water",
                "hexagon",
                "flow",
                "hex",
                "directional",
                "dodecahedron",
                "vectorfield",
                "direction",
                "rohmbic",
                "rhom"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 394
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nThis is an improvement of my Hex Directional Flow. It uses a slightly different\ngird structe that is a lot faster to compute. I think it has the same quality \nas the hexagon grid. Hexagon just uses a equilateral triangle, while square uses\na right triangle.\n\nDirectional Flow animates and rotates a texture in multiple directions with \na flowmap. This means that water wave textures can flow in multiple directions \nat the same time, while the waves point in the right direction. This is not \npossible with trational flow animation, which either has only one wind \ndirection or stretches the texture with temporal blending. The Directional Flow\ndoes this by blending in the spatial dimension. \n\nThe slightly slower Hex Directional Flow is implemented in shadertoys here:\nhttps://www.shadertoy.com/view/fsGyDG\n\nThe classic 8 sample Directional Flow is implemented in shadertoys here:\nhttps://www.shadertoy.com/view/fsKczd\n\nHere is my Rhombic Dodecahedron Tiling to have Hex Directional Flow in 3D:\nhttps://www.shadertoy.com/view/fddfRn\n\nHere is a diffeent use case with cyclone windwaves:\nhttps://www.shadertoy.com/view/7dycDV\n\nThe earliest iteration of directional flow I could find is from 2010:\nhttps://www.rug.nl/society-business/centre-for-information-technology/research/hpcv/publications/watershader/\nBut CatlikeCoding's version is much better explained, so I recommend reading \nit as a guide:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n*/\n\n// #define ShowGrid\n\n// Square tiling function, 0 and negative values don't work\ntilingVal squareTile(vec2 uv) {\n    vec2 grid = fract(uv) - 0.5;   // the cell coordinates in the grid\n\n    vec2 distanceFromCenter = abs(grid);\n    float edgeDist = (0.5 - max(distanceFromCenter.x, distanceFromCenter.y)) * 2.0;\n\n    vec2 id = uv - grid;  // ID values for the cell\n\n    return tilingVal(grid, id, edgeDist);  // make tilingVal struct\n}\n\n// makes a square pixelized pattern\ntilingVal squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    // generate square grid tiling\n    tilingVal tiling = squareTile(uv * gridRes + offset); \n    // generate square grid tiling    \n    tiling.id = (tiling.id - offset)/gridRes; //pixaltion    \n    return tiling;\n}\n\n// Rhombus tiling function\ntilingVal rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;    \n    vec2 grid = dot(a,a) < dot(b,b) ? a : b; //UV centered in cell\n    \n    vec2 ma = abs(a);\n    vec2 mb = abs(b);\n    float eDist = (max(ma.x+ma.y,mb.x+mb.y)-0.5)*2.; //Edge Distance\n    \n    // adding tiny offset to prevent floating point errors\n    vec2 id = uv - grid  + 0.0000001; //ID values\n    return tilingVal(grid, id, eDist);  // make tilingVal struct\n}\n\n// makes a rhombic pixelized pattern without offset\ntilingVal rhomPixelizor(vec2 uv, float gridRes) {\n    // generate square grid tiling\n    tilingVal tiling = rhomTile(uv*gridRes);    \n    tiling.id = tiling.id / gridRes; //pixaltion    \n    return tiling;\n}\n\n// 3 pixaled flowing textures thier edges get hidden by each other\nvec3 squareDirectionalFlow(sampler2D tex, sampler2D flow, vec2 uv, \n                           float gridRes, float time, float contrast) { \n    // generate grid values\n    tilingVal A = squarePixelizor(uv, gridRes, vec2(0.)); // grid A    \n    tilingVal B = squarePixelizor(uv, gridRes, vec2(0.5)); // grid B offset to corner A\n    tilingVal C = rhomPixelizor(uv, gridRes); // grid C\n\n    // sample flow map in each grid\n    vec2 flowA = flowMap(flow, A.id);\n    vec2 flowB = flowMap(flow, B.id);\n    vec2 flowC = flowMap(flow, C.id);\n            \n    // scale UVs so the entire texture is visible in a tile\n    // the proper range is ~1-3 and artists don't read, so constant\n    A.grid *= 2.0;\n    B.grid *= 2.0;\n    C.grid *= 2.0;\n    \n    // rotate and offset then sample texture\n    vec3 gridA = PanDirectionalTex(tex, A.grid, flowA, time);\n    vec3 gridB = PanDirectionalTex(tex, B.grid, flowB, time);\n    vec3 gridC = PanDirectionalTex(tex, C.grid, flowC, time);\n    \n    //All edgeDist added = 1 -> so we can skip the more expensive C calculation\n    vec3 alpha = vec3(A.edgeDist, B.edgeDist, 1.-(A.edgeDist + B.edgeDist)); \n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // interpolate result\n    vec3 col = gridA * alpha.x + gridB * alpha.y + gridC * alpha.z;\n    \n#ifdef ShowGrid\n    // overlaying the edges of the alpha mask\n    float lineThickness = 0.03; // must be smaller than 0.1\n    vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n    return max(mask, col);\n#else\n    return col;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime* .4; // flow speed multiplier\n    float gridRes = 8.; // the number of subdivisions for the sampling of the flowmap\n    float contrast = 2.;  // 1-inf, increased the contrast between the tiles\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n\n    vec3 sdf = squareDirectionalFlow(iChannel0, iChannel1, uv, gridRes, time, contrast);\n\n#ifndef  ShowGrid   \n    sdf += vec3(0.0,0.2,0.5); //adding arbitrary watery color\n#endif\n    \n    fragColor = vec4(sdf, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal {\n    vec2 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec2 id;         // ID values\n    float edgeDist;  // Edge distance from the cell's center to its boundaries\n};\n\n// rotates UV by direction\nvec2 rotateUV(vec2 uv, vec2 direction)\n{\n    // Normalize the direction vector\n    direction = normalize(direction);\n\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2(\n        direction.x, -direction.y,\n        direction.y, direction.x\n    );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// rotates and animates texture in flowmap direction \nvec3 PanDirectionalTex (sampler2D sam, vec2 uv, vec2 flowMap, float time) {  \n    uv += flowMap*time; // add offset with time\n\n    uv = rotateUV(uv, flowMap); // rotate UVs\n    \n    return texture(sam, uv).xyz; // sample texture\n}\n\n// generates a -1-1 smooth flowmap\nvec2 flowMap(sampler2D sam, vec2 uv) {\n    //a random spot in the noise map, normally you use an actual flowmap\n    vec2 flowMap = texture(sam, uv*0.05).xy;\n    return flowMap * 2. -1.; // constant bias scale for -1 to 1 range\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}