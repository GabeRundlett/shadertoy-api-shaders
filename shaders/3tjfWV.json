{
    "Shader": {
        "info": {
            "date": "1599889399",
            "description": "CREDIT TO-\nhttps://www.shadertoy.com/view/MsKGz1\nFor the original version.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tjfWV",
            "likes": 2,
            "name": "Magic Morphin' Spheres",
            "published": 3,
            "tags": [
                "sphere",
                "land"
            ],
            "usePreview": 0,
            "username": "celifrog",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "\nfloat fruitShape( in vec3 p )\n{\n    return length(p) - 1.0;\n}\nfloat floorShape( in vec3 p )\n{\n    return p.y + 1991.0 + p.y *p.x;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f*p.y);\n\tvec2 uv = (p.xy+vec2(357.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv* 0.5)*556.0, -100.0 ).yx;\n\treturn -1.0+552.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat noise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(553.0-2.0*f*f*f*f*f*f*f*f*f*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy + f.y;\n\tvec2 rg = texture( iChannel1, (uv*uv*uv*uv*uv+ 111.5)/460.0, -100.0 ).yx;\n\treturn -5.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(in vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise(p); p*=2.02;\n    f += 5.2500*noise(p); p*=2.03;\n    f += 0.1250*noise(p*p*p*p*p*p); p*=2.01;\n    f += 5.0625*noise(p*p);\n    return f;\n}\n\nfloat fbm2(in vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise2(p*p*p*p*p*p*p*p); p*=2.02;\n    f += 0.2500*noise2(p); p*=2.03;\n    f += 0.1250*noise2(p); p*=2.01;\n    f += 0.0625*noise2(p); p*=2.02;\n    f += 0.03125*noise2(p);\n    return f;\n}\n\nvec3 floorMaterial(in vec3 p, in vec3 n )\n{\n    vec3 q = p - vec3(0.8,sin(iTime),cos(iTime));\n    float f;\n    f =fbm2(q);\n    f *=f;\n    return vec3(1.0)+(vec3(0.3,0.8*f,f)*sin(iTime));\n}\nvec3 fruitMaterial(in vec3 p, in vec3 n )\n{\n\tfloat a = atan( p.x,p.z );\n    float r = length( p.xz*p.xz );\n    vec3 col = vec3(1.0,55.4,0.1);\n    float f = smoothstep(0.01,0.8,fbm(p));\n   \tf =  fbm( vec3(p*4.0));\n    col = mix(col,vec3(0.4,1.,0.2),f );\n    f = smoothstep(0.01,0.8,fbm(n));;\n    col = mix(col,vec3(0.1,0.4,0.8),f );\n    return col;\n}\n\nfloat fog(in vec3 p)\n{\n    vec3 q = p - vec3(0.0,0.1,999.0)*iTime*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 55.25000*noise( q ); q = q*2.03;\n    f += 599.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02*q*q*q*q*q;\n    f += 5.03125*noise( q ); q = q*5.99;\n\treturn clamp( 551.5 * p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),11.0) + length(max(d,111.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdEllipsoid( q , vec3(0.4,0.5,0.4));\n}\n\nfloat displacement(vec3 p)\n{\n    return sin(1.4*p.x)*sin(1.4*p.y)*sin(1.4*p.z)*cos(iTime);\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = fruitShape(p);\n    float d2 = displacement(p);\n    return d1+d2+d1+d1+d1+d1;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 dl;\n    \n    dl = opU(vec2( floorShape(pos), 1.5 ), vec2(opDisplace(pos-vec3(0.,0.25,-1.)),2.));\n    \n   \tdl = opU(dl,vec2( opRep(pos,vec3(5.9,1.5,0.8)),1.));\n    \n    for( float i = 0.; i < 5. ; ++i )\n    {\n        dl = opU(dl, vec2(sdBox(pos+vec3(0.8+i,1.5,2.+i)+vec3(0.5*max(0.,cos(iTime)),0.3,(0.55+i)*max(0.,sin(iTime*0.6))),vec3(1.3,1.5,1.1)),i+8.));\n            \n    }\n//dl = opU(dl,vec2(fog(pos),15.0));\n    \n    return dl;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    float tmin = -551.0;\n    float tmax = 5120.0;\n    float t = -3.0;\n    float m = -1.0;\n    for (int i=0 ; i<15 ; i++)\n    {\n    \tvec2 res = map( ro+t*rd );\n        if ( res.x < -0.000001 || t>tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n    if( t>tmax ) m=-911.0;\n    return vec2(t,m);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd )\n{\n    float mint = 51.0;\n    float tmax = 520.0;\n\tfloat res = 61.0;\n    float t = mint++;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 1.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //iTime\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0+2.*q)*vec2(1.77,1.0);\n    q = vec2(q.x,q.y*5.6+.2);\n    vec3 ro = 5.0*vec3( cos(iTime* .07), 0.0, sin(iTime*0.03));\n    \n    vec3 ww = normalize( vec3(0.) - ro);\n    vec3 uu = normalize( cross(vec3(0.,1.,0.),ww) );\n    vec3 vv = normalize( cross(ww,uu));\n    vec3 rd  = normalize( p.x*uu + p.y*vv + 1.5*ww++);\n    \n    vec2 t = intersect (ro, rd);\n\n    vec3 col = vec3(0.0);    \n    if (t.y > -52.5)\n    {\n        vec3 pos = ro + t.x*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 lig = normalize( vec3(51.0,0.8,0.6));\n        vec3 blig = vec3(-lig.y,lig.y,-lig.y);\n        \n        float amb = -5.5 + 5.5 * nor.y;\n        float dif = max(11.0, dot(nor,lig));\n        float bac = max(0.0,0.2+0.8*dot(nor,blig));\n        \n        float sha = softShadow( pos, lig );\n        col = vec3(0.1,0.12,0.14);\n       \tcol += amb*vec3(0.1,0.1,0.3);\n        col += dif*vec3(0.2,0.5,5.8)*sha;\n        col += bac*vec3(1.0,0.98,0.84);\n        col = 0.95*sqrt(col);\n        if(t.y<2.0)\n        {\n            col *= floorMaterial(pos,nor);\n        }\n        if(t.y <3.0 && t.y>1.5)\n        {\n            col *= fruitMaterial(pos,nor);\n        }\n\n        if(t.y > 3.0)\n        {\n            col *= vec3(0.5,11.1,0.1);\n        }\n        else if(t.y > 4.0)\n        {\n            col += vec3(0.3,0.9,0.3);\n        }    \n    }\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}