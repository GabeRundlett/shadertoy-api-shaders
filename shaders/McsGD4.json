{
    "Shader": {
        "info": {
            "date": "1703091706",
            "description": "This is a lookup texture (LUT) for planetary rings used in CosmosJourneyer. More informations about the creation of this texture can be found at http://barthpaleologue.github.io/Blog/posts/making-shaders-faster-1/",
            "flags": 0,
            "hasliked": 0,
            "id": "McsGD4",
            "likes": 1,
            "name": "Planetary rings lookup texture",
            "published": 3,
            "tags": [
                "rings",
                "planet",
                "lut"
            ],
            "usePreview": 0,
            "username": "barth",
            "viewed": 252
        },
        "renderpass": [
            {
                "code": "const float seed = 0.0; // noise offset for unique rings\nconst float frequency = 30.0; // noise frequency\nconst float ringStart = 2.0; // relative distance where the ring starts\nconst float ringEnd = 3.0; // relative distance where the ring ends\n\n\nfloat mod289(float x){ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x){ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 perm(vec4 x){ return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat noise(float r) {\n    float a = floor(r);\n    float d = r - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = vec4(a) + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + vec4(a);\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d + o1 * (1.0 - d);\n    vec2 o4 = o3.yw * d + o3.xz * (1.0 - d);\n\n    return o4.y * d + o4.x * (1.0 - d);\n}\n\n\nfloat fbm(float r, int nbOctaves, float decay, float lacunarity) {\n    float totalAmplitude = 0.0;\n    float amp = 1.0;\n    float samplePointMultiplier = 1.0;\n    float value = 0.0;\n    for (int i = 0; i < nbOctaves; i++) {\n        amp /= decay;\n        samplePointMultiplier *= lacunarity;\n        totalAmplitude += amp;\n        value += amp * noise(r * samplePointMultiplier);\n    }\n    return value / totalAmplitude;\n}\n\n// remap a value comprised between low1 and high1 to a value between low2 and high2\nfloat remap(float value, float low1, float high1, float low2, float high2) {\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // reversed remapping\n    float relativeDistance = remap(uv.x, 0.0, 1.0, ringStart, ringEnd);\n\n    // layer noise to get a more interesting result\n    float macroRingDensity = fbm(fract(seed) + relativeDistance * frequency / 10.0, 1, 2.0, 2.0);\n    float ringDensity = fbm(fract(seed) + relativeDistance * frequency, 5, 2.0, 2.0);\n    ringDensity = mix(ringDensity, macroRingDensity, 0.5);\n\n    // fade out the ring at the start and the end\n    ringDensity *= smoothstep(ringStart, ringStart + 0.03, relativeDistance);\n    ringDensity *= smoothstep(ringEnd, ringEnd - 0.03, relativeDistance);\n\n    // accentuate density gradient\n    ringDensity *= ringDensity;\n\n\n    // Output to screen\n    fragColor = vec4(vec3(ringDensity),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}