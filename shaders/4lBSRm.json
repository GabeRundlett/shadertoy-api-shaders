{
    "Shader": {
        "info": {
            "date": "1442326306",
            "description": "Major functions from other shaders. \nTested on mac. I think that there is difference in processing music volume with WebAudio API on win and osx. \nVolume from iChannel is  lower on mac.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lBSRm",
            "likes": 32,
            "name": "â™« Cube Music Transmitter",
            "published": 3,
            "tags": [
                "raymarching",
                "distortion",
                "chaos",
                "megabump"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 1632
        },
        "renderpass": [
            {
                "code": "#define max_distance 10.0\n#define epsilon 0.01\n#define max_steps 48\n#define K 0.07\n#define shininess 140.0\n#define ambient 0.5\n#define bump_factor 1.00\n#define specular_koef 1.5\n\n#define FOV 60.0\n#define PI 3.1415\n\nfloat diffuse_koef = 5.;\n\nfloat message(vec2 uv) { // there is music channel in shader :)\n    uv-=vec2(2.,3.); if ((uv.x<0.)||(uv.x>=8.)||(uv.y<0.)||(uv.y>=6.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(8.-uv.x)));\n    if (int(uv.y)==5) i=  12/bit; \n    if (int(uv.y)==4) i=  10/bit;\n    if (int(uv.y)==3) i=  8/bit; \n    if (int(uv.y)==2) i=  56/bit;\n    if (int(uv.y)==1) i= 104/bit;\n    if (int(uv.y)==0) i= 50/bit; \n \treturn float(i-2*(i/2));\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0 ;\n    return fract(cos(f*3.333)*1003.9);\n}\nvec4 getFreq(float f){\n    // first texture row is frequency data\n\tfloat fft  = texture( iChannel1, vec2(f, 0.25) ).x; \n    float fft2  = texture( iChannel1, vec2(f + 0.03, 0.25) ).x; \n\t\n    // second texture row is the sound wave\n\tfloat wave = texture( iChannel1, vec2(f, 0.75) ).x;\n\t\n\t// convert frequency to colors\n\tvec3 col = vec3( fft, 4.0 * fft * (1.0 - fft), 1.0 - fft ) * fft;\n    col = mix(col, vec3( fft2, 4.0 * fft2 * (1.0 - fft2), 1.0 - fft2 ) * fft2, vec3(0.55));\n    \n    \n    return vec4(col, 1.0);\n    //return vec4(0);\n}\n\n\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale) {\n\treturn \n\t\ttexture(t, p.yz * scale) * abs (n.x) +\n\t\ttexture(t, p.xz * scale) * abs (n.y) +\n\t\ttexture(t, p.xy * scale) * abs (n.z);\n}\n\n\n\nvec2 udBox( vec3 p, vec3 b ) {\n  return vec2(\n      length(max(abs(p)-b,0.0)),\n      1.0\n  );\n}\n\nvec2 udPlane( vec3 p, vec3 b) {\n    return vec2(\n        dot(p, b) + 0.9,\n        2.0\n     ); \n}\n\nvec2 opUnion( vec2 obj1, vec2 obj2 )\n{\n    if (obj1.x <= obj2.x) return obj1;\n    return obj2;\n}\n\n\nvec2 get_distance(vec3 point) {\n\tfloat bump = 0.0;\n\n    float y = point.y;\n    float x = point.x;\n    float z = point.z;\n        \n    bump =  min(\n         sin(iChannelTime[1]) * ((cos(y) / sin(x * z / (1.0 - sin(iChannelTime[1] / 60.) ))) / sin(x + getFreq(0.1).r + getFreq(0.2).r ))\n        , 2.0\n       ) / 32.0;\n    \n    \n    \n    float fr03 = getFreq(0.3).r * 10. * sin(iChannelTime[1] / 120.);\n    \n    vec3 size = vec3(0.8) + vec3(fr03 * sin(fr03) * 10.0, -getFreq(0.12).r * 2.0 * getFreq(0.35).r * 6.0, 0.1) ;\n    \n    vec2 box = udBox(point + vec3(0, -0.1, 0.0), size);\n    \n    \n    vec2 plane = udPlane(point,  vec3(0.0, 1.0, 0.0));\n\n    vec2 unified = opUnion(\n\t\t box + vec2((bump * (1.5) * getFreq(0.1).g), 0.0),\n\t\t plane\n\t);\n        \n    return unified;\n     \n    \n}\n\nvec2 raymarch(vec3 ray_origin , vec3 ray_direction) {\n\t \n    float d = 1.0;\n\tvec2 gd = vec2(0);\n\tfor (int i = 0; i < max_steps; i++) {\n\t\tvec3 new_point = ray_origin + ray_direction*d;\n        gd = get_distance(new_point);\n\t\tfloat s = gd.x;\n\t\tif (s < epsilon) return vec2(d, gd.y);\n\t\td += s * 0.8;\n\t\tif (d > max_distance) break;\n\t}\n\treturn vec2(max_distance, gd.y);\n}\n\nvec3 get_normal(vec3 point) {\n\tfloat d0 = get_distance(point).x;\n\tfloat dX = get_distance(point-vec3(epsilon, 0.0, 0.0)).x;\n\tfloat dY = get_distance(point-vec3(0.0, epsilon, 0.0)).x;\n\tfloat dZ = get_distance(point-vec3(0.0, 0.0, epsilon)).x;\n\t\t\n\treturn normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nmat3 rotateY(float fi) {\n\treturn mat3(\n\t    cos(fi), 0.0, sin(fi),\n\t  \t0.0, 1.0, 0.0,\n\t\t-sin(fi), 0.0, cos(fi)\n\t);\n}\n\nmat3 rotateX(float fi) {\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, cos(fi), -sin(fi),\n\t\t0.0, sin(fi), cos(fi)\n\t);\t\n}\n\nfloat shadow_sample (vec3 org, vec3 dir) {\n    float res = 1.0;\n    float t = epsilon * 200.0;\n    for (int i =0; i < 100; ++i){\n        float h = get_distance (org + dir*t).x;\n\t\tif (h <= epsilon) {\n            return 0.0;\n\t\t}\n        res = min (res, 32.0 * h / t);\n        t += h;\n\t\tif (t >= max_distance) {\n      \t\treturn res;\n\t\t}\n\t\t\n    }\n    return res;\n}\n\nvec4 renderAll(in vec2 fragCoord) {\n    vec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tuv *= tan (radians (FOV + getFreq(0.0).r * 20.0)/2.0);\n\t\n    vec4 fragColor;\n    \n    float c=message(fragCoord.xy/2.); \n    if (c >= 0.1) {fragColor=vec4(c);return fragColor;}\n    \n\tvec4 color = vec4(0.0);\n\t\n\tvec3 light = vec3(sin(getFreq(.5).g) * 4.0, 4.0 - getFreq(.5).g, sin(iTime) * 4.0);// * rotateY(iTime*2.0) ;\n\tmat3 rotated = rotateY(iTime );\n\t\n\tvec3 eye_pos = \n        rotated * vec3(getFreq(.1).r * 1.0, -0.2, -4.0) \n        + vec3(0, sin(iTime / 4.) / 2. + .35 + getFreq(0.3).r, 0.)\n    ;\n    \n\tvec3 up = vec3(0.0, 1.0, 0.20);\n\tvec3 forward = rotated * vec3(0.0, 0.0, 1.0);\n\tvec3 right = cross(up, forward);\t\n\t\n\tvec3 ray_dir = normalize(up * uv.y + right *uv.x + forward);\n\n\tvec2 rm = raymarch(eye_pos, ray_dir);\n    float d = rm.x;\n    \n\tvec3 point = (eye_pos+ray_dir*d);\t\t\t\n\t\n\tif (d < max_distance) {\t\t\n\t\tvec3 point_normal = get_normal(point);\n\t\t\n\t\tvec3 light_dir = -normalize(light-point);\n\t\tvec3 reflected_light_dir = reflect(-light_dir, point_normal);\n\t\tfloat attenuation = 1.0 / (1.0 + K*pow( length(light - point), 2.0));\n\t\t\t\n\t\tfloat dotp_diffuse = max(0.0, dot(light_dir, point_normal));\n\t\tfloat dotp_specular = pow(max(0.0, dot(ray_dir, reflected_light_dir)), shininess);\n\t\t\n\t\tif (dotp_diffuse <= 0.0) dotp_specular = 0.0;\n\t\t\n        diffuse_koef = getFreq(0.01).g * 8.0;\n        \n\t\tfragColor = vec4(1.0, 1.0, 1.0, 1.0) * (ambient + (dotp_diffuse*diffuse_koef + dotp_specular*specular_koef) * shadow_sample(point, -light_dir) * attenuation);\n        if (rm.y == 2.0) fragColor *= texture3d(iChannel2, point * 2., point_normal, 0.5);\n        if (rm.y == 1.0) fragColor *= texture3d(iChannel0, point, point_normal, 0.5);\n        fragColor *= fragColor * fragColor;//if (uv.x > 0.)  fragColor = vec4(1.) - min(fragColor, 1.);\n\t} else {\t\t\t\n\t    fragColor = vec4(0.01) + floor(getFreq(0.41).g * 3.0);\t\n\t} \n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    fragColor = renderAll(fragCoord).rrrr + vec4(1. - Hash2d(uv * iTime)) / 8.0;\n    \n     \n}     ",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}