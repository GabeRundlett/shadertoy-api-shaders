{
    "Shader": {
        "info": {
            "date": "1515172632",
            "description": "Escher's box. drag to move camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml2BRm",
            "likes": 24,
            "name": "Escher's box",
            "published": 3,
            "tags": [
                "illusion",
                "escher",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "keim",
            "viewed": 1050
        },
        "renderpass": [
            {
                "code": "precision highp float;\n vec2  resolution, mouse;\n float time;\n\nconst vec3 V  = vec3(0,.001,100);\nconst vec3 BG = vec3(0.0);\nconst vec3 Amb= vec3(0.01);\nconst vec3 PI = vec3(1.5707963,3.1415927,6.2831853);\nconst float BPM = 120.;\nvec2 uv;\nfloat tick;\n\nfloat rnd(vec3 s){s=fract(s*443.8975);s+=dot(s,s.yzx+19.19);return fract(s.x*s.y*s.z);}\nvec4  gamna(vec3 c){return vec4(pow(c,vec3(1./2.2)),1);}\nvec3  hsv(float h,float s,float v){return((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nmat3  camera(vec3 p, vec3 t, vec3 h){vec3 w=normalize(p-t),u=normalize(cross(w,h));return mat3(u,normalize(cross(u,w)),w);}\nmat3  euler(float h, float p, float r){float a=sin(h),b=sin(p),c=sin(r),d=cos(h),e=cos(p),f=cos(r);return mat3(f*e,c*e,-b,f*b*a-c*d,f*d+c*b*a,e*a,c*a+f*b*d,c*b*d-f*a,e*d);}\nfloat dfPln(vec3 p, vec3 n, float d){return dot(p,n)+d;}\nfloat dfBox(vec3 p, vec3 b, float r){return length(max(abs(p)-b,0.))-r;}\nfloat dfDdc(vec3 p, float r) {vec4 v=vec4(-.8507,.8507,.5257,0);return max(max(abs(dot(p,v.wyz)),max(abs(dot(p,v.wxz)),abs(dot(p,v.zwy)))),max(abs(dot(p,v.zwx)),max(abs(dot(p,v.yzw)),abs(dot(p,v.xzw)))))-r;}\n\nconst vec3 r = vec3(4.8,0.1,0.3), t = vec3(4,-4,0);\n\nvec3 trans(vec3 p) {\n    return (p - vec3(0,10,0)) * euler(tick/21.*PI.z,tick/16.*PI.z,0.0);\n}\n\nfloat trick(vec3 p) {\n    float d = V.z;\n    p = trans(p);\n    d = min(d, dfBox(p-t.yzy, r.yxy, r.z));\n    return d;\n}\n\nfloat map(vec3 p, bool trick) {\n    mat3 rot = euler(-tick/3.*PI.z,tick/5.*PI.z,0.0);\n    float d = dfPln(p, vec3(0,1,0), 0.);\n    p = trans(p);\n    d = min(d, dfDdc((p+vec3(sin(tick/8.*PI.z)*10.,0.,cos(tick/16.*PI.z)*8.))*rot, 1.5));\n    d = min(d, dfDdc((p+vec3(cos(tick/16.*PI.z+PI.x)*8.,sin(tick/8.*PI.z+PI.y)*8.,0.))*rot, 1.));\n    d = min(d, dfBox(p-t.zxy, r.xyy, r.z));\n    d = min(d, dfBox(p-t.zyy, r.xyy, r.z));\n    d = min(d, dfBox(p-t.xzx, r.yxy, r.z));\n    d = min(d, dfBox(p-t.yzx, r.yxy, r.z));\n    d = min(d, dfBox(p-t.xzy, r.yxy, r.z));\n    d = min(d, dfBox(p-t.yzy, r.yxy, r.z));\n    d = min(d, dfBox(p-t.yxz, r.yyx, r.z));\n    d = min(d, dfBox(p-t.yyz, r.yyx, r.z));\n    if (trick) {\n        d = min(d, dfBox(p-t.zxx, r.xyy, r.z));\n        d = min(d, dfBox(p-t.zyx, r.xyy, r.z));\n        d = min(d, dfBox(p-t.xxz, r.yyx, r.z));\n        d = min(d, dfBox(p-t.xyz, r.yyx, r.z));\n    }\n    return d;\n}\n\nvec3 background(vec3 pos, vec3 dir, inout float bld) {\n    bld = 0.;\n    return BG;\n}\n\nvec3 diff(vec3 nml, vec3 lit, vec3 col){return max(dot(nml,lit)*col,0.);}\nfloat shad(vec3 pos, vec3 lit){float s=V.z,t=.05,d;for(int i=20;i!=0;--i){t+=max(d=map(pos+lit*t, true),.05);s=min(s,d/t);if(t>20.)break;}return clamp(s*.2,0.,1.);}\nfloat occl(vec3 pos, vec3 nml){float s=0.;for(float t=.01;t<.5;t+=.05){s+=t-map(pos+nml*t, true);}return clamp(1.-s*.1,0.,1.);}\n\nbool tricktrace(vec3 pos, vec3 dir) {\n    float t = 0., d;\n    for (int i=80; i!=0; --i) {\n        t += (d = trick(pos + dir * t));\n        if (d < V.y) break;\n        if (t > V.z) return true;\n    }\n    return false;\n}\n\nvec3 trace(inout vec3 pos, inout vec3 dir, inout float bld) {\n    float t = 0., d;\n    bool trick = tricktrace(pos, dir);\n    for (int i=80; i!=0; --i) {\n        t += (d = map(pos + dir * t, trick));\n        if (d < V.y) break;\n        if (t > V.z) return bld * background(pos, dir, bld);\n    }\n    vec3 p = pos + dir * t;\n    vec3 n = normalize(vec3(map(p+V.yxx, true),map(p+V.xyx, true),map(p+V.xxy, true))-map(p, true));\n    vec3 c = vec3(1);\n    vec3 ldir = normalize(vec3(sin(tick/24.*PI.z)*20.,20.,cos(tick/24.*PI.z)*20.) - p);\n    vec3 lcol = diff(n, ldir, hsv(tick/16.,0.5,1.0)*10.) * shad(p, ldir) * occl(p, n) + Amb;\n    vec3 ldir2 = normalize(vec3(0.,25,0.) - p);\n    vec3 lcol2 = diff(n, ldir2, hsv(tick/16.+0.33,0.5,1.0)*10.) * shad(p, ldir2) * occl(p, n) + Amb;\n    vec3 col = c * (lcol + lcol2);\n    float b=bld*.4;\n    pos = p + n*V.y;\n    dir = reflect(dir, n);\n    bld *= .6;\n    return mix(col, BG, clamp(length(p.xz)/24.,0.,1.))*b;\n}\n\nvec3 render(in vec3 pos, in vec3 dir) {\n    float b = 1.;\n    vec3 col = trace(pos, dir, b);\n    if (b > V.y) col += trace(pos, dir, b);\n    if (b > V.y) col += trace(pos, dir, b);\n    return col;\n}\n\nvec4 entryPoint(vec2 fragCoord) {\n    uv = (fragCoord * 2.-resolution) / resolution.y;\n    tick = time * BPM / 60.;\n\n    float scan = 1., dist = 0.;\n    vec3 pos = vec3(25.,18.,0.);\n    if (iMouse.z > 0.5) {\n        vec2 r = mouse/resolution*2.-1.;\n        pos = vec3(cos(r.x*PI.y)*25.,r.y*12.+18.,sin(r.x*PI.y)*25.);\n    }\n    vec3 dir = camera(pos, vec3(0,7.5,0), vec3(0,1,0)) * normalize(vec3(uv+vec2(dist,0),-2));\n    return gamna(render(pos, dir)) * scan;\n}\n\nvoid mainImage(out vec4 flagColor,in vec2 flagCoord) {\n    resolution = iResolution.xy;\n    time = iTime;\n    mouse = iMouse.xy;\n    flagColor = entryPoint(flagCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}