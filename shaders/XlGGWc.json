{
    "Shader": {
        "info": {
            "date": "1477040662",
            "description": "social simulation : urban segregation (see [url]http://ncase.me/polygons/[/url])\n\"I want to move if less than 33% of my neighbors are like me\". (val def in bufB)\nParadox: small intolerance, big effects.\n\nimplement non-local automata - requires scattering\n",
            "flags": 32,
            "hasliked": 0,
            "id": "XlGGWc",
            "likes": 6,
            "name": "social simulation",
            "published": 3,
            "tags": [
                "simulation",
                "scattering",
                "automata",
                "ising",
                "social",
                "simulatedannealing"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1129
        },
        "renderpass": [
            {
                "code": "// social simulation : urban segregation, inspired by http://ncase.me/polygons/\n// non-local automata - requires scattering of cells\n// Tune INTOLERANCE in bufB\n\n// principle: unhappyness relates to neighborhod not of your kind, clamped to INTOLERANCE threshold\n// -> we iteratively search and swap invmax(greens) and invmax(reds). \n// (indeed color=sign , signed unhappyness too -> greens correspond to - and invmin ) \n\n#define D 2.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O *= 0.;\n    U.x -= (R.x-R.y)/2.;                                // centering\n    U *= 64./R.y; U.y += D;                             // mapping data\n\n    if ( U.x >= 0. && U.x < 64.+D )\n     // O = floor(mod(R.y*U.xyxy/R.y, 10.))/9.; return; // test mapping\n        O = texture(iChannel1,U/R),                   // x: value   y: unhapiness (signed)\n     // O.x = sign(O.x),                                // type of inhabitant (=sign)\n        O.x = sign(O.x)*(.5+.5*abs(O.x)),               // personalize with his value (noise)\n        O = vec4(O.x,-O.x, 0.*abs(O.y),1);              // show population kind\n     // O = vec4(O.y,-O.y,\t0,1)*4.;                    // show weight (use iChannel1 !)\n}\n\n\n// turn Channel1 to nearest to see the cells.",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// - random field\n// - compute min/max + invmin/invmax - first part\n// - swap invmin, invmax   ( NB: min = max within negative population )\n\n#define D 2.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (max(U.x,U.y) > 64.+D) return;\n    \n    // --- init field\n    if (iFrame < 10) { O.x = -1.+2.*texture(iChannel1,(U-D)/64.).r; return; }\n  //if (iFrame < 10) { O.x = -1.+2.*length(texture(iChannel1,(U-D)/64.).rgb*2.-1.)/sqrt(3.); return; }\n\t\n    vec2 R = iResolution.xy;\n    O = texture(iChannel0, U/R);                   // x: value  y: weight\n\n    // --- swap data at pos invmin and invmax\n    vec4 M = texture(iChannel2, vec2(.5)/R),\n         m = texture(iChannel2, vec2(1.5,.5)/R);\n    if (M.z != 0.) {   \n        if (U==M.zw) O = m;                          // swap\n        if (U==m.zw) O = M;\n    }\n       \n    // --- weight evaluation :   done in buffB for \n    //                             - swap (above) is registered when eval weights\n    //                             - weights are registered when sort (below)\n   \n    // --- seek for min/max invmin/max - part 1      // O.xyzw = (value, weight, xpos, ypos)\n#define T(x,y)  texture( iChannel2, vec2(x,y)/R ).xy\n    if (U.x==.5) {                                   // partial sort on each line\n        O.y = -99.;\n        for (float x = .5+D; x<64.+D; x++) {\n            vec2 V = T(x,U.y);\n            if (V.y > O.y) O = vec4(V, x,U.y);       // max +pos\n        }\n    }\n    if (U.x==1.5) {                                  // partial sort on each line\n        O.y = 99.;\n        for (float x = .5+D; x<64.+D; x++) {\n            vec2 V =  T(x,U.y);\n            if (V.y < O.y) O = vec4(V, x,U.y);       // min +pos\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// - evaluate neighborhood weight (i.e. unhappyness)\n// - compute min/max + invmin/invmax -  part 2\n\n#define INTOLERANCE .33  // cell unhappy if lesser proportion of neighbors are its kind (=sign). \n\n#define D 2.\n#define T(x,y)  texture( iChannel0, vec2(x,y)/R )  // comparison weight in T.y\n#define S(i,j)  sign( texture( iChannel0, (U+vec2(i,j))/R ).x )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (max(U.x,U.y) > 64.+D) return;\n    vec2 R = iResolution.xy;\n\n    // --- evaluate weight at pos \n\n    O = T(U.x,U.y);                                  // copy iChannel0\n    //O.y = O.x; // trivial test case\n    float v =   S(-1,-1) + S(0,-1) + S(1,-1)         // neighborhood tendendy\n              + S(-1, 0)      +      S(1, 0)\n              + S(-1, 1) + S(0, 1) + S(1, 1);\n    v = .5 + .5* sign(O.x) * v/8.;\n    v = 1.-clamp(v/INTOLERANCE, 0., 1.);             // unhappyness\n    O.y = v*sign(O.x) + O.x/100.;                    // weight = signed unhappyness + noise\n\n    // --- seek for min/max invmin/max - part 2      // O.xyzw = (value, weight, xpos, ypos)\n    // NB: to accelerate, we could calc cols with 2nd min/max, etc\n    if (U==vec2(.5)) {\n        O.y = -99.;\n        for (float y = .5+D; y<64.+D; y++) {\n            vec4 V = T(.5,y);\n            if (V.y > O.y)  O = V;                   // max +pos\n        }\n    }\n    \n    if (U==vec2(1.5,.5)) {\n        O.y = 99.;\n        for (float y = .5+D; y<64.+D; y++) {\n            vec4 V = T(1.5,y);\n            if (V.y < O.y)  O = V;                   // min +pos\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}