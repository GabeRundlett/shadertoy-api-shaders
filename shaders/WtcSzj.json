{
    "Shader": {
        "info": {
            "date": "1594863805",
            "description": "Trying to recreate some level design from the UE reddit. Had it laying around for a while, did some final touches and here it is!",
            "flags": 96,
            "hasliked": 0,
            "id": "WtcSzj",
            "likes": 5,
            "name": "Sci-Fi Corridor",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 buf = texture( iChannel0, uv );\n    \n    fragColor = mix( texture( iChannel1, uv ), buf, 0.7 );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define EPS 0.001\n#define FAR 30.0\n#define MAX_ITER 1200\n#define SPEED 2.1\n#define HASHSCALE1 .1031\n#define PI acos( -1.0 )\n#define Smooth\n#define AUD texture( iChannel2, vec2( 0.5 ) ).x\n#define WAV texture( iChannel2, vec2( 0.3 ) ).x\n#define FRE texture( iChannel2, vec2( 0.8 ) ).x\n\nvec3 glow = vec3( 0 );\n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n               );\n\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// power smooth min (k = 8);\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n// Taken from cabibo's https://www.shadertoy.com/view/Ml2XDw\nfloat smax( float a, float b, float k )\n{\n    return log( exp( k * a ) + exp( k * b ) ) / k;\n}\n\nvec3 turn( vec3 p )\n{\n\n    p.z -= iTime * SPEED;\n    p.x += 2.2 * sin( p.z * 0.4 ) + 1.5 * cos( p.z * 0.3 );\n    p.y += 0.1 * cos( p.z * 0.7 );\n    \n    return p;\n\n}\n\nvec3 dip( vec3 p )\n{\n\n    p.y -= 0.25 + 0.25 * sin( ( p.x + p.z ) + iTime * SPEED * FRE * 0.001 );\n    p.z += 1.0 + iTime * SPEED;\n    //p.x = abs( p.x );\n    //p.x -= 0.8;\n    //p.z = mod( p.z, 1.2 ) - 0.6;\n    \n    return p;\n\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    \n    vec2 d = abs( vec2( length( p.xz ), p.y ) ) - h;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    \n  \tvec3 q = abs( p ) - b;\n  \treturn length( max( q, 0.0 ) ) + min( max( q.x, max( q.y, q.z ) ), 0.0 );\n\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n    \n  \tvec2 q = abs( p ) - b;\n  \treturn length( max( q, 0.0 ) ) + min( max( q.x, q.y ), 0.0 );\n\n}\n\nfloat sp( vec3 p, float a )\n{\n\n\treturn length( p - vec3( 0, -0.7, 0 ) ) - a;\n\n}\n\nfloat tri( float amp, float dis, float fre, float spe, float dec )\n{\n\n    return amp * sin( fre * dis - iTime * spe ) / ( dec + dis * dis );\n    \n}\n\n// Shane's\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    //p.z += iTime * 0.2;\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\nvec2 map( vec3 p )\n{\n    \n    p = turn( p );\n    //p.xy *= 1.2;\n    \n    float tu =  max( -( length( p.xy ) - 2.0 ), length( p.xy ) - 2.5 );\n    \n    vec3 pRoo = p;\n    pRoo.y -= 2.0;\n    float roo = length( pRoo.xy ) - 1.0;\n    \n    vec2 tun = vec2( max( -roo, tu ), 0.0 );\n    \n    pRoo.y -= 2.1;\n    \n    vec2 roof = vec2( length( pRoo.xy ) - 2.0, 1.0 );\n    \n    if( roof.x < tun.x )\n    {\n    \n        tun = roof;\n    \n    }\n    \n    vec3 floP = dip( p );\n    vec2 flo = vec2( smin( p.y + 0.8 + tri( 0.5, length( floP.xz ), 10.0 + AUD * 10.0, 3.0, 35.0 + 30.0 * sin( ( floP.x + floP.z ) - iTime * SPEED ) ), sp( floP, 0.2 ), 0.2 ), 2.0 );\n    //vec2 flo = vec2( smin( p.y + 0.8, sp( floP, 0.2 ), 0.2 ), 2.0 );\n    \n    if( tun.x < flo.x ) \n    {\n    \n        flo = tun;\n    \n    }\n    \n    vec3 pro = p;\n    \n    pro.y += 0.1;\n    pro.zy *= rot( 1.5708 );\n    \n    pro.y = mod( pro.y, 2.0 ) - 1.0;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    vec3 boxP = pro;\n    boxP.z += 0.45;\n    boxP.x = abs( boxP.x );\n    boxP.x -= 1.95;\n    \n    vec2 cyl = vec2( min( sdBox( boxP, vec3( 0.01, 0.005, 0.07 ) ), max( -p.y + 0.4, max( -sdCylinder( pro, vec2( 1.98, 0.01 ) ), sdCylinder( pro, vec2( 2.03, 0.005 ) ) ) ) ), 3.0 );\n   \n    \n    if( cyl.x < flo.x )\n    {\n    \n        flo = cyl;\n    \n    }\n    \n    vec3 cylP = p;\n    cylP.y -= 2.1;\n    cylP.x = abs( cylP.x );\n    cylP.x -= 0.6;\n    \n    vec2 cylC = vec2( length( cylP.xy ) - 0.1, 4.0 );\n    \n    if( cylC.x < flo.x )\n    {\n    \n        flo = cylC;\n    \n    }\n    \n    vec3 pbo = p;\n    pbo.y += 0.7;\n    pbo.x = abs( pbo.x );\n    pbo.x -= 1.85;\n    \n    vec2 box = vec2( sdBox( pbo.xy, vec2( 0.1, 0.1 ) ) - 0.05, 5.0 );\n    \n    if( box.x < flo.x )\n    {\n    \n        flo = box;\n    \n    }\n    \n    //float tileSize = 1.5;\n    \n    //vec3 id = vec3( int( p.x / tileSize ), int( p.y / tileSize ), int( p.z / tileSize ) );\n    \n    vec3 tub = p;\n    tub.y += 0.29;\n    vec3 tubO = tub;\n    tub.x = abs( tub.x );\n    tub.x -= 1.995;\n    tubO.x = abs( tubO.x );\n    tubO.x -= 2.11;\n    tubO += 0.15;\n    tub.y += 0.05 * cos( tub.z * 1.0 ) * sin( tub.z * 0.4 );\n    tubO.y += 0.025 * cos( 20.0 + tubO.z * 1.0 ) * -sin( tubO.z * 0.6 );\n    \n    vec2 sid = vec2( min( length( tubO.xy ) - 0.024, length( tub.xy ) - 0.025 ), 6.0 );\n    \n    if( flo.x < sid.x )\n    {\n    \n        sid = flo;\n    \n    }\n    \n    // This one is quite fun!\n    //vec2 sph = vec2( flo.x - 0.004, 7.0 );\n    //vec2 sph = vec2( smin( p.y + 0.801, sp( p, 0.201 ), 0.2 ), 7.0 );\n    /*vec2 sph = vec2( sp( floP, 0.207 ), 7.0 );\n    \n    if( sph.x < sid.x )\n    {\n    \n        sid = sph;\n    \n    }*/\n    \n    return sid;\n    \n}\n\nvec3 norm( vec3 p )\n{\n\n    vec2 e = vec2( EPS, 0 );\n    \n    return normalize( \n           \t\t\t\tvec3( \n                        \t\tmap( p + e.xyy ).x - map( p - e.xyy ).x,\n                            \tmap( p + e.yxy ).x - map( p - e.yxy ).x,\n                            \tmap( p + e.yyx ).x - map( p - e.yyx ).x\n                            \n                        \t) \n    \t\t\t\t);\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n    float t = 0.0;\n    \n    for( int i = 0; i < MAX_ITER; ++i )\n    {\n    \n        d = map( ro + rd * t ).x;\n        \n        if( d < EPS || t > FAR )\n        {\n        \n            break;\n        \n        }\n        \n        t += d;\n        glow += vec3( 1e-4, 1e-3, 1e-4 ) * FRE;\n    \n    }\n    \n    return t;\n\n}\n\n/*\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n*/\n\nvec3 sha( vec3 ro, vec3 rd, float t, vec2 d )\n{\n\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    \n    vec3 col = vec3( 0 );\n    \n    if( map( p ).y == 0.0 ) \n    {\n    \n    \tn = texBump( iChannel1, turn( p ), n, 0.005 );\n        col += 0.1;\n    \n    }\n    \n    vec3 ref = reflect( rd, n );\n    \n    vec3 lig = ro - vec3( 0.1, 0.5, -1.4 );\n    lig.x -= turn( lig ).x;\n    lig = normalize( lig );\n    //lig.x -= turn( lig ).x;\n    //lig = normalize( lig );\n    vec3 blig = -lig;\n    \n    //vec2 d = map( p );\n    \n    \n    //float amb = 0.5 + 0.5 * n.y; \n    float dif = max( 0.0, dot( n, lig ) );\n    float bac = max( 0.0, dot( n, blig ) );\n    \n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 4.0 ); \n    //float sha = calcSoftshadow( p, lig, 0.01, 3.0, 1 );\n    \n    // Taken from tekf's awesome KIFS https://www.shadertoy.com/view/lssSWM.\n    vec3 ambient = mix( vec3( 0.03, 0.05, 0.08 ), vec3( 0.1 ), ( -n.y + 1.0 ) ); // ambient\n    // ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = t / 20.0; \n\tfloat occlusion = max( 0.0, 1.0 - map( p + n * aoRange ).x / aoRange ); // can be > 1.0\n\tocclusion = exp2( -3.0 * pow( occlusion, 2.0 ) ); // tweak the curve\n\tambient *= occlusion;\n    \n    col += vec3( 0.2, 0.2, 0.3 ) * ambient;\n    //col += vec3( 0.2, 0.2, 0.3 ) * amb;\n    col += vec3( 0.4, 0.4, 0.2 ) * spe;\n    col += vec3( 0.2, 0.1, 0.1 ) * dif;\n    col += vec3( 0.1, 0.1, 0.2 ) * bac;\n    \n    //col += vec3( 0.4, 0.4, 0.2 ) * spe;\n    \n    //col += 0.6 * texture( iChannel0, ref ).rgb;\n    \n    /*if( d.y == 2.0 )\n    {\n    \n        col += glow + AUD;\n    \n    }*/\n    \n    /*\n    if( d.y == 0.0 )\n    {\n    \n        col += tex3D( iChannel1, p, n );\n    \n    }\n    \n    \n    if( d.y == 1.0 )\n    {\n    \n        col *= vec3( 10 );\n    \n    }\n    \n    if( d.y == 2.0 )\n    {\n    \n        col *= vec3( 0, 1, 1 );\n    \n    }\n    \n    if( d.y == 3.0 )\n    {\n    \n        col *= vec3( 0, 1, 0 );\n    \n    }\n    \n    if( d.y == 4.0 )\n    {\n    \n        col *= vec3( 0, 0, 1 );\n    \n    }*/\n    \n    if( d.y == 1.0 )\n    {\n    \n        col += vec3( 0.2, 0.14, 0.1 ) * ( 0.5 + 0.5 * -n.y ) * occlusion;\n        col += 2.0 * spe;\n    \n    }\n    \n    if( d.y == 2.0 )\n    {\n    \n        col *= vec3( 0.5, 0.45, 0.4 );\n        //col += 0.5 * texture( iChannel0, ref ).rgb;\n    \n    }\n    \n    /*if( d.y == 3.0 )\n    {\n    \n        col *= 0.5;\n    \n    }*/\n    \n    //col *= glow;\n    \n    //col *= 0.5 + t * t * 0.3;\n    col = mix( col, vec3( 0.9, 0.88, 0.8 ), t * 0.08 );\n    \n    col += 0.2 * glow;// + AUD;\n    \n    return pow( col, vec3( 0.4545 ) );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec3 ro = vec3( 0, -0.3, 0 );\n    vec3 rd = normalize( vec3( uv, -1 ) );\n    vec3 tur = turn( ro );\n    ro.x -= tur.x;\n    //ro.zy *= rot( iMouse.y * 0.05 );\n    //rd.zy *= rot( iMouse.y * 0.05 );\n    rd.xz *= rot( tur.x * 0.2 );\n    \n    float d = 0.0, t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    \n    vec2 m = map( p );\n    \n    vec3 shad = d < EPS ? sha( ro, rd, t, m ) : vec3( 1 );\n    \n    if( ( m.y == 2.0 || m.y == 3.0 || m.y == 4.0 || m.y == 6.0 ) && d < EPS )\n    {\n\n    \trd = normalize( reflect( rd, n ) );\n   \t \tro = p + rd * EPS;\n\n        shad = sha( ro, rd, t, m );\n        \n    }\n    \n    fragColor = vec4( shad, 1 );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 23352,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/twistedmusic/shpongle-before-the-big-bang"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 tex = texture( iChannel0, uv );\n    vec4 bac = texture( iChannel1, uv );\n    \n    float eff = iTimeDelta * ( ( tex.r + bac.r + tex.g + bac.g + tex.b + bac.b ) * 0.33333 );\n    \n    fragColor = clamp( vec4( mix( bac, tex, eff ).rgb, eff ), vec4( 0.0 ), vec4( 1.0 ) );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}