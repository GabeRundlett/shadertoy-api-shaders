{
    "Shader": {
        "info": {
            "date": "1578610468",
            "description": "\nSDF and coloring from https://www.shadertoy.com/view/WtV3Rw\nMDTMJVM = Middecembertomidjanuaryvember\nA month of coding stuff.\nCoding some of the days at http://twitch.tv/wwrighter",
            "flags": 32,
            "hasliked": 0,
            "id": "Wty3Dz",
            "likes": 4,
            "name": "Day 20 - Julias",
            "published": 3,
            "tags": [
                "pathtracer",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": " \n\n// SDF and coloring from https://www.shadertoy.com/view/WtV3Rw\n\n\n\n#define FOCUS_FORMULA ((abs(texture(iChannel0,uv).w - FOCUS_DISTANCE)*BLUR_AMT ))\n\nconst float blurdist_px = 64.0;\n\n\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n\nvec3 sampletex( vec2 uv )\n{\n    #ifdef SRGBLIN\n    \treturn srgb2lin( texture( iChannel0, uv, -10.0 ).rgb );\n    #else\n    \treturn  texture( iChannel0, uv, -10.0 ).rgb ;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float blurdist = FOCUS_FORMULA;\n\n    //float srnd = hash12n(uv+fract(iTime))-0.5;\n    \n   \tvec3 sumcol0 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( 1.0, 0.577350269189626 );\n    \tvec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n    \tvec2 p1 = uv + 0.5 * blurdist * blurvec;\n    \tvec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n    \tvec2 p = p0;\n        p += stepvec;\n    \n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n        \tsumcol0 += sampletex(p);\n            p += stepvec;\n        }\n        sumcol0 /= float(NUM_SAMPLES);\n    }\n    \n    vec3 sumcol1 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( -1.0, 0.577350269189626 );\n        vec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n        vec2 p1 = uv + 0.5 * blurdist * blurvec;\n        vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n        vec2 p = p0;\n        p +=  stepvec;\n\n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n        \tsumcol1 += sampletex(p);\n            p += stepvec;\n        }\n        sumcol1 /= float(NUM_SAMPLES);\n    }\n\n    vec3 sumcol = min( sumcol0, sumcol1 );\n\n    #ifdef SRGBLIN\n    \tfragColor = vec4( lin2srgb( sumcol ), 1.0 );\n    #else\n    \tfragColor = vec4( sumcol , 1.0 );\n    #endif\n    fragColor = 1.*texture(iChannel1, uv);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define fov 0.7\n#define zoom 1.4\n#define BOUNCES 3\n#define MARCH_ITERATIONS 260\n\n\n\n#define mx (20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n#define pmod(p,x) mod(p, x) - x*0.5\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nMaterial materials[5] = Material[](\n\tMaterial(vec3(1.,0.4,1)*30.1,0.,1.), // wall\n\tMaterial(vec3(1.,1.,1.)*0.4,0.0,0.9), // light A\n\tMaterial(vec3(0.)*0.,0.1,0.), // Julia\n\tMaterial(vec3(0.001)*1.,0.9,0.1),\n\tMaterial(vec3(0.3,0.4,1.4)*3.5,0.9,2.0)\n);  \n\n\nvec3 getRd(vec3 o, vec3 lookAt, vec2 uv) {\n    uv += hash(uv.x + uv.y + float(iFrame))*0.002;\t\t\t// thx slerpy\n    vec3 dir = normalize(lookAt - o);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x*fov + up*uv.y*fov;\n}\n\n// ----------------- SDFs ----------------- //\nfloat sdBox (vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.y, p.z));\n}    \nfloat sdSphere (vec3 p, float s){\n\treturn length(p) - s;\n}\nfloat sdFloorA (vec3 p){\n    return p.y;\n}\nfloat sdWall (vec3 p){\n    return -p.x;\n}\nfloat sdBackWall (vec3 p){\n    return -p.z;\n}\n#define ITERATIONS 3.0\n\n#define C vec4(0.09,0.7,0.3,0.3)\n\n\nvec3 qColor = vec3(0);\n#define ASIZE 1.6\n\nObject sdJulia(vec3 p) {\n    Object o = NewObject;\n    p.xz *= rot(0.35 * PI);\n    p.y -= 0.1;\n    \n    \n    for (int i = 0; i < 2; i++){\n    \t\n        p.y -= 0.29;\n        p.x -= 0.4;\n        p.z -= 0.04;\n        if (i > 2) {\n        \tp.x *= atan(p.x,p.z);\n        }\n    \tp.xy *= rot(0.5*PI);\n        p.xz *= rot(0.24 - float(i)*0.01);\n        \n        p = abs(p);\n    }\n    p.z -= .5;\n    //p.zy *= rot(0.2);\n    p -= 0.58;\n    p.x -= 0.7;\n    \n    p.y -= 0.2;\n    /*\n    for (int i = 0; i < 4; i++){\n    \t\n        p.y -= 0.4;\n        if (i > 2) {\n        \tp.x *= atan(p.x,p.z);\n        }\n    \tp.xy *= rot(0.5*PI);\n        p.xz *= rot(0.54);\n        \n        p = abs(p);\n    }\n    */\n    vec4 z = vec4(p, 0.1);\n    vec4 dz = vec4(1, 0, 0, 0);\n    //o = omin(o,sdOcta(p, vec3(0.1)),materials[3]);\n    vec4 c = C;\n    \n    \n    float it;\n    float minDist = 1000.0;\n    float mdX, mdY, mdZ;\n    mdX = minDist; mdY = minDist; mdZ = minDist;\n    //c.w += 0.5*sin(iTime*2.0);\n    for(float x=0.0; x < 13.0; x++)\n    {\n        dz = 2.0*multQuat(z,dz);\n    \tz = squareQuat(z) + c;\n        \n        minDist = min(minDist, length(z - c)); //store minimum distance from starting point\n        mdX = min(mdX, abs(z.x));\n\t\tmdY = min(mdY, abs(z.y));\n\t\tmdZ = min(mdZ, abs(z.z));\n        \n        if(length(z) > 2.0)\n        {\n            it = x;\n            break;\n        }\n    }\n\n    \n    //Coloring based off orbits: https://iquilezles.org/articles/ftrapsgeometric\n    qColor = vec3(0) + vec3(0.7, 0.3, 0.55)*(minDist);\n    qColor += vec3(0.,0.3,0.3)*(mdX);\n    qColor += vec3(0.5,0.2,0)*(mdY);\n    qColor += vec3(0.0,0.1,0.)*(mdZ);\n\n\tmaterials[2].albedo = vec3(qColor)*2.6;\n    o.d = 0.75*length(z)*log(length(z)) / length(dz);\n\treturn o;\n}\n\n// ----------------- MAP ----------------- //\n#define HEIGHT\nObject map(vec3 p) {\n    Object o = NewObject;\n    \n\n    //o = omin(o, sdFloorA(p - vec3(0.,-0.14,0)), materials[0]);\n    \n    //o = omin(o, sdWall(p - vec3(0.9,0.,0)), materials[0]);\n    \n    ////o = omin(o, -sdWall(p - vec3(-0.4,0.,0)), materials[0]);\n    //o = omin(o, sdWall(p - vec3(0.4,0.,0)), materials[1]);\n    //o = omin(o, sdSphere(p - vec3(-.6,0.4,0.6), 0.2), materials[0]);\n    \n    o = omin(o, sdJulia(p - vec3(-0.0,0.0,0.1)).d, materials[2]);\n    //p.xz *= rot(0.1);\n    p.y += 1.7;\n    o = omin(o, sdJulia(p - vec3(4.,6.0,2.)).d, materials[2]);\n    \n    \n    o.didHit = true;\n    o.d *= 0.8;\n    return o;\n}\n\nObject trace(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.1;\n    float t = 0.;\n    for (int i = 0; i < MARCH_ITERATIONS; i++) {\n    \tObject obj = map(p);\n        \n        if (obj.d < 0.0002) {\n            obj.d = t;\n        \treturn obj;\n            break;\n        }\n        \n        if (t > 100.) {\n            obj.didHit = false;\n            return obj;\n        \tbreak;\n        }\n    \n        t += obj.d;\n        p = ro + rd*t;\n    }\n\n\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 t = vec2(0.0005,0.);    \n    return normalize(vec3(\n    \tmap(p + t.xyy).d - map(p - t.xyy).d,\n    \tmap(p + t.yxy).d - map(p - t.yxy).d,\n    \tmap(p + t.yyx).d - map(p - t.yyx).d\n    ));\n}\n\n// ----------------- MAIN ----------------- //\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv -= normalize(uv)*pow(length(uv)*0.34,3.);\n    vec2 uvs = (fragCoord/iResolution.xy);\n\n    vec4 col = texture(iChannel0, uvs);\n \n    vec3 accum = vec3(0);\n    float attenuation = 1.;\n    \n    vec3 ro = vec3(0,-0.09,0.);\n    \n    ro.x -= 0.9;\n    ro.y -= 1.8;\n    ro.z -= 0.7;\n    //ro.x -= 10.;\n    //ro.y -= 10.;\n    //ro.x += mx;\n    //ro.y += my;\n    vec3 lookAt = vec3(0.9,0,0);\n    vec3 rd = getRd(ro, lookAt, uv);\n    ro -= normalize(lookAt - ro)*zoom;\n    vec3 dir = rd;\n    float seed = hash(float(iFrame) + uv.x*243.124 + uv.y*212.512);\n    \n    float dFirst = 0.;\n    bool hitBg = false;\n    int i = 0;\n    for (; i < BOUNCES; i++){\n    \tObject obj = trace(ro, rd);\n        if (obj.didHit) {       \n            if (i == 0){\n                dFirst = obj.d;\n            }\n            vec3 p = ro + rd * obj.d;  \t\t\t\t\n    \t\tvec3 N = getNormal(p);\n            accum += obj.material.albedo*1. * attenuation;\n            attenuation /= PI; // thx slerpy\n            //accum += obj.material.albedo * attenuation;\n            //seed += 14.5;\n            seed = hash(float(iFrame) + uv.x*24.124 + uv.y*412.512 + float(i)*12.);\n            ro = p;\n            rd = mix(cosineDirection(seed, N),N,obj.material.metalness);\n            accum *= dot(rd,N)*0.4;\n\n            \n\n        } else {\n            hitBg = true;\n            break;\n        }\n        \n    }\n    col.xyz += accum;\n    \n    if (iFrame == 0) {\n        if (hitBg && i == 0 ){\n            col.w = 12345678.;\n        } else {\n            col.w = dFirst;\n        }\n    }\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define RAND 1\n\n#define NUM_SAMPLES 1\n#define bdist 0.00\n#define PI 3.14159265359\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec4 multQuat(vec4 q1, vec4 q2)\n{\n    vec4 r;\n    r.x   = q1.x*q2.x - dot( q1.yzw, q2.yzw );\n    r.yzw = q1.x*q2.yzw + q2.x*q1.yzw + cross( q1.yzw, q2.yzw );\n    return r;\n}\n\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec4 squareQuat(vec4 q)\n{\n \tvec4 r;\n    r.x   = q.x*q.x - dot( q.yzw, q.yzw );\n    r.yzw = 2.0*q.x*q.yzw;\n    return r;  \n}\n\n#define BLUR_AMT (1.)\n//#define FOCUS_DISTANCE (0.1 + (0.5 + sin(iTime)*0.5))\n#define FOCUS_DIV 3.\n//#define FOCUS_DISTANCE (0.1 + (FOCUS_DIV + sin(iTime)*FOCUS_DIV))\n#define FOCUS_DISTANCE (2.5)\n#define SRGBLIN\n\n#if RAND == 1\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\n#elif RAND == 2\n// by Dave Hoskins\nfloat r31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#endif\n\n\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// hg_sdf\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\nstruct Material {\n    vec3 albedo;\n\tfloat metalness; \n\tfloat roughness;\n};\n\nstruct Light {\n\tvec3 colour;\n    vec3 pos;\n\tfloat intensity;\n};\nLight lights[1] = Light[](\n    Light(vec3(1.2,1.2,1), vec3(-0.,10.,0.), 0.)\n);    \n\nstruct Object {\n\tfloat d;\n    bool didHit;\n\tMaterial material;\n};\nObject omin(Object a, float bdistance, Material bmaterial) {\n    if (a.d < bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\nObject omin(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, float bdistance, Material bmaterial) {\n    if (a.d > bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\n\n\n#define NewObject Object(1e8,false,materials[0])\n\n\n\n\n// by fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 tex = texture(iChannel0, uv);\n    fragColor = tex;\n    fragColor.xyz /= float(iFrame);\n    //fragColor.xyz = clamp(fragColor.xyz, 0. ,1.);\n    fragColor.xyz *= 1.9;\n    \n    vec3 fogColor =  mix(vec3(0.6,.26,0.119)*0.05, vec3(0.5,.16,0.319)*0.09, uv.y)*0.2;\n    fragColor.xyz = mix(fragColor.xyz,fogColor, pow(smoothstep(0.,1.,fragColor.w*0.19 - 0.9), 1.04));\n    if (fragColor.w == 12345678.){\n    \t//fragColor.xyz = fogColor;\n    }\n    fragColor.xyz = clamp(fragColor.xyz, 0.03,1.);\n    fragColor.x = fragColor.y;\n    fragColor *= 1.;\n    fragColor.g *= 0.9;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545));\n    fragColor.xyz *= 1.3;\n    fragColor.xyz = smoothstep(0.,1.,fragColor.xyz); // thx to yx for smoothstep col\n    \n    //fragColor.xyz = smoothstep(0.,1.,pow(fragColor.xyz, vec3(0.8)));\n} ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Depth of Field pass. Code from https://www.shadertoy.com/view/Xd3GDl\n// which is an implementation of DICE's depth of field paper\n\n//#define USE_RANDOM\nconst vec2 blurdir = vec2( 1.0, 1.0 );\n\nconst float blurdist_px = 64.0;\n\n\n//#define FOCUS_FORMULA (abs(texture(iChannel0,uv).w - 2.))\n#define FOCUS_FORMULA ((abs(texture(iChannel0,uv).w - FOCUS_DISTANCE)*BLUR_AMT ))\nconst float MULT = 4.0;\n\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nvec3 sampletex( vec2 uv )\n{\n    #ifdef SRGBLIN\n    \treturn srgb2lin( texture( iChannel0, uv, -10.0 ).rgb );\n    #else\n    \treturn  texture( iChannel0, uv, -10.0 ).rgb ;\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 blurdir = vec2( 0.0, 1.0 );\n    vec2 blurvec = normalize(blurdir) / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n    float blurdist = FOCUS_FORMULA;\n    \n    vec2 p0 = uv - 0.5 * blurdist * blurvec;\n    vec2 p1 = uv + 0.5 * blurdist * blurvec;\n    vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(iTime))-0.5) * stepvec;\n    #endif\n    \n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n        vec3 smpl = sampletex(p);\n        sumcol += smpl;\n        p += stepvec;\n    }\n    sumcol /= float(NUM_SAMPLES);\n    sumcol = max( sumcol, 0.0 );\n    \n    \n    #ifdef SRGBLIN\n    \tfragColor = vec4( lin2srgb( sumcol * MULT ), texture( iChannel0,uv).w );\n    #else\n    \tfragColor = vec4( sumcol * MULT , texture( iChannel0,uv).w );\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}