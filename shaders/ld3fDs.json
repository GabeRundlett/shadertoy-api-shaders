{
    "Shader": {
        "info": {
            "date": "1527529407",
            "description": "Traversal of a 3d grid with refraction. Code and visuals are based on the 2d analogous shader \n[url=https://www.shadertoy.com/view/ltXBz7] 2D Grid Traversal w/ Refraction [/url].\n\nThe mouse can be used to rotate the view.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ld3fDs",
            "likes": 41,
            "name": "3D Grid Traversal w/ Refraction",
            "published": 3,
            "tags": [
                "3d",
                "grid",
                "refraction",
                "traversal"
            ],
            "usePreview": 0,
            "username": "glk7",
            "viewed": 1450
        },
        "renderpass": [
            {
                "code": "// Created by genis sole - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nfloat iRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in float b) \n{\n    vec3 t0 = (-vec3(b) - ro) * invrd;\n    vec3 t1 = (vec3(b) - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    return fmin * sign(fmax - fmin);\n}\n\nfloat segment(vec2 uv, float e, float w, vec2 a, vec2 b)\n{         \n    b -= a;\n    uv -= a;\n    return smoothstep(-e, e, \n                      length( uv - b * clamp(dot(b, uv) / dot(b, b), 0.0, 1.0)) - w);\n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn smoothstep(-e, e, length(uv - p) - 0.0025); \n}\n\nfloat draw_cell(vec2 uv, float e, float w, vec3 c, float s, mat4 T) \n{\n    vec4 b1 = T * vec4(c + vec3(-0.5, -0.5, -0.5)*s, 1.0);\n    vec4 b2 = T * vec4(c + vec3(-0.5, -0.5, 0.5)*s, 1.0);\n    vec4 b3 = T * vec4(c + vec3(0.5, -0.5, 0.5)*s, 1.0);\n    vec4 b4 = T * vec4(c + vec3(0.5, -0.5, -0.5)*s, 1.0);\n   \n    vec4 t1 = T * vec4(c + vec3(-0.5, 0.5, -0.5)*s, 1.0);\n    vec4 t2 = T * vec4(c + vec3(-0.5, 0.5, 0.5)*s, 1.0);\n    vec4 t3 = T * vec4(c + vec3(0.5, 0.5, 0.5)*s, 1.0);\n    vec4 t4 = T * vec4(c + vec3(0.5, 0.5, -0.5)*s, 1.0);\n    \n    b1.xy /= b1.z;\n    b2.xy /= b2.z;\n    b3.xy /= b3.z;\n    b4.xy /= b4.z;\n    \n    t1.xy /= t1.z;\n    t2.xy /= t2.z;\n    t3.xy /= t3.z;\n    t4.xy /= t4.z;\n    \n    float v = 1.0;\n    v *= segment(uv, e, w, b1.xy, b2.xy);\n    v *= segment(uv, e, w, b2.xy, b3.xy);\n    v *= segment(uv, e, w, b3.xy, b4.xy);\n    v *= segment(uv, e, w, b4.xy, b1.xy);\n    \n    v *= segment(uv, e, w, t1.xy, t2.xy);\n    v *= segment(uv, e, w, t2.xy, t3.xy);\n    v *= segment(uv, e, w, t3.xy, t4.xy);\n    v *= segment(uv, e, w, t4.xy, t1.xy);\n    \n    v *= segment(uv, e, w, b1.xy, t1.xy);\n    v *= segment(uv, e, w, b2.xy, t2.xy);\n    v *= segment(uv, e, w, b3.xy, t3.xy);\n    v *= segment(uv, e, w, b4.xy, t4.xy);\n    \n\treturn v;\n}\n\nfloat draw_arrow(vec2 uv, float e, float w, vec3 p, vec3 d, mat4 T)\n{\n\tvec4 a = T * vec4(p, 1.0);\n    vec4 b = T * vec4(p - d, 1.0);\n    \n    a.xy /= a.z;\n    b.xy /= b.z;\n    \n    vec2 pd = normalize(b.xy - a.xy);\n    vec2 ppd = vec2(-pd.y, pd.x);\n    \n    return point(uv, e, a.xy)\n        * segment(uv, e, w, a.xy, a.xy + pd*0.005 + ppd*0.003) \n        * segment(uv, e, w, a.xy, a.xy + pd*0.005 - ppd*0.003)\n        * segment(uv, e, w, a.xy, a.xy + pd*0.02);\n    \n}\n\nfloat draw_segment(vec2 uv, float e, float w, vec3 p0, vec3 p1, mat4 T) \n{\n    vec4 a = T * vec4(p0, 1.0);\n    vec4 b = T * vec4(p1, 1.0);\n    \n    a.xy /= a.z;\n    b.xy /= b.z;\n    \n    return segment(uv, e, w, a.xy, b.xy) * point(uv, e, b.xy);\n}\n\nfloat draw_point(vec2 uv, float e, vec3 p, mat4 T)\n{\n    vec4 a = T * vec4(p, 1.0);\n    \n    a.xy /= a.z;\n    \n    return point(uv, e, a.xy);\n}\n\nfloat refract_index(vec3 c) \n{\n    return 1.0 + step(-2.1, -length(c + vec3(0.5)))*1.7;\n}\n\nvec2 traversal(vec2 uv, float e, vec3 ro, vec3 rd, vec3 cro, vec3 crd, mat4 T)\n{\n    vec3 icrd = 1.0 / crd;\n    \n    const float size = 4.0;\n    \n    if (iRayAABox(cro, crd, icrd, size + 1.0) < 0.0) {\n        return vec2(1.0, 0.0);\n    }\n        \n    float b = iRayAABox(ro, rd, 1.0/rd, size);\n    if (b < 0.0) return vec2(1.0, 0.0);\n    \n    ro += b*rd; \n    \n    vec3 c = floor(ro + rd*0.001) + 0.5;\n    ro -= c;\n\n    vec2 v = vec2(draw_arrow(uv, e, 0.001, ro + c, rd, T), 0.0);\n    \n    float refri = refract_index(c - 0.5);\n    \n    for( int i = 64; i > 0; --i ){\n       \t\n        vec3 d = (sign(rd)*0.5 - ro) / rd;\n    \tvec3 n = -sign(rd) * step(d.xyz, d.yxx) * step(d.xyz, d.zzy);\n        \n        vec3 pro = ro;\n        ro += min(d.x, min(d.y, d.z)) * rd;\n        \n        v.x *= draw_segment(uv, e, 0.001, pro + c, ro + c, T);\n        v.x *= 1.0 - ((1.0 - draw_cell(uv, e, 0.0005, c, 1.0, T)) * 0.75);\n        v.y = max(v.y, step(0.0, iRayAABox(cro - c, crd, icrd, 0.5)));\n        \n        // Refraction part.\n        #if 1\n        float nrefri = refract_index(c - 0.5 - n);\n        \n        vec3 reflrd = reflect(rd, n);\n        rd = refract(rd, n, refri/nrefri);\n        \n        float t = step(0.0, -dot(rd, rd));\n       \trefri = mix(nrefri, refri, t);\n        rd += reflrd*t;\n        n *= 1.0 - t;\n        #endif\n        \n        c -= n;\n        ro += n;\n       \n        if (any(greaterThan(abs(c), vec3(size - 0.5)))) break;\n        \n    }\n    \n    return v;\n}\n\nvec4 grid(vec2 uv, float e, vec3 ro, vec3 rd, mat4 T)\n{\n\tvec3 ird = 1.0/rd;\n    vec3 srd = sign(rd);\n    \n    const float size = 4.0;\n    \n    vec3 col = vec3(0.3, 0.5, 1.0);\n    float v = 1.0 - draw_cell(uv, e, 0.0015, vec3(0.0), 2.0*size, T);\n    \n    float b = iRayAABox(ro, rd, ird, size);\n    if (b < 0.0) return vec4(vec3(1.0), (1.0 - v) * 0.2);\n    \n    ro += b*rd; \n    \n    vec3 c = floor(ro + rd*0.001) + 0.5;\n    ro -= c;\n\n    //float dist = 0.0;\n    \n    for( int i = 64; i > 0; --i ){\n        float h =  step(1.5, refract_index(c - 0.5));\n        col = mix(col, vec3(1.0, 0.5, 0.3), h);\n        v = max(v, (1.0 - draw_cell(uv, e, 0.00015, c, 1.0, T)) * mix(0.5, 0.9, h));\n        \n        vec3 d = (srd*0.5 - ro) * ird;\n    \tvec3 n = -srd * step(d.xyz, d.yxx) * step(d.xyz, d.zzy);\n        \n        c -= n;\n        \n        if (any(greaterThan(abs(c), vec3(size - 0.5)))) break;\n        \n       \tfloat inc = min(d.x, min(d.y, d.z));\n        //dist += inc;\n        ro += inc * rd;\n        ro += n;\n    }\n    \n    return vec4(col, 1.0 - v);\n}\n\nconst float PI = 3.14159;\n\nconst float cam_dist = 25.0;\nmat4 camera() \n{\n\tvec2 m = -vec2(((iMouse.xy + 0.01) / iResolution.xy) * 2.0*PI) - vec2(PI, 0.0);\n    \n    if (all(lessThan(iMouse.xy, vec2(10.0)))) {\n        m = vec2(sin(iTime*0.1), cos(iTime*0.1));\n    }\n    \n    vec2 c = cos(m);\n    vec2 s = sin(m);\n    \n   \tmat4 t = mat4(c.x, 0.0, -s.x, 0.0, \n                  s.x*s.y, c.y, c.x*s.y, 0.0, \n                  s.x*c.y, -s.y, c.x*c.y, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    \n    t[3] = vec4(t[2].xyz * -cam_dist, 1.0); \n    \n    return t;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat e = 1.0 / iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * e;\n    \n    vec3 ro = vec3(0.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    \n    mat4 T = camera();\n    \n    ro = (T * vec4(ro, 1.0)).xyz;\n    rd = mat3(T) * rd;\n    \n    //mat4 iT = inverse(T);\n    mat4 iT = mat4(transpose(mat3(T)));\n    iT[3] = vec4(0.0, 0.0, cam_dist, 1.0);\n    \n    vec4 v = grid(uv, e, ro, rd, iT);\n    \n    vec3 tro = vec3(cos(iTime*0.1)*5.0, sin(iTime*0.1)*5.0, 6.0);\n    \n    vec2 tv = traversal(uv, e,tro, normalize(-tro + 1.333), ro, rd, iT);\n    v.rgb += tv.y*0.2;\n    v.rgb *= tv.x * v.w;\n \n    fragColor = vec4(pow(clamp(v.rgb, 0.0, 1.0), vec3(0.4545)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}