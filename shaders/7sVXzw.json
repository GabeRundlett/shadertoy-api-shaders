{
    "Shader": {
        "info": {
            "date": "1634440833",
            "description": "Inspired by 3Blue1Brown's video: [url=https://www.youtube.com/watch?v=LqbZpur38nw]https://www.youtube.com/watch?v=LqbZpur38nw[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "7sVXzw",
            "likes": 18,
            "name": "Julia Investigation",
            "published": 3,
            "tags": [
                "fractal",
                "juliaset",
                "cycles",
                "analysis",
                "3blue1brown"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "// https://www.desmos.com/calculator/tl1f1kcb1h\n\n// Red dots: fixed points\n// Blue dots: points cycling every two iterations\n// Pink dots: points that fall into fixed points\n// Green dots: points that fall into double cycles\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 3.0;\n    float unit = 6.0 / iResolution.y;\n\n    Complex z = uv;\n    Complex p = 0.6 * cexp(0.1 * iTime * i);\n    Complex c = csub(0.25, csqr(cadd(0.5, p)));//Complex(-0.196, -0.68) + 0.1 * cexp(0.5 * iTime * i) + Complex(-0.1, 0.15);\n\n    // Iterate function f(z) = z^2 + c (for z = uv)\n    float a = 0.0;\n    for (int iter=0; iter < 100; iter++) {\n        z = csqr(z) + c;\n        a += (c.im - z.im) / (length(z - c) + 0.001); // cross(normalize(z - c), vec2(1, 0))\n        if (cmod(z) > 2.0) break;\n    }\n\n    vec2 q = csqr(csqr(csqr(uv) + c) + c) + c;\n    vec3 color = 0.5 * (hue2rgb(0.01 * a) + cos(0.25 * a + iTime)) * exp(-0.1 * cmod(q));\n\n    // Iterate function f(z) = z^2 + c (for z = mouse)\n    if (iMouse.z > 0.0) {\n        z = (iMouse.xy - center) / iResolution.y * 3.0;\n        for (int iter=0; iter < 25; iter++) {\n            Complex zn = csqr(z) + c;\n            drawSDF(sdLine(uv, z, zn), vec3(0.0, 1.0, 0.0));\n            z = zn;\n        }\n    }\n\n    // Calculate fixed points (f(z) = z)\n    Complex u = csqrt(csub(0.25, c));\n    Complex fixed1 = cadd(0.5, u), fixed2 = csub(0.5, u);\n\n    // Draw fixed points\n    drawSDF(sdDisk(uv, fixed1, 0.04), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisk(uv, fixed2, 0.04), vec3(1.0, 0.0, 0.0));\n\n    // Calculate double cycle points (f(f(z)) = z)\n    Complex v = csqrt(csub(-0.75, c));\n    Complex cycle21 = cadd(-0.5, v), cycle22 = csub(-0.5, v);\n\n    // Draw double cycle points\n    drawSDF(sdDisk(uv, cycle21, 0.04), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdDisk(uv, cycle22, 0.04), vec3(0.0, 0.0, 1.0));\n\n    // Points opposite the fixed points fall into the fixed points anyways\n    drawSDF(sdDisk(uv, -fixed1, 0.04), vec3(0.8, 0.0, 1.0));\n    drawSDF(sdDisk(uv, -fixed2, 0.04), vec3(0.8, 0.0, 1.0));\n\n    // Points opposite the double cycling points fall into them and start cycling\n    drawSDF(sdDisk(uv, -cycle21, 0.04), vec3(0.2, 1.0, 0.0));\n    drawSDF(sdDisk(uv, -cycle22, 0.04), vec3(0.2, 1.0, 0.0));\n\n    // Unfortunately triple cycle points can only be found by\n    // solving a 6th degree polynomial which isn't possible with\n    // only elementary functions (+, -, *, /, nthroot, sin, cos, tan, exp, etc.) :(\n    // I might try implementing a numerical solver but its rather tricky business\n\n    // (f(f(f(z))) - z) / (f(z) - z) =\n    // z^6 + z^5 + (3c + 1)z^4 + (2c + 1)z^3 + (3c^2 + 3c + 1)z^2 + (c^2 + 2c + 1)z + c^3 + 2c^2 + c + 1\n\n    fragColor += vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord);\n    render(fragColor, fragCoord + vec2(0.5, 0.0));\n    render(fragColor, fragCoord + vec2(0.0, 0.5));\n    render(fragColor, fragCoord + 1.0);\n    fragColor /= 4.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Complex Math Utilities - https://www.shadertoy.com/view/sst3WH\n\n// Joke of the day:\n// Complex numbers are real.\n\n// Constants\n#define pi 3.14159265359\n#define rho 1.57079632679\n#define tau 6.28318530718\n#define e 2.7182818284\n#define i Complex(0.0, 1.0)\n\n// Hue to RGB conversion (https://www.desmos.com/calculator/amac5m7utl)\nvec3 hue2rgb(in float hue) {\n    //return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n    //return smoothstep(0.0, 1.0, abs(2.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0)) - 1.0)) * 1.2;\n    //return clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0);\n    return smoothstep(0.0, 1.0, clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0));\n}\n\n// -------------------------- Complex math --------------------------\n#define Complex vec2\n#define re x\n#define im y\n\n// Miscellaneous\nfloat carg(in Complex z) { return atan(z.im, z.re); }\nfloat cmod(in Complex z) { return length(z); }\nComplex cconj(in Complex z) { return Complex(z.re, -z.im); }\n\n// Elementary operations (+, -, *, /)\nComplex cadd(in Complex z, in Complex w) { return z + w; }\nComplex cadd(in Complex z, in float w) { return Complex(z.re + w, z.im); }\nComplex cadd(in float z, in Complex w) { return Complex(z + w.re, w.im); }\n\nComplex csub(in Complex z, in Complex w) { return z - w; }\nComplex csub(in Complex z, in float w) { return Complex(z.re - w, z.im); }\nComplex csub(in float z, in Complex w) { return Complex(z - w.re, -w.im); }\n\nComplex cmul(in Complex z, in Complex w) { return mat2(z, -z.im, z.re) * w; }\nComplex cmul(in Complex z, in float w) { return z * w; }\nComplex cmul(in float z, in Complex w) { return z * w; }\n\nComplex cinv(in Complex z) { return Complex(z.re, -z.im) / dot(z, z); }\nComplex cdiv(in Complex z, in Complex w) { return cmul(z, cinv(w)); }\nComplex cdiv(in Complex z, in float w) { return z / w; }\nComplex cdiv(in float z, in Complex w) { return z * cinv(w); }\n\n// Exponentials\nComplex cexp(in Complex z) { return exp(z.re) * Complex(cos(z.im), sin(z.im)); }\nComplex clog(in Complex z) { return Complex(0.5 * log(dot(z, z)), carg(z)); }\n\n// Powers\nComplex cpow(in Complex z, in Complex w) { return cexp(cmul(clog(z), w)); }\nComplex cpow(in float z, in Complex w) { return cexp(log(z) * w); }\nComplex cpow(in Complex z, in float w) {\n    float a = carg(z) * w;\n    return Complex(cos(a), sin(a)) * pow(dot(z, z), 0.5 * w);\n}\n\nComplex csqr(in Complex z) { return Complex(z.re * z.re - z.im * z.im, 2.0 * z.re * z.im); }\nComplex csqrt(in Complex z) {\n    Complex c = 0.5 * Complex(cmod(z), z.x);\n    return Complex(sqrt(c.re + c.im), sign(z.im) * sqrt(c.re - c.im));\n}\n\n// Hyperbolic functions\nComplex csinh(in Complex z) { return Complex(sinh(z.re) * cos(z.im), cosh(z.re) * sin(z.im)); }\nComplex ccosh(in Complex z) { return Complex(cosh(z.re) * cos(z.im), sinh(z.re) * sin(z.im)); }\nComplex ctanh(in Complex z) {\n    vec4 c = vec4(sinh(z.re), cosh(z.re), sin(z.im), cos(z.im));\n    return cdiv(c.xy * c.wz, c.yx * c.wz);\n}\n\n// Inverse hyperbolic functions\nComplex casinh(in Complex z) { return clog(z + cpow(cadd(cmul(z, z), 1.0), 0.5)); }\nComplex cacosh(in Complex z) { return clog(z + cpow(csub(cmul(z, z), 1.0), 0.5)); }\nComplex catanh(in Complex z) { return 0.5 * clog(cdiv(cadd(1.0, z), csub(1.0, z))); }\n\n// Trigonometric functions\nComplex csin(in Complex z) { return csinh(z.yx).yx; }\nComplex ccos(in Complex z) { return ccosh(Complex(z.im, -z.re)); }\nComplex ctan(in Complex z) {\n    vec4 c = vec4(sin(z.re), cos(z.re), sinh(z.im), cosh(z.im));\n    return cdiv(c.xy * c.wz, Complex(c.im, -c.re) * c.wz);\n}\n\n// Inverse trigonometric functions\nComplex casin(in Complex z) { return casinh(z.yx).yx; }\nComplex cacos(in Complex z) { return csub(rho, casin(z)); }\nComplex catan(in Complex z) { return catanh(z.yx).yx; }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}