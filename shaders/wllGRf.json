{
    "Shader": {
        "info": {
            "date": "1557184034",
            "description": "An interesting result from playing around with smooth minimum variation applied to distance and color.",
            "flags": 0,
            "hasliked": 0,
            "id": "wllGRf",
            "likes": 13,
            "name": "Smooth minimum on color and dist",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "ao",
                "smooth",
                "pbr",
                "minimum",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 1793
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Smooth minimum on color and distance - An interesting result from messing\n// around with smin().\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER    = 96;\nconst float STEP_SIZE = .5;\nconst float EPSILON   = .0001;\nconst float PI = 3.14159265359;\n\nstruct Result {\n\tfloat d;\n\tvec3 col;\n\tint id;\n};\n\nfloat udRoundBox (vec3 p, vec3 size, float r)\n{\n    return length (max (abs (p) - (size - r), .0)) - r;\n}\n\nfloat sdSphere (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\n// PBR toolbox\nfloat DistributionGGX (vec3 N, vec3 H, float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX (float NdotV, float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith (in vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = GeometrySchlickGGX (NdotV, roughness);\n    float ggx2 = GeometrySchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (float cosTheta, vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nvec4 smin (vec4 d1, vec4 d2, float k)\n{\n\tfloat h = clamp (.5 + .5*(d2.a - d1.a)/k, .0, 1.);\n\treturn mix (d2, d1, h) - h*k*(1. - h);\n}\n\nfloat vary (float value, float speed)\n{\n\treturn value*(.5 + .5*cos(speed*iTime));\n}\n\n// ray-marching stuff\nResult scene (in vec3 p)\n{\n    float floor = p.y + .35;\n\n\tvec3 sphereCenter = p;\n\tvec3 boxCenter = p;\n\tfloat offsetX = 1. - vary (1., 1.);\n\tfloat offsetZ = 1. - vary (1., 1.);\n\tsphereCenter -= vec3 (offsetX, .25, offsetZ);\n\tboxCenter -= vec3 (.0, .0, .5);\n\n\tfloat sphere = sdSphere (sphereCenter, .6);\n\tfloat box = udRoundBox (boxCenter, vec3 (.35, .35, .7), .05);\n\tfloat r = .1 + .4*(.5 + .5*cos(5.*boxCenter.x*5.*boxCenter.y*5.*boxCenter.z));\n\tvec3 col1 = vec3 (vary (.5, 2.), vary (1., 1.), vary (.25, 2.));\n\tvec3 col2 = vec3 (1. - vary (.5, 2.), 1. - vary (1., 1.), vary (1., 1.));\n    vec4 colorAndDistance = smin (vec4 (col1, box), vec4 (col2, sphere), r);\n    float d = colorAndDistance.a;\n\tvec3 col = colorAndDistance.rgb;\n\n    Result res = Result (.0, vec3 (.0), 0);\n\tres.d = min (d, floor);\n    res.id = (res.d == floor) ? 1 : 2;\n    res.col = (res.d == floor) ? vec3 (.2) : col;\n    return res;\n}\n\nResult raymarch (in vec3 ro, in vec3 rd)\n{\n    Result res = Result (.0, vec3 (.0), 0);\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        vec3 p = ro + res.d * rd;\n        Result tmp = scene (p);\n        if (abs (tmp.d) < EPSILON*(1. + .125*tmp.d)) return res;\n        res.d += tmp.d * STEP_SIZE;\n        res.id = tmp.id;\n\t\tres.col = tmp.col;\n    }\n\n    return res;\n}\n\nvec3 normal (in vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    float d = scene (p).d;\n    vec3 n = vec3 (scene (p + e.xyy).d - d,\n                   scene (p + e.yxy).d - d,\n                   scene (p + e.yyx).d - d);\n    return normalize(n);\n}\n\nfloat shadow (in vec3 ro, in vec3 rd)\n{\n    float result = 1.;\n    float t = .1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        float h = scene (ro + t * rd).d;\n        if (h < 0.00001) return .0;\n        result = min (result, 8. * h/t);\n        t += h;\n    }\n\n    return result;\n}\n\nfloat ao (vec3 p, vec3 n, float d) {\n    return clamp (scene (p + d*n).d/d, .0, 1.);\n}\n\nvec3 shadePBR (vec3 ro, vec3 rd, float d, int id, vec3 col)\n{\n    vec3 p = ro + d*rd;\n    vec3 nor = normal (p);\n\n    // \"material\" hard-coded for the moment\n    vec3 albedo1 = vec3 (1.);\n    vec3 albedo2 = col;\n    vec3 albedo = (id == 1) ? albedo1 : albedo2;\n    float metallic  = (id == 1) ? .1 : .9;\n    float roughness = (id == 1) ? .9 : .1;\n    float ao = ao (p, nor, .25);\n\n    // lights hard-coded as well atm\n    vec3 lightColors[3];\n    lightColors[0] = vec3 (.7, .8, .9)*20.;\n    lightColors[1] = vec3 (.9, .8, .7)*20.;\n    lightColors[2] = vec3 (.9, .3, .2)*20.;\n\n    vec3 lightPositions[3];\n    lightPositions[0] = p + vec3 (.5, .75, -1.5);\n    lightPositions[1] = p + vec3 (-.5, .25, 1.);\n    lightPositions[2] = p + vec3 (-.1, 1., .1);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (0.04); \n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3(.0);\n\t\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for(int i = 0; i < 3; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - p);\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i] - p);\n        float attenuation = 1. / (distance * distance);\n        vec3 radiance     = lightColors[i] * attenuation;\n\t        \n        // cook-torrance brdf\n        float aDirect = .125 * pow (roughness + 1., 2.);\n        float aIBL = .5 * roughness * roughness;\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);\n\t        \n        vec3 kS = F;\n        kD = vec3(1.) - kS;\n        kD *= 1. - metallic;\t  \n\t        \n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = nominator / max(denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n\t    Lo *= shadow (p, L);\n    }\n\n    vec3 ambient = (kD * albedo) * ao;\n\n    return ambient + Lo;\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 f = normalize (vec3 (aim - ro));\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*zoom;\n\n    return normalize (c + uv.x*r + uv.y*u - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\tvec2 uv = uvRaw;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3 (-2.*cos(iTime), 1.5, -2.*sin(iTime));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    Result res = raymarch (ro, rd);\n    float fog = 1. / (1. + res.d * res.d * .1);\n    vec3 c = shadePBR (ro, rd, res.d, res.id, res.col);\n\n\tc *= fog;\n\tc = c / (1. + c);\n    c = .2 * c + .8 * sqrt (c);\n    c *= vec3 (.9, .8, .7);\n    c *= .2 + .8*pow(16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n\n\tfragColor = vec4(c, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}