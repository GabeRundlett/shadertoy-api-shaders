{
    "Shader": {
        "info": {
            "date": "1540105714",
            "description": "I added caustics to this post\nhttps://www.shadertoy.com/view/lssXD4\n\ncaustics technique reference\nhttps://medium.com/@evanwallace/rendering-realtime-caustics-in-webgl-2a99a29a0b2c\nhttps://www.shadertoy.com/view/MldfDn",
            "flags": 0,
            "hasliked": 0,
            "id": "MttBRS",
            "likes": 69,
            "name": "Float with Caustics",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "water",
                "caustics"
            ],
            "usePreview": 0,
            "username": "kaneta",
            "viewed": 3825
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 64\n#define EPSILON .001\n\n#define M_PI 3.14159265358979\n\nconst vec3 LightSource = vec3(3.,20.5, 3.);\n\nvec3 WaterColor = vec3(0.4, 0.9, 1);\n\nconst float WaterHeight = 0.;\nconst float MaxWaveAmplitude = 0.03;\n\nconst float HeightPool = 1.;\nconst float HalfSizePool = 3.;\nconst float DepthPool = 3.0;\n\nstruct MaterialInfo {\n\tvec3 Kd;\n\tfloat Shininess;\n};\n\nfloat CyclicTime()\n{\n\treturn mod(iTime, 30.);\n}\n\nfloat WaveAmplitude() {\n\treturn MaxWaveAmplitude * exp(-CyclicTime() / 10.);\n}\n\nfloat WaterWave(vec3 a) {\n    float wave = 0.0;\n    vec3 org = a;\n    float amp = WaveAmplitude();\n    wave += amp * min(pow(distance(org, vec3(0.0)), -1.), 2.0) * sin((2. * a.x * a.x + 2. * a.z * a.z) - 15. * CyclicTime());\n\treturn wave;\n}\n\nfloat BallOscillation() {\n\treturn sin(5. * CyclicTime() + 4.) * exp(-CyclicTime() / 6.) + 0.3;\n}\n\nfloat PoolBottom(vec3 a) {\n\treturn a.y + DepthPool + .01;\n}\n\nfloat BackWall(vec3 a) {\n\treturn a.z + HalfSizePool + .01;\n}\n\nfloat LeftWall(vec3 a) {\n\treturn a.x + HalfSizePool + .01;\n}\n\nfloat WaterSurface2(vec3 a) {\n\tvec3 sz = vec3(HalfSizePool, 0, HalfSizePool);\n\treturn length(max(abs(a + vec3(0, 0.0, 0)) - sz, 0.));\n}\n\nfloat WaterSurface(vec3 a) {\n\tvec3 sz = vec3(HalfSizePool, 0, HalfSizePool);\n\treturn length(max(abs(a + vec3(0, WaterWave(a), 0)) - sz, 0.));\n}\n\nfloat Pool(vec3 a) {\n\treturn min(PoolBottom(a), min(LeftWall(a), BackWall(a)));\n}\n\nfloat Pool2(vec3 a) {\n\treturn min(PoolBottom(a), min(LeftWall(a), BackWall(a)));\n}\n\nfloat Ball(vec3 a) {\n\treturn length(a + vec3(0., BallOscillation(), 0.)) - 0.75;\n}\n\nfloat Scene(vec3 a) {\n\treturn min(WaterSurface(a), min(Ball(a), Pool(a)));\n}\n\nbool IsWaterSurface(vec3 a)\n{\n\tfloat closest = Ball(a);\n\tfloat dist = Pool(a);\n\tif (dist < closest) {\n\t\tclosest = dist;\n\t}\t\n\tdist = WaterSurface(a);\n\tif (dist < closest) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsWater(vec3 pos)\n{\n\treturn (pos.y < (WaterHeight - MaxWaveAmplitude));\n}\n\nbool IsPool(vec3 pos)\n{\n    return Pool(pos) < 0.01;\n}\n\nbool IsBall(vec3 pos)\n{\n    return Ball(pos) < 0.01;\n}\n\nvec3 PoolColor(vec3 pos) {\t\t\n\tif ((pos.y > HeightPool) || (pos.x > HalfSizePool) || (pos.z > HalfSizePool)) \n\t\treturn vec3(0.0);\n\tfloat tileSize = 0.2;\n\tfloat thickness = 0.015;\n\tvec3 thick = mod(pos, tileSize);\n\tif ((thick.x > 0.) && (thick.x < thickness) || (thick.y > 0.) && (thick.y < thickness) || (thick.z > 0.) && (thick.z < thickness))\n\t\treturn vec3(1);\n\treturn vec3(sin(floor((pos.x + 1.) / tileSize)) * cos(floor((pos.y + 1.) / tileSize)) * sin(floor((pos.z + 1.) / tileSize)) + 3.);\n}\n\nMaterialInfo Material(vec3 a) {\n\tMaterialInfo m = MaterialInfo(vec3(.5, .56, 1.), 50.);\n\tfloat closest = Ball(a);\n\n\tfloat dist = WaterSurface(a);\n\tif (dist < closest) {\n\t\tclosest = dist;\n\t\tm.Kd = WaterColor;\n\t\tm.Shininess = 120.;\n\t}\n\tdist = Pool(a);\n\tif (dist < closest) {\n\t\tm.Kd = PoolColor(a);\t\t\n\t\tm.Shininess = 0.;\n\t}\n\treturn m;\n}\n\nvec3 Normal(vec3 a) {\n\tvec2 e = vec2(.001, 0.);\n\tfloat s = Scene(a);\n\treturn normalize(vec3(\n\t\tScene(a+e.xyy) - s,\n\t\tScene(a+e.yxy) - s,\n\t\tScene(a+e.yyx) - s));\n}\n\nfloat Occlusion(vec3 at, vec3 normal) {\n\tfloat b = 0.;\n\tfor (int i = 1; i <= 4; ++i) {\n\t\tfloat L = .06 * float(i);\n\t\tfloat d = Scene(at + normal * L);\t\t\n\t\tb += max(0., L - d);\n\t}\n\treturn min(b, 1.);\n}\n\nvec3 LookAt(vec3 pos, vec3 at, vec3 rDir) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0., 1., 0.));\n\tvec3 u = cross(r, f);\n\treturn mat3(r, u, -f) * rDir;\n}\n\nfloat Trace(vec3 rPos, vec3 rDir, float distMin) {\n\tfloat L = distMin;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n\t\tfloat d = Scene(rPos + rDir * L);\n\t\tL += d;\n\t\tif (d < EPSILON * L) break;\n\t}\n\treturn L;\n}\n\nvec3 Lighting(vec3 at, vec3 normal, vec3 eye, MaterialInfo m, vec3 lColor, vec3 lPos) {\n\tvec3 lDir = lPos - at;\n\t\n\tvec3 lDirN = normalize(lDir);\n\tfloat t = Trace(at, lDirN, EPSILON*2.);\n\tif (t < length(lDir)) {\n\t\tvec3 pos = at + lDirN * t;\n\t\tif(!IsWaterSurface(pos))\n\t\t\treturn vec3(0.);\n\t}\n\tvec3 color = m.Kd * lColor * max(0., dot(normal, normalize(lDir)));\n\t\n\tif (m.Shininess > 0.) {\n\t\tvec3 h = normalize(normalize(lDir) + normalize(eye - at));\n\t\tcolor += lColor * pow(max(0., dot(normal, h)), m.Shininess) * (m.Shininess + 8.) / 25.;\n\t}\n\treturn color / dot(lDir, lDir);\n}\n\n\nfloat beforeWater(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 64; i++) {\n        float res = WaterSurface2(ro+ray*t);\n        if( res < 0.0001 ) return t;\n        t += res;\n    }\n\n    return -1.0;\n}\n\nfloat water(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        float res = WaterSurface(ro+ray*t);\n        if( res < 0.01 ) return t;\n        t += res*0.5;\n    }\n\n    return -1.0;\n}\n\nfloat pool(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    for (int i = 0; i < 64; i++) {\n        float res = Pool(ro+ray*t);\n        if( res < 0.001 ) return t;\n        t += res;\n    }\n\n    return -1.0;\n}\n\nfloat caustics(vec3 p, vec3 lp) {\n    vec3 ray = normalize(p - lp);\n    \n    float d = beforeWater(lp, ray);\n    vec3 inter = lp + ray * d;\n\n    \n    if (d < -0.5) {\n    \treturn (0.0);\n    }\n    \n    //d = water(lp, ray);\n    //vec3 surfpos = lp + ray * d;\n    vec3 surfpos = inter - vec3(0., WaterWave(inter) - 0.01, 0.);\n    \n    vec3 refractRay = refract(ray, vec3(0., 1., 0.), 1./1.333);\n    float beforeHit = pool(inter, refractRay);\n    vec3 beforePos = inter + refractRay * beforeHit;\n    //return beforePos.y;\n    float tp = (-beforePos.y - DepthPool) / refractRay.y;\n    beforePos += refractRay * tp;\n\n    refractRay = refract(ray, Normal(surfpos), 1./1.333);\n    float afterHit = pool(surfpos, refractRay);\n    vec3 afterPos = surfpos + refractRay * afterHit;\n    tp = (-afterPos.y - DepthPool) / refractRay.y;\n    afterPos += refractRay * tp;\n\n    float beforeArea = length(dFdx(beforePos)) * length(dFdy(beforePos));\n    float afterArea = length(dFdx(afterPos)) * length(dFdy(afterPos));\n    return max(beforeArea / afterArea, .001);\n}\n\nvec3 Shade(vec3 rpos, vec3 rdir, float t)\n{\n\tvec3 pos = rpos + rdir * t;\n\tvec3 nor = Normal(pos);\n\t\n\tbool waterSurface = IsWaterSurface(pos);\n\tbool water = IsWater(pos);\n\tvec3 waterSurfaceLight = vec3(0);\n    vec3 light = vec3(50.);\n\tif (waterSurface)\n\t{\n\t\tvec3 refractionDir = refract(normalize(rdir), nor, 1./1.333);\n\n\t\twaterSurfaceLight = Lighting(pos, nor, rpos, Material(pos), light, LightSource);\n\n\t\tfloat wt = Trace(pos, refractionDir, 0.03);\t\t\n\t\tpos += refractionDir * wt;\n\t\tnor = Normal(pos);\n\t}\n\tMaterialInfo mat = Material(pos);\n\n\tvec3 color = .11 * mat.Kd;\n\n\t\n\tif (water || waterSurface) {\n        if (IsPool(pos) || (IsBall(pos) && water)) {\n            color += Lighting(pos, nor, rpos, mat, light, LightSource) * vec3(caustics(pos, LightSource));\n            color *= WaterColor;\n        }\n        if (waterSurface) {\n\t\t\tcolor += waterSurfaceLight;\n        }\n    } else {\n        color += Lighting(pos, nor, rpos, mat, light, LightSource);\n    }\n\treturn color;\n}\n\nvec3 Camera(vec2 px) {\n\tvec2 uv = px.xy / iResolution.xy * 2. - 1.;\t\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float x = M_PI * 0.15;\n    float y = 4.;\n   \n\tif (iMouse.z>=1.) {\n    \tx = (iMouse.x/iResolution.x - .5)*7.;\n    \ty = (iMouse.y/iResolution.y)*7.;\n    \tx = clamp(x, -0.2, 1.8);\n    }\n    \n\tvec3 rayStart = vec3(sin(x) * 10.0, y * 1.5, cos(x) * 10.0);\n\tvec3 rayDirection = LookAt(rayStart, vec3(0, sin(iTime * 0.5) -1.5, 0), normalize(vec3(uv, -3.)));\n\t\n\tfloat path = Trace(rayStart, rayDirection, 0.);\t\n\treturn Shade(rayStart, rayDirection, path);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 col = Camera(fragCoord.xy);\n\tfragColor = vec4(col, 0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}