{
    "Shader": {
        "info": {
            "date": "1677182872",
            "description": "CC0: For the neon style enjoyers\nOr is it synthwave style? Don't know!\nAnyone been tinkering with this for awhile and now want to get on with other stuff\nHopefully someone enjoys it.\n",
            "flags": 64,
            "hasliked": 0,
            "id": "ddcGW8",
            "likes": 148,
            "name": "For the neon style enjoyers",
            "published": 3,
            "tags": [
                "neon"
            ],
            "usePreview": 1,
            "username": "mrange",
            "viewed": 5076
        },
        "renderpass": [
            {
                "code": "// CC0: For the neon style enjoyers\n//  Or is it synthwave style? Don't know!\n//  Anyone been tinkering with this for awhile and now want to get on with other stuff\n//  Hopefully someone enjoys it.\n\n//#define THAT_CRT_FEELING\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nvec3 rgb2hsv(vec3 c) {\n  const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nconst vec3 skyCol       = HSV2RGB(vec3(0.58, 0.86, 1.0));\nconst vec3 speCol1      = HSV2RGB(vec3(0.60, 0.25, 1.0));\nconst vec3 speCol2      = HSV2RGB(vec3(0.55, 0.25, 1.0));\nconst vec3 diffCol1     = HSV2RGB(vec3(0.60, 0.90, 1.0));\nconst vec3 diffCol2     = HSV2RGB(vec3(0.55, 0.90, 1.0));\nconst vec3 sunCol1      = HSV2RGB(vec3(0.60, 0.50, 0.5));\nconst vec3 sunDir2      = normalize(vec3(0., 0.82, 1.0));\nconst vec3 sunDir       = normalize(vec3(0.0, 0.05, 1.0));\nconst vec3 sunCol       = HSV2RGB(vec3(0.58, 0.86, 0.0005));\nconst float mountainPos = -20.0;\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan_approx(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat equilateralTriangle(vec2 p) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length(pa - ba*h);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat vnoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n    \n  vec2 u = f*f*(3.0-2.0*f);\n\n  float a = hash(i + vec2(0.0,0.0));\n  float b = hash(i + vec2(1.0,0.0));\n  float c = hash(i + vec2(0.0,1.0));\n  float d = hash(i + vec2(1.0,1.0));\n  \n  float m0 = mix(a, b, u.x);\n  float m1 = mix(c, d, u.x);\n  float m2 = mix(m0, m1, u.y);\n  \n  return m2;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 dim) {\n  vec3 ce = dim.xyz;\n  float ra = dim.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\nvec3 skyRender(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  col += 0.025*skyCol;\n  col += skyCol*0.0033/pow((1.001+((dot(sunDir2, rd)))), 2.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += (0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nvec4 sphere(vec3 ro, vec3 rd, vec4 sdim) {\n  vec2 si = raySphere(ro, rd, sdim);\n  \n  vec3 nsp = ro + rd*si.x;\n\n  const vec3 lightPos1   = vec3(0.0, 10.0, 10.0);\n  const vec3 lightPos2   = vec3(0.0, -80.0, 10.0);\n  \n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n  \n  vec3 nnor   = normalize(nsp - sdim.xyz);\n\n  vec3 nref   = reflect(rd, nnor);\n\n  const float sf = 4.0;\n  float ndif1 = max(dot(nld1, nnor), 0.0);\n  ndif1       *= ndif1;\n  vec3 nspe1  = pow(speCol1*max(dot(nld1, nref), 0.0), sf*vec3(1.0, 0.8, 0.5));\n\n  float ndif2 = max(dot(nld2, nnor), 0.0);\n  ndif2       *= ndif2;\n  vec3 nspe2  = pow(speCol2*max(dot(nld2, nref), 0.0), sf*vec3(0.9, 0.5, 0.5));\n\n  vec3 nsky   = skyRender(nsp, nref);\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 scol = vec3(0.0); \n  scol += nsky*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);\n  scol += diffCol1*ndif1;\n  scol += diffCol2*ndif2;\n  scol += nspe1;\n  scol += nspe2;\n  \n  float t = tanh_approx(2.0*(si.y-si.x)/sdim.w);\n  \n  return vec4(scol, t);\n}\n\nvec3 sphereRender(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyRender(ro, rd);\n  vec3 col = skyCol;\n  const vec4 sdim0 = vec4(vec3(0.0), 2.0);\n  vec4 scol0 = sphere(ro, rd, sdim0);\n  col = mix(col, scol0.xyz, scol0.w);\n  return col;\n}\n\nvec3 sphereEffect(vec2 p) {\n  const float fov = tan(TAU/6.0);\n  const vec3 ro = 1.0*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = sphereRender(ro, rd);\n  \n  return col;\n}\n\nvec3 cityOfKali(vec2 p) {\n  vec2 c = -vec2(0.5, 0.5)*1.12;\n\n  float s = 2.0;\n  vec2 kp = p/s;\n \n  const float a = PI/4.0;\n  const vec2 n = vec2(cos(a), sin(a));\n\n  float ot2 = 1E6;\n  float ot3 = 1E6;\n  float n2 = 0.0;\n  float n3 = 0.0;\n\n  const float mx = 12.0;\n  for (float i = 0.0; i < mx; ++i) {\n    float m = (dot(kp, kp));\n    s *= m;\n    kp = abs(kp)/m + c;\n    float d2 = (abs(dot(kp,n)))*s;\n    if (d2 < ot2) {\n      n2 = i;\n      ot2 = d2;\n    }\n    float d3 = (dot(kp, kp));\n    if (d3 < ot3) {\n      n3 = i;\n      ot3 = d3;\n    }\n  }\n  vec3 col = vec3(0.0);\n  n2 /= mx;\n  n3 /= mx;\n  col += 0.25*(hsv2rgb(vec3(0.8-0.2*n2*n2, 0.90, 0.025))/(sqrt(ot2)+0.0025));\n  col += hsv2rgb(vec3(0.55+0.8*n3, 0.85, 0.00000025))/(ot3*ot3+0.000000025);\n  return col;\n}\n\nvec3 outerSkyRender(vec3 ro, vec3 rd) {\n  vec3 center = ro+vec3(-100.0, 40.0, 100.0);\n  vec4 sdim = vec4(center, 50);\n  vec2 pi = raySphere(ro, rd, sdim);\n  const vec3 pn = normalize(vec3(0., 1.0, -0.8));\n  vec4 pdim = vec4(pn, -dot(pn, center)); \n  float ri = rayPlane(ro, rd, pdim);\n\n  vec3 col = vec3(0.0);\n  \n  col += sunCol/pow((1.001-((dot(sunDir, rd)))), 2.0);\n\n  if (pi.x != -1.0) {\n    vec3 pp = ro + rd*pi.x;\n    vec3 psp= pp-sdim.xyz;\n    vec3 pn = normalize(pp-sdim.xyz);\n    psp = psp.zxy;\n    psp.yz *= ROT(-0.5);\n    psp.xy *= ROT(0.025*TIME);\n    vec3 pss= toSpherical(psp);\n    vec3 pcol = vec3(0.0);\n    float dif = max(dot(pn, sunDir), 0.0);\n    vec3 sc = 2000.0*sunCol;\n    pcol += sc*dif;\n    pcol += (cityOfKali(pss.yz))*smoothstep(0.125, 0.0, dif);\n    pcol += pow(max(dot(reflect(rd, pn), sunDir), 0.0), 9.0)*sc;\n    col = mix(col, pcol, tanh_approx(0.125*(pi.y-pi.x)));\n    \n  }\n\n  vec3 gcol = vec3(0.0);\n\n  vec3 rp = ro + rd*ri;\n  float rl = length(rp-center);\n  float rb = 1.55*sdim.w;\n  float re = 2.45*sdim.w;\n  float rw = 0.1*sdim.w;\n  vec3 rcol = hsv2rgb(vec3(clamp((0.005*(rl+32.0)), 0.6, 0.8), 0.9, 1.0));\n  gcol = rcol*0.025;\n  if (ri > 0.0 && (pi.x == -1.0 || ri < pi.x)) {\n    float mrl = rl;\n    float nrl = mod1(mrl, rw);\n    float rfre = 1.0+dot(rd, pn);\n    vec3 rrcol = (rcol/max(abs(mrl), 0.1+smoothstep(0.7, 1.0, rfre))); \n    rrcol *= smoothstep(1.0, 0.3, rfre);\n    rrcol *= smoothstep(re, re-0.5*rw, rl);\n    rrcol *= smoothstep(rb-0.5*rw, rb, rl);\n    col += rrcol;;\n  }\n\n  col += gcol/max(abs(rd.y), 0.0033);\n\nreturn col;\n}\n\nvec3 triRender(vec3 col, vec3 ro, vec3 rd, inout float maxt) {\n  const vec3 tpn = normalize(vec3(0.0, 0.0, 1.0));\n  const vec4 tpdim = vec4(tpn, -2.0);\n  float tpd = rayPlane(ro, rd, tpdim);\n\n  if (tpd < 0.0 || tpd > maxt) {\n    return col;\n  }\n\n  vec3 pp = ro+rd*tpd;\n  vec2 p = pp.xy;\n  p *= 0.5;\n\n  const float off = 1.2-0.02;\n  vec2 op = p; \n  p.y -= off;\n  const vec2 n = SCA(-PI/3.0);\n  vec2 gp = p;\n  float hoff = 0.15*dot(n, p);\n  vec3 gcol = hsv2rgb(vec3(clamp(0.7+hoff, 0.6, 0.8), 0.90, 0.02));\n  vec2 pt = p;\n  pt.y = -pt.y;\n  const float zt = 1.0;\n  float dt = equilateralTriangle(pt/zt)*zt;\n//  col += 2.0*gcol;\n  col = dt < 0.0 ? sphereEffect(1.5*(p)) : col;\n  col += (gcol/max(abs(dt), 0.001))*smoothstep(0.25, 0.0, dt);\n  if (dt < 0.0) {\n    maxt = tpd;\n  }\n  return col;  \n}\n\nfloat heightFactor(vec2 p) {\n  return 4.0*smoothstep(7.0, 0.5, abs(p.x))+.5;\n}\n\nfloat hifbm(vec2 p) {\n  p *= 0.25;\n  float hf = heightFactor(p);\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return hf*sum;\n}\n\nfloat hiheight(vec2 p) {\n  return hifbm(p);\n}\n\nfloat lofbm(vec2 p) {\n  p *= 0.25;\n  float hf = heightFactor(p);\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return hf*sum;\n}\n\nfloat loheight(vec2 p) {\n  return lofbm(p)-0.5;\n}\n\nvec3 mountainRender(vec3 col, vec3 ro, vec3 rd, bool flip, inout float maxt) {\n  const vec3 tpn = normalize(vec3(0.0, 0.0, 1.0));\n  const vec4 tpdim = vec4(tpn, mountainPos);\n  float tpd = rayPlane(ro, rd, tpdim);\n\n  if (tpd < 0.0 || tpd > maxt) {\n    return col;\n  }\n\n  vec3 pp = ro+rd*tpd;\n  vec2 p = pp.xy;\n  const float cw = 1.0-0.25;\n  float hz = 0.0*TIME+1.0;\n  float lo = loheight(vec2(p.x, hz));\n  vec2 cp = p;\n  float cn = mod1(cp.x, cw);\n\n\n  const float reps = 1.0;\n\n  float d = 1E3;\n\n  for (float i = -reps; i <= reps; ++i) {\n    float x0 = (cn -0.5 + (i))*cw;\n    float x1 = (cn -0.5 + (i + 1.0))*cw;\n  \n    float y0 = hiheight(vec2(x0, hz));\n    float y1 = hiheight(vec2(x1, hz));\n    \n    float dd = segment(cp, vec2(-cw*0.5 + cw * float(i), y0), vec2(cw*0.5 + cw * float(i), y1));\n    \n    d = min(d, dd);\n  }\n\n  vec3 rcol = hsv2rgb(vec3(clamp(0.7+(0.5*(rd.x)), 0.6, 0.8), 0.95, 0.125));\n\n  float sd = 1.0001-((dot(sunDir, rd)));\n\n  vec3 mcol = col;\n  float aa = fwidth(p.y);\n  if ((dFdy(d) < 0.0) == !flip) {\n    mcol *= mix(0.0, 1.0, smoothstep(aa, -aa, d-aa));\n    mcol += HSV2RGB(vec3(0.55, 0.85, 0.8))*smoothstep(0.0, 5.0, lo-p.y);\n    col = mcol;\n    maxt = tpd;\n  }\n  col += 3.*rcol/(abs(d)+0.005+800.*sd*sd*sd*sd);\n  col += HSV2RGB(vec3(0.55, 0.96, 0.075))/(abs(p.y)+0.05);\n\n  return col;  \n}\n\nvec3 groundRender(vec3 col, vec3 ro, vec3 rd, inout float maxt) {\n  const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));\n  const vec4 gpdim = vec4(gpn, 0.0);\n  float gpd = rayPlane(ro, rd, gpdim);\n\n  if (gpd < 0.0) {\n    return col;\n  }\n  \n  maxt = gpd;\n  \n  vec3 gp     = ro + rd*gpd;\n  float gpfre = 1.0 + dot(rd, gpn);\n  gpfre *= gpfre;\n  gpfre *= gpfre;\n  gpfre *= gpfre;\n  \n  vec3 grr = reflect(rd, gpn);\n  \n  vec2 ggp    = gp.xz;\n  ggp.y += TIME;\n  float dfy   = dFdy(ggp.y);\n  float gcf = sin(ggp.x)*sin(ggp.y);\n  vec2 ggn    = mod2(ggp, vec2(1.0));\n  float ggd   = min(abs(ggp.x), abs(ggp.y));\n\n  vec3 gcol = hsv2rgb(vec3(0.7+0.1*gcf, 0.90, 0.02));\n  \n  float rmaxt = 1E6;\n  vec3 rcol = outerSkyRender(gp, grr);\n  rcol = mountainRender(rcol, gp, grr, true, rmaxt);\n  rcol = triRender(rcol, gp, grr, rmaxt);\n\n  col = gcol/max(ggd, 0.0+0.25*dfy)*exp(-0.25*gpd);\n  rcol += HSV2RGB(vec3(0.65, 0.85, 1.0))*gpfre;\n  rcol = 4.0*tanh(rcol*0.25);\n  col += rcol*gpfre;\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  float maxt = 1E6;  \n\n  vec3 col = outerSkyRender(ro, rd);\n  col = groundRender(col, ro, rd, maxt);\n  col = mountainRender(col, ro, rd, false, maxt);\n  col = triRender(col, ro, rd, maxt);\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const float fov = tan(TAU/6.0);\n  const vec3 ro = 1.0*vec3(0.0, 1.0, -4.);\n  const vec3 la = vec3(0.0, 1.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = render(ro, rd);\n#if defined(THAT_CRT_FEELING)  \n  col *= smoothstep(1.5, 0.5, length(pp));\n  col *= 1.25*mix(vec3(0.5), vec3(1.0),smoothstep(-0.9, 0.9, sin(0.25*TAU*p.y/aa+TAU*vec3(0.0, 1., 2.0)/3.0)));\n#endif  \n  col -= 0.05*vec3(.00, 1.0, 2.0).zyx;\n  col = aces_approx(col); \n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 32476,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/lotekstyle/lotek-style-she-danced-to-tainted-love-distracted-globe-prom-night-mix?si=3d284d8939304a2db4af73bfa86ae6c2&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}