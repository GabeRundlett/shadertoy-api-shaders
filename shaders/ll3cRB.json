{
    "Shader": {
        "info": {
            "date": "1533002989",
            "description": "ray trace - seed dance performed by sexy balls",
            "flags": 64,
            "hasliked": 0,
            "id": "ll3cRB",
            "likes": 10,
            "name": "seed dance",
            "published": 3,
            "tags": [
                "raytracedance"
            ],
            "usePreview": 1,
            "username": "lasiafly",
            "viewed": 894
        },
        "renderpass": [
            {
                "code": "const int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 4;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 26;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nfloat centerx=0.6;\nfloat centery = 1.315;\nfloat centerz=0.8;\nfloat headr=0.15;\nfloat bodyr=0.08;\nfloat legr=0.05;\nfloat armr=0.05;\nfloat armcenterx;\nfloat armcentery;\nfloat zout = 0.08;\nvec3 lighta0;\nvec3 lighta1;\n\nvoid lightchange(out vec3 attr0, out vec3 attr1){\n    if(iTime < 6.5){\n        attr0 = vec3(0.0);\n        attr1 = vec3(0.0);\n    }\n    else if(iTime == 6.5){\n        attr0 = vec3(1.0);\n        attr1 = vec3(1.0);\n    }\n    else if(iTime > 6.5 && iTime < 13.0){\n        attr0 = vec3(abs(sin(0.2 * iTime)), 0.5, 0.5);\n        attr1 = vec3(0.0);\n    }\n    \n    else if(iTime >= 13.0 && iTime < 19.0){\n        attr0 = vec3(0.0);\n        attr1 = vec3(0.5, 0.5, abs(sin(0.4 * iTime)));\n    }\n    \n    else if(iTime>77.5&&iTime<104.87){\n        attr0 = vec3(0.8 * abs(sin(1.0 * iTime)), 0.8 * abs(sin(1.3 * iTime)), 0.8 * abs(sin(1.5 * iTime)));\n        attr1 = vec3(0.8 * abs(sin(1.5*iTime)), 0.8 * abs(sin( 1.3* iTime)), 0.8 * abs(sin(1.0 * iTime)));\n    }\n    else\n        \n    {\n        attr0 = vec3(0.8 * abs(sin(0.2 * iTime)), 0.8 * abs(sin(0.5 * iTime)), 0.8 * abs(sin(0.8 * iTime)));\n        attr1 = vec3(0.8 * abs(sin(iTime)), 0.8 * abs(sin(0.7 * iTime)), 0.8 * abs(sin(0.4 * iTime)));\n        \n    }\n}\nvoid Update()\n{\n    Sphere[0].center = vec3(centerx ,centery, centerz);\n    Sphere[1].center = vec3( centerx  , centery-headr-bodyr, centerz);\n    Sphere[2].center = vec3( centerx  , centery-(headr+bodyr*3.0), centerz);\n    Sphere[3].center = vec3( centerx , centery-(headr+bodyr*5.0), centerz);\n    Sphere[4].center = vec3(centerx ,centery-(headr+bodyr*7.0) , centerz);\n    Sphere[5].center = vec3(centerx ,centery-(headr+bodyr*9.0) , centerz);\n    Sphere[6].center = vec3( centerx+bodyr+armr ,armcentery , centerz);\n    Sphere[8].center = vec3( centerx+bodyr+armr*5.0 ,armcentery, centerz);\n    Sphere[10].center = vec3( centerx+bodyr+armr*9.0,armcentery, centerz);\n    Sphere[11].center = vec3( centerx-(bodyr+armr),armcentery, centerz);\n    Sphere[13].center = vec3( centerx-(bodyr+armr*5.0),armcentery, centerz);\n    Sphere[15].center = vec3( centerx-(bodyr+armr*9.0),armcentery, centerz);\n    Sphere[16].center = vec3( centerx-0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[18].center = vec3( centerx-0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[20].center = vec3( centerx-0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[21].center = vec3( centerx+0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[23].center = vec3( centerx+0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[25].center =  vec3( centerx+0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[24].center =(Sphere[23].center +Sphere[25].center )/2.0;;\n    Sphere[12].center =  (Sphere[11].center+Sphere[13].center)/2.0;\n    Sphere[14].center =  (Sphere[13].center+Sphere[15].center)/2.0;\n    Sphere[17].center = (Sphere[16].center+Sphere[18].center)/2.0;\n    Sphere[7].center = (Sphere[6].center+Sphere[8].center)/2.0;\n    Sphere[9].center = (Sphere[8].center+Sphere[10].center)/2.0;\n    Sphere[19].center = (Sphere[18].center +Sphere[20].center )/2.0;\n    Sphere[22].center = (Sphere[21].center +Sphere[23].center )/2.0;\n    \n    \n}\n\n//basic action\n/*right arm right wave*/\nvoid rightarm_rwave(float freq, float amp){\n    Sphere[6].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[8].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[10].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[10].center.x += abs(amp * cos(0.15*freq * iTime));\n    \n}\nvoid rightarm_lwave(float freq, float amp){\n    Sphere[10].center.xy = Sphere[2].center.xy;\n    Sphere[10].center.z += zout;\n    Sphere[10].center.x -= 3.*armr;\n    Sphere[10].center.y -= 0.15;\n    Sphere[8].center.z += zout;\n    Sphere[8].center.y -= 0.15;\n    Sphere[6].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[8].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[10].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[10].center.x += abs(amp * cos(0.15*freq * iTime));\n    \n}\n/*right arm up wave*/\nvoid rightarm_ulwave(float freq, float amp){\n    Sphere[6].center.y += 0.5*armr;\n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y += 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y += 9.*armr;\n    Sphere[8].center.x -= amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    Sphere[8].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[10].center.y -= 2.*amp * abs(sin(iTime));\n}\nvoid rightarm_urwave(float freq, float amp){\n    Sphere[6].center.y += 0.5*armr;\n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y += 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y += 9.*armr;\n    Sphere[8].center.x += amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    Sphere[8].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[10].center.y -= 2.*amp * abs(sin(iTime));\n}\n/*right arm front wave*/\nvoid rightarm_fwave(float freq, float amp){\n    Sphere[6].center.y += 0.5 * amp * sin(freq * iTime);\n    Sphere[8].center.x = Sphere[6].center.x;\n    Sphere[8].center.z = Sphere[6].center.z+3.*armr;\n    Sphere[8].center.y -= 0.5 * amp * sin(freq * iTime);\n    Sphere[10].center.x = Sphere[6].center.x;\n    Sphere[10].center.z = Sphere[6].center.z+9.*armr;\n    Sphere[10].center.y += 0.8 * amp * sin(freq * iTime);\n}\n/*right arm down wave*/\nvoid rightarm_dlwave(float freq, float amp){\n    Sphere[6].center.y -= 0.5*armr;\n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y -= 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y -= 8.*armr;\n    Sphere[8].center.x -= 2.*amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    \n}\nvoid rightarm_drwave(float freq, float amp){\n    \n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y -= 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y -= 8.*armr;\n    Sphere[8].center.x += 2.*amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    \n}\n\n/*left arm right wave*/\nvoid leftarm_rwave(float freq, float amp){\n    Sphere[15].center.xy = Sphere[2].center.xy;\n    Sphere[15].center.z += zout;\n    Sphere[15].center.x += 3.*armr;\n    Sphere[15].center.y -= 0.15;\n    Sphere[13].center.z += zout;\n    Sphere[13].center.y -= 0.15;\n    Sphere[11].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[13].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[15].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[15].center.x -= abs(amp * cos(0.15*freq * iTime));\n}\n/*left arm left wave*/\nvoid leftarm_lwave(float freq, float amp){\n    Sphere[11].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[13].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[15].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[15].center.x -= abs(amp * cos(0.15*freq * iTime));\n}\n/*left arm up wave*/\nvoid leftarm_ulwave(float freq, float amp){\n    Sphere[11].center.y += 0.5*armr;\n    Sphere[11].center.x -= 0.8 * amp * sin(freq * iTime);\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y += 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y += 9.*armr;\n    Sphere[13].center.x += amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n    Sphere[13].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[15].center.y -= 2.*amp * abs(sin(iTime));\n    \n}\nvoid leftarm_urwave(float freq, float amp){\n    Sphere[11].center.y += 0.5*armr;\n    Sphere[11].center.x -= 0.8 * amp * sin(freq * iTime);\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y += 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y += 9.*armr;\n    Sphere[13].center.x -= amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n    Sphere[13].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[15].center.y -= 2.*amp * abs(sin(iTime));\n}\n/*left arm down wave*/\n\nvoid leftarm_dlwave(float freq, float amp){\n    Sphere[11].center.y -= 0.5*armr;\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y -= 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y -= 8.*armr;\n    Sphere[13].center.x += 2.*amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n    \n}\nvoid leftarm_drwave(float freq, float amp){\n    Sphere[11].center.y -= 0.5*armr;\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y -= 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y -= 8.*armr;\n    Sphere[13].center.x -= 2.*amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n}\n\n/*left arm front wave*/\nvoid leftarm_fwave(float freq, float amp){\n    Sphere[11].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[13].center.x = Sphere[11].center.x;\n    Sphere[13].center.z = Sphere[11].center.z+3.*armr;\n    Sphere[13].center.y -= 0.5 * amp * sin(freq * iTime);\n    Sphere[15].center.x = Sphere[11].center.x;\n    Sphere[15].center.z = Sphere[11].center.z+9.*armr;\n    Sphere[15].center.y += 0.8 * amp * sin(freq * iTime);\n}\n\n\nvoid llegwave(float freq,float amp)\n{\n    Sphere[16].center.x += 0.01 * cos(freq * iTime);\n    Sphere[16].center.z += 0.01 * sin(freq * iTime);\n    Sphere[17].center.x += 0.03 * sin(freq * iTime);\n    Sphere[17].center.z += 0.03 * cos(freq * iTime);\n    Sphere[18].center.x += 0.05 * sin(freq * iTime);\n    Sphere[18].center.z += 0.05 * cos(freq * iTime);\n    Sphere[19].center.x += 0.03 * sin(freq * iTime);\n    Sphere[19].center.z += 0.03 * cos(freq * iTime);\n    Sphere[20].center.x += 0.01 * sin(freq * iTime);\n    Sphere[20].center.z += 0.01 * cos(freq * iTime);\n}\n\n\n\nvoid rlegwave(float freq,float amp)\n{\n    Sphere[21].center.x += 0.01 * cos(freq * iTime);\n    Sphere[21].center.z += 0.01 * sin(freq * iTime);\n    Sphere[22].center.x += 0.03 * sin(freq * iTime);\n    Sphere[22].center.z += 0.03 * cos(freq * iTime);\n    Sphere[23].center.x += 0.05 * sin(freq * iTime);\n    Sphere[23].center.z += 0.05 * cos(freq * iTime);\n    Sphere[24].center.x += 0.03 * sin(freq * iTime);\n    Sphere[24].center.z += 0.03 * cos(freq * iTime);\n    Sphere[25].center.x += 0.01 * sin(freq * iTime);\n    Sphere[25].center.z += 0.01 * cos(freq * iTime);\n}\n\nvoid rllegwave(float freq,float amp)\n{\n    Sphere[21].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[21].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[22].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[22].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[23].center.x -= 0.05 * sin(freq * iTime);\n    Sphere[23].center.z -= 0.05 * cos(freq * iTime);\n    Sphere[24].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[24].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[25].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[25].center.z -= 0.01 * cos(freq * iTime);\n}\n\nvoid body_movex(float amp)\n{\n    centerx +=amp*sin(1.0*iTime);\n    \n}\n\nvoid body_movez(float amp)\n{\n    centerz +=amp*sin(1.0*iTime);\n}\n\n\n/*waist left*/\n\nvoid waist_lwave(float freq, float amp){\n    Sphere[0].center.x += 0.01 * cos(freq * iTime);\n    Sphere[0].center.z += 0.01 * sin(freq * iTime);\n    Sphere[1].center.x += 0.01 * sin(freq * iTime);\n    Sphere[1].center.z += 0.01 * cos(freq * iTime);\n    Sphere[2].center.x += 0.03 * sin(freq * iTime);\n    Sphere[2].center.z += 0.03 * cos(freq * iTime);\n    Sphere[3].center.x += 0.05 * sin(freq * iTime);\n    Sphere[3].center.z += 0.05 * cos(freq * iTime);\n    Sphere[4].center.x += 0.03 * sin(freq * iTime);\n    Sphere[4].center.z += 0.03 * cos(freq * iTime);\n    Sphere[5].center.x += 0.01 * sin(freq * iTime);\n    Sphere[5].center.z += 0.01 * cos(freq * iTime);\n}\n\nvoid noodle_arm(float freq, float amp){\n    Sphere[0].center.x += 0.01 * cos(freq * iTime);\n    Sphere[0].center.z += 0.01 * sin(freq * iTime);\n    Sphere[1].center.x += 0.01 * sin(freq * iTime);\n    Sphere[1].center.z += 0.01 * cos(freq * iTime);\n    Sphere[2].center.x += 0.03 * sin(freq * iTime);\n    Sphere[2].center.z += 0.03 * cos(freq * iTime);\n    Sphere[3].center.x += 0.05 * sin(freq * iTime);\n    Sphere[3].center.z += 0.05 * cos(freq * iTime);\n    Sphere[4].center.x += 0.03 * sin(freq * iTime);\n    Sphere[4].center.z += 0.03 * cos(freq * iTime);\n    Sphere[5].center.x += 0.01 * sin(freq * iTime);\n    Sphere[5].center.z += 0.01 * cos(freq * iTime);\n    Sphere[6].center.y += 0.01 * sin(freq * iTime);\n    Sphere[6].center.z += 0.01 * cos(freq * iTime);\n    Sphere[7].center.y += 0.03 * sin(freq * iTime);\n    Sphere[7].center.z += 0.03 * cos(freq * iTime);\n    Sphere[8].center.y += 0.05 * sin(freq * iTime);\n    Sphere[8].center.z += 0.05 * cos(freq * iTime);\n    Sphere[9].center.y += 0.03 * sin(freq * iTime);\n    Sphere[9].center.z += 0.03 * cos(freq * iTime);\n    Sphere[10].center.y -= 0.01 * sin(freq * iTime);\n    Sphere[10].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[11].center.y -= 0.01 * sin(freq * iTime);\n    Sphere[11].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[12].center.y -= 0.03 * sin(freq * iTime);\n    Sphere[12].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[13].center.y -= 0.05 * sin(freq * iTime);\n    Sphere[13].center.z -= 0.05 * cos(freq * iTime);\n    Sphere[14].center.y -= 0.03 * sin(freq * iTime);\n    Sphere[14].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[15].center.y -= 0.01 * sin(freq * iTime);\n    Sphere[15].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[16].center.x += 0.01 * sin(freq * iTime);\n    Sphere[16].center.z += 0.01 * cos(freq * iTime);\n    Sphere[17].center.x += 0.03 * sin(freq * iTime);\n    Sphere[17].center.z += 0.03 * cos(freq * iTime);\n    Sphere[18].center.x += 0.05 * sin(freq * iTime);\n    Sphere[18].center.z += 0.05 * cos(freq * iTime);\n    Sphere[19].center.x += 0.03 * sin(freq * iTime);\n    Sphere[19].center.z += 0.03 * cos(freq * iTime);\n    Sphere[20].center.x += 0.01 * sin(freq * iTime);\n    Sphere[20].center.z += 0.01 * cos(freq * iTime);\n    Sphere[21].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[21].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[22].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[22].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[23].center.x -= 0.05 * sin(freq * iTime);\n    Sphere[23].center.z -= 0.05 * cos(freq * iTime);\n    Sphere[24].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[24].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[25].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[25].center.z -= 0.01 * cos(freq * iTime);\n    \n}\n\n/*head node*/\nvoid head_node(float freq, float amp){\n    float theta = amp * abs(sin(freq * iTime));\n    Sphere[0].center.x =  Sphere[1].center.x + headr * sin(theta);\n    Sphere[0].center.y = Sphere[1].center.y + headr * cos(theta);\n    \n}\n\nvoid assmove(float freq, float amp){\n    Sphere[5].center.x += amp * sin(freq * iTime);\n    Sphere[5].center.y += amp * sin(freq * iTime);\n    Sphere[4].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[4].center.y += 0.8 * amp * sin(freq * iTime);\n    Sphere[16].center.x += 0.5 * amp * sin(freq * iTime);\n    Sphere[16].center.y += 0.5 * amp * sin(freq * iTime);\n    Sphere[21].center.x += 0.5 * amp * sin(freq * iTime);\n    Sphere[21].center.y += 0.5 * amp * sin(freq * iTime);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n\n{\n    lightchange(lighta0,lighta1);\n    armcenterx= centerx+bodyr+armr*5.0;\n    armcentery=centery-(headr+bodyr*3.0);\n    int flag = 0;\n    \n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n    \n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n    \n    // Center bouncing sphere.\n    \n    Sphere[0].center = vec3(centerx ,centery, centerz);\n    Sphere[0].radius = headr;\n    Sphere[0].materialID = 1;\n    \n    \n    // Circling sphere.\n    \n    Sphere[1].center = vec3( centerx  , centery-headr-bodyr, centerz);\n    Sphere[1].radius = bodyr;\n    Sphere[1].materialID = 3;\n    \n    \n    Sphere[2].center = vec3( centerx  , centery-(headr+bodyr*3.0), centerz);\n    Sphere[2].radius = bodyr;\n    Sphere[2].materialID = 3;\n    \n    \n    Sphere[3].center = vec3( centerx , centery-(headr+bodyr*5.0), centerz);\n    Sphere[3].radius = bodyr;\n    Sphere[3].materialID = 3;\n    \n    \n    Sphere[4].center = vec3(centerx ,centery-(headr+bodyr*7.0) , centerz);\n    Sphere[4].radius = 1.1*bodyr;\n    Sphere[4].materialID = 3;\n    \n    \n    Sphere[5].center = vec3(centerx ,centery-(headr+bodyr*9.0) , centerz);\n    Sphere[5].radius = 1.4*legr;\n    Sphere[5].materialID = 3;\n    \n    Sphere[6].center = vec3( centerx+bodyr+armr ,armcentery , centerz);\n    Sphere[6].radius = armr;\n    Sphere[6].materialID = 2;\n    \n    Sphere[8].center = vec3( centerx+bodyr+armr*5.0 ,armcentery, centerz);\n    Sphere[8].radius = armr;\n    Sphere[8].materialID = 2;\n    \n    \n    Sphere[10].center = vec3( centerx+bodyr+armr*9.0,armcentery, centerz);\n    Sphere[10].radius = armr;\n    Sphere[10].materialID = 2;\n    \n    \n    Sphere[11].center = vec3( centerx-(bodyr+armr),armcentery, centerz);\n    Sphere[11].radius = armr;\n    Sphere[11].materialID = 2;\n    \n    \n    \n    Sphere[13].center = vec3( centerx-(bodyr+armr*5.0),armcentery, centerz);\n    Sphere[13].radius = armr;\n    Sphere[13].materialID = 2;\n    \n    \n    Sphere[15].center = vec3( centerx-(bodyr+armr*9.0),armcentery, centerz);\n    Sphere[15].radius = armr;\n    Sphere[15].materialID = 2;\n    \n    Sphere[16].center = vec3( centerx-0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[16].radius = legr;\n    Sphere[16].materialID = 2;\n    \n    Sphere[18].center = vec3( centerx-0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[18].radius = legr;\n    Sphere[18].materialID = 2;\n    \n    Sphere[20].center = vec3( centerx-0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[20].radius = legr;\n    Sphere[20].materialID = 2;\n    \n    Sphere[21].center = vec3( centerx+0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[21].radius = legr;\n    Sphere[21].materialID = 2;\n    \n    Sphere[23].center = vec3( centerx+0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[23].radius = legr;\n    Sphere[23].materialID = 2;\n    \n    Sphere[25].center =  vec3( centerx+0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[25].radius = legr;\n    Sphere[25].materialID = 2;\n    \n    \n    if(iTime <6.5){\n        rightarm_dlwave(6.0,0.05);\n        leftarm_drwave(6.0,0.05);\n        waist_lwave(6.0,0.05);\n        flag = 1;\n    }\n    \n    if(iTime >6.5 && iTime<8.7){\n        rightarm_fwave(6.0,0.05);\n        leftarm_drwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >8.7&& iTime<9.5){\n        rightarm_ulwave(6.0,0.05);\n        rightarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >10.0&& iTime<11.9){\n        leftarm_lwave(6.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >11.9&& iTime<13.3){\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        leftarm_rwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >13.5&& iTime<14.3){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_urwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >14.5&& iTime<15.3){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        leftarm_rwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >15.5&& iTime<16.5){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >16.5&& iTime<18.3){\n        rightarm_drwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >18.7&& iTime<20.0){\n        rightarm_ulwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    \n    if(iTime >20.8&& iTime<21.9|| iTime>77.5&&iTime<80.8){//noodle\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        noodle_arm(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >21.9&& iTime<23.4 || iTime>80.8&&iTime<84.2|| iTime>94.5&&iTime<98.0|| iTime>88.0&&iTime<91.2 ){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_urwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >23.4&& iTime<25.9 || iTime>84.2&&iTime<88.0){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        leftarm_ulwave(6.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >25.9&& iTime<28.9|| iTime>88.0&&iTime<91.2){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        leftarm_fwave(6.0,0.05);\n        rightarm_fwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >28.9&& iTime<32.9|| iTime>91.2&&iTime<94.5){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        noodle_arm(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >33.0&& iTime<34.4|| iTime>98.0&&iTime<101.5){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        leftarm_ulwave(6.0,0.05);\n        rightarm_urwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >34.5 && iTime<36.2){\n        rightarm_fwave(6.0,0.05);\n        leftarm_drwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >36.3&& iTime<37.3){\n        rightarm_ulwave(6.0,0.05);\n        rightarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n   \tif(iTime >37.4&& iTime<39.6|| iTime>94.5&&iTime<98.0 ){\n        leftarm_lwave(6.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >39.6&& iTime<40.5){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        leftarm_rwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >41.2&& iTime<42.3){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >42.3&& iTime<45.5){\n        rightarm_drwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >46.8&& iTime<46.6){\n        rightarm_ulwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >46.6&& iTime<47.2){\n        rightarm_fwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(flag==0){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        noodle_arm(6.0,0.05);\n        head_node(6.0, 0.4);\n    }\n    \n    \n    Sphere[12].center =  (Sphere[11].center+Sphere[13].center)/2.0;\n    Sphere[12].radius = armr;\n    Sphere[12].materialID = 2;\n    \n    \n    Sphere[14].center =  (Sphere[13].center+Sphere[15].center)/2.0;\n    Sphere[14].radius = armr;\n    Sphere[14].materialID = 2;\n    \n    \n    Sphere[17].center = (Sphere[16].center+Sphere[18].center)/2.0;\n    Sphere[17].radius = legr;\n    Sphere[17].materialID = 2;\n    \n    \n    \n    Sphere[7].center = (Sphere[6].center+Sphere[8].center)/2.0;\n    Sphere[7].radius = armr;\n    Sphere[7].materialID = 2;\n    \n    Sphere[9].center = (Sphere[8].center+Sphere[10].center)/2.0;\n    Sphere[9].radius = armr;\n    Sphere[9].materialID = 2;\n    \n    \n    Sphere[19].center = (Sphere[18].center +Sphere[20].center )/2.0;\n    Sphere[19].radius = legr;\n    Sphere[19].materialID = 2;\n    \n    \n    Sphere[22].center = (Sphere[21].center +Sphere[23].center )/2.0;\n    Sphere[22].radius = legr;\n    Sphere[22].materialID = 2;\n    \n    \n    \n    Sphere[24].center =(Sphere[23].center +Sphere[25].center )/2.0;;\n    Sphere[24].radius = legr;\n    Sphere[24].materialID = 2;\n    \n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    \n    // Pink material.\n    Material[1].k_d = vec3(0.5, 1.0, 1.0);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n    \n    // Green plastic material.\n    Material[2].k_d = vec3(0.0, 0.8, 0.0);\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    // Blue material.\n    Material[3].k_d = vec3(1.0, 1.0, 0.5);\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 2.0 * Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n    \n    // Light 0.\n    Light[0].position = vec3(centerx + 3.0 * sin(iTime), centery + 20.0, 10.0 + centerz + 3.0 * cos(iTime));\n    Light[0].I_a = vec3(0.1, 0.1, 0.1);\n    Light[0].I_source = vec3(0.0 + lighta0.r, 0.0 + lighta0.g, 0.0 + lighta0.b);\n    \n    \n    // Light 1.\n    Light[1].position = vec3(centerx + 3.0 * sin(iTime), centery + 20.0, 10.0 + centerz - 3.0 * cos(iTime));\n    Light[1].I_a = vec3(0.1, 0.1, 0.1);\n    Light[1].I_source = vec3(0.0 + lighta1.r, 0.0 + lighta1.g, 0.0 + lighta1.b);\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                    out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    \n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    float a = 1.0;\n    float b = 2.0 * dot(ray.d, (ray.o - sph.center));\n    float c = dot((ray.o - sph.center), (ray.o - sph.center)) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    float t0;\n    if(d < 0.0) return false;\n    else\n    {\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n        float t2 = (-b - sqrt(d)) / (2.0 * a);\n        if (t1 < tmin || t1 > tmax)           //t1 false\n        {\n            if (t2 < tmin || t2 > tmax)    //t1&t2 false\n                return false;\n            else                           //t2 ok t1 false\n                t0 = t2;\n        }\n        else                               //t1 ok\n        {\n            if (t2 < tmin || t2 > tmax)    //t2 false t1 ok\n                t0 = t1;\n            else                           //t2 ok t1 ok\n                t0 = min(t1,t2);\n        }\n    }\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(vec3(ray.o + t0 * ray.d - sph.center));\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    float a = 1.0;\n    float b = 2.0 * dot(ray.d, (ray.o - sph.center));\n    float c = dot((ray.o - sph.center), (ray.o - sph.center)) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    float t0;\n    if(d < 0.0) return false;\n    else\n    {\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n        float t2 = (-b - sqrt(d)) / (2.0 * a);\n        if (t1 < tmin || t1 > tmax)           //t1 false\n        {\n            if (t2 < tmin || t2 > tmax)    //t1&t2 false\n                return false;\n            else                           //t2 ok t1 false\n                return true;\n        }\n        else\n            return true;\n    }\n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                   in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n        \n        return light.I_a * mat.k_a +\n        light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n             out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n    \n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n    \n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    \n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    for( int j = 0; j < NUM_SPHERES; ++j )//sphere intersect\n    {\n        temp_hasHit =  IntersectSphere(Sphere[j],ray,DEFAULT_TMIN,DEFAULT_TMAX);\n        if(temp_hasHit == false)\n            continue;\n        else{\n            IntersectSphere(Sphere[j],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(hasHitSomething == false && temp_hasHit == true)\n                hasHitSomething = true;\n            if(temp_t < nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[j].materialID;\n            }\n        }\n    }\n    \n    for( int j = 0; j < NUM_PLANES; ++j )//sphere intersect\n    {\n        temp_hasHit =  IntersectPlane(Plane[j],ray,DEFAULT_TMIN,DEFAULT_TMAX);\n        if(temp_hasHit == false)\n            continue;\n        else{\n            IntersectPlane(Plane[j],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(hasHitSomething == false && temp_hasHit == true)\n                hasHitSomething = true;\n            if(temp_t < nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[j].materialID;\n            }\n        }\n    }\n    /////////////////////////////////\n    \n    \n    \n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n    \n    vec3 I_local = vec3( 0.0 );// Result color will be accumulated here.\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n    \n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    Ray_t shadowray;\n    shadowray.o = nearest_hitPos;\n    bool inShadow;\n    bool inshadowtemp;\n    vec3 lightvec;\n    //make shadowray and calculate I_local\n    for( int i = 0; i < NUM_LIGHTS; ++i)//sphere intersect\n    {\n        inShadow = false;\n        shadowray.d = normalize(Light[i].position - shadowray.o);\n        lightvec = shadowray.d;\n        \n        for( int j = 0; j < NUM_SPHERES; ++j )//sphere intersect\n        {\n            inshadowtemp = IntersectSphere(Sphere[j],shadowray,DEFAULT_TMIN,DEFAULT_TMAX);\n            if(inShadow == false && inshadowtemp == true)\n                inShadow = true;\n            \n        }\n        //get I_local\n        I_local += PhongLighting(lightvec, nearest_hitNormal, -ray.d, inShadow,\n                                 Material[nearest_hitMatID], Light[i]);\n    }\n    \n    /////////////////////////////////\n    \n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    \n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n    \n    \n    \n    \n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Position the camera.\n    vec3 cam_pos;\n    vec3 cam_lookat;\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    cam_pos = vec3( -1.5, 0.8, 3. );\n    cam_lookat = vec3( 1.5, 1.0, -0.3 );\n    if(iTime>7.5&&iTime<19.2){\n        cam_pos = vec3(1.5-0.058*(iTime-7.5), 1.0-0.014*(iTime-7.5), 3. );\n        cam_lookat = vec3( 1.5*sin(0.08*iTime), 1.0, -0.3*cos(0.08*iTime) );\n    }\n    else if(iTime>36.3 && iTime<47.5){\n        cam_pos = vec3(1.5-sin(0.1*iTime), 1.0, 3.-cos(0.1*iTime) );\n        cam_lookat = vec3( 1.5*sin(0.08*iTime), 1.0, -0.3*cos(0.08*iTime) );\n    }\n    else if((iTime>47.5&&iTime<77.5)||iTime>104.87){\n        cam_pos = vec3(centerx + 2.0 * sin(iTime), centery, centerz + 2.0 * cos(iTime));\n        cam_lookat = vec3(centerx, centery / 2.0, centerz);\n    }\n    \n    \n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n    \n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n    \n    \n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    \n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n    \n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        \n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n        \n        I_result += compounded_k_rg * I_local;\n        \n        if ( !hasHit ) break;\n        \n        compounded_k_rg *= k_rg;\n        \n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n    \n    fragColor = vec4( I_result, 1.0 );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 15527,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/allanteng/dy-mix"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}