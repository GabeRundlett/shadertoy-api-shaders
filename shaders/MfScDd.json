{
    "Shader": {
        "info": {
            "date": "1723148313",
            "description": "A loopless ray tunnel intersection with lights, motion blur, and action with an addition of music.",
            "flags": 8,
            "hasliked": 0,
            "id": "MfScDd",
            "likes": 5,
            "name": "Ivans Tunnel (sound)",
            "published": 3,
            "tags": [
                "3d",
                "tunnel",
                "light",
                "analytic",
                "trap",
                "loopless"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 128
        },
        "renderpass": [
            {
                "code": "//image\n\n#define PI 3.14159525\n#define E 2.71828182846\n#define eps 0.0001\n#define inf 10000.\n\nconst float count = 8.0;\nconst float maxWeight = 100.0;\nconst float blendSmoothness = 0.5;\n\nfloat time = 0.0;\nconst int samples = 16;\nconst float motionBlur = 0.02;\nvec3 getColor(in vec3 o, in vec3 d) {\n    vec3 oo = o;\n    \n    const float freq = count/PI;\n    const float cellSize = 1./freq;\n    float a = 2.0*dot(d.yz, d.yz);\n    float b = 2.0*dot(o.yz, d.yz);\n    float c = dot(o.yz, o.yz)-1.0;\n    float k = (-b - sqrt(b*b-2.0*a*c))/a;\n    o += d*k;\n    vec2 l = floor(vec2(atan(o.y, o.z), o.x)*freq);\n    vec2 v = l/freq;\n    float m = (count-1.0)*PI/(count*2.0);\n    vec2 u = vec2(sin(v.x-m), cos(v.x-m));\n    if (mod(floor(l.x+l.y), 2.0) < 1.0) return vec3(0);\n    float v1 = -(o.x-v.y-cellSize*0.5+cellSize*sign(d.x)*0.5)/d.x;\n    float j = 0.5*length(vec2(sin(PI/count)-sin(2.0*PI/count), cos(PI/count)-cos(2.0*PI/count)));\n    float v2 = -(dot(o.yz, u)+j*sign(dot(d.yz, u)))/dot(d.yz, u);\n    if (length(o.yz+d.yz*v2) <= 1.0) v2 = v1; \n    j = max(v2, v1)+k;\n    o -= d*k;\n    vec3 s = vec3(l, floor(time));\n    m = hash13(s);\n    c -= m*m + 2.*m;\n    o = hash33(s)*vec3(1, 2, 3);\n    if (j < (-b - sqrt(b*b-2.0*a*c))/a) return vec3(o*maxWeight);\n    j = 1.-(length(oo.yz+d.yz*j)-1.0)/m;\n    const float v0 = -0.5+sqrt(1.+4.*blendSmoothness/maxWeight)*0.5;\n    v1 = blendSmoothness/(j+v0) - blendSmoothness/(1.+v0);\n    return vec3(v1*o);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 mr = 1./iResolution.xy;\n    vec3 color = vec3(0);\n    for (int i = 0; i < samples; i += 1) {\n        vec3 r = texelFetch(iChannel0, ivec2(fragCoord.xy+vec2(i*251, i*173))%ivec2(1024, 512), 0).xyz;//hash33(uvec3(fragCoord.xy, iFrame+i*samples));\n        time = iTime*0.5-(r.z)*motionBlur;\n        vec3 at = vec3(0);\n        vec3 ro;\n        float theta;\n        if (mod(iTime, 20.0) < 10.) {\n            ro = vec3(time*10., sin(time)*0.5, cos(time*0.5)*0.9);\n            vec2 angle = vec2(cos(time*2.3)*0.5-3.1415*0.5+sin(time*4.35)*0.1, (sin(time*5.)+sin(time*3.5))*0.5);\n            at = vec3(\n                sin(angle.x)*cos(angle.y),\n                cos(angle.x)*cos(angle.y),\n                sin(angle.y)\n            );\n            theta = pow(sin(time*6.182), 10.);\n        } else {\n            ro = vec3(time, sin(time)*0.5, 0.5*cos(time));\n            at = normalize(vec3(-1, 1, 0));\n            theta = time;\n        }\n        vec2 oc = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n        vec2 uv = ((fragCoord-iResolution.xy*0.5)+(r.xy-0.5)*length(oc)*30.0)*max(mr.x, mr.y);\n        uv *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n\n        vec3 xPlain = vec3(normalize(vec2(at.y, -at.x)), 0);\n        vec3 yPlain = cross(xPlain, at);\n        vec3 rd = vec3(at + xPlain*uv.x + yPlain*uv.y);\n        color += getColor(ro, rd);\n    }\n    fragColor = vec4(1.-exp(-color/float(samples)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n// The labeling refers to the number of values - hash(out)(in)...\n//---------------------------------------------------------------------------------------------------------------\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash14(uvec4 q)\n{\n\tq *= UI4;\n\tuint n = (q.x ^ q.y ^ q.z ^ q.w) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash14(vec4 p)\n{\n\tuvec4 q = uvec4(ivec4(p)) * UI4;\n\tuint n = (q.x ^ q.y ^ q.z ^ q.w) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash23(uvec3 q)\n{\n\tq *= UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash32(uvec2 q)\n{\n\tuvec3 n = q.xyx * UI3;\n\tn = (n.x ^ n.y ^n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash33(uvec3 q)\n{\n\tq *= UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec4 hash44(uvec4 q)\n{\n\tq *= UI4;\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*UI4;\n\treturn vec4(q) * UIF;\n}\n\nvec3 hash44(vec4 p)\n{\n\tuvec4 q = uvec4(ivec4(p)) * UI4;\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*UI4;\n\treturn vec3(q) * UIF;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\nfloat square(in float time, in float k) {\n    time *= 3.141592653*2.0;\n    return sin(time)/(abs(sin(time))+k);\n}\nfloat[6] freq = float[6](\n    440.,\n    330.,\n    250.,\n    200.,\n    220.,\n    220.\n);\nfloat kk(in float time, in float k) {\n    return square(time+0.1*sin(time*0.05), 1.0+sin(k*2.));\n}\nvec2 mainSound( int samp, float time )\n{\n    float v = 0.0;\n    v = fract(time*440.+sin(time*6.282))*fract(time);\n    v += fract(time*220.+sin(time*6.282*0.5))*fract(time*2.0+0.5);\n    v += fract(v+time*150.)*fract(time*0.5);\n    v /= 3.0;\n    \n    float k = fract(time*880.)*fract(time*0.151+0.61);\n    k += fract(time*200.)*fract(time*0.616+0.12);\n    k += fract(time*300.)*fract(time*0.1563+0.612);\n    k += fract(time*500.)*fract(time*0.0526+0.1);\n    k /= 4.0;\n    \n    v = mix(v, k, 0.5);\n    v += fract(time*0.1)*0.25*kk(time*freq[int(floor(time*2.0)-mod(floor(time*0.5), 3.0))%6], k);\n    return vec2(v*0.5);//vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}