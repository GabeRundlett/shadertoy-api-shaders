{
    "Shader": {
        "info": {
            "date": "1618112351",
            "description": "An implementation of the non maximum gradient suppression in Canny edge detection.\nUse the mouse to control the line thickness.",
            "flags": 32,
            "hasliked": 0,
            "id": "Wds3Rl",
            "likes": 22,
            "name": "Canny edge detection",
            "published": 3,
            "tags": [
                "filter",
                "edgedetection",
                "convolution",
                "gaussian",
                "canny",
                "scharr"
            ],
            "usePreview": 0,
            "username": "Zavie",
            "viewed": 860
        },
        "renderpass": [
            {
                "code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nStep 1: Gaussian blur.\nStep 2: edge detection.\nStep 3: non max suppression.\n\nThe last steps of the Canny edge detection are missing: after the\nnon-max value suppression, lines are supposed to be connected and\npruned.\n\n--\nZavie\n\n*/\n\n#define PI acos(-1.)\n\nvec3 hue(float angle)\n{\n    float r = clamp(sin(angle), 0., 1.);\n    float g = clamp(sin(angle + 2.*PI/3.), 0., 1.);\n    float b = clamp(sin(angle + 4.*PI/3.), 0., 1.);\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 dx = vec2(1. / iResolution.x, 0.);\n    vec2 dy = vec2(0., 1. / iResolution.y);\n\n    vec4 gradientInfo = texture(iChannel3, uv);\n\n#if VARIABLE_THICKNESS\n    float thicknessControl = fract(uv.x);\n    //float thicknessControl = abs(fract(uv.x*3.) * 2. - 1.);\n    float thickness = mix(0., float(MAX_THICKNESS), thicknessControl);\n#else\n    float thickness = float(MAX_THICKNESS) * iMouse.x/iResolution.x;\n#endif\n    for (int j = -MAX_THICKNESS; j <= +MAX_THICKNESS; ++j)\n    {\n        for (int i = -MAX_THICKNESS; i <= +MAX_THICKNESS; ++i)\n        {\n            vec2 offset = float(i)*dx + float(j)*dy;\n            float r = length(vec2(i, j));\n\n            vec4 a = texture(iChannel3, uv + offset);\n            if (a.x > gradientInfo.x)\n            {\n                gradientInfo = mix(gradientInfo, a, smoothstep(0.5, -0.5, r - thickness));\n            }\n        }\n    }\n    float amplitude = gradientInfo.x;\n\n    vec3 inputImage = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 blurredImage = texture(iChannel1, fragCoord.xy / iResolution.xy).rgb;\n    vec3 gradient = texture(iChannel2, fragCoord.xy / iResolution.xy).xxx;\n#if SHOW_GRADIENT_DIRECTION\n    gradient *= hue(gradientInfo.w);\n#endif // SHOW_GRADIENT_DIRECTION\n    vec3 maxGradient = texture(iChannel3, fragCoord.xy / iResolution.xy).xxx;\n    vec3 thicknessAdded = vec3(amplitude);\n\n#if SCALE_FIRST\n    float finalEdge = smoothstep(0.2, 0.25, amplitude);\n#else // !SCALE_FIRST\n    float finalEdge = smoothstep(0.02, 0.025, amplitude);\n#endif // !SCALE_FIRST\n    vec3 finalResult = mix(vec3(0.8, 0.77, 0.7), vec3(0.2, 0.24, 0.3), finalEdge);\n\n    fragColor = vec4(finalResult, 1.);\n\n    // Showcase the steps:\n    float t = fract(0.05*iTime+0.1*uv.x);\n    fragColor.rgb = mix(fragColor.rgb, inputImage, smoothstep(0.4, 0.405, t));\n    fragColor.rgb = mix(fragColor.rgb, blurredImage, smoothstep(0.5, 0.505, t));\n    fragColor.rgb = mix(fragColor.rgb, gradient, smoothstep(0.6, 0.605, t));\n    fragColor.rgb = mix(fragColor.rgb, maxGradient, smoothstep(0.7, 0.705, t));\n    fragColor.rgb = mix(fragColor.rgb, vec3(amplitude), smoothstep(0.8, 0.805, t));\n    fragColor.rgb = mix(fragColor.rgb, vec3(finalEdge), smoothstep(0.9, 0.905, t));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nSource image step.\nBlending between two fairly different videos.\n\n--\nZavie\n\n*/\n\n\nfloat luma(vec3 color)\n{\n    return dot(color, vec3(0.2116, 0.7152, 0.0722));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float image0 = luma(texture(iChannel0, uv).rgb);\n    float image1 = luma(texture(iChannel1, uv).rgb);\n\n\tfloat change = smoothstep(0.3, 0.7, abs(fract(iTime*0.2) * 2. - 1.));\n\n    fragColor = vec4(vec3(mix(image0, image1, change)), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nStep 1: Gaussian blur.\n\n--\nZavie\n*/\n\n\n//\n//  1 | 2 | 1\n// ---+---+---\n//  2 | 4 | 2\n// ---+---+---\n//  1 | 2 | 1\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 dx = vec2(1. / iResolution.x, 0.);\n    vec2 dy = vec2(0., 1. / iResolution.y);\n\n    float a = texture(iChannel0, uv - dx - dy).x;\n    float b = texture(iChannel0, uv      - dy).x;\n    float c = texture(iChannel0, uv + dx - dy).x;\n    float d = texture(iChannel0, uv - dx     ).x;\n    float e = texture(iChannel0, uv          ).x;\n    float f = texture(iChannel0, uv + dx     ).x;\n    float g = texture(iChannel0, uv - dx + dy).x;\n    float h = texture(iChannel0, uv      + dy).x;\n    float i = texture(iChannel0, uv + dx + dy).x;\n\n    float blurred = 1./16. * (\n        1.*a + 2.*b + 1.*c +\n        2.*d + 4.*e + 2.*f +\n        1.*g + 2.*h + 1.*i\n        );\n    fragColor = vec4(vec3(blurred), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nStep 2: edge detection.\n\nThe Scharr operator is used; it is similar to the Sobel operator\nbut has better rotational symmetry.\n\n--\nZavie\n*/\n\n\n//\n// Scharr operator.\n//\n// -3 | 0 | 3     -3 |-10|-3\n// ---+---+---    ---+---+---\n// -10| 0 | 10     0 | 0 | 0\n// ---+---+---    ---+---+---\n// -3 | 0 | 3      3 | 10| 3\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 dx = vec2(1. / iResolution.x, 0.);\n    vec2 dy = vec2(0., 1. / iResolution.y);\n\n    float a = texture(iChannel0, uv - dx - dy).x;\n    float b = texture(iChannel0, uv      - dy).x;\n    float c = texture(iChannel0, uv + dx - dy).x;\n    float d = texture(iChannel0, uv - dx     ).x;\n    float e = texture(iChannel0, uv          ).x;\n    float f = texture(iChannel0, uv + dx     ).x;\n    float g = texture(iChannel0, uv - dx + dy).x;\n    float h = texture(iChannel0, uv      + dy).x;\n    float i = texture(iChannel0, uv + dx + dy).x;\n\n    float Gx = 1./32. * (\n        -3. *a + 3. *c +\n        -10.*d + 10.*f +\n        -3. *g + 3. *i\n        );\n\n    float Gy = 1./32. * (\n        -3.*a + -10.*b + -3.*c +\n        3. *g + 10.*h + 3. *i\n        );\n\n    vec2 G = vec2(Gx, Gy);\n#if SCALE_FIRST\n    G *= 10.;\n#endif //SCALE_FIRST\n\n    float amplitude = sqrt(dot(G, G));\n    float theta = atan(G.y, G.x);\n\n    fragColor = vec4(amplitude, G, theta);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nStep 3: non max suppression.\n\n--\nZavie\n*/\n\n\n#define PI acos(-1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 dx = vec2(1. / iResolution.x, 0.);\n    vec2 dy = vec2(0., 1. / iResolution.y);\n\n    vec4 gradientInfo = texture(iChannel0, uv);\n    float amplitude = gradientInfo.x;\n    vec2 G = gradientInfo.yz;\n    float theta = gradientInfo.w;\n\n    float localMax = 0.;\n    if ((theta < 0.125 * PI && theta > -0.125 * PI) ||\n        (theta > 0.875 * PI || theta < -0.875 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv + dx).x);\n        localMax = max(localMax, texture(iChannel0, uv - dx).x);\n    }\n    if ((theta > 0.125 * PI && theta < 0.365 * PI) ||\n       (theta > -0.875 * PI && theta < -0.625 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv - dx - dy).x);\n        localMax = max(localMax, texture(iChannel0, uv + dx + dy).x);\n    }\n    if ((theta > 0.375 * PI && theta < 0.625 * PI) ||\n        (theta < -0.375 * PI && theta > -0.625 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv - dy).x);\n        localMax = max(localMax, texture(iChannel0, uv + dy).x);\n    }\n    if ((theta > 0.625 * PI && theta < 0.875 * PI) ||\n        (theta > -0.365 * PI && theta < -0.125 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv + dx - dy).x);\n        localMax = max(localMax, texture(iChannel0, uv - dx + dy).x);\n    }\n\n    if (gradientInfo.x < localMax)\n    {\n        gradientInfo.x = 0.;\n        gradientInfo.y = 0.;\n        gradientInfo.z = 0.;\n    }\n    fragColor = vec4(gradientInfo);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nMacros.\n\n--\nZavie\n\n*/\n\n#define SCALE_FIRST 1\n#define VARIABLE_THICKNESS 0\n#define MAX_THICKNESS 8\n#define SHOW_GRADIENT_DIRECTION 0\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}