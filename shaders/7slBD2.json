{
    "Shader": {
        "info": {
            "date": "1645446594",
            "description": "Comparing gamut clipping allowing hue distortions, top, and gamut clipping without hue distortions on the bottom. With some hue distortions the result can be made smoother.",
            "flags": 0,
            "hasliked": 0,
            "id": "7slBD2",
            "likes": 4,
            "name": "Gamut clipping - modified Oklab",
            "published": 3,
            "tags": [
                "gamut"
            ],
            "usePreview": 0,
            "username": "bjornornorn",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "vec2 findCenterAndPurity(vec3 x)\n{\n    // Matrix derived for (c_smooth+s_smooth) to be an approximation of the macadam limit\n    // this makes it some kind of g0-like estimate\n    mat3 M = mat3(\n        2.26775149, -1.43293879,  0.1651873,\n        -0.98535505,  2.1260072, -0.14065215,\n        -0.02501605, -0.26349465,  1.2885107);\n\n    x = x*M;\n    \n    float x_min = min(x.r,min(x.g,x.b));\n    float x_max = max(x.r,max(x.g,x.b));\n    \n    float c = 0.5*(x_max+x_min);\n    float s = (x_max-x_min);\n    \n    // math trickery to create values close to c and s, but without producing hard edges\n    vec3 y = (x-c)/s;\n    float c_smooth = c + dot(y*y*y, vec3(1.0/3.0))*s;\n    float s_smooth = sqrt(dot(x-c,x-c)/2.0);\n    return vec2(c_smooth, s_smooth);\n}\n\n\nvec3 toLms(vec3 c)\n{\n    mat3 rgbToLms = mat3(\n        0.4122214708, 0.5363325363, 0.0514459929,\n        0.2119034982, 0.6806995451, 0.1073969566,\n        0.0883024619, 0.2817188376, 0.6299787005);\n\n    vec3 lms_ = c*rgbToLms;\n    return sign(lms_)*pow(abs(lms_), vec3(1.0/3.0));\n}\n\nfloat softness_scale = 0.2;\n\nvec3 toLms(float I, float hue, float sat)\n{\n    float a = cos(hue);\n    float b = sin(hue);\n    \n    float l_ = + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = - 0.0894841775f * a - 1.2914855480f * b;\n    \n    vec3 lms = vec3(l_,m_,s_);\n    \n    vec2 MC = findCenterAndPurity(lms);   \n    lms -= MC.x;    \n    lms *= sat;    \n    lms += I;\n    \n    return lms;\n}\n\nvec2 approximateShapeA(float L, float hue, float sat)\n{\n    vec3 lms = toLms(L, hue, sat);\n        \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n    \n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n  \n    // softness_scale 0.0\n    // Estimated using https://colab.research.google.com/drive/1rYFDmHuv0MNzCHXQSwhBkJaMbTQzoXl3?usp=sharing\n    return vec2(\n        1.70021527e+00 + -8.21491826e-02*a +  1.73329721e-01*b +  1.73952306e-01*a2 +  4.95620904e-03*b2 + 1.94643985e-02*a3 +  2.39021796e-02*b3,\n        3.07593575e-01 + 1.70513225e-02*a +   7.21549478e-03*b +  1.99728079e-02*a2 + -1.25118676e-03*b2 + -7.99372300e-04*a3 + 1.21489709e-03*b3\n    );\n}\n\nvec2 approximateShapeB(float I, float hue, float sat)\n{\n    vec3 lms = toLms(I, hue, sat); \n    \n    float a = 1.9779984951f*lms.x - 2.4285922050f*lms.y + 0.4505937099f*lms.z;\n    float b = 0.0259040371f*lms.x + 0.7827717662f*lms.y - 0.8086757660f*lms.z;\n    \n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n\n    // softness_scale 0.2\n    // Estimated using https://colab.research.google.com/drive/1rYFDmHuv0MNzCHXQSwhBkJaMbTQzoXl3?usp=sharing\n    return vec2(\n        1.45502420e+00 + -7.65623334e-02*a +  2.26234241e-01*b +  6.25596210e-02*a2 +  3.16995726e-02*b2 + 4.46107711e-02*a3 +  3.49876286e-02*b3,\n        2.69987106e-01 + 1.69987106e-02*a +   1.00116716e-03*b +  1.02594717e-02*a2 + -6.08142494e-04*b2 + 2.29845394e-03*a3 + 2.13300284e-03*b3\n    );\n}\n\n\nvec3 compute(float I, float hue, float sat)\n{\n    vec3 lms = toLms(I, hue, sat);\n\n    lms = lms*lms*lms;\n    \n    float l = lms.x;\n    float m = lms.y;\n    float s = lms.z;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    \n    return rgbResult;\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColorOutsideGamutOnly(vec3 color)\n{\n    // soft clipping scaled to only have an effect if the color is outside the gamut\n    \n    float grey = 0.2;\n    \n    vec3 x = color-grey;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-grey);\n    x /= xscale;\n    \n    vec3 absX = abs(x);\n    \n    float maxX = max(max(1.0,absX.r), max(absX.g, absX.b));\n    \n    float softness_scale = 0.5;\n    float softness = softness_scale*(maxX-1.0);\n    softness = softness/(1.0+softness);\n    \n    return grey + xscale*xsgn*softSaturate(absX, vec3(softness));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = (fragCoord.x / iResolution.x)* 3.141592 * 2.;\n    float I = 2.0*fragCoord.y / iResolution.y;\n    I = I - floor(I);\n    float C = -0.5*log(0.5+0.5*sin(iTime));\n\n    float C_max;\n    \n    for (int i=0; i<200; i++)\n    {\n        vec3 rgbTest = compute(I, h, 0.5*float(i)/200.0);\n        float diff = length(rgbTest - clamp(rgbTest, 0., 1.));\n    \n        if(diff == 0.)\n        {\n            C_max = 0.5*float(i)/200.0;\n        }\n    }\n    \n    vec3 rgb;\n    \n    if (fragCoord.y / iResolution.y > 0.5)\n    {\n        vec2 ST = approximateShapeA(I, h, 1.0);\n   \n        float C_smooth = (1.0/((ST.x/I) + (ST.y/(1.0-I))));\n        rgb = compute(I, h, min(C,C_smooth));\n        rgb = softClipColorOutsideGamutOnly(rgb);\n        \n    }\n    else\n    {\n        rgb = compute(I, h, min(C,C_max));\n    }\n    \n    rgb = clamp(rgb,0.0,1.0);\n    \n    fragColor.rgb = Srgb3(vec3(rgb));\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define F1 float\n#define F3 vec3\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4121656120f * c.r + 0.5362752080f * c.g + 0.0514575653f * c.b;\n    float m = 0.2118591070f * c.r + 0.6807189584f * c.g + 0.1074065790f * c.b;\n    float s = 0.0883097947f * c.r + 0.2818474174f * c.g + 0.6302613616f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767245293f*l - 3.3072168827f*m + 0.2307590544f*s;\n    rgbResult.g = - 1.2681437731f*l + 2.6093323231f*m - 0.3411344290f*s;\n    rgbResult.b = - 0.0041119885f*l - 0.7034763098f*m + 1.7068625689f*s;\n    return rgbResult;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}