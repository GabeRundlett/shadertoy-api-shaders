{
    "Shader": {
        "info": {
            "date": "1721202703",
            "description": "infinite square tunnel",
            "flags": 0,
            "hasliked": 0,
            "id": "MclcWN",
            "likes": 10,
            "name": "Machination",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "square",
                "infinite"
            ],
            "usePreview": 0,
            "username": "darnok",
            "viewed": 151
        },
        "renderpass": [
            {
                "code": "#define PI     3.14159265\n#define MAX_DIST     150.\n#define YWave  5.\n\nfloat degToRad(float d) {\n    return PI * d / 180.;\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Funtion Distance\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Distance to the scene\nfloat map(vec3 p, float timeRad) {      \n    vec3 squareSize = vec3(60., 60., 0.1);\n    \n    float distFract = 2.;\n    \n    float idBlock = p.z - (mod(p.z, distFract));\n    float blockDistCoef = idBlock / 15.;\n    float blockYDistortion = 2.2 * idBlock / 10.;\n    float blockRot = 17. * idBlock / MAX_DIST;\n    \n    float distCenter = 63. - sin(timeRad) * 2.5 * (1. + blockDistCoef);\n    \n    vec3 pos = p;\n    pos.z = mod(p.z, distFract) - (distFract / 2.);\n    \n    pos.y += sin(blockYDistortion + timeRad * YWave * 1.25);\n    pos.xy *= rot2D(sin(timeRad + sin(timeRad / 2.5)) * blockRot);\n    \n    float squareLeft = sdBox(pos - vec3(-distCenter, 0., 0.2), squareSize);\n    float squareTop = sdBox(pos - vec3(0., -distCenter, 0.4), squareSize);\n    float squareRight = sdBox(pos - vec3(distCenter, 0., 0.6), squareSize);\n    float squareBottom = sdBox(pos - vec3(0., distCenter, 0.8), squareSize);\n    \n    return min(\n        min(squareLeft, squareTop),\n        min(squareRight, squareBottom)\n    );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float timeRad )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, timeRad ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, timeRad ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, timeRad ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, timeRad ) );    \n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor, float timeRad )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor, timeRad );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = vec2(0.);//(iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, 0);                     // ray origin\n    vec3 rd = normalize(vec3(uv, 1));             // ray direction\n    vec3 col = vec3(0);                           // final pixel color\n    \n    float t = 0.;                                 // total distance travelled\n   \n    \n    float timeRad = degToRad(iTime) * 15.;\n    \n    ro.xy *= rot2D(timeRad);\n    rd.xy *= rot2D(timeRad);\n    \n    // Raymarching\n    int i;\n    vec3 p;\n    for (i = 0; i < 80; i++) {    \n        p = ro + rd * t;                     // position along the ray\n\n        float d = map(p, timeRad);                         // current distance to the scene\n\n        t += d;                                   // \"march\" the ray\n        \n        //col = vec3(i) / 80.;                    // iteration count\n       \n        if (d < .001 || t > MAX_DIST) break;          // early stop\n    }\n    \n    // Coloring\n    float distCoef = 0.05;\n    float iterationCoef = 0.005;\n    col = vec3(t * distCoef\n        + iterationCoef * float(i)); // color based on distance\n    \n    fragColor = vec4(col, 1);\n    \n    \n    float shadow = 1. - (max(0., min(t, MAX_DIST)) / MAX_DIST);\n    \n    float ao = calcAO(p, calcNormal(p, timeRad), timeRad);\n    ao = 0.5 + (0.5 * ao);\n    \n    col = shadow * ao * palette(log(t) * .05 + float(i) * 0.02 + (iTime * 0.1),\n        \n        vec3(0.558, 0.168, 0.338),\n        vec3(0.358, 0.808, 0.418),\n        vec3(-0.552, 0.338, 0.218),\n        vec3(1.975, 1.975, -0.925)); // http://dev.thi.ng/gradients/\n        \n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}