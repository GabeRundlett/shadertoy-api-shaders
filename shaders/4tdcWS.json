{
    "Shader": {
        "info": {
            "date": "1533861026",
            "description": "I wanted to create an organic-looking SDF scene in a single, fully procedural, fragment shader.",
            "flags": 1,
            "hasliked": 0,
            "id": "4tdcWS",
            "likes": 201,
            "name": "[SH18] Woman",
            "published": 3,
            "tags": [
                "sdf",
                "sh18",
                "woman"
            ],
            "usePreview": 1,
            "username": "reinder",
            "viewed": 11628
        },
        "renderpass": [
            {
                "code": "// [SH18] Woman. Created by Reinder Nijhoff 2018\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4tdcWS\n//\n// I wanted to create an organic-looking SDF scene in a single, fully procedural,\n// fragment shader. The scene is modelled for this specific camera viewpoint and \n// lighting setup.\n//\n// Please change AA (line 13) to 1 if this shader is running slow.\n//\n\n#define AA 1\n#define FLOOR 0.\n#define BODY 1.\n#define HAIR 2.\n\n//\n// Hash functions by Dave Hoskins:\n//\n// https://www.shadertoy.com/view/4djSRW\n//\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3. -2.*f);\n    \n    return mix(mix(hash12(i + vec2(0, 0)), \n                   hash12(i + vec2(1, 0)), u.x), \n               mix(hash12(i + vec2(0, 1)), \n                   hash12(i + vec2(1, 1)), u.x), u.y);\n}\n\n//\n// SDF framework by Inigo Quilez:\n//\n// https://www.shadertoy.com/view/Xds3zN\n//\n\nvec2 boxIntersect(in vec3 ro, in vec3 rd, in vec3 rad) {\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    if(tN > tF || tF < .0) return vec2(-1);\n    \n    return vec2(tN, tF);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b - a)/k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p)-b, .0)) -r;\n}\n\nfloat sdCapsuleF(vec3 p, vec3 a, vec3 b, const float r0, const float r1, const float f) {\n    vec3 d = b -a;\n    float h = length(d);\n    d = normalize(d);\n    float t=dot(p-a, d);\n    float th = t/h;\n    return distance(a+clamp(t,0.,h)*d, p)-mix(r0, r1, th) * \n           max(0., 1.+f-f*4.*abs(th-.5)*abs(th -.5));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, const float r0, const float r1) {\n    vec3 d = b -a;\n    float h = length(d);\n    d = normalize(d);\n    float t=clamp(dot(p-a, d), 0., h);\n    return distance(a+t*d, p) -mix(r0, r1, t/h);\n}\n\nfloat mapHand(in vec3 p) {\n    float sph = length(p) - .1;\n    if (sph > .1) return sph; //  bounding sphere\n    \n    const float s = 1.175;\n    float d = udRoundBox(p, vec3(.0175/s + p.y * (.25/s), .035/s + p.x * (.2/s), 0.), .01);\n    d = smin(d, min(sdCapsule(p, vec3(.025, .0475, 0)/s, vec3(.028, .08, .02)/s, .01/s, .0075/s), \n                    sdCapsule(p, vec3(.028, .08, .02)/s, vec3(.03, 0.1, .06)/s, .0075/s, .007/s)), .0057);\n    d = smin(d, min(sdCapsule(p, vec3(.01, .0425, 0)/s, vec3(.008, .07, .025)/s, .009/s, .0075/s), \n                    sdCapsule(p, vec3(.008, .07, .025)/s, vec3(.008, .085, .065)/s, .0075/s, .007/s)), .0057);\n    d = smin(d, min(sdCapsule(p, vec3(-.01, .04, 0)/s, vec3(-.012, .065, .028)/s, .009/s, .0075/s), \n                    sdCapsule(p, vec3(-.012, .065, .028)/s, vec3(-.012, .07, .055)/s, .0075/s, .007/s)), .0057);\n    d = smin(d, min(sdCapsule(p, vec3(-.025, .035, 0)/s, vec3(-.027, .058, .03)/s, .009/s, .0075/s), \n                    sdCapsule(p, vec3(-.027, .058, .03)/s, vec3(-.028, .06, .05)/s, .0075/s, .007/s)), .0057);\n    return d;\n}\n\nvec2 map(in vec3 pos) {\n    const float f0 = .075;\n    const float f1 = .2;\n    const float f2 = .275;\n    \n    vec3 ph = pos;\n    \n    if (pos.x < 0.) {\n        ph += vec3(.11, -.135, .2);\n        ph = mat3(-0.8674127459526062, -0.49060970544815063, 0.08304927498102188, 0.22917310893535614, -0.5420454144477844, -0.8084964156150818, 0.4416726529598236, -0.6822674870491028, 0.5826116800308228) * ph;\n    } else {\n        ph.x = -ph.x;\n        ph += vec3(.075, -.09, .125);\n        ph = mat3(-0.6703562140464783, -0.7417424321174622, 0.020991835743188858, 0.36215442419052124, -0.3517296612262726, -0.8632093667984009, 0.6476624608039856, -0.5710554718971252, 0.5044094920158386) * ph;\n    }\n    \n    float dh = mapHand(ph);\n    \n    //  right arm\n    float d = sdCapsuleF(pos, vec3(0.13, 0.535, -.036), vec3(.09, 0.292, -0.1), .035, .025, f1);\n    d = smin(d, sdCapsuleF(pos, vec3(.08, 0.29, -0.1), vec3(-.09, 0.15, -0.17), .03, .02, f0), .0051);\n    if (pos.x < 0.) d = smin(d, dh, .015);\n    \n    //  left arm\n    float d1 = sdCapsuleF(pos, vec3(-0.12, 0.56, .02), vec3(-0.11, 0.325, -.045), .035, .025, f1);\n    d1 = smin(d1, sdCapsuleF(pos, vec3(-0.11, 0.315, -.05), vec3(.07, .08, -0.11), .024, .022, f2), .005);\n    if (pos.x > 0.) d1 = smin(d1, dh, .015);\n    d = min(d1, d);\n    \n    //  body\n    vec3 bp1 = pos;\n    bp1 += vec3(0, -.44, -.027);\n    bp1 = mat3(0.9761762022972107, 0.033977385610342026, 0.2143024057149887, -0.07553963363170624, 0.9790945649147034, 0.18885889649391174, -0.20340539515018463, -0.20054790377616882, 0.9583353996276855) * bp1;\n    float db = udRoundBox(bp1, vec3(.07 + bp1.y*.3, 0.135 -abs(bp1.x)*0.2, 0.), .04);\n    \n    vec3 bp2 = pos;\n    bp2 += vec3(-.032, -.235, -.06);\n    bp2 = mat3(0.8958174586296082, -0.37155669927597046, 0.24383758008480072, 0.3379548490047455, 0.9258314967155457, 0.16918234527111053, -0.28861331939697266, -0.0691504031419754, 0.9549453258514404) * bp2;\n    db = smin(db, udRoundBox(bp2, vec3(.065 - bp2.y*.25, 0.1, .02 -bp2.y*.13), .04), .03);\n    \n    db = smin(db, sdCapsule(pos, vec3(0.11, 0.5, -.032), vec3(.05, 0.52, -.015), .04, .035), .01);\n    db = smin(db, sdCapsule(pos, vec3(.01, 0.4, -.01), vec3(.01, 0.7, .0), .045, .04), .02);\n    \n    vec3 bp3 = pos;\n    bp3 += vec3(-.005, -.48, .018);\n    bp3 = mat3(0.9800665974617004, 0.05107402056455612, 0.19199204444885254, 0, 0.9663899540901184, -0.2570805549621582, -0.19866932928562164, 0.2519560754299164, 0.9471265077590942) * bp3;\n    db = smin(db, udRoundBox(bp3, vec3(.056 + bp3.y*.23 , .06, 0.), .04), .01);\n    \n    d = smin(d, db, .01);\n    \n    //  right leg\n    float d2 = sdCapsuleF(pos, vec3(0.152, 0.15, .05), vec3(-.03, 0.43, -.08), .071, .055, f2);\n    d2 = smin(d2, sdCapsuleF(pos, vec3(0.14, .08, .05), vec3(-.01, 0.23, -.02), .05, .02, f1), .075);\n    d = min(d, d2);\n    float d3 = sdCapsuleF(pos, vec3(-.03, 0.43, -.084), vec3(.055, .04, -.04), .053, .02, f0);\n    d3 = smin(d3, sdCapsuleF(pos, vec3(-.0, 0.35, -.05), vec3(.025, 0.2, -.03), .04, .02, f2), .05);\n    d = min(d, d3);\n    \n    //  left leg\n    d = min(d, sdCapsuleF(pos, vec3(-.02, 0.12, 0.1), vec3(-0.145, .08, -0.17), .07, .055, f2));\n    float d4 = sdCapsuleF(pos, vec3(-0.145, .08, -0.17), vec3(0.205, .02, -0.09), .05, .0185, f0);\n    d4 = smin(d4, sdCapsuleF(pos, vec3(-.05, .085, -0.145), vec3(.05, .03, -.09), .035, .03, f2), .0075);\n    \n    //  right feet\n    float d6 = distance(pos, vec3(.0, .0, -0.1)) -.1; //  bounding sphere\n    if(d6 < 0.1) {\n        d = min(d, sdCapsule(pos, vec3(.03, .03, -.08), vec3(.031, .01, -0.146), .015, .005));\n        d = min(d, sdCapsule(pos, vec3(.02, .03, -.08), vec3(.018, .01, -0.1505), .015, .006));\n        d = min(d, sdCapsule(pos, vec3(.00, .03, -.08), vec3(.005, .01, -0.1525), .015, .007));\n        d = min(d, sdCapsule(pos, vec3(-.01, .03, -.08), vec3(-.014, .01, -0.1575), .015, .01));\n    } else {\n        d = min(d6, d);\n    }\n    \n    //  left feet\n    float d5 = distance(pos, vec3(0.25, .025, -0.1)) -.12; //  bounding sphere\n    if(d5 < 0.1) {\n        d5 = sdCapsule(pos, vec3(0.2, .035, -.075), vec3(0.3, .01, -.09), .035, .02);\n        d5 = smin(d5, sdCapsule(pos, vec3(0.31, .035, -.0975), vec3(0.1, .01, -0.10), .015, .02), .02);\n        d5 = smin(d5, sdCapsule(pos, vec3(0.31, .035, -.0975), vec3(0.355, .034, -0.10), .015, .01), .005);\n        d5 = min(d5, sdCapsule(pos, vec3(0.31, .022, -.0875), vec3(0.335, .022, -.09), .02, .01));\n    }\n    d4 = smin(d4, d5, .025);\n    d = min(d, d4);\n    \n    //  hair\n    vec3 hp = pos;\n    hp.x += smoothstep(.55, .45, pos.y)*.035;\n    hp.z *= 1.9 - .8 * pos.y;\n    hp.yz -= 2.*pos.x*pos.x;\n    float h = sdCapsule(hp, vec3(.0, 0.725, -.02), vec3(-.02, 0.415, .0), .094, .085);\n    h = smin(h, sdCapsule(hp, vec3(.0, 0.725, -.02), vec3(.06, 0.705, -.05), .085, .095), .02);\n    h = max(-(pos.y - abs(fract(pos.x*90.) -.5)*0.1 -.14 - smoothstep(-0.2, 0.1, pos.x)*.5), h);\n    \n    return (h < d) ? vec2(h, HAIR) : vec2(d, BODY);\n}\n\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.;\n    float t = mint;\n    for(int i=0; i<14; i++) {\n        float h = map(ro + rd*t).x;\n        res = min(res, 8.*h/t);\n        t += max(h, .02);\n        if(res<.005 || t>tmax) break;\n    }\n    return clamp(res,0.,1.);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec2 e = vec2(1,-1)*.00005;\n    return normalize(e.xyy*map(pos + e.xyy).x +\n                     e.yyx*map(pos + e.yyx).x +\n                     e.yxy*map(pos + e.yxy).x +\n                     e.xxx*map(pos + e.xxx).x);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.;\n    float sca = 1.;\n    for(int i=0; i<5; i++) {\n        float hr = .005 + .12*float(i)/4.;\n        vec3 aopos =  nor * hr + pos;\n        float dd = min(aopos.y, map(aopos).x);\n        occ += -(dd -hr)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat render(in vec3 ro, in vec3 rd, in vec2 uv) {\n    //  cast ray\n    float planeIntersect = abs(-ro.y/rd.y);\n    vec2 box = boxIntersect(ro, rd, vec3(.37, 1, .3));\n    float t = box.x;\n    float tmax = min(box.y, planeIntersect);\n    \n    float m = FLOOR;\n    if (t > 0.) {\n        for(int i=0; i<40; i++) {\n            float precis = .0004*t;\n            vec2 res = map(ro+rd*t);\n            m = res.y;\n            if(abs(res.x) < precis || t > tmax) break;\n            t += res.x;\n        }\n    }\n    if(t>=tmax || t<0.) {\n        t = rd.y < 0. ? planeIntersect : 1000.;\n        m = FLOOR;\n    }\n    \n    //  shade scene\n    float col = 0.;\n    if(t < 10.) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = vec3(0, 1, 0);\n        \n        if (m < FLOOR + .5) {\n            col = .03;\n        } else {\n            col = .5;\n            nor = calcNormal(pos);\n        }\n        if (m > BODY + .5) {\n            col = 0.;\n        }\n        nor = normalize(nor + (hash33(pos) -.5) * .1);\n        vec3 ligp = vec3(5., 5., -.5);\n        vec3 lig = -normalize(pos - ligp);\n        float dif = clamp(dot(nor, lig), 0., 1.);\n        float bac = clamp(dot(nor, normalize(vec3(-.2, .5, -.02))), .0, 1.0)\n                    *clamp(1.-pos.y,0.,1.);  \n        if(m > FLOOR) bac *= clamp(-10.*pos.z+.4,0.,1.);\n        \n        float occ, sha;\n        if (pos.x > .4 || pos.z > 1.) {\n            occ = sha = 1.;\n        } else {\n            occ = calcAO(pos, nor);\n            sha = calcSoftshadow(pos, lig, .01, 1.5);\n        }\n        \n        col *= 1.30*dif*sha*(.25+.75*occ) + .5*bac*occ;\n        \n        if (m > BODY + .5) {\n            // totally fake hair lighting\n            vec3 ref = reflect(rd, nor);\n            vec3 hal = normalize(normalize(vec3(-.1, .5, .35)) -rd);\n            vec2 hv = mix(vec2(pos.x*60. -pos.z*35., 0.), \n                          vec2(-pos.x*50. -pos.z*50., 0.), \n                          smoothstep(.0, .01, -dot(pos, normalize(vec3(-1., .15, .45)))));\n            float n = noise(hv*20. + vec2(2. + 10.*sin(pos.y*20.+.4), 2.5));\n            n = smoothstep(.4, 1., n);\n            float nd = noise(hv*40.+ vec2(2. + 10.*sin(pos.y*20.+.4), .5));\n            n *= nd * nd;\n            col += n * pow(max(0., dot(ref, hal)), 8.);\n            col += .03 * n * max(0., dot(ref, hal)) * smoothstep(.75, .5, pos.y);\n        }\n        \n        col *= smoothstep(.985, 1., dot(normalize(vec3(0.7, 0.58, -.05)), lig));\n    }\n    \n    return clamp(col, 0., 1.);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta -ro);\n    vec3 cu = normalize(cross(cw, vec3(0,1,0)));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float angle = -.18+ .18*sin(iTime*0.5);\n    float tot = 0.;\n    \n    for(int m=0; m<AA + min(0,iFrame); m++)\n        for(int n=0; n<AA + min(0,iFrame); n++) {\n            vec2 o = vec2(float(m), float(n))/float(AA) - .5;\n            vec2 p = (-iResolution.xy + 2.*(fragCoord+o))/iResolution.y;\n            \n            p.x -= .8;\n            \n            vec3 ro = vec3(2.9*sin(angle) , .65, -2.9*cos(angle));\n            vec3 ta = vec3(0., 0.45, 0.);\n            mat3 ca = setCamera(ro, ta);\n            vec3 rd = ca * normalize(vec3(p.xy, 5));\n            \n            float col = render(ro, rd, p);\n            tot += pow(col, .4545);\n        }\n    tot /= float(AA*AA);\n    \n    tot += .075 * hash12(fragCoord/iResolution.xy);\n    tot *= 1.35;\n    \n    fragColor = vec4(min(tot*vec3(1, .97, .92), 1.), 1.);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\n    vec2 p = (-iResolution.xy + 2.*fragCoord)/iResolution.y;\n    float c = pow(render(ro + vec3(0,.65,-1), rd, p), .4545);\n    fragColor = vec4(c,c,c,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}