{
    "Shader": {
        "info": {
            "date": "1711588759",
            "description": "An accompanying shader for an article about Ray Marching.\n\nAssociated article can be found here:\nhttps://connorahaskins.substack.com/p/ray-marching-menger-sponge-breakdown\n\nMirror:\nhttps://lucodivo.github.io/menger_sponge.html",
            "flags": 0,
            "hasliked": 0,
            "id": "MXB3Wt",
            "likes": 5,
            "name": "Menger Sponge Breakdown v2",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Parcle",
            "viewed": 391
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2013 Connor Alexander Haskins\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A helpful breakdown for teaching a beginner how to create a Menger Sponge\n// This shader has an associated article which can be found here: http://connorahaskins.com/menger_sponge.html\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAX_STEPS 40\n#define MISS_DIST 10.0\n#define HIT_DIST 0.01\n\n#define WIDTH 2.0\n#define HALF_WIDTH 1.0\n    \nvec2 distanceRayToScene(vec3 rayDir);\nfloat sdScene(vec3 rayPos);\nfloat sdIndex(int index, vec3 rayPos);\nfloat sdYAlignedPlane(vec3 rayPos);\nmat2 rotate(float angle);\n\nfloat sdSphere(vec3 rayPos, vec3 sphereCenterPosition, float radius);\nfloat sdSphere(vec3 rayPos, float radius);\nfloat sdSphere(vec3 rayPos);\nfloat sdCube(vec3 rayPos);\nfloat sdCross(vec3 rayPos);\n\nfloat sdInfSphere(vec3 rayPos);\nfloat sdInfCube(vec3 rayPos);\nfloat sdBoundedCross(vec3 rayPos);\nfloat sdBoundedCrossSlimmed(vec3 rayPos);\nfloat sdBoundedCrossWithBox(vec3 rayPos);\nfloat sdMengerSpongeIteration1(vec3 rayPos);\nfloat sdBoundedBoxFieldBroken(vec3 rayPos);\nfloat sdBoundedBoxField(vec3 rayPos);\nfloat sdTwentySevenBoxesKinda(vec3 rayPos);\nfloat sdTwentySevenBoxesCross(vec3 rayPos);\nfloat sdTwentySevenBoxes(vec3 rayPos);\nfloat sdTwentySevenCrossesBound(vec3 rayPos);\nfloat sdTwentySevenCrossesBoundUnionBox(vec3 rayPos);\nfloat sdSevenHundredTwentyNineCrossesBoundUnionBox(vec3 rayPos);\nfloat sdMengerSpongeIteration2(vec3 rayPos);\nfloat sdMengerSponge(vec3 rayPos, int numIterations);\n\nconst vec3 origin = vec3(0.0, 0.0, 0.0);\nconst vec3 worldUp = vec3(0.0, 1.0, 0.0);\n\n// NOTE: EDIT TO CHANGE CAMERA POS, FOCAL POINT, MISS COLOR\nconst vec3 cameraPos = vec3(6.0, 6.0, -6.0);\nconst vec3 focalPoint = vec3(0.0, 0.0, 0.0);\nconst vec3 missColor = vec3(0.2, 0.2, 0.2);\n\n// NOTE: EDIT THE FOLLOWING TWO LINES TO ADJUST SPEED/TRANSITION\nfloat secondsPerStage = 2.5;\nfloat transitionPoint = 0.7;\n\nconst float floorHeight = -3.0;\nconst vec3 spherePos = origin;\nconst float sphereScale = 3.0;\nconst vec3 cubePos = origin;\nconst float cubeScale = 2.0;\nconst vec3 crossPos = origin;\nconst float crossScale = 1.1;\nconst vec3 infSpherePos = cubePos;\nconst float infSphereScale = 0.5;\nconst vec3 infCubePos = origin;\nconst float infCubeScale = 0.5;\nconst vec3 mengerSpongePos = origin;\nconst float mengerSpongeScale = 2.5;\n\n// NOTE: Entry point of fragment shader\n// This function point is called per pixel\n// gl_FragCoord is (x,y) location of pixel\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n  vec2 pixelCoord = fragCoord.xy;\n  pixelCoord -= (0.5 * iResolution.xy);\n  pixelCoord = pixelCoord / iResolution.y;\n\n  vec3 forward = normalize(focalPoint - cameraPos);\n  vec3 right = normalize(cross(forward, worldUp));\n  vec3 up = normalize(cross(right, forward));\n  vec3 rayDir = pixelCoord.x * right +\n                pixelCoord.y * up +\n                forward;\n  rayDir = normalize(rayDir);\n\n  float dist = 0.0;\n  bool hit = false;\n  int iterations = 0;\n \n  while(iterations < MAX_STEPS) {\n    vec3 pos = cameraPos + (dist * rayDir);\n    float posToScene = sdScene(pos);\n    dist += posToScene;\n    if(posToScene < HIT_DIST) {\n      hit = true;\n      break;\n    }\n    if(posToScene > MISS_DIST) { break; }\n    iterations += 1;\n  }\n\n  if(hit) {\n    vec3 color = vec3(1.0 - (float(iterations) / float(MAX_STEPS)));\n    fragColor = vec4(color, 1.0);\n  } else { // miss\n    const vec3 missColor = vec3(0.2, 0.2, 0.2);\n    fragColor = vec4(missColor, 1.0);\n  }\n}\n\n\nfloat sdIndex(int index, vec3 rayPos){\n  float dist;\n  // NOTE: UNCOMMENT/EDIT NEXT LINE TO FORCE A STATIC RENDER\n  // index = 18;\n  if(index == 0) { \n    //dist = sdSphere(rayPos, spherePos, sphereScale); // Sphere Method #1\n    //dist = sdSphere(rayPos - spherePos, sphereScale); // Sphere Method #2\n    dist = sdSphere((rayPos - spherePos) / sphereScale) * sphereScale; // Sphere Method #3\n  } else if(index == 1){\n    dist = sdCube((rayPos - cubePos) / cubeScale) * cubeScale;\n  } else if(index == 2){\n    dist = sdInfSphere(rayPos);\n  } else if(index == 3){\n    dist = sdCross((rayPos - crossPos) / crossScale) * crossScale;\n  } else if(index == 4){\n    dist = sdBoundedCross((rayPos - mengerSpongePos) / 1.5) * 1.5; // MengerSponge Part 1: Bounded Cross\n  } else if(index == 5){\n    dist = sdBoundedCrossSlimmed((rayPos - mengerSpongePos) / 1.5) * 1.5; // MengerSponge Part 2: Slimmed Bounded Cross\n  } else if(index == 6){\n    dist = sdBoundedCrossWithBox((rayPos - mengerSpongePos) / 1.5) * 1.5; // MengerSponge Part 3: Bounded Cross w/ Box\n  } else if(index == 7){\n    dist = sdMengerSpongeIteration1((rayPos - mengerSpongePos) / 1.5) * 1.5; // MengerSponge Part 4: Iteration 1\n  } else if(index == 8){\n    dist = sdBoundedBoxFieldBroken((rayPos - mengerSpongePos) / 0.5) * 0.5; // MengerSponge Part 5: Bounded Box Field (Broken)\n  } else if(index == 9){\n    dist = sdBoundedBoxField((rayPos - mengerSpongePos) / 0.5) * 0.5; // MengerSponge Part 6: Bounded Box Field (Fixed)\n  } else if(index == 10){\n    dist = sdTwentySevenBoxesKinda((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale; // MengerSponge Part 7: Twenty Seven Boxes...Kinda\n  } else if(index == 11){\n    dist = sdTwentySevenBoxesCross((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale; // MengerSponge Part 8: Twenty Seven Boxes Cross-Section\n  } else if(index == 12){\n    dist = sdTwentySevenBoxes((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale; // MengerSponge Part 9: 27 Cubes\n  } else if(index == 13){\n    dist = sdTwentySevenCrossesBound((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale; // MengerSponge Part 10: 27 Crosses Bound\n  } else if(index == 14){\n    dist = sdTwentySevenCrossesBoundUnionBox((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale; // MengerSponge Part 10: 27 Crosses Bound\n  } else if(index == 15){\n    dist = sdMengerSpongeIteration2((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale; // MengerSponge Part 11: Iteration 2\n  } else if(index == 16){\n    dist = sdSevenHundredTwentyNineCrossesBoundUnionBox((rayPos - mengerSpongePos) / mengerSpongeScale) * mengerSpongeScale; // MengerSponge Part 10: 27 Crosses Bound\n  } else if(index == 17){\n    dist = sdMengerSponge((rayPos - mengerSpongePos) / mengerSpongeScale, 3) * mengerSpongeScale; // Menger Sponge\n  } else if(index == 18){\n    dist = sdMengerSponge((rayPos - mengerSpongePos) / mengerSpongeScale, 4) * mengerSpongeScale; // Menger Sponge\n  }\n  \n  return dist;\n}\n\nfloat sdScene(vec3 rayPos) {\n    \n    float dist;\n    const int stageCount = 19;\n    float time = iTime / secondsPerStage;\n    time = mod(time, float(stageCount));\n    dist = sdIndex(int(time), rayPos);\n    float time_fract = fract(time);\n    if(time_fract > transitionPoint) {\n      dist = mix(dist, sdIndex(int(time + 1.0), rayPos), (time_fract - transitionPoint) * (1.0 / (1.0 - transitionPoint)));\n    }\n\n    return dist;\n}\n\nfloat sdSphere(vec3 rayPosition, vec3 sphereCenterPosition, float radius) {\n    vec3 centerToRay = rayPosition - sphereCenterPosition;\n\tfloat distToCenter = length(centerToRay);\n    return distToCenter - radius;\n}\n\nfloat sdSphere(vec3 rayPos, float radius) {\n    return length(rayPos) - radius;\n}\n\nfloat sdSphere(vec3 rayPos) {\n    return length(rayPos) - HALF_WIDTH;\n}\n\nfloat sdCube(vec3 rayPos) {\n\tconst vec3 corner = vec3(HALF_WIDTH);\n    vec3 ray = abs(rayPos); // fold ray into positive octant\n    vec3 cornerToRay = ray - corner;\n    float cornerToRayMaxComponent = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n    float distToInsideRay = min(cornerToRayMaxComponent, 0.0);\n    vec3 closestToOutsideRay = max(cornerToRay, 0.0);\n\treturn length(closestToOutsideRay) + distToInsideRay;\n} \n\nfloat sdCross(vec3 rayPos) {\n    const vec3 corner = vec3(HALF_WIDTH);\n\tvec3 ray = abs(rayPos); // fold ray into positive quadrant\n\tvec3 cornerToRay = ray - corner;\n\n    float smallestComp = min(min(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat largestComp = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat middleComp = cornerToRay.x + cornerToRay.y + cornerToRay.z\n\t\t\t\t\t\t\t- smallestComp - largestComp;\n            \n\tvec2 closestOutsidePoint = max(vec2(smallestComp, middleComp), 0.0);\n\tvec2 closestInsidePoint = min(vec2(middleComp, largestComp), 0.0);\n\n\treturn length(closestOutsidePoint) + -length(closestInsidePoint);\n}\n\nfloat sdInfSphere(vec3 rayPos) {\n  vec3 infRayPos = mod(rayPos, WIDTH) - HALF_WIDTH;\n  return sdSphere((infRayPos - infSpherePos) / infSphereScale) * infSphereScale;\n}\n\nfloat sdInfCube(vec3 rayPos) {\n  vec3 infRayPos = mod(rayPos, WIDTH) - HALF_WIDTH;\n  return sdCube((infRayPos - infCubePos) / infCubeScale) * infCubeScale;\n}\n\nfloat sdBoundedCross(vec3 rayPos) {\n\tfloat boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n\tfloat crossDist = sdCross(rayPos);\n\tfloat intersection = max(boundingBoxDist, crossDist);\n\treturn intersection;\n}\n\n\nfloat sdBoundedCrossSlimmed(vec3 rayPos) {\n\tfloat boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n\tfloat crossDist = sdCross(rayPos / 0.33) * 0.33;\n\tfloat intersection = max(boundingBoxDist, crossDist);\n\treturn intersection;\n}\n\n\nfloat sdBoundedCrossWithBox(vec3 rayPos) {\n\tfloat boundingBoxDist = sdCube(rayPos / 2.0) * 2.0;\n\tfloat crossDist = sdCross(rayPos * 3.0) / 3.0;\n\tfloat intersection = max(boundingBoxDist, crossDist);\n\tfloat spongeBox = sdCube(rayPos);\n\tfloat boxCrossUnion = min(intersection, spongeBox);\n\treturn boxCrossUnion;\n}\n\n\nfloat sdMengerSpongeIteration1(vec3 rayPos) {\n\tfloat crossDist = sdCross(rayPos * 3.0) / 3.0;\n\tfloat spongeBox = sdCube(rayPos);\n\treturn max(spongeBox, -crossDist);\n}\n\n\nfloat sdBoundedBoxFieldBroken(vec3 rayPos) {\n\tfloat boundingBox = sdCube(rayPos / 3.9) * 3.9;\n\tvec3 ray = mod(rayPos, 2.0);\n\tfloat dist = sdCube(ray / 1.5) * 1.5;\n\treturn max(dist, boundingBox);\n}\n\n\nfloat sdBoundedBoxField(vec3 rayPos) { \n\tfloat boundingBox = sdCube(rayPos / 4.0) * 4.0;\n\tvec3 ray = mod(rayPos, 2.0);\n\tray -= 1.0;\n\tfloat dist = sdCube(ray / 0.8) * 0.8;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdTwentySevenBoxesKinda(vec3 rayPos) {\n\t// bounding box spans all axes between [-halfBoxDimen, halfBoxDimen]\n\tfloat boundingBox = sdCube(rayPos);\n\t// The rays are transformed into boxed spaces with all axes between [0, boxDimen / 3.0)\n\t// this is because each cube should have a third the dimension of the entire cube\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tvec3 ray = mod(rayPos, boxedWorldDimen);\n\t// The origin within the boxes is moved from the corner to the center of the cube,\n\t// with the rays now having a range between [-boxDimen / 6.0, boxDimen / 6.0)\n\tray -= (boxedWorldDimen) / 2.0;\n\t// Transform coordinates of each boxed space to range [-halfBoxDimen, halfBoxDimen)\n\tray *= 3.0;\n\t// Shrink the cubes slightly to reveal gaps between them\n\tfloat dist = sdCube(ray / 0.9) / 0.9;\n\t// Correct warping of space caused by previously stretching the ray\n\tdist /= 3.0;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdTwentySevenBoxesCross(vec3 rayPos) {\n\tfloat boundingBox = sdCube(rayPos);\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tvec3 ray = mod(rayPos, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCube(ray / 0.9) * 0.9;\n\tdist /= 3.0;\n\tdist = max(dist, boundingBox);\n\t// Cross that runs along the axes of our world\n\tfloat axesCross = sdCross(rayPos / 0.25) * 0.25;\n\treturn max(dist, axesCross);\n}\n\nfloat sdTwentySevenBoxes(vec3 rayPos) {\n\tfloat boundingBox = sdCube(rayPos);\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\t// We want to translate the first box in the positive octant to change it’s world coordinates\n\t// from [0, boxedWorldDimen) to [-boxedWorldDimen / 2.0, boxedWorldDimen / 2.0) \n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCube(ray / 0.9) * 0.9;\n\tdist /= 3.0;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdTwentySevenCrossesBound(vec3 rayPos) {\n  const float oneThird = 1.0 / 3.0;\n\tfloat boundingBox = sdCube(rayPos / 1.1) * 1.1;\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCross(ray / oneThird) * oneThird;\n\tdist /= 3.0;\n\treturn max(dist, boundingBox);\n}\n\nfloat sdSevenHundredTwentyNineCrossesBoundUnionBox(vec3 rayPos) {\n  const float oneThird = 1.0 / 3.0;\n\tfloat cubeDist = sdMengerSpongeIteration2(rayPos);\n\tfloat boundingBox = sdCube(rayPos / 1.05) * 1.05;\n\tfloat boxedWorldDimen = WIDTH / 9.0;\n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 9.0;\n\tfloat dist = sdCross(ray / oneThird) * oneThird;\n\tdist /= 9.0;\n\treturn min(max(dist, boundingBox), cubeDist);\n}\n\nfloat sdTwentySevenCrossesBoundUnionBox(vec3 rayPos) {\n  const float oneThird = 1.0 / 3.0;\n\tfloat cubeDist = sdMengerSpongeIteration1(rayPos);\n\tfloat boundingBox = sdCube(rayPos / 1.1) * 1.1;\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat dist = sdCross(ray / oneThird) * oneThird;\n\tdist /= 3.0;\n\treturn min(max(dist, boundingBox), cubeDist);\n}\n\nfloat sdMengerSpongeIteration2(vec3 rayPos) {\n    const float oneThird = 1.0 / 3.0;\n\tfloat boxedWorldDimen = WIDTH / 3.0;\n\tfloat translation = boxedWorldDimen / 2.0;\n\tvec3 ray = rayPos + translation;\n\tray = mod(ray, boxedWorldDimen);\n\tray -= (boxedWorldDimen) / 2.0;\n\tray *= 3.0;\n\tfloat crossesUnboundDist = sdCross(ray / oneThird) * oneThird;\n\tcrossesUnboundDist /= 3.0;\n    \n\tfloat distFirstIter = sdMengerSpongeIteration1(rayPos);\n\treturn max(distFirstIter, -crossesUnboundDist);\n}\n\nfloat sdMengerSponge(vec3 rayPos, int numIterations) {\n  const float cubeWidth = 2.0;\n  const float oneThird = 1.0 / 3.0;\n  float spongeCube = sdCube(rayPos);\n  float mengerSpongeDist = spongeCube;\n  \n  float scale = 1.0;\n  for(int i = 0; i < numIterations; ++i) {\n    // #1 determine repeated box width\n    float boxedWidth = cubeWidth / scale;\n    \n    float translation = -boxedWidth / 2.0;\n    vec3 ray = rayPos - translation;\n    vec3 repeatedPos = mod(ray, boxedWidth);\n    repeatedPos += translation;\n    \n    // #2 scale coordinate systems from \n    // [-1/scale, 1/scale) -> to [-1.0, 1.0)\n    repeatedPos *= scale; \n    \n    float crossesDist = sdCross(repeatedPos / oneThird) * oneThird;\n    \n    // #3 Acquire actual distance by un-stretching\n    crossesDist /= scale;\n    \n    mengerSpongeDist = max(mengerSpongeDist, -crossesDist);\n    \n    scale *= 3.0;\n  }\n  return mengerSpongeDist;\n}\n\nfloat sdYAlignedPlane(vec3 rayPos) {\n    return abs(rayPos.y);\n}\n\nmat2 rotate(float angle) {\n    float sine = sin(angle);\n    float cosine = cos(angle);\n    return mat2(cosine, -sine, sine, cosine);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}