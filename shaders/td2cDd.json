{
    "Shader": {
        "info": {
            "date": "1587563488",
            "description": "playing around with the raymarching equation and SDFs in 4 dimensions",
            "flags": 0,
            "hasliked": 0,
            "id": "td2cDd",
            "likes": 9,
            "name": "Doodle: 4D Rendering",
            "published": 3,
            "tags": [
                "raymarching",
                "4d"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 528
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat smin(float a, float b, float k) {\n  float h = max(0., k-abs(a-b))/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\n//smooth triangle wave for smooth domain repetition https://www.desmos.com/calculator/ototv6tja8\nvec4 stri(vec4 p, float k) {\n  return asin(sin(p*3.14)*k)/3.14+0.5;\n}\n\nfloat scene(vec4 p) {\n  vec4 q = abs(p) - 1.;\n  float cube = length(max(q,0.0)) + min(max(max(q.x,q.w),max(q.y,q.z)),0.0) - 0.1;\n  float scale = 1.;\n  vec4 p2 = p+iTime*0.2;\n  p2 = (stri(p2/scale, .9)-0.5)*scale;\n  float spheres = length(p2)-0.2;\n  spheres = -smin(-(length(p) - 2.), -spheres, 0.1);\n  return smin(cube, spheres, 0.5);\n}\n\nvec4 norm(vec4 p) {\n  mat4 k = mat4(p,p,p,p) - mat4(0.001);\n  return normalize(scene(p) - vec4( scene(k[0]),scene(k[1]),scene(k[2]),scene(k[3]) ) );\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 srgb(float r, float g, float b) {\n  return pow(vec3(r,g,b),vec3(2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n  vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  vec4 cam = normalize(vec4(1,uv,0));\n  vec4 init = vec4(-5,0,0,sin(iTime*0.1));\n\n  float wrot = cos(iTime*0.5);\n  float zrot = cos(iTime*0.25);\n  float yrot = sin(iTime*0.5);\n  float zrot2 = iTime;\n  if (iMouse.z > 0.) {\n    zrot = mouse.x*2.;\n    wrot = radians(45.0);\n    yrot = mouse.y*2.;\n    zrot2 = 0.;\n  }\n  cam.xyw = erot(cam.xyw, vec3(0,1,0), zrot);\n  init.xyw = erot(init.xyw, vec3(0,1,0), zrot);\n  cam.xyz = erot(cam.xyz, vec3(0,1,0), yrot);\n  init.xyz = erot(init.xyz, vec3(0,1,0), yrot);\n  cam.yzw = erot(cam.yzw, vec3(0,1,0), wrot);\n  init.yzw = erot(init.yzw, vec3(0,1,0), wrot);\n  cam.xyz = erot(cam.xyz, vec3(0,0,1), zrot2);\n  init.xyz = erot(init.xyz, vec3(0,0,1), zrot2);\n  \n  vec4 p = init;\n  bool hit = false;\n  for (int i = 0; i<200 && !hit;i++) {\n    float dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n  }\n  vec4 n = norm(p);\n  vec4 r = reflect(cam,n);\n  vec4 aon = reflect(cam, norm(p+r*0.3));\n  float factor = length(sin(aon*3.)*0.5+0.5)/2.;\n  vec3 color = mix(srgb(0.1,0.1,0.2), srgb(0.2,0.6,0.9), factor) + pow(factor, 10.);\n  fragColor.xyz = hit ? color : srgb(0.1,0.1,0.1);\n  fragColor.xyz = sqrt(fragColor.xyz);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}