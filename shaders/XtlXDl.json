{
    "Shader": {
        "info": {
            "date": "1440637522",
            "description": "Nvm got it :D\n\nI'm trying to get the point on the edge of a box/cube based on direction, I'm sure this is really simple but I can't figure it out.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtlXDl",
            "likes": 6,
            "name": "point on rectangle from ray test",
            "published": 3,
            "tags": [
                "hmmm"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    \nvec2 cubeSize = vec2(.35,.2);\nvec2 normalizedCubeSize = normalize(cubeSize);\n\n    \n    vec2 mp = iMouse.xy/iResolution.xy - .5;\n    vec2 tp = normalize(mp);\n    \n    float os = max(0., .3-max(0.,length(uv)-.02)*80.);//center point\n\tos += max(0., .3-length(max(abs(uv)-cubeSize, 0.))*80.); //cube outline\n    os += max(0., .3-abs(atan(mp.y,mp.x) - atan(uv.y,uv.x))*80.);//direction line\n    os += max(0., .3-max(0.,length(tp*.1 - uv)-.01)*80.);//normalized point\n    \n    \n    /*vec2 p = normalize(max(abs(tp)-normalize(cubeSize)*length(cubeSize/2.),0.)*sign(tp))*length(cubeSize);//tp*cubeSize*2.;// \n    p = clamp(p,-cubeSize,cubeSize);\n    */\n    \n    \n    //thanks Gijs(https://www.shadertoy.com/user/Gijs) for posting a fast and clean solution :)\n    \n    //(http://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms)\n    // r.dir is unit direction vector of ray\n    vec2 dirfrac = 1./tp;\n\n    float t1 = -cubeSize.x*dirfrac.x;//min coords\n    float t2 = -t1;//max coords\n    float t3 = -cubeSize.y*dirfrac.y;\n    float t4 = -t3;\n\n    float tmin = max(min(t1, t2), min(t3, t4));\n    float tmax = min(max(t1, t2), max(t3, t4));\n\n    float t;\n    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us\n    if (tmax < 0.)\n    {\n        t = tmax;\n    }\n\n    // if tmin > tmax, ray doesn't intersect AABB\n    if (tmin > tmax)\n    {\n        t = tmax;\n    }\n\n    t = tmin;\n    vec2 p = -tp*t;\n    \n    /*\n    //got it :D\n    //rough version!\n    //calculate point on edge of cube/rect\n\n    vec2 ntp = tp;\n    tp *= length(cubeSize);\n    vec2 p = tp;//clamp(tp,-cubeSize,cubeSize);\n    float px = abs(p.x)-cubeSize.x;\n    float py = abs(p.y)-cubeSize.y;\n    \n    float am;\n    if (px > py) {\n        py = (px/abs(ntp.x))*abs(ntp.y);\n    } else {\n        px = (py/abs(ntp.y))*abs(ntp.x);\n    }\n    \n    p = vec2(p.x-sign(p.x)*px, p.y-sign(p.y)*py);\n    */\n/*\n    if (px > py) {\n        p = vec2(tp.x,normalizedCubeSize.y*sign(tp.y));\n    } else {\n        p = vec2(normalizedCubeSize.x*sign(tp.x),tp.y);\n    }\n    p *= .1;*/\n   // p *= cubeSize;\n    /*\n    if (abs(tp.x) > cubeSize.x) {\n        p = tp*(abs(tp.x)-cubeSize.x);\n    } else {\n        p = tp*(abs(tp.y)-cubeSize.y);\n    }*/\n\n\n    os += max(0., 1.-(length(uv-p)-.01)*80.);//point\n    \n    \n    fragColor = vec4(os);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}