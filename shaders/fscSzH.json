{
    "Shader": {
        "info": {
            "date": "1632568604",
            "description": "NOTHING LAST FOREVER",
            "flags": 32,
            "hasliked": 0,
            "id": "fscSzH",
            "likes": 7,
            "name": "Smokey Bubbles dUTCH oVEN",
            "published": 3,
            "tags": [
                "mouse",
                "background",
                "shadertoy",
                "feedback",
                "integration",
                "library",
                "web",
                "webdevelopment",
                "webdev",
                "javascript"
            ],
            "usePreview": 0,
            "username": "xenn",
            "viewed": 348
        },
        "renderpass": [
            {
                "code": "\n// Fork of \"Barbarella's Lava Lamp 2\" by xenn. https://shadertoy.com/view/Ndd3Ws\n// 2021-09-17 15:03:30\n\n/*\n\n// Postprocess copied with some small modifications from Mattias: https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 3.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 3.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *(0.92 - (.01*sin(iTime))) + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = curve( q );\n    vec3 oricol = texture( iChannel2, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n    vec3 sha = texture( iChannel1, vec2(q.x,q.y) ).xyz;\n   \n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0005 ;\n\n    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\n    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\n    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\n    col.r += 0.08*texture(iChannel2,0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*texture(iChannel2,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*texture(iChannel2,0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n    \n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.15));\n\n    col *= vec3(0.9,1.1,0.9);\n    \n\tfloat scans = clamp( 0.35+0.05*sin(3.5*iTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.75);\n\tcol = col *vec3(0.4+0.7*s) * ( col + (oricol * (sha - oricol)));\n\n    col *= 1.0+0.035*sin(110.0*(iTime / .50));\n\n\tcol*=1.0-0.75*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*1.0,0.0,1.0));\n\t\n    float comp = smoothstep( 0.1, 0.9, cos(iTime) );\n\n    fragColor = vec4(col,1.0);\n}\n*/\n\n// Fork of \"Nebulous Nonformanifest\" by xenn. https://shadertoy.com/view/fdV3RW\n// 2021-09-10 01:34:21\n\n// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      col = min(col,col2);\n                      color = min(col2,col);\n                 //     col2 = mix(col2,color,0.05);\n                     col2 = min(col,color);\n                      \n                       \n    //  color = max(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (min(col2,(color))))*noise), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lovely Bubbles\n// by @P_Malin\n// https://www.shadertoy.com/view/Nl2SRc\n//\n// Some lovely shadertoy bubbles.\n// I've wanted to implement something with thin film interference for a while.\n\n\n// CAMERA\n\nvec2 GetWindowCoord( vec2 uv )\n{\n\tvec2 window = uv * 2.0 - 1.0;\n\twindow.x *= iResolution.x / iResolution.y;\n\n\treturn window;\t\n}\n\nvec3 GetCameraRayDir( vec2 window, vec3 cameraPos, vec3 cameraTarget, float fov )\n{\n\tvec3 forward = normalize( cameraTarget - cameraPos );\n\tvec3 right = normalize( cross( vec3(0.0, 1.0, 0.0), forward ) );\n\tvec3 up = normalize( cross( forward, right ) );\n\t\t\t\t\t\t\t  \n\tvec3 dir = normalize(window.x * right + window.y * up + forward * fov);\n\n\treturn dir;\n}\n\n\n// POSTFX\n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) / length(vec2(1.0));\n    \n    d /= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\nvec3 ApplyTonemap( vec3 linearCol )\n{\n\tconst float kExposure = 0.75;\n\t\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    vec3 x = linearCol * kExposure;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n}\n\nvec3 ApplyGamma( vec3 linearCol )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow( linearCol, vec3(1.0/kGamma) );\t\n}\n\nvec3 ApplyPostFX( vec2 uv, vec3 col )\n{    \n    col *= 1.3;\n\n    col *= 0.1 + 0.9 * Vignette( uv, 1.0 );\n\n    col *= vec3(1.0, 0.95, 0.8); // warmer\n  \n    col = ApplyTonemap(col);\n\tcol = ApplyGamma(col);\n    \n\treturn col;\n}\n\t\n\n\n// Scene\n\nfloat speed = 1.0;\n\nfloat BubbleOriginForward( float t )\n{\n    t = t * 30.0;\n    if ( t > 0.0)\n    {\n        t = t / (1.0+t/10.0f);\n\n    }\n    return t + iTime * speed;\n}\n\nfloat BubbleOriginInverse( float r )\n{\n    r = r- iTime * speed;\n    if( r > 0.0)\n    {\n        r = -10.0f * r / (r - 10.0f);\n    }\n    r = r / 30.0f;\n    return r;\n}\n\nfloat Scene_Distance(vec3 pos)\n{\n\n    vec3 vPos = pos;\n    vPos.x += 3.0;\n\n    float scale = 50.0;\n    \n    vPos /= scale;\n\n    // wobble\n    vec3 offset = vec3(0);\n    offset += sin( pos.yzx * 8.91 + iTime * 10.0 ) * 0.001;\n    offset += sin( pos.zxy * 7.89 + iTime * 10.0 ) * 0.001;    \n    offset *= 0.08;\n    \n    float f = BubbleOriginForward( vPos.x );\n    \n    f = floor(f);\n    \n    float minD = 1000000.0;\n    \n    for (float b=-1.0; b<=2.0; b+=1.0)\n    {\n        float p = f + b;\n        vec3 o = vPos;\n        o.x = BubbleOriginInverse( p );\n                \n        o.x -= vPos.x;\n\n         float spreadBlend = 1.0 - clamp( vPos.x * 3.0 + 0.2, 0.0, 1.0);\n         \n         float spread = spreadBlend;\n         \n         spread *= 0.05;\n\n         o.y += sin(p * 123.3456) * spread;\n         o.z += sin(p * 234.5678) * spread;\n         \n         o += offset;\n           \n         float rad = sin( p * 456.8342 ) * 0.5 + 0.5;\n                             \n         float d = length(o) - 0.005f - rad * rad * 0.02f;\n         \n         minD = min( minD, d );\n    }\n    \n     return minD * scale;\n}\n\nvec3 Scene_GetNormal( vec3 pos )\n{\n    const float delta = 0.0001;\n    \n    vec4 samples;\n    for( int i=ZERO; i<=4; i++ )\n    {\n        vec4 offset = vec4(0);\n        offset[i] = delta;\n        samples[i] = Scene_Distance( pos + offset.xyz );\n    }\n    \n    vec3 normal = samples.xyz - samples.www;    \n    return normalize( normal );\n}    \n\nfloat Scene_Trace( vec3 rayOrigin, vec3 rayDir, float minDist, float maxDist, float side )\n{\n\tfloat t = minDist;\n\n    const int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tfloat d = Scene_Distance( rayOrigin + rayDir * t ) * side;\n        if ( abs(d) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist + 1.0f;\n            break;\n        }       \n        \n        t += d;        \n\t}\n    \n    return t;\n}\n\nvec3 GetSkyColour( vec3 dir )\n{\n\tvec3 result = vec3(0.0);\n\t\n//    vec3 envMap = texture(iChannel1, dir).rgb;\n//    envMap = envMap * envMap;\n//    float kEnvmapExposure = 0.99999;\n//    result = -log2(1.0 - envMap * kEnvmapExposure);\n\n    return result;\t\n}\n\nfloat FilmThickness( vec3 pos )\n{\n    return Noise(pos * 0.3f, iTime * 0.5);\n}\n\nvoid Shade( inout vec3 colour, inout vec3 remaining, vec3 pos, vec3 rayDir, vec3 normal )\n{\n    float NdotV = max( dot(normal, -rayDir), 0.0 );\n\n    float filmThickness = FilmThickness(pos);\n\n    vec3 reflection = GetSkyColour( reflect( rayDir, normal ) );\n    \n#if 1\n    // Extra highlight\n    vec3 LightColour = vec3(1,.9,.7) * 0.8;\n    vec3 L = normalize(vec3(1.0, 2.0, 0.0));\n    float NdotL = max( dot( normal, L ), 0.0 );\n    float NdotH = max( dot( normal, normalize(L-rayDir) ), 0.0 );\n    reflection += (pow(NdotH,10000.0) * 10000.0) * NdotL * LightColour;\n    //vReflection += (pow(NdotH,1000.0) * 2000.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,100.0) * 200.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,10.0) * 20.0) * NdotL * LightColour;\n#endif     \n     \n    float ni = N_Air;\n    float nt = N_Water;     \n    \n    float cosi = NdotV;\n    float cost = GetCosT( ni, nt, cosi );\n    float fresnelA = Fresnel( ni, nt, cosi, cost );\n    float fresnelB = Fresnel( nt, ni, cost, cosi );\n\n    float fresnelFactor = 1.0f - (1.0f - fresnelA) * (1.0f - fresnelB);\n    \n    vec3 fresnel = vec3(fresnelFactor);\n\n    vec3 thinFilmColour;\n#if USE_THIN_FILM_LOOKUP\n    thinFilmColour = texture(iChannel0, vec2(NdotV, filmThickness) ).rgb;\n#else\n    thinFilmColour = GetThinFilmColour(NdotV, filmThickness);\n#endif\n    fresnel *= thinFilmColour;\n    \n    colour += reflection * fresnel * remaining;\n    remaining *= (1.0f - fresnel);\n\n\n#if 0\n    float fGlassThickness = 0.5;\n    vec3 vGlassColor = vec3(1,0.5, 0.25);\n\n\tfloat fOpticalDepth = fGlassThickness / NdotV;\n    vec3 vExtinction = exp2( -fOpticalDepth * (1.0 - vGlassColor) ); \n    remaining *= vExtinction;\n#endif    \n}\n\n\nvec3 GetSceneColour( vec3 rayOrigin, vec3 rayDir )\n{    \n    float kFarClip = 200.0;\n\n\tvec3 colour = vec3(0);\n    vec3 remaining = vec3(1);\n    \n    float side = 1.0;\n    \n    float minDist = 0.0;\n    \n    for( int i=0; i<10; i++ )\n    {\n        float t = Scene_Trace( rayOrigin, rayDir, minDist, kFarClip, side );\n        \n        if ( t>=kFarClip )\n        {\n            break;\n        }\n        \n        minDist = t + 0.1f;\n        \n        vec3 hitPos = rayOrigin + rayDir * t;\n\n        vec3 normal = Scene_GetNormal( hitPos );\n\n        Shade(colour, remaining, hitPos, rayDir, normal * side );\n        \n        side = side * -1.0f;\n    }\n    \n    colour += GetSkyColour(rayDir) * remaining; \n\t\n\treturn colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float heading = 0.3f + sin(iTime * 0.3) * 0.1;\n\n    float elevation = 1.8 + sin(iTime * 0.134) * 0.1;\n    \n    float fov = 2.5 + sin( iTime * 0.234) * 0.5;\n    \n    float cameraDist = 10.0;\n\tvec3 cameraPos = vec3(sin(heading) * sin(-elevation), cos(-elevation), cos(heading) * sin(-elevation)) * cameraDist;\n\tvec3 cameraTarget = vec3(sin(iTime * 0.1542) * 3.0, 0.0, 0.0);\n\n\tvec3 rayOrigin = cameraPos;\n\tvec3 rayDir = GetCameraRayDir( GetWindowCoord(uv), cameraPos, cameraTarget, fov );\n\t\n\tvec3 sceneCol = GetSceneColour( rayOrigin, rayDir );\n\t\n\tvec3 final = ApplyPostFX( uv, sceneCol );\n\t\n\tfragColor = vec4(final, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Margins 0.\n#define TS abs(sin(iTime / 3.0))\n#define TC abs(cos(iTime / 2.50))\n#define TS2 abs(sin(iTime / 2.0))\n#define TC2 abs(cos(iTime / 2.0))\n\n// Use a lookup texture in Buffer A for thin film interference instead of calculating it at every intersection\n#define USE_THIN_FILM_LOOKUP 0\n\nfloat N_Air = 1.0f;\nfloat N_Water = 1.33f;\n\nfloat PI = 3.141592654;\n\n// used to prevent loop unrolling\n// This will be zero but the compiler doesn't know that as iFrame is a uniform\n#define ZERO min(iFrame,0)\n\n// https://en.wikipedia.org/wiki/Fresnel_equations\nfloat FresnelS(float ni, float nt, float cosi, float cost)\n{\n    return ((nt * cosi) - (ni * cost)) / ((nt * cosi) + (ni * cost));\n}\n\nfloat FresnelP(float ni, float nt, float cosi, float cost)\n{\n    return ((ni * cosi) - (nt * cost)) / ((ni * cosi) + (nt * cost));\n}\n\nfloat Fresnel(float ni, float nt, float cosi, float cost )\n{    \n    float Rs = FresnelS( ni, nt, cosi, cost );\n    float Rp = FresnelP( ni, nt, cosi, cost );\n\n    return (Rs * Rs + Rp * Rp) * 0.5;\n}\n\nfloat FresnelR0(float ni, float nt)\n{\n    float R0 = (ni-nt) / (ni+nt);\n    R0 *= R0;\n    return R0;\n}\n\n// https://en.wikipedia.org/wiki/Snell%27s_law\nfloat GetCosT( float ni, float nt, float cosi )\n{\n    float n = ni/nt;\n    float sinT2 = n*n*(1.0-cosi*cosi);\n    \n    // Total internal reflection\n    if (sinT2 >= 1.0)\n    {\n        return 1.0;\n    } \n\n    float cost = sqrt(1.0 - sinT2);\n    return cost;\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3d(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fr = p - fl;\n    \n    vec3 ot = fr*fr*(3.0-2.0*fr);\n    vec3 zt = 1.0f - ot;\n    \n    \n    float result = 0.0f;\n    \n    result += hash13(fl + vec3(0,0,0)) * (zt.x * zt.y * zt.z);\n    result += hash13(fl + vec3(1,0,0)) * (ot.x * zt.y * zt.z);\n\n    result += hash13(fl + vec3(0,1,0)) * (zt.x * ot.y * zt.z);\n    result += hash13(fl + vec3(1,1,0)) * (ot.x * ot.y * zt.z);\n\n    result += hash13(fl + vec3(0,0,1)) * (zt.x * zt.y * ot.z);\n    result += hash13(fl + vec3(1,0,1)) * (ot.x * zt.y * ot.z);\n\n    result += hash13(fl + vec3(0,1,1)) * (zt.x * ot.y * ot.z);\n    result += hash13(fl + vec3(1,1,1)) * (ot.x * ot.y * ot.z);\n\n    return result;\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\n\nfloat Noise(vec3 p, float o)\n{\n    float result = 0.0f;\n    float a = 1.0f;\n    float t= 0.0;\n    float f = 0.5;\n    float s= 2.0f;\n    \n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    result = result / t;\n    \n    return result;\n}\n\n\n\n// Spectrum to xyz approx function from http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    return xyzFit_1931( f );    \n}\n\n\n\n// from  https://github.com/amandaghassaei/SoapFlow/blob/main/python/Thin%20Film%20Interference.ipynb\nfloat ThinFilmAmplitude( float wavelength, float thickness, float cosi )\n{\n    float ni = N_Air;\n    float nt = N_Water;\n    \n    float cost = GetCosT( ni, nt, cosi );\n\n    // # The wavelength inside a medium is scaled by the index of refraction.\n    // wavelength_soap = wavelength / n_soap\n    // wavelength_air = wavelength / n_air\n    // # First calc phase shift of reflection at rear surface, based on film thickness.\n    // phaseDelta = 2 * thickness / math.cos(theta) * 2 * math.pi / wavelength_soap  \n    // # There is an additional path to compute, the segment AJ from:\n    // # https://www.glassner.com/wp-content/uploads/2014/04/CG-CGA-PDF-00-11-Soap-Bubbles-2-Nov00.pdf\n    // phaseDelta -= 2 * thickness * math.tan(theta) * math.sin(incidentAngle) * 2 * math.pi / wavelength_air\n    // Simplified to:\n    float phaseDelta = 2.0 * thickness * nt * cost * 2.0 * PI / wavelength;\n    \n    // https://en.wikipedia.org/wiki/Reflection_phase_change\n    if (ni < nt)\n        phaseDelta -= PI;\n    if (ni > nt)\n        phaseDelta += PI;\n\n    float front_refl_amp = Fresnel(cosi, cost, ni, nt);\n    float front_trans_amp = 1.0 - front_refl_amp;\n    float rear_refl_amp = front_trans_amp * Fresnel(cost, cosi, nt, ni);\n    \n    rear_refl_amp /= front_refl_amp;\n    front_refl_amp = 1.0f;\n        \n    // http://scipp.ucsc.edu/~haber/ph5B/addsine.pdf\n    return sqrt(front_refl_amp * front_refl_amp + rear_refl_amp * rear_refl_amp + 2.0 * front_refl_amp * rear_refl_amp * cos(phaseDelta));\n}\n\nvec3 GetThinFilmColour( float cosi, float thicknessN )\n{\n    float thicknessMin = 100.0;//1.0f;\n    float thicknessMax = 1500.0;//2500.0f;\n    \n    float thickness = mix(thicknessMin, thicknessMax, thicknessN);\n\n    vec3 result = vec3(0.0);\n    \n    float t = 0.0;\n    \n    vec3 white = vec3(0.0);\n    \n    for (float wavelength = 380.0; wavelength<=780.0; wavelength += 50.0)\n    {\n        float amplitude = ThinFilmAmplitude( wavelength, thickness, cosi );\n        \n        vec3 XYZ = WavelengthToXYZ( wavelength );\n    \n        white += XYZ;\n    \n        result += XYZ * amplitude;\n        t += 1.0f;\n    }\n\n    result = XYZtosRGB( result );\n      \n    result /= t;\n    //result /= white;\n    //result = vec3(1.0);\n    \n    return result;\n}\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,0.95);\n//  blend = max(blend, (fract((pos+v*vec2(-1,1)*2.0)/Res.xy),0.));\n//  blend = (col * col2)  + blend * col;\n // fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n// fragColor=vec4(fract((pos+v*vec2(-1,1)*2.0)/Res.xy),1.);\n//  fragColor=blend;\n    fragColor=blend,texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if USE_THIN_FILM_LOOKUP\n    if (iFrame > 0)\n    {\n        int segmentCount = 32;\n        int segment = iFrame % segmentCount;\n        int currSegment = int(floor((fragCoord.y * float(segmentCount) / iResolution.y)));\n        \n        if ( segment != currSegment )\n        {\n            fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n            return;\n        }\n    }\n\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec3 result = GetThinFilmColour(uv.x, uv.y);  \n\n    fragColor = vec4(result,1.0);\n#else\n    discard;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[3]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n//  vec4 blend = mix(col,col2,0.05);\n   vec4 blend = mix(col,col2,(0.005 * TS));\n     vec4 blendy = mix(col2,col,(0.09 * TC));\n     vec4 blendo = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n    blend = min(blend,blendy);\n       blend = max(blend,blendo);\n //      blend = max(blend,blendy);\n// blend = blendo*blendy ;\n//  blend = (col * col2)  + blend * col;\n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.0001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}