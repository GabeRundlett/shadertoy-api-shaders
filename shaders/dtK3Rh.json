{
    "Shader": {
        "info": {
            "date": "1683576349",
            "description": "CC0: Glow shader experiment found\nFound this old glow shader experiment\nBetter than I remembered it so publishing it now.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "dtK3Rh",
            "likes": 22,
            "name": "Glow shader experiment found",
            "published": 3,
            "tags": [
                "mandelbox"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 445
        },
        "renderpass": [
            {
                "code": "// CC0: Glow shader experiment found\n// Found this old glow shader experiment\n// I found it better than I remembered it so publishing it now.\n// Fractal based on EvilRyu's mandelbox\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define NORM_OFF    0.001\n\nconst int   max_iter      = 90;\nconst float fixed_radius2 = 1.8;\nconst float min_radius2   = 0.5;\nconst vec4  folding_limit = vec4(1.0);\nconst float scale         = -2.9-0.2;\n\nmat3 g_rot;\nfloat g_off;\n\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nmat3 rotX(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    1.0 , 0.0 , 0.0\n  , 0.0 , +c  , +s\n  , 0.0 , -s  , +c\n  );\n}\n\nmat3 rotY(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , 0.0 , +s\n  , 0.0 , 1.0 , 0.0\n  , -s  , 0.0 , +c\n  );\n}\n\nmat3 rotZ(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , +s  , 0.0\n  , -s  , +c  , 0.0\n  , 0.0 , 0.0 , 1.0\n  );\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec4 pmin(vec4 a, vec4 b, vec4 k) {\n  vec4 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid sphere_fold(inout vec4 z, inout float dz) {\n  float r2 = dot(z, z);\n    \n  float t1 = (fixed_radius2 / min_radius2);\n  float t2 = (fixed_radius2 / r2);\n\n  if (r2 < min_radius2) {\n    z  *= t1;\n    dz *= t1;\n  } else if (r2 < fixed_radius2) {\n    z  *= t2;\n    dz *= t2;\n  }\n}\n\nvoid box_fold(float k, inout vec4 z, inout float dz) {\n  // Soft clamp after suggestion from ollij\n  vec4 zz = sign(z)*pmin(abs(z), folding_limit, vec4(k));\n  z = zz * 2.0 - z;\n}\n\nfloat mb(vec4 z, out float ss) {\n  float k = 0.1;\n  vec4 offset = z;\n  float dr = 1.0;\n  for(int n = 0; n < 5; ++n) {\n    box_fold(k/dr, z, dr);\n    sphere_fold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n  }\n\n  float d0 = (box(z, vec4(3.5, 3.5, 3.5, 3.5))-0.2) / abs(dr);\n  ss = dr;\n  return d0;\n}\n\nfloat df(vec3 p, out float ss) {\n  const float z = 0.1;\n  p /= z;\n  vec4 p4 = vec4(p, g_off);\n  p4.yzw *= g_rot;\n    \n  float d0 = mb(p4, ss);\n  float d = d0;\n  return d*z;\n} \n\nvec3 glow(vec3 ro, vec3 rd, out float tt) {\n  float res;\n  float t = 0.+0.2;\n  int iter = max_iter;\n\n  vec3 col = vec3(0.0);    \n  for(int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + rd * t;\n    float ss;\n    res = df(p, ss);\n    float lss = log(ss);\n    float lum = 0.4*exp(-0.5*t-5.0*res*float(i*i));\n    vec3 gcol = ((0.5+0.5*cos(2.4-vec3(0.0, 1.0, 2.0)+1.2*(lss))))*lum;\n    col += gcol;\n    if(res < 0.0003 * t || res > 20.) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n  \n  tt = t;\n    \n  return col;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  float ss;\n  nor.x = df(pos+eps.xyy, ss) - df(pos-eps.xyy, ss);\n  nor.y = df(pos+eps.yxy, ss) - df(pos-eps.yxy, ss);\n  nor.z = df(pos+eps.yyx, ss) - df(pos-eps.yyx, ss);\n  return normalize(nor);\n}\n\nvec3 render(vec2 p) {\n  float tm = TIME*0.5;\n  g_off = sin(tm*0.53);\n  g_rot = rotX(0.1*tm)*rotY(0.23*tm)*rotZ(0.31*tm);\n  vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));\n  mat2 rot= ROT(TIME/10.0); \n  vec3 ro = 0.5*vec3(-1.0, 0.5, -0.0);\n  lightDir.xz *= rot;\n  ro.xz  *= rot;\n  vec3 la = vec3(0.0, 0.0, 0.0); \n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 3.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  float tt = 0.0;\n  vec3 col = vec3(0.0);\n  vec3 gcol = glow(ro, rd, tt);\n  vec3 pos = ro+rd*tt;\n  vec3 nor = normal(pos);\n  vec3 ref = reflect(rd, nor);\n \n  float ttt = tanh_approx(0.3*tt);\n  float diff  = max(dot(lightDir, nor), 0.0);\n  float spe   = pow(max(dot(lightDir, ref), 0.0), 40.0);\n  float fre   = dot(rd, nor) + 1.0;\n  fre *= fre;\n \n  float fog = exp(-0.75*tt);\n  float sfog = exp(-2.0*0.5*tt);\n  const vec3 scol = 4.0*vec3(1.0, 0.5, 0.5).zyx;\n  col += gcol;\n  col += spe*sfog*scol;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x*=RESOLUTION.x/RESOLUTION.y;\n\n \n  vec3 col = render(p);\n  col -= 0.05*vec3(1.0, 2.0, 1.0);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}