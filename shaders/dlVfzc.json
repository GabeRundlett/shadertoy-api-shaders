{
    "Shader": {
        "info": {
            "date": "1702353005",
            "description": "Unlike [url]https://www.shadertoy.com/view/dtGfRV[/url], handles negative heights as well.\n\nLeft - flat, right - hill-shaded.\nTop - discrete, bottom - continuous palette.",
            "flags": 0,
            "hasliked": 0,
            "id": "dlVfzc",
            "likes": 4,
            "name": "Hypsometric palette (â‰ˆwiki-2.0)",
            "published": 3,
            "tags": [
                "heightmap",
                "topography",
                "cartography",
                "hypsometric"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 162
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Hypsometric palette somewhat based on\n//     http://soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/template/tn/wiki-2.0.png.index.html\n//     http://soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/country/tn/wiki-france.png.index.html\n// with input data interpreted as sRGB color triplets.\n// NOTE: the original palette (wiki-2.0 by Eric Gaba (Sting)) is itself in\n// the public domain.\n// Range: -1..+1, discrete/continuous (corresponds roughly to -5000m .. +5000m).\n// NOTE: output colors are in linear RGB.\n// NOTE: nonlinear (sqrt) input transform tries to roughly match\n// the distribution of isovalues in wiki-france above.\nvec3 hypsometric(float x,bool discrete)\n{\n    x=clamp(x,-1.0,1.0);\n    if(x>0.0)\n    {\n        x=sqrt(x)*19.0;\n        if(discrete) x=floor(x)+0.5;\n        return vec3(0.471,0.686,0.435)\n            +max(x- 0.0,0.0)*vec3(-0.116,-0.110,-0.118)\n            +max(x- 1.5,0.0)*vec3( 0.230, 0.172, 0.172)\n            +max(x- 6.5,0.0)*vec3(-0.179,-0.146,-0.117)\n            +max(x-13.5,0.0)*vec3( 0.168, 0.217, 0.223);\n    }\n    else\n    {\n        x=-sqrt(-x)*10.0;\n        if(discrete) x=floor(x)+0.5;\n        return vec3(\n            0.75+0.1*x+0.004*x*x,\n            0.9+0.05*x,\n            min(min(1.135+x*0.047,0.985-0.015*x),1.0));\n    }\n}\n\n//==============================================================================\n// Terrain with derivatives, based on https://www.shadertoy.com/view/DtdyDl\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nfloat rnd2i(ivec2 v)\n{\n    return float(int(hash(uint(v.x+65536*v.y))))*4.6566129e-10;\n}\n\n// 2D value noise. Gradient in xy, value in z.\nvec3 noise2d(vec2 v)\n{\n    ivec2 i=ivec2(floor(v)),e=ivec2(0,1);\n    v=fract(v);\n    float A=rnd2i(i+e.xx);\n    float B=rnd2i(i+e.yx);\n    float C=rnd2i(i+e.xy);\n    float D=rnd2i(i+e.yy);\n    vec2 d=30.0*v*v*(v*(v-2.0)+1.0);\n    v=v*v*v*(v*(v*6.0-15.0)+10.0);\n    return vec3(\n        vec2(mix(B-A,D-C,v.y),mix(C-A,D-B,v.x))*d,\n        mix(mix(A,B,v.x),mix(C,D,v.x),v.y));\n}\n\n// Terrain function. Height in z, gradient in xy.\nvec3 f(vec2 v)\n{\n    vec3 ret=vec3(0);\n    float w=1.0;\n    mat2 m=mat2(0.6,0.8,-0.8,0.6),A=2.5*m;\n    for(int i=0;i<6;++i)\n    {\n        vec3 r=w*noise2d(A*v);\n        r.xy=r.xy*A;\n        ret+=r;\n        A*=1.75*m;\n        w*=0.49;\n    }\n    ret=0.25*ret+0.75*vec3(3.0*ret.z*ret.z*ret.xy,ret.z*ret.z*ret.z);\n    return ret;\n}\n\n//==============================================================================\n// Main function.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 h=f(xy+0.1*iTime);\n    if(false&&xy.y>0.0) // Debug derivatives.\n    {\n        float eps=1e-3;\n        float dx=(f(xy+0.1*iTime+vec2(eps,0.0)).z-f(xy+0.1*iTime-vec2(eps,0.0)).z)/(2.0*eps);\n        float dy=(f(xy+0.1*iTime+vec2(0.0,eps)).z-f(xy+0.1*iTime-vec2(0.0,eps)).z)/(2.0*eps);\n        h.xy=vec2(dx,dy);\n    }\n    vec3 col=hypsometric(h.z,(xy.y>0.0));\n    if(xy.x>0.0) col*=max(dot(normalize(vec3(h.xy,16.0)),normalize(vec3(1,-1,2))),0.0); // Hill-shading.\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}