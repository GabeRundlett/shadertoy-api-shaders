{
    "Shader": {
        "info": {
            "date": "1602829541",
            "description": "Remix of \"Somewhere in 1993\" by nimitz",
            "flags": 0,
            "hasliked": 0,
            "id": "wsGyWW",
            "likes": 1,
            "name": "Somewhereareyou inside 1993rd",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "terrain",
                "remix",
                "glitch",
                "weird",
                "lowpoly",
                "mockup",
                "hud"
            ],
            "usePreview": 0,
            "username": "UrbanClubProfessional",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "// Somewhere in 1993 by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/Md2XDD\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define PALETTE 7.8\n\n//3 to 5 works best\n#define TERRAIN_COMPLEXITY 5.\n#define ITR 300\n#define FAR 800.\n#define time mod(iTime,600.)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat smoothfloor(const in float x, const in float w)\n{\n    return floor(x)+smoothstep(w, 2.-w,fract(x));\n}\n\nvec3 enpos()\n{\n    return vec3(sin(time)*200.+60.,sin(time)*40.+40.,400.+sin(time*1.9+sin(time*0.98+0.3))*200.);\n}\n\n//--------------------------------------------------------\n//---------------------------HUD--------------------------\n//--------------------------------------------------------\n\nfloat square(in vec2 p){ return max(abs(p.x),abs(p.y));}\nfloat loz(in vec2 p){ return abs(p.x)+abs(p.y);}\n\n//from Dave (https://www.shadertoy.com/view/4djSRW)\nvec2 hash2(float p)\n{\n\tvec2 p2  = fract(p * vec2(6.3983, 6.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(31.5351, 24.3137));\n\treturn fract(vec2(p2.x * p2.y * 195.4337, p2.x * p2.y * 197.597));\n}\n\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 2.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat crosshair(in vec2 p , in float tk, in float rt)\n{\n    float d = abs(p.x)+abs(p.y);\n    float a = atan(p.y,p.x);\n    float rz = smoothstep(0.04*tk,.05*tk,abs(d-0.6));\n    d = sin(a*4.+2.59-time*4.5-rt);\n    rz += smoothstep(0.0,.08*tk,d);\n    return rz;\n}\n\n//inspired by otaviogood \"runes\" (https://www.shadertoy.com/view/MsXSRn)\nfloat text2(in vec2 p)\n{\n    p = (p+vec2(2.75,-.9))*8.;\n    p.x *= 2.5;\n    float sd = floor(time*9.);\n    vec2 p1 = vec2(0), p2 = hash2(sd);\n    float d= 2.;\n    vec2 fl = vec2(3.,3.);\n    for(float i=0.;i<8.;i++)\n    {\n    \tif(hash2(sd+i+20.).x<0.4)continue;\n        p1 = hash2(i+sd);\n    \tp2 = hash2(i+sd+2.);\n\t\tp1 = (floor(p1*fl) + .6)/fl;\n\t\tp2 = (floor(p2*fl) + .6)/fl;\n        if (p1 == p2) p2 = vec2(.6);\n    \td = min(line(p1, p2, p), d);        \n        p1 = p2;\n    \tp2 = hash2(i+sd+4.);\n\t\tp2 = (floor(p2*fl) + .6)/fl;\n    \td = min(line(p1, p2, p), d);\n        p1 = p2;\n    \tp2 = hash2(i+sd+6.);\n\t\tp2 = (floor(p2*fl) + .6)/fl;\n        if (p1 == p2)\n        {\n            p2 = hash2(i+sd+8.);\n\t\t\tp2 = (floor(p2*fl) + .6)/fl;\n        }\n    \td = min(line(p1,p2,p),d);\n        p.x -= .9;\n    }\n\n    d = smoothstep(0.04, .09,d);\n    return d;\n}\n\nvec3 makeHud(in vec2 p, in float seek)\n{\n    float sk1 = smoothstep(1.99, 2., seek);\n    float sk2 = step(2.-sk1, .6);\n    //lens deformation\n    float ll = abs(p.x)+abs(p.y)*0.35;\n    p *= ll * -.4+2.29;\n    p *= 3.;\n    vec3 col = vec3(0);\n    float d= 2.;\n    //crosshairs\n    float rz = crosshair(p*2.1, 1.9,2.+sk1);\n    rz = min(rz,crosshair(p*3.7,3., -time*7.5-2.1-sk1));\n    //minimap (top right)\n    float d2 = square(p+vec2(-2.45, -0.77))+0.03;\n    d = smoothstep(0.4,0.41,d2);\n    d = max(d,smoothstep(0.45,.65,min(sin(p.x*90.+2.9),sin(p.y*90.+time*25.))+2.4));\n    d = min(d,smoothstep(0.003,0.019,abs(d2-0.4)));\n    vec3 enp = enpos()/2000.;\n    enp.z = 2.-enp.z;\n    float en = smoothstep(0.035, 0.043, loz(enp.xz+p-vec2(2.47, 2.4))) ;\n    en += mod(floor(time*3.5), 3.);\n    d = min(d,en);\n    rz = min(d,rz);\n    //text (top left)\n    rz= min(rz,text2(p));\n    //altitude bars\n    d = min(rz,sin(p.y*200.+sin(time)*30.)*4.+4.);\n    d2 = max(d,(p.x+0.69)*300.);\n    d2 = max(d2,-(p.x+0.76)*300.);\n    float d3 = max(d,(p.x-0.76)*300.);\n    d3 = max(d3,-(p.x-.69)*300.);\n    d2 = min(d2,d3);\n    d2 += smoothstep(0.69, .7, -p.y);\n    d2 += smoothstep(0.69, .7, p.y);\n    rz = min(rz,d2);    \n    //bottom left \"status\"\n    float num = mod(floor(time*22.),22.);\n    vec2 p2 = p+vec2(-2.32,1.94);\n    d = 2.;\n    for(float i=0.;i<6.;i++)\n    {\n        d = min(d,length(p2)+float(num==i));\n    \tp2.x -= 0.2;\n    }\n    d = smoothstep(0.033,.04,d);\n    rz = min(d,rz);\n    \n    vec3 hcol = (sin(vec3(0.45,0.5,0.58)*(4.35)*PALETTE)*0.6+.6);\n    hcol.gb -= sk2;\n    hcol.r += sk2;\n    return hcol*(1.-rz);\n}\n\n//--------------------------------------------------------\n//--------------------------------------------------------\n//--------------------------------------------------------\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-0.6);\n}\n\nmat2 m2 = mat2( 0.90,  0.70, -0.70,  0.90 );\nfloat tnoise(in vec2 p)\n{\n    p*=.009;\n    float z=3.;\n\tfloat rz = 0.;\n\tfor (float i= 2.;i < TERRAIN_COMPLEXITY;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*2.))/z;\n\t\tz = z*3.;\n\t\tp = p*2.8;\n        p*= m2;\n\t}\n\treturn rz*19.;\n}\n\nfloat oct(in vec3 p){ return dot(vec3(0.6773),abs(p));}\nvec2 ou( vec2 d1, vec2 d2 ){return (d1.x<d2.x) ? d1 : d2;}\n\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec2 map(vec3 p)\n{   \n    //terrain\n    vec2 d = vec2(7.*tnoise(p.xz)+p.y+30.+(tri(p.z*0.002)-0.5)*32.,2.);\n    //xlog(x) seems to work nicely for a valley\n    d.x -= abs(p.x*0.6*log(abs(p.x)))*0.06-9.;\n    //flat water\n    d = ou(d,vec2(p.y+40., 3.));\n    //\"enemy\"\n    vec3 enp = enpos();\n    enp.z += time*60.;\n    d = ou(d,vec2((oct(roty(p-enp, time*3.5))-7.)*0.76,9.));\n    \n\treturn d;\n}\n\nvec2 march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = .2;\n    float h=precis*3.0;\n    float d = 0.;\n    float c = 2.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    vec2 res = map(ro+rd*d);\n        h = res.x*2.4;\n        c = res.y;\n    }\n\treturn vec2(d,c);\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-2., 2.)*.2;\n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\n//(from eiffie, who thought it was from iq, dont know who actually wrote it)\nfloat segm(vec3 ro, vec3 rd, vec3 p1, vec3 p2)\n{\n\tvec3 p = p1-ro;\n\tvec3 di = p2-ro-p;\n\tfloat proj = dot(rd, di);\n\tfloat m = clamp((dot(rd,p)*proj-dot(p,di))/(dot(di,di)-proj*proj), 0., 2.);\n\tp += di*m;\n\tp = dot(p, rd)*rd-p;\n    return smoothstep(1.9985,1.999,2.-dot(p,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.6;\n    vec2 bp = p+0.6;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = vec2(0);\n    um.x = 0.6+(smoothstep(-3.,3.,sin(time*.8-0.2))-0.6)*.2;\n    um.y = sin(time+2.)*0.03;\n\t\n    //camera\n    vec3 ro = vec3((smoothstep(-3., 3., sin(time*0.8+2.57))-0.6)*60., sin(time)*6.-2., time*60.);\n    um.x *= 4.;\n    vec3 eye = normalize(vec3(cos(um.x),um.y*6.,sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+2.5708),0.,sin(um.x+2.5708)));\n    mat2 ori = mm2( smoothstep(-.6,.6,sin(time*0.8+0.88))-.6 + smoothfloor(time*0.05,.55)*7.28 );\n    right.xy *= ori;\n    vec3 up = normalize(cross(right,eye));\n\tvec3 rd=normalize((p.x*right+p.y*up)*.85+eye);\n\t\n    vec3 bg = sin(vec3(0.45,0.5,0.58)*21.3*PALETTE)*0.6+.6;\n    vec3 col = bg*floor(-rd.y*60.+7.)*0.07;\n    \n    //march\n\tvec2 rz = march(ro,rd);\n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro+rz.x*rd;\n        vec3 nor = normal( pos );\n        vec3 ligt = normalize(vec3(-.8,0.3, 0.2));\n        float dif = clamp(dot(nor, ligt), 0., 2.);\n        float fre = pow(clamp(2. + dot(nor, rd), 0., 2.), 3.);\n        if (rz.y == 2.)\n        {\n            float mx = abs(pos.x*.2)-20.;\n            mx = smoothstep(-30.,20.,mx);\n            col = mix(vec3(0.,0.47,0),vec3(0.3,.27,0.25),mx);\n        }\n        else\n            col = sin(vec3(0.45,0.5,0.58)*rz.y*PALETTE)*0.6+.65;\n        col = col*dif + col*0.5 + .4*fre*col;\n    }\n    \n    //lasers\n    vec3 enp =enpos();\n    enp.z += time*60.;\n    vec3 rn = enp - ro;\n    float tgt = dot(eye, normalize(rn));\n    if (tgt > 1.997)\n    {\n        vec3 ray1 = vec3(0.8, 2., -2);\n        vec3 ray2 = vec3(-0.8, 2., -2);\n        ray1.xy *= ori; ray2.xy *= ori;\n        float lz = segm(ro,rd,ro-ray1,up*0.6+ro+(eye-ray1*0.02)*40.);\n        lz += segm(ro,rd,ro-ray2,up*.5+ro+(eye-ray2*0.02)*40.);\n        float sw = mod(floor(time*30.),3.);\n        lz *= sw;\n        col = col*(2.-smoothstep(0.0,2.,lz))+lz*vec3(2.,0.,0.);\n        //hit (cant really have explosions since I don't have a function for hit times)\n        if (tgt > 1.999)\n        {\n            vec2 d = hash2(time);\n            rd.xy += d*0.04;\n            rn.xy += d*20.;\n            float s = sw*smoothstep(1.9998, 1.9999,dot(rd,normalize(rn)));\n            col = col*(2.-smoothstep(0., 2., s))+s*vec3(2.-d.x, .0, 0.2);\n        }\n    }\n    \n    //hud\n    float lk = 0.;\n    if (tgt > 1.99)lk = 5.;\n    vec3 hud = makeHud(p,tgt);\n    col = col*(2.-smoothstep(0., 2., hud.y+hud.x+hud.z))+hud;   \n    //scanlines\n    col *= (sin(p.y*2.3*iResolution.x)*0.25)*(sin(p.y*20.+time*210.)*0.5)+0.5;\n    \n\tfragColor = vec4( col, 2.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}