{
    "Shader": {
        "info": {
            "date": "1672845189",
            "description": "Let's see how the Kotelnikov (Nyquist—Shannon) theorem works in practice. I specifically chose the closest frequency of the wave to the maximum possible to fulfill the condition. Don't forget to click on the screen",
            "flags": 0,
            "hasliked": 0,
            "id": "DtjGRh",
            "likes": 6,
            "name": "Kotelnikov's theorem",
            "published": 3,
            "tags": [
                "2d",
                "sound",
                "wave",
                "audio",
                "theorem"
            ],
            "usePreview": 0,
            "username": "foxes",
            "viewed": 378
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Let's see how the Kotelnikov (Nyquist—Shannon) theorem works in practice.\n//\n// I specifically chose the closest frequency of the wave to the maximum\n// possible to fulfill the condition. You can change this in constants.\n//\n// As you can see, there are wave deviations at the frequency boundary,\n// but they are allowed by the theorem.\n//\n// The original theory goes like this:\n// Any function F(t) consisting of frequencies from 0 to f can be continuously\n// transmitted with any accuracy using numbers following each other in less\n// than 1/2f seconds. There is no concept of absolute accuracy here.\n//\n// The standart sampling rate was chosen not because 44100 could record 22000,\n// this is because the problem when trying to restore the frequency\n// of 20000 (the audibility threshold) persisted at 40050\n// the same as in the pair of 22022 and 44100\n// it was called the device problem, but this is the problem of the theory itself\n// Вasically this is a problem for people trying to prove that the signal can be restored\n// absolutely accurately\n//\n// https://ibb.co/pbYRMCF 22000 frequency, 44100 samples\n//\n// The second standard 48000 corresponds to the quality of 2.4 from 20000\n// it is also a mathematical threshold for another basis of various devices\n// that require increasing the frequency not by 1/2f but by close 1/2.5f seconds\n// and is a prime multiplier of other common formats\n//\n// I'm more interested in the distortion of real sound during sampling,\n// so I'm not displaying frequencies, but a wave.\n//\n// You can try to change the FX to generate more complex waves\n// and don't forget to click on the screen\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// for IQ, type 1 and you can remove ZOOM\n// IQ_TEST - very funny\n#define IQ_TEST 0\n\n#if IQ_TEST\n//(kFreqSignal+1.)*2.01\n//#define SAMPLES 24.12\n#define SAMPLES 22.05\n#define FREC 11.0\n#else\n#define ZOOM 2000.\n#define SAMPLES 44100.\n#define FREC 22000.\n#endif\n\n// You can increase the range to get rid of the modulation and thereby get closer to the absolute,\n// but you will not be able to get rid of distortions in this way, they will only get bigger in real sound\n#define RANGE 50.\n#define PI 3.1415\n#define DB 0.25\n\n// Kotelnikov 's basis\nfloat sinc(float x)\n{\n    return abs(x)>0. ? sin(x)/x : 1.;\n}\n\n// test function\nfloat FX(float t)\n{\n#if IQ_TEST\n    float freq = FREC*2.;\n#else\n    float freq = FREC*2./ZOOM;\n#endif\n    \n    float wav = 0.;\n    \n    if (iMouse.z <= 0.0) {\n        wav += (t>0. && t<1.) ? (sin((sqrt(sqrt(t))*2.-0.5)*3.1415)*0.5+0.5)*sin(t*freq*PI) : 0.;\n        t-=0.925;\n        wav += (t>0. && t<1.) ? (sin((sqrt(t)*2.-0.5)*3.1415)*0.5+0.5)*sin(t*freq*PI) : 0.;\n    } else {\n        wav += sin(t*freq*PI);\n    }\n\n    return wav;\n}\n\nfloat restore(float t,float ofs,float samp)\n{\n    float val=0.;\n    for (float i=-RANGE;i<RANGE;i+=1.) {       \n        float dto = (t+ofs)*samp+0.5;\n        float dt = floor(dto)+i;\n        float x = PI*((dto - dt)-0.5);\n        dt = dt/samp;\n        val += FX(dt-ofs)*sinc(x);\n    }\n        \n    return val;\n}\n\nfloat discret(float t,float ofs,float samp)\n{      \n    return FX(floor((t+ofs)*samp+0.5)/samp-ofs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = uv.x*3.-1.0;\n    float sign = FX(t);\n#if IQ_TEST\n    float s = SAMPLES;\n#else\n    float s = SAMPLES/ZOOM;\n#endif\n    float of = fract(iTime)/s;\n    float disc = discret(t,of,s);\n    float rest = restore(t,of,s);\n\n    rest = clamp((1. - abs(rest*0.25+0.5-uv.y)*5.0/(0.01+abs(dFdx(rest)))),0.,1.);\n    \n    sign = clamp((1. - abs(sign*0.25+0.5-uv.y)*5.0/(0.01+abs(dFdx(sign)))),0.,1.);\n    \n    float dto = (t+of)*s+0.5;\n    float dt = floor(dto);\n    float x = ((dto - dt)-0.5);\n    disc = disc*DB+0.5;\n    disc = abs(disc-uv.y)>0.005 || abs(x)>0.007*s ? 0. : 1.;\n\n    vec3 vawe = vec3(1.,1.,0.5)*sign;\n    vec3 rez = vec3(0.7,0.7,1.0)*rest;\n    vec3 dots = vec3(disc);\n\n    vec3 col= clamp(dots + vawe + rez,vec3(0.),vec3(1.));\n\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}