{
    "Shader": {
        "info": {
            "date": "1549133039",
            "description": "I've done a shader session at my IUT (a kind of French school) for there open doors event\n\ndone on Bonzomatic with some @Iq functions to help me up :)",
            "flags": 0,
            "hasliked": 0,
            "id": "tsS3RG",
            "likes": 3,
            "name": "Shader session at IUT #1",
            "published": 3,
            "tags": [
                "raymarching",
                "livecoding",
                "showdown",
                "bonzomatic"
            ],
            "usePreview": 0,
            "username": "antonOTI",
            "viewed": 528
        },
        "renderpass": [
            {
                "code": "\n\n#define PI 3.14159\n#define TAU 2. * PI\n#define REP(p, r) (mod(p + r/2., r) - r /2.)\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat subtraction( float d1, float d2, float k ) \n{\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat intersection( float d1, float d2, float k ) \n{\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 lookAt (vec3 eye, vec3 at, vec2 uv) \n{\n  vec3 forward = normalize(at - eye);\n  vec3 right = normalize(cross(forward, vec3(0,1,0)));\n  vec3 up = normalize(cross(right, forward));\n  return normalize(forward + right * uv.x + up * uv.y);\n}\n\n\nvec2 modA(vec2 p, float r)\n{\n  float a = atan(p.y,p.x);\n\n  a = mod(a + PI, TAU/r) - PI;\n\n  return length(p) * vec2(cos(a),sin(a));\n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat ease(float t)\n{\n  return floor(t) + sin(fract(t) * PI - PI / 2.) * .5 + .5;\n}\n\nfloat map(vec3 p)\n{\n\n  vec3 cp = p;\n  float dist = 1000.;\n  float time = iTime;\n  time = ease(time ) * 5. ;\n\n\n  p.z += iTime * 3.;\n\n  p.xy *= rot(sin(p.z * .1) * .1);\n\n  p = REP(p, 30.);\n\n  p.x = abs(p.x);\n\n\n  float bump = sin(iTime  * 2.+ p.y * .2 + p.x + cp.z*.25) * .5 + .5;\n\n  bump = pow(bump, 4.)*.9+.5;\n\n  p.y -= p.x * bump;\n\n  dist = length(p) - 1.;\n\n  p = cp;\n\n\n\n  p.xy *= rot(p.z * .5 + iTime);\n    \n//  p.xy = modA(p.xy, 2.);\n  p.x = -abs(p.x);\n  p += 1.7;\n\n\n  float cy = length(p.xy) - .5;\n\n  dist  = min(dist, cy);\n\n  p = cp;\n  cy = length(p.xy) - .4 * clamp(-cp.z*.1+1.,0.,1.);\n\n  dist = -min(-dist, cy);\n  return dist;\n}\n\n\nfloat cd = 0.;\nfloat ray(inout vec3 cp, vec3 rd)\n{\n  float st = 0.;\n  for(;st < 1.; st += 1./ 128.)\n  {\n    cd = map(cp);\n    if(cd < .01) break;\n    cp += rd * cd * .5;\n  }\n\n  return st;\n}\n\n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.01,.0);\n\n  return normalize(vec3(\n  map(p - e.xyy) - map(p + e.xyy),\n  map(p - e.yxy) - map(p + e.yxy),\n  map(p - e.yyx) - map(p + e.yyx)\n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 eye = vec3(0.,0.,-10.);\n  vec3 tar = vec3(0.);\n  vec3 rd = lookAt(eye, vec3(0.), uv);\n  vec3 cp = eye;\n\n  float st = ray(cp,rd);\n\n  vec3 norm = normal(cp);\n  vec3 ldir = normalize(tar - eye);\n\n  float li = dot(norm, ldir * 2.);\n  li = pow(1. - li, 3.);\n  \n\n  fragColor = vec4(li) * (1. - st);\n  fragColor.zy *= rot(cp.x);\n  fragColor.xz *= rot(cp.y);\n  fragColor.xy *= rot(cp.z * .1);\n  fragColor *= 3.;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}