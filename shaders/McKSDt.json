{
    "Shader": {
        "info": {
            "date": "1716500638",
            "description": "Morphing animation kata. Public domain.\nPlaying with variations of traditional patterns without looking at other people's code.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "McKSDt",
            "likes": 27,
            "name": "2D patterns 3: traditional",
            "published": 3,
            "tags": [
                "pattern"
            ],
            "usePreview": 0,
            "username": "rrrola",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "// Morphing animation kata. Public domain.\n// Playing with variations of traditional patterns\n// without looking at other people's code.\n\nfloat aawidth;  // antialiasing width\n\n// Antialias: smoothstep around 0 with specified width.\nfloat aa(float width, float x) { return smoothstep(-width, width, x); }\n\n// Square wave with frequency f, antialiased relative to aawidth.\nfloat squarewave(float x, float f) {\n  float a = aawidth * f;\n  // move the pulse to 0.25..0.75: only two edges\n  x = fract(x*f + .25) - .25;\n  return aa(a,x) - aa(a,x-.5);\n}\n\n// Triangle wave with period p and slope ±1.\n//   \\    /\\    /\n// --0\\--/-p\\--/2p--\n//     \\/    \\/\nfloat triwave(float x, float p) { return abs(mod(x,p) - .5*p) - .25*p; }\n\n// Smooth minimum (for scallops).\nfloat smoothmin(float a, float b) {\n  const float w = 10.;\n  return a + b - log2(exp2(w*a) + exp2(w*b)) / w;\n}\n\n// Herringbone <-> honeycomb. We'll use it twice.\n// The inner distance is wrong, but that's ok for this effect.\nfloat honeycomb(vec2 x, float t) {\n  float ext = mix(1., sqrt(3.), t);\n  vec4 m = .25*vec4(2,-1, 0,sqrt(3.)/ext);  // elongated hex\n  mat2 M = mat2(m);\n  float k = 4./sqrt(3.)*ext;\n  x.x += t * clamp(triwave(x.y + .25*k, k), -k/6., k/6.);  // skew vertical parts\n  x -= inverse(M) * round(M*x);\n  return max(max(abs(dot(x, m.xz)), abs(dot(x, m.yw))), abs(dot(x, m.xz+m.yw)));\n}\n\n// Quarter of a scallop: two circular arcs at 90°.\nfloat scallop(vec2 f) {\n  float d = length(f - .5),\n        D = length(f - vec2(-.5, 1.5));\n  return d<1. ? max(d,2.-D) : 2.-d;\n}\n\nvoid mainImage(out vec4 O, vec2 X) {\n  float zoom = 4.;\n  vec2 R = iResolution.xy,\n       uv = (X+X-R)/R.y,  // .y = -1..1\n       x = zoom*uv + .5;  // .y = -zoom..zoom, then center on [.5 .5].\n  aawidth = 1.5 * zoom / R.y;\n  vec2 T = (iTime + 32.) * vec2(3, 1.618);\n  float t = T.y - .1*x.x;  // animation depends on time and horz position\n  float phase = mod(t / radians(360.), 6.);  // scene = integer part\n  float P = fract(phase);  // animation = fraction part\n\n  vec2 i = floor(x + .5),  // half-integer cell\n       f = x - i,          // cell fraction -0.5..0.5\n       M1 = vec2(1),\n       m = mod(i-.5, M1+M1) - M1;  // cell mod 2 (-.5 .5)\n\n  // background colors\n  vec3 bg0 = vec3(.1,0,0),\n       bg1 = vec3(0,.06,.02),\n       bg2 = vec3(.07,.02,0),\n       bg3 = vec3(0,.01,.02),\n       bg4 = vec3(0,.05,.07),\n       bg5 = vec3(.04,0,.07);\n  vec3 bg, fg;\n  float c = 0.;  // color\n\n  // stars <-> polka dots <-> squircle\n  if (phase < 1.) {\n    bg = bg0;\n    // 45° square fold so that the dots can be bigger\n    vec2 i = floor(.5 * vec2(x.x - x.y + .75, x.x + x.y - .25)),  // cell\n         f = x - vec2(i.y + i.x + .75, i.y - i.x + .5);\n    // timing is quantized to cells\n    float p = log2(2.01 - cos(T.y - .1*(i.x + i.y)));  // star pointiness\n    float r = length(pow(.001+abs(f), vec2(p,p)));  // warped radius\n    float w = .55 + .08 * sin(T.x - i.x - .5*i.y) / p;  // pulsating width\n    c = aa(aawidth / min(1.,p), pow(r, 1./p) - w); // hacky antialiasing\n  }\n  \n  // quatrefoil <-> ogee\n  else if (phase < 2.) {\n    bg = bg1;\n    float tt = T.y / radians(360.);\n    vec2 M = vec2(3,2), m = mod(i-.5, M+M) - M;  // -2.5 -1.5 -.5 .5 1.5 2.5\n    // two quatrefoils in one supercell\n    if (abs(m.x) > 2. || abs(m.x) > 1. && abs(m.y) > 1.) { m = mod(m, M+M) - M; }\n    vec2 s = 2./3. * sign(m) * cos(.5*T.y);\n    if (abs(abs(m.x)-abs(m.y)) < .1) { s = -s; tt = -.125-tt; }\n    c = squarewave(length(s+f) - tt, 1.); // concentric circles\n  }\n  \n  // honeycomb <-> herringbone\n  // these have the same topology\n  else if (phase < 3.) {\n    bg = mix(bg1, bg2, aa(.05, P-.05));\n    float tt = .5 - .5*cos(.5*T.y);\n    float w = 1./3. * aa(.15, P);\n    // two copies with different shifts\n    c = 1. - aa(.5*aawidth, honeycomb(x, tt) - w)\n      + .4 * (1. - aa(.5*aawidth, honeycomb(x + vec2(4./3.,0), tt) - w));\n  }\n\n  // stripes <-> chevron <-> houndstooth\n  else if (phase < 4.) {\n    bg = mix(bg2, bg3, aa(.05, P-.05));\n    vec2 u = x + vec2(-T.y, T.y-1.5);  // scroll, center on diagonal\n    float t = .9*T.y - .1*floor(u.x);\n    // interleave stripes in horizontal and vertical bands\n    float s = squarewave(u.x+u.y, .51 - .5 * cos(t));  // diagonal stripes\n    c = step(1., mod(u.x,2.)) * s + step(1., mod(u.y,2.)) * (1.-s);\n  }\n\n  // scallop\n  else if (phase < 5.) {\n    bg = bg4;\n    \n    if (m.y < 0.) { m.x = -m.x; }\n    if (m.x < 0.) { f.x = -f.x; }\n    float c1 = scallop(f);  // same orientation: fish scales\n\n    vec2 M2 = vec2(2), m2 = mod(i-.5, M2+M2) - M2;  // -1.5 -.5 .5 1.5\n    if (abs(m2.x) > 1.) { f.xy = -f.yx; }\n    if (abs(m2.y) > 1.) { f.xy = -f.yx; }\n    if (m.y < 0.) { f.xy = f.yx; }\n    float c2 = scallop(f);  // interlocking curly brackets {}\n    \n    // wire antialiasing: if the curve gets too narrow, fade it out instead\n    float F = smoothstep(0.,1.,P);\n    float Fmin = 1. * zoom / R.y;\n    if      (F < Fmin)    { c = 1. - aa(aawidth, c1-(1.-Fmin)) / Fmin * F; }\n    else if (F > 1.-Fmin) { c = 1. - aa(aawidth, c2-(1.-Fmin)) / Fmin * (1.-F); }\n    // morph\n    else { c = 1. - aa(aawidth, smoothmin(c2-F, c1-(1.-F))); }\n  }\n\n  // coarse checkers <-> bowtie <-> fine checkers\n  else {\n    bg = bg5;\n    f = mat2(sin(.5*t + radians(vec4(45,-45, 135,45)))) * (sign(m) * f);\n    c = aa(2.*aawidth, abs(f.x) - abs(f.y));\n  }\n\n  bg *= 1.3 - .3*dot(uv,uv);  // vignette: background color -> black\n  fg = mix(vec3(1,.9,.7), vec3(1), .15*dot(uv,uv));  // cream -> white\n  O = vec4(sqrt(mix(bg, fg, c)),1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}