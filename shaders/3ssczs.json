{
    "Shader": {
        "info": {
            "date": "1585381413",
            "description": "The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n\nCreated a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ssczs",
            "likes": 11,
            "name": "The Live Coders Conference - 1",
            "published": 3,
            "tags": [
                "2d",
                "fbm",
                "tlc"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n// Created a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.\n\n// 2D shape created by combining 2D primitives from IQ's blog:\n//  https://iquilezles.org/articles/distfunctions2d\n// pmin from IQ's blog on smooth minimum functions:\n//  https://iquilezles.org/articles/smin\n// Lightning based on \"Sparkle sparkle little lightning\":\n//  https://www.shadertoy.com/view/3sXSD2\n\n#define PI     3.141592654\n#define TAU    (2.0*PI)\n#define SCA(a) vec2(sin(a), cos(a))\n#define TTIME  (iTime*TAU)\n#define PERIOD 600.0\n\nconst float a1 = PI/2.0;\nconst float a2 = PI*4.5/6.0;\n\nconst vec2 sca1 = SCA(a1);\nconst vec2 sca2 = SCA(a2);\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  return (aggr * 0.5) + 0.5;    \n}\n\nvec3 lightning(vec2 pos, float offset) {\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*SCA(PI/2.0 + TTIME/PERIOD);\n    \n  for (int i = 0; i < 3; i++) {\n    float btime = TTIME*85.0/PERIOD + float(i);\n    float rtime = TTIME*75.0/PERIOD + float(i) + 10.0;\n    float d1 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 3.0, rtime)));\n    float d2 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 2.0, btime)));\n    col += vec3(d1 * vec3(0.1, 0.3, 0.8));\n    col += vec3(d2 * vec3(0.7, 0.3, 0.5));\n  }\n    \n  return col;\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.0)/k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, vec4 r) {\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat arc(vec2 p, vec2 sca, vec2 scb, float ra, float rb) {\n  p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n  p.x = abs(p.x);\n  float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n  return sqrt(dot(p,p) + ra*ra - (2.0 - 0.000001)*ra*k) - rb;\n}\n\nfloat spokes(vec2 p, float s) {\n  vec2 pp = toPolar(p);\n  pp.y += TTIME*40.0/PERIOD;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  float ds = box(p, s*vec2(0.075, 0.5), s*vec4(0.04));\n  return ds;\n}\n\nfloat arcs(vec2 p, float s) {\n  \n  float d1 = arc(p, sca1, sca2, s*0.275, s*0.025);\n  float d2 = arc(p, sca1, sca2, s*0.18, s*0.025);\n  \n  return min(d1, d2);\n}\n\nfloat meeple(vec2 p, float s) {\n  float dh = box(p - s*vec2(0.0, -0.035), s*vec2(0.07, 0.1), s*vec4(0.065));\n  float dc = box(p - s*vec2(0.0, -0.22), s*vec2(0.15, 0.04), s*vec4(0.05, 0.02, 0.05, 0.02));\n  \n  return pmin(dh, dc, s*0.115);\n}\n\nfloat theLiveCoders(vec2 p, float s) {\n  float ds = spokes(p, s);\n  float dc = circle(p, 0.375*s);\n  float da = arcs(p, s);\n  float dm = meeple(p, s);\n  \n  float d = ds;\n  d = min(d, dc);\n  d = max(d, -da);\n  d = max(d, -dm);\n  \n  return d;\n}\n\nfloat df(vec2 p) {\n  float d = theLiveCoders(p, 1.0 - 0.5*cos(TTIME*7.0/PERIOD));\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=vec3(1.0 - tanh(pow(length(p/1.5), 5.0)));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  vec2 op = p;\n\n  p *= 1.0;\n\n  float d = df(p);\n  \n  const vec3  background   = vec3(0.0)/vec3(255.0);\n\n  vec3 col = background;\n\n  float borderStep = 0.0075;\n \n  vec3 baseCol = vec3(1.0);\n  vec4 logoCol = vec4(baseCol, 1.0)*smoothstep(-borderStep, 0.0, -d);\n  \n  if (d >= 0.0) {\n    vec2 pp = toPolar(p);\n    float funky = 0.7*pow((0.5 - 0.5*cos(TTIME/PERIOD)), 4.0);\n    pp.x *= 1./(pow(length(p) + funky, 15.0) + 1.0);\n    p = toRect(pp);\n    col += lightning(p, (pow(abs(d), 0.25 + 0.125*sin(0.5*iTime + p.x + p.y))));\n  }\n  col = clamp(col, 0.0, 1.0);\n\n  col *= 1.0 - logoCol.xyz;\n\n  col = postProcess(col, q, op);\n  col *= smoothstep(0.0, 16.0, iTime*iTime);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}