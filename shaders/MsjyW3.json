{
    "Shader": {
        "info": {
            "date": "1494179630",
            "description": "Attemp to show nice constellations. Plexus plugin for After Effects was an inspiration.",
            "flags": 32,
            "hasliked": 0,
            "id": "MsjyW3",
            "likes": 75,
            "name": "Constellations",
            "published": 3,
            "tags": [
                "stars",
                "night"
            ],
            "usePreview": 0,
            "username": "anomes",
            "viewed": 3761
        },
        "renderpass": [
            {
                "code": "// -----------------------------------------\n// RENDER POINTS, CONNECTIONS AND BACKGROUND\n// -----------------------------------------\n\n\n// must be the same as in 'Buf A'\n#define POINTS_SIZE 12\n#define POINTS_NUMBER POINTS_SIZE*POINTS_SIZE\n\n//\n#define BLOCK_SIZE 10\n#define BLOCK_NUMBER BLOCK_SIZE*BLOCK_SIZE\n\n// improve quality but also calculations\n#define SELECTION_SIZE 20\n\n#define ZOOM min(2.  ,  1.+0.*iMouse.y/iResolution.y  )\n#define POINT_RADIUS 0.025*ZOOM\n#define CONNECTION_DISTANCE 0.2*ZOOM\n#define GLOW 4.\n#define GLOW_INTENSITY 0.15\n\n\n\n// #########################\n\n\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : \n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n// \nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  \n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  \n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439); \n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0), \n                        dot(x1,x1), \n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: \n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple \n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nint blockIndexForPosition(vec2 pos)\n{\n\tvec2 p2 = vec2(  (pos.x*iResolution.y/iResolution.x+1.)/2.  ,  (pos.y+1.)/2.  );\n    float size = 1./float(BLOCK_SIZE);\n    return int(p2.x/size) + int(p2.y/size)*BLOCK_SIZE;\n}\n\nvec4 pointAtIndex(int index, int blockIndex)\n{\n    vec2 pos = vec2(  float(index)+0.5  ,  float(blockIndex)+0.5  )  /  iResolution.xy;\n    return texture(iChannel1, pos);\n}\n\nvec3 colorForIndex(int index)\n{\n    index = index%12;\n    if( index == 0 )\n    {\n         return vec3(1., 0., 0.);\n    }\n    else if( index == 1 )\n    {\n         return vec3(0., 1., 0.);\n    }\n    else if( index == 2 )\n    {\n         return vec3(0., 0., 1.);\n    }\n    else if( index == 3 )\n    {\n         return vec3(1., 1., 0.);\n    }\n    else if( index == 4 )\n    {\n         return vec3(0., 1., 1.);\n    }\n    else if( index == 5 )\n    {\n         return vec3(1., 0., 1.);\n    }\n    else if( index == 6 )\n    {\n         return vec3(1., 1., 1.);\n    }\n    else if( index == 7 )\n    {\n         return vec3(1., 0.5, 0.5);\n    }\n    else if( index == 8 )\n    {\n         return vec3(0.5, 1., 0.5);\n    }\n    else if( index == 9 )\n    {\n         return vec3(1., 0.5, 0.);\n    }\n    else if( index == 10 )\n    {\n         return vec3(0., 0.5, 1.);\n    }\n    else\n    {\n         return vec3(0.5, 0.5, 1.);\n    }\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( false )\n    {\n    \tvec2 pos = fragCoord/iResolution.xy;\n    \tfragColor = texture(iChannel1, pos);\n    \treturn;\n    }\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 p2 = vec2(  (p.x*iResolution.y/iResolution.x+1.)/2.  ,  (p.y+1.)/2.  );\n    int blockIndex = blockIndexForPosition(p);\n    \n    // selection\n    int k = 0;\n    vec2 selectionPoints[SELECTION_SIZE];\n    float selectionLengths[SELECTION_SIZE];\n    float selectionBlurs[SELECTION_SIZE];\n    vec3 selectionTints[SELECTION_SIZE];\n    for(int i=0; i<POINTS_NUMBER && k<SELECTION_SIZE; i++)\n    {\n        vec4 a = pointAtIndex(i, blockIndex);\n        if( a.w < 0. )\n        {\n            break;\n        }\n\t\tvec2 pa = p - a.xy;\n        float d = length(pa);\n        if( d < CONNECTION_DISTANCE )\n        {\n            selectionPoints[k] = a.xy;\n            selectionLengths[k] = d;\n            selectionBlurs[k] = abs(a.z);\n            /*if( a.w < 0.34 )\n            {\n            \tselectionTints[k] = vec3(0.8, 0.9, 1.); // blue\n            }\n            else if( a.w < 0.67 )\n            {\n            \tselectionTints[k] = vec3(1., 1., 1.); // white\n            }\n            else\n            {\n            \tselectionTints[k] = vec3(0.9, .9, .9); // gray\n            }*/\n            k++;\n        }\n    }\n    \n    \n    // connections\n    float h = 2.0/iResolution.y;\n    float col = 0.0;\n    float glow = 0.0;\n    for(int i=0; i<k; i++)\n    {\n        vec2 a = selectionPoints[i];\n        for(int j=0; j<k; j++)\n        {\n            vec2 b = selectionPoints[j];\n            if( a == b )\n            {\n                continue;\n            }\n            vec2 ba = b - a;\n            float d = length(ba);\n            d = smoothstep(CONNECTION_DISTANCE, CONNECTION_DISTANCE-0.1, d);\n    \t\tfloat blur = (selectionBlurs[i]+selectionBlurs[j])/2.;\n            float sd = sdSegment(p,a,b);\n            col = max(  col  ,  d*(1.0-smoothstep(h/2.,max(blur*2.,1.)*h,sd)) \n                     \t/ max(blur*1.5 , 1.)\n                     );\n            glow = max( glow,  (d*(1.0-smoothstep(0.,3.*GLOW*h,sd)) / max(blur*1.5 , 1.) )*GLOW_INTENSITY );\n        }\n    }\n    col = min(col+glow, 1.0);\n    \n    // points\n    vec3 tint = vec3(0.8, 0.9, 1.);\n    if( 0. < iMouse.z )\n    {\n    \ttint = colorForIndex(blockIndex);\n    }\n    for(int i=0; i<k; i++)\n    {\n        float d = selectionLengths[i];\n        float value = (1.0-smoothstep(0.,POINT_RADIUS*max(selectionBlurs[i]/2.,1.)/3.,d))\n                 \t/ max(selectionBlurs[i]/1.5 , 1.);\n        value += (  1.0-smoothstep(0.,GLOW*POINT_RADIUS*max(selectionBlurs[i]/2.,1.)/3.,d)  )*GLOW_INTENSITY;\n        col = max(  col  ,  value  );\n        //tint = mix(tint, selectionTints[i], col);\n    }\n \n    // background\n    vec2 vel = vec2(iTime*.1);\n    float background = snoise(2.*fragCoord.xy/iResolution.y+vel)*.25+.25;\n    float a = snoise(2.*fragCoord.xy/iResolution.y*vec2(cos(iTime*.08),sin(iTime*0.1))*0.1)*3.1415;\n    vel = vec2(cos(a),sin(a));\n    background += snoise(2.*fragCoord.xy/iResolution.y+vel)*.25+.25;\n    background *= 0.33*fragCoord.y/iResolution.y;\n    col += background;\n    if( 0. < iMouse.z )\n    {\n    \tcol += 0.25;\n    }\n    \n\tfragColor = vec4( col*tint.r, col*tint.g, col*tint.b, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// -------------------------------------------\n// PRECALCULATE/ANIMATE POINTS PER MACRO-BLOCK\n// -------------------------------------------\n\n\n// must be the same as in 'Main Image'\n#define POINTS_SIZE 12\n#define POINTS_NUMBER POINTS_SIZE*POINTS_SIZE\n\n// \n#define BLOCK_SIZE 10\n#define BLOCK_NUMBER BLOCK_SIZE*BLOCK_SIZE\n\n#define DEPTH_OF_FIELD 3.\n#define SPACING 2.8\n#define POSITION vec2(  1.4  ,  0.7  )\n#define SCALE    vec2(  1.1  ,  0.5  )\n#define TIME iTime\n\n\nint blockIndexForPosition(vec2 pos)\n{\n\tvec2 p2 = vec2(  (pos.x*iResolution.y/iResolution.x+1.)/2.  ,  (pos.y+1.)/2.  );\n    float size = 1./float(BLOCK_SIZE);\n    return int(p2.x/size) + int(p2.y/size)*BLOCK_SIZE;\n}\n\nvec4 rectForBlockIndex(int index)\n{\n   \tfloat size = 1./float(BLOCK_SIZE);\n    int y = index/BLOCK_SIZE;\n    int x = index - y*BLOCK_SIZE;\n    return vec4( float(x)*size, float(y)*size, size, size );\n}\n\nvec4 rectInset(vec4 rect, float inset)\n{\n    return rect + vec4(-inset,-inset,2.*inset,2.*inset);\n}\n\nbool pointInRect(vec4 rect, vec2 point)\n{\n    return rect.x <= point.x && point.x < rect.x+rect.z &&\n           rect.y <= point.y && point.y < rect.y+rect.w;\n}\n\nvec4 pointAtIndex(int index)\n{\n    float i = mod(float(index), float(POINTS_SIZE));\n    float j = floor(  float(index)/float(POINTS_SIZE)  );\n    float step = SPACING/float(POINTS_SIZE);\n    vec4 point = vec4(SCALE.x*step*i-POSITION.x, SCALE.y*step*j-POSITION.y, 0., 0.);\n    float factor = mod(  (j+1.)*(i+1.)  ,  22.  ) + 1.;\n    point.x += sin((20.+TIME/2.)*0.03*factor+i*0.5)*0.3;\n    point.y += cos((20.+TIME/3.)*0.01*factor)*0.3;\n    point.z = DEPTH_OF_FIELD*pow(  cos((20.+TIME)*0.01*factor)  ,16.);\n    point.w = float(  blockIndexForPosition(point.xy)  );\n    return point;\n    if( point.w == 0. )\n    {\n        point.xyz = vec3(1., 0., 0.);\n    }\n    else if( point.w == 1. )\n    {\n        point.xyz = vec3(0., 1., 0.);\n    }\n    else if( point.w == 2. )\n    {\n        point.xyz = vec3(0., 0., 1.);\n    }\n    else\n    {\n        point.xyz = vec3(1., 1., 0.);\n    }\n    return point;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(-100.);\n    if( fragCoord.x <= float(POINTS_NUMBER) && fragCoord.y < float(BLOCK_NUMBER) )\n    {\n        int index = int(fragCoord.x);\n\t\tvec4 point = pointAtIndex(index);\n        int blockIndex = int(fragCoord.y);\n        vec4 rect = rectForBlockIndex(blockIndex);\n        rect = rectInset(rect, 0.1);\n\t\tvec2 p2 = vec2(  (point.x*iResolution.y/iResolution.x+1.)/2.  ,  (point.y+1.)/2.  );\n        bool inside = pointInRect(rect, p2);\n        if(  inside  )//||  (point.w-0.5 < fragCoord.y && fragCoord.y <= point.w+0.5)  )\n        {\n            color = point;\n            //color = vec4(1.);\n        }\n    }\n    fragColor = color;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --------------------------\n// SORT POINTS BY MACRO-BLOCK\n// --------------------------\n\n\n// must be the same as in 'Main Image'\n#define POINTS_SIZE 12\n#define POINTS_NUMBER POINTS_SIZE*POINTS_SIZE\n\n// \n#define BLOCK_SIZE 10\n#define BLOCK_NUMBER BLOCK_SIZE*BLOCK_SIZE\n\n#define DEPTH_OF_FIELD 3.\n#define SPACING 2.8\n#define POSITION vec2(  1.4  ,  0.7  )\n#define SCALE    vec2(  1.1  ,  0.5  )\n#define TIME iTime\n\n\n\nvec4 pointAtIndex(int index, int blockIndex)\n{\n    vec2 pos = vec2(  float(index)+0.5  ,  float(blockIndex)+0.5  )  /  iResolution.xy;\n    return texture(iChannel0, pos);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(-100.);\n    if( fragCoord.x <= float(POINTS_NUMBER) && fragCoord.y < float(BLOCK_NUMBER) )\n    {\n        int targetIndex = int(fragCoord.x);\n        int blockIndex = int(fragCoord.y);\n        int k = 0;\n        for(int index=0; index<POINTS_NUMBER; index++)\n        {\n\t\t\tvec4 point = pointAtIndex(index, blockIndex);\n            if( point.w < 0. )\n            {\n                continue;\n            }\n            if( k == targetIndex  )\n            {\n                color = point;\n                break;\n            }\n            k++;\n        }\n    }\n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}