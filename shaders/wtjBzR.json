{
    "Shader": {
        "info": {
            "date": "1598232560",
            "description": "yes",
            "flags": 32,
            "hasliked": 0,
            "id": "wtjBzR",
            "likes": 1,
            "name": "Moonmoon",
            "published": 3,
            "tags": [
                "raymarch",
                "moon"
            ],
            "usePreview": 0,
            "username": "DarkWyvren",
            "viewed": 281
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.0005;\nconst int max_iter = 230;\nconst float MAXDIST = 70.0;\nconst float PI = 3.141592;\nfloat k = 0.1;\nfloat constDIV = 0.9;\nfloat moondist = 3.0;\nfloat asspace= 0.1;\nfloat asspacesc= 10.;\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\nfloat contrast(float x, float neg,float mul){\n\treturn max(0.0,mul*(x-neg));\n}\t\nfloat hash( uvec2 q )\n{\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nvec3 hash3(uvec2 q )\n{\n    return vec3(hash(q),hash(q+uvec2(13.032)),hash(q+uvec2(2.12)));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sphereSDF(vec3 pos, float r){\n\treturn length(pos)-r;\n}\n\nfloat boxSDF( vec3 pos, vec3 bounds )\n{\n  vec3 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat boxSDF( vec2 pos, vec2 bounds )\n{\n  vec2 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,d.y),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat roundEdge(float sdf,float rad){\n\treturn sdf+rad;\n}\n\nfloat sub(float sdf,float sdf2){\n\treturn max(-sdf,sdf2);\n}\nfloat Ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat add(float sdf,float sdf2){\n\treturn min(sdf,sdf2);\n}\nfloat Sadd(float sdf,float sdf2){\n\treturn smin(sdf,sdf2,k);\n}\n\nvec3 opRep( in vec3 p, in vec3 peroid)\n{\n    vec3 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\nvec2 opRep( in vec2 p, in vec2 peroid)\n{\n    vec2 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\n\nvec2 cartToSphere(vec3 cart){\n\treturn vec2(acos(cart.z),atan(cart.y,cart.x));\n}\n\nvec3 SphereToCart(vec2 sph){\n\treturn vec3(sin(sph.x)*cos(sph.y),sin(sph.x)*sin(sph.y),cos(sph.x));\n}\n\n\n\n\nvec4 getBG(vec3 dir){\n    return vec4(vec3(contrast(texture(iChannel0,10.*cartToSphere(dir)).x,0.56,5.0)),1.0);\n\n}\n\nfloat getSmoothnoise(vec3 thing){\n    vec3 thingrot = (rotationMatrix(vec3(1.,0.,0.),PI*0.5)*vec4(thing,0.0)).xyz;\n    vec2 thing2 = cartToSphere(normalize(thingrot));\n    //thing2*=10.0;\n\treturn clamp((vec4(1.9)//texture(iChannel0,thing2)*0.125\n           +texture(iChannel0,thing2*0.5)*0.05\n          //+texture(iChannel0,thing2*0.25)*0.5\n          +texture(iChannel2,thing2*0.125)*0.1\n                 -texture(iChannel3,thing2.xy*2.0)*0.3\n          ).r*0.8,-10.0,10.0);\n}\nfloat getpebblenoise(vec3 thing,float r){\n    vec3 thingrot = (rotationMatrix(vec3(1.,0.,0.),PI*0.5)*vec4(thing,0.0)).xyz;\n    vec2 thing2 = cartToSphere(normalize(thingrot));\n    //thing2*=10.0;\n\treturn clamp((vec4(1.0)//texture(iChannel0,thing2)*0.125\n\n                 -texture(iChannel3,thing2.xy*0.04+vec2(r))*2.\n          ).r*0.8,-10.0,10.0);\n}\nfloat asteroidSDF(vec3 pos, float r){\n\treturn length(pos)-r-getpebblenoise(pos,r*33.0)*r;\n}\n\nfloat moonSDF(vec3 raypos, vec3 pos, float scale\t){\n    float sdf = sphereSDF(raypos-pos,scale);\n    sdf-=0.025*max(0.85,getSmoothnoise(raypos-pos));\n    return sdf;\n}\n\nfloat getcrossSDF(vec3 pos, float scale\t){\n    \n    vec2 gridid = floor(pos.xz*asspacesc);\n    float t = length(gridid*asspace);\n    vec3 grididnoise = hash3(uvec2(gridid));\n    float moon = add(moonSDF(pos,vec3(0.0),scale),moonSDF(pos,vec3(moondist*sin(iTime),0.0,moondist*cos(iTime)),scale*0.6));;\n \n        return moon;\n}\n\nfloat getmoonBinarySDF(vec3 pos, float scale\t){\n   // float t = length(pos);\n   // vec2 gridid = floor(pos.xz/asspace);\n    float moon = add(moonSDF(pos,vec3(0.0),scale),moonSDF(pos,vec3(moondist*sin(iTime),0.0,moondist*cos(iTime)),scale*0.6));;\n \n    \n   // moon = add((texture(iChannel0,gridid*0.5).r*0.2+abs((t-49.0)*0.05))/scale+sphereSDF(vec3(mod(pos.x,asspace),pos.y,mod(pos.z,asspace))-vec3(asspace*0.5),0.1),moon);\n    return moon;\n}\n\nvec3 getNormal(vec3 pos, float scale){\n\treturn normalize(vec3(getcrossSDF(pos+vec3(EPSILON,0,0),scale)-getcrossSDF(pos-vec3(EPSILON,0,0),scale),  \n               \tgetcrossSDF(pos+vec3(0,EPSILON,0),scale)-getcrossSDF(pos-vec3(0,EPSILON,0),scale),  \n                getcrossSDF(pos+vec3(0,0,EPSILON),scale)-getcrossSDF(pos-vec3(0,0,EPSILON),scale)  \n               ));\n}\n\nfloat getDist(vec3 rayPos, vec3 raydir){\n    float totalDist = 0.0;\n    float sdfRN = 0.0;\n\tfor(int i = 0;i<max_iter;i++){\n    \tsdfRN = max(0.0,getcrossSDF(rayPos,1.0))*constDIV;\n        \n        rayPos += sdfRN*raydir;\n        totalDist += sdfRN;\n        if(sdfRN<EPSILON*2.0){\n            return totalDist;\n        \tbreak;\n        }\n        \n        if(sdfRN>MAXDIST){\n            return float(MAXDIST);\n        \tbreak;\n        }\n    }\n    return float(MAXDIST);\n\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = getmoonBinarySDF(ro + rd*t,0.7);\n        if( h<EPSILON )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat hardshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = getmoonBinarySDF(ro + rd*t,1.0);\n        if( h<EPSILON )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nfloat getLightIntense(vec3 normal,vec3 lightdir,vec3 viewdir,float spec,float expo,float diff){\n\tvec3 ref = reflect(viewdir,normal);\n\treturn spec*pow(clamp(dot(ref,lightdir),0.0,1.0),expo) + max(0.0,dot(normal,lightdir)*diff);\n}\n\nvec4 getBuf(vec2 auv, float blur){\n    vec4 ttt = vec4(0.0);\n    for(int i =-5;i<5;i++){\n    \tttt+=texture(iChannel1,auv+vec2(blur*float(i),0.));\n    }\n   ttt.g=ttt.r;\n    ttt.b=ttt.r;\n    return ttt*0.1;\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 auv = fragCoord/iResolution.xy;\n    vec2 uv = 1.0*(fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5));\n\tvec3 col;\n    vec3 camray ;\n     vec3 rayPos;\n    vec3 raydir;\n    camray = normalize(vec3(uv,-10.0));\n    vec3 light = normalize(SphereToCart(vec2(iTime*0.1+33.5,0.0)));\n    vec3 lookPos = vec3(0,0,0);//vec3(15.0*sin(iTime),-20.0*cos(0.25*iTime)*sin(iTime),0);\n    vec2 screenraypos = 2.0*(vec2(iMouse.x,iMouse.y)/iResolution.xy  - vec2(0,0.5)) ;\n    screenraypos*=0.04;\n    screenraypos.y+=0.03;\n    \n        rayPos = 50.0*SphereToCart(screenraypos);\n\t\t\n        mat4 camProj  = viewMatrix(rayPos, lookPos,vec3(0,1,0));\n        raydir = normalize((camProj * vec4(camray, 0.0)).xyz);\n     float cast1 = getDist(rayPos,raydir);\n    if(cast1>MAXDIST-EPSILON*2.0){\n    \tfragColor = getBG(raydir); //inital cast\n    }else{\n        vec3 norm= getNormal(rayPos+raydir*cast1, 1.0);\n        vec3 raypos2 = rayPos+raydir*cast1;\n        vec3 Light = max(vec3(0.0),getLightIntense(norm,light,raydir,0.1,2.0,0.9));\n \n        Light*=softshadow(raypos2,light,0.005,20.,9.0);\n        Light*=hardshadow(raypos2,light,0.005,1.,19.0);\n        Light+=getLightIntense(norm,-normalize(raypos2),raydir,0.1,2.0,0.9)*0.1*(dot(normalize(raypos2),light)*0.5+0.5);\n        if(length(raypos2)>1.4){\n        \tLight*=texture(iChannel2,cartToSphere(norm)).xyz;\n        }\n        Light*=4.0;\n        Light = log(Light+vec3(1.0));\n        fragColor = vec4(Light,1.0);\n    }\n    vec4 buffertex = getBuf(auv,0.005);\n    fragColor = mix(fragColor,buffertex,buffertex.a);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float EPSILON = 0.0005;\nconst int max_iter = 230;\nconst float MAXDIST = 70.0;\nconst float PI = 3.141592;\nfloat k = 0.1;\nfloat constDIV = 0.9;\nfloat moondist = 3.0;\nfloat asspace= 0.1;\nfloat asspacesc= 10.;\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\nfloat contrast(float x, float neg,float mul){\n\treturn max(0.0,mul*(x-neg));\n}\t\nfloat hash( uvec2 q )\n{\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nvec3 hash3(uvec2 q )\n{\n    return vec3(hash(q),hash(q+uvec2(13.032)),hash(q+uvec2(2.12)));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sphereSDF(vec3 pos, float r){\n\treturn length(pos)-r;\n}\n\nfloat boxSDF( vec3 pos, vec3 bounds )\n{\n  vec3 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat boxSDF( vec2 pos, vec2 bounds )\n{\n  vec2 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,d.y),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat roundEdge(float sdf,float rad){\n\treturn sdf+rad;\n}\n\nfloat sub(float sdf,float sdf2){\n\treturn max(-sdf,sdf2);\n}\nfloat Ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat add(float sdf,float sdf2){\n\treturn min(sdf,sdf2);\n}\nfloat Sadd(float sdf,float sdf2){\n\treturn smin(sdf,sdf2,k);\n}\n\nvec3 opRep( in vec3 p, in vec3 peroid)\n{\n    vec3 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\nvec2 opRep( in vec2 p, in vec2 peroid)\n{\n    vec2 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\n\nvec2 cartToSphere(vec3 cart){\n\treturn vec2(acos(cart.z),atan(cart.y,cart.x));\n}\n\nvec3 SphereToCart(vec2 sph){\n\treturn vec3(sin(sph.x)*cos(sph.y),sin(sph.x)*sin(sph.y),cos(sph.x));\n}\n\n\n\n\nvec4 getBG(vec3 dir){\n    return vec4(vec3(contrast(texture(iChannel0,10.*cartToSphere(dir)).x,0.9,5.0)),1.0);\n\n}\n\nfloat getSmoothnoise(vec3 thing){\n    vec3 thingrot = (rotationMatrix(vec3(1.,0.,0.),PI*0.5)*vec4(thing,0.0)).xyz;\n    vec2 thing2 = cartToSphere(normalize(thingrot));\n    //thing2*=10.0;\n\treturn clamp((vec4(1.9)//texture(iChannel0,thing2)*0.125\n           +texture(iChannel0,thing2*0.5)*0.05\n          //+texture(iChannel0,thing2*0.25)*0.5\n          +texture(iChannel2,thing2*0.125)*0.1\n                 -texture(iChannel3,thing2.xy*2.0)*0.3\n          ).r*0.8,-10.0,10.0);\n}\nfloat getpebblenoise(vec3 thing,float r){\n    vec3 thingrot = (rotationMatrix(vec3(1.,0.,0.),PI*0.5)*vec4(thing,0.0)).xyz;\n    vec2 thing2 = cartToSphere(normalize(thingrot));\n    //thing2*=10.0;\n\treturn clamp((vec4(1.0)//texture(iChannel0,thing2)*0.125\n\n                 -texture(iChannel3,thing2.xy*0.04+vec2(r))*2.\n          ).r*0.8,-10.0,10.0);\n}\nfloat asteroidSDF(vec3 pos, float r){\n\treturn length(pos)-r-getpebblenoise(pos,r*33.0)*r;\n}\n\nfloat moonSDF(vec3 raypos, vec3 pos, float scale\t){\n    float sdf = sphereSDF(raypos-pos,scale);\n    sdf-=0.025*max(0.85,getSmoothnoise(raypos-pos));\n    return sdf;\n}\n\nfloat getcrossSDF(vec3 pos, float scale\t){\n    \n    vec2 gridid = floor(pos.xz*asspacesc);\n    float t = length(gridid*asspace);\n    vec3 grididnoise = hash3(uvec2(gridid));\n    float moon =t+1.;\n \n        if(t>40. && pos.y<asspace\n          && pos.y>-asspace){\n            pos= (vec4(pos,0.0)*rotationMatrix(vec3(0.,1.0,0.),-0.004*iTime)).xyz;\n            float dd = 1.0-(texture(iChannel0,gridid*0.5).r*0.3+abs((t-49.0)*0.3));\n            if(dd<0.){\n            \treturn asspace;\n            }\n    moon = add(\n               asteroidSDF(vec3(mod(pos.x,asspace),pos.y,mod(pos.z,asspace))-asspace*vec3(vec3(0.5)+((grididnoise.xyz)*0.4)-vec3(0.4)),dd*0.04*asspace),moon);\n        }\n            return moon;\n}\n\nfloat getdustSDF(vec3 pos,vec3 dir, float scale\t){\n\n    if(abs(pos.y)>asspace*0.5){\n            return (abs(pos.y)-asspace*0.5)/(max(dot(dir, vec3(0,-1,0)),dot(dir, vec3(0,1,0))));\n    }\n    return abs(pos.y)-asspace*0.5;\n}\n\nfloat getmoonBinarySDF(vec3 pos, float scale\t){\n   // float t = length(pos);\n   // vec2 gridid = floor(pos.xz/asspace);\n    float moon = add(moonSDF(pos,vec3(0.0),scale),moonSDF(pos,vec3(moondist*sin(iTime),0.0,moondist*cos(iTime)),scale*0.6));;\n \n    \n   // moon = add((texture(iChannel0,gridid*0.5).r*0.2+abs((t-49.0)*0.05))/scale+sphereSDF(vec3(mod(pos.x,asspace),pos.y,mod(pos.z,asspace))-vec3(asspace*0.5),0.1),moon);\n    return moon;\n}\n\nvec3 getNormal(vec3 pos, float scale){\n\treturn normalize(vec3(getcrossSDF(pos+vec3(EPSILON,0,0),scale)-getcrossSDF(pos-vec3(EPSILON,0,0),scale),  \n               \tgetcrossSDF(pos+vec3(0,EPSILON,0),scale)-getcrossSDF(pos-vec3(0,EPSILON,0),scale),  \n                getcrossSDF(pos+vec3(0,0,EPSILON),scale)-getcrossSDF(pos-vec3(0,0,EPSILON),scale)  \n               ));\n}\n\nfloat getDist(vec3 rayPos, vec3 raydir){\n    float totalDist = 0.0;\n    float sdfRN = 0.0;\n\tfor(int i = 0;i<max_iter;i++){\n    \tsdfRN = max(0.0,getcrossSDF(rayPos,1.0))*constDIV;\n        \n        rayPos += sdfRN*raydir;\n        totalDist += sdfRN;\n        if(sdfRN<EPSILON*2.0){\n            return totalDist;\n        \tbreak;\n        }\n        \n        if(sdfRN>MAXDIST){\n            return float(MAXDIST);\n        \tbreak;\n        }\n    }\n    return float(MAXDIST);\n\n}\n\nfloat getDust(vec3 rayPos, vec3 raydir, out float totalDist){\n    totalDist = 0.0;\n    float sdfRN = 0.0;\n    float dust = 0.0;\n    float sdf;\n\tfor(int i = 0;i<max_iter;i++){\n        sdf = getdustSDF(rayPos,raydir,1.0);\n        sdf = add(sdf,getmoonBinarySDF(rayPos,1.0));\n    \tsdfRN = max(asspace*0.03,sdf)*constDIV;\n        \n        \n        if(sdf<EPSILON*2.0){\n                float t = length(rayPos.xz);\n            if(t>30.){\n     \t\t\tfloat dd = 1.0/(abs(rayPos.y)*100.0+1.0 + max(0.0,t-40.));\n            dust+=dd*0.03*(1.-dust);\n            }\n            sdfRN = min(asspace*0.3,sdfRN);\n        }\n        rayPos += sdfRN*raydir;\n        if(dust==0.0)\n        totalDist += sdfRN;\n        \n        if(sdfRN>MAXDIST*3.0){\n            return dust;\n        \tbreak;\n        }\n    }\n    return dust;\n\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = getmoonBinarySDF(ro + rd*t,0.7);\n        if( h<EPSILON )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat hardshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = getmoonBinarySDF(ro + rd*t,1.0);\n        if( h<EPSILON )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nfloat getLightIntense(vec3 normal,vec3 lightdir,vec3 viewdir,float spec,float expo,float diff){\n\tvec3 ref = reflect(viewdir,normal);\n\treturn spec*pow(clamp(dot(ref,lightdir),0.0,1.0),expo) + max(0.0,dot(normal,lightdir)*diff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.0*(fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5));\n\tvec3 col;\n    vec3 camray ;\n     vec3 rayPos;\n    vec3 raydir;\n    camray = normalize(vec3(uv,-10.0));\n    vec3 light = normalize(SphereToCart(vec2(iTime*0.1+33.5,0.0)));\n    vec3 lookPos = vec3(0,0,0);//vec3(15.0*sin(iTime),-20.0*cos(0.25*iTime)*sin(iTime),0);\n    vec2 screenraypos = 2.0*(vec2(iMouse.x,iMouse.y)/iResolution.xy  - vec2(0,0.5)) ;\n    screenraypos*=0.04;\n    screenraypos.y+=0.03;\n    \n        rayPos = 50.0*SphereToCart(screenraypos);\n\t\t\n        mat4 camProj  = viewMatrix(rayPos, lookPos,vec3(0,1,0));\n        raydir = normalize((camProj * vec4(camray, 0.0)).xyz);\n     float cast1 = getDist(rayPos,raydir);\n    vec3 norm= vec3(0.0);\n    float dustcast;\n    float dust = getDust(rayPos,raydir,dustcast);\n    vec3 raypos2 =  rayPos+raydir*dustcast;;\n    if(cast1>MAXDIST-EPSILON*2.0){\n        \n    \tfragColor = vec4(0.0); //inital cast\n    }else{\n        norm= getNormal(rayPos+raydir*cast1, 1.0);\n        raypos2 = rayPos+raydir*cast1;\n        vec3 Light = max(vec3(0.0),getLightIntense(norm,light,raydir,0.1,2.0,0.9));\n \n        \n        fragColor = vec4(Light.r,1.0/length(cast1),0.0,1.0);\n    }\n    fragColor = mix(fragColor,vec4(1.0,0.,0.,1.0),dust);\n    \n    \n    fragColor.r*=softshadow(raypos2,light,0.005,60.,9.0);\n      //  fragColor.r*=hardshadow(raypos2,light,0.005,1.,19.0);\n      //  fragColor.r+=getLightIntense(norm,-normalize(raypos2),raydir,0.1,2.0,0.9)*0.1*(dot(normalize(raypos2),light)*0.5+0.5);\n    \n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}