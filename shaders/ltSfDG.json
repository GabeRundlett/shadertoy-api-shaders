{
    "Shader": {
        "info": {
            "date": "1517560921",
            "description": "Learning profiling ray marching",
            "flags": 32,
            "hasliked": 0,
            "id": "ltSfDG",
            "likes": 1,
            "name": "raymarching_profiling_00",
            "published": 3,
            "tags": [
                "todo"
            ],
            "usePreview": 0,
            "username": "PhuHUYNH",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "// Place the shader to be profiled in bufA, and add the beacon at the end (tune S & T as you wish).\n// Better to stop shader iTime for coherency (see define on top)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U /= R.xy;\n    O = texture( iChannel0, U );\n    //if ( iMouse.z>0. ||                                     // comment if you want save image :-)\n    //    length(iMouse.xy)<10. && mod(iTime*4.,2.)<1.) \n    { O *= 2.; return; }\n    \n    \n    float M = texture( iChannel0, U , 100.).w \n              / min(1.,texture( iChannel0, vec2(.5)/R ).w), // average time\n          t = texture( iChannel0, U ).w;\n    t *= 25.;                                              // ms to sec\n    //t = log(1.+t);                                        // magnitude\n    //t *= .5/M;                                              // average mapped to 50%\n    \n    //t = clamp(t,0.,1.);                                     // prefer not wrapping\n    //O = .6 - .6 * sin( 6. * t + .2 + vec4(0,2.1,-2.1,0)  ); // heatmap\n    O = vec4(t);\n    if (t > 1.)\n        O = vec4(1., 0., 0., 1.);\n    if (t < 0.)\n        O = vec4(0., 0., 1., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define COL 0\n#define TEST_INTERACTION 0\n\n\n//#define _time iTime\n#define _time 15.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdPlanXZ( vec3 p)\n{\n    return p.y;\n}\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 c = vec3 (-3., -2., 0.);\n    vec2 res = vec2(sdPlanXZ(p -vec3(0., -2.5, 0.)), -.1);    \n    \n    //return vec2(sdSphere(p - vec3(0., 0., 0.), 1.55),.7);\n    res = opU(vec2(sdSphere(p - vec3(0., 0., 0.), 1.55),.7), \n              vec2(sdSphere(p - vec3(3. * sin(_time * .5), 0., 3. * cos(_time *.5)), .5),.2));\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    //Light setup\n\tvec3 light = vec3(10.0 * sin(_time / 10.), 7.0, cos(_time / 10.) * 10.0);\n    \n\tU = (-1.0 + 2.0*U.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(U, 1.0));\n\t\n    O = vec4(0.); // Sky color\n\n    float t = 0.0;\n    const int maxSteps = 64;\n    float epsilon = 0.005;\n    const float tmax = 20.;\n    vec2 res = vec2 (.0, -.5);\n    vec3 p = vec3(.0);\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        p = ro + rd * t;\n        res = map(p); // Distance to sphere of radius 0.5\n        if(res.x < epsilon || t > tmax)\n        {\n            break;\n        }\n        O.w ++;\n\n        t += res.x;\n    }\n    \n    if (t <= tmax)\n    {\n        vec3 nor = calcNormal( p );\n        vec3 ref = reflect( rd, nor );\n        float dif = max(0.0, dot(nor, normalize(light - p))); //diffuse.\n        if (res.y == -.1)\n        {\n            O.xyz = vec3(.3, .3, .3) * dif + vec3(0.2, 0.1, 0.2);\n        }\n        else \n            O.xyz = vec3(.5, .5, .5) * dif + vec3(0.1, 0.1, 0.1);\n    }\n   \n    // comment if you want save image :-)\n    if ( iMouse.z>0. || length(iMouse.xy)<10. && mod(_time * 4.,2.)<1.) \n    { O *= 2.; return; }\n    \n    O.w = U.x;\n    O.w = clamp(O.w,0., 1.);\n#if TEST_INTERACTION    \n#if COL\n    float n = O.w *= 7.*epsilon;\n   \n    O = .6 - .6 * sin( 6. * O.w + .2 + vec4(0,2.1,-2.1,0)  );\n    O /= ceil(n);\n#else\n# if 0\n    if (O.w < 10.) { O=vec4(1,0,0,0); return;}\n    if (O.w < 16.) { O=vec4(0,1,0,0); return;}\n    if (O.w ==64.) { O=vec4(0,0,1,0); return;}\n# else\n    O = O.wwww / 70.;  \n   \n    if (O.w > 1.) O = vec4(1,0,0,0);\n    if (O.w < 0.) O = vec4(0,0,1,0);\n# endif\n#endif\n#endif //#TEST_INTERACTION\n}\n\n// ------------- <><><> inspection beacon <><><> -------------------------\n#define INJECTION 1\n#if INJECTION\n#undef S\n#undef T\n#define S 16                          // inspected block size\n#define T 1000                          // test duration per block\n\n#define mainImage(O,U)                       \\\n    init(O,U);                               \\\n    if (select(O,U)) {                       \\\n        for(int t=0; t<T+min(0,iFrame); t++) \\\n            mainImage(O,U);                  \\\n        post(O,U);                           \\\n    }\n\nvoid init(inout vec4 O, vec2 U) {     // --- keep time buffer\n    O = texelFetch(iChannel0,ivec2(U),0);\n}\nbool select(inout vec4 O, vec2 U) {   // --- select block\n    int N = int(iResolution.x)/S, t = iFrame;\n    if (U==vec2(.5)) O.w = float(t)/float(N)/(iResolution.y/float(S)); // % of image scanned\n    return ivec2(U)/S == ivec2(t%N,t/N);\n}\nvoid post(inout vec4 O, vec2 U) {     // --- increment block time counter\n    O.w = texelFetch(iChannel0,ivec2(U),0).w + iTimeDelta;\n}\n#endif //INJECTION",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}