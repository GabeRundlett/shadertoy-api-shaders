{
    "Shader": {
        "info": {
            "date": "1696766239",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n \nturn AA on (AA=2)",
            "flags": 0,
            "hasliked": 0,
            "id": "fd2czG",
            "likes": 14,
            "name": "Year of Truchets #056",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "truchet",
                "aa"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 218
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #056\n    10/08/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n    \n*/\n\n// AA 1 = OFF 2 = ON > depending on GPU <\n#define ZERO (min(iFrame,0))\n#define AA 1\n// AA\n\n#define R    \t\tiResolution\n#define T \t    \tiTime\n#define M \t    \tiMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MIN_DIST    1e-5\n#define MAX_DIST    25.\n\nmat2 flip,turn,r90;\n\nconst vec3 size = vec3(1.);\nconst vec3 hlf =  size/2.;\nconst vec3 bs = vec3(hlf);\nconst vec3 grid = vec3(2,1,2);\nconst float thick = .12;\n\nfloat speed=0.,tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\nmat2 cam;\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(23.53,84.21+iDate.z)))*4832.3234); }\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 q1,q2,q3;\nfloat trh,trx,jre;\nconst float bg = .035;\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n\n    p.yz*=flip; p.xz*=turn;\n\n    vec3 q = p;\n\n    vec3 id = floor((q + hlf)/size)-grid;\n    float chk = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n    \n    q = q-size*clamp(round(q/size),-grid,grid);\n    \n    float hs = hash21(id.xz+id.y);\n\n    if( hs>.5) q.xz*=r90;\n    if(chk>.5) q.zy*=r90;\n    \n    float sn = mod(hs,5.)*5.;\n    float t1 = lsp(sn,sn+2.,tmod);\n    float t2 = lsp(sn+8.,sn+10.,tmod);\n    \n    t1 = eoc(t1); t1 = t1*t1*t1;\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    \n    cam=rot((t1-t2)*1.5707);\n    \n    if(chk>.5) { q.zx*=cam; } else { q.xy*=cam; }\n    \n    float xhs = fract(2.31*hs+id.y);\n\n    q1 = vec3(q+vec3(0,hlf.x,-hlf.y)).yxz;\n    q2 = q+vec3(hlf.x,0,hlf.z);\n    q3 = vec3(q-vec3(hlf.xy,0)).yzx;\n\n    \n    trh = trs(q1,vec2(hlf.x,thick));\n    trx = trs(q2,vec2(hlf.x,thick));\n    jre = trs(q3,vec2(hlf.x,thick));\n\n    float cut = box(q,bs*.90);\n\n    trh=max(abs(trh)-bg,trh);\n    jre=max(abs(jre)-bg,jre);\n    trx=max(abs(trx)-bg,trx);\n    \n    trh=max(trh,cut);\n    jre=max(jre,cut);\n    trx=max(trx,cut);\n    \n    if(trh<res.x ) {\n        res = vec2(trh,2.);\n    } \n    if(jre<res.x ) {\n        res = vec2(jre,4.);\n    }\n    if(trx<res.x ) {\n        res = vec2(trx,6.);\n    } \n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(2,-9,7);\n    vec3 l = normalize(lpos);\n    float diff = clamp(dot(n,l),.0,1.);\n    vec3 h = m==1.? vec3(.15) : hsv2rgb(vec3((T*.015)+(m*.075),.7,.3))*.35;\n    return h*diff;\n}\n\nvec3 render(in vec2 uv, in vec2 F )\n{    \n    vec3 C = hsv2rgb(vec3(T*.015,.7,.3))*.25;\n    vec3 ro = vec3(0,0,4.25),\n         rd = normalize(vec3(uv,-1));\n    \n    tspeed = T*.6;\n    tmod = mod(tspeed,25.);\n\n    // bounces - set lower if slow 10. to 5.\n    float b = 7.;\n\n    vec3  p = ro + rd * .1;\n    float atten = 1., k = 1., iv = 1., alpha = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n\n        float d = i<42? ray.x*.25: ray.x*.65;\n        float m = ray.y;\n\n        p += rd * d * k;\n        \n        if (d*d < 1e-7) {\n            C+=shade(p,rd,d,ray.y,n)*atten;\n\n            b -= 1.;\n            if(b<1.) break;\n            \n            atten *= .8;\n            p += rd* .02;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,iv>0.?.875:1.1);\n            iv *= -1.;\n            \n            if(length(rf) == 0.) rf = reflect(rd,n);\n            \n            rd=rf;\n            p+=-n*.001;\n        } \n        if(distance(p,rd)>45.) { break; }\n    }\n    \n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    // mouse //\n    float x = M.xy==vec2(0) ? .0 : (M.y/R.y * .5-.25)*PI2;\n    float y = M.xy==vec2(0) ? .0 : (M.x/R.x * 1.-.5)*PI2;\n\n    flip=rot(x-T*.075);\n    turn=rot(y+T*.05);\n    r90=rot(1.5707);\n\n    vec3 C = vec3(0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - .5;\n        vec2 uv = (-R.xy + 2.*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.*F)/max(R.x,R.y);\n#endif\n        vec3 color = render(uv,F);       \n        color = 1.35*color/(1.+color);\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    C = pow(clamp(C,0.,1.), vec3(.4545));\n\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}