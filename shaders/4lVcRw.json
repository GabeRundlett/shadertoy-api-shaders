{
    "Shader": {
        "info": {
            "date": "1535546976",
            "description": "Dipole simulation. Careful! Some of what looks important is just sampling limitations from the Nyquist–Shannon sampling theorem. That said, I'm also fairly sure there's a bug in here somewhere…",
            "flags": 0,
            "hasliked": 0,
            "id": "4lVcRw",
            "likes": 3,
            "name": "Dipole simulation",
            "published": 3,
            "tags": [
                "simulation",
                "physics",
                "dipole",
                "radio",
                "antenna"
            ],
            "usePreview": 0,
            "username": "BenWheatley",
            "viewed": 832
        },
        "renderpass": [
            {
                "code": "const float F_LOOP_MAX = 500.0;\nconst float PI = 3.14159265359;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.y -= 0.5;\n    uv *= 500.0;\n    uv.x += 00.0;\n\n    // For each element of dipole antenna…\n    float red_sum = 0.0;\n    float blue_sum = 0.0;\n    for (float i=-F_LOOP_MAX; i<F_LOOP_MAX; i+=1.0) {\n        // Get distance from this location to that element…\n        float fractional_position = PI*(i/F_LOOP_MAX); // -π ≤ fp ≤ π\n        float dy = uv.y - fractional_position;\n        float r = sqrt(uv.x*uv.x + dy*dy);\n        // That element has been varying in intensity sinusoidaly\n        // so ∑ sin(d+t)*relative_intensity\n        // relative_intensity zero at middle of dipole, peak (=1) at tips\n        float relative_intensity = 1.0;//sin(fractional_position);\n        float sine = sin(-iTime+r) * relative_intensity;\n\t    float value = 0.5*(1.0+sine);\n        red_sum += value;\n        blue_sum += value / (r*r);\n    }\n    // Red: phase\n    red_sum /= F_LOOP_MAX*2.0;\n    // Blue: logarithmic amplitude contours\n    blue_sum /= F_LOOP_MAX*2.0;\n    blue_sum = mod(log(blue_sum), 1.0);\n    if (blue_sum > 0.2) {\n        blue_sum = 0.0;\n    } else {\n        blue_sum = 1.0;\n    }\n    //blue_sum = 0.0;\n    \n    // Output to screen\n    fragColor = vec4(red_sum, 0.0, blue_sum, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}