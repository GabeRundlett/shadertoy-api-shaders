{
    "Shader": {
        "info": {
            "date": "1524577172",
            "description": "define 3 polylines for the 6 brick segments: (must visit corners + midside)\n .---1---.---2---.\n |                   |\n 3                 3\n |                   |\n .---2---.---1---.\nrobust colored version of [url]https://www.shadertoy.com/view/MstBR7[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "MddfR7",
            "likes": 6,
            "name": "escherized tiling 3",
            "published": 3,
            "tags": [
                "escher",
                "pattern",
                "tile",
                "mz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 635
        },
        "renderpass": [
            {
                "code": "// better filling variant of https://shadertoy.com/view/lsdBR7\n// colored variant of https://shadertoy.com/view/MstBR7\n\n// polylines must pass to corners and mid-side of brick.\n// trying to release the last constraint here: https://www.shadertoy.com/view/lsdfR7\n\n#define MM 0\nfloat  CELL = 5.,                  // grid size vertically -> cell size\n      RATIO = 2.,                  // brick length / brick width\n      BEVEL = .2,                  // bevel width ( cell %  )\n       GAP  = 0.;                  // inter brick gap ( cell % )\n\nvec2  CYCLE = 0.*vec2(3,2);        // pattern repeat scale ( in #brick )\n\n#define SHAPE 0                    // 0...6 : presets of shapes\n#define ANIM  1                    // anim (for demo) \n\n#if SHAPE==0 \nbool  BRICK = true;                // tiling or bricks\n//bool  BRICK = false;             // tiling or bricks\n\n// .---1---.---2---.\n// |               |\n// 3               3\n// |               |\n// .---2---.---1---.\n// polylines must pass to corners and mid-side of brick.\nvec2 polyline1[] = vec2[]( vec2(0,0), vec2(.25,.1), vec2(.75,-.1),vec2(1,0) );\nvec2 polyline2[] = vec2[]( vec2(0,0), vec2(.25,.3), vec2(.5,.1), vec2(.3,0),vec2(.5,-.2), vec2(.75,-.3),vec2(1,0) );\nvec2 polyline3[] = vec2[]( vec2(0,0), vec2(.1,-.25), vec2(0,-.4), vec2(-.5,-.5),vec2(-1.,-.3), vec2(-.8,-.2),vec2(-1.2,-.3), vec2(-.3,-.75),vec2(0,-1) );\n\n#elif SHAPE==1\n\nbool  BRICK = false;                // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0), vec2(.7,.3),vec2(1.3,-.3), vec2(2,0));\nvec2 polyline2[1];\nvec2 polyline3[] = vec2[]( vec2(0,0), vec2(-.3,-.6), vec2(0,-1));                          \n\n#elif SHAPE==2\n\nbool  BRICK = true;                // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),vec2(.5,0),vec2(.43,-.33),vec2(.76,-.33),vec2(.7,0),vec2(1,0));\nvec2 polyline2[] = vec2[]( vec2(0,0),vec2(.3,0),vec2(.23, .33),vec2(.56, .33),vec2(.5,0),vec2(1,0));\nvec2 polyline3[] = vec2[]( vec2(0,0), vec2(0,-.4),vec2(-.33,-.33),vec2(-.33,-.66),vec2(0,-.6),vec2(0,-1));                          \n\n#elif SHAPE==3\n\nbool  BRICK = true;                // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),vec2(.25,.2),vec2(.75,-.2),vec2(1,0));\nvec2 polyline2[] = vec2[]( vec2(0,0),vec2(.25,.2),vec2(.75,-.2),vec2(1,0));\nvec2 polyline3[] = vec2[]( vec2(0,0),vec2(.2,-.25),vec2(-.2,-.75),vec2(0,-1));\n\n#elif SHAPE==4 \n\n#define RATIO 1.\nbool  BRICK = false;               // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),vec2(.45,.25),vec2(.7,-.2),vec2(1,0));\nvec2 polyline2[1];\nvec2 polyline3[] = vec2[]( vec2(0,0),vec2(.25,-.45),vec2(-.2,-.7),vec2(0,-1));\n\n#elif SHAPE==5 \n\nbool  BRICK = true;               // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),/*vec2(.2,.2), */vec2(.5,.3),vec2(1,0));\nvec2 polyline2[] = vec2[]( vec2(0,0),/*vec2(.2,-.2),*/vec2(.5,-.3),vec2(1,0));\nvec2 polyline3[] = vec2[]( vec2(0,0),vec2(-.4,-.5),vec2(0,-1));\n\n#elif SHAPE==6 \n\nbool  BRICK = true;               // tiling or bricks\nvec2 polyline1[] = vec2[]( vec2(0,0),vec2(1,0));\nvec2 polyline2[] = vec2[]( vec2(0,0),vec2(1,0));\nvec2 polyline3[] = vec2[]( vec2(0,0),vec2(0,-.3),vec2(-.1,-.3),vec2(-.4,-.1),vec2(-.6,-.1),vec2(-.9,-.3),vec2(-1.,-.5),vec2(-.9,-.7),vec2(-.6,-.9),vec2(-.4,-.9),vec2(-.1,-.7),vec2(0,-.7),vec2(0,-1));\n\n#endif\n\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x )              // integer param\n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU);\n}\nvec3 hash3f(vec3 x) {              // float[0,1] param\n    return hash3(uvec3( x * float(0xffffffffU) ) );\n}\n\n// distance to line\nfloat line( vec2 p, vec2 a, vec2 b )\n{\n    p -= a; b -= a;\n\tfloat h = dot(p,b)/dot(b,b),   // projection index on line in [0,1]\n         hs = clamp( h, 0., 1. ); \n\treturn length( p - b*hs );     // with round edges\n  //return h==hs ? length( p - b*hs ) : 1e5; // without round edge\n}\n\n// signed distance to line\nfloat sline( vec2 p, vec2 a, vec2 b , float s)\n{\n    p -= a; b -= a;\n\tfloat h = dot(p,b)/dot(b,b),   // projection index on line in [0,1]\n         hs = clamp( h, 0., 1. ), l;\n    p -= b*hs;                     // projection point on line\n    l = length(p) * s* sign(p.x*b.y-p.y*b.x); // signed distance to line\n\t//return l;                   // with round edges\n    return h==hs ? l : 1e5;       // without round edge\n}\n\n// distance to line + inside count\nfloat lineC( vec2 p, vec2 a, vec2 b , inout int c)\n{\n    p -= a; b -= a;\n    if ( p.y >= min(0.,b.y) && p.y < max(0.,b.y) \n        && b.y!=0. && b.x*p.y/b.y > p.x ) c++;\n\tfloat h = dot(p,b)/dot(b,b),    // projection index on line in [0,1]\n         hs = clamp( h, 0., 1. ); \n    p -= b*hs;                      // projection point on line\n\treturn length(p);               // with round edges\n  //return h==hs ? length(p) : 1e5; // without round edge\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; U /= R.y;          // normalized coordinates \n    O -= O;\n    vec2 W = vec2(RATIO,1);                     // normalize in cells units\n    U *= CELL/W;\n#if !MM                                         // <- demo mode\n     if (!BRICK && RATIO==2.) polyline1[polyline1.length()-1] = vec2(2,0);\n    BEVEL = 1.5*CELL/R.y;                       // 1-pixel thick line\n   #if ANIM                                     // animation\n    for (int i=1; i<polyline1.length()-1; i++)\n        polyline1[i] += .1*cos(iTime+float(i)+vec2(0,1.57));\n    for (int i=1; i<polyline2.length()-1; i++)\n        polyline2[i] += .1*cos(iTime+.3+float(i)+vec2(0,1.57));\n    for (int i=1; i<polyline3.length()-1; i++)\n        polyline3[i] += .05*cos(iTime+.6+float(i)+vec2(0,1.57));\n   #endif\n#endif\n    float ofs = mod(floor(U.y),2.);\n    if (BRICK) \n        U.x += .5*ofs;\n    else ofs = 0.;\n    vec2 S = W* (fract(U) - 1./2.);             // centered coords in a brick\n\n    float d = 1e5,s,l, X = RATIO/2.;\n    int c=0;\n    \n#define testline(O,T)                        \\\n        l =  lineC( S-O, _P, P , c) ;        \\\n        if ( l < d) d = l, D = T;\n    \n    vec2 P = polyline1[0], _P, D=vec2(0);\n    float X0 = BRICK ? 0. : -X;\n    for (int i=0; i < polyline1.length()-1; i++) {\n        _P = P; P = polyline1[i+1];\n        testline( vec2(-X, .5), vec2(  -ofs, 1) );\n        testline( vec2(X0,-.5), vec2(float(BRICK)-ofs,-1) );\n    }\n    if (BRICK) {\n    P = polyline2[0];\n    for (int i=0; i < polyline2.length()-1; i++) {\n        _P = P; P = polyline2[i+1];\n        testline( vec2( 0, .5), vec2(1.-ofs, 1) );\n        testline( vec2(-X,-.5), vec2(  -ofs,-1) );\n    }}\n    P = polyline3[0];\n    for (int i=0; i < polyline3.length()-1; i++) {\n        _P = P; P = polyline3[i+1];\n        testline( vec2( X, .5), vec2( 1,0) );\n        testline( vec2(-X, .5), vec2(-1,0) );\n    }\n    \n    if ((c&1)==1) D = vec2(0);\n\n    vec2 H = U+D+1.; // vec2 tile id\n    H = CYCLE==vec2(0) ? H : mod(H,CYCLE);\n    O += clamp ( (d-GAP)/BEVEL, 0., 1.); \n#if !MM    \n    O.rgb *= hash3(uvec3(H,2));\n#else  \n // O-=O;\n    O.r =  hash3(uvec3(H,2)).r;\n#endif    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}