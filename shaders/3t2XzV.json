{
    "Shader": {
        "info": {
            "date": "1566461884",
            "description": "Testing google AI color map using the interpolation approximation:\nhttps://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html\nhttps://observablehq.com/@mbostock/turbo",
            "flags": 32,
            "hasliked": 0,
            "id": "3t2XzV",
            "likes": 3,
            "name": "Testing turbo colormap",
            "published": 3,
            "tags": [
                "raymarching",
                "colormap"
            ],
            "usePreview": 0,
            "username": "maeln",
            "viewed": 971
        },
        "renderpass": [
            {
                "code": "// fifth-order polynomial approximation of Turbo based on:\n// https://observablehq.com/@mbostock/turbo\nvec3 turbo(float x) {\n    float r = 0.1357 + x * ( 4.5974 - x * ( 42.3277 - x * ( 130.5887 - x * ( 150.5666 - x * 58.1375 ))));\n\tfloat g = 0.0914 + x * ( 2.1856 + x * ( 4.8052 - x * ( 14.0195 - x * ( 4.2109 + x * 2.7747 ))));\n\tfloat b = 0.1067 + x * ( 12.5925 - x * ( 60.1097 - x * ( 109.0745 - x * ( 88.5066 - x * 26.8183 ))));\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float dist = texture(iChannel0, uv).x;\n    \n\tfragColor = vec4(turbo(dist), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAXSTEPS 128\n#define MAXDIST  20.0\n#define saturate(x) (clamp(0.0, 1.0, x))\n\n\n\n// Primitive fun from Iq: \n// https://iquilezles.org/articles/distfunctions\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\n\nfloat sdPlane(vec3 p)\n{\n  return p.y;\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\t\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 cubes(vec3 p)\n{\n    p.z = min(p.z, 0.0);\n   \tvec3 c = vec3(1.0, 0.0, 1.0);\n    vec3 q = mod(p,c)-0.5*c;\n    float y = 0.25+0.25*2.0;\n    float cube = sdBox(q-vec3(0.0, y, 0.0), vec3(0.15));\n    return vec2(cube, 2.0);\n}\n\nvec2 spheres(vec3 p)\n{\n    p.z = max(p.z, 0.0);\n   \tvec3 c = vec3(4.0, 0.0, 4.0);\n    vec3 q = mod(p,c)-0.5*c;\n    \n    float s1 = sphere(q-vec3(0,0.5,1.5), 0.5);\n    float s2 = sphere(q-vec3(0,0.2,1.0), 0.5);\n    vec2 u1 = vec2(smin(s1,s2,0.3), 1.0);\n    \n    return u1;\n}\n\nvec2 centralSphere(vec3 p) {\n    float centralSphere = sphere(p - vec3(1.0, 1.0+sin(iTime)*sin(iTime*2.0), cos(cos(cos(iTime)*0.3)*2.0)), 0.5);\n    \n    return vec2(centralSphere, 2.0);\n}\n\nvec2 scene(vec3 ray)\n{\n    vec2 plane = vec2(sdPlane(ray), 0);\n    vec2 b1 = cubes(ray);\n    vec2 u1 = spheres(ray);\n    vec2 c = centralSphere(ray);\n    return opU(c, opU(plane, opU(b1, u1)));\n}\n\nvec2 DE(vec3 ray) {\n    return scene(ray);\n}\n\nvec2 raymarch(vec3 from, vec3 direction)\n{\n    float t = 0.0;\n    float obj = -1.0;\n    for(int i=0; i<MAXSTEPS; ++i)\n    {\n        vec2 dist = DE(from + t * direction);\n        // if(t > MAXDIST) break;\n        t += dist.x;\n        obj = dist.y;\n    }\n    \n    return vec2(t, t > MAXDIST ? -1.0 : obj);\n}\n\nmat3 rotationX(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, c, s,\n                0.0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    int tx = int(uv2.x*512.0);\n    \n    vec3 target  = vec3(0.0, .5, 0.0);\n\tvec3 eye     = vec3(sin(iTime)*3.0, 1.5, cos(iTime)*3.0);\n    vec3 up      = vec3(0.0, 1.0, 0.0);\n    \n    vec3 eyeDir   = normalize(target - eye);\n    vec3 eyeRight = normalize(cross(up, eye));\n    vec3 eyeUp    = normalize(cross(eye, eyeRight));\n    \n    vec3 rayDir = normalize(eyeRight * uv.x + eyeUp * uv.y + eyeDir);\n    vec2 c = raymarch(eye, rayDir);\n    vec3 hit = eye+c.x*rayDir;\n    \n\tfragColor = vec4(c.x/MAXDIST);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}