{
    "Shader": {
        "info": {
            "date": "1680097808",
            "description": "Pentachoron rotating in 4D.",
            "flags": 0,
            "hasliked": 0,
            "id": "mdcXz2",
            "likes": 3,
            "name": "Rotating pentachoron",
            "published": 3,
            "tags": [
                "raytracing",
                "4d",
                "pentachoron"
            ],
            "usePreview": 0,
            "username": "stla",
            "viewed": 152
        },
        "renderpass": [
            {
                "code": "const float xmin = -1.9;\nconst float xmax = 1.9;\nconst float ymin = -1.9;\nconst float ymax = 1.9;\nconst float CRADIUS = 0.15;  // cylinders radius\nconst float SRADIUS = 0.25;  // spheres radius\nconst int RTYPE = 0; // type of the 4D rotation\n\n// pentachoron vertices -------------------------------------------------------\nconst vec4 vertices[] = vec4[5](\n  vec4(1.0/sqrt(10.0), 1.0/sqrt(6.0), 1.0/sqrt(3.0), 1.0),\n  vec4(1.0/sqrt(10.0), 1.0/sqrt(6.0), 1.0/sqrt(3.0), -1.0),\n  vec4(1.0/sqrt(10.0), 1.0/sqrt(6.0), -2.0/sqrt(3.0), 0.0),\n  vec4(1.0/sqrt(10.0), -sqrt(1.5), 0.0, 0.0),\n  vec4(-2.0 * sqrt(0.4), 0.0, 0.0, 0.0)\n);\n\n// colors for the edges (cylinders) -------------------------------------------\nconst vec3 colors[] = vec3[10](\n  vec3(0.882, 0.847, 0.400), \n  vec3(0.855, 0.412, 0.702), \n  vec3(0.663, 0.333, 0.882),\n  vec3(0.545, 0.616, 0.490), \n  vec3(0.525, 0.804, 0.878), \n  vec3(0.886, 0.851, 0.800), \n  vec3(0.557, 0.894, 0.725), \n  vec3(0.898, 0.533, 0.478), \n  vec3(0.663, 0.620, 0.851), \n  vec3(0.537, 0.894, 0.380)\n);\n\n// 3D rotations ---------------------------------------------------------------\nmat3 Rx(float phi) {\n  return mat3(\n    1.0, 0.0, 0.0, \n    0.0, cos(phi), -sin(phi), \n    0.0, sin(phi), cos(phi)\n  );\n}\nmat3 Ry(float phi) {\n  return mat3(\n    cos(phi), 0.0, sin(phi), \n    0.0, 1.0, 0.0, \n    -sin(phi), 0.0, cos(phi)\n  );\n}\nmat3 Rz(float phi) {\n  return mat3(\n    cos(phi), -sin(phi), 0.0, \n    sin(phi), cos(phi), 0.0, \n    0.0, 0.0, 1.0\n  );\n}\nvec3 rotate(vec3 pt, float ax, float ay, float az) {\n  return Rx(ax) * (Ry(ay) * (Rz(az) * pt));\n}\nvec3 invrotate(vec3 pt, float ax, float ay, float az) {\n  return Rz(-az) * (Ry(-ay) * (Rx(-ax) * pt));\n}\n\n// ROTATIONS 4D ---------------------------------------------------------------\n//// rotation around the plane spanned by 'axis1' and 'axis2'\nvec4 rotation4D(vec4 axis1, vec4 axis2, float theta, vec4 v) {\n  axis1 = normalize(axis1);\n  axis2 = normalize(axis2);\n  float vx = dot(v, axis1);\n  float vy = dot(v, axis2);\n  float coef1 = vx * cos(theta) - vy * sin(theta);\n  float coef2 = vy * cos(theta) + vx * sin(theta);\n  vec4 pvector = vx*axis1 + vy*axis2; \n  return coef1*axis1 + coef2*axis2 + (v-pvector);\n}\nconst vec4 AX1 = vec4(0, 0, 0, 1);\nconst vec4 AX2 = vec4(0, 1, 0, 0);\n//// right-isoclinic rotation\nvec4 rotation4DR(vec4 v, float theta, float phi, float xi) {\n  float a = cos(xi);\n  float b = sin(theta)*cos(phi)*sin(xi);\n  float c = sin(theta)*sin(phi)*sin(xi);\n  float d = cos(theta)*sin(xi);\n  float p = v.x, q = v.y, r = v.z, s = v.w;\n  return vec4(\n    a*p - b*q - c*r - d*s,\n    a*q + b*p + c*s - d*r,\n    a*r - b*s + c*p + d*q,\n    a*s + b*r - c*q + d*p\n  );\n}\nconst float THETA = 5.88;\nconst float PHI = 2.56;\n\n\n// SPHERE STUFF ---------------------------------------------------------------\n// ro is the ray origin, rd is the (normalized) ray direction, R is the radius\nvec4 iSphere(vec3 ro, vec3 rd, float R) {\n  float b = 2.0 * dot(ro, rd);\n  float c = dot(ro, ro) - R * R; \n  float delta = b * b - 4.0 * c;\n  if(delta < 0.0) { return vec4(-1.0); } // No intersection\n  float t = (-b - sqrt(delta)) / 2.0;    // Intersection occurred\n  vec3 nrml = (ro + t*rd) / R;\n  return vec4(t, nrml);\n}\n\n// CONE STUFF -----------------------------------------------------------------\n// ro is the ray origin, rd is the ray direction, \n// pa and pb are the centers of the caps, ra and rb are the radii\nfloat dot2(vec3 v) { return dot(v,v); }\nvec4 iCappedCone(\n  vec3 ro, vec3 rd, vec3 pa, vec3 pb, float ra, float rb, bool caps\n) {\n  vec3 ba = pb - pa;\n  vec3 oa = ro - pa;\n  vec3 ob = ro - pb;\n  float m0 = dot(ba,ba);\n  float m1 = dot(oa,ba);\n  float m2 = dot(ob,ba); \n  float m3 = dot(rd,ba);\n\n  if(caps) {\n    if(m1 < 0.0) {\n      if(dot2(oa*m3-rd*m1) < (ra*ra*m3*m3)) {\n        return vec4(-m1/m3, -ba*inversesqrt(m0));\n      }\n    } else if(m2 > 0.0) {\n      if(dot2(ob*m3-rd*m2) < (rb*rb*m3*m3)) {\n        return vec4(-m2/m3, ba*inversesqrt(m0));\n      }\n    }\n  }\n  \n  float rr = ra - rb;\n  float hy = m0 + rr*rr;\n  float m4 = dot(rd,oa);\n  float m5 = dot(oa,oa);\n  \n  float k2 = m0*m0 - m3*m3*hy;\n  float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*rr*m3;\n  float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n  \n  float h = k1*k1 - k2*k0;\n  if(h < 0.0) return vec4(-1.0);\n\n  float t = (-k1-sqrt(h))/k2;\n  float y = m1 + t*m3;\n  if(y > 0.0 && y < m0) {\n    return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));\n  }\n  \n  return vec4(-1.0);\n}\n\n// ----------------------------------------------------------------------------\n\n// Modified stereographic projection\n//  https://laustep.github.io/stlahblog/posts/ModifiedStereographicProjection.html\nvec3 stereog(vec4 q) {\n  return acos(q.w/sqrt(1.6)) * q.xyz/sqrt(1.6-q.w*q.w);\n}\n\n// coding (i,j) with i<j\nint f(int i, int j) {\n  if(i == 0) {\n    if(j == 1) return 0;\n    if(j == 2) return 1;\n    if(j == 3) return 2;\n    if(j == 4) return 3;\n  }else if(i == 1) {\n    if(j == 2) return 4;\n    if(j == 3) return 5;\n    if(j == 4) return 6;\n  }else if(i == 2) {\n    if(j == 3) return 7;\n    if(j == 4) return 8;\n  } else {\n    return 9;\n  }\n}\n\n// get the intersection value of t and the normal -----------------------------\n// ro is the ray origin, rd is the ray direction \nvec4 getTnorm(vec3 ro, vec3 rd, out vec3 color, out int shape) {\n  float t = 1.0e20; \n  vec4 OUTPUT = vec4(t);\n  color = vec3(0.0);\n  float theta = iTime;\n  vec3 rro = rotate(ro, -theta, theta, theta);\n  vec3 rrd = rotate(rd, -theta, theta, theta);\n  vec4 tnorm;\n  shape = 1;\n  float xi = iTime;\n  for(int i = 0; i < 4; i++) {\n    vec3 vi = RTYPE == 0 ? \n      stereog(rotation4D(AX1, AX2, xi, vertices[i])) : \n      stereog(rotation4DR(vertices[i], THETA, PHI, xi)); \n    for(int j = 1; j < 5; j++) {\n      if(j > i) {\n        vec3 vj = RTYPE == 0 ? \n          stereog(rotation4D(AX1, AX2, xi, vertices[j])) :\n          stereog(rotation4DR(vertices[j], THETA, PHI, xi)); \n        tnorm = iCappedCone(rro, rrd, vi, vj, CRADIUS, CRADIUS, false);\n        if(tnorm.x > 0.0){\n          tnorm.yzw = invrotate(tnorm.yzw, -theta, theta, theta);\n          OUTPUT = tnorm.x < t ? tnorm : OUTPUT;\n          color = tnorm.x < t ? colors[f(i,j)] : color;\n          t = min(t, tnorm.x);\n        }\n      }\n    }\n  }\n  float t_cylinder = t;\n  for(int i = 0; i < 5; i++){\n  vec3 vi = RTYPE == 0 ? \n    stereog(rotation4D(AX1, AX2, xi, vertices[i])) : \n    stereog(rotation4DR(vertices[i], THETA, PHI, xi)); \n  tnorm = iSphere(rro - vi, rrd, SRADIUS);\n  if(tnorm.x > 0.0) {\n    tnorm.yzw = invrotate(tnorm.yzw, -theta, theta, theta);\n    OUTPUT = tnorm.x < t ? tnorm : OUTPUT;\n    t = min(t, tnorm.x);\n  }\n  }\n  if(t < t_cylinder) shape = 2;\n  return OUTPUT;\n}\n\n// ----------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aspectRatio = iResolution.x/iResolution.y;\n  vec2 uv = vec2(\n    ((xmax - xmin) * fragCoord.x/iResolution.x + xmin) * aspectRatio, \n    (ymax - ymin) * fragCoord.y/iResolution.y + ymin\n  );\n\n  // Cast a ray out from the eye position into the scene\n  vec3 ro = vec3(uv, 5); \n  vec3 rd = normalize(vec3(uv, -4));\n\n  // Default color if we don't intersect with anything\n  vec3 rayColor = vec3(54.0, 57.0, 64.0) / 255.0;\n  // Direction the lighting is coming from\n  vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n  // Ambient light color\n  vec3 ambient = vec3(0.05, 0.1, 0.1);\n  // See if the ray intersects with any objects.\n  vec3 color; int shape;\n  vec4 tnorm = getTnorm(ro, rd, color, shape);\n  if(!(tnorm.x == 1.0e20)) {\n    vec3 nrml = tnorm.yzw;\n    vec3 objColor = shape == 1 ? color : vec3(0.2, 0.2, 0.2);\n    vec3 toEye = -rd;\n    vec3 r_m = normalize(-reflect(lightDir, nrml));\n    float specular = 0.72 * pow(max(dot(r_m, toEye), 0.0), 8.0);\n    float diffuse = max(dot(nrml, lightDir), 0.0); // diffuse factor\n    rayColor = objColor * (diffuse + ambient) + specular;\n  }\n  fragColor.rgb = rayColor;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}