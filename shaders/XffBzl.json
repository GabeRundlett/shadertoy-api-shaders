{
    "Shader": {
        "info": {
            "date": "1724417334",
            "description": "Using a triangle grid to produce a common interlocked block pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "XffBzl",
            "likes": 50,
            "name": "Interlocked Triangle Grid Blocks",
            "published": 3,
            "tags": [
                "triangle",
                "cube",
                "hexagon",
                "pencil",
                "isometric",
                "pattern",
                "block"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 372
        },
        "renderpass": [
            {
                "code": "/*\n\n\tInterlocked Triangle Grid Blocks\n\t--------------------------------\n    \n    Using a triangle grid to produce a cliche geometric block design... I'm not\n    exactly sure how you'd describe the pattern in the mathematical sense, but it's \n    very common in the geometric stock image world.\n    \n    There'd be numerous ways to produce this, and I'm pretty certain that I didn't\n    choose the best one. To be fair, these things tend to be hand drawn. In fact, \n    I've never seen it produced algorithmically, so consider this a first attempt. \n    \n    I chose a triangle grid, because I figured that would require the least amount \n    of rendering, but with the benefit of hindsight, a hexagon grid-based approach \n    might have made life easier, so don't take the code too seriously.\n    \n    Basically, I've rendered a few quads at strategic places within each triangle. \n    If you wish to see the repeat nature of the pattern, uncomment the \"SHOW_GRID\" \n    define and comment out the \"INNER_EDGES\" one. \n    \n    Hopefully, Fabrice Neyret -- or someone along those lines, will eventually see \n    this and render it in a more efficient way. In fact, it'd be great to see more \n    of the less common grid-based patterns in general.\n \n \n \n\t\n    Other patterns:\n    \n    // Just one of many simple patterns that can be created with\n    // a triangle grid.\n    tuto: triangle/hex coord + 3syms - FabriceNeyret2\n    Other Hexagonal Pattern Examples:\n\n    \n    // There are so many triangle grid-based patterns on here. I like the\n    // way this one looks, and the way it was produced.\n    Sine Wave Tiling - fizzer\n    https://www.shadertoy.com/view/fdtXRn\n    \n\n*/\n\n\n// Color scheme - Primary and grey: 0, Secondary and grey: 1, \n// Red and colors: 2, Earthtone: 3, Greyscale: 4.\n#define COLOR 0\n\n// Coloring the inner edges.\n//#define COL_EDGES\n\n// Applying a subtle pencil sketch style.\n#define PENCIL\n\n// Show inner edges. Taking them away allows you to see the geometric\n// pattern a little more clearly.\n#define INNER_EDGES\n\n// Faux ambient occlusion... I did it in a hurry, so it needs work.\n#define AO\n\n// Show the triangle grid that the pattern is constructed from.\n//#define SHOW_GRID\n\n\n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return max(dot(p - ro, n), 0.)/max(dot(rd, n), 1e-8);\n   float dn = dot(rd, n);\n   return dn>0.? dot(p - ro, n)/dn : 1e8;   \n   //return dn>0.? max(dot(p - ro, n), 0.)/dn : 1e8;   \n\n} \n\n// Block size.\nfloat getSize(float sL, vec2 ip){\n   \n   //return sL/4.5;//\n   //return sL*(sin(ip.y/6. - cos(ip.x/4. + iTime*2.)*1.57)*.25 + .5)/2.5;\n   return mix(sL/6., sL/3.25, smoothstep(.5, .7, sin(6.2831*hash21(ip) + iTime)*.5 + .5));\n   //return mix(sL/8., sL/2.5, hash21(ip));\n\n}\n\n// Block color.\nvec3 getCol(vec3 a, vec3 b){\n\n \n    float rnd = hash31(a);//hash31(a + b);\n    float rnd2 = hash31(a + .23);//hash31(a + b + .1);\n    float rnd3 = hash31(a + .34);//hash31(a + b + .1);\n    float rnd4 = hash31(a + .41);//hash31(a + b + .1);\n        \n    //vec3 col = .5 + .4*cos(6.2831589*rnd/4. + vec3(0, 1, 2));\n    vec3 col = mix(a, b, .25);\n  \n    #if COLOR < 2\n    if(rnd2<.4) col = mix(col, vec3(1.2)*dot(col, vec3(.299, .587, .114)), .9);\n    #endif\n    \n    #if COLOR == 4\n    col = mix(col, vec3(1.2)*dot(col, vec3(.299, .587, .114)), .9);\n    #endif\n    \n    #if COLOR < 3\n    if(rnd3<.35){\n    \n        #if COLOR < 2\n        col = col.zyx;\n        #else\n        if(rnd4<.33) col = col.zyx;\n        else if(rnd4<.66) col = col.yxz;\n        else col = col.xzy/(3. + col.xzy)*3.5;\n        #endif\n    }\n    #endif\n    \n    #if COLOR==1\n    col = col.yxz;\n    col /= (3. + col)/3.5;\n    #endif\n    \n    return col;\n\n}\n\n// Inner edge color.\nvec3 getEdgeCol(vec3 a){\n\n    #ifdef COL_EDGES\n    a *= vec3(1.2, 1, .8);\n    #endif\n    return (a + .9)*a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n    // Global scale factor.\n    const float sc = 1.;\n    // Smoothing factor.\n    float sf = sc/res;\n    \n    // Scene rotation, scaling and translation.\n    mat2 sRot = mat2(1, 0, 0, 1);//rot2(3.14159/12.); // Scene rotation.\n    vec2 camDir = sRot*normalize(vec2(1.732, 1)); // Camera movement direction.\n    vec2 ld = sRot*normalize(vec2(1, -1)); // Light direction.\n    vec2 p = sRot*uv*sc + camDir*iTime*scale/3.;\n    \n    // Perturbing coordinates for that unpredictable hand-drawn feel.\n    #ifdef PENCIL\n    vec2 offs = vec2(fbm(p*64.), fbm(p*64. + .35));\n    const float oFct = .001;\n    p -= (offs - .5)*oFct;  \n    #endif\n \n    // Keep a copy of the overall coordinates.\n    vec2 oP = p;\n    \n    // Vertex IDs and vertice points.\n    mat3x2 vID, v;\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    vec4 p4 = getTriVerts(p, vID, v);\n    // Local cell coordinates\n    p = p4.xy;\n    // Unique triangle ID (cell position based).\n    vec2 ctrID = p4.zw; \n    \n\n\n    // Equilateral triangle cell side length.\n    float sL = length(v[0] - v[1]);\n    \n \n    \n    // Edge width.\n    #ifdef PENCIL\n    float ew = .0055*(fbm(p*40.)*.35 + .65);\n    #else\n    float ew = .004;\n    #endif\n    \n    // Precalculating the edge points and edge IDs. You could do this inside\n    // the triangle grid function, but here will be fine.\n    mat3x2 e, eID;\n    for(int i = 0; i<3; i++){\n        int ip1 = (i + 1)%3;\n        eID[i] = mix(vID[i], vID[ip1], .5);\n        e[i] = mix(v[i], v[ip1], .5);\n    }\n \n    \n    // Quads.\n    vec3 quad = vec3(1e5);  // Large quads.\n    vec3 quad1 = vec3(1e5); // Block tops.\n    vec3 quad2 = vec3(1e5); // Block sides (in the triangle centers).\n    vec3 quad3 = vec3(1e5); // Block ends.\n\n    // A dividing line varible -- I think it's used to divide an \"L\" shape\n    // into two quads, or something like that.\n    vec3 lnDivC;\n\n\n    // Producing the quads. I haven't provided a great explanation here. However,\n    // a lot of it is simple: Start with the triangle vertices, then move points\n    // out by various angle vectors to produce the remaining quad points, etc.\n    //\n    for(int i = 0; i<3; i++){\n    \n        int ip1 = (i + 1)%3;\n        int ip2 = (i + 2)%3;\n        \n        // Varibale rotation angle and matrix. \n        float ang = -3.14159/32.;\n        mat2 rA = rot2(ang);\n        \n          \n        // Three ray line intersection points.\n        vec2 rd = -rA*normalize(v[i]);\n        float t = rayLine(v[i], rd, v[ip2], rot2(ang)*normalize(v[ip2].yx*vec2(1, -1)));\n        \n        // Start at the vertex positions, then render slightly rotated lines that meet\n        // one another just past the center.\n        vec2 rV0 = v[i] - rA*normalize(v[i])*t;\n        vec2 rV1 = v[ip1] - rA*normalize(v[ip1])*t;\n        vec2 rV2 = v[ip2] - rA*normalize(v[ip2])*t;\n        \n        \n        // Dividing lines.\n        float ln0 = distLineS(p, rV0, v[i]);\n        //float ln1 = distLineS(p, rV1, v[ip1]);\n        float ln2 = distLineS(p, rV2, v[ip2]);\n\n        \n        // Large quads and block tops.\n        quad[i] = max(ln0, -ln2);\n        \n        // Small inner triangle side length.\n        float triL = length(rV0 - rV2);\n \n        \n        // Different dividing lines, quads, etc, for the opposing triangles.\n        if(gTri>0.){ \n    \n            // Random small side length.\n            float smSL = getSize(sL, ctrID + eID[ip2]*2.);\n         \n            // More dividing lines.\n            float lnA = distLineS(p, rV0, rV1);   \n            float lnB = distLineS(p, rV1, rV2); \n            float lnC = distLineS(p, rV2, rV0); \n            \n            // Line between points rV0 and rV1, pushed out by the base height \n            // of the triangle.\n            quad1[i] = max(lnA + (t - smSL - triL)*.8660254, lnB - triL*.8660254);  \n\n            // Chips on the sides.\n            quad2[(i + 1)%3] = max(-lnC + (t - smSL - triL)*.8660254, -(lnB - triL*.8660254)); \n    \n            // Line to split the \"L\" shape into two quads.\n            vec2 sp = rV0 - normalize(rV2 - v[ip2])*(t - triL - smSL);\n            lnDivC[i] = -distLineS(p, sp, sp + rV1 - rV0);\n\n      \n        } \n        else {\n        \n            // Random small side length.\n            float smSL = getSize(sL, ctrID); \n        \n            // Key points.\n            vec2 rVA = rV0 + normalize(v[i] - rV0)*(triL + smSL); \n            vec2 rVB = rVA + normalize(v[ip2] - rV2)*(smSL); \n            vec2 rVC = rVB - normalize(v[i] - rV0)*(triL + smSL); \n            vec2 rVD = rV0 - normalize(v[i] - rV0)*smSL; \n\n        \n            // Various dividing lines -- Used to construct the quads.\n            float lnA = distLineS(p, rV1, rVB);\n            float lnB = distLineS(p, rVB, rVC);\n            float lnC = distLineS(p, rVC, rVD);\n            float lnD = distLineS(p, rVD, rV1);  \n            \n            // Inner quad panel points.\n            quad1[i] = max(max(lnA, lnB), max(lnC, lnD));\n\n            // Line to split the \"L\" shape into two quads.\n            lnDivC[i] = -distLineS(p, rVB, rVB + rV0 - v[i]);\n        \n        }\n        \n    \n    }\n    \n    \n    // Combined quads.\n    float quads = min(min(quad1[0], quad1[1]), quad1[2]);\n    quads = min(quads, min(min(quad2[0], quad2[1]), quad2[2]));\n    quads = min(quads, min(min(quad3[0], quad3[1]), quad3[2]));\n    \n    // More CSG quad construction.\n    for(int i = 0; i<3; i++){         \n         quad3[(i + 1)%3] = max(max(quad[i], -quads), -lnDivC[i]); // Ends.\n         quad[i] = max(quad[i], lnDivC[i]);\n    }\n    \n  \n    // Overall color, shade and random color variables.\n    vec3 col = vec3(.1);\n    vec3 shade = vec3(.9, .6, .3);\n    vec3 c3B[3];\n    \n    #ifdef INNER_EDGES\n    float rmW = sL/32.;\n    #else\n    float rmW = -ew*1.25;\n    #endif\n    \n    // Set block colors.\n    vec3[3] c3 = vec3[3](vec3(1, 1, .5), vec3(.2, .4, 1), vec3(1, .3, .6));\n \n    // Rendering the main quads.\n    for(int i = 0; i<3; i++){\n    \n        // Random block color.\n        vec2 id = gTri<0.? ctrID : ctrID + eID[(i + 2)%3]*2.;\n        // \n        c3B[i] = .5 + .45*cos(6.2831589*hash21(id)/6. + vec3(0, 1, 2)*1.2);\n\n        // Shaded color.\n        vec3 lCol = getCol(c3B[i], c3[i])*shade[i];\n        \n        // Top face.\n        #ifdef AO\n        col = mix(col, col*.5, (1. - smoothstep(0., sf*24.*res/450., quad[i])));\n        #endif\n        #ifdef INNER_EDGES\n        col = mix(col, getEdgeCol(lCol), (1. - smoothstep(0., sf, quad[i] + ew)));\n        col = mix(col, col*.2, (1. - smoothstep(0., sf, quad[i] + rmW + ew)));\n        #endif\n        col = mix(col, lCol, (1. - smoothstep(0., sf, quad[i] + rmW + ew*2.)));\n        \n    }\n    \n    // Rendering the rest of the smaller quads.\n    for(int i = 0; i<3; i++){\n    \n        int ip1 = (i + 1)%3;\n        int ip2 = (i + 2)%3;\n\n        // Shaded color.\n        vec3 lCol = getCol(c3B[i], c3[i])*shade[ip1];\n        \n        // Other faces.\n        #ifdef INNER_EDGES\n        col = mix(col, getEdgeCol(lCol), (1. - smoothstep(0., sf, quad1[i] + ew)));\n        col = mix(col, col*.2, (1. - smoothstep(0., sf, quad1[i] + rmW + ew)));\n        #endif\n        col = mix(col, lCol, (1. - smoothstep(0., sf, quad1[i] + rmW + ew*2.)));\n \n \n        lCol = getCol(c3B[ip2], c3[i])*shade[ip1];\n        #ifdef INNER_EDGES\n        col = mix(col, getEdgeCol(lCol), (1. - smoothstep(0., sf, quad2[i] + ew)));\n        col = mix(col, col*.2, (1. - smoothstep(0., sf, quad2[i] + rmW + ew)));\n        #endif\n        col = mix(col, lCol, (1. - smoothstep(0., sf, quad2[i] + rmW + ew*2.)));\n\n\n        lCol = getCol(c3B[ip2], c3[i])*shade[ip2];\n        #ifdef INNER_EDGES\n        col = mix(col, getEdgeCol(lCol), (1. - smoothstep(0., sf, quad3[i] + ew)));\n        col = mix(col, col*.2, (1. - smoothstep(0., sf, quad3[i] + rmW + ew)));\n        #endif\n        col = mix(col, lCol, (1. - smoothstep(0., sf, quad3[i] + rmW + ew*2.)));\n\n    }\n    \n    \n    \n    // Faux anisotopic effect.\n    //float oShp = min(min(quad[0], quad[1]), quad[2]);\n    //col *= (1. - smoothstep(0., 1., -oShp/sL*8.)) + .65;\n    // Fake ambient occlusion.\n    #ifdef AO\n    col *= (smoothstep(0., .5, length(p)/sL))*.85 + .5;\n    #endif\n    \n    /*\n    // Color gradient.\n    vec2 uv2 = fragCoord/iResolution.xy;\n    uv2 = smoothstep(.2, .8, uv2);\n    col = mix(col.xzy, col, mix(uv2.x, uv2.y, .66)*.7 + .3);\n    */\n    \n    \n    \n    // Display the background grid.\n    #ifdef SHOW_GRID\n    float ln = 1e5;\n    // Lines between vertices.\n    for(int i = 0; i<3; i++){\n         ln = min(ln, distLine(p, v[i], v[(i + 1)%3]));\n         //ln = min(ln, distLine(p, vec2(0), e[i]));\n    }\n\n    vec3 svCol = col;\n    col = mix(col, col*.1, (1. - smoothstep(0., sf, ln - .005)));\n    col = mix(col, svCol + .5, (1. - smoothstep(0., sf, ln - .001)));\n    #endif\n\n    \n    #ifdef PENCIL\n    // Subtle pencel overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    vec2 q = oP*9.;\n    vec3 colP = pencil(col, q*res/450.);\n    col *= colP*1.5 + .5; \n    //col = colP; \n    #endif\n\n    \n    /*\n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n    */\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n    \n}\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./4.5;\n \nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n\n    // Rectangle scale.\n    const vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = vID[2]/3.; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n/*\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat sdEqTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n*/\n\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n\n\n////////////////\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/2.5);\n    // Extra toning.\n    col /= 1./3. + dot(col, vec3(.299, .587, .114));\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns2 = gr - ns2;\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = min(min(ns, ns2), ns3) + .5; // Rough pencil sketch layer.\n    //ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .5); // Same, but with contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(ns);\n    \n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}