{
    "Shader": {
        "info": {
            "date": "1531736913",
            "description": "Trying to do the same effect but with glass rather than chrome; not sure I've got it right really.",
            "flags": 0,
            "hasliked": 0,
            "id": "ll3cR4",
            "likes": 9,
            "name": "Playtracing Glass",
            "published": 3,
            "tags": [
                "raytracing",
                "refraction"
            ],
            "usePreview": 0,
            "username": "_polymath",
            "viewed": 711
        },
        "renderpass": [
            {
                "code": "#define BALLCOUNT 5\n#define EPSILON .001\n#define NBASE 0.93\n#define NDIFF .02\n\nstruct ball {\n\tvec3 position;\n    float radius;\n    float radiusSq;\n};\nball newBall(vec3 pos, float rad) {\n\treturn ball(pos, rad, rad*rad);\n}\n\n// if you want a camera position, subtract it from both inputs\nfloat point2rayDistSq(vec3 p, vec3 ray) {\n    vec3 dd = p - dot(p, ray) / dot(ray, ray) * ray;\n    return dot(dd, dd);\n}\n\nvec4 sky(vec3 ray, vec3 light) {\n    float l = dot(ray, light) * 0.3;\n    return texture(iChannel1, ray) +\n        vec4(l, l, l, 0.0);\n}\n\nvec4 floorColor(vec2 floorUv, ball[BALLCOUNT] balls, float floorH, vec3 light) {\n    vec4 fragColor = texture(iChannel0, floorUv * 0.2)\n        * (pow(length(floorUv), -0.1)) * 1.2;\n    \n    // shadow\n    for (int i = 0; i < BALLCOUNT; ++i)\n    \tif (point2rayDistSq(\n        \tballs[i].position - vec3(floorUv.x, floorH, floorUv.y),\n            light) < balls[i].radiusSq) {\n        return fragColor *= 0.7;\n    }\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float floorH = sin(iTime * 0.32) * 0.4 - 1.;\n    \n    ball[] balls = ball[] (\n        newBall(vec3(\n            sin(iTime * 0.2) + 1.0,\n            cos(iTime * 0.7) + 1.2,\n            sin(iTime * 0.2) + 8.0),\n            cos(iTime * 0.3) * 0.3 + 1.3),\n        newBall(vec3(\n            sin(iTime * 0.4) + 1.0,\n            cos(iTime * 0.5) + 1.2,\n            sin(iTime * 0.6) + 8.0),\n            cos(iTime * 0.5) * 0.3 + 1.3),\n        newBall(vec3(\n            sin(iTime * 0.2) + 1.0,\n            cos(iTime * 0.4) + 1.2,\n            sin(iTime * 0.4) + 8.0),\n            cos(iTime * 0.4) * 0.3 + 1.3),\n        newBall(vec3(\n            sin(iTime * 0.3) + 1.0,\n            cos(iTime * 0.2) + 1.2,\n            sin(iTime * 0.1) + 8.0),\n            cos(iTime * 0.6) * 0.3 + 1.3),\n        newBall(vec3(\n            sin(iTime * 0.45) + 1.0,\n            cos(iTime * 0.7) + 1.2,\n            sin(iTime * 0.3) + 8.0),\n            cos(iTime * 0.7) * 0.3 + 1.3));\n\n    vec3 light = vec3(cos(iTime * 0.5), 1., sin(iTime * 0.5));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.) *2.0 / iResolution.yy;\n    \n    float[] rgb = float[](0.,0.,0.),\n        N = float[](NBASE + NDIFF, NBASE, NBASE - NDIFF);\n    \n    for (int ch = 0; ch < 3; ++ch) {\n        vec3 ray = normalize(vec3(uv, 3.5));\n        vec3 cam = vec3(0.,0.,0.);\n        float rayLeft = 1.;\n        int ballsIn = 0;\n        bool[] inBalls = bool[](false,false,false,false,false);\n\n        while (rayLeft > 0.001) {\n            //balls\n            int bId = -1;\n            bool bIn = false;\n            float minBallDist = 10000000000.0;\n            for (int i = 0; i < BALLCOUNT; ++i) {\n                vec3 b = balls[i].position - cam;\n                float d = point2rayDistSq(b, ray);\n                if (d < balls[i].radiusSq) {\n                    float a = dot(b, ray),\n                        aa = sqrt(1. - d/balls[i].radiusSq),\n                        distanceToBall = a - aa;\n                    if (distanceToBall > 0. && distanceToBall < minBallDist) {\n                        minBallDist = distanceToBall;\n                        bId = i;\n                        bIn = true;\n                    } else {\n                        float distanceToBack = a + aa;\n                        if (distanceToBack > 0. && distanceToBack < minBallDist) {\n                            minBallDist = distanceToBack;\n                            bId = i;\n                            bIn = false;\n                        }\n                    }\n                }\n            }\n            if (bId >= 0) {\n                 vec3 intersection = cam + ray * minBallDist;\n                if (bIn) {\n                    if (!inBalls[bId]) {\n                    ballsIn++;\n                    if (ballsIn == 1) {\n\t\t\t\t\t\tinBalls[bId] = true;\n                        if (intersection.y > floorH) {\n                            vec3 normal = -normalize(intersection - balls[bId].position);\n                            float c = dot(-normal, ray);\n                            vec3 refraction = ray / N[ch] + \n                                normal * (N[ch] * c - sqrt(1. - N[ch]*N[ch]*(1.-c*c)));//, \n                                //reflection = ray - 2. * dot(ray, normal) * normal;\n                            float l = dot(normal, light) * 0.2;\n                            rgb[ch] += l * rayLeft;\n                            ray = refraction;\n                            cam = intersection + ray * EPSILON;\n                            rayLeft *= 0.8;\n                            continue;\n                        } else { cam = intersection + ray * EPSILON; }\n                    }\n                    else { cam = intersection + ray * EPSILON; }\n                    }else { cam = intersection + ray * EPSILON; }\n                } else {\n                    if (inBalls[bId]) {\n                    ballsIn--;\n                    if (ballsIn == 0) {\n                        inBalls[bId] = false;\n                        if (intersection.y > floorH) {\n                            vec3 normal = -normalize(intersection - balls[bId].position);\n                            float c = dot(-normal, ray);\n                            vec3 refraction = ray * N[ch] + normal * (c / N[ch] - sqrt(1. - pow(N[ch],-2.)*(1.-c*c)));\n                            if (dot(refraction, normal) > 0.)\n                                // total internal reflection\n                                refraction = ray - 2. * dot(ray, normal) * normal;\n                            float l = dot(normal, light) * 0.2;\n                            rgb[ch] += l * rayLeft;\n                            ray = refraction;\n                            cam = intersection + ray * EPSILON;\n                            rayLeft *= 0.8;\n                            continue;\n                        }else { cam = intersection + ray * EPSILON; }\n                    }else { cam = intersection + ray * EPSILON; }\n                    }else { cam = intersection + ray * EPSILON; }\n                }\n            }\n\n            if (ray.y > 0.) {\n                // we escaped so we're done here\n                rgb[ch] += sky(ray, light)[ch] * rayLeft;\n                break;\n            }\n\n            // floor\n            vec2 floorUv = cam.xz + ray.xz / ray.y * (floorH - cam.y);\n            rgb[ch] += floorColor(floorUv,\n                 balls, floorH, light)[ch] * rayLeft * 0.7;\n\n            // reflect\n            cam = vec3(floorUv.x, floorH, floorUv.y);\n            ray.y *= -1.;\n            rayLeft *= 0.3;\n        }\n    }\n    \n    fragColor = vec4(rgb[0], rgb[1], rgb[2], 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}