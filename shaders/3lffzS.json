{
    "Shader": {
        "info": {
            "date": "1596981410",
            "description": "humans have flesh\nonions also have flesh\nI thin ¯\\_(ツ)_/¯",
            "flags": 32,
            "hasliked": 0,
            "id": "3lffzS",
            "likes": 18,
            "name": "flesh onoinss",
            "published": 3,
            "tags": [
                "2d",
                "zoom",
                "rainbow"
            ],
            "usePreview": 0,
            "username": "zikbakguru",
            "viewed": 537
        },
        "renderpass": [
            {
                "code": "//#define SHOWMOUSE\n//#define SHOWDITHER\n#define DITHERING\n#define DOWNSCALE\n#define PI 3.14\n\n#define GRID_UV_ZOOM 10.0\n#define GRID_NOISE_ZOOM 2.0\n#define GRID_NUM vec2(8.0)\n#define BLUR_SPREAD 32.0\n#define VIGNETTE\n\n// dithering : colour precision\n#define COL_LEVELS 4.0\n\nfloat sampleDither (vec2 uv, vec2 resolution)\n{\n    vec2 screencoord = (uv * resolution);\n    return texture(iChannel1, fract(screencoord / vec2(8.0))).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenuv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    // downscale the screen\n    #ifdef DOWNSCALE\n    \tvec2 downscaleResolution = floor(iResolution.xy * 0.25);\n    \tvec2 uvScale = downscaleResolution; // vec2(downscaleFactor) / iResolution.xy;\n    \tvec2 uv = floor(screenuv * uvScale) / uvScale;\n    \n    \t#ifdef DITHERING\n    \t\tfloat screenDither = sampleDither(uv, downscaleResolution);\n   \t\t#endif\n   \t#else\n    \tvec2 uv = screenuv;\n    \tfloat screenDither = 0.5;\n    #endif\n    \n    // get screen texture\n    col = texture(iChannel0, uv).rgb;\n    \n    // calculate blur\n    vec3 colblur = vec3(0.0);\n    \n    vec2 PIXEL_SZ = 1.0 / iResolution.xy;\n    const float HALF_ITERATION = 4.0;\n    const float ITERATION_WEIGHT = 0.5 / HALF_ITERATION;\n    const vec2 BLUR_OFF = vec2(BLUR_SPREAD, 0.0);\n    for (float i=-HALF_ITERATION; i<HALF_ITERATION; i+=1.0)\n    {\n        float iterationIndex = i + screenDither;\n        vec2 uvoff = PIXEL_SZ * BLUR_OFF * iterationIndex;\n        vec3 screencolh = texture(iChannel0, uv + uvoff.xy).rgb;\n        vec3 screencolv = texture(iChannel0, uv + uvoff.yx).rgb;\n        \n        colblur += (screencolh + screencolv) * ITERATION_WEIGHT * 0.5;\n    }\n\n    // apply blur as glow\n    const vec2 BLUR_SHARPNESS = vec2(2.0, 4.0);\n    const float BLUR_STRENGTH = 0.85;\n    colblur.r = pow(1.0 - pow(1.0 - colblur.r, BLUR_SHARPNESS.x), BLUR_SHARPNESS.y);\n    colblur.g = pow(1.0 - pow(1.0 - colblur.g, BLUR_SHARPNESS.x), BLUR_SHARPNESS.y);\n    colblur.b = pow(1.0 - pow(1.0 - colblur.b, BLUR_SHARPNESS.x), BLUR_SHARPNESS.y);\n    col += colblur * BLUR_STRENGTH;\n    col = clamp(col, 0.0, 1.0);\n    \n    // Limit colours\n    #ifdef DITHERING\n        const float COL_LEVELS_INV = 1.0 / COL_LEVELS;\n        vec3 colDiv = (floor(col * COL_LEVELS) * COL_LEVELS_INV);\n        vec3 colFrac = fract(col * COL_LEVELS);\n        col = colDiv + floor(max(screenDither - colFrac, 0.0) + 0.5) * COL_LEVELS_INV;\n        col = clamp(col, 0.0, 1.0);\n    #endif\n    \n    // Apply vignette\n    #ifdef VIGNETTE\n    \tconst vec3 vignettetint = vec3(0.2, 0.25, 0.4);\n    \tfloat centerDist = length(0.5 - uv);\n    \t\n    \tcol *= mix(vec3(1.0), vignettetint, smoothstep(0.5, 0.75, centerDist));\n    #endif\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n    \n    #ifdef SHOWDITHER\n    \tfragColor = vec4(vec3(screenDither),1.0);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define SHOWMOUSE\n//#define SHOWDITHER\n#define MOTIONBLUR\n#define PI 3.14\n\n#define GRID_UV_ZOOM 10.0\n#define GRID_NOISE_ZOOM 2.0\n#define GRID_NUM vec2(8.0)\n\n// Noise & rand function from\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n)\n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n////\n\n// HSV to RGB conversion function from\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n////\n\nfloat getGridContent (vec2 p)\n{\n    const float noiseTreshold = 0.4;\n    float val = noise(p * GRID_NOISE_ZOOM);\n    val = clamp(ceil(val - noiseTreshold), 0.0, 1.0);\n    \n   \treturn val;\n}\n\nfloat sampleDither (vec2 uv)\n{\n    vec2 screenuv = uv * iResolution.xy;\n    return texture(iChannel0, fract(screenuv / vec2(8.0))).r;\n}\n\nfloat dither (vec2 uv, float v1, float v2, float treshold)\n{\n    float dither = sampleDither(uv);\n    if (dither < treshold)\n    \treturn v1; //mix(v1, v2, ceil(max(dither - treshold, 0.0)));\n   \treturn v2;\n}\n\nvec3 sampleGrid (vec2 uv)\n{\n    vec3 col = vec3(1.0);\n    \n\t// get grid UV\n    vec2 gridUV = floor(uv * GRID_NUM) / GRID_NUM;\n    vec2 gridLocalUV = fract(uv * GRID_NUM);\n    \n    // get grid contents\n    float grid = getGridContent(gridUV);\n    col = vec3(grid);\n    return col;\n}\n\nvec3 sampleScreen (vec2 uv, float t)\n{\n    vec3 col = vec3(0.0);\n    \n    // aspect ratio/factor\n    vec2 uvAspectFactor = vec2(iResolution.xy / iResolution.x);\n    \n    float time = t * 2.0;\n    float timeInt = floor(time);\n    float timeFrac = fract(time);\n    \n    const float iterations = 7.0;\n    const float iterationsInv = 1.0 / iterations;\n    const vec2 iterationUVOff = vec2(420.0, 512.0);\n    const float iterationZoomStep = (1.0 / iterations) * 2.0;\n    const float iterationHalf = iterations * 0.5;\n    \n    const float animWeight = 8.0;\n    float iterationAnimT = pow(1.0 - pow(1.0 - timeFrac, animWeight), animWeight);\n    float iterationZoom = iterationAnimT;\n    float iterationZoomOff = iterationZoom * iterationZoomStep;\n    float iterationZoomShadeOff = iterationZoom * iterationsInv;\n    \n    for (float i=0.0; i<=iterations; i+=1.0)\n    {\n        float layerTime = time;\n        float layerInterp = i * iterationsInv;\n        float layerInterpZoom = clamp((1.0 - layerInterp) - iterationZoomShadeOff, 0.0, 1.0);\n        \n        float layerNumCentered = i - iterationHalf;\n        float layerZoom = (layerNumCentered * iterationZoomStep + iterationZoomOff);\n        float layerAngle = layerTime * 0.1 + cos(layerTime) * PI * 0.1 * (1.0 + (layerInterpZoom - 0.5));\n        \n        float layerIndexOff = (i - timeInt);\n        \n        vec2 layerGridOff = iterationUVOff * layerIndexOff;\n        vec3 layerTint = hsv2rgb(vec3(layerIndexOff * 0.1, 1.0, 1.0));\n        \n        // transform grid\n        vec2 layerUV = uv;// * uvAspectFactor;\n        layerUV -= 0.5;\n        layerUV *= uvAspectFactor;\n        layerUV *= mat2(cos(layerAngle), -sin(layerAngle),\n                       \tsin(layerAngle), cos(layerAngle));\n        layerUV *= 1.0 / uvAspectFactor;\n            \n        layerUV *= (1.0 + iterationZoomStep - layerZoom);\n        layerUV += 0.5;\n        layerUV *= uvAspectFactor * GRID_UV_ZOOM;\n        layerUV += vec2(layerTime + cos(layerTime * PI * 0.15 + PI) * 4.0, layerTime + sin(layerTime * 0.5 * PI));\n        layerUV += layerGridOff;\n        \n        // visualize grid\n        float layerAlpha = mix(1.0, 1.0 - iterationZoom, max(layerInterp + iterationZoomShadeOff - 1.0, 0.0) / iterationsInv); // (1.0 - (min(layerShadeInterp, 0.0) / iterationsInv));\n        float layerShadeInterp = layerInterpZoom; // clamp((1.0 - layerInterp) - iterationZoomShadeOff, 0.0, 1.0);\n        float layerShade = 1.0 - layerShadeInterp; //(1.0 - abs(layerShadeInterp * 2.0 - 1.0));\n        float layerMask = sampleGrid(layerUV).r;\n        layerTint *= layerShade; //vec3(sin(layerInterp * PI * 2.0 + PI * 0.75), sin(layerInterp + PI * 0.5), sin(layerInterp * PI * 2.0 + PI));\n        \n        col = mix(col, layerTint, layerMask * layerAlpha); // dither(uv, 1.0, 0.0, layerMask * layerAlpha));\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    #ifdef MOTIONBLUR\n    \tfloat screenDither = sampleDither(uv);\n    \tconst float iteration = 4.0;\n    \tconst float iterationInv = 1.0 / (iteration + 1.0);\n    \tconst float motionblurFactor = 0.03;\n    \tfor (float i=0.0; i<=iteration; i+=1.0)\n        {\n            float timeoffset = (i + screenDither) * iterationInv * motionblurFactor;\n            vec3 currentFrame = sampleScreen(uv, iTime - timeoffset);\n        \tcol += currentFrame * iterationInv;\n        }\n    \t// col = sampleScreen(uv, iTime);\n    #else\n    \tcol = sampleScreen(uv, iTime);\n    #endif\n    \n    /*\n\t// fix aspect ratio\n    vec2 uvAspectFactor = vec2(iResolution.xy / iResolution.x);\n    uv *= 1.0;\n    \n    float time = iTime * 2.0;\n    float timeInt = floor(time);\n    float timeFrac = fract(time);\n    \n    const float iterations = 7.0;\n    const float iterationsInv = 1.0 / iterations;\n    const vec2 iterationUVOff = vec2(420.0, 512.0);\n    const float iterationZoomStep = (1.0 / iterations) * 2.0;\n    const float iterationHalf = iterations * 0.5;\n    \n    const float animWeight = 8.0;\n    float iterationAnimT = pow(1.0 - pow(1.0 - timeFrac, animWeight), animWeight);\n    float iterationZoom = iterationAnimT;\n    float iterationZoomOff = iterationZoom * iterationZoomStep;\n    float iterationZoomShadeOff = iterationZoom * iterationsInv;\n    \n    for (float i=0.0; i<=iterations; i+=1.0)\n    {\n        float layerTime = time;\n        float layerInterp = i * iterationsInv;\n        float layerInterpZoom = clamp((1.0 - layerInterp) - iterationZoomShadeOff, 0.0, 1.0);\n        \n        float layerNumCentered = i - iterationHalf;\n        float layerZoom = (layerNumCentered * iterationZoomStep + iterationZoomOff);\n        float layerAngle = layerTime * 0.1 + cos(layerTime) * PI * 0.1 * (1.0 + (layerInterpZoom - 0.5));\n        \n        float layerIndexOff = (i - timeInt);\n        \n        vec2 layerGridOff = iterationUVOff * layerIndexOff;\n        vec3 layerTint = hsv2rgb(vec3(layerIndexOff * 0.1, 1.0, 1.0));\n        \n        // transform grid\n        vec2 layerUV = uv;// * uvAspectFactor;\n        layerUV -= 0.5;\n        layerUV *= uvAspectFactor;\n        layerUV *= mat2(cos(layerAngle), -sin(layerAngle),\n                       \tsin(layerAngle), cos(layerAngle));\n        layerUV *= 1.0 / uvAspectFactor;\n            \n        layerUV *= (1.0 + iterationZoomStep - layerZoom);\n        layerUV += 0.5;\n        layerUV *= uvAspectFactor * GRID_UV_ZOOM;\n        layerUV += vec2(layerTime + cos(layerTime * PI * 0.15 + PI) * 4.0, layerTime + sin(layerTime * 0.5 * PI));\n        layerUV += layerGridOff;\n        \n        // visualize grid\n        float layerAlpha = mix(1.0, 1.0 - iterationZoom, max(layerInterp + iterationZoomShadeOff - 1.0, 0.0) / iterationsInv); // (1.0 - (min(layerShadeInterp, 0.0) / iterationsInv));\n        float layerShadeInterp = layerInterpZoom; // clamp((1.0 - layerInterp) - iterationZoomShadeOff, 0.0, 1.0);\n        float layerShade = 1.0 - layerShadeInterp; //(1.0 - abs(layerShadeInterp * 2.0 - 1.0));\n        float layerMask = sampleGrid(layerUV).r;\n        layerTint *= layerShade; //vec3(sin(layerInterp * PI * 2.0 + PI * 0.75), sin(layerInterp + PI * 0.5), sin(layerInterp * PI * 2.0 + PI));\n        \n        col = mix(col, layerTint, layerMask * layerAlpha); // dither(uv, 1.0, 0.0, layerMask * layerAlpha));\n    }\n\t*/\n    // output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}