{
    "Shader": {
        "info": {
            "date": "1507390101",
            "description": "As seen in our 4k intro \"Quadtripophobia\" by Quadtrip",
            "flags": 0,
            "hasliked": 0,
            "id": "llScR1",
            "likes": 55,
            "name": "Quadtripophobic Tentacle",
            "published": 3,
            "tags": [
                "raymarching",
                "orennayardiffuse"
            ],
            "usePreview": 0,
            "username": "visy",
            "viewed": 3305
        },
        "renderpass": [
            {
                "code": "float NEAR_CLIPPING_PLANE=.005;\nfloat FAR_CLIPPING_PLANE=1000.;\nint NUMBER_OF_MARCH_STEPS=500;\nfloat EPSILON=.1;\nfloat DISTANCE_BIAS=.2;\nfloat t = 0.;\n\nfloat fly = 1.;\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - (s);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid r(inout vec3 pos) {\n    if (pos.z < FAR_CLIPPING_PLANE) {\n        pR(pos.yx,cos(pos.z*.1+pos.z*.1)+t);\n        pR(pos.xy,0.2*sin(pos.z*.2*t*.1));\n    }\n    else pR(pos.yx,cos(pos.z*.1)+t);\n    \n}\n\nvoid r2(inout vec3 pos) {\n   if (pos.z < 2800.+cos(pos.z*2.1+t*5.)*10.) pR(pos.yx,cos(pos.z*cos(t*.002+sin(pos.z*.001+abs(pos.y*.0001)))*.5)+t*.05);\n}\n\nvoid r3(inout vec3 pos) {\n   pR(pos.xy,sin(pos.z*cos(t*.002+sin(pos.z*.001+(pos.z*.01)))*.5)+t*.5);\n}\n\nfloat celli(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\n\nfloat cellTile(in vec3 p){\n    vec4 d; \n    d.x = celli(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = celli(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = celli(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = celli(p - vec3(.2, .82, .64));\n    d.xy = min(d.xz, d.yw);\n    return min(d.x, d.y)*2.66; \n}\n\nfloat hex(vec2 p) {\n    p.x *= 0.57735*2.;\n\tp.y += mod(floor(p.x), 2.)*.5;\n\tp = abs((mod(p, 1.) - .5));\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.) - 1.);\n}\n\nfloat cellTile2(in vec3 p){\n    vec4 d; \n    d.x = celli(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)+hex(p.xy*0.2);\n    d.y = celli(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)+hex(p.yz*0.2);\n    d.z = celli(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)+hex(p.xz*0.2);\n    d.w = celli(p - vec3(.2, .82, .64));\n    d.xy = min(d.xz, d.yw);\n    return min(d.x, d.y)*.5; \n}\nfloat bump(vec3 pos) {\n    float re = 0.;\n\tre += cellTile2(pos*.25) * cellTile2(pos*1.1) * 3. + cellTile2(pos*1.2) * cellTile2(pos*4.4) * .5;\n    return re;\n}\nvec3 hit;\n\nfloat sp(vec3 opos, vec3 pos) {\n\treturn sdSphere(cos(opos*.2),1.1+cos(pos.z*.01+cos(pos.x*1.1)*.1)*.2)*3.91;\n}\n\nvoid rota(inout vec3 pos) {\n    if (fly == 1.) r(pos);\n    if (fly == 0.) r2(pos);\n    if (fly == 2.) r3(pos);\n}\n\nfloat scene1(vec3 pos)\n{\n\trota(pos);\n    float of = .3*sin(pos.z*5.5);\n\treturn sp(pos - vec3(of, -of, cos(pos.z)*.5),pos);\n}\n\nfloat scene2(vec3 pos)\n{\n    vec3 translate = vec3(-0.5*cos(pos.z*.01), -.2*sin(.005*pos.z*cos(pos.z*4.5+pos.z*.5+pos.z*5.)*.1), 0.);\n\trota(pos);\n    hit = pos;\n\treturn sp(pos - translate,pos);\n}\n\nfloat scene(vec3 pos) {\n\treturn min(scene1(pos),scene2(pos));\n}\n\nfloat sceneb(vec3 pos) {\n\treturn min(scene1(pos),scene2(pos))-bump(hit+cos(pos.z*.3)*3.)*1.5;\n}\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    float acc = 0.;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 pos = position + direction * total_distance;\n        float result = scene(pos);\n        acc+=cos(result*1.)*.05;\n\n        if(result < EPSILON)\n        {\n            return vec2(total_distance, acc);\n        }\n        \n        total_distance += result * DISTANCE_BIAS;\n        \n        \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    return vec2(FAR_CLIPPING_PLANE, acc);\n}\n\nvec3 nr(vec3 n) {\n\treturn normalize(n);\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec3 eps = vec3(.3,0.,0.)*EPSILON;\n\tvec3 nor = vec3(\n\t    sceneb(pos+eps.xyy) - sceneb(pos-eps.xyy),\n\t    sceneb(pos+eps.yxy) - sceneb(pos-eps.yxy),\n\t    sceneb(pos+eps.yyx) - sceneb(pos-eps.yyx) );\n\treturn nr(nor);\n}\n\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1., max(NdotL, NdotV), step(0., s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\n  float B = .45 * sigma2 / (sigma2 + .09);\n\n  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;\n}\n\nfloat fader = 1.0;\nfloat fader2 = 1.0;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    // pixel coordinates\n    vec2 uv = (-res + 2.*(fragCoord.xy))/res.y;\n    \n    vec3 direction = nr(vec3(uv, 0.));\n\n    t = iTime+32.;\n    \n    if (fly >= 1.) t-=31.;\n\n    float cz = t*5.9;\n    \n\n    float FOV = t*.1;\n        \n\t    vec3 camera_origin = vec3(0., 1., cz);\n\tvec3 lookAt = vec3(0.,1.,cz+1.);\n    \n    vec3 forward = nr(lookAt-camera_origin);\n    vec3 right = nr(vec3(forward.z, 0., -forward.x ));\n    vec3 up = nr(cross(forward,right));\n\n    \n    vec3 ro = camera_origin;\n    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    vec2 result = raymarch(ro, rd);\n            \n    float fog = pow(1. / (1. + result.x), .2);\n    \n    vec3 icecol = vec3(.6,.6,1.0);\n\tvec3 materialColor = vec3(1.3-result.x*.01*.5,.9-cos(result.x*.1)*.5,1.*.5);\n\n\tmaterialColor -= vec3(.4,4.7,8.0)*(bump(hit)+bump(hit*.2*vec3(1.,1.,4.))*1.5);\n    vec3 intersection = ro + rd*result.x;\n    \n    vec3 nrml = normal(intersection);\n    vec3 light_dir = nr(vec3(sin(result.x*.1),.3,-1.+fly));\n    vec3 ref = reflect( rd, nrml );\n\t\n    if (t > 85.) { materialColor=mix(materialColor,icecol,clamp((t-85.)*0.2,0.,1.8)); }\n\n    float dom = smoothstep( -.1, .9, ref.y);\n    float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);\n\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,.3*fly,.7*fly)-result.y*.05;\n    \n    vec3 light_color = vec3(1.);\n    vec3 ambient_color = light_color;\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    vec3 outColor = diffuseLit*fog+dom*.2+spe*.6;\n\tfragColor = vec4(mix(vec3(diffuse),outColor,fader), 1.)*fader2;\n }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}