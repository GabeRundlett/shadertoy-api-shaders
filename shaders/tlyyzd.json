{
    "Shader": {
        "info": {
            "date": "1611603629",
            "description": "Aliasing- and ringing artifacts free versions of the basic waveform types.\nTheir Fourier coeffcients are computed using two recursive procedures.\n\nThe horizontal mouse position maps to the number of used Fourier coefficients. ",
            "flags": 0,
            "hasliked": 0,
            "id": "tlyyzd",
            "likes": 15,
            "name": "Smooth Waveforms",
            "published": 3,
            "tags": [
                "wave",
                "audio",
                "waveforms",
                "sawtooth"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 707
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nAliasing- and ringing artifacts free versions of the basic waveform types.\nTheir Fourier coeffcients are computed using two recursive procedures.\nEvery additional Fourier coefficient is used to zero out another higher order derivative at x=1/2 and x=3/2;\n\nThe horizontal mouse position maps to the number of used Fourier coefficients n (procedure becomes numerically unstable for n>61).\n\n\nI found these procedure by computing the first few results manually and then staring at them with squinted eyes trying to identify possible relationships.\nThis is basically the same I did when deriving the FlatBand FIR filter ( https://www.shadertoy.com/view/ttfBzj ); just a bit more advanced this time.\n\nMathematica is actually able to reduce SquareWave(x,n) to a closed-form expression.\nIt does, however, turn out as a bit of a not so extraordinarily useful abomination:\n\nsqwave[x_, n_] :=\n    (2^(-3 - 2 n) E^(-2 I (1 + n) \\[Pi] x) Sqrt[\\[Pi]]\n    Gamma[3 + 2 n] (2 n! (E^(I (3 + 4 n) \\[Pi] x)\n    Hypergeometric2F1[-1 - 2 n, -(1/2) - n, 1/2 - n, E^(-2 I \\[Pi] x)] + E^(I \\[Pi] x)\n    Hypergeometric2F1[-1 - 2 n, -(1/2) - n, 1/2 - n, E^(\n    2 I \\[Pi] x)]) - (-1)^n E^(I (1 + 2 n) \\[Pi] x) (1 + 2 n) Sqrt[\\[Pi]] Gamma[2 + 2 n] \n    (HypergeometricPFQRegularized[{1/2, 1, -n}, {3/2, 2 + n},E^(-2 I \\[Pi] x)] + E^(2 I \\[Pi] x)\n    HypergeometricPFQRegularized[{1/2, 1, -n}, {3/2, 2 + n}, E^(2 I \\[Pi] x)])))/(n! Gamma[1/2 - n] Gamma[2 + n] Gamma[2 + 2 n])\n\n\nTODO:\n- find better or exact normalization procedure for SawtoothWave\n- pulse waveform with variable duty cycle\n*/\n\nconst float pi = 3.14159265359;\nconst float pi05 = pi * 0.5;\n\nfloat SquareWave(float x, float n)\n{\n    x = x * pi - pi05;\n    \n    float w = 1.0;\n    \n    for(float i = 0.0; i < n; ++i)\n    {\n        w *= -(i * 2.0 + 1.0) / \n              (i * 8.0 + 8.0);\n    }\n    \n    float a = n * 2.0 + 1.0;\n    float b = n * 2.0 + 2.0;\n    float c = n * 2.0 + 3.0;\n    \n    float f = w * cos(a * x);\n    \n    for(float i = 1.0; i <= n; ++i)\n    {\n        w *= ((i * 2.0 - c) * (i - b)) / \n             ((i * 2.0 - a) *  i     );\n        \n        f += w * cos(((n-i) * 2.0 + 1.0) * x);\n    }\n    \n    return f;\n}\n\n\nfloat TriangleWave(float x, float n)\n{\n    x = x * pi;\n\n    float w = 1.0;\n    \n    for(float i = 0.0; i < n; ++i)\n    {\n        w *= -(i * 2.0 + 1.0) / \n              (i * 8.0 + 8.0);\n    }\n    \n    float a = n * 2.0 + 1.0;\n    float b = n * 2.0 + 2.0;\n    float c = n * 2.0 + 3.0;\n    \n    float f = w * sin(a * x) / a;\n    float h = abs(w) / a;\n    \n    float s = 1.0;\n    for(float i = 1.0; i <= n; ++i, s = -s)\n    {\n        w *= ((i * 2.0 - c) * (i - b)) / \n             ((i * 2.0 - a) *  i     );\n        \n        float k = (n-i) * 2.0 + 1.0;\n        \n        f += w * sin(k * x) / k;\n        h += abs(w) / k;\n    }\n    \n    return f / h;\n}\n\n\nfloat SawtoothWave(float x, float n)\n{\n    float f;\n    {\n        x = x * pi05;\n    \n        float w = 1.0;\n        \n        for(float i = 0.0; i < n; ++i)\n        {\n            w *= -(i * 2.0 + 1.0) / \n                  (i * 8.0 + 8.0);\n        }\n        \n        float a = n * 2.0 + 1.0;\n        float b = n * 2.0 + 2.0;\n        float c = n * 2.0 + 3.0;\n        \n        float square = w * cos(a * x);\n        float tri    = w * sin(a * x) / a;\n        float h      = abs(w) / a;\n        \n        float s = 1.0;\n        for(float i = 1.0; i <= n; ++i, s = -s)\n        {\n            w *= ((i * 2.0 - c) * (i - b)) / \n                 ((i * 2.0 - a) *  i     );\n            \n            float k = (n-i) * 2.0 + 1.0;\n            \n            square += w * cos(k * x);\n            tri    += w * sin(k * x) / k;\n            h      += abs(w) / k;\n        }\n        \n        tri /= h;\n        \n        f = tri * square;\n    }\n    \n  #if 1\n    // empirical normalization\n    float u = 1.0;\n    \n    float b = 1.86;\n    float a = b * 0.798;\n    \n    for(float i = 0.0; i < n; ++i)\n    {\n        u *= (i+a)/(i+b)*0.999;\n    }\n    \n    f /= 1.0-u*0.5;\n  #endif\n  \n    return f;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.y * 0.5;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.5;\n    \n   #if 0\n    tex *= 0.25;\n    tex.x+=0.3;\n    tex.y+=0.8;\n   #endif\n   \n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    float n = floor((1.0-clamp01(iMouse.x/iResolution.x))*60.0);\n\n    //n += 0.3333\n    //n += 0.5;\n    //n += 0.6666;\n\n  #if 0\n    // visualize coefficients\n    {\n        float x = floor((uv0.x/iResolution.x)*16.0);\n    \n        float w = 1.0;\n    \n        for(float i = 0.0; i < n; ++i)\n        {\n            w *= -(i * 2.0 + 1.0) / \n                  (i * 8.0 + 8.0);\n        }\n\n        float a = n * 2.0 + 1.0;\n        float b = n * 2.0 + 2.0;\n        float c = n * 2.0 + 3.0;\n\n        if(x == n)\n        {\n            if(w > uv0.y/iResolution.y*1.25) col *= 0.5;\n        }\n        else    \n        for(float i = 1.0; i <= n; ++i)\n        {\n            w *= ((i * 2.0 - c) * (i - b)) / \n                 ((i * 2.0 - a) *  i     );\n                 \n            if((n-i) == x)\n            {\n                if(abs(w) > uv0.y/iResolution.y*1.25) col *= 0.5;\n                \n                break;\n            }\n        }\n    }\n  #endif\n  \n    col = mix(col, vec3(0.0, 0.5  , 1.0  ), Graph(  SquareWave(tex.x, n) - tex.y, 1.0)*0.925);\n    col = mix(col, vec3(0.0, 0.8  , 0.125), Graph(TriangleWave(tex.x, n) - tex.y, 1.0)*0.925);\n    col = mix(col, vec3(1.0, 0.125, 0.0  ), Graph(SawtoothWave(tex.x, n) - tex.y, 1.0)*0.925);\n    \n  #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n  #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}