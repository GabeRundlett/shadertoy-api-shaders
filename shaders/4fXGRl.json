{
    "Shader": {
        "info": {
            "date": "1703924837",
            "description": "Ray tracing code",
            "flags": 0,
            "hasliked": 0,
            "id": "4fXGRl",
            "likes": 0,
            "name": "Ray Tracing 3",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "Andreuicncuza",
            "viewed": 121
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n#define NUM_OF_SPHERES 4\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct Material {\n    vec3 albedo;\n    float persistence;\n    bool diffuse;\n    float fuzzines;\n};\n\nstruct Sphere {\n    vec3 c;\n    float r;\n    Material mat;\n};\n\nstruct Record { \n    vec3 p;\n    float t;\n    vec3 n;\n    Material mat;\n    bool didHit;\n};\n\nvec2 randState;\n\nfloat hash( const float n ) \n{\n     return fract(sin(n)*43758.54554213);\n}\n\n\nfloat rand2D()\n{\n    randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    return randState.x;\n}\n\n\n// random direction in unit sphere (for lambert brdf)\nvec3 random_in_unit_sphere()\n{\n    float phi = 2.0 * PI * rand2D();\n    float cosTheta = 2.0 * rand2D() - 1.0;\n    float u = rand2D();\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nvec3 random_in_hemisphere(vec3 normal)\n{\n    vec3 rand = random_in_unit_sphere();\n    if (dot(normal, rand) < 0.0)\n        return -rand;\n    return rand;\n}\n\n\nSphere SPHERES[] = Sphere[NUM_OF_SPHERES](\n    Sphere(\n        vec3(2.5,-7.5,-15.),\n        7.,\n        Material(vec3(0.9,.2,.2), 0.9, false, .9)  \n    ),\n    Sphere(\n        vec3(.0,-6.,5.),\n        4.,\n        Material(vec3(.2,.2,.9), 0.9, false, .1)  \n    ),\n    Sphere(\n        vec3(0,-5.5,-3),\n        5.,\n        Material(vec3(0.2,0.2,.2)*5.0, 0.8, true,1.12)  \n    ),\n    Sphere(\n        vec3(0,-15.25,-3),\n        2.5,\n        Material(vec3(0.2,0.8,.9)*5.0, 0.8, true, 1.)  \n    )\n);\n\nRecord hit(Ray r, Sphere s){\n    Record info;\n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc, oc) - s.r * s.r;\n\n    float disc = b*b - a * c;\n\n    if (disc > 0.0){\n        float t = (-b - sqrt(disc)) / a;\n        vec3 p = r.o + r.d * t;\n        info.didHit = true;\n        info.t = t;\n        info.n = (p - s.c) / s.r;\n        info.p = p;\n        info.mat = s.mat;\n        return info;\n    }\n\n    info.didHit = false;\n    return info;\n}\n\nRecord hit_world(Ray r){\n    Record info;\n    info.t = 99999999.0;\n\n    for (int i = 0; i < NUM_OF_SPHERES; i++){\n        Sphere s = SPHERES[i];\n        Record tempinfo = hit(r, s);\n        if (tempinfo.didHit && tempinfo.t < info.t && tempinfo.t > 0.0){\n            info = tempinfo;\n        }\n    }\n\n    return info;\n}\n\nRay calculateRay(vec3 lookTo, vec3 CameraOrigin, vec2 ScaledDown){\n    vec3 forwad = normalize(lookTo - CameraOrigin);\n    vec3 right = normalize(cross(forwad, vec3(0, 1,0)));\n    vec3 up = normalize(cross(forwad, right));\n    vec3 direction = forwad + right * (ScaledDown.x+rand2D()*0.003) + up * (ScaledDown.y + rand2D()*0.003);\n    return Ray(CameraOrigin, direction * 3. ); \n}\n\nvec3 background(Ray r){\n    return vec3(.7);\n}\n\nvec3 rayColor(Ray r){\n    vec3 col = vec3(1);\n    Record info;\n    bool didHit = false;\n    for (int i = 0; i <= 20; i++){\n        info = hit_world(r);\n        if (info.didHit){\n            didHit= true;\n            r.o = info.p;\n            if (info.mat.diffuse){\n                r.d = info.n + random_in_unit_sphere() * info.mat.fuzzines;\n                col *= info.mat.persistence * info.mat.albedo;\n            }\n            else{\n                r.d = reflect(r.d,info.n) + random_in_unit_sphere() * info.mat.fuzzines;\n                col *= info.mat.albedo;\n                }\n        }else{\n            col *= background(r);\n            break;\n        }\n    }\n    \n    if ( r.o.y <= 0. && r.d.y > 0.){\n        float t = -r.o.y / r.d.y;\n        vec3 p = r.o + r.d * t;\n        p/= 5.0;\n        int p_int_x = int(round(p.x));\n        int p_int_y = int(round(p.z));\n        if ((p_int_x+p_int_y)%2==0){\n            col *= vec3(.1, .6, 0.1);\n        }\n        col *= vec3(.4, 0.5, 0.4);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    randState = fragCoord.xy / iResolution.xy;\n    vec2 uv = randState - 0.5;\n    vec2 ScaledDown = iResolution.xy / 400.0 * uv;\n\n    Ray r = calculateRay(\n        vec3(0,-5.5,-7.3),\n        vec3(sin(iTime/2.), -.55 * (sin(iTime)+1.2), cos(iTime/2.)) * 25.,\n        ScaledDown\n    );\n\n    vec3 color = vec3(0,0,0);\n   \n    int resolution = 35;\n    for (int x = 0; x < resolution; x++){\n            Ray clone = r;\n            clone.d += random_in_unit_sphere() * 0.008;\n            color += rayColor(clone);\n    }\n    \n    color /= float(resolution);\n    color *= color * 2.5;\n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}