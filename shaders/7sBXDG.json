{
    "Shader": {
        "info": {
            "date": "1620910105",
            "description": "https://mathworld.wolfram.com/FourierSeriesSquareWave.html",
            "flags": 0,
            "hasliked": 0,
            "id": "7sBXDG",
            "likes": 3,
            "name": "fourier approximate square wave",
            "published": 3,
            "tags": [
                "wave",
                "approximation",
                "square",
                "analog",
                "fourier"
            ],
            "usePreview": 0,
            "username": "hornet",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "//#define ANIMATE\n\n//note: [-4.0/PI;4.0/PI]\nfloat sq_approx( float t )\n{    \n    const float PI = 3.1415926536;\n    const int NUM_ITERATIONS = 7;\n    const float T = 0.5;\n    \n    float sum_sin = 0.0;\n    for (int i=1; i<2*NUM_ITERATIONS; i+=2 )\n    {\n        sum_sin += sin( (2.0*PI*float(i)*t) / T ) / float(i);\n    }\n    sum_sin *= 4.0 / PI;\n    return sum_sin;\n}\n\n//note: [0;1]\nfloat sq_approx_norm( float t )\n{\n    const float PI = 3.1415926536;\n    return 0.5 + 0.5 * sq_approx(t) * PI / 4.0;\n}\n\n\n// ======================================\n\nfloat f( float v )\n{\n    //return sq_approx(v);\n    return sq_approx_norm(v);\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab=b-a,ap=p-a;\n    return length(ap-ab*clamp(dot(ab,ap)/dot(ab,ab), 0.0, 1.0));\n}\nfloat eval_dist( vec2 uv )\n{\n    //note: evaluate function at pixel-edges\n    //      +-------+\n\t//      |       |\n\t//      x0  x  x1\n\t//      |       |\n\t//      +-------+\n    float dx = 0.5 * dFdx( uv.x );\n    float x0 = uv.x - dx;\n    float x1 = uv.x + dx;\n    float y0 = f( x0 );\n    float y1 = f( x1 );\n\n    //note: calculate distance to line-segment (x0,y0)<->(x1,y1)\n    //      +-------+\n\t//      |    /-x1\n    //      |  -x   |\n\t//     x0-/     |\n\t//      +-------+\n    float d = sd_segment( uv, vec2(x0,y0), vec2(x1,y1) );\n    return smoothstep( dFdy(uv.y), 0.0, d );\n}\n\n\n// ======================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n \n    #if defined( ANIMATE )\n    ssuv.x += 0.125*sin(iTime);\n    #endif //ANIMATE\n \n    vec2 luv = vec2( 2.0 * ssuv.x-1.0, 5.0*ssuv.y - 1.25 );\n   \n    float v = f( luv.x );\n    float g = eval_dist( luv );\n    \n    if ( ssuv.y < 0.5 )\n    {\n        fragColor = vec4( vec3(g), 1.0 );\n        if ( abs(luv.y-1.0) < dFdy(luv.y) ) fragColor.rgb += 0.5;\n        if ( abs(luv.y-0.0) < dFdy(luv.y) ) fragColor.rgb += 0.5;\n        if ( abs(luv.y+1.0) < dFdy(luv.y) ) fragColor.rgb += 0.5;    \n        if ( abs(luv.x+0.0) < dFdx(luv.x) ) fragColor.rgb += 0.5;\n    }\n    else\n        fragColor = vec4( vec3(v), 1.0 );\n            \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.4) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}