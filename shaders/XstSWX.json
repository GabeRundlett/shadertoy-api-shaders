{
    "Shader": {
        "info": {
            "date": "1461827980",
            "description": "A cheap and relatively effective denoising/smoothing technique that preserves hard edges.",
            "flags": 32,
            "hasliked": 0,
            "id": "XstSWX",
            "likes": 27,
            "name": "Adaptive Manifold Denoise",
            "published": 3,
            "tags": [
                "denoise",
                "adaptive",
                "manifold",
                "denoising"
            ],
            "usePreview": 1,
            "username": "cornusammonis",
            "viewed": 2469
        },
        "renderpass": [
            {
                "code": "/*\n\tAdaptive Manifold Denoise\n\n\tLoosely based on this approach: http://inf.ufrgs.br/~eslgastal/AdaptiveManifolds/\n\n\tComputes three filters: a standard gaussian blur, a max filter, and a min filter.\n\tThe max and min filters are computed using normalized convolution on color values\n    greater than or less than the gaussian blur value (respectively). The three filtered\n\timages are blended together using normalized convolution, with weights determined\n    by the distance between the color values in the original image and the color values\n    in each of the filtered images.\n\n\tThe noise level and the gaussian width in the final blending pass are animated to\n    demonstrate the use of this filter for both smoothing and denoising.\n*/\n\n#define STDEV 0.2\t// max gaussian width\n\nvec4 gaussian(vec4 x, vec4 m, float s) {\n    return exp(-(x-m)*(x-m)/(s*s));\n}\n\nvec4 sigmoid(vec4 x, float k) {\n\treturn 1.0 / (1.0 + exp(-k*(x-0.5)));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    bool ypass = mod(float(iFrame), 2.0) >= 1.0;\n    if (ypass) {\n        vec4 smax = texture(iChannel1, uv);\n        vec4 smin = texture(iChannel2, uv);\n        vec4 savg = texture(iChannel0, uv);\n        vec4 nois = texture(iChannel3, uv);\n        \n        // the gaussian width is animated in sync with the noise amount. \n        // generally a larger width is better for noisier data\n        \n        float t = sin(float(iFrame)/40.0);\n        float s = STDEV * (t + 1.3);\n        \n        vec4 gmax = gaussian(smax, nois, s);\n        vec4 gmin = gaussian(smin, nois, s);\n        vec4 gavg = gaussian(savg, nois, s);\n        vec4 gsum = gmax + gmin + gavg;\n        gmax /= gsum;\n        gmin /= gsum;\n        gavg /= gsum;\n        vec4 gres = gmax * smax + gmin * smin + gavg * savg;\n        \n        \n\t\t#define STR 10.0\n        vec4 fmin = sigmoid((savg - smin)/(smax - smin), STR);\n        vec4 fmax = sigmoid((smax - savg)/(smax - smin), STR);\n        vec4 sres = 0.5 * (mix(smin, smax, fmin) + mix(smax, smin, fmax));\n        \n        vec4 res = gres;//mix(gres, savg, 2.0 * (smax - smin));\n    \n        //fragColor = smin;\n\t\t\n        if (uv.x > 0.5) {\n            fragColor = res;\n        } else {\n            fragColor = nois;\n        }\n\t\t\n\n    } else {\n        // discard every other frame, because the buffers haven't completed both blur passes\n        discard;\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tStandard 2-pass gaussian blur\n*/\n\n#define GX texture(iChannel0, uv + i * step)\n#define GY texture(iChannel1, uv + i * step)\n\n#define STDEV 6.5\n#define RADIUS 12.0\n\n#define GAMMA vec4(2.2)\n\nfloat gaussian(float x) {\n    return exp(-x*x/(STDEV*STDEV));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 ix = vec2(1.0 / iResolution.x, 0.0);\n    vec2 iy = vec2(0.0, 1.0 / iResolution.y);\n    \n    bool xpass = mod(float(iFrame), 2.0) < 1.0;\n    vec2 step = xpass ? ix : iy;\n    \n    vec4 sum = vec4(0.0);\n    vec4 denom = vec4(0.0);\n    \n    #define ZERO vec4(0.0)\n    \n    for (float i = -RADIUS; i <= RADIUS; i += 1.0) {\n        float g = gaussian(i);\n        sum += g * pow(xpass ? GX : GY, GAMMA);\n        denom += g;\n    }\n\n    sum /= denom;\n    \n    fragColor = pow(sum, 1.0 / GAMMA);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\tMax buffer, computes a normalized convolution of color channel values\n    greater than the corresponding gaussian-blurred color channel value.\n*/\n\n#define GX texture(iChannel0, uv + i * step)\n#define GY texture(iChannel1, uv + i * step)\n\n#define STDEV 6.5\n#define RADIUS 12.0\n\n#define GAMMA vec4(1.0)\n#define ZERO vec4(0.0)\n\nfloat gaussian(float x) {\n    return exp(-x*x/(STDEV*STDEV));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 ix = vec2(1.0 / iResolution.x, 0.0);\n    vec2 iy = vec2(0.0, 1.0 / iResolution.y);\n\n    bool xpass = mod(float(iFrame), 2.0) < 1.0;\n    \n    vec2 step = xpass ? ix : iy;\n\n    vec4 maxG = vec4(0.0);\n    vec4 denomMax = vec4(0.0);\n    \n    vec4 mid = texture(iChannel0, uv);\n\n    for (float i = -RADIUS; i <= RADIUS; i += 1.0) {\n        vec4 g = vec4(gaussian(i));\n        vec4 s = pow(texture(iChannel2, uv + i * step), GAMMA);\n        vec4 v = pow(xpass ? GX : GY, GAMMA);\n        \n        vec4 gt = xpass ? vec4(length(v) >= length(s) ? 1 : 0) : vec4(1);\n        maxG += mix(ZERO, g*v, gt);\n        denomMax += mix(ZERO, g, gt);\t\n\t\t\n        \n        //maxG += g*max(v,s);\n        //denomMax += g;\n    }\n    \n    vec4 sg = pow(texture(iChannel2, uv), GAMMA);\n    \n    vec4 maxNorm = maxG / denomMax;\n    maxG = pow(maxNorm, 1.0 / GAMMA);\n    fragColor = clamp(maxG, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\tMin buffer, computes a normalized convolution of color channel values\n    less than the corresponding gaussian-blurred color channel value.\n*/\n\n#define GX texture(iChannel0, uv + i * step)\n#define GY texture(iChannel1, uv + i * step)\n\n#define STDEV 6.5\n#define RADIUS 12.0\n\n#define GAMMA vec4(1.0)\n#define ZERO vec4(0.0)\n\nfloat gaussian(float x) {\n    return exp(-x*x/(STDEV*STDEV));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 ix = vec2(1.0 / iResolution.x, 0.0);\n    vec2 iy = vec2(0.0, 1.0 / iResolution.y);\n\n    bool xpass = mod(float(iFrame), 2.0) < 1.0;\n    \n    vec2 step = xpass ? ix : iy;\n\n    vec4 minG = vec4(0.0);\n    vec4 denomMin = vec4(0.0);\n    \n    vec4 mid = texture(iChannel0, uv);\n    \n    for (float i = -RADIUS; i <= RADIUS; i += 1.0) {\n        vec4 g = vec4(gaussian(i));\n        vec4 s = pow(texture(iChannel2, uv + i * step), GAMMA);\n        vec4 v = pow(xpass ? GX : GY, GAMMA);\n       \t\n        vec4 lt = xpass ? vec4(length(v) <= length(s) ? 1 : 0) : vec4(1);\n        minG += mix(ZERO, g*v, lt);\n        denomMin += mix(ZERO, g, lt);\t\n\t\t\n        \n        //minG += g*min(v,s);\n        //denomMin += g;\n    }\n    \n    vec4 sg = pow(texture(iChannel2, uv), GAMMA);\n    \n    vec4 minNorm = minG / denomMin;\n    minG = pow(min(minNorm, sg), 1.0 / GAMMA);\n    fragColor = clamp(minG, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\tAdds some gaussian white noise to the source texture.\n*/\n\n// max noise amount\n#define NOISE_AMOUNT 1.0\n\n// uncomment to use RGB colored noise\n//#define COLORED_NOISE\n\nfloat rand(vec2 u){\n    return fract(sin(dot(u.xy ,vec2(12.9898,78.233))) * 43758.5453) - 0.5;\n}\n\nfloat gr(vec2 u){\n\tfloat r0 = rand(u);\n    float r1 = rand(u + r0);\n    float r2 = rand(u + r0 + r1);\n    float r3 = rand(u + r0 + r1 + r2);\n    float r4 = rand(u + r0 + r1 + r2 + r3);\n    return (r0 + r1 + r2 + r3 + r4) / 5.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 orig = texture(iChannel0, uv);\n    \n    // animate the noise amount. this is synchronized \n    // to the gaussian width in the Image buffer\n    float t = sin(float(iFrame)/40.0) + 1.0;\n    vec4 noise = vec4(0.0);\n    #ifdef COLORED_NOISE\n    \tnoise = vec4(gr(uv), gr(uv + 0.1), gr(uv + 0.2), gr(uv + 0.3));\n    #else\n    \tnoise = vec4(gr(uv));\n    #endif\n\n    vec4 noisy = clamp(orig + t * NOISE_AMOUNT * noise, 0.0, 1.0);\n\tfragColor = noisy;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}