{
    "Shader": {
        "info": {
            "date": "1558075372",
            "description": "Using rotations that retain the minkowski length on bulbs. Just Chebyshev and Manhattan distance.",
            "flags": 32,
            "hasliked": 0,
            "id": "WlsGDl",
            "likes": 11,
            "name": "BoxBulb Fractal Slideshow",
            "published": 3,
            "tags": [
                "rotations",
                "minkowski"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 659
        },
        "renderpass": [
            {
                "code": "//while I wait for iq to develope super elliptic rotations\n//here are some simpler \"minkowski rotations\" rotations that\n//retain the minkowski distance pow(pow(abs(x),n)+pow(abs(y),n),1/n)\n//only power 1 Manhattan Distance and power inf Chebshev Distance\n//are implemented here on the Mandelbulb formula.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float flip(float time, float frame)\n{\n    return min(time/7.0,0.01*frame);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define rez iResolution\n#define TAU 6.283\n#define maxDepth 10.0\n//trying to mimick a packet of photons\nconst float fov = 2.5,blurAmount = 0.007;\nconst int RaySteps=128, maxBounces=16;\nconst float FudgeFactor=0.9;\nconst vec3 ior=vec3(1.0,1.33,1.0/1.33);//water=1.33,glass=1.52,diamond=2.42\n\nstruct material {vec3 color;float refrRefl,difExp,spec,specExp;};\n\n//rotations that retain the minkowski distance\nfloat Pi,Pwr;//just 1 and inf for now\nfloat t_atan(float y, float x){//atan is always complicated by the quadrant (probably a simpler way to write these)  \n float a=x-y,b=x+y,res;   \n if(b==0.0)return (a>0.0?7.0:3.0);  \n float d=a/b;\n if(abs(d)<1.0){  \n  if(b>0.0)res=1.0-d;  \n  else res=5.0-d;  \n }else {\n  d=b/a;  \n  if(a>0.0)res=7.0+d;  \n  else res=3.0+d;  \n }  \n return res*0.25*Pi;  \n}  \nfloat c_atan(float y, float x){  \n if(y==0.0)return (x>0.0?0.0:4.0);  \n float a=x/y;  \n if(abs(a)<1.0){  \n  if(y>0.0)return 2.0-a;  \n  else return 6.0-a;  \n }else {  \n  a=y/x;  \n  if(x>0.0)return mod(a,8.0);  \n  else return 4.0+a;  \n }  \n}\nfloat Cos(float a){\n  if(Pwr<2.0)return 2.0*abs(mod(a,2.0*Pi)-Pi)/Pi-1.0;\n  return clamp(abs(mod(a,2.0*Pi)-Pi)-Pi/2.0,-1.0,1.0);\n}\nfloat Atan(float y, float x){if(Pwr<2.0)return t_atan(y,x);return c_atan(y,x);}\nfloat Length(vec2 p){p=abs(p);if(Pwr<2.0)return p.x+p.y;return max(p.x,p.y);}\nfloat Length(vec3 p){p=abs(p);if(Pwr<2.0)return p.x+p.y+p.z;return max(p.x,max(p.y,p.z));}\nvoid SetPwr(float pwr){if(pwr<2.0){Pwr=1.0;Pi=2.0*sqrt(2.0);}else{Pwr=1000.0;Pi=4.0;}}  \nfloat Sin(float a){return Cos(a-Pi/2.0);}\n\nvec4 orbitTrap;vec3 config;  \nfloat DE(vec3 z0){//mandelBulb by twinbee with minkowski distance \n   vec4 c = vec4(z0,1.0),z = c; \n   float r = Length(z.xyz),zo,zi,r0=r,k=config.y; \n   for (int n = 0; n < 5; n++) {\n      if(r>2.0 || float(n)>=config.x)break;\n      zo = Atan(z.z, Length(z.xy)) * k;\n      zi = Atan(z.y, z.x) * k;\n      z=pow(r, k-1.0)*vec4(r*vec3(Cos(zo)*vec2(Cos(zi),Sin(zi)),Sin(zo)),z.w*k)+c; \n      r = Length(z.xyz);\n   }\n   orbitTrap=z;\n   return 0.5*log(r) * r / z.w; \n}\n\nmaterial getMaterial( in vec3 p, in vec3 nor )\n{//return material properties\n //if(obj==1)return material(vec3(0.5),0.01,64.0,1.0,pow(2.,64.));//sin(orbitTrap.w)\n return material(vec3(0.75)+sin(-orbitTrap.rgb*10.0)*0.25,config.z,pow(2.,6.0),1.0,pow(2.,10.0));\n}\n\nvec3 getBackground( in vec3 rd ){\n// return texture(tex,rd).rgb+sunColor*pow(max(0.0,dot(rd,sunDir)),80.0)*8.0;\n vec3 sunDir=normalize(vec3(0.1,0.9,-0.7)), sunColor=vec3(1.0,0.9,0.6);\n return rd*0.1+sunColor*(pow(max(0.0,dot(rd,sunDir)),1.0)+pow(abs(dot(rd,sunDir)),80.0))*1.8;\n}\n\n//random seed and generator\nvec2 randv2;\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 4375.5453),\n  fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 2342.631));\n}\n \nvec3 powDir(vec3 nor, vec3  dir, float power) \n{//creates a biased random sample without penetrating the surface\n float ddn=max(0.01,abs(dot(dir,nor)));\n vec2 r=rand2()*vec2(TAU,1.0);\n vec3 nr=(ddn<0.99)?nor:((abs(nor.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0));\n vec3 sdir=normalize(cross(dir,nr));\n r.y=pow(r.y,1.0/power);\n vec3 ro= normalize(sqrt(1.0-r.y*r.y)*(cos(r.x)*sdir + sin(r.x)*cross(dir,sdir)*ddn) + r.y*dir);\n return (dot(ro,nor)<0.0)?reflect(ro,nor):ro;\n}\n\nvec3 scene(vec3 ro, vec3 rd) \n{// find color and depth of scene\n vec3 fcol=vec3(1.0);//color frequency mask\n vec2 rnd=rand2();//a couple random numbers\n float HitDistance=1.0/rez.x;\n float d,t=rnd.x*HitDistance*10.0,side=sign(DE(ro+t*rd));//dist to obj, total ray len, len to first obj, -inside or +outside of obj\n int iHitCount=0;\n for(int i=0; i<RaySteps; i++ ){// march loop\n  t+=d=DE(ro+t*rd)*side*FudgeFactor;//march\n  if(abs(d)<HitDistance*t){//hit\n   t+=d=DE(ro+t*rd)*side;//move close to the hit point without fudging\n   ro+=rd*t;// advance ray position to hit point\n   vec2 ve=vec2(HitDistance*0.1,0.0);\n   vec3 nor = side*normalize(vec3(-DE(ro-ve.xyy)+DE(ro+ve.xyy),\n    -DE(ro-ve.yxy)+DE(ro+ve.yxy),\n    -DE(ro-ve.yyx)+DE(ro+ve.yyx)));// get the surface normal\n   if(nor!=nor)nor=-rd;\n   material m=getMaterial( ro, nor );//and material\n   rnd=rand2();//a couple more random numbers\n   vec3 refl=reflect(rd,nor),newRay=refl;//setting up for a new ray direction and defaulting to a reflection\n   if(m.refrRefl<0.0){//if the material refracts use the fresnel eq. to determine refr vs refl\n    vec3 refr=refract(rd,nor,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n    vec2 ca=vec2(dot(nor,rd),dot(nor,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n    if(rnd.y+rnd.x>pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)){newRay=refr;nor=-nor;}\n   }\n   rd=powDir(nor,newRay,m.difExp);//redirect the ray\n   //the next line calcs the amount of energy left in the ray based on how it bounced (diffuse vs specular) \n   fcol*=mix(m.color,vec3(1.0),min(pow(max(0.0,dot(rd,refl)),m.specExp)*m.spec+abs(m.refrRefl),1.0));\n   t=max(d*side*5.0,HitDistance);//hopefully pushs thru the surface\n   if(iHitCount++>maxBounces || dot(fcol,fcol)<0.01 || t>maxDepth)break;\n   side=sign(DE(ro+t*rd));//keep track of which side you are on\n  }\n }\n return clamp(fcol*getBackground(rd),0.0,1.0);//light the scene\n} \nmat3 lookat(vec3 fw){\n  fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw); \n}\nvoid Setup(float t, out vec3 eye, out vec3 tgt){t=floor(t);\n  if(t<1.0){SetPwr(1.0);eye=vec3(.22,.84,.22);tgt=vec3(.0,.87,.02);config=vec3(5.,7.,0.2);}\n  else if(t<2.0){SetPwr(10.0);eye=vec3(.54,1.58,.5);tgt=vec3(.21,1,.25);config=vec3(3.,9.,0.3);}\n  else if(t<3.0){SetPwr(10.0);eye=vec3(1.4,.16,.26);tgt=vec3(.6,.97,.04);config=vec3(3.,4.,-0.4);}\n  else if(t<4.0){SetPwr(1.0);eye=vec3(.56,.4,.44);tgt=vec3(.33,.46,.09);config=vec3(2.,24.,0.0);}\n  else if(t<5.0){SetPwr(10.0);eye=vec3(1.25);tgt=vec3(.5);config=vec3(2.,9.,0);}\n  else if(t<6.0){SetPwr(1.0);eye=vec3(.75);tgt=vec3(.4);config=vec3(2.,9.,0);}\n  else {SetPwr(10.0);eye=vec3(vec2(1)-fract(vec2(sin(t),sin(t+2.0))*431.456)*2.0,-2.0);float d=DE(eye);\n   tgt=normalize(eye)*d*0.6;eye-=tgt;tgt=eye-tgt;config=vec3(mod(t,3.0)<1.0?2.:4.,9.,mod(t,3.0)<1.0?-0.3:0.3);}\n} \nvoid mainImage(out vec4 O, in vec2 U) {\n randv2=fract(cos(U.xy+U.yx*vec2(113.0,107.0)+vec2(iTime+float(iFrame)*0.1))*4231.8413);\n vec3 eye,tgt;\n float t=flip(iTime,float(iFrame));if(fract(t)<0.05){O=vec4(0);return;}\n Setup(t,eye,tgt);tgt-=eye;\n float focusDistance=length(tgt);\n mat3 looky=lookat(tgt);\n vec2 pxl=(-rez.xy+2.0*(U.xy+rand2()))/rez.y;\n vec3 er = normalize( vec3( pxl.xy, fov ) );\n vec3 go = blurAmount*focusDistance*vec3( -1.0 + 2.0*rand2(), 0.0 );\n vec3 gd = normalize( er*focusDistance - go );gd.z=0.0;\n O=texture(iChannel0,U/rez.xy)*0.98+vec4(scene(eye+looky*go,looky*normalize(er+gd)),1.0)*0.02;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    float t=flip(iTime,float(iFrame));\n    fragColor = (fract(t)>0.5 || t<=0.5)?texture(iChannel0,uv):texture(iChannel1,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}