{
    "Shader": {
        "info": {
            "date": "1623960949",
            "description": "A new raymarching spherical harmonics viewer for all functions up to l~30 with |m|<17. Select the spherical harmonic you want using your mouse. Only a few are available with the mouse selection directly, others need to be selected in the code.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlS3Dw",
            "likes": 16,
            "name": "Spherical Harmonics Viewer",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "physics"
            ],
            "usePreview": 0,
            "username": "weasel",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(1.0-x*x, float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n/*** Now the rendering ***/\n\nfloat map(float t, float a, float b, float A, float B) {\n    if (A - B == 0. || a - b == 0.)\n        return (A+B)*0.5;\n    return A + (t - a) * (B - A) / (b - a);\n}\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\nvec3 rotateZ(vec3 pos, float angle) {\n    return vec3(cmul(pos.xy, cexp(vec2(0.,-angle))), pos.z);\n}\n\nfloat sphereSdf(vec3 pos, float r) {\n    return length(pos)-r;\n}\n\n#define SELECT_GRID 7.0\nvoid get_lm(out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t = int(iTime);\n    \n    if (mouse.x + mouse.y > 0.0) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        l = cell.x;\n        m = cell.y;\n        return;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = int(floor(float(t) - 0.5*float(l + l*l)));\n}\n\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    // get spherical coordinates\n    float sin_theta = length(pos.xy);\n    float ball_phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float ball_theta = atan(sin_theta, pos.z);\n\n    int m, l;\n    get_lm(l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    float off = m == 0 ? 0.0 : iTime/float(m);\n    vec2 sph_harm = sphere_harm(ball_theta, ball_phi + off, l, m);\n\n    // normalization for visual purposes\n    sph_harm *= SQRT2PI;\n    float occ = abs(sph_harm.x);\n    \n    float crit = float(1+max(abs(m), l-abs(m)));\n    float crit2 = 1.0 / (3.0 + crit);\n    float max_abs_sd = (length(pos)+0.01)*PI*2.0/crit;\n    \n    float sdx = sphereSdf(pos, max(sph_harm.x, 0.))*crit2;\n    float sdy = sphereSdf(pos, -min(sph_harm.x, 0.))*crit2;\n    color = vec3(float(sdx < sdy),occ,0);\n    float sd = min(sdx, sdy);\n    return min(max_abs_sd, abs(sd)) * sign(sd);\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), color.r );\n\n    float occ = min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = 0.0;//pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/2.1;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}