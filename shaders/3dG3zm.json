{
    "Shader": {
        "info": {
            "date": "1569915866",
            "description": "Digital differential analyzer (DDA) Raycasting algorithm based on Wolfenstein 3D raycasting algorithm, as explained in Fabien Sanglard: Game Engine Black Book: Wolfenstein 3D",
            "flags": 0,
            "hasliked": 0,
            "id": "3dG3zm",
            "likes": 0,
            "name": "syltefar-raycast",
            "published": 3,
            "tags": [
                "raycasting"
            ],
            "usePreview": 0,
            "username": "syltefar",
            "viewed": 138
        },
        "renderpass": [
            {
                "code": "// -----------------------------------------------------\n// Configuration\n// -----------------------------------------------------\nconst float FOV = 0.66;\nconst int BRUTE_MAX_STEP = 150;\nconst float BRUTE_STEP_LENGTH = 0.03;\n\nvec4 bmap[256]=vec4[](\nvec4(0x000000,0x000000,0x000000,0x000000), vec4(0x000000,0x000000,0x000001,0x040000), vec4(0x000000,0x000000,0x000041,0x000000), vec4(0x000000,0x000000,0x040000,0x000041), vec4(0x082082,0x082082,0x082082,0x082082), vec4(0x082082,0x0830c3,0x100005,0x182082), vec4(0x082082,0x083104,0x104146,0x082082), vec4(0x082082,0x1041c8,0x149249,0x243146), vec4(0x082084,0x080082,0x0c00c3,0x0030c3), vec4(0x000084,0x000000,0x1c8285,0x182083), vec4(0x0c4082,0x0c4104,0x10a146,0x08b24b), vec4(0x24b2cb,0x2cb0c0,0x149244,0x0c4145), vec4(0x083004,0x0c30c0,0x0020c2,0x2030c8), vec4(0x100003,0x0c0007,0x208285,0x1820c2), vec4(0x0840c3,0x004002,0x1ca146,0x0892cb), vec4(0x08b309,0x2c20c0,0x142089,0x0ca145), vec4(0x084087,0x0c70c0,0x0000c4,0x100204), vec4(0x1c3200,0x1c820a,0x28a205,0x1820c4), vec4(0x1030c0,0x1001ca,0x20a146,0x08b242), vec4(0x30b242,0x0c4107,0x1441c0,0x00a145), vec4(0x084002,0x082200,0x000083,0x0c3104), vec4(0x007200,0x0001c7,0x20a205,0x182084), vec4(0x082007,0x1c7108,0x28a146,0x08b08c), vec4(0x34c08b,0x0831c0,0x143107,0x20a145), vec4(0x0830c9,0x242082,0x0c2082,0x0c31c4), vec4(0x280200,0x000007,0x28a285,0x182082), vec4(0x104007,0x104107,0x20a146,0x0892c2), vec4(0x2cb082,0x240007,0x14300a,0x28a145), vec4(0x0820c2,0x249083,0x008082,0x0c4100), vec4(0x1c71c8,0x0001c8,0x288205,0x182084), vec4(0x004104,0x004008,0x28a146,0x0892c9), vec4(0x089249,0x0801c0,0x14320a,0x20a145), vec4(0x083003,0x082103,0x0031c7,0x104108), vec4(0x20010a,0x1c71c8,0x20a285,0x1820c4), vec4(0x107102,0x0801c0,0x288146,0x089309), vec4(0x244102,0x0831c8,0x145145,0x145145), vec4(0x084104,0x080000,0x0821ca,0x20a1ca), vec4(0x107007,0x2071c8,0x28a285,0x182104), vec4(0x1c0004,0x10720a,0x20a146,0x0892c2), vec4(0x244104,0x0c420a,0x143249,0x242145), vec4(0x0c0102,0x1041c3,0x0821c7,0x28a287), vec4(0x2001c8,0x1c0007,0x288285,0x183100), vec4(0x1c7104,0x1c020a,0x20a146,0x0892cb), vec4(0x084104,0x100208,0x142243,0x244145), vec4(0x0c40c0,0x002108,0x00a00a,0x28a288), vec4(0x20438e,0x280000,0x28a285,0x183100), vec4(0x1c71c4,0x287287,0x28a146,0x0892cb), vec4(0x242104,0x0c0208,0x143084,0x0c8145), vec4(0x0c00c0,0x204100,0x200200,0x20a1ca), vec4(0x1ca38e,0x38a1c7,0x288285,0x183004), vec4(0x1c7208,0x1c8288,0x20a146,0x0892cb), vec4(0x0830c0,0x10728a,0x143083,0x1ca145), vec4(0x0c3000,0x00720a,0x288008,0x1c820a), vec4(0x28a28e,0x38a28a,0x28a285,0x184107), vec4(0x1c828a,0x28a20a,0x20a146,0x08908b), vec4(0x103103,0x000288,0x144100,0x207145), vec4(0x0c00c8,0x207200,0x20728a,0x20a208), vec4(0x20828a,0x28a28a,0x28a285,0x184204), vec4(0x20828a,0x28a28a,0x28a146,0x0cb24b), vec4(0x2c4084,0x1c828a,0x1401c8,0x28a145), vec4(0x145145,0x145145,0x145145,0x145145), vec4(0x145145,0x145145,0x145145,0x185145), vec4(0x145145,0x145145,0x145146,0x0cb242), vec4(0x0c3104,0x20a20a,0x145145,0x145145), vec4(0x2c9089,0x082082,0x089082,0x082186), vec4(0x186186,0x186186,0x186186,0x186186), vec4(0x186186,0x186186,0x186186,0x0c92c3), vec4(0x2c00c0,0x00828a,0x14730c,0x30c309), vec4(0x2420c2,0x2c9084,0x082002,0x0c0146), vec4(0x188003,0x0030c2,0x08000a,0x28e386), vec4(0x186287,0x0c3084,0x0071c6,0x0cb24b), vec4(0x0c3303,0x00720a,0x14430c,0x3cb30c), vec4(0x2430c4,0x082100,0x0c3000,0x0c3146), vec4(0x2000c3,0x0c3089,0x082108,0x1c720a), vec4(0x1861c3,0x080100,0x100205,0x0c3089), vec4(0x2c30c0,0x007288,0x14230f,0x40f24c), vec4(0x083249,0x0c3000,0x003000,0x000146), vec4(0x0c30c9,0x089240,0x103207,0x20a207), vec4(0x186002,0x007200,0x20a005,0x10924b), vec4(0x243100,0x20a208,0x14230c,0x3c930b), vec4(0x10324b,0x240003,0x0c00ca,0x00014e), vec4(0x243244,0x24200a,0x1c01ca,0x2881c0), vec4(0x146104,0x0801c7,0x287205,0x10b249), vec4(0x1c7100,0x1c820a,0x14930c,0x242249), vec4(0x0840c9,0x2400c0,0x008207,0x00014e), vec4(0x082249,0x0890c7,0x007288,0x208287), vec4(0x1461c2,0x10420a,0x00a285,0x002082), vec4(0x1c71c0,0x1ca28a,0x14b30c,0x24c089), vec4(0x100103,0x083000,0x0c81c0,0x28a14a), vec4(0x089242,0x303100,0x1c8208,0x2871ca), vec4(0x1461c7,0x20a288,0x288205,0x003082), vec4(0x1071c7,0x20a28a,0x149309,0x2c908b), vec4(0x0840c0,0x0c00c3,0x007008,0x00a147), vec4(0x0c2084,0x004107,0x1c01c8,0x1ca287), vec4(0x146185,0x145145,0x145145,0x0030cb), vec4(0x0001c7,0x1ca20a,0x149309,0x0832cb), vec4(0x243109,0x0c30c3,0x0001ca,0x28a147), vec4(0x0c2100,0x0c41ca,0x1c70c7,0x007007), vec4(0x14208b,0x2c2083,0x0c4146,0x0c3083), vec4(0x0c01c7,0x28828a,0x14230c,0x24c30b), vec4(0x084004,0x249200,0x0c4107,0x288147), vec4(0x0c4009,0x083007,0x004309,0x107207), vec4(0x1422cb,0x083107,0x100146,0x0cb242), vec4(0x0c0007,0x20820a,0x142309,0x30b24b), vec4(0x0c0102,0x249083,0x004107,0x28814a), vec4(0x104003,0x2430c4,0x103244,0x0001c0), vec4(0x1420c2,0x0841c2,0x1c8146,0x08b24b), vec4(0x083107,0x20a208,0x14230c,0x309089), vec4(0x0c90c3,0x089088,0x0071c7,0x28a14e), vec4(0x000109,0x449102,0x0c00c4,0x1c4200), vec4(0x142083,0x004084,0x1c7146,0x08908b), vec4(0x083007,0x2081ca,0x14430c,0x30924b), vec4(0x104082,0x0c2088,0x1ca20a,0x28a14e), vec4(0x000103,0x242083,0x082103,0x00a00a), vec4(0x142082,0x0c21c7,0x107146,0x0820c2), vec4(0x103100,0x28a288,0x144309,0x30c089), vec4(0x0c4082,0x083007,0x20a20e,0x38a145), vec4(0x0040c2,0x102102,0x247247,0x2881ca), vec4(0x142309,0x0841c8,0x208146,0x083084), vec4(0x000000,0x28a28a,0x14430c,0x2c9249), vec4(0x103102,0x080208,0x28a28e,0x388145), vec4(0x200003,0x003083,0x0891ca,0x20028a), vec4(0x1420c9,0x0841c7,0x1c8146,0x0832c2), vec4(0x0c41c7,0x28728a,0x14430c,0x243082), vec4(0x104004,0x100208,0x1c0008,0x288146), vec4(0x288000,0x0000c2,0x1c00c7,0x00a28a), vec4(0x1420c3,0x080208,0x1ca146,0x08224b), vec4(0x0841c8,0x00028a,0x144309,0x3090c2), vec4(0x1020c7,0x0001c8,0x1c0008,0x28a146), vec4(0x18e28a,0x28a28a,0x28a28a,0x28a28e), vec4(0x1420c2,0x207007,0x20a146,0x082249), vec4(0x0820c0,0x20020a,0x144309,0x304102), vec4(0x083104,0x00820a,0x2071c8,0x28a146), vec4(0x186145,0x145145,0x145145,0x145145), vec4(0x142084,0x008208,0x28a146,0x08b2c2), vec4(0x0c30c3,0x10828a,0x14430c,0x103102), vec4(0x0c3100,0x00000a,0x20e28a,0x20a146), vec4(0x188208,0x208207,0x1c7208,0x208286), vec4(0x182104,0x1ca288,0x28a146,0x08b2c2), vec4(0x0c00c3,0x1001ca,0x147309,0x3030c4), vec4(0x104007,0x00000a,0x38e38a,0x28a146), vec4(0x1881c0,0x0c3003,0x104000,0x208285), vec4(0x182084,0x008288,0x28a146,0x0832c3), vec4(0x2c01c4,0x00720a,0x147309,0x0c3104), vec4(0x1081c0,0x20000a,0x38e38e,0x20a146), vec4(0x188003,0x0c40c0,0x1c41c7,0x107285), vec4(0x182080,0x0c720a,0x28a146,0x082089), vec4(0x0c31c7,0x20820a,0x147249,0x0c4104), vec4(0x0c0200,0x207288,0x38a38e,0x28a146), vec4(0x1880c4,0x1c30c7,0x107287,0x0c71c5), vec4(0x182083,0x0801c8,0x28a146,0x08b083), vec4(0x0c728a,0x1ca28a,0x147243,0x103104), vec4(0x103107,0x00728a,0x28e38e,0x28a146), vec4(0x1880c0,0x0c0003,0x1c420a,0x1c7285), vec4(0x1820c2,0x0c4007,0x208146,0x08b0c2), vec4(0x0c720a,0x28728a,0x147243,0x0c3104), vec4(0x0c4008,0x1c01ca,0x28828a,0x208146), vec4(0x188103,0x0c01c8,0x28828a,0x20a285), vec4(0x182084,0x0001c8,0x20a146,0x0c90c3), vec4(0x0001c8,0x20a28a,0x1470c3,0x0c00c4), vec4(0x145145,0x145145,0x145145,0x145146), vec4(0x1880c4,0x00828a,0x20a287,0x1c7285), vec4(0x1830c0,0x0081ca,0x20a146,0x0c20c0), vec4(0x28028a,0x20a28a,0x146145,0x145145), vec4(0x186186,0x18a287,0x1c4104,0x00720a), vec4(0x286145,0x145145,0x145145,0x145145), vec4(0x183080,0x2071ca,0x288146,0x100288), vec4(0x2871c8,0x28a28a,0x1461c7,0x1c7186), vec4(0x183089,0x2cb2cb,0x2cb2cb,0x2cb2cb), vec4(0x249242,0x0830c0,0x186186,0x186186), vec4(0x1830c0,0x1c828a,0x28a146,0x100208), vec4(0x28a28a,0x20a1ca,0x1461ca,0x00a186), vec4(0x1822cb,0x2cb2c9,0x0892c2,0x0822c2), vec4(0x089240,0x104108,0x14628a,0x2081c6), vec4(0x183004,0x1ca28a,0x28a146,0x185145), vec4(0x145145,0x145145,0x14628a,0x287186), vec4(0x1822c9,0x242249,0x2cb2c3,0x08b2cb), vec4(0x242109,0x200288,0x146283,0x109005), vec4(0x184004,0x20720a,0x208146,0x186186), vec4(0x186186,0x186186,0x186186,0x186186), vec4(0x18b2cb,0x2492cb,0x0c308b,0x2c3244), vec4(0x0830c0,0x108288,0x146282,0x243285), vec4(0x180008,0x1c828a,0x28a146,0x18b2cb), vec4(0x2cb2cb,0x2cb2cb,0x2cb249,0x242186), vec4(0x18b089,0x089249,0x0c30cb,0x084102), vec4(0x0030c3,0x00728a,0x146209,0x242105), vec4(0x186145,0x145145,0x145146,0x18b2cb), vec4(0x2c9242,0x089249,0x08224b,0x084146), vec4(0x18b2c9,0x0c4249,0x0830c2,0x2cb082), vec4(0x0800c3,0x00a288,0x146202,0x107285), vec4(0x1840c2,0x242082,0x0c4106,0x18b249), vec4(0x2c908c,0x302242,0x0cb2c3,0x0c4146), vec4(0x18b2c3,0x08b244,0x089249,0x002090), vec4(0x083207,0x20a20a,0x1461c3,0x1ca285), vec4(0x183089,0x083243,0x2471c5,0x18b2c9), vec4(0x2422cb,0x300003,0x1000c7,0x100146), vec4(0x18b2cb,0x2c210b,0x109000,0x084082), vec4(0x0c00c3,0x008208,0x1461c4,0x20a205), vec4(0x182249,0x084004,0x1ca205,0x18b24b), vec4(0x242249,0x080000,0x0c2000,0x007146), vec4(0x18b08b,0x0c208b,0x243000,0x002087), vec4(0x003000,0x20a00a,0x146185,0x145145), vec4(0x183084,0x1001ca,0x20a285,0x18b2c9), vec4(0x3cf083,0x083000,0x084103,0x20a146), vec4(0x18b243,0x0cb3cb,0x084080,0x002084), vec4(0x1000c7,0x1c828a,0x146186,0x186186), vec4(0x185145,0x145145,0x145145,0x18b242), vec4(0x3cf30b,0x2420c9,0x0070c3,0x20a146), vec4(0x18b08b,0x08f44f,0x0c3083,0x100104), vec4(0x10400e,0x38a20a,0x1460c3,0x0c2082), vec4(0x082082,0x0c30c4,0x1071c6,0x18b242), vec4(0x0cc302,0x0c00c0,0x1030c0,0x20a146), vec4(0x18b24b,0x24b3cb,0x080082,0x208200), vec4(0x1041ce,0x38e28a,0x1460c2,0x0c4084), vec4(0x0c2084,0x0c2000,0x1c7285,0x18b082), vec4(0x243103,0x102100,0x102107,0x20a146), vec4(0x18b08b,0x249244,0x104007,0x208208), vec4(0x1c71ca,0x38e28a,0x1460c3,0x104102), vec4(0x082243,0x104108,0x1ca285,0x18b2c2), vec4(0x0c3104,0x0040c3,0x0c41c8,0x28a146), vec4(0x1822c9,0x242000,0x0c20c3,0x008208), vec4(0x20720a,0x00a28a,0x146084,0x082243), vec4(0x083082,0x083100,0x1ca205,0x18b242), vec4(0x0c0000,0x1c0103,0x008288,0x1ca146), vec4(0x18b08b,0x244109,0x002083,0x1c0287), vec4(0x000288,0x28a288,0x146082,0x1020c4), vec4(0x0040c2,0x083100,0x288205,0x18b24b), vec4(0x242107,0x28a007,0x28a38e,0x20a146), vec4(0x18b08b,0x083100,0x204082,0x0c720a), vec4(0x00000a,0x20a20a,0x1460c4,0x083102), vec4(0x0040c3,0x0c4007,0x20a285,0x18b2c2), vec4(0x080003,0x28a207,0x28a38e,0x38a146), vec4(0x189084,0x104088,0x108103,0x0c71c8), vec4(0x00000a,0x28728a,0x1460c2,0x100000), vec4(0x107000,0x1001c8,0x28a285,0x1890c2), vec4(0x0cb0c0,0x0081ca,0x1ca28e,0x38a146), vec4(0x189087,0x204202,0x0000ca,0x20a288), vec4(0x28000a,0x28820a,0x146103,0x0801c0), vec4(0x2001c0,0x1c71ca,0x208285,0x1892c2), vec4(0x0031c7,0x00a20a,0x28a208,0x20a146), vec4(0x182084,0x10810a,0x20a207,0x207207), vec4(0x28a28a,0x28a28a,0x146103,0x1001c8), vec4(0x1c720a,0x1ca288,0x20a285,0x182003), vec4(0x0040c0,0x1c8288,0x28828a,0x28a146), vec4(0x1820c0,0x1031c7,0x1c71c7,0x208208), vec4(0x208208,0x208208,0x146100,0x1c71c7), vec4(0x1c7208,0x208208,0x1c81c6,0x1820c0), vec4(0x1001c7,0x208208,0x208208,0x208186), vec4(0x040000,0x000000,0x000000,0x000000), vec4(0x000000,0x000000,0x041000,0x000000), vec4(0x000000,0x000000,0x000001,0x040000), vec4(0x000000,0x000000,0x000000,0x000481), vec4(0x4d34d3,0x4d34d3,0x4d34d3,0x4d34d3), vec4(0x4d34d3,0x4d34d3,0x4d34d3,0x4d34d3), vec4(0x4d34d3,0x4d34d3,0x4d34d3,0x4d34d3), vec4(0x4d34d3,0x4d34d3,0x4d34d3,0x4d34d3)\n);\n\n\n// -----------------------------------------------------\n// Raycast render\n// -----------------------------------------------------\n#define PI 3.14159265359\n// Movement\nvec2 playerPos()\n{\n    const float moveSpeed = 0.3;\n    const float moveDist = 1.8;\n    //return vec2(3.5, 2.5);\n    return vec2(3.5, (sin(iTime*moveSpeed)*0.5+0.5)*moveDist+2.0);\n}\nfloat playerRot()\n{\n    const float rotSpeed = 0.3;\n    //return 0.27;\n    //return sin(iTime*rotSpeed)*PI+PI*0.5;\n    return mod(iTime*rotSpeed, PI*2.0);\n}\n\n// Level data\nint grid(in vec2 pos)\n{\n    int a[] = int[](\n        1,1,2,1,1,1,1,\n        1,1,0,1,0,0,2,\n        1,1,0,0,0,1,1, \n        2,0,0,0,0,1,1, \n        1,1,0,0,0,0,2, \n        1,1,0,0,0,1,1, \n        1,1,1,1,1,1,1\n    );\n    int x = int(pos.x);\n    int y = 6-int(pos.y);\n    return a[y*7+x];\n}\nvec3 tex(in vec2 pos01)\n{\n    int a[] = int[](1,2,3,4,\n                    2,2,2,2,\n                    3,3,3,3,\n                    1,2,5,4);\n\n    int x = int(pos01.x*3.99);\n    int y = int(pos01.y*3.99);\n    int p = a[y*4+x];\n    vec3 col = vec3(1.0, 0.5, 0.5); // error pink\n    \nif(p==0) col = vec3(0.000, 0.000, 0.439);\nelse if(p==1) col = vec3(0.220, 0.220, 0.220);\nelse if(p==2) col = vec3(0.000, 0.000, 0.596);\nelse if(p==3) col = vec3(0.000, 0.000, 0.533);\nelse if(p==4) col = vec3(0.000, 0.000, 0.486);\nelse if(p==5) col = vec3(0.000, 0.000, 0.000);\nelse if(p==6) col = vec3(0.125, 0.125, 0.125);\nelse if(p==7) col = vec3(0.000, 0.000, 0.392);\nelse if(p==8) col = vec3(0.000, 0.000, 0.345);\nelse if(p==9) col = vec3(0.000, 0.000, 0.643);\nelse if(p==10) col = vec3(0.000, 0.000, 0.298);\nelse if(p==11) col = vec3(0.000, 0.000, 0.690);\nelse if(p==12) col = vec3(0.000, 0.000, 0.737);\nelse if(p==13) col = vec3(0.125, 0.141, 0.988);\nelse if(p==14) col = vec3(0.000, 0.000, 0.251);\nelse if(p==15) col = vec3(0.000, 0.000, 0.831);\nelse if(p==16) col = vec3(0.000, 0.000, 0.988);\nelse if(p==17) col = vec3(0.251, 0.251, 0.988);\nelse if(p==18) col = vec3(0.173, 0.173, 0.173);\nelse if(p==19) col = vec3(0.329, 0.329, 0.329);\n    return col;\n}\n\nvec3 color(int gridVal, vec2 uv)\n{\n    if(gridVal == 0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if(gridVal == 1)\n    {\n        return tex(uv);\n    }\n    else if(gridVal == 2)\n    {\n        return vec3(1.0, sin(iTime*3.0)*0.5+0.5, 0.0);\n    }\n}\n\n// Trivial ray marching algorithm\nvoid raycast_brute(vec2 rayPos, vec2 rayDir, out vec2 hitPos, out int hit)\n{\n    for(int i=0; i < BRUTE_MAX_STEP; ++i)\n    {\n        hit = grid(rayPos);\n        if(hit != 0) break;\n        rayPos += rayDir * BRUTE_STEP_LENGTH;\n    }\n    hitPos = rayPos;\n}\n\n// Digital differential analyzer (DDA) Raycasting algorithm by Schmid.\n// - Based on Wolfenstein 3D raycasting algorithm, as explained in\n//   Fabien Sanglard: Game Engine Black Book: Wolfenstein 3D\nvoid raycast_dda_wolf3d(vec2 rayPos, vec2 rayDir, out vec2 hitPos, out int hit)\n{\n    float x = floor(rayPos.x); // map tile x\n    float y = floor(rayPos.y); // map tile y\n    float mapx = x;\n    float mapy = y;\n    float tileStepX = sign(rayDir.x); // -1 or 1\n    float tileStepY = sign(rayDir.y); // -1 or 1\n    float yMovePerXStep = rayDir.y / rayDir.x;// * tileStepY;\n    float xMovePerYStep = rayDir.x / rayDir.y;// * tileStepX;\n\n    if(rayDir.x < 0.0)\n    {\n        x += 1.0;\n    }\n    if(rayDir.y < 0.0)\n    {\n        y += 1.0;\n    }\n    \n    // Find first intersection\n    float accx = rayPos.x;\n    float accy = rayPos.y;\n\n    float dx = (y - rayPos.y) * xMovePerYStep;\n    float dy = (x - rayPos.x) * yMovePerXStep;\n\n    // Find accx: x coordinate of first intersection with horizontal grid line in rayDir\n    //  and accy: y coordinate of first intersection with vertical   grid line in rayDir\n    if(abs(dx) > abs(dy))\n    {\n\t    accy = rayPos.y + dy;\n\t    accx = x - (accy-y) * xMovePerYStep;\n    }\n    else\n    {\n\t    accx = rayPos.x + dx;\n\t    accy = y - (accx-x) * yMovePerXStep;\n    }\n\n    float daccx = xMovePerYStep * tileStepY;\n    float daccy = yMovePerXStep * tileStepX;\n    \n    hit = 0;\n    int steps = 0;\n    const int maxsteps = 20;\n    while(hit == 0)\n    {\n\t\t// Vertical\n        while(\n\t        (daccx > 0.0 && (accx+daccx < mapx+1.0)) ||\n\t        (daccx < 0.0 && (accx+daccx > mapx))\n\t    )\n        {\n            y += tileStepY;\n            mapy += tileStepY;\n            accx += daccx;         \n\t\t\t\n            hit = grid(vec2(mapx,mapy));\n            if(hit != 0)\n            {\n                hitPos = vec2(accx, y);\n                break;\n            }\n\t        \n            if(++steps >= maxsteps)\n\t\t        break;\n        }\n\n\t    if(steps >= maxsteps)\n\t        break;\n\n        if(hit != 0)\n            break;\n        \n\t    // Horizontal\n        while(\n\t        (daccy > 0.0 && (accy+daccy < mapy+1.0)) ||\n\t        (daccy < 0.0 && (accy+daccy > mapy))\n\t    )\n        {\n\t        x += tileStepX;\n            mapx += tileStepX;\n            accy += daccy;\n            \n            hit = grid(vec2(mapx,mapy));\n            if(hit != 0)\n            {\n                hitPos = vec2(x, accy);\n                break;\n            }\n            \n            if(++steps >= maxsteps)\n\t\t        break;\n        }\n        \n\t    \n        if(++steps >= maxsteps)\n\t         break;\n    }\n}\n\n// Raycast rendering\nvec3 renderPixels(in vec2 pos01)\n{\n    vec3 col;\n    pos01 = vec2(1.0-pos01.x, pos01.y); // flip x (don't know why)\n    vec2 pos_v = pos01 * 2.0 - vec2(1.0, 1.0); // view coords [(-1,-1);(1,1)]\n    float cdist_y = abs(pos01.y-0.5) * 2.0; // y distance from screen center [0;1]\n    float r = playerRot();\n    vec2 playerDir = vec2(cos(r), sin(r));\n    \n    // BG\n    col = mix(vec3(0.0, 0.0, 0.0), vec3(0.4, 0.4, 0.4), cdist_y);\n    vec2 camPlane = vec2(-playerDir.y, playerDir.x) * FOV;\n    vec2 rayPos = playerPos() + playerDir * 0.2 + camPlane * pos_v.x;\n    float rayRot = playerRot() + (pos01.x - 0.5) * 1.0;\n    vec2 rayDir = vec2(cos(rayRot), sin(rayRot));\n    \n    // raycast\n    int hit = 0;\n    vec2 hitPos;\n    raycast_dda_wolf3d(rayPos, rayDir, hitPos, hit);\n        \n    // calculate length of player-to-hit vector projected onto playerDir (avoids horrible fish eye)\n\tvec2 playerToHit = hitPos - playerPos();\n    float dist = dot(playerToHit, playerDir);\n    float wallHeight = 0.8/dist;\n    \n    if(wallHeight > cdist_y)\n    {\n        vec2 uv;\n        \n        uv.y = (pos01.y-0.5)/wallHeight+0.5;\n        uv.x = max(hitPos.x - floor(hitPos.x), hitPos.y - floor(hitPos.y));\n        col = mix(vec3(0.0, 0.0, 0.0), color(hit, uv), wallHeight*0.5);\n    }\n    \n    return col;\n}\n\nvec3 renderMap(in vec2 pos01)\n{\n    const float gridSize = 0.2;\n    vec2 renderRes = vec2(7,7);\n    vec2 gridPosf = pos01*renderRes;\n    vec2 pos = round(gridPosf-vec2(0.5,0.5));\n    vec2 gridFrac = vec2(mod(gridPosf.x, 1.0), mod(gridPosf.y,1.0));\n    vec2 gridFracPow = vec2(pow(gridFrac.x, gridSize), pow(gridFrac.y, gridSize));\n    float grid01 = round(gridFracPow.x) * round(gridFracPow.y);\n    \n    vec3 col = mix(vec3(0.5, 0.0, 0.0), color(grid(pos), vec2(0.0, 0.0)), grid01);\n\n    float rayRot = playerRot();\n    vec2 rayDir = vec2(cos(rayRot), sin(rayRot));\n    float dist;\n    int hit;\n    vec2 hitPos_brute;\n    raycast_brute(playerPos(), rayDir, hitPos_brute, hit);\n    vec2 hitPos_wolf3d;\n    raycast_dda_wolf3d(playerPos(), rayDir, hitPos_wolf3d, hit);\n    \n    if(length(gridPosf-playerPos())<0.2)\n    {\n        col = vec3(1.0, 1.0, 0.0);\n    }\n    if(length(gridPosf-(playerPos()+rayDir*0.3))<0.1)\n    {\n        col = vec3(1.0, 1.0, 0.0);\n    }\n    if(length(gridPosf-hitPos_brute)<0.2)\n    {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n    if(length(gridPosf-hitPos_wolf3d)<0.15)\n    {\n        col = vec3(1.0, 0.0, 1.0);\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float screenFraction = 0.6;\n    vec2 pos01 = fragCoord/iResolution.xy;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(pos01.x < screenFraction)\n    {\n    \tvec3 col = renderPixels( pos01 / vec2(screenFraction,1.0) );\n\t    fragColor = vec4(col,1.0);\n    }\n    else if(pos01.x > screenFraction + 0.005)\n    {\n        if(pos01.y < 0.4)\n        {\n\n        }\n        else if(pos01.y > 0.403)\n        {\n            vec2 pos_offset = pos01 - vec2(screenFraction,0.403);\n            vec2 pos01_window = pos_offset / vec2(1.0-screenFraction,1.0-0.4);\n            vec3 col = renderMap( pos01_window );\n            fragColor = vec4(col, 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}