{
    "Shader": {
        "info": {
            "date": "1511091438",
            "description": " tri-tree variant of  [url]https://www.shadertoy.com/view/Mt2XDc[/url]\nMouse controls the focus area.\n\nSee defines to draw edges or corners centered disks instead.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlsBzH",
            "likes": 14,
            "name": "tritree 2",
            "published": 3,
            "tags": [
                "triangle",
                "short",
                "hexa",
                "quadtree",
                "tritree",
                "3tree"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 659
        },
        "renderpass": [
            {
                "code": "// variant of https://www.shadertoy.com/view/Mt2XDc\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    o = vec4(0.0);\n    float r=.05, z=4., t=iTime, H = iResolution.y, uz;\n    U /=  H;                              // object : disc(P,r)\n    vec2 P = iMouse.xy, C=vec2(-.7,0), fU;\n    P =  length(P)>10. ? P/H :  .5+.5*vec2(cos(t),sin(t*.7));  \n    U =(U-C)/z; P=(P-C)/z; r/= z;         // unzoom for the whole domain falls within [0,1]^n\n    \n    mat2 M = mat2(1,0,.5,.87), IM = mat2(1,0,-.577,1.155);\n    U = IM*U;         // goto triangular coordinates (there, regular orthonormal grid + diag )\n    \n    o.b = .25;                            // backgroud = cold blue\n\n    for (int i=0; i<int(log2(H)); i++) {  // to the infinity, and beyond ! :-)\n        fU = min(U,1.-U); uz = 1.-U.x-U.y;\n      //if (min(min(fU.x,fU.y),abs(uz)) < z*r/H) { o--; break; } // cell border\n    \tif (length(P-M*vec2(.5-sign(uz)/6.)) - r > .6) break;    // cell is out of the shape\n\n                                          // --- iterate to child cell\n        fU = step(.5,U);                  // select grid-child\n        U = 2.*U - fU;                    // go to new local frame\n        P = 2.*P - M*fU;  r *= 2.;\n        \n        o += .13;                         // getting closer, getting hotter\n    }\n    \n    vec3 u = vec3(U,1.-U.x-U.y), c;      // local diamond barycentric coordinates\n    u = fract(u*sign(u.z));              // local triangle barycentric coordinates\n    \n                                         // --- display\n\n #define S(v) smoothstep(fwidth(v), 0.,(v)) // * step((fwidth(v)),.1)\n    o = vec4(u, 0);                      // paint coordinates \n    //o +=  smoothstep(.01,.0,abs(o-.5));// mid lines\n    //o = vec4( length(o) );\n#if 1                                     // disk around center    \n    o +=  smoothstep(.51,.5, length(1./3.-u)*1.27  ) ;\n#endif\n#if 0                                     // disks around edges    \n    c.x = length(vec2(u.r*1.73,u.g-u.b)) /2. ;\n    c.y = length(vec2(u.g*1.73,u.b-u.r)) /2. ;\n    c.z = length(vec2(u.b*1.73,u.r-u.g)) /2. ;\n    o.rgb =  smoothstep(.51,.5, c*2.);    // radius = 1/4 \n#endif\n#if 0                                     // disks around corners    \n    c.x = length(vec2((1.-u.r)*1.73,u.g-u.b)) /2. ;\n    c.y = length(vec2((1.-u.g)*1.73,u.b-u.r)) /2. ;\n    c.z = length(vec2((1.-u.b)*1.73,u.r-u.g)) /2. ;\n    o.rgb =  smoothstep(.51,.5, c);                   // colored disks\n  //o -= smoothstep(.06,.05, min(c.x,min(c.y,c.z)));  // black disks\n  //o = vec4( sin(31.*min(c.x,min(c.y,c.z))) );       // concentric curves\n#endif\n    \n    o.gb *= smoothstep(.9,1.,length(P-M*U)/r); // draw object\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}