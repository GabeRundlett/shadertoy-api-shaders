{
    "Shader": {
        "info": {
            "date": "1505654751",
            "description": "this is a fork of\nhttps://www.shadertoy.com/view/XlBGzm\n\nvery identical. many optimizations, no more global vars: line_count*=.5\ncamera handling intentionally sets it apart, yo you can differentiate them better.",
            "flags": 9,
            "hasliked": 0,
            "id": "XtfcRX",
            "likes": 7,
            "name": "Midnight Snow Plow",
            "published": 3,
            "tags": [
                "volume",
                "raymarch",
                "landscape",
                "rain",
                "snow",
                "winter",
                "wind",
                "realism",
                "bound"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 1119
        },
        "renderpass": [
            {
                "code": "//forest snow street, plowed\n\n//parent: https://www.shadertoy.com/view/XlBGzm\n//self  : https://www.shadertoy.com/view/XtfcRX\n// removed global vars, results in better compatibility.\n// applied various optimizations and style changes to its parent.\n// line_count*=.5\n\n//Backstory;\n// I had no internet for a 3 days, and a lot of folders of copied porly sorted shaders.\n// Optimizing this insanely sub-optimal shader kept me sane for a whole day.\n\nconst float branchStart=.1;\nconst vec2 eps=vec2(.00007,0);\n\n//zFar clipping sphere\n#define maxd 256.\n#define roadGroundY -14.\n#define roadZ 56.\n#define roadW 240.\n\n\nconst float PI =acos(-1.),PI2=PI*2.;\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(a) clamp(a,.0,1.)\n#define dd(a) dot(a,a)\n\nvoid hardAdd(inout int c, inout float a, int n, float b){if (b<a){a=b;c=n;}}\n#define smoothdis(a,b,p,h) (mix(b,a,h)-p*h*(1.-h))\n#define smoothAdd(a,b,p) smoothdis(a,b,p,sat(u5((b-a)/p)))\n#define smoothSub(a,b,p) -smoothAdd(a,-b,p)\n\nvec2 rv(vec2 v,vec2 r){return vec2(v.x*r.x-v.y*r.y,v.x*r.y+v.y*r.x);}\n#define branchspaces(y,a) v=vec2(cos(y),sin(y));o.a=rv(o.a,v);d.a=rv(d.a,v)\nvec3 moveToBranchSpace(vec3 o,inout vec3 d,float p,float y){\n vec2 branchspaces(y,xz);branchspaces(p,xy);return o;}\n\n#define dBall(p,r) length(p)-r\nfloat dCylinder(vec3 p,vec3 c,vec2 s,float r){vec3 t=p-c;\n vec2 d=abs(vec2(length(t.yz),t.x))-s;return min(max(d.x,d.y)+r,.0)+length(max(d,.0))-r;}\nfloat dRoundline(vec3 p,vec3 a,vec3 b,float r){p-=a;b-=a;\n float h=sat(dot(p,b)/dd(b));return length(p-b*h)-r;}\nfloat dBox(vec3 p,vec3 c,vec3 s,float r){vec3 d=abs(p-c)-(s-r);\n return min(max(d.x,max(d.y,d.z)),.0)+length(max(d,.0))-r;}\n\nbool testAABB(vec3 o, vec3 d, vec3 m, vec3 h, out float D){vec3 a=(m-h-o)/d,b=(m+h-o)/d;\n float v=max(max(min(a.x,b.x),min(a.y,b.y)),min(a.z,b.z)),\n        w=min(min(max(a.x,b.x),max(a.y,b.y)),max(a.z,b.z));if(v>w||w<.0)return false;D=v;\n return true;}// thanks to http://gamedev.stackexchange.com/a/18459\n\nfloat branchDistance(vec3 p, inout int mat,float E){\n float d=9999.9;mat=0;//2 return values\n const float s=.2,lr=.2,lb=-.2,//leaf branch params\n sg=.5,sb=sg-s*2.;//total space before wrap//branch size allowing for rounded ends\n const vec3 sbo=vec3(.0,lb,.0),sbs=vec3(s,0,0),sbl=vec3(sb,-.8,.8);\n vec3 c=vec3((branchStart+E)*.5,0,0);vec2 cs=vec2(.0,(E-branchStart)*.5-s);//cylinder params\n hardAdd(mat,d,1,dCylinder(p,c,cs,s));\n if(!((p.x>=E)||(p.x<=branchStart))){\n  vec3 m=vec3(mod(E-p.x,sg),p.y,abs(p.z));\n  float branchX=(floor((E-p.x)/sg)*sg),a=sin(PI*branchX/(E-branchStart));\n  d=smoothAdd(dRoundline(m,sbs+sbl*a,sbs,s),d,.2);\n  hardAdd(mat,d,2,dRoundline(m,sbs+sbl*(a+.2)+sbo,sbs+sbo,lr));}\n hardAdd(mat,d,2,dCylinder(p,c+vec3(0,lb,0),cs,lr));return d;}\n\n//this core fuunctions still lacks optimization. \n//i am just glad i got it functional\n//using global vars like this, that was just bad on too many levels.\nfloat raytraceBranch(vec3 u, vec3 D,vec3 t, float theE,float pitch, \n                    float yaw,float E,inout vec3 color,inout float nearestD){\n E=theE;   //this like is a terrible leftover from the pathethic original using too many globals.\n u=moveToBranchSpace(u-t,D,pitch,yaw);float testDist=-1.;\n if(!testAABB(u,D,vec3((branchStart+E)*.5,-.05,.0),\n              vec3((E-branchStart)*.5,.8,2.),testDist))return E;\n    //hardcoded y offset, size\n vec3 q=u+D*testDist;float f=testDist,d=.01;int mat,dummyMat;\n for(int i=0;i<16;i++){if(f>=testDist+E*2.){\n  f=maxd;break;}if(abs(d)<.01)break;f+=d;q=u+D*f;d=branchDistance(q,mat,E);}\n if(f<nearestD){nearestD=f;\n  vec3 n=normalize(vec3(d-branchDistance(q-eps.xyy,dummyMat,E),\n                        d-branchDistance(q-eps.yxy,dummyMat,E),\n                        d-branchDistance(q-eps.yyx,dummyMat,E)));\n  if(mat==1)color=mix(vec3(.9,.55,.0),vec3(.95,.85,.7),\n                      pow(max(dot(n,vec3(0,1,0)),.0),.5));\n  else color=vec3(.1,.2,.2)*max(dot(n,vec3(0,1,0)),.0);}\n #ifdef DRAW_CLIP_RAYTRACES\n color = mix(color,vec3(1,0,0),.1);\n #endif   \n return E;}\n\nvoid raytraceBranchShelf(vec3 u, vec3 d,vec3 o,float r,\n                        float p,float y,inout vec3 color,inout float nearestD){\n vec2 s=vec2(sin(p),cos(p))*r;float dd;\n if(!testAABB(u,d,o-vec3(0,s.x,0),vec3(s.y,abs(s.x)+2.,s.y),dd)) return;\n const float b=4.;\n float E=0.;\n for(int i=0;i<8;i++){E=raytraceBranch(u,d,o,r,p,y+PI*float(i)/b,E,color,nearestD);}\n #ifdef DRAW_CLIP_RAYTRACES\n color=mix(color,vec3(0,0,1),.1);\n #endif\n}\n\nfloat waveT(float time){return u5(sin(time+sin(time*.8)+sin(time*.2)*sin(time*2.1)));}\n//u=origin,d=rayditrectiom,t=treeOrigin,h=heightOff,v=v\nvoid raytraceTree(vec3 u,vec3 d,vec3 t,float o,float h, float v,inout vec3 color,inout float nearestD){t.y+=6.+o;\n vec2 n=normalize(d.xz),g=t.xz-u.xz,b=t.y+vec2(-12,20);\n float y=u.y+d.y*length(g)/length(d.xz);\n if(y<b.x||y>b.y)return;//above of below bounding plane.\n float q=dot(g,n)/length(n);//distToPointOnRayClosestToCenterOfTree\n if (q<=.0) return;//should consider radius of cylinder too, but won't matter for this scene\n const vec2 cone=vec2(14,2);// test within cylinder radius\n float cdttc = length(u.xz+n*q-t.xz);//closestDistToTreeCenter\n if (cdttc>cone.y+(cone.x-cone.y)*(1.-(y-b.x)/(b.y-b.x))) return;\n const float j=11.0,m=.2;\n for(float i=.0;i<j;i++){float b=i/j,w=waveT(iTime*1.5-t.x*.007);w=1.-w;w=1.-w*w;\n  float s=sin(iTime*3.+t.x*-.01 + b*1.2);s=1.-u5(s);s=(1.-s*s)*((w-w*m)+m)*-.04;\n  raytraceBranchShelf(u,d,t+vec3(0,1.+(pow(1.-b,.6))*(13.+h),0),//height\n                      branchStart+.5+(9.+v)*b,.05+.6*b+s,3.*b,color,nearestD);}//length//pitch//yaw offset\n float r=-(y-(t.y+8.0))*.1;\n if(y<t.y+10.){\n  if(cdttc<r){// this is utterly fudged, but it's close enough for such a tiny detail\n   float f=(1.-pow((cdttc/r),3.))*r,k=q-f;    \n   if(k<nearestD)color=vec3(.15,.1,0)*(f+.2);\n   #ifdef DRAW_CLIP_RAYTRACES\n    else color-=vec3(0,.5,0);\n   #endif\n   nearestD=min(k,nearestD);\n }}\n #ifdef DRAW_CLIP_RAYTRACES\n color=mix(color,vec3(0,1,0),.1);\n #endif\n return;\n}\n\n//#define traceTree ,sin(t+a.x)*1.5,sin(t*.7+a.x)*4.,sin(t*.85+a.x));}\nvoid raytraceTreeline(vec3 u,vec3 d,vec4 a,inout vec3 color,inout float nearestD){ \n float t=floor((u.x+d.x*(a.x-u.z)/d.z-a.z)/a.y)*a.y+a.y*.5+a.z;\n if(abs(t)>240.)return;\n raytraceTree(u,d,vec3(t,a.w,a.x),sin(t+a.x)*1.5,sin(t*.7+a.x)*4.,\n              sin(t*.85+a.x),color,nearestD);}\n//[U]RayOrigin,Direction,(offset.xy),(treelineX,treeGapZ,slopeY)\nvoid raytraceHillTreeline(vec3 u,vec3 d,vec2 o,vec3 a,inout vec3 color,\n                          inout float nearestD){a.x*=sign(d.x);\n float t=floor((u.z+d.z*(a.x-u.x)/d.x-o.x)/a.y)*a.y+a.y*.5+o.x;\n if(t>40.||t<-70.) return;//clipping planes\n if(t>.0)o.y+=t*a.z;//catches trees that otherwise float in the air\n raytraceTree(u,d,vec3(a.x,o.y,t),sin(t+a.x)*1.5,sin(t*.7+a.x)*4.,\n              sin(t*.85+a.x),color,nearestD);}\n\n\n\n\nvec3 trees(vec3 A,vec3 D,inout vec3 color,inout float nearestD){\n raytraceHillTreeline(A,D,vec2(4, -6),vec3(75,19,-4),color,nearestD);//trees\n raytraceHillTreeline(A,D,vec2(0,-10),vec3(100,12,-.25),color,nearestD);\n raytraceTreeline(A,D,vec4(roadZ+25.,17,12,roadGroundY-1.),color,nearestD);\n raytraceTreeline(A,D,vec4(roadZ+40.,14, 2,roadGroundY-1.),color,nearestD);\n raytraceTreeline(A,D,vec4(roadZ+55.,11, 3,roadGroundY-1.),color,nearestD);\n return color;\n}\n\n\n\nfloat groundDistance(vec3 p, inout int mat){\n float distance = 9999.9;\n mat=0;\n hardAdd(mat,distance,1,dBox(p, vec3(0,-50,-23),vec3(70,50,55),40.) );\n distance=smoothAdd(dBox(p,vec3(0,-12,-75),vec3(58,32,36),30.),distance,30.);\n distance=smoothAdd(dBox(p,vec3(0,roadGroundY-20.,64),vec3(roadW,20,100),20.),distance,15.);\n distance+=sin(p.x*.4+sin(p.x*.2)+sin(p.z*.5)*.75)*.2;\n distance+=sin(p.z*.4+sin(p.z*.2)+sin(p.x*.5)*.75)*.2;\n distance=smoothSub(dBox(p,vec3(0,roadGroundY+4.9,roadZ),vec3(roadW,6,12),4.),distance,1.);\n hardAdd(mat,distance,3,dBox(p, vec3(0,roadGroundY-3.1,roadZ),vec3(roadW,2.1,12),.0) );\n return distance;}\n\nfloat dFlake(vec3 p){const float m=20.,d=4.;\n if (any(greaterThan(abs(p),vec3(m))))return 9999.9;\n p+=1.25*iTime*vec3(-10.,1.5,-.25);return dBall(mod(p,d)-vec3(d*.5)\n -sin(1.25*iTime+floor(p.yzx/d)*vec3(1,1.3,1.7))*(2./5.)*d,.08);}\n\n//very basic fm synth for tire tracks.\n//Uvw, aCcumulator,Period,Offset,amplitude,wavelength\nvoid tiretrack(vec3 u,inout float c, float p,vec2 o, float a, float w) {\n u.z=abs(u.z-roadZ);if(u.z>5.)u.z-=5.;//if(abs(u.z+.25)<2.5)o.x+=8.;//seems superflous.\n float d=abs(u.z-sin(u.x*p+o.x)*a-o.y)/w;if(d<1.)c+=1.-d*d;}\nvoid tiretrackM(vec3 p, inout float c){\n tiretrack(p,c,.13,vec2(5,1),.5,.8);\n tiretrack(p,c,.06,vec2(0,2),.5,.7);\n tiretrack(p,c,.22,vec2(7,3),.5,.6);c/=3.;}\n\n//mix sky color, brown orange snowy diffuse.\nvec3 sky(vec3 D,vec3 color,inout float nearestD){\n float litAmt=max(.0,dot(vec3(0,1,0),D))*.5+.5;\n litAmt=1.-pow(1.-litAmt,1.5);\n return mix(color,mix(vec3(.45,.1,.25),vec3(.9,.8,.5),litAmt),nearestD/maxd);}\n\n//march distance to snow flakes in the wind\nfloat SnowFlakes(vec3 p,vec3 A,vec3 D,out float d){float f=.0;\n for(int i=0;i<128;i++){//another raymarching, so it is deferred.\n  if((abs(d)<.001)||(f>maxd))break;\n  f+=d*.125;p=A+D*f;d=dFlake(p);}return f;}\nvec3 snowFlakeColor(vec3 p,vec3 D,float d,float f,vec3 color,inout float nearestD){\n if(f<nearestD){const vec2 eps=vec2(.007,0);\n  vec3 n=normalize(d-vec3(dFlake(p-eps.xyy),dFlake(p-eps.yxy),dFlake(p-eps.yyx)));\n  vec2 f=vec2(pow(max(.0,dot(n,-D)),3.)*.7,max(.0,1.-(f/20.)));//fading\n  return mix(color,vec3(1,.9,.6),f.x*f.y);}return color;}\n\n//get ground and tiretrack color\nvec3 groundColor(vec3 p,float f,float d,int mat,int dd,vec3 color,inout float nearestD){\n if(f<nearestD){nearestD=f;\n  if(mat==1){const float m=-1.;\n   vec3 n=normalize(vec3(d-groundDistance(p-eps.xyy,dd),\n                         d-groundDistance(p-eps.yxy,dd),\n                         d-groundDistance(p-eps.yyx,dd)));\n   float diffuse=max(.0,m+max(u5(dot(n,vec3(0,1,0))),.0)*(1.-m));\n   color=mix(vec3(.25,0,.1),vec3(.95,.85,.6),diffuse*diffuse);\n  }if(mat==3){float c=.5;  \n   if(abs(p.z-roadZ)<.8)color=vec3(.47,.42,.20);\n   else                 color=vec3(.2,.15,.15);\n   tiretrackM(p,c);//tireTrackMultiPass\n   //c=1.-pow(1.-c,1.5);//pow is barely worth it\n   color=mix(color,vec3(.95,.85,.6),.5-.4*c);}}return color;}\n\n//Outoput,Uv,[A]=RayOrigin,[D]=RayDirection\nvoid mainVR(out vec4 O,in vec2 U,in vec3 A,in vec3 D){\n float nearestD=maxd;vec3 color=vec3(0);\n A.y+=1.7;//+height of eyes above ground.\n D *=vec3(-1,1,-1);//A *=vec3(-1,1,-1);//flipping rays instead of flipping set\n float f=.0,d=.01;\n int mat,dd;\n vec3 p=A;//p gets modified in this loop, and used after it, parallel to A\n for(int i=0;i<64;i++){//marching loop\n  if((abs(d)<.001)||(f>maxd))break;\n  f+=d;p=A+D*f;d=groundDistance(p,mat);}\n color=groundColor(p,f,d,mat,dd,color,nearestD); \n color=trees(A,D,color,nearestD);\n color=sky(D,color,nearestD);\n d=.01;f=SnowFlakes(p,A,D,d);//snowflake intersection\n color=snowFlakeColor(p,D,d,f,color,nearestD);//snorflake color\n O=vec4(color,1);}\n\n\nvoid mainImage(out vec4 O,in vec2 U){\n const vec3 cameraPos=vec3(0);//camPos is simple offset\n const float rad=360./acos(-1.),dar=acos(-1.)/180.;\n vec2 m=u2(iMouse.xy/iResolution.xy); \n m=PI*mix(vec2(1.-m.x,m.y*.35),vec2(1,0),step(iMouse.z,.0));\n vec2 fov=vec2(25.);fov.x=atan(tan(fov.y/rad)*iResolution.x/iResolution.y)*rad;\n mat3 cam;\n cam[0]=vec3(cos(m.x),0,sin(m.x));//camera.right\n m.x=m.x+PI*.5;\n cam[1]=vec3(cos(m.x)*cos(m.y),sin(m.y),sin(m.x)*cos(m.y));//cameraFwd\n //cam[2]=-cross(cam[0],cam[1]));//camUp\n fov=(2.*U/iResolution.xy-1.)*sin(fov*dar)/sin(PI*.5-fov*dar);\n cam[0]=cameraPos-cam[1]+fov.x*cam[0]-fov.y*cross(cam[0],cam[1]);\n cam[1]=normalize(cam[0]-cameraPos);\n // scene is accidentally backwards, ugh\n cam[1]*=vec3(-1,1,-1);cam[0]*=vec3(-1,1,-1);\n mainVR(O,U,cam[0],cam[1]);}\n\n//tail, memo of useful unused functions:\n//float middleMod(float d,float o){return mod(d+o*.5,o)-o*.5;}//offset modulo\n//aka dotperp==determinant2d\n//float det2d(vec2 vecA, vec2 vecB){return vecA.x*vecB.y-vecA.y*vecB.x;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//parent: https://www.shadertoy.com/view/XlBGzm\n//self  : https://www.shadertoy.com/view/XtfcRX\n//audio is unchanged, identical, except i added a static transpose, for differentiation\n\n#define transp -6\n\n\nconst int rest = 999;\n\nint imod(int x, int modulo){\n    return int(mod(float(x),float(modulo)));//ewwwww\n}\n\nfloat noteFreq(int note){\n    float oct = 1.0;\n    if (note >= 12) {\n        note -= 12;\n        oct = 2.0;\n    }\n    if (note < 0) {\n        note += 12;\n        oct = 0.5;\n    }\n    if (note ==  0) return oct*391.995;\n    if (note ==  1) return oct*415.305;\n    if (note ==  2) return oct*440.000;\n    if (note ==  3) return oct*466.164;\n    if (note ==  4) return oct*493.883;\n    if (note ==  5) return oct*523.251;\n    if (note ==  6) return oct*554.365;\n    if (note ==  7) return oct*587.330;\n    if (note ==  8) return oct*622.254;\n    if (note ==  9) return oct*659.255;\n    if (note == 10) return oct*698.456;\n    if (note == 11) return oct*739.989;\n    return 0.0;\n}\nint melodyNote(int beat){\n    if (beat < 0) return rest;\n    int melodyBeat = imod(beat,6);\n    if (melodyBeat == 0) return 3;\n    if (melodyBeat == 1) return 7;\n    if (melodyBeat == 2) return 2;\n    if (melodyBeat == 3) return 3;\n    if (melodyBeat == 4) return 0;\n    if (melodyBeat == 5) return 7;\n    return rest;\n}\nfloat melodyVol(int beat){\n    if (beat < 0) return 0.0;\n    int melodyBeat = imod(beat,6);\n    if (melodyBeat == 0) return 1.0;\n    if (melodyBeat == 1) return 0.07;\n    if (melodyBeat == 2) return 0.4;\n    if (melodyBeat == 3) return 0.3;\n    if (melodyBeat == 4) return 0.5;\n    if (melodyBeat == 5) return 0.07;\n    return 0.0;\n}\n\n/*\nint harmonyNote(int bar){\n    if (bar == 0) return 12;\n    if (bar == 1) return 10;\n    if (bar == 2) return 8;\n    if (bar == 3) return 7;\n    if (bar == 4) return 8;\n    if (bar == 5) return 7;\n    if (bar == 6) return 5;\n    if (bar == 7) return 0;\n    return rest;\n}\n*/\n\nint harmonyNoteA(int bar){\n    if (bar > 7) bar = 7;\n    if (bar == 0) return 12;\n    if (bar == 1) return 10;\n    if (bar == 2) return 8;\n    if (bar == 3) return 7;\n    if (bar == 4) return 8;\n    if (bar == 5) return 7;\n    if (bar == 6) return 5;\n    if (bar == 7) return 3;\n    return rest;\n}\nint harmonyNoteB(int bar){\n    if (bar > 7) bar = 7;\n    if (bar == 0) return 7;\n    if (bar == 1) return 5;\n    if (bar == 2) return 3;\n    if (bar == 3) return 3;\n    if (bar == 4) return 3;\n    if (bar == 5) return 3;\n    if (bar == 6) return 0;\n    if (bar == 7) return 0;\n    return rest;\n}\nint harmonyNoteC(int bar){\n    if (bar > 6) {\n        bar = 6+imod(bar,2);\n    }\n    if (bar == 0) return 3;\n    if (bar == 1) return 2;\n    if (bar == 2) return 0;\n    if (bar == 3) return 0;\n    if (bar == 4) return 0;\n    if (bar == 5) return -2;\n    if (bar == 6) return -4;\n    if (bar == 7) return -5;\n    return rest;\n}\n\nconst float beatLength = 0.36;\nconst float ringLength = 3.0;\n\nfloat beatFrac;\nfloat attack(float power){\n\treturn 1.0-pow(1.0-beatFrac,power);\n}\nfloat release(float power){\n    float result = 1.0-pow(beatFrac,power);\n\treturn max(0.0,result);//cap to avoid pop\n}\n\nvec2 strikeNote(int note, float vol, float time, bool isMelody){\n    note-=transp;\n    \n    if (note == rest) return vec2(0.0);\n    if (time < 0.0) return vec2(0.0);\n    \n    beatFrac = time/(beatLength*(isMelody?ringLength:7.0));\n    float baseFreq = 6.2831*noteFreq(note)*time;\n    \n    vec2 mix = vec2(0.0);\n    \n    if (isMelody) {\n        mix += vec2( sin(baseFreq* 1.0)*attack(100.0)*release(0.25)*vol*0.10 );\n        mix += vec2( sin(baseFreq* 4.0)*attack(200.0)*release(0.125)*vol*0.25 );\n        mix += vec2( sin(baseFreq*10.0)*attack(200.0)*release(0.125)*vol*0.025 );\n        mix += vec2( sin(baseFreq*16.0)*attack(400.0)*release(0.125)*vol*0.02 );\n        mix *= 0.4;\n    } else {\n        baseFreq *= 0.125;\n        mix += vec2( sin(baseFreq* 2.0)*attack(400.0)*release(3.0)*vol*0.004 );\n        mix += vec2( sin(baseFreq* 3.0)*attack(1600.0)*release(2.0)*vol*0.002 );\n        mix += vec2( sin(baseFreq* 4.0)*attack(3200.0)*release(0.5)*vol*0.125 );\n        mix += vec2( sin(baseFreq* 8.0)*attack(400.0)*release(0.25)*vol*0.005 );\n    }\n    \n    \n    return mix;\n    \n}\n\nvec2 mainSound( in int samp,float time){\n    \n    float songtime = time - 1.0;\n    \n    if (songtime < 0.0) return vec2(0.0);\n    \n    \n    int beat = int(songtime/beatLength);\n    float beatTime = mod(songtime,beatLength);\n    \n    vec2 mix = vec2(0.0);\n    for(float i=0.0; i<ringLength; i++){\n        mix += strikeNote(melodyNote(beat-int(i)),melodyVol(beat-int(i)),beatTime+beatLength*i,true);\n    }\n    \n    \n    int bar = int(songtime/(beatLength*6.0))-4;\n    if (bar >= 0) {\n        \n        float barTime = mod(songtime,(beatLength*6.0));\n\n        mix += strikeNote(harmonyNoteA(bar),0.8,barTime,false);\n        mix += strikeNote(harmonyNoteB(bar),0.3,barTime-0.02,false);\n        mix += strikeNote(harmonyNoteC(bar),0.3,barTime-0.04,false);\n        \n        if (barTime < 1.0) {\n            beatFrac = barTime*1.0;\n            float tom = sin(barTime*pow((1.0-barTime),1.5)*500.0);\n        \tmix += (tom*attack(5000.0)*release(0.02))*0.5;\n        }\n\n    }\n        \n    const float fadeStart = beatLength*6.0*14.0;\n    const float fadeEnd = beatLength*6.0*16.0;\n    float fadeout = max(0.0,min(1.0,1.0-((songtime-fadeStart)/(fadeEnd-fadeStart))));\n    fadeout = pow(fadeout,1.5);\n    \n    return mix*fadeout*4.0;\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}