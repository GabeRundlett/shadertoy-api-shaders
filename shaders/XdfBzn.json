{
    "Shader": {
        "info": {
            "date": "1494493089",
            "description": "random figure",
            "flags": 0,
            "hasliked": 0,
            "id": "XdfBzn",
            "likes": 1,
            "name": "Box & spher",
            "published": 3,
            "tags": [
                "3d",
                "beginner"
            ],
            "usePreview": 0,
            "username": "Rifeyka",
            "viewed": 479
        },
        "renderpass": [
            {
                "code": "\n#define QUALITES 100\n#define EPSILON 0.01\n#define Pi 3.141592653589793\n\n\nmat3 rotY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, 0., s, 0., 1., 0., -s, 0., c);\n}\n\nmat3 rotX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(1., 0., 0., 0., c, s, 0., -s, c);\n}\n\nfloat udBox( vec3 p, vec3 b ){\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b, float k ){\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat M(vec3 a, float x){\n    float t = mod(iTime, 12.56);\n    float roubox = udRoundBox(rotY(t * x) * rotX(t) *  a,vec3(x), x / 15.);\n    float spher = sdSphere(a, (sin(iTime * 11.) / (10. / x )+ (1.666 * x))/*x * 1.6*/);\n    return max (roubox, -spher);\n}\n\nfloat M2(vec3 a, float x){\n    \n    float tor = sdTorus(rotX(iTime * x) * rotY(iTime) * a,vec2(x, x * (sin(iTime * 11.) + x * 1.5) / (5. / x ) * 0.1));\n    float spher = sdSphere(a, x);\n    return max (tor, -spher);\n}\n\nfloat wplane(vec3 a) {\n  return a.y + 4.0;\n}\n\nfloat world1(vec3 a) {\n    float minM = M(a, 2.0);\n    for(float x = 1.75; x >= 0.25; x -= 0.25)\n        minM = min(minM, M(a, x));\n    return min(minM, wplane(a));\n}\n\nfloat world2(vec3 a) {    \n    float minM = M2(a, 2.0);\n    for(float x = 1.75; x >= 0.25; x -= 0.25)\n        minM = min(minM, M2(a, x));\n    return min(minM, wplane(a));\n}\n\nvec3 wcolor(vec3 a) {\n    float x = 2.;\n    float minimum = M(a, x);\n    vec3 color = vec3(length (a) / sqrt(3.), 0.,  1. - length (a) / sqrt(3.));\n    for(float x = 1.75; x >= 0.25; x -= 0.25){\n        if (minimum > M(a, x)) {\n        \tminimum = M(a, x);\n            color =  vec3(length (a) / sqrt(3.), 0., 1. - length (a) / sqrt(3.));\n        }\n    }\n    if (minimum > wplane(a))\n        color = vec3(0.0, 1.0, 0.0);\n    color *= 1.5;\n    return color;\n}\n\nvec3 wnormal(vec3 a) {\n  vec2 e = vec2(EPSILON, 0.);\n  float w = world1(a);\n  return normalize(vec3(\n    world1(a+e.xyy) - w,\n    world1(a+e.yxy) - w,\n    world1(a+e.yyx) - w));\n}\n\nfloat trace(vec3 O, vec3 D) {\n    float t = mod(iTime, Pi * 12.);\n\tfloat L = 0.;\n    float d1, d2;\n\tfor (int i = 0; i < QUALITES; ++i) {\n        if (t < Pi * 4.) {\n\t\t\td1 = world1(O + D*L);\n        } else {\n            if (t < Pi * 5.) {\n            \tfloat x = abs(sin(iTime * 0.5));\n                d1 = mix(world1(O + D*L), d1 = world2(O + D*L), x);\n        \t} else {\n            \tif (t < Pi * 11.) {\n        \t\t\td1 = world2(O + D*L);\n           \t\t} else {\n            \t\tfloat x = abs(sin(iTime * 0.5));\n            \t    d1 = mix(world1(O + D*L), d1 = world2(O + D*L), x);            \t   \n            \t}\n            }\n        }\n        //float x = sin(iTime * 0.5) / 3. + 0.33;\n\t\t//L += mix(d1, d2, x);\n        \n\t\tL += d1;\n\t\tif (d1 < EPSILON && d2 < EPSILON) break;\n\t}\n\treturn L;\n}\n\nfloat occlusion(vec3 at, vec3 normal) {\n  float b = 0.;\n  for (int i = 1; i <= 4; ++i) {\n    float L = .06 * float(i);\n    float d = world1(at + normal * L);\n    b += max(0., L - d);\n  }\n  return min(b, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 O =  vec3(0., 0., 9.);\n\tvec3 D = normalize(vec3(uv, -2.));\n    \n\tfloat path = trace(O, D);    \n    vec3 pos = O + D * path;\n    vec3 nor = wnormal(pos);\n\n    vec3 color = vec3(.9) * (1.0 - occlusion(pos, nor)) * wcolor(pos);\n\n    color = mix(color, vec3(1.0), smoothstep(0.,30.,path));\n\n    fragColor = vec4(color,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}