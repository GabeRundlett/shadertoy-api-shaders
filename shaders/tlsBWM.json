{
    "Shader": {
        "info": {
            "date": "1596912910",
            "description": "oreo network",
            "flags": 1,
            "hasliked": 0,
            "id": "tlsBWM",
            "likes": 20,
            "name": "oreo_network",
            "published": 3,
            "tags": [
                "tunnel"
            ],
            "usePreview": 0,
            "username": "slackmage",
            "viewed": 501
        },
        "renderpass": [
            {
                "code": "/**\n\tGyroid Tunnel Thing\n\tJust some playing with the base\n\tof my asteroid shader \n\thttps://www.shadertoy.com/view/WtfyDX\n\n\talso wanted a break from hexagon truchets\n*/\n\n#define MAX_DIST \t100.\n#define PI  \t\t3.1415926\n#define R \t\t\tiResolution\n#define T \t\t\tiTime\n#define S\t\t\tsmoothstep\n\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n\n// gyroid function\nfloat sdGry(vec3 p, float s, float t, float b) {\n    p *=s;\n   \tfloat g = abs(dot(sin(p), cos(p.zxy))-b)/(s)-t;\n    return g;\n}\n\n//global vars cause its just a demo\nfloat g1,g2,g3,g4,g5;\nvec3 hitPoint;\nvec2 map(vec3 p) {\n    vec2 res=vec2(1000.,1.);\n    p.xy*=r2(T*.009);\n    p +=vec3(-.05,-.2,iTime*1.4);\n    // sdGry(p, thickness, scale, offset) / sdf focus \n   // p = twist(p);\n\tg1 =  sdGry(p, 8.,  .025,  1.05);\n    g2 = sdGry(p, 24., .025, .75);\n    g3 = sdGry(p, 54., .01, .25);\n    g1 -= (g2 *.1);\n\n    hitPoint =p;\n    res.x = g1/1.75;\n    return res;\n}\n\nvec3 get_normal(in vec3 p, in float t) {\n    t *= 0.001;\n\tvec2 eps = vec2(t, 0.0);\n\tvec3 n = vec3(\n\t    map(p+eps.xyy).x - map(p-eps.xyy).x,\n\t    map(p+eps.yxy).x - map(p-eps.yxy).x,\n\t    map(p+eps.yyx).x - map(p-eps.yyx).x);\n\treturn normalize(n);\n}\n\nvec2 ray_march( in vec3 ro, in vec3 rd, int x) {\n    float t = 0.0001;\n    float m = 0.;\n    for( int i=0; i<x; i++ ) {\n        vec2 d = map(ro + rd * t);\n        m = d.y;\n        if(d.x<.0001*t||t>MAX_DIST) break;\n        t += d.x*.6;\n    }\n    return vec2(t,m);\n}\n\nfloat get_diff(in vec3 p, in vec3 lpos, in vec3 n) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),0. , 1.),\n          shadow = ray_march(p + n * .0001 * 2., l,128).x;\n    if(shadow < length(lpos-p)) dif *= .4;\n    return dif;\n}\n\n// Tri-Planar blending function. Ryan Geiss\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz,\n         ty = texture(t, p.zx).xyz,\n         tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nvec3 get_hue(float qp) {\n   return (.9 + .45*cos(qp + vec3(5, 5, .5)));\n}\n\nvec3 tone1 = (.5 + .45*cos(3.72 + vec3(2, 1, .5)));\nvec3 tone2 = (.5 + .45*cos(12.5 + vec3(2, 1, .5)));\n\nvec3 get_color(vec3 p, vec3 n) {\n    vec3 col = vec3(0.);\n    vec3 dif = tone1 * tex3D(iChannel1,hitPoint*9.,n).g; \n\tfloat bbd = abs(abs(g3-.005)-.0025); //b2m\n    bbd = abs(bbd-.015);\n    float cks1 = S(.01,.011,bbd)*.45;\n    float cks2 = S(-.02,-.05,g2)*2.;\n    \n    vec3 mate = 4.5 + 1.45*cos(hitPoint.z*4.25 + vec3(4, 1, 1.5));\n    col += mate*cks1+cks2;   \n    return col + dif;\n}\n\nvec3 fog (in float t, in float d, in vec3 c) {\n    return mix( c, tone2, 1.-exp(-d*t*t*t));\n}\n\nvec3 r( in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 c = vec3(0.);\n    vec2 ray = ray_march(ro, rd, 128);\n\n    float t = ray.x;\n    float m = ray.y;\n    if(t<MAX_DIST) {\n\t\tvec3 p = ro + t * rd,\n             n = get_normal(p, t);\n        float diff = n.x*.5+.5;\n        if(ray.y == 1.){\n         \tc += diff * get_color(p, n);  \n        }\n\n        vec2 ref;\n        vec3 rr=reflect(rd,n),\n             fc=vec3(0.);\n\n        c = fog(t,.07,c);\n    } \n    return c;\n}\n\n// ACES tone mapping from HDR to LDR\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51,\n          b = 0.03,\n          c = 2.43,\n          d = 0.59,\n          e = 0.14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    vec2 U = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0.,.0,-.75),\n         lp = vec3(0.,.0,0.);\n\t\t\n    vec3 cf = normalize(lp-ro),\n     \t cp = vec3(0.,1.,0.),\n     \t cr = normalize(cross(cp, cf)),\n     \t cu = normalize(cross(cf, cr)),\n     \t c = ro + cf * 1.,\n     \t i = c + U.x * cr + U.y * cu,\n     \t rd = i-ro;\n    \n    vec3 C = r(ro, rd, U);\n    C = ACESFilm(C);\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}\n\n\nvoid mainVR( out vec4 O, in vec2 F, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    /** normalizing center coords */\n  \tvec2 U = (2.*F.xy-R.xy)/\n        max(R.x,R.y);\n    \n    vec3 ro = fragRayOri;\n    vec3 rd = fragRayDir;\n\n    vec3 C = r(ro, rd, U);\n    C = ACESFilm(C);\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}