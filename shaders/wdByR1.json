{
    "Shader": {
        "info": {
            "date": "1586077111",
            "description": "Visualization of the Hessian curve of an elliptic curve.\n\nYou can change the elliptic curve parameters with mouse,\nbut for some parameters the iterative computation of the inflection points fails,\nyou can try changing the initial approximations then.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdByR1",
            "likes": 4,
            "name": "The Hessian of an elliptic curve",
            "published": 3,
            "tags": [
                "2d",
                "curves",
                "geometry",
                "elliptic"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 373
        },
        "renderpass": [
            {
                "code": "/*\nVisualization of the Hessian of an elliptic curve.\nThe Hessian is the set of points where the\ndeterminant of the Hessian Matrix of the curve vanishes.\nIt has the interesting property that it passes through all\nthe inflection points of the curve.\n\n(An inflection point is a point on the curve where the\ncurve tangent is intersecting the curve with multiplicity >=3)\n\nThe blue curve is the elliptic curve\nThe cyan curve is the Hessian of the elliptic curve\nThe red dots are the inflection points\nThe green lines are the tangents at the inflection points\n\nMove mouse to change curve parameters\n\nFor some curve parameters the iterative computation of the\ninflection points fails.\n\nsee https://en.wikipedia.org/wiki/Polar_curve#The_Hessian\n*/\n\nconst int grad_descent_iterations=16;\n\nfloat border;\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x-(2.*f*f1)/(2.*f1*f1-f*f2);\n}\n\nfloat eval_poly4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nvec2 compute_inflection_point_gradient_descent(float g_2, float g_3){\n\n\tvec2 p0=vec2(0.5,0.5);//initial approximation of the inflection point\n\n\t//compute inflection points by alternately gradient descenting to curve and hessian of curve\n\tfloat p0_val, hesse_p0_val;\n\tvec2 p0_grad, hesse_p0_grad;\n\n\tfor(int i=0;i<grad_descent_iterations;i++){\n\t\tp0_val = p0.y*p0.y - (( 4.*p0.x*p0.x - g_2 ) * p0.x - g_3);\n\t\tp0_grad = vec2(-12.*p0.x*p0.x+g_2,2.*p0.y);\n\t\tp0-=(p0_grad*p0_val)/dot(p0_grad,p0_grad);\n\n\t\thesse_p0_val = -96.*g_2*p0.x*p0.x + 96.*p0.x*p0.y*p0.y - 8.*g_2*g_2 - 288.*g_3*p0.x;\n\t\thesse_p0_grad = vec2(-192.*g_2*p0.x + 96.*p0.y*p0.y - 288.*g_3,192.*p0.x*p0.y);\n\t\tp0-=(hesse_p0_grad*hesse_p0_val)/dot(hesse_p0_grad,hesse_p0_grad);\n\t}\n\n\treturn p0;\n}\n\nvec2 compute_inflection_point_halley(float g_2, float g_3){\n\n\tvec4 coeffs = vec4(-1./48.*g_2*g_2,-g_3,-1./2.*g_2,0.);\n\n\tbool swap=false;\n\n\tif(eval_poly4(coeffs,1.)<0.){\n\t\tswap=true;\n\t\tcoeffs=vec4(1.,coeffs[3],coeffs[2],coeffs[1])/coeffs[0];\n\t}\n\n\tfloat lb=0.;\n\tfloat ub=1.;\n\n\tfor(int i=0;i<4;i++){\n\t\tif(eval_poly4(coeffs,.5*lb+.5*ub)>0.){\n\t\t\tub=.5*lb+.5*ub;\n\t\t}\n\t\telse{\n\t\t\tlb=.5*lb+.5*ub;\n\t\t}\n\t}\n\n\tfloat x_0=.5*lb+.5*ub;\n\n\tfor(int i=0;i<2;i++){\n\t\tx_0=halley_iteration4(coeffs,x_0);\n\t}\n\n\tif(swap){\n\t\tx_0=1./x_0;\n\t}\n\n\tfloat y_0 = sqrt(( 4.*x_0*x_0 - g_2 ) * x_0 - g_3);\n\n\treturn vec2(x_0,y_0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= aspect_ratio;\n\n\tvec2 mouse = (iMouse.xy+1.) / iResolution.xy;\n\tmouse-=.5;\n\n\tconst float line_width = .001;\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\n\tconst float axis_width = .005;\n\n\tconst vec3 bg_col = vec3(1,1,1);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 line_col = vec3(0,1,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 hesse_curve_col = vec3(0,1,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\n    border = 2./iResolution.y;\n\n\tfloat curve_dis = 1e38;\n\tfloat hesse_curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\tfloat line_dis = 1e38;\n\n\t//elliptic curve parameters (weierstrass normal form)\n\n\tfloat g_2, g_3;\n\n\tif(iMouse.x > 0.0){\n\t\tg_2 = .3+mouse.x;\n\t\tg_3 = -.05+mouse.y;\n\t}\n\telse{\n\t\tg_2 = .3;\n\t\tg_3 = -.05;\n\t}\n\n\t//vec2 p0=compute_inflection_point_gradient_descent(g_2,g_3);\n\tvec2 p0=compute_inflection_point_halley(g_2,g_3);\n\tvec2 p1=p0*vec2(1.,-1.);\n\n\tdot_dis=min(dot_dis,distance(p0,uv)-dot_size);\n\tdot_dis=min(dot_dis,distance(p1,uv)-dot_size);\n\n\tvec2 p0_grad = vec2(-12.*p0.x*p0.x+g_2,2.*p0.y);\n\tvec3 tangent1=vec3(normalize(p0_grad),0);\n\ttangent1.z=-dot(p0,tangent1.xy);\n\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),tangent1)));\n\n\tvec2 p1_grad = vec2(-12.*p1.x*p1.x+g_2,2.*p1.y);\n\tvec3 tangent2=vec3(normalize(p1_grad),0);\n\ttangent2.z=-dot(p1,tangent2.xy);\n\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),tangent2)));\n\n\tfloat uv_val = uv.y*uv.y - (( 4.*uv.x*uv.x - g_2 ) * uv.x - g_3);\n\tvec2 uv_grad = vec2(-12.*uv.x*uv.x+g_2,2.*uv.y);\n\n\tcurve_dis=min(curve_dis, abs(uv_val)/length(uv_grad)-curve_width);\n\n\tfloat hesse_uv_val = -96.*g_2*uv.x*uv.x + 96.*uv.x*uv.y*uv.y - 8.*g_2*g_2 - 288.*g_3*uv.x;\n\tvec2 hesse_uv_grad = vec2(-192.*g_2*uv.x + 96.*uv.y*uv.y - 288.*g_3,192.*uv.x*uv.y);\n\n\thesse_curve_dis=min(hesse_curve_dis, abs(hesse_uv_val)/length(hesse_uv_grad)-curve_width);\n\n\taxis_dis=min(axis_dis, abs(uv.x));\n\taxis_dis=min(axis_dis, abs(uv.y));\n\n\tvec3 color = bg_col;\n\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(line_col,color,smoothstep(0., border, line_dis)));\n\tcolor=vec3(mix(hesse_curve_col,color,smoothstep(0., border, hesse_curve_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}