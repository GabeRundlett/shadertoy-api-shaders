{
    "Shader": {
        "info": {
            "date": "1640427389",
            "description": "I was looking for some random pixelated color grid. \nThis is what i was aiming for. \n\nSadly this only works in 3.0 and above :(",
            "flags": 0,
            "hasliked": 0,
            "id": "7tKXzm",
            "likes": 2,
            "name": "Grid random bit color",
            "published": 3,
            "tags": [
                "grid",
                "color",
                "random",
                "hash",
                "4bit",
                "bitwiseoperation"
            ],
            "usePreview": 0,
            "username": "ersteller",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "// grid dimensions\n#define GRID vec2(16,9)\n\n// number of bits used for each color channel\n// max 8 bits (otherwise the masks will overlapp)\n#define BITS 1\n\n\n// https://stackoverflow.com/Questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nint hash( int x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// uv input 0 to 1\nvec3 getRandomGridColor( in vec2 uv , in vec2 grid_size, int bits)\n{\n \n    // we use time fraction for random val\n    int frac = int(fract(iTime)*4095.);        \n    \n    // transform to grid pos\n    vec2 fetch_pos = vec2( uv * grid_size);\n    // quantize with int() and convert x y to an index \n    int idx = int(fetch_pos.x) + ( int(grid_size.y) - 1 - int(fetch_pos.y)) * int(grid_size.x);\n\n    // random value for each square\n    int rand = hash(idx + frac);\n    \n    // mask bits from the random value, shift and normalize each channel\n    int basemask = 0xff >> (8 - bits); // create a base bitmask\n    int rmask = basemask; \n    int gmask = basemask << 8;\n    int bmask = basemask << 16;\n    \n    return vec3( \n        float( rand & rmask)        / float(basemask), \n        float((rand & gmask) >> 8)  / float(basemask), \n        float((rand & bmask) >> 16) / float(basemask)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // get random color in a grid\n    vec3 col = getRandomGridColor(uv, GRID, BITS);\n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}