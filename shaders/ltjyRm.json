{
    "Shader": {
        "info": {
            "date": "1508057309",
            "description": "Efficient way to render scattered pebbles, using cells with B random blob (as for Worley noise).\n+ tilability.\n\nuncomment line 18 to check tilability",
            "flags": 0,
            "hasliked": 0,
            "id": "ltjyRm",
            "likes": 29,
            "name": "Tilable Pebbles 2",
            "published": 3,
            "tags": [
                "2d",
                "worley",
                "pattern",
                "short",
                "voronoid"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 3186
        },
        "renderpass": [
            {
                "code": "// inspired from simplified https://www.shadertoy.com/view/MtlyR8 (VoronoÃ¯ with various metrics)\n// + tilability, multiple seed per cell\n\n#define C 50.  // cell size\n#define B  2.  // number of blob per cell. B=1 -> Poisson disk. Large or random B -> Poisson\n#define R  .5  // jittering blob location. .5 = anywhere in the tile. could be < or >\n#define dr .5  // blob radius fluctuates in [1-r,1+r]\n#define N  3   // tested neighborhood. Make it odd > 3 if R is high \n\n#define srnd(p)  ( 2.* fract(43758.5453*sin( dot(p, vec2(12.9898, 78.233) )      ) ) - 1. )\n#define srnd2(U) ( 2.* fract(4567.89* sin(4567.8*(U)* mat2(1,-13.17,377.1,-78.7) ) ) - 1. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float H = iResolution.y,\n          S = round(H/C);             // make number of cells integer for tilability\n    U /= H;\n    if (U.x > 1.) { O-=O; return; }   \n // U = fract(2.*U);                  // check tilability\n\n    U *= S; \n    float m=1e9, v, r, r0=1e2;\n    \n    for (int k=0; k<N*N; k++)                  // neihborhood\n        for (float i=0.; i<B; i++) {                // B blobs per cell\n            vec2 iU = floor(U),\n                  g = mod( iU + vec2(k%N,k/N)-1. , S),  // cell location within neighborhood\n                  p = g+.5 + R* srnd2(g+i*.1) ;         // blob location\n            \n            p = mod( p - U +S/2. , S) - S/2.;           // distance to blob center\n            r =  1. + dr* srnd(g+i*.1+.1);              // blob radius\n            v = length(p) / r;                          // distance in blob referential\n \n         // if (v < 1. && r < r0 ) m = v,r0 = r;        // smallest blob win\n            if (v < m) m = v;                           // nearest win\n    }\n    \n     O =   vec4( 1.-m*m );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}