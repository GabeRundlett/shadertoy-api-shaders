{
    "Shader": {
        "info": {
            "date": "1722802536",
            "description": "This shader is inspired by Code Lyoko. It's done with some good old ray marching applied to a bent cylinder. Dynamic noise textures are used for the color of the pipe and for turbulences applied to the light beams. It is not optimized for realtime.",
            "flags": 0,
            "hasliked": 0,
            "id": "McjcDh",
            "likes": 0,
            "name": "Diving into Lyoko",
            "published": 3,
            "tags": [
                "raymarching",
                "noise",
                "sdf",
                "light",
                "beams",
                "spheremarching",
                "thunder",
                "lyoko"
            ],
            "usePreview": 0,
            "username": "Tynien",
            "viewed": 86
        },
        "renderpass": [
            {
                "code": "#define M_PI 3.1415926535897932384626433832795\n#define M_2PI 6.283185307179586476925286766559\n#define CLAMP01(T) clamp((T), 0.0, 1.0)\n\n\n// dark color palette\n#define DARK\n\n// travel speed of the camera through the pipe\n#define SPEED 200.0\n// texture speed relative to the pipe. 1.0 means it seems attached to the pipe, more means that the texture is moving relative to the pipe\n#define TEXTURE_SPEED_FACTOR 2.0\n// time between each bending\n#define BEND_PERIOD 1.5\n// Z distance where the bending origin appears\n#define BEND_DISTANCE_Z (SPEED * BEND_PERIOD)\n// distance range on XY plane for the bending origin\n#define BEND_RANGE_XY vec2(40, 80)\n// angle range when the pipe bends\n#define BEND_RANGE_ANGLE vec2(M_PI/2., M_PI/8.)\n// fog intensity\n#define FOG_INTENSITY 0.01\n// number of light beams\n#define NB_LIGHTS 5\n// light beams width\n#define LIGHT_WIDTH 0.12\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) { // source: https://stackoverflow.com/a/17479300\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) { // source: https://stackoverflow.com/a/17479300\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nvec3 hashUIntToVec3(uint value) {\n    float hash1 = floatConstruct(hash(value));\n    float hash2 = floatConstruct(hash(value * 13u + 7u)); \n    float hash3 = floatConstruct(hash(value * 31u - 11u));\n    return vec3(hash1, hash2, hash3);\n}\n\nvec3 ColorRGB(in int Hex) // source: https://www.shadertoy.com/view/3lVfWt\n{\n    // 0xABCDEF\n    int AB = (Hex & 0x00FF0000) >> 16;\n    int CD = (Hex & 0x0000FF00) >> 8;\n    int EF = Hex & 0x000000FF;\n    return pow(vec3(AB, CD, EF)/255.0, vec3(2.2));\n}\n\nvec3 CatmulRom(in float T, vec3 D, vec3 C, vec3 B, vec3 A) // source: https://www.shadertoy.com/view/3lVfWt\n{\n    return 0.5 * ((2.0 * B) + (-A + C) * T + (2.0 * A - 5.0 * B + 4.0 * C - D) * T*T + (-A + 3.0 * B - 3.0 * C + D) *T*T*T);\n}\n\nvec3 ColorRamp_BSpline(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D) // source: https://www.shadertoy.com/view/3lVfWt\n{\n    // Distances :\n    float AB = B.w-A.w;\n    float BC = C.w-B.w;\n    float CD = D.w-C.w;\n \n    // Intervals :\n    float iAB = CLAMP01((T-A.w)/AB);\n    float iBC = CLAMP01((T-B.w)/BC);\n    float iCD = CLAMP01((T-C.w)/CD);\n    \n    // Weighting :\n    vec4 p = vec4(1.0-iAB, iAB-iBC, iBC-iCD, iCD);\n    vec3 cA = CatmulRom(p.x, A.xyz, A.xyz, B.xyz, C.xyz);\n    vec3 cB = CatmulRom(p.y, A.xyz, B.xyz, C.xyz, D.xyz);\n    vec3 cC = CatmulRom(p.z, B.xyz, C.xyz, D.xyz, D.xyz);\n    vec3 cD = D.xyz;\n\n    if(T < B.w) return cA.xyz;\n    if(T < C.w) return cB.xyz;\n    if(T < D.w) return cC.xyz;\n    return cD.xyz;\n}\n\nfloat Noise3D(in vec3 p3) { // source: https://www.shadertoy.com/view/WdyfDy\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3D(in vec3 p) { // source: https://www.shadertoy.com/view/WdyfDy\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = Noise3D(cell);                       // Left, Down, Back\n    float rdb = Noise3D(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = Noise3D(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = Noise3D(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = Noise3D(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = Noise3D(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = Noise3D(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = Noise3D(cell + vec3(1.0, 1.0, 1.0)); // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat FractalNoise3D(in vec3 p, in vec3 scale, in float octaves) { // source: https://www.shadertoy.com/view/WdyfDy\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise3D(p * scale * pow(2.0, octave)) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nvec3 colorContrast(vec3 col)\n{\n    return col * col / (2.0 * col * col- 2.0 * col + vec3(1.0)); // Quadratic Rational smoothstep function from https://iquilezles.org/articles/smoothsteps/\n}\n\nfloat parabola( float x, float k ) // source: https://iquilezles.org/articles/functions/\n{\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nfloat map(float value, float minIn, float maxIn, float minOut, float maxOut) {\n  return minOut + (value - minIn) * (maxOut - minOut) / (maxIn - minIn);\n}\n\n// bend the Z axis (camera forward) around bendOrigin\nvec3 bendPosition(vec3 pos, vec3 bendOrigin, float bendAngle)\n{\n    // input variables\n    float bendRadius = length(bendOrigin.xy);\n    float bendLength = bendRadius * bendAngle;\n    float bendProgress = CLAMP01((pos.z - bendOrigin.z) / bendLength); // progress value between 0 and 1\n    float alpha = bendAngle * bendProgress;\n    vec3 bendStartPos = vec3(0.0, 0.0, bendOrigin.z);\n    vec3 bendOriginToZAxisNormalized = normalize(vec3(-bendOrigin.xy, 0.0));\n    \n    // unit vectors u, v and w used as referential around the bend circle\n    vec3 u = vec3(0.0, 0.0, cos(alpha)) - sin(alpha) * bendOriginToZAxisNormalized;\n    vec3 v = vec3(0.0, 0.0, sin(alpha)) - cos(alpha) * bendOriginToZAxisNormalized;\n    vec3 w = cross(bendOriginToZAxisNormalized, vec3(0.0, 0.0, 1.0));\n    \n    // position around the bending\n    vec3 bendPos = bendOrigin\n        + cos(alpha) * bendOriginToZAxisNormalized * bendRadius\n        + vec3(0.0, 0.0, sin(alpha) * bendRadius)\n        - dot(pos, bendOriginToZAxisNormalized) * v\n        + dot(pos, w) * w;\n    \n    // position after the bending\n    vec3 postBendPos = bendPos + (pos.z - bendOrigin.z - bendLength) * u;\n\n    // return either the actual position, the position inside the bending or the position after the bending depending on Z\n    return pos.z < bendOrigin.z ? pos :\n        pos.z < bendOrigin.z + bendLength ? bendPos :\n        postBendPos;\n}\n\nfloat sdCylinder( vec3 pos, float radius)\n{\n  return length(pos.xy)-radius;\n}\n\nvec3 raymarch(vec3 pos, vec3 dir, out vec3 uvw)\n{\n    float debug;\n    float signedDistance = 0.0;\n    vec3 bentPos;\n    \n    // setup bending parameters\n    // each time the camera goes through a bending, bendId is incremented and the next bending is placed in the horizon\n    uint bendId = uint(iTime / BEND_PERIOD);\n    vec3 randValues = hashUIntToVec3(bendId);\n    float progress = (iTime - BEND_PERIOD * float(bendId)) / BEND_PERIOD;\n    float bendOriginRho = mix(BEND_RANGE_XY.x, BEND_RANGE_XY.y, randValues.x); // XY polar coordinate rho\n    float bendOriginTheta = randValues.y * M_2PI; // XY polar coordinate theta\n    float bendAngleInitial = mix(BEND_RANGE_ANGLE.x, BEND_RANGE_ANGLE.y, randValues.z);\n    \n    float distanceToBendBeginInitial = BEND_DISTANCE_Z - 2.0 * bendOriginRho * bendAngleInitial;\n    float progressAtBendBegin = distanceToBendBeginInitial / BEND_DISTANCE_Z;\n    float bendAngleActual = bendAngleInitial * CLAMP01(map(progress, progressAtBendBegin, 1.0, 1.0, 0.0));\n    float bendOriginZ = distanceToBendBeginInitial * CLAMP01(map(progress, 0.0, progressAtBendBegin, 1.0, 0.0));\n    vec3 bendOrigin = vec3(bendOriginRho * cos(bendOriginTheta), bendOriginRho * sin(bendOriginTheta), bendOriginZ);\n    \n    \n    for( int i=0; i<70; i++ )\n    {\n        bentPos = bendPosition(pos, vec3(100, 100, 10), M_PI / 4.0);\n        bentPos = bendPosition(pos, bendOrigin, bendAngleActual);\n        signedDistance = -sdCylinder(bentPos, 6.0);\n        pos += dir * signedDistance;\n        if( abs(signedDistance)<(0.0001) )\n        {\n            vec2 bentPosXYNormalized = normalize(bentPos.xy);\n            //uv = vec2(\n            //    mod(bentPos.z, Z_TILING) / Z_TILING,\n            //    map(atan(bentPosXYNormalized.y,bentPosXYNormalized.x), -M_PI, M_PI, 0.0, 1.0));\n            uvw = bentPos;\n            return pos;\n        }\n    }\n    uvw = bentPos;\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uvScreen = fragCoord/iResolution.xy;\n    vec2 posScreen = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // focal length\n    const float focalLength = 3.; // 2.5\n        \n    // ray direction\n    vec3 rayDirection = normalize( vec3(posScreen,focalLength) );\n    vec3 uvw; // 3D texture coordinates\n    vec3 pos = raymarch(vec3(0, 0, 0), rayDirection, uvw);\n    vec2 uv = vec2(map(atan(uvw.y,uvw.x), -M_PI, M_PI, 0.0, 1.0), uvw.z); // 2D texture coordinates\n\n    // pipe color\n    vec3 texScale = vec3(1.0, 1.0, 0.04) * 1.5;\n    vec3 texScroll = vec3(0, 0, TEXTURE_SPEED_FACTOR * iTime * SPEED);\n    float noiseValue = FractalNoise3D(uvw + texScroll, texScale, 6.0);\n    vec3 color = ColorRamp_BSpline(noiseValue,\n#ifdef DARK\n        vec4(ColorRGB(0x70635B), 0.2),\n        vec4(ColorRGB(0x968476), 0.68),\n        vec4(ColorRGB(0xBCA98A), 0.76),\n        vec4(ColorRGB(0xFFFFFF), 0.80));\n#else\n        vec4(ColorRGB(0xB99C89), 0.2),\n        vec4(ColorRGB(0xDCBFA0), 0.68),\n        vec4(ColorRGB(0xFBED82), 0.78),\n        vec4(ColorRGB(0xFFFFFF), 0.81));\n#endif\n    float dist = length(pos);\n    float fogAmount = 1.0 - exp(-dist*FOG_INTENSITY); // simple fog from https://iquilezles.org/articles/fog/\n    color = mix(color, ColorRGB(0x322D0F), fogAmount);\n    \n    // red lights\n    float lightCoord =\n        uv.x * float(NB_LIGHTS) // base coordinate\n        + 0.5 * (2.5 * iTime + 0.5 * sin(2.0 / 3.0 * iTime * M_2PI)) // time offset with oscillation\n        - 0.004 * uv.y // distance offset\n        + 1.0 * FractalNoise3D(uvw + vec3(0.0, 0.0, iTime * SPEED / 4.0), vec3(0.025), 1.0) // noise turbulence low frequency\n        + 0.4 * FractalNoise3D(uvw + vec3(0.0, 0.0, iTime * SPEED / 4.0), vec3(0.25), 2.0) // noise turbulence mid frequency\n        + 0.1 * FractalNoise3D(uvw + vec3(0.0, 0.0, iTime * SPEED / 4.0), vec3(2.5), 2.0);// noise turbulence high frequency\n    float lightIntensity = CLAMP01(map(abs(mod(lightCoord, 1.0) - LIGHT_WIDTH / 2.0), 0.0, LIGHT_WIDTH / 2.0, 1.0, 0.0));\n    vec3 lightColor = ColorRamp_BSpline(lightIntensity,\n#ifdef DARK\n        vec4(ColorRGB(0x000000), 0.0),\n        vec4(ColorRGB(0xC85E52), 0.6),\n        vec4(ColorRGB(0xF3DD5E), 0.9),\n        vec4(ColorRGB(0xFFF0F0), 0.95));\n#else\n        vec4(ColorRGB(0x000000), 0.0),\n        vec4(ColorRGB(0xAD3E30), 0.5),\n        vec4(ColorRGB(0xEDDE9A), 0.9),\n        vec4(ColorRGB(0xFFF0F0), 0.99));\n#endif\n    color += lightColor * lightIntensity;\n    \n    // wave lights\n    float waveCoord = CLAMP01(mod(uvw.z / 1000.0 - iTime * 0.7, 1.0) * 4.0);\n    float waveValue = CLAMP01(parabola(waveCoord, 4.0) * 1.0);\n    color += vec3(waveValue);\n    \n    // output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}