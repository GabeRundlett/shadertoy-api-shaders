{
    "Shader": {
        "info": {
            "date": "1550883096",
            "description": "click for ahe persistent light near the cam\n\nsss light study 9 :)\n\nthumbail at 46.54s\n\ntunes with [url=https://twitter.com/search?q=noodlesplate&src=typd]NoodlesPlate[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WdsSR7",
            "likes": 19,
            "name": "Go little firefly, Go !",
            "published": 3,
            "tags": [
                "sss",
                "pointlight",
                "light",
                "bump",
                "mapping",
                "pattern",
                "planes",
                "firefly"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 800
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - @Aiekick/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/WdsSR7\n\n// click for have persistent light near the cam\n\n// this header will create uniforms widget when imported in NoodlesPlate\n//@UNIFORMS_START\n//uniform vec3(0:1:0.1) _smooth; // smin coef\n//uniform float(0:10:5) dist; // sub surface scattering penetration distance\n//uniform mat4(gizmo) light; // light pos\n//uniform vec3(color:0.7,0.6,0.4) pointColor; // firefly color\n//uniform float(0:0.1:0.001) pointLight; // firefly intensity\n//uniform float(0:10:3) pointRadius; // firefly radius\n//@UNIFORMS_ELSE\nconst vec3 _smooth = vec3(0.1,0.1,0.1);\nconst float dist = 5.0;\nconst mat4 light = mat4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);\nconst vec3 pointColor = vec3(0.7,0.6,0.4);\nconst float pointLight = 0.001;\nconst float pointRadius = 3.;\n//@UNIFORMS_END\n\nfloat pattern(vec3 p)\n{\n\tp = fract(p) - 0.5;\n\treturn smin(smin(abs(p.x), abs(p.y), _smooth.y), abs(p.z), _smooth.y) + 0.56;\n}\n\nvec3 effect(vec3 p) \n{\n    float time = 0.52;\n\tmat3 mx = getRotXMat(-7.*(sin(time*2.)*.5+.5));\n\tmat3 my = getRotYMat(-5.*(sin(time*1.5)*.5+.5));\n\tmat3 mz = getRotZMat(-3.*(sin(time)*.5+.5));\n\t\n\tmat3 m = mx*my*mz;\n\t\n\tfloat d = smin(smin(pattern(p*m), pattern(p*m*m), _smooth.x), pattern(p*m*m*m), _smooth.x);\n    \n    return vec3(d/0.94); \n}\n\nvec4 displacement(vec3 p)\n{\n\tvec3 col = 1.-clamp(effect(p*0.24),0.,1.);\n   \tfloat dist = dot(col,vec3(1.));\n\tcol = step(col, vec3(0.395));\n    return vec4(dist,col);\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\n\t\n    p *= getRotZMat(p.z * 0.1);\n\t\n    vec4 disp = displacement(p);\n    float di = mix(0.8 + disp.x, 2.8 - disp.x, sin(p.z*0.3)*.5+.5);\n\tfloat sp = di - mix(length(p.xy), abs(p.y), sin(p.z*0.1)*.5+.5);\n    return vec4(sp, disp.yzw);\n}\n\n///////////////////////////////////////////\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float prec)\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = calcNormal(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter));\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = calcNormal(p,s);\n\treturn map(p - n * s).x;\n}\n\n// from shane shaders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane shaders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro+rd*d;\n\tvec3 n = calcNormal(p, 0.1);\n\tfloat ao = calcAO(p, n);\n\tfloat sha = softshadow(p, normalize(lp-p), 0.8, 1.0);\n\tfloat sb = SubDensity(p, 0.01, 0.04);\n\tfloat sss = 1. - SubDensity(p, 8.); \t\n\tfloat ks = map(lp).x;\n\tfloat kp = 0.0;\n\tconst float nIter = 10.;\n\tfor (float i=0.;i<nIter;i++)\n\t\tkp += (map(mix(lp,p,i/nIter/nIter)).x);\n\tfloat dCoef = dist;\n\tif (ks < 0.0)\n\t{\n\t\tdCoef *= clamp(kp/nIter*1.5,0.,1.);\n\t\tsha = 1.0;\n\t}\n\telse\n\t{\n\t\tdCoef *= 1.0;\n\t}\n\tfloat atten = clamp(dCoef-length(lp-p),0.0,10.0);\n\tvec3 bb = blackbody(80.*sb+320.);\n\tvec3 ld = normalize(lp-p); \t\n\tn = doBumpMap(iChannel0, p, n, 0.019);\n\tvec3 refl = reflect(rd,n);\t\t\n\tfloat amb = 0.23; \t\t\t\t\t\t\t\t\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ) * sha + ao * 0.5; \n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\n\tvec4 c = vec4(\n        (diff + fre + bb.x * sss) * amb * li + spe, \n        (diff * pointColor + (1.-map(p).yzw*3.) + fre + bb * sb * 0.8 + sss * 0.4) * amb * li + spe * 0.6 \t\n    );\n\treturn c * atten;\n}\n\nfloat march(vec3 ro, vec3 rd, float rmPrec, float maxd, float mapPrec)\n{\n    float s = rmPrec;\n    float d = 0.;\n    for(int i=0;i<100;i++)\n    {      \n        if (d*d/s>1e5||s>maxd) break;\n        s = map(ro+rd*d).x*mapPrec;\n        d += s;\n    }\n    return d;\n}\n\nvec3 DrawPointLight(vec3 ro, vec3 rd, float d, vec3 lp, vec3 lc, float r)\n{\n\tvec3 res = vec3(0);\n\tfloat pld = sphDistance( ro, rd, vec4(lp, r) );\n\tfloat plhit = shpIntersect( ro, rd, vec4(lp, r) );\n\tif (plhit > 0.0)\n\t{\n\t\tvec3 p = ro+rd*pld;\n\t\tfloat len = length(lp-p);\n\t\t\t\n\t\tif (d>len)\n\t\t{\n\t\t\tvec3 k = rd - normalize(lp-ro);\n\t\t\tres += lc * pointLight * (1.-pld / dot(k, k));\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 g = fragCoord.xy;\n    vec2 s = iResolution.xy;\n    \n\tfloat t = iTime * 3.;\n    vec3 ro = vec3(path(t),t);\n\tvec3 cu = vec3(0,1,0);\n  \tvec3 cv = vec3(path(t+1.),t + 1.);\n    \n\tvec3 col = vec3(0.);\n    \n    vec2 uv = (g+g-s)/s.y;\n\t\n  \tvec3 rov = normalize(cv-ro);\n    vec3 u = normalize(cross(cu,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n\tfloat d = march(ro, rd, 0.01, 50., 0.6);\n    \n\tfloat a = iTime * 1.5;\n\tvec3 lp0 = ro + vec3(cos(a),0.,sin(a) + 2.) * 2.;\n    \n\tif (iMouse.z>0.)\n\t{\n\t\tlp0 = ro + vec3(0,0,2);\n\t}\n\t\n    col += shade(ro, rd, d, lp0, 0.25).yzw;\n\tcol += DrawPointLight(ro, rd, d, lp0, pointColor, pointRadius);\n\t\n\tfragColor.rgb = mix(col, 1.-pointColor, 1.0-exp(-0.01*d*d));;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//https://www.shadertoy.com/view/llj3Rz\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float h = dot( oc, oc ) - b*b;\n    return sqrt( max(0.0,h)) - sph.w;\n}\n\n//https://www.shadertoy.com/view/llj3Rz\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( rd, oc );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) h = -b - sqrt( h );\n    return h;\n}\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smin( float a, float b, float k )\n{\n\treturn sminPoly(a,b,k);\n}\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.08), sin(t*0.12)) * 4.;\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}