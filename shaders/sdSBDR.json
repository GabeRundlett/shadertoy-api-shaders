{
    "Shader": {
        "info": {
            "date": "1645978826",
            "description": "You can only think of Halloween until you die.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdSBDR",
            "likes": 8,
            "name": "Snobbish Dream",
            "published": 3,
            "tags": [
                "3d",
                "modeling"
            ],
            "usePreview": 1,
            "username": "IWBTShyGuy",
            "viewed": 332
        },
        "renderpass": [
            {
                "code": "// Copyright Â© 2022 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n/*** configure ***/\nstruct Wall {\n    vec3 origin;\n    vec3 normal;\n};\n\nconst float EPS = 1.0e-4;\nconst float FLOOR_INTERVAL = 2.0;\nconst Wall LEFT_WALL = Wall(vec3(-1, 0, 0), vec3(1, 0, 0));\nconst Wall RIGHT_WALL = Wall(vec3(1, 0, 0), vec3(-1, 0, 0));\nconst vec3 SHELF_UNIT = vec3(0.3, 0.3, 0.9);\nconst float SHELF_THICK = 0.05;\nconst vec3 SHELF_UNIT_WITH_THICK = SHELF_UNIT + SHELF_THICK;\n\nconst vec2 NUM_BOOK_RANGE = vec2(12.0, 36.0);\nconst vec2 BOOK_MIN_SIZE = vec2(0.105, 0.148); // A6\nconst vec2 BOOK_MAX_SIZE = vec2(0.210, 0.297); // A4\nconst vec3 BOOK_COLOR_RATIO = vec3(1.0, 0.8, 0.8);\n\n// walk settings\nconst float WALK_BASE_HEIGHT = 1.4;\nconst float WALK_STRIDE = 0.3;\nconst float WALK_PERIOD = 0.75;\nconst float WALK_TIME = WALK_PERIOD * 5.0;\nconst float WALK_AMPT = 0.05;\nconst float WALK_HEIGHT_AMPT = 0.01;\n\n// look around\nconst float LOOKAROUND_TIME = 10.0;\n\n// gaze from far\nconst vec3 GAZE_POSITION = vec3(-5.0, 100.0, 100.0);\nconst float GAZE_TIME = (WALK_TIME + LOOKAROUND_TIME) * 2.0 - WALK_TIME - 0.12 * LOOKAROUND_TIME;\n\nconst float SCENE_PERIOD = (WALK_TIME + LOOKAROUND_TIME) * 2.0 + WALK_TIME + 0.12 * LOOKAROUND_TIME + GAZE_TIME;\n\n/*** 3D toolkit ***/\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nvec2 dCosTheta(in vec2 uv, in float fov) {\n    Camera cam = Camera(\n        vec3(0, 0, 0),\n        vec3(0, 0, 1),\n        vec3(0, 1, 0),\n        fov,\n        iResolution.x / iResolution.y\n    );\n    vec3 e = vec3(1, 1, 0) / iResolution;\n    Ray ray = cameraRay(cam, uv);\n    Ray rayx = cameraRay(cam, uv + e.xz);\n    Ray rayy = cameraRay(cam, uv + e.zy);\n    return vec2(\n        dot(ray.direction, rayx.direction),\n        dot(ray.direction, rayy.direction)\n    );\n}\n\nfloat microfacet(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = clamp(-dot(normal, middle), 0.0, 1.0);\n    float dotCM = clamp(dot(cameraDir, middle), 0.0, 1.0);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\n/*** integer hash ***/\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    const uint k = 1103515245U;\n    x.y = ((x.y>>8U)^x.y)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 noise31(float x) {\n    uint s = uint(int(floor(x)) + 2147483647);\n    float t = fract(x);\n    return mix(hash(uvec3(s)), hash(uvec3(s + 1u)), t);\n}\n\n\nvec3 noise32(vec2 x) {\n    uvec3 s = uvec3(ivec2(floor(x)) + 2147483647, 1);\n    vec2 t = fract(x);\n    uvec2 e = uvec2(0, 1);\n    return mix(\n        mix(hash(s + e.xxx), hash(s + e.yxx), t.x),\n        mix(hash(s + e.xyx), hash(s + e.yyx), t.x),\n        t.y\n    );\n}\n\nvec2 noise22(vec2 x) {\n    return noise32(x).xy;\n}\n\nvec3 noise33(vec3 x) {\n    uvec3 s = uvec3(ivec3(floor(x)) + 2147483647);\n    vec3 t = fract(x);\n    uvec2 e = uvec2(0, 1);\n    return mix(\n        mix(\n            mix(hash(s + e.xxx), hash(s + e.yxx), t.x),\n            mix(hash(s + e.xyx), hash(s + e.yyx), t.x),\n            t.y\n        ),\n        mix(\n            mix(hash(s + e.xxy), hash(s + e.yxy), t.x),\n            mix(hash(s + e.xyy), hash(s + e.yyy), t.x),\n            t.y\n        ),\n        t.z\n    );\n}\n\nfloat noise13(vec3 x) {\n    return noise33(x).x;\n}\n\n#define three_mix(a0, a1, a2, t) (\\\n      a0 * (1.0 - t) * (1.0 - t) * 0.5\\\n    + a1 * ((t + 1.0) * (1.0 - t) + t * (2.0 - t)) * 0.5\\\n    + a2 * t * t * 0.5\\\n)\n\nvec3 smoothnoise32(vec2 x) {\n    const int k = 2147483647;\n    uvec2 s = uvec2(ivec2(floor(x)) + k);\n    vec2 t = fract(x);\n    uvec3 e = uvec3(0, 1, 2);\n    return three_mix(\n        three_mix(\n            hash(uvec3(s - e.zz, k)),\n            hash(uvec3(s - e.yz, k)),\n            hash(uvec3(s - e.xz, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zy, k)),\n            hash(uvec3(s - e.yy, k)),\n            hash(uvec3(s - e.xy, k)),\n            t.x\n        ),\n        three_mix(\n            hash(uvec3(s - e.zx, k)),\n            hash(uvec3(s - e.yx, k)),\n            hash(uvec3(s - e.xx, k)),\n            t.x\n        ),\n        t.y\n    );\n}\n\nvec3 fbm325(in vec2 uv) {\n    float a = 0.5;\n    vec3 res = vec3(0);\n    for (int i = 0; i < 5; i++) {\n        res += noise32((a *= 2.0) * uv);\n    }\n    return res;\n}\n\nvec3 smoothfbm325(in vec2 uv) {\n    float a = 0.5;\n    vec3 res = vec3(0);\n    for (int i = 0; i < 5; i++) {\n        res += smoothnoise32((a *= 2.0) * uv);\n    }\n    return res;\n}\n\n/*** main ***/\nfloat dCosThetax;\n\nvec2 bookSize(in vec3 p) {\n    vec2 r = noise22(floor(p.yz / SHELF_UNIT_WITH_THICK.yz));\n    return mix(BOOK_MIN_SIZE, BOOK_MAX_SIZE, r);\n}\n\nstruct Hit {\n    vec3 position;\n    vec2 uv;\n    vec3 normal;\n};\n\nconst Hit UNHIT = Hit(vec3(0), vec2(0), vec3(0));\n\nHit hitBox(in Ray ray, vec3 boxSize) {\n    vec3 m = 1.0 / ray.direction, n = m * ray.origin,\n    k = abs(m) * boxSize, t1 = - n - k, t2 = - n + k;\n    float tN = max(max(t1.x, t1.y), t1.z),\n    tF = min(min(t2.x, t2.y), t2.z);\n    vec3 p = ray.origin + tN * ray.direction,\n    uv = (1.0 + p / boxSize) / 2.0,\n    e = sign(p);\n    if(tN > tF || tF < 0.0) return UNHIT;\n    else if (t1.x == tN) return Hit(p, uv.yz, vec3(e.x, 0.0, 0));\n    else if (t1.y == tN) return Hit(p, uv.zx, vec3(0, e.y, 0));\n    else return Hit(p, uv.xy, vec3(0, 0, e.z));\n}\n\nHit hitFloor(in Ray ray) {\n    if (abs(ray.direction.y) < EPS) return UNHIT;\n    float t = -(ray.origin.y + SHELF_THICK) / ray.direction.y;\n    vec3 p = ray.origin + t * ray.direction;\n    if (t > 0.0 && abs(p.x) < FLOOR_INTERVAL * 0.5)\n        return Hit(p, p.zx, vec3(0, 1, 0));\n    else return UNHIT;\n}\n\nHit hitWall(in Ray ray, in Wall wall) {\n    float dotRN = dot(ray.direction, wall.normal);\n    if (abs(dotRN) < EPS) return UNHIT;\n    float distRW = dot(wall.origin - ray.origin, wall.normal),\n    t = distRW / dotRN;\n    if (t < 0.0) return UNHIT;\n    vec3 p = ray.origin + t * ray.direction;\n    return Hit(p, vec2(0), wall.normal);\n}\n\nHit hitUniformBook(in Ray ray, in Hit wall_hit) {\n    vec3 p = wall_hit.position;\n    vec2 bookSize = bookSize(p);\n    vec3 booksCenter = vec3(\n        sign(p.x) * (FLOOR_INTERVAL * 0.5 + SHELF_UNIT.x - bookSize.x / 2.0),\n        floor(p.y / SHELF_UNIT_WITH_THICK.y) * SHELF_UNIT_WITH_THICK.y + bookSize.y / 2.0,\n        floor(p.z / SHELF_UNIT_WITH_THICK.z) * SHELF_UNIT_WITH_THICK.z + SHELF_UNIT.z / 2.0\n    );\n    ray.origin -= booksCenter;\n    Hit hit = hitBox(ray, vec3(bookSize, SHELF_UNIT.z) / 2.0);\n    if (hit != UNHIT) hit.position += booksCenter;\n    return hit;\n}\n\nHit hitShelf(in Ray ray, in Hit wall_hit) {\n    vec3 d = ray.direction, p = wall_hit.position, e = sign(d),\n    u = mod(p, SHELF_UNIT_WITH_THICK),\n    t = vec3(\n        SHELF_UNIT.x / abs(d.x),\n        abs(SHELF_UNIT.y * 0.5 / d.y) - (u.y - SHELF_UNIT.y * 0.5) / d.y,\n        abs(SHELF_UNIT.z * 0.5 / d.z) - (u.z - SHELF_UNIT.z * 0.5) / d.z\n    );\n    if (u.z > SHELF_UNIT.z || u.y > SHELF_UNIT.y)\n        return Hit(p, u.zy / SHELF_UNIT_WITH_THICK.yz, vec3(-e.x, 0, 0));\n    float tMin = min(min(t.x, t.y), t.z);\n    p += tMin * d;\n    u = fract(vec3(abs(p.x) - FLOOR_INTERVAL * 0.5, p.yz) / SHELF_UNIT_WITH_THICK);\n    if (t.x == tMin) return Hit(p, u.zy, vec3(-e.x, 0, 0));\n    else if (t.y == tMin) return Hit(p, u.zx, vec3(0, -e.y, 0));\n    else return Hit(p + t.z * ray.direction, u.xy, vec3(0, 0, -e.z));\n}\n\nHit hitScene(in Ray ray) {\n    Hit hit = hitFloor(ray);\n    if (hit != UNHIT) return hit;\n    hit = hitWall(ray, RIGHT_WALL);\n    if (hit != UNHIT) {\n        Hit hBook = hitUniformBook(ray, hit);\n        Hit hShelf = hitShelf(ray, hit);\n        float distBook = distance(ray.origin, hBook.position);\n        float distShelf = distance(ray.origin, hShelf.position);\n        if (hBook != UNHIT && distBook < distShelf) return hBook;\n        else return hShelf;\n    }\n    hit = hitWall(ray, LEFT_WALL);\n    if (hit != UNHIT) {\n        Hit hBook = hitUniformBook(ray, hit);\n        Hit hShelf = hitShelf(ray, hit);\n        float distBook = distance(ray.origin, hBook.position);\n        float distShelf = distance(ray.origin, hShelf.position);\n        if (hBook != UNHIT && distBook < distShelf) return hBook;\n        else return hShelf;\n    }\n    return UNHIT;\n}\n\nfloat shadow(in vec3 p, in vec3 lightPos) {\n    Ray ray = Ray(lightPos, normalize(p - lightPos));\n    Hit hit = hitScene(ray);\n    return distance(hit.position, p) < EPS ? 1.0 : 0.0;\n}\n\nfloat cloth(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = clamp(-dot(normal, middle), 0.0, 1.0);\n    float dotCM = clamp(dot(cameraDir, middle), 0.0, 1.0);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // distribution by Imageworks\n    float distribution = dotNM * (1.0 + 0.5 / alpha) * pow(1.0 - dotNM * dotNM, 0.5 / alpha);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    float tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\nvec3 colorFloor(in Ray ray, in Hit hit, in vec3 lightPos) {\n    vec3 p = hit.position, dir = p - lightPos;\n    if (abs(p.x) < 0.7) {\n        float k = abs(abs(p.x) - 0.6);\n        k = smoothstep(0.02, 0.01, k);\n        float c = cloth(\n            normalize(vec3(0, 1, 0) + 0.25 * (2.0 * fbm325(p.zx * 10.0) / 5.0 - 1.0)),\n            ray.direction,\n            normalize(dir),\n            0.9,\n            0.5\n        ) / dot(dir, dir);\n        return clamp(c, 0.0, 1.0) * vec3(252.0 / 255.0, k, 0);\n    } else {\n        float c = microfacet(\n            vec3(0, 1, 0),\n            ray.direction,\n            normalize(dir),\n            0.1,\n            0.7\n        ) / dot(dir, dir);\n        return clamp(c, 0.0, 1.0) * texture(iChannel0, fract(p.zx)).xyz;\n    }\n}\n\nvec3 colorUniformBook(in Ray ray, in Hit hit, in vec3 lightPos) {\n    vec3 p = hit.position, dir = p - lightPos, normal = hit.normal, col = vec3(1);\n    vec2 gen = floor(p.yz / SHELF_UNIT_WITH_THICK.yz);\n    float s = sign(hit.position.x), r = noise13(vec3(gen, 12.0 * s)),\n    nBooks = floor(mix(NUM_BOOK_RANGE.x, NUM_BOOK_RANGE.y, r));\n    if (normal.x != 0.0) {\n        r = fract(hit.uv.y * nBooks);\n        float sinAlpha = -dot(ray.direction, normal);\n        float du = distance(p, ray.origin) * sqrt(1.0 - dCosThetax * dCosThetax) / sinAlpha;\n        float a = smoothstep(SHELF_UNIT.z / nBooks, 0.0, 2.0 * du);\n        normal = normalize(normal + vec3(0, 0, a * sin(2.0 * (r - 0.5))));\n        col = noise33(vec3(gen, 16.0 * s)) * BOOK_COLOR_RATIO\n            * (0.6 + 0.4 * texture(iChannel1, hit.uv).xyz);\n    } else {\n        r = fract(hit.uv.x * nBooks);\n        float sinAlpha = -dot(ray.direction, normal);\n        float du = distance(p, ray.origin) * sqrt(1.0 - dCosThetax * dCosThetax) / sinAlpha;\n        float a = smoothstep(SHELF_UNIT.z / nBooks, 0.0, 2.0 * du);\n        if (fract(r + 0.005 * nBooks) < 0.01 * nBooks || hit.uv.y > 0.95)\n            col = 1.0 - a * (1.0 - noise33(vec3(gen, 16.0 * s)) * BOOK_COLOR_RATIO);\n        normal = normalize(normal - vec3(0, 0, a * 0.5 * sin(r - 0.5)));\n    }\n    float t = distance(ray.origin, hit.position),\n    c = 0.5 * microfacet(\n        normal,\n        ray.direction,\n        normalize(dir),\n        0.05,\n        0.7\n    ) / dot(dir, dir) * shadow(p, lightPos);\n    c += 0.5 * microfacet(\n        normal,\n        ray.direction,\n        ray.direction,\n        0.05,\n        0.7\n    ) / (1.0 + t * t);\n    return clamp(c, 0.0, 1.0) * col;\n}\n\nvec3 colorShelf(in Ray ray, in Hit hit, in vec3 lightPos) {\n    vec3 dir = hit.position - lightPos;\n    float t = distance(ray.origin, hit.position),\n    c = 0.5 * microfacet(\n        hit.normal,\n        ray.direction,\n        normalize(dir),\n        0.1,\n        0.7\n    ) / dot(dir, dir) * shadow(hit.position, lightPos);\n    c += 0.5 * microfacet(\n        hit.normal,\n        ray.direction,\n        ray.direction,\n        0.1,\n        0.7\n    ) / (1.0 + t * t);\n    return clamp(c, 0.0, 1.0) * pow(texture(iChannel0, hit.uv).xyz, vec3(2.2));\n}\n\nfloat directLight(in vec3 lightPos, in Ray ray) {\n    vec3 ol = lightPos - ray.origin;\n    float t = dot(ol, ray.direction);\n    if (t < 0.0) return 0.0;\n    vec3 h = ol - t * ray.direction;\n    return 5.0e-4 / dot(h, h);\n}\n\nvec3 sceneColor(in Ray ray, in vec3 lightPos) {\n    Hit hit = hitFloor(ray);\n    if (hit != UNHIT) return colorFloor(ray, hit, lightPos);\n    hit = hitWall(ray, RIGHT_WALL);\n    if (hit != UNHIT) {\n        Hit hBook = hitUniformBook(ray, hit);\n        Hit hShelf = hitShelf(ray, hit);\n        float distBook = distance(ray.origin, hBook.position);\n        float distShelf = distance(ray.origin, hShelf.position);\n        if (hBook != UNHIT && distBook < distShelf)\n            return colorUniformBook(ray, hBook, lightPos);\n        else return colorShelf(ray, hShelf, lightPos);\n    }\n    hit = hitWall(ray, LEFT_WALL);\n    if (hit != UNHIT) {\n        Hit hBook = hitUniformBook(ray, hit);\n        Hit hShelf = hitShelf(ray, hit);\n        float distBook = distance(ray.origin, hBook.position);\n        float distShelf = distance(ray.origin, hShelf.position);\n        if (hBook != UNHIT && distBook < distShelf)\n            return colorUniformBook(ray, hBook, lightPos);\n        else return colorShelf(ray, hShelf, lightPos);\n    }\n    return vec3(0);\n} \n\nvec3 cameraPos(in float t) {\n    if (mod(t, SCENE_PERIOD) < SCENE_PERIOD - GAZE_TIME) {\n        float bt = floor(t / (WALK_TIME + LOOKAROUND_TIME)) * WALK_TIME,\n        dt = mod(t, WALK_TIME + LOOKAROUND_TIME);\n        t = bt + min(dt, WALK_TIME);\n        float it = floor(t / WALK_PERIOD), ft = fract(t / WALK_PERIOD);\n        return vec3(\n            WALK_AMPT * cos(PI * t / WALK_PERIOD),\n            WALK_BASE_HEIGHT + WALK_HEIGHT_AMPT * abs(sin(PI * t / WALK_PERIOD)),\n            -WALK_STRIDE * (it + smoothstep(0.0, 1.0, ft))\n        );\n    } else {\n        return GAZE_POSITION;\n    }\n}\n\nvec3 cameraDir(in float t) {\n    if (mod(t, SCENE_PERIOD) < SCENE_PERIOD - GAZE_TIME) {\n        float dt = mod(t, WALK_TIME + LOOKAROUND_TIME);\n        vec3 dir = vec3(0, 0, -1);\n        if (dt > WALK_TIME) {\n            int signum = int(t / (WALK_TIME + LOOKAROUND_TIME)) % 2;\n            dt = (dt - WALK_TIME) / LOOKAROUND_TIME;\n            dt = smoothstep(0.0, 0.125, dt) * 0.125\n                    + smoothstep(0.125, 0.375, dt) * 0.25 \n                    + smoothstep(0.375, 0.625, dt) * 0.25\n                    + smoothstep(0.625, 0.875, dt) * 0.25\n                    + smoothstep(0.875, 1.0, dt) * 0.125;\n            dt += (signum == 1 ? 0.25 : 0.75);\n            vec2 disp = vec2(cos(2.0 * PI * dt), 1.5 * sin(-4.0 * PI * dt));\n            dir += 0.25 * vec3(disp, 0);\n        }\n        return normalize(dir + 0.02 * fbm325(vec2(t * 0.05, 1.0)) / 5.0 - 0.01);\n    } else {\n        return vec3(1, 0, 0);\n    }\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    float fov = PI / 3.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    Camera camera = Camera(\n        cameraPos(iTime),\n        cameraDir(iTime),\n        vec3(0, 1, 0),\n        fov,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, uv);\n    dCosThetax = dCosTheta(uv, fov).x;\n\n    vec3 lightPos;\n    if (mod(iTime, SCENE_PERIOD) < SCENE_PERIOD - GAZE_TIME) {\n        lightPos = vec3(\n            0.5 * cos(iTime),\n            WALK_BASE_HEIGHT + 0.5 * sin(0.333 * iTime),\n            ray.origin.z - 1.5 + 0.5 * sin(0.5 * iTime)\n        );\n    } else {\n        lightPos = GAZE_POSITION + vec3(\n            3.0,\n            1.5 * sin(iTime),\n            1.5 * cos(iTime * 0.5)\n        );\n    }\n    \n\n    vec3 col = sceneColor(ray, lightPos);\n    if (mod(iTime, SCENE_PERIOD) > SCENE_PERIOD - GAZE_TIME) {\n        col *= 37.5;\n    }\n    col += directLight(lightPos, ray);\n\n    float ft = mod(iTime, SCENE_PERIOD);\n    col *= smoothstep(0.0, 0.5, ft)\n            * smoothstep(0.0, 0.5, abs(ft + GAZE_TIME - SCENE_PERIOD))\n            * smoothstep(SCENE_PERIOD, SCENE_PERIOD - 0.5, ft);\n\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1);\n}\n\n#define AA 3\nvoid mainImage(out vec4 O, in vec2 U) {\n    mainImage0(O, U);\n    \n    // smart anti-aliasing\n    // reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n    // If defined, visualize anti-aliased pixels.\n    //#define VISUALIZE_AA\n    #ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n        vec4 o;\n    #if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += o;\n        }\n        O /= 5.0;\n    #elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += o;\n        }\n        O /= 9.0;\n    #endif\n    #ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n    #endif\n    }\n    #endif\n    O.xyz = pow(O.xyz, vec3(.4545));\n    O.w = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}