{
    "Shader": {
        "info": {
            "date": "1457307637",
            "description": "Useful for debugging your analytic derivative. When noise is layered, scaled, and rotated, it become very difficult to make sure your resulting final analytic derivative is computed properly. Therefore this shader, to visualize it.",
            "flags": 0,
            "hasliked": 0,
            "id": "lscSzn",
            "likes": 25,
            "name": "Analytic Derivative Viewer3D",
            "published": 3,
            "tags": [
                "noise",
                "antialiasing",
                "derivative",
                "analytic"
            ],
            "usePreview": 1,
            "username": "Bers",
            "viewed": 1286
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : May 2015\n// Modified : Feb 2016\n//\n// This shader was written with the intent of easing the pain of finding and validating \n// analytic derivatives. I had decided to do this after having read an interesting article, from Inigo Quilez :\n// https://iquilezles.org/articles/morenoise\n//\n// Although deriving a function in a theorical context is not so difficult, it can still \n// quickly become an overwhelming task if you stack up multiple layers of rotated, scaled, and distorted noise.\n// How do you rotate the derivatives, do you simply rotate the gradient in the same direction as the noise function?\n// What do you do with time multiplier, is it always derived as a constant factor?\n// Do you also have to derive the bilinear / trilinear equation, or just the ease function?\n// \n// One way to check you did not do any error is to visualize the final result.\n//\n// License : Creative Commons Non-commercial (NC) license\n\n// Of course, you could also skip all that and get Matlab or Maple...\n\n//----------------------\n// Constants\nconst float LINE_WIDTH = 0.18; //From 0.0 to 1.0\nconst float AXIS_WIDTH = 0.035;\nconst float AXIS_LEN   = 0.5;\nconst float CELL_SIZE  = 2.25;\nconst int MAT_GROUND = 0;\nconst int MAT_AXIS   = 1;\nconst int MAT_SKY    = 2; \n\n//----------------------\n// Globals\nmat2 m2,m2t;\nfloat DOMAIN_SCALING   = 12.0;\n\nvec4 trilinearNoiseDerivative(vec3 p)\n{\n    p /= DOMAIN_SCALING;\n    const float TEXTURE_RES = 256.0; //Noise texture resolution\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    vec2 layer_translation = -pixCoord.z*vec2(37.0,17.0)/TEXTURE_RES; //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels -> this is no keypad smashing, but the actual translation embedded in the noise texture).\n    \n    vec2 c1 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,0)+0.5)/TEXTURE_RES,-100.0).xy;\n    vec2 c2 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,0)+0.5)/TEXTURE_RES,-100.0).xy; //+x\n    vec2 c3 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,1)+0.5)/TEXTURE_RES,-100.0).xy; //+z\n    vec2 c4 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,1)+0.5)/TEXTURE_RES,-100.0).xy; //+x+z\n    \n    vec3 x = p-pixCoord;     //Pixel interpolation position, linear range [0-1] (fractional part)\n    vec3 t = (3.0 - 2.0 * x) * x * x;\n    \n    //Lower quad corners\n    float a = c1.x; //(x+0,y+0,z+0)\n    float b = c2.x; //(x+1,y+0,z+0)\n    float c = c3.x; //(x+0,y+1,z+0)\n    float d = c4.x; //(x+1,y+1,z+0)\n    \n    //Upper quad corners\n    float e = c1.y; //(x+0,y+0,z+1)\n    float f = c2.y; //(x+1,y+0,z+1)\n    float g = c3.y; //(x+0,y+1,z+1)\n    float h = c4.y; //(x+1,y+1,z+1)\n    \n    //Trilinear noise interpolation : (1-t)*v1+(t)*v2, repeated along the 3 axis of the interpolation cube.\n    float za = ((a+(b-a)*t.x)*(1.-t.y)\n               +(c+(d-c)*t.x)*(   t.y));\n    float zb = ((e+(f-e)*t.x)*(1.-t.y)\n               +(g+(h-g)*t.x)*(   t.y));\n    float value = (1.-t.z)*za+t.z*zb;\n    \n    //Derivative scaling\n    float sx =  ((b-a)+t.y*(a-b-c+d))*(1.-t.z)\n               +((f-e)+t.y*(e-f-g+h))*(   t.z);\n    float sy =  ((c-a)+t.x*(a-b-c+d))*(1.-t.z)\n               +((g-e)+t.x*(e-f-g+h))*(   t.z);\n    float sz =  zb-za;\n    \n    //Ease-in ease-out derivative : (3x^2-2x^3)' = 6x-6x^2\n    vec3 dxyz = 6.*x*(1.-x);\n    \n    return vec4(value*DOMAIN_SCALING,\n\t            vec3(dxyz.x*sx,\n                     dxyz.y*sy,\n                     dxyz.z*sz));\n}\n\nstruct FuncValue\n{\n\tfloat height;\n    float dh_dx;\n    float dh_dz;\n};\n    \n//----------------------\n// Surface Definition\nFuncValue evalSurface(vec2 p_xz, float fTime)\n{\n    FuncValue val;\n    vec4 h_dx_dy_dz = trilinearNoiseDerivative(vec3(p_xz.x,DOMAIN_SCALING*iTime*0.2,p_xz.y));\n    val.height = h_dx_dy_dz[0];\n    val.dh_dx  = h_dx_dy_dz[1];\n    //val.dh_dy  = h_dx_dy_dz[2];\n    val.dh_dz  = h_dx_dy_dz[3];\n    return val;\n}\n\nstruct SurfaceAxis\n{\n    vec3 normal;\n    vec3 tangent;\n    vec3 binormal;\n    vec3 pos;\n};\n\nSurfaceAxis computeSurfaceVectors(vec2 p)\n{\n    vec2 rp = m2*p; //rotated point\n    FuncValue val = evalSurface(rp, iTime);\n\tvec2 dx = m2t*vec2(1,0); //rotated x+ vector\n\tvec2 dz = m2t*vec2(0,1); //rotated z+ vector\n    SurfaceAxis surfAxis;\n\tsurfAxis.tangent  = normalize(vec3(dx[0],val.dh_dx,dx[1]));\n\tsurfAxis.binormal = normalize(vec3(dz[0],val.dh_dz,dz[1]));\n    surfAxis.normal   = cross(surfAxis.binormal, surfAxis.tangent);\n\tsurfAxis.pos      = vec3(p, val.height).xzy;\n    return surfAxis;\n}\n\nvec3 textureGrid(vec2 uv, float eps)\n{\n    uv = m2*uv;\n    float Ix = smoothstep(0.5*(LINE_WIDTH-eps),0.5*(LINE_WIDTH+eps),abs(fract(uv.x)-0.5));\n    float Iy = smoothstep(0.5*(LINE_WIDTH-eps),0.5*(LINE_WIDTH+eps),abs(fract(uv.y)-0.5));\n    return vec3(Ix*Iy);\n}\n\nstruct Cell\n{\n    vec2 localSample;\n    vec2 center;\n};\n    \nCell repeat(vec2 p, vec2 cellSize)\n{\n    Cell cell;\n    cell.localSample = (fract(p/cellSize+0.5)-0.5)*cellSize;\n    cell.center = p-cell.localSample;\n    return cell;\n}\n\nfloat distanceToLineSeg3D(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    vec3 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nstruct HitInfo\n{\n    float d;\n    int matID;\n};\n    \nHitInfo map(vec3 p)\n{\n    SurfaceAxis surfInfo = computeSurfaceVectors(p.xz);\n\tfloat dSurf = dot((p-surfInfo.pos),surfInfo.normal);\n    \n    Cell probeCell = repeat(p.xz, vec2(CELL_SIZE));\n    p.xz = probeCell.localSample;\n    SurfaceAxis surfAxis = computeSurfaceVectors(probeCell.center);\n    vec3 pAxis = vec3(0,surfAxis.pos.y,0);\n        \n    float d1 = distanceToLineSeg3D(p,pAxis+surfAxis.normal *AXIS_LEN,pAxis-surfAxis.normal *AXIS_LEN)-AXIS_WIDTH;\n    float d2 = distanceToLineSeg3D(p,pAxis+surfAxis.tangent*AXIS_LEN,pAxis-surfAxis.tangent*AXIS_LEN)-AXIS_WIDTH;\n    float d3 = distanceToLineSeg3D(p,pAxis+surfAxis.binormal*AXIS_LEN,pAxis-surfAxis.binormal*AXIS_LEN)-AXIS_WIDTH;\n    float dAxis = min(min(d1,d2),d3); \n    \n    HitInfo info;\n    info.d = min(dSurf,dAxis);\n    info.matID = (dSurf<dAxis)?MAT_GROUND:MAT_AXIS;    \n    return info;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\nfloat softProjLight( vec3 o, vec3 L, vec3 N)\n{\n    float coneWidth   = 0.1;\n    float minAperture = 1.0; \n    float t = 0.001;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 p = o+L*t;\n        float dist = map( p ).d;\n        float curAperture = dist/t;\n        minAperture = min(minAperture,curAperture);\n        t += 0.05+dist;\n    }\n    return saturate(minAperture/coneWidth)*dot(L,N);\n}\n\nfloat itCount = 0.0;\nHitInfo rayMarch(vec3 o, vec3 d)\n{\n    const float tMax = 75.0;\n    float t = 0.0;\n    for(int i=0; i < 40; ++i)\n    {\n        itCount += 1.0;\n        float d = map(o+t*d).d;\n        t += d>0.?d:0.75*d;\n        if(abs(d)<0.001 || t > tMax)\n            break;\n    }\n    \n    HitInfo info = map(o+t*d);\n    info.matID = (t>tMax)?MAT_SKY:info.matID;\n    info.d = min(t,tMax);\n    return info;\n}\n\nvec3 apply_atmosphere(float travelDist, vec3 color, vec3 p)\n{\n    //From this nice article on fog:\n    //https://iquilezles.org/articles/fog\n    //or this PowerPoint from Crytek:\n\t//GDC2007_RealtimeAtmoFxInGamesRev.ppt p17\n\tvec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*p.y/length(p.xz),0.,1.));\n    float c = 15.68;\n    float b = 0.001;\n\n    float cumul_density = c * exp(-1.0*b) * (1.0-exp( -travelDist*1.0*b ))/1.0;\n    cumul_density = clamp(cumul_density,0.0,1.0);\n    vec3 FinalColor = mix(color,c_atmosphere,cumul_density);\n    return FinalColor;\n}\n\n#define m2Transpose(m) mat2(m[0][0],m[1][0],m[0][1],m[1][1])\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.xx;\n    float t = 12.+iTime*0.35;\n    DOMAIN_SCALING *= (1.0+0.8*sin(t));\n    \n    m2  = mat2(cos(t),-sin(t),sin(t),cos(t));\n\tm2t = m2Transpose(m2);\n    \n    vec3 camR = vec3(1,0,0);\n    vec3 camU = vec3(0,1,0);\n    vec3 camD = vec3(0,0,-1);\n    vec3 dir  = normalize(uv.x*camR+uv.y*camU+camD);\n\tvec3 vpos = vec3(0,evalSurface(vec2(0), t).height,0)+4.5;\n    \n    HitInfo hit = rayMarch(vpos, dir);\n    \n    vec3 p = vpos+hit.d*dir;\n    vec3 c = vec3(0);\n    if     (hit.matID == MAT_SKY    ) c = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*p.y/length(p.xz),0.,1.));\n    else if(hit.matID == MAT_GROUND ) c = textureGrid(16.0*p.xz/DOMAIN_SCALING,0.1+0.0025*hit.d).xyz;\n    else if(hit.matID == MAT_AXIS )   c = vec3(1,0,0);\n    \n    if(hit.matID != MAT_SKY)\n    {\n        vec3  L = vec3(-0.31, 0.924, -0.23);\n        float I = softProjLight(p, L, computeSurfaceVectors(p.xz).normal);\n        c *= (0.25+0.75*I);\n        c = apply_atmosphere(hit.d,c,p);\n    }\n    \n    fragColor = vec4(c,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}