{
    "Shader": {
        "info": {
            "date": "1676753694",
            "description": "Not so useful for calculations, but this is one way to go about antialiasing an angular gradient.",
            "flags": 0,
            "hasliked": 0,
            "id": "DlSXDd",
            "likes": 16,
            "name": "Antialiased atan2",
            "published": 3,
            "tags": [
                "antialiasing",
                "aa",
                "angle",
                "atan2"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 381
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926536\n#define RHO 1.5707963268\n\n// atan2(x, y) = abs(atan(abs(y / x)) + PI * min(0, sign(x))) * sign(y)\n// sign(y) causes the discontinuity so we just need a smooth sign function\n// for example, a smoothstep mapped from -1 to 1\nfloat satan(in vec2 p, in float w) { // :)\n    float a = abs(p.x) < 1e-8 ? RHO : atan(abs(p.y / p.x));\n    float sy = 2.0 * smoothstep(-w, w, p.y) - 1.0;\n    return abs(a + PI * min(0.0, sign(p.x))) * sy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 1.0 / iResolution.y;\n\n    float rot = 0.1 * iTime;\n    float co = cos(rot), si = sin(rot);\n    uv *= mat2(co, -si, si, co);\n\n    fragColor = vec4(0.5 + 0.5 * satan(uv, unit) / PI);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}