{
    "Shader": {
        "info": {
            "date": "1626923274",
            "description": "A Shader I made in 2008. While not my first raymarched SDF, this was my first SDF based content creation exercise. Lots of the usual SDF techniques are used, although soft shadows and smooth minimum were not fully evolved yet.",
            "flags": 0,
            "hasliked": 0,
            "id": "NtlSDs",
            "likes": 102,
            "name": "Slisesix (2008)",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield",
                "sdf",
                "demoscene"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 5994
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2021 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n// -------------------------------------------------------\n\n// I made this shader in 2008 for the Euskal Party\n// competition in Spain. The original Pouet entry is \n// here: https://www.pouet.net/prod.php?which=51074\n\n// It's a raymarched SDF, and while I had raymarched some\n// fractal SDFs back in 2005, this was the first time I\n// used the technique to produce art-directed content and\n// \"paint with maths\" (as opposed to doing \"mathematical art\").\n\n// This is also the shader where I first used the now\n// popular ambient occlusion estimation. You'll also find\n// my first attemtps at smooth-minumum (used to blend the\n// creature's head and tentacles together), and soft \n// shadows (still not as good as the ones we use today).\n// You'll find most of the other usual Shadertoy/raymarching\n// stuff - domain repetition, Value Noise, box SDFs and of\n// course the raymarching machinery.\n\n// Surprisngly, copying the code from my original project\n// to Shadertoy here required very little modifications.\n\n\n#define AA 1\n\n#define ZERO min(iFrame,0)\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// https://iquilezles.org/articles/sfrand\nfloat sfrand( inout int mirand )\n{\n    mirand = mirand*0x343fd+0x269ec3;\n    float res = uintBitsToFloat((uint(mirand)>>9)|0x40000000u ); \n    return( res-3.0 );\n}\n\n// hash by Hugo Elias\nuint ihash( uint n )\n{\n\tn = (n << 13) ^ n;\n    n = (n*(n*n*15731u+789221u)+1376312589u)&0x7fffffffu;\n    return n;\n}\n\n// hash by Hugo Elias\nfloat hash( int n )\n{\n\tn = (n << 13) ^ n;\n    n = (n*(n*n*15731+789221)+1376312589)&0x7fffffff;\n    return 1.0 - float(n)*(1.0/1073741824.0);\n}\n\nfloat noise( vec3 p )\n{\n\tivec3 ip = ivec3(floor(p));\n     vec3 fp = fract(p);\n\n    vec3 w = fp*fp*(3.0-2.0*fp);\n    \n    int n = ip.x + ip.y*57 + 113*ip.z;\n\n\treturn mix(mix(mix( hash(n+(0+57*0+113*0)),\n                        hash(n+(1+57*0+113*0)),w.x),\n                   mix( hash(n+(0+57*1+113*0)),\n                        hash(n+(1+57*1+113*0)),w.x),w.y),\n               mix(mix( hash(n+(0+57*0+113*1)),\n                        hash(n+(1+57*0+113*1)),w.x),\n                   mix( hash(n+(0+57*1+113*1)),\n                        hash(n+(1+57*1+113*1)),w.x),w.y),w.z);\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm( vec3 p )\n{\n#if 0\n    // original code\n    return 0.5000*noise( p*1.0 ) + \n           0.2500*noise( p*2.0 ) + \n           0.1250*noise( p*4.0 ) +\n           0.0625*noise( p*8.0 );\n#else\n    // equivalent code, but compiles MUCH faster\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        f += s*noise( p );\n        s *= 0.5;\n        p *= 2.0;\n    }\n    return f;\n#endif\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat udSqBox( vec3 p, vec3 b )\n{\n\tfloat di = 0.0;\n\tfloat dx = abs(p.x)-b.x; if( dx>0.0 ) di+=dx*dx;\n    float dy = abs(p.y)-b.y; if( dy>0.0 ) di+=dy*dy;\n    float dz = abs(p.z)-b.z; if( dz>0.0 ) di+=dz*dz;\n    return di;\n}\n\n//-------------------------------------------------------------------------------\n\nfloat columna( vec3 pos, float offx )\n{\n    float x = pos.x;\n    float y = pos.y;\n    float z = pos.z;\n    \n\tfloat y2=y-0.40;\n    float y3=y-0.35;\n    float y4=y-1.00;\n\n    float di =    udSqBox( vec3(x, y , z), vec3(0.10, 1.00, 0.10) );\n    di = min( di, udSqBox( vec3(x, y , z), vec3(0.12, 0.40, 0.12) ) );\n    di = min( di, udSqBox( vec3(x, y , z), vec3(0.05, 0.35, 0.14) ) );\n    di = min( di, udSqBox( vec3(x, y , z), vec3(0.14, 0.35, 0.05) ) );\n    di = min( di, udSqBox( vec3(x, y4, z), vec3(0.14, 0.02, 0.14) ) );\n    di = min( di, udSqBox( vec3((x-y2)*0.7071, (y2+x)*0.7071, z), vec3(0.10*0.7071,  0.10*0.7071, 0.12) ) );\n    di = min( di, udSqBox( vec3(x, (y2+z)*0.7071, (z-y2)*0.7071), vec3(0.12,  0.10*0.7071, 0.1*0.7071) ) );\n    di = min( di, udSqBox( vec3((x-y3)*0.7071, (y3+x)*0.7071, z), vec3(0.10*0.7071,  0.10*0.7071, 0.14) ) );\n    di = min( di, udSqBox( vec3(x, (y3+z)*0.7071, (z-y3)*0.7071), vec3(0.14,  0.10*0.7071, 0.10*0.7071) ) );\n\n    #if 1\n    float fb = fbm(vec3(10.1*x+offx,10.1*y,10.1*z));\n    if( fb>0.0 )\n        di = di + 0.00000003*fb;\n    #endif\n\n    return sqrt(di);\n}\n\nfloat bicho( vec3 pos, float mindist )\n{\n    pos -= vec3(0.64,0.50,1.5);\n    \n    float r2 = dot2(pos);\n\n\tfloat sa = smoothstep(0.0,0.5,r2);\n    pos *= vec3(0.75,0.80,0.75) + sa*vec3(0.25,0.20,0.25);\n    r2 = dot2(pos);\n\n    if( r2>5.0 ) return mindist;\n    if( pos.y >0.5 ) return mindist;\n\tif( pos.y>-0.2 && dot(pos.xz,pos.xz)>0.6 ) return mindist;\n    if( r2>(1.7+mindist)*(1.7+mindist)  ) return mindist;\t// algo ayuda, poco, pero algo oiga\n\n\tfloat r = sqrt(r2);\n\n\tif( r<0.75 )\n    {\n\tfloat a1 = 1.0-smoothstep( 0.0, 0.75, r );\n\ta1 *= 0.6;\n\tvec2 sico = vec2( sin(a1), cos(a1) );\n\tfloat nx = pos.x;\n\tfloat ny = pos.y;\n\tpos.x = nx*sico.y - ny*sico.x;\n\tpos.y = nx*sico.x + ny*sico.y;\n    }\n\t#define TENTACURA 0.045\n\tfloat mindist2 = 100000.0;\n    vec3  p = pos;\n\tfloat rr = 0.05+length(pos.xz);\n\tfloat ca = (0.5-TENTACURA*0.75) -6.0*rr*exp2(-10.0*rr);\n    for( int j=1+ZERO; j<7; j++ )\n\t{\n\t\tfloat an = (6.2831/7.0) * float(j);\n\t\tfloat aa = an + 0.40*rr*noise(vec3(4.0*rr, 2.5, an)) + 0.29;\n\t\tfloat rc = cos(aa);\n        float rs = sin(aa);\n\t\tvec3 q = vec3( p.x*rc-p.z*rs, p.y+ca, p.x*rs+p.z*rc );\n\t\tfloat dd = dot(q.yz,q.yz);\n\t\tif( q.x>0.0 && q.x<1.5 && dd<mindist2 ) mindist2=dd;\n\t}\n\tfloat dtentacles = sqrt(mindist2) - TENTACURA;\n\n    // proto-smooth-minimum\n\tfloat dhead = r-0.15;\n\n    float h = clamp( r*3.0, 0.0, 1.0 );\n    return mix(dhead-0.15,dtentacles,h);\n}\n\nfloat techo2( float x, float y, float z )\n{\n    y = 1.0 - y;\n    x = x - 0.5;\n    z = z - 0.5;\n    return 0.4 - sqrt(y*y+min(x*x,z*z) );\n}\n\nfloat map( vec3 pos, out uint sid, out uint submat )\n{\n    submat = 0u;\n    float mindist;\n    \n    //-----------------------\n    // suelo\n    //-----------------------\n    {\n\tfloat dis = pos.y;\n\t\n\tfloat ax = 128.0 + (pos.x+pos.z)*6.0;\n\tfloat az = 128.0 + (pos.x-pos.z)*6.0;\n    uint ix = uint(floor(ax));\n    uint iz = uint(floor(az));\n    submat = ihash(ix+53u*iz);\n    bool ba = ( ((submat>>10)&7u)>6u );\n    float peld = max(fract(ax),fract(az));\n    peld = smoothstep( 0.975, 1.0, peld );\n    if( ba ) peld = 1.0;\n    dis += 0.005*peld;\n\tmindist = dis;\n    if( peld>0.0000001 ) sid = 2u; else sid = 0u;\n    }\n    \n    //-----------------------\n    // techo\n    //-----------------------\n\tif( pos.y>1.0 ) \n    {\n        float dis = techo2( fract(pos.x), pos.y, fract(pos.z) );\n        if( dis<mindist )\n        {\n            mindist = dis;\n            sid = 5u;\n        }\n    }\n\n    //-----------------------\n    // columnas\n    //-----------------------\n    {\n\tvec3 fc = vec3(fract( pos.x+0.5 )-0.5, pos.y,\n\t               fract( pos.z+0.5 )-0.5);\n    float bb = udSqBox( fc, vec3(0.14, 1.0, 0.14) );\n    if( bb < mindist*mindist )\n    {\n        float dis = columna( fc, 13.1*floor(pos.x)+17.7*floor(pos.z) );\n        if( dis<mindist )\n        {\n            mindist = dis;\n            sid = 1u;\n        }\n    }\n    }\n    \n    //-----------------------\n    // bicho\n    //-----------------------\n    //if( length( pos-vec3(0.64,-2.1,1.5) ) - 2.8 < mindist )\n    if( dot2( pos-vec3(0.64,-2.1,1.5) ) < (mindist+2.8)*(mindist+2.8) )\n    {\n    float dis = bicho( pos, mindist );\n    if( dis<mindist )\n    {   \n        mindist = dis;\n        sid = 4u;\n    }\n    }\n\n    //-----------------------\n    // baldosas\n    //-----------------------\n    if( pos.y-0.02 < mindist )\n\t{\n\tint kkr = 65535;\n    for( int i=ZERO; i<10; i++ )\n    {\n        float a = 3.14*sfrand(kkr);\n        float co = cos(a);\n        float si = sin(a);\n        float xc = pos.x - (0.5 + 1.5*sfrand(kkr));\n        float zc = pos.z - (1.0 + 1.0*sfrand(kkr));\n        float xo = xc*co-si*zc;\n        float zo = zc*co+si*xc;\n        float dis = sdBox( vec3(xo, pos.y-0.008, zo), vec3(0.07, 0.008, 0.07) );\n        if( dis < mindist ) \n        {\n            mindist = dis;\n            sid = 1u;\n        }\n    }\n\t}\n    \n    return mindist;\n}\n\nvoid raycast( vec3 ro, vec3 rd, float to, float tMax, out float resT, out vec3 resPos, out uint resSurface, out uint submat )\n{\n    float t = to;\n    for( int i=ZERO; i<256; i++ )\n\t{\n        resPos = ro + t*rd;\n\t\tfloat h = map( resPos, resSurface, submat );\n\t\tif( h<0.0001 )\n\t\t{\n\t\t    resT = t;\n\t\t\treturn;\n\t\t}\n        t += h*0.75;\n        if( t>tMax ) break;\n\t}\n    resSurface = 666u;\n}\n\nvec3 calcNormal( vec3 pos )\n{\n#if 0\n    // original code\n    const float eps = 0.0002;\n    uint kk, kk2;\n    vec3 nor = vec3(\n      map( pos.x+eps, pos.y, pos.z, kk, kk2 ) - map( pos.x-eps, pos.y, pos.z, kk, kk2 ),\n      map( pos.x, pos.y+eps, pos.z, kk, kk2 ) - map( pos.x, pos.y-eps, pos.z, kk, kk2 ),\n      map( pos.x, pos.y, pos.z+eps, kk, kk2 ) - map( pos.x, pos.y, pos.z-eps, kk, kk2 ));\n    return normalize(nor);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        uint kk, kk2;\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0002*e, kk, kk2);\n        if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 shade( vec3 pos, vec3 rd, uint matID, uint subMatID, float dis )\n{\n    if( matID==666u ) return vec3(0.0,0.0,0.0);\n\n    vec3 col = vec3(0.1*dis);\n\n    // calc normal\n    vec3 nor = calcNormal( pos );\n\n    // bump mapping\n    #if 1\n    const float kke = 0.0001;\n    float bumpa = 0.0075;\n\tif( matID!=5u ) bumpa *= 0.75;\n    if( matID==4u ) bumpa *= 0.50;\n    bumpa /= kke;\n    float kk = fbm( 32.0*pos );\n    nor.x += bumpa*(fbm( 32.0*vec3(pos.x+kke, pos.y, pos.z) )-kk);\n    nor.y += bumpa*(fbm( 32.0*vec3(pos.x, pos.y+kke, pos.z) )-kk);\n    nor.z += bumpa*(fbm( 32.0*vec3(pos.x, pos.y, pos.z+kke) )-kk);\n    nor = normalize(nor);\n    #endif\n\n\n    // light\n\tfloat spe = 0.0;\n    vec3 lig = vec3( 0.5, 0.8, 1.5 ) - pos;\n    float llig = dot2(lig);\n    float im = 1.0/sqrt(llig);\n    lig *= im;\n    float dif = dot( nor, lig ); \n    if( matID==4u )\n        dif = 0.5+0.5*dif;\n    else\n        dif = 0.10+0.90*dif;\n    dif = max( dif, 0.0 );\n\tdif *= 2.5*exp2( -1.75*llig );\n\tfloat dif2 = (nor.x+nor.y)*0.075;\n\n    // materials\n    if( matID==0u )\n    {\n        float xoff = 13.1 * float(subMatID&255u);\n        float fb = fbm( 16.0*vec3(pos.x+xoff, pos.y, pos.z) );\n\n        col = 0.7 + vec3(0.20,0.22,0.25)*fb;\n\n        float baldscale = float((subMatID>>9)&15u)/14.0;\n        baldscale = 0.51 + 0.34*baldscale;\n        col *= baldscale;\n        float fx = 1.0;\n        if( (subMatID&256u)!=0u ) fx = -1.0;\n        float m = sin( 64.0*pos.z*fx +  64.0*pos.x + 4.0*fb );\n        m = smoothstep( 0.25, 0.5, m ) - smoothstep( 0.5, 0.75, m );\n\n        col += m*0.15;\n    }\n    else if( matID==2u )\n    {\n        col = vec3(0.0,0.0,0.0);\n    }\n    else if( matID==1u )\n    {\n        float fb = fbm( 16.0*pos );\n        float m = sin( 64.0*pos.z +  64.0*pos.x + 4.0*fb );\n        m = smoothstep( 0.3, 0.5, m ) - smoothstep( 0.5, 0.7, m );\n        col = 0.59 + fb*vec3(0.17,0.18,0.21) + m*0.15 + dif2;\n    }   \n    else if( matID==4u )\n    {\n        float ft = fbm( 16.0*pos );\n        col = vec3(0.82,0.73,0.65) + ft*vec3(0.10,0.10,0.15);\n        float fs = 0.90+0.10*fbm( 32.0*pos );\n        col *= fs;\n\n        float fre = -dot( nor, rd );\n        if( fre<0.0 ) fre=0.0;\n        fre = fre*fre*0.45;\n        col -= fre;\n\n\t\tspe = (nor.y-nor.z)*0.707;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe = spe*spe;\n        spe *= 0.20;\n     }   \n    // techo\n    else //if( matID==5 )\n    {\n        float fb = fbm( 16.0*pos );\n        col = vec3(0.64,0.61,0.59) + fb*vec3(0.21,0.19,0.19) + dif2;\n    }   \n\n    // AO\n    float ao;\n    #if 1\n    float totao = 0.0;\n    float sca = 10.0;\n    for( int aoi=ZERO; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.015*float(aoi*aoi);\n        vec3 aopos = pos + hr*nor;\n        uint kk, kk2;\n        float dd = map( aopos, kk, kk2 );\n        ao = -(dd-hr);\n        totao += ao*sca;\n        sca *= 0.5;\n        //if( totao>1000.0+sin(iTime) ) break;\n    }\n    ao = 1.0 - clamp( totao, 0.0, 1.0 );\n    #else\n    ao = 1.0;\n    #endif\n\n    // shadow\n    #if 1\n    float so = 0.0;\n\tfor( int i=ZERO; i<6; i++ )\n    {\n\t\tfloat h = float(i)/6.0;\n        float hr = 0.01 + 1.0*h;\n        vec3 aopos = pos + hr*lig;\n        uint kk, kk2;\n        float dd = map( aopos, kk, kk2 );\n        so += (1.0-h)*dd*20.0/6.0;\n        //if( so>1000.0+iTime ) break;\n    }\n    dif *= clamp( (so-0.40)*1.5, 0.0, 1.0 );\n    #endif\n\n    // shade\n\tfloat ao2 = 0.05 + 0.95*ao;\n    col *= vec3(0.25,0.30,0.35)*ao + dif*ao2*vec3(1.95,1.65,1.05);\n    col += spe;\n    col *= exp2( -0.40*pos.z );\n\n    return col;\n}\n\nvec3 post( vec3 col, vec2 p )\n{\n    // flare\n\tfloat rr = (p.x+0.10)*(p.x+0.10) + (p.y-0.40)*(p.y-0.40);\n    col += vec3( 1.0, 0.95, 0.90 )*0.75*exp2( -64.0*rr );\n\n    // color correct\n    col = sqrt(col)*0.3 + 0.7*col;\n    col *= vec3(0.83,1.00,0.83);\n\n    // vignetting\n    col *= 0.25 + 0.75*clamp( 0.60*abs(p.x-1.77)*abs(p.x+1.77), 0.0, 1.0 );\n    \n    return clamp( col, 0.0, 1.0 );\n}\n\nvec3 computePixel( vec2 p, vec2 res, float time )\n{\n    vec2 s = (2.0*p-res)/res.y;\n    \n    // fisheye distortion\n    float r2 = s.x*s.x*0.32 + s.y*s.y;\n\tfloat tt = (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n\n    // create camera and ray\n    vec2 d = s*tt;\n#if 0\n    vec3 ro = vec3( 0.195, 0.5, 0.0 );\n\tvec3 rd = normalize( vec3( d.x*0.955336 + 0.29552, d.y, 0.955336 - d.x*0.29552 ) );\n#else\n    float an = 4.4 + 0.2*sin(0.4*time);\n    vec3 ta = vec3(0.64,0.50,1.5);\n    vec3 ro = ta + 1.55*vec3( cos(an), 0.0, sin(an));\n    vec3 ww = normalize( ta-ro );\n    vec3 vv = vec3(0.0,1.0,0.0);\n    vec3 uu = normalize(cross(vv,ww));\n    vec3 rd = normalize( uu*d.x + vv*d.y + 1.0*ww );\n#endif\n\tfloat t;\n\tuint matID, sumMatID;\n\tvec3 xyz;\n    \n    // raycast\n\traycast( ro, rd, 0.5, 24.0, t, xyz, matID, sumMatID );\n    \n    // shade\n\tvec3 col = shade(  xyz, rd, matID, sumMatID, t  );\n    \n    // postprocess\n\tcol = post( col, s );\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if AA<2    \n    vec3 col = computePixel(fragCoord, iResolution.xy, iTime );\n#else\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 of = vec2(i,j)/float(AA);\n        float time = iTime + (0.5/30.0)*float(j*AA+i)/float(AA*AA);\n        col += computePixel(fragCoord+of, iResolution.xy, time );\n    }\n    col /= float(AA*AA);\n#endif\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}