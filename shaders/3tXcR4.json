{
    "Shader": {
        "info": {
            "date": "1591520364",
            "description": "https://raytracing.github.io/books/RayTracingTheNextWeek.html",
            "flags": 32,
            "hasliked": 0,
            "id": "3tXcR4",
            "likes": 3,
            "name": "Cornell_box_test",
            "published": 3,
            "tags": [
                "raytracing",
                "cornellbox"
            ],
            "usePreview": 0,
            "username": "chen1180",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    vec4 col=texture(iChannel0,uv);\n    col/=float(iFrame);\n    // Output to screen\n    fragColor =pow(col,vec4(1.0/2.2));\n    \n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\nfloat g_seed = 0.0;\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray trace helper functions\n//\n\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define Samples 1\n#define MaxDepth 10\n#define T_MIN 1e-3\n#define T_MAX 1000.0\n#define CornellBoxSize 2.0\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELETRIC 2\n#define EMISSIVE 3\nstruct Material{\n\tint matType;\n    vec3 albedo;\n    float ior;\n};\nstruct Sphere{\n\tvec3 center;\n    float radius;\n    Material material;\n};\n struct Plane{\n\tvec3 p;\n    vec3 normal;\n    Material material;\n};\nstruct Rectangle{\n\tPlane plane;\n    float size;\n};\nSphere sceneList[] =Sphere[](Sphere(vec3(1.0,-1.5,-1.0),0.5,Material(METAL,vec3(0.8,0.8,0.8),0.0)),\n    Sphere(vec3(-0.0,-1.5,-0.5),0.5,Material(DIELETRIC,vec3(0.8,0.8,0.8),1.3)),\n    Sphere(vec3(-0.5,-1.5,-1.5),0.5,Material(LAMBERTIAN,vec3(0.1,1.0,0.1),0.0)));\n\nRectangle planeList[]=Rectangle[](\n    //Left wall\n    Rectangle(Plane(vec3(-CornellBoxSize,0.0,0.0),vec3(1.0,0.0,0.0),Material(LAMBERTIAN,vec3(0.1,1.0,0.1),0.0)),CornellBoxSize),\n    //Right wall\n     Rectangle(Plane(vec3(CornellBoxSize,0.0,0.0),vec3(1.0,0.0,0.0),Material(LAMBERTIAN,vec3(1.0,0.1,0.1),0.0)),CornellBoxSize),\n    //back\n     Rectangle(Plane(vec3(0.0,0.0,-CornellBoxSize),vec3(0.0,0.0,1.0),Material(LAMBERTIAN,vec3(0.5,0.5,0.5),0.0)),CornellBoxSize),\n    //floor\n     Rectangle(Plane(vec3(0.0,-CornellBoxSize,0.0),vec3(0.0,1.0,0.0),Material(LAMBERTIAN,vec3(0.5,0.5,0.5),0.0)),CornellBoxSize),\n    //ceiling\n     Rectangle(Plane(vec3(0.0,CornellBoxSize,0.0),vec3(0.0,1.0,0.0),Material(LAMBERTIAN,vec3(0.5,0.5,0.5),0.0)),CornellBoxSize)\n);\n\nRectangle lightList[]=Rectangle[](\nRectangle(Plane(vec3(0.0,2.0,0.0),vec3(0.0,1.0,0.0),Material(EMISSIVE,vec3(1.0,1.0,1.0),0.0)),1.0)\n);\nstruct HitRecord{\n    bool isHit;\n    vec3 p;\n    vec3 normal;\n    Material material;\n    \n};\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n    };\n//Primitive:Sphere\nfloat intersectSphere(Ray r,Sphere s){\n    vec3 oc=r.origin-s.center;\n    vec3 t=r.direction;\n\tfloat a=dot(t,t);\n    float b=2.0*dot(t,oc);\n    float c=dot(oc,oc)-s.radius*s.radius;\n    float discriminant=b*b-4.0*a*c;\n    if (discriminant<=0.0)\n        return -1.0;\n    else\n    {\n    \tfloat x1=(-b-sqrt(discriminant))/(2.0*a);\n        if(x1>T_MIN&&x1<T_MAX)\n        \treturn x1;\n        x1=(-b+sqrt(discriminant))/(2.0*a);\n         if(x1>T_MIN&&x1<T_MAX)\n        \treturn x1;\n    }\n}\nvec3 getSphereNormal(vec3 hitPoint,Sphere s){\n\treturn normalize(hitPoint-s.center);\n}\n//Primitive:Plane\nfloat intersectPlane(Ray r,Plane s){\n\tvec3 op=s.p-r.origin;\n    float d=dot(op,s.normal)/dot(r.direction,s.normal);\n    return d;\n\n}\nvec3 getPlaneNormal(vec3 hitPoint,Plane p){\n\treturn normalize(hitPoint+p.normal);\n}\n//Primitive:Rectangle\nfloat intersectRectangle(Ray r, Rectangle rec){\n    float d=intersectPlane(r,rec.plane);\n    vec3 hitPoint=r.origin+d*r.direction;\n    float size=rec.size;\n    //XZ_PLANE\n    if (rec.plane.normal==vec3(0.0,1.0,0.0)){\n    \tvec3 tmin=rec.plane.p-vec3(size,0.0,size);\n        vec3 tmax=rec.plane.p+vec3(size,0.0,size);\n        if (hitPoint.x>tmin.x&&hitPoint.x<tmax.x)\n            if (hitPoint.z>tmin.z&&hitPoint.z<tmax.z)\n                return d;\n     //YZ_PLANE\n    }else if (rec.plane.normal==vec3(1.0,0.0,0.0)){\n    \tvec3 tmin=rec.plane.p-vec3(0.0,size,size);\n        vec3 tmax=rec.plane.p+vec3(0.0,size,size);\n        if (hitPoint.y>tmin.y&&hitPoint.y<tmax.y)\n            if (hitPoint.z>tmin.z&&hitPoint.z<tmax.z)\n                return d;\n    }//XY_PLANE\n    else if (rec.plane.normal==vec3(0.0,0.0,1.0)){\n    \tvec3 tmin=rec.plane.p-vec3(size,size,0.0);\n        vec3 tmax=rec.plane.p+vec3(size,size,0.0);\n        if (hitPoint.x>tmin.x&&hitPoint.x<tmax.x)\n            if (hitPoint.y>tmin.y&&hitPoint.y<tmax.y)\n                return d;\n    }\n    \n    return -1.0;\n    \n}\nvec3 getRectangleNormal(Ray r,Rectangle rec){\n    vec3 normal=normalize(rec.plane.normal);\n    if (dot(r.direction,rec.plane.normal)>T_MIN)\n    {\n    \treturn  -normal;\n    }else\n\t\treturn normal;\n}\n\nvec3 skyColor(float t){\n    return (1.0-t)*vec3(1.0)+t*vec3(0.2,0.5,0.7);\n\t\n}\n\nvec3 checkerTexture(vec2 uv, vec3 dir){\n\tfloat sines=sin(dir.x*10.0)*sin(dir.y*10.0)*sin(dir.z*10.0);\n    if (sines>0.0)\n        return vec3(1.0);\n    else\n        return vec3(0.0);\n}\n\nHitRecord intersectScene(Ray r){\n    float tMax=T_MAX;\n    float tMin=T_MIN;\n    HitRecord hit_record;\n    hit_record.isHit=false;\n    //interseciton of the spheres \n    for (int i=0;i<sceneList.length();i++)\n    {\n    \tfloat ts=intersectSphere(r, sceneList[i]);\n   \t\t if (ts>tMin && ts<tMax){\n            tMax=ts;\n             hit_record.p=r.origin+r.direction*ts;\n            hit_record.normal=getSphereNormal(hit_record.p,sceneList[i]);\n             hit_record.material=sceneList[i].material;\n             hit_record.isHit=true;\n         }\n        \n    }\n    //intersection of the Light emitter\n    for (int i=0;i<lightList.length();i++)\n    {\n    \t float tp=intersectRectangle(r,lightList[i]);\n   \t\t if (tp>tMin && tp<tMax){\n            tMax=tp;\n             hit_record.p=r.origin+r.direction*tp;\n            hit_record.normal=getPlaneNormal(hit_record.p,lightList[i].plane);\n             hit_record.material=lightList[i].plane.material;\n             hit_record.isHit=true;\n         }\n        \n    }\n   \n    //intersection of the cornell box\n    for (int i=0;i<planeList.length();i++)\n    {\n    \t float tp=intersectRectangle(r,planeList[i]);\n   \t\t if (tp>tMin && tp<tMax){\n            tMax=tp;\n             hit_record.p=r.origin+r.direction*tp;\n            hit_record.normal=getRectangleNormal(r,planeList[i]);\n             hit_record.material=planeList[i].plane.material;\n             hit_record.isHit=true;\n         }\n        \n    }\n     \n    return hit_record;\n\n}\nfloat schlick(float cos_theta, float n2)\n{\n    const float n1 = 1.0f;  // refraction index for air\n\n    float r0s = (n1 - n2) / (n1 + n2);\n    float r0 = r0s * r0s;\n\n    return r0 + (1.0f - r0) * pow((1.0f - cos_theta), 5.0f);\n}\nbool refractVec(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted)\n{\n    vec3 uv = normalize(v);\n\n    float dt = dot(uv, n);\n\n    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0f - dt * dt);\n\n    if (discriminant > 0.0f)\n    {\n        refracted = ni_over_nt*(uv - n * dt) - n * sqrt(discriminant);\n\n        return true;\n    }\n    else\n        return false;\n}\nbool material_bsdf(HitRecord hit_record,Ray inRay, out Ray outRay,out vec3 attenuation){\n    vec3 col=vec3(0.0);\n    //lambertian\n    if(hit_record.material.matType==LAMBERTIAN){\n        vec3 ray_origin=hit_record.p;\n        vec3 ray_dir=random_cos_weighted_hemisphere_direction(hit_record.normal,g_seed);\n        outRay=Ray(ray_origin,ray_dir);\n        attenuation=hit_record.material.albedo;\n        return true;\n    }else if(hit_record.material.matType==METAL){\n     //metal\n        vec3 reflected=reflect(inRay.direction,hit_record.normal);\n        outRay=Ray(hit_record.p,reflected);\n        attenuation=hit_record.material.albedo;\n         return true;\n    }else if(hit_record.material.matType==DIELETRIC){\n     //dieletric\n        vec3 outward_normal,refracted;\n        float ni_over_nt,cosine,reflect_prob;\n        vec3 reflected=reflect(inRay.direction,hit_record.normal);\n        if (dot(inRay.direction,hit_record.normal)>0.0){\n        \toutward_normal=-hit_record.normal;\n            ni_over_nt=hit_record.material.ior;\n            cosine=dot(inRay.direction,hit_record.normal)/length(inRay.direction);\n            cosine=sqrt(1.0-ni_over_nt*ni_over_nt*(1.0-cosine*cosine));\n            \n        }else{\n            outward_normal=hit_record.normal;\n        \tni_over_nt = 1.0f / hit_record.material.ior;\n            cosine=-dot(inRay.direction,hit_record.normal)/length(inRay.direction);\n        }\n        if (refractVec(inRay.direction, outward_normal, ni_over_nt, refracted))\n            reflect_prob = schlick(cosine, hit_record.material.ior);\n        else\n            reflect_prob = 1.0f;\n  \n        if (hash1(g_seed)<reflect_prob)\n        {\n        \toutRay=Ray(hit_record.p,reflected);\n\n        } \t\n        else\n        {\n\n            outRay=Ray(hit_record.p,refracted);\n        }\n        attenuation=hit_record.material.albedo;\n        return true;\n\n        \n    }\n    return false;\n\n}\n\nvec3 radiance(Ray r,vec2 uv,Rectangle rec){\n  \tvec3 col=vec3(1.0);\n    HitRecord hit_record;\n    for(int bounce=0;bounce<MaxDepth;bounce++)\n    {\n        hit_record=intersectScene(r);\n        vec3 emitter=rec.plane.material.albedo;\n        if (hit_record.isHit)\n        {\n\t\t\t\n            Ray outRay;\n            vec3 color;\n\n            bool scattered=material_bsdf(hit_record,r,outRay,color);\n            r.origin=outRay.origin;\n            r.direction=outRay.direction;\n            if (scattered)\n            {\n                col*=color;\n            }\n            \n            else\n            {\n            \tcol*=emitter;\n                break;\n            }\n               \n  \n        }else\n        {\n            col*=vec3(0.0);\n        \tbreak;\n        }\n        \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    g_seed = float(base_hash(floatBitsToUint(fragCoord.xy)))/float(0xffffffffU)+iTime;\n    //camera ray calculation\n    vec3 cameraPos=vec3(0.0,0.0,3.5);\n    vec3 cameraLookAt=vec3(0.0,0.0,-1.0);\n    float zNear=1.0,zFar=1000.0;\n    float fov=60.0;\n    float height=zNear*tan(radians(fov/2.0));\n    float ratio=iResolution.x/iResolution.y;\n    float viewport_height=2.0*height;\n    float viewport_width=viewport_height*ratio;\n\n    vec3 t=normalize(cameraLookAt-cameraPos);\n    vec3 up=vec3(0.0,1.0,0.0);\n    vec3 h=normalize(cross(t,up));\n    vec3 v=normalize(cross(h,t));\n    vec3 horizontal=viewport_width*h;\n    vec3 vertical=viewport_height*v;\n\n    vec3 leftBotCorner=cameraPos+t-horizontal*0.5-vertical*0.5;\n    vec3 rayDir=leftBotCorner+uv.x*horizontal+uv.y*vertical-cameraPos;\n    Ray r=Ray(cameraPos,rayDir);\n \n     vec3 col=vec3(0.0);\n     float x=(fragCoord.x+ hash1(g_seed))/iResolution.x;\n     float y=(fragCoord.y+ hash1(g_seed))/iResolution.y;\n     for(int n=0;n<lightList.length();n++)\n         col+=radiance(r,vec2(x,y),lightList[n]);\n    // Output to screen\n    fragColor = vec4(col,1.0)+texture(iChannel0,uv);\n       \t\n    \n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    fragColor =texture(iChannel0,uv);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}