{
    "Shader": {
        "info": {
            "date": "1720439892",
            "description": "Standard truchet tile set with some neighbor checking to cap off the ends in a few variations. Add in some FBM Noise to move things around.",
            "flags": 0,
            "hasliked": 0,
            "id": "X3GSDG",
            "likes": 16,
            "name": "Byt3-daily-009",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "parallax",
                "truchet",
                "tile"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 155
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Byt3-daily-009\n    Wanted to try the standard rounded truchet tile set, some variations in the end cap\n    logic, and a simple parallax scroll.\n     \n    07/08/2024  @byt3_m3chanic\n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a){ return fract(sin(dot(a,vec2(22.54,35.45)))*4823.232);}\nfloat box(vec2 p, vec2 a) {vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);}\n\nvec3 hue(float t) { \n    vec3 d = vec3(0.929,0.690,0.027);\n    return .45 +.45*cos( PI2*t*vec3(.984,.914,.914)+d ); \n}\n\n// @Shane compacted self-contained version of @iq's 3D value noise function.\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n// @iq fbm generator with some mods\nfloat fbm3( in vec3 x) {\n    vec2 uv = x.xy;\n    x*=.1;\n    float a = 0.1,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for (int i = 0; i < 4; ++i) {      \n        float n = n3D(f*x);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n    float aa = 1.5+1.5*sin(uv.y*.75);\n    if(uv.x<(1.+aa) && uv.x>-(2.5-aa)  && a>.5) a = 0.;\n\treturn a;\n}\n\nvec3 truchet(vec2 p) {\n    vec2 uv = p;\n    uv *= p.y<0.? 8. : 16.; uv -= vec2(0,T*.633);\n    \n    vec2 id = floor(uv), q = fract(uv)-.5;\n    float hs = hash21(id);\n\n    const float sx = .755;\n    // cheap check of the hood\n    vec3 nid = vec3(id,T*1.185);\n    float ns = fbm3(vec3(nid*sx));\n    vec4 hhs = vec4(\n        fbm3(vec3((nid+vec3(0,-1,0))*sx)),\n        fbm3(vec3((nid+vec3(1,0,0))*sx)),\n        fbm3(vec3((nid+vec3(0,1,0))*sx)),\n        fbm3(vec3((nid+vec3(-1,0,0))*sx))\n    );\n    \n    float rnd = fract(hs*4324.79);\n    if(rnd>.5) q.xy*= rot(1.5707);\n    \n    const float pf = .5, wd = .165;\n    vec2 q2 = q;\n    \n    // main pattern\n    vec2 pq = length(q.xy+pf)<length(q.xy-pf)? q.xy+pf : q.xy-pf;\n    float d = length(pq)-.5;\n    d = abs(d) - wd;\n    \n    // alt pattern\n    if(hs>.65) {\n        d = min(length(q2.x),length(q2.y))-wd;\n        float xd = length(abs(q2.x)-(wd*1.2))-(wd*.2);\n        d = max(d,-xd);\n    }\n\n    // edge block check to cap and alter patterns\n    // prob could do better with logic but first stab at it..\n    const float thr = .5;\n    if(ns<thr) {\n        d = 1.;\n        // basic just the tips additive \n        if(rnd>.5) { q2.xy*= rot(-1.5707); } \n        if(hhs.x>thr) d = min(min(box(q2+vec2(0,.5),vec2(wd,wd*1.275)),length(q2+vec2(0,.3))-wd), d);\n        if(hhs.z>thr) d = min(min(box(q2-vec2(0,.5),vec2(wd,wd*1.275)),length(q2-vec2(0,.3))-wd), d);\n        if(hhs.y>thr) d = min(min(box(q2-vec2(.5,0),vec2(wd*1.275,wd)),length(q2-vec2(.3,0))-wd), d);\n        if(hhs.w>thr) d = min(min(box(q2+vec2(.5,0),vec2(wd*1.275,wd)),length(q2+vec2(.3,0))-wd), d);\n        \n        // just for single ends\n        float ck = mod(id.y+id.x,2.);\n        if(fract(47.43*rnd)<.32) ck = 1.;\n        if(hhs.x<thr&&hhs.y>thr&&hhs.z<thr&&hhs.w<thr&&ck<1.) d = min(box(q2-vec2(.2,0),vec2(wd*2.85,wd)),length(q2+vec2(.25,0))-wd);\n        if(hhs.x<thr&&hhs.y<thr&&hhs.z>thr&&hhs.w<thr&&ck<1.) d = min(box(q2-vec2(0,.2),vec2(wd,wd*2.85)),length(q2+vec2(0,.25))-wd);\n        if(hhs.x<thr&&hhs.y<thr&&hhs.z<thr&&hhs.w>thr&&ck<1.) d = min(box(q2+vec2(.2,0),vec2(wd*2.85,wd)),length(q2-vec2(.25,0))-wd);\n        if(hhs.x>thr&&hhs.y<thr&&hhs.z<thr&&hhs.w<thr&&ck<1.) d = min(box(q2+vec2(0,.2),vec2(wd,wd*2.85)),length(q2-vec2(0,.25))-wd);\n\n        // just two corners - rounded\n        if(hhs.x>thr&&hhs.y>thr&&hhs.z<thr&&hhs.w<thr) {\n            d = rnd<.5? abs(length(q.xy+vec2(-.5,.5))-.5)-wd : abs(length(q.xy+vec2(.5,.5))-.5)-wd;\n        }\n        if(hhs.z>thr&&hhs.w>thr&&hhs.x<thr&&hhs.y<thr) {\n            d = rnd<.5? abs(length(q.xy-vec2(-.5,.5))-.5)-wd : abs(length(q.xy-vec2(.5,.5))-.5)-wd;\n        }\n        if(hhs.w>thr&&hhs.x>thr&&hhs.z<thr&&hhs.y<thr) {\n            d = rnd<.5? abs(length(q.xy-vec2(-.5,-.5))-.5)-wd : abs(length(q.xy-vec2(-.5,.5))-.5)-wd;\n        }\n        if(hhs.z>thr&&hhs.y>thr&&hhs.w<thr&&hhs.x<thr) {\n            d = rnd<.5? abs(length(q.xy-vec2(.5,.5))-.5)-wd : abs(length(q.xy-vec2(.5,-.5))-.5)-wd;\n        }\n        \n        // directly across from each other\n        if(hhs.x>thr&&hhs.z>thr && hhs.w<thr&&hhs.y<thr) d = length(q2.x)-wd;\n        if(hhs.w>thr&&hhs.y>thr && hhs.x<thr&&hhs.z<thr) d = length(q2.y)-wd;\n   \n    }\n\n    return vec3(d,uv);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    \n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y); \n    vec2 f = uv;\n\n    vec3 clr =hue(1.5-(uv.y*.75)+sin(uv.x*4.+T*.5)*.075);\n    vec3 C = uv.y<0. ? vec3(.01):vec3(.1);\n    \n    float sc = uv.y<0.? 12.:24.;\n    f.x+=uv.y<0.? T*-.02:T*.02; f = fract(f*sc)-.5;\n\n    C = f.x*f.y>0. ? C*.5 : C;\n    \n    vec3 dt = truchet(uv);\n    float d = dt.x;\n\n    vec3 st = truchet(uv*2.);\n    float s = st.x;\n    float px = fwidth(uv.x*8.); \n\n    // backdrop motion\n    C = mix(C,uv.y<0.?vec3(0):vec3(.0035),smoothstep(px,-px,s));\n    \n    // truchet and accent\n    px = fwidth(uv.x*3.); \n    C = mix(C,C*.45,smoothstep(.05+px,-px,d-.04));\n    C = mix(C,clr,smoothstep(px,-px,d));\n    C = mix(C,mix(vec3(0),vec3(.65),.5+.5*sin(dt.z*PI2+T*2.)),smoothstep(px,-px,abs(d+.02)-.02));\n\n    float ln = length(uv.y)-.001;\n    C = mix(C,vec3(1),smoothstep(px,-px,ln));\n    // gamma and output\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}