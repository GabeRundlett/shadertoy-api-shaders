{
    "Shader": {
        "info": {
            "date": "1659786500",
            "description": "3d graphic of zeia function in a box with shadows",
            "flags": 0,
            "hasliked": 0,
            "id": "7ltcW8",
            "likes": 7,
            "name": "Zeta in a box",
            "published": 3,
            "tags": [
                "box",
                "zeta"
            ],
            "usePreview": 0,
            "username": "guil",
            "viewed": 250
        },
        "renderpass": [
            {
                "code": "const float pi = 3.1415926535897932;\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\n\n//------------------ ------------------------------------------\n// complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cinv(vec2 z) {return vec2(z.x,-z.y)/dot(z,z);}\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 cpow( float n, vec2 z ) {  return pow( n, z.x )*vec2( cos(z.y*log(n)), sin(z.y*log(n)) ); }\nvec2 cexp( vec2 z) {  return exp( z.x )*vec2( cos(z.y), sin(z.y) ); }\nvec2 clog( vec2 z) {  return vec2( 0.5*log(z.x*z.x+z.y*z.y), atan(z.y,z.x)); }\nvec2 csin( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*sin(z.x),(r-1.0/r)*cos(z.x));}\nvec2 cpow( vec2 a, vec2 b ) {  return cexp(cmul(b,clog(a))) ;}\nvec2 ccos( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*cos(z.x),-(r-1.0/r)*sin(z.x));}\n//\n\n\n\n// Spouge's method\nvec2 gamma(vec2 z){\n    const int N = 8;\n    float c = sqrt(2.*pi);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += cinv(z+vec2(float(k),0.))*c;\n\t}\n\ts = cmul(s,cmul(cexp(-z-vec2(float(N),0.)),cpow(z+vec2(float(N),0.),z+vec2(.5,0.))));\n    return cdiv(s,z);   \n}\n\n\nvec2 zeta3(vec2 s) {\n  const int N = 8;  \n  \n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*(cpow(float(i), -s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = -1.0;\n  float bk= 1.0/pow(2.,float(N));\n  float ek= bk;\n  for(int i = 0 ; i <  N; i++) {\n    sum2 += a*ek*(cpow(float(2*N-i),-s));\n    bk *= float(N-i)/float(i+1);\n    ek += bk;    \n    a = -a;\n  }\n\n\n  return cdiv(sum1+sum2, vec2(1,0) - cpow(2., vec2(1,0) - s));\n}\n\nvec2 khi(vec2 z){\n    return cmul(cmul(cpow(2.*pi,z)/pi,csin(pi*z/2.)),gamma(vec2(1.,0.)-z));\n}  \n\n\nvec2 zeta(vec2 z){\n    if(z.x<.5&&abs(z.y)<55.)return cmul(khi(z),zeta3(vec2(1.,0.)-z));\n    return zeta3(z);\n}\n\n//https://iquilezles.org/articles/boxfunctions\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    return vec2( tN, tF );\n}\n\nvec2 f(vec2 s){\n\nreturn cdiv(cmul(s,s-1.),s+1.);\n}\n\n\nvec3 field(in vec3 p) {\n\t\n    vec2 z=p.xz;\n    z=zeta(5.*z);\n    //z=f(z);\n    //z=gamma(z);\n    float d=p.y-log(length(z)+1.);\n    return vec3(z,d);\n}\n\nvec3 col(vec2 u){\n    return hsv2rgb(vec3(atan(u.y,u.x)/6.28,.6,1.));\n}\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 0., dt = .05, d, dd,tmax;\n    vec2 vt = boxIntersection( ro, rd, vec3(3)); \n\tt=vt.x;    \n    if (t<0.)return vec3(1);\n    tmax=vt.y;\n    vec3 v, c, v1;\n    for( int i=0; i<100; i++ )\n\t{        \n        v = field(ro+t*rd);\n        d=v.z;        \n        t+=dt*abs(d);\n        if(t>tmax)return vec3(.5);\n        if(t<vt.x)return vec3(.5);\n        if(abs(d)<.0001)break;\n                       \n    } \n    vec3 l =normalize(vec3(.0,.2,.2));//light\n    l.xz *= rot(t);\n    ro = ro+t*rd;       \n    t=.02;d=1.;\n    for( int i=0; i<15; i++ )\n\t{                \n        d = min((field(ro+t*l).z)/t,d);               \n        t+=.2; \n        if(abs(d)<.0001)break;\n    } \n    c=col(v.xy)*clamp(d,.5,1.);\n    //c=vec3(1)*clamp(d,.4,.9);\n    return c;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*.2;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n   \n    \n    // camera\n\n    vec3 ro = vec3(8.,6.,0.);   \n    vec3 rd = -normalize(vec3( p.y , 2., p.x ));   \n    rd.xy *= rot(1.);\n    \n    rd.xz *= rot(t);\n    ro.xz *= rot(t);\n    \n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \t\n\t// shade\n        \n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}