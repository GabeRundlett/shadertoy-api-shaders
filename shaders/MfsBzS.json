{
    "Shader": {
        "info": {
            "date": "1723968684",
            "description": "mixed lightning",
            "flags": 0,
            "hasliked": 0,
            "id": "MfsBzS",
            "likes": 1,
            "name": "Mixed RBG lights",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "deni_de",
            "viewed": 92
        },
        "renderpass": [
            {
                "code": "vec2 Map( in vec3 pos ) \n{\n    float o,m;\n    //                         \\/ animated floor\n    float uvW = 0.0;//pos.x * 0.1 * sin(pos.z +1.5 + iTime) * 0.1;\n    vec3 uv = pos + uvW ;\n    \n    //floor                               + iTime * 0.25                                    //this\n    float p = uv.y - texture(iChannel1,pos.xz ).r * 0.06; //* abs(0.05 + 0.27 * sin(iTime) * 0.1);\n    \n    \n    float an = sin(0.1 + 0.324573*iTime);\n\n    o = smin(1.0,p,0.05);\n    \n    return vec2(o,m);\n}\n\nvec3 Normal(vec3 pos)\n{\n    vec2 e = vec2(SURFACE_DISTANCE,0.0);\n    return normalize( vec3( Map(pos+e.xyy).x - Map(pos-e.xyy).x,\n                            Map(pos+e.yxy).x - Map(pos-e.yxy).x,\n                            Map(pos+e.yyx).x - Map(pos-e.yyx).x ));\n}\n\nvec2 RayCast(vec3 RO, vec3 RD)\n{\n    float D = 0.;\n    float M = 0.;\n    for(float i = 0.; i < MAX_RAY_ITERATIONS; i++)\n    {\n        vec3 POS = RO+RD*D;\n        \n        vec2 MAP = Map(POS);\n        float DS = MAP.x;\n        if(D > MAX_RAY_DISTANCE || DS < SURFACE_DISTANCE) break;\n        D += DS;\n        M = MAP.y;\n    }\n    //background is black\n    D = D > MAX_RAY_DISTANCE ?  D = 0. : D ;\n    return vec2(D,M);\n}\n\nvec3 Light(vec3 POS, vec2 RAY, int lIndex)\n{\n    vec3 lpos = vec3(0.0 + abs(sin(iTime * 0.1 + float(lIndex+1)) )* 4.,0, 0.0 - abs(cos(iTime * 0.1 + float(lIndex+1)) )* 4.) + LPOS[lIndex];\n    lpos.y += sin(iTime * 0.5 + float(lIndex+1)) * 0.5;\n    vec3 LD = lpos-POS;\n    vec3 O = AMBIENT;\n    \n    float Lshape = clamp(1.0 -(length(LD) - 1.75),0.,1.);\n    \n    float N2L = clamp( dot( Normal(POS), normalize(LD)), 0., 1. ) ;\n    \n    float shadow = step(RayCast(POS + Normal(POS) * SURFACE_DISTANCE * 5.5, normalize(LD)).x, 0.);\n        \n    N2L = shadow < .1 ? (N2L * 0.01)  : N2L;\n    \n    O += (LCOL[lIndex]  * clamp(N2L,0.,1.)  * Lshape);\n    \n    return  O;\n}\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec3 FINAL = vec3(0);\n    vec2 UV = (U -.5 *iResolution.xy) / iResolution.y;\n    vec3 RO = vec3(0,.5,0);\n    vec3 RD = normalize(vec3(UV.xy, 1.0));\n    RO.z -= 1.2;\n    RD.zx *= Rotate(90.);\n    \n    //RD.zx *= Rotate(iMouse.x * 0.01);\n\n    vec3 POS;\n    \n    vec2 r = RayCast(RO,RD);\n    if(r.x > 0.)\n    {\n        POS = RO+RD*r.x;\n        for(int i = 0; i < 3; i++)\n        {\n            FINAL += pow(vec3( Light(POS,r,i)),vec3(0.5)) ;\n        }  \n    }\n    \n    O = vec4(FINAL, 1.0); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SURFACE_DISTANCE 0.001\n#define MAX_RAY_DISTANCE 10.\n#define MAX_RAY_ITERATIONS 45.\n#define LPOS vec3[3](vec3(0.5,1,1.5), vec3(0,1.5,-1), vec3(-1,1,-1))\n#define LCOL vec3[3](vec3(1,0,0), vec3(0,0,1), vec3(0,1,0))\n#define AMBIENT vec3(0,0,.001)\n\n\nmat2 Rotate(float angle)\n{\n    float s = sin(angle); float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n\nfloat Random (vec2 uv) \n{\n    return fract(sin(dot(uv.xy,vec2(1231.845679823,14351.130895732)))*43758.0456098);\n}\nfloat smin(float a,float b, float blendRadius)\n{\n    float c = clamp(0.5 + (b - a) * ( 0.5 / blendRadius),0.,1.);\n    return mix(b,a,c) - blendRadius * c * (1.0 - c);\n}\n\n#define up length(p.xz), p.y\n#define down length(p.xz), -p.y\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}