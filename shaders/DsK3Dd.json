{
    "Shader": {
        "info": {
            "date": "1679323708",
            "description": "computing a feature point (red) from an arbitrary number of hermite points (white) from the minimum of the variance over all planes. This is an alternative to QEF which does not require a costly SVD operation.",
            "flags": 0,
            "hasliked": 0,
            "id": "DsK3Dd",
            "likes": 10,
            "name": "Closed Form Feature Extraction",
            "published": 3,
            "tags": [
                "plane",
                "points",
                "hermite",
                "qef",
                "svd",
                "feature"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 388
        },
        "renderpass": [
            {
                "code": "\n// Closed Form Feature Extraction (CFFE)\n// by Leonard Ritter (2023/3/20)\n// announcement toot: https://mastodon.gamedev.place/@lritter/110056186547987400\n\n// this code is in the public domain, but citations are welcome\n\n// update: 2023/3/21 - small simplications\n\n// This is original work this author developed while looking for a cheaper alternative for finding a feature \n// point from hermite data, as used in dual contouring, dual marching cubes and extended marching cubes. \n// \n// Similar to QEF, we also construct a quadratic error function, here called a quadratic distance function, but\n// constrain the search space to the average plane, allowing us to lower the problem to 2d. The minimal\n// distance is located where the first derivative of the function is zero. The shape of this root\n// is either a point, chosen as the location of the feature, or a line, in which case we pick a point on\n// the line closest to the coordinate center.\n\n// In addition to providing an exact solution for the meeting of three planes, all underdetermined and \n// overdetermined cases are trivially recognized and handled gracefully. Save for the initial two accumulations\n// needed to build average plane and QDF, which is O(N) for N planes, computing the feature point itself \n// completes in fixed time, and does not depend on an arbitrarily chosen count of iterations as when\n// solving a QEF with a SVD, which, in the author's opinion, is overkill for realtime applications.\n\n// try 2, 3, 4, 6 for typical examples\n#define PLANE_COUNT 12\n\n// input: arbitrary number of sampled planes >= 1\nvec4 sampled_planef[PLANE_COUNT];\n// output: the computed feature point (see compute_feature() below)\nvec3 corner;\n\n// 0   1   2  3 4 5\n// X^2 Y^2 XY X Y W\nstruct quadratic2d { float v[6]; };\n\n// square a planar function; produces quadratic surface\nquadratic2d square_plane(vec3 a) {\n    quadratic2d q;\n    q.v[0] = a.x*a.x;\n    q.v[1] = a.y*a.y;\n    q.v[2] = 2.0*a.x*a.y;\n    q.v[3] = 2.0*a.x*a.z;\n    q.v[4] = 2.0*a.y*a.z;\n    q.v[5] = a.z*a.z;\n    return q;\n}\n\n// assuming the determinant of a quadratic 2d surface is zero, we can treat it as a squared 2d plane and unsquare it\nvec3 quadratic_sqrt(quadratic2d q) {\n#if 0\n    // reconstruct from C*x*y + D*x + E*y only\n    return vec3(\n        sqrt(q.v[2]*q.v[3]/q.v[4]),\n        q.v[2]/sqrt(q.v[2]*q.v[3]/q.v[4]),\n        sqrt(q.v[2]*q.v[3]/q.v[4])*q.v[4]/q.v[2])*sqrt(0.5);\n#else\n    // reconstruct from A*x^2 + B*y^2 + F, compute signs from other arguments\n    return sqrt(abs(vec3(q.v[0],q.v[1],q.v[5])))*vec3(1.0, sign(q.v[2]), sign(q.v[4])*sign(q.v[2]));\n#endif\n}\n\nquadratic2d quadratic_add(quadratic2d a, quadratic2d b) {\n    quadratic2d q;\n    for (int i = 0; i < 6; ++i) {\n        q.v[i] = a.v[i] + b.v[i];\n    }\n    return q;\n}\nquadratic2d quadratic_scale(quadratic2d a, float s) {\n    quadratic2d q;\n    for (int i = 0; i < 6; ++i) {\n        q.v[i] = a.v[i] * s;\n    }\n    return q;\n}\n\n// homogeneous solution for the minimum of a quadratic function with a singular root\nvec3 quadratic_minimum(quadratic2d q) {\n    float d = (4.0*q.v[0]*q.v[1] - q.v[2]*q.v[2]);\n    float x = q.v[2]*q.v[4] - 2.0*q.v[1]*q.v[3];\n    float y = q.v[2]*q.v[3] - 2.0*q.v[0]*q.v[4];\n    return vec3(x,y,d);\n}\n\n// from http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n// pick an arbitrary orthogonal vector for a normal\nvec3 orthogonal(vec3 v) {\n    return (abs(v.x) > abs(v.z))?vec3(-v.y, v.x, 0.0):vec3( 0.0, -v.z, v.y);\n}\n    \n// project a 3d plane to a 2d planar basis f(u,v) = c + s*u + t*v\nvec3 plane_project(vec4 q, vec3 c, vec3 s, vec3 t) {\n    return vec3(\n        dot(q.xyz, s),\n        dot(q.xyz, t),\n        dot(q.xyz, c) + q.w\n    );\n}\n\n// used for visualization only: quadratic surface embedded on average plane\nquadratic2d K;\n// used for visualization only: coordinate system of average plane\nmat3 MC;\n\n// read out sampled_planef and compute corner\nvoid compute_feature() {\n    // compute average plane\n    // the average plane will intersect the singularity where all planes are closest to each other\n    // our resulting feature point is going to be somewhere on this plane\n    vec4 m;\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        m += sampled_planef[i];\n    }\n    m /= float(PLANE_COUNT);\n    float mm = dot(m.xyz, m.xyz);\n    if (abs(mm) < 1e-5) {\n        // planes are all parallel, just pick the closest point of the first one        \n        corner = -sampled_planef[0].w * sampled_planef[0].xyz;\n        return;\n    }\n    // normalize plane\n    m /= sqrt(mm);\n    // closest point to origin becomes the basis of our 2d coordinate system\n    vec3 c = -m.w * m.xyz;\n    // pick an arbitrary orthogonal of the plane normal\n    vec3 s = orthogonal(m.xyz);\n    // and with this, we have an orthonormal basis on the plane: f(u,v) = c + s*u + t*v\n    vec3 t = cross(m.xyz, s);\n    MC = mat3(s, t, c);\n    // build quadratic distance function over all u,v embedded in the average plane\n    // the distance will be minimal close to where all planes intersect\n    quadratic2d v = quadratic2d(float[](0.0,0.0,0.0,0.0,0.0,0.0));\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        // lower 3d plane to our average plane's coordinate system.\n        vec3 p = plane_project(sampled_planef[i], c, s, t);       \n        // add up squared planes; since each plane is (close to) zero for search points\n        // that lie on the plane, the final sum will be also minimal at our search point.\n        v = quadratic_add(v, square_plane(p));\n    }\n    // normalization doesn't really matter here, but we do it anyway, for completeness\n    v = quadratic_scale(v, 1.0/float(PLANE_COUNT));\n    K = v; \n    vec3 h = quadratic_minimum(v);\n    if (h.z < 1e-5) { // minimum is edge or planar\n        // lower quadratic surface back to planar, this won't change the roots\n        vec3 pl = quadratic_sqrt(v);\n        float pp = dot(pl.xy, pl.xy);\n        if (abs(pp) < 1e-5) { // single plane\n            corner = c;\n            return;\n        }\n        // closest point along root\n        h.xy = -pl.z * pl.xy / pp;\n    } else {\n        h.xy /= h.z;\n    }\n    corner = c + s * h.x + t * h.y;\n}\n\n//------------------------------------------------------------------------\n// data construction\n//------------------------------------------------------------------------\n\nstruct line3d { vec3 v; vec3 m; };\n\n// FGED Vol 1 by Eric Lengyel, 3.5.2 Homogeneous Formulas\nline3d line_from_points(vec3 p, vec3 q) {\n    return line3d(q-p, cross(p, q));\n}\n\nvec4 intersect_line_plane(line3d l, vec4 e) {\n    // { m x n + d * v | -n . v }\n    return vec4(cross(l.m, e.xyz) + e.w * l.v, -dot(e.xyz, l.v));\n}\n\nfloat error;\nfloat compute_error(vec3 pt) {\n    float total_w = 0.0;\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        float d = dot(vec4(pt,1.0), sampled_planef[i]);\n        total_w += d*d;\n    }\n    return total_w;\n}\n\nvoid rotate_xy(inout float x, inout float y, in float a) {\n    float c = cos(a);\n    float s = sin(a);\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n\n#define PLANE_RADIUS 1.0\n#define PLANE_PT_R 0.05\n#define FEATURE_PT_R 0.05\n\nvec3 normals[PLANE_COUNT];\nvec3 origins[PLANE_COUNT];\nvec3 points[PLANE_COUNT];\n\nvoid update_planes() {\n    vec4 planef[PLANE_COUNT];\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        float a = float(i)*PI2 / float(PLANE_COUNT);\n        float f = mod(float(i),2.0)*2.0-1.0;\n        normals[i] = normalize(vec3(sin(iTime*0.1+a)*cos(iTime*0.22+a*7.41)*0.8,1.0,0.0));\n        rotate_xy(normals[i].x, normals[i].z, -a*11.2*f);\n        origins[i] = vec3(cos(a)*PLANE_RADIUS,0.0,sin(a)*PLANE_RADIUS);\n        planef[i] = vec4(normals[i], -dot(origins[i],normals[i]));\n    }\n    // push origins onto deepest plane\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        points[i] = origins[i] * 2.0;\n        points[i].y = 5.0;\n        vec3 n = normals[i];\n        for (int j=0; j < PLANE_COUNT; ++j) {\n            line3d l = line_from_points(points[i], points[i] + vec3(0.0,-1.0,0.0));\n            vec4 np = intersect_line_plane(l, planef[j]);\n            float h = np.y / np.w;\n            if (h < points[i].y) {\n                points[i].y = h;\n                n = normals[j];\n            }                \n        }\n        sampled_planef[i] = vec4(n, -dot(n, points[i]));\n    }       \n    \n    compute_feature();\n    error = compute_error(corner)*0.2;\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n#ifdef CROSS_SECTION\n    float an = 1.5+sin(0.3*iTime);\n#else\n    float an = 0.3*iTime + 10.0*mouseX;\n#endif\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat plane(vec3 p, vec3 n, vec3 o) {\n    return dot(p,n) + dot(-o,n);\n}\n\nfloat doModel( vec3 p ) {\n    float d = plane(p, normals[0], origins[0]);\n    float s = sphere(p - corner, max(FEATURE_PT_R, error));\n    s = min(s, sphere(p - points[0], PLANE_PT_R));\n    for (int i = 1; i < PLANE_COUNT; ++i) {\n        d = max(d, plane(p, normals[i], origins[i]));\n        s = min(s, sphere(p - points[i], PLANE_PT_R));\n    }\n    \n  \treturn min(s, d);\n}\n\nvec3 viridis(float t) {\n\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nfloat quadratic_eval(quadratic2d q, vec2 p) {\n    return q.v[0]*p.x*p.x \n         + q.v[1]*p.y*p.y\n         + q.v[2]*p.x*p.y\n         + q.v[3]*p.x\n         + q.v[4]*p.y\n         + q.v[5];\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 p, in vec3 nor )\n{\n    if (sphere(p - corner, max(FEATURE_PT_R, error)) <= 1e-3) {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        if (sphere(p - points[i], PLANE_PT_R) <= 1e-3) {\n            return vec3(1.0);\n        }\n    }\n    float w = 0.0;\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        w += max(0.0, 1.0-abs(plane(p, normals[i], origins[i]))*40.0);\n    }\n    w = clamp((1.5-w)*10.0, -1.0, 1.0)*0.5 + 0.5;\n    \n    // project coordinate to plane local coordinate system and evaluate variance function\n    vec3 lp = p - MC[2];    \n    float h = quadratic_eval(K, vec2(dot(lp, MC[0]), dot(lp, MC[1])));\n    // linearized\n    float lh = sqrt(abs(h));\n    \n    float sh = sign(h)*0.3+0.7;\n    vec3 col = viridis(1.0 - clamp(abs(lh*0.5),0.0,1.0));\n    float d = sh*(clamp(sin(lh*PI*2.0*5.0)*10.0,-1.0,1.0)*0.3+0.7);\n    return mix(vec3(1.0),col*col*0.5,0.9)*w*d;\n    //return vec3(0.3);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    update_planes();\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}