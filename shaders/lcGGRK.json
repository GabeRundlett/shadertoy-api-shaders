{
    "Shader": {
        "info": {
            "date": "1712955801",
            "description": "restoring \"Hyperbolic Poincaré transformed\" by stb ( was 23 likes )",
            "flags": 0,
            "hasliked": 0,
            "id": "lcGGRK",
            "likes": 22,
            "name": "[stb] Hyperbolic Poincaré transf",
            "published": 3,
            "tags": [
                "stb"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "/*\n\tHyperbolic Poincaré transformed\n\t2015-2020 stb\n\n\tJust messing with some old code, and a few complex functions.\n*/\n\n// change these\nconst int N\t\t= 7;\t// number of polygon vertices\nconst int P\t\t= 3;\t// number of polygons meeting at a vertex\nconst int Iters\t= 16;\t// number of iterations\n\n\n#define E \t\t2.71828182\n#define HALFPI\t1.57079633\n#define PI\t\t3.14159265\n#define TWOPI\t6.28318531\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n#define rotate2(p, a) vec2(p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a))\n\n\nvec2 radialRepeat(vec2 p, vec2 o, int n) {\n    return rotate(vec2(o.x, o.y), floor(atan(p.x, p.y)*(float(n)/TWOPI)+.5)/(float(n)/TWOPI));\n}\n\nvec2 cInvert(vec2 p, vec2 o, float r) {\n    return (p-o) * pow(r, 2.) / dot(p-o, p-o) + o;\n}\n\nvec2 cInvertMirror(vec2 p, vec2 o, float r, float flip){\n    return (length(p-o)<r ^^ flip==1. ? cInvert(p, o, r) : p);\n}\n\nvec4 poincareGetStuff(int n_, int p_) {\n    float n = PI / float(n_), p = PI / float(p_);\n\tvec2 r1 = vec2(cos(n), -sin(n));\n    vec2 r2 = vec2(cos(p+n-HALFPI), -sin(p+n-HALFPI));\n    float dist = (r1.x - (r2.x/r2.y) * r1.y);\n    float rad = length(vec2(dist, 0.)-r1);\n    float d2 = dist*dist - rad*rad;\n    float s = (d2<0. ? 1. : sqrt(d2));\n\treturn vec4(vec3(dist, rad, 1.)/s, float(d2<0.));\n}\n\nvec2 poincareCreateUVs(vec2 p, vec4 pI) {\n    return cInvertMirror(p, radialRepeat(p, vec2(0., pI.x), N), pI.y, pI.w);\n}\n\n// Many complex functions are from: https://raw.githubusercontent.com/julesb/glsl-util/master/complexvisual.glsl\n\n#ifndef sinh\n\t#define sinh(a) (pow(E, a)-pow(E, -a)) / 2.\n#endif\n#ifndef cosh\n\t#define cosh(a) (pow(E, a)+pow(E, -a)) / 2.\n#endif\n\n#define c_abs(a) length(a)\n#define c_arg(a) atan(a.y, a.x)\n\n#define c_conj(a) vec2(a.x, -a.y)\n#define c_exp(a) vec2(exp(a.x)*cos(a.y), exp(a.x)*sin(a.y))\n#define c_sqr(a) vec2(a.x*a.x-a.y*a.y, 2.*a.x*a.y)\n#define c_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define c_div(a, b) vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y))\n#define c_sin(a) vec2(sin(a.x)*cosh(a.y), cos(a.x)*sinh(a.y))\n#define c_cos(a) vec2(cos(a.x)*cosh(a.y), -sin(a.x)*sinh(a.y))\n#define c_cartToPolar(a) vec2(length(a), atan(a.y, a.x))\n#define c_polarToCart(a) a.x * vec2(cos(a.y), sin(a.y))\n\nvec2 c_sqrt(vec2 a){\n    float r = sqrt(a.x*a.x+a.y*a.y);\n    float rpart = sqrt(.5*(r+a.x));\n    float ipart = sqrt(.5*(r-a.x));\n    if (a.y < 0.) ipart = -ipart;\n    return vec2(rpart, ipart);\n}\n\nvec2 c_tan(vec2 a){ return c_div(c_sin(a), c_cos(a)); }\n\nvec2 c_log(vec2 a){\n    float rpart = length(a);\n    float ipart = atan(a.y, a.x);\n    if (ipart > PI) ipart -= 2. * PI;\n    return vec2(log(rpart), ipart);\n}\n\nvec2 c_toThe(vec2 a, float b){ return c_exp(b*c_log(a)); }\nvec2 c_toThe(vec2 a, vec2 b){ return c_exp(c_mul(b, c_log(a))); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = 2. * (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n\t\n    \n    // some transformations\n    float nArms = 1.+floor(16.*abs(fract(.025*iTime)-.5));\n\tp = rotate2(p, .2*iTime);\n    p /= dot(p, p);\n    p = c_toThe(p, nArms);\n    p.x += 1.;\n    p = c_toThe(p, .5);\n    p.x += .5;\n    p /= dot(p, p);\n    p.x -= 1.;\n    p = rotate2(p, .1*iTime);\n    \n    \n    // get data for the disk model\n    vec4 pI = poincareGetStuff(N, P);\n    \n    // build the disk\n    for(int i=0; i<Iters; i++)\n        p = poincareCreateUVs(p, pI);\n    \n    // uncomment to mirror from disk's margin\n    //p = cInvertMirror(p, vec2(0., 0.), 1., 1.);\n    \n    \n    // this is the pattern for each polygon\n    float f = 1. - dot(p, p) / pow(pI.z, 2.);\n    \n    fragColor = vec4(vec3(f)*vec3(1.7, 1.2, .8), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}