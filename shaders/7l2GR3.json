{
    "Shader": {
        "info": {
            "date": "1624448074",
            "description": "Come for the Pride / Stay for the Dance Music.\nMoar typography stuff - slowly building out a full character set however needs optimization. ",
            "flags": 64,
            "hasliked": 0,
            "id": "7l2GR3",
            "likes": 7,
            "name": "Proud / Pride Shader",
            "published": 3,
            "tags": [
                "raymarching",
                "typography",
                "pride"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 367
        },
        "renderpass": [
            {
                "code": "// ðŸŒˆ PROUD/PRIDE\n// \n// Being seen is important. / giving others hope that\n// they can succeed and be more / together we're all stronger.\n//\n// technical - typography created from sdf shapes and extruded.\n// using some simple linear stepping functions to time the \n// motion and morphing of words.\n//\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    40.\n#define MIN_DIST    .001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat vmax(vec3 p){ return max(max(p.x,p.y),p.z); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n\nfloat box(vec3 p, vec3 b, in vec4 r )\n{   r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n\tvec3 d = abs(p) - b+vec3(r.x,0,0);\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box( in vec2 p, in vec2 b, in vec4 r ){\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nmat2 r22;\n// Letters from 2D to 3D extruded SDF's\nfloat getP(vec2 uv)\n{\n    float letp = box(uv-vec2(0,.1),vec2(.15),vec4(.15,.15,.00,0));\n    letp=abs(letp)-.05;\n    letp=min(box(uv+vec2(.15, .0),vec2(.05,.3)),letp);\n    return letp;\n}\nfloat getR(vec2 uv)\n{\n    float letr = box(uv-vec2(0,.1),vec2(.15),vec4(.15,.15,.00,0));\n    letr=abs(letr)-.05;\n    letr=min(box(uv+vec2(.15,.0),vec2(.05,.3)),letr);\n    vec2 uu = uv+vec2(-.1, .175);\n    uu.xy*=r22;\n    letr=min(box(uu,vec2(.05,.175)),letr);\n    letr=max(letr, -box(uv+vec2(-.1, .37),vec2(.17,.06)) ); \n    return letr;\n}\nfloat getI(vec2 uv)\n{\n    uv.y=abs(uv.y);\n    float leti = box(uv,vec2(.05,.3));\n    leti = min(box(uv-vec2(.0, .25),vec2(.20,.05)),leti);\n    return leti;\n}\nfloat getD(vec2 uv)\n{\n    float letd = box(uv,vec2(.145,.25),vec4(.125,.125,.00,0));\n    letd=abs(letd)-.05;\n    letd=min(box(uv+vec2(.145, .0),vec2(.05,.3)),letd);\n    return letd;\n}\nfloat getE(vec2 uv)\n{\n    uv.y=abs(uv.y);\n    float lete = box(uv+vec2(.15,0),vec2(.05,.3));\n    lete = min(box(uv+vec2(.05, .0),vec2(.125,.05)),lete);\n    lete = min(box(uv-vec2(.02, .25),vec2(.175,.05)),lete);\n    return lete;\n}\nfloat getO(vec2 uv)\n{\n    float leto = box(uv,vec2(.145,.25),vec4(.125));\n    leto=abs(leto)-.05;\n    return leto;\n}\nfloat getQ(vec2 uv)\n{\n    float letq = box(uv,vec2(.145,.25),vec4(.125));\n    letq=abs(letq)-.05;\n    vec2 uu = uv+vec2(-.1, .175);\n    uu.xy*=r22;\n    letq=min(box(uu,vec2(.05,.175)),letq);\n    letq=max(letq, -box(uv+vec2(-.1, .37),vec2(.17,.06)) ); \n    return letq;\n}\nfloat getU(vec2 uv)\n{\n    float letu = box(uv-vec2(0,.1),vec2(.145,.35),vec4(0,.125,.00,.125));\n    letu=abs(letu)-.05;\n    letu=min(box(uv-vec2(.145, .0),vec2(.05,.3)),letu);\n    letu = max(letu, -box(uv-vec2(.0, .8),vec2(.5,.5)) );\n    return letu;\n}\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec3 hitPoint,hit;\nfloat tmod=0.,time=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.,ga6=0.;\nconst float sz = 3.;\nconst float hf = sz*.5;\n\nvec2 map (vec3 pos) {\n\tvec2 res = vec2(100.,-1.);\n\n    vec3 q = pos;\n    vec3 p = pos;\n    \n    float pr = 1e5;\n    float pd = 1e5;\n    for(int i=0;i<5;i++)\n    {\n\n        vec3 p2 = p+vec3(0,.3,0);\n        vec3 p1 = p-vec3(0,.8,0);\n        \n        mat2 g1 = rot(ga2*PI2);\n        mat2 g2 = rot(ga1*PI2);\n        mat2 g0 = rot(ga3*PI2);\n        mat2 g4 = rot(ga4*PI2);\n        \n        float oft = .2*sin(T+float(i)+ga3*PI);\n        p1.xz*=g1;\n        p1.yz*=g2;\n                \n        p2.xz*=g1;\n        p2.yz*=g2;\n        \n        float toutline,loutline,tz,tx;\n        if(i==0) { \n        vec3 tmq = p1+vec3(1.2,oft,0);\n        vec3 tmx = p2+vec3(1.2,-oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getQ(tmq.xy); \n        toutline=getP(tmx.xy); \n        }\n        if(i==1) {\n        vec3 tmq = p1+vec3(.6,oft,0);\n        vec3 tmx = p2+vec3(.6,-oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getU(tmq.xy);\n        toutline=getR(tmx.xy);\n        }\n        if(i==2) {\n        vec3 tmq = p1-vec3(.0,-oft,0);\n        vec3 tmx = p2-vec3(.0,oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getE(tmq.xy);\n        toutline=mix(getO(tmx.xy),getI(tmx.xy),ga5);\n        }\n        if(i==3) {\n        vec3 tmq = p1-vec3(.6,-oft,0);\n        vec3 tmx = p2-vec3(.6,oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getE(tmq.xy);\n        toutline=mix(getU(tmx.xy),getD(tmx.xy),ga5);\n        }\n        if(i==4) {\n        vec3 tmq = p1-vec3(1.2,-oft,0);\n        vec3 tmx = p2-vec3(1.2,oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getR(tmq.xy);\n        toutline=mix(getD(tmx.xy),getE(tmx.xy),ga5);\n        }\n        \n        pr = min(opx(abs(toutline)-.015,tz,.075),pr);\n        pr = min(opx(abs(loutline)-.015,tx,.075),pr);\n    \n    }\n  \n    if(pr<res.x){\n        res = vec2(pr,2.);\n    \thit=p;\n    } \n\n    float wall = q.z+1.75;\n    if(wall<res.x) {\n        hit=vec3(1.-q.x,q.yz);\n        res = vec2(wall,4.);\n    }\n    return res;\n}\n\n// Tetrahedron technique @Shane\nvec3 normal(vec3 p, float t)\n{\n    const vec2 h = vec2(1.,-1.)*.5773;\n    vec3 n = vec3(0);\n    vec3[4] e4 = vec3[4](h.xyy, h.yyx, h.yxy, h.xxx);\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\t    n += e4[i]*map(p + e4[i]*t*MIN_DIST).x;\n        if(n.x>1e8) break; // Fake non-existing conditional break.\n    }\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += ray.x*.9;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,150, 1.);\n\n    hitPoint = hit;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(0,4,12);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .8, fresnel);\n\n        ga5=1.-ga5;\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; )\n        {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        ga5=1.-ga5;\n        diff = mix(diff,diff*shdw,.75);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n\n        // materials and reflections\n        if(m==2.) {\n            vec3 mp = hitPoint*.5;\n            vec3 clr = hsv2rgb(vec3(hitPoint.x*.175,1.,.5));\n            C+=spec+(vec3(.9)*diff);\n            C=mix(C,hsv2rgb(vec3(fresnel,1.,.5)),fresnel);\n            ref = clr-fresnel;\n        }\n\n        if(m==4.) {\n\n            hitPoint.x-=T*1.5;\n            hitPoint.y+=.4*sin(T*1.4+hitPoint.x*1.3);\n            vec2 uv =hitPoint.xy*.5;    \n            float px = fwidth(uv.x);\n            vec2 grid_uv = fract(uv)-.5;\n            vec2 grid_id = floor(uv);\n\n            float chk = mod(grid_id.y + grid_id.x,2.) * 2. - 1.;\n            float hs = hash21(grid_id);\n            if(hs>.5) grid_uv.x*=-1.;\n\n            vec2 d2 = vec2(length(grid_uv-.5), length(grid_uv+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid_uv-.5) : vec2(grid_uv+.5);\n\n            float circle = length(gx)-.5;\n            float circle2 =abs(abs(circle)-.05)-.025;\n            circle2=smoothstep(-px,.001+px,circle2);\n            circle=(chk>0.^^ hs>.5)?smoothstep(-px,.001+px,circle):smoothstep(.001+px,-px,circle);\n            circle= min(circle2,circle);\n            vec3 fl = hsv2rgb(vec3(.09+hitPoint.y*.16,1.,.5));\n            h =mix(vec3(.9),fl, circle);\n            ref = vec3(1.-circle)-fresnel;\n            C+=spec+((h*diff)*.4);\n            \n        }\n\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n        ga5=1.-ga5;\n    } \n\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n\n    r22=rot(0.38397243543);\n    time = T;\n    tmod = mod(time, 14.);\n    float t1 = lsp(2.0, 4.0, tmod);\n    float t2 = lsp(6.0, 10.0, tmod);\n    \n    float t3 = lsp(6.0, 8.0, tmod);\n    float t4 = lsp(8.0, 10.0, tmod);\n    \n    float t7 = lsp(0.6, 4.0, tmod);\n    float t8 = lsp(10., 12., tmod);\n\n    float t9 = lsp(3.0, 4.0, tmod);\n    float t0 = lsp(8.0, 9.0, tmod);\n    \n    ga1 = (t1-t2);\n    ga2 = (t3-t4);\n    ga3 = (t1-t3);\n    ga4 = (t7-t8);\n    ga5 = (t9-t0);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,.25,2.25);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    mat2 ry = rot(.15*sin(time*.03));\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 2.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n    // gamma\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 27655,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/replay-48063375/erasure-chains-of-love-combo-mix"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}