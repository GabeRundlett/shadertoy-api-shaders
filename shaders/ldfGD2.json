{
    "Shader": {
        "info": {
            "date": "1379529639",
            "description": "use mouse to scale contrast (vertical) and tune anisotropy (horizontal)\n\ndensity *= product_i{ 1+ scale * signedBaseNoise(2^i.x) }",
            "flags": 0,
            "hasliked": 0,
            "id": "ldfGD2",
            "likes": 3,
            "name": "galactic gaz",
            "published": 3,
            "tags": [
                "fractalgaz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 772
        },
        "renderpass": [
            {
                "code": "#define ANIM true\n\nfloat scale = 1., time;\nvec2 FragCoord;\nvec4 FragColor;\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//mat3 m = mat3( 0.00,  0.80,  0.60,\n//              -0.80,  0.36, -0.48,\n//              -0.60, -0.48,  0.64 );\nmat3 m = mat3(-0.60, -0.48,  0.64,\n              -0.80,  0.36, -0.48,\n               0.00,  0.80,  0.60);\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of Created by inigo quilez\n\n\nfloat fbmm( vec3 p )\n{\n    float f;\n    f  =    noise( p ); p = m*p*2.02;\n    f *= 2.*noise( p ); p = m*p*2.03;\n    f *= 2.*noise( p ); p = m*p*2.01;\n    f *= 2.*noise( p ); p = m*p*2.03;\n    f *= 2.*noise( p ); p = m*p*2.01;\n    f *= 2.*noise( p );\n    return f;\n}\n\n#define noises(p) (2.*noise(p)-1.)\nfloat fbms( vec3 p )\n{\n    float f;\n    f  = 0.5000*noises( p ); p = m*p*2.02;\n    f += 0.2500*noises( p ); p = m*p*2.03;\n    f += 0.1250*noises( p ); p = m*p*2.01;\n    f += 0.0625*noises( p );\n    return f;\n}\nfloat scaleW = 0.;\n#define warp1(p) p\n//#define warp1(p) (p*vec3(6,1.,1.)/6.)\n#define warp2(p) (p+10.*scaleW*(.5+.5*sin(.2*p)))\nfloat fbmms( vec3 p )\n{\n    float f;\n\tp = warp2(p);\n    f  = 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.02);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.03);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.01);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.03);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.01);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.03);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.01);\n    f *= 1.+scale*noises( warp1(p) );\n    return .5*f;\n}\nfloat fbma( vec3 p )\n{\n    float f;\n    f  = 0.5000*abs(noise( p )); p = m*p*2.02;\n    f += 0.2500*abs(noise( p )); p = m*p*2.03;\n    f += 0.1250*abs(noise( p )); p = m*p*2.01;\n    f += 0.0625*abs(noise( p ));\n    return f;\n}\nfloat fbmsa( vec3 p )\n{\n    float f;\n    f  = 0.5000*abs(noises( p )); p = m*p*2.02;\n    f += 0.2500*abs(noises( p )); p = m*p*2.03;\n    f += 0.1250*abs(noises( p )); p = m*p*2.01;\n    f += 0.0625*abs(noises( p ));\n    return f;\n}\nfloat fbmsma( vec3 p )\n{\n    float f;\n    f  = 0.5000*(1.-abs(noises( p ))); p = m*p*2.02;\n    f += 0.2500*(1.-abs(noises( p ))); p = m*p*2.03;\n    f += 0.1250*(1.-abs(noises( p ))); p = m*p*2.01;\n    f += 0.0625*(1.-abs(noises( p )));\n    return f;\n}\n\n// gives a random 1..N integer for index i\n#define rnd(i,N) int(1.+float(N)*hash(float(i)))\n\n// gives a random 1..N integer every T seconds, starting at i.\n#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iTime/(T))))\n\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\n{\n\tvec3 pos = vec3(p,.5);\n\tif (ANIM) pos.z += time;\n\tpos *= m;\n    float fx = noise(pos);\n    float fy = noise(pos+vec3(1345.67,0,45.67));\n    return vec2(fx,fy);\n}\n\nbool affSlider(vec2 p0, vec2 dp, float v,int ticks)\n{\n\tfloat R=5.;\n\tvec2 pix = FragCoord.xy/iResolution.y;\n\tfloat pt = max(1e-2,1./iResolution.y); R*=pt;\n\tpix -= p0;\n\n\tfloat dp2 = dot(dp,dp);\n\tfloat x = dot(pix,dp)/dp2; if ((x<0.)||(x>1.)) return false;\n\tfloat x2=x*x;\n\tfloat y = dot(pix,pix)/dp2-x2; if (y>R*R) return false;\n\n\tFragColor = vec4(1.,.2,0.,1.); \n\ty = sqrt(y);\n\tif (y<pt) return true;       // rule\n\tvec2 p = vec2(x-v,y);\n\tif (dot(p,p)<R*R) return true; // button\n\tif ((ticks>0)&&\n\t (int(mod(FragCoord.x-p0.x,iResolution.y*dp.x/float(ticks)))==0)) return true;\n\n\treturn false;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime;\n    vec2 uv = fragCoord.xy / iResolution.y;\n\tuv = 2.*(uv - vec2(.8,.5));\n    FragCoord=fragCoord;\n\tFragColor = vec4(0.);\t\n\n\tvec2 val = iMouse.xy/iResolution.y;\n\t\n\n\tif (affSlider(vec2(.05,.02),vec2(.45,.0),val.x,0)) { fragColor=FragColor; return;}\n\tif (affSlider(vec2(.02,.05),vec2(0.,.45),val.y,0)) { fragColor=FragColor; return;}\n\t\n\tvec3 pos = vec3(5.*uv,0.5);\n\tvec3 col;\n\tfloat shape, noiz;\n\n\t\n#if 1 // galaxy gaz\n\n\tscale  = val.y;\n\tscaleW = val.x;\n\n\t// shape= fbmm(pos); // produits(noise[0..1])\n\n\tshape= fbmms(pos);   // produits(1+scale*noise[-1..1])\n\tshape = exp(-shape); // extinction\n\t//col = 1.-exp(-1.*shape*vec3(1.,.8,.6));\n\t\n\t//col = vec3(shape);     // draw \n\tcol = vec3(1.-shape);    // draw in white\n\t\n#else // various base noises\n\t\n\t// base shape = deformed disc\n\tshape = 1.-2.*dot(uv,uv);\n\tshape += .3*noises(.6*pos); \n\n\t// choose noise\n\tif     (MOD==0) noiz = fbm(pos);\n\telse if(MOD==1) noiz = fbms(pos);\n\telse if(MOD==2) noiz = fbma(pos);\n\telse if(MOD==3) noiz = fbmsa(pos);\n\telse if(MOD==4) noiz = fbmsma(pos);\n\telse if(MOD==5) noiz = fbmsma(pos)*fbmsma(pos+vec3(0.,0.,1.));\n\n\t// set true for the coef to tune with mouse.y\n\tfloat Ishape = (true) ? .2+2.*val.y : 1.;\n\tfloat Inoise = (false) ? .2+2.*val.y : 1.;\n\tshape = Ishape*shape + Inoise*noiz;\n\t\n    // non-linear distortion towards 0 or 1\t\n#define  PRE_POWER 1.\n#define POST_POWER 1.\t\n\tshape = clamp(shape,0.,1.);\n\tshape = pow(shape,PRE_POWER);\n\tshape = 1.-shape;\n\tshape = pow(shape,POST_POWER);\n\t\n\tcol = vec3(shape);\n\n#endif\n\t\n\t\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}