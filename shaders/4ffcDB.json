{
    "Shader": {
        "info": {
            "date": "1721618135",
            "description": "variation of Conways' Game of Life algorithm",
            "flags": 48,
            "hasliked": 0,
            "id": "4ffcDB",
            "likes": 1,
            "name": "ConwayVariation",
            "published": 3,
            "tags": [
                "conway"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 98
        },
        "renderpass": [
            {
                "code": "// Variation of Conway's Game of Life.\n// \n// In the classic version a cell becomes alive if it has 3 live neighbors,\n// and dies if it has less than 2 or more than 3 live neighbors.\n//\n// In this variation each cell also maintains a count of how many cycles it has been alive.\n// That count is accounted for when asked whether the cell is alive.\n//\n// Keyboard Commands:\n//\n// <Q>,<W> Weight. \n//         How much weight should the cycle count have? 0.0 == none  (classic version)\n// <A>,<S> Die low value (classic version = 2)\n//         Cell dies if neighbor count is less than this value\n// <Z>,<X> Die high value (classic version = 3)\n//         Cell dies if neighbot count is greater than this value\n// <E>,<R> Alive value (classic version = 3)\n//         Cell is born if neighbor count is this value (or less < 0.5 higher)\n//\n// <Return> Reset everything (starts with classic settings)\n// <Space>  Add some Population\n//\n// <1> ... <6>  interesting variations I stumbled upon (more to come I hope)\n//--------------------------------------------------------------\n\nvoid displaySettings(inout vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > iResolution.x * 0.5) return; // no printing in that region\n    if(fragCoord.y < iResolution.y * 0.65) return;\n\n    Font f;\n    setFont(f,iChannelResolution[3].xy / vec2(16, 16),iChannelResolution[3].xy);\n\n    TextCursor t;\n    float fSize = 20. + iResolution.x / 80.;  // 16 character string -> ~1/3 width of screen \n    vec2 charScale = vec2(fSize,fSize);\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.8,0.9) * charScale;\n    t.pageWidth = int(iResolution.x / t.charSize.x);\n    t.fragCoord = fragCoord;\n    \n    String str;\n    setString(str,10,(cQ,cW,cSp,cW,ce,ci,cg,ch,ct,cSp));\n    printString(str,t);\n    printFloat(qWeight,t);\n    newlineCursor(t);\n    t.fragCoord += vec2(0.,10.);\n    \n    setString(str,10, (cA,cS,cSp,cD,ci,ce,c1,cSp,cSp,cSp));\n    printString(str,t);\n    printFloat(qDie1,t);\n    newlineCursor(t);\n\n    setString(str,10, (cZ,cX,cSp,cD,ci,ce,c2,cSp,cSp,cSp));\n    printString(str,t);\n    printFloat(qDie2,t);\n    newlineCursor(t);\n    t.fragCoord += vec2(0.,10.);\n\n    setString(str,10, (cE,cR,cSp,cL,ci,cv,ce,cSp,cSp,cSp));\n    printString(str,t);\n    printFloat(qLive,t);\n    newlineCursor(t);\n\n    drawText(t, iChannel2, fragColor);\n}\n\n// ----------------------------------------------------------\n\nvec3 generateColor(float x) {\n\tx = sin(log(x));\n\n\tfloat r = (1.0-x)*(1.0-x);\n\tfloat g = x*x;\n\tfloat b = 2.0*(1.0-x)*x;\n\treturn vec3(r,g,b);\n}\n\n\n// ----------------------------------------------------------\n\nvoid drawGrid(inout vec4 fragColor,in vec2 fragCoord) {\n    // screen coord -> grid\n    fragCoord /= iResolution.xy;  // 0 ... 1\n    ivec2 addr = ivec2(int(float(GRIDX) * fragCoord.x),int(float(GRIDY) * fragCoord.y));\n\n    vec4 data = fetchData(iChannel0, addr);    \n    vec2 cell = isEvenFrame(iFrame) ? data.zw : data.xy;\n\n    if(cell.x > 0.) fragColor.xyz = vec3(1.0); // cell is alive\n    else fragColor.xyz = generateColor(cell.y);   // cycle count\n}\n\n// ---------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    drawGrid(fragColor,fragCoord);\n    \n    getSettings(iChannel0);\n    if(iFrame - int(qFrame) < 120)\n        displaySettings(fragColor,fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void saveSettings(inout vec4 fragColor,vec2 fragCoord) {\n    for(int i=0;i<ADDR_COUNT;++i)\n        if(storeDataAddr(fragCoord, addrList[i])) {\n            fragColor.xyz = q[i];\n            return;\n        }\n}\n\n// ----------------------------------------------------------\n\nconst ivec2[] neighborOffsets = ivec2[](\n    ivec2(-1,0 ),ivec2(1, 0),ivec2(0,-1),ivec2(0,1),\n    ivec2(-1,-1),ivec2(1,-1),ivec2(-1,1),ivec2(1,1));   \n\n\nivec2 neighborCoord(ivec2 base, int offsetIndex) {\n    ivec2 ans = base + neighborOffsets[offsetIndex];\n    if(ans.x < 0) ans.x = GRIDX-1; else if(ans.x >= GRIDX) ans.x = 0;\n    if(ans.y < 0) ans.y = GRIDY-1; else if(ans.y >= GRIDY) ans.y = 0;\n   \n    return ans;\n}\n\nvoid adjustColor(inout float color,float alive) {\n    if(alive > 0.) color = min(color+0.01,1.); else color = max(color-0.01,0.);\n}\n   \n// ----------------------------------------------------------\n\nbool shouldDie(float v,float count) {\n   return v > 0. && (count < qDie1 || count > qDie2);    \n}\n\nbool shouldAlive(float v,float count) {\n   return v == 0. && (count >= qLive && count < qLive + 0.5 );    \n}\n\nvoid evolveCell(inout vec4 color, vec2 coord) {\n    ivec2 adr = ivec2(coord);\n    vec4 cell = texelFetch(iChannel0,adr,0); \n        \n    float count = 0.;\n        \n    if(!isEvenFrame(iFrame)) {  // xy -> zw\n        for(int i=0;i<8;++i) {\n            vec4 v = texelFetch(iChannel0,neighborCoord(adr,i),0); \n            if(v.x > 0.) count += 1. + v.y * qWeight;\n        }\n        \n        color.zw = color.xy;\n        if(shouldDie(cell.x,count)) color.z = 0.; else\n        if(shouldAlive(cell.x,count)) color.z = 1.; \n        \n        adjustColor(color.w,color.z);\n    }\n    else {                     // zw -> xy\n        for(int i=0;i<8;++i) {\n            vec4 v = texelFetch(iChannel0,neighborCoord(adr,i),0); \n            if(v.z > 0.) count += 1. + v.w * qWeight;\n        }\n        \n        color.xy = color.zw;\n        if(shouldDie(cell.z,count)) color.x = 0.; else\n        if(shouldAlive(cell.z,count)) color.x = 1.; \n\n        adjustColor(color.y,color.x);\n    }\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n\tbool keyPressed = (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n    if(keyPressed) qFrame = float(iFrame);\n    return keyPressed;\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n    bool keyPressed = bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n    if(keyPressed) qFrame = float(iFrame);\n    return keyPressed;\n}\n\n// ----------------------------------------------------------\n\nconst float RNDCHANCE = 0.1;\n\nvoid resetDiffusion(inout vec4 color,vec2 coord) {\n    ivec2 adr = ivec2(coord);\n    if(adr.x < GRIDX && adr.y < GRIDY) {\n        if(rndStart(coord,iTime) < RNDCHANCE) \n            color = vec4(1.,0.,1.,0.);\n    }\n}\n\n// ----------------------------------------------------------\n\nconst float[] settings = float[](\n    0.,2.,3.,3.,\n    1.4,1.88,4.05,2.7,\n    0.5,1.87,4.83,2.69,\n    3.0999,2.1599,4.39,3.0299,\n    6.0,2.2999,4.52,3.0299,\n    2.2999,1.8699,4.8299,2.69,\n    3.2999,1.9898,4.9599,2.7999);\n\nvoid updateSettings(int index,inout vec4 fragColor,vec2 fragCoord) {\n    index *= 4;\n    qWeight = settings[index++];\n    qDie1 = settings[index++];\n    qDie2 = settings[index++];\n    qLive = settings[index];\n    resetDiffusion(fragColor,fragCoord);\n    saveSettings(fragColor,fragCoord);\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    getSettings(iChannel0); \n    fragColor = fetchData(iChannel0, ivec2(fragCoord));\n\n    if(keyClick(32,iChannel3)) { // <Space>\n        resetDiffusion(fragColor,fragCoord);\n        saveSettings(fragColor,fragCoord);\n        return;\n    }\n\n    if(iFrame < 2 || keyClick(13,iChannel3)) { // coldstart or <Return>\n        updateSettings(0,fragColor,fragCoord);\n        return;\n    }\n    \n    for(int i=1;i<7;++i) \n        if(keyClick(48+i,iChannel3)) {\n        updateSettings(i,fragColor,fragCoord);\n        return;\n    }\n\n    if(fragCoord.x < float(GRIDX) && fragCoord.y < float(GRIDY)) \n        evolveCell(fragColor,fragCoord);     \n    \n    // -----------------------------------------------------------------------------------\n    if(getKeyState(81,iChannel3)) qWeight = clamp(qWeight - 0.1,0.,7.); // Q\n    if(getKeyState(87,iChannel3)) qWeight = clamp(qWeight + 0.1,0.,7.); // W\n    \n    #define LDHOP 0.01\n    if(keyClick(65,iChannel3)) qDie1 = clamp(qDie1 - LDHOP,1.,7.); // A\n    if(keyClick(83,iChannel3)) qDie1 = clamp(qDie1 + LDHOP,1.,7.); // S\n    if(keyClick(90,iChannel3)) qDie2 = clamp(qDie2 - LDHOP,1.,7.); // Z\n    if(keyClick(88,iChannel3)) qDie2 = clamp(qDie2 + LDHOP,1.,7.); // X\n    if(keyClick(69,iChannel3)) qLive = clamp(qLive - LDHOP,1.,7.); // E\n    if(keyClick(82,iChannel3)) qLive = clamp(qLive + LDHOP,1.,7.); // R\n\n    saveSettings(fragColor,fragCoord); \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GRIDX  120*3  // terrain size\n#define GRIDY   80*3\n\n#define qWeight   q[0].x\n#define qDie1     q[0].y\n#define qDie2     q[0].z\n#define qLive     q[1].x\n#define qFrame    q[1].y  // frame# when edits were made\nconst int ADDR_COUNT = 2;\n\nvec3[ADDR_COUNT] q;\n\nconst ivec2 Q0 = ivec2( 0,GRIDY+1);\nconst ivec2 Q1 = ivec2( 1,GRIDY+1);\nconst ivec2[ADDR_COUNT] addrList = ivec2[](Q0,Q1);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\nvoid getSettings(sampler2D channel) { \n    for(int i=0;i<ADDR_COUNT;++i) \n        q[i] = texelFetch(channel, addrList[i],0).xyz;\n}\n\nbool isEvenFrame(int v) { return((v&1) == 0); }\n\n// ========================================================================\n// https://www.shadertoy.com/view/MtfGWM\n\nfloat previousRnd = 0.;\n\nfloat rnd(vec2 c) { return fract(sin(dot(vec2(1.317,19.753),c))*413.7972); } // 0...1\n\nfloat rndStart(vec2 coord, float t) {  // 0...1\n\tpreviousRnd += rnd(coord.xy + vec2(t * 217.0));\n    return previousRnd;\n}\n\n// ========================================================================\n// https://www.shadertoy.com/view/mdsSD7\n\nconst int maxStringLength = 24;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12),\n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12)\n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11),\n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11),\n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11),\n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10),\n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10)\n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9),\n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9),\n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9),\n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8),\n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8)\n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    int count;\n    ivec2[maxStringLength] chars;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char) {\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\nvoid printInt(int val, inout TextCursor t) {\n    if(val < 0) {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    if(val < 100) printChar(cSp,t);\n    if(val < 10) printChar(cSp,t);\n    \n    for(;;)  {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n}\n\nvoid printFloat(float val, inout TextCursor t)\n{\n    if(val < 0.0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;)\n    {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n    \n    printChar(cDot, t);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++)\n    {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor) {\n    if(length(t.outColor) > 0.) {\n        if(texture(fontTexture, t.outUV).r < 0.2)\n            fragColor = vec4(0.2);\n        else\n            fragColor = t.outColor;\n    }\n        \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}