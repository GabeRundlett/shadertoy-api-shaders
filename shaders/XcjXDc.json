{
    "Shader": {
        "info": {
            "date": "1706904379",
            "description": "Converting a normal map to a height map via filter inversion in frequency space.",
            "flags": 48,
            "hasliked": 0,
            "id": "XcjXDc",
            "likes": 17,
            "name": "Height Map from Normal Map",
            "published": 3,
            "tags": [
                "normalmap",
                "filtering",
                "heightmap"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 490
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm/status/1754581767405621665\n\n/*\n    Converting a normal map to a height map via filter inversion in frequency space.\n    \n    \n    Left : normal map (press shift to toggle between normal map and original height map)\n    \n    Right: height map (press ctrl to toggle between (recovered) height map and abs(error) in recovered height map)\n    \n    \n    Buffer A: read normal map + output derivatives\n    \n    Buffer B: horizontal DFT of derivatives map\n    \n    Buffer C: vertical DFT of derivatives map + filter inversion + output frequency space height map\n    \n    Buffer D: horizontal inverse DFT of frequency space height map\n    \n    Image   : vertical inverse DFT of frequency space height map + presentation\n    \n    \n    The idea here is to (re-)integrate the normal map in frequency space where doing so is pretty straightforward.\n    \n    The derivative of cos(k*x)\n    is             -k*sin(k*x).\n    \n    To re-integrate we therefore divide every fourier coefficient by k and apply a -90° phase shift.\n    If we want to specifically invert the result of a central difference kernel there is an \n    additional attenuation in the higher frequencies we need to compensate for (see Buffer C).\n    \n    To simplify things a bit the height map used here is set up so that it averages to 0.\n    This makes it easier to compare the original to the recovered height map.\n    In a practical setting one might also want to compute the\n    min and max values of the recovered height map and remap it to [0, 1].\n*/\n\n\n/*\n    vertical inverse DFT of frequency space height map + presentation\n*/\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x;}\n\nvec4 Read_DFT(vec2 uv0)\n{\n    ivec2 uv2 = ivec2(uv0 - 0.5);\n    int size = int(SIZE);\n    uv2 += size/2;\n    if(uv2.x >= size) uv2.x -= size;\n    if(uv2.y >= size) uv2.y -= size;\n    vec4 dft = texelFetch(iChannel1, uv2, 0);\n    \n    return dft;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    float size = SIZE;\n    \n    uv0.y -= floor((iResolution.y - size) * 0.5);\n    \n    vec3 col = vec3(0.0);\n    outCol = vec4(0.0);\n\n    if(uv0.y < 0.0 || uv0.y >= size)\n    {\n        return;\n    }\n    \n    vec2 res = vec2(0.0);\n    \n    if(uv0.x < size)\n    {\n        if(ReadKeyToggle(KEY_SHIFT) == 0.0)\n        {\n            vec2 dxy = texelFetch(iChannel0, ivec2(uv0-0.5), 0).xz;\n\n            vec3 N = normalize(vec3(-dxy, 0.02));\n\n            outCol = vec4(N * 0.5 + 0.5, 1.0);// normal map (generated from original height map)\n        }\n        else\n        {\n            float ref = Read_Height(uv0 - 0.5, iTime, size);\n        \n            outCol = vec4(vec3(ref) * 0.5 + 0.5, 0.0);// original height map\n        }\n        \n        return;\n    }\n    else\n    {\n        uv0.x -= size;\n        \n        vec2 uv = uv0.xy - 0.5;\n        \n        // vertical iDFT pass\n        for(float i = 0.0; i < size; ++i)  \n        {\n            vec4 v = texelFetch(iChannel2, ivec2(uv.x, i), 0);\n\n            float ang = Pi2/size * (uv.y * i);\n\n            res.xy += cmul(v.xy, ang);\n        }\n        \n        if(ReadKeyToggle(KEY_CTRL) == 0.0)\n        {\n            col.rgb = res.rrr * 0.5 + 0.5;// recovered height map\n        }\n        else\n        {\n            float ref = Read_Height(uv, iTime, size);\n        \n            col.rgb = abs(abs(res.r - ref)) * exp2(14.0) * vec3(1.0);// absolute error in recovered height map\n        }\n        \n        outCol = vec4(col, 1.0);\n        \n        return;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n#define SIZE (floor(iResolution.y/2.25)*2.0)\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\nvec2 cmul(vec2 c, float ang)\n{\n    return cmul(c, vec2(cos(ang), sin(ang)));\n}\n\nfloat Read_Height(vec2 uv, float time, float size)\n{    \n    float v = 0.0;\n\n    vec2 tc = fract(uv / size);\n\n    v += sin((tc.x-tc.y - time*0.5)*2.0 * (2.0*Pi)) * 0.2;\n    v += sin((tc.x-tc.y*2.0 - time*0.35+v*0.5)*1.0 * (2.0*Pi)) * .2;\n    v += sin((tc.x*2.0-tc.y + time*0.2-v*0.5)*1.0 * (2.0*Pi)) * .1;\n\n    //v = min(v, 0.4);\n\n    {\n        vec2 vec = tc - vec2(0.25, 0.25);\n    \n        float u = sqrt(max(0.0, 1.0 - dot(vec, vec) / Pow2(0.24)));\n        u = min(u, 0.9);\n        //v = mix(v, max(v, u), u);\n        v += u * 0.5;\n    }\n    \n    {\n        vec2 vec = tc - vec2(0.75, 0.75);\n    \n        float u = sqrt(max(0.0, 1.0 - dot(vec, vec) / Pow2(0.24)));\n        u = min(u, 0.9);\n        \n        //v = mix(v, min(v, -u), u);\n        v -= u * 0.5;\n    }\n    \n    return v;\n}\n\nvec3 Read_Normal(vec2 uv, float time, float size)\n{\n    // central difference\n    float dx = (Read_Height(uv + vec2(1.0, 0.0), time, size) - \n                Read_Height(uv - vec2(1.0, 0.0), time, size)) * 0.5;\n    float dy = (Read_Height(uv + vec2(0.0, 1.0), time, size) - \n                Read_Height(uv - vec2(0.0, 1.0), time, size)) * 0.5;\n    \n    vec3 N = normalize(vec3(-dx, -dy, 1.0));\n    \n    return N;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    read normal map + output derivatives\n*/\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    float size = SIZE;\n    \n    if(uv0.x > size || uv0.y > size)\n    {\n        discard;\n    }\n    \n    vec2 uv = uv0 - 0.5;\n    \n    vec3 N = Read_Normal(uv, iTime, size);\n    \n    // recover derivatives\n    float dx = -N.x / N.z;\n    float dy = -N.y / N.z;\n    \n    outCol = vec4(dx, 0.0, dy, 0.0);\n    \n    return;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    horizontal DFT of derivatives map\n*/\n\nvoid mainImage(out vec4 outCol, vec2 uv0)\n{\n    float size = SIZE;\n    \n   \toutCol = vec4(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n    \n    if(uv0.x >= size || uv0.y >= size) discard;\n    \n    // horizontal DFT pass\n    for(float i = 0.0; i < size; ++i)  \n\t{\n\t\tvec4 v = texelFetch(iChannel0, ivec2(i, uv.y), 0);\n        \n\t\tfloat ang = -Pi2/size * (uv.x * i);\n        \n\t\toutCol.xy += cmul(v.xy, ang);\n\t\toutCol.zw += cmul(v.zw, ang);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    vertical DFT of derivatives map + filter inversion + output frequency space height map\n*/\n\nvoid mainImage(out vec4 outCol, vec2 uv0)\n{\n    float size = SIZE;\n    \n   \toutCol = vec4(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n    \n    if(uv0.x >= size || uv0.y >= size) discard;\n    \n    // vertical DFT pass\n    for(float i = 0.0; i < size; ++i)  \n\t{\n\t\tvec4 v = texelFetch(iChannel0, ivec2(uv.x, i), 0);\n        \n\t\tfloat ang = -Pi2/size * (uv.y * i);\n        \n\t\toutCol.xy += cmul(v.xy, ang);\n\t\toutCol.zw += cmul(v.zw, ang);\n    }\n    \n    outCol /= size*size;\n    \n    // FILTER INVERSION:\n    vec4 res = outCol;\n\n    // [0, size) -> [-size/2, size/2); makes uv match coefficient index/wave number\n    if(uv.x >= size*0.5) uv.x -= size;\n    if(uv.y >= size*0.5) uv.y -= size;\n    \n    // normalized coefficient index\n    vec2 u = uv * (Pi / (size*0.5));\n    \n    u = sin(u);// central difference; comment out to assume sinc kernel\n    \n    // reverse differentiation: -90° shift + div out amplitude response\n    vec4 res2 = vec4(res.y, -res.x, res.w, -res.z) / u.xxyy;\n    \n    // masks for valid coefficients\n    bool maskA = uv.x != 0.0 && abs(uv.x) != size*0.5;\n    bool maskB = uv.y != 0.0 && abs(uv.y) != size*0.5;\n\n    // flush invalid coefficients\n    if(!maskA) res2.xy = vec2(0.0);\n    if(!maskB) res2.zw = vec2(0.0);\n\n    // patch in missing coefficients\n    res.xy = maskA ? res2.xy : res2.zw;\n    res.zw = maskB ? res2.zw : res2.xy;\n    \n    if(uv.x != 0.0 || uv.y != 0.0)\n    {\n        vec2 d = normalize(uv);\n        \n        // mix both results for better numerical accuracy\n        res.xy = res.xy*(d.x*d.x) + res.zw*(d.y*d.y);\n    }\n    else\n    {\n        res = vec4(0.0);// lost DC/integration constant\n    }\n    \n    outCol = vec4(res.xy, 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    horizontal inverse DFT of frequency space height map\n*/\n\nvoid mainImage(out vec4 outCol, vec2 uv0)\n{\n    float size = SIZE;\n    \n   \toutCol = vec4(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n    \n    if(uv0.x >= size || uv0.y >= size) discard;\n    \n    // horizontal iDFT pass\n    for(float i = 0.0; i < size; ++i)  \n\t{\n\t\tvec4 v = texelFetch(iChannel0, ivec2(i, uv.y), 0);\n        \n\t\tfloat ang = Pi2/size * (uv.x * i);\n        \n\t\toutCol.xy += cmul(v.xy, ang);\n\t\t//outCol.zw += cmul(v.zw, ang);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}