{
    "Shader": {
        "info": {
            "date": "1474875905",
            "description": "Rework of [url=https://www.shadertoy.com/view/ltfXDM]A lonely diamond[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "XlyGDm",
            "likes": 10,
            "name": "Diamond ring",
            "published": 3,
            "tags": [
                "transparency",
                "diamond"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 919
        },
        "renderpass": [
            {
                "code": "// Global rendering switch\n//#define FAST\n\n// Rendering parameters\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_BOUNCE_MAX\t\t10\n#define RAY_STEP_MAX\t\t100\n#define LIGHT\t\t\t\tvec3 (-1.0, 0.5, 0.0)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.8\n#define DIAMOND_FACES\t\t8.0\n#define RING_ROTATE\t\t\tPI * 0.465\n#define RING_TRANSLATE\t\t3.0\n#define TRAY_HEIGHT\t\t\t1.3\n\n// Rendering options (for those who have a slow GPU)\n#define PROPAGATION\n#ifndef FAST\n\t#define DISPERSION\n\t#define COVER\n#endif\n\n// Macros used to handle color channels\n#ifdef DISPERSION\n\t#define COLOR float\n\t#define CHANNEL(x) dot (x, channel)\n#else\n\t#define COLOR vec3\n\t#define CHANNEL(x) x\n#endif\n\n// Math constants\n#define DELTA\t0.01\n#define PI\t\t3.14159265359\n\n// Rotation on the X axis\nvec3 rotateX (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (p.x, c * p.y + s * p.z, c * p.z - s * p.y);\n}\n\n// Rotation on the Y axis\nvec3 rotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\n// Materials\nstruct Material {\n\tvec3 color;\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\n\tvec3 refractIndex; // not used if behavior < 0.0\n};\nMaterial getMaterial (in int materialIndex) {\n\tMaterial material;\n\tif (materialIndex == 0) { // Ring\n\t\tmaterial = Material (vec3 (1.0, 1.0, 0.8), -0.5, vec3 (1.50, 1.55, 1.60));\n\t} else if (materialIndex == 1) { // Diamond\n\t\tmaterial = Material (vec3 (0.9, 0.9, 1.0), 0.7, vec3 (2.407, 2.426, 2.451));\n\t} else if (materialIndex == 2) { // Tray\n\t\tmaterial = Material (vec3 (0.5, 0.5, 0.7), -0.4, vec3 (1.50, 1.55, 1.60));\n\t} else { // materialIndex == 3 // Cover\n\t\tmaterial = Material (vec3 (1.0, 1.0, 1.0), 0.8, vec3 (1.50, 1.55, 1.60));\n\t}\n\treturn material;\n}\n\n// Distance to the ring\nfloat getDistanceRing (in vec3 p) {\n\tvec2 q = vec2 (length (p.xy) - 7.8, p.z);\n\tfloat d1 = max (length (q) - 0.6, -0.2 - q.x);\n\tfloat d2 = length (max (abs (vec3 (abs (p.x), p.y, abs (p.z)) - vec3 (0.7, 8.2, 0.7)) - vec3 (0.1, 0.5, 0.1), 0.0)) - 0.1;\n\treturn min (d1, d2);\n}\n\n// Distance to the diamond\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\nfloat getDistanceDiamond (in vec3 p) {\n\tp.y -= 10.0;\n\tfloat topCut = p.y - 1.0;\n\tfloat angleStep = PI / DIAMOND_FACES;\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\n\tvec3 q = rotateY (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0;\n\tfloat topC = dot (q, normalTopC) - 1.5;\n\tfloat bottomA = dot (q, normalBottomA) - 1.7;\n\tq = rotateY (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan (q.x, q.z) / angleStep);\n\tq = rotateY (p, angle);\n\tfloat topB = dot (q, normalTopB) - 1.85;\n\tfloat bottomB = dot (q, normalBottomB) - 1.9;\n\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\n// Distance to the tray\nfloat getDistanceTray (in vec3 p) {\n\tp.y += TRAY_HEIGHT;\n\tfloat d = length (p.xz);\n\treturn max (min (d - 4.0, max (d - 17.0, -p.y - 1.0)), p.y);\n}\n\n// Distance to the cover\nfloat getDistanceCover (in vec3 p) {\n\tp.y += TRAY_HEIGHT + 4.0;\n\tfloat d = length (p) - 17.0;\n\treturn max (max (d, -d - 1.0), -p.y + 3.5);\n}\n\n// Distance to a given material\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\n\tfloat materialDist;\n\tif (materialIndex == 0) {\n\t\tmaterialDist = getDistanceRing (q);\n\t} else if (materialIndex == 1) {\n\t\tmaterialDist = getDistanceDiamond (q);\n\t} else if (materialIndex == 2) {\n\t\tmaterialDist = getDistanceTray (p);\n\t#ifdef COVER\n\t} else { // materialIndex == 3\n\t\tmaterialDist = getDistanceCover (p);\n\t#endif\n\t}\n\treturn materialDist;\n}\n\n// Distance to the scene\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\n\n\t// Air\n\tmaterialTo = -1;\n\tfloat sceneDist = RAY_LENGTH_MAX;\n\n\t// Ring\n\tfloat materialDist = getDistanceRing (q);\n\tMATERIAL_PROCESS (0)\n\n\t// Diamond\n\tmaterialDist = getDistanceDiamond (q);\n\tMATERIAL_PROCESS (1)\n\n\t// Tray\n\tmaterialDist = getDistanceTray (p);\n\tMATERIAL_PROCESS (2)\n\n\t// Cover\n\t#ifdef COVER\n\tmaterialDist = getDistanceCover (p);\n\tMATERIAL_PROCESS (3)\n\t#endif\n\n\t// Return the distance\n\treturn sceneDist;\n}\n\n// Normal at a given point\nvec3 getNormal (in vec3 p, in int materialIndex) {\n\tconst vec2 h = vec2 (DELTA, -DELTA);\n\treturn normalize (\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\n\t);\n}\n\n// Cast a ray for a given color channel (and its corresponding refraction index)\nvec3 lightDirection = normalize (LIGHT);\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\n\n\t// Check the behavior of the material\n\tMaterial material = getMaterial (materialTo);\n\tfloat alpha = abs (material.behavior);\n\tcolor *= 1.0 - alpha;\n\n\t// The ray continues...\n\tint materialFrom = -1;\n\tfloat refractIndexFrom = 1.0;\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\n\n\t\t// Interface with the material\n\t\tfloat refractIndexTo;\n\t\tvec3 refraction;\n\t\tif (materialTo == -1) {\n\t\t\trefractIndexTo = 1.0;\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\n\t\t} else {\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\n\t\t}\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflect (direction, normal.xyz);\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tmaterialFrom = materialTo;\n\t\t\trefractIndexFrom = refractIndexTo;\n\t\t}\n\n\t\t// Ray marching\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\n\t\t\tnormal.w += dist;\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * dist;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tif (materialFrom == materialTo) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tif (materialTo == -1) {\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\n\t\t} else {\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t\t// Basic lighting\n\t\t\tmaterial = getMaterial (materialTo);\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\n\t\t\tfloat localAlpha = abs (material.behavior);\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\n\t\t\talpha *= localAlpha;\n\t\t}\n\t}\n\n\t// Get the background color\n\tCOLOR backColor = CHANNEL (texture (iChannel0, -direction).rgb);\n\n\t// Return the intensity of this color channel\n\treturn color + backColor * alpha;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 4.0));\n\n\t// Set the camera\n\tvec3 origin = (35.0 + 10.0 * cos (iTime * 0.5)) * vec3 (cos (iTime * 0.1), 0.6 + 0.5 * sin (iTime * 0.2), sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\torigin.z += 6.0;\n\n\t// Cast the initial ray\n\tvec4 normal = vec4 (0.0);\n\tint materialTo = -1;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\n\t\tnormal.w += dist;\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += direction * dist;\n\t}\n\n\t// Check whether we hit something\n\tif (materialTo == -1) {\n\t\tfragColor.rgb = texture (iChannel0, -direction).rgb;\n\t} else {\n\n\t\t// Get the normal\n\t\tnormal.xyz = getNormal (origin, materialTo);\n\n\t\t// Basic lighting\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\n\n\t\t// The ray continues...\n\t\t#ifdef PROPAGATION\n\t\t\t#ifdef DISPERSION\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\n\t\t\t#else\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\n\t\t\t#endif\n\t\t#endif\n\t}\n\n\t// Set the alpha channel\n\tfragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}