{
    "Shader": {
        "info": {
            "date": "1629864618",
            "description": "why are there cubes\n\nidk why I couldn't quite get the fllor on line 68 to line up correctly\nalso if anyone knows why is gets grainy as it gets to ~300 iTime, that would be appreciated.",
            "flags": 0,
            "hasliked": 0,
            "id": "NddGWN",
            "likes": 6,
            "name": "CubeLand",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "trippy",
                "polar",
                "logpolar"
            ],
            "usePreview": 0,
            "username": "scry",
            "viewed": 323
        },
        "renderpass": [
            {
                "code": "#define time iTime\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 map(vec3 p) {\n    \n    p.z -= 5.;\n    //p.z += time*20.; \n    //p.xy -= (sin(time)*3);\n    //p.yz *= r2d(-02);\n    vec3 o = p;\n    float d = 1000.;\n    p = o;\n    float lxz = (length(p.xz));\n    //vec2 pc = p.xz;\n    vec2 pc = vec2(log(lxz),atan(p.x,p.z));\n    //p.y += (sin(pc.x*10.-time*30)+sin(pc.y*1.+lxz+time*10.)*3)*0.01*lxz;\n    //pc.y += time*0.01;\n    //pc = vec2(log(length(pc)),atan(pc.x,pc.y));\n    \n    float ns = 1.;\n    //pc.y *= 3./3.141;\n    //pc.y = (fract(pc.y-0.5));\n    //pc.y *= 2./3.141;\n    \n    pc.x -= time*0.3;\n\n\n    vec3 bp = p;\n    float fy = 0.;\n    float bps = 0.6;\n    vec2 fpc = pc;\n    //fpc.y *= .;\n    //fpc.x *= 16./3.14159; \n    fpc = floor(fpc/bps)*bps;\n   \n    //fpc.y = floor(fpc.y/bps)*bps;\n    //fpc.y += sin(time);\n    for (int i=0;i<4;i++) {\n        ns += 1.0;\n        //p.y += (sin(pc.x*10*ns*0.1*pc.y*0.00)*0.4)*lxz*0.1;\n        p.y += (sin(pc.y*6.*ns*0.5+pc.x*sin(ns*0.5)*10.)*0.04)*lxz;\n        p.y += (sin(pc.y*2.*ns*0.5+pc.x*sin(ns*20.)*20.)*0.04)*lxz;\n        fy += (sin(fpc.y*6.*ns*0.5+fpc.x*sin(ns*0.5)*10.)*0.04)*lxz;\n        fy += (sin(fpc.y*2.*ns*0.5+fpc.x*sin(ns*20.)*20.)*0.04)*lxz;\n        //p.y += (sin(pc.x*sin(ns)*20.03)+sin(pc.y*sin(ns)*40.+pc.x*0.1))*0.01*lxz;\n        //p.y += (sin(pc.x*ns-time*3*ns+pc.y)+sin(pc.y*ns+pc.x))*0.04*lxz;\n        \n    }\n    bp.zx = pc;\n    //bp.z *= 1;\n    bp.y += 1.; \n    bp.x /= 1./bps;\n    bp.x *= 8./3.14159;\n    bp.x += sin(bp.z*.1)*5.;\n    bp.xz = (fract(bp.xz/bps)-0.5)*bps;\n    //bp.y /= lxz;\n    //bp.y += -0.05;\n    \n    bp.y += (fy*sin(log(lxz)*2.+time));\n    bp.y -= 0.2;\n    bp.y /= lxz;\n    bp.xz *= r2d(pc.y*0.1);\n    bp.xy *= r2d(pc.y*0.4);\n    //bp.y *= 0.3;\n    float db = sdBoxFrame(bp,vec3(0.03),0.004)*(lxz+0.1)*0.5;\n    //db *= lxz;\n    //db *= 0.99;\n    //db -= 0.001;\n    //d = min(d,//);\n    //pc.y *= 3./3.141;\n    //pc.y = (fract(pc.y-0.5));\n    //pc.y += 1./3.14;\n    \n    //pc.y *= 10./3.14;\n    //p.y += sin(pc.y*10.+pc.x*20.+time*4.)*0.2;\n    //p.y += lxz;\n    if (p.y+1. > db) {\n        pc.y -= 2.;\n    }\n    d = db-0.;\n    d = min(d,length(p.y+1.)*0.3);\n    //d += 0.01;\n    //float d = length(p)-1.;\n    return vec4(pc.x,lxz,pc.y,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<64;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii += 0.02;\n        if (dO > 24.2 || dS < 0.0005) {break;}\n    }\n    return vec2(dO,ii);\n}\n\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.00003; // or some other value\n    const vec2 h = vec2(eps,0.);\n    return normalize( vec3(map(p+h.xyy).w - map(p-h.xyy).w,\n                           map(p+h.yxy).w - map(p-h.yxy).w,\n                           map(p+h.yyx).w - map(p-h.yyx).w ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * (fragCoord/iResolution.xy);\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x*=ar;\n    float c = length(uv);\n    //uv.y -= 0.3;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,0.,2.);\n    vec3 rd = normalize(vec3(uv,.75+c*0.75));\n    vec2 ra = vec2(cos(time),sin(time))*0.3;\n\n    //ro.z += sin(uv.x*4.*uv.y+time*2.)-c*2.;\n    //ro.z *= 0.2;\n    //ra.z += sin(time+sin(uv.x));\n    //ra.x += floor(sin((uv.x*1.)*150.*(sin(uv.x*0.01+time*0.1)*0.5+0.5)))*0.1;\n    //ra.y += floor(sin((uv.y*1.)*150.*(sin(uv.y*0.01+time*0.08)*0.5+0.5)))*0.1;\n    //ra.x += sin(uv.y*1.+time)*0.2;\n    //ro.xz *= r2d(ra.x);\n    //rd.xz *= r2d(ra.x);\n    //ro.yz *= r2d(ra.y);\n    rd.yz *= r2d(-.25);\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    \n    vec3 mp = map(p).xyz;\n    //p.xy *= r2d(time);\n    vec3 norm = calcNormal(p);\n    p.z -= 5.;\n    float lz = length(p.xz);\n    \n    //col = 1.-d.xxx*.1;\n    col = hsv2rgb(vec3(floor(mp.z/3.14/2.*5.+mp.x*0.4)/5.,floor(sin(mp.x*10.1+mp.z*2.)*2.)/2.,(1.15-d.x*0.2)));\n    \n    //col = hsv2rgb(vec3(floor(mp.z/3.14/2*5.+mp.x*0.4)/5.,floor(sin(mp.x*10.1+mp.z*2.)*2.)/2,clamp(1.-d.x*0.1,0.,1.)));\n    col += (clamp(sin(mp.z*30.)+sin(mp.x*90.),-0.,0.1)*5.-0.5)+d.y*0.08;\n    norm.xz *= r2d(mp.x*0.2);\n    col += (norm.x*2.)*0.4;\n    //col.rg += (d.y*0.05-0.5);\n    fragColor = vec4(col,1.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}