{
    "Shader": {
        "info": {
            "date": "1673379478",
            "description": "An iterated FIR filter generates mouse trails which drlift around.\n\nUse (shift)-click-and-drag.\n\nParticles binned into bounding boxes to avoid excess computation at each pixel (0 view, tab disables).\n\nBased on: https://scratch.mit.edu/projects/783499452/",
            "flags": 48,
            "hasliked": 0,
            "id": "dtS3Dw",
            "likes": 9,
            "name": "wiggly worm",
            "published": 3,
            "tags": [
                "particles",
                "feedback",
                "mousetrails"
            ],
            "usePreview": 0,
            "username": "sh1boot",
            "viewed": 330
        },
        "renderpass": [
            {
                "code": "\n\n// from https://www.shadertoy.com/view/ll2GD3\nvec3 palette(int i) {\n    float t = float(i) * 0.01;\n    vec3 a = vec3(0.5,0.5,0.5), b = vec3(0.5,0.5,0.5), c = vec3(1.0,1.0,1.0), d = vec3(0.0,0.33,0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec4 get_point(int i) {\n    return array0(clamp(i, 0, num_points - 1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 mask = texture(iChannel1, fragCoord / (iResolution.xy * bitmap_scale));\n\n    fragColor = vec4(0.0);\n    const int bins_per_word = num_bins / 4;\n    for (int w = 0; w < 4; ++w) {\n        for (int wo = 0; wo < bins_per_word && (mask.x > 0.0 || DRAW_ALL); ++wo) {\n            int i = w * bins_per_word + wo;\n            int start = i * num_points / num_bins;\n            int end = (i + 1) * num_points / num_bins;\n            if (fract(mask.x) >= 0.5 || DRAW_ALL) {\n                vec2 p0 = get_point(start - 2).xy;\n                vec2 p1 = get_point(start - 1).xy;\n                vec2 p2 = get_point(start - 0).xy;\n                for (int j = start; j < end; ++j) {\n                    vec2 p3 = get_point(j + 1).xy;\n                    float trail = 2.0 / \n                        (NO_CUBIC ? line(fragCoord, p1, p2) : spline(fragCoord, p0, p1, p2, p3));\n                    float fade = 1.0 - smoothstep(0.75 * float(num_points), float(num_points), float(j));\n                    trail = max(0., trail - 0.1);\n\n                    fragColor = max(fragColor, vec4(trail * fade * palette(j), 1.0));\n\n                    p0 = p1;\n                    p1 = p2;\n                    p2 = p3;\n                }\n                if (SHOW_BOXES) fragColor.xyz = max(fragColor.xyz + 0.01, vec3(0.2));\n            }\n            mask.x = fract(mask.x * 2.0);\n        }\n        mask = mask.yzwx;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Set the first particle to the mouse position, then apply a FIR filter with time offset across the list of particles to produce wobbly trails.\n\n\nconst int window_length = 8;\nconst float window_offset = 4.2;\n\nfloat window_lut(int i) {\n    const float window[] = float[](\n        0.0,\n        0.3,\n        0.2,\n        0.75,\n        -0.14,\n        -0.11,\n        0.0,\n        0.0\n    );\n    if (i < 0 || window.length() <= i) return 0.0;\n    return window[i];\n}\n\nfloat window(int i) {\n    const float window[] = float[](\n        0.0,\n        0.3,\n        0.2,\n        0.75,\n        -0.14,\n        -0.11,\n        0.0,\n        0.0\n    );\n    float wf = fract(window_offset);\n    return interpolate(window_lut(i - 1),\n                       window_lut(i - 0),\n                       window_lut(i + 1),\n                       window_lut(i + 2), wf);\n}\n\n\nvec4 random_walk(vec4 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p *= (1.0 / iResolution.xy).xyxy;\n    p += (nrand2(vec2(iTime, 0)) * mat2(c,s,-s,c)).xyxy * 0.008;\n    c = cos(iTime * 3.5), s = sin(iTime * 3.1);\n    p += (nrand2(vec2(iTime, 1)) * mat2(c,s,-s,c)).xyxy * 0.007;\n    p += (0.5 - p) * 0.02;\n    p *= iResolution.xyxy;\n    return p;\n}\n\nvec4 get_mouse_or_whatever() {\n    vec4 previous = iFrame < 1 ? iResolution.xyxy * 0.5 : array0(0);\n\n    if (RESPONSIVE_MOUSE) return iMouse;\n\n    if (all(lessThan(iMouse.xy, vec2(3)))) {\n        return random_walk(previous);\n    }\n\n    previous.xy += (iMouse.xy - previous.xy) * 0.1;\n    return previous;\n}\n\n\nvec4 get_point(int i) {\n    return array0(clamp(i, 0, num_points - 1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 g = 0.5 * (vec2(cos(iTime * 1.1), sin(iTime * 1.1)) + 0.5) * iResolution.xy;\n    int i = index(fragCoord);\n    if (i >= num_points) discard;\n\n    if (iFrame < 1 || i < 1) {\n        fragColor = get_mouse_or_whatever();\n        return;\n    }\n\n    fragColor = vec4(0.0);\n    float window_sum = 0.0;\n    for (int j = 0; j < window_length; ++j) {\n        float w = window(j);\n        window_sum += w;\n        fragColor += w * get_point(i + j - int(window_offset));\n    }\n    fragColor *= 1.0 / window_sum;\n    fragColor += 0.001 * (g.xyxy - fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int num_points = 256;\nconst int num_bins = 64;\n\nconst int neighbours = 1;  // lines must connect with neighbouring bin points.\nconst float radius = 16.0;  // a bit of slop for line width, glow, and interpolation overshoot\n\nconst float bitmap_scale = 8.0;\n\n#define RESPONSIVE_MOUSE (texelFetch(iChannel3, ivec2(16,0),0).x >= 0.5)  // shift -- go directly to mouse, without smoothing filter\n#define DRAW_ALL (texelFetch(iChannel3, ivec2(9,2),0).x >= 0.5)      // tab toggles bounding box optimisation\n#define SHOW_BOXES (texelFetch(iChannel3, ivec2(48,2),0).x >= 0.5)   // '0' toggles bounding box highlight\n#define NO_CUBIC (texelFetch(iChannel3, ivec2(49,2),0).x >= 0.5)     // '1' toggles cubic/linear interpolation\n\n#define index(fc) int(floor(fragCoord.x) + floor(fragCoord.y) * iResolution.x)\n#define array0(i) array(i, iChannel0, int(iResolution.x))\n#define array1(i) array(i, iChannel1, int(iResolution.x))\n\nvec4 array(int i, sampler2D tex, int tw) {\n    return texelFetch(tex, ivec2(i % tw, i / tw), 0);\n}\n\nfloat nrand( vec2 n ) {\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\nvec2 nrand2( vec2 n ) { return vec2(nrand(n * vec2(-3.2145, 1.2345)),\n                                    nrand(n * vec2(-5.4321, 3.4521))); }\n\n\nfloat cubic(float t) {\n    const float a = -0.5;\n    t = abs(t);\n    float t3 = t * t * t;\n    float t2 = t * t;\n    if (t <= 1.) return (a + 2.) * t3 - (a + 3.) * t2 + 1.;\n    if (t < 2.) return a * t3 - 5. * a * t2 + 8. * a * t - 4. * a;\n    return 0.;\n}\n\nvec2 interpolate(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    return p0 * cubic(t + 1.)\n         + p1 * cubic(t + 0.)\n         + p2 * cubic(t - 1.)\n         + p3 * cubic(t - 2.);\n}\n\nfloat interpolate(float p0, float p1, float p2, float p3, float t) {\n    return p0 * cubic(t + 1.)\n         + p1 * cubic(t + 0.)\n         + p2 * cubic(t - 1.)\n         + p3 * cubic(t - 2.);\n}\n\n// Line SDF from Inigo Quilez\nfloat line(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - h * ba);\n}\n\nfloat spline(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    vec2 i125 = interpolate(p0, p1, p2, p3, 0.25);\n    vec2 i150 = interpolate(p0, p1, p2, p3, 0.5);\n    vec2 i175 = interpolate(p0, p1, p2, p3, 0.75);\n    float l0 = line(p, p1,   i125);\n    float l1 = line(p, i125, i150);\n    float l2 = line(p, i150, i175);\n    float l3 = line(p, i175, p2);\n    return min(min(l0, l1), min(l2, l3));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Separate particles into a set of bins and generate bounding boxes for each bin.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int i = index(fragCoord);\n    if (i >= num_bins) discard;\n\n    fragColor = vec4(1,1,-1,-1) * 1000000.0;\n    int start = max(0, i * num_points / num_bins - neighbours);\n    int end = min(num_points - 1, (i + 1) * num_points / num_bins + neighbours);\n    for (int j = start; j < end; j++) {\n        // TODO: Do the cubic interpolation here to make sure we consider overshoot.\n        fragColor.xy = min(fragColor.xy, array0(j).xy);\n        fragColor.zw = max(fragColor.zw, array0(j).xy);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// For each pixel, produces a bitmap of bins which are relevant.\n\nconst vec4 test_window = vec4(-1,-1,1,1) * radius + vec4(0,0,1,1) * bitmap_scale;\n\n\nbool near_any_points(vec2 c, int i) {\n    c += bitmap_scale * 0.5;\n    int start = max(0, i * num_points / num_bins - neighbours);\n    int end = min(num_points - 1, (i + 1) * num_points / num_bins + neighbours);\n    vec2 p0 = array1(start).xy;\n    for (int j = start + 1; j < end; ++j) {\n        vec2 p1 = array1(j).xy;\n        if (line(c, p0, p1) < (radius + bitmap_scale)) return true;\n        p0 = p1;\n    }\n    return false;\n}\n\nbool small_box(vec4 box) {\n    return distance(box.xy, box.zw) < radius * radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= bitmap_scale;\n    if (!all(lessThan(fragCoord, iResolution.xy))) discard;\n\n    fragColor = vec4(0.0);\n    const int bins_per_word = num_bins / 4;\n    for (int w = 0; w < 4; ++w) {\n        for (int wo = 0; wo < bins_per_word; ++wo) {\n            int i = w * bins_per_word + wo;\n            vec4 box = array0(i) + test_window;\n            fragColor.x *= 2.0;\n            if (all(bvec4(lessThan(box.xy, fragCoord), lessThan(fragCoord, box.zw)))) {\n                if (small_box(box) || near_any_points(fragCoord, i)) {\n                    fragColor.x += 1.0;\n                }\n            }\n        }\n        fragColor = fragColor.yzwx;\n    }\n    fragColor *= pow(2.0, -float(num_bins / 4));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}