{
    "Shader": {
        "info": {
            "date": "1618173621",
            "description": "Finding the normals from a point to a conic (so the shortest is the shortest distance to the conic), from the intersection with another conic & solving the resulting quartic equation.\n\nMouse moves point.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdjGDt",
            "likes": 11,
            "name": "Normals to a Conic",
            "published": 3,
            "tags": [
                "normal",
                "quartic",
                "conic",
                "shortestdistance"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 384
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Normals to conic, Matthew Arcus, mla, 2021.\n//\n// Normals to conic section from point. The feet (red) of normals to a conic\n// (black) from a point (also black) are the intersection of the conic with\n// another conic (blue) (Smith, 1882) & can be found as the roots of a\n// quartic equation.\n//\n// There is some numeric instability when the point is close to the x or y\n// axis and the blue conic is (nearly) degenerate. Fixing this is left to reader.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}\n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving general cubic equation\nint cubic0(float a, float b, float c, out vec3 roots) {\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    roots[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    roots[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    roots[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),1.0/3.0);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    roots[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nint cubic(float a, float b, float c, float d, out vec3 roots) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,roots.xy);\n  }\n  if (d == 0.0) {\n    roots.x = 0.0;\n    return 1+quadratic(a,b,c,roots.yz);\n  }\n  return cubic0(b/a,c/a,d/a,roots);\n}\n\n// For the Lanczos quartic method, we want the largest\n// positive root of the cubic.\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // Sort into descending order\n  if (nroots > 1 && roots.x < roots.y) roots.xy = roots.yx;\n  if (nroots > 2) {\n    if (roots.y < roots.z) roots.yz = roots.zy;\n    if (roots.x < roots.y) roots.xy = roots.yx;\n  }\n  // And select the largest\n  float psi = roots[0];\n  // There _should_ be a positive root, but sometimes the cubic\n  // solver doesn't find it directly (probably a double root\n  // around zero).\n  // If so, nudge in the right direction\n  //psi = max(1e-6,psi);\n  // and give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\n// The Lanczos quartic method, see his \"Applied Analysis\", 1956.\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int nroots = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    nroots += 2;\n  }\n  return nroots;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this seems to give the least wild behaviour.\n  if (abs(B/A) < abs(D/E)) {\n    nroots = lquartic(B/A,C/A,D/A,E/A,roots);\n  } else {\n    nroots = lquartic(D/E,C/E,B/E,A/E,roots);\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  return nroots;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a, b -= a;\n  float h = clamp(dot(p,b) / dot(b,b), 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat getconicdistance(vec2 z, vec2 ab) {\n  float a = ab.x, b = ab.y, h = z.x, k = z.y;\n  float A = b*h, B = a*k, C = a-b;\n  float alpha = b*C*C;\n  float beta = -2.0*b*B*C;\n  float gamma = a*A*A+b*B*B-C*C;\n  float delta = 2.0*B*C;\n  float epsilon = -B*B;\n  vec4 roots;\n  int nroots = quartic(alpha,beta,gamma,delta,epsilon,roots);\n  float d = 1e8;\n  for (int i = 0; i < nroots; i++) {\n    float y = roots[i];\n    float x = A*y/(B-C*y);\n    vec2 q = vec2(x,y);\n    d = min(d,distance(z,q));\n  }\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec3 col = vec3(0);\n  vec2 ab = vec2(tan(0.5*iTime+3.25),1);\n  vec2 w = vec2(-1.4,0.25);\n  float scale = 3.0;\n  if (iMouse.x > 0.0) w = scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n  float xwidth = fwidth(z.x);\n  float lwidth0 = 0.02;\n  float pwidth0 = 0.06;\n  float lwidth1 = max(2.0*lwidth0,xwidth);\n  float pwidth1 = max(pwidth0+lwidth0,xwidth);\n\n  vec3 c = vec3(0.8,1,1);\n\n  c *= 0.6+0.1*sin(10.0*PI*getconicdistance(z,ab));\n  \n  // Draw the main conic\n  float cdist = dot(z*ab,z)-1.0;\n  vec2 cgrad = 2.0*z*ab;\n  cdist /= length(cgrad);\n  c = mix(vec3(0),c,smoothstep(lwidth0,lwidth1,abs(cdist)));\n\n  // The normals from (h,k) = w intersect the conic ax²+by²-1 = 0\n  // at points lying on conic xy(a-b)+bhy-akx = 0\n  // (from C.Smith, \"Conic Sections\", 1882).\n\n  // Draw the second conic\n  float x = z.x, y = z.y, a = ab.x, b = ab.y, h = w.x, k = w.y;\n  cdist = x*y*(a-b)+b*h*y-a*k*x;\n  cgrad = vec2(y*(a-b)-a*k,x*(a-b)+b*h);\n  cdist /= length(cgrad);\n  c = mix(vec3(0,0,1),c,smoothstep(lwidth0,lwidth1,abs(cdist)));\n\n  // The second conic gives: x = bhy/(ak-y(a-b)) so can substitute\n  // into first & get a quartic fairly easily:\n  // Put x = Ay/(B-Cy) then:\n  // aA²y²+b(B-Cy)²y²-(B-Cy)² = 0\n  // aA²y² + b(B²-2BCy+C²y²)y² - B² + 2BCy - C²y² = 0\n  // bC²y⁴ - 2bBCy³ + (aA²+bB²-C²)y² + 2BCy - B² = 0\n  // so solve the quartic & find points of intersection\n  float A = b*h, B = a*k, C = a-b;\n  // It would be nice to use unicode variable names here\n  // but GLSL disallows it.\n  float alpha = b*C*C;\n  float beta = -2.0*b*B*C;\n  float gamma = a*A*A+b*B*B-C*C;\n  float delta = 2.0*B*C;\n  float epsilon = -B*B;\n  vec4 roots;\n  int nroots = quartic(alpha,beta,gamma,delta,epsilon,roots);\n  for (int i = 0; i < nroots; i++) {\n    float y = roots[i];\n    float x = A*y/(B-C*y);\n    vec2 q = vec2(x,y);\n    if (!isnan(dot(q,q)) && !isinf(dot(q,q))) {\n      c = mix(vec3(1,1,0),c,smoothstep(lwidth0,lwidth1,segment(z,w,q)));\n      c = mix(vec3(1,0,0),c,smoothstep(pwidth0,pwidth1,distance(z,q)));\n    }\n  }\n  c = mix(vec3(0),c,smoothstep(pwidth0,pwidth1,distance(z,w)));\n  c = pow(c,vec3(0.4545));\n  fragColor = vec4(c,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}