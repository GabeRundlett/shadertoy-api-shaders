{
    "Shader": {
        "info": {
            "date": "1699862396",
            "description": "simulates waves with a bit more information",
            "flags": 0,
            "hasliked": 0,
            "id": "ctdcWB",
            "likes": 6,
            "name": "wave simulation 2.0",
            "published": 3,
            "tags": [
                "wavesimulation"
            ],
            "usePreview": 0,
            "username": "Schatten2020",
            "viewed": 182
        },
        "renderpass": [
            {
                "code": "#define pi 3.1415926535\n//#define intensityLossMult 1.\n//#define interferenceTollarence .02\n//#define doDistortion\n\n\nconst vec3 constructiveInterferenceCol = vec3(10, 10, -10);\nconst vec3 destructiveInterferenceCol  = vec3(-10, 10, 10);\n\nstruct Wave {\n    vec2 origin;\n    float speed;\n    float energy;\n    float frequency;\n};\n\nconst Wave [] waves = Wave[] (\n    Wave(vec2(.25, .5), 5., 1., 10.),\n    Wave(vec2(.5, .75), 5., 1., 10.),\n    Wave(vec2(.75, .5), 5., 1., 10.)\n);\n\n\n\nfloat calcWave(vec3 pos, Wave wave) {\n    vec2 uv = pos.xy;\n    float iTime = -pos.z;\n    float dst = distance(uv, wave.origin);\n    float dstPhase = dst*wave.frequency * pi;\n    float timeDiff = iTime * wave.speed;\n    float waveVal = sin(dstPhase + timeDiff);\n    waveVal *= wave.energy;\n    #ifdef intensityLossMult\n        float circumference = 2. * pi * dst;\n        float intensityLoss = waveVal - waveVal/circumference;\n        intensityLoss *= intensityLossMult;\n        if(sign(waveVal-intensityLoss) != sign(waveVal)) {\n            waveVal = 0.;\n        } else {\n            waveVal -= intensityLoss;\n        }\n    #endif\n    return waveVal;\n}\n#ifdef interferenceTollarence\nvec2 calcInterference(vec2 uv) {\n    float con = 0.;\n    float des = 0.;\n    int len = waves.length();\n    float mult = 1. / (float(len) * (float(len)-1.) * .5);\n    for(int i = 0; i < len; i++) {\n        Wave wav1 = waves[i];\n        float s1 = distance(wav1.origin, uv);\n        float lambda1 = 2. / wav1.frequency;\n        \n        for(int j = i+1; j < len; j++) {\n            Wave wav2 = waves[j];\n            float lambda2 = 2. / wav2.frequency;\n            if(lambda1 != lambda2) continue;\n            \n            float s2 = distance(waves[j].origin, uv);\n            float ds = abs(s1-s2);\n            float n = abs(ds/lambda1);\n            while(n > 1.) {\n                n -= 1.;\n            }\n            if(abs(n) < interferenceTollarence) {\n                con += mult;\n            } else if (abs(n - .5) < interferenceTollarence) {\n                des += mult;\n            }\n        }\n    }\n    return vec2(con, des);\n}\n#else\nvec2 calcInterference(vec2 uv) {return vec2(0);}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef doDistortion\n        vec2 uv = fragCoord/iResolution.xy;\n    #else\n        vec2 uv = fragCoord/iResolution.y;\n    #endif\n    vec3 pos = vec3(uv, iTime);\n    vec3 col = vec3(0);\n    \n    float sum = 0.;\n    for(int i = 0; i < waves.length(); i++) {\n        sum += calcWave(pos, waves[i]);\n    }\n    float correctedSum = sum/float(waves.length());\n    col.r -= correctedSum;\n    col.g += correctedSum;\n    col = clamp(col, 0., 1.);\n    vec2 interference = calcInterference(uv);\n    col += interference.y * destructiveInterferenceCol;\n    col += interference.x * constructiveInterferenceCol;\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}