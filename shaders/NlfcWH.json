{
    "Shader": {
        "info": {
            "date": "1647884636",
            "description": "draw a ~screenspace-constant density of curves \ngetting a unique id per line.\niMouse.y controls zoom while preserving screen-space density.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlfcWH",
            "likes": 28,
            "name": "adaptive polar lines 4",
            "published": 3,
            "tags": [
                "raytracing",
                "intersection",
                "isolines",
                "hatching",
                "balanced"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 711
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/NllczM\n// variant of https://shadertoy.com/view/flXyR7\n\n//#define S\n#define S(v) ( v - 6.283*sign(v)*step(3.14,abs(v)) )       // fight wrap discontinuity\n#define fwidth2(v) length( S( vec2( dFdx(v), dFdy(v) ) ) ) // high quality fwidyj\n#define fwidth(v)  fwidth2(v)                              // to manage wrap\n#define r(t)       mat2(cos( t + vec4(0,-1,1,0)*1.5708))   // rotation\n#define LOD(v)     exp2( round(log2(abs(.5/(v)))))\n#define hue(v)   ( .6 + .6 * cos( 6.283*(v)  + vec4(0,23,21,0)  ) )\n#define hash(p)   fract(sin( (p) * 12.9898 ) * 43758.5453)\n//#define hash(p)   fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution,\n         P = vec3( 2.*u - R.xy, 0 ) / R.y;                 // P on sphere surface (or background)\n // P *= exp2( 2.*sin(.5*iTime) );\n    if (iMouse.z>0.) P *= exp2( 2.*(2.*iMouse.y/R.y-1.) ); // mouse.y zoom\n    float l = length(P), n=2.,                             // n : more lines  \n          T = .3*iTime;\n    P.z = sqrt(1.-l*l);\n    P.xy *= r(T); P.yz *= r(T);                            // rotations\n    //if (P.z<0.) P.x = -P.x;   \n    float a = sign(P.z)* acos(clamp(P.x/sqrt(1.-P.y*P.y),-1.,1.)), // polar coord\n          t = sin(3.*asin(P.y)),\n          U = a + .1*cos(10.*a)  - t,  U0 = U,             // isoline to draw\n          V,\n          d = fwidth2(U),\n          z = LOD(d) ,                                     // LOD \n          f = .5 + log2(abs(.5/d)) - log2(z),              // fractional part\n          p = fwidth(U) * z*n;\n          U *= z*n;\n         \n    V = 1. - abs(sin(U)/(cos(U)*p));                       // lines\n    U0 -= tan(U0*z*n)/(z*n); // U0 = line id. reproject on the closest drawn line\n    U0 -= tan(U0*z*n)/(z*n);\n    vec4 C = sqrt(V) * hue( hash(round(mod(U0+exp2(-9.),6.283)*exp2(9.))) );\n         \n // f = max(1.5*f-.5 ,0.);                                 // shorter transition\n    O = l > 1. \n          ? vec4(0)                                        // background\n          : vec4( abs(sin(U/2.)) < .5 \n                    ? C                                    // plain line\n                    : mix( vec4(0), C, f ));               // transition lines  \n  //O = sqrt(O);                                           // to sRGB\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}