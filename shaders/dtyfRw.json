{
    "Shader": {
        "info": {
            "date": "1701918152",
            "description": "Playground for testing tonemapping\n\nFrom Right to Left:\nNo tonemapping, Aces, Agx, Uncharted2, Simple Reinhard, Luma-based Reinhard, White-preserving luma-based Reinhard, \"RomBinDaHouse\"",
            "flags": 0,
            "hasliked": 0,
            "id": "dtyfRw",
            "likes": 1,
            "name": "Tonemapping Testing",
            "published": 3,
            "tags": [
                "tonemapping",
                "filmic",
                "aces",
                "agx"
            ],
            "usePreview": 0,
            "username": "GabeRundlett",
            "viewed": 486
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 base_uv = fragCoord/iResolution.xy;\n    base_uv *= vec2(8.0, 1.0);\n\n    vec2 uv = fract(base_uv);\n    vec3 col = hsv2rgb(vec3(uv.y, 1.0, uv.x * 5.0));\n\n    if (base_uv.x < 1.0) {\n        // do nothing (show default)\n    } else if (base_uv.x < 2.0) {\n        aces(col);\n    } else if (base_uv.x < 3.0) {\n        agx(col);\n        agxLook(col);\n        // agxEotf(col);\n    } else if (base_uv.x < 4.0) {\n        col = Uncharted2ToneMapping(col);\n    } else if (base_uv.x < 5.0) {\n        col = simpleReinhardToneMapping(col);\n    } else if (base_uv.x < 6.0) {\n        col = lumaBasedReinhardToneMapping(col);\n    } else if (base_uv.x < 7.0) {\n        col = whitePreservingLumaBasedReinhardToneMapping(col);\n    } else if (base_uv.x < 8.0) {\n        col = RomBinDaHouseToneMapping(col);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n    return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n}\n\nconst mat3 SRGB_2_XYZ_MAT = mat3(\n    0.4124564, 0.3575761, 0.1804375,\n    0.2126729, 0.7151522, 0.0721750,\n    0.0193339, 0.1191920, 0.9503041);\nconst float SRGB_ALPHA = 0.055;\n\nfloat luminance(vec3 color) {\n    vec3 luminanceCoefficients = SRGB_2_XYZ_MAT[1];\n    return dot(color, luminanceCoefficients);\n}\n\nconst mat3 agxTransform = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992, 0.878468636469772, 0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n\nconst mat3 agxTransformInverse = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n\nvec3 agxDefaultContrastApproximation(vec3 x) {\n    vec3 x2 = x * x;\n    vec3 x4 = x2 * x2;\n    return +15.5 * x4 * x2 - 40.14 * x4 * x + 31.96 * x4 - 6.868 * x2 * x + 0.4298 * x2 + 0.1191 * x - 0.00232;\n}\n\nvoid agx(inout vec3 color) {\n    const float minEv = -12.47393;\n    const float maxEv = 4.026069;\n    color = agxTransform * color;\n    color = clamp(log2(color), minEv, maxEv);\n    color = (color - minEv) / (maxEv - minEv);\n    color = agxDefaultContrastApproximation(color);\n}\n\nvoid agxEotf(inout vec3 color) {\n    color = agxTransformInverse * color;\n}\n\nvoid agxLook(inout vec3 color) {\n    // Punchy\n    const vec3 slope = vec3(1.1);\n    const vec3 power = vec3(1.2);\n    const float saturation = 1.3;\n    float luma = luminance(color);\n    color = pow(color * slope, power);\n    color = max(luma + saturation * (color - luma), vec3(0.0));\n}\n\n\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvoid aces(inout vec3 color) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n}\n\nfloat gamma = 2.4;\n\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n\tfloat exposure = 1.5;\n\tcolor *= exposure/(1. + color / exposure);\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 RomBinDaHouseToneMapping(vec3 color)\n{\n    color = exp( -1.0 / ( 2.72*color + 0.15 ) );\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 Uncharted2ToneMapping(vec3 color) {\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}