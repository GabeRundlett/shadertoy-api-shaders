{
    "Shader": {
        "info": {
            "date": "1673491217",
            "description": "êÇÇ, simple model/code, will try and 3D print using [url]https://tdhooper.github.io/glsl-marching-cubes/[/url]\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Dl23WW",
            "likes": 4,
            "name": "remaindeer v1",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "remaindeer",
                "keychain"
            ],
            "usePreview": 0,
            "username": "remaindeer",
            "viewed": 191
        },
        "renderpass": [
            {
                "code": "float scene(vec3 p) {\n    float d;\n    vec3 q;\n    \n    // êÇÇ\n    //// cabeza\n    q = rotmat3(vec3(0, 0, radians(75.0))) * p;\n    d = sdRoundCone(q - vec3(0), 0.15, 0.25, 0.35);\n    //// ojos\n    q = p; q.x = abs(q.x);\n    d = min(d, sdSphere(q - vec3(+0.175, 0.25, -0.205), 0.10));\n    q = p; q.x = abs(q.x); q = rotmat3(vec3(0, 0, radians(90.0))) * q;\n    d = min(d, sdCutHollowSphere(q - vec3(+0.175, 0.205, 0.25), 0.10, -0.085, 0.01));\n    //// orejas\n    q = p; q.x = abs(q.x); q = rotmat3(vec3(radians(10.0), radians(15.0), radians(90.0))) * q;\n    d = min(d, sdRhombus(q - vec3(+0.35, +0.40, 0.20), 0.25, 0.15, 0.05, 0.001));\n    //// astas\n    q = p; q.x = abs(q.x); q = rotmat3(vec3(radians(15.0), 0, 0)) * q;\n    d = min(d, sdVerticalCapsule(q - vec3(+0.015, 0.3, -0.325), 0.35, 0.05));\n    //// sejas\n    q = p; q.x = abs(q.x);\n    d = min(d, sdCappedTorus(q - vec3(+0.175, 0.25, -0.205), vec2(0.25), 0.10, 0.05));\n    //// nariz (%)\n    q = p;\n    d = min(d, sdCappedTorus(q - vec3(-0.025, +0.015, 0.15), vec2(0), 0.0125, 0.0075));\n    d = min(d, sdCappedTorus(q - vec3(+0.025, -0.015, 0.15), vec2(0), 0.0125, 0.0075));\n    q = rotmat3(vec3(radians(30.0), 0, 0)) * p;\n    d = min(d, sdVerticalCapsule(q - vec3(0, -0.030, 0.15), 0.060, 0.0075));\n    //// blep\n    q = p; q = rotmat3(vec3(0, 0, radians(80.0))) * (q - vec3(0, -0.075, 0));\n    d = min(d, sdLink(q, 0.10, 0.040, 0.025));\n    \n    // cadena\n    q = rotmat3(vec3(0, 0, radians(30.0))) * (p - vec3(0, 0.15, -0.5));\n    d = min(d, sdLink(q, 0.15, 0.045, 0.025));\n    \n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    float d;\n\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + depth * rd;\n        d = scene(p);\n        depth += d;\n        if (d < PRECISION || depth > MAX_DIST) {\n            break;\n        }\n    }\n\n    d = depth;\n\n    return d;\n}\n\nvec3 normal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n        e.xyy * scene(p + e.xyy) +\n        e.yyx * scene(p + e.yyx) +\n        e.yxy * scene(p + e.yxy) +\n        e.xxx * scene(p + e.xxx)\n    );\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    if (m == vec2(0.0)) m = vec2(0.5);\n\n    vec3 col = vec3(0);\n    vec3 lp = vec3(0);\n    vec3 ro = vec3(0, 0, 1.5);\n\n    float camRadius = 1.0;\n    ro.yz = ro.yz * camRadius * rotmat2(mix(-PI / 2.0, PI / 2.0, m.y));\n    ro.xz = ro.xz * rotmat2(mix(-PI, PI, m.x)) + vec2(lp.x, lp.z);\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(p, -1));\n\n    float d = march(ro, rd);\n\n    if (d > MAX_DIST) {\n        col = COLOR_BACKGROUND;\n    } else {\n        vec3 p = ro + rd * d;\n        vec3 norm = normal(p);\n\n        vec3 lightPos = vec3(0, 1, 1);\n        vec3 lightDir = normalize(lightPos - p) * 0.65;\n\n        float diff = clamp(dot(norm, lightDir), 0.0, 1.0) * 0.5 + 0.5;\n\n        vec3 rnd = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n        rnd.xy = vec2(0.0);\n        col = vec3(diff) + rnd;    \n    }\n\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ray marching\n#define MAX_ITER 500\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n#define EPSILON 0.0005\n#define COLOR_BACKGROUND vec3(0, 0, 0)\n#define COLOR_AMBIENT vec3(0.42, 0.20, 0.1);\n\n// math\n//// constants\n#define PI 3.1415926535897932384626433\n#define PHI (1.0 + sqrt(5.0)) / 2.0\n#define ICO_CIRCUMRADIUS sin((2.0 * PI) / 5.0)\n#define cos30 cos(radians(30.0))\n#define sqrt3 sqrt(3.0)\n\n//// rotations\n\nmat2 rotmat2(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nmat3 rotmat3(vec3 angle) {\n    float sintht = sin(angle.x), sinpsi = sin(angle.y), sinphi = sin(angle.z);\n    float costht = cos(angle.x), cospsi = cos(angle.y), cosphi = cos(angle.z);\n    return mat3(\n        costht * cospsi, sintht * cospsi, -sinpsi, \n        costht * sinpsi * sinphi - sintht * cosphi, sintht * sinpsi * sinphi + costht * cosphi, cospsi * sinphi,\n        costht * sinpsi * cosphi + sintht * sinphi, sintht * sinpsi * cosphi - costht * sinphi, cospsi * cosphi\n    );\n}\n\n\n//// ---------------------------------------------------\n//// iq (https://iquilezles.org/articles/distfunctions/)\n//// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n \n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n//// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//// ---------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}