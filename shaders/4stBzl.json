{
    "Shader": {
        "info": {
            "date": "1526556748",
            "description": "I made her a valentine's day shader but I cheated and used a few textures. This one is all procedural - as you can tell by the GPU fans - and I had to disable reflections to keep it at 60FPS full-screen. On the plus side, I have optimisation targets :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4stBzl",
            "likes": 1,
            "name": "Birthday Elle",
            "published": 3,
            "tags": [
                "raymarch",
                "birthday",
                "elle"
            ],
            "usePreview": 0,
            "username": "pudding",
            "viewed": 632
        },
        "renderpass": [
            {
                "code": "const int STEPS = 90;\nconst float MIN_D = 0.001;\nconst float MAX_D = 40.0;\nconst float MAX_D_REFL = 25.0;\nconst float EPS = 0.001;\n\n/*\nI have a bajillion people to thank for either teaching me tricks from reading their code or in some cases reusing bits\n\nHopefully I'm not missing anyone out - iq, Shane, Dave_Hoskins, BigWIngs, Jamie Wong, and everyone who has \n\tposted code here - it's been extremely informative (as well as challenging!)\n\nps I know I'm doing the uv normalisation the naive way Fabrice but I'm not sure I understand the method you suggest :(\n*/\n\n\nfloat hash21(in vec2 p) {\n\treturn fract(sin(p.x * 172. + p.y * 153.5) * 1234.563);   \n}\n\nfloat noise11(in float x) {\n\treturn fract(sin(x)*5346.1764); \n}\n    \n\nfloat snoise(in vec2 p) {\n    \n    vec2 luv = fract(p);\n    vec2 id = floor(p);\n\n    luv = luv * luv * (3. - 2. * luv);\n    \n    float bl = hash21(id);\n    float br = hash21(id + vec2(1, 0));\n    float b = mix(bl, br, luv.x);\n    \n    float tl = hash21(id + vec2(0, 1));\n    float tr = hash21(id + vec2(1, 1));\n    float t = mix(tl, tr, luv.x);\n    \n    return mix(b, t, luv.y);\n}\n\nvec3 rgb(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\n\nmat3 RotateY(in float theta){\n \n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        c,\t\t\t0.0,\ts,\n        0.0,\t\t1.0,\t0.0,\n        -s,\t\t\t0.0,\tc);\n}\n\nfloat SinPlasma(in vec3 p){\n    return sin(p.x+iTime*2.)*cos(p.y+iTime*3.1)*sin(p.z+iTime*4.3) + 0.25*sin(p.x*2.)*cos(p.y*2.)*sin(p.z*2.);\n}\n\nvec2 opU(in vec2 d1, in vec2 d2) {\n \treturn d1.x < d2.x ? d1 : d2;\n}\n\nfloat Cylinder(in vec3 p, in vec2 h) {\n \tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat NoiseCylinder(in vec3 p, in vec2 h) {\n \tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + snoise(p.xz * 5.) * 0.1 * min(1., (iTime / 10.));\n}\n\nfloat Candle(in vec3 p) {\n return Cylinder(p, vec2(.1, 0.75));   \n}\n\nfloat Box(in vec3 p, in vec3 b, in float r){\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nconst float CH = -1.1; // candle height\n\nvec2 Map(in vec3 p) {\n    \n    vec2 result = opU(vec2(NoiseCylinder(p + vec3(0, 0.1, 0), vec2(3., 1.)), 1.0), vec2(Box(p + vec3(0, 1, 0), vec3(4.0, 0.1, 4.), 0.05), 3.));\n    for (float i = 1.; i < 31.; i+= 1.) {\n        vec2 offset = vec2(i, i) * 0.09;\n        result = opU(result, vec2(Candle(p + vec3(sin(i) * offset.x, CH, cos(i) * offset.y)), 2.)); \n        result = opU(result, vec2(Cylinder(p + vec3(sin(i) * offset.x, -2., cos(i) * offset.y), vec2(0.05)), 4. + i)); // we use the differing .y values to randomly flicker candles\n    }   \n    return result;\n}\n\nvec2 DistanceToSurface(in vec3 ro, in vec3 rd, in float start, in float end) {\n \n    float depth = start;\n    for (int i = 0; i < STEPS; i++) {\n     \tvec2 dist = Map(ro + rd * depth);\n        \n        if (dist.x < EPS) {\n            return vec2(depth, dist.y);\n        }\n        \n        depth += dist.x;\n        if (depth >= end) {\n            return vec2(end, 1e3);\n        }\n    }\n    return vec2(end, 1e3);\n}\n\nvec3 RayDirection(in float fov, in vec2 size, in vec2 fragCoord) {\n \tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 ViewMatrix(in vec3 eye, in vec3 center, in vec3 up) {\n \tvec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 CalculateNormal(in vec3 p) {\n \tvec2 tmp = vec2(EPS, 0.0);\n    return normalize(\n        vec3(\n        \tMap(p + tmp.xyy).x - Map(p - tmp.xyy).x,\n        \tMap(p + tmp.yxy).x - Map(p - tmp.yxy).x,\n        \tMap(p + tmp.yyx).x - Map(p - tmp.yyx).x\n       \t)\n    );\n}\n\nvec3 PhongContribForLight(in vec3 k_d, in vec3 k_s, in float shininess, in vec3 p, in vec3 eye, in vec3 lightPos, in vec3 lightIntensity, bool doShadow) {\n \t\n    vec3 N = CalculateNormal(p);\t\t\t// surf norm\n    vec3 L = normalize(lightPos - p);\t\t// light\n    vec3 V = normalize(eye - p);\t\t\t// view\n    vec3 R = normalize(reflect(-L, N));\t\t// reflection\n    \n    float NdotL = dot(N, L);\n    float VdotR = dot(R, V);\n    \n    if (NdotL < 0.0) {\t// not visible\n        return vec3(0.);\n    }\n    \n    vec3 nLightPos = normalize(lightPos);\n    float shadow;\n    \n    shadow = doShadow ? DistanceToSurface(p + nLightPos , -nLightPos, MIN_D, MAX_D).x : 1.;\n    \n    if (VdotR < 0.0) { // refl is opposite direction to view\n        return lightIntensity * (k_d * shadow * NdotL);\n    }\n   \n    return lightIntensity * (k_d * shadow * NdotL + k_s * pow(VdotR, shininess));   \n}\n\nvec3 PhongLight(vec3 k_a, vec3 k_d, vec3 k_s, float shininess, vec3 p, vec3 eye, bool doShadow) {\n \t\n    const vec3 ambientLight = 0.5 * vec3(0.3, 0.3, 0.35);\n    vec3 color = ambientLight * k_a;\n    vec3 lightPos = vec3(6. * sin(iTime), 5.0, 2.);\n    vec3 lightIntensity = vec3(0.94);\n    \n    // hack: flame has shininess 0 to shortcut lighting\n    color += (shininess == 0.) ? k_a : PhongContribForLight(k_d, k_s, shininess, p, eye, lightPos, lightIntensity, doShadow);\n    return color;  \n}\n\nfloat Heart(in vec2 st){\n    st.y /= 0.5;\n    st.y -= sqrt(abs(st.x)) * 0.25;\n    return length(st) / 4.5;\n}\n\nvec3 Confetti(in vec2 uv, float t) {\n    t /= 2.;\n    uv *= 3.;\n    vec2 aspect = vec2(3., 1.);\n    vec2 st = uv * aspect;\n    float id = floor(st.x);\n    \n    st.y -= t * (noise11(floor(id)) + 1.);\n    st = fract(st) - 0.5; \n    float mask = smoothstep(0.11, 0.1, Heart(st));\n \treturn mask * rgb(abs(sin(id)));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n   \tvec3 viewDir = RayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 color;\n    \n    //vec3 eye = vec3(-5.0 + 10.0 * (1.- iMouse.x / iResolution.x), 8. + 10.0 * (iMouse.y / iResolution.y), 15.) * RotateY(mod(iTime * 0.5, 6.28));\n    vec3 eye = vec3(-5.0 + 10.0, 8. + 10.0 * sin(iTime * 0.3) + 2., 15.) * RotateY(mod(iTime * 0.5, 6.28));\n    \n    mat3 viewToWorld = ViewMatrix(eye, vec3(0.), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = viewToWorld * viewDir;\n    vec2 dist = DistanceToSurface(eye, worldDir, MIN_D, MAX_D);    \n     \n    vec2 uv = fragCoord.xy /iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x / iResolution.y;           \n    \n    if (iTime < 2. || dist.x > MAX_D - EPS) // no hit or in intro pre-roll\n    {\n        color = Confetti(uv, iTime);\n        color += Confetti(uv * 0.8, iTime * 1.1);\n        //color = pow( clamp(color,0.0,1.0), vec3(0.4545) );\n       \tfragColor = vec4(color, 1.0);\n        return;\n    }\n       \n    // Closest point on eye ray\n    vec3 p = eye + dist.x * worldDir;\n \n    vec3 k_a, k_d, k_s;\n    float shininess, reflection;\n        \n    // Figure out what material this is and render\n    if (dist.y < 1.1) // cake 1.0\n    {\n        k_a = vec3(0.8) + vec3(SinPlasma(p), SinPlasma(p*1.8), SinPlasma(p * 1.5));\n        k_d = k_a;\n        k_s = k_a * 2.;\n        shininess = 20.;\n       // reflection = DistanceToSurface(p, reflect(worldDir, CalculateNormal(p)), EPS, MAX_D_REFL).x;\n        reflection = 0.;\n        color = PhongLight(k_a, k_d, k_s, shininess, p, eye, true);\n    } else if (dist.y < 2.1) // candle 2.0\n    {\n        k_a = vec3(0.65, 0.7, 0.72);\n        k_d = vec3(0.3, 0.7, 0.7);\n        k_s = k_a * 2.;\n        shininess = 10.;\n        reflection = 0.;\n        color = PhongLight(k_a, k_d, k_s, shininess, p, eye, false);\n    } else if (dist.y < 3.1) // tray\n    {\n        k_a = vec3(0.1, 0.7, 0.6);\n        k_d = k_a;\n        k_s = k_a;\n        shininess = 5.;\n        //reflection = DistanceToSurface(p, reflect(worldDir, CalculateNormal(p)), EPS, MAX_D_REFL).x;\n        reflection = 0.;\n    \tcolor = PhongLight(k_a, k_d, k_s, shininess, p, eye, true);\n    } else if (dist.y > 4.1) // flame\n    {\n    \tk_a = mix(vec3(0.8, 0.8, 0.01), vec3(0.6, 0.2, 0.01), abs(sin(iTime * 10. + noise11(dist.y))));\n        k_d = k_a * 1.1;\n        k_s = k_a;\n        shininess = 0.;\n        reflection = 0.;\n        color = PhongLight(k_a, k_d, k_s, shininess, p, eye, false);\n    }\n   \n    if (iTime < 22.) {\n        \tfloat scale = iTime - (1.0455 * iTime) + 1.;\n        \t\n        \t// fade in color which has been set by raymarch\n        \tcolor = color * (1. - scale);\n        \n        \t// fade out confetti in foreground. raymarch miss pixels will be confettied throughout\n        \tcolor += Confetti(uv, iTime)  * scale;\n    \t\tcolor += Confetti(uv * 0.8, iTime /2.) * scale;\n   \t}\n        \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}