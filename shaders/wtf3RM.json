{
    "Shader": {
        "info": {
            "date": "1555861741",
            "description": "4k exe graphics entry for Revision 2019.\n\nI was really struggling with modelling this until I had a look at [url=https://www.shadertoy.com/view/MltcDB]Ink Drawing[/url] by lnae. I also cheated a bit by 'tracing' a polygon model from Daz 3D.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtf3RM",
            "likes": 132,
            "name": "ᴇ  s  ᴄ  ʜ  ᴇ  ʀ  ᴡ  ᴀ  ᴠ  ᴇ",
            "published": 3,
            "tags": [
                "escher",
                "helix",
                "vaporwave"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 4508
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//#define REFRACT\n\n// HG_SDF\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n\nfloat fHalfCapsule(vec3 p, float r) {\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\n}\n\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\n// Modelling\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat helix(vec3 p, float lead, float thick) {\n    // p.z += iTime * .1;\n    float d = (mod(atan(p.y, p.x) - p.z * lead, PI * 2.) - PI) / lead;\n    d = abs(d) - thick;\n    return d;\n}\n\nvoid fMouth(inout float d, vec3 pp) {\n    vec3 p;\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n}\n\nbool isMap = true;\nbool isEye = false;\n\nfloat mHead(vec3 p) {\n\n    p.y -= .13;\n\n    vec3 pa = p;\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = pp;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = pp;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n\n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\n    brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // jaw\n\n    p = pp;\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = pp + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // return d;\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    fMouth(d, pp);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    // return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n    if (isMap) isEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    return d;\n}\n\nfloat mBg(vec3 p) {\n    pR(p.xy, 1420./10.);\n    // return length(p) - .1;\n\n    p.xy -= vec2(23.22, 90.67);\n    // p.xy -= vec2(1.);\n    p.z += 17.;\n    float r = 5.5;\n    float rz = 5.;\n    float a = floor(p.z / rz);\n    pR(p.xy, a * 3.4);\n    pR(p.xy, -.002);\n    p.xy = mod(p.xy, r) - r / 2.;\n    // if (p.z > -1.2) {\n        p.z = mod(p.z, rz) - rz / 2.;\n    // }\n    float d = length(p)- r / 5.;\n    return d;\n}\n\nfloat mce(vec3 p) {\n    float h = mHead(p);\n    // h = length(p) - .5;\n    // return h;\n    p.y -= .45;\n    float s = helix(p.xzy, 35., .06);\n    h = abs(h + .01) - .01;\n    h = smax(h, s, .005);\n    return h;    \n}\n\nfloat inside = 1.;\n\nvec2 map(vec3 p) {\n    float d = mBg(p) * inside;\n    float e = p.z + 25.;\n    p.z += 17.;\n    p.y -= .4;\n    float hs = 10.;\n    float h = mce(p / hs) * hs;\n    vec2 m = vec2(e, 1.);    \n    if (h < m.x) {\n        m = vec2(h, 2.);\n    }\n    #ifndef REFRACT\n    \tif (inside == -1.) return m;\n    #endif\n    if (d < m.x) {\n        m = vec2(d, 0.);\n    }\n    return m;\n}\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    isMap = false;\n    vec3 eps = vec3(.001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert).x * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    isMap = true;\n    return normalize(nor);\n}\n\n// IQ's cos palette\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvec3 march(vec2 fc) {\n    vec2 p = (-iResolution.xy + 2. * fc.xy) / iResolution.y;\n    inside = 1.;\n    vec3 camPos = vec3(0,0,2.5);\n    vec3 rayDirection = normalize(vec3(p,-4));\n    vec3 rayPosition = camPos;\n    float distance = 0.;\n    vec3 c = vec3(0);\n    vec3 n;\n    bool rf = false;\n    vec2 m;\n    float ss;\n\n    for (int i = 0; i < 300; i++) {\n\n        rayPosition += rayDirection * distance * .8;\n        m = map(rayPosition);\n        distance = m.x;\n\n        if (abs(distance) < .005) {\n            if (m.y == 0.) {\n                n = calcNormal(rayPosition);\n                rayDirection = refract(rayDirection, n, 1. / 2.222);\n                rayPosition -= n * .001;\n                inside *= -1.;\n            } else {\n                break;\n            }\n        }\n    }\n\n    if (m.y == 1.) {\n        ss = rayPosition.y / 20. + .5;\n        ss = saturate(ss);\n        c = spectrum(ss/ 2.);\n    }\n    if (m.y == 2.) {\n        n = calcNormal(rayPosition);\n        c = n * .5 + .5;\n        ss = dot(n, .5*vec3(.5,1,1));\n        ss = saturate(ss);\n        c = spectrum(ss / 2. - .8);\n        c *= mix(1., saturate(ss), .8);\n    }\n\n    c = pow(c, vec3(1./2.2));\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 lastFrame = texture(iChannel0, uv);\n    \n    if (lastFrame.a != 0. && iFrame > 2) {\n        fragColor = lastFrame;\n        return;\n    }\n    \n    vec3 c = vec3(0);\n    vec2 o = vec2(1./3.,0);    \n    for (float i = 0.; i < 4.; i++) {\n        if (i == 2.) o *= -1.;\n        o = o.yx;\n        c += march(gl_FragCoord.xy + o);\n    }\n    c /= 4.;\n    fragColor = vec4(c, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}