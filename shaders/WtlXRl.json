{
    "Shader": {
        "info": {
            "date": "1564103937",
            "description": "Template for montecarlo path tracing, use mouse + arrow keys to look around. Supports translucency, chromatic reflection/refraction, volumetrics, importance sampling and more.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "WtlXRl",
            "likes": 25,
            "name": "montecarlo path tracing template",
            "published": 3,
            "tags": [
                "ray",
                "refraction",
                "volumetric",
                "template",
                "montecarlo",
                "tracer",
                "analytic",
                "marcher",
                "hybrid",
                "path",
                "4",
                "bidirectional",
                "importance",
                "opacity"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 1617
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2019 - CC0\n//Image - Display pathtracing result in Buffer B with gamma correct\n\n//Controls - Mouse to look and arrow keys to move\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n    vec4 s = texelFetch(iChannel0,ivec2(u),0);\n    o = pow(s/s.w,vec4(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//camera settings\n#define CAM_POS vec3(0,-.2,-2)\n#define CAM_YAW 0.\n#define CAM_PITCH 0.\n#define CAM_FOV .6\n\n//control settings\n#define MOUSE_SENSITIVITY .005\n#define MOVE_SPEED .02\n\n//rendering settings\n#define VIEW_DISTANCE 5.\n#define BOUNCES 5\n#define EPSILON 2e-3\n\n//importance sampling settings\n#define LIGHT_IMPORTANCE .1\n#define LIGHT_INTENSITY .1\n#define LIGHT_POS vec3(0,1,0)\n#define LIGHT_SIZE 0.\n#define LIGHT_COLOR vec3(1)\n\n//toggle r2 point sampling\n#define R2_SAMPLING\n\n\n#define PI 3.141592653\n#define PI2 (PI*2.)\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Ethan Alexander Shulman 2019 - CC0\n//Buffer A - Camera state and control\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    int id = int(u.x);\n    if (id > 1 || u.y > 1.) return;\n    if (iFrame == 0) {\n        if (id == 0) o = vec4(CAM_POS,0);\n        else o = vec4(CAM_YAW,CAM_PITCH,-1,0);\n     \treturn;   \n    }\n    \n    vec4 s = texelFetch(iChannel0,ivec2(u),0);\n    if (id == 0) {\n        //movement\n        s.w = 0.;\n        vec2 rot = texelFetch(iChannel0,ivec2(1,0),0).xy;\n        mat2 ym = r2(rot.x), pm = r2(rot.y);\n        vec3 fwd = vec3(0,0,MOVE_SPEED), right = vec3(MOVE_SPEED,0,0);\n        fwd.yz *= pm;fwd.xz *= ym;\n        right.yz *= pm;right.xz *= ym;\n        #define tk(kc,co) if (texelFetch(iChannel1,ivec2(kc,0),0).x > .5) {co;s.w = 1.;}\n        tk(38,s.xyz += fwd);\n        tk(40,s.xyz -= fwd);\n        tk(37,s.xyz -= right);\n        tk(39,s.xyz += right);\n        if (iMouse.w > 0.) s.w = 1.;\n    } else {\n        //rotation\n        if (iMouse.w > 0.) {\n            if (dot(s.zw,vec2(1)) >= 0.) s.xy -= (iMouse.xy-s.zw)*MOUSE_SENSITIVITY;\n        \ts.y = clamp(s.y,-PI*.48,PI*.48);\n            s.zw = iMouse.xy;\n        } else s.zw = vec2(-1.);\n    }\n    o = s;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Alexander Shulman 2019 - CC0\n//Buffer B - Montecarlo path tracing\n\n//pseudo-random hash unclamped vec4 in, 0-1 vec4 out\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\n//outputs tangent and returns binormal from normal\nvec3 calculateUpRight(vec3 normal, out vec3 tangent) {\n    if (abs(normal.x) > abs(normal.y)) tangent = normalize(vec3(-normal.z, 0., normal.x));\n    else tangent = normalize(vec3(0., normal.z, -normal.y));    \n\treturn cross(normal, tangent);\n}\n\n\n//raytracing functions\nstruct rayhit {\n    vec4 diffuse,specular,//diffuse/specular.w = emission\n        normal;//normal.w = hit distance\n    float metallic,roughness,opacity,refrIndex;\n};\n\n//no ray hit\n#define NNO vec4(0,0,0,VIEW_DISTANCE)\n\n//ray marching function macros\n#define NEPS vec3(EPSILON*.1,0,0)\n#define rmarch(fname,distf,normf,iter) vec4 fname(vec3 rp, vec3 rd) {\\\nfloat s = 0.;\\\nfor (int i = 0; i < iter; i++) {\\\n    vec3 trp = rp+rd*s;\\\n    float d = distf(trp);\\\n    if (d < EPSILON) {\\\n        trp -= rd*EPSILON;\\\n        d = normf(trp);\\\n    \treturn vec4(normalize(vec3(normf(trp+NEPS)-d,\\\n                                   normf(trp+NEPS.yxz)-d,\\\n                                   normf(trp+NEPS.yzx)-d)),s-EPSILON);\\\n    }\\\n    s += d;\\\n}\\\nreturn NNO;\\\n}\n#define rmarchc(fname,distf,normf,iter,maxd) vec4 fname(vec3 rp, vec3 rd) {\\\nfloat s = 0.,ld = 1e8;\\\nfor (int i = 0; i < iter; i++) {\\\n    vec3 trp = rp+rd*s;\\\n    float d = distf(trp);\\\n    if (d < EPSILON) {\\\n        trp -= rd*EPSILON;\\\n        d = normf(trp);\\\n    \treturn vec4(normalize(vec3(normf(trp+NEPS)-d,\\\n                                   normf(trp+NEPS.yxz)-d,\\\n                                   normf(trp+NEPS.yzx)-d)),s-EPSILON);\\\n    }\\\n    s += d;\\\n    if (d > maxd && d > ld) {return NNO;}\\\n    ld = d;\\\n}\\\nreturn NNO;\\\n}\n\n//raymarching macros, only supports unsigned distance\n#define rayMarch(fname,distf,iter) rmarch(fname,distf,distf,iter)\n//limited version will stop tracing when distance above maxd for optimization\n#define rayMarchLimited(fname,distf,iter,maxd) rmarchc(fname,distf,distf,iter,maxd)\n\n//raymarching macros with seperate distance function for normal\n#define rayMarchDetailed(fname,distf,normf,iter) rmarch(fname,distf,normf,iter)\n#define rayMarchDetailedLimited(fname,distf,normf,iter,maxd) rmarchc(fname,distf,normf,iter,maxd)\n\n//volumetric distance dither, look at cloudDist function for an example\n#define VOLUME(density) step(density,fract(dot(abs(rp),vec3(.12,.23,.32)*100.)+float(iFrame)*.3183098861))*EPSILON*2.\n\n//chromatic seperation dither, look at triPrism part of rayScene function for an example\n#define CHRSC(s) h.diffuse.xyz *= s;h.specular.xyz *= s\n#define CHROMA(rc,gc,bc) int cifm = iFrame%3;\\\nif (cifm == 0) {CHRSC(vec3(3,0,0));rc}\\\nelse if (cifm == 1) {CHRSC(vec3(0,3,0));gc}\\\nelse {CHRSC(vec3(0,0,3));bc}\n\n\n//ray functions return vec4 where .w = distance to hit and .xyz is hit normal\nvec4 rayPlane(vec3 rp, vec3 rd, vec3 pos, vec3 normal) {\n    float dst = dot(rp-pos,normal)/dot(rd,normal);\n    if (dst < 0.) return vec4(normal,-dst);\n    return NNO;\n}\nvec4 rayBox(vec3 rp, vec3 rd, vec3 pos, vec3 ext) {\n    rp -= pos;\n    vec3 mind = (rp+ext)/rd, maxd = (rp-ext)/rd;\n\tmind = -(mind-step(vec3(-1e-6),mind)*(mind+VIEW_DISTANCE));\n\tmaxd = -(maxd-step(vec3(-1e-6),maxd)*(maxd+VIEW_DISTANCE));\n\tmind = min(mind,maxd);\n    \n    vec4 nrm;\n    nrm.w = VIEW_DISTANCE;\n    if (mind.x < VIEW_DISTANCE && mind.x < nrm.w) {\n        vec2 pd = abs(rp.zy+rd.zy*mind.x)-ext.zy;\n        if (max(pd.x,pd.y) < 0.) nrm = vec4(-sign(rd.x),0.,0.,mind.x);\n    }\n    if (mind.y < VIEW_DISTANCE && mind.y < nrm.w) {\n        vec2 pd = abs(rp.xz+rd.xz*mind.y)-ext.xz;\n        if (max(pd.x,pd.y) < 0.) nrm = vec4(0,-sign(rd.y),0.,mind.y);\n    }\n    if (mind.z < VIEW_DISTANCE && mind.z < nrm.w) {\n        vec2 pd = abs(rp.xy+rd.xy*mind.z)-ext.xy;\n        if (max(pd.x,pd.y) < 0.) nrm = vec4(0.,0.,-sign(rd.z),mind.z);\n    }\n    return nrm;\n}\nvec4 raySphere(vec3 rp, vec3 rd, vec3 pos, float radius) {\n    rp -= pos;\n    float c = dot(rp, rp)-radius*radius;\n    float b = dot(rd, rp), \n        d = b*b - c;\n\n    if (d >= 0.) {\n        b = -b;\n        float s = sqrt(d), t, n;\n        if (s < b) {\n            t = b-s;\n            n = 1.;\n        } else {\n            t = b+s;\n            n = -1.;\n            if (t < 0.) return vec4(0,0,0,VIEW_DISTANCE);\n        }\n        return vec4(normalize(rp+rd*t)*n,t);\n    }\n    return NNO;\n}\n\n//rotate rp,rd by yaw,pitch,roll\n#define ROTATE(yaw,pitch,roll) if (roll != 0.0) {\\\n    mat2 rm = r2(roll);\\\n\trp.xy *= rm;rd.xy *= rm;\\\n}\\\nif (pitch != 0.0) {\\\n    mat2 rm = r2(pitch);\\\n    rp.yz *= rm;rd.yz *= rm;\\\n}\\\nif (yaw != 0.0) {\\\n\tmat2 rm = r2(yaw);\\\n    rp.xz *= rm;rd.xz *= rm;\\\n}\n//inverse rotation on point p\n#define ROTATEP(p,yaw,pitch,roll) if (yaw != 0.0) {\\\n\tmat2 rm = r2(yaw);\\\n    p.xz *= rm;\\\n}\\\nif (pitch != 0.0) {\\\n    mat2 rm = r2(pitch);\\\n    p.yz *= rm;\\\n}\\\nif (roll != 0.0) {\\\n    mat2 rm = r2(roll);\\\n\tp.xy *= rm;\\\n}\n\n//custom cloud cube distance function\nfloat cloudDist(vec3 rp) {\n    float ff = float(iFrame)/33.33333;\n    for (float x = 1.; x < 4.; x += x) rp += cos(rp.yzx*100./x+ff)*x*.01;\n    return length(max(abs(rp)-.3,0.))+VOLUME(0.2);\n}\nrayMarchLimited(rayCloudCubeB,cloudDist,32,1.)\n//raymarch cloud cube\nvec4 cloudCube(vec3 rp, vec3 rd) {\n    ROTATE(0.6,0.7,0.);\n    vec4 hit = rayCloudCubeB(rp,rd);\n    if (hit.w < VIEW_DISTANCE) {\n        ROTATEP(hit.xyz,-0.6,-0.7,0.);\n    }\n    return hit;\n}\n\n//raymarch triangle prism\nfloat sdTriPrism(vec3 p) {\n    vec2 h = vec2(.3);\n    vec3 q = abs(p);\n    return abs(max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5));\n}\nrayMarchLimited(rayTriPrism,sdTriPrism,16,1.)\n\n\n//ray traces function 'f' and if closest hit execute material code 'm'\n#define rt(f,m) {\\\n\tvec4 s = f;\\\n    if (s.w < h.normal.w) {\\\n        h.normal = s;\\\n        m\\\n    }\\\n}\n//rt with sphere bounds culling\n#define rtc(f,boundPos,boundRadius,m) {\\\nfloat boundDst = raySphere(rp,rd,boundPos,boundRadius).w;\\\nif ((boundDst < h.normal.w && boundDst < VIEW_DISTANCE) || length(rp-boundPos) < boundRadius) {\\\n    vec4 s = f;\\\n    if (s.w < h.normal.w) {\\\n        h.normal = s;\\\n    \tm\\\n\t}\\\n}\\\n}\n//raytrace scene\nrayhit rayScene(vec3 rp, vec3 rd) {\n    rayhit h;\n\th.normal.w = VIEW_DISTANCE;\n    \n    //your custom scene code goes here\n    \n    #define wallmat() h.diffuse = vec4(.8,.8,.8,0);\\\n    h.metallic = 0.;h.opacity = 1.\n    \n    //floor\n    rt(rayPlane(rp,rd,vec3(0,-1,0),vec3(0,1,0)),\n    \twallmat();\n    );\n    \n    //ceiling\n    rt(rayPlane(rp,rd,vec3(0,1,0),vec3(0,-1,0)),\n    \twallmat();\n        //light emission\n        vec2 hp = abs(rp.xz+rd.xz*s.w);\n        h.diffuse.w = max(0.,(.3-max(hp.x,hp.y))*120.);\n    );\n    \n    //back wall\n    rt(rayPlane(rp,rd,vec3(0,0,1),vec3(0,0,-1)),\n    \th.metallic = 1.;\n        h.roughness = 0.001;\n        h.specular = vec4(.95,.95,.95,0);\n        h.opacity = 1.;\n    );\n    \n    //red right wall\n    rt(rayPlane(rp,rd,vec3(1,0,0),vec3(-1,0,0)),\n    \th.diffuse = vec4(1,0,0,0);\n        h.metallic = 0.;\n        h.opacity = 1.;\n    );\n    \n    //green left wall\n    rt(rayPlane(rp,rd,vec3(-1,0,0),vec3(1,0,0)),\n    \th.diffuse = vec4(0,1,0,0);\n        h.metallic = 0.;\n        h.opacity = 1.;\n    );\n    \n    //raymarched volumetric cloud cube\n    #define CUBE_POS vec3(.5,-.5,-.5)\n    rtc(cloudCube(rp-CUBE_POS,rd),CUBE_POS,.5,\n        h.metallic = 0.;\n        h.diffuse = vec4(1.8,1.8,1.8,0);\n        h.opacity = .4;\n        h.refrIndex = 1.;\n    );\n    \n    //chromatic refractive triangle prism\n    #define PRISM_POS vec3(-.4,-.7,-.2)\n    rtc(rayTriPrism(rp-PRISM_POS,rd),PRISM_POS,.5,\n    \th.metallic = 1.;\n        h.specular = vec4(1,1,1,0);\n        h.opacity = 0.;\n        CHROMA(h.refrIndex = 1.;,//r\n               h.refrIndex = .9;,//g\n               h.refrIndex = .8;);//b\n    );\n    \n    return h;\n}\n\n//ray trace background, returns color\nvec3 rayBackground(vec3 rp, vec3 rd) {\n    return vec3(0);\n}\n\n//montecarlo path tracing\nvoid mainImage(out vec4 o, in vec2 u) {\n    //initial screen rays based on camera\n\tvec3 rd = normalize(vec3((u*2.-iResolution.xy+(hash(u.xyxy+float(iFrame)*vec4(.132,.432,.342,.234)).xy*2.-1.)*1.5)/iResolution.y,1./CAM_FOV));\n\tvec2 camrot = texelFetch(iChannel1,ivec2(1,0),0).xy;\n    rd.yz *= r2(camrot.y);\n\trd.xz *= r2(camrot.x);\n\trd = normalize(rd);\n    vec4 campos = texelFetch(iChannel1,ivec2(0),0),\n        s = texelFetch(iChannel0,ivec2(u),0);\n    if (iFrame == 0 || campos.w > .5) s = vec4(0);\n\t\n    //path tracing light accumulation\n    #ifdef LIGHT_IMPORTANCE\n    bool important = false;\n    vec3 lastRp,lastRd;\n    #endif\n    vec3 rp = campos.xyz, c = vec3(1), l = vec3(0);\n    for (int b = 0; b < BOUNCES+1; b++) {\n        //raytrace\n        rayhit h = rayScene(rp,rd);\n        if (h.normal.w >= VIEW_DISTANCE) {\n         \t#ifdef LIGHT_IMPORTANCE\n            vec3 bgc = rayBackground(rp,rd);\n            if (important) {\n            \tif (dot(normalize(bgc),normalize(LIGHT_COLOR)) > .9999) l += c*bgc*LIGHT_INTENSITY;\n            } else l += c*bgc;\n            #else\n            l += c*rayBackground(rp,rd);\n            #endif\n            break;\n        }\n        rp += rd*h.normal.w;\n        \n        vec4 rnd = hash(rp.xyzz+float(iFrame)*vec4(.222,.1111,PI*.1,PI*.13));\n        #ifdef R2_SAMPLING\n        //r2 random point sampling http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\t\t#define r2g 1.32471795724474602596\n        rnd.xy = fract(.5+float(iFrame)*(1.0/vec2(r2g,r2g*r2g))+rnd.xy*(.2+float(min(1,b)))*.5);\n        #endif\n                         \n        //apply hit material\n        bool specular = h.metallic > rnd.w;\n        if (specular) {\n         \tc *= h.specular.xyz;\n            #ifdef LIGHT_IMPORTANCE\n            if (important) {\n                if (dot(normalize(h.specular.xyz),normalize(LIGHT_COLOR))>.9999) l += c*h.specular.w*LIGHT_INTENSITY;\n                rp = lastRp;\n                rd = lastRd;\n                important = false;\n                continue;\n            }\n            #endif\n            l += c*h.specular.w;\n        } else {\n            c *= h.diffuse.xyz;\n            #ifdef LIGHT_IMPORTANCE\n            if (important) {\n                if (dot(normalize(h.diffuse.xyz),normalize(LIGHT_COLOR))>.9999) l += c*h.diffuse.w*LIGHT_INTENSITY;\n                rp = lastRp;\n                rd = lastRd;\n                important = false;\n                continue;\n            }\n            #endif\n            l += c*h.diffuse.w;\n            h.roughness = 1.;\n        }\n        \n        //simulate random micro surface bumps scaled by roughness\n        vec3 tang,binorm = calculateUpRight(h.normal.xyz,tang);\n        float cost = pow(rnd.x,h.roughness), sint = sqrt(1.-cost*cost), phi = rnd.y*PI2, cosp = cos(phi), sinp = sin(phi);\n        vec3 sr = vec3(sint*cosp, sint*sinp, cost);\n        sr = normalize(h.normal.xyz*sr.z+tang*sr.x+binorm*sr.y);\n        \n        //reflect off bumps for opaque and refract through bumps for translucent\n        if (h.opacity >= rnd.z) {\n            rp += h.normal.xyz*EPSILON*2.;\n            if (specular) rd = reflect(rd,sr);\n            else {\n            \trd = sr;  \n                #ifdef LIGHT_IMPORTANCE\n                //light importance sampling for very rough surfaces\n                vec3 ldir = normalize((LIGHT_POS+(rnd.zxy*2.-1.)*LIGHT_SIZE)-rp);\n                if (dot(ldir,h.normal.xyz) > 0. && LIGHT_IMPORTANCE> fract(rnd.z*100.)) {\n                    lastRp = rp;\n                    lastRd = rd;\n                    important = true;\n                    rd = ldir;\n                }\n                #endif\n            }\n        } else {\n            rd = refract(rd,sr,h.refrIndex);\n            rp -= h.normal.xyz*EPSILON*4.;\n        }\n    }\n    o = s+vec4(l,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}