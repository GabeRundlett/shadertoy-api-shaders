{
    "Shader": {
        "info": {
            "date": "1663271849",
            "description": "This doesn't looks like a .io game at all... What are you thinking?",
            "flags": 0,
            "hasliked": 0,
            "id": "7tdBz7",
            "likes": 8,
            "name": "011 - SSSnake",
            "published": 3,
            "tags": [
                "2d",
                "beginner",
                "snake",
                "slither"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 316
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n#define RAD 6.2831853\n\nfloat antiAlias;\n\nvec2 rotAround(vec2 p, vec2 o, float ang);\n\nvec4 circle(vec2 uv, vec2 origin, float size, vec3 col) {\n    return vec4(col, smoothstep(size + antiAlias, size - antiAlias, length(uv - origin)));\n}\n\nvec4 eye(vec2 uv, vec2 origin, float size, float ang) {\n    vec4 eyeBall = circle(uv, origin, size, vec3(1.));\n    vec2 pupilO = vec2(origin.x + size/2., origin.y);\n    pupilO = rotAround(origin, pupilO, ang);\n    vec4 pupil = circle(uv, pupilO, size/2., vec3(0.));\n\n    return mix(eyeBall, pupil, pupil.w);\n}\n\n\nmat2 rot2D(float ang) {\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n}\n\n// p: reference point to rotation from\n// o: point that will be rotated\n// ang: angle in radians\nvec2 rotAround(vec2 p, vec2 o, float ang) {\n    vec2 v = (o - p);\n    \n    return (rot2D(ang) * v) + p;\n}\n\n// returns the angle of a vector in radians\nfloat angle(vec2 v) {    \n    return -atan(v.y/v.x);\n}\n\nvec3 rgb(int r, int g, int b) {\n    return vec3(float(r)/255., float(g)/255., float(b)/255.);\n}\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\n\n// returns -size to size cycle\nfloat rangeCycle(float size, float perSec) {\n    return mod(iTime*perSec - size, size) - .5*size;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    antiAlias = 1.5/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float size = floor(50. + (200. * cycle(0.1)));\n    float thick = 0.15 + (0.25 * cycle(0.2));\n    \n    vec2 o = vec2(-1.3, 0.);\n    vec3 initCol = rgb(186, 98, 245);\n    vec3 destCol = rgb(228, 237, 62);\n    \n    // what is the step size when going from source color to destinate color?\n    vec3 incCol = (destCol-initCol) / size;\n    // used for the head\n    vec2 lastO;\n    \n    for (float i = 1.; i <= size; i+= 1.) {\n       lastO = vec2(o);\n       o.x += 0.01;\n       o.y = cos(o.x + iTime*5.12) / (0.5/thick);\n       initCol += incCol;\n       \n       vec4 circleColor = circle(uv, o, thick, initCol);\n       col = mix(col, circleColor.xyz, circleColor.w);\n       \n       // last part, time for the eyes c.c\n       if (i == size) {\n           float eyeSize = thick/4.;\n           vec2 eyeVec = vec2(eyeSize, eyeSize * 2.);\n           \n           // discover the angle between the head and the body\n           vec2 angVec = o - lastO;\n           float ang = angle(angVec);\n           \n           // discover the left eye origin\n           vec2 lEyeO = o + eyeVec;\n           // align the eye with the body\n           lEyeO = rotAround(o, lEyeO, ang);\n          \n           // draw the eye\n           vec4 lEye = eye(uv, lEyeO, eyeSize, ang);\n           col = mix(col, lEye.xyz, lEye.w);\n           \n           // same thing as above but for right eye\n           // note that ang is the same, since I want the two eyes to look at the same place\n           eyeVec.y = -eyeVec.y;\n           vec2 rEyeO = o + eyeVec;\n           rEyeO = rotAround(o, rEyeO, ang);\n           vec4 rEye = eye(uv, rEyeO, eyeSize, ang);\n          \n           col = mix(col, rEye.xyz, rEye.w);\n       }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}