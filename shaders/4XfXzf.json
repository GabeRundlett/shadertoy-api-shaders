{
    "Shader": {
        "info": {
            "date": "1709756275",
            "description": "Conversions between 3D direction and its 2D octahedron map.",
            "flags": 0,
            "hasliked": 0,
            "id": "4XfXzf",
            "likes": 2,
            "name": "Octahedron projection",
            "published": 3,
            "tags": [
                "map",
                "projection",
                "normal",
                "octahedron"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 177
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Octahedron mapping.\n// Well known, just wanted this written down somewhere.\n\n// See also:\n//     https://web.archive.org/web/20140620112342/http://www.vis.uni-stuttgart.de/~engelhts/paper/vmvOctaMaps.pdf\n//     https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/\n//     https://jcgt.org/published/0003/02/01/paper.pdf\n//     https://webglinsights.github.io/downloads/WebGL-Insights-Chapter-16.pdf\n\n//==============================================================================\n\n// Convert unnormalized direction into [-1;+1]x[-1;+1].\nvec2 dir2xy(vec3 v)\n{\n    v/=dot(vec3(1),abs(v));\n    v.xy=(v.z<0.0)?(1.0-abs(v.yx))*(2.0*step(0.0,v.xy)-1.0):v.xy;\n    return v.xy;\n}\n\n// Convert [-1;+1]x[-1;+1] into normalized direction.\nvec3 xy2dir(vec2 p)\n{\n    vec3 v=vec3(p.xy,1.0-abs(p.x)-abs(p.y));\n    v.xy=(v.z<0.0)?(1.0-abs(v.yx))*(2.0*step(0.0,v.xy)-1.0):v.xy;\n    return normalize(v);\n}\n\n// Convert unnormalized direction into [0;1]x[0;1].\nvec2 dir2uv(vec3 v)\n{\n    v/=dot(vec3(1),abs(v));\n    v.xy=(v.z<0.0)?(1.0-abs(v.yx))*(2.0*step(0.0,v.xy)-1.0):v.xy;\n    return 0.5*v.xy+0.5;\n}\n\n// Convert [0;1]x[0;1] into normalized direction.\nvec3 uv2dir(vec2 p)\n{\n    p=2.0*p-1.0;\n    vec3 v=vec3(p.xy,1.0-abs(p.x)-abs(p.y));\n    v.xy=(v.z<0.0)?(1.0-abs(v.yx))*(2.0*step(0.0,v.xy)-1.0):v.xy;\n    return normalize(v);\n}\n\n// If you need to sample outside [0;1]x[0;1], for\n// filtering or whatever.\n// NOTE: GL_MIRRORED_REPEAT will not give a correct result,\n// but at least it will be continuous.\nvec3 uv2dir_tiled(vec2 p)\n{\n    return uv2dir((int(dot(floor(p),vec2(1)))&1)==0?fract(p):1.0-fract(p));\n}\n\n// Density function for subtended solid angle:\n//     dA=density(x,y)*dx*dy\n// NOTE: there exist explicit expressions for solid\n// angle subtended by a finite texel, see e.g.\n//     https://www.shadertoy.com/view/tlBXDd\nfloat xy2density(vec2 xy)\n{\n    xy=abs(xy);\n    if(xy.x+xy.y>1.0) xy=1.0-xy;\n    float r=1.0+2.0*(xy.x*xy.x+xy.y*xy.y+xy.x*xy.y-xy.x-xy.y);\n    return 1.0/(r*sqrt(r));\n}\n\n// Same for uv parametrization.\nfloat uv2density(vec2 uv)\n{\n    vec2 xy=2.0*uv-1.0;\n    xy=abs(xy);\n    if(xy.x+xy.y>1.0) xy=1.0-xy;\n    float r=1.0+2.0*(xy.x*xy.x+xy.y*xy.y+xy.x*xy.y-xy.x-xy.y);\n    return 4.0/(r*sqrt(r));\n}\n\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float b=32.0; // Quantize to [0;b-1].\n    float a=0.25*iTime,c=cos(a),s=sin(a);\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0,0,2),rd=normalize(vec3(xy,-1));\n    vec3 col=texture(iChannel0,uv2dir_tiled(xy+vec2(c,s))).xyz;\n    float p=dot(ro,rd),q=dot(ro,ro)-1.0,d=p*p-q;\n    if(d>0.0)\n    {\n        vec3 r=ro-(p+sqrt(d))*rd;\n        mat3 m=mat3(c,0,s,0,1,0,-s,0,c)*mat3(c,s,0,-s,c,0,0,0,1);\n        vec3 v=uv2dir((floor(b*dir2uv(m*r))+0.5)/b);\n        // vec3 v=uv2dir(floor((b-1.0)*dir2uv(m*r)+0.5)/(b-1.0)); // <-- represents zeroes exactly.\n        col=(0.0625+0.5*max(dot(r,normalize(vec3(1))),0.0))*\n            texture(iChannel0,v).xyz;\n    }\n    col.xyz=mix(12.92*col.xyz,1.055*pow(col.xyz,vec3(1.0/2.4))-0.055,step(0.0031308,col.xyz)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}