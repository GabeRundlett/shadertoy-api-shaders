{
    "Shader": {
        "info": {
            "date": "1532254713",
            "description": "Moebius Spiral 2",
            "flags": 0,
            "hasliked": 0,
            "id": "XttyWr",
            "likes": 2,
            "name": "Moebius Spiral 2",
            "published": 3,
            "tags": [
                "spiral",
                "moebius"
            ],
            "usePreview": 0,
            "username": "emh",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define M_PI atan(1.0) * 4.0\n\n#define time iTime\n#define resolution iResolution.xy\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 nfract(vec2 co) {\n\tfloat x = co.x;\n\tfloat y = co.y;\n\treturn vec2(x >= 0.0 ? x - floor(x) : x - ceil(x), y >= 0.0 ? y - floor(y) : y - ceil(y));\n}\n\nvec2 nfloor(vec2 co) {\n\tfloat x = co.x;\n\tfloat y = co.y;\n\treturn vec2(x >= 0.0 ? floor(x) : ceil(x), y >= 0.0 ? floor(y) : ceil(y));\n}\n\nfloat sinc(float t) {\n\treturn (sin(t) + 1.0) / 2.0;\n}\n\nfloat cosc(float t) {\n\treturn (cos(t) + 1.0) / 2.0;\n}\n\n\nvec2 rndstep(vec2 p, int i) {\n\tvec2 seed = vec2(0.2342352, 0.4234254);\n\tfloat pwr = sinc(float(i));\n\tvec2 p1 = p * pwr; //vec2(pow(seed.x, pwr), pow(seed.y, pwr));\n\treturn p1;\n}\n\nfloat DistToLine(vec2 pt1, vec2 pt2, vec2 testPt)\n{\n  vec2 lineDir = pt2 - pt1;\n  vec2 perpDir = vec2(lineDir.y, -lineDir.x);\n  vec2 dirToPt1 = pt1 - testPt;\n  return abs(dot(normalize(perpDir), dirToPt1));\n}\n\nfloat drawLine(vec2 p1, vec2 p2, vec2 uv, float Thickness) {\n  float a = abs(distance(p1, uv));\n  float b = abs(distance(p2, uv));\n  float c = abs(distance(p1, p2));\n\n  if ( a >= c || b >=  c ) return 0.0;\n\n  float p = (a + b + c) * 0.5;\n\n  // median to (p1, p2) vector\n  float h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  return mix(1.0, 0.0, smoothstep(0.5 * Thickness, 1.5 * Thickness, h));\n}\n\nvoid main2(vec2 uv, out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat t = time + 8.0;\n\tvec2 r = resolution;\n\t\n\tvec2 no = uv;\n\tvec2 o = vec2(0.0);\n\tvec2 aspect = vec2(1.0, r.y / r.x);\n\tfloat sz = 0.0;\n\tfloat t2 = t;\n\tvec2 idx = vec2(0.0);\n\tvec2 boxOffset = vec2(0.0);\n\t\n\to = no * r - r / 2.0;\n\tt = t2;\n\t\n\t// bool cutCircle = length(boxOffset)\n\tvec2 or = o / r;\n\t\n\tif (sz > 6.0) {\n\t\tt = 8.0;\n\t}\n\t\t\n\to = vec2(length(o) / r.y - .3, atan(o.y,o.x) + fract(-t / 100.0) * 2.0 * M_PI);\n\t\n\tvec2 o2 = o;\n\t\n\tfloat width = 20.0;\n\tfloat scale = 20.0;\n\tfloat offset = 0.02;\n\t\n\to.x += 0.3;\n\t\n\tfloat y0to1 = (o.y + M_PI) / (2.0 * M_PI); // + floor(o2.x * scale);\n\to.x = (fract(o.x * scale + y0to1) + 1.0 + y0to1) / width;\n\to.x = (o.x - 0.05 * 1.5) / 0.2;\n\to.x -= (o.y + M_PI) / (8.0 * M_PI);\n\to.y *= M_PI / 2.0 + offset;\n\to.y = sin(M_PI * o.y);\n\t\n\tfloat dir = mod(floor(o2.x * scale), 2.0) == 0.0 ? 1.0 : -1.0;\n\tdir *= floor(o2.x * scale / 2.0);\n\tvec4 s = 0.08 * cos(1.5*vec4(0,1,2,3) + dir * t + o.y + cos(o.y) * cos(8.0));\n\t// s = sz > 6.0 ? vec4(1.0) : s;\n\tvec4 e = s.yzwx;\n\tvec4 f = max(o.x-s,e-o.x);\n\tvec4 color = o.x > -0.1 ? dot(clamp(f*r.y,0.,1.), 80.*(s-e)) * (s-.1) + (e - o.x) : vec4(0.0);\n\t\n\tfloat cutoff = 0.15;\n\tfragColor = o2.x + y0to1 / scale < cutoff ? color : vec4(1.0);\n\t\n\tvec2 ot = boxOffset;\n\t// gl_FragColor = vec4(ot.x, ot.y, 0.0, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 position = ( gl_FragCoord.xy / resolution.xy );\n\n\tvec2 o = vec2(0.0);\n\t\n\tvec2 no = position;\n\tfloat t = time + 8.0;\n\tvec2 aspect2 = vec2(1.0, resolution.y / resolution.x);\n\tfloat sz2 = 0.0;\n\tfloat t2 = t;\n\tvec2 idx = vec2(0.0);\n\tvec2 boxOffset = vec2(0.0);\n\n\tconst int maxi2 = 6;\n\tfor (int i = 0; i <= maxi2; i++) {\n\t\tfloat sc = pow(2.0, float(i));\n\t\tfloat sc2 = pow(2.0, float(maxi2 - i + 1));\n\t\tfloat j = float(i);\n\t\tfloat maxj = float(maxi2);\n\t\t\n\t\tbool gotOne = false;\n\t\t\n\t\tvec2 to2 = nfloor(no * sc);\n\t\t\n\t\tfloat tslow = t  / 100.0;\n\t\t\n\t\tvec2 to3 = to2;\n\t\tfloat rndMove = mix(rand(to3 + floor(tslow)), rand(to3 + floor(tslow) + 1.0), fract(tslow));\n\t\tfloat rnd = rand(to2);\n\t\t\n\t\tfloat tsc = .1 * t * j / sc + rnd * 1000.0;\n\t\tvec2 bo = 0.0 * (i > 0 ? vec2(cosc(tsc), sinc(tsc)) : vec2(0.0));\n\t\t\n\t\tvec2 to = nfract((no + bo) * sc);\n\t\tvec2 tbo = nfract(bo * sc);\n\t\t\n\t\t// big on top\n\t\tbool check1 = length((o - 0.5) * aspect2) < 0.15;\n\t\t// small on top\n\t\tbool check2 = length((to - 0.5) * aspect2) > 0.15;\n\n\t\tfloat prob = 0.0;\n\t\tif (i == 0) {\n\t\t\tprob = 1.0;\n\t\t} else if (i >= 3) {\n\t\t\tprob = 0.5 / j;\n\t\t}\n\t\t\n\t\tbool check = rnd < prob && sz2 > 1.0 && length(to - 0.5) < sinc(t * 2.5 + 1000.0 * rnd) ? check2 : check1;\n\t\t// check = check1;\n\t\tbool cutCircle = false;\n\t\tif (check) {\n\t\t\tcutCircle = length((tbo - 0.5) * aspect2) <= 0.51;\n\t\t}\n\t\t\t\t\t\t\n\t\t// bool visible = rand(to2 + vec2(0.254, 0.2342543)) < prob;\n\t\tbool visible = !cutCircle;\n\t\t// if (!visible) continue;\n\t\t\n\t\to = check ? o : to;\n\t\tsz2 = check ? sz2 : float(i + 1);\n\t\tt2 = check ? t2 : t * (rnd + 0.5) + rnd * 1000.0;\n\t\tidx = check ? idx : to2;\n\t\tboxOffset = check ? boxOffset : to;\n\t\tgotOne = gotOne || check;\n\n\t\tif (gotOne) {\n\t\t\t// break;\n\t\t}\n\t}\n\t\n\t// vec2 orepeat = o * resolution - resolution / 2.0;\n\tvec2 orepeat = o;\n\t//float gsc = 0.5;\n\to = (no - 0.5) * 1.5 + 0.5;\n\t\n\tvec2 aspect = vec2(resolution.x / resolution.y, 1.0);\n\t\n\tvec2 p = vec2(0.189346713, 0.1982346);\n\t\n\tvec2 oc = vec2(length(o - 0.5), atan(o.y - 0.5, o.x - 0.5));\n\t\n\tfloat scale = 50.0;\n\t\n\tfloat r = 0.0;\n\tfloat g = 0.0;\n\tfloat b = 0.0;\n\t\n\tconst int pts = 2;\n\tfloat v1 = rand(floor(rndstep(p, 0) * scale));\n\tfloat v2 = rand(floor(rndstep(p, 1) * scale));\n\tfloat v3 = rand(floor(rndstep(p, 2) * scale));\n\tfloat v4 = rand(floor(rndstep(p, 3) * scale));\n\tconst int maxi = 20;\n\t\n\tfor (int i = 1; i <= maxi; i++) {\n\t\t//int j = int(mod(float(i), float(maxi)));\n\t\tfloat v5 = rand(floor(rndstep(p, i * pts + 2) * scale));\n\t\tfloat v6 = rand(floor(rndstep(p, i * pts + 3) * scale));\n\t\tif (i == maxi - 1) {\n\t\t\tv5 = rand(floor(rndstep(p, 0) * scale));\n\t\t\tv6 = rand(floor(rndstep(p, 1) * scale));\n\t\t}\n\t\tif (i == maxi) {\n\t\t\tv5 = rand(floor(rndstep(p, 2) * scale));\n\t\t\tv6 = rand(floor(rndstep(p, 3) * scale));\n\t\t}\n\t\t\n\t\t\n\t\tvec2 v12 = vec2(v1, v2);\n\t\tvec2 v34 = vec2(v3, v4);\n\t\tvec2 v56 = vec2(v5, v6);\n\t\t\n\t\t// v34 += 0.1 * (v56 - v12);\n\t\tb += drawLine(v12, v34, o, 0.003);\n\t\tfloat ti = time / 2.0;\n\t\tfloat tflen = 0.1;\n\t\tfloat tf = fract(ti);\n\t\tint t = int(mod(ti, float(maxi)));\n\t\t\n\t\tvec2 v = (v34 - v12);\n\t\tvec2 w = (v56 - v34);\n\t\t\n\t\ttflen /= length(v);\n\t\tvec2 endpoint = v12 + min(1.0, tf + tflen) * v;\n\t\tr += drawLine(v12 + tf * v, endpoint, o, 0.006);\n\t\t\n\t\tfloat d1 = length(v12 + tf * v - o);\n\t\tfloat d2 = 0.0;\n\t\tvec2 p1 = v12 + tf * v;\n\t\tvec2 p2 = vec2(0.0);\n\t\tfloat sz = 0.05;\n\n\t\tbool allInOne = tf + tflen < 1.0;\n\t\t\n\t\tif (allInOne) {\n\t\t\td2 = length(endpoint - o);\n\t\t\tp2 = endpoint;\n\t\t\t\n\t\t\td2 = length(endpoint - o);\n\t\t\tp2 = endpoint;\n\t\t}\n\t\t\n\t\tfloat tf2len = tflen - (min(1.0, tf + tflen) - tf);\n\t\ttf2len *= length(v) / length(w);\n\t\tif (i <= maxi) {\n\t\t\tr += drawLine(v34, v34 + tf2len * w, o, 0.006);\n\t\t\t\n\t\t\tif (!allInOne) {\n\t\t\t\td2 = length(v34 + tf2len * w - o);\n\t\t\t\tp2 = v34 + tf2len * w;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec2 mid1 = mix(v12, v34, tf + 0.5);\n\t\tvec2 mid2 = mix(v34, v56, tf - 0.5);\n\t\tvec2 mid = mix(mid1, mid2, tf);\n\t\t\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\n\t\t\tfloat th = sin(time / 1.0 + float(j));\n\t\t\tvec2 mid = (mid - 0.5) * mat2(cos(th), -sin(th), sin(th), cos(th)) + 0.5;\n\t\t\t\n\t\t\tfloat d = length((mid - o) * aspect);\n\t\t\tif (i <= maxi) {\n\t\t\t\tg += d < sz ? d / sz : 0.0;\n\t\t\t\tif (d < sz) {\n\t\t\t\t\tfloat sc = sz * 2.8;\n\t\t\t\t\tvec2 uv = (mid - o) / sc + 0.5;\n\t\t\t\t\t\n\t\t\t\t\t\t// vec2 offset = 0.0 * vec2(float(j));\n\t\t\t\t\tmain2(uv, fragColor, fragCoord);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// g += d1 < sz ? d1 / sz : 0.0;\n\t\t// g += d2 < sz ? d2 / sz : 0.0;\n\t\t\t\t\n\t\tv1 = v3;\n\t\tv2 = v4;\n\t\tv3 = v5;\n\t\tv4 = v6;\n\t}\n\t\n\tif (g == 0.0) {\n\t\tmain2(orepeat, fragColor, fragCoord);\n\t}\n\t\n\t// g = g > 0.0 ? 1.0 - g: 0.0;\n\t/*if (g > 0.0) {\n\t\tmain2(o);\n\t}*/\n\t\n\t// gl_FragColor += vec4(1.0 * r, 0.0, b, 1.0);\n\t// gl_FragColor = vec4(o.x, 0.0, o.y, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}