{
    "Shader": {
        "info": {
            "date": "1496083975",
            "description": "Infinitely many circles move around in the hyperbolic plane.\n\nThis is a stripped-down and converted-to-Shadertoy-syntax version of a thing that I'm building here: https://github.com/felixbauckholt/hyperbolic_canvas",
            "flags": 0,
            "hasliked": 0,
            "id": "ldsfD8",
            "likes": 29,
            "name": "Hyperbolic moving tesselation",
            "published": 3,
            "tags": [
                "tesselation",
                "hyperbolic"
            ],
            "usePreview": 0,
            "username": "felixbauckholt",
            "viewed": 908
        },
        "renderpass": [
            {
                "code": "#define ITER_L 20\n\n#define number float\n#define complex highp vec2\n#define i_complex highp ivec2\n#define mobius highp ivec4\n\n\ncomplex thetransform[4];\ncomplex passive_t[4];\nhighp number PI=3.14159265359;\nhighp number l = 1./3.*sqrt(3.);\nhighp number halfl;\nhighp int dcount=0;\n\nhighp int sides = 4;\n\nhighp number t = 0.;\n\ncomplex conj(complex a) {\n\treturn vec2(a.x, -a.y);\n}\n\ncomplex mul(complex a, complex b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\ncomplex expo(complex a)\n{\n\tnumber l = exp(a.x);\n\treturn l*vec2(cos(a.y), sin(a.y));\n}\n\nhighp number abs_sq(complex xy)\n{\n\treturn xy.x*xy.x + xy.y*xy.y;\n}\n\ncomplex invert(complex xy)\n{\n\tnumber a = abs_sq(xy);\n\treturn (1./a)*conj(xy);\n}\n\n\ncomplex doshift(complex z, complex a) {\n\treturn mul(z - a, invert(vec2(1, 0) - mul(conj(a), z)));\n}\n\ncomplex transform(complex z) {\n\treturn mul(mul(z, thetransform[0]) + thetransform[1],\n\t    invert(mul(z, thetransform[2]) + thetransform[3]));\n}\n\nvec4 getpixel(complex pos) {\n\tpos = 1.05*pos;\n\tif (abs_sq(pos) >= 1.) return vec4(0.5, 0.5, 0.5, 0.5);\n\t//if (abs_sq(pos) <= 0.0002) return vec4(1, 0, 0, 1);\n\t//pos = transform(pos);\n\tint col = dcount;\n\n\tcomplex rv = expo(vec2(0, PI*2./float(sides)));\n\tcomplex dv = vec2(l, 0);\n\tint ctr = 0;\n\tint flipctr = 0;\n\tfor (int i=0; i<ITER_L; i++) {\n\t\tdv = mul(dv, rv);\n\t\tcomplex newpos = doshift(pos, dv);\n\t\tif (abs_sq(newpos) >= abs_sq(pos)) {\n\t\t\tctr++;\n\t\t\tif (ctr >= sides) break;\n\t\t} else {\n\t\t\tctr = 0;\n\t\t\tpos = -newpos;\n\t\t\tif (i%2 == 0) flipctr++;\n\t\t\tcol++;\n\t\t}\n\t}\n\n\tif ((col + flipctr) % 2 == 0) pos.x *= -1.;\n\tif (flipctr % 2 == 0) pos.y *= -1.;\n\n\tnumber shift = mod(t, 8.);\n\tif (shift >= 4.) {\n\t\tshift -= 4.;\n\t\t//pos = -pos;\n\t}\n\tif (shift >= 2.) {\n\t\tshift -= 2.;\n\t\tpos = vec2(pos.y, -pos.x);\n\t\tcol++;\n\t}\n    shift = 1. - cos(shift * PI * .5);\n\tshift -= 1.; shift *= halfl;\n\tpos = doshift(pos, vec2(halfl, 0));\n\tpos = doshift(pos, vec2(shift, 0));\n\tcomplex newpos = doshift(pos, vec2(-l, 0));\n\tif (abs_sq(newpos) < abs_sq(pos)) {\n\t\tcol++;\n\t\tpos = newpos;\n\t}\n    \n\tvec4 backgtiles = vec4(vec3(col%2), 1);\n    vec4 thecolor = vec4(0,0,0,1);\n\tif (abs_sq(pos) <= halfl*halfl*0.5) thecolor.rgb = vec3(1, 1, 1);\n\n\treturn 0.9*thecolor + 0.1*backgtiles;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    halfl = (1. - sqrt(1. - l*l))/l;\n    pos.xy -= max(vec2(0), iResolution.xy - iResolution.yx)/2.;\n    pos = pos / min(iResolution.x, iResolution.y);\n    pos = pos*2. - vec2(1,1);\n\n    t = iTime * 1.4;\n\tfragColor = getpixel(pos);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}