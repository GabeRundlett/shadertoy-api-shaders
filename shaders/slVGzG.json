{
    "Shader": {
        "info": {
            "date": "1637926484",
            "description": "Import from https://github.com/Oncorporation/obs-shaderfilter",
            "flags": 0,
            "hasliked": 0,
            "id": "slVGzG",
            "likes": 2,
            "name": "Gradient 2",
            "published": 3,
            "tags": [
                "filter",
                "gradient"
            ],
            "usePreview": 0,
            "username": "turboplay",
            "viewed": 239
        },
        "renderpass": [
            {
                "code": "\n// gradient shader by Charles Fettinger for obs-shaderfilter plugin 3/2019\n//https://github.com/Oncorporation/obs-shaderfilter\n vec4 start_color = vec4(0.5, 0.3, 0.1, 1.0);\n float start_step = 0.15f;\n vec4 middle_color = vec4(1.0, 1.0, 1.0, 1.0);\n float middle_step = 0.4f;\n vec4 end_color = vec4(0.5, 0.75, 0.05, 1.0);\n float end_step = 0.9f;\n float alpha_percent = 90.;\n float pulse_speed = 0.;\n bool ease = true;\n bool rotate_colors = false;\n bool Apply_To_Alpha_Layer = true;\n bool Apply_To_Specific_Color;\n vec4 Color_To_Replace = vec4(0.,1.,0.,1.);\n bool horizontal = false;\n bool vertical = false;\n float gradient_center_width_percentage = 50.;\n float gradient_center_height_percentage = 50.;\n\nfloat EaseInOutCircTimer(float t, float b, float c, float d) {\n\tt /= d / 2.;\n\tif (t < 1.) return -c / 2. * (sqrt(1. - t * t) - 1.) + b;\n\tt -= 2.;\n\treturn c / 2. * (sqrt(1. - t * t) + 1.) + b;\n}\n\nfloat BlurStyler(float t, float b, float c, float d, bool ease)\n{\n\tif (ease) return EaseInOutCircTimer(t, 0., c, d);\n\treturn t;\n}\n\nstruct gradient\n{\n\tvec4 color;\n\tfloat step;\n};\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nconst float PI = 3.14159265f;//acos(-1);\n\tfloat speed = pulse_speed * 0.01;\n\tfloat alpha = alpha_percent * 0.01;\n\t\n\t//circular easing variable\n\tfloat t = sin(iTime * speed) * 2. - 1.;\n\tfloat b = 0.0; //start value\n\tfloat c = 2.0; //change value\n\tfloat d = 2.0; //duration\n\n\tvec2 gradient_center = vec2(gradient_center_width_percentage * 0.01,gradient_center_height_percentage * 0.01);\n\tvec4 color = texture(iChannel0, uv);\n\tfloat luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n\tvec4 gray = vec4(luminance,luminance,luminance, 1);\n\t// skip if (alpha is zero and only apply to alpha layer is true) \n\tif (!(color.a <= 0.0 && Apply_To_Alpha_Layer == true))\n\t{\n\t\tb = BlurStyler(t, 0., c, d, ease);\n\n\t\tconst int no_colors = 3;\n\t\tvec4 s_color = start_color;\n\t\tvec4 m_color = middle_color;\n\t\tvec4 e_color = end_color;\n\n\t\tif (rotate_colors)\n\t\t{\n\t\t\t// get general time number between 0 and 4\n\t\t\tfloat tx = (b + 1.) * 2.;\n\t\t\t// 3 steps  c1->c2, c2->c3, c3->c1\n\t\t\t//when between 0 - 1 only c1 rises then falls\n\n\t\t\tif (tx <= 2.0)\n\t\t\t{\n\t\t\t\ts_color = mix(start_color, middle_color, clamp((min(tx, 2.0) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\tm_color = mix(middle_color, end_color, clamp((min(tx, 2.0) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\te_color = mix(end_color, start_color, clamp((min(tx, 2.0) * 0.5) * 2., 0.0, 1.0));\n\t\t\t}\n\n\t\t\tif ((tx >= 1.0) && (tx <= 3.0))\n\t\t\t{\n\t\t\t\ts_color = mix(middle_color, end_color, clamp(((min(max(1.0, tx), 3.0) - 1.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\tm_color = mix(end_color, start_color, clamp(((min(max(1.0, tx), 3.0) - 1.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\te_color = mix(start_color, middle_color, clamp(((min(max(1.0, tx), 3.0) - 1.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t}\n\n\t\t\tif (tx >= 2.0)\n\t\t\t{\n\t\t\t\ts_color = mix(end_color, start_color, clamp(((min(2.0, tx) - 2.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\tm_color = mix(start_color, middle_color, clamp(((min(2.0, tx) - 2.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t\te_color = mix(middle_color, end_color, clamp(((min(2.0, tx) - 2.) * 0.5) * 2., 0.0, 1.0));\n\t\t\t}\n\n\t\t\tif (tx < 0.)\n\t\t\t{\n\t\t\t\ts_color = mix(end_color, start_color, clamp(abs(max(1.0, tx)) * 2., 0.0, 1.0));\n\t\t\t\tm_color = mix(start_color, middle_color, clamp(abs(max(1.0, tx)) * 2., 0.0, 1.0));\n\t\t\t\te_color = mix(middle_color, end_color, clamp(abs(max(1.0, tx)) * 2., 0.0, 1.0));\n\t\t\t}\n\t\t}\n\n\t\tvec4 colors[no_colors] = vec4[](s_color, m_color, e_color );\n\t\tfloat step[no_colors] = float[]( start_step, middle_step, end_step );\n\n\t\tfloat redness = max(min(color.r - color.g, color.r - color.b) / color.r, 0.);\n\t\tfloat greenness = max(min(color.g - color.r, color.g - color.b) / color.g, 0.);\n\t\tfloat blueness = max(min(color.b - color.r, color.b - color.g) / color.b, 0.);\n\n\t\tfloat dist = distance(uv, gradient_center);\n\t\tif (horizontal && (vertical == false))\n\t\t{\n\t\t\tdist = distance(uv.y, gradient_center.y);\n\t\t}\n\t\tif (vertical && (horizontal == false))\n\t\t{\n\t\t\tdist = distance(uv.x, gradient_center.x);\n\t\t}\n\n\t\tvec4 col = colors[0];\n\t\tfor (int i = 1; i < no_colors; ++i) {\n\t\t\tcol = mix(col, colors[i], smoothstep(step[i - 1], step[i], dist));\n\t\t}\n\t\tcol.a = clamp(alpha, 0.0, 1.0);\n\t\tif (Apply_To_Alpha_Layer == false)\n\t\t\tcolor.a = alpha;\n        if (Apply_To_Specific_Color)\n        {\n            col.a = alpha;\n            vec4 original_color = texture(iChannel0, uv);\n            col.rgb = (distance(color.rgb, Color_To_Replace.rgb) <= 0.075) ? col.rgb : original_color.rgb;\n        }\n\t\t//\tresult = vec4(redness, greenness,blueness,1);\n\t\t//color *= vec4(col.r, col.g, col.b, clamp(dot(color, luminance)* alpha, 0.0, 1.0));\n\t\t//color.rgb += col * alpha;\n\t\t//color.a += clamp(1.0 - alpha, 0.0,1.0);\n\t\t///color.rgb *= (color.rgb * clamp(1.0- alpha, 0.0, 1.0)) + (col.rgb * clamp(alpha, 0.0, 1.0));\n\t\t//color = vec4(max(color.r, col.r), max(color.g, col.g), max(color.b, col.b), clamp(dot(color, luminance) * alpha, 0.0, 1.0));\n\t\tcolor.rgb = mix(color.rgb, col.rgb, clamp(alpha, 0.0, 1.0));\n\n\nfragColor = color;\n\t}\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}