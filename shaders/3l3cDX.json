{
    "Shader": {
        "info": {
            "date": "1610071351",
            "description": "playing with volumetric rendering",
            "flags": 32,
            "hasliked": 0,
            "id": "3l3cDX",
            "likes": 35,
            "name": "Fluffy fractal",
            "published": 3,
            "tags": [
                "nebula"
            ],
            "usePreview": 1,
            "username": "michael0884",
            "viewed": 704
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 c, in vec2 p )\n{\n    c = 1.13*tanh(texture(iChannel0, p/iResolution.xy));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define LOW_QUALITY\n\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 16\n    #define MIN_STEP 0.15\n    #define DITHER 0.5\n    #define TRACE_STEPS 4\n#else\n    #define MAX_STEPS 32\n    #define MIN_STEP 0.09\n    #define DITHER 0.4\n    #define TRACE_STEPS 16\n#endif\n\n#define MAX_DIST 3.0\n\n#define FOV 1.0\n#define LIGHT_PATH_NUM 6\n#define MAX_PATH_LENGTH 4\n#define LIGHT_DIR -normalize(vec3(1.,1.,1.))\n\n//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\nmat3 get_cam(float phi, float theta)\n{\n    vec3 x_dir = vec3(cos(phi)*sin(theta), sin(phi)*sin(theta), cos(theta));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,0,1)));\n    vec3 z_dir = normalize(cross(x_dir, y_dir));\n    return mat3(x_dir, y_dir, z_dir);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\n#define sharpness 0.07\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\nvec4 mandelbulb_fog(vec3 p) {\n    vec3 w = p;\n    float m = dot(w, w);\n    vec3 orbitTrap = vec3(1.);\n\tfloat dz = 1.0;\n    for(int i = 0; i < 5; i++){\n        if(m > 1.2) break;\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n        m = dot(w, w);\n        orbitTrap = min(abs(w)*1.2, orbitTrap);\n    }\n    float sdf = 0.25*log(m)*sqrt(m)/dz;\n    vec3 col = (1.-orbitTrap);\n    if(m > 1.2) return vec4(0.);\n    return vec4(16.*col, sdf);\n}\n\nvec4 box_fog(vec3 p, vec3 b, float k)\n{\n    vec3 refl = normalize(vec3(0.4,0.6,0.9));\n    float sc = 1.0;\n    for(int i = 0; i < 6; i++)\n    {\n        refl.xy = rot(iTime*0.1)*refl.xy;\n        refl.yz = rot(iTime*0.2-2.1)*refl.yz;\n       // p *= 1.1; sc *= 1.1;\n      //  p += 0.05*vec3(1.,3.,1.0);\n        p -= 2.*max(dot(refl, p), 0.)*refl;\n        p += 0.015*sin(10.*dot(refl,p) + sin(p.x*p.y));\n    }\n    float sdf = sdBox(p,b)/sc;\n    return vec4(12.*(vec3(.3, .6, .9) + (0.5 + 0.5*sin(40.*vec3(0.392,0.580,1.000)*p.x)))*smoothstep(k,-k,sdf), sdf);\n}\n\nvec4 density(vec3 p){\n    vec4 box = box_fog(p, vec3(0.7,0.3,0.2), sharpness); \n   // vec4 bulb = mandelbulb_fog(p);\n    return vec4(box.xyz + vec3(.3, .6, .9)*0.1, min(box.w, MAX_DIST + 0.6 - length(p)));\n}\n\nvec3 trace(vec3 ro, vec3 rd, float target_opacity, float dither)\n{\n    //cumulative opacity and scattering\n    vec3 k = vec3(1.0);\n    \n    float step_size;\n    \n    for(int i = 0; i < TRACE_STEPS; i++)\n    {\n        vec4 rho = density(ro);\n        step_size = (1.0 - DITHER*dither)*max(rho.w, MIN_STEP);\n        vec3 absorption = exp(-step_size*rho.xyz);\n        \n        //accumulate\n        k *= absorption; \n       \n        if(length(k) < target_opacity || distance(ro, vec3(0)) > 2.0) break;\n        //step ray\n        ro += rd*step_size;\n    }\n    return k;\n}\n\n//vec3 path_trace()\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    \n    vec4 prev = texture(iChannel0, p/iResolution.xy);\n    \n    vec2 uv = (p - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 angles = iMouse.xy*vec2(-TWO_PI, PI)/iResolution.xy-1e-4;\n    mat3 cam = get_cam(angles.x, angles.y);\n    \n    vec3 ro = cam*vec3(-1.7, 0.0, 0.0);\n    vec3 rd = normalize(cam*vec3(1.0, FOV*uv));\n    \n    vec4 brand = rand4blue();\n    \n    float dither = brand.x;\n    \n    //cumulative opacity\n    vec3 k = vec3(1.0);\n    \n    //accumulated incoming light to the camera\n    vec3 col = vec3(0.); \n    int L = 0;\n    \n    //main camera ray\n    float step_size;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec4 rho = density(ro);\n        step_size = (1.0 - DITHER*dither)*max(rho.w, MIN_STEP);\n        \n        vec3 absorption = exp(-step_size*rho.xyz);\n       \n        if(rho.z > 0.0)\n        {\n            vec3 incoming = trace(ro, LIGHT_DIR, 0.05, brand.z);\n            float amount = 35.0*HenyeyGreenstein(0.15, dot(LIGHT_DIR, rd));\n            //add incoming light\n            col += k.xyz*(1. - absorption.xyz)*amount*incoming;   \n        }\n        \n        //accumulate\n        k *= absorption;\n        \n        ro += step_size*rd;\n         \n        if(length(k) < 0.05 || distance(ro, vec3(0)) > MAX_DIST) break;\n    }\n    \n    \n    c = vec4(mix(prev.xyz, col, 0.65), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}