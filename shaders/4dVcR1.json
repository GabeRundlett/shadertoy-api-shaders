{
    "Shader": {
        "info": {
            "date": "1521263121",
            "description": "Visualizing the relationship between the ellipse distance problem and roots of a quartic. Drag the white point around to see how the roots behave, or click in bottom left to reset position.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dVcR1",
            "likes": 17,
            "name": "Ellipse / quartic",
            "published": 3,
            "tags": [
                "distance",
                "quartic",
                "ellipse",
                "analytic",
                "exact"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 853
        },
        "renderpass": [
            {
                "code": "/* \"Ellipse / quartic\", by mattz\n\n   License: Creative Commons Attribution ShareAlike 4.0\n   https://creativecommons.org/licenses/by-sa/4.0/\n       \n   Visualizing the relationship between the ellipse distance\n   problem and the resulting quartic.\n\n   Colored points on the ellipse are where the white dotted\n   lines are perpendicular to solid white tangents of ellipse.\n   Each colored point corresponds to a root of the quartic\n   (4th degree polynomial) function plotted below the ellipse.\n\n   Note that the shortest white dotted line (i.e. the one \n   corresponding to the exact ellipse distance to the white\n   point) is always perpendicular to the shaded isocontours\n   of the ellipse distance function at the white point.\n\n*/\n\n\n//////////////////////////////////////////////////////////////////////\n// closed-form solver from https://www.shadertoy.com/view/XdKyRR \n// but without special-case checks\n\nbvec4 solve_quartic(in vec4 coeffs,\n                    out vec4 roots) {\n        \n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n    \n    ////////////////////////////////////////////////////////////\n\t// form resolvent cubic and solve it to obtain one real root\n        \n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    \n    // coefficients of normal form\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    \n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    \n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= 0.) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n\t// now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= 0.);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= 0.);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= 0.);\n    bool E_ok = R_ok && (foo - bar >= 0.);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct unit vector from angle around circle\n\nvec2 from_angle(float t) {\n    return vec2(cos(t), sin(t));\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct unit vector from cosine of angle\n\nvec2 from_cos(float u) {\n    u = clamp(u, -1., 1.);\n    return vec2(u, sqrt(1. - u*u));\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct 2D vector perpendicular to input \n\nvec2 perp(vec2 v) {\n    return vec2(-v.y, v.x);\n}\n\n//////////////////////////////////////////////////////////////////////\n// return whichever vector has smaller x-coordinate\n\nvec2 smaller_x(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat ellipse_dist(in vec2 p, in vec2 ab, \n                   out vec4 coeffs,\n                   out vec4 roots,\n                   out bool is_circle) {\n    \n    // distance and sign\n    vec2 ds = vec2(1e5, -1);\n    \n    is_circle = abs((ab.x - ab.y) / ab.x) < 1e-2;\n    \n    // circles need special-case handling because the quartic\n    // degenerates into a quadratic.    \n    if (is_circle) {\n        \n        // a and b are pratically equal, so treat this as a circle\n        float dc = length(p) - ab.x;\n        \n        float u = normalize(p).x;\n        \n        \n        \n        roots = vec4(u, 0, 0, -u);\n        coeffs = vec4(0, 1, 0, -u*u);\n        \n        ds = vec2(abs(dc), dc);\n        \n    } else {\n        \n        // general ellipse case\n        \n        \n        // formulate the quartic polynomial that represents\n        // this ellipse. we are solving for the position \n        // u = cos(theta) along the ellipse such that the\n        // tangent at the point [a*u, b*sqrt(1-u^2)] is \n        // perpendicular to the displacement between p\n        // and the point itself.\n        //\n        // there may be multiple valid solutions for this \n        // polynomial -- for a full ellipse we could just \n        // grab the maximal root but we actually need\n        // to inspect each of them in the arc case.\n        \n        float l = ab.y*ab.y - ab.x*ab.x;\n\n        float ax = ab.x*p.x / l;\n        float by = ab.y*p.y / l;\n\n        float a2x2 = ax*ax;\n        float b2y2 = by*by;\n\n        // vector of polynomial coefficients\n        coeffs = vec4(2.*ax, (a2x2 + b2y2) - 1., -2.*ax, -a2x2);\n\n        // solve for up to 4 roots \n        solve_quartic(coeffs, roots);\n\n        // for each root\n        for (int i=0; i<4; ++i) {\n            \n            // construct point on unit circle\n            vec2 uv = from_cos(roots[i]);\n            \n            // need to check this point both above and below x-axis\n            for (int j=0; j<2; ++j) {\n                \n                // get the absolute distance to the closest point on \n                // the ellipse, as well as its sign\n                vec2 pc = ab*uv;\n                ds = smaller_x(ds, vec2(length(p - pc), dot(p-pc, pc)));    \n                \n                // mirror the root point across the x-axis\n                uv.y *= -1.;\n                \n            }\n        }        \n        \n    }\n    \n    // combine the absolute distance with the sign of the \n    // distance, respecting original sign classification\n    // before root finding\n    return ds.x*sign(ds.y);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to (optionally dashed) line\n\nfloat dline(vec2 p, vec2 a, vec2 b, float dash) {\n    \n    p -= a;\n    b -= a;\n    \n    float l2 = dot(b,b);\n    float l = sqrt(l2);\n    \n    float u = clamp(dot(p, b) / l2, 0., 1.);\n    \n    float d = length(p - u*b);\n    \n    if (dash != 0.) {\n        float p = dash/6.28;\n        d = max(d, -sin(u*l/p)*p);\n    }\n    \n    return d;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a cubic polynomial with given coefficients\n\nfloat poly3(vec4 p, float x) {\n    return ((p[0]*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a quartic polynomial whose first coefficient is 1.\n\nfloat poly4(vec4 p, float x) {\n    return (((x + p[0])*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// given point p, function value at p.x and function derivative at\n// p.x, determine estimated distance to curve of function plot.\n\nfloat dist_to_plot(vec2 p, vec2 fdf) {\n    \n    vec2 p0 = vec2(p.x, fdf.x);\n    vec2 n = normalize(vec2(-fdf.y, 1));\n    return abs(dot(p - p0, n));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// our main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    ////////////////////////////////////////////////////////////\n    // set up ellipse drawing\n    \n\tfloat e_px_per_unit = iResolution.y / 3.;\n    \n    vec2 pctr = iResolution.xy * vec2(0.5, 0.65);\n    \n    // frag coords relative to ellipse\n    vec2 p = (fragCoord.xy - pctr) / e_px_per_unit;\n    \n    // white dot\n    vec2 q = vec2(0.5, 0.2);\n    \n    if (max(iMouse.x, iMouse.y) > 20.) {\n        q = (iMouse.xy - pctr) / e_px_per_unit;\n    }\n    \n    // ellipse radii\n    float time = iTime * 0.25 + 4.4;\n    vec2 ab = vec2(cos(time + 1.2)*.6 + .8, sin(time*0.7 - 0.5)*.2 + .6);\n   \n    // get initial ellipse distance for shading background and drawing ellipse\n    vec4 coeffs, roots;\n    bool is_circle;\n    float d = ellipse_dist(p, ab, coeffs, roots, is_circle);\n    \n    ellipse_dist(q, ab, coeffs, roots, is_circle);\n    \n    ////////////////////////////////////////////////////////////\n    // set up graph \n    \n    float g_px_per_unit = iResolution.x / 2.75;\n    \n    // frag coords relative to graph\n    vec2 v = (fragCoord.xy - vec2(0.5, 0.2)*iResolution.xy)/g_px_per_unit;\n    \n    // get derivative polynomial\n    vec4 pder = vec4(4,3,2,1) * vec4(1, coeffs.xyz);\n\n    // evaluate quartic & derivative\n    vec2 fdf = vec2(poly4(coeffs, v.x), poly3(pder, v.x));\n    \n    if (is_circle) {\n        \n        // in circle case, quartic collapses down to a quadratic\n        pder[0] = 0.;\n        fdf = vec2(poly3(coeffs, v.x), poly3(pder, v.x));\n        \n    }\n    \n    ////////////////////////////////////////////////////////////\n\t// get distances for drawing\n\n    // dist to ellipse & markers\n    float dwhite = abs(d)*e_px_per_unit - .75;\n\n    // dist to draggable dot\n    float dq = length(p-q)*e_px_per_unit - 5.;\n\n    // distances to colored points on ellipse/x-axis\n    vec4 d_ellipse_root = vec4(1e5);\n    vec4 d_axis_root = vec4(1e5);\n    \n    // distance to gray graph line\n    float dplot = dist_to_plot(v, 20.*fdf)*g_px_per_unit;\n    \n    // distance to dark dot outlines by ellipse\n    float ddot = length(p-q)*e_px_per_unit-7.;\n\n    // for each potential root\n    for (int i=0; i<4; ++i) {\n        \n        // create point on unit circle\n        vec2 uv = from_cos(roots[i]);\n        \n        vec3 uvmin = vec3(1e5);\n        \n        // test against both pos & neg. y\n        for (int j=0; j<2; ++j) {\n            \n            // ellipse point\n            vec2 e = ab*uv;\n            \n            // tangent\n            vec2 t = 0.5*(ab*perp(uv));\n            \n            vec3 uvd = vec3(uv, abs(dot(t, q-e)));\n            if (uvd.z < uvmin.z) { uvmin = uvd; }\n            \n            // test other sign next\n            uv.y = -uv.y;\n            \n        }\n            \n        // if we found a good tangent point\n        if (uvmin.z < 1e-3) {\n            \n            // reconstruct unit circle point, ellipse point, tangent            \n            uv = uvmin.xy;\n            vec2 e = ab*uv;\n            vec2 t = 0.5*(ab*perp(uv));\n\n            // distance to point on ellipse\n            float edst = length(p-e)*e_px_per_unit - 5.;\n            d_ellipse_root[i] = min(d_ellipse_root[i], edst);\n                \n            // distance to root on x-axis\n            float pdst = length(v - vec2(roots[i], 0.))*g_px_per_unit - 5.;\n            d_axis_root[i] = min(d_axis_root[i], pdst);\n            dplot = min(dplot, pdst-2.);\n\n            ddot = min(ddot, edst-2.);\n            dwhite = min(dwhite, dline(p, q, e, 10./e_px_per_unit)*e_px_per_unit - .25);\n            dwhite = min(dwhite, dline(p, e-t, e+t, 0.)*e_px_per_unit - .25);\n            \n        }\n        \n    }\n   \n    ////////////////////////////////////////////////////////////\n\t// do actual drawing\n\n        \n    const vec3 axis_color = vec3(0.12, 0.15, 0.25);\n    \n    const vec3 root_colors[4] = vec3[4](\n        vec3(1, 0, 0),\n        vec3(1, 0.7, 0),\n        vec3(0, 0.7, 0),\n        vec3(0, 0, 1)\n    );\n\n    // bg color\n    vec3 col = vec3(0.45, 0.4, 0.48);\n    \t\n    // ellipse isolines\n    col *= 0.95 + 0.05*cos(60.*d);\n\n    // squares\n    vec2 g = abs(v - .25*floor(4.*v + 0.5));\n    col = mix(col, axis_color, 0.5*smoothstep(1., 0., min(g.x, g.y)*g_px_per_unit));\n\n    // x-axis \n    col = mix(col, axis_color, smoothstep(1., 0., abs(v.y)*g_px_per_unit-1.));\n    \n    // plot line\n    col = mix( col, vec3(0.025), smoothstep(1., 0., dplot-1.));\n    \n    // roots on x-axis\n    for (int i=0; i<4; ++i) {\n        col = mix(col, root_colors[i], smoothstep(1., 0., d_axis_root[i]));\n    }\n\n    // slight dark shadow/glow for ellipse figure\n    col = mix( col, vec3(0), 0.6*exp(-.5*dwhite) );\n    \n    // ellipse figure\n    col = mix( col, vec3(1), smoothstep(1., 0., dwhite) );\n\n    // dark dot outlines \n    col = mix( col, vec3(0.025), smoothstep(1., 0., ddot) );\n    \n    // roots on ellipse\n    for (int i=0; i<4; ++i) {\n        col = mix(col, root_colors[i], smoothstep(1., 0., d_ellipse_root[i]));\n    }\n    \n    // draggable dot\n    col = mix( col, vec3(0.025), smoothstep(1., 0., dq-2.) );\n    col = mix(col, vec3(1), smoothstep(1., 0., dq)); \n\n    // gamma correction\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}