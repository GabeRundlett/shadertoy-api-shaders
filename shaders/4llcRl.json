{
    "Shader": {
        "info": {
            "date": "1506010427",
            "description": "Three normal compression approaches.\n\n * UL: Raw normals\n * UR: R8G8B8 Compression\n * LL: Fibonacci Compression\n * LR: Octahedron Compression\n\nSplit as:\n\n * Left Half: normals rendered as RGB.\n * Right Half: error value.\n\nSee comments for source. ",
            "flags": 32,
            "hasliked": 0,
            "id": "4llcRl",
            "likes": 13,
            "name": "Normals Compression Comparison",
            "published": 3,
            "tags": [
                "normals",
                "compression",
                "comparison"
            ],
            "usePreview": 0,
            "username": "ssell",
            "viewed": 1292
        },
        "renderpass": [
            {
                "code": "/**\n * -----------------------------------------------------------\n * - Normals Compression Comparison\n * - Created by Steven Sell (ssell) / 2017\n * - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * - https://www.shadertoy.com/view/4llcRl\n * -----------------------------------------------------------\n * \n * Comparsion of three different normal compression methods:\n *\n *     (1) R8G8B8 Compression\n *     (2) Fibonacci Compression\n *     (3) Octahedron Compression\n *\n * The screen is split showing each compression and the associated error.\n *\n *     Upper Left:  Raw normals, no error display.\n *     Upeer Right: R8G8B8 Compression \n *     Lower Left:  Fibonacci Compression\n *     Lower Right: Octahedron Compression\n *\n * For all but the raw view, each quadrant is split in half.\n *\n *     Left Half:  Packed then unpacked normals rendered to RGB.\n *     Right Half: Error between the compression and raw.\n *\n * Where error is calculated as:\n *\n *     error = abs(compressed - raw) * 100.0\n *\n *  or (depending on ERROR_AS_DISTANCE #define)\n *\n *     error = distance(compressed, raw) * 100.0\n *\n * The darker the error render, the better the compression/uncompression (error approaches 0.0).\n *\n * See the buffers for compression methods:\n *\n *     Buf A: Scene rendering and raw normal retrieval.\n *     Buf B: R8G8B8 Compression\n *     Buf C: Fibonacci Compression\n *     Buf D: Octahedron Compression\n *\n * -----------------------------------------------------------\n * - References\n * -----------------------------------------------------------\n * \n *     'Normals Compression - Fibonacci' - iq\n *     https://www.shadertoy.com/view/4t2XWK\n *\n *     'Normals Compression - Octahedron' - iq\n *     https://www.shadertoy.com/view/Mtfyzl\n */\n\n//#define ERROR_AS_DISTANCE\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = vec4(1.0);\n    \n    //----------------------------------------------------------\n    // Upper Left - Raw Normals\n    //----------------------------------------------------------\n    \n    if((uv.x < 0.5) && (uv.y > 0.5))\n    {\n        uv.x = uv.x * 2.0;\n        uv.y = (uv.y - 0.5) * 2.0;\n        \n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    \n    //----------------------------------------------------------\n    // Upper Right - R8G8B8 Compression\n    //----------------------------------------------------------\n    \n    if((uv.x > 0.5) && (uv.y > 0.5))\n    {\n        uv.x = (uv.x - 0.5) * 2.0;\n        uv.y = (uv.y - 0.5) * 2.0;\n        \n        vec4 raw    = texture(iChannel0, uv);\n        vec3 packed = texture(iChannel1, uv).rgb;\n        \n#ifdef ERROR_AS_DISTANCE\n        vec3 error  = vec3(distance(packed, raw.rgb)) * 100.0;\n#else\n        vec3 error  = abs(packed - raw.rgb) * 100.0;\n#endif\n        \n        vec3 color  = (uv.x > 0.5) ? error : packed;\n        fragColor.rgb = (raw.a > 0.0 ? color : raw.rgb);\n        \n        return;\n    }\n    \n    //----------------------------------------------------------\n    // Lower Left - Fibonacci Compression\n    //----------------------------------------------------------\n    \n    if((uv.x < 0.5) && (uv.y < 0.5))\n    {\n        uv.x = uv.x * 2.0;\n        uv.y = uv.y * 2.0;\n        \n        vec4 raw    = texture(iChannel0, uv);\n        vec3 packed = texture(iChannel2, uv).rgb;\n        \n#ifdef ERROR_AS_DISTANCE\n        vec3 error  = vec3(distance(packed, raw.rgb)) * 100.0;\n#else\n        vec3 error  = abs(packed - raw.rgb) * 100.0;\n#endif\n        \n        vec3 color  = (uv.x > 0.5) ? error : packed;\n        fragColor.rgb = (raw.a > 0.0 ? color : raw.rgb);\n        \n        return;\n    }\n    \n    //----------------------------------------------------------\n    // Lower Right - Octahedron Compression\n    //----------------------------------------------------------\n    \n    if((uv.x > 0.5) && (uv.y < 0.5))\n    {\n        uv.x = (uv.x - 0.5) * 2.0;\n        uv.y = uv.y * 2.0;\n        \n        vec4 raw    = texture(iChannel0, uv);\n        vec3 packed = texture(iChannel3, uv).rgb;\n        \n#ifdef ERROR_AS_DISTANCE\n        vec3 error  = vec3(distance(packed, raw.rgb)) * 100.0;\n#else\n        vec3 error  = abs(packed - raw.rgb) * 100.0;\n#endif\n        \n        vec3 color  = (uv.x > 0.5) ? error : packed;\n        fragColor.rgb = (raw.a > 0.0 ? color : raw.rgb);\n        \n        return;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * - Scene Rendering\n * -----------------------------------------------------------\n * \n * Simple raymarched scene. The shape is sourced from iq's normal shaders, such as:\n *\n *     https://www.shadertoy.com/view/Mtfyzl\n */\n\n#define NearClip 0.01\n#define FarClip  15.0\n#define CamFOV   40.0\n\n//------------------------------------------------------------------------------------------\n// Ray / Camera\n//------------------------------------------------------------------------------------------\n\nstruct Ray\n{\n\tvec3 o;\n    vec3 d;\n};\n\nRay Ray_LookAt(in vec2 uv, in vec3 o, in vec3 d)\n{\n    vec3 forward = normalize(d - o);\n    vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up      = normalize(cross(right, forward));\n\n    uv = (uv * 2.0) - 1.0;\n\n    float imgU = tan(CamFOV) * distance(o, d);\n    float imgV = imgU * iResolution.y / iResolution.x;\n    \n    Ray ray;\n    ray.o = o;\n    ray.d = normalize(d + uv.x * imgU * right + uv.y * imgV * up - o);\n\n    return ray;\n}\n\n//------------------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------------------\n\nfloat Scene(vec3 p)\n{\n    p.xz *= 0.8;\n    p.xyz += 1.000*sin(  2.0*p.yzx );\n    p.xyz -= 0.500*sin(  4.0*p.yzx );\n    float d = length( p.xyz ) - 1.5;\n\treturn d * 0.25;\n}\n\nfloat March(in Ray ray)\n{\n    float depth = NearClip;\n    \n    for(uint i = 0u; i < 100u; ++i)\n    {\n        vec3 pos  = ray.o + (ray.d * depth);\n        float sdf = Scene(pos);\n        \n        if((sdf < 0.001) || (depth > FarClip))\n        {\n            break;\n        }\n        \n        depth += sdf;\n    }\n    \n    return depth;\n}\n\nvec3 SceneNormal(vec3 pos, float depth)\n{\n    vec2 eps = vec2(0.01 * depth, 0.0);\n    return normalize(vec3(Scene(pos + eps.xyy) - Scene(pos - eps.xyy),\n                          Scene(pos + eps.yxy) - Scene(pos - eps.yxy),\n                          Scene(pos + eps.yyx) - Scene(pos - eps.yyx)));\n}\n\n//------------------------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------------------------\n\nvec4 Render(in Ray ray)\n{\n    vec4 color  = vec4(0.3, 0.3, 0.3, 0.0);\n\tfloat depth = March(ray);\n    \n    if(depth < FarClip)\n    {\n        vec3 pos = ray.o + (ray.d * depth);\n        vec3 norm = SceneNormal(pos, depth);\n        \n        color = vec4(norm, 1.0);\n    }\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvec3 OrbitAround(vec3 origin, float radius, float rate)\n{\n  \treturn vec3((origin.x + (radius * cos(iTime * rate))), (origin.y), (origin.z + (radius * sin(iTime * rate))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    Ray ray = Ray_LookAt(uv, OrbitAround(vec3(0.0), 6.0, 0.25), vec3(0.0));\n    \n    fragColor = Render(ray);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * - R8G8B8 Compression\n * -----------------------------------------------------------\n * \n * A simple compression method that transforms normals from [-1,1] to [0,0]\n * and packs them using straightforward shifting/compression.\n *\n * Have used it in multiple older shaders.\n */\n\n//------------------------------------------------------------------------------------------\n// R8G8B8 Packing\n//------------------------------------------------------------------------------------------\n\nfloat PackR8G8B8(vec3 rgb)\n{\n    rgb = (rgb * 255.0) + 0.5;\n    return float((uint(rgb.r)) | (uint(rgb.g) << 8) | (uint(rgb.b) << 16));\n}\n\nfloat PackNorm(vec3 norm)\n{\n\treturn PackR8G8B8((norm + 1.0) * 0.5);   \n}\n\nvec3 UnpackR8G8B8(float f)\n{\n    uint ufloat = uint(f);\n    return vec3(float(ufloat & 0xFFu), float((ufloat >> 8) & 0xFFu), float((ufloat >> 16) & 0xFFu)) * 0.00392156862;\n}\n\nvec3 UnpackNorm(float f)\n{\n\treturn (UnpackR8G8B8(f) * 2.0) - 1.0;   \n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 raw = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if(raw.a < 1.0)\n    {\n        fragColor = vec4(raw.rgb, 1.0);\n        return;\n    }\n    \n    float pack   = PackNorm(raw.rgb);\n    vec3  unpack = UnpackNorm(pack);\n    \n    fragColor = vec4(unpack, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * - Fibonacci Compression\n * -----------------------------------------------------------\n * \n * Source:\n *\n *     'Normals Compression - Fibonacci' - iq\n *     https://www.shadertoy.com/view/4t2XWK\n */\n\n//------------------------------------------------------------------------------------------\n// Fibonacci Packing\n//------------------------------------------------------------------------------------------\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2 a, float b) { return a*b -floor(a*b); }\n\nfloat sf2id(vec3 p, float n) \n{\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.0)/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\n\nvec3 id2sf( float i, float n) \n{\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 raw = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if(raw.a < 1.0)\n    {\n        fragColor = vec4(raw.rgb, 1.0);\n        return;\n    }\n    \n    float pack   = sf2id(raw.rgb, pow(2.0, 16.0));\n    vec3  unpack = id2sf(pack, pow(2.0, 16.0));\n    \n    fragColor = vec4(unpack, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * - Octahedron Compression\n * -----------------------------------------------------------\n * \n * Source:\n *\n *     'Normals Compression - Octahedron' - iq\n *     https://www.shadertoy.com/view/Mtfyzl\n */\n\n//------------------------------------------------------------------------------------------\n// Octahedral Packing\n//------------------------------------------------------------------------------------------\n\nuint octahedral_32( in vec3 nor, uint sh )\n{\n    nor /= ( abs( nor.x ) + abs( nor.y ) + abs( nor.z ) );\n    nor.xy = (nor.z >= 0.0) ? nor.xy : (1.0-abs(nor.yx))*sign(nor.xy);\n    vec2 v = 0.5 + 0.5*nor.xy;\n\n    uint mu = (1u<<sh)-1u;\n    uvec2 d = uvec2(floor(v*float(mu)+0.5));\n    return (d.y<<sh)|d.x;\n}\n\nvec3 i_octahedral_32( uint data, uint sh )\n{\n    uint mu =(1u<<sh)-1u;\n    \n    uvec2 d = uvec2( data, data>>sh ) & mu;\n    vec2 v = vec2(d)/float(mu);\n    \n    v = -1.0 + 2.0*v;\n    vec3 nor;\n    nor.z = 1.0 - abs(v.x) - abs(v.y);\n    nor.xy = (nor.z>=0.0) ? v.xy : (1.0-abs(v.yx))*sign(v.xy);\n    return normalize( nor );\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 raw = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if(raw.a < 1.0)\n    {\n        fragColor = vec4(raw.rgb, 1.0);\n        return;\n    }\n    \n    uint pack   = octahedral_32(raw.rgb, 16u);\n    vec3 unpack = i_octahedral_32(pack, 16u);\n    \n    fragColor = vec4(unpack, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}