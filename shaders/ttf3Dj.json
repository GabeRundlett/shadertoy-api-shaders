{
    "Shader": {
        "info": {
            "date": "1566742977",
            "description": "render",
            "flags": 0,
            "hasliked": 0,
            "id": "ttf3Dj",
            "likes": 0,
            "name": "Sphere ray cast render v6",
            "published": 3,
            "tags": [
                "raycast"
            ],
            "usePreview": 0,
            "username": "oseday",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "struct material{\n    vec3 color;\n    float reflectance;\n    float transparency;\n    float eta;\n};\n\nstruct sphere{\n    vec3 pos;\n    float radius;\n    float radiussq;\n    material material;\n};\n    \nstruct panel{\n    vec3 pos;\n    vec3 normal;\n    float radius;\n    vec3 uvn1; //normal for uv\n    vec3 uvn2; \n    material material;\n};\n\nstruct rayresult{\n    bool hit; //if hit\n    vec3 N; //normal\n    vec3 P; //hit pos\n    vec3 o; //origin\n    vec3 v; //direction\n    float dist; //distance\n    vec2 uv; //material texture uv pos\n    material material;\n    bool does;\n    bool gin;\n};\n\nstruct light{\n    vec3 pos;\n    float brightness;\n    vec3 color;\n};\n\nconst int sphere_count=5;\nsphere spheres[sphere_count];\n\nconst int panel_count=1;\npanel panels[panel_count];\n\nconst int light_count=1;\nlight lights[light_count];\n\n    \n\nmat4 cam = mat4(\n    1,0,0,0,\n    0,1,0,0,\n    0,0,1,0,\n    0,0,0,1\n);\n\nmat4 addmv(mat4 mat, vec3 v){\n    mat4 n = mat;\n    n[3]=n[3]+vec4(v,0);\n    return n;\n}\n\nmat4 mat4v(vec3 v){\n    return mat4(\n        1,0,0,v.x,\n        0,1,0,v.y,\n        0,0,1,v.z,\n        0,0,0,1\n    );\n}\n\nvec3 matpos(mat4 mat){\n    return mat[3].xyz;\n}\n\nconst float planedist = 1.;\n\n//float tick = iTime/5.0;\n\nbool raycheck(vec3 pos, vec3 dir, float len){\n    for (int i=0;i<sphere_count;i++){\n        sphere c=spheres[i];\n        vec3 L = c.pos-pos;\n        float tca = dot(L,dir);\n        if (tca>0.){\n            float d2 = dot(L,L)-tca*tca;\n            if (d2<c.radiussq){\n                float dist = tca-sqrt(c.radiussq-d2);\n                if (dist<len){\n                    return true;\n                }\n            }\n        }\n    }\n    \n    for (int i=0;i<panel_count;i++){\n        panel p=panels[i];\n        vec3 op=p.pos-pos;\n        if (dot(p.normal,dir)<0.){\n            float dist = dot(op,p.normal)/dot(dir,p.normal);\n            if (dist<len){\n                vec3 P = pos+dist*dir;\n                if (length(P-p.pos)<p.radius){\n                    return true;\n                }\n            }\n        }\n    }\n    \n    \n    return false;\n}\n\nrayresult ray(vec3 pos, vec3 dir){\n    \n    rayresult ray;\n    float zbuffer = 9999999999.;\n    \n    ray.hit=false;\n    ray.o=pos;\n    ray.v=dir;\n    ray.gin=true;\n    \n    for (int i=0;i<sphere_count;i++){\n        sphere c=spheres[i];\n        vec3 L = c.pos-pos;\n        float tca = dot(L,dir);\n        if (tca>0.){\n            float d2 = dot(L,L)-tca*tca;\n            if (d2<c.radiussq){\n                float dist;\n                float ori = 1.;\n                if (dot(L,L)>c.radiussq){\n                \tdist = tca-sqrt(c.radiussq-d2);\n                }else{\n                    dist = tca+sqrt(c.radiussq-d2);\n                    ori=-1.;\n                    ray.gin=false;\n                }\n                if (dist<zbuffer){\n                    zbuffer=dist;\n                    ray.P = pos+dist*dir;\n                    ray.N = normalize(ray.P-c.pos)*ori;\n                    ray.material=c.material;\n                    ray.dist=dist;\n                    ray.hit=true;\n                    ray.uv=vec2(atan(ray.N.z,ray.N.x),acos(ray.N.y));\n                }\n            }\n        }\n    }\n    \n    for (int i=0;i<panel_count;i++){\n        panel p=panels[i];\n        vec3 op=p.pos-pos;\n        if (dot(p.normal,dir)<0.){\n            float dist = dot(op,p.normal)/dot(dir,p.normal);\n            vec3 P = pos+dist*dir;\n            if ( dist<zbuffer && length(P-p.pos)<p.radius){\n                zbuffer = dist;\n                ray.P = P;\n                ray.N = p.normal;\n                ray.material=p.material;\n                ray.dist=dist;\n                ray.hit=true;\n                vec3 normop = normalize(p.pos-P);\n                ray.uv=vec2(atan(dot(p.uvn1,normop),dot(p.uvn2,normop)),length(p.pos-P)/p.radius*2.);\n            }\n        }\n    }\n    \n    return ray;\n}\n\nconst float ambient = 0.6;//0.21;//0.50035;\n\nvec3 doLight(rayresult o,float dit,bool next){//Returns color\n    vec3 col = vec3(0,0,0);\n    \n    if (!o.gin){\n        col+= texture(iChannel0,o.v).xyz*o.material.transparency*ambient*o.material.color;\n        return col;\n    }\n    \n    for (int i=0;i<light_count;i++){\n        vec3 v = lights[i].pos-o.P;\n        vec3 dir = normalize(v);\n        //vec3 fv += dir*dit;\n        if (!raycheck(o.P,dir,length(v))){\n            col +=  texture(iChannel1,o.uv).xyz\n                    *o.material.color\n                    *lights[i].color\n                    *lights[i].brightness\n                    /length(v)/length(v)\n                    *max(0.,dot(v,o.N))\n                    *(1.-o.material.reflectance)\n               \t\t*(1.-o.material.transparency);\n            \n            float ft = acos(dot(reflect(o.v,o.N),dir));//phong\n            if (ft<1.5){\n                col += col*(1.5-ft)/6.5;\n            }\n        }\n    }\n    //if (next){\n    if (o.gin){\n        col+=   (texture(iChannel1,o.uv).xyz*(texture(iChannel0,reflect(o.v,o.N)).xyz*o.material.reflectance+\n                (1.-o.material.reflectance)*vec3(1,1,1))\n                *ambient*o.material.color\n                 )*(1.-o.material.transparency);\n    }\n    //}\n    \n    \n    \n    return col;\n}\n\nconst int maxrec = 6; //maximum recursion\n\nfloat drawlight(rayresult o, int rec, float initref){\n    \tfor (int i=0;i<light_count;i++){\n            float aa = acos(dot(o.v,normalize(lights[i].pos-o.o)));\n            if (aa<0.009  && (!o.hit || length(lights[i].pos-o.o)<o.dist)){\n                if (rec<=1){\n                    return (0.009-aa)/0.009;\n                }else{\n                    return (0.009-aa)/0.009*initref;\n                }\n            }\n        } \n}\n\nvec3 manager(rayresult io){\n    vec3 col = vec3(0,0,0);\n    bool en = true;\n    float dist=0.;\n    int rec = 1;\n    float initref = 1.;//io.material.reflectance;\n    \n    col += drawlight(io, rec, initref);\n    \n    rayresult os[50];\n    io.does=true;\n    os[0]=io;\n    \n    int oscount = 1;\n    \n    while (en && maxrec>rec){\n        en=false;\n        for (int oi=0;oi<oscount;oi++){\n            rayresult o = os[oi];\n            \n            if (o.does){\n                //if (o.gin){\n            \tcol += doLight(o,dist,rec<=1)*initref;\n                //}\n                os[oi].does=false;\n            \n                if (o.material.reflectance>0.01){\n                    vec3 ndir = reflect(o.v,o.N);\n                    initref *= o.material.reflectance;\n                    os[oi] = ray(o.P+ndir*0.01,ndir);\n\n                    col += drawlight(os[oi], rec, initref);\n\n                    en = os[oi].hit || en;\n                    dist+=os[oi].dist;\n                    rec++;\n                    os[oi].does=true;\n                }   \n                if (o.material.transparency>0.01){\n                    //float eta = o.gin ? o.material.eta : 1./o.material.eta;\n                    \n                    vec3 ndir;\n                        \n                    if (o.gin){\n                        ndir = refract(o.v,o.N,o.material.eta);\n                    }else{\n                        ndir = refract(o.v,-o.N,1./o.material.eta);\n                    }\n                    \n                    \n                    \n                    \n                    initref *= o.material.transparency;\n\n                    int noo = oi+1;\n                    oscount++;\n\n                    os[noo] = ray(o.P+ndir*0.0001,ndir);\n                    \n\t\t\t\t\t\n                    col += drawlight(os[noo], rec, initref);\n\n                    en = os[noo].hit || en;\n                    dist+=os[noo].dist;\n                    rec++;\n                    os[noo].does=true;\n                }\n            }\n            \n        }\n    }\n    return col;\n}\n\nvoid updatescene(float tick){\n    for (int i=0;i<sphere_count;i++){\n        float ii = float(i);\n        spheres[i].pos=vec3(cos(tick+ii)*29.,sin(tick*5.+ii)*12.,50.1+ii*2.9+sin(ii*4.4567));\n        spheres[i].radius = cos(tick*2.+ii)*2.+5.;\n        spheres[i].radiussq = spheres[i].radius*spheres[i].radius;\n        spheres[i].material.color=vec3(1,sin(ii),cos(ii));\n        spheres[i].material.reflectance=sin(ii*456.456)*.5+.5;//sin(tick*6.)*0.5+0.5;//pow(sin(tick*6.)*sin(tick*6.),0.5);\n    }\n    \n    lights[0].pos = vec3(cos(tick)*20.,5,sin(tick)*40.+80.);\n    lights[0].brightness = 25.;//25.;\n    lights[0].color = vec3(1,1,1);\n    \n    \n    spheres[4].material.reflectance=0.;\n    spheres[4].material.transparency=0.55;\n    spheres[4].material.eta=1.20;\n    spheres[4].material.color=vec3(1,1,1);\n    spheres[4].radius = 15.;\n    spheres[4].radiussq = spheres[4].radius*spheres[4].radius;\n    \n    //lights[1].pos = vec3(0,-22,80);\n    //lights[1].brightness = 20.;\n    //lights[1].color = vec3(1,1,1);\n    \n    /*\n    lights[2].pos = vec3(0,-20,80);\n    lights[2].brightness = 0.;\n    lights[2].color = vec3(1,1,1);\n    */\n    \n    //lights[2].pos = vec3(10,10,25);\n    //lights[2].brightness = 25.;\n    //lights[2].color = vec3(1,1,1);\n    //for (int i=1;i<light_count;i++){\n        \n    //}\n    panels[0].pos = vec3(0,-30,80);\n    panels[0].normal = normalize(vec3(cos(tick*2.),3.,sin(tick*2.)));\n    panels[0].radius = 30.+sin(tick)*10.;\n    panels[0].material.color = vec3(1,1,1);\n    panels[0].material.reflectance = 1.;\n    panels[0].uvn1 = cross(panels[0].normal,normalize(vec3(454,957,234)));\n    panels[0].uvn2 = cross(panels[0].normal,panels[0].uvn1);\n    \n    /*\n    panels[1].pos = vec3(0,0,120);\n    panels[1].normal = vec3(0,0,-1);\n    panels[1].radius = 40.;\n    panels[1].material.color = vec3(1,1,1);\n    panels[1].material.reflectance = 0.8;\n    panels[1].uvn1 = cross(panels[0].normal,normalize(vec3(454,957,234)));\n    panels[1].uvn2 = cross(panels[0].normal,panels[0].uvn1);\n    \n    panels[2].pos = vec3(0,0,40);\n    panels[2].normal = vec3(0,0,1);\n    panels[2].radius = 40.;\n    panels[2].material.color = vec3(1,1,1);\n    panels[2].material.reflectance = 0.8;\n    panels[2].uvn1 = cross(panels[0].normal,normalize(vec3(454,957,234)));\n    panels[2].uvn2 = cross(panels[0].normal,panels[0].uvn1);\n\t*/\n}\n\nconst int MSAA = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tick = iTime/5.;\n    \n    \n    updatescene(tick);\n    \n    vec2 mouseuv = (iMouse.xy-iResolution.xy/2.0)/iResolution.xx*2.;\n    \n    \n    mat4 ncam = cam\n        *build_transform(vec3(0,0,0),vec3(0,-mouseuv.x*3.1415928,0))\n        *build_transform(vec3(0,0,0),vec3(-mouseuv.y*3.1415928+sin(tick*2.*0.)/3.,0,0))\n        ;\n    ncam = ncam\n        *build_transform(vec3(0,0,-80),vec3(0,0,0))\n        ;\n    ncam[3].xyz = ncam[3].xyz + vec3(0,0,80);\n    \n    \n    vec3 campos = matpos(ncam);\n    vec3 totcol = vec3(0,0,0);\n        \n    float distMSAA = float(MSAA+1);\n    \n    for (int xs=1;xs<=MSAA;xs++){\n        for (int ys=1;ys<=MSAA;ys++){\n            \n            vec2 uv = (fragCoord+vec2(xs,ys)/distMSAA-iResolution.xy/2.0)/iResolution.xx*2.;\n\n            vec3 v = normalize(uv.x*ncam[0].xyz+uv.y*ncam[1].xyz+ncam[2].xyz*planedist);\n\n            vec3 col = vec3(0,0,0);\n\n            rayresult o = ray(campos,v);\n\n\n            if (o.hit){\n                col += manager(o);\n            }else{\n                col += texture(iChannel0,o.v).xyz*ambient;\n                for (int i=0;i<light_count;i++){\n                    float aa = acos(dot(v,normalize(lights[i].pos-campos)));\n                    if (aa<0.009  && (!o.hit || length(lights[i].pos-campos)<o.dist)){\n                        col += (0.009-aa)/0.009;\n                    }\n                }\n            }\n\n            col = clamp(col,vec3(0,0,0),vec3(1,1,1));\n            totcol += col;\n        }\n    }\n    \n    totcol /= float(MSAA*MSAA);\n\n    fragColor = vec4(totcol,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat4 build_transform(vec3 pos, vec3 ang) \n{\n  float cosX = cos(ang.x);\n  float sinX = sin(ang.x);\n  float cosY = cos(ang.y);\n  float sinY = sin(ang.y);\n  float cosZ = cos(ang.z);\n  float sinZ = sin(ang.z);\n\n  mat4 m;\n\n  float m00 = cosY * cosZ + sinX * sinY * sinZ; \n  float m01 = cosY * sinZ - sinX * sinY * cosZ; \n  float m02 = cosX * sinY;\n  float m03 = 0.0;\n  \n  float m04 = -cosX * sinZ; \n  float m05 = cosX * cosZ; \n  float m06 = sinX;\n  float m07 = 0.0;\n  \n  float m08 = sinX * cosY * sinZ - sinY * cosZ;\n  float m09 = -sinY * sinZ - sinX * cosY * cosZ;\n  float m10 = cosX * cosY;\n  float m11 = 0.0;\n  \n  float m12 = pos.x;\n  float m13 = pos.y;\n  float m14 = pos.z;\n  float m15 = 1.0;\n\n  /*\n  //------ Orientation ---------------------------------\n  m[0] = vec4(m00, m01, m02, m03); // first column.\n  m[1] = vec4(m04, m05, m06, m07); // second column.\n  m[2] = vec4(m08, m09, m10, m11); // third column.\n\n  //------ Position ------------------------------------\n  m[3] = vec4(m12, m13, m14, m15); // fourth column.\n  */\n\n  //------ Orientation ---------------------------------\n  m[0][0] = m00; // first entry of the first column.\n  m[0][1] = m01; // second entry of the first column.\n  m[0][2] = m02;\n  m[0][3] = m03;\n  \n  m[1][0] = m04; // first entry of the second column.\n  m[1][1] = m05; // second entry of the second column.\n  m[1][2] = m06;\n  m[1][3] = m07;\n\n  m[2][0] = m08; // first entry of the third column.\n  m[2][1] = m09; // second entry of the third column.\n  m[2][2] = m10;\n  m[2][3] = m11;\n  \n  //------ Position ------------------------------------\n  m[3][0] = m12; // first entry of the fourth column.\n  m[3][1] = m13; // second entry of the fourth column.\n  m[3][2] = m14;\n  m[3][3] = m15;\n\n  return m;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}