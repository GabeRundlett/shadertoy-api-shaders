{
    "Shader": {
        "info": {
            "date": "1604517696",
            "description": "WoS for subsurface scattering! Currently only double-scattering for the MS component with only 1 step on a sphere. Can be easily extended to do triple(or more)-scattering. WoS's biggest contribution is still luminaire sampling.",
            "flags": 32,
            "hasliked": 0,
            "id": "WstfzN",
            "likes": 19,
            "name": "Walk on Spheres Light Transport",
            "published": 3,
            "tags": [
                "sdf",
                "light",
                "scattering",
                "subsurface",
                "multiple",
                "transport"
            ],
            "usePreview": 1,
            "username": "toomuchvoltage",
            "viewed": 1127
        },
        "renderpass": [
            {
                "code": "/***********************************************************\n\n   Walk-on-Spheres light transport!\n   Follow up to: https://www.shadertoy.com/view/3t2BDz\n   Original inspiration: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n   Using Sebastien Hillaire's improved integration for longer walks (Page 38, Eq. 17): https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n   All your sdf and value noises are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord/iResolution.xy;\n    vec4 fetchMC = texture(iChannel0, uvRaw);\n\tvec3 light = fetchMC.rgb/fetchMC.a;\n    light = max(light, 0.0);\n    light = light / (1.0 + light); // Reinhard\n    light = pow(light, vec3(1.0f/2.2)); // Gamma correction\n    fragColor = vec4 (light, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/***********************************************************\n\n   Walk-on-Spheres light transport!\n   Follow up to: https://www.shadertoy.com/view/3t2BDz\n   Original inspiration: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n   Using Sebastien Hillaire's improved integration for longer walks (Page 38, Eq. 17): https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n   All your sdf and value noises are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\n#define M_PI 3.1415926535\n#define SURFACE_ROUGHNESS 0.4\n#define SCATTERING_COEF 10.0\n#define TRANSMISSION_COEF 0.5\n#define EXTINCTION_COEF (SCATTERING_COEF + TRANSMISSION_COEF)\n#define EMISSIVITY vec3(4.0)\n#define DIFFUSION_COLOR vec3(60.0, 0.0, 0.0)\n#define MEDIUM_DENSITY 1.0\n\nfloat phaseFunc (vec3 toMarch, vec3 toLight)\n{\n    return 1.0 / (4.0 * M_PI); // Isotropic scattering for now...\n}\n\n// *******************************************************\n// Change sceneLum(vec3 p) to try any of them out\n// They converge faster! though with bias. This is because we don't have the exact projected sampling area.\n// *******************************************************\n\nfloat sceneLumSphere (vec3 p) // Sphere\n{\n    return length(p) - 0.5;\n}\n\nfloat sceneLumBox (vec3 p) // Box\n{\n    vec3 q = abs(p) - vec3 (0.2);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sceneLumTorus (vec3 p) // Capped torus\n{\n    float ra = 1.0;\n    float rb = 0.1;\n    vec2 sc = vec2 (1.0, 0.0);\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sceneLumLink(vec3 p) // Link\n{\n    float le = 0.5;\n    float r1 = 0.5;\n    float r2 = 0.05;\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdOctahedron(vec3 p) // Octahedron\n{\n    float s = 0.5;\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n    if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n        else if( 3.0*p.z < m ) q = p.zxy;\n            else return m*0.57735027;\n\n            float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n        return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sceneLum(vec3 p)\n{\n    return sceneLumSphere (p); // <--- Change this to try different ones...\n}\n\n// *******************************************************\n// Below are different translucent and scattering objects\n// *******************************************************\n\nfloat sssLink(vec3 p)\n{\n    return sceneLumLink(p + vec3 (0.0, -0.2, 0.5)) - 0.1;\n}\n\nfloat sssTorus(vec3 p)\n{\n    return sceneLumTorus(p + vec3 (0.0, 0.0, 0.5)) - 0.1;\n}\n\nfloat sssBox(vec3 p)\n{\n    return sceneLumBox(p + vec3 (0.0, 0.0, 1.0)) - 0.1;\n}\n\nfloat sssOctahedron(vec3 p)\n{\n    return sdOctahedron(p + vec3 (0.0, 0.0, 1.2)) - 0.1;\n}\n\nfloat sceneSSSObj (vec3 p)\n{\n    return sssLink(p); // <--- Change this to try different translucent/scattering shapes...\n}\n\n// *******************************************************\n// Scene definition\n// *******************************************************\n\nfloat scene (vec3 p, out float mat)\n{\n    mat = 0.0;\n    float walls = p.y + 1.0;\n    walls = min (walls, -p.z + 1.0);\n    \n    float lamp = sceneLum(p);\n    float sssComp = sceneSSSObj(p);\n    \n    float sceneSDF = min (min (lamp, walls), sssComp);\n    \n    if ( sceneSDF == lamp ) mat = 1.0;\n    else if ( sceneSDF == sssComp ) mat = 2.0;\n    else mat = 0.0;\n\n    return sceneSDF;\n}\n\n// *******************************************************\n// Marching utils\n// *******************************************************\n\nbool sphereMarchScene(vec3 startPt, vec3 dir, out vec3 hitPt, out vec3 hitNorm, out float mat)\n{\n    float i = 0.0;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = scene (samplePt, mat);\n        if ( abs (curDist) < 0.001 )\n        {\n            float sceneMatTmp;\n            hitNorm.x = scene(samplePt + vec3(0.001, 0.0, 0.0), sceneMatTmp) - scene(samplePt - vec3(0.001, 0.0, 0.0), sceneMatTmp);\n            hitNorm.y = scene(samplePt + vec3(0.0, 0.001, 0.0), sceneMatTmp) - scene(samplePt - vec3(0.0, 0.001, 0.0), sceneMatTmp);\n            hitNorm.z = scene(samplePt + vec3(0.0, 0.0, 0.001), sceneMatTmp) - scene(samplePt - vec3(0.0, 0.0, 0.001), sceneMatTmp);\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nbool sphereMarchInsideSSSObj(vec3 startPt, vec3 dir, out vec3 hitPt, out vec3 hitNorm)\n{\n    float i = 0.0;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = abs(sceneSSSObj (samplePt));\n        if ( curDist < 0.01 )\n        {\n            hitNorm.x = sceneSSSObj(samplePt + vec3(0.001, 0.0, 0.0)) - sceneSSSObj(samplePt - vec3(0.001, 0.0, 0.0));\n            hitNorm.y = sceneSSSObj(samplePt + vec3(0.0, 0.001, 0.0)) - sceneSSSObj(samplePt - vec3(0.0, 0.001, 0.0));\n            hitNorm.z = sceneSSSObj(samplePt + vec3(0.0, 0.0, 0.001)) - sceneSSSObj(samplePt - vec3(0.0, 0.0, 0.001));\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nfloat wosSSSObjStep(inout vec3 samplePt)\n{\n    // This is not shell tracing: we're not advancing the path via importance sampling a shell transport function.\n    // Jury's out whether this introduces bias by skipping smaller scattering events inside.\n    float curDist = abs (sceneSSSObj (samplePt));\n\tvec3 dir = normalize (textureLod (iChannel1, (samplePt.xz + vec2(iTime)) * samplePt.zy * 3.0, 0.0).rgb * 2.0 - 1.0);\n    samplePt += curDist * dir;\n    return curDist;\n}\n\nfloat sphereMarchSSSObjStep(inout vec3 samplePt, vec3 dir)\n{\n    float curDist = abs (sceneSSSObj (samplePt));\n    samplePt += curDist * dir;\n    return curDist;\n}\n\nbool wosLum(vec3 startPt, out vec3 hitPt, out vec3 hitNorm)\n{\n    float i = 0.0;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = sceneLum (samplePt);\n        if ( abs (curDist) < 0.01 )\n        {\n            hitNorm.x = sceneLum(samplePt + vec3(0.001, 0.0, 0.0)) - sceneLum(samplePt - vec3(0.001, 0.0, 0.0));\n            hitNorm.y = sceneLum(samplePt + vec3(0.0, 0.001, 0.0)) - sceneLum(samplePt - vec3(0.0, 0.001, 0.0));\n            hitNorm.z = sceneLum(samplePt + vec3(0.0, 0.0, 0.001)) - sceneLum(samplePt - vec3(0.0, 0.0, 0.001));\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        vec3 dir = normalize (textureLod (iChannel1, samplePt.xz * 3.0 + iTime * samplePt.zy * 3.0, 0.0).rgb * 2.0 - 1.0);\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\n// *******************************************************\n// Scattering helper util\n// *******************************************************\n\nvec3 getInScattering (vec3 samplePt, vec3 lightDir)\n{\n\tfloat randPenAmount = (0.03 * textureLod (iChannel1, (samplePt.yz + iTime * samplePt.xy) * 5.0, 0.0).b + 0.02);\n    vec3 sssExit, sssExitNorm, exitToLumHit, exitToLumHitNorm;\n    float exitToLumHitMat = -1.0;\n    sphereMarchInsideSSSObj (samplePt, lightDir, sssExit, sssExitNorm);\n    if ( sphereMarchScene (sssExit + sssExitNorm * randPenAmount /* Go out */, lightDir, exitToLumHit, exitToLumHitNorm, exitToLumHitMat) && exitToLumHitMat == 1.0 )\n    {\n        vec3 lightSegment = exitToLumHit - sssExit;\n        float NddotLo = abs (dot (sssExitNorm, lightDir));\n        float LidotNl = abs (dot (exitToLumHitNorm, -lightDir));\n        float distSq = dot (lightSegment, lightSegment);\n        float GeomTerm = (NddotLo * LidotNl) / distSq;\n        vec3 surfaceTransmission = GeomTerm * 0.75 * EMISSIVITY * DIFFUSION_COLOR; // We don't have |A| so just make stuff up...\n\n        /* There should be a BTDF here... but we're not using any real distributions... so :shrugs: */\n\n        vec3 toSurface = sssExit - samplePt;\n        float sssToSurfDist = length (toSurface);\n        float incomingLightAbsorption = exp (-MEDIUM_DENSITY * EXTINCTION_COEF * sssToSurfDist);\n        vec3 inScattering = surfaceTransmission * MEDIUM_DENSITY * SCATTERING_COEF * incomingLightAbsorption * phaseFunc (toSurface, lightDir);\n        return (inScattering - inScattering * incomingLightAbsorption) / max (MEDIUM_DENSITY * EXTINCTION_COEF, 0.000001);\n    }\n    return vec3 (0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvRaw = fragCoord/iResolution.xy;\n    vec2 uv = uvRaw * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n\tvec2 aa = textureLod(iChannel1, iTime * M_PI * uv, 0.0).rg * 2.0 - 1.0; // LDS jitter\n    aa *= 2.0;\n    uv += aa / iResolution.xy;\n    \n    vec4 mouseInfo = iMouse / iResolution.xxxx;\n    \n    vec3 curEye = vec3 (cos(mouseInfo.x * 3.0 - M_PI), mouseInfo.y * 3.0, sin(mouseInfo.x * 3.0 - M_PI)) * 3.0;\n    vec3 sampleLook = normalize (-curEye);\n    \n    vec3 side = cross (vec3 (0.0, -1.0, 0.0), sampleLook);\n    vec3 up = cross (side, sampleLook);\n    if ( dot (up, vec3 (0.0, 1.0, 0.0)) < 0.0 ) up = -up;\n    \n    vec3 sampleDir = normalize (sampleLook + side * uv.x + up * uv.y);\n    vec3 samplePt = curEye + sampleDir;\n    vec3 colorAccum = vec3 (0.0);\n\n    samplePt = curEye + sampleDir;\n    bool samplingLight = false;\n    vec3 hitNorm;\n    vec3 hitPoint;\n    float hitMat;\n\n    if ( sphereMarchScene (samplePt, sampleDir, hitPoint, hitNorm, hitMat) )\n    {\n        if ( hitMat == 1.0 )\n        {\n            colorAccum = EMISSIVITY;\n        }\n        else if ( hitMat == 2.0 )\n        {\n            float randPenAmount = (0.03 * textureLod (iChannel1, (samplePt.xz + iTime * samplePt.zy) * 3.0, 0.0).g + 0.02);\n            samplePt = hitPoint - hitNorm * randPenAmount; // Go in\n\n            float sssObjDist = sceneSSSObj(samplePt);\n            float transmittance = 1.0;\n            float travelAmount = length(samplePt - hitPoint); // Penetration amount...\n            int countSteps = 0;\n            \n            vec3 blueNoiseFetch = textureLod (iChannel1, (samplePt.yz + iTime * samplePt.xy) * 5.0, 0.0).rgb;\n            blueNoiseFetch = (blueNoiseFetch - vec3 (0.5)) * 2.0 * SURFACE_ROUGHNESS; // Hacky random surface distribution\n            vec3 singleScatDir = normalize (sampleDir + blueNoiseFetch);\n            \n            /* There should be a BTDF here... but we're not using any real distributions... so :shrugs: */\n\n            do\n            {\n                vec3 destOnLum, destOnLumNorm;\n                wosLum (samplePt, destOnLum, destOnLumNorm); // Pick a random spot on the luminaire...\n\t            vec3 toLightPt = normalize (destOnLum - samplePt); // Get the light direction\n\n                vec3 inScattering = getInScattering (samplePt, toLightPt); // Single scattering\n                float sphMarchExtinction = exp(-MEDIUM_DENSITY * EXTINCTION_COEF * travelAmount);\n                vec3 curScatteringIntegral = (inScattering - inScattering * sphMarchExtinction) / max (MEDIUM_DENSITY * EXTINCTION_COEF, 0.000001);\n                colorAccum += transmittance * curScatteringIntegral;\n                vec3 samplePtNext = samplePt;\n                sphereMarchSSSObjStep (samplePtNext, singleScatDir);\n                \n                vec3 samplePtNextMS = samplePt;\n                wosSSSObjStep (samplePtNextMS);\n                vec3 msTravel = samplePtNextMS - samplePt;\n                float msTravelAmount = length (msTravel);\n                msTravel /= msTravelAmount;\n                inScattering = getInScattering (samplePtNextMS, normalize (destOnLum - samplePtNextMS)); // Multiple scattering\n                float secondAbsorption = exp (-MEDIUM_DENSITY * EXTINCTION_COEF * msTravelAmount);\n                inScattering *= MEDIUM_DENSITY * SCATTERING_COEF * secondAbsorption * phaseFunc (msTravel, singleScatDir) * msTravelAmount;\n                curScatteringIntegral = (inScattering - inScattering * sphMarchExtinction) / max (MEDIUM_DENSITY * EXTINCTION_COEF, 0.000001);\n                colorAccum += transmittance * curScatteringIntegral;\n                \n                travelAmount = length (samplePtNext - samplePt);\n                samplePt = samplePtNext;\n                transmittance *= sphMarchExtinction;\n                if ( transmittance < 0.01 ) break;\n                countSteps++;\n                if ( countSteps > 10 ) break;\n            } while (sssObjDist < -0.01);\n        }\n        else\n        {\n            vec3 hit2Norm, hit2Point;\n            if ( wosLum (hitPoint, hit2Point, hit2Norm) )\n            {\n                vec3 lightSegment = hit2Point - hitPoint;\n                vec3 Lo = normalize (lightSegment);\n                float NddotLo = abs (dot (hitNorm, Lo));\n                float LidotNl = abs (dot (hit2Norm, -Lo));\n                float distSq = dot (lightSegment, lightSegment);\n                float GeomTerm = (NddotLo * LidotNl) / distSq;\n                colorAccum = GeomTerm * 0.75 * EMISSIVITY; // We don't have |A| so just make stuff up...\n            }\n            else\n                colorAccum = vec3 (0.0);\n        }\n    }\n    else\n\t\tcolorAccum = vec3 (0.0);\n\n    vec4 bufA = texture(iChannel0, uvRaw);\n    if ( mouseInfo.z > 0.0 )\n        bufA = vec4 (colorAccum, 1.0);\n    else\n        bufA += vec4 (colorAccum, 1.0);\n    fragColor = bufA;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}