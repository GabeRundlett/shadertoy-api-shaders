{
    "Shader": {
        "info": {
            "date": "1549312093",
            "description": "This is a quick golfing of the famous shader by lsdlive:\n[url]https://www.shadertoy.com/view/MscBRs[/url]\nPlease help me make this smaller ... Thank you.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsSGzV",
            "likes": 15,
            "name": "Golfing Voxel Tunnel - 538 c",
            "published": 3,
            "tags": [
                "golf"
            ],
            "usePreview": 0,
            "username": "GregRostami",
            "viewed": 989
        },
        "renderpass": [
            {
                "code": "// 538 chars - Fabrice and coyote join FORCES to slay the BEAST by using SUPER clever math!\n// This version has contributions from adx and Greg.\n\n#define V vec3//\n#define S sin//\n#define P(v) v.xy += vec2(2, S(d = v.z*.2)) * S(d + 1.5)           //\nvoid mainImage(out vec4 o, vec2 U) {\n    V R=iResolution, O=R-R, X, Y=O, g=O, p=(U.xyy-R*.5)/R.y;\n    float d, T = Y.z = iTime*6.;\n    O.z = T-5.;\n    P(O); P(Y);\n    Y = p.xyx * V(-5, 5, Y-=O) - p.y * Y.y*Y/5. + Y;\n    Y.xy *= mat2( S( V(33,22,0).xyzx - .1*O.x ) );\n    R = sign(Y);\n    for ( p = round(O) ;\n          o.w++ < 99. && d > 0.;\n          p += X = R * step( X= (p-O +.5*R)/Y, min(X.yzx, X.zxy) )\n        )\n        X = p,\n        d = 5. - length( P(X)*-1. ),\n        X += S(X.z + T) * V( S(T), 1, 0 ),\n        X.z -= 6. + T,\n        d = min( d, dot(X,X) ),\n        g += .006 / (.01 + --d * d );\n    o.rgb = (  V( .2* S(T) + S(p.z*.5 - T), 0 , .5 )\n               - V(0,.3,1.5) * length(X/V(3,6,4)) + g\n            ) / exp( dot( p-=O, p ) /1e3 ) + .2; } /*\n\n\n// 599 chars - Fabrice added 6 chars (to initialize vars) but then removed 6 chars! #respect\n// 594 chars - Fabrice removed the mix from the final color calculation.\n// 591 chars - Code golfing legend, coyote, slays another 3 chars ...\n// 583 chars - Greg experiments with removing normalize()\n\n#define V vec3//\n#define S sin//\n#define P(v) v.xy += vec2(2, S(d = v.z*.2)) * S(d + 1.5)      //\n#define mainImage(o,U)                                        \\\n    V R=iResolution, O=R-R,X,Y=O,p, u=(U.xyy-R*.5)/R.y;       \\\n    float g=0., d, T = Y.z = iTime*6.;                        \\\n    O.z = T-5.;                                               \\\n    P(O); P(Y);                                               \\\n    Y = u.y/5. * cross( R = Y-O, X = V(5, 0, -R) )            \\\n       -u.x * X + R;                                          \\\n    Y.xy *= mat2( S( V(33,22,0).xyzx - .3* S(O.x / 3.) ) );   \\\n    p = round(O);                                             \\\n    R = sign(Y);                                              \\\n    for ( u = p-O + .5*R ; o.w++ < 99. && d > 0.; u += X )    \\\n        X = p,                                                \\\n        d = 4. - length( P(X)*-1. ),                          \\\n        X += S(X.z + T) * V( S(T), 1, 0 ),                    \\\n        X.z -= 6. + T,                                        \\\n        d = min( d, dot( X, sign(X)/1.7 ) - 1.),              \\\n        g += .006 / (.01 + d * d ),                           \\\n        p += X = R * step( X= u/Y, min(X.yzx, X.zxy) );       \\\n    o.rgb = V( .2, .1, .2 ) +                                 \\\n            (  V( .2* S(T) + S(p.z*.5 - T), .1 , .5 )         \\\n               - V(0,.3,1.5) * length(X/V(3,6,4)) + g         \\\n            )/  exp( dot( p-=O, p ) /1e3 )\n\n        \n\n// 601 chars\n\n#define V vec3//\n#define S sin//\n#define P(v) v.xy += vec2(2, S(d = v.z*n)) * S(d + 1.5)//\n#define mainImage(o,U)                                                \\\n    float g=0., d, T, n=.2;                                           \\\n    V O,X,Y,p, R=iResolution, u=(U.xyy-R*.5)/R.y;\t                  \\\n    Y.z = T = iTime * 6.;                                             \\\n    O.z = T-5.;                                                       \\\n    P(O);                                                             \\\n    P(Y);                                                             \\\n    Y = u.y*-cross(R=normalize(Y - O),                                \\\n                   X=V(-R.z, 0, R.x))+R + u.x*X;                      \\\n    Y.xy *= mat2( S(S(-O.x / 3.14)*.3 + vec4(33,0,0,55)) );           \\\n    p = round(O);                               \t                  \\\n    R = sign(Y);                                                      \\\n    for ( u = ( p - O + .5*R ) / Y ; o.w++ < 99. && d > 0.; u += X/Y )\\\n        X = p,\t\t\t\t\t\t\t\t\t\t                  \\\n        d = 4.-length(P(X) * -1.),                                    \\\n        X += S(X.z + T) * V(S(T),1,0),\t\t\t                      \\\n        X.z -= 6. + T,\t\t\t\t\t\t\t\t                  \\\n        d = min(d, dot(X, sign(X)/1.7) - 1.),                         \\\n        g += .006 / (.01 + d * d),\t\t\t\t\t                  \\\n        p += X = R * step(u, min(u.yzx, u.zxy));                      \\\n    o.rgb = mix( V(n,.1,n), V(n+S(T)*n + S(p.z*.5 - T),n,.7) - V(0,.3,1.5) * length(X/V(3,6,4)) + g  \\\n                , exp(-dot(p-=O, p)/1e3) )\n\n\n\n// 615 chars - This is almost HALF the size of the original shader!!\n\n#define V vec3//\n#define P(v) v.xy += vec2(2, sin(d = v.z*n)) * sin(d + 1.5)//\n#define mainImage(o,U)                                                \\\n    float g=0., d, T, n=.2;                                           \\\n    V O,A,X,Y,p, R=iResolution, u=(U.xyy-R*.5)/R.y;\t                  \\\n    A.z = T = iTime * 6.;                                             \\\n    O.z = T-5.;                                                       \\\n    P(O);                                                             \\\n    P(A);                                                             \\\n    Y = u.y*-cross(R=normalize(A - O),                                \\\n                   X=V(-R.z, 0, R.x))+R + u.x*X;                      \\\n    Y.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );       \\\n    p = round(O);                               \t                  \\\n    R = sign(Y);                                                      \\\n    for ( u = ( p - O + .5*R ) / Y ; o.w++ < 99. && d > 0.; u += X/Y )\\\n        X = p,\t\t\t\t\t\t\t\t\t\t                  \\\n        d = 4.-length(P(X) * -1.),                                    \\\n        X += cos(X.z + T) * V(sin(T),1,0),\t\t\t                  \\\n        X.z -= 6. + T,\t\t\t\t\t\t\t\t                  \\\n        d = min(d, dot(X, sign(X)/1.7) - 1.),                         \\\n        g += .006 / (.01 + d * d),\t\t\t\t\t                  \\\n        p += X = R * step(u, min(u.yzx, u.zxy));                      \\\n    A = V(n,n,.7) - V(0,.3,1.5) * length(X/V(3,6,4)) + g;             \\\n    A.r += sin(T)*n + sin(p.z*.5 - T);                                \\\n    o.rgb = mix( V(n,.1,n), A, exp(-dot(p-=O, p)/1e3) )\n\n\n\n// 625 chars - Fabrice and adx shaved many more chars\n\n#define V vec3\n#define P(v) v.xy += vec2(2, sin(d = v.z*.2)) * sin(d + 1.5)\nfloat g=0., d, T;\n\n#define mainImage(o,U)                                               \\\n\tV O,A,X,Y,p, R=iResolution, u=(U.xyy-R*.5)/R.y;\t                 \\\n\tA.z = T = iTime * 6.;                                            \\\n\tO.z = T-5.;                                                      \\\n\tP(O);                                                            \\\n\tP(A);                                                            \\\n\tY = u.y*-cross(R=normalize(A - O), X=V(-R.z, 0, R.x))+R + u.x*X; \\\n\tY.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );      \\\n\tp = round(O);                               \t                 \\\n\tR = sign(Y);                                                     \\\n\tu = R/Y * (R * (p - O) + .5);                                    \\\n\tfor (;o.w++ < 99. && d > 0.;)\t\t\t\t\t                 \\\n\t\tX = p,\t\t\t\t\t\t\t\t\t\t                 \\\n\t\td = 4.-length(P(X) * -1.),\t\t\t\t\t                 \\\n\t\tX += cos(X.z + T) * V(sin(T),1,0),\t\t\t                 \\\n\t\tX.z -= 6. + T,\t\t\t\t\t\t\t\t                 \\\n\t\td = min(d, dot(X, sign(X)/1.73) - 1.),\t\t                 \\\n\t\tg += .006 / (.01 + d * d),\t\t\t\t\t                 \\\n\t\tp += X = R * step(u, min(u.yzx, u.zxy)),                     \\\n\t\tu += X/Y;                         \t\t                     \\\n\tA = (V(2, 2, 7) - V(0, 3, 15) * length(X / V(3, 6, 4)))*.1 + g;  \\\n\tA.r += sin(T)*.2 + sin(p.z*.5 - T);             \\\n\to.rgb = mix(V(.2, .1, .2), A, exp(-dot(p-=O, p)/1e3))\n\n\n\n// 669 chars - adx and BigWIngs are on a ROLL ... \n\n#define V vec3\n#define P(v) v.xy += sin(v.z*.2 + 1.5) * vec2(2,sin(v.z*.2))\nfloat g = 0., B, d, T;\n\nfloat D(V p) {\n\tP(p) * -1.;\n\td = 4.-length(p.xy);\n\tp.xy += cos(p.z + T) * vec2(sin(T),1);\n\tp.z -= 6. + B;\n\td = min(d, dot(p, sign(p)/1.73) - 1.);\n\tg += .006 / (.01 + d * d);\n\treturn d;\n}\n\n#define mainImage(o,U)                              \\\n\tV O,A,X,Y,p, R=iResolution, u=(U.xyy-R*.5)/R.y; \\\n\tA.z = B = T = iTime*6.;                         \\\n\tO.z = B-5.;                                     \\\n\tP(O);                                           \\\n\tP(A);                                           \\\n\tR = normalize(A - O);                           \\\n\tX = V(-R.z, 0, R.x);                            \\\n\tY = R + u.x*X + u.y*cross(X, R);                \\\n\tY.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );  \\\n\tp = ceil(O) - .5;                               \\\n\tR = sign(Y);                                    \\\n\tu = R/Y * (R * (p - O) + .5);                   \\\n\twhile (o.w++ < 99. && D(p) > 0.)                \\\n        p += X = R * step(u, min(u.yzx, u.zxy)),    \\\n\t\tu += X/Y;                         \t\t    \\\n\tA = (V(2, 2, 7) - V(0, 1, 5) * length(X * V(1, .5, .8)))*.1 + g;  \\\n\tA.r += sin(T)*.2 + sin(p.z*.5 - B);             \\\n\to.rgb = mix(V(.2, .1, .2), A, exp(-dot(p-=O, p)/1e3))\n\n\n        \n// 700 chars - BigWIngs and adx squashed a LOT of chars\n\n#define V vec3\n#define P(v) v.xy += sin(v.z*.2 + 1.5) * vec2(2,sin(v.z*.2))\nfloat g = 0., B, d, T;\n\nfloat D(V p) {\n\tP(p) * -1.;\n\td = 4.-length(p.xy);\n\tp.xy += cos(p.z + T) * vec2(sin(T),1);\n\tp.z -= 6. + B;\n\td = min(d, dot(p, sign(p)/1.73) - 1.);\n\tg += .006 / (.01 + d * d);\n\treturn d;\n}\n\n#define mainImage(o,U)                          \\\n\tV O,A,F,X,Y,p,M,Z,S,c;                      \\\n\tvec2 R = iResolution.xy, u = (U-R*.5)/R.y;  \\\n\tT = iTime;                                  \\\n\tA.z = B = T*6.;                             \\\n\tO.z = B-5.;                                 \\\n\tP(O);                                       \\\n\tP(A);                                       \\\n\tF = normalize(A - O);                       \\\n\tX = V(-F.z, 0, F.x);                        \\\n\tY = F + u.x*X + u.y*cross(X, F);            \\\n\tY.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );  \\\n\tp = floor(O) + .5;                          \\\n\tZ = Y;                                      \\\n\tY = sign(Y);                                \\\n\tS = Y/Z * (Y * (p - O) + .5);               \\\n\tfor (int i; ++i < 99 && D(p) > 0.;)         \\\n\t\tM = step(S, min(S.yzx, S.zxy)),          \\\n\t\tS += Y/Z * M,                           \\\n\t\tp += Y * M;                             \\\n\tc = (V(2, 2, 7) - V(0, 1, 5) * length(M * V(1, .5, .75)))*.1 + g;  \\\n\tc.r += sin(T)*.2 + sin(p.z*.5 - B);         \\\n\to.rgb = mix(V(.2, .1, .2), c, exp(-dot(p-=O, p)/1e3))\n\n        \n\n// 773 chars - Greg Rostami's original golfed version\n\n#define T iTime\n#define P(t) sin(t*.2 + 1.5) * vec2(2,sin(t*.2))\nfloat g = 0., B, d;\n\nfloat D(vec3 p) {\n\tp.xy -= P(p.z);\n\td = 4.-length(p.xy);\n\tp.xy += cos(p.z + T) * vec2(sin(T),1);\n\tp.z -= 6. + B;\n\td = min(d, dot(p, normalize(sign(p))) - 1.);\n\tg += .015 / (.01 + d * d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 o,vec2 U){\n    vec3 O,A,F,X,Y,p,M,Z,S,c;\n\tvec2 R = iResolution.xy, u = .5*(U+U-R)/R.y;\n    \n         A.z = B = T*6.;\n\t     O.z = B-5.;\n\t     \n\t     O.xy += P(O.z);\n\t     A.xy += P(A.z);\n    \n\t     X = cross(F = normalize(A - O), vec3(0, 1, 0));\n\t     Y = F + u.x*X + u.y*cross(X, F);\n\t     Y.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );\n\t     p = floor(O) + .5;\n\t     Z = 1. / abs(Y);\n\t     Y = sign(Y);\n\t     S = Z * (Y * (p - O) + .5);\n\t\n\tfor (int i; ++i < 99;) {\n\t\tif (D(p) < 0.) break;\n\t\tM = step(S, S.yzx) * step(S, S.zxy);\n\t\tS += Z * M;\n\t\tp += Y * M;\n\t}\n\tc = mix(vec3(.2, .2, .7), vec3(.2, .1, .2), length(M * vec3(1, .5, .75))) + g * .4;\n\tc.r += sin(T)*.2 + sin(p.z*.5 - B);\n\to.rgb = mix(c, vec3(.2, .1, .2), 1. - exp(-dot(p-O, p-O)/1e3));\n}\n\n\n\n// 1169 chars - Original shader:\n\n// @lsdlive\n\n// This was my shader for the shader showdown at Outline demoparty 2018 in Nederland.\n// Shader showdown is a live-coding competition where two participants are\n// facing each other during 25 minutes.\n// (Round 1)\n\n// I don't have access to the code I typed at the event, so it might be\n// slightly different.\n\n// Original algorithm on shadertoy from fb39ca4: https://www.shadertoy.com/view/4dX3zl\n// I used the implementation from shane: https://www.shadertoy.com/view/MdVSDh\n\n// Thanks to shadertoy community & shader showdown paris.\n\n// This is under CC-BY-NC-SA (shadertoy default licence)\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(2.*a, a*b);\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n\tp.xy -= path(p.z);\n\n\tfloat d = -length(p.xy) + 4.;// tunnel (inverted cylinder)\n\n\tp.xy += vec2(cos(p.z + iTime)*sin(iTime), cos(p.z + iTime));\n\tp.z -= 6. + iTime * 6.;\n\td = min(d, dot(p, normalize(sign(p))) - 1.); // octahedron (LJ's formula)\n\t// I added this in the last 1-2 minutes, but I'm not sure if I like it actually!\n\n\t// Trick inspired by balkhan's shadertoys.\n\t// Usually, in raymarch shaders it gives a glow effect,\n\t// here, it gives a colors patchwork & transparent voxels effects.\n\tg += .015 / (.01 + d * d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tfloat dt = iTime * 6.;\n\tvec3 ro = vec3(0, 0, -5. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 right = cross(fwd, vec3(0, 1, 0));\n\tvec3 up = cross(right, fwd);\n\tvec3 rd = normalize(fwd + uv.x*right + uv.y*up);\n\n\trd.xy *= r2d(sin(-ro.x / 3.14)*.3);\n\n\t// Raycast in 3d to get voxels.\n\t// Algorithm fully explained here in 2D (just look at dde algo):\n\t// http://lodev.org/cgtutor/raycasting.html\n\t// Basically, tracing a ray in a 3d grid space, and looking for \n\t// each voxel (think pixel with a third dimension) traversed by the ray.\n\tvec3 p = floor(ro) + .5;\n\tvec3 mask;\n\tvec3 drd = 1. / abs(rd);\n\trd = sign(rd);\n\tvec3 side = drd * (rd * (p - ro) + .5);\n\n\tfloat t = 0., ri = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\n\t\tif (de(p) < 0.) break;// distance field\n\t\t\t\t\t\t\t  // we test if we are inside the surface\n\n\t\tmask = step(side, side.yzx) * step(side, side.zxy);\n\t\t// minimum value between x,y,z, output 0 or 1\n\n\t\tside += drd * mask;\n\t\tp += rd * mask;\n\t}\n\tt = length(p - ro);\n\n\tvec3 c = vec3(1) * length(mask * vec3(1., .5, .75));\n\tc = mix(vec3(.2, .2, .7), vec3(.2, .1, .2), c);\n\tc += g * .4;\n\tc.r += sin(iTime)*.2 + sin(p.z*.5 - iTime * 6.);// red rings\n\tc = mix(c, vec3(.2, .1, .2), 1. - exp(-.001*t*t));// fog\n\n\tfragColor = vec4(c, 1.0);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}