{
    "Shader": {
        "info": {
            "date": "1595525137",
            "description": "Another attempt at analytically rasterizing a triangle, much simpler than previous attempt. Calculate exactly how much area of a (rectangular) pixel is covered by a triangle, and therefore get perfect antialiasing. I think UnrealEngine5 is doing this",
            "flags": 0,
            "hasliked": 0,
            "id": "wlByWc",
            "likes": 0,
            "name": "Analytic Raster Triangle, Pt II",
            "published": 3,
            "tags": [
                "antialiasing"
            ],
            "usePreview": 0,
            "username": "Schrompf",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "const float GridSize = 32.0f;\n\nfloat saturate( float t) { return max( 0.0f, min( 1.0f, t)); }\nvec2 saturate( vec2 v) { return max( vec2( 0), min( vec2( 1), v)); }\nvec3 saturate( vec3 v) { return max( vec3( 0), min( vec3( 1), v)); }\nvec4 saturate( vec4 v) { return max( vec4( 0), min( vec4( 1), v)); }\n\nfloat triangleIntegral( vec2 pa, vec2 pb, vec2 pc, vec2 rectMin, vec2 rectMax, vec2 fragCoord, out vec4 debugColour)\n{\n    vec4 rectCenterSize = vec4( 0.5f * (rectMin + rectMax), rectMax - rectMin);\n    \n    // there has been a sorting here, but it was unnecessary\n    vec2 p1 = pa, p2 = pb, p3 = pc;\n    \n    // from left to right: enter of AB and AC, either leave of AB, AC or end of AB, enter of BC, leave of BC and AC\n    vec2 d12 = p2 - p1, d23 = p3 - p2, d31 = p1 - p3; \n    \n    // where d12 enters and leaves the area\n    vec4 p12Step = mix( (rectCenterSize - vec4( p1, 0, 0)) / d12.xyxy, vec4( 0, 0, 1000, 1000), equal( d12.xyxy, vec4( 0)));\n    vec4 p12EnterExit = saturate( p12Step.xyxy + vec4( -0.5f, -0.5f, 0.5f, 0.5f) * abs( p12Step.zwzw));\n    float p12LatestEnter = max( p12EnterExit.x, p12EnterExit.y);\n    float p12EarliestExit = min( p12EnterExit.z, p12EnterExit.w);\n\n    // and where d23 enters and leaves\n    vec4 p23Step = mix( (rectCenterSize - vec4( p2, 0, 0)) / d23.xyxy, vec4( 0, 0, 1000, 1000), equal( d23.xyxy, vec4( 0)));\n    vec4 p23EnterExit = saturate( p23Step.xyxy + vec4( -0.5f, -0.5f, 0.5f, 0.5f) * abs( p23Step.zwzw));\n    float p23LatestEnter = max( p23EnterExit.x, p23EnterExit.y);\n    float p23EarliestExit = min( p23EnterExit.z, p23EnterExit.w);\n    \n    // and finally where d31 enters and leaves\n    vec4 p31Step = mix( (rectCenterSize - vec4( p3, 0, 0)) / d31.xyxy, vec4( 0, 0, 1000, 1000), equal( d31.xyxy, vec4( 0)));\n    vec4 p31EnterExit = saturate( p31Step.xyxy + vec4( -0.5f, -0.5f, 0.5f, 0.5f) * abs( p31Step.zwzw));\n    float p31LatestEnter = max( p31EnterExit.x, p31EnterExit.y);\n    float p31EarliestExit = min( p31EnterExit.z, p31EnterExit.w);\n\n    // Calculate world positions of those crossing points, separated for X and Y\n    vec4 enterExitF123 = vec4( p12LatestEnter, p12EarliestExit, p23LatestEnter, p23EarliestExit);\n    vec2 enterExitF31 = vec2( p31LatestEnter, p31EarliestExit); \n    vec4 posX123 = vec4( p1.xx, p2.xx) + enterExitF123 * vec4( d12.xx, d23.xx);\n    vec4 posY123 = vec4( p1.yy, p2.yy) + enterExitF123 * vec4( d12.yy, d23.yy);\n    vec4 posXY31 = p3.xyxy + enterExitF31.xxyy * d31.xyxy;\n    \n    // limit everything to the pixel area\n    posX123 = max( rectMin.xxxx, min( rectMax.xxxx, posX123));\n    posY123 = max( rectMin.yyyy, min( rectMax.yyyy, posY123));\n    posXY31 = max( rectMin.xyxy, min( rectMax.xyxy, posXY31));\n\n    float t = fract( iTime);\n    debugColour = \n          vec4( 1, 0, 0, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( vec2( posX123.x, posY123.x), vec2( posX123.y, posY123.y), t)))\n        + vec4( 1, 1, 0, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( vec2( posX123.y, posY123.y), vec2( posX123.z, posY123.z), t)))\n        + vec4( 0, 1, 0, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( vec2( posX123.z, posY123.z), vec2( posX123.w, posY123.w), t)))\n        + vec4( 0, 1, 1, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( vec2( posX123.w, posY123.w), posXY31.xy, t)))\n        + vec4( 0, 0, 1, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( posXY31.xy, posXY31.zw, t)))\n        + vec4( 1, 0, 1, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( posXY31.zw, vec2( posX123.x, posY123.x), t)));\n    \n    if( rectMin.x != 416.0f || rectMin.y != 192.0f ) \n        debugColour = vec4( 0);\n    \n    posY123 -= rectMin.yyyy; \n    posXY31.yw -= rectMin.yy;\n    \n\t// determine difference of every value to the following value at the triangle's edges\n    vec4 stepX123 = vec4( posX123.yzw, posXY31.x) - posX123.xyzw;\n    vec4 stepY123 = vec4( posY123.yzw, posXY31.y) - posY123.xyzw;\n    vec4 stepXY31 = vec4( posXY31.zw, posX123.x, posY123.x) - posXY31.xyzw;        \n    \n    // calculate area below these edges: quad + diagonal part. Quad part is signed with xstep, diagonal is signed with both X and Y\n    // The segments from ExitCurrent to EntryNext are not allowed to go diagonal. They either need to be ramped up to full quad\n    // or reduced to zero depending on direction of that segment\n    vec3 cornerClipSegCorrection = mix( vec3( 1.0f), vec3( 0.0f), lessThan( vec3( stepX123.yw, stepXY31.z) * vec3( stepY123.yw, stepXY31.w), vec3( 0.0f)));\n    vec4 segArea123 = stepX123 * posY123 + vec4( 0.5f, cornerClipSegCorrection.x, 0.5f, cornerClipSegCorrection.y) * stepX123 * stepY123;\n    vec2 segArea31 = stepXY31.xz * posXY31.yw + vec2( 0.5f, cornerClipSegCorrection.z) * stepXY31.xz * stepXY31.yw;\n    \n\tfloat summedArea = dot( segArea123, vec4( 1, 1, 1, 1)) + dot( segArea31, vec2( 1, 1));\n    float coverage = summedArea / (rectCenterSize.z * rectCenterSize.w);\n    \n    return saturate( coverage);\n}\n\nfloat drawTriangle( in vec2 fragCoord, in vec2 pa, in vec2 pb, in vec2 pc)\n{\n    vec2 papb = pb - pa, papc = pc - pa;\n    vec2 pafr = fragCoord - pa;\n    \n    float den = papb.x * papc.y - papc.x * papb.y;\n    float t1 = (pafr.x * papc.y - papc.x * pafr.y) / den;\n    float t2 = (papb.x * pafr.y - pafr.x * papb.y) / den;    \n    return t1 >= 0.0f && t2 >= 0.0f && (t1 + t2) < 1.0f ? 1.0f : 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // construct an edge from some point at the left and some angle\n    vec2 pa = vec2( iMouse.x, iMouse.y);\n    float angleToPb = 8.0f * (iMouse.x / iResolution.x - 0.5f);\n    vec2 dirToPb = vec2( cos( angleToPb), -sin( angleToPb));\n    vec2 pb = pa + 0.4f * iResolution.x * dirToPb;\n\n    float angleToPc = angleToPb + 0.4f;\n    vec2 dirToPc = vec2( cos( angleToPc), -sin( angleToPc));\n    vec2 pc = pa + 0.5f * iResolution.x * dirToPc;\n    \n    // a grid of rectangles\n    ivec2 gridpos = ivec2(fragCoord.xy / GridSize);\n    vec2 rectMin = vec2( gridpos) * GridSize;\n    vec2 rectMax = rectMin + vec2( GridSize, GridSize);   \n    \n    vec4 debugColour = vec4( 0.0f);\n    float tri = triangleIntegral( pa, pb, pc, rectMin, rectMax, fragCoord, debugColour);\n    \n    float groundTruth = drawTriangle( fragCoord, pa, pb, pc);\n    vec3 resColour = \n          saturate( tri * vec3( 1, 1, 1))\n//        + saturate( (tri > 0.0f ? 0.2f : 0.0f) * vec3( 1, 0, 0))\n        ;\n    resColour = mix( resColour, vec3( 0, 0, 1), 0.3f * groundTruth);\n    \n    resColour = resColour + debugColour.xyz;\n    fragColor = vec4( resColour, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}