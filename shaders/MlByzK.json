{
    "Shader": {
        "info": {
            "date": "1509184162",
            "description": "Here are very simple if not lame 2D/3D blobs, without any kind of perspective projection.  \nGreetz to all members of PROXiUM: guys, coding of shaders is a real fun, just like in good ol' dayz =)",
            "flags": 0,
            "hasliked": 0,
            "id": "MlByzK",
            "likes": 15,
            "name": "Glownig Blobz",
            "published": 3,
            "tags": [
                "3d",
                "blobs",
                "scalarfield",
                "isosurface"
            ],
            "usePreview": 0,
            "username": "drLongman",
            "viewed": 854
        },
        "renderpass": [
            {
                "code": "/**\n * Here are very simple if not lame 2D/3D blobs, without any kind of perspective projection.  \n * Greetz to all members of PROXiUM: guys, coding of shaders is a real fun, just like in good ol' dayz =)\n *\n *  -={   Asman   }=-\n *  -={ mr.Dsteuz }=-\n *  -={  Markoos  }=-\n *\n *  More greetz to Manwe/SandS, and all folks from Moscow scene...\n * \n */\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n// CONTROLS\n// Set to 1 for simple bumpmapping\n#define BUMP_NOISE 0\n// Set to 1 for stupid scanlines\n#define SCANLINES 0\n\n\n// CONSTANTS\n#define SPHERES 10\n#define BISECT_LIMIT 50\n#define BISECT_GOAL 0.001\n#define LIGHTS 2\n#define SCENE_ROTATION\t-0.2\n\n\nuniform sampler2D backbuffer;\nuniform sampler2D noise;\n\nfloat scale;\n\nstruct FieldPoint {\n\tvec3 pos;\n    float field;\n};\n\nFieldPoint uvp;\n\nvec3[SPHERES] s = vec3[SPHERES](\n\tvec3(0.1, -0.02, 0.024),\n\tvec3(0.04, 0.06, 0.007),\n\tvec3(-0.02, -0.02, 0.018),\n\tvec3(-0.017, 0.045, 0.012),\n\tvec3(0.1, 0.31, 0.017),\n\tvec3(0.032, -0.012, 0.019),\n\tvec3(0.08, -0.042, 0.021),\n\tvec3(-0.067, -0.01, 0.0141),\n\tvec3(0.029, -0.032, 0.0119),\n\tvec3(-0.028, 0.054, 0.0229));\n\nvec2[SPHERES] ms;\nfloat[SPHERES] frc;\n\nvec4[SPHERES] clr = vec4[SPHERES] (\n\tvec4(0.98, 0.21, 0.17, 1.0),\n\tvec4(0.09, 0.2, 0.75, 1.0),\n\tvec4(0.45, 0.32, 0.12, 1.0),\n\tvec4(0.02, 0.78, 0.92, 1.0),\n\tvec4(0.98, 0.21, 0.17, 1.0),\n\tvec4(0.09, 0.2, 0.75, 1.0),\n\tvec4(0.45, 0.32, 0.12, 1.0),\n\tvec4(0.98, 0.21, 0.17, 1.0),\n\tvec4(0.09, 0.2, 0.75, 1.0),\n\tvec4(0.02, 0.78, 0.92, 1.0));\n\n\nvec3[SPHERES] offset = vec3[SPHERES] (\n\tvec3(0.25, -0.32, 1.7),\n\tvec3(-0.13, 0.02, 2.4),\n\tvec3(-0.07, 0.3, 0.2),\n\tvec3(0.26, -0.168, 1.92),\n\tvec3(0.12, 0.22, 0.7),\n\tvec3(0.25, -0.63, 0.4),\n\tvec3(0.185, 0.19, 3.2),\n\tvec3(-0.092, -0.075, 0.9),\n\tvec3(0.03, 0.17, 1.5),\n\tvec3(0.014, -0.08, 0.82));\n\n\nstruct Light {\n\tvec3 p;\n    vec3 pr;\n\tvec3 c;\n\tfloat i;\n\tfloat fuzz;\n    float rotSpd;\n};\n\n\nLight[LIGHTS] l = Light[LIGHTS] (\n\t\tLight(\n\t\t\t\tvec3(-1.0, 1.0, 2.0),\n            \tvec3(0.0),\n\t\t\t\tvec3(1.0, 0.8, 0.6),\n\t\t\t\t0.65, 1500.0, 1.0),\n\t\tLight(\n\t\t\t\tvec3(1.0, -1.0, 1.0),\n            \tvec3(0.0),\n\t\t\t\tvec3(0.0, 0.0, 0.9),\n\t\t\t\t.93, 90.0, -0.32)\n\t);\n\n\n// RASTER DATA\n#define PROXiUM_LOGO_X_SIZE 64\n#define PROXiUM_LOGO_Y_SIZE 11\n\nstruct Sprite {\n    int w;\n    int h;\n    int x;\n    int y;\n};\n\nSprite PROXiUM_Logo = Sprite( \n    PROXiUM_LOGO_X_SIZE,\n    PROXiUM_LOGO_Y_SIZE,\n    0,0\n);\n\nint[] PROXiUM_LogoBitmap = int[](\n\t\t0x1ffffeed, 0xb77ffffc, 0x30000000, 0x00000006, \n\t\t0x6639c000, 0x00022923, 0x694a4000, 0x00036903, \n        0xc94a4000, 0x0002a931, 0xc94a4000, 0x00022921, \n        0x6939c000, 0x00022923, 0x69484000, 0x00022923, \n\t\t0x66484000, 0x00022673, 0x30000000, 0x00000006, \n\t\t0x1ffffeed, 0xb77ffffc);\n\n\n// PROCEDURES AND FUNCTIONS\n\n\nint getLogoPixel(Sprite s, vec2 t){\n\tint addr = int(floor(t.y)) * (s.w / 32) + (int(t.x) / 32);\n    int raster = PROXiUM_LogoBitmap[addr];\n    int b = (raster >> (int(t.x) % 32)) & 0x01;\n\treturn b;\n}\n\nint displayLogo(vec2 scr){\n    scr = floor(scr);\n    int b = 0;\n    if ((int(scr.x) >= PROXiUM_Logo.x) && \n        (int(scr.y) >= PROXiUM_Logo.y) &&\n        (int(scr.x) < PROXiUM_Logo.x + PROXiUM_Logo.w) && \n        (int(scr.y) < PROXiUM_Logo.y + PROXiUM_Logo.h)) {\n       \tb = getLogoPixel(\n            PROXiUM_Logo,\n            vec2(scr.x - float(PROXiUM_Logo.x), float(PROXiUM_Logo.h - 1) - (scr.y - float(PROXiUM_Logo.y))));\n    }\n    return b;\n}\n\nhighp float rand(vec2 co) {\n\thighp float a = 12.9898;\n\thighp float b = 78.233;\n\thighp float c = 43758.5453;\n\thighp float dt= dot(co.xy ,vec2(a,b));\n\thighp float sn= mod(dt,3.14);\n\treturn abs(fract(sin(sn) * c));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec2 movedS(int idx) {\n\tfloat t = iTime * 0.5;\n\treturn vec2(s[idx].x + sin(t) * offset[idx].x,\n\t\ts[idx].y + cos(t * offset[idx].z) * offset[idx].y);\n}\n\nvoid moveSpheres() {\n    mat4 rm = rotationMatrix(vec3(0.0, 0.0, 1.0), iTime * SCENE_ROTATION);\n    for (int i = 0; i < SPHERES; i++){\n        ms[i] = (vec4(movedS(i), 0.0, 1.0) * rm).xy;\n    }\n}\n\nvoid rotateLights() {\n    mat4 rm;\n    for (int i = 0; i < LIGHTS; i++) {\n\t    rm = rotationMatrix(vec3(0.0, 0.0, 1.0), iTime * l[i].rotSpd);\n\t\tl[i].pr = (vec4(l[i].p, 1.0) * rm).xyz;\n    }\n}\n\nfloat force(vec2 coord, int idx) {\n\treturn s[idx].z / distance(ms[idx], coord);\n}\n\nfloat force3D(vec3 coord, int idx) {\n\tfloat f = 0.0;\n\tf  = s[idx].z / distance(vec3(ms[idx], 0.0), coord);\n\treturn f;\n}\n\nvoid calcForce() {\n    for (int i = 0; i < SPHERES; i++) {\n        frc[i] = force(uvp.pos.xy, i);\n    }\n}\n\n\nfloat field(vec2 coord) {\n\tfloat f = 0.0;\n    for (int i = 0; i < SPHERES; i++) {\n    \tf += frc[i];\n    }\n  return f;\n}\n\nfloat field3D(vec3 coord){\n\tfloat f = 0.0;\n\tfor (int i = 0; i < SPHERES; i++) {\n\t\tf += force3D(coord, i);\n\t}\n\treturn f;\n}\n\nfloat height(vec2 coord){\n  float h = 0.0;\n  float hb = 0.0;\n  float ht = 1.0;\n  float pb = field3D(vec3(coord.xy, hb));\n  if (pb <= 1.0) return 0.0;\n  float pm;\n  float pt = field3D(vec3(coord.xy, ht));\n\n  for (int i = 0; i < BISECT_LIMIT; i++) {\n  \tfloat hm = hb + (ht - hb) * 0.5;\n  \tfloat pm = field3D(vec3(coord.xy, hm));\n    if (pm < 1.0) {\n    \tht = hm;\n    \tpt = pm;\n    } else {\n      hb = hm;\n      pb = pm;\n    }\n    if (pb - pt < BISECT_GOAL) break;\n  }\n\n  h = hb + (ht - hb) * ((pb - 1.0) / (pb - pt));\n  return h;\n}\n\nvec3 getN() {\n   vec3 n;\n    \n   n = vec3(\n   \tfield3D(vec3(uvp.pos.x - scale, uvp.pos.yz)) - field3D(vec3(uvp.pos.x + scale, uvp.pos.yz)),\n   \tfield3D(vec3(uvp.pos.x, uvp.pos.y - scale, uvp.pos.z)) - field3D(vec3(uvp.pos.x, uvp.pos.y + scale, uvp.pos.z)),\n   \tfield3D(vec3(uvp.pos.xy, uvp.pos.z - scale)) - field3D(vec3(uvp.pos.xy, uvp.pos.z + scale)));\n\n   #if BUMP_NOISE > 0\n   n += rand(uvp.pos.xy) * 0.001;\n   #endif \n    \n   return normalize(n);\n}\n\nvec4 colorize(){\n\tvec4 c = vec4(0);\n\tfor (int i = 0; i < SPHERES; i++) {\n\t\tc +=  clr[i] * pow(frc[i], 1.2);\n\t}\n  return c;\n}\n\nvec3 getLight() {\n\tfloat light = 0.0;\n\tvec3 color = vec3 (0.0);\n\tvec3 normal = getN();\n\n\tfor (int i = 0; i < LIGHTS; i++) {\n\t\tvec3 lv = normalize(l[i].pr - uvp.pos);\n\t\tvec3 specv = normalize(lv + normal);\n\t\tfloat k = pow(dot(lv, specv), l[i].fuzz);\n\t\tlight += dot(normal, lv) * l[i].i;\n\t\tcolor += (l[i].c * (k + light)) / float(LIGHTS);\n\t}\n\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int logoScale = 4;\n    if (iResolution.x <= 450.0) logoScale = 2;\n    \n    PROXiUM_Logo.x = (int(floor(iResolution.x)) / logoScale) - (PROXiUM_LOGO_X_SIZE + 5);\n\tPROXiUM_Logo.y = (8 + PROXiUM_LOGO_Y_SIZE) / logoScale;\n    \n    float aspect = iResolution.x / iResolution.y;\n    if (aspect >= 1.0) {\n    \tscale = 1.0 / iResolution.x;\n    } else {\n        scale = 1.0 / iResolution.y;\n    }\n    \n\tvec2 uv = (fragCoord.xy * scale) - (iResolution.xy * scale * 0.5);\n    \n    moveSpheres();\n    rotateLights();\n    uvp.pos = vec3(uv, 0.0);\n    calcForce();\n    uvp.field = field(uv);\n    \n    vec4 c;\n    \n\tif (uvp.field < 1.0)\n\t\tc = vec4(vec3(uvp.field), 1.0) * colorize();\n\telse {\n        uvp.pos.z = height(uv);\n\t\tfloat tr = uvp.pos.z * 4.0;\n\t    vec4 transDiffuseSpec = vec4(getLight(), 1.0) + vec4(tr * 0.4, tr * 0.87, tr * 0.99, 1.0);\n\t    c = (transDiffuseSpec) + (colorize() / 8.0);\n\t}\n    \n    if (displayLogo(fragCoord / float(logoScale)) > 0) {\n        //RASTER LOGO\n        c = vec4(1.0);\n    } else {\n        //POSTPROCESSING\n        c = c + rand(iTime * uv) * 0.02;\n#if SCANLINES > 0        \n        if (int(floor(fragCoord.y / 4.0)) % 2 == 0) {\n            c *= 0.7;\n        }\n#endif        \n    }\n    \n    fragColor = c;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}