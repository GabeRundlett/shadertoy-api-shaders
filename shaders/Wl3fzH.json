{
    "Shader": {
        "info": {
            "date": "1612194819",
            "description": "re-up When Squatterman returns to reset technology while you're hiding behind a rock finding religion I'll be getting a jump start on building the new world with my manual trig calculator. This also calculates pi and the golden ratio.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wl3fzH",
            "likes": 12,
            "name": "Trig Calculator",
            "published": 3,
            "tags": [
                "trig"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "//trig calc by eiffie\n//does all trig functions, chord lengths, some square roots\n//pi and the golden ratio but can you get Euler's constants?\n#define maxDepth 6.\nconst int MarchSteps=48,ShadowSteps=24; \nconst float FudgeFactor=1.0,shadows=0.6,contrast=0.6; \nconst float spec=1.0,specExp=64.0,HitDistance=0.001;//,maxDepth=10.0; \nconst vec3 dirLight=vec3(0.577,0.577,-0.577),colLight=vec3(1.0,0.9,0.7); \nbool bColoring=false; \nfloat px; \nmat2 rmx; \nvec3 pg,pg2,dc; \n#define tex iChannel0 \n#define size iResolution \n#define time iTime \nvec3 faketexture(vec2 v){return vec3(.8,.4+v.x*.1,.2+v.y*.2)+0.1*sin(v.x*120.+sin((v.y-v.x*2.1)*11.));}\nfloat RBox(in vec3 z, in vec4 r){return length(max(abs(z)-r.xyz,0.0))-r.w;} \nfloat RCyl(in vec3 z, in vec3 r){return length(max(vec2(abs(z.z)-r.y,length(z.xy)-r.x),0.0))-r.z;} \nfloat DE(in vec3 z){//thingy \n float dT=RBox(z-vec3(-1.0,-1.3,3.0),vec4(5.0,0.245,3.1,0.05)); \n float dW=RCyl(z-vec3(-px,0.0,0.25),vec3(0.95,0.245,0.05)); \n float dA=RCyl((z-vec3(-px,-0.45,-0.1)).xzy,vec3(0.0,0.45,0.025)); \n dA=min(dA,RCyl(z-vec3(-px,0.0,0.0),vec3(0.0,0.05,0.025))); \n float dA2=RBox(z-pg-vec3(0.0,-1.0,-0.15),vec4(0.05,1.0,-0.04,0.05)); \n float dA3=RBox(z-pg2-vec3(0.0,-1.0,-0.2),vec4(0.05,1.0,-0.04,0.05)); \n float dP=RCyl(z-pg,vec3(0.0,0.15,0.015)); \n dP=min(dP,RCyl(z-pg2,vec3(0.0,0.2,0.015))); \n float dS=min(dP,min(min(dT,dW),min(dA,min(dA2,dA3)))); \n if(bColoring){//since all the pixels get colored at once \n  bColoring=false;\n  if(dS==dW){//wheel \n   vec3 p=z-vec3(-px,0.0,0.0); \n   p.xy=p.xy*rmx; \n   dc=faketexture(p.xy+vec2(0.0,sin(p.y+p.z*(10.0-p.x*3.0))*0.02)).rgb; \n   dc=mix(vec3(0.0),dc,step(0.01,abs(length(p.xy+vec2(0.0,0.7))-0.03))); \n   float r=length(p.xy); \n   if(r>0.75 && r<0.975){ \n    float d=atan(p.y,p.x)*0.318; \n    dc=mix(vec3(0.0),dc,step(0.0075,mod(d,0.25))); \n    if(r>0.85){ \n     dc=mix(vec3(0.0),dc,step(0.005,mod(d,0.02777777))); \n    } \n   } \n  }else if(dS==dA)dc=vec3(1.0,0.0,0.0);//angle marker \n  else if(dS==dA2 || dS==dA3 || dS==dT){//sine and cosine rulers \n   dc=vec3(0.75);vec3 p2=pg;\n   if(dS==dT){dc=z.z<-0.13?vec3(0):vec3(.4,.7,.4);p2=vec3(0);z.xy=z.zx-vec2(0,1);}\n   if(dS==dA3){p2=pg2;dc=vec3(0.9,0.6,0.3);} \n   vec3 p=z-p2-vec3(0.0,-1.0,-0.15); \n   dc=mix(vec3(0.0),dc,step(0.01,abs(length(p.xy)-0.03))); \n   if(p.x<0.0){ \n    float d=p.y; \n    dc=mix(vec3(0.0),dc,step(0.01,mod(d,0.1))); \n    if(p.x<-0.05){ \n     dc=mix(vec3(0.0),dc,step(0.01,mod(d,0.025))); \n    } \n   } \n  }else dc=vec3(0.25);//pegs \n } \n return dS; \n} \n \nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) \n{ \n float t=mint*10.0,d=1.0,fStep=0.0; \n for( int i=0; i<ShadowSteps; i++ ){ \n  if(t>maxt || d<0.001)continue; \n  t+=d=DE(ro+rd*t); \n  fStep+=1.0; \n } \n if(d<0.01)return 0.0; \n return 1.0-(fStep-d*k/t)/float(ShadowSteps);//no rationale, just seems to work \n} \n \nvec3 scene( vec3 ro, vec3 rd ) \n{// find color of scene \n vec3 col=vec3(0.4+rd.y*0.5); \n float t=0.0,d=10.0; \n for(int i=0;i<MarchSteps;i++){ \n  if(t>maxDepth || d<HitDistance)continue; \n  t+=d=DE(ro+rd*t)*FudgeFactor; \n } \n if(d<0.01){ \n  bColoring=true; \n  t+=d=DE(ro+rd*t); \n  ro+=rd*(t-HitDistance); \n  const vec2 ve=vec2(0.0002,0.0); \n  vec3 nor=normalize(vec3(-DE(ro-ve.xyy)+DE(ro+ve.xyy), \n   -DE(ro-ve.yxy)+DE(ro+ve.yxy),-DE(ro-ve.yyx)+DE(ro+ve.yyx))); \n  float dif=max(0.0, dot(dirLight, nor)),shad=0.0; \n  if(shadows>0.0 && dif>0.0)shad=softshadow(ro,dirLight,HitDistance,maxDepth,12.0); \n  col=dc*(1.0-shadows+shad*shadows)*(1.0-contrast+dif*contrast) \n   +colLight*shad*spec*pow(max(0.0,dot(rd,reflect(dirLight,nor))),specExp); \n } \n return clamp(col,0.0,1.0); \n}   \n \nmat3 lookat(vec3 fw,vec3 up){ \n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw); \n} \n \nvoid mainImage(out vec4 O, in vec2 U) { \n px=5.0*iMouse.x/size.x; \n float f=0.0,cx=cos(px-f),sx=sin(px-f); \n rmx=mat2(cx,sx,-sx,cx); \n pg=vec3(rmx*vec2(-1.0,0.0),0.0)-vec3(px,0.0,0.0); \n pg2=vec3(rmx*vec2(0.0,-1.0),0.0)-vec3(px,0.0,0.0); \n vec3 clr=vec3(0.0); \n vec3 ro=vec3(-2.0,0.5,-3.0); \n mat3 rotCam=lookat(vec3(-px,-0.5,0.0)-ro,vec3(0.0,1.0,0.0)); \n vec3 rd=rotCam*normalize(vec3((2.0*U.xy-size.xy)/size.y,2.0)); \n O = vec4(scene(ro,rd),1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}