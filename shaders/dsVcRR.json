{
    "Shader": {
        "info": {
            "date": "1695737452",
            "description": "potate",
            "flags": 0,
            "hasliked": 0,
            "id": "dsVcRR",
            "likes": 23,
            "name": "Solid angle sphere/cone sampling",
            "published": 3,
            "tags": [
                "sphere",
                "cone",
                "sampling",
                "sampling",
                "uniform",
                "dw",
                "nee"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "// ------ I haven't actually tested if this is correct yet   ------ //\n// ------ Also quite possible you could remove the trig here ------ //\n\n// The sphere is rendered as points, just for illustrative purposes.\n// The actual directions are sampled uniformly in cone.\n\nvec3 sphere_pos = vec3(.0,0.4,0.2);\nfloat sphere_rad = 0.3;\n\nmat3 get_orth_basis(vec3 origin, vec3 target){\n    vec3 dir = normalize(target - origin);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = cross(dir, right);\n    return mat3(up, right, dir);\n}\n\nvec3 sample_cone(vec3 origin, vec3 sphere_pos, float sphere_rad){\n    mat3 orth_basis = get_orth_basis(origin, sphere_pos);\n    \n    // The apex angle is derived the same way as in https://www.shadertoy.com/view/DtSBD3\n    float l = length(sphere_pos.xyz - origin.xyz);\n    float apex_angle = asin(sphere_rad/2.0/l)*2.0;\n    \n    // --- w is the solid angle, derived from the apex angle\n    // w = integrate sin(theta) for theta from 0 to pi/2 for phi from 0 to 2pi)\n    // w = (âˆ’cos(apex_angle/2) + cos(0)) * 2pi\n\n    // pdf(w)       = 1./w\n    // --- convert to theta/phi\n    // pdf(the,phi) = sin(the) * pdf(w)\n    // pdf(phi)     = 1/2pi\n    \n    // pdf(theta) = integrate sin(the) * pdf(w) from 0 to 2pi\n    // pdf(theta) = sin(theta) * pdf(w) * 2pi\n    \n    // --- integrate & inverse to get inverse CDF\n    // c = pdf(w) * 2pi \n    // x_theta_integr_0_the = c - c * cos(the)\n    // x_theta = acos((c-the)/c)\n    // x_phi = phi * 2pi\n    \n    \n    vec2 x = hash_v2();\n    \n    float w = (-cos(apex_angle/2.0) + cos(0.0)) * 2.*pi;\n    \n    \n    float c = 2. * pi * 1./w;\n    float theta = acos((c - x.x)/c);\n    float phi = x.y * 2. * pi;\n    \n    return orth_basis * car_to_pol(theta,phi);\n}\nvec3 proj(vec3 p){\n\n    vec2 muv = (iMouse.xy - 0.5*R)/R.y;\n    \n    if(iMouse.z > 0.5){\n        p.xz *= rot(-muv.x*tau/2.0);\n        p.yz *= rot(-muv.y*2.6);\n\n    } else {\n        p.xz *= rot(iTime*0.4);\n    }\n    p.y -= 0.5;\n    p.z += 1.4;\n    \n    p.xy /= p.z;\n    \n    return p;\n}\n\n\nvoid draw_sphere(inout vec3 col, vec2 uv){\n    \n    float subdivs_the = 40.;\n    float subdivs_phi_max = 40.;\n    \n    for(float the = 0.; the <= subdivs_the; the++){\n        float the_idx = the/subdivs_the*pi;\n        \n        float sc = sqrt(abs(cos(the_idx - pi/2.0)));\n        float subdivs_phi = max(subdivs_phi_max*sc,1.0);\n        for(float phi = 0.; phi < subdivs_phi; phi++){\n            float phi_idx = phi/subdivs_phi * 2. * pi;\n            vec3 p = vec3(\n                cos(phi_idx) * sc,\n                (the/subdivs_the*2. - 1.0),\n                sin(phi_idx) * sc\n            ) * sphere_rad * 0.5;\n            p += sphere_pos;\n            p.z += 0.;\n            vec3 q = proj(p);\n            float sd = sd_dot(uv, q.xy) - 0.002;\n            //sd = min(sd, sdSegment(uv, proj(vec3(0)).xy, q.xy) - ln_sz);\n            //col = mix(col,c,0.2*smoothstep(fwidth(uv.y),0.,sd));\n            col = mix(col,vec3(1),smoothstep(fwidth(uv.y),0.,sd)*smoothstep(4.,0.,q.z));\n        }\n    }\n    \n}\n\nvoid draw_floor(inout vec3 col, vec2 uv){\n    float iters = 10.;\n    float range = 2.;\n    for(float axis = 0.; axis < 2.0; axis++){\n        for(float z = 0.; z <= iters; z++){\n            float zidx = z/iters;\n            \n            float pz = zidx * range - 0.5*range;\n            vec3 pa = vec3(-1,0,pz);\n            vec3 pb = vec3(1,0,pz);\n            if(axis > 0.5){\n                pa = vec3(pz,0,-1);\n                pb = vec3(pz,0,1);\n            }\n            \n            vec3 qa = proj(pa);\n            vec3 qb = proj(pb);\n            if(qa.z > 0.0 && qb.z > 0.){\n                float sd = sdSegment(uv, qa.xy, qb.xy) - 0.001;\n                col = mix(col,vec3(1.0),0.9*smoothstep(fwidth(uv.y),0.,sd));\n            }\n            \n        }\n    }\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n\n    vec2 uv = (U - 0.5*R)/R.y;\n\n    vec3 col = vec3(0.);\n    \n    sphere_pos += sin(\n        vec3(\n            sin(iTime*1.1),\n            sin(iTime*0.7),\n            sin(iTime*0.8)\n        )\n    )*0.2;\n    sphere_rad += sin(iTime + sin(iTime))*0.2;\n    \n    \n    draw_floor(col, uv);\n    \n    float pt_sz = 0.01;\n    float ln_sz = 0.001;\n    float opacity = 0.2;\n    \n    //seed += uint(iFrame);\n    for(float i = 0.; i < 525. + min(iTime,0.); i++){\n        vec3 c = oklch_to_srgb(vec3(0.7,0.3,hash_f()*tau));\n        vec3 p = vec3(0,0,0.);\n        vec3 s = sample_cone(p, sphere_pos, sphere_rad);\n        p += s;\n        \n        vec3 q = proj(p);\n        float sd = sdSegment(uv, proj(vec3(0,0.,0)).xy, q.xy) - ln_sz;\n        col = mix(col,c*2.,0.1*smoothstep(fwidth(uv.y),0.,sd));\n        \n        sd = sd_dot(uv, q.xy) - pt_sz;\n        col = mix(col,c*2.,0.3*smoothstep(fwidth(uv.y),0.,sd));\n    }\n    \n    draw_sphere(col, uv);\n    \n    col *= 1.;\n    col = 1.-col;\n    col = 1.-exp(-abs(col));\n    col = pow(col,vec3(0.4545));\n    //col = pow(col,vec3(2.4545));\n    //col = smoothstep(vec3(0),vec3(1.0),col);\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n\nuint seed = 154125u;\n\n\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\nuint wang(uint a) {\n\ta = (a ^ 61U) ^ (a >> 16U);\n\ta = a * 9U;\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2dU;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n#define hash_f_s(s)  ( float( hashi(uint(s)) ) / float( 0xffffffffU ) )\n\n#define hash_f()  ( float( seed = hashi(seed) ) / float( 0xffffffffU ) )\n#define hash_v2()  vec2(hash_f(),hash_f())\n#define hash_v3()  vec3(hash_f(),hash_f(),hash_f())\n#define hash_v4()  vec3(hash_f(),hash_f(),hash_f(),hash_f())\n\n\n\nfloat sd_dot(vec2 uv, vec2 p){\n    return length(uv - p);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 car_to_pol(float th, float phi){\n    return vec3(\n        sin(th)*sin(phi),\n        sin(th)*cos(phi),\n        cos(th)\n    );\n}\n\n\n\n\n\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\n\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\n\nvec3 srgb2oklab(vec3 c) {\n    \n    mat3 m1 = mat3(\n        0.4122214708,0.5363325363,0.0514459929,\n        0.2119034982,0.6806995451,0.1073969566,\n        0.0883024619,0.2817188376,0.6299787005\n    );\n    \n    vec3 lms = mul3(m1,c);\n    \n    lms = pow(lms,vec3(1./3.));\n\n    mat3 m2 = mat3(\n        +0.2104542553,+0.7936177850,-0.0040720468,\n        +1.9779984951,-2.4285922050,+0.4505937099,\n        +0.0259040371,+0.7827717662,-0.8086757660\n    );\n    \n    return mul3(m2,lms);\n}\n\nvec3 oklab2srgb(vec3 c)\n{\n    mat3 m1 = mat3(\n        1.0000000000,+0.3963377774,+0.2158037573,\n        1.0000000000,-0.1055613458,-0.0638541728,\n        1.0000000000,-0.0894841775,-1.2914855480\n    );\n\n    vec3 lms = mul3(m1,c);\n    \n    lms = lms * lms * lms;\n  \n    mat3 m2 = mat3(\n        +4.0767416621,-3.3077115913,+0.2309699292,\n        -1.2684380046,+2.6097574011,-0.3413193965,\n        -0.0041960863,-0.7034186147,+1.7076147010\n    );\n    return mul3(m2,lms);\n}\n\nvec3 lab2lch( in vec3 c ){return vec3(c.x,sqrt((c.y*c.y) + (c.z * c.z)),atan(c.z,c.y));}\n\nvec3 lch2lab( in vec3 c ){return vec3(c.x,c.y*cos(c.z),c.y*sin(c.z));}\n\nvec3 srgb_to_oklch( in vec3 c ) { return lab2lch(srgb2oklab(c)); }\nvec3 oklch_to_srgb( in vec3 c ) { return oklab2srgb(lch2lab(c)); }\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}