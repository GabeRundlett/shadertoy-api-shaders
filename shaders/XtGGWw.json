{
    "Shader": {
        "info": {
            "date": "1474805418",
            "description": "Compare different normal packing methods, from top to bottom:\n\n1) Stereographic\n2) Spheremap\n3) Unsigned\n4) Simple (naive)\n\nEven stripes shows 8bit unsigned error, odd stripes show floating point error.\nMouse position flattens normal",
            "flags": 32,
            "hasliked": 0,
            "id": "XtGGWw",
            "likes": 6,
            "name": "Normal mapping comparison",
            "published": 3,
            "tags": [
                "test",
                "normal",
                "packing",
                "spheremap",
                "sterographic"
            ],
            "usePreview": 1,
            "username": "pheelicks",
            "viewed": 940
        },
        "renderpass": [
            {
                "code": "vec3 mockNormal(vec2 uv) {\n    vec3 normal;\n    normal.xy = sin( vec2( 318.1, 178.2 ) * uv );\n    normal.z = 1.0 + cos( 82.2 * uv.x ); \n    return normalize( normal );\n}\n\nvec3 textureNormal(vec2 uv) {\n    vec3 normal = texture( iChannel1, 100.0 * uv ).rgb;\n    normal.xy = 2.0 * normal.xy - 1.0;\n    normal.z = sqrt(iMouse.x / iResolution.x);\n    return normalize( normal );\n}\n\nvec3 simpleUnpack(vec2 n) {\n    vec3 normal = vec3( n.xy, 1.0 );\n \treturn normalize( normal );   \n}\n\nvec3 unsignedUnpack(vec2 n) {\n    vec2 nn = 2.0 * n - 1.0;\n    vec3 normal = vec3( nn.xy, 1.0 );\n \treturn normalize( normal );   \n}\n\nvec3 spheremapUnpack(vec2 n) {\n    vec4 nn = vec4(2.0 * n - 1.0, 1.0, -1.0);\n    float l = dot(nn.xyz,-nn.xyw);\n    nn.z = l;\n    nn.xy *= sqrt(l);\n    return nn.xyz * 2.0 + vec3(0.0, 0.0, -1.0);\n}\n\nvec3 stereographUnpack(vec2 n) {\n    float scale = 1.7777;\n    vec3 nn = vec3(2.0 * scale * n, 0.0) + vec3(-scale,-scale,1.0);\n    float g = 2.0 / dot(nn.xyz,nn.xyz);\n    vec3 normal;\n    normal.xy = g*nn.xy;\n    normal.z = g-1.0;\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //vec3 normal = mockNormal(uv);\n    vec3 normal = textureNormal(uv);\n    \n    // Packed normal\n    vec2 packedNormal = texture( iChannel0, uv ).rg;\n    \n    vec3 unpackedNormal;\n    if ( uv.y < 0.25 ) { unpackedNormal = simpleUnpack( packedNormal ); }\n    else if ( uv.y < 0.5 ) { unpackedNormal = unsignedUnpack( packedNormal ); }\n    else if ( uv.y < 0.75 ) { unpackedNormal = spheremapUnpack( packedNormal ); }\n    else if ( uv.y < 1.0 ) { unpackedNormal = stereographUnpack( packedNormal ); }\n\n    \n    // Error\n    float e = length( abs( unpackedNormal - normal ) );\n    vec3 error = vec3( 0.01, 0.1, 1.0 ) * e;\n    if ( mod( uv.y, 0.25 ) < 0.125 ) {\n      // Highlight floating point error\n      error *= 100000.0;\n    }\n    \n\tfragColor = vec4( error * pow( 1.0 + floor( 10.0 * uv.x ), 3.0 ), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 mockNormal(vec2 uv) {\n    vec3 normal;\n    normal.xy = sin( vec2( 318.1, 178.2 ) * uv );\n    normal.z = 1.0 + cos( 82.2 * uv.x ); \n    return normalize( normal );\n}\n\nvec3 textureNormal(vec2 uv) {\n    vec3 normal = texture( iChannel1, 100.0 * uv ).rgb;\n    normal.xy = 2.0 * normal.xy - 1.0;\n    \n    // Adjust n.z scale with mouse to show how flat normals behave\n    normal.z = sqrt(iMouse.x / iResolution.x);\n    return normalize( normal );\n}\n\nvec2 bit8(vec2 normal) {\n    vec2 n = clamp( normal, 0.0, 1.0 ); // 0 -> 1 range\n    return floor( 255.0 * n + 0.499999 ) / 255.0; // 256 discrete values\n}\n\n// Normalize into 2 channels by assuming n.z = 1.0\nvec2 simplePack(vec3 n) {\n \treturn n.xy / n.z;   \n}\n\n// Transform -1 -> 1 into 0 -> 1 range\nvec2 unsignedPack(vec3 n) {\n \tvec2 normal = n.xy / n.z;\n    return 0.5 * normal + 0.5;\n}\n\n// Spheremap packing\nvec2 spheremapPack(vec3 n)\n{\n    float p = sqrt(n.z * 8.0 + 8.0);\n    vec2 normal = n.xy / p + 0.5;\n    return normal;\n}\n\n// Stereographic packing\nvec2 stereographPack(vec3 n)\n{\n    float scale = 1.7777;\n    vec2 enc = n.xy / ( n.z + 1.0 );\n    enc /= scale;\n    enc = enc * 0.5 + 0.5;\n    return enc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec3 normal = mockNormal(uv);\n    vec3 normal = textureNormal(uv);\n    vec2 packedNormal;\n    if ( uv.y < 0.125 ) { packedNormal = simplePack( normal ); }\n    else if ( uv.y < 0.25 ) { packedNormal = bit8( simplePack( normal ) ); }\n    \n    else if ( uv.y < 0.375 ) { packedNormal = unsignedPack( normal ); }\n    else if ( uv.y < 0.5 ) { packedNormal = bit8( unsignedPack( normal ) ); }\n\n    else if ( uv.y < 0.625 ) { packedNormal = spheremapPack( normal ); }\n    else if ( uv.y < 0.75 ) { packedNormal = bit8( spheremapPack( normal ) ); }\n\n    else if ( uv.y < 0.875 ) { packedNormal = stereographPack( normal ); }\n    else if ( uv.y < 1.0 ) { packedNormal = bit8( stereographPack( normal ) ); }\n\n    fragColor = vec4(packedNormal, 0.0 ,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}