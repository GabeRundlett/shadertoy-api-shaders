{
    "Shader": {
        "info": {
            "date": "1674812395",
            "description": "4 fun but need to add AA later",
            "flags": 0,
            "hasliked": 0,
            "id": "mtXXWN",
            "likes": 7,
            "name": "Crossing ribbon",
            "published": 3,
            "tags": [
                "2d",
                "ribbon",
                "cross"
            ],
            "usePreview": 0,
            "username": "Karp",
            "viewed": 190
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Parameter\n    float scale = 3.;\n    float time = 1.5 * 1./scale * iTime;\n    vec3 bgColor = vec3(0.33);\n    \n    vec3 ribbonAcolor = Color255(157,39,242);\n    ribbonAcolor = HueShiftcolor(ribbonAcolor,.05 * iTime);\n    vec3 ribbonBcolor = Color255(255,242,39);\n    ribbonBcolor = HueShiftcolor(ribbonBcolor,.05 * iTime);\n    float ribbonThickness = (.6)/2.;\n    \n    vec3 shadowColor = vec3(.15);\n    float shadowStrength = .25;\n    float shadowOffset = .15;\n\n    // UV manipulation\n    vec2 uv = scale * AspectRatioUV(fragCoord.xy, iResolution.xy);\n    uv = RotateUV(uv, 45.);\n    vec2 uvA = vec2(fract(uv.x), uv.y);\n    vec2 uvB = vec2(uv.x, fract(uv.y));\n    \n    //Visu\n    vec3 pix = bgColor;\n    \n    vec2 lineGrid = step(mod(uv,2.), vec2(1.));\n    float checkboard = mod(lineGrid.x + lineGrid.y, 2.0);\n    \n    float stripA = step(distance(uvA.x,.5),ribbonThickness);\n    stripA *= step(uvA.y, ceil(-uv.x) + 2.25 * scale * sin(time));\n    float stripAshadow = step(distance(uvA.x - shadowOffset,.5),ribbonThickness);\n    stripAshadow *= step(uvA.y, ceil(-uv.x) +  2.25 * scale * sin(time) - shadowOffset);\n    stripAshadow = clamp01(stripAshadow - stripA);\n    \n    float stripB = step(distance(uvB.y,.5), ribbonThickness);\n    stripB *= step(uvB.x, ceil(-uv.y) +  2.25 * scale * sin(time));\n    float stripBshadow = step(distance(uvB.y + shadowOffset,.5), ribbonThickness);\n    stripBshadow *= step(uvB.x, ceil(-uv.y) +  2.25 * scale * sin(time) - shadowOffset);\n    stripBshadow = clamp01(stripBshadow - stripB);\n    \n    float crossRibbon = (stripA + stripAshadow + stripB + stripBshadow)-1.;\n    \n    vec3 preRibbonB = mix(pix, ribbonBcolor, stripB);\n    vec3 ribbonA = mix(preRibbonB, ribbonAcolor, stripA);\n    ribbonA = mix(ribbonA, shadowColor, stripAshadow * shadowStrength);\n    vec3 ribbonB = mix(ribbonA, ribbonBcolor, stripB);\n    ribbonB = mix(ribbonB, shadowColor, stripBshadow * shadowStrength);\n    \n    pix = mix(ribbonB, ribbonA, crossRibbon * checkboard);\n    \n\tfragColor = vec4(pix, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Constant\n#define PI  3.14159265359\n#define TAU 6.28318530717\n\n//Color\n#define black   vec3(0.0)\n#define grey    vec3(0.5)\n#define white   vec3(1.0)\n//\n#define red     vec3(1.0,0.0,0.0)\n#define green   vec3(0.0,1.0,0.0)\n#define blue    vec3(0.0,0.0,1.0)\n//\n#define cyan    vec3(0.0,1.0,1.0)\n#define yellow  vec3(1.0,1.0,0.0)\n#define magenta vec3(1.0,0.0,1.0)\n\n//Maths\nfloat clamp01(float value) {return clamp(value,0.0,1.0);}\nfloat saturate(float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\n///Playlist shadertoy SDF : \n//https://www.shadertoy.com/playlist/MXdSRf&from=36&num=12\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n///UV (TextCoord)\nvec2 CenterUV(vec2 fragCoord, vec2 resolution)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5 * resolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 FullScreenUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy, resolution);\n    uv = 2.0 * uv.xy / resolution.xy;\n\t// [-iResolution.x/2, iResolution.x/2] -> [-1.0, 1.0]\n    // [-iResolution.y/2, iResolution.y/2] -> [-1.0, 1.0]\n    \n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy, resolution);\n\tuv = 2.0 * uv.xy / resolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\n\nvec2 RotateUV(vec2 uv, float angle)\n{\t\n    //angle in degree (TAU = 2PI = 360 degrees)\n\tangle = angle * PI / 180.0;\n    return uv * mat2( cos(angle), sin(angle),\n                     -sin(angle), cos(angle));\n}\n\n///COLOR\nvec3 Color255(int R, int G, int B)\n{\n    float rat = 1.0/255.0;\n    return vec3(float(R)*rat, float(G)*rat, float(B)*rat);\n}\nvec4 Color255(int R, int G, int B, int A)\n{\n    return vec4(Color255(R,G,B), 255);\n}\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 HSV2RGB(vec3 c){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//Source: https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 RGB2HSV(vec3 c){\n\tvec4 K=vec4(0.,-1./3.,2./3.,-1.),\n\t     p=mix(vec4(c.bg ,K.wz),vec4(c.gb,K.xy ),step(c.b,c.g)),\n\t     q=mix(vec4(p.xyw,c.r ),vec4(c.r ,p.yzx),step(p.x,c.r));\n\tfloat d=q.x-min(q.w,q.y),\n\t      e=1e-10;\n\treturn vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\nvec3 HueShiftcolor(vec3 c, float shift)\n{\n    c = RGB2HSV(c);\n    c = vec3(mod(c.x + shift,1.), c.yz);\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}