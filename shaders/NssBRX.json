{
    "Shader": {
        "info": {
            "date": "1645134134",
            "description": "Dithering should happen in sRGB. Disable the #define in line 12 to see the effects of doing dithering _before_ the linear to sRGB conversion instead of after.",
            "flags": 0,
            "hasliked": 0,
            "id": "NssBRX",
            "likes": 39,
            "name": "Dithering should happen in sRGB",
            "published": 3,
            "tags": [
                "2d",
                "rgb",
                "dithering",
                "srgb"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1921
        },
        "renderpass": [
            {
                "code": "// The displays expects colors in sRGB space, so we'll be converting colors\n// from linear space to sRGB. But also, the display has a limted number of\n// bits (usually 8, but we'll do 3 for today's test - change line 12 to emulate\n// other bit counts). So we'll want to dither the results to prevent banding\n// before sending the colors ot the display. So now the question arises - should\n// we convert to sRGB before or after dithering. The answer is _before_, since\n// dithering aids quantization, and that happens in sRGB, or in the display if\n// you want. Comment the #define in line 13 to see the consequences of doing the\n// sRGB conversion _after_ dithering - darkest colors are wrong, and the noise\n// no longer feels uniform.\n\n#define BITS 4\n#define SHOW_CORRECT\n//#define PERCEPTUAL_UNIFORM\n\n//------------------------------------------------------------------\n// rand()\n//------------------------------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // hash by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n//------------------------------------------------------------------\n// color display functions\n//------------------------------------------------------------------\n\nfloat lrgb2srgb( float color )\n{\n\treturn (color<0.0031308) ? color*12.92:1.055*pow(color,(1.0/2.4))-0.055;\n}\n\nfloat dither( float color )\n{\n    float n = frand()+frand()-1.0;  // triangular noise\n    return color + n*exp2(-float(BITS));\n}\n\nfloat quantize( float color )\n{\n    const float levels = exp2(float(BITS));\n    return floor(color*levels)/(levels-1.0);\n}        \n\n//------------------------------------------------------------------\n// main\n//------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Init randoms\n    srand( ivec2(fragCoord), iFrame );\n\n    // Coordinates\n    float x = 1.0*fragCoord.x/iResolution.x;\n    float y = 3.0*fragCoord.y/iResolution.y;\n\n    // Create an energy linear color ramp. Note that darks will feel\n    // compressed to your eye. Enable #define PERCEPTUAL_UNIFORM in \n    // line 14 to make it more perceptually uniform, if you want.\n    float col = x;\n    #ifdef PERCEPTUAL_UNIFORM\n    col = pow( col, 2.2 );\n    #endif\n\n\n    // CORRECT: convert to sRGB BEFORE dithering\n    #ifdef SHOW_CORRECT\n        col = lrgb2srgb( col ); \n\n        if( y>1.0 && y<2.0 )\n        col = dither( col );\n\n    // INCORRECT: converting to sRGB AFTER dithering\n    #else\n        if( y>1.0 && y<2.0 )\n        col = dither(col);\n        \n        col = lrgb2srgb( col ); \n    #endif\n\n    // simulate 2^BITS color level display screen\n    if( y>1.0 )\n    col = quantize(col); \n\n    // separation lines\n    //col *= smoothstep( 0.0, 0.01, 1.0-2.0*abs(fract(y)-0.5) );\n\n    fragColor = vec4( col, col, col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}