{
    "Shader": {
        "info": {
            "date": "1609539793",
            "description": "Maybe don't stay for too long.\n\n--\n\nKaDokta.com",
            "flags": 0,
            "hasliked": 0,
            "id": "tsKyD1",
            "likes": 5,
            "name": "The Others",
            "published": 3,
            "tags": [
                "2d",
                "tunnel",
                "eye",
                "orb",
                "floating"
            ],
            "usePreview": 0,
            "username": "KaDokta",
            "viewed": 357
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define TAU 2.0*PI\n#define ANIMATE true\n#define MOUSE_LOOK false\n#define TIME_OFFSET 60.0\n\n#define COL_OUTER_EYE vec3(0.5, 0.5, 0.7)\n#define COL_BACKGROUND vec3(0.04, 0.06, 0.1)\n#define COL_PUPIL_OUTER_START vec3(0.1, 0.3, 0.9)\n#define COL_PUPIL_OUTER_END vec3(0.8, 0.0, 0.0)\n#define COL_PUPIL_INNER vec3(1.0)\n#define COL_EYEBALL_COLOR vec3(0.1, 0.1, 0.1)\n#define COL_EYEBALL_TEXTURE_COLOR vec3(0.3, 0.1, 0.5)\n#define COL_ORB_BACKGROUND vec3(0.5, 0.1, 0.9)\n#define COL_ORB_OUTLINE vec3(0.8, 0.0, 0.0)\n#define COL_CANTHUS vec3(0.3, 0.0, 0.0)\n\n#define TIMER_PHASE_LOOK 30.0\n#define TIMER_PHASE_SPLIT 50.0\n#define TIMER_PHASE_FADEOUT 56.0\n#define TIMER_PHASE_RESET 60.0\n#define TIMER_PHASE_ALL 64.0\n\n\nstruct phaseInfo\n{\n    int id;\n    float time;\n};\n\n\nstruct orbInfo\n{\n    vec2 position;\n    float size;\n    float timedSeed;\n    float fixedSeed;\n};\n\n\nfloat ang(in vec2 from, in vec2 to)\n{\n    return atan(from.y - to.y, from.x - to.x);\n}\n\n\nfloat calculatePixelValue(in float currentDistance, in float maxWidth)\n{\n    return max(0.0, 1.0 - pow(abs(currentDistance - 1.0), 2.5) / (maxWidth));\n}\n\n\nfloat calculatePixelValueFilled(in float currentDistance, in float maxWidth)\n{\n    return max(0.0, 1.0 - pow(currentDistance - 1.0, 5.0) / (maxWidth));\n}\n\n\nfloat getTimedMix(in float phaseTimer, in float phaseTimeStart, in float duration)\n{\n    phaseTimer -= phaseTimeStart;\n    return min(phaseTimer/duration, 1.0);\n}\n\n\nfloat interpolateLinear(in float val1, in float val2, in float percentage)\n{\n    return mix(val1, val2, percentage);\n}\n\n\nfloat interpolateSmooth(in float val1, in float val2, in float percentage)\n{\n    return mix(val1, val2, -cos(PI * percentage) * 0.5 + 0.5);\n}\n\n\nvoid getNoiseValues(in float seed, in float offset, in float upperLimit, out float val1, out float val2, out float percentage)\n{\n    vec2 texSize = iChannelResolution[0].xy;\n    float maxSize = texSize.x * texSize.y - 1.0;\n    \n    offset = mod(offset, maxSize);\n    upperLimit = (upperLimit <= 0.0 ? maxSize : min(upperLimit + offset, maxSize));\n    \n    seed = offset + mod(seed, upperLimit - offset);\n    \n    percentage = fract(seed);\n    float lowerSeed = floor(seed);\n    float upperSeed = ceil(seed);\n    \n    if(upperSeed > upperLimit){ // Make clean repetition\n        upperSeed = offset;\n    }\n    \n    if(seed < ceil(offset)){ // Adjust for fractions (lower)\n        float maxFraction = ceil(offset) - offset;\n        percentage -= fract(offset);\n        percentage = percentage/maxFraction;\n    }\n    \n    if(seed > floor(upperLimit)){ // Adjust for fractions (upper)\n        float maxFraction = upperLimit - floor(upperLimit);\n        percentage = percentage/maxFraction;\n    }\n    \n    \n    float xValue1 = mod(lowerSeed, texSize.x);\n    float yValue1 = mod(floor(lowerSeed/texSize.y), texSize.y);\n    \n    float xValue2 = mod(upperSeed, texSize.x);\n    float yValue2 = mod(floor(upperSeed/texSize.y), texSize.y);\n    \n    vec4 tex1 = texelFetch(iChannel0, ivec2(xValue1, yValue1), 0);\n    vec4 tex2 = texelFetch(iChannel0, ivec2(xValue2, yValue2), 0);\n    \n    val1 = tex1.x;\n    val2 = tex2.x;\n}\n\n\nfloat getRandSmooth(in float seed, in float offset, in float repeatAt)\n{\n    float val1;\n    float val2;\n    float percentage;\n    \n    getNoiseValues(seed, offset, repeatAt, val1, val2, percentage);\n    return interpolateSmooth(val1, val2, percentage);\n}\n\n\nfloat getRandSmooth(in float seed)\n{\n\treturn getRandSmooth(seed, 0.0, 0.0);\n}\n\n\nfloat getRand(in float seed, in float offset, in float repeatAt)\n{\n    float val1;\n    float val2;\n    float percentage;\n    \n    getNoiseValues(seed, offset, repeatAt, val1, val2, percentage);\n    return interpolateLinear(val1, val2, percentage);\n}\n\n\nfloat getRand(in float seed, in float offset)\n{\n    return getRand(seed, offset, 0.0);\n}\n\n\nfloat getRand(in float seed)\n{\n    return getRand(seed, 0.0, 0.0);\n}\n\n\nfloat getFixedValue(in float duration)\n{\n    return iTime - mod(iTime, duration);\n}\n\n\nmat2 rotate(in float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n\nvec2 rotateVec(in vec2 startVec, in vec2 offset, in float angle)\n{\n    mat2 rotation = rotate(angle);\n    startVec = startVec - offset;\n    startVec *= rotation;\n    return startVec + offset;\n}\n\n\nfloat normalizedCos(in float value)\n{\n    return 0.5*(1.0-cos(value/PI*20.0));\n}\n\n\nfloat calculateParabola(in vec2 startPoint, in vec2 centerPoint, in float parabolaX, out float a, out float height)\n{\n    // General parabola formula: y = a*(x - x_center)Â² + y_center\n    a = (startPoint.y - centerPoint.y) / pow(startPoint.x - centerPoint.x, 2.0);\n    float parabolaY = a*pow(parabolaX - centerPoint.x, 2.0) + centerPoint.y;\n    height = parabolaY - startPoint.y;\n    return parabolaY;\n}\n\n\nvoid drawBackLines(inout vec3 col, in vec2 fragCoord)\n{\n    vec2 center = iResolution.xy*0.5;\n    float angle = (ang(fragCoord, center) + PI) * 180.0/PI * 0.8 + iTime;\n    angle = mod(angle, 360.0);\n    float angleDisc = floor(angle);\n    \n    float timePerAngle = getRand(angleDisc, 0.0) * 2.0 + 5.0;\n    \n    float val = getRand(angleDisc, ANIMATE ? ceil(iTime/timePerAngle) * 180.0 : 0.0);\n    \n    if(val > 0.96){\n        float halfTime = timePerAngle * 0.5;\n        float timer = mod(iTime, timePerAngle);\n        timer = (timer > halfTime ? halfTime - abs(halfTime - timer) : timer) / halfTime;\n        \n        col -= col * smoothstep(round(angle), ceil(angle)-0.5, angle) * timer * 0.7;\n    }\n}\n\n\nvoid drawForeLines(inout vec3 col, in vec2 fragCoord, in float seed, in phaseInfo phase)\n{\n    if(!ANIMATE){\n        return;\n    }\n\n    vec2 center = iResolution.xy*0.5;\n    fragCoord = rotateVec(fragCoord, center, iTime * 0.02); \n    \n    float angle = (ang(fragCoord, center) + PI) * 180.0/(2.0*PI);\n    float angleDisc = floor(angle);\n       \n    float maxLength = (iResolution.x + iResolution.y) * 1.0;\n    \n    float timePerAngle = getRand(angleDisc, seed + 128.0) * 10.0 + 5.0;\n    float speedPerAngle = maxLength/timePerAngle;\n    \n    float timeStart = iTime + 0.0;\n    \n    float val = getRand(angleDisc, seed + (ANIMATE ? ceil((timeStart * speedPerAngle)/maxLength) * 10.0 : 0.0));\n    \n    if(val < 0.05){\n        float currentLength = mod(timeStart * speedPerAngle, maxLength);\n        float dist = length(fragCoord - center);\n        \n        float endMin = dist;\n        float endMax = dist + 3.0;\n        \n        float startMin = currentLength - maxLength*0.5;\n        float startMax = startMin + 3.0;\n        \n        float mixValue = 0.0;\n        \n        if(phase.id == 1){\n            mixValue = getTimedMix(phase.time, TIMER_PHASE_LOOK, 2.0);\n        }\n        else if(phase.id > 1 && phase.id < 4){\n            mixValue = 1.0;\n        }\n        \n        col += smoothstep(round(angle), ceil(angle)-0.5, angle) \n               * smoothstep(startMin, startMax, dist)\n               * smoothstep(endMin, endMax, currentLength)\n               * (1.0 - (timePerAngle / 15.0))\n               * mix(COL_PUPIL_OUTER_START, COL_PUPIL_OUTER_END, mixValue);\n    }\n}\n\n\nvoid drawSmoothedCircle(in vec2 position, in float radius, in float lineWidth, in vec3 lineColor, in vec3 backgroundColor, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float centerValue = length(fragCoord.xy - position);\n    \n\tcurrentColor += vec3(smoothstep(radius + lineWidth * 0.25, radius , centerValue)) * (lineColor - currentColor)\n         + vec3(smoothstep(radius, radius - lineWidth * 0.25, centerValue)) * (backgroundColor - currentColor);\n}\n\n\nvoid drawCircle(in vec2 position, in float radius, in float lineWidth, in vec3 lineColor, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float pixelFract = calculatePixelValue(length(fragCoord - position) - radius, lineWidth);\n    currentColor += vec3(pixelFract) * (lineColor - currentColor);\n}\n\n\nvoid drawFullCircle(in vec2 position, in float radius, in vec3 color, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float pixelFract = calculatePixelValueFilled(length(fragCoord - position) - radius, radius);\n    currentColor += vec3(pixelFract) * (color - currentColor);\n}\n\n\nvoid drawFilledSmoothedOval(in vec2 center, in float width, in float height, in vec3 color, inout vec3 currentColor, in vec2 fragCoord)\n{\n    vec2 size = vec2(width, height);\n    \n    float curValue = length((fragCoord.xy - center)/size);\n    float minValue = 1.0;\n    float maxValue = 1.0 - 0.04;\n    \n    currentColor += vec3(smoothstep(maxValue, minValue, curValue)) * (color - currentColor);\n}\n\n\nfloat calcFrayHeight(in float time, in float seed, in float angle, in float divs, in float amount)\n{\n    return getRandSmooth(time + angle * divs, seed, TAU * divs) * amount;\n}\n\n\nfloat calcRandHeightMultiplier(in float time, in float seed)\n{\n    return 1.0+(getRand(1.0 + (ANIMATE ? time : 0.0) * 1.0, seed) - 0.5) * 2.0;\n}\n\n\nfloat calcRandWobble(in float seed, in float angle, in float direction, in float divs, in float offset, in float amount)\n{\n    return (0.5-getRandSmooth(angle * divs + (ANIMATE ? iTime * -direction : 0.0), seed + offset, TAU * divs)) * amount;\n}\n\n\nvec3 drawFrayedCircle(in float time, in float seed, in float direction, in vec2 position, in phaseInfo phase, in float radius, in float lineWidth, in vec3 currentColor, in vec2 fragCoord)\n{  \n    if(!ANIMATE){\n        time = 0.0;\n    }\n    \n    float mixValue = 0.0;\n    \n    if(phase.id == 1){\n        mixValue = getTimedMix(phase.time, TIMER_PHASE_LOOK, 2.0);\n    }\n    else if(phase.id > 1 && phase.id < 4){\n        mixValue = 1.0;\n    }\n    \n    float angle = atan(fragCoord.y - position.y, fragCoord.x - position.x) + PI;    \n    \n    float divs = 50.0 * radius/iResolution.x + 5.0 + 10.0 * mixValue;\n    \n    radius = radius + calcFrayHeight(time, seed, angle, divs, radius * 0.1)\n        * calcRandHeightMultiplier(time, seed)\n        + calcRandWobble(seed, angle, direction, 3.0, 0.0, radius * 0.1);\n    \n    radius += calcFrayHeight(2.0*time, seed, angle, divs, radius * 0.1)\n        * calcRandHeightMultiplier(2.0*time, seed)\n        - calcRandWobble(seed, angle, direction, 4.0, TAU*10.0, radius * 0.1);;\n    \n    float valueInner = length(vec2(1.0, 2.0) * (fragCoord - position)) - radius;\n    float valueOuter = length(fragCoord - position) - radius;\n    \n    float offset = 0.2 + 0.5 * abs(sin(time * 0.2));\n    vec3 colorTexture = COL_ORB_BACKGROUND - vec3(0.0, 0.0, mod(valueInner - iTime * 50.0, iResolution.x/12.0)/radius);\n    \n    vec3 lineColor = mix(vec3(0.0), COL_ORB_OUTLINE, mixValue) * vec3(offset);\n    \n    return vec3(smoothstep(radius + 1.0 + lineWidth * 0.25, radius , valueOuter)) * (lineColor - currentColor)\n           + vec3(smoothstep(radius, radius - lineWidth * 0.25 * offset * 3.0, valueOuter)) \n           * (0.4 * colorTexture * valueInner/100.0 - (lineColor));\n}\n\n\nvoid drawParabola(in float parabolaY, in vec2 centerPoint, in float width,  in float lineWidth, in vec3 lineColor, inout vec3 currentColor, in vec2 fragCoord, out float height)\n{   \n    if(abs(fragCoord.x - centerPoint.x) <= width){\n        float pixelFract = calculatePixelValue(fragCoord.y - parabolaY, 2.0 * lineWidth);\n        currentColor = clamp(vec3(0.0), currentColor, vec3(1.0));\n        currentColor += vec3(pixelFract) * (lineColor - currentColor);\n    }\n}\n\n\nvoid drawBall(in float seed, in vec2 center, in vec2 pupilPosition, in float width, inout vec3 currentColor, in vec2  fragCoord)\n{\n    vec3 backgroundColor = COL_EYEBALL_COLOR;\n    \n    currentColor += backgroundColor - currentColor;\n    \n    vec2 toPosition = normalize(pupilPosition - center) * length(pupilPosition - center);\n    \n    float angle = ang(fragCoord, center - pupilPosition) + PI;\n    float draw = length(fragCoord - pupilPosition);\n    \n    float value = getRand(angle * iResolution.x/100.0 + getRand(draw / length(iResolution.xy) * 100.0, seed) \n                        *  iResolution.x/100.0 + iTime, seed, 2.0 * PI * 12.0) - 0.4;\n\n    currentColor += step(width*0.45, draw)\n                    * smoothstep(value, value + 8.0, (length(pupilPosition - fragCoord)+1.0)/width*2.0) * 6.0\n                    * (COL_EYEBALL_COLOR);\n\n    currentColor += smoothstep(width*0.55,width*0.6, width - draw)\n                    * (COL_EYEBALL_TEXTURE_COLOR);\n}\n\n\nvoid drawCanthus(in vec2 position, in float width, inout vec3 currentColor, in vec2 fragCoord)\n{\n    drawFilledSmoothedOval(position, width * 1.38, width * 1.4 * 0.55, COL_CANTHUS, currentColor, fragCoord);\n}\n\n\nvec2 addSaccade(in float seed, in float saccadeTimeMultiplier, in float movementMultiplier)\n{\n    if(!ANIMATE){\n    \treturn vec2(0.0);\n    }\n    \n    float saccadeInterval = max((getRand(getFixedValue(2.0), seed)+0.3)*saccadeTimeMultiplier, 0.6);  \n    float saccadeTimeFrame = getFixedValue(saccadeInterval);\n    float randomValue = getRand(saccadeTimeFrame / saccadeInterval, seed) - 0.5;\n    return movementMultiplier * randomValue * normalize(vec2(cos(randomValue), sin(randomValue)));\n}\n\n\nvec2 randomPosition(in float seed)\n{\n    if(!ANIMATE){\n        return vec2(0.0);\n    }\n    \n    float offsetInterval = max((getRand(getFixedValue(32.0), seed)+0.5)*5.0, 2.0);\n    float timeFrame = getFixedValue(offsetInterval);\n    float randomValue = getRand(timeFrame / offsetInterval, seed);\n    float randomValue2 = getRand(timeFrame / offsetInterval, 32.0 + seed);\n    return vec2(randomValue * iResolution.x, randomValue2 * iResolution.y);\n}\n\n\nfloat addPupilSize(in float seed)\n{\n    if(!ANIMATE){\n        return 0.0;\n    }\n    \n    float changeInterval = max(getRand(getFixedValue(2.0), seed), 0.6) * 15.0;\n    float timeFrame = getFixedValue(changeInterval);\n    float randomValue = getRand(timeFrame / changeInterval, 16.0 + seed) - 0.5;\n    return randomValue;\n}\n\n\nvec2 calculatePupilPosition(in float seed, in vec2 center, in float width, in vec2 fragCoord)\n{\n    vec2 position = center;\n    position += addSaccade(seed, 2.0, 5.0);\n    vec2 toMouse = vec2(0.0);\n    float maxDistance = width * 0.5;\n    float toMouseAngle = 0.0;\n    \n    if(MOUSE_LOOK){\n        toMouse = position - iMouse.xy;\n        toMouseAngle = -atan(position.y - iMouse.y, position.x - iMouse.x);\n    }\n    else{\n        vec2 offset =  randomPosition(seed) * 0.5;\n        vec2 fixedPos = iResolution.xy * 0.5;\n        toMouse = (fixedPos - offset) * 0.15;\n        toMouseAngle = -ang(fixedPos * 0.5, offset);\n    }\n\n    float squishValue = 1.0-min(1.0, length(toMouse)/maxDistance)*0.15;\n    position -= fragCoord;\n    position +=  rotate(toMouseAngle) * vec2(-min(length(toMouse), maxDistance), 0.0);\n    position *=  rotate(toMouseAngle);\n    position.x *= 1.0/squishValue;\n    position += fragCoord;\n    return position;\n}\n\n\nvoid drawPupil(in float seed, in int phase, in float phaseTimer, in vec2 position, in vec2 offset, in float width, inout vec3 currentColor, in vec2 fragCoord)\n{   \n\n    float mixValue = 0.0;\n\n    if(phase == 1){\n        mixValue = getTimedMix(phaseTimer, TIMER_PHASE_LOOK, 2.0);\n    }\n    else if(phase > 1 && phase < 4){\n        mixValue = 1.0;\n    }\n\n    vec3 pupilColor = mix(COL_PUPIL_OUTER_START, COL_PUPIL_OUTER_END, mixValue);\n    float pupilOuterSize = width * 0.5;\n    float pupilInnerSize = width * 0.12 + addPupilSize(seed) * 5.0;\n    float pupilCenterSize = (pupilOuterSize + pupilInnerSize) * 0.5;\n    \n    drawSmoothedCircle(position, pupilCenterSize, width - pupilInnerSize, pupilColor, COL_PUPIL_INNER, currentColor, fragCoord);\n    drawFullCircle(position, pupilInnerSize - 2.0, vec3(0.0), currentColor, fragCoord);\n    drawCircle(position, pupilInnerSize, 15.0, pupilColor, currentColor, fragCoord);\n}\n\n\nvoid drawInnerEye(in phaseInfo phase, in float seed, in float width, in float height, in vec2 position, in vec2 offset, inout vec3 currentColor, in vec2 fragCoord)\n{\n    if(abs(fragCoord.y - position.y) > abs(height) ||\n       abs(fragCoord.x - position.x) > abs(width)) {\n    \treturn;\n    }\n    \n    vec2 pupilPosition = position;\n    \n    if(phase.id == 0 || phase.id == 4){\n        pupilPosition = calculatePupilPosition(seed, position, width*0.85, fragCoord);\n    }\n    else{\n        pupilPosition += addSaccade(seed, 2.0, 7.0);\n    }\n    \n    drawBall(seed, position, pupilPosition, width, currentColor, fragCoord);\n    drawCanthus(position, width*0.68, currentColor, fragCoord);\n    drawPupil(seed, phase.id, phase.time, pupilPosition, offset, width*0.85, currentColor, fragCoord);\n}\n\n\nvoid drawOrbBackground(in orbInfo orb, in phaseInfo phase, inout vec3 col, in vec2 fragCoord)\n{   \n    col += drawFrayedCircle(orb.timedSeed, orb.fixedSeed, 1.0, orb.position, phase, orb.size*0.65, 10.0, col, fragCoord);;\n}\n\n\nfloat calculateOpenness(in float seed)\n{\n    float blinkInterval = 1.5 + 1.5 * getRand(seed);\n    float blinkDuration = 0.1;\n    float maxOpeness = 1.0;\n    float eyeOpen = maxOpeness;\n    \n    float blinkTimer = mod(iTime, blinkInterval);\n    \n    if(blinkTimer <= blinkDuration && ANIMATE){\n    \teyeOpen = maxOpeness-normalizedCos(blinkTimer * maxOpeness/blinkDuration);\n    }\n    \n    return eyeOpen;\n}\n\n\nvoid drawEye(in orbInfo orb, in phaseInfo phase, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float a;\n    float width = orb.size;\n    float height = width * 0.5;\n    \n    float centerHeight = height * calculateOpenness(orb.fixedSeed);\n    \n    vec2 startPos = vec2(orb.position.x - width, orb.position.y);\n    vec2 centerPointUp = startPos + vec2(orb.size, centerHeight);\n    vec2 centerPointDown = startPos + vec2(width, -centerHeight);\n    float parabolaYup = calculateParabola(startPos, centerPointUp, fragCoord.x, a, height);\n    float parabolaYDown = calculateParabola(startPos, centerPointDown, fragCoord.x, a, height);\n    \n    float upperLineWidth = 5.0;\n    float lowerLineWidth = 3.0;\n    \n    vec2 offset = 0.1 * (orb.position - iMouse.xy);\n    \n    drawInnerEye(phase, orb.fixedSeed, width, height, orb.position, offset, currentColor, fragCoord);\n    drawParabola(parabolaYup, centerPointUp, width + 2.0, upperLineWidth, COL_OUTER_EYE, currentColor, fragCoord, height);\n    drawParabola(parabolaYDown, centerPointDown, width, lowerLineWidth, COL_OUTER_EYE, currentColor, fragCoord, height);\n}\n\n\nvoid drawOrb(in orbInfo orb, in phaseInfo phase, inout vec3 currentColor, in vec2 fragCoord)\n{    \n    drawOrbBackground(orb, phase, currentColor, fragCoord);  \n    drawEye(orb, phase, currentColor, fragCoord);\n}\n\n\nvoid splitImage(inout vec3 col, inout vec2 fragCoord, in float phaseTimer)\n{\n    float divs = 16.0;\n    float pixels = iResolution.x/divs;\n    float percentage = max((phaseTimer-TIMER_PHASE_SPLIT)/(TIMER_PHASE_FADEOUT-TIMER_PHASE_SPLIT), 0.0);\n    \n    float currentLength = length(fragCoord - iResolution.xy*0.5);\n    float currentLengthDisc = currentLength/pixels - fract(currentLength/pixels);\n        \n    if(currentLengthDisc <= (percentage * length(iResolution.xy*0.5)/pixels)){\n        float number = (fragCoord.y/pixels - fract(fragCoord.y/pixels));\n        float direction = mod(number, 2.0) >= 1.0 ? -1.0 : 1.0;\n     \n        fragCoord.x += (iResolution.x/divs) * direction;\n        fragCoord.y -= (iResolution.y/divs) * direction;\n    }\n}\n\n\nvoid spliceImage(inout vec2 fragCoord)\n{\n    vec2 pos1 = vec2(0.8, 1.5);\n    vec2 pos2 = vec2(0.8, 0.5);\n\n    if((iResolution.y-fragCoord.y * pos1.y)/(fragCoord.x * pos1.x) * iResolution.x/iResolution.y > 1.0){\n        fragCoord = fragCoord * mat2(0.5, 0.0, 0.0, 0.5);\n    }\n\n    if((fragCoord.y * pos2.y)/(fragCoord.x * pos2.x) * iResolution.x/iResolution.y > 1.0){\n        fragCoord = fragCoord * mat2(1.5, 0.0, 0.0, 1.5);\n    }\n}\n\n\nvoid drawRectVignette(inout vec3 currentColor, in vec2 fragCoord)\n{\n    float angle = ang(fragCoord, iResolution.xy * 0.5);\n    float maxDistance = 50.0 + 100.0 * (0.5 - getRand(angle * 4.0, 0.0, 2.0 * PI * 4.0)) * sin(angle + iTime * 0.5);\n    vec3 startColor = currentColor;\n\n    float val = min(min(iResolution.x - fragCoord.x, iResolution.y - fragCoord.y), min(fragCoord.x, fragCoord.y));\n    val = min(min(iResolution.x - fragCoord.x, iResolution.y - fragCoord.y), min(fragCoord.x, fragCoord.y));\n\n    currentColor += vec3(smoothstep(0.0, 2.0, (maxDistance-val)/(maxDistance)) * 0.2) * 1.1;\n}\n\n\nvec2 calculateEyePos(in float startAngle, in float offset, in vec2 fragCoord)\n{\n    vec2 center = iResolution.xy*0.5;\n    vec2 defDistance = vec2(offset, 0.0);\n    vec2 position = center;\n   \n    position -= fragCoord;\n    position += rotate(startAngle + (ANIMATE ? iTime * 0.1 : 0.0)) * defDistance;\n    position += fragCoord;\n    return position;\n}\n\n\nvoid drawBackground(inout vec3 currentColor, in vec2 fragCoord)\n{\n    float currentLength = length(fragCoord - iResolution.xy*0.5);\n    float maxLength = length(iResolution.xy*0.5);\n    float currentLengthRatio = currentLength/maxLength;\n    float divs = iResolution.x/4.0;\n    \n    float colorValue = currentLength*2.0/maxLength;\n    \n    currentColor = COL_BACKGROUND * vec3(colorValue, colorValue, colorValue) \n                   * max(0.0, 1.0 - mod(currentLength - iTime * 0.1 * divs, divs)/maxLength);\n}\n\n\nvoid fadeOut(in float phaseTimer, inout vec3 currentColor){\n\n    float value = getTimedMix(phaseTimer, TIMER_PHASE_FADEOUT, TIMER_PHASE_RESET - TIMER_PHASE_FADEOUT - 1.0);\n    currentColor -= vec3(1.0) * value;\n}\n\n\nvoid fadeIn(in float phaseTimer, inout vec3 currentColor){\n\n    float value = getTimedMix(phaseTimer, TIMER_PHASE_RESET, TIMER_PHASE_ALL - TIMER_PHASE_RESET);\n    currentColor += vec3(1.0) * value;\n}\n\n\nint setPhase(in float time, out float phaseTimer)\n{\n    int phase = 0;\n    phaseTimer = mod(time, TIMER_PHASE_ALL);\n    \n    if(phaseTimer > TIMER_PHASE_RESET){\n        phase = 4;\n    }\n    else if(phaseTimer > TIMER_PHASE_FADEOUT){\n        phase = 3;\n    }\n    else if(phaseTimer > TIMER_PHASE_SPLIT){\n        phase = 2;\n    }\n    else if(phaseTimer > TIMER_PHASE_LOOK){\n        phase = 1;\n    }\n    else{\n        phase = 0;\n    }\n    \n    return phase;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.0);\n    float time = mod(iTime + TIME_OFFSET, 16384.0);\n    float phaseTimer;\n    \n    phaseInfo phase = phaseInfo(setPhase(time, phaseTimer), phaseTimer);\n    \n    drawBackground(col, fragCoord);\n      \n    if(phase.id >= 3 && phase.id < 4){\n        spliceImage(fragCoord);\n    }\n    \n    if(phase.id >= 2 && phase.id < 4){\n        splitImage(col, fragCoord, phaseTimer);  \n    }\n    \n    drawBackLines(col, fragCoord);  \n    drawForeLines(col, fragCoord, 0.0, phase);\n    \n    vec2[] positions = vec2[] (\n        \tiResolution.xy*0.5,\n       \t\tcalculateEyePos(TAU, iResolution.x*0.3, fragCoord),\n        \tcalculateEyePos(TAU/3.0, iResolution.x*0.3, fragCoord),\n        \tcalculateEyePos(TAU/3.0 * 2.0, iResolution.x*0.3, fragCoord)\n        );\n    \n    float[] sizes = float[] (\n        \tiResolution.x*0.105,\n        \tiResolution.x*0.055,\n        \tiResolution.x*0.055,\n        \tiResolution.x*0.055\n    \t);\n    \n    for(int i = 0; i < positions.length(); i++){\n        float seed = float(i) * 100.0;\n        orbInfo newOrb = orbInfo(positions[i], sizes[i], time + seed, seed);        \n        drawOrb(newOrb, phase, col, fragCoord);\n    }\n    \n    if(phase.id >= 3){\n        fadeOut(phaseTimer, col);\n    }\n    \n    if(phase.id >= 4){\n        fadeIn(phaseTimer, col);\n    }\n    \n    drawRectVignette(col, fragCoord);\n   \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}