{
    "Shader": {
        "info": {
            "date": "1401547259",
            "description": "Test to learn how to make shapes a bit complex like cups or badges, and it is also a tribute for the Decima  <img src=\"/img/emoticonHappy.png\"/>.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdsSD4",
            "likes": 5,
            "name": "La Decima",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "raymarching",
                "decima",
                "football",
                "realmadrid",
                "badge"
            ],
            "usePreview": 0,
            "username": "ciberxtrem",
            "viewed": 1037
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415\n#define EPSILON 0.05\n#define MAX_DIST 9999.\n#define STEP 0.1\n\nfloat gTime;\nfloat sampAvg;\nfloat cupsTime = 25.;\n\nvec3 rotate(vec3 v, vec3 k, float a){\n    vec3 r = v*cos(a) + cross(v, k)*sin(a) + k*dot(k, v)*(1.-cos(a));\n    return r;\n}\n\nfloat smin( float a, float b ){\n    float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Primitives\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p ){\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n ){\n  return dot(p,n.xyz) + n.w;\n}\n\n// Geometry\nfloat sdWings( vec3 p, vec2 h ){\n\t// Main Shape\n\tvec3 q = p - vec3(3.0, -0.8, 0.);\n\tq = rotate(q, vec3(0.,0.,1.), PI/1.85);\n\tq.x *= 0.32;\n\tvec3 ref = vec3(q.x, sin(q.x)*1.0, 0.) * (1.-step(PI* 0.928, abs(q.x)));\n\tfloat d = length(q - ref) - h.x;\n\t\n\tfloat cutPlane = sdPlane(p - vec3(0., 8.0, 0.), normalize(vec4(0,-1.,0., 0.)));\n\td = max(-cutPlane, d);\n\t\n\tcutPlane = sdPlane(p - vec3(0., -4.0, 0.), normalize(vec4(0,1.,0., 0.)));\n\td = max(-cutPlane, d);\n\t\n\t// Inner Shape\n\tq = p - vec3(3.68, 3.5, 0.);\n\tq = rotate(q, vec3(0.,0.,1.), PI/1.8);\n\tref = vec3(q.x, sin(q.x), 0.) * (1.-step(PI*1.48, abs(q.x)));\n\tfloat d2 = mix(length(q - ref) - h.x, 1., step(4., q.x ));\n\td = smin(d, d2);\n\t\n\t// Top Circle\n\tfloat circleY = 7.8;\n\tq = p - vec3(2.7, circleY, 0.0);\n\tq = rotate(q, vec3(1.,0.,0.), PI/2.);\n\td2 = sdTorus(q, vec2(1.10, h.x - 0.035));\n\t\n\tcutPlane = sdPlane(p - vec3(0., 8.4, 0.), normalize(vec4(0.2, 1.,0., 0.)));\n\td2 = max(-cutPlane, d2);\n\t\n\td = smin(d, d2);\n\treturn d;\n}\n\nvec2 sdLasso(vec3 p, vec2 h){\n\tfloat len = h.x;\n\tvec3 ref = vec3(0., p.y, sin(p.y + gTime + h.y) * abs(p.y - len) * 0.1 );\n\tfloat d = (length(p.xy - ref.xy) - (0.2 + smoothstep(0., len, abs(p.y - len)) * 0.6));\n\t\n\td = max(mix(d, 1., step(len, abs(p.y))), abs(p.z - ref.z) - 0.2);\n\t\n\treturn vec2(d, 3.);\n}\n\nfloat sdOne2D(vec3 p, vec2 s){return max(abs(p.x) - s.x, abs(p.y)-s.y);}\nfloat sdZero2D(vec3 p, vec2 s){return abs(length(p.xy) - s.x) - s.y;}\nfloat udBox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\n\nvec3 sdCL(vec3 p){\n\tvec3 q = p - vec3(0., 6., 0.);\n\t\n\t// main shape\n\tvec2 h = sdSegment(vec3(0.0, 0.0, 0.0), vec3(0.0, -7.0, 0.0), q);\n\th.x = h.x - 3.5 + pow(h.y, 1.8) * 2.5;\n\tfloat d = h.x;\n\tfloat d2 = sdCappedCylinder(q - vec3(0., 3., 0.), vec2(4., 2.0));\n\td = max(d, -d2);\n\t// up part\n\td2 = sdCappedCylinder(q - vec3(0., 2.8, 0.), vec2(3.45, 2.0));\n\tfloat dy = 1. - pow(clamp(abs((q.y -2.8) / 2.0), 0., 1. ), 1.5);\n\tfloat dCutPlane = (q.y - 2.8);\n\td2 = max(d2 + dy * 1.2, dCutPlane);\n\td = smin(d, d2);\n\t// top part\n\td2 = sdCappedCylinder(q - vec3(0., 3., 0.), vec2(2.5, 0.13));\n\td = smin(d, d2);\n\t// bottom\n\td2 = sdCappedCylinder(q - vec3(0., -8, 0.), vec2(2., 0.1));\n\td = smin(d, d2);\n\t\n\td2 = sdCappedCylinder(q - vec3(0., -8.20, 0.), vec2(2.5, 0.2));\n\td = smin(d, d2);\n\t// wings\n\tvec3 q2 = q - vec3(-6., -2, 0.);\n\td2 = sdWings(q2, vec2(0.25, 0.0));\n\td = smin(d, d2);\n\t\n\tq2 = rotate(q - vec3(6., -2, 0.), vec3(0., 1., 0.), PI);\n\td2 = sdWings(q2, vec2(0.25, 0.0));\n\td = smin(d, d2);\n\t// lasso\n\tvec2 res = vec2(d, 2.);\n\tvec2 res2 = sdLasso(q - vec3(3., -1., 0.), vec2(5., 2.*PI));\n\tif(res2.x < res.x) {\n\t\tres = res2;\n\t}\n\tres2 = sdLasso(q - vec3(-3., -1., 0.), vec2(3.5, PI));\n\tif(res2.x < res.x) {\n\t\tres = res2;\n\t}\n\t// cube\n\td = udBox(q - vec3(0., -11, 0.), vec3(2.5));\n\tif(d < res.x) {\n\t\tres = vec2(d, 4.);\n\t}\n\t\n\treturn vec3(res.xy, d);\n}\n\nvec3 CLGroup(vec3 p)\n{\n\tfloat c = 13.;\n\tvec3 q = p;\n\tq = mix((q - vec3(0., 0., -0.)) * vec3(1., 1.0, 1.0), q, step(26., abs(p.x)));\n\tq.x = mod(p.x,c)-0.5*c;\n\t\n\tvec3 res = sdCL(q);\n\tres = mix(res, vec3(1., -1., 9999.), step(65., abs(p.x)));\n\treturn res;\n}\n\nvec3 map(vec3 p)\n{\t\n\tvec3 res = CLGroup(p - vec3(0., 0.0, 35.));\n\tvec2 res2 = vec2(sdPlane(p - vec3(0., -6.5, 0.), normalize(vec4(0,1., 0., 0.))), 1.);\n\tif(res2.x < res.x)\n\t{\n\t\tres.xy = res2.xy;\n\t}\n\tres2 = vec2(sdPlane(p - vec3(0., 0.0, 40.), normalize(vec4(0,0., -1., 0.))), 5.);\n\tif(res2.x < res.x)\n\t{\n\t\tres.xy = res2.xy;\n\t}\n\treturn res;\n}\n\nvec3 calcNormal(vec3 p)\n{\n\tvec3 e = vec3(EPSILON, 0., 0.);\n\t\n\tvec3 n = vec3\n\t(\n\t\t  map(p + e.xyy).x - map(p - e.xyy).x\n\t\t, map(p + e.yxy).x - map(p - e.yxy).x\n\t\t, map(p + e.yyx).x - map(p - e.yyx).x\n\t);\n\t\n\treturn normalize(n);\n}\n\nvec3 intersect(vec3 ro, vec3 rd)\n{\n\tfloat prec = 0.002;\n\tfloat k = 2.*prec;\n\tvec3 res = vec3(MAX_DIST, -1., 9999.);\n\tfloat bloom = MAX_DIST;\n\t\n\tfor(int i = 0; i < 90; ++i)\n\t{\n\t\tif(res.x <= prec)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tres = map(ro + k*rd);\n\t\tbloom = res.z < bloom ? res.z : bloom;\n\t\tk += res.x;\n\t}\n\t\n\tif(res.x > prec)\n\t{\n\t\tres.y = -1.;\n\t\tk = MAX_DIST;\n\t}\n\t\n\tres.x = k;\n\tres.z = bloom;\n\t\n\treturn res;\n}\n\nvec3 colorBadge(vec3 p)\n{\n\tvec3 bgColor =  vec3(0.43,0.5,0.55);\n\tvec3 bColor = bgColor;\n\tvec3 q = p - vec3(1., 25., 0.);\n\t\n\t// foreground\n\tfloat d = length(q.xy)- 8.2;\n\tbColor = mix(vec3(1.), bColor, step(0., d));\n\t\n\tfloat d2 = max(length(q.xy - vec2(q.x, q.x))- 3.5, length(q.xy) - 8.);\n\tbColor = mix(vec3(0., 0., 0.7), bColor, step(0., d2));\n\td = min(d, d2);\n\t// main circle\n\td2 = sdZero2D(q, vec2(8., 0.4));\n\t// color + border\n\tbColor = mix(mix(vec3(0.), vec3(1., 0.84, 0.), smoothstep(0., 0.2, abs(d2))), bColor, step(0., d2));\n\td = min(d, d2);\n\n\t// sub circles\n\tvec3 q2 = q - vec3(-0.5, 0.0, 0.);\n\td2 = mix(sdZero2D(q2, vec2(5.6, 0.4)), 1., step(-3.0, q2.x));\n\tq2 = q - vec3(0.5, 0.0, 0.);\n\tfloat d3 = mix(sdZero2D(q2, vec2(5.6, 0.4)), 1., step(-3.0, -q2.x));\n\td2 = min(d2, d3);\n\t\n\t// m2\n\tq2 = q - vec3(-1.75, 2.9, 0.);\n\td3 = max(length(q2.xy - vec2(q2.x, -q2.x))- 0.6, length(q2.xy) - 2.9);\n\td2 = min(d2, d3);\n\t\n\t// c\n\tq2 = q - vec3(0.5, 0., 0.);\n\td3 = mix(sdZero2D(q2, vec2(2.5, 0.4)), 1., step(1.8, -q2.x));\n\td2 = min(d2, d3);\n\t\n\t// m1\n\tq2 = q - vec3(1.75, 2.9, 0.);\n\td3 = max(length(q2.xy - vec2(q2.x, q2.x))- 0.6, length(q2.xy) - 2.9);\n\td2 = min(d2, d3);\n\t\n\t// f\n\tq2 = q - vec3(-0.5,0.,0.);\n\td3 = min(min(sdOne2D(q2, vec2(0.8, 0.5)), sdOne2D(q2 - vec3(1., -2.5, 0.), vec2(0.5, 3.0))), sdOne2D(q2 - vec3(0.,-1.2, 0.), vec2(0.8, 0.5)));\n\td2 = min(d2, d3);\n\t// color + border\n\tbColor = mix(mix(vec3(0.), vec3(1., 0.84, 0.), smoothstep(0., 0.2, abs(d2))), bColor, step(0., d2));\n\t\n\tq2 = q - vec3(0.,0.5,0.);\n\td3 = mix(sdZero2D(q2, vec2(10.0, 1.6)) + mix(0., sin(p.x*2.0)*sin(p.y)*0.2, step(10., q2.y)), 1., max(step(q2.y, -q2.x*1.5 + 2.5), step(q2.y, q2.x*1.5 + 2.5)));\n\tif(d3 < 0.)\n\t{\n\t\tbColor = mix(bColor, vec3(0.8,0.,0.), step(10., length(q.xy)));\n\t\tbColor = mix(vec3(1., 0.84, 0.), bColor, step(10., length(q.xy) + sin(p.x * 4.) * sin(p.y*5.) * 0.6 ));\n\t\tbColor = mix(vec3(0.), bColor, smoothstep(0., 0.4, abs(d3)));\n\t}\n\td2 = min(d2, d3);\n\t\n\t// cross\n\tq2 = q - vec3(0.,13.7,0.);\n\td3 = sdOne2D(q2, vec2(0.35, 2.6));\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\n\td2 = min(d2, d3);\n\t\n\tq2 = q - vec3(0.,15.6,0.);\n\td3 = sdOne2D(q2, vec2(1.0, 0.25));\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\n\td2 = min(d2, d3);\n\t\n\t// top\n\tq2 = q - vec3(3.0,11.,0.);\n\td3 = mix(sdZero2D(q2, vec2(2.0, 0.5)), 1., step(q2.y, -q2.x*0.8 + 1.5)) + sin(p.x * 6.) * sin(p.y*6.) * 0.1;\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\n\td2 = min(d2, d3);\n\t\n\tq2 = q - vec3(-3.0,11.,0.);\n\td3 = mix(sdZero2D(q2, vec2(2.0, 0.5)), 1., step(q2.y, q2.x*0.8 + 1.5)) + sin(p.x * 6.) * sin(p.y*6.) * 0.1;\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\n\td2 = min(d2, d3);\n\t\n\tq2 = q - vec3(0.,12.,0.);\n\td3 = mix(sdZero2D(q2, vec2(2.5, 0.5)), 1., step(q2.y, -1.)) + sin(p.x * 6.) * sin(p.y*6.) * 0.1;\n\tbColor = mix(mix(vec3(0.5), vec3(1., 0.84, 0.), smoothstep(0., 0.3, abs(d3))), bColor, step(0., d3));\t\n\td = min(min(d2, d3), d);\n\t\n\tif(d < 0.){ // Apply illumination to badge\n\t\tbColor += 1.5 * pow(max(dot(normalize(vec3(sin(gTime) * 0., 4., -10) - q), vec3(0.,0.,-1.)), 0.), 150.);\n\t}\n\t\n\t// One\n\tq = p - vec3(13., 26.5, 0.);\n\tfloat dNumber = mix(sdOne2D(q, vec2(2.0, 9.)), 1., smoothstep(-q.x*0.5 - 1.5, -q.x*0.5, q.y-6.));\n\td = min(d, dNumber);\n\tvec3 colorOne = mix(vec3(1., 0.84, 0.), mix(vec3(1.), bgColor, smoothstep(0., 0.2, dNumber)), smoothstep(0., 0.3, abs(dNumber)));\n\n\tvec3 layer1 = mix(colorOne, bColor, smoothstep(0., 0.2, dNumber));\n\tlayer1 = mix(bgColor, layer1, smoothstep(20., 45., gTime));\n\t\n\t\n\t// Zero\n\t//dNumber = length(max(abs(q - vec3(-13., -1.,0.)).xy-vec2(3., 3.).xy,0.0))-5.0;\n\t//dNumber = mix(1., dNumber, smoothstep(-5.5, 0., dNumber));\n\t//d = min(d, dNumber);\n\t//vec3 layer0 = mix(vec3(1., 0.84, 0.), mix(vec3(1.), bgColor, smoothstep(0., 0.2, dNumber)), smoothstep(0., 0.3, abs(dNumber)));\n\t//layer0 = mix(layer0, colorOne, smoothstep(0., 0.2, dNumber));\n\t\n\t// mix badge and number zero\n\t//bColor = mix(bgColor, mix(layer1, layer0, smoothstep(35., 46., gTime)), smoothstep(20., 35., gTime));\n\t\n\t//return bColor;\n\treturn layer1;\n}\n\nvec4 mapColor(vec3 res, vec3 p, out vec2 colorExtra)\n{\n\tcolorExtra = vec2(1.); // r:diffFactor, g:specFactor\n\tvec4 col = vec4(1.);\n\t\n\tfloat currentCup = (68.5 - 3. * (p.x-70.)/140.) - floor(((max(gTime-4., 0.) / (cupsTime-2.)) * 10.)) * 0.1 * 140.;\n\tfloat cupIntensity = step(currentCup, p.x) * max(mix(fract((max(gTime-4., 0.) / (cupsTime-2.))*10.), 1., step(cupsTime, max(gTime-4., 0.))), 1. - step(abs(p.x - currentCup), 140.*0.1));\n\t\n\tif(res.y < 1.5){ //floor\n\t\tcol = vec4(0., 0.,0.2, 1.);\n\t\tcolorExtra = vec2(0.2, 0.1);\n\t}\n\telse if(res.y < 2.5){ //cl\n\t\tcol = mix(vec4(0.), vec4(0.72,0.72,0.72, 0.5), cupIntensity);\n\t\tcolorExtra = vec2(0.1, 0.5);\n\t}\n\telse if(res.y < 3.5){ // lasso\n\t\tcol = vec4(1., 1., 1., 0.);\n\t\tcolorExtra = vec2(0.5, 1.0);\n\t}\n\telse if(res.y < 4.5){ //Cube\n\t\tcol = mix(vec4(0.), vec4(1., 1., 1., 0.), cupIntensity);\n\t}\n\telse if(res.y < 5.5) { // Wall\n\t\tcol = vec4(colorBadge(p), 0.2);\n\t\tcolorExtra = vec2(0.5, 0.1);\n\t}\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tgTime = iTime;\n\t\n\tvec4 soundSampler = texture(iChannel0, vec2(0.5));\n\tsampAvg = (soundSampler.r + soundSampler.b + soundSampler.g) / 3.;\n\t\n\tfloat ar = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = ((uv * 2.) - 1.) * vec2(ar, -1.);\n\t\n\tvec2 mouse = iMouse.xy / iResolution.xy * 2. -1.;\n\tvec3 mouseDir = vec3(-mouse.x*2., 0., 1.) * max((mouse.y+1.) * 20., 0.);\n\t\n\tfloat travelFactor = 1.-clamp(pow((max(0., (gTime-5.)*0.05)), 1.3), 0., 1.);\n\tvec3 ro = vec3(0. + 58.*travelFactor, 1.*travelFactor,-15. + 38.*travelFactor) + mouseDir; //vec3(0. + 60.*travelFactor, 0.0,-15. + 38.*travelFactor);\n\tfloat rotSpeed = 0.;\n\tro = vec3(ro.x * cos(gTime*rotSpeed) - ro.z * sin(gTime*rotSpeed), ro.y, ro.z * cos(gTime*rotSpeed) + ro.x * sin(gTime*rotSpeed));\n\tvec3 camLA = ro + vec3(0. + 6.*travelFactor, 1. + 4.*travelFactor,30.) + vec3(-mouse.x, (mouse.y+1.)*0.5, 1.) * 0.1; //vec3(0. + 60.*travelFactor, 1. + 1.*travelFactor,30.);\n\tvec3 camFront = normalize(camLA - ro);\n\tvec3 camRight = normalize(cross(camFront, vec3(0,1,0)));\n\tvec3 camUp = normalize( cross(camFront, camRight) );\n\t\n\tfloat halffov = 38. * (PI/180.);\n\tfloat scale = tan(halffov);\n\tvec3 rd = normalize(camFront + camRight * uv.x * scale + camUp * uv.y * scale);\n\t\n\tfloat att = 1.;\n\tvec4 totalCol = vec4(0,0,0,1);\n\tvec2 bloom = vec2(0., 9999.);\n\t\n\tfor(int i = 0;i < 2; ++i)\n\t{\n\t\tif(att < 0.01) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvec3 res = intersect(ro, rd);\n\t\tvec4 col = vec4(0,0,0,1);\n\t\tvec3 p = ro + res.x*rd;\n\t\tvec2 colorExtra = vec2(1.);\n\t\t\t\t\t\t  \n\t\tif(res.y > 0.) {\t\n\t\t\tvec4 dif = mapColor(res, p, colorExtra);\n\t\t\t\n\t\t\tvec3 lightOr = vec3(0., 4., 0.);\n\t\t\tvec3 lightDir = normalize(lightOr - p);\n\t\t\t\n\t\t\tvec3 n = calcNormal(p);\n\t\t\tfloat difFac = pow(max(dot(n, lightDir), 0.), 4.) * 0.2;\n\t\t\t\t\t\t\n\t\t\tvec3 refl = normalize(rd + 2.*dot(-rd, n)*n);\n\t\t\tfloat specFac = pow(max(dot(lightDir, refl), 0.), 10.);\n\t\t\tfloat ambFac = 0.05;\n\t\t\t\n\t\t\tcol.rgb += dif.rgb * (ambFac + difFac*(1.-ambFac)) * vec3(250,250,210)/255.;\n\t\t\tcol.rgb += vec3(1.,0.9,0.82)* 2. * specFac * colorExtra.g;\n\t\t\tcol.rgb += (dif.rgb * colorExtra.r);\n\t\t\t\n\t\t\ttotalCol.rgb += col.rgb * att;\n\t\t\t\n\t\t\tro = p;\n\t\t\trd = refl, rd;\n\t\t\t\n\t\t\tatt *= 0.7 * dif.a;\n\t\t}\n\t\telse {\n\t\t\tcol = vec4(0,0,0,1);\n\t\t\tatt = 0.;\n\t\t}\n\t\t\n\t\t// Save Bloom data\n\t\tbloom = mix(vec2(res.z, mix(1., sampAvg, step(45., gTime))), bloom, step(0.5, float(i)));\n\t}\n\t\n\t// Bloom\n\ttotalCol.rgb = mix(totalCol.rgb + vec3(1., 0.84, 0.) * 2.0 * sampAvg * clamp(smoothstep(44., 45., gTime), 0., 1.), totalCol.rgb, smoothstep(0., 2.0, pow(bloom.x, 0.5)));\n\t\n\t// vigneting\n\ttotalCol.rgb = mix(totalCol.rgb, totalCol.rgb * vec3(0), length(uv) * 0.4);\n\t\n\tfragColor = totalCol * smoothstep(0., 1., gTime * 0.1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 21,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}