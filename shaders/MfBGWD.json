{
    "Shader": {
        "info": {
            "date": "1704222017",
            "description": "Recreation of Akiyoshi Kitaoka's [url=http://www.psy.ritsumei.ac.jp/~akitaoka/fringede.html#:~:text=%22-,Primrose%27s%20field,-%22]\"Primrose field\" illusion[/url] which is based on the fringed edges effect.\n\nChange the parameters to get different effects!",
            "flags": 0,
            "hasliked": 0,
            "id": "MfBGWD",
            "likes": 8,
            "name": "Primrose field",
            "published": 3,
            "tags": [
                "2d",
                "illusion",
                "opticalillusion",
                "apparentmotion"
            ],
            "usePreview": 0,
            "username": "sheepmaster",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "const float TILE_SIZE = 36.;\n\n// Add a wave / ripple effect.\nconst bool RIPPLE = true;\nconst float RIPPLE_FREQ = 5./4.;\n\n// Add a \"bulging\" effect.\nconst bool BULGE = false;\n\n// Use both petal colors in the same blossom.\n// This changes the perceived skew of horizontal vs vertical edges.\nconst bool TWO_COLORED_BLOSSOMS = false;\n\n// Flip the two petal colors. This can also affect the skew direction.\nconst bool FLIP = true;\n\nconst float PETAL_SHAPE = 1.;\nconst float PETAL_THICKNESS = .4;\nconst float PETAL_SIZE = .175;\n\nconst ivec3 BG_COLOR_1 = ivec3(0xA0, 0xD7, 0x33);\nconst ivec3 BG_COLOR_2 = ivec3(0x4F, 0xBB, 0x81);\nconst ivec3 FG_COLOR_1 = ivec3(0xFF, 0xFF, 0xFF);\nconst ivec3 FG_COLOR_2 = ivec3(0xCC, 0x00, 0x98);\n\n// Anti-aliasing variant of step() using linear interpolation\nfloat aaStep(float edge, float x, float w) {\n    return clamp((x - edge) / w + 0.5, 0., 1.);\n}\n\n// https://www.shadertoy.com/view/NssXWM\nfloat sdBlobbyCross(in vec2 pos, float he) {\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 tile = (fragCoord - iResolution.xy / 2.) / TILE_SIZE + 0.5;\n\n    const vec3 bgCol1 = vec3(BG_COLOR_1) / 255.;\n    const vec3 bgCol2 = vec3(BG_COLOR_2) / 255.;\n    const vec3 fgCol1 = vec3(FG_COLOR_1) / 255.;\n    const vec3 fgCol2 = vec3(FG_COLOR_2) / 255.;\n    \n    vec2 tileCorner = round(tile);\n    \n    float petalColorSelector;\n    if (RIPPLE) {\n        petalColorSelector = floor((tileCorner.x + tileCorner.y) * RIPPLE_FREQ);\n    } else {\n        petalColorSelector = tileCorner.x + tileCorner.y;\n    }\n    if (BULGE) {\n        petalColorSelector += step(tile.x, 0.5) + step(tile.y, 0.5);\n    }\n    if (TWO_COLORED_BLOSSOMS) {\n        petalColorSelector += abs(tile.x - tileCorner.x) - abs(tile.y - tileCorner.y);\n    }\n    if (FLIP) {\n        petalColorSelector += 1.;\n    }\n    vec3 checkerBoard = mix(bgCol1, bgCol2, mod(floor(tile.x) + floor(tile.y), 2.));\n    vec3 petal = mix(fgCol1, fgCol2, floor(mod(petalColorSelector, 2.)));\n\n    float dist = sdBlobbyCross((tile - tileCorner) / PETAL_SIZE, PETAL_SHAPE);\n    vec3 col = mix(petal, checkerBoard, aaStep(PETAL_THICKNESS, dist, 1./TILE_SIZE));\n\n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}