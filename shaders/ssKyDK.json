{
    "Shader": {
        "info": {
            "date": "1655842978",
            "description": "- first pass at sdf-based grid\n- improved construction method here: https://www.shadertoy.com/view/fsdfRH\n- https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#The_[6,3]_group_family\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ssKyDK",
            "likes": 16,
            "name": "hexagonal tilings",
            "published": 3,
            "tags": [
                "grid",
                "sdf",
                "tiling",
                "tile",
                "euclidean",
                "hexagonal",
                "uniform",
                "tnumber"
            ],
            "usePreview": 0,
            "username": "remaindeer",
            "viewed": 417
        },
        "renderpass": [
            {
                "code": "const float R = 1.0 / 3.0;\nconst float r = R * cos(radians(30.0));\n\nfloat dist(vec2 p, int scene)\n{\n    float d;\n    switch(scene) {\n        case 1: { // hex\n            vec2 v = vec2(3.0 * R, 2.0 * r);\n            vec2 p1 = opRep(p, v);\n            vec2 p2 = opRep(p + v / 2.0, v);\n            d = opUnion(\n                sdHexagon(p1, r),\n                sdHexagon(p2, r)\n            );\n            break;\n        }\n        case 2: { // trihex\n            vec2 v = vec2(2.0 * R, 4.0 * r);\n            vec2 p1 = opRep(p, v);\n            vec2 p2 = opRep(p + v / 2.0, v);\n            vec2 px = vec2(0);\n            d = sdHexagon(p1, r);\n            d = opUnion(d, sdHexagon(p2, r));\n            d = opUnion(d, sdTriangle(opRep(p - vec2(0, r), v), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle(opRep(p - vec2(R, r), v), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle(opRep(p - vec2(R, 3.0 * r), v), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle(opRep(p - vec2(2.0 * R, 3.0 * r), v), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            break;\n        }\n        case 3: { // snubhex\n            mat2 b = mat2(2.5 * R, r, 0.5 * R, 3.0 * r);\n            mat2 binv = inverse(b);\n            vec2 p1 = b * round(binv * p);\n            d = sdHexagon(p - p1, r);\n            d = opUnion(d, sdTriangle((p - vec2(0, r)) - (b * round(binv * (p - vec2(0, r)))), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(R, r)) - (b * round(binv * (p - vec2(R, r)))), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(4.0 * R, r)) - (b * round(binv * (p - vec2(4.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(6.0 * R, r)) - (b * round(binv * (p - vec2(6.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(R, r)) - (b * round(inverse(b) * (p - vec2(R, r)))), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(4.0 * R, r)) - (b * round(binv * (p - vec2(4.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(5.0 * R, r)) - (b * round(binv * (p - vec2(5.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(6.0 * R, r)) - (b * round(binv * (p - vec2(6.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            break;\n        }\n        case 4: { // rhombitrihex\n            mat2 b = mat2(R + r + R / 2.0, R / 2.0 + r, 0, r + R + r);\n            mat2 binv = inverse(b);\n            vec2 p1 = b * round(binv * p);\n            vec2 px;\n            d = sdHexagon(p - p1, r);\n            d = opUnion(d, sdBox((p - vec2(0, R / 2.0 + r)) - (b * round(binv * (p - vec2(0, R / 2.0 + r)))), vec2(R / 2.0)));\n            d = opUnion(d, sdTriangle((p - vec2(R / 2.0, R / 2.0 + r)) - (b * round(binv * (p - vec2(R / 2.0, R / 2.0 + r)))), vec2(0, -(R / 2.0)), vec2(0, (R / 2.0)), vec2(r, 0)));\n            px = ((rotmat2(radians(60.0)) * p) - vec2(0 , R / 2.0 + r));\n            d = opUnion(d, sdBox(px - (b * round(binv * px)), vec2(R / 2.0)));\n            d = opUnion(d, sdTriangle((p - vec2(R + r, 0)) - (b * round(binv * (p - vec2(R + r, 0)))), vec2(0, -(R / 2.0)), vec2(0, (R / 2.0)), vec2(-r, 0)));\n            px = ((rotmat2(radians(120.0)) * p) - vec2(0 , R / 2.0 + r));\n            d = opUnion(d, sdBox(px - (b * round(binv * px)), vec2(R / 2.0)));  \n            break;\n        }\n        case 5: { // dualhex\n            float s2 = R * sqrt(3.0) / 3.0; \n            float s = 2.0 * s2;\n            float R3 = s * sqrt(3.0) / 3.0;\n            float r3 = s * sqrt(3.0) / 6.0;\n            float a = R3 + r3;\n            mat2 b = mat2(1.5 * R, r, 0, 2.0 * r);\n            vec2 px;\n            px = p - vec2(0, r3);\n            px = opRep(px, vec2(s, 2.0 * a));\n            d = sdEquilateralTriangle(px, s2);\n            px = p - vec2(0, r3);\n            px = px - vec2(1.5 * s, a);\n            px = opRep(px, vec2(s, 2.0 * a));\n            d = opUnion(d, sdEquilateralTriangle(px, s2));\n            px = p - vec2(0, R3);\n            px = px - vec2(1.5 * s, 0);\n            px = rotmat2(radians(180.0)) * px;\n            px = opRep(px, vec2(s, 2.0 * a));\n            d = opUnion(d, sdEquilateralTriangle(px, s2));\n            px = p - vec2(0, R3);\n            px = px - vec2(s, a);\n            px = rotmat2(radians(180.0)) * px;\n            px = opRep(px, vec2(s, 2.0 * a));\n            d = opUnion(d, sdEquilateralTriangle(px, s2));\n            break;\n        }\n        case 6: { // dualtrihex\n            mat2 b = mat2(1.5 * R, r, 0, 2.0 * r);\n            vec2 p1 = b * round(inverse(b) * p);\n            vec2 px;\n            for (int i = 0; i < 6; i++) {\n                px = rotmat2(radians(float(i) * 60.0)) * p;\n                px -= b * round(inverse(b) * px);\n                d = opUnion(d, sdRhombus(px - vec2(0, r / 2.0), vec2(R / 2.0 / 2.0, r / 2.0)));\n                px = rotmat2(radians(float(i) * 60.0)) * p;\n                px = px - vec2(R - R / 4.0, 1.5 * r);\n                px -= b * round(inverse(b) * px);\n                d = opUnion(d, sdRhombus(px - vec2(0,r/2.0), vec2(R / 2.0 / 2.0, r / 2.0)));\n            }\n            break;\n        }\n        case 7: { // dualsnubhex\n            float R3 = R * sqrt(3.0) / 3.0;\n            float r3 = R * sqrt(3.0) / 6.0;\n            vec2 v0 = vec2(0, 0);\n            vec2 v1 = vec2(0, r + r3);\n            vec2 v2 = vec2(R / 2.0, r + R3);\n            vec2 v3 = vec2(R, r + r3);\n            vec2 v4 = vec2(R, R3);\n            vec2[] v = vec2[](v0,v1,v2,v3,v4);\n            mat2 b = 2.0 * mat2(2.5 * R, r, 0.5 * R, 3.0 * r);\n            mat2 binv = inverse(b);\n            vec2 px = p;\n            vec2 p1 = px - b * round(binv * px);\n            px = p - vec2(2.5 * R, 1.0 * r);\n            vec2 p2 = px - b * round(binv * px);\n            px = p - vec2(2.0 * R, -2.0 * r);\n            vec2 p3 = px - b * round(binv * px);\n            px = p - vec2(0.5 * R, 3.0 * r);\n            vec2 p4 = px - b * round(binv * px);\n            for (int i = 0; i < 6; i++) {\n                px = p1;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd5Gon(px, v));\n                px = p2;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd5Gon(px, v));\n                px = p3;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd5Gon(px, v));\n                px = p4;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd5Gon(px, v));\n            }\n            break;\n            \n        }\n        case 8: { // dualrhombitrihex\n            float R3 = R * sqrt(3.0) / 3.0;\n            float r3 = R * sqrt(3.0) / 6.0;\n            vec2 v0 = vec2(0, 0);\n            vec2 v1 = vec2(0, r);\n            vec2 v2 = vec2(R / 2.0, r);\n            vec2 v3 = vec2(0.75 * R, r / 2.0);\n            vec2[] v = vec2[](v0,v1,v2,v3);\n            vec2 b = vec2(3.0 * R, 2.0 * r);\n            vec2 p1 = opRep(p, b);\n            vec2 p2 = opRep(p + b / 2.0, b);\n            for (int i = 0; i < 6; i++) {\n                vec2 px = p1;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd4Gon(px, v));\n                px = p2;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd4Gon(px, v));\n            }\n        }\n    }\n   return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // transform\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    p = rotmat2(radians(5.0 * iTime)) * p;\n    m = rotmat2(radians(5.0 * iTime)) * m;\n    \n    // distance\n    int scene = 1 + int(mod(round(iTime), 8.0));\n    float d = dist(p, scene);\n\n    // color\n    vec3 col = vec3(0);\n    col = (d > 0.0) ? col : 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n    float th = 0.075 * R;\n    col *= th - exp(-2.0 * abs(d));\n    col *= th + cos(300.0 * d);\n    col = mix(col, vec3(0.5), 1.0 - smoothstep(0.0, th, abs(d)));\n    \n    if( iMouse.z>0.001 )\n    {\n        d = dist(m, scene);\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) -abs(d)) - 0.005));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float ndot(vec2 a, vec2 b )\n{ \n    return a.x*b.x - a.y*b.y;\n}\n\nmat2 rotmat2(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opUnion( float d1, float d2 )\n{ \n    return min(d1,d2); \n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nvec2 opRep( in vec2 p, in vec2 c )\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\n// r is the half-side\nfloat sdEquilateralTriangle(  in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd4Gon( in vec2 p, in vec2[4] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd5Gon( in vec2 p, in vec2[5] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\n// r is the inradius\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}