{
    "Shader": {
        "info": {
            "date": "1457192086",
            "description": "I was just trying to make a smooth min function, but this one makes an interesting sight:\nreturn min(b,s) - .01/(b-s);",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVGDt",
            "likes": 9,
            "name": "Funky Distance Field",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sphere",
                "distance",
                "fortunatebug"
            ],
            "usePreview": 0,
            "username": "gaboose",
            "viewed": 781
        },
        "renderpass": [
            {
                "code": "#define time iTime\n#define resolution iResolution\n\nfloat box( vec3 p ) {\n\tfloat s = sin(time);\n\tfloat c = cos(time);\n\tp -= vec3(0.,s,1.); // translate\n\tfloat xn = c * p.x - s * p.z;\n\tfloat zn = s * p.x + c * p.z;\n\tp = vec3(xn, p.y, zn); // rotate\n\treturn length(max(abs(p)-vec3(0.4),0.0));\n}\n\nfloat sphere ( vec3 p ) {\n\tp -= vec3(0.,0.,1.);\n\treturn length(p) - 0.5;\n}\n\nfloat scene(vec3 p) {\n\tfloat b = box(p);\n\tfloat s = sphere(p);\n\t\n\t//source of all the funkyness\n\treturn min(b,s) - .01/(b-s);\n\treturn min(b,s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max( resolution.x, resolution.y );\n\tvec2 uv = gl_FragCoord.xy/mx;\n\t\n\t// center image\n\tuv += (1.-resolution.xy/mx)/2.;\n\t\n\t//     screen\n\t//      /|     ___\n\t//     / p    /   \\\n\t//    /  |   |     |     ^ y\n\t// eye  -0-  |     |     |\n\t//    \\  |   |     |     |\n\t//     \\ |    \\___/      o---> z\n\t//      \\|                \\\n\t//                         x\n\t//\n\t// -0- marks the origin point (0,0,0) - middle of the screen\n\t\n\tvec3 p = vec3((uv-.5)*2., 0);\n\tvec3 eye = vec3(0,0,-5); // z coord is the focal length\n\t\n\tvec3 light = normalize(vec3(1.,-1.,1));\n\t\n\tvec3 dir = normalize(p-eye); // ray direction\n\tvec3 color = vec3(scene(p)); // bg\n\t\n\tfor (int i=0; i<64; i++) {\n\t\tfloat d = scene(p);\n\t\tif (d < 0.01) {\n\t\t\tfloat dif = (scene(p-light*0.0001)-d)/0.0001; // distance derivative towards the light source\n\t\t\tcolor = vec3(0.2, 0.1, 0.01)*(dif+1.)*2.;\n\t\t\tbreak;\n\t\t} else if (d > 3.) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// march onwards the distance equal to the closest object in the scene\n\t\t// (this way we know we'll never step over an obstacle)\n\t\tp += dir*d;\n\t}\n\t\n\t//Gamma correction\n\tcolor = pow( color, vec3(1.0/2.2) );\n\t\t\n\tfragColor = vec4( color, 1.0 );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}