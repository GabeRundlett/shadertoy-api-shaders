{
    "Shader": {
        "info": {
            "date": "1457308311",
            "description": "Generative, smooth edged hexagonal prism primitive, shaded with arithmetic PBR Lights.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdcXzn",
            "likes": 212,
            "name": "Geomechanical",
            "published": 3,
            "tags": [
                "distancefield",
                "hexagon",
                "pbr"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 14224
        },
        "renderpass": [
            {
                "code": "// Author : Sebastien Berube\n// Created : March 2015\n// Modified : Jan 2016\n// \n// Composition made from a repeated hexagon prism pattern.\n// Hexagon prism distance function had to be modified to smooth out vertical edges.\n//\n// Sources:\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\n// https://iquilezles.org/articles/raymarchingdf\n// For those interested in the origin of sphere tracing:\n// Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1994)\n// http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.3825\n// Spline\n// http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n//\n// License : Creative Commons Non-commercial (NC) license\n//\n\n//----------------------\n// Constants\nconst float PI = 3.14159;\nconst float SCALE = 1.0;\nconst float MAX_DIST = 1000.0;\nconst float FLOOR_HEIGHT  = 0.0;\nconst float X_REPEAT_DIST = 0.90*SCALE;\nconst float Z_REPEAT_DIST = 1.05*SCALE;\nconst float PRIM_HEIGHT    = 1.0;\nconst float HEX_HALF_WIDTH = 0.26*SCALE;\nconst float GEOMETRY_DISPLACEMENT = 1.00;\nfloat g_time;\n\nstruct AnimationChannels\n{\n    float material_roughness;   //[0-1 range]\n    float geometry_width;       //[0-1 range]\n    float geometry_scale;       //[0-1 range]\n    float geometry_displacement;//[0-1 range]\n\tfloat geometry_smoothness;  //[0-1 range]\n    vec3 camPos;                //[IR range]\n    vec3 camLookAt;             //[IR range]\n};\nAnimationChannels g_animationChannels;\n\n//Material ID enum\nconst int MATERIALID_NONE      = 0;\nconst int MATERIALID_FLOOR     = 1;\nconst int MATERIALID_SKY       = 2;\nconst int MATERIALID_PLASTIC   = 3;\nconst int MATERIALID_METAL     = 4;\n\n//Debug flag enum\nconst int DEBUG_RAYLEN  = 0;\nconst int DEBUG_GEODIST = 1;\nconst int DEBUG_NORMAL  = 2;\nconst int DEBUG_MATID   = 3;\n\nfloat fDEBUG = 0.1;\n\n//Defines\n#define saturate(x) clamp(x,0.0,1.0)\n//----------------------\n// Camera\nstruct Cam { vec3 R; vec3 U; vec3 D; vec3 o; float lens; float zoom; }; //Right, Up, Direction, origin\nCam    CAM_lookAt(vec3 target, float pitchAngleRad, float dist, float theta);\nCam    CAM_mouseLookAt(vec3 at, float dst);\nCam    CAM_animate(vec2 uv, float fTime);\nvec3   CAM_getRay(Cam cam, vec2 uv);\n\n//----------------------\n// Post Process\nvec3 POST_ProcessFX(vec3 c, vec2 uv);\n\n//----------------------\n// Analytic Intersections\nfloat RAYINTERSEC_plane(vec3 o, vec3 d, vec3 po, vec3 pn)\n{\n    return dot(po-o,pn)/dot(d,pn); \n}\n\nstruct repeatInfo\n{\n    vec3 smpl; //object-space, cyclic\n    vec3 anchor; //world space\n};\n    \n#define normalized_wave(a) (0.5*a+0.5)\nrepeatInfo DF_repeatHex(vec3 p)\n{\n    //Repetition\n    float xRepeatDist = X_REPEAT_DIST;\n    float zRepeatDist = Z_REPEAT_DIST*0.5;\n    float latticeX = (fract(p.x/xRepeatDist+0.5)-0.5)*xRepeatDist;\n    float latticeY = (fract(p.z/zRepeatDist+0.5)-0.5)*zRepeatDist;\n    vec2 anchorPosXZ = p.xz-vec2(latticeX,latticeY);\n    p.x = latticeX; //Cyclic coords.\n    p.z = latticeY;\n    \n    //Variation\n    float period = fract(g_time/30.)*3.0;\n    float theta = period*2.0*PI;\n    float overallAmplitude = normalized_wave(-cos(theta)); //Overall amplitude modulation\n    float waveAmplitude = g_animationChannels.geometry_displacement\n                         *normalized_wave(sin(anchorPosXZ.x+anchorPosXZ.y+theta*4.0));\n    float primHeight = FLOOR_HEIGHT+overallAmplitude*waveAmplitude;\n     \n    repeatInfo outData;\n    outData.anchor = vec3(anchorPosXZ[0], primHeight, anchorPosXZ[1]);\n    outData.smpl = p;\n    \n    return outData;\n}\n\n#define zclamp(a) max(a,0.0) //Clamp negative values at zero\nfloat DF_RoundedHex( vec3 p, float width, float height)\n{\n    //Modified version (smooth edges) of the exagon prism found here:\n    //https://iquilezles.org/articles/distfunctions\n    float smoothRadius = g_animationChannels.geometry_smoothness*0.2;\n    width -= smoothRadius*2.0;\n    \n    //Hexagon prism constructed using X,Y,Z symmetry.\n    //Only quadrant 1 needs to be solved, but the joining diagonal to quadrant IV is also\n    //required for distance blending (see db).\n    p = abs(p);\n    \n    //Hexagonal edge distances :\n    //Note : [.8666,0.5] = [sin(PI/3,cos(PI/3)] -> Hexagon edges rotation coeff (60 degrees).\n    float da = (p.x*0.866025+p.z*0.5)-width; //quadrant I diagonal edge distance\n    float db = (p.x*0.866025-p.z*0.5)-width; //quadrant IV diagonal edge distance (needed for blending)\n    float dc = p.z-width; //upper distance\n    \n    vec3 d = zclamp(vec3(da,db,dc));\n    //Note: this is not an euclidian length, therefore this operation slightly distorts our distance field.\n    //Yet, it is harmless to convergence, and does the smoothing job quite well.\n    float dw = length(d)-smoothRadius; //hexagonal part smoothness (blending at 60 deg)\n    float dh = p.y-height;\n    \n    //Now that we have xz distance(dw) and y distance (dh), we can compute the distance \n    //for the given isovalue (the smoothing radius).\n    //Note : internal distance (maxX,maxY,maxZ) is also used to genereate internal signed dist,\n    //       helping convergence when overstepping (very frequent with domain repetition).\n    float externalDistance = length(zclamp(vec2(dh,dw)))-smoothRadius; //Smoothed, unsigned\n\tfloat internalDistance = max(max(da,dc),dh); //Sharp, signed.\n    return min(externalDistance,internalDistance);\n}\n\nstruct DF_out\n{\n    float d;\n    int matID;\n    vec3 objectPos;\n};\n    \n//The distance field composition.\n//::DF_composition\nDF_out DF_composition( in vec3 pos )\n{\n    //Explanation:\n    //https://iquilezles.org/articles/distfunctions\n    DF_out oFloor;\n    DF_out oHexA;\n    DF_out oHexB;\n    \n    oHexA.matID = MATERIALID_PLASTIC;\n    repeatInfo infoA = DF_repeatHex(pos-vec3(0));\n\toHexA.objectPos = infoA.anchor;\n    oHexA.d = DF_RoundedHex( infoA.smpl-vec3(0,infoA.anchor.y,0),\n\t                         g_animationChannels.geometry_width*HEX_HALF_WIDTH, PRIM_HEIGHT );\n    \n    oHexB.matID = MATERIALID_PLASTIC;\n    repeatInfo infoB = DF_repeatHex(pos-vec3(X_REPEAT_DIST*0.5,0, Z_REPEAT_DIST*0.25));\n\toHexB.objectPos = infoB.anchor;\n    oHexB.d = DF_RoundedHex( infoB.smpl-vec3(0,infoB.anchor.y,0),\n\t                         g_animationChannels.geometry_width*HEX_HALF_WIDTH, PRIM_HEIGHT );\n    \n    if(oHexA.d<oHexB.d)\n        return oHexA;\n    else\n        return oHexB;\n}\n\n//The distance field gradient\nvec3 DF_gradient( in vec3 p )\n{\n    //The field gradient is the distance derivative along each axis.\n    //The surface normal follows the direction where this variation is strongest.\n\tconst float d = 0.001;\n\tvec3 grad = vec3(DF_composition(p+vec3(d,0,0)).d-DF_composition(p-vec3(d,0,0)).d,\n                     DF_composition(p+vec3(0,d,0)).d-DF_composition(p-vec3(0,d,0)).d,\n                     DF_composition(p+vec3(0,0,d)).d-DF_composition(p-vec3(0,0,d)).d);\n\treturn grad/(2.0*d);\n}\n\n#define OVERSTEP_COMPENSATION 1\n\n//o = ray origin, d = direction, t = distance travelled along ray, starting from origin\nfloat RAYMARCH_isosurface( vec3 o, vec3 d, float isoSurfaceValue)\n{\n    //Learned from Inigo Quilez DF ray marching :\n    //https://iquilezles.org/articles/raymarchingdf\n    //Original articles (interesting read) :\n    //Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1989)\n    //http://mathinfo.univ-reims.fr/IMG/pdf/hart94sphere.pdf\n    //John C. Hart Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1994)\n    //http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.3825 p. 5.75-5.85\n    \n    const float tolerance = 0.0001;\n    float t = 0.0;\n    float dist = MAX_DIST;\n    #if OVERSTEP_COMPENSATION\n    for( int i=0; i<30; i++ )\n    {\n        dist = DF_composition( o+d*t ).d;\n        dist -= isoSurfaceValue;\n        \n        if( abs(dist)<tolerance*100.0 ) break;\n        t += dist;\n    }\n    \n    t -= Z_REPEAT_DIST/2.0;\n    \n    for( int i=0; i<30; i++ )\n    {\n        dist = DF_composition( o+d*t ).d;\n        dist -= isoSurfaceValue;\n        \n        if( abs(dist)<tolerance ) break;\n        \n        t += min(dist,Z_REPEAT_DIST/5.0);\n    }\n    #else\n    for( int i=0; i<70; i++ )\n    {\n        dist = DF_composition( o+d*t ).d;\n        dist -= isoSurfaceValue;\n        \n        if( abs(dist)<tolerance ) break;\n        t += dist;\n    }\n    #endif\n    \n    return t;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\nfloat RAYMARCH_DFSS( vec3 o, vec3 L, float coneWidth )\n{\n    //Variation of the Distance Field Soft Shadow from : https://www.shadertoy.com/view/Xds3zN\n    //Initialize the minimum aperture (angle tan) allowable with this distance-field technique\n    //(45deg: sin/cos = 1:1)\n    float minAperture = 1.0; \n    float t = 0.0; //initial travel distance, from geometry surface (usually, pretty close)\n    float dist = 10.0;\n    for( int i=0; i<7; i++ )\n    {\n        vec3 p = o+L*t; //Sample position = ray origin + ray direction * travel distance\n        float dist = DF_composition( p ).d;\n        dist = min(dist,t);\n        float curAperture = dist/t; //Aperture ~= cone angle tangent (sin=dist/cos=travelDist)\n        minAperture = min(minAperture,curAperture);\n        //Step size : limit range (0.02-0.42)\n        t += 0.02+min(dist,0.4);\n    }\n    \n    //The cone width controls shadow transition. The narrower, the sharper the shadow.\n    return saturate(minAperture/coneWidth); //Should never exceed [0-1]. 0 = shadow, 1 = fully lit.\n}\n\nfloat RAYMARCH_DFAO( vec3 o, vec3 N, float isoSurfaceValue)\n{\n    //Variation of DFAO from : https://www.shadertoy.com/view/Xds3zN\n    //Interesting reads:\n    //https://docs.unrealengine.com/latest/INT/Engine/Rendering/LightingAndShadows/DistanceFieldAmbientOcclusion/index.html#howdoesitwork?\n    //Implementation notes:\n    //-Doubling step size at each iteration\n    //-Allowing negative distance field values to contribute, making cracks much darker\n    //-Not reducing effect with distance (specific to this application)\n    float MaxOcclusion = 0.0;\n    float TotalOcclusion = 0.0;\n    const int nSAMPLES = 4;\n    float stepSize = 0.11/float(nSAMPLES);\n    for( int i=0; i<nSAMPLES; i++ )\n    {\n        float t = 0.01 + stepSize;\n        //Double distance each iteration (only valid for small sample count, e.g. 4)\n        stepSize = stepSize*2.0;\n        float dist = DF_composition( o+N*t ).d-isoSurfaceValue;\n        //Occlusion factor inferred from the difference between the \n        //distance covered along the ray, and the distance from other surrounding geometry.\n        float occlusion = zclamp(t-dist);\n        TotalOcclusion += occlusion;//Not reducing contribution on each iteration\n        MaxOcclusion += t;\n    }\n    \n    //Here, TotalOcclusion can actually exceed MaxOcclusion, where the rays\n    //get inside the shape and grab negative occlusion values. It does look good\n    //that way IMHO (much darker in the cracks), therefore the maximum occlusion is bumped\n    //25% to allow those cracks to get darker.\n    return saturate(1.0-TotalOcclusion/(MaxOcclusion*1.25));\n}\n\nstruct TraceData\n{\n    float rayLen;  //Ray travel distance\n    vec3  rayDir;  //Ray direction\n    float geoDist; //Distance to geometry (error on final position)\n    vec3  normal;  //Geometry normal\n    vec3  objectPos; //Object position (center)\n    int   matID;     //Material ID\n};\n    \nTraceData new_TraceData()\n{\n    TraceData td;\n    td.rayLen = 0.;\n    td.rayDir = vec3(0);\n    td.geoDist = 0.;\n    td.normal = vec3(0);\n    td.objectPos = vec3(0);\n    td.matID = MATERIALID_NONE;\n    return td;\n}\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    return mix(c,1.3*vec3(4.5,3.5,3.0),fHDR);\n}\n\n//http://refractiveindex.info/?shelf=3d&book=liquids&page=water\nconst float F_DIELECTRIC_PLASTIC = 1.49; //@550nm\nconst float F_DIELECTRIC_WATER   = 1.33; //@550nm\nconst float F_DIELECTRIC_DIAMOND = 2.42; //@550nm\n\n//ior = index of refraction\n//n = refraction index\nvec3 PBR_Fresnel_Schlick_Dielectric(vec3 n, float VdotH)\n{\n\t//<Source : https://en.wikipedia.org/wiki/Schlick%27s_approximation>\n\tvec3 F0 = abs ((1.0 - n) / (1.0 + n));\n\treturn F0 + (1.-F0) * pow( 1. - VdotH, 5.);\n    //</Source : https://en.wikipedia.org/wiki/Schlick%27s_approximation>\n}\n\nvec3 PBR_ABL_Equation(vec3 V, vec3 L, vec3 N, float roughness, float metallic, vec3 ior_n, vec3 ior_k)\n{\n    roughness = max(roughness,0.01);\n    \n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n    //Distribution term\n    //This D value is an approximation of the probability for a given light to bounce into the viewing vector direction.\n\t//It is not necessarily 100% mathematically/physically correct : this is still just a function which has a curve that decently\n    //matches the physical distribution.\n    //<Source: https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59>\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = (NdotH>0.)?alpha2/(PI*den*den):0.0;\n\t//</https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59>\n    \n    //Fresnel term\n    vec3 F = PBR_Fresnel_Schlick_Dielectric(ior_n, VdotH);\n    \n    //Geometric term\n    //<Source: https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59>\n    float Gk = (roughness+1.)*(roughness+1.)/8.; //<-Disney's modification for ABL\n    float Gl = max(NdotL,0.)/(NdotL*(1.0-Gk)+Gk);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-Gk)+Gk);\n    float G = Gl*Gv;\n    //</https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59>\n    \n    //The PBR equation seen pretty much everywhere:\n    //<Source : https://seblagarde.wordpress.com/2015/07/14/siggraph-2014-moving-frostbite-to-physically-based-rendering/ p.14>\n    //<Source : http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    float softTr = 0.2; // Valid range : [0.001-0.25]. Will reduce reflexivity on edges if too high.\n    //Personal addition : This parameter softens up the transition at grazing angles (otherwise too sharp IMHO).\n    vec3 Rs = D*F*G / (4.*NdotV*NdotL*(1.0-softTr)+softTr);\n    //<Source : http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    \n\treturn Rs;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\nvec3 MAT_Plastic(TraceData traceData, vec3 cDiff, vec3 N, vec3 V, vec3 L0, vec3 L1, float dfao, float dfss0, float dfss1)\n{\n    vec3 col = vec3(0);\n    \n    float fRoughness = g_animationChannels.material_roughness;\n    \n    //Ambient directional contribution (3x):\n    //           color*directionalContribution(<normal,ambientDir>)\n    //This give a basic \"ambient\" shading, which varies with normal angle\n    vec3 cAmb  = vec3(0.26,0.24,0.23)*vec3(0.5+0.5*dot(traceData.normal,vec3(+0.08,1,+0.1)))\n               + vec3(0.25,0.25,0.30)*vec3(0.5+0.5*dot(traceData.normal,vec3(-0.28,1,-0.17)))\n               + vec3(0.19,0.25,0.30)*vec3(0.5+0.5*dot(traceData.normal,vec3(+0.28,1,-0.27)));\n    //2 x PBR lights\n    vec3 CL0  = PBR_HDRremap(vec3(1))*PBR_ABL_Equation(V,L0,traceData.normal, fRoughness, 0., vec3(F_DIELECTRIC_PLASTIC), vec3(0));\n    vec3 CL1  = PBR_HDRremap(vec3(1))*PBR_ABL_Equation(V,L1,traceData.normal, fRoughness, 0., vec3(F_DIELECTRIC_PLASTIC), vec3(0));\n    \n    col = cAmb*dfao;\n    col *= saturate(0.30+fRoughness*0.5+0.2*(dfss0+dfss1));\n    col += (dfss0+fRoughness*0.25)*CL0;\n    col += (dfss1+fRoughness*0.25)*CL1;\n    \n    return col*0.75;\n}\n\nfloat SAMPLER_trilinear(vec3 p)\n{\n    //Noise layering trick from Inigo Quilez.\n    //See this for more explanation: https://www.shadertoy.com/view/Ms3SRr\n    const float TEXTURE_RES = 256.0; //Noise texture resolution\n    p *= TEXTURE_RES;   //Computation in pixel space (1 unit = 1 pixel)\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    vec3 t = p-pixCoord;     //Pixel interpolation position, linear range [0-1] (fractional part)\n    t = (3.0 - 2.0 * t) * t * t; //interpolant easing function : linear->cubic\n    vec2 layer_translation = -pixCoord.y*vec2(37.0,17.0)/TEXTURE_RES; //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels -> this is no keypad smashing, but the actual translation embedded in the noise texture).\n    vec2 layer1_layer2 = texture(iChannel0,layer_translation+(pixCoord.xz+t.xz+0.5)/TEXTURE_RES,-100.0).xy; //Note : +0.5 to fall right on pixel center\n    return mix( layer1_layer2.x, layer1_layer2.y, t.y ); //Layer interpolation (trilinear/volumetric)\n}\n\nfloat MAT_remap_angle_probability(float x_01)\n{\n    //cos(jitter) is used to alter probabilty distribution : \n    //it remaps an evenly distributed function into another \n    //one where closer angles are more probable, and wider\n    //angles are less probable.\n    return (1.0-cos(x_01*PI/2.0));\n}\n\nvec3 MAT_addFog(float travelDist, in vec3 color, in vec3 p, in vec3 c_atmosphere)\n{\n    float a = 0.08;\n    float NORMALIZATION_TERM = log((1.+a)/a);\n    float da = travelDist/50.0;\n    da = log((da+a)/a)/NORMALIZATION_TERM;\n    vec3 FinalColor = mix(color,c_atmosphere,saturate(da));\n    return FinalColor;\n}\n\n//::MAT_apply\nvec4 MAT_apply(vec3 pos, TraceData traceData)\n{\n    vec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*pos.y/length(pos.xz),0.,1.));\n    \n    if(traceData.matID==MATERIALID_SKY)\n    {\n        return vec4(c_atmosphere,1.0);\n    }\n    \n    vec4 col = vec4(0);\n    vec3 N = traceData.normal;\n    vec3 V = normalize(-traceData.rayDir);\n    vec3 L0 = normalize(vec3(0.5,1.2,0.3));\n    vec3 L1 = normalize(vec3(-L0.x,L0.y,-L0.z+0.5));\n    \n    //<Jittered AO Samples around Y axis, to reduce artifacts associated with closely repeated geometry>\n    float fNoiseAmplitude = 0.4;\n    float jitter_01 = SAMPLER_trilinear(pos*10.0+g_time*50.0);\n    float t = MAT_remap_angle_probability(jitter_01)*fNoiseAmplitude;\n    vec3 Na = vec3(N.xz*mat2(cos(t),sin(t),-sin(t),cos(t)),N.y).xzy; //Rotate(t)\n    jitter_01 = SAMPLER_trilinear(5.0+pos*9.11);\n    t = MAT_remap_angle_probability(jitter_01)*fNoiseAmplitude;\n    vec3 Nb = vec3(N.xz*mat2(cos(t),-sin(t),sin(t),cos(t)),N.y).xzy; //Rotate(-t)\n    float dfaoA = RAYMARCH_DFAO( pos, Na, 0.02);\n    float dfaoB = RAYMARCH_DFAO( pos, Nb, 0.02);\n    float dfaoAveraged = 0.5*(dfaoA+dfaoB);\n    //</Jittered AO Samples>\n    \n    float dfss0 = RAYMARCH_DFSS( pos+L0*0.01, L0, 0.2);\n    float dfss1 = RAYMARCH_DFSS( pos+L1*0.01, L1, 0.2);\n    \n    if(traceData.matID==MATERIALID_PLASTIC)\n    {\n        col.rgb = MAT_Plastic(traceData, vec3(1), N, V, L0, L1, dfaoAveraged, dfss0, dfss1);\n    }\n    \n    col.rgb = MAT_addFog(traceData.rayLen*0.3, col.rgb, pos, c_atmosphere);\n    \n    return col;\n}\n\nfloat TRACE_zprime(vec3 o, vec3 d)\n{\n    float geometryCeiling = FLOOR_HEIGHT+PRIM_HEIGHT\n\t                       +g_animationChannels.geometry_displacement*GEOMETRY_DISPLACEMENT;\n    float t = RAYINTERSEC_plane(o, d, vec3(0,geometryCeiling,0), vec3(0,1,0));\n    return (t<0.0)?MAX_DIST:t;\n    return t;\n}\n\n//o=ray origin, d=ray direction\n//::TRACE_geometry\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    //Raymarching (the expensive function)\n    TraceData dfTrace;\n    float rayLen = RAYMARCH_isosurface(o,d,0.0);\n    vec3 dfHitPosition = o+rayLen*d;\n    \n    //Additional sample, to gather material ID and other info\n    //(we want that stuff coompiled out of the raymarching loop, it clutters the code and might slow things down)\n    DF_out compInfo = DF_composition( dfHitPosition );\n    rayLen += compInfo.d;\n    dfHitPosition = o+rayLen*d;\n        \n    dfTrace.rayLen     = rayLen;\n    dfTrace.matID      = compInfo.matID;\n    dfTrace.objectPos  = compInfo.objectPos;\n    dfTrace.geoDist    = compInfo.d;\n    dfTrace.rayDir     = d;\n    dfTrace.normal     = normalize(DF_gradient(dfHitPosition));\n    \n    return dfTrace;\n}\n\nvec3 TRACE_debug(TraceData traceData, int elemID)\n{\n    if(elemID==DEBUG_RAYLEN)  return vec3(log(traceData.rayLen)*0.2);\n    if(elemID==DEBUG_GEODIST) return vec3(traceData.geoDist);\n    if(elemID==DEBUG_NORMAL)  return traceData.normal;\n    if(elemID==DEBUG_MATID)   return traceData.matID==MATERIALID_PLASTIC?vec3(1):\n                                     vec3(traceData.matID==MATERIALID_FLOOR?1:0,\n                                          traceData.matID==MATERIALID_METAL?1:0,\n                                          traceData.matID==MATERIALID_SKY?1:0);\n    return vec3(0);\n}\n\nconst int SPLINE_POINT_COUNT = 8;\nstruct SPLINE_CtrlPts\n{\n    vec4 p[SPLINE_POINT_COUNT];\n};\nvec4 SPLINE_PointArray(int i, SPLINE_CtrlPts ctrlPts)\n{\n    //Just a way to get around the fact global arrays do not support random index access.\n    //(only texture/resources)\n    if(i==0 || i==SPLINE_POINT_COUNT  ) return ctrlPts.p[0];\n    if(i==1 || i==SPLINE_POINT_COUNT+1) return ctrlPts.p[1];\n    if(i==2 || i==SPLINE_POINT_COUNT+2) return ctrlPts.p[2];\n    if(i==3) return ctrlPts.p[3];\n    if(i==4) return ctrlPts.p[4];\n    if(i==5) return ctrlPts.p[5];\n    if(i==6) return ctrlPts.p[6];\n    if(i==7) return ctrlPts.p[7];\n    return vec4(0);\n}\n\nvec4 SPLINE_catmullRom(float fTime, SPLINE_CtrlPts ctrlPts)\n{\n    float t = fract(fTime);\n    const float n = float(SPLINE_POINT_COUNT);\n    \n    int idxOffset = int(t*n);\n    vec4 p1 = SPLINE_PointArray(idxOffset,ctrlPts);\n    vec4 p2 = SPLINE_PointArray(idxOffset+1,ctrlPts);\n    vec4 p3 = SPLINE_PointArray(idxOffset+2,ctrlPts);\n    vec4 p4 = SPLINE_PointArray(idxOffset+3,ctrlPts);\n    \n    //For some reason, fract(t) returns garbage on my machine with small values of t.\n    //return fract(n*t);\n    //Using this below yields the same results, minus the glitches.\n    t *= n;\n    t = (t-float(int(t)));\n    \n    //A classic catmull-rom\n    //e.g.\n    //http://steve.hollasch.net/cgindex/curves/catmull-rom.html\n    //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n    vec4 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n               + (-p1+p3)*t\n               + 2.*p2);\n    return val;\n}\n\nvoid ANIM_main(float fTime)\n{\n    float t1 = 0.010*fTime;\n    float t2 = 0.010*fTime+0.03;\n    \n    SPLINE_CtrlPts cameraPosKeyFrames; //100 sec cycle.\n    //                    DATA: PosX,PosY,PosZ,Tilt\n    cameraPosKeyFrames.p[1] = vec4(10.0,2.70,05.0,1.90); //t=00.0s\n    cameraPosKeyFrames.p[2] = vec4(16.0,3.30,08.5,1.00); //t=12.5s\n    cameraPosKeyFrames.p[3] = vec4(20.0,6.80,05.0,2.97); //t=25.0s\n    cameraPosKeyFrames.p[4] = vec4(40.0,3.40,17.5,0.82); //t=37.5s\n    cameraPosKeyFrames.p[5] = vec4(30.0,3.10,27.5,1.97); //t=50.0s\n    cameraPosKeyFrames.p[6] = vec4(25.0,3.20,22.5,1.93); //t=62.5s\n    cameraPosKeyFrames.p[7] = vec4(15.0,3.00,24.5,1.95); //t=75.0s\n    cameraPosKeyFrames.p[0] = vec4(05.0,2.80,12.5,1.20); //t=87.5s\n    vec4 cameraPos = SPLINE_catmullRom(t1,cameraPosKeyFrames);\n    vec4 cameraDir = normalize(SPLINE_catmullRom(t2,cameraPosKeyFrames)-cameraPos);\n        \n    SPLINE_CtrlPts geometryKeyFrames; //25 sec cycle.\n    //                      DATA: round,width,roughness,displacement\n\tgeometryKeyFrames.p[1] = vec4(0.070,1.000,0.30,1.000); //t=00.0s\n    geometryKeyFrames.p[2] = vec4(0.090,0.900,0.50,0.900); //t=01.25s\n    geometryKeyFrames.p[3] = vec4(0.080,1.000,0.20,1.000); //t=02.50s\n    geometryKeyFrames.p[4] = vec4(0.150,0.970,0.50,0.990); //t=03.75s\n    geometryKeyFrames.p[5] = vec4(0.090,0.820,0.50,0.820); //t=05.00s\n    geometryKeyFrames.p[6] = vec4(0.110,0.970,0.50,0.990); //t=06.25s\n    geometryKeyFrames.p[7] = vec4(0.050,0.930,0.50,0.930); //t=07.50s\n    geometryKeyFrames.p[0] = vec4(0.120,0.950,0.50,0.980); //t=08.75s\n    vec4 geoPose = SPLINE_catmullRom(t1*25.0,geometryKeyFrames);\n    \n    g_animationChannels.camPos    = cameraPos.xyz;\n    g_animationChannels.camLookAt = cameraPos.xyz+cameraDir.xyz-vec3(0,cameraPos.w,0);\n    g_animationChannels.geometry_smoothness = geoPose[0];\n    g_animationChannels.material_roughness = 0.45;\n    g_animationChannels.geometry_width = geoPose[1];\n    g_animationChannels.geometry_displacement = GEOMETRY_DISPLACEMENT;\n}\n\nvec3 TRACE_main( vec3 o, vec3 dir, vec2 uv)\n{ \n    float fRemainingAlpha = 1.0;\n    float zStart = TRACE_zprime(o, dir);\n    vec3 pt = o+dir*zStart;\n    vec3 ptGeo = vec3(0);\n    \n    TraceData geometryTraceData;\n    if(zStart< MAX_DIST)\n    {\n        geometryTraceData = TRACE_geometry(pt, dir);\n        geometryTraceData.rayLen += zStart;\n        ptGeo = o+dir*geometryTraceData.rayLen;\n    }\n    else\n    {\n        geometryTraceData.rayLen     = MAX_DIST;\n    \tgeometryTraceData.matID      = MATERIALID_SKY;\n    \tgeometryTraceData.objectPos  = pt;\n    \tgeometryTraceData.geoDist    = 0.0;\n    \tgeometryTraceData.rayDir     = dir;\n        ptGeo = pt;\n    }\n    \n    //return TRACE_debug(geometryTraceData, DEBUG_RAYLEN);  //OK\n    //return TRACE_debug(geometryTraceData, DEBUG_GEODIST); //OK\n    //return TRACE_debug(geometryTraceData, DEBUG_NORMAL);  //OK\n    //return TRACE_debug(geometryTraceData, DEBUG_MATID);   //OK\n    \n    vec4 cFinal = MAT_apply(ptGeo,geometryTraceData);\n        \n    return cFinal.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_time = iTime+2.6; //Time offset for better preview\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    \n    float fTime = g_time+2.1;\n    ANIM_main(fTime);\n    \n    Cam cam = CAM_animate(uv,fTime);\n    vec3 d = CAM_getRay(cam,uv);\n    vec3 c = TRACE_main(cam.o, d, uv);\n    \n    //No supersampling required for most PostProcessFX.\n    c = POST_ProcessFX(c,uv);\n    \n    fragColor = vec4(c,1.0);\n}\n\nvec3 POST_ProcessFX(vec3 c, vec2 uv)\n{\n    //Vignetting\n    float lensRadius = 0.65;\n    uv /= lensRadius;\n    float sin2 = uv.x*uv.x+uv.y*uv.y;\n    float cos2 = 1.0-min(sin2*sin2,1.0);\n    float cos4 = cos2*cos2;\n    c *= cos4;\n    \n    //Gamma\n    c = pow(c,vec3(0.4545));\n    return c;\n}\n\n//----------------------\n// Camera\n//::CAM\nCam CAM_animate(vec2 uv, float fTime)\n{\n    Cam cam;\n    cam.o = g_animationChannels.camPos;\n    cam.D = normalize(g_animationChannels.camLookAt-cam.o);\n\tcam.R = normalize(cross(cam.D,vec3(0,1,0)));\n    cam.U = normalize(cross(cam.R,cam.D));\n    cam.lens = 1.2+0.3*sin(fTime*0.1);\n    cam.zoom = 3.0+sin(fTime*0.1)/cam.lens;\n\treturn cam;\n}\n\nvec3 CAM_getRay(Cam cam,vec2 uv)\n{\n    uv = cam.lens*uv/(cam.lens-length(uv)*length(uv));\n    uv *= cam.zoom;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}