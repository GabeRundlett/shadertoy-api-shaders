{
    "Shader": {
        "info": {
            "date": "1557309538",
            "description": "this shader is a union of \nhttps://www.shadertoy.com/view/3tXGRX\nand\nhttps://www.shadertoy.com/results?query=logeps\n(with up to as many reflections as iterations)\n\n#define qualityPreset 0 is fast\n#define qualityPreset 3 is detaield",
            "flags": 0,
            "hasliked": 0,
            "id": "3tl3Rl",
            "likes": 4,
            "name": "recursive reflect (phong fixed)",
            "published": 3,
            "tags": [
                "phong",
                "reflections",
                "softshadows",
                "mirrorcabinet",
                "dynamiceps",
                "logeps",
                "nsdrf",
                "nshade"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 839
        },
        "renderpass": [
            {
                "code": "//qualityPresets (fps measured on a 2-gb-ram gpu 900px preview size):\n//3=max  , 5-10 fps, maxed detail&&distance&&reflections, mostly constant fps, regardless of cameraAngle\n//2=high ,25-30 fps,        settings (comarable and) almost identical to [mother] \n//1=med  ,45-50 fps, minor artefacts for higher fps, nearly identical to [mother] (tricky to spot differences)\n//0=low  ,maxed fps, speed over quality, runs smooth in fullscreen\n//#define qualityPreset 2\n#define qualityPreset 3\n//#define qualityPreset HW_PERFORMANCE+1  //shadertoy.com canvas specific\n//if qualityPreset<3, some params below are overwritten\n\n\n\n/*todo\nuse\n\n#if HW_PERFORMANCE==0\n#else\n#endif\n\n*/\n\n/*\nthe naive approach to reflections is\nto add a number of reflection functions (in a loop).\nas shown in https://www.youtube.com/watch?v=beNDx5Cvt7M \n(and previous videos of its series)\n\nBut this ReflectLoop (multiple passes of reflection() ) \ncan be merged with the raymarching() Loop\n, if that loop accumulates rayColor on each reflection\n, depending on the surfaces pseudo-BRDF function \n, BRDF() moved inside the raymarching loop\nThis makes a reflection a lot like accumulating a volume-marched cloud\n, with one poerterDuff alpha-compositing for each bounche\n, except that the cloud-volume only exists on a hit surface.\n\nThis shader can have as many reflections as raymarching steps.\nBut for performance reasons\n- limited number of reflections and with shadow() and phong() in them\n  and there is no scattering , so its [SRDF], and no BRDF\n- epsilon varies by RayLength; sigmoid curve, with a logarythmic right end.\n\nLogEps,nSDRF,nShade,phong,reflections,dynamiceps,softShadows,mirrorCabinet\n\n[LogEps] =logarythmic epsilon does not care as much about zFar or lipschitz Continuity or CameraAngles, shallow horizons are fast.\n[dynEps] =precursor to [LogEps], still needed for precise (nearby) reflections.\n[nSDRF]  =(up to) as many (SingleDirectional)-ReFlections as Raymarch iterations\n[nShade] =every reflection has soft shadows calculated.   (only up to 5th shadows would likely be enohugh)\n[phong]  =every reflection has  simple illumination model (only up to 5th shadows would likely be enohugh) https://en.wikipedia.org/wiki/Blinn–Phong_reflection_model\n\n- no exponents higher than 2 (only spheres and planes, nothing parabolic or hyperbolic). orthogonal fOpUnionRound() is quadratic, no DisplacementMaps\n- no more than 1 pointLight, only pointLights\n- no subsurface estimates\n- no texture/pattern model, only single color, gloss, reflectivity, no noises\n- no noisy bokeh scatter trickery and no temporal reprojection and no fresnel-integral estimates\n- no illumination of shadows by reflected light\n- no analytic differentials and no automaticDifferentiation (concave self-reflection has precision issues)\n- no relativistic effects\n\ngrandmother: https://www.shadertoy.com/view/WsfSDB\n[mother]   : https://www.shadertoy.com/view/3tXGRX\nfathers    : https://www.shadertoy.com/results?query=logeps\nself       : https://www.shadertoy.com/view/3tl3Rl\n/**/\n\n//use hg_sdf fOpUnionRound() intead of a min() CSGunion\n//i need at least one simple visual distinction (besides fixing shadows of [mother])\n//the merely c1-consinuous reflecting wall is confusing/unnatural though.\n#define roundUnion 2\n\n/**/\n\n#define shadowEps .0001\n#define shadowIters 32.\n//sharpness of shadows (is acrually ReciprocalBokeh)\n#define shadowBokeh 2.\n\n//start modifiers hardwareSpecific (how old/mobile is your gpu)\n\n//yay for logeps obsoletes distance fog :: https://en.wikipedia.org/wiki/Single-precision_floating-point_format#Single-precision_examples\n//MAX_DISTANCE no longer has an upper bound, the real upper bound here is maxIterRm\n//MAX_DISTANCE <60.\n#define MAX_DISTANCE 100000.\n//#define MAX_DISTANCE 2.e38\n//(pow(2.,127.) *(2.−pow(2.,−23.)) )\n// 3.4028234664e38 == largest normal 32bit float\n\n//machine epsilon is hardware specific, it is exp2(exponentBits-mantissabits)\n//https://en.wikipedia.org/wiki/Machine_epsilon\n//this should be exp2(-23.), but on mobile devices this may default to exp2(-10.) https://en.wikipedia.org/wiki/Half-precision_floating-point_format\n//it is the upper bound of the precision error foreach float operation (qhich quickly accumulates)\n#define mEpsilon 0.01\n//#define mEpsilon exp2(-23.)\n\n//branchlessEmode may be faster on newer GPUs\n//may be faster on older GPUS without branchlessEmode\n#define branchlessEmode\n\n//as extension to branchlessEmode (reqired)\n//smoothstelLinWithLog does the silly thing; mix(linear(),log(),smoothstep(0.,1.,distanceToCamera))\n//instead of a more rational          thing: mix(linear(),log(),step(0.,distanceToCamera))\n//efine smoothstelLinWithLog\n\n\n//end__ modifiers hardwareSpecific\n//start modifiers QualityVsFps\n\n//max number of spheretracking iterations, this one is hard to compromise\n//you want this as high as possible for good screenshots, ideally you want this to accumulate precision over time.\n//with maxIterRm 1026 //the spherical zFar horizon approaches a line (in any angle where you can still se it)\n#define maxIterRm (512.+256.)\n//[maximumNumberOfReflections<=maxIterRm] //if the 4th reflection is missing, its usually noticed. the 6th reflection is rarely missed.\n#define maxbounces maxIterRm\n\n//lipschitz= maximumof abs(rateOfChangeof(distances to Objects) along the ray)\n//lipschitz=maximum lengthOf(nonNormalizedSurfaceNormals) of all measured points on the ray.\n//reciptocalLipschitz=1./lipschitz\n//set this to like .5 or .25 IFF(you have strong deformations in your distance field)\n//set this to <=.79, IFF branchlessEmode is defined\n//else, set this <=1. (the larger the faster, but >1. is not worth the extra Fps)\n#define reciprocalLipschitz .79\n\n/*\n#ifdef branchlessEmode\n #if (reciprocalLipschitz>.97) //this does not take floats, is there any elegant way?\n  #define reciprocalLipschitz .97\n #endif\n#endif*/\n\n//[e*]=[epsilon] sets your heuristic precision of iterative rootsolving\n//, to measure distance between camera and surface in many directions.\n//Larger [e*] increase framerate, but make the world \"chubbier\".\n//Epsilon is split in 2; An inside or outside of..\n//[eThreshold], Radius of sphere around camera,switches [epsilon modes];\n//within a [distance< eThreshold] precision is linear     , significantly better for nearby reflections (necessary for reflections)\n//within a [distance>=eThreshold] precision is logarythmic, chubbier over distance, not precise enough for good reflections\n//, but fast enough for a high fps horizon with eyes near ground level.\n#define eThreshold (1111.) //MAX_DISTANCE/16.\n//see: https://www.shadertoy.com/view/MtSyzh\n//eNear is only relevant for the [distance<eThreshold] case\n#define Epsilon 0.001\n#define eNear (Epsilon*128.) //roughly 256*mEpsilon, because we are linear\n//eFar is only relevant for the [distance>=eThreshold] case\n//if (0.<log(t*t*eFar/s)){close enough}\n//  eNear mode has Better precision for reflections.\n#define eFar mEpsilon    //roughly mEpsilon, because we are logarythmic.\n//beware that eNear and eFar are on very different scales, not to be compared linearily,and barely even exponentially\n//they both are scalars of mEpsilon ONLY for maximum float precision.\n\n//above proudly demoes values that are close top 232bit float precision bounds\n//very small epsilon, verylarge distances, manyreflections, ith 15fps in the peview on 2011 hardware.\n//below are lower quality presets (for fullscreen mode)\n\n#if qualityPreset<3\n #undef  MAX_DISTANCE\n #undef  maxIterRm\n #undef  maxbounces\n #undef  eThreshold\n #undef  eNear\n #undef  eFar\n #undef shadowEps\n #undef shadowIters\n #undef shadowBokeh\n //#undef  branchlessEmode\n #if qualityPreset==2\n  #define maxIterRm   (256.+128.)//more is a bit superficial (in lower resolutions the error is barely visinle)\n  #define MAX_DISTANCE 500.      //comparable to parent:  https://www.shadertoy.com/view/3tXGRX\n  #define maxbounces    20.      //comparable to parent:  https://www.shadertoy.com/view/3tXGRX\n  #define eThreshold MAX_DISTANCE/32. \n//#define eThreshold MAX_DISTANCE/32. is a maximum, or else you see a mirage near the horizon \n  #define eNear mEpsilon*128.*256.\n//#define eNear mEpsilon*128.*256. is maximum (for max fps), or else you have neartby mirages\n  #define eFar  mEpsilon*128.\n//#define eFar  mEpsilon*128. is maximum (for max fps), or else the horiton is a mirage.\n  #define shadowEps (1./256.)\n  #define shadowIters 16.\n  #define shadowBokeh 1.\n #elif qualityPreset==1\n  //qualityPreset==1 is a compromise between 0 and 2 that may reach 50 fps more easily.\n  #define maxIterRm    (128.+64.)  //we need iterations more than distance, this preset equates them\n  #define MAX_DISTANCE (128.+64.)\n  #define maxbounces       5.\n  #define eThreshold MAX_DISTANCE/16.  \n//ripples             are a too low  eThreshold (and mathematically more complex log())\n//haloes or sprinkles are a too high Ethreshold\n  #define eNear mEpsilon*4096.*8.\n  #define eFar  mEpsilon*64.  *8.\n  #define shadowEps (1./64.)\n  #define shadowIters 8.\n  #define shadowBokeh .5\n #elif qualityPreset==0\n  #define maxIterRm    (64.+32.)     //definitely need more iterations than distance.\n  #define MAX_DISTANCE (16.+ 8.)\n  #define maxbounces         3.  \n  #define eThreshold MAX_DISTANCE/4.\n  #define eNear mEpsilon*4096.*16. \n  #define eFar  mEpsilon*64.  *16.\n  //seems okayish, no good clue how to improve\n  #define shadowEps (1./16.)\n  #define shadowIters 4.\n  #define shadowBokeh .25\n #endif\n#endif\n/**/\n\nfloat eMode(float t,float s //logeps 2019-05 (type float)\n){//t=distanceToCamera s=distanceToSurface\n #ifdef branchlessEmode\n ;return mix(log(t*t*eFar/s)  //logeps 2019-05\n            ,(eNear-s)        \n            #ifdef smoothstelLinWithLog\n            ,smoothstep(1.,-1.,t-eThreshold) );}//linear interpolate a linearFunction with a logyrythicFunction! :D\n            #else\n            ,step(             t,eThreshold) );}//branchless substitution for the if() cases below:\n            #endif\n //above branchless version requires        0.<reciprocalLipschitz<=.97<1. //this is a tiny tradeoff. (may be faster on newer GPUs)\n //below branching version works with  ANY  0.<reciprocalLipschitz     <1. //                         (may be faster on older GPUs)\n #else\n ;if(t<eThreshold)return eNear-s//better for short distance reflections\n ;         returnlog(t*t*eFar /s);}//logeps 2018-08 (with dynEps for nearby reflections)\n #endif\n\n\n#define NUM_LIGHTS 1\n#define AMBIENT_LIGHT 1.61\n#define NUM_SPHERES\t6\n\nvec3 colours[9] = vec3[](vec3(0.2,0.4,0.6), vec3(0.0,0.6,0.13), vec3(0.5,0.5,0.55), vec3(0.8,0.7,0.2), vec3(0.18,0.64,0.38), vec3(0.75,0.51,0.1), vec3(0.95,0.41,0.51), vec3(0.3,0.4,0.8), vec3(0.2,0.6,0.6));\nvec3 speculars[9] = vec3[](vec3(.9),vec3(.9),vec3(.9), vec3(.9), vec3(.9), vec3(.9), vec3(.9), vec3(.9), vec3(.9));\nvec3 intensities[9] = vec3[](vec3(.9),vec3(.9),vec3(.8),vec3(.4), vec3(.1,.4,.8), vec3(.25,.51,.1), vec3(.35,.81,.01), vec3(.1,.3,.4), vec3(.9));\nfloat shine[9] = float[](10.,10.,10.,10.,10.,10.,10.,10.,10.);\nfloat reflectivity[9] = float[](.4,.3,.85,.65,.65,.65,.75,.75,.5);\n\n//sdf functions of libraries of iq || mercury\nfloat sdfSphere(vec3 p, vec3 t, float r){return length(p-t)-r;}\n\nfloat sdfBox( vec3 p, vec3 t, vec3 b\n){vec3 d = abs(p - t) - b\n ;return length(max(d,0.0))\n + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdfPlane( vec3 p, vec3 t, vec4 n // n must be normalized\n){return dot(p-t,n.xyz) + n.w;}\n\nfloat sdfTorus( vec3 p, vec3 tr, vec2 t\n){p = p-tr;vec2 q = vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n////////\n\n\nfloat sdPlane (vec3 p, vec3 n, float h) {\n  return dot(p, n) + h;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\n\nfloat distanceToClosest ( vec3 pos, inout int pick ) {\n  Material material;\n  float minDist = 1e10;\n  float dist;\n  vec3 col;\n  object(sdBox(pos.xyz - vec3(-1.0, 0.0, 0.0), vec3(0.5, 0.7, 1e10)), Material(vec3(0.5, 0.3, 0.0), 1.5));\n  object(sdBox(pos.xyz - vec3(-0.5, 0.0, 0.0), vec3(0.5, 0.0, 1e10)), Material(vec3(0.2), 1.0));\n  object(sdBox(vec3(pos.xy - vec2(-0.5, 0.05), mod(pos.z, 0.05) - 0.025), vec3(0.4, 0.05, 0.02)) - 0.005, Material(vec3(2.0), 2.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.0125, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.0625, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.1625, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.2125, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdBox(vec3(pos.xy - vec2(-0.4, 0.15), mod(pos.z + 0.2625, 0.35) - 0.1), vec3(0.2, 0.03, 0.01)), Material(vec3(0.0), 3.5));\n  object(sdPlane(pos, vec3(0.0, 1.0, 0.0), .5), Material(int(mod(pos.x, 0.3) < 0.15) + int(mod(pos.z, 0.3) < 0.15) == 1 ? vec3(0.0) : vec3(1.0), 1.5));\n  object(sdPlane(pos, vec3(0.0, -1.0, 0.0), 3.0), Material(vec3(0.4), 1.2));\n  return minDist;\n}\n\n\n// objects map\nfloat distanceToClosest2(vec3 p, inout int pick\n){float def = MAX_DISTANCE\n ;float d = sdfPlane(p,vec3(0,-5,0),normalize(vec4(0,1,0,1)))\n ;pick = 1\n ;if (d > def){d = def;pick = 0;}\n ;float roundness=float(roundUnion)\n ;float so=\n #ifdef roundUnion\n  fOpUnionRound\n #else\n  opUnion\n #endif\n         (sdfBox(p,vec3(0,roundness,0),vec3(5.5,4.,1. ))\n         ,sdfBox(p,vec3(0)            ,vec3(1. ,4.,5.5)) \n #ifdef roundUnion  \n         ,roundness\n #endif\n )\n ;if (so < d){pick = 2;d = so;}\n    \n    float offset = 0.;\n    float offset2 = 0.;\n    float offsetinc = acos(-1.)*2./float(NUM_SPHERES);\n\t\n\tfor (int s = 0; s < NUM_SPHERES; s ++)\n    {\n        so = sdfSphere(p,vec3(6.5 * cos(iTime+offset),0.75*cos(iTime*offset),6.5 * sin(iTime+offset)),1.0);\n\t\toffset += offsetinc;    \n    \tif (so < d)\n    \t{\n        \tpick = int(mod(float(s),float(6))+3.0);\n        \td = so;\n    \t}\n\n        so = sdfSphere(p,vec3(8.5 * cos(-iTime+offset2),0.95*cos(-iTime*offset2 * 0.33),8.5 * sin(-iTime+offset2)),1.2);\n\t\toffset2 += offsetinc;    \n    \tif (so < d)\n    \t{\n        \tpick = int(mod(float(s),float(6))+3.0);\n        \td = so;\n    \t}\n\n    }\n\n    return d;\n    \n}\n\n\nvec3 estimateNormal(vec3 p, inout int pick){\n    const float EPSILON = 0.001;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getLightPosition(int l\n){return 14.*vec3(cos(iTime*1.61)\n                 ,sin(iTime*sqrt(7.)*.4)*2.+3.\n                 ,sin(iTime)\n                 );}\n\n\nfloat shadowMarch(vec3 ro,vec3 l//raypositionOnSurface, LightPosition\n){int dum=0;l-=ro//l is now lightDirection\n ;vec3 rd=normalize(l)\n ;float tmax=length(l)\n ;float r = 1.,t=1.//tmax/shadowIters\n ;for(float i=0.;i<shadowIters;i++\n ){if(t>=tmax)break\n  ;float d=distanceToClosest(ro+rd*t,dum)\n  ;if(d<shadowEps) return 0.\n  ;r=min(r, shadowBokeh*d)\n  ;t+=d\n  ;}return r;}//https://www.shadertoy.com/view/XllXR4\n\n\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 surfaceNormal, float ambientLight, int materialPick\n){vec3 surfaceColour = vec3(0)\n ;float shadow = 1.\n ;for (int l = 0; l < NUM_LIGHTS; l ++\n ){vec3 lightPos =getLightPosition(l)//=vec3(15,40,35)\n  ,L=normalize(lightPos-surfacePoint)                     \n  ,colour=colours[materialPick]*.01\n  ;float dotLN=dot(L,surfaceNormal)\n  \n  ;\tif (dotLN < 0.0\n  ){// Light not visible from this point on the surface\n   ;colour =  colours[materialPick] * 0.01\n  ;}else{\n   ;float dotRV=dot(normalize(reflect(-L,surfaceNormal)),normalize(eye-surfacePoint))\n      ;if (dotRV<0.){\n        \tcolour = intensities[l] * (colours[materialPick] * dotLN);\n            shadow = min(shadow, shadowMarch(surfacePoint, lightPos));\n    \t}else{\n    \t\tcolour = intensities[l] * (colours[materialPick] * dotLN + speculars[materialPick] * pow(dotRV, shine[materialPick]));\n            shadow = min(shadow, shadowMarch(surfacePoint,lightPos));\n        }}\n        shadow=mix(.2,1.,shadow)\n       ;       surfaceColour += colour;}\n\treturn surfaceColour*shadow*ambientLight;}\n\n#define sat(a) clamp(a,0.,1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0\n ;uv.x *= iResolution.x/iResolution.y//change this, this makes fabr2 cry\n ;float zoom = 1.\n ;int pickTarget = 0 //surfaceID\n ;vec3 lookAt=vec3(0,.5,0)\n ;vec3 camOrigin = vec3(10.0 * cos(iTime * 0.1),6.5 * cos(iTime * 0.5)+4.2,-10.0 * sin(iTime * 0.1))\n ;vec3 forwardVec = normalize(lookAt - camOrigin)\n ;vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec))\n ;vec3 upVec = cross(forwardVec,rightVec)\n ;vec3 centerVec = camOrigin+forwardVec*zoom\n ;vec3 intersectVec=centerVec+uv.x*rightVec + uv.y * upVec\n ;vec3 rayDirection=normalize(intersectVec - camOrigin)\n ;vec3 surfacePoint=vec3(0)\n ;vec3 c = vec3(.1,.3,.44)\n ;vec3 marchVec = camOrigin  \n ;vec3 marchStep = vec3(0)\n ;vec3 surfaceNormal = vec3(0)\n ;c=colours[pickTarget]-rayDirection.y*.5\n ;float distNow=0.\n ,bounceCount=0.\n ,refMixVal=1.\n ,marchDistance=0.\n ,totalDistanceMarched=0.\n ,maxDist=MAX_DISTANCE\n ;for (float i=maxIterRm;i>0.;i--\n ){//ideally loops are countdowns!\n  ;marchStep = marchVec + rayDirection * marchDistance\n  ;distNow = distanceToClosest(marchStep, pickTarget)\n  ;if(eMode(marchDistance,distNow)>0.\n  ){// hit something!\n   ;surfaceNormal = estimateNormal(marchStep, pickTarget)\n   ;c=mix(c,lightSurfacePoint(marchVec , marchStep, surfaceNormal, AMBIENT_LIGHT, pickTarget)\n                 ,sat(reflectivity[pickTarget]+refMixVal+bounceCount*.1))\n   ;if (bounceCount<maxbounces//we have more bounces\n   ){rayDirection = normalize(reflect((rayDirection ), surfaceNormal))\n    ;bounceCount +=1.\n    ;marchDistance =.01   //eNear*16. //.01\n    ;totalDistanceMarched+=marchDistance\n    ;// move camera origin to reflection location\n    ;marchVec = marchStep\n    ;}else{break;//this bounce is the last bounce\n    ;}\n   ;}//end of hit something\n  //i have absolutely no idea why the line below works at all as it is, this should not work, but it does!\n  ;float dynUnderstep=mix(1.,.1,totalDistanceMarched/eThreshold) //eThreshold) // /MAX_DISTANCE)\n  ;dynUnderstep*=reciprocalLipschitz\n  ;totalDistanceMarched+= distNow*dynUnderstep\n  ;marchDistance       += distNow*dynUnderstep\n  ;if(marchDistance>maxDist)break//essential line, or webgl likely crashes.\n \n  ;}//end of marching loop\n  //must add +1 sky\n  ;pickTarget = 0\n  ;c=mix(c,colours[pickTarget]-rayDirection.y*.5\n        ,sat(reflectivity[pickTarget]+bounceCount*.1))\n  ;c*=1.305\n  ;fragColor=vec4(c,1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nSimple scene that displays a raymarched sphere on a floor at (0,0,0)\n\nIncludes minified HG_SDF by Mercury (mercury.sexy/hg_sdf) \nto have all primitives & spatial operators without taking up too much space; \nomitted platonic solids because the original code uses arrays and I was lazy.\n\nSome functions are converted to macros because they would be even smaller when preprocessed.\n\nAnother macro, _M, is really filling up almost identical code as to make the result even smaller,\nthis breaks Shader_Minifier by CTRL_ALT_TEST, just so you know. \n\nAdditionally a lot of float constants are suffixed with '.' to support WebGL\n\nCntains a simple Gradient() function (without normalize, so only works on real linear SDF functions).\nas well as basic diffuse top light, distance fog and horizon gradient.\n\nUse in any way you like, I in no way can take any credit for this.\n\nI tried to be basic & brief, no lighting shadows ao or reflections, no functions where not necessary (texture, trace, shade).\n*/\n\n//somehow this shader god SAVED without the 2 essential structs below\n//, so i rebuild them and resaved, BUT this obviously was not the only error in the shadertoy database\n//or more likely, the webgl implementation py browsers and OS changed AGAIN within 2 years...\n//this may still work nicely in win7???\nstruct Material{vec3 a;float b;};\nstruct object{float a;Material c;};\n\n#define PI acos(-1.)\nconst float _1=.57735026919;\nconst vec2 _A=normalize(vec2(2.61803398875, 1));\nconst vec2 _B=normalize(vec2(1,1.61803398875));\n\n//dist2sphere [r]radius [p]vector2sphereCenter\n#define fSphere(p,r) (length(p)-r)\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n#define fPlane(p,n,d) (dot(p,n)+d)\n\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\nfloat fBox2Cheap(vec2 p,vec2 b){vec2 q=abs(p)-b;return max(q.x,q.y);}\nfloat fBox2(vec2 p,vec2 b){vec2 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(q.x,q.y);}\nfloat fCorner(vec2 p){vec2 q=min(p,0.);return length(max(p,0.))+max(q.x,q.y);}\nfloat fBlob(vec3 p){p=abs(p);if(p.x<max(p.y,p.z))p=p.yzx;if(p.x<max(p.y,p.z))p=p.yzx;float l=length(p),b=max(max(max(dot(p,vec3(_1)),dot(p.xz,_A)),dot(p.yx,_B)),dot(p.xz,_B));return l-1.5-.15*cos(min(sqrt(1.01-b/l)*4.*PI,PI));}\nfloat fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}\nfloat fCapsule(vec3 p,float r,float c){return mix(length(p.xz)-r,length(vec3(p.x,abs(p.y)-c,p.z))-r,step(c,abs(p.y)));}\nfloat fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\nfloat fCapsule(vec3 p,vec3 a,vec3 b,float r){return fLineSegment(p,a,b)-r;}\nfloat fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}\nfloat fCircle(vec3 p,float r){return length(vec2(p.y,length(p.xz)-r));}\nfloat fDisc(vec3 p,float r){float l=length(p.xz)-r;return l<0.?abs(p.y):length(vec2(p.y,l));}\nfloat fHexagonCircumcircle(vec3 p,vec2 h){vec3 q=abs(p);return max(q.y-h.y,max(q.x*0.866+q.z*.5,q.z)-h.x);}\nfloat fHexagonIncircle(vec3 p,vec2 h){return fHexagonCircumcircle(p,vec2(h.x*0.866,h.y));}\nfloat fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}\nvoid pR(inout vec2 p,float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*sqrt(.5);}\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);p*=mod(c,2.)*2.-1.;return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=6.28318530718/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size){vec2 c=floor((p+size*.5)/size);p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5;if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec3 pMod3(inout vec3 p,vec3 s){vec3 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pMirror(inout float p,float d){float s=(p<0.)?-1.:1.;p=abs(p)-d;return s;}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;if(t<0.){p=p-(t+t)*n;}return (t<0.)?-1.:1.;}\nfloat fOpUnionChamfer(float a,float b,float r){return min(min(a,b),(a-r+b)*sqrt(.5));}\nfloat fOpIntersectionChamfer(float a,float b,float r){return max(max(a,b),(a+r+b)*sqrt(.5));}\n#define fOpDifferenceChamfer(a,b,r) fOpIntersectionChamfer(a,-b,r)\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n\n\n//is better near 180deg angles, worse near 90deg angles.\nfloat fOpUnionSoft(float a,float b,float r){float e=max(r-abs(a-b),0.);return min(a,b)-e*e*.25/r;}\n//gets slanted, is bad neat 180deg, otherwise is VERY good.\nv0 ma(v1 a){return max(a.y,a.x);}\nv0 ma(v2 a){return max(a.z,ma(a.xy));}\nv0 ma(v3 a){return max(ma(a.zw),ma(a.xy));}\n#define mi(a)-ma(-a)\nfloat fOpRoundMin(vec2 a,float r){return min(-r,ma(a))+length(max(r+a,0.));}\n//float fOpRoundMax(vec2 a,float r){return-fOpRoundOr(-a,r);}\nfloat fOpRoundD(vec2 a,float r){return fOpRoundMin(vec2(a.x,-a.y),r);}\nfloat fOpRoundE(vec2 a,float r){return fOpRoundMin(vec2(-a.x,a.y),r);}\n#define fOpRoundMax(a,r)-fOpRoundOr(-a,r)\n#define fOpRoundD(a,r) fOpRoundMin(vec2(a.x,-a.y),r)\n#define fOpRoundE(a,r) fOpRoundMin(vec2(-a.x,a.y),r)\n//beware that these are good close to 90deg but rather bad near 180deg.\nfloat fOpUnionRound(float a,float b,float r){vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}\nfloat fOpIntersectionRound(float a,float b,float r){vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nfloat fOpDifferenceRound(float a,float b,float r){return fOpIntersectionRound(a,-b,r);}\n\n//stairs are sharp, underestimating distance.\nfloat fOpStairsMin(vec2 a,float r,float n){float s=r/n,u=a.y-r;return min(mi(a),.5*(u+a.x+abs(mod(u-a.x+s,2.*s)-s)));}\n#define fOpIntersectionStairs(a,r,n)-fOpStairsMin(-a,r,n)\n//float fOpUnionStairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n//#define fOpIntersectionStairs(a,b,r,n)-fOpUnionStairs(-a,-b,r,n)\n//#define fOpDifferenceStairs(a,b,r,n)-fOpUnionStairs(-a,b,r,n)\n\n//column code is pretty ugly, requires 2 subroutines and a shaded define:\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\n//float fOpUnionColumns _M(1.)p.x+=0.70710678118*-r+c*1.41421356237;if(mod(n,2.)-=1.)p.y+=c;pMod1(p.y,c*2.);return min(min(min(length(p)-c,p.x),a),b);}\n//float fOpDifferenceColumns _M(-1.)p.y+=c;p.x-=0.70710678118*(r+c);if(mod(n,2.)-=1.)p.y+=c;pMod1(p.y,c*2.);return-min(min(max(-length(p)+c,p.x),a),b);}\n#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\n\n//todo, make better column code!\n\nfloat fOpPipe(float a,float b,float r){return length(vec2(a,b))-r;}\nfloat fOpEngrave(float a,float b,float r){return max(a,(a+r-abs(b))*sqrt(.5));}\nfloat fOpGroove(float a,float b,float ra,float rb){return max(a,min(a+ra,rb-abs(b)));}\nfloat fOpTongue(float a,float b,float ra,float rb){return min(a,max(a-ra,abs(b)-rb));}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}