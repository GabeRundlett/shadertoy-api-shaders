{
    "Shader": {
        "info": {
            "date": "1714405082",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "4ftXWB",
            "likes": 1,
            "name": "3d experimentations",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "Miaoler",
            "viewed": 70
        },
        "renderpass": [
            {
                "code": "const float FOV=30.;\nconst int MAX_MARCH=512;\nconst float EPSILON=0.001;\n\n//quanternion multiplication\nvec4 qmult(vec4 q1, vec4 q2){\n    float a = q1.x * q2.x - q1.y * q2.y - q1.z * q2.z - q1.w * q2.w;\n    float b = q1.x * q2.y + q1.y * q2.x + q1.z * q2.w - q1.w * q2.z;\n    float c = q1.x * q2.z - q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;\n    float d = q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;\n    return vec4(a,b,c,d);\n}\n\n//get rotation quanternion from axis and rotation angle\nvec4 getrotateq(vec3 axis, float theta){\n    return vec4(cos(theta/2.),sin(theta/2.)*normalize(axis));\n}\n\n//get inverse of a rotation quanternion\nvec4 getinvq(vec4 q){\n    return vec4(q.x,-q.yzw)/length(q)/length(q);\n}\n\n//rotate a 3d vector with a rotation quanternion\nvec3 rotate(vec3 uv, vec4 rotateq){\n    vec4 normuv=vec4(0.,normalize(uv));\n    vec4 rotateqinv=getinvq(rotateq);\n    return length(uv)*qmult(qmult(rotateq,normuv),rotateqinv).yzw;\n}\n\n//smooth min from iq\nfloat smin( float a, float b, float k )\n{\n    k *= 4.0;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - h*h*k*(1.0/4.0);\n}\n\n//smooth max\nfloat smax( float a, float b, float k){\n    return a+b-smin(a,b,k);\n}\n\nfloat sdSphere(vec3 uv, float r){\n    return length(uv)-r;\n}\n\n//pasted from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//twist 3d vector around axis proportional to k\nvec3 twist(vec3 uv, vec3 axis, float k){\n    axis = normalize(axis);\n    vec4 rotq = getrotateq(axis, dot(uv, axis)*k);\n    return rotate(uv, rotq);\n}\n\n//sdf for entire scene\nfloat sdscene(vec3 uv){\n    uv=twist(uv, vec3(0.,0.,1.), 3.1415/2.);\n    return sdBox(uv,vec3(1.));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, float start, float end){\n    float d=start;\n    vec3 v=ro+d*rd;\n    int s = MAX_MARCH;\n    for(int i=1; i<s; i++){\n        \n        float dif=clamp(0., 0.005, sdscene(v));\n        //float dif=abs(sdscene(v));\n        \n        if(dif<EPSILON)return v;\n        d+=dif;\n        v+=dif*rd;\n        if(d>end)s=i+10;\n    }\n    return ro;\n}\n\n//from iq\nfloat softShadow(vec3 ro, vec3 rd, float start, float end,const float k){\n    float d=start;\n    float res=1.;\n    for(int i=1; i<MAX_MARCH; i++){\n        float dif=sdscene(ro+d*rd);\n        //if(dif<EPSILON)return 0.;\n        d+=clamp(dif,0.,0.05);\n        res=min(res,k*dif/d);\n        if(d>end||dif<EPSILON)break;\n    }\n    return clamp(res,0.,1.);\n}\n\n//get normal vector of a point on the scenesdf\nvec3 getNormalVec(vec3 uv){\n    vec3 ch1=uv+vec3(EPSILON,0.,0.);\n    vec3 ch2=uv+vec3(0.,EPSILON,0.);\n    vec3 ch3=uv+vec3(0.,0.,EPSILON); \n    vec3 ch4=uv+vec3(-EPSILON,0.,0.);\n    vec3 ch5=uv+vec3(0.,-EPSILON,0.);\n    vec3 ch6=uv+vec3(0.,0.,-EPSILON); \n    return normalize(vec3(sdscene(ch1),sdscene(ch2),sdscene(ch3))-vec3(sdscene(ch4),sdscene(ch5),sdscene(ch6)));\n}\n\n//lambertian reflectance\nfloat getBrightness(vec3 uv, vec3 light){\n    float d0=sdscene(uv);\n    vec3 d=getNormalVec(uv);\n    return dot(d,normalize(light-uv));\n}\n\nvec3 getColor(vec3 uv){\n    vec3 d=getNormalVec(uv);\n    float m=max(max(abs(d.x),abs(d.y)),abs(d.z));\n    return vec3(.5)+.5*getNormalVec(uv)/m;\n}\n\n//2d screen vector to a direction unit vector in 3d\nvec3 screenToSpacedir(vec2 uv, vec4 rotq){\n    vec3 beforerotate=normalize(vec3(1./tan(radians(FOV)),uv.xy));\n    return rotate(beforerotate,rotq);\n}\n\n//3d point to screen position\nvec2 spaceToScreen(vec3 uv, vec3 cam, vec4 rotq){\n    uv-=cam;\n    uv=rotate(uv,getinvq(rotq));\n    return (uv/tan(radians(FOV))/uv.x).yz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //camera and mouse\n    vec2 mouse=3.*(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 axis1=vec3(0.,1.,0.);\n    vec3 axis2=vec3(0.,0.,1.);\n    vec2 theta=mix(vec2(.2,.4),0.01*vec2(iMouse.x,iMouse.y),step(0.,iMouse.z));\n    float theta1=theta.y;\n    float theta2=theta.x;\n    vec4 rotq=qmult(getrotateq(axis2,theta2),getrotateq(axis1,theta1));\n    vec3 cam=7.*vec3(-cos(theta2)*cos(theta1),-sin(theta2)*cos(theta1),sin(theta1));\n    vec3 camdir=screenToSpacedir(uv,rotq);\n    \n    //light\n    vec3 light=vec3(-4.,2.,0.);\n    \n    //raymarch hit coord\n    vec3 coord=raymarch(cam,camdir,0.,20.);\n    \n    //if hit nothing\n    if(coord==cam) fragColor=vec4(0.);\n    else{\n        float dist=length(coord-cam);\n        float covered=softShadow(coord,normalize(light-coord),0.7,5.,5.);\n        vec3 col=getColor(coord)*max(0.2,covered*getBrightness(coord,light));\n        //col = getColor(coord)*covered;\n        //col = getColor(coord)*getBrightness(coord, light);\n        fragColor = vec4(col,1.0);\n    }\n    \n    //add a little light spot\n    fragColor+=vec4(vec3(.8*smoothstep(0.95,1.,1.-.1*length(light-cam)*length(uv-spaceToScreen(light,cam,rotq)))),0.);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}