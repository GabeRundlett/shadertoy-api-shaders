{
    "Shader": {
        "info": {
            "date": "1584222723",
            "description": "My first attempt in creating a character. I'm not really happy with the lighting yet--I'm no artist--, but I think it's time to finish this one.",
            "flags": 32,
            "hasliked": 0,
            "id": "tlVXRz",
            "likes": 39,
            "name": "Night Sneakings",
            "published": 3,
            "tags": [
                "trash",
                "raymarch",
                "animation",
                "night",
                "character"
            ],
            "usePreview": 1,
            "username": "crocidb",
            "viewed": 3938
        },
        "renderpass": [
            {
                "code": "// Comment these lines to disable the effect\n#define BLOOM\n#define GRAIN\n\n#define BLOOM_SAMPLES 7\nfloat threshold = 0.34;\n\nvec4 bloom(vec2 uv)\n{\n    vec4 bloom = vec4(0.0);\n    vec4 col = vec4(0.0);\n    \n    for (int x = -BLOOM_SAMPLES; x < BLOOM_SAMPLES; x++)\n    for (int y = -BLOOM_SAMPLES; y < BLOOM_SAMPLES; y++)\n    {\n        col = texture(iChannel0, uv + vec2(x, y) * vec2(.0011));\n        float val = ((0.3 * col.r) + (0.59 * col.g) + (0.11 * col.b));\n        if (val < threshold) col = vec4(0.0);\n        \n        bloom += col;\n    }\n    \n    bloom /= float((2 * BLOOM_SAMPLES) * (2 * BLOOM_SAMPLES));\n    \n    return bloom;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec4 color = texture(iChannel0, uv);\n#ifdef BLOOM\n    color += bloom(uv) * 0.7;\n#endif\n\n#ifdef GRAIN\n    vec2 guv = uv + noise(vec2(iTime)) + noise(vec2(uv));\n    float h = hash12(guv)*0.3+0.7;\n    color = color * mix(1.0, h, clamp(color.y, 0.7, 1.0));\n#endif\n    \n    // gamma\n    color.xyz = pow( color.xyz, vec3(0.735) );\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Math\nconst float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\nmat2 rot(float phi)\n{\n    float c = cos(phi);\n    float s = sin(phi);\n\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c));\n}\n\n// SDF\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// SDF Operators\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// Noise\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noiseo(vec2 st)\n{\n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n    vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    \n    float r = mix( mix( dot( random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return r * .5 + .5;\n}\n\nfloat fbm(vec2 st)\n{\n    float value = 0.;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < 4; i++)\n    {\n        value += amplitude * noiseo(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n// Noise and FBM (as seen on iq tutorials)\n//==========================================================================================\n// hashes\n//==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//==========================================================================================\n// noises\n//==========================================================================================\n\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n#if 0\n    p *= 0.3183099;\n    float kx0 = 50.0*fract( p.x );\n    float kx1 = 50.0*fract( p.x+0.3183099 );\n    float ky0 = 50.0*fract( p.y );\n    float ky1 = 50.0*fract( p.y+0.3183099 );\n\n    float a = fract( kx0*ky0*(kx0+ky0) );\n    float b = fract( kx1*ky0*(kx1+ky0) );\n    float c = fract( kx0*ky1*(kx0+ky1) );\n    float d = fract( kx1*ky1*(kx1+ky1) );\n#else\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n#endif\n    \n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\n//==========================================================================================\n// fbm constructions\n//==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n//------------------------------------------------------------------------------------------\n\nfloat fbm_2( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<2; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define NOISE\n\n#define AA 1\n\n#define ZERO (min(iFrame,0))\n#define MAX_STEPS\t\t\t300\n#define MAX_DIST\t\t\t9.0\n#define SURFACE_DIST\t\t0.001\n\nconst vec3 bin_disp = vec3(0.0, -0.72, 1.0);\n\nfloat sin_func(float x, int t)\n{\n    float vi = sin(x);\n    float v = vi;\n    for (int i = 2; i <= t; i++)\n    {\n        v += sin(vi * float(i)) / 10.0;\n    }\n    \n    return v;\n}\n\nfloat cos_func(float x, int t)\n{\n    float vi = cos(x);\n    float v = vi;\n    for (int i = 2; i <= t; i++)\n    {\n        v += cos(vi * float(i)) / 10.0;\n    }\n    \n    return v;\n}\n\nvec2 map(vec3 p, bool complete)\n{\n    vec2 v = vec2(MAX_DIST, 0.0);\n    \n    // floor\n    float f = dot(p + vec3(0.0, 0.3, 0.0), vec3(0.0, 1.0, 0.0)) + 0.0;\n    f = min(f, sdBox(p + vec3(0.0, 0.32, 0.0), vec3(10.2, 0.3, 2.7)) - .025);\n\n    #ifdef NOISE\n    if (p.y < 0.1 && complete) f -= abs(noise(p * 40.0)) * .01 + (p.z > -2.73 ? abs(noise(p * 10.0)) * .03 : 0.0);\n    #endif\n    if (f < v.x) v = vec2(f, 1.0);\n    \n    // trash bin\n    vec3 bin_pos = p + bin_disp;\n    if (sdBox(bin_pos, vec3(1.3, 1.5, 0.6)) < v.x)\n    {\n        float dl = smoothstep(0.3, 1.0, ((p.y + 4.1) * 0.2));\n        float t = sdBox(bin_pos, vec3(1.0 * dl, 0.5, 0.5 * dl));\n        t = min(t, sdBox(bin_pos + vec3(0.0, -0.8 - p.z * 0.3, 0.0), vec3(1.0, 0.2, 0.5))) - .05;\n        t = opSmoothUnion(t, sdBox(bin_pos + vec3(0.0, -0.95 - p.z * 0.3, 0.0), vec3(1.0 * dl, 0.05, 0.5 * dl)) - .07, 0.05);\n        t = opSmoothSubtraction(sdBox(bin_pos + vec3(0.0, -0.3, 0.0), vec3(0.95 * dl, 0.7, 0.45 * dl)), t, 0.19);\n        t = opSmoothUnion(t, sdBox(abs(bin_pos + vec3(0.0, -0.015, 0.51)) + vec3(-0.4, 0.0, 0.0), vec3(0.005 * dl, 0.32, 0.002 * dl)), 0.035);\n        if (t < v.x) v = vec2(t, 3.0);\n    \n        // bin wheels\n        vec3 wheel_pos = abs(bin_pos + vec3(0.0, 0.62, 0.0));\n        wheel_pos.xy *= rot(PI_2);\n        wheel_pos +=  vec3(-0.0, -0.7, -0.4);\n\n        float bw = sdCappedCylinder(wheel_pos, 0.081, 0.016) - .02;\n        if (bw < v.x) v = vec2(bw, 4.0);\n\n        // bin lid\n        float x = iTime * 1.82f;\n        float sx = sin(x * PI_4);\n        float s = sx + sin(2.0 * sx) / 2.0 + sin(3.0 * sx) / 3.0 + sin(4.0 * sx) / 10.0 + sin(5.0 * sx) / 10.0;\n        vec3 lid_pos = bin_pos - vec3(0.0, 0.88, 0.0) - vec3(0.0, 0.0, .5);\n        lid_pos.yz *= rot(PI_4 * 0.4 + ((PI_4) * -smoothstep(2.0, 0.1, exp(s)) * 1.0 - 0.0));\n        lid_pos += vec3(0.0, 0.0, .5);\n\n        float lid = sdBox(lid_pos, vec3(0.99, 0.015, 0.5)) - .03;\n        lid = opSmoothUnion(lid, \n                 sdBox(\n                     abs(\n                         abs(\n                             abs(lid_pos - vec3(0.0, 0.04, 0.0)) \n                             - vec3(0.5, 0.0, 0.0))\n                         - vec3(0.2, 0.0, 0.0))\n                     - vec3(0.1, 0.0, 0.0), vec3(0.005, 0.018, 0.4)) - .01, \n                     0.1);\n\n        if (lid < v.x) v = vec2(lid, 3.0);\n\n        // character\n        float s2 = sin_func(x * PI_2, 6);\n        float s3 = sin_func(x * PI + PI_2, 2);\n        vec3 e_pos = bin_pos - vec3(-0.1 + s2 * 0.35, max(0.1 - s * 0.42 - s3 * 0.06, 0.1), 0.0);\n        \n        if (sdSphere(e_pos, 0.2) < v.x && complete)\n        {\n            float c2 = cos_func(x * PI_2, 6);\n\n            float eh = (cos_func(x * PI_2 + PI_4, 7) * 0.5 + 0.5) * 0.03;\n        \tfloat eh2 = (sin_func(x * PI_2, 8) * 0.5 + 0.5) * 0.03;\n            \n            float eye = sdSphere(abs(e_pos - vec3(0.06 + s2 * .02, max(0.0, -0.25 - s * 0.16), -0.02)) - vec3(0.074, 0.0, 0.0), .038);\n            if (eye < v.x) v = vec2(eye, 6.0);\n\n            float eyes = sdEllipsoid(e_pos - vec3(0.0, eh, 0.0), vec3(.075, .095 + eh, .07));\n            eyes = min(eyes, sdEllipsoid(e_pos - vec3(0.15, eh2, 0.0), vec3(.075, .095 + eh2, .07)));\n            eyes = opSmoothSubtraction(eye - .002, eyes, .04);\n            if (eyes < v.x) v = vec2(eyes, 5.0);\n        }\n    }\n    \n    // wall\n    if (sdBox(p - vec3(0.0, 1.5, 0.2), vec3(20.0, 1.5, 0.5)) < v.x)\n    {\n        float w = sdBox(p - vec3(0.0, 0.0, 0.2), vec3(20.0, 5.0, 0.2));\n        if (w < v.x) v = vec2(w, 2.0);\n\n       \tif (complete)\n        {\n            // wall bricks\n            vec3 c = vec3(0.45, 0.4, 0.0);\n            vec3 bp = p - vec3(0.0, 0.13, 0.01);\n            vec3 bp1 = mod(bp + 0.5 * c, c) - 0.5 * c;\n            bp -= vec3(0.225, 0.2, 0.0);\n            vec3 bp2 = mod(bp + 0.5 * c, c) - 0.5 * c;\n\n            float br = sdBox(bp1, vec3(0.188, 0.06, 0.03));\n            br = min(br, sdBox(bp2, vec3(0.188, 0.06, 0.03))) - .01;\n            \n            #ifdef NOISE\n            float abs_noise_1 = abs(noise(p * 30.0));\n            float abs_noise_2 = abs(noise(p * 5.0));\n            \n            br -= abs_noise_2 * 0.02 + abs_noise_1 * .01;\n            #endif\n            \n            if (br < v.x) v = vec2(br, 7.0);\n        }\n        \n    }\n\n    \n    return v;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0001*e, true).x;\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec3 p;\n    vec2 obj;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = ro + t * rd;\n       \t\n        obj = map(p, true);\n        \n        if (obj.x < SURFACE_DIST || t > MAX_DIST) break;\n        \n        t += obj.x;\n    }\n    \n    obj.x = t;\n    return obj;\n}\n\n// Lighting\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.0016f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tvec2 obj = map(p + n * t, true);\n\t\toc += t - obj.x;\n\t\tt += pow(float(i), 2.2) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.2, 0.0, 1.0);\n}\n\nfloat getVisibility(vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURFACE_DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt || t < MAX_DIST)\n\t{\n\t\tvec2 o = map(p0 + rd * t, false);\n\n\t\tif(o.x < SURFACE_DIST)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.x / t);\n\n\t\tt += o.x;\n\t}\n\n\treturn f;\n}\n\n// Texturing\nvec2 triplanar(vec3 p, vec3 normal)\n{\n    if (abs(dot(normal, vec3(0.0, 1.0, 0.0))) > .8)\n    {\n        return p.xz;\n    }\n    else if (abs(dot(normal, vec3(1.0, 0.0, 0.0))) > .8)\n    {\n        return p.yz;\n    }\n    else\n    {\n        return p.xy;\n    }\n}\n\n// Renderer\nvec3 render(vec2 obj, vec3 p, vec3 rd, vec2 uv)\n{\n    vec3 col;\n    \n    vec3 normal = calcNormal(p);\n    float fog;\n    \n    vec3 background = vec3(0.0, 0.01, 0.05);\n    float n = fbm(uv * 250.0 + iTime * .4);\n    n = smoothstep(0.6, 0.65, n) * .5;\n    background += n;\n    \n    if (obj.x >= MAX_DIST)\n    {\n        col = background;\n    }\n    else\n    {\n        float wallnoise = ((noise(p * 2.0)) * .2 + 0.7);\n        \n        vec3 albedo = vec3(0.0, 0.0, 0.0);\n        fog = pow((obj.x / MAX_DIST), 6.8);\n        float aa = 1.0;\n        \n        float diff_mask = 1.0;\n        float spec_power = 15.0;\n        float spec_mask = 1.0;\n        \n        if (obj.y >= 7.0) // wall bricks\n        {\n            float n = abs(noise(uv * 2.0));\n            albedo = vec3(0.505, 0.194, 0.184) * (n * 0.4 + 0.6);\n            \n            aa = ambientOcclusion(p, normal);\n            spec_power = 20.0;\n            spec_mask = .6 * n + .4;\n        }\n        else if (obj.y >= 6.0) // character eyes\n        {\n            //vec2 uv = triplanar(p, normal) * 3.0;\n            //uv = mod(uv * 0.02 + 0.5, 1.0);\n            albedo = vec3(0.165, 0.154, 0.184);\n            diff_mask = 0.0;\n            spec_power = 90.0;\n            spec_mask = 1.7f;\n        }\n        else if (obj.y >= 5.0) // character eye balls\n        {\n            albedo = vec3(1.365, 1.354, 1.384);\n            diff_mask = 0.0;\n            spec_power = 90.0;\n            spec_mask = .8f;\n        }\n        else if (obj.y >= 4.0) // bin wheel\n        {\n            albedo = vec3(0.105, 0.154, 0.184);\n        }\n        else if (obj.y >= 3.0) // bin\n        {\n            albedo = vec3(0.145, 0.454, 0.194);\n            vec3 d = (bin_disp - vec3(0.0, -1.5, 1.8)) - p;\n            vec3 n = normalize(d);\n            if (dot(normal, n) > 0.0) albedo *= (dot(normal, n) * .5 + .5) * .1;\n            aa = ambientOcclusion(p, normal);\n            spec_power = 90.0;\n            spec_mask = 2.5f;\n             \n        }\n        else if (obj.y >= 2.0) // Walls\n        {\n            albedo = vec3(0.305, 0.354, 0.384) * wallnoise;\n            aa = ambientOcclusion(p, normal);\n        }\n        else if (obj.y >= 1.0) // floor\n        {\n            albedo = vec3(0.285, 0.364, 0.294) * 0.9 * (p.z < -2.73 ? 0.6 : 0.8);\n            aa = ambientOcclusion(p, normal);\n            spec_power = 10.0;\n            spec_mask = 0.5;\n        }\n        \n        // Ambient light\n        #if 1\n        col += albedo * pow(aa, 2.0) * .4;\n        #endif\n        \n        // Top Light\n        #if 1\n        {\n            vec3 light_pos = vec3(-10.0, 20.0, 0.4);\n            vec3 light_col = vec3(0.2, 0.2, 1.0);\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = dot(light_dir, normal);\n            float visibility = getVisibility(p, light_pos, 10.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diff_mask * diffuse * albedo * visibility * light_col * .46;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n        #endif\n        \n        // Street Light\n        #if 1\n        {\n            vec3 light_pos = vec3(6.0, 7.0, -4.0);\n            vec3 light_col = vec3(0.725, 0.285, 0.0);\n            vec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n\n            float diffuse = dot(normalize(light_pos - p), normal);\n            float visibility = getVisibility(p, light_pos, 10.0);\n            float spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diff_mask * diffuse * albedo * visibility * light_col * 2.0;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n        #endif\n        \n    }\n    \n    return mix(col, background, fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(-1.5, 2.0, -4.0);\n    \n// Free camera 1\n#if 0\n    float d = 1.0;\n    float v = ((iMouse.x / iResolution.x) - .5) * -5.;\n    vec3 ta = ro + vec3(sin(v) * d, clamp((iMouse.y / iResolution.y) - .5, -0.5, 0.5), cos(v) * d);\n    \n// Free camera 2\n#elif 0\n    float d = 5.0;\n    float u = iMouse.x / iResolution.x * -5.0;\n    float v = (1.0 - iMouse.y / iResolution.y) * 10.0;\n    vec3 ta = vec3(0.0, 0.6, -1.0);\n    ro = vec3(\n        sin(u) * d,\n        v * .1f * d,\n        cos(u) * d\n    );\n    \n// Fixed camera\n#elif 1 \n    float mx = iMouse.x / iResolution.x * -0.2;\n    float my = (1.0 - iMouse.y / iResolution.y) * 0.5;\n    \n    float d = 5.0;\n    float u = mx + -2.6 + (sin(iTime * .3)) * -0.2;\n    float v = my + 2.6 + sin(iTime * .2) * 0.5;\n    vec3 ta = vec3(0.0, 0.8, -1.0);\n    ro = vec3(\n        sin(u) * d,\n        v * .1f * d,\n        cos(u) * d\n    );\n#endif\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for(int m=ZERO; m<AA; m++)\n    for(int n=ZERO; n<AA; n++)\n    {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else    \n    \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif       \n        // Ray direction\n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n        vec3 vv = normalize(cross(uu, ww));\n        \n        vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.3 * ww);\n        \n        // render\t\n        vec2 obj = rayMarch(ro, rd);\n        vec3 p = ro + obj.x * rd;\n    \n   \t\tvec3 col = render(obj, p, rd, uv);\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n        \n\n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}