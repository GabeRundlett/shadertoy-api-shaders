{
    "Shader": {
        "info": {
            "date": "1538844868",
            "description": "This is an experiment to create an \"AR shader\" by implementing the mainVR-function and using the WebCam texture as background. Use the [url=https://itunes.apple.com/us/app/shadertoy/id717961814]Shadertoy iOS app[/url] to view this shader.",
            "flags": 3,
            "hasliked": 0,
            "id": "XttfRN",
            "likes": 5,
            "name": "Menger Sponge - iOS AR",
            "published": 3,
            "tags": [
                "menger",
                "ar",
                "sponge",
                "ios"
            ],
            "usePreview": 0,
            "username": "reinder",
            "viewed": 1872
        },
        "renderpass": [
            {
                "code": "// Menger Sponge - iOS AR. Created by Reinder Nijhoff 2018\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/XttfRN\n//\n// This is an experiment to create an \"AR shader\" by implementing the mainVR-function and \n// using the WebCam texture as background. If you view this shader with the Shadertoy iOS \n// app[1], you can walk around the cube to view it from all sides.\n//\n// If you don't have an iOS device (or if you don't have the app installed) you can find a\n// screen capture of the shader in action here: https://youtu.be/7woT6cTx-bo.\n//\n// The SDF of this shader is based on the \"Menger Sponge\" shader by Íñigo Quílez:\n// https://www.shadertoy.com/view/4sX3Rn\n//\n// [1] https://itunes.apple.com/us/app/shadertoy/id717961814\n//\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3  di = abs(p) - b;\n  float mc = max(di.x,max(di.y,di.z));\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat boxIntersect( in vec3 ro, in vec3 rd, in vec3 rad ) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return 1e30;\n\treturn tN;\n}\n\nfloat map( in vec3 p ) {\n    float d = sdBox(p,vec3(1.0));\n    float s = .5;\n    for( int m=0; m<4; m++ ) {\n        vec3 a = fract( p*s )-.5;\n        s *= 3.;\n        vec3 r = abs(1.-6.*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/(2.*s);\n\n        if( c>d ) {\n          d = c;\n        }\n    }\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; \n    for( int i=0; i<32; i++ ) {\n\t\tfloat h = map( ro + rd*t );\n       \tfloat y = h*h/(2.0*ph);\n        float d = sqrt(max(0.,h*h-y*y));\n        res = min( res, 8.0*d/max(0.0001,t-y) );\n        ph = h;\n        t += h;//min(h, .1);// clamp( h, 0.02, 0.10 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.5*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.9;\n    }\n    return clamp( 1. - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec4 tex3D( sampler2D sam, in vec3 p, in vec3 n ) {\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in sampler2D tex ) {\n    ro *= 2.; // scale scene\n    const float tmax = 100.;\n    vec3 lightDir = normalize(vec3(0.7,1.,.2));\n    float tmin = boxIntersect(ro, rd, vec3(1.));\n    if (all(lessThan(abs(ro),vec3(1)))) tmin = 0.01;\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ ) {\n\t    float precis = 0.001*t;\n\t    float d = map( ro+rd*t );\n        if( abs(d)<precis || t>tmax ) break;\n        t += d;\n    }\n    \n    vec3 col = texture(tex, uv).xyz;\n    // Use mipmap level 9 to get an average environment color from the webcam texture\n    // used for lighting.\n    vec3 lightColor = pow(.25 + .75 * texelFetch(tex, ivec2(0), 9).rgb, vec3(2.2)) * 3.;\n    \n    if (t < tmax) {\n        vec3 p = ro + t * rd;\n  \t\tvec3 n = calcNormal(p);\n        vec3 ref = reflect(rd, n);\n\n        float ao = .4 + .6 * calcAO(p, n);\n        float sh = .4 + .6 * calcSoftshadow(p, lightDir, 0.005, 1.);\n    \n        float diff = max(0.,dot(lightDir,n)) * ao * sh;\n        float amb  = (.4+.2*n.y) * ao * sh;\n\t\tfloat spe = pow(clamp(dot(ref,lightDir), 0., 1.),8.) * sh * .5;\n           \n        vec3 mat = tex3D(iChannel2, p, n).rgb;\n        col = (amb + diff) * mix(vec3(.4,.6,.8),vec3(.1,.2,.3),mat.r) + spe * dot(mat,mat);\n        col *= lightColor;\n    }\n    \n    // gamma\n    col = mix(col, sqrt(clamp(col,vec3(0),vec3(1))), .95);\n    \n    return clamp(col,vec3(0),vec3(1));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n   \n    float a = .3 * iTime;\n    vec3 ro = 2. * vec3( sin(a), .1, cos(a) );\n    vec3 ta = vec3( 0.0, 0., 0.0 );\n    \n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    vec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, iChannel1 );\n    fragColor = vec4(col,1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\n    ro += vec3(0,0.5,1.5);\n    vec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, iChannel0 );\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}