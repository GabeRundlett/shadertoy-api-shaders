{
    "Shader": {
        "info": {
            "date": "1599943551",
            "description": "One more day.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlBBD3",
            "likes": 3,
            "name": "#876 - Daily Experiments",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "experiment",
                "daily"
            ],
            "usePreview": 0,
            "username": "sixclones",
            "viewed": 276
        },
        "renderpass": [
            {
                "code": "// =========\n// CONSTANTS\n// =========\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 64.0\n#define DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// ========\n// UTILS FN\n// ========\n\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\n  to be used with cos/sin\n  e.g.: `map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n// classical 2d rotation\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\n// =====\n// SCENE\n// =====\n\nfloat boxSDF(vec3 p, vec3 s) {\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n/* scene definition\n  mainly defining a plane deformed to be a wave */\nfloat sceneSDF(vec3 p) {\n  vec3 _p = p;\n    \n  p.yz = rotate2d(p.yz, -0.5 * QP * sin(t) - 0.25);\n  p.xz = rotate2d(p.xz, t + HP * sin(t + HP * sin(2.0 * t)));\n  float box = boxSDF(p, vec3(1.25));\n  float inner = boxSDF(p, vec3(0.45));\n    \n  float f = map01(sin(t + cos(t)), 0.8, 1.0);\n  float sx = abs(f * p.x) - map01(cos(t), 0.0, 0.25);\n  float sy = abs(f * p.y) - map01(sin(t + HP * sin(2.0 * t)), 0.0, 0.25);\n  float sz = abs(f * p.z) - map01(sin(t + sin(-t)), 0.0, 0.25);\n  vec3 columns = vec3(\n      boxSDF(p, vec3(10.0, sx, sx)),\n      boxSDF(p, vec3(sy, 10.0, sy)),\n      boxSDF(p, vec3(sz, sz, 10.0))\n  );\n  \n  //return columns.y;\n  \n  return 0.7 * max(box, -max(-inner, min(columns.x, min(columns.y, columns.z))));\n  return 0.7 * max(-min(columns.x, min(columns.y, columns.z)), max(box, -inner));\n}\n\n// ======\n// RENDER\n// ======\n\n/* compute normales by an estimation of them, offseting the scene computation\n  more details reading here:\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting */\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\n/* compute surface of the object, combining normales, light, ambient etc. */\nvec3 computeSurface(vec3 pos, float f) {\n  vec3 normal = computeNormal(pos);\n\n  vec3 lightPos = vec3(2.5, -5.0, 5.0);\n  vec3 lightColor = vec3(0.01, 0.01, 0.125);\n  float light = max(0.0, dot(normal, lightPos));\n\n  vec3 ambient = vec3(0.01, 0.01, 0.025);\n\n  float fog = 50.0 / pow(f, 3.0);\n\n  return fog * light * lightColor + ambient;\n}\n\n// =====\n// MAIN\n// =====\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0.01);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n\n  // raymarching loop\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      color = computeSurface(pos, f);\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}