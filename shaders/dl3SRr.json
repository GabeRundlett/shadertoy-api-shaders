{
    "Shader": {
        "info": {
            "date": "1685026281",
            "description": "Neon circles blooming into a fractal hexagonal grid.",
            "flags": 0,
            "hasliked": 0,
            "id": "dl3SRr",
            "likes": 28,
            "name": "Triskelion",
            "published": 3,
            "tags": [
                "triangle",
                "circle",
                "kaleidoscope",
                "hexagon",
                "glow",
                "rainbow",
                "rotation"
            ],
            "usePreview": 0,
            "username": "rrrola",
            "viewed": 675
        },
        "renderpass": [
            {
                "code": "// Neon circles blooming into a fractal hexagonal grid.\n// Inspiration:\n// - https://www.shadertoy.com/view/mly3Dd - Glowing concentric circles + square grid folding\n// - https://www.shadertoy.com/view/NtBSRV - Hexagonal cells\n\n//#define TETRASKELION  // if hexagons offend you\n\nvec3 pal(float a) { return 0.5 + cos(3.0*a + vec3(2,1,0)); }  // Biased rainbow color map. Will be squared later.\n\nvec2 fold(vec2 p) {  // Shift and fold into a vertex-centered grid.\n#ifdef TETRASKELION\n  return fract(p) - 0.5;\n#else\n  vec4 m = vec4(2,-1, 0,sqrt(3.));\n  p.y += m.w/3.0;      // center at vertex\n  vec2 t = mat2(m)*p;  // triangular coordinates (x →, y ↖, x+y ↗)\n  return p - 0.5*mat2(m.xzyw) * round((floor(t) + ceil(t.x+t.y)) / 3.0);  // fold into hexagonal cells\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime / 4.0, t2 = t * 0.618034, t3 = t * 1.4142135;  // dissonant timers\n  mat2 M = mat2(cos(t),sin(t), -sin(t),cos(t)) * (1.0 - 0.1*cos(t2));  // rotation and scale: 0.9 [smooth] .. 1.1 [fractal]\n\n  vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;  // y: -1 .. 1\n  float d = 0.5*length(p);  // animation phase is based on distance to center\n\n  vec3 sum = vec3(0);\n  for (float i = 0.0; i < 24.0; i++) {\n    p = fold(M * p);                                            // rotate and scale, fold\n    sum += pal(0.01*i - d + t2) / cos(d - t3 + 5.0*length(p));  // interfering concentric circles\n    // Use pal(...)/abs(cos(...)) for additive circles. I like the interference effect without the abs.\n  }\n  \n  fragColor = vec4(0.0002*sum*sum, 1);  // square the sum for better contrast\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}