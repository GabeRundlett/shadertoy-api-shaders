{
    "Shader": {
        "info": {
            "date": "1657229597",
            "description": "For some reason it was harder for me to understand the concept of creating a square than to create a circle. At least I found how to create a moon!\n\nBut, in a nutshell, seems like you only need to check if the .xy coords are in a range.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdtfW2",
            "likes": 1,
            "name": "005 - Square study",
            "published": 3,
            "tags": [
                "beginner",
                "square",
                "learning"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 197
        },
        "renderpass": [
            {
                "code": "// 2022.07.07 rev 1\n// 2022.07.13 rev 2 - fix a bug where the square calculations was wrong\n\n#define TIME_SKEW 1.0\n\n// returns a constant cycle instead of comming and going from cycle function\n// ______________________________________________\n// | iTime | perSecond | range     |   return   |\n// |_______|___________|___________|____________|\n// |0.1    |0.5        |10         |2.5         |\n// |3.4    |0.5        |10         |17          |\n// |_______|___________|___________|____________|\n//\n// doing a sin() with the return allows you to \"skew through the range\" seamlessly \nfloat constCycle(float perSecond, float range) {\n    return ((iTime + TIME_SKEW + iTimeDelta) * perSecond) * range;\n}\n\n// returns a back and forth 0.0 to 1.0 per second\nfloat cycle(float perSecond) {\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    \n    // step 0.5 is used to reverse the keyframe, to get a coming and going effect\n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float antiAlias = 1.5/iResolution.y; // the larger the screen, the subtle is the antialias\n    \n    // this was a try to rotate the viewport with a \"rotation matrix\" which failed beautifully\n    uv *= vec2(sin(uv.x * constCycle(1., 1.)), cos(uv.y * constCycle(1., 1.)));\n    \n    vec3 c;\n    float s;\n    \n    // mistake moon :)!\n    //if (length(uv - vec2(0.05, 0.)) > sqrt(0.1 * 0.1) && length(uv) < sqrt(0.1 * 0.1 + 0.1 * 0.1)) {\n    //    s = 1.;\n    //}\n\n    // almost a square, almost! look closely\n    //s = smoothstep(0.5 - antiAlias, 0.5 + antiAlias, length(vec2(max(abs(uv.x), 0.35), max(abs(uv.y), 0.35))));\n\n    // success square! \\o/\n    //if (uv.x > -0.25 && uv.y > -0.25 && uv.x < 0.25 && uv.y < 0.25) {\n    //    s = 1.;\n    //}\n    \n    // another way to create a square\n    //vec2 q = vec4(0.25, 0.25);\n    //s = step(uv.x - q.x, 0.) * step(uv.y - q.y, 0.) * step(0., uv.x + q.x) * step(0., uv.y + q.y);\n    \n    // yet another way to do it\n    //s = step(abs(uv.x), 0.25) * step(abs(uv.y), 0.25);\n    \n    // square with antialias\n    // this version tests if the coords are within .25 range - the antiAlias variable.\n    // THIS VERSION HAS A BUG - returns 0.5 when it shouldn't in the X and Y axis\n    //s = length(smoothstep(vec2(0.25-antiAlias), vec2(0.25+antiAlias), abs(uv)));\n    \n    // mistake X pattern\n    // generates a cool effect when uv is changed\n    //s = smoothstep(0.25-antiAlias, 0.25+antiAlias, abs(abs(uv.y) - abs(uv.x)));\n    \n    // mistake prism\n    // at least now I got to know how to make a prism!\n    //s = smoothstep(0.25-antiAlias, 0.25+antiAlias, (abs(uv.x) + abs(uv.y)) *.5);\n    \n    // square with smoothstep, kinda ugly, but works\n    s = 1.-(1.-smoothstep(0.25-antiAlias, 0.25+antiAlias, abs(uv.x))) * (1.-smoothstep(0.25-antiAlias, 0.25+antiAlias, abs(uv.y)));\n    \n    c = mix(\n        vec3(0., 0., .8),\n        vec3(cycle(0.3) * cycle(0.2)),\n        s\n    );\n\n    fragColor = vec4(\n        c, \n        1\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}