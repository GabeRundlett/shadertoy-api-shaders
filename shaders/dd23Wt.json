{
    "Shader": {
        "info": {
            "date": "1668394523",
            "description": "Read the instructions in the Image tab.",
            "flags": 48,
            "hasliked": 0,
            "id": "dd23Wt",
            "likes": 28,
            "name": "Rocket Simulation II",
            "published": 3,
            "tags": [
                "2d",
                "physics",
                "flying",
                "rockets"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 381
        },
        "renderpass": [
            {
                "code": "/*\nq - fire upper left thruster\na - fire lower left thruster\ns - fire main (bottom) thruster\nd - fire lower right thruster\ne - fire upper right thruster\nspace - increase main thrust\n\nOr instead of q/a/s/d/e you can use the arrow keys.\nIf the arrow controls feel inverted to you,\nuncomment CONTROLS_INVERTED in the Common tab.\n\nTry and hit platforms!\n\nPro tip: to right the rocket after a crash landing,\ntry jostling the rocket with small pulses from the\nmain thruster and then catch it before it over\ncorrects with the auxiliary thrusters.\n\nOr just hit r to engage the emergency break :)\n*/\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Setup\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Load rocket state\n    vec4 stateBlock1 = load(iChannel0, ivec2(0, 0));\n    vec4 stateBlock2 = load(iChannel0, ivec2(1, 0));\n\n    vec2 pos = stateBlock1.xy, vel = stateBlock1.zw;\n    float angle = stateBlock2.x, angVel = stateBlock2.y;\n    float score = stateBlock2.z, flag = stateBlock2.w;\n\n    // Camera zoom\n    float zoom = clamp(length(pos - INITIAL_POSITION) / 0.6, 1.0, 5.0);\n\n    // Reference frame\n    vec2 refUv = uv - aspectCorrect(REF_FRAME_POS, aspect);\n    if (abs(refUv.x) < 0.2 && abs(refUv.y) < 0.2) {\n        uv = refUv;\n    }\n\n    // Zoom out on the scene\n    else {\n        uv *= zoom;\n        unit *= zoom;\n    }\n\n    // Draw environment\n    vec2 envUv = uv + pos;\n\n    // Reference grid\n    drawSDF(abs(mod(envUv.x, 0.25) - 0.125), vec3(0.25));\n    drawSDF(abs(mod(envUv.y, 0.25) - 0.125), vec3(0.25));\n\n    vec3 envMaterial = TERRAIN_COLOR;\n    if (envUv.y > PLATFORM_OFFSET - PLATFORM_THICKNESS - 2.0 * unit) { // In the area populated with platforms\n        envMaterial = PLATFORM_COLOR; // Default platform color\n        float cell = round(envUv.x / PLATFORM_SPACING) * PLATFORM_SPACING;\n        for (int platform=0; platform < int(score); platform++) {\n            if (load(iChannel0, ivec2(platform, 1)).x == cell) { // Has been collided with\n                envMaterial = PLATFORM_HIT_COLOR; // Platform color after collision\n                break;\n            }\n        }\n    }\n\n    drawSDF(mapEnv(envUv), envMaterial);\n\n    // Thruster animation\n    vec2 rocketUv = Rotate2D(-angle) * uv;\n\n    // Draw upper left thruster flame\n    if (keypress(iChannel1, KEY_q)) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[0].xy, thrusters[0].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, FLAME_SIZE)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, FLAME_SIZE)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw lower left thruster flame\n    if (keypress(iChannel1, KEY_a) || keypress(iChannel1, LEFT_CONTROL)) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[1].xy, thrusters[1].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, FLAME_SIZE)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, FLAME_SIZE)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw main thruster flame\n    if (keypress(iChannel1, KEY_s) || keypress(iChannel1, MAIN_CONTROL)) {\n        float mainFlameSize = MAIN_FLAME_SIZE;\n        if (keypress(iChannel1, KEY_SPACE)) {\n            mainFlameSize = MAX_FLAME_SIZE;\n        }\n\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[2].xy, thrusters[2].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, mainFlameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, mainFlameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw lower right thruster flame\n    if (keypress(iChannel1, KEY_d) || keypress(iChannel1, RIGHT_CONTROL)) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[3].xy, thrusters[3].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, FLAME_SIZE)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, FLAME_SIZE)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw upper right thruster flame\n    if (keypress(iChannel1, KEY_e)) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[4].xy, thrusters[4].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, FLAME_SIZE)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, FLAME_RATIO * vec2(0.02, FLAME_SIZE)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw rocket\n    rocketUv = vec2(abs(rocketUv.x), rocketUv.y - 0.0243594417401);\n    drawSDF(sdIsosceles(rocketUv + vec2(0.0, 0.09), vec2(0.03, 0.08)), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdIsosceles(Rotate2D(-0.7) * (rocketUv - vec2(0.08, -0.06)), vec2(0.03, 0.08)), vec3(0.0, 1.0, 0.0));\n    drawSDF(sdIsosceles(Rotate2D(-1.8) * (rocketUv - vec2(0.07, 0.03)), vec2(0.03, 0.08)), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdIsosceles(rocketUv, vec2(0.08, 0.2)), vec3(1.0));\n\n    if (abs(refUv.x) > 0.2 || abs(refUv.y) > 0.2) {\n        // Reset zoom\n        uv /= zoom;\n        unit /= zoom;\n\n        // Draw velocity vector\n        vec2 vectorBase = normalize(vel) * 0.2;\n        drawSDF(sdVectorArrow(uv - vectorBase, 0.05 * vel), vec3(1.0));\n\n        // Show score\n        color = digitIn(color, vec3(1.0), uv - aspectCorrect(SCORE_POS, aspect), 100.0, score);\n    }\n\n    // Outline the reference frame\n    float frame = sdBox(refUv, vec2(0.2));\n    drawSDF(abs(frame) - 0.001, vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Constants\n#define PI 3.1415926536\n#define EPS 0.001\n\n#define GRAVITY 0.6\n#define FRICTION 0.5\n\n#define KEY_q     81\n#define KEY_a     65\n#define KEY_s     83\n#define KEY_d     68\n#define KEY_e     69\n#define KEY_r     82\n#define KEY_SPACE 32\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n// Uncomment if the arrow controls feel inverted to you\n//#define CONTROLS_INVERTED\n\n// Alternate controls\n#ifdef CONTROLS_INVERTED\n#define LEFT_CONTROL KEY_RIGHT\n#define MAIN_CONTROL KEY_UP\n#define RIGHT_CONTROL KEY_LEFT\n#else\n#define LEFT_CONTROL KEY_LEFT\n#define MAIN_CONTROL KEY_DOWN\n#define RIGHT_CONTROL KEY_RIGHT\n#endif\n\n// GUI settings\n#define SCORE_POS vec2(-0.52, -0.442)\n#define REF_FRAME_POS vec2(0.359, -0.25)\n\n// Rocket settings\n#define MAIN_THRUST 15.0\n#define MAX_THRUST 25.0 // For main thruster\n#define AUXILIARY_THRUST 0.04 // Mainly for small angle corrections\n\n#define FLAME_SIZE 0.04 // Thruster flame length\n#define FLAME_RATIO 0.4 // Changes inner flame size\n#define MAIN_FLAME_SIZE 0.06\n#define MAX_FLAME_SIZE 0.09 // For main thruster\n\n#define MASS 5.0\n#define MOI 0.000144426534534\n\n#define INITIAL_POSITION vec2(0.0, 2.75)\n\n// Environment settings\n#define PLATFORM_WIDTH 0.65\n#define PLATFORM_THICKNESS 0.075\n#define PLATFORM_OFFSET 2.5\n#define PLATFORM_SPACING 1.5\n#define PLATFORM_VARIATION 20.0\n#define PLATFORM_COLOR vec3(0.6)\n#define PLATFORM_HIT_COLOR vec3(1.0, 0.8, 0.0)\n\n#define TERRAIN_HEIGHT 2.0\n#define TERRAIN_EXAGGERATION 4.0\n#define TERRAIN_ROUGHNESS 2\n#define TERRAIN_COLOR vec3(0.8, 0.5, 0.0)\n\n// Utilities\n#define load(buf, addr) texelFetch(buf, addr, 0)\n#define keypress(buf, key) (texelFetch(buf, ivec2(key, 0), 0).x > 0.5)\n#define aspectCorrect(p, aspect) vec2(p.x * aspect, p.y)\n\nvec2 perp(in vec2 v) {\n    return vec2(-v.y, v.x);\n}\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nvec2 axisAlign(in vec2 p, in vec2 up) {\n    return p * mat2(up.y, -up.x, up);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat noise(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat snoise(in float p) {\n    return mix(noise(floor(p)), noise(ceil(p)), smoothstep(0.0, 1.0, fract(p)));\n}\n\nfloat fbm(in float p) {\n    float val = 0.0;\n    float noiseScale = 1.0;\n    float totalScale = 0.0;\n    for (int oct=0; oct < TERRAIN_ROUGHNESS; oct++) {\n        val += snoise(p) * noiseScale;\n        totalScale += noiseScale;\n        noiseScale *= 0.5;\n        p *= 2.0;\n    }\n\n    return val / totalScale;\n}\n\n// SDFs\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in vec2 q) {\n    p = vec2(abs(p.x), 2.0 * q.y / 3.0 - p.y);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\n// Uncentered isosceles triangle\nfloat sdIsosceles2(in vec2 p, in vec2 q) {\n    p = vec2(abs(p.x), q.y - p.y);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float mag = length(v);\n    p = axisAlign(p, v / mag);\n    return min(sdVerticalLine(p, mag), sdIsosceles(p - vec2(0.0, mag), vec2(0.02, 0.03)));\n}\n\n// Rocket geometry\nconst vec2[11] convexHull = vec2[11](\n    vec2( 0.0000000000,  0.1576927751),\n    vec2(-0.0891532073,  0.0896335932),\n    vec2(-0.1027853330,  0.0312027353),\n    vec2(-0.1201244039, -0.0367098193),\n    vec2(-0.0742338727, -0.0753628805),\n    vec2(-0.0300000000, -0.0923072249),\n    vec2( 0.0300000000, -0.0923072249),\n    vec2( 0.0742338727, -0.0753628805),\n    vec2( 0.1201244039, -0.0367098193),\n    vec2( 0.1027853330,  0.0312027353),\n    vec2( 0.0891532073,  0.0896335932)\n);\n\n// vec4(position, direction)\n// Listed in counterclockwise order from the upper left\nconst vec4[5] thrusters = vec4[5](\n    vec4(-0.0959692702,  0.0604181643, -0.9738476309,  0.2272020947),\n    vec4(-0.0971791383, -0.0560363499, -0.6442176872, -0.7648421873),\n    vec4( 0.0000000000, -0.0923072249,  0.0000000000, -1.0000000000),\n    vec4( 0.0971791383, -0.0560363500,  0.6442176872, -0.7648421873),\n    vec4( 0.0959692702,  0.0604181643,  0.9738476309,  0.2272020947)\n);\n\n// Environment distance\nfloat mapEnv(in vec2 p) {\n    float ground = p.y - TERRAIN_HEIGHT * pow(fbm(p.x), TERRAIN_EXAGGERATION);\n\n    // Randomly positioned platforms\n    float cell = round(p.x / PLATFORM_SPACING) * PLATFORM_SPACING;\n    p -= vec2(cell, PLATFORM_VARIATION * noise(cell) + PLATFORM_OFFSET);\n    float platforms = max(abs(p.x) - PLATFORM_WIDTH, abs(p.y) - PLATFORM_THICKNESS);\n\n    return min(ground, platforms);\n}\n\n// Rocket distance\nfloat mapRocket(in vec2 p) {\n    p = vec2(abs(p.x), p.y - 0.0243594417401);\n    float dist = sdIsosceles(p + vec2(0.0, 0.09), vec2(0.03, 0.08));\n    dist = min(dist, sdIsosceles(Rotate2D(-0.7) * (p - vec2(0.08, -0.06)), vec2(0.03, 0.08)));\n    dist = min(dist, sdIsosceles(Rotate2D(-1.8) * (p - vec2(0.07, 0.03)), vec2(0.03, 0.08)));\n    dist = min(dist, sdIsosceles(p, vec2(0.08, 0.2)));\n    return dist;\n}\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM 💃 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 3; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    ivec2 iAddr = ivec2(fragCoord);\n\n    // Initialize\n    if (iFrame == 0) {\n        if (iAddr == ivec2(0, 0)) fragColor.xy = INITIAL_POSITION;\n    }\n\n    // Update\n    if (iFrame > 0) {\n        if (iAddr.y < 2) { // Save calculations for the relevant pixels\n            // Load previous state\n            fragColor = texelFetch(iChannel0, iAddr, 0);\n            vec4 stateBlock1 = load(iChannel0, ivec2(0, 0));\n            vec4 stateBlock2 = load(iChannel0, ivec2(1, 0));\n\n            vec2 pos = stateBlock1.xy, vel = stateBlock1.zw;\n            float angle = stateBlock2.x, angVel = stateBlock2.y;\n            float score = stateBlock2.z, flag = stateBlock2.w;\n            mat2 basis = Rotate2D(angle);\n\n            // Get the closest rocket vertex to the environment\n            // Note that even checking the full list of vertices is not enough\n            // but since we're being cheap, the convex hull is fine\n            vec2 contact = basis * convexHull[0] + pos;\n            float contactDist = mapEnv(contact);\n            for (int i=1; i < 11; i++) {\n                vec2 newContact = basis * convexHull[i] + pos;\n                float newContactDist = mapEnv(newContact);\n                if (newContactDist < contactDist) {\n                    contact = newContact;\n                    contactDist = newContactDist;\n                }\n\n                // In the rare case of a parallel edge/edge collision\n                // Really only occurs when everything is first initialized\n                if (abs(newContactDist - contactDist) < 1e-6) {\n                    contact = (contact + newContact) / 2.0;\n                }\n            }\n\n            // Align thrust vectors to the rocket's new orientation\n            vec4[5] orientedThrusters;\n            for (int i=0; i < 5; i++) {\n                orientedThrusters[i].xy = basis * thrusters[i].xy;\n                orientedThrusters[i].zw = basis * thrusters[i].zw;\n            }\n\n            // Linear and angular forces\n            vec2 force = vec2(0.0);\n            float torque = 0.0;\n\n            // Apply forces\n            force.y -= GRAVITY * MASS;\n\n            // Upper left thruster\n            if (keypress(iChannel1, KEY_q)) {\n                vec2 newForce = -orientedThrusters[0].zw * AUXILIARY_THRUST;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[0].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Lower left thruster\n            if (keypress(iChannel1, KEY_a) || keypress(iChannel1, LEFT_CONTROL)) {\n                vec2 newForce = -orientedThrusters[1].zw * AUXILIARY_THRUST;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[1].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Main thruster\n            if (keypress(iChannel1, KEY_s) || keypress(iChannel1, MAIN_CONTROL)) {\n                float mainThrust = MAIN_THRUST;\n                if (keypress(iChannel1, KEY_SPACE)) {\n                    mainThrust = MAX_THRUST;\n                }\n\n                vec2 newForce = -orientedThrusters[2].zw * mainThrust;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[2].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Lower right thruster\n            if (keypress(iChannel1, KEY_d) || keypress(iChannel1, RIGHT_CONTROL)) {\n                vec2 newForce = -orientedThrusters[3].zw * AUXILIARY_THRUST;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[3].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Upper right thruster\n            if (keypress(iChannel1, KEY_e)) {\n                vec2 newForce = -orientedThrusters[4].zw * AUXILIARY_THRUST;\n                force += newForce;\n                torque += cross(vec3(orientedThrusters[4].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Collision handling\n            if (contactDist < 0.0) {\n                float d0 = mapEnv(contact);\n                vec2 contactNormal = normalize(vec2(mapEnv(contact + vec2(EPS, 0.0)), mapEnv(contact + vec2(0.0, EPS))) - d0);\n                pos -= contactNormal * d0;\n                contact -= pos;\n\n                // Calculate force required to reflect contact point's velocity\n                // I'm not sure if this is correct, but it gives reasonable behavior\n                vec2 contactVel = vel + vec2(-contact.y, contact.x) * angVel;\n                mat2 sys = mat2(\n                    MOI / MASS + contact.y * contact.y, -contact.x * contact.y,\n                    -contact.x * contact.y, MOI / MASS + contact.x * contact.x\n                );\n\n                vec2 deltaV = FRICTION * reflect(contactVel, contactNormal) - contactVel;\n                vec2 collisionForce = inverse(sys) * (deltaV * MOI / iTimeDelta);\n\n                // Apply force\n                force += collisionForce;\n                torque += cross(vec3(contact, 0.0), vec3(collisionForce, 0.0)).z;\n\n                // Check for a platform collision\n                contact += pos;\n                float cell = round(contact.x / PLATFORM_SPACING) * PLATFORM_SPACING;\n                vec2 toPlatform = contact - vec2(cell, PLATFORM_VARIATION * noise(cell) + PLATFORM_OFFSET);\n                bool newPlatformCollision = abs(toPlatform.x) <= PLATFORM_WIDTH && abs(toPlatform.y) <= PLATFORM_THICKNESS;\n                if (newPlatformCollision) {\n                    // Check if this platform has already been collided with\n                    for (int platform=0; platform < int(score); platform++) {\n                        if (load(iChannel0, ivec2(platform, 1)).x == cell) {\n                            newPlatformCollision = false;\n                            break;\n                        }\n                    }\n                }\n\n                // New high score!\n                if (newPlatformCollision) {\n                    if (iAddr == ivec2(score, 1)) fragColor.x = cell; // Remember this platform\n                    score++;\n                }\n            }\n\n            // Emergency brake!\n            if (keypress(iChannel1, KEY_r)) {\n                force = vec2(0.0);\n                vel = vec2(0.0);\n                angle = 0.0;\n                angVel = 0.0;\n            }\n\n            // Simulation step\n            vel += force / MASS * iTimeDelta;\n            pos += vel * iTimeDelta;\n\n            angVel += torque / MOI * iTimeDelta;\n            angle += angVel * iTimeDelta;\n\n            // Store rocket state\n            if (iAddr == ivec2(0, 0)) fragColor = vec4(pos, vel);\n            if (iAddr == ivec2(1, 0)) fragColor = vec4(angle, angVel, score, flag);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}