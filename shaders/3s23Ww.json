{
    "Shader": {
        "info": {
            "date": "1549147664",
            "description": "A simple voxel raycaster.\ncamera controls via mouse + shift key",
            "flags": 48,
            "hasliked": 0,
            "id": "3s23Ww",
            "likes": 18,
            "name": "Voxel Raycaster",
            "published": 3,
            "tags": [
                "raycasting",
                "raycast",
                "voxel",
                "dda",
                "raycaster"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 1094
        },
        "renderpass": [
            {
                "code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n/*\n    camera controls via mouse + shift key\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\nbool map0(vec3 p)\n{\n    p += 0.5;\n    vec3 b = abs(p);\n    \n    bool r;\n    \n    r =      b.x < 4.0;\n    r = r && b.y < 4.0;\n    r = r && b.z < 4.0;\n    \n    r = r && (b.x > 2.0 || b.y > 2.0);\n    r = r && (b.z > 2.0 || b.y > 2.0);\n    r = r && (b.x > 2.0 || b.z > 2.0);    \n    \n    return r;\n}\n\nbool map1(vec3 p)\n{\n    float o = 2.0; \n    \n    return map0(p + vec3( -o, 0.0, 0.0)) != \n           map0(p + vec3(  o, 0.0, 0.0)) != \n           map0(p + vec3(0.0,  -o, 0.0)) != \n           map0(p + vec3(0.0,   o, 0.0)) != \n           map0(p + vec3(0.0, 0.0,  -o)) != \n           map0(p + vec3(0.0, 0.0,   o));\n}\n\n#define map map1\n\nvec3 minmask(vec3 v)\n{\n    return vec3(v.x <= v.y && v.x <= v.z,\n                v.y <  v.z && v.y <  v.x,\n                v.z <  v.x && v.z <= v.y);\n}\n\nbool VoxelRaycast(vec3 ro, vec3 rd, out vec3 vp, out vec3 N, out float t)\n{\n\tvp = floor(ro);\n\t\n    vec3 ri = 1.0/rd;\n    \n\tvec3 rs = vec3(rd.x < 0.0 ? -1.0 : 1.0,\n                   rd.y < 0.0 ? -1.0 : 1.0,\n                   rd.z < 0.0 ? -1.0 : 1.0);\n                     \n\tvec3 off = vec3(rd.x < 0.0 ? 0.0 : ri.x,\n                    rd.y < 0.0 ? 0.0 : ri.y,\n                    rd.z < 0.0 ? 0.0 : ri.z) - ro * ri;\n\n\tvec3 mm = vec3(0.0);\n    vec3 t3 = vec3(0.0);\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 24; i++) \n\t{\n\t\tif(map(vp)) { hit = true; break; }\n        \n        t3 = vp * ri + off;\n\t\t\n        mm = minmask(t3);\n        \n        vp += mm * rs;\n\t}\n\t\n\tN = -rs * mm;\n    t = dot(t3, mm);\n\n\treturn hit;\n}\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\nbool SceneRayCast(vec3 rp, vec3 rd, out vec3 c, out vec3 n, out vec3 p)\n{\n    vec3 vp; float t;\n\tbool hit = VoxelRaycast(rp, rd, /*out:*/ vp, n, t);\n    \n    if(!hit) return false;\n\n    vec3 fm = abs(n);\n\n    p = rp + rd * t; \n    p = mix(p, round(p), equal(fm, vec3(1.0))) + (n * 1e-5);\n\n    bvec3 b = greaterThan(abs(fract(p) - 0.5), vec3(0.45));\n    float wf = ((b.z && (b.x || b.y)) || (b.x && (b.y || b.z)) ? 0.0 : 1.0);\n\n    c = (fm + fm.yzx*0.125) * wf;\n\n    return true;\n}\n\n\nvec3 EvalSceneCol(vec3 rp, mat3 cmat, float focalLen, vec2 uv)\n{    \n    //if(map(rp-0.5)) {return vec3(0.0);}\n    \n    vec3 col = vec3(0.8);  \n    \n    vec2 tc = uv * (1.0 / (iResolution.xx*0.5)) - vec2(1.0, iResolution.y/iResolution.x);\n    \n    vec3 rd = normalize(cmat * vec3(tc, focalLen)); \n\n#if 1\n    vec2 tt; \n    float res = Intersect_Ray_Cube(rp, rd, vec3(6.0 + 1e-5), /*out:*/ tt);\n    \n    if(res == -1.0) { return col; }\n    \n    if(res == 1.0)\n    {\n    \trp += rd * tt.x;\n    }\n#endif\n    \n\tvec3 c, n, p;\n    if(SceneRayCast(rp, rd, /*out:*/ c, n, p))\n    {\n        vec3 r = n * (2.0 * dot(n, -rd)) + rd;\n        \n        col = c;\n        \n        vec3 n0;\n        if(!SceneRayCast(p, r, /*out:*/ c, n0, p)) {c = vec3(0.8);}\n        \n        col = mix(col, c, mix(0.05, 1.0, Pow5(1.0 - dot(-rd, n))));\n    }\n\n    return col;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;    \n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n\n    //vec2 lightAng = vec2(Pi * 0.0, Pi * 0.5);\n    //lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    //lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    \n    vec2 ang = vec2(-0.1 * Pi, -Pi * 0.1);\n    ang += mouseAccu.xy * 0.008;\n\n    //float fov = Pi * 0.6;\n    float focalLen = 0.6;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    vec3 cpos = -cmat[2] * exp2(1.5 + mouseAccu.w * 0.02);\n    \n\n#if 0\n    // 1 sample\n    col = vec3(EvalSceneCol(cpos, cmat, focalLen, uv0));\n#elif 1\n    // 3 samples ( https://www.shadertoy.com/view/3tdBWM )\n    uvec2 uvi = uvec2(uv);\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n\tif(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 2d Roberts sequence\n    const uint r0 = 3242174893u;\n    const uint r1 = 2447445397u;\n\n    float u = float((uvi.x * r0) + (uvi.y * r1)) * (1.0 / 4294967296.0);\n\n    if((uint(iFrame) & 1u) != 0u) u += 0.5;\n\n    for(float i = 0.0; i < 3.0; ++i) \n    {\n        float ang = (Pi*0.666667) * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang))*0.333333;\n\n        col += vec3(EvalSceneCol(cpos, cmat, focalLen, uv0 + off));\n    }\n    col *= 0.333333; \n#endif\n    \n    \n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n}\n#endif\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define Frame float(iFrame)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// persistent state stuff\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast   = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}