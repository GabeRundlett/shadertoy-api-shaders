{
    "Shader": {
        "info": {
            "date": "1520381616",
            "description": "Using an ordered pattern of samples for motion blur and depth of field, with a low number of samples per pixel.\n\nUndefine PATTERN_RAND to compare it to random samples.",
            "flags": 0,
            "hasliked": 0,
            "id": "4d3yDf",
            "likes": 24,
            "name": "Dithered Blur",
            "published": 3,
            "tags": [
                "raytracing",
                "motionblur",
                "random",
                "depthoffield"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1157
        },
        "renderpass": [
            {
                "code": "// Cylinder Ray Tracer - Plus motion blur\n// by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n// comment this out to use a random sample pattern\n#define PATTERN_RAND 1\n\n#define NUM_SAMPLES 5\n\n\n// list of cylinders\n// Each cylinder is decribed by a pair of vec4's:\n// vec4( start position, radius ), vec4( end pos, ignored )\nvec4 Scene[] = vec4[](\n    vec4(-.7071,-1.+.7071,0,1), vec4(.7071,-1.+3.*.7071,0,0),\n    vec4(0,-1.3,0,10), vec4(0,-2,0,0),\n    vec4(0,-1,0,3.5), vec4(0,-2,0,0),\n    vec4(0,-1,3,.2), vec4(0,4,3,0),\n    vec4(2.12,-1,2.12,.2), vec4(2.12,4,2.12,0),\n    vec4(3,-1,0,.2), vec4(3,4,0,0),\n    vec4(2.12,-1,-2.12,.2), vec4(2.12,4,-2.12,0),\n    vec4(0,-1,-3,.2), vec4(0,4,-3,0),\n    vec4(-2.12,-1,-2.12,.2), vec4(-2.12,4,-2.12,0),\n    vec4(-3,-1,0,.2), vec4(-3,4,0,0),\n    vec4(-2.12,-1,2.12,.2), vec4(-2.12,4,2.12,0),\n    vec4(0,4,0,3.5), vec4(0,5,0,0)\n    );\n\n\nvec3 Sky( vec3 ray )\n{\n    return vec3(.01);\n}\n\n\n\n#define FLT_MAX 1e38\n\nfloat IntersectCylinder( out vec3 normal, vec4 a, vec4 b, vec3 pos, vec3 ray )\n{\n    vec3 m = (a.xyz+b.xyz)/2.;\n    \n    pos -= m; // centre all maths on the cylinder\n    \n    float radius = a.w;\n    vec3 n = (a.xyz-b.xyz)/2.;\n    float l = length(n);\n    n /= l;\n    \n    \n    // intersect infinite cylinder\n    // flatten everything along the axis\n    vec3 r = ray-dot(ray,n)*n;\n    vec3 p = pos-dot(pos,n)*n;\n    float rl = length(r);\n    r /= rl;;\n    float rdp = dot(r,p);\n    float pp = dot(p,p);\n    float q = pp - rdp*rdp;\n    if ( q >= radius*radius ) return FLT_MAX;\n    \n    float d = sqrt(radius*radius-q);\n    float front = (-rdp - d)/rl;\n    float back = (-rdp + d)/rl;\n    normal = normalize(p+front*r*rl);\n    \n    \n    // intersect facing plane\n    float rdn = dot(ray,n);\n    float pdn = dot(pos,n);\n    \n    if( rdn < 0. ) { n = -n; rdn = -rdn; pdn = -pdn; }\n    \n    float front2 = (-l-pdn)/rdn;\n    \n    if ( front2 > front )\n    {\n        front = front2;\n        normal = -n;\n    }\n\n    \n    // clip the back sides\n    if (\n        front > back || // clip to back of cylinder\n    \tpdn+rdn*front > l // clip to back plane\n        )\n        return FLT_MAX;\n    \n    return front;\n}\n\n\nfloat Trace( out vec3 normal, out int index, vec3 pos, vec3 ray )\n{\n    index = -1;\n    normal = vec3(0);\n    float t = FLT_MAX;\n    for ( int i=0; i < Scene.length(); i += 2 )\n    {\n        vec3 n;\n        float f = IntersectCylinder( n, Scene[i], Scene[i+1], pos, ray );\n        if ( f > 0. && f < t )\n        {\n            t = f;\n            normal = n;\n            index = i/2;\n            // todo: remember object index for material lookup\n        }\n    }\n    return t;\n}\n\n\nvec3 ShadeRay( vec3 pos, vec3 ray, float time )\n{\n    // animate moving objects\n    float r = -(time+sin(time))*50.;\n//    vec4 s0 = vec4(-.7071,-1.+.7071,0,1), s1 = vec4(.7071,-1.+3.*.7071,0,0);\n    vec4 s0 = vec4(-1.5,0,0,1), s1 = vec4(1.5,1,0,0);\n    Scene[0] = s0;\n    Scene[1] = s1;\n    Scene[0].xz = s0.xz*cos(r)+sin(r)*vec2(1,-1)*s0.zx;\n    Scene[1].xz = s1.xz*cos(r)+sin(r)*vec2(1,-1)*s1.zx;\n    Scene[0].w = .1;//.5+.5*pow(1.-fract(time*2.),2.);\n    \n    vec3 normal = vec3(0);\n    int material = -1;\n    float t = Trace(normal,material,pos,ray);\n    \n    vec3 col = Sky(ray);\n    if ( length(normal) > 0. )\n    {\n        pos += ray*t;\n        \n        vec3 sun = normalize(vec3(-.5,2,3));\n        vec3 testn = vec3(0);\n        int ignore;\n        Trace(testn,ignore,pos,sun);\n        \n        vec3 light = vec3(.05,.065,.09)*(normal.y*.3+1.); // ambient\n        if ( length(testn) == 0. )\n        {\n        \tlight += max(0.,dot(normal,sun)) * vec3(1,.95,.92);\n        }\n        \n        vec3 albedo = smoothstep(.01,.02,abs(fract( pos+.001 )-.5));\n        \n        if ( material == 0 ) { albedo = vec3(1,0,0); }//light += vec3(1.); }\n        \n        col = light*albedo;\n    }\n    \n    return col;\n}\n\n\nvec4 PatternRand( uint seed )\n{\n    return vec4(\n        float((seed*0x73494U)&0xfffffU)/float(0x100000),\n    \tfloat((seed*0xAF71FU)&0xfffffU)/float(0x100000),\n        float((seed*0x67a42U)&0xfffffU)/float(0x100000), // a bit stripey against x and z, but evens out over time\n        float((seed*0x95a8cU)&0xfffffU)/float(0x100000) // good vs x or y, not good against z\n        );\n}\n\n\nuvec4 Hash( uint seed ) \n{\n    // integer hash from Hugo Elias\n\tseed = (seed << 13U) ^ seed;\n    seed = seed * (seed * seed * 15731U + 789221U) + 1376312589U;\n    return seed * uvec4(seed,seed*16807U,seed*48271U,seed*31713U);\n}\n\n\nvec4 Rand( uint seed )\n{\n#if defined(PATTERN_RAND)\n    return PatternRand(seed);\n#else\n    return vec4(Hash(seed)&0x7fffffffU)/float(0x7fffffffU);\n#endif\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    uint pseed = uint(iFrame<<16) + (uint(fragCoord.y)<<8U) + uint(fragCoord.x);\n    \n    vec4 prand = Rand( pseed );\n    float motionJitter = prand.y;\n    \n    uint n = uint(NUM_SAMPLES); // it actually runs fine with higher numbers, but I want to see the noise!\n    \n    for ( uint i=0U; i < n; i++ )\n    {\n        uint seed = pseed*n + i;\n\t    vec4 rand = Rand( seed );\n        \n        float f = (float(i)+motionJitter)/float(n);\n\n        // with high time values and high number of samples precision can cause samples to coincide\n        // could improve this by frac'ing to period of any looped animations\n    \tfloat time = iTime+iTimeDelta*f;\n//time *= 20.; // lol!\n        \n        vec2 a = vec2(sin(time*.313)*.3+.08,time*.5);\n        vec3 cam = 5.*vec3(sin(a.y)*cos(a.x),sin(a.x),cos(a.y)*cos(a.x));\n        vec3 target = vec3(-.5,.5,0);\n\n        vec3 camk = normalize(target-cam);\n        vec3 cami = normalize(cross(vec3(0,1,0),camk));\n        vec3 camj = cross(camk,cami);\n\n        rand -= .5;\n\n        vec3 ray = vec3( (fragCoord + rand.yx - iResolution.xy*.5)/iResolution.y, 50./36. );\n        \n        // offset source for focal blur\n        vec3 pos = vec3( rand.xy*.1, 0 );\n        \n        ray /= ray.z;\n        ray.xy -= pos.xy/length(target-cam); // focus rays at target length\n        \n        ray = normalize(ray);\n\n        ray = ray.x*cami + ray.y*camj + ray.z*camk;\n        pos = pos.x*cami + pos.y*camj + cam;\n        \n        \n        fragColour.rgb += ShadeRay(\n            \t\t\t\tpos, ray,\n                            time\n                            //+ 8.*sin(time/4.)*fragCoord.x/iResolution.x\n                            //+ exp2(sin(time)*4.)*fragCoord.y/iResolution.y\n                            );\n    }\n    fragColour.rgb /= float(n);\n\n    fragColour = vec4(pow(fragColour.rgb,vec3(1./2.2)),1.0);\n    \n\t// signature\n\t#define L(m,n,u,v,l,f) min(f,max(abs(dot(fragCoord-vec2(m,n),vec2(u,v)))-l,abs(dot(fragCoord-vec2(m,n),vec2(-v,u)))-1.))\n\tfloat sig=L(3,7,0,1,3.5,L(7,7,0,1,3.5,L(5,7,1,0,2.,L(14.5,5,.7071,-.7071,2.5,abs(length(fragCoord-vec2(12.7,7))-3.)-1.))));\n\tfragColour.rgb = clamp(fragColour.rgb,0.,1.)*sig/(.1+abs(sig));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}