{
    "Shader": {
        "info": {
            "date": "1635192693",
            "description": "From Soerbgames Twitter: https://twitter.com/SoerbGames/status/1233059213716402176\nGaussian Blur from FabriceNeyret2: https://www.shadertoy.com/view/ltScRG\nAnisopropic effect from ulianlumia: https://www.shadertoy.com/view/wtlfz8",
            "flags": 32,
            "hasliked": 0,
            "id": "sdySWG",
            "likes": 37,
            "name": "Lightning Effect [Reproduction]",
            "published": 3,
            "tags": [
                "lightning",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 1611
        },
        "renderpass": [
            {
                "code": "/*\n\nThe idea is a direct reproduction of Soerbgames Twitter:\nhttps://twitter.com/SoerbGames/status/1233059213716402176\nIt's a tutorial, but not a glsl tutorial so that's what\nI added.\n\n1. Start with a line\n2. Move it up and down (parabolically from the center\n3. Add a sine wave component\n4. Add a noise component\n5. Add more of these\n6.Post process (Bloom and Anisotropic filtering I guess)\n\n\n3d could be cool.\n\n*/\n\n//Single pass Gaussian blur by FabriceNeyret2\n//https://www.shadertoy.com/view/ltScRG\n\n//anisotrpic effect by ulianlumia \n//https://www.shadertoy.com/view/wtlfz8\n\n//fragColor initialized \n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.);\n    float f = length((uv+0.5)  - 0.6);\n    fragColor.x += T(uv + f*0.006).x;\n    fragColor.y += T(uv).y;\n    fragColor.z += T(uv - f*0.006).z;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define boltNum 8.\n\nfloat hash(float x){\n    return fract(sin(x*12.)*42119.);\n}\n\nfloat noise(float x){\n    float a = hash(floor(x));\n    float b = hash(floor(x) + 1.);\n    float f = fract(x);\n  \n    return mix(a,b,f);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(61,59,77)/325.;//mix(vec3(0.3,0.4,0.2),vec3(0.4,0.,0.9),(1.-length(uv))/1.);\n    //col = mix(col,vec3(1.),(1.-length(uv))/9.);\n    col += vec3(2.-length(uv)-0.6)/9.;\n    float t = iTime/1.+5.;\n    float bend,y,f;\n    for(float i = 0.; i < boltNum; i++){\n        \n        //line \n        //y = 0.;\n        \n        //bend line in middle every second\n        bend = fract(t*(1.+(boltNum-i)/4.)+i/7.+i/8.)*0.13-0.13/2.;\n        bend *= 1.5;\n        y = bend*2. + (1.-uv.x*uv.x)*bend;\n        \n        //add sinewave\n        float randomOff = hash(floor(t*3. + i));\n        y += sin(uv.x*1.6+t*(3.) + randomOff*3.5 + i*80.)/3.;\n        \n        randomOff = hash(floor(t*2.));\n        y += noise(uv.x*6.+t*1. + randomOff*(10.5+i*8.))/5.;\n        //(fract(iTime*2.+uv.x*2.)/5.); \n        \n        //bring everything to 0 at edges\n        y = mix(y, .0, abs(uv.x/2.)/1.2);\n        //draw\n        float f = pow(1.0-smoothstep(0.02,0.5,pow(abs(y-uv.y), 0.5)),4.+i*1.9);\n        //1.0-smoothstep(0.0,0.02,pow(abs(y-uv.y)/fwidth(y-uv.y)/(25.-i*2.),2.));\n        col = mix(col, vec3(1.), f);\n    }\n\n    // Output to screen\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.25); \n    \n    fragColor = vec4(col*vig,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Single pass Gaussian blur by FabriceNeyret2\n//https://www.shadertoy.com/view/ltScRG\n\n//another that might work ok is: https://www.shadertoy.com/view/Xltfzj\n\n\n\n// 16x acceleration of https://www.shadertoy.com/view/4tSyzy\n// by applying gaussian at intermediate MIPmap level.\nconst int samples = 35,\n          LOD = 2,         // gaussian done on MIPmap at scale LOD\n          sLOD = 1 << LOD; // tile size = 2^LOD\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O / O.a;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = blur( iChannel0, U/iResolution.xy, 1./iChannelResolution[0].xy );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Just adding Buffer A and Buffer B\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.);\n    fragColor =  texture(iChannel0,uv) + texture(iChannel1,uv)/2.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}