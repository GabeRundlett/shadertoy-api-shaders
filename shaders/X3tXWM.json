{
    "Shader": {
        "info": {
            "date": "1719133808",
            "description": "/*originals https://www.shadertoy.com/view/sdtBRH https://www.shadertoy.com/view/ldBXDD https://www.shadertoy.com/view/wlG3zV*/",
            "flags": 0,
            "hasliked": 0,
            "id": "X3tXWM",
            "likes": 2,
            "name": "meteor in ripple milky way",
            "published": 3,
            "tags": [
                "star",
                "cosmos",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 254
        },
        "renderpass": [
            {
                "code": "/*originals https://www.shadertoy.com/view/sdtBRH https://www.shadertoy.com/view/ldBXDD https://www.shadertoy.com/view/wlG3zV*/\n#define BACKGROUND_COLOR vec3(0.1, 0.2, 0.6)\n#define SECONDARY_COLOR vec3(0.49, 0.45, 0.655)\n#define BIG_STAR_SIZE 16.\n#define MEDIUM_STAR_RATIO 0.3\n#define BIG_STAR_CHANCE 0.1\n#define STAR_COLOR vec3(0.9, 0.7, 1.0)\n#define SPACE_DUST_COLOR vec3(0.432941, 0.38627, 0.69020)\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n   \n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec3 hash(vec3 p3)\n{  \n\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxx+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat voronoi(vec2 n, float t) {\n  \n    vec3 p = vec3(n.x, n.y, t);\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 q = h * h * h * h * vec4(dot(d0, hash(i)), dot(d1, hash(i + i1)), dot(d2, hash(i + i2)), dot(d3, hash(i + 1.0)));\n    \n    return dot(vec4(50.), q);\n\n}\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nconst float PI = 3.14159265;\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\n\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  return (p.y+p.z)*0.735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\n return vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\n\nvec2 GetDist(vec3 p) {\n vec2 d;\n\n d.x =p.y +10.;\n for(int i=0; i<15; i++)\n {\n  p = abs(p);\n \n   p = rotate( normalize( vec3(1.3 ,-.1,2. ) ), sin(59.*0.2)*80.)*p;\n  vec2 dbox = vec2(sdOctahedron( p- vec3(-0.,0,abs(sin(p.z-iTime)*2.)),1.),1.);\n  if( dbox.x < d.x)\n  {\n   g1 +=1./(0.6+pow(abs(dbox.x),10.));\n   d = condmin( d,dbox);\n  }\t\n }\n return d ;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);  \nfor (int i=0; i<164; i++) \n {   \n  h = GetDist(ro + t.x * rd);   \n  if(h.x<0.001||abs(t.x)>70.) break;\n  t.x+=h.x *.76;\n \n }\n  \n\nreturn t;\n}\n\n\nvec3 GetNormal(vec3 p){\n \n vec2 d = GetDist(p);\n vec2 e = vec2(0.001,0);\n vec3 n = d.x - vec3(\n GetDist(p-e.xyy).x,\n GetDist(p-e.yxy).x,\n GetDist(p-e.yyx).x);\n return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(sin(iTime*0.),cos(iTime*0.),0.);\n vec3 l = normalize(lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*.001*1., l);\n \n return dif;       \n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n \n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\n\nfloat voronoiFbm(vec2 p, int iter)\n{\np.x+=iTime*0.1;\n    float f = 0.0;\n    float a = 1.0;\n    float norm = 0.0;\n    \n    for (int i = 0; i < iter; i++) {\n\t    f += a * abs(voronoi(p, 0.0)); \n        norm += a;\n        p *= 2.0;\n        a *= 0.65;\n    }\n    \n    return 1.0 - f / norm;\n}\n\nfloat fbm(vec2 p, int iter, float freq, float amp)\n{p.x+=iTime;\n    float n = 0.0;\n    float a = 1.0;\n    float norm = 0.0;\n    for(int i = 0; i < iter; ++i)\n    {\n        n += noise(p) * a;\n        norm += a;\n        p *= freq;\n        a *= amp;\n    }\n    return n / norm;\n}\n\n\nfloat fbm(vec2 p, int iter)\n{p.x+=iTime;\n    return fbm(p, iter, 2.0, 0.5);\n}\n\nvec3 starColor(vec2 p)\n{\n\n    return sin(vec3(.2, .3, .9)*fract(rand(p + vec2(7.91, 246.792))*2345.2)*123.2)*vec3(0.15, 0.1, 0.15) + 0.75;\n}\n\nvoid stars(inout vec3 col, vec2 fragCoord, float density)\n{\n    vec2 p = fragCoord;\n    \n    if(rand(vec2(ivec2(fragCoord / 2.0)) * 2.0) < MEDIUM_STAR_RATIO)\n        fragCoord = vec2(ivec2(fragCoord / 2.0)) * 2.0;\n    vec3 star = col * 0.5 + 0.5 * starColor(p);\n   \n    if(rand(fragCoord + vec2(1071.52, -662.1)) > 0.0) return;\n    col = star;\n}\n\nvoid bigStars(inout vec3 col, vec2 fragCoord, float density)\n{\n    vec2 p = vec2(ivec2(fragCoord / BIG_STAR_SIZE)) * BIG_STAR_SIZE;\n  \n    float star_size = BIG_STAR_SIZE * pow(rand(p), 2.0);\n    vec3 star = col * 0.5 + 0.5 * starColor(p);\n    float d = max(1.0 - distance(p + star_size * 0.5, fragCoord) / star_size * 2.0, 0.0);\n    star += d * d * d * d;\n    star.x+=iTime;\n    if(rand(p + vec2(6181.616, 9028.1)) > BIG_STAR_CHANCE) return;\n    col = mix(col, star, d * d * d);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n \n    vec3 col = BACKGROUND_COLOR; // Background\n    float primary = sqrt(fbm(uv * 3.0 + vec2(6.175, -23.612), 8, 1.5, 0.5)); // Space lighness\n    float secondary = fbm(uv * 4.0, 8);\n    float nebula = 4.0 * pow(fbm(uv * 4.0 + vec2(-12.1, 2.62), 18, 2.0, 0.5), 5.0);\n    float space = primary * secondary * nebula;\n    vec3 variation = normalize(vec3(fbm((uv + vec2(11.61)) * 2.0, 8), fbm((uv - vec2(2.11)) * 2.0, 8), fbm((uv + vec2(66.61)) * 2.0, 8)));\n    vec3 col2 = vec3(0);  \n vec3 ro = vec3(-3, -10.,20.);\nvec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    // distance of current pixel from center\n\tfloat cLength = length(cPos);\n\n\tuv += (cPos/cLength)*cos(cLength*12.0-iTime*4.0) * 0.03;\n\t\n ro.xy *= Rot(1.);\n  vec2 uv2 = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n \n vec3 rd = R(uv, ro, vec3(cos(iTime),sin(iTime),cos(iTime)*15.), .7);\n vec2 d = RayMarch(ro, rd);   \n float t =d.x ;   \n\n vec3 p = ro + rd *t;\n vec3 baseColor = vec3(20.,10.,5.);\n\n float dif = GetLight (p); \n col2 = vec3(dif);  \n col2+=baseColor; \n\n\n\n\n col2 *=g1*vec3(.0007);\n fragColor = vec4(col2,1.0);\n    col *= space;\n    col = mix(col, secondary * SECONDARY_COLOR, 0.5); // Nebula\n    col = mix(variation, col, 0.93);\n    col += SPACE_DUST_COLOR * vec3(pow(fbm(uv * 12.0, 18, 2.0, 0.5), 3.0) * 0.5);\n    col += vec3(0.7, 0.6, 0.5) * nebula;\n    stars(col, fragCoord, space);\n    bigStars(col, fragCoord, space);\n    col /= 1.0 + vec3(1.0, 1.3, 1.5) * (4.0 * vec3(pow(max(voronoiFbm(uv * 2.0, 8), 0.0), 6.0))); // Voronoi (stripes of emptiness)\n    col = rgb2hsv(col);\n    col *= vec3(1.0, 1.0 + cos(iTime) / 500.0, 1.0 + iMouse.y / 500.0);\n    col = hsv2rgb(col);\n    \n    fragColor = vec4(col+col2,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}