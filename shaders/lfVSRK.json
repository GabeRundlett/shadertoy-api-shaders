{
    "Shader": {
        "info": {
            "date": "1715765038",
            "description": "Clouds shader from Goodbye Dream.\n(demo released at Outline 2024)\n\nBig thanks to iq for tricks / key insights!",
            "flags": 0,
            "hasliked": 0,
            "id": "lfVSRK",
            "likes": 41,
            "name": "Goodbye Dream Clouds",
            "published": 3,
            "tags": [
                "clouds",
                "volumetric"
            ],
            "usePreview": 1,
            "username": "teadrinker",
            "viewed": 896
        },
        "renderpass": [
            {
                "code": "\n//\n// Clouds shader from Goodbye Dream, released at Outline 2024\n// by teadrinker 2024, License: CC BY-NC-SA\n//\n//   https://youtu.be/ZXXnBtW2NcI\n//   https://demozoo.org/productions/345947/\n//\n\n\n#define _BaseSize         0.18\n#define _BaseOffset       0.2\n#define _BaseGradient    -1.8\n#define _Animate          1.0\n#define _AnimateBase      0.53\n#define _AnimateDetail   -0.11\n#define _AnimateDetail2   0.1\n#define _AnimateBaseV     vec3(0.0, 0.00, 1.00)\n#define _AnimateDetailV   vec3(1.0, 0.31, 0.55)\n#define _AnimateDetail2V  vec3(1.0, 0.00, 0.00)\n#define _BaseShape        1.54\n#define _BaseWeight       2.06\n#define _DetailWeight     0.93\n#define _DetailCombine   -0.25\n#define _DensityCutoff    0.47\n#define _LowDensityColor  vec4(0.668, 0.586, 0.801, 0.043)\n#define _HighDensityColor vec4(0.317, 0.250, 0.368, 0.270)\n#define _SunColor         vec4(1.000, 0.572, 0.410, 0.620)\n#define _BackgroundC      vec4(0.317, 0.250, 0.368, 0.886)\n#define _BackgroundSunC   vec4(0.698, 0.321, 0.239, 0.317)\n#define _BackgroundSunSize 0.22\n#define _Near             6.0\n#define _Far              42.0\n#define _FarFade          0.75\n#define _SunDir           vec3(-0.61, -0.1, 1.96)\n#define _SunCurve         0.286\n#define _SunOffset        0.963\n#define _Gamma            4.0\n#define _DetailCutoff    -0.4\n#define _AlphaMax         0.93\n#define _StepSizeInside   0.27\n#define _StepSizeOutside  0.66\n#define _Jitter           2.0\n#define _Debug            0.0  // 0.8 to see iterations, 0.6 to see 1st density hit\n\n#define Loop_Max 159\n\nfloat hashu(uvec2 q) {   // cc0 https://www.shadertoy.com/view/MdcfDj\n    q *= uvec2(1597334677U, 3812015801U);\n    uint n = (q.x ^ q.y) * 1597334677U;\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat hash(vec2 n) {\n    return hashu(uvec2(n * 9e5));\n}\n\n\nfloat noise(vec3 c)\n{\n    // This the shadertoy built-in \"RGBA Noise Medium\" / 3D noise by iq\n    //\n    // The actual demo uses a larger precalculated noise texture,\n    // based on the triple round hash function found here: \n    // https://nullprogram.com/blog/2018/07/31/\n    \n    vec3 p = floor(c);\n    vec3 f = fract(c);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\nfloat cloudDensity(vec3 p, float len) {\n    float linearField = (p.y * _BaseGradient + _BaseOffset) * _BaseWeight;\n    if (linearField < -_BaseWeight)\n        return -1000.;\n    float time = iTime * _Animate;\n    p += time * _AnimateBase * _AnimateBaseV;\n    \n    float basenoise = noise(mat3(0.5, -0.5, 0.70711, 0.85355, 0.14644, -0.5, 0.14644, 0.85355, 0.5) * p);\n    \n    float nd = 0.5 + 0.5 * basenoise; // normalized course density noise (0 to 1)\n    nd = pow(nd, _BaseShape);\n    float d = _BaseWeight * (nd*2.-1.);\n    d += linearField;\n    \n    // d here represents the course/larger cloud shape \n    \n    if (d > _DetailCutoff)\n    {\n        // detail density\n        p += time * _AnimateDetail * _AnimateDetailV;\n        float f = 0.28 * noise(p * 5.);\n        f += 0.2 * noise(p * 10.1);\n        p += time * _AnimateDetail2 * _AnimateDetail2V;\n        f += 0.1 * noise(p * 22.52);\n        \n        \n        float fadeDist = 6.;\n        if (len < fadeDist)\n        {\n            f += 0.057 * noise(p * 54.28);\n            \n            // fade fine detail by distance to avoid alias\n            // and increase detail on very close clouds\n            // (not ideal impl, tweaked for a lower resolution...)\n            float fadeByDist = (fadeDist - len) * (1. / fadeDist);\n            f += 0.1 * fadeByDist * noise(p * 154.28);\n        }\n        \n        // comment out this line to see only course cloud shape \n        d += _DetailWeight * f * (1.0 - _DetailCombine * (nd - 0.5));\n\n    }    \n    return d;\n}\n\nfloat gm(float c) { return pow(c, _Gamma); }\nvec3 gm(vec3 c) { return pow(c.rgb, vec3(_Gamma)); }\nvec4 gm(vec4 c) { c.rgb = pow(c.rgb, vec3(_Gamma)); return c; }\n\nvec4 rm(vec3 ro, vec3 rd, vec2 uv) {\n\n    float len = 0.0;\n    vec4 sum = vec4(0.0);\n    float depthAlphaSum = 0.0;\n    \n    // As the ray-marching step size is \n    // quite large, each ray actually misses\n    // a lot of detail. Randomly offsetting\n    // initial distance helps a lot.\n    // The result is noisy though...\n    len = _Jitter * hash(uv+fract(iTime));\n\n    vec4 ldColor = gm(_LowDensityColor);  \n    vec4 hdColor = gm(_HighDensityColor);\n    vec3 sunColor = gm(_SunColor).rgb;\n    float ambient = gm(_SunColor.a);\n\n    int n = 0;\n    for (; n < Loop_Max; ++n)\n    {\n        vec3 p = ro + len * rd;\n        p *= _BaseSize;\n        float d = cloudDensity(p, len * _BaseSize);\n\n        if (d < -100. && sign(_BaseGradient)*rd.y < 0.)\n            break;\n            \n        if (d > _DensityCutoff) {\n\n            if(_Debug > 0.5 && _Debug < 0.75)\n            { \n                vec4 col = vec4(d, d, d, 1.0);\n                sum += col * (1.0 - sum.a);\n            }\n            else\n            {\n                // Approximate lighting with a single extra sample of the\n                // density function. Thanks to iq for this delightful trick:\n                //\n                //    https://iquilezles.org/articles/derivative/\n                //\n                float sundiff = cloudDensity(p+0.06*normalize(_SunDir), len * _BaseSize)-d;\n                \n                // Fake the appearance of shadowed valleys, just assume sun is low on the\n                // horizon, so the lower a point is, the more likely it is in shadow\n                float sunCurve = pow(max(0.0, _SunOffset - p.y*_BaseGradient*_SunCurve), 8.);\n            \n                float sun = max(0.0, -sunCurve * sundiff / 0.2);\n                            \n                d = clamp(d, 0., 1.);\n                vec4 col = mix(ldColor, hdColor, d);\n                col.rgb *= ambient + sunColor * sun * 5.;\n              \n                // make close clouds more transparent\n                col.a *= min(1.0, len / _Near);\n\n                // accumulate color and depth alpha\n                float weight = col.a * (1.0 - sum.a);\n                depthAlphaSum += weight * smoothstep(1.0 - _FarFade, 1.0, len / _Far);                               \n                sum.rgb += weight * col.rgb;\n                sum.a += weight;\n            }\n        }\n\n        len += d > _DetailCutoff ? _StepSizeInside : _StepSizeOutside;\n\n        if (len > _Far || sum.a > _AlphaMax)\n            break;\n    }\n\n    if (_Debug >= 0.75)\n        return vec4(vec3((float(n)/float(Loop_Max))), 1.0);\n\n\n    float depthAlpha = 1.0 - depthAlphaSum / (sum.a + 0.00001);\n\n    // if alpha has reached _AlphaMax\n    // clouds should be fully opaque\n    sum.a = sum.a / _AlphaMax;\n    \n    // \"fog\" / fade out by depth\n    sum.a *= depthAlpha;\n    \n    \n    // If you want to blend the clouds with other stuff\n    // the bright parts sort of disappear, to have more\n    // of an expected look, this hack tries to make bright\n    // parts more opaque, so that the final composite\n    // is more like the result of mixing the rgb with\n    // the sort of extreme gamma of 4.0 \n    \n    // sum.a += depthAlpha * depthAlpha * dot(vec3(2.0), sum.rgb);\n\n\n    sum.a = min(1.0, sum.a);\n    return sum;\n}\n\n\n\nvec4 renderPixel(vec3 ro, vec3 rd, vec2 uv) {\n\n    vec4 col = rm(ro, rd, uv);\n    float sun = 0.5 + 0.5 * dot(normalize(_SunDir), rd);\n    sun = pow((1. - pow(1. - sun, _BackgroundSunSize) ),1./ _BackgroundSunSize)* 5.;\n    \n    \n    // cheap/fake corona simulation:\n    //\n    // Make it so that background is brighter when overlayed with\n    // thin clouds close to the sun.\n    //  ( it actually brightens thicker clouds even more, but that\n    //    takes care of itself when blending bg and col later )\n    //\n    // together with the alpha-depth-fade-out/fog, this also\n    // contribute to a slight subsurface-scattering-look at\n    // further distances...\n    sun *= 1. + col.a * 6.;\n    \n    \n    // Note! there is an error in this line, bg.a might get larger than 1.0\n    // however, this looks better, so... (constants were tweaked before I found this out)\n    vec4 bg = gm(_BackgroundC) + _BackgroundSunC.a * sun * gm(_BackgroundSunC);\n    \n  \n    col = mix(bg, vec4(col.rgb,1.0), col.a);\n   \n    // inverse gamma\n    col.rgb = pow(col.rgb, vec3(1.0 / _Gamma));\n    \n    \n    // Make sure output alpha don't exceed 1,\n    // and if it does, apply it to color, \n    // (treat it as if it was blended from 0)\n    col.rgb *= max(1.0, col.a);\n    col.a = min(1.0, col.a);\n    return col;\n\n}\n\n\nvec2 rot(vec2 p, float r) { float s = sin(r),  c = cos(r); return vec2(p.x * c - p.y * s, p.x * s + p.y * c); } \n\n// uv = fragCoord/iResolution.xy\n// aspect = iResolution.x/iResolution.y\nvec3 camraydir(vec2 uv, float aspect, vec3 pos, vec3 target, float fov, float roll) { \n    vec3 forward = normalize(target - pos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = normalize(cross(forward, right));\n    float halfH = tan(fov * 0.5);\n    uv = (2.0 * uv - 1.0) * vec2(halfH * aspect, halfH);\n    vec2 rotatedUV = mat2(cos(roll), -sin(roll), sin(roll), cos(roll)) * uv;\n    return normalize(forward + rotatedUV.x * right + rotatedUV.y * up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 campos = vec3(0.0,1.7,-3.0);\n    vec3 camtarget = vec3(0.0,1.7,6.0);\n    \n    float orbit = 0.0;\n    float updown = 0.0;\n    if (iMouse.z > 0.) {\n        updown = clamp(-4.*mouse.y, -3.14159/2.0, 3.14159/2.0);\n        orbit = -4.*mouse.x;\n    }\n    campos -= camtarget;\n    campos.yz = rot(campos.yz, updown);\n    campos.xz = rot(campos.xz, orbit);    \n    campos += camtarget;\n \n    vec3 ro = campos;\n    vec3 rd = camraydir(uv, aspect, campos, camtarget, radians(40.), 0.0);\n    ro += vec3(125.,0.,64.); // start position\n    fragColor = renderPixel(ro, rd, uv);\n}\n ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}