{
    "Shader": {
        "info": {
            "date": "1490546271",
            "description": "It's just testing own distance function.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsBczz",
            "likes": 2,
            "name": "Box Ellipsoid Distance",
            "published": 3,
            "tags": [
                "raymarching",
                "distancefunction",
                "ellipsoid"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 648
        },
        "renderpass": [
            {
                "code": "#define NEAR 0.01\n#define FAR 128.\n#define ITER 128\n\nmat4 matRotateX(float rad)\n{\n    return mat4(1,       0,        0,0,\n                0,cos(rad),-sin(rad),0,\n                0,sin(rad), cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n    return mat4( cos(rad),0,-sin(rad),0,\n                0,       1,        0,0,\n                sin(rad),0, cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n    return mat4(cos(rad),-sin(rad),0,0,\n                sin(rad), cos(rad),0,0,\n                0,        0,1,0,\n                0,        0,0,1);\n}\n\nmat3 mat3RotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\nfloat sdCustomEllipsoid(vec3 p){\n    vec3 q = (p);\n    float a = (1.0+abs(cos(iTime*0.5))*1.2);\n    float b = (0.6+cos(sin(iTime*0.5))*0.6);\n    return max(abs(q.z)-(1.5+abs(cos(iTime*0.5)*2.0)),max(pow(q.x*0.1/a,2.0)+pow(q.y*0.1/b,2.0),abs(q.y)*0.01)-1.0);\n}\n\nvec4 map( vec3 pos, mat4 m)\n{\n    vec4 q = vec4(pos+vec3(0,0,-80.0),1.0)*m;\n\n    vec3 bodyColor = vec3(0.2,0.9,0.4);\n\n    vec4 rotatedPos1 = (q+vec4( 0, 0, 0, 1.0));\n\n    vec4 val1 = vec4(bodyColor,sdCustomEllipsoid(rotatedPos1.xyz ));\n\n    return val1;\n}\n\nvec2 rot(vec2 p, float a) {\n    return vec2(\n        cos(a) * p.x - sin(a) * p.y,\n        sin(a) * p.x + cos(a) * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n    position -= .5;\n    vec3 dir = vec3( position, 1.0 );\n\n    float aspect = iResolution.x / iResolution.y;\n    dir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n    dir.yz = rot(dir.yz, 0.2);\n\n    vec3 pos = vec3(0.0, 10.0, 20.0);\n    mat4 m = matRotateY(iTime)*matRotateZ(iTime);\n\n    vec4 result;\n    int march = 0;\n    for (int i = 0; i < ITER; i++)\n    {\n        result = map(pos, m);\n        march = i;\n        if (result.w < NEAR || result.w > FAR) break;\n        pos += result.w * dir;\n    }\n\n    vec3 col = map(pos, m).xyz;\n    vec4 bgCol;\n    if ( pos.z> 100. )\n    {\n        // bg\n        float temp = length(vec2(position.xy))+0.9;\n        col = vec3(.3,.3,.3)/vec3(temp);\n    }\n    else\n    {\n        //http://prideout.net/blog/?p=22\n        // shade\n\n        vec3 lightPos = vec3(20.0, 20.0, 20.0 );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( .1, .01, .0 );\n        vec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n                      result.w - map( pos - eps.yxy, m ).w,\n                      result.w - map( pos - eps.yyx, m ).w );\n        n = normalize(n);\n\n        float lambert = max(.0, dot( n, light2Pos));\n        col *= vec3(lambert);\n        col += vec3(result.xyz);\n    }\n\n    fragColor = vec4( col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}