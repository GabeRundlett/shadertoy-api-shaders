{
    "Shader": {
        "info": {
            "date": "1497658723",
            "description": "[0..15] boolean truth table counter.",
            "flags": 0,
            "hasliked": 0,
            "id": "lslfRs",
            "likes": 3,
            "name": "draw Boolean logic",
            "published": 3,
            "tags": [
                "envelope",
                "boolean",
                "shift",
                "bitwise",
                "drawlogic"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 608
        },
        "renderpass": [
            {
                "code": "/*\nmaking elements for circuits, but it progresses much slower than anticipated.\neven simple tasks take way too long.\nbecause i have no library for most things\nor get sidetracked by red herrings\nand a need to find new stuff and optimize, both worth it, but slow.\n*/\n\n#define blur .1\n\n//branchless [t]=[0..15] boolean truth table (counter) for [u]=FragmentPos\nfloat gfour(vec2 u,int t){ivec2 v=ivec2(floor(u));v.y=-v.y;//flip .y domain\n float f=float(any(lessThan(ivec2(1),v))||any(lessThan(v,ivec2(0))));//frame\n int i=(t&(((1<<v.x)<<v.y)<<v.y));float g=float(min(i,1));//boolean operator mask\n return 1.-step(g,f);}//return mix(0.,g,step(f,0.));\n\n//return Taxicap distance of [v] to line from (-a,0) to (a,0)\nfloat boxTaxy(vec2 u,vec2 a){u=abs(u)-a;return max(u.x,u.y);}\n//ellipse is to sphere as rectangle is to square, SAME scaling of gradient issuea!\n//must use -, can not use * or /, for the SAME reasons! (can not SCALE cradient!)\n//must assume every domain as indepentend! can not assume square or circle.\n//as long as i do not multiply, all is fine.\n\n//modulo [p] in interval [s], offset by +s*.5;\n//float pMod(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2  pMod(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\n/*\n//works fine, just was not needed.\n//pMod [p,s], but only [0..n] times!\nfloat pModN(inout float p,float s,float n){\n float h=s*.5,c=floor((p+h)/s);\n p=mod(p+h,s)-h;\n if(c>n)p+=s*(c-n);\n if(0.>c)p+=s*(c);\n return min(n,c);}\n*/\n\n//thsi envelope sucks, its a \"special\" case. not doing envelopes now!\n//smoothstep-like envelope with ascending diagonal from p.x till p.y within [0..w]\nfloat hardstep(float p,float a,float b,float w){\n return mix(0.,mix(1.,mix(0.,1.,(p-a)/max(w-a-b,.01)),step(p,b)),step(a,p));}\n//nah the core of this appears wrong still. needs its own viewer i suppose!\n//a \"poor\" compromise between smoothstep() and step()\n//main problem here is scaling x by w!, still better than dividing.\n//and hardstep() has more mults than smoothstep()!\n\n//grid for a boolean truth table\nfloat boolGrid(vec2 u){ \n float a=boxTaxy(u+vec2(-.7,-.3),vec2(-.5))-1.;//framing masm\n a=hardstep(a,.7,1.,2.);//envelopeing framing mask\n u=(abs(fract(u)-.5)-.25);float b=max(u.x,u.y)*3.;//grid fence\n float r=min(b,1.-a);//masking the grid fence\n r=hardstep(r,.2,.5,1.);//another envelope\n return r;}\n\nfloat g16and(vec2 u){\n int a=int(floor(iTime*6.));//keep counting those integers\n return max(boolGrid(u),gfour(u,a)*.6);}//display\n\n//#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvec2 frame(vec2 u){u/=iResolution.xy;u-=.5;\nif(iResolution.x>iResolution.y)u.x*=iResolution.x/iResolution.y;\nelse u.y*=iResolution.y/iResolution.x;return u*4.;}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n vec2 u=frame(U);\n u.x+=1.;\n float f=g16and(u);\n //f=fract(f);\n u=fract(u);\n O=vec4(.3*vec3(f*2.,u*.2)*mat3(1),1);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}