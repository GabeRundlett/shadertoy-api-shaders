{
    "Shader": {
        "info": {
            "date": "1630549573",
            "description": "cubes",
            "flags": 0,
            "hasliked": 0,
            "id": "ss33Rl",
            "likes": 19,
            "name": "Vapor Cube Durability Testing",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "glow"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 620
        },
        "renderpass": [
            {
                "code": "#define STEPS 220.0\n#define MDIST 150.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nvec3 glow = vec3(0);\nvec3 rlim(vec3 p, float c, vec3 l ){\n    return p-c*clamp(round(p/c),-l,l);\n}\nfloat h21(vec2 a){\n    return fract(sin(dot(a,vec2(43.234,25.433)))*944.3434);\n}\nfloat frame(vec3 p, vec3 b, float e){\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n/*\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n*/\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n//https://www.desmos.com/calculator/dxixbmrvmb\nfloat easeOutElastic(float x) {\n    float c4 = (2. * pi) / 3.;\n    return x = pow(1.63,-10.*x) * sin((x*5.25-.75)*c4)+1.;\n}\n//I would like to make a more procdeural version of this but so far this one still\n//looks the best. \nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\n//https://www.shadertoy.com/view/fdsXRf\nfloat timeRemap (float t, float s1, float s2){\n    return (s1-s2)*(fract(t)*step(1.0,mod(t,2.0))+floor(t*0.5))+t*s2;\n}\nvec2 map(vec3 p){\n    float t = iTime*0.8*(6./5.);\n    float ttt = t;\n    vec3 po = p;\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    float m= 2.4;\n    vec2 id = floor(clamp(p.xz,-13.,13.)/m-0.5);\n    float off = 0.;\n    \n    float cycle = mod(floor(t/4.0+0.5),6.0);\n    //cycle = .0;\n    if(cycle == 0.0){\n        t+=length(id+1.0)*0.07;\n    }\n    if(cycle == 1.0){\n        t+=length(id-21.0)*0.07-1.685;\n    }\n    if(cycle == 2.0){\n        if(mod(id.y+mod(id.x,2.0),2.0)<1.0)t+=0.15;\n        id = abs(id+1.);\n        t+=max(id.x,id.y)*0.2;\n        t-=0.15;\n    }\n    if(cycle == 3.0){\n        t+=0.562;\n        t+=id.y*0.08;\n        t+=id.x*0.01;\n    }\n    /*\n    if(cycle == 4.0){\n        t+=0.4;\n        //id=id+1.0;\n        id.y+=1.0;\n        id.x+=7.0;\n        float ang = atan(id.x,id.y)*0.2;\n        t+=ang;\n    }\n    */\n    if(cycle == 4.0){\n        t+=0.3;\n        id+=1.0;\n        t+=(mod(id.y,2.0)*3.0-2.0)*abs(id.x)*0.0175;\n    }\n    if(cycle == 5.0){\n        t+=h21(id);\n    }\n    t = timeRemap(t,1.0,0.0);//changing the third value here makes some interesting bugs\n    \n\n    \n    \n    float tt = t;\n    t = (mod(t,2.0)>1.0)?easeOutBounce(fract(t))+floor(t):easeOutElastic(fract(t))+floor(t);\n    \n    if(mod(tt,2.0)<1.0) off = t-floor(tt);\n    else off = 1.0-(t-floor(tt));\n    \n    //CUBES\n    p.y-=off*13.;\n    p = rlim(p,m,vec3(5,0,5));\n    a.x = box(p,vec3(0.99));\n    //CUBE FRAMES\n    b.x = frame(p,vec3(1.0),0.06)*0.8;\n    float gl = 0.05;\n    glow+=gl/(gl+b.x*b.x)*vec3(0.373,0.200,1.000)*clamp((0.5-abs(0.5-off))*5.0,0.0,1.0);\n    \n    a=(a.x<b.x)?a:b;\n\n    //Domain fuckery\n    //#define rdt(a) pow(smoothstep(0.5,1.0,abs(a)),2.0)*1.0\n    vec3 d = abs(p)-vec3(m/1.7,0,m/1.7);\n    vec3 d2 = abs(po)-m*5.4;\n    float domBox = max(d.x,d.z);\n    float outBox = max(d2.x,d2.z);\n    domBox = min(-outBox,domBox);\n    a.x = min(-domBox,a.x);\n    \n    //Floor\n    p = po;\n    b.x = box(p-vec3(0,-31,0),vec3(13,30,13));\n    b.y = 3.0;\n    a=(a.x<b.x)?a:b;\n    \n    //BOX RINGS\n    t = ttt;\n    float sz = 16.;\n    p.y+=-t*14.0;\n    p.y = pmod(p.y,8.0);\n    b.x = box(p,vec3(sz,1,sz));\n    b.x = max(-box(p,vec3(sz-1.,6,sz-1.)),b.x);\n    b.x = max(po.y-3.,b.x);\n    \n    glow+=0.1/(0.1+b.x*b.x)*vec3(0.733,0.000,1.000)*0.2*smoothstep(4.0,-6.0,po.y);\n    b.y = 5.0;\n    a=(a.x<b.x)?a:b;\n    \n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e= vec2(0.001,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,12,-30);\n    ro.zx*=rot(iTime*0.15*pi/3.*(6./5.));\n    \n    vec3 lk = vec3(0,2,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*0.7+uv.x*r+uv.y*cross(f,r);\n    vec3 p = vec3(0);\n    vec2 d = vec2(0);\n    float dO = 0.;\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        \n        if((d.x)<0.005){\n            if(d.y == 5.0){\n                d.x = 0.08;\n            }\n            else{\n            hit = true;\n            break;\n            }\n        }\n        if(dO>MDIST){\n            p = ro+rd*MDIST;\n            dO = MDIST;\n            break;\n        }\n        dO+=d.x*0.9;\n    }\n    vec3 al = vec3(0);\n    if(hit){\n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);\n        if(d.y==1.0) al = vec3(0.000,0.984,1.000)*1.4;\n        if(d.y==2.0) al = vec3(0.004,0.137,0.537);\n        if(d.y==3.0) {\n        al = vec3(0.588,0.180,1.000);\n        al+=smoothstep(0.95,1.0,sin(p.x*pi*0.75+pi/2.0))*1.6;\n        al+=smoothstep(0.95,1.0,sin(p.y*pi*0.75+2.0))*1.6;\n        al+=smoothstep(0.95,1.0,sin(p.z*pi*0.75+pi/2.0))*1.6;\n        }\n        //Lighting EQs from blackle\n        float diff = length(sin(n*3.)*.5+.5)/sqrt(3.);\n        float spec = length(sin(r*2.)*.4+.6)/sqrt(3.);\n        col = al*diff+pow(spec,8.0)*0.4*vec3(1.000,0.722,0.910);\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n        float ao = AO(0.05,n,p)*AO(0.1,n,p);\n        ao*=smoothstep(-.4,.4,map(p+n*.4).x*2.1);\n        col*=pow(ao,0.7);\n    }\n    else{\n        col = mix(vec3(0),vec3(0.055,0.000,0.161),length(pow(uv,vec2(3.0))));\n    \n    }\n    //col = sqrt(col);\n    col+=glow*0.07;\n    fragColor = vec4(col,1.0);\n}\n\n#define AA 1.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            glow = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}