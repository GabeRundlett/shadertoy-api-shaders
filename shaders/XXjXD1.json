{
    "Shader": {
        "info": {
            "date": "1710540339",
            "description": "My approach for fixing the SDF \"correctness\" when combining shapes with Union and Subtraction.",
            "flags": 0,
            "hasliked": 0,
            "id": "XXjXD1",
            "likes": 4,
            "name": "More correct combined SDF?",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "union",
                "combine",
                "subtraction",
                "correctsdf"
            ],
            "usePreview": 0,
            "username": "jaszunio15",
            "viewed": 198
        },
        "renderpass": [
            {
                "code": "/*\n * Lately in my free time I'm working on a physics engine, where colliders are defined by an \n * SDF that uses union and subtraction operations. The issue I had with this approach is that\n * those operations make SDF correct only near the \"surface\". So when simulating larger objects,\n * I was facing the issue that they were colliding with invisible surfaces.\n *\n * I solved this problem by doing a local search for nearby SDF surface. Basically I jump in 4\n * directions few times and return the 2D point that was closest to the surface. Distance to \n * this point will be a new SDF value.\n *\n * This approach requires much more SDF reads, but in case of physics engine, this needs to be\n * calculated once per each physics object in each frame, so the performance impact is not\n * so noticeable. The final result is obviously wrong, but it is much closer to the correct SDF, \n * and it is just enough for me.\n *\n * This can be also written for 3D (I run physics in 3D), just search needs to use normal, tangent\n * and bitangent of SDF surface during the search.\n *\n *\n *\n * The shader is partially inspired by this article. Article missed the idea to do some local search \n * of an exact SDF surface.\n * https://iquilezles.org/articles/interiordistance/\n * \n * I modified Inigo Qulez shader and use his SDF visualization: https://www.shadertoy.com/view/3ltSW2 \n */\n\nfloat Union(float s1, float s2)\n{\n    return min(s1, s2);\n}\n\nfloat Subtract(float s1, float s2)\n{\n    return max(s1, -s2);\n}\n\nfloat smoothness = 0.1;\n\n// Function that defines main object\nfloat SDFFunction(vec2 position)\n{\n    float circle1SDF = sdCircle(position, 0.5);\n    float circle2SDF = sdCircle(position - vec2(0.15, -0.7), 0.3);\n    float box1SDF = sdBox(position - vec2(0.5, -0.3), vec2(0.5, 0.8));\n    float box2SDF = sdBox(position - vec2(1.0, -0.7), vec2(0.4, 0.4));\n    float box3SDF = sdBox(position - vec2(0.95, -0.0), vec2(0.3, 0.3));\n    \n    float d = Union(circle1SDF, box1SDF);\n    d = Union(d, box2SDF);\n    d = Subtract(d, box3SDF);\n    d = Subtract(d, circle2SDF);\n    \n    return d;\n}\n\nvec2 SDFFunctionNormalizedGradient(vec2 position)\n{\n    float epsilon = 0.001;\n    float dYmin = SDFFunction(position + vec2(0.0, -epsilon));\n    float dYmax = SDFFunction(position + vec2(0.0, epsilon));\n    float dXmin = SDFFunction(position + vec2(-epsilon, 0.0));\n    float dXmax = SDFFunction(position + vec2(epsilon, 0.0));\n    \n    return normalize(vec2(dXmax - dXmin, dYmax - dYmin));\n}\n\nvec2 ClosestSDFSurfaceSearch(vec2 position)\n{\n    float absSDFValue = 999999.0;\n    vec2 searchPosition = position;\n    for (int i = 0; i < 3; i++)\n    {\n        vec2 sdfNormal = SDFFunctionNormalizedGradient(searchPosition);\n        vec2 sdfTangent = sdfNormal.yx * vec2(-1, 1);\n\n        float localSearchDistance = abs(SDFFunction(searchPosition));\n        \n        float tangentMultiplier = 1.0;\n        float normalMultiplier = 1.0;\n\n        vec2 rightPosition = searchPosition + sdfTangent * localSearchDistance * tangentMultiplier;\n        vec2 leftPosition = searchPosition - sdfTangent * localSearchDistance * tangentMultiplier;\n        vec2 upPosition = searchPosition + sdfNormal * localSearchDistance * normalMultiplier; \n        vec2 downPosition = searchPosition - sdfNormal * localSearchDistance * normalMultiplier; \n        \n        float rightSDF = abs(SDFFunction(rightPosition));\n        float leftSDF = abs(SDFFunction(leftPosition));\n        float upSDF = abs(SDFFunction(upPosition));\n        float downSDF = abs(SDFFunction(downPosition));\n\n        if (rightSDF < absSDFValue)\n        {\n            absSDFValue = rightSDF;\n            searchPosition = rightPosition;\n        }\n        \n        if (leftSDF < absSDFValue)\n        {\n            absSDFValue = leftSDF;\n            searchPosition = leftPosition;\n        }\n        \n        if (upSDF < absSDFValue)\n        {\n            absSDFValue = upSDF;\n            searchPosition = upPosition;\n        }\n        \n        if (downSDF < absSDFValue)\n        {\n            absSDFValue = downSDF;\n            searchPosition = downPosition;\n        }\n    }\n    \n    return searchPosition;\n}\n\nfloat SDFFunctionFixed(vec2 position)\n{\n    float sdfSign = sign(SDFFunction(position));\n    vec2 closestSurfacePoint = ClosestSDFSurfaceSearch(position);\n    \n    return distance(position, closestSurfacePoint) * sdfSign;\n}\n\n\n// Modified code from https://www.shadertoy.com/view/3ltSW2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    p -= vec2(-0.4, 0.4);\n    m -= vec2(-0.4, 0.4);\n\n\tfloat d = SDFFunction(p);\n    if (mod(iTime, 2.0) < 1.0)\n    {\n        d = SDFFunctionFixed(p);\n    }\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-5.0*abs(d));\n\tcol *= mix(0.8 + 0.2*cos(150.0*d), 1.0, 0.7);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z<=0.0 )\n    {\n        m = vec2(0.2, 0.1);\n    }\n    \n    d = SDFFunction(m);\n    if (mod(iTime, 2.0) < 1.0)\n    {\n        d = SDFFunctionFixed(m);\n    }\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    \n    //col.rg = SDFFunctionNormalizedGradient(p);\n    //col.b = 0.0;\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The MIT License\n// Copyright Â© 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat sdCircle(in vec2 p, in float r) \n{\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}