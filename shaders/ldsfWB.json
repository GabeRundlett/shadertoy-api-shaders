{
    "Shader": {
        "info": {
            "date": "1497980402",
            "description": "Hexagonal grid line of sight (updated); ray-grid intercepts added. Mouse moves line end.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldsfWB",
            "likes": 22,
            "name": "Line of Sight 2",
            "published": 3,
            "tags": [
                "hexagon",
                "los",
                "intercept"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1370
        },
        "renderpass": [
            {
                "code": "// \"Line of Sight 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Hexagonal grid line of sight (updated); ray-grid intercepts added (uses different\n  grid orientation from mattz). Mouse moves line end.\n*/\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nbool HexNeb (vec2 a, vec2 b)\n{\n  vec2 d = a - b;\n  return (d.x == 0. && abs (d.y) == 1. || abs (d.x) == 1. && d.y == 0. ||\n    d.x * d.y == -1.);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (SQRT3/2.) - p.x + 0.5 * min (p.x - SQRT3 * p.y, 0.);\n}\n\nbool HexOnLine (vec2 v, vec2 b)\n{\n  vec3 w;\n  w = abs (vec3 (v.x, 0.5 * (v.x + SQRT3 * v.y), 0.5 * (v.x - SQRT3 * v.y)));\n  return (abs (b.x * v.y - b.y * v.x) < max (w.x, max (w.y, w.z)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 ShowScene (vec2 pA, vec2 pB, vec2 pC)\n{\n  vec3 col, vri, ev, hv, hvv, vf;\n  vec2 edN[3], cIdA, cIdB, cIdC, pCM, pM, rd, vt;\n  float lenLn, dEdge, hitW, s, t;\n  rd = pB - pA;\n  lenLn = length (rd);\n  rd /= lenLn;\n  cIdC = PixToHex (pC);\n  cIdA = PixToHex (pA);\n  cIdB = PixToHex (pB);\n  pCM = HexToPix (cIdC);\n  dEdge = HexEdgeDist (pC - pCM);\n  col = vec3 (0.3);\n  vt = pCM - pA;\n  t = dot (vt, rd);\n  if (cIdC == cIdA || cIdC == cIdB || t > 0. && t < lenLn && HexOnLine (rd, vt)) {\n    col = HsvToRgb (vec3 (1., 1. - 1.2 * dEdge,\n       min (1. + 0.2 * sin (50. * dEdge), 1.)));\n    col = mix (vec3 (0., 0., 1.), col, smoothstep (0.1, 0.13, length (pC - pCM)));\n  } else {\n    if (HexNeb (cIdC, cIdA) || HexNeb (cIdC, cIdB)) col += 0.2;\n  }\n  col = mix (vec3 (0., 0., 1.), col, smoothstep (0.04, 0.05, dEdge));\n  vt = pC - pA;\n  t = dot (vt, rd);\n  if (t > -0.03 && t < lenLn + 0.03) {\n    col = mix (vec3 (0.), col, smoothstep (0.03, 0.1,\n       sqrt (max (0., dot (vt, vt) - t * t))));\n    if (t > 0. && t < lenLn) col = mix (vec3 (1., 1., 0.), col,\n       smoothstep (0.03, 0.04, sqrt (max (0., dot (vt, vt) - t * t))));\n  }\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., SQRT3);\n  edN[2] = 0.5 * vec2 (1., - SQRT3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd));\n  vri = 1. / vec3 (dot (rd, edN[0]), dot (rd, edN[1]), dot (rd, edN[2]));\n  vf = (SQRT3/2.) - vec3 (dot (pA, edN[0]), dot (pA, edN[1]), dot (pA, edN[2]));\n  pM = HexToPix (cIdA);\n  hitW = 1e6;\n  for (int j = 0; j < 40; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    if (s > lenLn) break;\n    pM += SQRT3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    hitW = min (hitW, length (pA + s * rd - pC));\n  }\n  col = mix (vec3 (0., 1., 0.), mix (vec3 (0.), col, smoothstep (0.13, 0.2, hitW)),\n     smoothstep (0.13, 0.15, hitW));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 col;\n  vec2 canvas, uv, va, pC, pA, pM, r;\n  float tCur, pSize, a, h;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  pSize = 20.;\n  va = pSize * vec2 (canvas.x / canvas.y, 1.);\n  a = 0.1 * tCur;\n  r = vec2 (cos (a), sin (a)) * va;\n  pC = pSize * uv;\n  pM = 2. * mPtr.xy * va;\n  pA = (mPtr.z > 0.) ? pM : - 0.65 * r + 0.1 * vec2 (- r.y, r.x);\n  col = ShowScene (pA, pA + 1.3 * r, pC);\n  if (mPtr.z > 0.) {\n    h = length (pC - pM);\n    col = mix (vec3 (1., 1., 0.), mix (vec3 (0.), col,\n       smoothstep (0.15, 0.2, h)), smoothstep (0.15, 0.17, h));\n  }\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}