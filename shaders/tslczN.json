{
    "Shader": {
        "info": {
            "date": "1584321473",
            "description": "Inspire by https://solarsystem.nasa.gov/planets/saturn/by-the-numbers/ and KSP.",
            "flags": 0,
            "hasliked": 0,
            "id": "tslczN",
            "likes": 9,
            "name": "Saturn & Titan (SS11)",
            "published": 3,
            "tags": [
                "sdf",
                "space",
                "shadersundays"
            ],
            "usePreview": 0,
            "username": "angelo12",
            "viewed": 704
        },
        "renderpass": [
            {
                "code": "/*\n\tShader Sundays! (11/52) \n\t\"Saturn & Titan!\"\n\n    The inspiration for this shader came from the beautiful NASA pictures you see below.\n\tSpecifically this one: \n\thttps://d.ibtimes.co.uk/en/full/1653195/saturn-rings.jpg\n\thttps://solarsystem.nasa.gov/planets/saturn/overview/\n\n\tI added Titan because it has such a nice color and it broke the monotony of the scene a \n\tbit. I cannot wait for KSP2 to come out :D!\n*/\nfloat\nhash(vec2 n){\n    return fract(sin(dot(n,vec2(12.9898, 4.1414)))*43758.5453);\n}\n\nfloat\nsdRing(vec3 p)\n{\n    vec3 pos = p - vec3(-0., -0.00, 0.0);\n\n    float r = length(vec2(pos.x, pos.z));\n    float ringSize = 2.0;\n    float d = sdBox(pos, vec3(ringSize, 0.00002, ringSize));\n    if(r > ringSize || r < 1.35) d += 0.001;\n    if(r > 1.75 && r < ringSize - 0.18)  d += 0.001;\n    if(r > 1.975 && r < ringSize - 0.02)  d += 0.001;\n\n    return d;\n}\n\n#define SATURN_ID 0.0\n#define MOON_ID 1.0\n#define RING_ID 2.0\nvec2\nMap(vec3 p)\n{\n    vec2 res = vec2(1e10, -1.0);\n\n    UOP(sdSphere(p, 0.85), SATURN_ID);\n    UOP(sdRing(p), RING_ID);\n\n    float ang = -iTime/ 12.0 + M_PI;\n    float rad = 1.5;\n    UOP(sdSphere(p - vec3(rad*sin(ang), 0.2, rad*cos(ang)), 0.05), MOON_ID);\n\n    return res;\n}\n\n#define MAX_DIST 20.0\n#define MIN_DIST 0.0001\n#define MAX_STEPS 200\nvec2\nRayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec2 res = vec2(-1.0, -1.0);\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i)\n    {\n        vec2 hit = Map(ro + t*rd);\n        if(abs(hit.x) < t* MIN_DIST)\n        {\n            res = vec2(t, hit.y);\n            break;\n        }\n        t+= hit.x;\n    }\n\n    return res;\n}\n\nvec3\nCalcNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x,\n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x\n    ));\n}\n\nvec3\nMaterial(float id, vec3 pos)\n{\n    vec3 col = vec3(1.0);\n\n    if(id == SATURN_ID )\n    {\n        vec2 uv = vec2(atan(pos.x, pos.z) / (2.0*M_PI) + 0.5, pos.y *0.5 + 0.5);\n        col = vec3(0.789, 0.765, 0.43);\n        if(uv.y > 0.91) col *= 0.95;\n    }\n\n    if(id == RING_ID )\n    {\n        float r = length(pos.xz);\n        r -= 1.0;\n        r = 1.0 - r;\n        col = mix(vec3(0.875, 0.7, 0.097) * 0.2, vec3(0.875, 0.7, 0.5)*1.0, r);\n    }\n\n    if(id == MOON_ID) col = vec3(0.25, 0.6, 0.375);\n\n    return col;\n}\n\nfloat\nCalcShadow(vec3 ro, vec3 rd)\n{\n    for(float t = 0.10; t < MAX_DIST;)\n    {\n        float h = Map(ro + t*rd).x;\n\n        if(h < MIN_DIST)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvec3\nRender(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    vec2 res = RayMarch(ro, rd);\n    float t = res.x;\n    float id = res.y;\n\n    //Sky\n    col += vec3(1.0) * pow(hash(uv * vec2(13.0, 2.2)), 703.58);\n    col *= 6.0;\n\n    //Opaque\n    if(id >= 0.0)\n    {\n        //Geometry\n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormal(P);\n\n        //Material\n        col = Material(id, P);\n\n        //Lighting\n        vec3 lin = vec3(0.0);\n        float ang = M_PI / 4.2 + iTime / 25.0 ;\n        vec3 L = normalize(vec3(cos(ang), 0.5, sin(ang)));\n        float diff = saturate(dot(L, N));\n        float amb = 0.05;\n\n        //Shadowing\n        diff *= CalcShadow(P, L);\n\n        //Shading\n        float isRing =  (id == RING_ID) ? 0.0 : 1.0;\n        isRing *= P.y * 6.0;\n        lin += 0.07 * amb  * vec3(1.0) * isRing;\n        lin += 1.2 * diff * vec3(1.0, 1.0, 1.0);\n        col *= lin;\n    }\n    return saturate(col);\n}\n\n#define AA 2\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    float nearP = 1.8;\n    float roll = 0.0;\n    vec3 tot = vec3(0.0);\n\n#if AA > 1\n    for(int i =0; i < AA; ++i)\n    for(int j =0; j < AA; ++j)\n    {\n        vec2 offset = 0.5 - vec2(i, j)/ float(AA);\n        vec2 uv = ((fragPos + offset) - 0.5*iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = ((fragPos) - 0.5*iResolution.xy)/iResolution.y;\n#endif\n\n        vec3 ta = vec3(0.0, 0.00, 0.0);\n        vec3 ro = ta + vec3(0.0, 1.7, -4.5);\n        mat3 cam = SetCamera(ro, ta, roll);\n        vec3 rd = cam * normalize(vec3(uv, nearP));\n        vec3 col = Render(ro, rd, uv);\n\n        GAMMA(col);\n        tot += col;\n#if AA > 1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4(tot, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//Comment this out if running this file on shadertoy\n#define SHADERTOY \n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat\nsdGroundPlane(vec3 p)\n{\n    return p.y;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Camera functions------------------------------\nmat3\nSetCamera(vec3 ro, vec3 ta, float roll)\n{\n    vec3 f, temp, r, u;\n    f = normalize(ta - ro);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = normalize(cross(f, r));\n\n    return mat3(r, u, f);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n\n//--------------------------------------------------------------------------------------\n//----------------------------------Post processing functions----------------------------\n#define GAMMA(col) col = pow(col, vec3(INV_GAMMA))\n\n\n//---------------------------------------------------------------------------------------- \n//----------------------------------Basic functions---------------------------------------\n#ifdef SHADERTOY\n#define saturate(col) clamp(col, 0.0, 1.0)\n#endif\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}