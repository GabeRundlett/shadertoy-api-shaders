{
    "Shader": {
        "info": {
            "date": "1540065622",
            "description": "Simple Analytic Approximations to the CIE XYZ Color Matching Functions\nhttps://research.nvidia.com/publication/simple-analytic-approximations-cie-xyz-color-matching-functions",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttBRB",
            "likes": 5,
            "name": "XYZ Color Matching Functions",
            "published": 3,
            "tags": [
                "color",
                "xyz",
                "cie",
                "matching"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 393
        },
        "renderpass": [
            {
                "code": "\n/*\nSimple Analytic Approximations to the CIE XYZ Color Matching Functions\nhttps://research.nvidia.com/publication/simple-analytic-approximations-cie-xyz-color-matching-functions\n*/\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 XYZ_to_sRGB(vec3 xyz)\n{\n    float r = dot(xyz, vec3( 3.2406, -1.5372, -0.4986));\n    float g = dot(xyz, vec3(-0.9689,  1.8758,  0.0415));\n    float b = dot(xyz, vec3( 0.0557, -0.2040,  1.0570));\n    \n    return vec3(r, g, b);\n}\n\n// https://en.wikipedia.org/wiki/Planck%27s_law\n// wavelength l in nm, temperature T in Kelvin, returns radiance\nfloat Blackbody(float l, float T)\n{\n    const float h = 6.626070040e-16;\n    const float k = 1.38064852e-5;\n    const float c = 299792458.0e9;\n    \n    const float o0 = 2e-3 * h * (c * c);\n    const float o1 = h * c / k * 1.442695;\n    \n    float l5 = ((l * l) * (l * l)) * l;\n    \n    return o0 / (l5 * (exp2(o1 / (l * T)) - 1.0));\n}\n\n// Simple Analytic Approximations to the CIE XYZ Color Matching Functions\n// https://research.nvidia.com/publication/simple-analytic-approximations-cie-xyz-color-matching-functions\nvec3 XYZ10(float l)\n{\n    vec3 xyz;\n\n    xyz.x = 0.4 * exp2(-866.433976 * Pow2(log2(l * 0.000986 + 0.56213)));\n\txyz.x += 1.13 * exp2(-162.19644 * Pow2(log2(l * -0.001345 + 1.799597)));\n    \n\txyz.y = 1.011 * exp2(-1.442695 * Pow2(l * 0.015325 - 8.522368));\n\n\txyz.z = 2.06 * exp2(-22.18071 * Pow2(log2(l * 0.005543 - 1.474501)));\n    \n    return xyz;\n}\n\nvec3 XYZ2(float l)\n{\n    vec3 xyz;\n\n    {\n        float dParam1 = (l-442.0)*((l < 442.0)?0.0624:0.0374);\n        float dParam2 = (l-599.8)*((l < 599.8)?0.0264:0.0323);\n        float dParam3 = (l-501.1)*((l < 501.1)?0.0490:0.0382);\n        xyz.x = 0.362*exp(-0.5*dParam1*dParam1) + 1.056*exp(-0.5*dParam2*dParam2) - 0.065*exp(-0.5*dParam3*dParam3);\n    }\n\n    {\n        float dParam1 = (l-568.8)*((l < 568.8)?0.0213:0.0247);\n        float dParam2 = (l-530.9)*((l < 530.9)?0.0613:0.0322);\n        xyz.y = 0.821*exp(-0.5*dParam1*dParam1) + 0.286*exp(-0.5*dParam2*dParam2);\n    }\n\n    {\n        float dParam1 = (l-437.0)*((l < 437.0)?0.0845:0.0278);\n        float dParam2 = (l-459.0)*((l < 459.0)?0.0385:0.0725);\n        xyz.z = 1.217*exp(-0.5*dParam1*dParam1) + 0.681*exp(-0.5*dParam2*dParam2);\n    }\n\n    return xyz;\n}\n\n// single lobe approx, maybe use this one for wavelen sampling\nfloat Y2(float l)\n{\n    vec3 xyz;\n\n    float a = 1.014;\n\tfloat b = 556.3;\n\tfloat c = 0.075;\n\tfloat tmp = ( log( l ) - log( b ) ) / c;\n\treturn a*exp(-0.5*tmp*tmp);\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += .0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.125;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.25+0.0375;\n    \n    float wavelen = mix(360.0, 720.0, tex.x);\n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    //col = mix(col, vec3(0.0, 1.0, 1.0), Graph(Y2(wavelen) - tex.y, 4.0) * 0.3);\n    {\n    \tfloat sat = 0.3;   \n    \tcol = mix(col, vec3(1.0, 0.0, 0.0), Graph(XYZ10(wavelen).x - tex.y, 4.0) * sat);                  \n    \tcol = mix(col, vec3(0.0, 1.0, 0.0), Graph(XYZ10(wavelen).y - tex.y, 4.0) * sat);                  \n    \tcol = mix(col, vec3(0.0, 0.0, 1.0), Graph(XYZ10(wavelen).z - tex.y, 4.0) * sat);                  \n    }\n    \n    {\n    \tfloat sat = 0.99;   \n    \tcol = mix(col, vec3(1.0, 0.0, 0.0), Graph(XYZ2(wavelen).x - tex.y, 0.2) * sat);                  \n    \tcol = mix(col, vec3(0.0, 1.0, 0.0), Graph(XYZ2(wavelen).y - tex.y, 0.2) * sat);                  \n    \tcol = mix(col, vec3(0.0, 0.0, 1.0), Graph(XYZ2(wavelen).z - tex.y, 0.2) * sat);                  \n    }\n    \n    //col = mix(col, vec3(0.0, 0.0, 0.0), Graph(Blackbody(wavelen, 3000.0) - tex.y, 0.2) * 1.0);                  \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}