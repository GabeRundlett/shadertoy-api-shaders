{
    "Shader": {
        "info": {
            "date": "1500922227",
            "description": "Behind the scenes of my adventure game shader! This is the version before I added pretty graphics to it.\nFrom Tuesday to Friday I worked on this one, then I did the graphical overhaul over the weekend, then added some polish.",
            "flags": 48,
            "hasliked": 0,
            "id": "Xd2fWD",
            "likes": 5,
            "name": "Adventure Game - BTS",
            "published": 3,
            "tags": [
                "adventure"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 859
        },
        "renderpass": [
            {
                "code": "// data indices\n#define MAP_SIZE ivec2(128,128)\n#define PLAYER_POS_MAP (MAP_SIZE/2)\n// enemies get a whole row\n#define ENEMY_DATA_Y MAP_SIZE.y\n#define MAX_ENEMIES 16\n#define PLAYER_DATA ivec2(MAP_SIZE.x,0)\n#define PLAYER_STATS ivec2(MAP_SIZE.x+1,0)\n#define ATTACK_DATA ivec2(MAP_SIZE.x+2,0)\n#define INVENTORY_DATA ivec2(MAP_SIZE.x+3,0)\n\n#define EQ2(a,b) ((a).x==(b).x && (a).y==(b).y)\n#define LT2(a,b) ((a).x<(b).x && (a).y<(b).y)\n\n#define Get(index) texelFetch(iChannel0,index,0)\n\nint GetMagnification()\n{\n    return int(iResolution.y/float(MAP_SIZE.y));\n}\n\nivec2 ToScreen( vec2 a )\n{\n    int magnification = GetMagnification();\n    return ivec2(a)/magnification;\n}\n\nivec2 ToView( vec2 a )\n{\n    int magnification = GetMagnification();\n    return ToScreen(a) - ivec2(iResolution.xy*.5)/magnification;\n}\n\nconst ivec2 collectibles[] = ivec2[](\n        // position x, y\n        ivec2(180,100),\n        ivec2(100,400),\n        ivec2(529,481),\n        ivec2(303,233),\n        ivec2(327,228),\n        ivec2(690,100),\n        ivec2(620,440),\n        ivec2(300,570),\n        ivec2(300,800),\n        ivec2(300,700), // hard to get to\n        ivec2(965,875),\n        ivec2(970,700) // furthest away, via top right (hardest enemies should go there)\n    );\n\n\nfloat ShootTest( vec2 uv, vec2 dir )\n{\n    float d = dot(dir,uv);\n//    return d > .0 && d < 40. && sqrt(dot(uv,uv)-d*d) < 3.;\n    float perp2 = max(.0,dot(uv,uv)-d*d);\n    float par = max(-d,.0) + max(d-40.,.0);\n    return sqrt( par*par + perp2 ) - 3.;\n}\n       \n\n//--end of shared--\n\n\n// char is 0xVU, where V and U are the row and column of the character\n// Prints character in the range [(0,0),(.5,1)]\nfloat PrintCharacter( in int char, in vec2 uv )\n{\n    uint idx = uint(char);\n    vec2 charp = vec2( idx&0xFU, idx>>4U );\n\n//    uv = clamp(uv,vec2(0),vec2(.5,1));\n    if ( min(uv.x,uv.y) < .0 || max(uv.x-.5,uv.y-1.) > .0 )\n        return 0.;\n    uv.x += .25;\n//    return step(textureLod(iChannel0, (uv+charp)/16., .0).w,.5);\n//    return smoothstep(.53,.47,textureLod(iChannel1, (uv+charp)/16., .0).w );\n//    return textureLod(iChannel0, (uv+charp)/16., .0).x;\n    return 1.-textureLod(iChannel1, (uv+charp)/16., .0).w;\n}\n\n// prints a float in a box from (0,0) to (length*.5,1)\nfloat PrintInt( in int value, in vec2 uv )\n{\n    float o = .0;\n    int v;\n    bool y = false;\n    if ( value < 0 ) { o += PrintCharacter( 0xDD, uv ); uv.x -= .5; value = -value; }\n    v = (value/100000000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/10000000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/1000000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/100000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/10000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/1000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/100)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/10)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/1)%10; o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5;\n    return o;\n}\n\nbool InBox( ivec2 p, ivec2 a, ivec2 b )\n{\n/*    p = abs(2*p-a-b)-abs(a-b);\n    return p.x < 0 && p.y < 0; // will have 1-pixel error on odd-width/height*/\n    ivec2 i = min(a,b);\n    ivec2 j = max(a,b);\n    return p.x >= i.x && p.y >= i.y && p.x < j.x && p.y < j.y;\n}\n\n\nvec4 GameLose( ivec2 u )\n{\n    const int string[] = int[]( 0x50, 0xB7, 0xB1, 0xBD, 0xB5, 0x50, 0xBF, 0xA6, 0xB5, 0xA2,0x50 );\n    \n    //u.y -= iFrame/2; u.y = (u.y%40)+20;\n\n    vec2 uv = vec2(u) / 40. - vec2(-float(string.length())*.25,-.5);\n    float o = 0.;\n    for ( int i=0; i < string.length(); i++ )\n    {\n        o += PrintCharacter( string[i], uv ); uv.x -= .5;\n    }\n    return mix( vec4(1,0,0,1), vec4(1,1,0,1), smoothstep(.48,.52,o) );\n}\n\n\nvec4 GameWin( ivec2 u )\n{\n    float o = 0.;\n\n    const int string[] = int[]( 0xB3, 0xBF, 0xBE, 0xB7, 0xA2, 0xB1, 0xA4, 0xA5, 0xBC, 0xB1, 0xA4, 0xB9, 0xBF, 0xBE, 0xA3 );\n    vec2 uv = vec2(u) / 25. - vec2(-float(string.length())*.25,-1.1);\n\n    float a = .0;\n    for ( int i=0; i < string.length(); i++ )\n    {\n        a += PrintCharacter( string[i], uv ); uv.x -= .5;\n    }\n    o += smoothstep(.48,.52,a);\n    \n    const int string2[] = int[]( 0xA9, 0xBF, 0xA5, 0x50, 0xA7, 0xB9, 0xBE, 0xD1 );\n    uv = vec2(u) / 50. - vec2(-float(string2.length())*.25,.0);\n    float b = .0;\n    for ( int i=0; i < string2.length(); i++ )\n    {\n        b += PrintCharacter( string2[i], uv ); uv.x -= .5;\n    }\n    o += smoothstep(.49,.51,b);\n    \n    vec4 bg = max(sin(float(u.y+iFrame/2)*vec4(.2,.3,.5,1)*6.283/10.),vec4(0));\n    return mix( bg, 1.-bg.yzxw, o );\n}\n\n\nvoid mainImage( out vec4 o, in vec2 _u )\n{\n    int magnification = GetMagnification();\n    ivec2 screenPos = ToScreen(_u);\n    ivec2 u = ToView(_u);\n    \n    ivec2 mu = u+PLAYER_POS_MAP;\n    ivec2 mua = abs(mu-MAP_SIZE/2);\n\n    o = vec4(0);\n    \n    vec4 playerData = Get(PLAYER_DATA);\n    playerData.xy = floor(playerData.xy+.5);\n    ivec4 playerStats = ivec4(Get(PLAYER_STATS)); // max magic level, max health, magic regen rate, health regen rate\n    vec4 attackData = Get(ATTACK_DATA);\n    ivec4 inventoryData = ivec4(Get(INVENTORY_DATA)); // bitmask of collectibles, [bitmask of equipment, number of potions, number of lives]\n\n    \n    // detect game end states and abort\n\tif ( inventoryData.y <= 0 && iFrame > 0 )\n    {\n        o = GameLose(u);\n        return;\n    }\n    \n    if ( inventoryData.x == (1<<collectibles.length())-1 )\n    {\n        o = GameWin(u);\n        return;\n    }\n    \n    \n    if ( max(mua.x-MAP_SIZE.x/2,mua.y-MAP_SIZE.y/2) < 0)\n    {\n        // map\n        o = Get(mu);\n\n        // water\n        if ( o.z < .07 ) o = vec4(.2,.4,.7,1);\n        \n        \n        // pick-ups\n        for( int i=0; i < collectibles.length(); i++ )\n        {\n            if ( (inventoryData.x & (1<<i)) == 0 &&\n            \t EQ2(u,collectibles[i].xy-ivec2(playerData.xy)) )\n            {\n                o = vec4(float(iFrame%9)/8.,float(iFrame%11)/10.,1,1);\n            }\n        }\n        \n        \n        // magic effects\n        if ( attackData.x < 5. )\n        {\n            float s = ShootTest(vec2(u),attackData.zw);\n\t\t\tif ( s < .0 )\n            {\n            \to += vec4(0,1.-attackData.x/5.,1,0)*(-s/3.);\n            }\n        }\n\n        if ( attackData.y < 10. )\n        {\n            float l = length(vec2(u))/(20.-attackData.y);\n            if ( l < 1. ) o = mix(vec4(0),vec4(1),exp2(-vec4(1,4,16,1)*(l*attackData.y/10.)));\n        }\n        \n    \t// player\n        vec4 playerCol = playerData.w > .0 ? vec4(.3,1,.2,1) : vec4(uint(-playerData.w)&8U);\n\t    if ( EQ2(u,ivec2(0)) ) o = playerCol; //mix( playerCol, o, smoothstep(.7,1.7,length(vec2(u))) );\n\n        // enemies\n        for ( int i=0; i < MAX_ENEMIES; i++ )\n        {\n            vec4 enemyData = Get(ivec2(i,ENEMY_DATA_Y));\n            enemyData.xy = floor(enemyData.xy+.5);\n            if ( enemyData.w > 0.\n                && EQ2(u,ivec2(enemyData.xy-playerData.xy)) )\n            {\n                o = vec4(1,enemyData.w,.2,1);//, o, smoothstep(.7,1.7,length(enemyData.xy-playerData.xy-vec2(u))) );\n            }\n        }\n    }\n\n    // HUD\n    ivec2 bl = screenPos;\n    ivec2 tr = ivec2(iResolution.xy)/magnification - screenPos;\n    vec4 hud = vec4(0); // premultiplied alpha\n    \n    // energy bars\n    if ( InBox(bl,ivec2(4,4),ivec2(4+playerStats.x,8)) ) hud = (bl.x-4 <= int(playerData.z)) ? vec4(0,.4,1,1) : vec4(0,.2,.5,1)*.2;\n    if ( InBox(bl,ivec2(4,10),ivec2(4+playerStats.y,14)) ) hud = (bl.x-4 <= int(playerData.w)) ? vec4(1,0,0,1) : vec4(.5,0,0,1)*.2;\n    \n    // collectibles\n    if ( InBox(tr,ivec2(4,4),ivec2(4+collectibles.length()*5,8)) )\n    {\n        int idx = (tr.x-4)/5;\n        if ( ((tr.x-4)%5) != 0 )\n        \thud = (inventoryData.x & (1<<idx)) == 0 ? vec4(1)*.2: vec4(1);\n    }\n    \n    // collectible map\n    ivec2 m = tr-ivec2(4,10);\n    if ( InBox(m,ivec2(0),ivec2(32)) )\n    {\n        m = 31-m; // flip it back around\n        hud = textureLod(iChannel2,vec2(m)/31.,4.);\n        if ( hud.z < .07 ) hud = vec4(.4,.6,1,1);\n        hud *= .5;\n        if ( EQ2(m,ivec2(32.*playerData.xy/iChannelResolution[2].xy)) )\n        \thud = vec4(0,1,0,1);\n\n        for( int i=0; i < collectibles.length(); i++ )\n        {\n            if ( (inventoryData.x & (1<<i)) == 0 &&\n            \t EQ2(m,32*collectibles[i].xy/ivec2(iChannelResolution[2].xy)) )\n            {\n                hud = vec4(1);\n            }\n        }\n    }\n    \n    // lives\n    if ( InBox(tr,ivec2(4,44),ivec2(4,44)+ivec2(17,5)) )\n    {\n        ivec2 uu = tr - ivec2(4,44);\n        int life = uu.x/6;\n        uu.x = uu.x%6;\n\n        const int heartShape[] = int[] ( 0x0a, 0x1f, 0x1f, 0x0e, 0x04 );\n            \n\t\tfloat flash = 1.;\n        if ( playerData.w < .0 && int(inventoryData.y) == life+1 )\n        {\n            flash = (iFrame&8) == 0 ? .0 : 1.;\n        }\n            \n        if ( (heartShape[uu.y]&(1<<uu.x)) != 0 )\n            hud = int(inventoryData.y) > life ? vec4(1,0,0,1)*flash : vec4(1,0,0,1)*.0;\n    }\n    \n\n/*    // Debug Text\n    vec2 l = _u;\n    l.y -= iResolution.y;\n    l /= 16.;\n    l.y += 1.; hud += vec4(1,1,0,1) * smoothstep(.47,.53,PrintInt( int(playerData.x), l ));\n    l.y += 1.; hud += vec4(1,1,0,1) * smoothstep(.47,.53,PrintInt( int(playerData.y), l ));*/\n    \n\n    o = o*(1.-hud.a) + hud; // premultiplied alpha\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// data indices\n#define MAP_SIZE ivec2(128,128)\n#define PLAYER_POS_MAP (MAP_SIZE/2)\n// enemies get a whole row\n#define ENEMY_DATA_Y MAP_SIZE.y\n#define MAX_ENEMIES 16\n#define PLAYER_DATA ivec2(MAP_SIZE.x,0)\n#define PLAYER_STATS ivec2(MAP_SIZE.x+1,0)\n#define ATTACK_DATA ivec2(MAP_SIZE.x+2,0)\n#define INVENTORY_DATA ivec2(MAP_SIZE.x+3,0)\n\n#define EQ2(a,b) ((a).x==(b).x && (a).y==(b).y)\n#define LT2(a,b) ((a).x<(b).x && (a).y<(b).y)\n\n#define Get(index) texelFetch(iChannel0,index,0)\n\nint GetMagnification()\n{\n    return int(iResolution.y/float(MAP_SIZE.y));\n}\n\nivec2 ToScreen( vec2 a )\n{\n    int magnification = GetMagnification();\n    return ivec2(a)/magnification;\n}\n\nivec2 ToView( vec2 a )\n{\n    int magnification = GetMagnification();\n    return ToScreen(a) - ivec2(iResolution.xy*.5)/magnification;\n}\n\nconst ivec2 collectibles[] = ivec2[](\n        // position x, y\n        ivec2(180,100),\n        ivec2(100,400),\n        ivec2(529,481),\n        ivec2(303,233),\n        ivec2(327,228),\n        ivec2(690,100),\n        ivec2(620,440),\n        ivec2(300,570),\n        ivec2(300,800),\n        ivec2(300,700), // hard to get to\n        ivec2(965,875),\n        ivec2(970,700) // furthest away, via top right (hardest enemies should go there)\n    );\n\n\nfloat ShootTest( vec2 uv, vec2 dir )\n{\n    float d = dot(dir,uv);\n//    return d > .0 && d < 40. && sqrt(dot(uv,uv)-d*d) < 3.;\n    float perp2 = max(.0,dot(uv,uv)-d*d);\n    float par = max(-d,.0) + max(d-40.,.0);\n    return sqrt( par*par + perp2 ) - 3.;\n}\n       \n\n//--end of shared--\n\n\n#define K(a) texelFetch(iChannel1,ivec2(a,0),0).x\n\n#define SHOOT_COST 20.\n#define BLAST_COST 90.\n\nuint g_randCount = 0U;\n\nfloat Rand( int index )\n{\n    uint n = g_randCount + uint(iFrame)*20U + uint(index)*400U; //20U = more than number of calls per frame\n    g_randCount++;\n    \n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float( n & 0x7fffffffU)/float(0x7fffffff);\n}\n\nfloat Rand() { return Rand(0); }\n\nvoid mainImage( out vec4 o, in vec2 _index )\n{\n    ivec2 index = ivec2(_index);\n    \n    // leave data intact unless we have something we need to do to it\n    o = Get(index);\n\n    vec4 playerData = Get(PLAYER_DATA); // position, magic level, health\n    vec4 playerStats = Get(PLAYER_STATS); // max magic level, max health, magic regen rate, health regen rate\n    vec4 attackData = Get(ATTACK_DATA); // magic cool-down, ...\n    ivec4 inventoryData = ivec4(Get(INVENTORY_DATA)); // bitmask of collectibles, [bitmask of equipment, number of potions, number of lives]\n\n    if ( ( inventoryData.y <= 0 && iFrame > 0 )\n    \t|| ( inventoryData.x == (1<<collectibles.length())-1 ) )\n    {\n        // game has ended, do nothing\n        return;\n    }\n    \n    \n    \n    bool alive = playerData.w >= .0;\n    \n    // INPUTS\n    \n    // how much should we move this frame?\n    ivec2 delta = ivec2( K(39)-K(37), K(38)-K(40) ); // cursors\n    delta += ivec2( K(68)-K(65), K(87)-K(83) ); // WASD\n    \n    if ( (iFrame&1) != 0 // slow down player\n        || !alive ) // don't move when you're dead\n        delta = ivec2(0);\n    \n    // collisions - yes, we need this for every pixel (could maybe do another buffer if it was expensive)\n//    if ( Get(PLAYER_POS_MAP+delta).z < .07 ) delta = ivec2(0);\n    if ( Get(PLAYER_POS_MAP+ivec2(delta.x,0)).z < .07 ) delta.x = 0;\n    if ( Get(PLAYER_POS_MAP+delta).z < .07 ) delta.y = 0;\n    \n    \n    ivec2 qqq = ToView(iMouse.zw);\n    vec2 rangedAttack = normalize(vec2(qqq));\n    bool shooting = alive && LT2( abs(qqq), MAP_SIZE/2 ) && attackData.x > 30.0 && playerData.z >= SHOOT_COST;\n    bool blasting = alive && K(32) != .0 && attackData.y > 150.0 && playerData.z >= BLAST_COST;\n    \n    \n    if ( iFrame == 0 )\n    {\n        playerData = vec4(32,32,100,100);\n        playerStats = vec4(100,100,.1,.02);\n        attackData = vec4(1000,1000,0,0);\n        inventoryData = ivec4(0,3,0,0);\n    }\n\n    // move player here, because everything needs to agree about player's position\n    // other player stats just get updated if we're on the player data/stat pixels\n    playerData.xy += vec2(delta);\n    \n    // death state\n    bool respawn = false;\n    if ( !alive )\n    {\n        playerData.w += 1.;\n        if ( playerData.w > -1. )\n        {\n            respawn = true;\n        }\n    }\n    \n    if ( EQ2( index, PLAYER_DATA ) )\n    {\n        if ( alive ) // don't update player state while dead!\n        {\n            // test for enemy collisions\n            int damage = 0;\n            for ( int i=0; i < MAX_ENEMIES; i++ )\n            {\n                vec4 enemyData = Get(ivec2(i,ENEMY_DATA_Y));\n                if ( enemyData.w > 0.\n                   && length(playerData.xy-enemyData.xy) < 3.\n                   && ((iFrame+i)&7) == 0 )\n                {\n                    damage += 3;\n                }\n            }\n\n            playerData.w += (damage == 0) ? playerStats.w: float(-damage);\n            if ( playerData.w < .0 ) playerData.w = -180.;\n\n            // use magic\n            playerData.z += blasting ? -BLAST_COST : shooting ? -SHOOT_COST : min(attackData.x,attackData.y) < 30.0 ? .0 : playerStats.z;\n\n            playerData.zw = min( playerData.zw, playerStats.xy );\n        }\n\n        if ( respawn )\n        {\n            playerData.zw = vec4(32,32,100,100).zw;\n        }\n        \n        o = playerData;\n    }\n    \n    if ( EQ2( index, PLAYER_STATS ) )\n    {\n    \to = playerStats;\n    }\n    \n    if ( EQ2( index, ATTACK_DATA ) )\n    {\n        attackData.x = shooting ? 0. : attackData.x+1.; // shoot cooldown\n        attackData.y = blasting ? 0. : attackData.y+1.; // blast cooldown\n        if ( shooting ) attackData.zw = rangedAttack; // last attack direction\n    \to = attackData;\n    }\n    \n    if ( EQ2( index, INVENTORY_DATA ) )\n    {\n        for( int i=0; i < collectibles.length(); i++ )\n        {\n            if ( (inventoryData.x & (1<<i)) == 0 &&\n            \tlength(playerData.xy - vec2(collectibles[i].xy)) < 3. )\n            {\n                inventoryData.x |= 1<<i;\n            }\n        }\n        \n        if ( respawn )\n        {\n            inventoryData.y--; // lose a life\n        }\n        \n        o = vec4(inventoryData);\n    }\n        \n    if ( index.y == ENEMY_DATA_Y )\n    {\n        vec4 enemyData = Get(index);\n\n        // enemy data: xy = pos, w = health/dead/blank\n        if ( enemyData.w <= .0 )\n        {\n            if ( index.x < MAX_ENEMIES && !EQ2(delta,ivec2(0)) ) // can we create an enemy?\n            {\n                // decide whether to spawn an enemy in this slot\n                /*don't want rate of spawning affected by number of slots\n                and we have no atomic state\n                => have to scan to test if this is the first empty slot\n                - alternatively we could shift everything down every time an enemy dies - but that's a similar problem*/\n\n                // Am I the first empry slot?\n                int i=0;\n                for ( ; i < MAX_ENEMIES; i++ )\n                {\n                    if ( Get(ivec2(i,ENEMY_DATA_Y)).w <= 0. || i == index.x )\n                        break;\n                }\n\n                if ( i == index.x )\n                {\n                    // I'm the first empty slot, decide whether to spawn an enemy\n\t\t\t\t\tif ( Rand() < 1./20. ) // enemies/framesOfMovement\n                    {\n                        // enemy type\n                        enemyData.w = 1.; // full health\n                        enemyData.z = 0.;//todo: type - speed vs damage/strength - i.e. \"size\"\n\n                        // put it on one of the sides we're moving toward\n                        //enemyData.xy = playerData.xy + vec2(sign(delta)*(MAP_SIZE/2-1));\n                        enemyData.xy = vec2(Rand(),Rand())*vec2(MAP_SIZE);\n                        // flatten to leading edge in direction of travel\n\t\t\t\t\t\tenemyData.xy -= vec2(MAP_SIZE/2);\n\n// this doesn't work on up-left and down-right, fine in other directions\n//                        enemyData.xy += dot(abs(vec2(MAP_SIZE/2)-enemyData.xy),vec2(delta))*vec2(delta);\n                        enemyData.xy += dot(vec2(MAP_SIZE/2)*sign(vec2(delta))-enemyData.xy,vec2(delta))*vec2(delta);\n\t\t\t\t\t\t\n                        enemyData.xy += vec2(MAP_SIZE/2);\n                        enemyData.xy += playerData.xy-vec2(PLAYER_POS_MAP);\n                            \n                        \n\t               \t\tif ( enemyData.x < .0 || enemyData.y < .0 || enemyData.x >=  iChannelResolution[2].x || enemyData.y >=  iChannelResolution[2].y )\n                        {\n                            // abort creation\n                            enemyData = vec4(0);\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            vec2 enemyPosView = enemyData.xy-playerData.xy;\n            \n            // take damage\n            if ( shooting && ShootTest(enemyPosView,rangedAttack) <= .0 )\n                enemyData.w -= .5;\n            if( blasting && length(enemyPosView) < 20. )\n                enemyData.w -= 2.;\n            \n            // move enemy\n            if ( max(abs(enemyPosView.x),abs(enemyPosView.y)) > float(MAP_SIZE/2+1) )\n            {\n                enemyData = vec4(0); // cull\n            }\n            else\n            {\n                if ( length(enemyPosView) < 32. )\n                {\n                    // track player\n                    if ( ((iFrame+index.x)&3) == 0 ) // don't step them all on the same frame\n                    {\n                        //enemyData.xy += sign(playerData.xy-enemyData.xy); // integer movement\n                        // or do float movement to get better-looking direction\n                        enemyData.xy -= normalize(enemyPosView);\n                    }\n                }\n                else\n                {\n                    // idle\n                    if ( ((iFrame+index.x)&15) == 0 )\n                    {\n                        enemyData.xy += floor(2.999*vec2(Rand(index.x),Rand(index.x)))-1.;\n                    }\n                }\n            }\n        }\n                        \n//if ( iFrame == 0 && index.x == 0 ) enemyData = vec4(48,48,0,1);\n        \n        if ( playerData.w < .0 )\n            enemyData = vec4(0); // kill all enemies\n        \n\t\to = enemyData;\n    }\n    \n    if ( LT2( index, MAP_SIZE ) )\n    {\n        if ( delta.x != 0 || delta.y != 0 )\n        {\n            // scroll map\n            o = Get(index+delta); // this will over/underflow but we'll fix that next\n        }\n        \n        if (\n            iFrame < 60 || // wait until textures are loaded\n//            respawn || // redraw after death (teleport)\n            ( index.x == 0 && delta.x < 0 ) ||\n            ( index.y == 0 && delta.y < 0 ) ||\n            ( index.x == MAP_SIZE.x-1 && delta.x > 0 ) ||\n            ( index.y == MAP_SIZE.y-1 && delta.y > 0 )\n            )\n        {\n            ivec2 uv = index+ivec2(playerData)-PLAYER_POS_MAP;\n            \n        \t// redraw this pixel\n            o = texelFetch(iChannel2,uv,0);\n            \n            // fade the edge to make everything water\n            uv = abs(uv - ivec2(iChannelResolution[2].xy)/2);\n            uv = abs(uv - ivec2(iChannelResolution[2].xy)/2);\n            o *= smoothstep(0.,10.,float(min(uv.x,uv.y)));\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}