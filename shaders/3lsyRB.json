{
    "Shader": {
        "info": {
            "date": "1592376402",
            "description": "playing with the n vector usually producing the simplex noise via n.x+n.y+n.z ( from Iq's implem, inspired by izutionix's [url]https://shadertoy.com/view/tlfczS[/url] ).\nleft to right:  n.xyz, sorted, sum, length, max, min, harmon\nbottom: idem for abs(n)",
            "flags": 16,
            "hasliked": 0,
            "id": "3lsyRB",
            "likes": 35,
            "name": "inside Simplex Noise ",
            "published": 3,
            "tags": [
                "voronoi",
                "noise",
                "worley",
                "simplex",
                "cells",
                "worms",
                "brain",
                "intestines"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1673
        },
        "renderpass": [
            {
                "code": "// === analyzing the effects of Simplex Noise components ==============\n//    - isolate effect of n components, sorted or not, without or with abs\n//    - normalized on different ways ( uncomment #48 and possibly #47 )\n//    - using gradients normalized or not ( swap comment #13/14 )\n//    uncomment #44 to see identical noise in tiles\n//    click for better histogram balance\n\n// inspired by izutionix's \"Simplex Noise Worms and Cells\" https://shadertoy.com/view/tlfczS\n// playing with Iq's Simplex Noise implem https://www.shadertoy.com/view/Msf3WH\n\n#define S 2.     // scale of noise\n\n// refactored from Iq's version\n  #define  hash(p) fract(sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123)\n  #define shash(p)          ( 2.*hash(p) -1. )\n//#define shash(p) normalize( 2.*hash(p) -1. )\n\nvec3 snoise( vec2 p ) {\n    float K1 = .366025404, // (sqrt(3)-1)/2; = -.5+.5*sqrt(3)\n          K2 = .211324865; // (3-sqrt(3))/6; =  .5-.5/sqrt(3)\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 ), // F(p*M), M = ( sqrt(3) + mat2(1,-1,-1,1) )/2.\n          a =    p - i + (i.x+i.y)*K2  , // p -F(pM)M⁻¹  \n          o = step( a.yx, a ), // set 1 on the axis of max value\n          b = a - o  +    K2,\n\t      c = a - 1. + 2.*K2;  // < a,b,c > ~= 3 hexa axis: show every 2 seconds\n    if (mod(iTime,2.)>1.) return vec3(length(a),length(b),length(c))*2.-1.;\n    vec3  h = max( .5 - vec3( dot(a,a), dot(b,b), dot(c,c) ), 0. ),\n\t      n = h*h*h*h * vec3( dot(a, shash(i   )),   // random gradients at each...\n                              dot(b, shash(i+o )),   //   node of the triangle grid\n                              dot(c, shash(i+1.)) ); // h⁴: pseudo-Gaussian kernel cf https://www.desmos.com/calculator/ioek66ltzu\n    \n // return dot( n, vec3(70.) );  // original\n    return 70.*n;                // I instead return the full vector\n}\n\n//                                   if signed, remap to 0,1\n#define V(n,s)   s==1 && y==1 ? vec4(.5+.5*vec3(n)      , 1 ) \\\n               : s==2 && y==1 ? vec4(.5+.5*vec3(n)/.627 , 1 ) \\\n               :                vec4(vec3(n), 1 )\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 R = iResolution.xy,\n         U = 7.*u/R.y;\n    int  x = int(7.*u/R), y = int(2.*u.y/R.y); \n // U = 7./R.y*mod(u,R/vec2(7,2));                 // identical noise in tiles\n    vec3 n = snoise(S*U),s=n, \n         m = iMouse.z>0. ? y==1 && x==1 ? vec3(1.5) : vec3(1,3.4,14.3) : vec3(1); \n    float v=0.;      \n  //v = (n.x+n.y+n.z)/3.;                          // below: center first\n  //s = n = v+(n-v)/length(n-v);                   // normalization by variance\n    if (y==0) s = n = abs(n);\n    s =   s.y <= min(s.x,s.z) ? s.yxz              // s = sorted n ( NB: <= is crucial ! )\n        : s.z <  min(s.x,s.y) ? s.zxy : s,\n    s =   s.z <  s.y ? s.xzy : s; \n    \n    O =   x==0 ? V( n           , 2)               // components of n\n        : x==1 ? V( s.zyx *m    , 2)               // sorted components\n        : x==2 ? V( n.x+n.y+n.z , 1)               // usual noise: sum (= average)\n        : x==3 ? V( length(n)   , 0)               // quadratic sum\n        : x==4 ? V( s.z +.1     , 0)               // max\n        : x==5 ? iMouse.z<=0. ? V( .8+2.*s.x , 1 ) // min\n                 :  vec4( y>0 ?.9+s.x : 8.*s.x   ) //  if click, better hist balancing\n        :      ( v = n.x*n.y*n.z,\n                 V( 8.*sign(v)*pow(abs(v),1./3.) , 1) );   // harmonic average\n     \n    if (m.x==1.5) O -= vec4(.43,.3,-.15,0), O.b = 1.-O.b;\n            \n  //if (iFrame/10%2==0) O = fract(O);                      // test under/overflow              \n    if ( mod(iTime,4.)<2.) O = pow(O,vec4(1./2.2));        // to sRGB\n    U = mod(u,R/vec2(7,2)); if ( U.x<1. || U.y<1. ) O-=O;  // separator\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}