{
    "Shader": {
        "info": {
            "date": "1501176103",
            "description": "mouse sets one vector.\n\nline segments without division inside the function, colinear segments are faster.\n\nmy approach to more symmetry is by substitution. buffer or delay slow functions as much as possible.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xd2fRK",
            "likes": 6,
            "name": "line segment withut division",
            "published": 3,
            "tags": [
                "line",
                "complex",
                "smoothstep",
                "segment",
                "symmetry",
                "neon",
                "linesegment",
                "normalize",
                "disymmetry"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 911
        },
        "renderpass": [
            {
                "code": "/*\nhttps://www.shadertoy.com/view/4dBfzG\nmade me think about searching substitutions to utilize more symmetry in my line segment functions.\nI just love to find alternatives to dot()/dot():\n\nThis shader takes  normalize() out of length() and dot()/dot().\nIt makes m=normalize(m) the first step, which can easily be buffered outside the function.\n-> distance-to-line_segment/ray functions without any division and without atan()\n\nThis can be faster if you have many different colinear line segments and rays...\n...usually a straight hole is filled with something that is faiirly colinear to the hole\n...subway trains, pills on a conveyor, bulet in a gun.\nThis can be faster when working with already normalized vectors, like quaternions?\nThis can be faster for some complex numbers on a unit sphere?\n\nI am pretty sure this is also useful for polar, bipolar and spiral transformations.\nand any kind of transformed straight track.\n*/\n\n#define viewScale 4.\n\n#define frame(u) ((u-.5*iResolution.xy)*viewScale/iResolution.y)\n\n//return distance to line segment from vec2(0) to vec2(1,0)\nfloat lsNoDot(vec2 p){p.x-=.5;p=abs(p);return mix(length(p-vec2(.5,0)),p.y,step(p.x,.5));}\n\n//an alternative to the dotproduct line segment.\n\n//blurryness for anti aliasing\n#define blur 4.\n\n//pseudo-antialiasing, made dependant on screen resolution.\n#define crisp (blur/iResolution.y)\n\n\n\n\n//too bad this sucker has a division in it:\n//smoothstep also constains clamp() which has shown some inconsistencies for NaN\n#define ss(a) a=smoothstep(crisp,-crisp,a);\n//above is smoothstep, blow is smootheststep, which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss(a) (1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n//rotate counterclockwise by 90deg==make perpendicular\n#define perp(a) vec2(-a.y,a.x)\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat line(vec2 u,vec2 m){\n //return determinant(mat2(u,m));//determinant()==openGL_1.5, bad compatibility.\n return dot(m,perp(u));}//2d determinant==perpendicular dotproduct.\nfloat lineN(vec2 u,vec2 m){return line(u,normalize(m));}\n//https://www.shadertoy.com/view/4dBfzG\n//return unsigned distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat lsa(vec2 u,vec2 m){return abs(line(u,m));}\nfloat lsaN(vec2 u,vec2 m){return abs(line(u,normalize(m)));}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat ils(vec2 u,vec2 m){\n //return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\nfloat ilsN(vec2 u,vec2 m){return ils(u,normalize(m));}\n                         \n//return distance of [u] to line_segment from (0,0) to [m],m must be normalized!\n//this line segment has a length of 1.\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\nfloat ls1N(vec2 u,vec2 m){return ls1(u,normalize(m));}\n\n//return distance of [u] to line_segment from (0,0) to [m], n must be normalized\n//[m] must NOT be normalized!\nfloat ls(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless            \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\nfloat lsN(vec2 u,vec2 m){return ls(u,normalize(m),m);}\n\n//return distance of [u] to line_segment from (0,0) to [n]*[a], n must be normalized\nfloat lss(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m); //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless            \n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless            \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\nfloat lssN(vec2 u,vec2 n,float a){return lss(u,normalize(n),a);}\n\n\nvoid mainImage( out vec4 O, in vec2 U ){\n vec2 u=frame(U);\n vec2 m=frame(iMouse.xy);\n vec3 c=vec3(0);\n vec2 n=normalize(m);//we only normalize m once, and use that for 3 different lineX distances.\n //all divisions happen above this line, below this line is division-free zone.\n //length() happens, but is really not too important.\n c.r=lsa(u,n);\n c.b=ils(u,n);\n c.g=ls(u,n,m);\n //c.g=(1.-cos(clamp(u.x*acos(-1.),0.,1.*acos(-1.)))-u.y);\n //c.g=ls1(p,n);//line segment of length 1\n c-=sin(iTime)*.5+.5;  \n c=abs(c)-.25*(sin(iTime*.61)*.5+.5);\n c=sss(1.-c);//smoothstep does have 1 division. so we use \"smootheststep()\"\n //c*=.5;O=vec4(c+c.yzx,1);\n O=vec4(c.xyz,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}