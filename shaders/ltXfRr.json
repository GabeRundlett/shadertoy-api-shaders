{
    "Shader": {
        "info": {
            "date": "1510781854",
            "description": "Explanations for [url]https://www.shadertoy.com/view/4lXfzn[/url]\nRight: interest point (Mouse control).\nLeft, in red: anisotropic pixel footprint in texture space.\n2 alternate implem are proposed ( #if )",
            "flags": 32,
            "hasliked": 0,
            "id": "ltXfRr",
            "likes": 13,
            "name": "Antialiasing Demo 3",
            "published": 3,
            "tags": [
                "aliasing",
                "filtering",
                "ellipse",
                "footprint"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1505
        },
        "renderpass": [
            {
                "code": "// Note that hardware x16 aniso *should* ideally compute the footprint ellipse, \n// but I bet it just use max(dFdx,dFdy) as main axis and the other as min radius.\n\nvec2 R;\n#if 1\n// --- computes eigenvalues and eigenvectors of J\nvoid eigen(in mat2 J, out vec2 A0, out vec2 A1, out float r0, out float r1) {\n    float d = determinant(J), t = J[0][0]+J[1][1],  // find ellipse: eigenvalues, max eigenvector\n          D = sqrt(t*t-4.*d); \n          r0 = (t+D)/2., r1 = (t-D)/2.;             // eigenvalues \n    A0 = normalize(vec2( -J[0][1], J[0][0] -r0 ));  // eigenvectors\n    A1 = normalize(vec2( -J[0][1], J[0][0] -r1 ));\n    vec2 I; if (r1>r0) d=r0,r0=r1,r1=d, I=A0,A0=A1,A1=I; // sort eigenV  ( in fact, useless )\n\n}\n\n// --- computes ellipse geometry from Jacobian\nvoid ellips(in mat2 J, out vec2 A0, out vec2 A1, out float r0, out float r1) {\n    J = inverse(J); J = transpose(J)*J;             // quadratic form equiv to length(J⁻¹.P) = 1\n\teigen(J, A1,A0,r1,r0);                          // eigenvector = axis\n    r0 = 1./sqrt(r0);                               // eigenvalues = 1./radii^2\n    r1 = 1./sqrt(r1); \n}\n#else\n// --- alternate direct computation of ellipse geometry. Which is cheaper ? ( both have 5 sqrt +  5 div )\nvoid ellips(in mat2 M, out vec2 A0, out vec2 A1, out float r0, out float r1) {\n    vec2 I = M[0], J = M[1];                        // ellipse: P = cos(u).I + sin(u).J \n    float a = ( dot(J,J) - dot(I,I) ) / dot (I,J),  // -> search for extrema of length(P) \n          D = sqrt(a*a+4.),                         // get tan(u) -> s, c, axis*radii\n          t0 = (a+D)/2., t1 = (a-D)/2.;\n    A0 = (I + t0*J) / sqrt(1.+t0*t0);               // c = 1/sqrt(1+t²), s = t/sqrt(1+t²)\n    A1 = (I + t1*J) / sqrt(1.+t1*t1);               // axis also encodes radius\n    r0 = length(A0); A0 /= r0;\n    r1 = length(A1); A1 /= r1;\n    if (r1>r0) a=r0,r0=r1,r1=a, I=A0,A0=A1,A1=I;    // sort eigenV\n\n}\n#endif\n\n// --- compute texture average on pixel footprint\nvec4 textureAniso(sampler2D T, vec2 p) {\n    mat2 J = mat2(dFdx(p),dFdy(p));                 // pixel footprint in texture space\n    vec2 A,a; float M,m,l;\n    ellips(J, A,a,M,m); \n    A *= M;\n    l = log2( m * R.y );                            // MIPmap level corresponding to min radius\n    if (M/m>16.) l = log2(M/16.*R.y);               // optional      \n    vec4 O = vec4(0);\n    for (float i = -7.5; i<8.; i++)                 // sample x16 along main axis at LOD min-radius\n        O += textureLod(iChannel0, p+(i/16.)*A, l);\n    return O/16.;\n}\n\n#define pers(P)   - vec2( 2.*(P).x-1., 1 ) / (2.*(P).y-1.) / 4.  // - r.xz/r.y\n                                                    // / 4 because texture contains big tiles\nvoid mainImage( out vec4 O, vec2 U )\n{\n    R = iResolution.xy; \n    vec2 P = iMouse.xy,\n         e = vec2(1./R.y,0);\n    if (length(P)<10.) P = R*vec2(.7,.2) + .15*R*vec2(cos(iTime),sin(iTime)); \n    U /= R; P /= R; \n    \n    // --- drawing antialiased mapped texture\n    vec2 p  = pers(U);                              // pixel ray intersection on floor\n    O =   U.x < .5 ? texture(iChannel0,U)\n        : U.y > .5 ? vec4(.5, .7, .9, 1)            // background\n        :            textureAniso(iChannel0, p);    // anisotropic\n\n    // --- drawing footprints\n    vec2 p0 = pers(P);                              // floor projection of interest point under mouse\n#define spot(v,C)   O = mix(O, C, smoothstep( 1./R.y, 0., length(v) -.03 ) )  \n    vec4 red = vec4(1,0,0,0), blue = vec4(0,0,1,0);\n\n    spot( (p-p0)*R/R.y , blue);\n    spot( (U-P )*R/R.y , red);                      // interest point (screen space )\n   \n    vec2 A,a; float M,m,l, k;\n    mat2 J = mat2( pers(P+e)-p0, pers(P+e.yx)-p0);  // pixel footprint in texture space\n    ellips(J, A,a,M,m); \n    spot( (U-p0)*mat2(A/M,a/m)/R.y , red);          // why / R.y ?\n    spot( (U-p0)*R/R.y , blue);   \n    O = pow(O,vec4(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u )\n{   ivec2 U = ivec2( u / iResolution.xy * 8. ) % 2;\n    O = vec4( U.x == U.y );\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}