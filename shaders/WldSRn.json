{
    "Shader": {
        "info": {
            "date": "1580288662",
            "description": "Raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "WldSRn",
            "likes": 75,
            "name": "002-Blue",
            "published": 3,
            "tags": [
                "cineshader"
            ],
            "usePreview": 0,
            "username": "haquxx",
            "viewed": 50127
        },
        "renderpass": [
            {
                "code": "float sdSphere(vec3 pos, float size)\n{\n    return length(pos) - size;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n    pos = abs(pos) - vec3(size);\n    return max(max(pos.x, pos.y), pos.z);\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdPlane(vec3 pos)\n{\n    return pos.y;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 repeat(vec3 pos, vec3 span)\n{\n    return abs(mod(pos, span)) - span * 0.5;\n}\n\nfloat getDistance(vec3 pos, vec2 uv)\n{\n    vec3 originalPos = pos;\n\n    for(int i = 0; i < 3; i++)\n    {\n        pos = abs(pos) - 4.5;\n        pos.xz *= rotate(1.0);\n        pos.yz *= rotate(1.0);\n    }\n\n    pos = repeat(pos, vec3(4.0));\n\n    float d0 = abs(originalPos.x) - 0.1;\n    float d1 = sdBox(pos, vec3(0.8));\n\n    pos.xy *= rotate(mix(1.0, 2.0, abs(sin(iTime))));\n    float size = mix(1.1, 1.3, (abs(uv.y) * abs(uv.x)));\n    float d2 = sdSphere(pos, size);\n    float dd2 = sdOctahedron(pos, 1.8);\n    float ddd2 = mix(d2, dd2, abs(sin(iTime)));\n  \n    return max(max(d1, -ddd2), -d0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera\n    vec3 cameraOrigin = vec3(0.0, 0.0, -10.0 + iTime * 4.0);\n    vec3 cameraTarget = vec3(cos(iTime) + sin(iTime / 2.0) * 10.0, exp(sin(iTime)) * 2.0, 3.0 + iTime * 4.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec3 rayDirection = normalize(cameraRight * p.x + cameraUp * p.y + cameraDir);\n    \n    float depth = 0.0;\n    float ac = 0.0;\n    vec3 rayPos = vec3(0.0);\n    float d = 0.0;\n\n    for(int i = 0; i < 80; i++)\n    {\n        rayPos = cameraOrigin + rayDirection * depth;\n        d = getDistance(rayPos, p);\n\n        if(abs(d) < 0.0001)\n        {\n            break;\n        }\n\n        ac += exp(-d * mix(5.0, 10.0, abs(sin(iTime))));        \n        depth += d;\n    }\n    \n    vec3 col = vec3(0.0, 0.3, 0.7);\n    ac *= 1.2 * (iResolution.x/iResolution.y - abs(p.x)) ;\n    vec3 finalCol = col * ac * 0.06;\n    fragColor = vec4(finalCol, 1.0);\n    fragColor.w = 1.0 - depth * 0.1;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}