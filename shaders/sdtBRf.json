{
    "Shader": {
        "info": {
            "date": "1656955373",
            "description": "Today I found a way to create a circle from the coordinates. It just checks the distance between the vec2 pixel from the origin. If the distance is below a range, paint it with Japan flag red. The wobbling is made affecting the uv space.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdtBRf",
            "likes": 1,
            "name": "004 - Windy Japan flag",
            "published": 3,
            "tags": [
                "beginner",
                "sin",
                "circle",
                "cos",
                "learning",
                "japan"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 245
        },
        "renderpass": [
            {
                "code": "// 2022.07.04 rev 1\n// 2022.07.05 rev 2 - did improvements that FabriceNeyret2 suggested. learned simple antialias :). some refactors.\n// 2022.07.07 rev 3 - small changes in the cycle function and antialias improve\n\n#define PI 3.14159265\n#define TWOPI 6.2831853\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    // doing this multiplication, we make the animation % grow by perSecond factor\n    // iTime is the current time + timeDelta for precision\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |1          |0.1    |\n    // |0.2    |1          |0.2    |\n    // |0.45   |1          |0.45   |\n    // |0.5    |1          |0.5    |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |2          |0.2    |\n    // |0.2    |2          |0.4    |\n    // |0.45   |2          |0.9    |\n    // |0.5    |2          |0      |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |0.5        |0.05   |\n    // |0.2    |0.5        |0.1    |\n    // |0.45   |0.5        |0.225  |\n    // |0.5    |0.5        |0.25   |\n    // |_______|___________|_______|\n\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    \n    // step 0.5 is used to reverse the keyframe, to get a coming and going effect\n    \n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\n// returns a constant cycle instead of comming and going from cycle function\n// ______________________________________________\n// | iTime | perSecond | range     |   return   |\n// |_______|___________|___________|____________|\n// |0.1    |0.5        |10         |2.5         |\n// |3.4    |0.5        |10         |17          |\n// |_______|___________|___________|____________|\n//\n// doing a sin() with the return allows you to \"skew through the range\" seamlessly \nfloat constCycle(float perSecond, float range) {\n    return ((iTime + iTimeDelta) * perSecond) * range;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    uv.x += (cos(uv.y * 10.0 + (constCycle(0.3, -12.0)))/150.0) - ((cycle(0.07) * 0.1)-0.05);\n    uv.y += (sin(uv.x * 10.0 + (constCycle(0.5, -12.0)))/175.0) - ((cycle(0.03) * 0.1)-0.05);\n    \n    float antiAlias = 1.5/iResolution.y; // the larger the screen, the subtle is the antialias\n    \n    vec3 c;\n\n    vec3 japanRed = vec3(0.73, 0.0, 0.01);\n    vec3 waves = vec3(min(\n            245.0, \n            255.0 * abs(sin(uv.y * 15.0 + (constCycle(0.25, 1.0)))/5000.0) + 0.94\n        ));\n    \n    c = mix(\n        japanRed, \n        waves,\n        smoothstep(0.5 - antiAlias, 0.5 + antiAlias, length(uv))\n    );\n\n    fragColor = vec4(\n        c, \n        1\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}