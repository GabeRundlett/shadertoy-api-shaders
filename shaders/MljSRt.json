{
    "Shader": {
        "info": {
            "date": "1445960710",
            "description": "Feel the retro! :)",
            "flags": 8,
            "hasliked": 0,
            "id": "MljSRt",
            "likes": 37,
            "name": "Chiptune (sound)",
            "published": 3,
            "tags": [
                "sound",
                "retro",
                "oldskool",
                "tracker"
            ],
            "usePreview": 1,
            "username": "srtuss",
            "viewed": 816
        },
        "renderpass": [
            {
                "code": "// srtuss, 2015\n\n#define ABERATE\n\nfloat tempo = 1.3;\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat fun(float id, vec2 p)\n{\n    float a = 0.0, b = 0.0;\n    #define _CD(n,va,vb) a+=step(abs(id-n),0.4)*va;b+=step(abs(id-n),0.4)*vb\n    _CD(0.,-8188350.,8232831.); _CD(1.,-8587020.,8269920.);\n    _CD(2.,-9181598.,8309809.); _CD(3.,-9181598.,3984769.);\n    _CD(4.,7183928.,15778811.);_CD(5.,508351.,3984771.);\n    _CD(6.,-14730012.,3984793.); _CD(7.,-793023.,1585249.);\n    _CD(8.,-13425054.,3984793.); _CD(9.,-13425054.,1859971.);\n    _CD(10.,6353724.,7968792.); _CD(11.,14261023.,4119350.);\n    _CD(12.,-12952447.,16718001.); _CD(13.,-12952447.,1972401.);\n    _CD(14.,6353724.,16358296.); _CD(15.,14261784.,13474806.);\n    _CD(16.,-14267199.,8362803.); _CD(17.,14670646.,7134203.);\n    _CD(18.,-14680064.,3.);\n    p.y = 7. - p.y;\n    p = floor(p);\n    if(p.x < 0.0 || p.x >= 7.0 || p.y < 0.0 || p.y >= 7.0)\n    \treturn 0.0;\n    float addr = p.x + p.y * 7.0;\n    if(addr == 24.0)\n    \treturn step(a, 0.0);\n    else if(addr > 24.0)\n        return mod(floor(abs(b) / exp2(addr - 25.0)), 2.0);\n    return mod(floor(abs(a) / exp2(addr)), 2.0);\n}\n\nfloat gate(float t)\n{\n    t = mod(t, 32.0);\n    float v = 0.0;\n    //#define _NT(o, d) v += smoothstep(0.0, -0.2, abs(t - (o) - ((d) - 0.1)*.5) - ((d) - 0.1)*.5)\n    #define _NT(o, d) v += smoothstep(-0.05, 0.0, (t - (o))) * smoothstep(0.0, -0.4, (t - (o) - (d)))\n    _NT(0., 2.);\n    _NT(4., 1. - 0.2);\n    _NT(6., 2.);\n    _NT(10., 1. - 0.2);\n    _NT(12., 2.);\n    _NT(16., 2.);\n    _NT(19., 1.);\n    _NT(22., 1.);\n    _NT(24., 1.);\n    _NT(26., 2.);\n    _NT(28., 1.);\n    _NT(30., 1.);\n    return v;\n}\n\nfloat gate1(float t)\n{\n    t = mod(t, 32.0);\n    float v = 0.0;\n    //#define _NT(o, d) v += smoothstep(0.0, -0.2, abs(t - (o) - ((d) - 0.1)*.5) - ((d) - 0.1)*.5)\n    #define _NT(o, d) v += smoothstep(-0.05, 0.0, (t - (o))) * smoothstep(0.0, -0.4, (t - (o) - (d)))\n    _NT(0., 2.);\n    _NT(4., 1. - 0.2);\n    _NT(6., 2.);\n    //_NT(10., 1. - 0.2);\n    //_NT(12., 2.);\n    _NT(16., 2.);\n    _NT(19., 1.);\n    _NT(22., 1.);\n    _NT(24., 1.);\n    _NT(26., 2.);\n    //_NT(28., 1.);\n    _NT(30., 1.);\n    return v;\n}\n\nvoid mad(inout vec2 a, float wi)\n{\n    float vi = abs(wi);\n    if(vi < a.x)\n    {\n        a.y = wi;\n        a.x = vi;\n    }\n}\n\nfloat lock(float y)\n{\n    vec2 a = vec2(1e38, 0.0);\n    float x = mod(y, 12.0);\n    mad(a, x - 0.0);\n    mad(a, x - 2.0);\n    mad(a, x - 4.0);\n    mad(a, x - 5.0);\n    mad(a, x - 7.0);\n    mad(a, x - 9.0);\n    mad(a, x - 10.0);\n    mad(a, x - 12.0);\n    return y - a.y;\n}\n\nfloat tracker(vec2 uv)\n{\n    float v;\n    float txs = 80.0;\n    float row = floor(uv.y / (8.0 / txs) + 0.5);\n    vec2 q;\n    q.x = uv.x;\n    q.y = mod(uv.y - 4.0 / txs, 8.0 / txs);\n    \n    float tsc = 16. * tempo;\n    float rowmv = floor(iTime * tsc);\n    float time = rowmv / tsc - row / tsc;\n    float p0 = step(0.5, fract(time * tempo / 4.0));\n    float p1 = max(step(0.5, fract(time * tempo / 4.0)), step(fract(time * tempo / 16.0), 0.5));\n    float v0 = step(0.5, fract(time * tempo / 32.0));\n    float v1 = 1.0;//step(0.5, fract(time * tempo / 64.0));\n    \n    float src = floor(time * tempo * 4.0);\n    float nt = lock(floor(fract(src * src * 1.79425579) * 20.0));\n    nt -= 12.0;\n    float gt = gate(time * tempo * (8.0 + p0 * 8.0)) * 1.0 * v0;\n    \n    nt += 69.0;\n    //nt = 11.0;\n    float ntl = mod(nt, 12.0);\n    float sharp = ntl;\n    ntl = ntl + (ntl > 4.0 ? 1.0 : 0.0);\n    sharp = mod(ntl, 2.);\n    ntl = floor(ntl / 2.0);\n    v = gt * (fun(10.0 + ntl, q * txs) + fun(18.0 - sharp, q * txs - vec2(8.0, 0.0)) + fun(floor(nt / 12.), q * txs - vec2(16.0, 0.0)));\n    \n  \n    \n    q.x += 40.0 / txs;\n    \n    \n    src = floor(time * tempo * 4.0);\n    nt = lock(floor(fract(src * src * 1.79425579) * 10.0));\n    gt = gate(time * tempo * (8.0 + p1 * 8.0)) * 1.0 * v0;\n    nt += 69.;\n    \n    sharp = ntl = mod(nt, 12.0);\n    ntl = ntl + (ntl > 4.0 ? 1.0 : 0.0);\n    sharp = mod(ntl, 2.);\n    ntl = floor(ntl / 2.0);\n    v += gt * (fun(10.0 + ntl, q * txs) + fun(18.0 - sharp, q * txs - vec2(8.0, 0.0)) + fun(floor(nt / 12.), q * txs - vec2(16.0, 0.0)));\n    \n    \n    \n    q.x += 40.0 / txs;\n    \n    \n    src = floor(time * tempo * 4.0);\n    nt = lock(floor(fract(src * src * 1.79425579) * 10.0));\n    nt += step(0.5, fract(time * tempo * 16.0)) * 7.0;// * (4.0 + step(nt2, 0.5) * 3.0);\n    nt += 69.;\n    gt = gate1(mod(time * tempo, 3.0) * 8.0) * 1.5 * (1.0 - v0);\n    \n    sharp = ntl = mod(nt, 12.0);\n    ntl = ntl + (ntl > 4.0 ? 1.0 : 0.0);\n    sharp = mod(ntl, 2.);\n    ntl = floor(ntl / 2.0);\n    v += gt * (fun(10.0 + ntl, q * txs) + fun(18.0 - sharp, q * txs - vec2(8.0, 0.0)) + fun(floor(nt / 12.), q * txs - vec2(16.0, 0.0)));\n    \n    \n    q.x += 65.0 / txs;\n    float rowi = mod(-row + rowmv, 64.0);\n    v += (//fun(mod(floor(rowi / 100.0), 10.0), q * txs) +\n          fun(mod(floor(rowi / 10.0), 10.0), q * txs - vec2(8.0, 0.0)) +\n          fun(mod(floor(rowi), 10.0), q * txs - vec2(16.0, 0.0))) * 0.4;\n    \n    \n    v += smoothstep(0.01, 0.0, max(abs(uv.x) - 2.0, abs(uv.y + 0.5 / txs) - 0.04)) * 0.2;\n    v += 0.05;\n    v *= sin(uv.y * 450.0) * 0.4 + 0.6;\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv += vec2(cos(iTime * 10.0) + cos(iTime * 24.0) * 0.5,\n              sin(iTime * 12.0) + sin(iTime * 23.0) * 0.5) * 0.005;\n    \n    uv = rotate(uv, 0.07);\n    \n    vec3 col = vec3(0.0);\n    \n    float v = 0.0, w = 0.0;\n    \n#ifdef BACKUP\n    uv.y -= floor(iTime * 16.0) * 0.09;\n    \n    uv.x = abs(abs(uv.x) - 0.46) - 0.46;\n    \n    w = max(abs(abs(abs(abs(uv.x) - 0.105 * 2.0) - 0.105) - 0.035), abs(mod(uv.y + 0.035, 0.07) - 0.035));\n    v = smoothstep(0.005, 0.0, w - 0.006);\n    w = max(abs(uv.x) - 0.4, abs(mod(uv.y, 0.07 * 4.0) - 0.07 * 2.0) - 0.03);\n    v += smoothstep(0.005, 0.0, w) * 0.2;\n    \n    v += smoothstep(0.005, 0.0, min(abs(uv.x + 0.45) - 0.015, -uv.x + 0.43)) * 0.5;\n#endif\n    \n    \n    \n    vec3 ps = vec3(5.0 / iResolution.xy, 0.0);\n#ifdef ABERATE\n    col = vec3(tracker(uv) * vec3(1.0, 0.2, 0.2) + tracker(uv + ps.xz) * vec3(0.2, 1.0, 0.2) + tracker(uv + ps.zy) * vec3(0.2, 0.2, 1.0));\n#else\n    col = vec3(tracker(uv));\n#endif\n    col *= exp(length(uv) * -1.0 + 1.0);\n    col = pow(col, vec3(1.0 / 2.2));\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// srtuss, 2015\n\nfloat tempo = 1.3;\n\nfloat n2f(float n)\n{return 440.0*pow(2.0,(n-69.0)/12.0);}\nfloat n2m(float n)\n{return pow(2.0,n/12.0);}\nfloat sine(float ph)\n{return sin(ph*6.283185307179586476925286766559);}\nfloat shns(float x)\n{return fract(sin(floor(x * 4000.0)) * 29919.0) - 0.5;}\nfloat hpns(float x, float h)\n{return (shns(x + h) - shns(x - h));}\nfloat adsr(float x, float a, float d)\n{return smoothstep(0.0, a, x) * exp(max(x - a, 0.0) * -d);}\nfloat adsr(float x, float a, float d, float g)\n{return smoothstep(0.0, a, x) * smoothstep(a + d + g, a + g, x);}\nfloat pwm(float t, float v)\n{\n    float s = 0.001;\n    t = fract(t);\n    return smoothstep(v,  v + s, t) * smoothstep(1.0, 1.0 - s, t) * 2.0 - 1.0;\n}\n\nfloat oscc(float t, float tt, float pw)\n{\n    float blend = smoothstep(-1.0, 1.0, cos(tt * 0.1));\n    float a = 1.0 - blend, b = blend;\n    a = sqrt(a);\n    b = sqrt(b);\n    return pwm(t, pw) * a * 0.5 + sine(t) * b;\n}\n\nvec2 osc(float t, float tt)\n{\n    float pw = sin(t * 0.01) * 0.25 + 0.5;\n    float a = oscc(t, tt, pw);\n    float b = oscc(t * 1.01, tt, pw);\n    \n    return vec2(a + b, a - b);\n}\n\nfloat gate(float t)\n{\n    t = mod(t, 32.0);\n    float v = 0.0;\n    //#define _NT(o, d) v += smoothstep(0.0, -0.2, abs(t - (o) - ((d) - 0.1)*.5) - ((d) - 0.1)*.5)\n    #define _NT(o, d) v += smoothstep(-0.05, 0.0, (t - (o))) * smoothstep(0.0, -0.4, (t - (o) - (d)))\n    _NT(0., 2.);\n    _NT(4., 1. - 0.2);\n    _NT(6., 2.);\n    _NT(10., 1. - 0.2);\n    _NT(12., 2.);\n    _NT(16., 2.);\n    _NT(19., 1.);\n    _NT(22., 1.);\n    _NT(24., 1.);\n    _NT(26., 2.);\n    _NT(28., 1.);\n    _NT(30., 1.);\n    return v;\n}\n\nfloat gate1(float t)\n{\n    t = mod(t, 32.0);\n    float v = 0.0;\n    //#define _NT(o, d) v += smoothstep(0.0, -0.2, abs(t - (o) - ((d) - 0.1)*.5) - ((d) - 0.1)*.5)\n    #define _NT(o, d) v += smoothstep(-0.05, 0.0, (t - (o))) * smoothstep(0.0, -0.4, (t - (o) - (d)))\n    _NT(0., 2.);\n    _NT(4., 1. - 0.2);\n    _NT(6., 2.);\n    //_NT(10., 1. - 0.2);\n    //_NT(12., 2.);\n    _NT(16., 2.);\n    _NT(19., 1.);\n    _NT(22., 1.);\n    _NT(24., 1.);\n    _NT(26., 2.);\n    //_NT(28., 1.);\n    _NT(30., 1.);\n    return v;\n}\n\nfloat blep(float t, float dt)\n{\n\tif(t < dt)\n\t{\n\t\tt /= dt;\n\t\treturn t + t - t*t - 1.0;\n\t}\n\telse if(t > 1.0 - dt)\n\t{\n\t\tt = (t - 1.0) / dt;\n\t\treturn t*t + t + t + 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\nfloat saw(float x, float freq)\n{\n    float v;\n    x = fract(x * freq);\n    v = x * 2.0 - 1.0;\n    v -= blep(x, freq / 44100.0);\n    return v;\n}\n\nfloat sqr(float x, float freq, float pw)\n{\n    float v;\n    x = fract(x * freq);\n    v = x < pw ? 1.0 : -1.0;\n    v += blep(x, freq / 44100.0);\n    v -= blep(fract(x - pw), freq / 44100.0);\n    return v;\n}\n\nfloat beat(float time, float big)\n{\n    float v = 0.0;\n    float tb = time * tempo;\n    tb = mod(tb, 2.0);\n    tb = mod(tb, 5.0 / 4.0);\n    tb /= tempo;\n    v += sin(exp(tb * -1.0) * 800.0 + exp(tb * -100.0) * 200.0) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -10.0) * 0.5 * big;\n    \n    tb = time * tempo;\n    tb = mod(tb - 0.25, 2.0);\n    tb /= tempo;\n    v += sin(exp(tb * -1.0) * 800.0 + exp(tb * -100.0) * 200.0) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -10.0) * 0.5 * big;\n    \n    tb = time * tempo;\n    tb = mod(tb - 1.0, 2.0);\n    tb /= tempo;\n    v += (sin(exp(tb * -2.0) * 300.0) + hpns(tb, 0.0003) * 0.1) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -5.0) * big;\n    \n    tb = time * tempo;\n    tb = mod(tb, 2.0);\n    tb = mod(tb, 2.5 / 4.0);\n    tb = mod(tb - 1.0, 0.25);\n    tb /= tempo;\n    v += hpns(tb, 0.0002) * exp(tb * -20.0) * 0.3;\n    \n    tb = time * tempo;\n    tb = mod(tb, 0.5);\n    tb /= tempo;\n    v += hpns(tb, 0.00002) * exp(tb * -5.0) * 0.3;\n    \n    \n    //v = sqr(time, 440.0 * 0.1, 0.5);\n    \n    return v;\n}\n\nfloat beat2(float time, float big)\n{\n    float tb, v = 0.0;\n    \n    tb = time * tempo;\n    tb = mod(tb, 2.0);\n    tb = mod(tb, 5.0 / 4.0);\n    tb /= tempo;\n    float kick = sin(exp(tb * -1.0) * 400.0 + exp(tb * -100.0) * 200.0) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -10.0);\n    kick = smoothstep(-0.2, 0.2, kick) * 2.0 - 1.0;\n    v = kick * 0.3;\n    \n    tb = time * tempo;\n    tb = mod(tb - 0.5, 1.0);\n    tb /= tempo;\n    v += (hpns(exp(-tb) * 4.0, 0.0002) * exp(max(tb - 0.1, 0.0) * -10.0) * 0.5 + sin(sin(tb * 100.0) * 5.0 + tb * 2000.0) * exp(max(tb - 0.1, 0.0) * -10.0) * 0.4) * 0.6;\n    \n    /*tb = time * tempo;\n    tb = mod(tb - 0.5, 1.0);\n    //tb = mod(tb, 5.0 / 4.0);\n    tb /= tempo;\n    v += sin(exp(tb * -1.0) * 800.0 + exp(tb * -100.0) * 200.0) * exp(max(0.1 - tb, 0.0) * -10.0) * exp(tb * -10.0);*/\n    \n    tb = time * tempo + 0.25;\n    tb = mod(tb, 2.0);\n    tb = mod(tb, 2.5 / 4.0);\n    tb = mod(tb - 1.0, 0.25);\n    tb /= tempo;\n    v += hpns(tb * 4.0, 0.0002) * exp(tb * -25.0) * 0.25;\n    \n    tb = time * tempo;\n    tb = mod(tb, 0.5);\n    tb /= tempo;\n    v += (hpns(tb * 2.0, 0.00002) + hpns(tb * 100.0, 0.002) * 0.3) * exp(tb * -4.0) * 0.2;\n    \n    tb = time * tempo;\n    tb = mod(tb - 0.25, 0.5);\n    tb /= tempo;\n    v += (hpns(tb * 9.0, 0.0002)) * exp(tb * -8.0) * 0.3;\n    \n    //v = sqr(time, 440.0 * 0.1, 0.5);\n    \n    return v;\n}\n\nvec2 s(float time)\n{\n    time *= tempo;\n    float tb = floor(mod(time, 32.0) * 0.5) - 3.0 * step(15.0, mod(time, 16.0));\n    float f = fract(sin(tb * 11.0) * 29082.523);\n    \n    float to = time * n2m(floor(f * 12.0) - 6.0) / tempo;\n    vec2 v;\n    v = osc(to * n2f(29.0), time);\n    v += osc(to * n2f(53.0), time);\n    v += osc(to * n2f(56.0), time);\n    v += osc(to * n2f(60.0), time);\n    v += osc(to * n2f(65.0), time);\n    v += osc(to * n2f(68.0), time);\n    v += osc(to * n2f(72.0), time);\n    v += osc(to * n2f(75.0), time);\n    v += osc(to * n2f(87.0), time);\n    \n    v *= mix(1.0, gate(time * 8.0), smoothstep(-1.0, 1.0, cos(time * 0.1)));\n    \n    return v;\n}\n\nvoid mad(inout vec2 a, float wi)\n{\n    float vi = abs(wi);\n    if(vi < a.x)\n    {\n        a.y = wi;\n        a.x = vi;\n    }\n}\n\nfloat lock(float y)\n{\n    vec2 a = vec2(1e38, 0.0);\n    float x = mod(y, 12.0);\n    mad(a, x - 0.0);\n    mad(a, x - 2.0);\n    mad(a, x - 4.0);\n    mad(a, x - 5.0);\n    mad(a, x - 7.0);\n    mad(a, x - 9.0);\n    mad(a, x - 10.0);\n    mad(a, x - 12.0);\n    return y - a.y;\n}\n\nvec2 s2(float time)\n{\n    float pwm = sin(time * 0.3) * 0.25 + 0.4;\n    \n    \n    float p0 = step(0.5, fract(time * tempo / 4.0));\n    float p1 = max(step(0.5, fract(time * tempo / 4.0)), step(fract(time * tempo / 16.0), 0.5));\n    \n    float v0 = step(0.5, fract(time * tempo / 32.0));\n    float v1 = 1.0;//step(0.5, fract(time * tempo / 64.0));\n    \n    \n    \n    vec2 v = vec2(0.0);\n    float src = floor(time * tempo * 4.0);\n    float nt = lock(floor(fract(src * src * 1.79425579) * 20.0));\n    nt -= 12.0;\n    v = sqr(time, 440.0 * pow(2.0, nt / 12.0), pwm) * gate(time * tempo * (8.0 + p0 * 8.0)) * 1.0 * v0 * vec2(1.0, 0.5);\n    nt = lock(floor(fract(src * src * 1.79425579) * 10.0));\n    //nt += 12.0;\n    v += sqr(time, 440.0 * pow(2.0, nt / 12.0), pwm) * gate(time * tempo * (8.0 + p1 * 8.0)) * 1.0 * v0 * vec2(0.5, 1.0);\n    //v = vec2(0.0);\n    src = floor(time * tempo * 1.0);\n    nt = lock(floor(fract(src * src * 1.79425579) * 4.0));\n    float ntb = nt;\n    nt -= 36.0;\n    float ff = 440.0 * pow(2.0, nt / 12.0);\n    v += sqr(time, ff, 0.4) * gate(time * tempo * 8.0) * 1.5 * v1;\n    v += sine(time * ff * 1.0) * gate(time * tempo * 8.0) * 2.0 * v1;\n    \n    \n    src = floor(time * tempo * 4.0);\n    nt = lock(floor(fract(src * src * 1.79425579) * 10.0));\n    nt += step(0.5, fract(time * tempo * 16.0)) * 7.0;// * (4.0 + step(nt2, 0.5) * 3.0);\n    v += saw(time, 440.0 * pow(2.0, nt / 12.0)) * 1.0 * gate1(mod(time * tempo, 3.0) * 8.0) * 1.5 * (1.0 - v0);\n    \n    nt = abs((mod(time * tempo * 32.0, 16.0) - 8.0) * 1.0);\n    nt = lock(nt) + ntb + floor(abs((mod(time * tempo * 0.5, 2.0) - 1.0) * 3.0)) * 12.0 - 12.;\n    v += saw(time, 440.0 * pow(2.0, nt / 12.0)) * vec2(0.5, 1.0);\n    \n    float tb = mod(time * tempo, 8.0);\n    v += hpns(exp(tb * -1.0), 0.0002) * exp(tb * -0.4);\n    \n    return v * vec2(0.2);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    vec2 v = vec2(0.0);\n    float a = 1.0, sw = 0.0;\n    float to = 0.0;\n    for(int i = 0; i < 8; ++i)\n    {\n        vec2 src = s2(time - to);\n        \n        v += mix(src, src.yx, sw) * a * mix(vec2(1.0, 0.4), vec2(0.4, 1.0), sw);\n        sw = 1.0 - sw;\n        a *= 0.3;\n        to += 0.33;\n    }\n    \n\n    v *= vec2(1.0);\n    \n\n    float big = 1.0;//step(0.5, fract(time * tempo));\n    //v += beat(time, big) * vec2(0.8);\n    //v += beat(time - tempo / 3.0, big) * vec2(0.3, 0.2);\n    \n    v += beat2(time, big) * vec2(0.8);\n    v += beat2(time - tempo / 6.0, big) * vec2(0.3, 0.2);\n    \n    \n    float dl = time * 1.0;\n    v *= min(dl * dl, 1.0);\n    \n    return v * 0.8;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}