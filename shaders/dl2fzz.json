{
    "Shader": {
        "info": {
            "date": "1693835063",
            "description": "An extruded Bauhaus Truchet pattern with a simplistic Cook-Torrance diffuse and specular lighting scheme applied to give the vague appearance of hard ceramic and metal tiles.",
            "flags": 32,
            "hasliked": 0,
            "id": "dl2fzz",
            "likes": 129,
            "name": "Extruded Bauhaus Truchet Pattern",
            "published": 3,
            "tags": [
                "raymarch",
                "truchet",
                "brdf",
                "cook",
                "torrance",
                "traversal",
                "bdrf",
                "bauhaus"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 4852
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Bauhaus Truchet Pattern\n    --------------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.5 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 2.5, coc = .5;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Extruded Bauhaus Truchet Pattern\n    --------------------------------\n    \n    This is an extruded Bauhaus Truchet pattern with a very simplistic \n    Cook-Torrance diffuse and specular lighting scheme applied to give \n    the vague appearance of hard ceramic and metal tiles.\n    \n    When not path tracing, I tend to get a bit lazy with material lighting \n    routines. Most of the time, I can make things look the way I want by\n    tweaking the diffuse and specular powers. However, if you want a bit \n    more material realism, it's probably a good idea to drop in some kind \n    of BRDF (bidirectional reflectance distribution function) routine, \n    which is what I've done here.\n    \n    I hacked a very basic BRDF routine together pretty quickly some time \n    ago, and it works well enough for the purpose of this example, but I \n    wouldn't use it for anything other than a basic introduction. By the\n    way, if you're an expert on the process, and I've made a mistake that\n    can't be ignored, feel free to let me know.\n    \n    The Bauhaus pattern itself is nothing special. You can find them in\n    abundance online, but I haven't seen them in variable heightmap form, \n    so I thought it'd be fun to do that. Technically speaking, the example\n    is interesting in the sense that every cell is only rendered once, \n    which is made possible using a cell wall intersection trick that I've\n    covered previously.\n    \n    I've included a heap of define options below, for anyone interested in\n    playing around with different design settings.\n    \n\n\n    Other examples:\n\n    // A much nicer implementation.\n    Disney Principled BRDF - markusm\n    https://www.shadertoy.com/view/XdyyDd\n\n\n*/\n \n\n// Paint on some edging.\n#define EDGES\n\n// Put some rivet holes on random objects.\n#define HOLES\n\n// Ratio of metallic tiles to dielectric (non-conducting) ones.\n// Values range from zero (no metallic tiles) to one (all metallic).\n#define METAL_AMOUNT .35 // Range: [0, 1].\n\n// The color variety... I wasn't sure what to call this. Lower\n// numbers mean fewer colors. Changing the variety of colors used\n// changes the feel. I prefer fewer, but everyone's different.\n//\n// Greyscale 0, One color: 1, Two colors: 2, Four colors, 3\n#define COLOR_VARIETY 2\n\n// An override to display random material values and colors.\n//#define RANDOM_MATERIALS\n\n// Swizzle the palette from orange to purple based colors.\n//#define SWIZZLE_PALETTE\n\n// Relative amount of metallic tiles that are gold. For initial\n// design reasons, the default is undefined.\n//#define GOLD_AMOUNT .35 // Range: [0, 1].\n\n// Subtle textured lines.\n//#define LINES\n\n \n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n \n// Hacked together from IQ, Nimitz and Fabrice's hash functions.\nvec3 hash23(in vec2 f){\n     \n    uvec2 p = floatBitsToUint(f);\n    uint  n = 1103515245U*((p.x)^(p.y>>3U));\n    // Converting a uint to a uvec3:\n    // These numbers came from here:\n    // Quality hashes collection WebGL2 - Nimitz.\n    // https://www.shadertoy.com/view/Xt3cDn\n    uvec3 u3 = uvec3(1, 16807U, 48271U);\n    return vec3(((u3*n) >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n    \n    // Dave Hoskins's reliable hash function.\n\t//vec3 p3 = fract(f.xyx*vec3(.1031, .1030, .0973));\n    //p3 += dot(p3, p3.yxz + 423.123);\n    //return fract((p3.xxy+p3.yzz)*p3.zyx);\n     \n}\n \n \n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n    \n// Height map value, which is just the pixel's greyscale value.\n//vec3 hm3(in vec2 p){ return texture(iChannel2, p*563.837, -100.).xyz; }\nvec3 hm3(in vec2 p){ return hash23(p); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n \n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nfloat scale = 1./1.5;\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n \n \nvec2 gIP;\n\n// An extended square grid 2D Truchet routine: Split into square tiles\n// as per usual, then produce the distance fields and ID for simple \n// shapes inside them. The kinds of shapes you render is up to you.\n//\n// This is 2D function called once per raymarching iteration, so it \n// needs to be reasonably quick, but not blindingly fast. I also wanted\n// it to be a little bit readable, so I didn't go out of my way to \n// tweak it. If speed was the goal, then I'd be more inclined to render\n// it to a backbuffer, rather than turn it into an unreadable mess, but\n// to each their own.\nvoid tr(inout vec2 oP, inout vec3 d, inout vec2[3] id, int oID){\n\n\n    vec2 p = oP;\n    \n    // Row and column offset variable.\n    vec2 offs = vec2(0);\n    // Row and column ID.\n    vec2 ii = floor(p/scale);\n    /*\n    // Offset columns.\n    if(mod(ii.x, 2.)<.5){ \n        p.y -= scale/2.;\n        offs.y += .5;\n    } \n    */ \n    /*\n    // Offset rows.\n    if(mod(ii.y, 2.)<.5){ \n        p.x -= scale/2.;\n        offs.x += .5;\n    } */\n    \n    \n    #ifndef RANDOM_MATERIALS\n    // Animated offset columns.\n    // Time, beginning at random intervals.\n    float t = iTime/8. + hash21(vec2(2, ii.x));\n    float iT = floor(t); // Integer time increments to keep track of position.\n    float fT = t - iT; // Fractional time increment used for animation.\n    \n    // Smoothly slide the columns at random time intervals. \n    float dir = mod(ii.x, 2.)<.5? -1. : 1.;\n    p.y += dir*(smoothstep(0., .0625, fT) + .25)*scale;\n    offs.y = dir*(iT + .25); \n    #endif\n   \n    // Positional cell ID and local coordinates. If you didn't want to shift\n    // rows and columns, you wouldn't need any of the code above, nor would you\n    // need the three lines below.\n    vec2 ip = floor(p/scale);\n    p -= (ip + .5)*scale;\n    \n    \n    ip += offs; // Update the positional cell ID with the sliding offset.\n    gIP = ip; // Record the ID for usage elsewhere.\n    oP = p; // Record the local position.\n \n\n     \n    // Random local coordinate rotation.\n    float rnd = hash21(ip + .05);\n    p *= rot2(floor(rnd*64.)*3.14159/2.);\n   \n     // A second random number that determines what kind of tile to draw.\n    float rnd2 = hash21(ip + .1);\n\n    \n    // Three distances and IDs, to represent up to three shapes per cell.\n    d = vec3(1e5);\n    id = vec2[3](vec2(0), vec2(0), vec2(0));\n    \n    \n    // Based on the random choice above, render one of three types of\n    // tiles. I hacked this together to get the job done, so there'd no\n    // doubt be more efficient ways to do this, but this seems fast \n    // enough on my machine, and it's readable enough, so it'll do.\n    if(rnd2<.3){\n    \n        // Triangles.\n         \n        // Square boundary.\n        vec2 q = abs(p);\n        float sq = max(q.x, q.y) - .5*scale;\n        \n        // The diagonal center line.\n        q = p;\n        d.x = (p.x + p.y)*.7071;\n        id[0] = ip - .25; // ID for this side of the line.\n\n        // The other side of the diagonal line.\n        d.y = max(sq, -d.x);\n        id[1] = ip + .25; // ID for the other side.\n        \n        // Use the square boundary to render the other two lines.\n        // This will leave you with two triangles... Probably not\n        // real distance field values, but no one will notice.\n        d = max(d, sq);\n        \n        oID = 0; // Record the overall square cell ID.\n        \n        \n    }\n    else if(rnd2<.5){\n    \n        // Square with central circle tile.\n        \n        // Circle.\n        vec2 q = p;\n        d.x = length(q) - 1./2.*.7071*scale + .05;\n        id[0] = ip; // Center ID for the circle.\n\n        // The remainder of the rectangle.\n        q = abs(p);\n        d.y = max(q.x - .5*scale, q.y - .5*scale);\n        d.y = max(d.y, -d.x);\n        id[1] = ip + vec2(-.25, 0); // Off to the side for the remainder.\n        \n        oID = 1; // Square cell ID.\n    }\n    else {\n    \n        // Three circular arcs.\n    \n        // Square boundary.\n        vec2 q = abs(p);\n        float sq = max(q.x, q.y) - .5*scale;\n        \n        float qrtr = length(p - .5*scale) - .5*scale; // Quarter.\n        float semi = length(p - .5*scale) - 1.*scale; // Semi circle.\n    \n        d.x = qrtr; // Inner quarter.\n        id[0] = ip - .25;\n        \n        d.y = max(semi, -qrtr); // Middle arc.\n        id[1] = ip + vec2(0);\n        \n        \n        \n        d.z = max(sq, -semi); // Outer quarter.\n        id[2] = ip + .25;\n        \n        // Using the square boundary to form the three bounded arcs.\n        d = max(d, sq);\n        \n        oID = 2; // Square cell ID.\n    \n    }\n\n    \n    // Shape border line width.\n    float lw = .015*scale;\n    d += lw;\n    \n    \n    // Rivet offset distance.\n    float rvO = (1./2. - 1./4.*.7071)*scale;\n    \n    // Rivet nole distance.\n    float rv;\n   \n    // Rivet holes.\n    if(oID == 1){\n        // Square corner holes.\n        vec2 q = abs(p) - rvO;\n        rv = length(q);\n    }\n    else {\n        \n        // Triangle holes and corner arc holes.\n        vec2 q = p;\n        rv = length(q - rvO);\n        rv = min(rv, length(q + rvO));\n        \n        if(oID == 2){\n           // Central arc rivet position.\n           vec2 arcR = vec2(rvO, -(1.*scale - lw)/4.);\n           rv = min(rv, min(length(p - arcR), length(p.yx - arcR)));\n           \n        }    \n    } \n    \n    // Smaller rivet holes when using edging.\n    #ifdef EDGES\n    float hw = .035;\n    #else\n    float hw = .045;\n    #endif\n \n    // Use CSG for some random rivet holes.\n    #ifdef HOLES\n    if(hash21(ip + .08)<.35){\n       d = max(d, -(rv - hw*scale));\n    }\n    #endif\n \n}\n\n  \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z;\n    \n    // 2D Truchet distance, for the extrusion cross section.\n    vec3 d; vec2[3] id; int oID;\n    vec2 gP = p.xy;\n    tr(gP, d, id, oID);\n \n    // Extrude the 2D Truchet object along the Z-plane.\n    //vec3 h3 = vec3(hm(id[0]), hm(id[1]), hm(id[2]))*.25 + .05;\n    // A bit of face beveling to reflect the light a little more.\n    vec3 bev = min(-d*6., .2)*.03; // 03;\n    vec3 h3 = hm3(gIP)*.25 + .05;\n    float obj = opExtrusion(d.x, p.z, h3.x, .015) - bev.x; \n    obj = min(obj, opExtrusion(d.y, p.z, h3.y, .015) - bev.y); \n    if(oID==0) obj = min(obj, opExtrusion(d.z, p.z, h3.z, .015) - bev.z); \n  \n    // Directional ray collision with the square cell boundaries.\n    vec2 rC = (gDir.xy*scale - gP)/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .0015; // Adding a touch to advance to the next cell.\n \n     \n    // Object ID.\n    objID = fl<obj? 0 : 1;\n    \n    // Minimum distance for the scene.\n    return min(fl, obj);\n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 32; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd; \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.7, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = m(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);  \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n  // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Most dominant term.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return (col*diff + spec*PI);\n  \n}\n////////////////////\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/2., -3), l = o + vec3(.5, 1, 1.5);\n    //vec3(-2.5, 2.5, -1.25);\n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n    \n    // Mouse camera movement.\n    if(iMouse.z>1.){\n        r.yz *= rot2(-.5*(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        r.xz *= rot2(-.25*(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);\n    } \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash21(r.xy*57. + fract(iTime))*.5;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(r)*.5;\n    gRd = r; \n\n    \n    // Raymarch.\n    for(int i = min(iFrame, 0); i<96; i++){ \n        \n        vec3 p = o + r*t;\n        d = m(p); // Surface distance.\n        // Surface hit -- No far plane break, since it's just the floor.\n        if(abs(d)<.001) break; \n        t += min(d*.9, gCD);  // Advance the overall distance closer to the surface.\n         \n    }\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n \n \n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    \n        // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.05); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    /*\n    // Old diffuse and specular calculations.\n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    float fr = pow(max(1. + dot(r, n), 0.), 2.); // Fresnel.\n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    */\n    \n    // 2D Truchet face distace -- Used to render borders, etc.\n    //scale *= 3.;\n    vec3 d3; vec2[3] vID; int oID;\n    vec2 p2 = p.xy;\n    tr(p2, d3, vID, oID);\n    \n    // Minimum tile object index.\n    int index = (d3.x<d3.y && d3.x<d3.z)? 0 : d3.y<d3.z? 1 : 2;\n    // 2D object face distance and ID.\n    float obj2D = d3[index];\n    vec2 id = vID[index]*scale;\n    \n    // Object heights.\n    vec3 h3 = hm3(gIP)*.25 + .05;\n    float h = h3[index];\n\n \n    // Texture position.\n    vec3 txP = vec3(p2, p.z);\n    vec3 txN = n;\n    vec3 tx = tex3D(iChannel1, txP/2., txN);//vec3(.25);//\n\n    \n    // Subtle lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 24.;\n    float pat = (abs(fract((p2.x - p2.y)*lSc - .5) - .5) - .125)/lSc;\n    #endif  \n    \n\n  \n    // Standard material properties: Roughness, matType and reflectance.\n    //\n    float roughness = .2; // Lower roughness reflects more light, as expected.\n    float matType = 0.; // Dielectric (non conducting): 0, or metallic: 1.\n    float reflectance = .5; // Reflective strength.\n    \n    \n    // Object color.\n    vec3 oCol = vec3(0);\n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n    \n       // Floor -- Redundant here, but I've included it anyway.\n       oCol = vec3(.125);\n       matType = 1.; // Metallic material.\n       roughness = .5;\n       \n       \n    }\n    else if(gObjID==1){\n    \n        // Extruded Truchet:\n\n        // Noise texture, used for a hacky scratched surface look.\n        // Usually, you'd tailor this to specific material needs.\n        vec3 txR = txP;\n        txR.xy *= rot2(-3.14159/6.);\n        vec3 rTx = tex3D(iChannel2, txR*vec3(.5, 3, .5), txN);\n        float rGr = dot(rTx, vec3(.299, .587, .114));\n \n        \n        // The tile base color.\n         \n        float sRnd = hash21(id + .01); // Random tile component value.\n        \n        //sRnd = id.x;\n        vec3 sCol = .5 + .45*cos(6.2831*sRnd/8. + (vec3(0, 1, 2) + .05));//vec3(1, .15, .45);\n        sCol = pow(sCol, vec3(1.5));\n        \n        #if COLOR_VARIETY >= 2\n        if(hash21(id + .27)<.35) sCol = sCol.zyx; //yzx\n        #endif\n        \n        #if COLOR_VARIETY >= 3\n            #ifdef SWIZZLE_PALETTE\n            if(hash21(id + .15)<.35) sCol = mix(sCol, sCol.yxz, .5);\n            #else\n            if(hash21(id + .15)<.35) sCol = mix(sCol, sCol.xzy, .5);\n            #endif\n        #endif\n \n        // Face rim and face distance values for edge rendering. \n        float b = abs(obj2D) - .01;\n        float pH = p.z + h - .04;\n        b = max(b, (p.z + h - .02));\n        \n        float sf = .01; // Smoothing factor.\n        float ew = .02; // Edge width.\n        \n        #ifdef RANDOM_MATERIALS\n        float rRnd = hash21(gIP + .11);\n        sCol = .5 + .45*cos(6.2831*rRnd + vec3(0, 1, 2)*hash21(gIP + .4)*1.5);\n        #endif\n        \n        #ifdef EDGES\n        \n            float rW = .035; // Rim width.\n            \n            oCol = sCol;\n            oCol = mix(oCol*.8, oCol*.15, (1. - smoothstep(0., sf, pH)));\n            oCol = mix(oCol, mix(min(sCol*1.4, 1.), vec3(1), .2), (1. - smoothstep(0., sf, pH + ew)));\n            oCol = mix(oCol, oCol*.15, (1. - smoothstep(0., sf, obj2D + rW)));\n\n            #ifdef LINES\n            // If applicable, apply lines to the inner face color.\n            sCol = mix(sCol*1.15, sCol*.7, (1. - smoothstep(0., sf, pat)));\n            #endif\n            oCol = mix(oCol, sCol, (1. - smoothstep(0., sf, obj2D + rW + ew)));\n        #else\n        \n            oCol.xyz = sCol;\n            #ifdef LINES\n            // If applicable, apply lines to the inner face color.\n            pat = max(pat, pH + .02);\n            oCol = mix(oCol, oCol*.15, (1. - smoothstep(0., sf, abs(pH + .02) - ew/2.)));\n            oCol = mix(oCol*1.1, oCol.xyz*.7, (1. - smoothstep(0., sf, pat)));\n            #endif\n            \n        #endif          \n          \n        \n        // Greyscale value, calculated prior to gradient coloring.\n        float gr = dot(oCol.xyz, vec3(.299, .587, .114));\n        \n        // Subtle face color gradient.\n        oCol = mix(oCol, oCol.xzy, clamp(-p2.y - .125, 0., 1.));\n        //oCol.xyz = mix(oCol.xyz, oCol.xzy, clamp(obj2D/scale*3. + .5, 0., 1.));\n\n        #if COLOR_VARIETY == 0\n        oCol.xyz = vec3(gr*sqrt(gr)*1.5);\n        #endif\n        \n        #ifdef SWIZZLE_PALETTE\n        oCol = oCol.yzx;\n        #endif\n   \n      \n        #ifndef RANDOM_MATERIALS   \n        if(hash21(id + .2)<METAL_AMOUNT){\n        //if(hash21(gIP + .2)<.25){ // gPI: Square cell ID.\n        //if(mod(floor(gIP.x) + floor(gIP.y), 2.)>.5){ \n            \n            \n            // Metal material.\n            \n            // Mostly grey with tiny leftover color residue.\n            oCol = mix(oCol, vec3(gr), .9);\n             \n            // Gold. Interesting, but a bit much for this example,\n            // so the default is set to zero.\n            #ifdef GOLD_AMOUNT\n            if(hash21(id + .43)<GOLD_AMOUNT) oCol.xyz *= vec3(1, .75, .4)*2.5;\n            #endif\n\n            matType = 1.; // Metallic material.\n            oCol.xyz *= tx*1. + .5;\n            roughness = .6;\n            //roughness *= gr*2.;\n            roughness *= rGr*.6 + .4;\n            \n            // Metallic materials look dark when compared to their non-conducting \n            // dielectric equivalent, so for design sake, we're artificially \n            // inflating the brightness.\n            //sCol *= 1.5;\n        }\n        else {\n        \n            // Dielectic material.\n            \n            roughness = .3;\n            roughness *= (rGr*.4 + .6);\n            oCol *= tx*.6 + .9;\n             \n        }\n        #endif\n        \n        #ifdef RANDOM_MATERIALS\n        roughness = hash21(gIP + .31)*(rGr*.5 + .5);\n        matType = step(.5, hash21(gIP + .32));\n        reflectance = hash21(gIP + .33);\n        oCol *= tx*2.5 + .2;// + .5;\n        #endif\n        \n        \n        \n    }\n\n    /*\n    // Requires \"St Peter's Basillica\" cube map loaded into \"iChannel3\".\n    // Specular reflection.\n    vec3 hv = normalize(-r + ld); // Half vector.\n    vec3 ref = reflect(r, n); // Surface reflection.\n    vec4 refTx = texture(iChannel3, -ref.yzx, 1.); refTx *= refTx; // Cube map.\n    float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n    //spRef = mix(spRef/4., spRef, 1. - smoothstep(0., .01, d + .05));   \n    float rf = (matType < .5)? .25 : 2.;//mix(.25, 4., 1. - smoothstep(0., .01, d + .05));\n    oCol += oCol*reflectance*spRef*refTx.zyx*rf; //smoothstep(.03, 1., spRef) \n    */\n\n\n    // I wanted to use a little more than a constant for ambient light this \n    // time around, but without having to resort to sophisticated methods, then I\n    // remembered Blackle's example, here:\n    // Quick Lighting Tech - blackle\n    // https://www.shadertoy.com/view/ttGfz1\n    float am = pow(length(sin(n*2.)*.5 + .5)/sqrt(3.), 2.)*1.5; // Studio.\n    //float am = length(sin(n*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -n.z); // Outdoor.\n \n    // Cook-Torrance based lighting.\n    vec3 ct = BRDF(oCol, n, ld, -r, matType, roughness, reflectance);\n        \n    // Combining the ambient and microfaceted terms to form the final color:\n    // None of it is technically correct, but it does the job. Note the hacky \n    // ambient shadow term. Shadows on the microfaceted metal doesn't look \n    // right without it... If an expert out there knows of simple ways to \n    // improve this, feel free to let me know. :)\n    c.xyz = (oCol*am*(sh*.5 + .5) + ct*(sh))*ao*at;\n     \n \n    // Save the linear color to the backbuffer.\n    c = vec4(max(c.xyz, 0.), t);  \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}