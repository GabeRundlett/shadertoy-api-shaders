{
    "Shader": {
        "info": {
            "date": "1564012070",
            "description": "It's [url]https://www.shadertoy.com/view/wtj3Ry[/url] on steroids. Hit ENTER for a new random tiling. See comments at top of code for more instructions.",
            "flags": 48,
            "hasliked": 0,
            "id": "3tsSzM",
            "likes": 47,
            "name": "Hyperbolic Wythoff explorer v2",
            "published": 3,
            "tags": [
                "tiling",
                "tessellation",
                "hyperbolic",
                "wythoff"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 1762
        },
        "renderpass": [
            {
                "code": "/* Hyperbolic Wythoff explorer v2, by mattz\n   License https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n   Click in the display to move the center. Shift + click to\n   set rotation. All of the UI elements on the left are \n   interactive.\n\n   Keys:\n    \n     ENTER   Generate a random tiling!\n     + or -  Next/prev random tiling\n     SPACE   Show or hide the UI\n     C       Reset center position & rotation - halt motion\n     G       Toggle gyrating motion\n     R       Toggle continuous rotation\n     T       Toggle translation along geodesic - a little \n             glitchy sometimes due to numerical inaccuracy :(\n     SHIFT   Reveal central point\n\n   These keys duplicate functionality in the UI:\n  \n     [ or ]  Previous/next projection\n     1-7     Set generator point\n     Q or A  Increment/decrement degree of 1st triangle vertex\n     W or S  Increment/decrement degree of 2nd triangle vertex\n     E or D  Increment/decrement degree of 2nd triangle vertex\n     YUIOP   Draw style options\n     JKL     Color schemes\n     X       Fix color (forced when translating along geodesic)\n\n   This shader is basically https://www.shadertoy.com/view/wtj3Ry \n   with a few improvements:\n\n     - using hyperboloid model instead of Poincaré disk for\n       \"native\" coordinate representation simplifies (LOL) \n       code and increases numerical stability\n\n     - added several other models/projections of the hyperbolic\n       plane besides Poincaré disk:\n\n        - Upper half-plane\n        - Band\n        - Inverted Poincaré disk\n        - Orthographic projection\n        - Beltrami-Klein model\n\n     - added support for translation along geodesics\n\n     - added support for rotation, continuous rotation mode\n\n     - added a new coloring type: random gradients of Viridis\n       see https://www.shadertoy.com/view/WlfXRN\n\n     - added a new draw style: circle packing\n\n     - use flat shading for rainbow/HSV coloring, looks cooler\n\n   Have fun!\n   -mattz\n\n*/\n\n// scene transform globals\nmat2 sceneRotate;\nvec3 sceneCenter;\nvec3 sceneWrap;\n\n//////////////////////////////////////////////////////////////////////\n// isometries to manipulate scene\n\nvec3 sceneTransformFwd(vec3 p) {\n    p = hyperTranslate(p, sceneWrap);\n    p.xy = sceneRotate * p.xy;\n    p = hyperTranslate(p, sceneCenter);\n    return p;\n}\n\nvec3 sceneTransformInv(vec3 p) { \n    p = hyperTranslate(p, vec3(-sceneCenter.xy, sceneCenter.z));\n    p.xy = p.xy * sceneRotate;\n    p = hyperTranslate(p, vec3(-sceneWrap.xy, sceneWrap.z));\n    return p;\n}\n\n//////////////////////////////////////////////////////////////////////\n// repeated reflections of triangle till it lands on x\n\nfloat flipTriangleToPoint(inout mat3 edges, in vec3 x) {\n   \n    // negative = odd, positive = even\n    float parity = 1.0;\n    \n    int insideCount = 0;\n    int i = 0;\n    \n    // enough flips to cover the hyperboloid hopefully\n    for (int iter=0; iter<60; ++iter) {\n        \n        // test if x is inside edge i\n        if (hyperDot(x, edges[i]) < 0.) {\n            \n            if (++insideCount == 3) {\n                break;\n            }\n            \n        } else {\n\n            // not done yet\n            insideCount = 0;\n\n            // get indices of other two edges\n            int j = TRI_NEXT(i);\n            int k = TRI_LAST(i, j);\n\n            // reflect edge j and k about edge i\n            edges[j] = reflectPG(edges[j], edges[i]);\n            edges[k] = reflectPG(edges[k], edges[i]);\n\n            // flip sign on edge i\n            edges[i] = -edges[i];\n\n            // flip parity\n            parity = -parity;\n\n        } // x outside edge\n        \n        // increment test edge\n        i = TRI_NEXT(i);\n        \n    } // for each flip\n        \n    return parity;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// return integers such that x is nearest perpendicular, \n// y is nearest face, and z is second-nearest face.\n//\n// note that y == z if the perpendicular is a mirror (i.e. lies \n// on an edge incident to a right angle)\n\nivec3 computeFace(vec3 x, mat3 verts, vec3 generator, \n                  mat3 perps, int triangleFlags) {\n\n    // approx. distances to each perpendicular\n    vec3 pdists = -hyperConj(x) * perps;\n    \n    // true unsigned distances along hyperboloid\n    vec3 pdistsTrue = asinh(abs(pdists));\n\n    // will hold return value\n    ivec3 face;\n    \n    // dist to nearest perp\n    float dmin = 1e5;\n\n    // dist from cur point to generator\n    float gdist = hyperDistPP(x, generator);\n\n    // for each perp\n    for (int i=0; i<3; ++i) {\n\n        // if zero length, ignore it\n        if (!QUERY_BIT(triangleFlags, BIT_PERP_HAS_LENGTH, i)) {\n            continue;\n        }\n        \n        // compute distance to ray from perpendicular to edge\n\n        // get the line perpendicular to perps[i] passing thru generator\n        vec3 l = geodesicPerpThruPoint(perps[i], generator);\n\n        // if x is over that line, take distance to generator, otherwise distance to perp\n        float d = hyperDot(x, l)*hyperDot(verts[i], l) > 0. ? gdist : pdistsTrue[i];\n\n        // update dmin\n        if (d < dmin) { \n            dmin = d;\n            face.x = i;\n        }\n\n    }\n    \n    // now face.x holds index of closest perp\n\n    // get vertices along the edge that perp is perpendicular to\n    face.y = TRI_NEXT(face.x);\n    face.z = TRI_LAST(face.x, face.y);\n\n    // if not a mirror edge...\n    if (QUERY_BIT(triangleFlags, BIT_PERP_SPLITS_EDGE, face.x)) {\n        // see which side of perp we lie on\n        if (pdists[face.x]*hyperDot(verts[face.y], perps[face.x]) > 0.) {\n            face = face.xzy; \n        } else {\n            face = face.xyz; \n        }\n    } else if (QUERY_BIT(triangleFlags, BIT_VERT_IS_FACE, face.y)) {\n        // was a mirror edge so choose the only valid vertex along it\n        face = face.xyy;\n    } else {\n        face = face.xzz;\n    }\n    \n    return face;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/WlfXRN\n\nvec3 palette(float t) {\n\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// based on https://www.shadertoy.com/view/4sfGzS\n\nvec2 noise( in vec3 x ) {\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(27.0,11.0)*p.z) + f.xy;\n\tvec4 t = textureLod( iChannel2, (uv+0.5)/256.0, 0.0);\n\treturn mix( t.xz, t.yw, f.z );\n    \n}    \n\n//////////////////////////////////////////////////////////////////////\n// random rgb values, just to look cool\n\nvec3 rando(vec3 x, vec3 v, vec3 vOrig, float vgmax, bool fixColors, float seed) {\n\n    float dz = vOrig.z - 1.;\n\n    float k = length(vOrig.xy);\n    const float kmax = 1.0;\n    \n    vec2 cs = (k < kmax ? vOrig.xy : vOrig.xy*kmax/k);\n    float r = dz < 1e-3 ? 0. : acosh(vOrig.z);\n\n    vec2 scl = fixColors ? vec2(1.5, 0.2) : vec2(127, 1);\n    \n    vec2 n = noise(vec3(scl.x*cs, scl.y*r) + mod(seed, 187.));\n    \n    float theta = n.y*2.*PI;\n    \n    vec3 l = vec3(cos(theta), sin(theta), 0); \n    \n    l = hyperTranslate(l, v);\n    \n    const float margin = 0.125;\n    const float basescl = 1. - 2.*margin;\n    \n    float d = hyperDistPG(x, l);\n    float offset = d * margin / vgmax;\n    \n    vec3 color = palette(smoothstep(0., 1., n.x)*basescl + margin + offset);\n\n    return color*color; // to counter sqrt in main\n   \n}\n\n//////////////////////////////////////////////////////////////////////    \n// hue from color in [0, 1]\n\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rainbow coloring based on Poincaré disk projection\n       \nvec3 rainbow(vec3 x) {\n    vec2 d = diskFromHyperboloid(x);\n    float h = 0.5*atan(d.x, d.y)/PI;\n    vec3 rgb = hue(h);\n    return mix(rgb, WHITE, 1.-dot(d.xy, d.xy));\n}\n\n//////////////////////////////////////////////////////////////////////\n// for coloring tiling - each polygon gets a constant fill color\n\nvec3 getFaceColor(vec3 x, int idx, int perpToMirror, \n                  mat3 verts, mat3 perps, int style, float vgmax,\n                  bool fixColors, float seed) {\n    \n            \n    if (style == FACE_COLOR_PRIMARY) {\n    \n        // primary colors just care about index for red/blue/yellow\n        return VCOLORS[idx];\n        \n    } else {\n        \n        // other colorings depend on vertex position - get vertex for this face\n        vec3 v = verts[idx];\n        \n        // flip it about mirror if necessary\n        if (perpToMirror >= 0) { v = reflectPG(v, perps[perpToMirror]); }\n        \n        vec3 vOrig = fixColors ? v : sceneTransformInv(v);\n\n        if (style == FACE_COLOR_RAINBOW) {\n            return rainbow(vOrig);\n        } else {\n            return rando(x, v, vOrig, vgmax, fixColors, seed);\n        }\n        \n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct a line from 2 points\n\nvec3 line2D(vec2 a, vec2 b) {\n    vec2 n = perp(b - a);\n    return vec3(n, -dot(n, a));\n}\n\n//////////////////////////////////////////////////////////////////////\n// 2D distance to line\n\nfloat lineDist2D(vec3 l, vec2 p) {\n    float s = length(l.xy);\n    return (dot(l.xy, p) + l.z)/s;\n}\n\n//////////////////////////////////////////////////////////////////////\n// 2D distance to line\n\nfloat lineDist2D(vec2 a, vec2 b, vec2 p) {\n    return lineDist2D(line2D(a, b), p);\n}\n\n//////////////////////////////////////////////////////////////////////\n// 2D distances to line and line segment\n\nvec2 lineSegDist2D(vec2 a, vec2 b, vec2 p) {\n\n    p -= a;\n    b -= a;\n    \n    vec2 n = normalize(perp(b));\n    \n    float u = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    \n    return vec2(dot(b, n) - dot(p, n), length(p-u*b));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to character in SDF font texture\n\nfloat fontDist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n      \n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+offset+0.5)*(1.0/16.0);\n    \n    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv)-0.5;\n        \n    return max(k-127.0/255.0, max(box.x, box.y))/scl;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// a string is a group of 4-character chunks (last one holds str len)\n\nfloat stringDist(vec2 textPos, float textSize, ivec4 chars) {  \n    \n    \n    int len = int(chars.w) >> 24;\n    float flen = float(len);\n    \n    float xsize = 0.8*textSize;\n    \n    float x0 = -0.5*(flen-1.)*xsize;\n    float xRel = textPos.x - x0;\n\n    float cidx = floor(xRel/xsize + 0.5);\n    \n    if (cidx < 0. || cidx >= flen || abs(textPos.y) > textSize) {\n        return 1e5;\n    }\n    \n    float xChar = x0 + cidx*xsize;\n\n    int i = int(cidx);\n    int c = chars[i>>2] >> ((i&0x3)<<3);\n\n    int lo = c & 0xF;\n    int hi = (c >> 4) & 0xF;\n\n    vec2 offset = vec2(float(lo), 15.-float(hi));\n\n    return fontDist(textPos - vec2(xChar, 0), textSize, offset);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to triangle for spin box\n\nfloat spinIconDist(vec2 pos, float size, bool flip, bool dim) {\n    \n    if (flip) { pos.y = -pos.y; }  \n    pos.x = abs(pos.x);\n        \n    vec2 p0 = vec2(0, 0.2)*size;\n    vec2 p1 = vec2(0.35, 0.2)*size;\n    vec2 p2 = vec2(0.0, -0.2)*size;\n    \n    float d = max(lineDist2D(p0, p1, pos), \n                  lineDist2D(p1, p2, pos));\n    \n    if (dim) { \n        d = abs(d + 0.02*pqrSize) - 0.02*size;\n    }\n    \n    return d;\n       \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to decor icon\n\nfloat styleIconDist(vec2 p, float sz, int style) {\n    \n    float s = sign(p.x*p.y);\n    \n    p = abs(p);\n    \n    // outside edge dist\n    vec2 a = vec2(0, sz);\n    vec2 b = vec2(sz, 0);\n    float l = lineDist2D(a, b, p);\n    \n    if (style == STYLE_DRAW_GENERATOR) {\n        float c = length( p - (p.x > p.y ? b : a)*0.8 );\n        return c - 0.2*sz;\n    } else if (style == STYLE_DRAW_POLYGONS) {\n        return abs(l + 0.04*sz) - 0.08*sz;\n    } else if (style == STYLE_DRAW_TRIANGLES) {\n        return min(abs(l), max(min(p.x, p.y), l)) - 0.03*sz;\n    } else if (style == STYLE_DRAW_CIRCLES) {\n        float c = length(p) - 0.65*sz;\n        return max(l, -c);\n    } else {\n        return min(max(min(s*p.x, s*p.y), l), abs(l)-0.03*sz);\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// draw color icon (RGB or facet-shaded selectors)\n\nvoid drawColorIcon(vec2 p, float sz, int i, bool enable, inout vec3 color) {\n    \n    const float k = 0.8660254037844387;\n    \n    mat2 R = mat2(-0.5, k, -k, -0.5);\n    \n    vec2 p1 = vec2(k*sz, 0);\n    vec2 p2 = vec2(0, 0.5*sz);\n        \n    float ue = enable ? 1. : 0.3;\n    float ds = 1e5;\n    \n    vec2 po = p;\n        \n    for (int j=0; j<3; ++j) {\n        \n        vec2 ap = vec2(abs(p.x), abs(p.y-0.5*sz));\n        \n        vec2 dls = lineSegDist2D(p2, p1, ap);\n                \n        vec3 src = WHITE;\n        \n        if (i == 0) {\n            src = VCOLORS[j];\n        } else if (i == 1) {\n            float t = (atan(po.y, po.x)+0.5*PI)*0.5/PI;\n            src = hue(t - 0.333) * 0.6666 + 0.3333;\n        } else {\n            const float k[3] = float[3](0.75, 0.25, 0.5);\n            src = palette(k[j] + 0.5*dot(p-p2, perp(p2-p1))/(sz*sz) );\n        }\n        \n        color = mix(color, src, smoothstep(1.0, 0.0, -dls.x+0.5) * ue);\n        ds = min(ds, dls.y);\n                \n        p = R*p;\n    \n    }\n\n    color = mix(color, vec3(0), smoothstep(1.0, 0.0, ds-0.05*sz) * ue);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// draw helper arrow that appears under mouse\n\nvec3 drawCompass(vec3 colorOut, vec2 uv) {\n\n    vec2 ctrUV = fromHyperboloid(sceneCenter);\n        \n    vec3 h = hyperboloidFromOrtho(vec2(0.1, 0));\n\n    vec2 y = normalize(fromHyperboloid(sceneTransformFwd(h.yxz)) - ctrUV);\n\n    vec2 p = (uv - ctrUV)/px;\n    p = p*mat2(-perp(y), y);\n\n    float s = pqrSize;\n\n    float d = fontDist(p, s, vec2(1,14));\n\n    d = max(d, max(abs(p.y) - 0.8*s, abs(p.x) - 0.5*s));\n\n    colorOut = mix(colorOut, BLACK, smoothstep(1.0, 0.0, d-1.5));\n    colorOut = mix(colorOut, WHITE, smoothstep(1.0, 0.0, d+0.5));\n    \n    return colorOut;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    ///////////////////////////////////////////////////\n    // load data from registers\n    \n    vec4 pqr = LOAD4(REG_PQR_PROJ);\n    vec3 gbary = LOAD3(REG_GENERATOR);\n    vec4 center = LOAD4(REG_CENTER); \n    ivec4 flags = ivec4(LOAD4(REG_FLAGS));\n    vec3 uiState = LOAD3(REG_UI_STATE);\n    vec2 rvec = LOAD2(REG_ROTATE);\n    vec3 time = LOAD3(REG_TIME);\n    vec4 wrap = LOAD4(REG_WRAP);\n    \n    bool paused = (time.x == time.y);\n    \n    sceneCenter = center.xyz;\n    sceneWrap = vec3(0, 0, 1);\n    sceneRotate = mat2(rvec, perp(rvec));\n    \n    int drawStyle = flags.x;\n    int faceColor = flags.y;\n    int triangleFlags = flags.z;\n    \n    ///////////////////////////////////////////////////\n\t// set up projection and draw tiling if valid\n\n    setupProjection(int(pqr.w), iResolution.xy, uiState.x);\n    \n    vec2 uv = sceneFromFrag(fragCoord);\n    \n    vec3 colorOut = WHITE;\n    vec3 uiColor = WHITE;\n    \n    float uiOpacity = smoothstep(0.0, 0.9, uiState.x);\n    \n    bool insideUI = insideBox(fragCoord, uiBox) && uiOpacity > 0.; \n    bool insideInset = insideUI && insideBox(fragCoord, insetBox);\n    bool drawTiling = pointValid(uv) && (!insideUI|| uiOpacity < 1.);\n    \n    // compute edges from PQR\n    mat3 edges;\n    \n    if (insideInset || drawTiling) { \n        edges = setupTriangle(pqr.xyz);\n        insetEdges = edges;\n    }\n \n    bool fixColors = ((center.w == CENTER_SWEEPING) ||\n                      bool(flags.x & STYLE_FIX_COLOR));\n   \n    // draw tiling\n    if (drawTiling) {\n\n        ///////////////////////////////////////////////////\n        // handle scroll\n\n        // see if scroll pos stored as hyperboloid coords or\n        // scene coords (latter need projection)\n        if (sceneCenter.z == 0.) {\n            sceneCenter = toHyperboloid(projValid(sceneCenter.xy, false));\n        }\n        \n        vec2 ctrScene = fromHyperboloid(sceneCenter);\n         \n        // deal with wrap\n        if (center.w == CENTER_SWEEPING) {\n    \n            float dist = wrap.w;\n\n            vec3 u = vec3(0, 0, 1);\n\n            dist *= fract(time.z) - 0.5;\n\n            sceneWrap = hyperNormalizeP(u*cosh(dist) + wrap.xyz*sinh(dist));\n\n        }\n        \n        ///////////////////////////////////////////////////\n        // triangle setup\n\n        // translate edges by scroll position\n        for (int i=0; i<3; ++i) {\n            edges[i] = sceneTransformFwd(edges[i]);\n        }       \n\n        // project current frag pos to the hyperboloid\n        vec3 x = toHyperboloid(uv);\n        \n        x = toHyperboloid(fromHyperboloid(x));\n\n        // flip triangle on top of current frag pos\n        float parity = flipTriangleToPoint(edges, x);\n\n        // compute vertices\n        mat3 verts = hyperTriVerts(edges);\n        \n        // compute generator position from barycentric coords\n        vec3 generator = hyperNormalizeP(verts * gbary);\n\n        // compute perpendiculars thru generator to edges\n        mat3 perps = hyperTriPerps(edges, generator);\n\n        // compute max dist to vert from generator\n        float vgmax = -1e5;\n        \n        for (int i=0; i<3; ++i) {\n            vgmax = max(vgmax, hyperDistPP(verts[i], generator));\n        }\n        \n        // compute radii for drawing circles below\n        vec3 rads = vec3(1e5);\n        \n        if (bool(drawStyle & STYLE_DRAW_CIRCLES)) {\n            for (int i=0; i<3; ++i) {\n                if (QUERY_BIT(triangleFlags, BIT_VERT_IS_FACE, i)) {\n                    int j = TRI_NEXT(i);\n                    int k = TRI_LAST(i, j);\n                    rads[i] = min(rads[i], abs(hyperDot(verts[i], perps[j])));\n                    rads[i] = min(rads[i], abs(hyperDot(verts[i], perps[k])));\n                }\n            }\n            rads = asinh(rads);\n        }\n            \n        /////////////////////////////////////////////////////////////////\n        // find out which polygon face we lie on\n\n        // face.x = closest perp\n        // face.y = closest vert index\n        // face.z = second closest vert index\n\n        ivec3 face = computeFace(x, verts, generator, perps, triangleFlags);\n        \n        float fparity = hyperDot(verts[face.y], perps[face.x]) < 0. ? -1. : 1.; \n\n        int perpToMirror = face.z == face.y ? face.x : -1;\n        \n        // colors for each face\n        vec3 faceFG = getFaceColor(x, face.y, -1, \n                                   verts, perps, faceColor, vgmax,\n                                   fixColors, uiState.z);\n        \n        vec3 faceBG = getFaceColor(x, face.z, perpToMirror, \n                                   verts, perps, faceColor, vgmax,\n                                   fixColors, uiState.z);\t\n\n        /////////////////////////////////////////////////////////////////\n        // shade the current pixel\n\n        vec3 accum = vec3(0); \n        vec2 origUV = uv;\n\n        // 4-Rook Antialiasing\n        // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n        const vec2 deltas[4] = vec2[4](\n            vec2(0.125, 0.375),\n            vec2(-0.375, 0.125),\n            vec2(0.375, -0.125),\n            vec2(-0.125, -0.375)\n        );\n\n        // we will do either 1 or 4 subpixels - only need to \n        // worry about AA if projection is not conformal\n        float subPixelCoverage = isConformal ? 1.0 : 0.5;\n        float subPixelWeight = subPixelCoverage * subPixelCoverage;\n        float subPixelOffset = isConformal ? 0.0 : px;\n\n        // antialiasing distance\n        float lengthScale = metric(uv)/(px*subPixelCoverage);\n\n        // shade up to 4 sub-pixels\n        for (int i=0; i<4; ++i) {\n\n            // sub-pixel offset\n            uv = origUV + subPixelOffset * deltas[i];\n            \n            // project\n            x = toHyperboloid(uv);\n\n            // dists to triangle edges\n            vec3 edists = -hyperConj(x) * edges;\n            float emin = min(edists[0], min(edists[1], edists[2]));\n\n            // dist to polygon edges/perps\n            float pmin = fparity*hyperDot(x, perps[face.x]);\n\n            // shade fg vs BG\n            float fgWeight = smoothstep(-0.5, 0.5, pmin*lengthScale*0.5);\n            \n            vec3 subPixelColor = mix(faceBG, faceFG, fgWeight);\n            \n            // shade triangles\n            if (bool(drawStyle & STYLE_SHADE_TRIANGLES)) { \n                float brightWeight = smoothstep(-0.5, 0.5, parity*emin*lengthScale);\n                subPixelColor *= mix(0.75, 1.0, brightWeight);\n            }\n            \n            // draw triangle outlines\n            if (bool(drawStyle & STYLE_DRAW_TRIANGLES)) {\n                float tWeight = smoothstep(0.0, 1.0, (emin - 0.5*lineSize)*lengthScale);\n                subPixelColor *= mix(0.33333, 1.0, tWeight);\n            }\n\n            // draw polygon edges, generator, and circles\n            float bdist = 1e5;\n\n            if (bool(drawStyle & STYLE_DRAW_POLYGONS)) {\n                bdist = min(bdist, abs(pmin) - lineSize);\n            }\n\n            if (bool(drawStyle & STYLE_DRAW_GENERATOR)) {\n                bdist = min(bdist, hyperDistPP(x, generator)- 4.*lineSize);\n            }\n            \n            if (bool(drawStyle & STYLE_DRAW_CIRCLES)) {\n                float cmin = 1e5;\n                for (int i=0; i<3; ++i) {\n                    if (QUERY_BIT(triangleFlags, BIT_VERT_IS_FACE, i)) {\n                        float cdist = (hyperDistPP(x, verts[i])-rads[i]);\n                        cmin = min(cmin, cdist);\n                    }\n                }\n                bdist = min(bdist, -cmin);\n            }\n            \n            // shade in black\n            subPixelColor *= smoothstep(0.0, 1.0, bdist*lengthScale);\n\n            // accumulate this subpixel\n            accum += subPixelWeight * subPixelColor;\n\n            // only need to do one sample for conformal maps (AA just for klein & ortho)\n            if (isConformal) { break; }\n\n        }\n        \n        // done with tiling\n        colorOut = accum;\n        \n        // compass for locating center & direction\n        if (bool(flags.w)) {\n            sceneWrap = vec3(0, 0, 1);\n            colorOut = drawCompass(colorOut, uv);\n        }\n\n    }   \n    \n    // draw UI\n    if (insideUI) {\n        \n        float dBlack = 1e5;\n        float dGray = 1e5;\n\n        // text and spin icons\n        for (int i=0; i<3; ++i) {\n\n            vec2 textPos = fragCoord.xy - digitUIBox(i).xy;\n            dBlack = min(dBlack, fontDist(textPos, pqrSize, vec2(pqr[i], 12.0)));\n\n            vec2 p0 = fragCoord.xy - triUIBox(i, 1.).xy;\n            vec2 p1 = fragCoord.xy - triUIBox(i, -1.).xy;\n            dGray = min(dGray, spinIconDist(p0, pqrSize, true, pqr[i] == PQR_MAX));\n            dGray = min(dGray, spinIconDist(p1, pqrSize, false, pqr[i] == PQR_MIN));\n\n        }\n        \n        // top row of clickable icons\n        for (int i=0; i<5; ++i) {\n            \n            int flag = (1 << i);\n\n            vec2 p = fragCoord - iconUIBox(ivec2(i, 0)).xy;\n            float idist = styleIconDist(p, iconSize, flag);\n\n            if (bool(drawStyle & flag)) {\n                dBlack = min(dBlack, idist);\n            } else {\n                dGray = min(dGray, idist);\n            }\n\n        }\n\n        // bottom row of clickable icons\n        for (int i=0; i<3; ++i) {\n            bool enable = (faceColor == i);\n            vec2 pos = iconUIBox(ivec2(i+1, 1)).xy;\n            if (i > 0 && enable) {\n                //float d = length(fragCoord - pos) - 1.25*iconSize;\n                float d = boxDist(fragCoord, vec4(pos, vec2(1.25*iconSize)));\n                float w = smoothstep(1., 0., d);\n                if (center.w == CENTER_SWEEPING) {\n                    uiColor = mix(uiColor, LIGHTGRAY, w);\n                } else if (bool(flags.x & STYLE_FIX_COLOR)) {\n                    uiColor = mix(uiColor, GRAY, w);\n                }\n            }\n            drawColorIcon(fragCoord - pos, iconSize, i, enable, uiColor);\n        }\n        \n        // projection text\n        const ivec4 PROJ_STRINGS[6] = ivec4[6](\n            ivec4(0x6e696f50,0xe9726163,0x73696420,0x0d00006b),\n            ivec4(0x666c6148,0x616c702d,0x0000656e,0x0a000000),\n            ivec4(0x646e6142,0x00000000,0x00000000,0x04000000),\n            ivec4(0x65766e49,0x64657472,0x73696420,0x0d00006b),\n            ivec4(0x6874724f,0x6172676f,0x63696870,0x0c000000),\n            ivec4(0x746c6542,0x696d6172,0x656c4b2d,0x0e006e69)\n        );\n\n        float textDist = stringDist(fragCoord - projBox.xy, \n                                    projSize,\n                                    PROJ_STRINGS[activeProj]);\n        \n        // spin icons for projection\n        for (int i=0; i<2; ++i) {\n            vec2 p = projUIBox(i == 0 ? -1. : 1.).xy;\n            p = fragCoord - p;\n            p = p.yx;\n            dGray = min(dGray, spinIconDist(p, 2.*projSize, i==1, false));\n        }\n        \n        // inset triangle\n        if (insideInset) {\n            \n            setupInset(insetEdges);\n            vec2 uv = diskFromInset(fragCoord);\n            \n            if (dot(uv, uv) < 0.99) {\n                \n                vec3 x = hyperboloidFromDisk(uv);\n                float ds = diskMetric(uv);\n                \n                // distance to \n                float pmin = 1e5;\n                float pmax = -1e5;\n                \n                float gmin = 1e5;\n                \n                for (int i=0; i<3; ++i) {\n                    float di = hyperDot(x, insetEdges[i]);\n                    pmin = min(pmin, abs(di));\n                    pmax = max(pmax, di);\n                    vec3 l = geodesicPerpThruPoint(insetBisectors[i], insetVerts[i]);\n                    pmax = max(pmax, -hyperDot(x, l));\n                    gmin = min(gmin, length(uv - diskFromHyperboloid(insetVerts[i])));\n                    gmin = min(gmin, length(uv - diskFromHyperboloid(insetEdgePoints[i])));\n\n                }\n                gmin = min(gmin, length(uv));               \n                \n                uiColor = mix(uiColor, LIGHTGRAY, step(pmax, 0.0));\n                uiColor *= smoothstep(0.0, 1.0, max(pmin, pmax)*ds/insetPx-0.5);\n                uiColor *= smoothstep(0.0, 1.0, gmin/insetPx-insetPointSize);\n                uiColor = mix(uiColor, WHITE, smoothstep(1.0, 0.0, gmin/insetPx-insetPointSize+2.0));\n                \n                vec3 generator = hyperNormalizeP(insetVerts * gbary.xyz);\n                gmin = length(uv - diskFromHyperboloid(generator));\n\n                uiColor = mix(uiColor, RED, smoothstep(1.0, 0.0, gmin/insetPx-insetPointSize+1.75));\n                \n            }\n            \n        }\n        \n        dBlack = min(dBlack, textDist+0.25);\n\n        // draw the things\n        uiColor = mix(GRAY, uiColor, smoothstep(0.0, 1.0, dGray));\n        uiColor = mix(BLACK, uiColor, smoothstep(0.0, 1.0, dBlack));\n    \n        colorOut = mix(colorOut, uiColor, uiOpacity);\n        \n    }\n    \n    // draw outer disk for klein or poincare disk\n    if (shouldDrawDisk) { \n        colorOut *= smoothstep(0.0, 1.0, abs(length(uv)-1.0)/px-0.5);\n    } \n    \n    // draw line separating UI from scene\n    if (activeProj != PROJ_DISK && activeProj != PROJ_KLEIN) {\n        float lineDist = abs(lineDist2D(uiBorder, fragCoord))-0.5;\n        vec3 lineColor = colorOut * smoothstep(0.0, 1.0, lineDist);\n        colorOut = mix(colorOut, lineColor, uiOpacity); \n    }\n\n#ifdef DEMO_SHOW_SEED\n    {\n        int seed = int(uiState.z);\n        bool done = false;\n        float s = pqrSize;\n        vec2 textPos = fragCoord - vec2(iResolution.x - 0.5*s, 0.75*s);\n        for (int i=0; i<20; ++i) {\n            int k = (seed % 10);\n            seed = seed / 10;\n            float d = fontDist(textPos, s, vec2(float(k), 12));\n            colorOut = mix(colorOut, BLACK, smoothstep(1.0, 0.0, d-1.5));\n            colorOut = mix(colorOut, WHITE, smoothstep(1.0, 0.0, d+1.5));\n            textPos.x += 0.8*s;\n            if (i > 0 && seed == 0) { break; }\n        }\n    }\n#endif    \n    \n    // approximate gamma correction\n    fragColor = vec4(sqrt(colorOut), 1);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RED vec3(0.8, 0, 0)\n#define BLUE vec3(0, 0, 0.8)\n#define GREEN vec3(0, 0.5, 0)\n#define CYAN vec3(0, 0.5, 0.8)\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define GRAY vec3(.3)\n#define LIGHTGRAY vec3(.8)\n#define LIGHTRED vec3(0.9, 0.5, 0.5)\n#define LIGHTBLUE vec3(0.5, 0.5, 0.9)\n\n#define REG_PQR_PROJ  ivec2(0,0)\n#define REG_MOUSE     ivec2(1,0)\n#define REG_GENERATOR ivec2(2,0)\n#define REG_FLAGS     ivec2(3,0)\n#define REG_CENTER    ivec2(4,0)\n#define REG_TIME      ivec2(5,0)\n#define REG_UI_STATE  ivec2(6,0)\n#define REG_ROTATE    ivec2(7,0)\n#define REG_WRAP      ivec2(8,0)\n\n#define STYLE_DRAW_POLYGONS   0x01\n#define STYLE_DRAW_GENERATOR  0x02\n#define STYLE_DRAW_TRIANGLES  0x04\n#define STYLE_DRAW_CIRCLES    0x08\n#define STYLE_SHADE_TRIANGLES 0x10\n#define STYLE_FIX_COLOR       0x20\n\n#define FACE_COLOR_PRIMARY    0\n#define FACE_COLOR_RAINBOW    1\n#define FACE_COLOR_RANDOM     2\n\n#define LOADC(c, reg) texelFetch(c, reg, 0)\n#define LOAD(reg) texelFetch(iChannel0, reg, 0)\n\n#define LOAD1(reg) LOAD(reg).x\n#define LOAD2(reg) LOAD(reg).xy\n#define LOAD3(reg) LOAD(reg).xyz\n#define LOAD4(reg) LOAD(reg)\n\n#define PROJ_DISK     0\n#define PROJ_HALF     1\n#define PROJ_BAND     2\n#define PROJ_INV_DISK 3\n#define PROJ_ORTHO    4\n#define PROJ_KLEIN    5\n\n#define NUM_PROJ      6.\n\n#define CLAMP_ABS(x, m) clamp((x), -(m), (m))\n\n#define TRI_NEXT(i)   ((2 + (i)*(5 - 3*(i)))/2)\n#define TRI_LAST(i,j) (3 - (i) - (j))\n\n#define PI 3.141592653589793\n\n#define BIT_VERT_IS_FACE     0\n#define BIT_PERP_HAS_LENGTH  3\n#define BIT_PERP_SPLITS_EDGE 6\n\n#define CLEAR_BIT(flags, bit, idx) (flags) &= ~(1 << ((bit) + (idx)))\n#define QUERY_BIT(flags, bit, idx) (((flags) & (1 << ((bit)+(idx)))) != 0)\n\n#define PQR_MIN 2.\n#define PQR_MAX 9.\n\n#define PCOLOR vec3(1, 0, 0)\n#define RCOLOR vec3(1, 1, 0)\n#define QCOLOR vec3(0, 0, 1)\n\n#define CENTER_STATIONARY 0.\n#define CENTER_SWEEPING   1.\n#define CENTER_ROTATING   2.\n#define CENTER_GYRATING   3.\n\n\nconst mat3 VCOLORS = mat3(PCOLOR, QCOLOR, RCOLOR);\n\n// global projection variables\nint activeProj;\n\nfloat px;\nfloat lineSize;\n\n// global UI variables\nfloat uiSize;\nvec3 uiBorder;\n\nbool isConformal;\nbool shouldDrawDisk;\n\nvec4 sceneBox;\nvec4 uiBox;\n\nvec2 sceneOrigin;\n\nvec4 insetBox;\nvec4 iconsBox;\nvec4 pqrBox;\nvec4 projBox;\nfloat projSize;\n\nfloat iconSize;\nfloat pqrSize;\n\n// global vars for inset triangle\nmat3 insetEdges;\nmat3 insetBisectors;\nmat3 insetVerts;\nmat3 insetEdgePoints;\n\nvec2 insetOrigin;\nfloat insetPx;\nmat2 insetR;\nfloat insetPointSize;\n\n//////////////////////////////////////////////////////////////////////\n// rotate vector by 90 degrees\n\nvec2 perp(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to 2D box given by (ctr, radius)\n\nfloat boxDist(vec2 p, vec4 b) {\n    p = abs(p - b.xy) - b.zw;\n    return max(p.x, p.y);\n}\n\nbool insideBox(vec2 p, vec4 b) {\n    return boxDist(p, b) <= 0.;\n}\n\n//////////////////////////////////////////////////////////////////////\n// general hyperbolic functions\n\n// return p but with z flipped\nvec3 hyperConj(vec3 p) {\n    return vec3(p.xy, -p.z);\n}\n\n// hyperDot(u, v) = dot(u, hyperConj(v)) = dot(hyperConj(u), v)\nfloat hyperDot(vec3 u, vec3 v) {\n    return dot(u.xy, v.xy) - u.z*v.z;   \n}\n\n// return cross product with negative z\n// hyperDot(x, hyperCross(x, y)) = hyperDot(y, hyperCross(x, y)) = 0\nvec3 hyperCross(vec3 x, vec3 y) {\n    return hyperConj(cross(x, y));\n}\n\n// flip point if necessary to lie in upper hyperboloid and normalize it\n// so that hyperDot(u, u) = -1\nvec3 hyperNormalizeP(vec3 u) {\n    float s = u.z < 0. ? -1. : 1.;\n    return u * (s / sqrt(-hyperDot(u, u)));\n}\n\n// normalize geodesic so that hyperDot(v, v) = 1\nvec3 hyperNormalizeG(vec3 v) {\n    return v / sqrt(hyperDot(v, v));\n}\n\n// distance between two points\nfloat hyperDistPP(vec3 u, vec3 v) {\n    return acosh(max(1.0, -hyperDot(u, v)));\n}\n\n// distance between point and line\nfloat hyperDistPG(vec3 u, vec3 v) {\n    return asinh(hyperDot(u, v));\n}\n\n// construct geodesic from two points\nvec3 geodesicFromPoints(vec3 u, vec3 v) {\n    return hyperNormalizeG(hyperCross(u,v));\n}\n\n// construct geodesic perpendicular to l passing thru x\n#define geodesicPerpThruPoint(l,x) geodesicFromPoints(l,x)\n\n// intersection of two geodesics - undefined if they don't intersect\nvec3 intersectGG(vec3 l, vec3 f) {\n    return hyperNormalizeP(hyperCross(l, f));\n}\n\n// construct bisector of two points\nvec3 hyperBisector(vec3 u, vec3 v) {\n    return hyperNormalizeG(hyperCross(u+v, hyperCross(u, v)));\n}\n\n// reflect point across geodesic\nvec3 reflectPG(vec3 x, vec3 l) {\n    return x - (2.*hyperDot(x,l)/hyperDot(l,l))*l;\n}\n\n// translate the origin to a specific point\nvec3 hyperTranslate(vec3 p, vec3 t) {\n    \n    if (dot(t.xy, t.xy) < 1e-7) { return p; }\n    \n    vec3 flipz = vec3(1, 1, -1);\n    vec3 o = vec3(0, 0, 1);\n    \n    vec3 tp1 = t+o;\n    vec3 tx1 = cross(t, o) * flipz;\n    \n    // bisector of t and origin\n    vec3 b = cross(t+o, tx1);\n    \n    // reflect across bisector\n    p -= (2.*hyperDot(p, b)/hyperDot(b,b))*b;\n    \n    // reflect direction of t\n    vec2 n = t.xy;\n    p.xy = p.xy - (2.*dot(n, p.xy)/dot(n,n))*n;\n     \n    return p;\n\n}\n\n// construct angular bisector at intersection of l1 & l2\nvec3 hyperAngleBisector(vec3 l1, vec3 l2) {\n    return hyperNormalizeG(l1 - l2);\n}\n\n// set up a triangle with angles pi/p, pi/q, pi/r, anchored at origin\nmat3 setupTriangle(vec3 pqr) {\n    \n    vec3 angles = PI/pqr;\n    \n    vec3 cpqr = cos(angles);\n    float sp = sin(angles.x);\n    \n    float a = (cpqr.x*cpqr.y + cpqr.z)/sp;\n    float b = cpqr.y;\n    float c = sqrt(a*a + b*b - 1.);\n \n    return mat3(vec3(-b, a, c),\n                vec3(-cpqr.x, -sp, 0),\n                vec3(1, 0, 0));\n    \n}\n\n// construct triangle vertices from edges\nmat3 hyperTriVerts(mat3 edges) {\n    \n    mat3 verts;\n    \n    for (int i=0; i<3; ++i) {\n        int j = TRI_NEXT(i);\n        int k = TRI_LAST(i, j);\n        verts[i] = intersectGG(edges[j], edges[k]);\n    }\n    \n    return verts;\n    \n}\n\n// construct angle bisectors at vertices of triangle\nmat3 hyperTriAngleBisectors(mat3 edges) {\n    \n    mat3 bisectors;\n    \n    for (int i=0; i<3; ++i) {\n        int j = TRI_NEXT(i);\n        int k = TRI_LAST(i, j);\n        bisectors[i] = hyperAngleBisector(edges[j], edges[k]);\n    }\n    \n    return bisectors;\n    \n}\n\n// construct perpendiculars to edges passing thru generator\nmat3 hyperTriPerps(mat3 edges, vec3 generator) {\n    \n    mat3 perps;\n    \n    for (int i=0; i<3; ++i) {\n        perps[i] = geodesicPerpThruPoint(edges[i], generator);\n    }\n    \n    return perps;\n    \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// complex math functions\n\nvec2 complexLog(vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 complexExp(vec2 z) {\n    return exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 complexInv(vec2 z) {\n    return vec2(z.x, -z.y) / dot(z, z);   \n}\n\nvec2 complexMul(vec2 a, vec2 b)  {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);    \n}\n\nvec2 complexAtanh(vec2 z) {\n    return 0.5*(complexLog(vec2(1, 0) + z) - complexLog(vec2(1, 0) - z));\n}\n\nvec2 complexTanh(vec2 z) {\n    \n    vec2 e2z = complexExp(2.*z);\n    \n    vec2 num = e2z - vec2(1, 0);\n    vec2 denom = e2z + vec2(1, 0); \n    \n    return complexMul(num, complexInv(denom));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Poincaré disk projection functions\n\nfloat diskMetric(vec2 d) {\n    return 0.5*(1. - dot(d, d));\n}\n\nbool diskPointValid(vec2 d) {\n    return dot(d, d) < 1.;\n}\n\nvec2 diskProjValid(vec2 d, bool pad) {\n    \n    float DISK_MAX = pad ? 0.95 : 0.875;\n    \n    float l = length(d);\n    if (l > DISK_MAX) { d *= DISK_MAX/l; }\n    return d;\n    \n}\n\nvec2 diskFromHyperboloid(vec3 p) {\n    return p.xy / (1. + p.z);\n}\n\nvec3 hyperboloidFromDisk(vec2 d) {\n    float s = dot(d, d);\n    return vec3(2.*d, 1.+s) / (1. - s); \n}\n\n//////////////////////////////////////////////////////////////////////\n// Poincaré half-plane projection functions\n\nbool halfPointValid(vec2 h) {\n    return h.y > 0.;\n}\n\nvec2 halfProjValid(vec2 h, bool pad) {\n    float ey = pad ? 0.01 : 0.1;\n    return vec2(h.x, max(h.y, ey));\n}\n\nfloat halfMetric(vec2 h) {\n    return h.y;\n}\n\nvec2 halfFromDisk(vec2 d) {\n    \n    float dx2 = d.x*d.x;\n    float dy1 = (d.y - 1.);\n    float k = 1./(dx2 + dy1*dy1);\n    \n    float hx = 2.*d.x*k;\n    float hy = -(dx2 + dy1*(d.y + 1.))*k;\n    \n    return vec2(hx, hy);\n\n}\n\nvec2 diskFromHalf(vec2 h) {\n    \n    float hx2 = h.x*h.x;\n    float hy1 = (h.y + 1.);\n    float k = 1./(hx2 + hy1*hy1);\n    \n    float dx = 2.*h.x*k;\n    float dy = (hx2 + (h.y - 1.)*hy1)*k;\n    \n    return vec2(dx, dy);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Band projection functions\n\nbool bandPointValid(vec2 b) {\n    return abs(b.y) < 1.;\n}\n\nvec2 bandProjValid(vec2 b, bool pad) {\n    const vec2 BAND_LIMITS = vec2(1.125, 0.85);\n    return CLAMP_ABS(b, BAND_LIMITS + (pad ? 0.05 : 0.));\n}\n\n#define BAND_SCL (4./PI)\n\nfloat bandMetric(vec2 b) {\n    return (2./PI)*cos(b.y*0.5*PI);\n}\n\nvec2 bandFromDisk(vec2 z) {\n    return BAND_SCL*complexAtanh(z);\n}\n\nvec2 diskFromBand(vec2 z) {\n    return complexTanh(z / BAND_SCL);\n}\n\n//////////////////////////////////////////////////////////////////////\n// inverted poincare disk projection functions\n\nvec2 invertDisk(vec2 p) {\n    return p / dot(p, p);\n}\n\nbool invDiskPointValid(vec2 p) {\n    return dot(p, p) > 1.;\n}\n\nvec2 invDiskProjValid(vec2 p, bool pad) {\n    \n    float DISK_MIN = pad ? 1.15 : 1.25;\n    \n    if (p == vec2(0)){ \n        return vec2(0, 1.65);\n    }\n    \n    \n    float l = length(p);\n    \n    return l < DISK_MIN ? p*DISK_MIN/l : p;\n    \n}\n\nfloat invDiskMetric(vec2 p) {\n    float d = dot(p, p);\n    return 0.5*(1. - 1./d)*d;\n}\n\n//////////////////////////////////////////////////////////////////////\n// orthographic projection functions\n\nvec2 orthoFromHyperboloid(vec3 p) {\n    return p.xy;\n}\n\nvec3 hyperboloidFromOrtho(vec2 o) {\n    return vec3(o, sqrt(1. + dot(o, o)));\n}\n\nmat2x3 hyperboloidFromOrthoJacobian(vec2 o) {\n    \n    float s = 1./sqrt(1. + dot(o, o));\n    \n    vec3 j0 = vec3(1, 0, o.x*s);\n    vec3 j1 = vec3(0, 1, o.y*s);\n    \n    return mat2x3(j0, j1);\n\n}\n\nfloat orthoMetric(vec2 o) {\n \n    float w = 1./(1. + dot(o, o));\n    \n\t// hyper-dot products of jacobian above    \n    float j00 = 1. - o.x*o.x*w;\n    float j01 = -o.x*o.y*w;\n    float j11 = 1. - o.y*o.y*w; \n\n    // inspired by equation 1.4 of Arvo 2001\n    float dA = sqrt(j00*j11 - j01*j01);\n    \n    return 1.0 / sqrt(dA);\n\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// klein projection functions\n\nvec2 kleinFromDisk(vec2 d) {    \n    return 2.*d / (1. + dot(d, d)); \n}\n\nvec2 diskFromKlein(vec2 k) {\n    float z = sqrt(1. - dot(k, k));\n    vec2 d = k / (1. + z);\n    return d;\n}\n\nmat2 kleinFromDiskJacobian(vec2 d) {\n    \n\tvec2 d2 = d*d;\n    \n    float z = (1. + dot(d,d));\n    float h = 2.0/(z*z);\n    \n    float m00 = (-d2.x + d2.y + 1.);\n    float m11 = (d2.x - d2.y + 1.);\n    \n    float m01 = -2.*d.x*d.y;\n    \n    return mat2(m00, m01, m01, m11)*h;\n                   \n}\n\nfloat kleinMetric(vec2 k) {\n\n    vec2 d = diskFromKlein(k);\n    \n    vec2 d2 = d*d;\n    \n    float z = (1. + dot(d,d));\n    \n    float m00 = (-d2.x + d2.y + 1.);\n    float m11 = (d2.x - d2.y + 1.);\n        \n    // determinant of jacobian above\n    return diskMetric(d) * sqrt(2.*m00*m11 - 4.*d2.x*d2.y)/z;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// generic projection functions - just call functions above\n// depending on activeProj\n\nvec2 fromHyperboloid(vec3 p) {\n    \n    if (activeProj == PROJ_DISK) {\n        return diskFromHyperboloid(p);\n    } else if (activeProj == PROJ_HALF) {\n        return halfFromDisk(diskFromHyperboloid(p));\n    } else if (activeProj == PROJ_BAND) {\n        return bandFromDisk(diskFromHyperboloid(p));\n    } else if (activeProj == PROJ_INV_DISK) {\n        return invertDisk(diskFromHyperboloid(p));\n    } else if (activeProj == PROJ_ORTHO) {\n        return orthoFromHyperboloid(p);\n    } else if (activeProj == PROJ_KLEIN) {\n        return kleinFromDisk(diskFromHyperboloid(p));\n    }\n    \n}\n\nvec3 toHyperboloid(vec2 q) {\n    \n    if (activeProj == PROJ_DISK) {\n        return hyperboloidFromDisk(q);\n    } else if (activeProj == PROJ_HALF) {\n        return hyperboloidFromDisk(diskFromHalf(q));\n    } else if (activeProj == PROJ_BAND) {\n        return hyperboloidFromDisk(diskFromBand(q));\n    } else if (activeProj == PROJ_INV_DISK) {\n        return hyperboloidFromDisk(invertDisk(q));\n    } else if (activeProj == PROJ_ORTHO) {\n        return hyperboloidFromOrtho(q);\n    } else {\n        return hyperboloidFromDisk(diskFromKlein(q));\n    }\n    \n}\n\nbool pointValid(vec2 q) {\n    \n    if (activeProj == PROJ_DISK || activeProj == PROJ_KLEIN) {\n        return diskPointValid(q);\n    } else if (activeProj == PROJ_INV_DISK) {\n        return invDiskPointValid(q);\n    } else if (activeProj == PROJ_HALF) {\n        return halfPointValid(q);\n    } else if (activeProj == PROJ_BAND) {\n        return bandPointValid(q);\n    } else {\n        return true;\n    }\n    \n}\n\nvec2 projValid(vec2 q, bool pad) {\n    \n    if (activeProj == PROJ_DISK || activeProj == PROJ_KLEIN) {\n        return diskProjValid(q, pad);\n    } else if (activeProj == PROJ_INV_DISK) {\n        return invDiskProjValid(q, pad);\n    } else if (activeProj == PROJ_HALF) {\n        return halfProjValid(q, pad);\n    } else if (activeProj == PROJ_BAND) {\n        return bandProjValid(q, pad);\n    } else {\n        return q;\n    }\n\n}\n\nfloat metric(vec2 q) {\n    \n    if (activeProj == PROJ_DISK) {\n\n        return diskMetric(q);\n\n    } else if (activeProj == PROJ_HALF) {\n\n        return halfMetric(q);\n\n    } else if (activeProj == PROJ_BAND) {\n        \n        return bandMetric(q);\n        \n    } else if (activeProj == PROJ_INV_DISK) {\n        \n        return invDiskMetric(q);\n        \n    } else if (activeProj == PROJ_KLEIN) {\n        \n        return kleinMetric(q);\n                        \n    } else { // PROJ_ORTHO\n            \n        return orthoMetric(q);\n        \n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// pixel coords <-> scene coords\n\nvec2 sceneFromFrag(vec2 f) {\n    return (f - sceneOrigin) * px;\n}\n\nvec2 fragFromScene(vec2 s) {\n    return s / px + sceneOrigin;\n}\n\n//////////////////////////////////////////////////////////////////////\n// UI setup functions\n\nvec4 flipBox(vec4 box, vec2 dims) {\n    \n    box = box.yxwz;\n    box.xy = dims.yx - box.xy;\n    \n    return box;\n    \n}\n\nvoid setupUI(vec2 dims, bool flip, float showUI) {\n\n    uiSize = 0.25*dims.x;\n\n    float deltaUI = (1.0 - showUI) * uiSize;\n    \n    uiBox.xy = 0.5*vec2(uiSize, dims.y);\n    uiBox.zw = uiBox.xy;\n    \n    vec2 sceneSize = vec2(dims.x - uiSize, dims.y);\n\n    sceneBox.xy = vec2(uiSize + 0.5*sceneSize.x, 0.5*dims.y);\n    sceneBox.zw = 0.5*sceneSize;\n    \n    uiBox.x -= deltaUI;\n    \n    sceneBox.x -= 0.5*deltaUI;\n    sceneBox.z += 0.5*deltaUI;\n    \n    vec2 insetSize = vec2(uiSize, dims.y*(flip ? 0.2 : 0.3333));\n    \n    float remainingLength = dims.y - insetSize.y;\n    \n    vec2 sel = flip ? vec2(1, 0) : vec2(0, 1);\n    \n    insetBox.xy = vec2(uiBox.x, 0.5*insetSize.y);\n    insetBox.zw = 0.5*insetSize;\n    \n    float iconsLength = dot(sel, vec2(6, 6));\n    float pqrLength = dot(sel, vec2(4, 5));\n    float projLength = dot(sel, vec2(8, 2));\n    float gapLength = dot(sel, vec2(0.3, 0.5));\n    \n    float totalLength = iconsLength + pqrLength + projLength + 3.*gapLength;\n    \n    float scl = remainingLength / totalLength;\n    \n    iconsLength *= scl;\n    pqrLength *= scl;\n    projLength *= scl;\n    gapLength *= scl;\n    \n    iconsBox = vec4(uiBox.x, dims.y - 0.5*iconsLength, 0.5*uiSize, 0.5*iconsLength);\n    \n    pqrBox = vec4(uiBox.x, dims.y - iconsLength - 0.5*pqrLength - gapLength,\n                  0.5*uiSize, 0.5*pqrLength);\n    \n\n    projBox = vec4(uiBox.x, dims.y - iconsLength - pqrLength - 0.5*projLength - 2.*gapLength,\n                   0.5*uiSize, 0.5*projLength);\n    \n    uiBorder = vec3(1, 0, -uiSize+deltaUI); \n   \n    if (flip) { \n        uiBox = flipBox(uiBox, dims);\n        sceneBox = flipBox(sceneBox, dims);\n        insetBox = flipBox(insetBox, dims);\n        iconsBox = flipBox(iconsBox, dims);\n        pqrBox = flipBox(pqrBox, dims);\n        projBox = flipBox(projBox, dims);\n        uiBorder = vec3(0, -1, dims.x-uiSize+deltaUI);\n    } \n    \n    iconSize = min(0.15*iconsBox.z, 0.32*iconsBox.w);\n    pqrSize = min(0.65*pqrBox.z, 0.75*pqrBox.w);\n    projSize = min(0.13*projBox.z, projBox.w);\n\n    sceneOrigin = sceneBox.xy;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// initialize the viewport transformation & UI globals\n\nvoid setupProjection(in int p, vec2 res, float showUI) {\n                   \n    bool flip = res.y > res.x;\n    setupUI(flip ? res.yx : res.xy, flip, showUI);\n    \n    activeProj = p;\n    \n    float smin = min(sceneBox.z, sceneBox.w);\n    lineSize = 0.008 * smin;\n\n    if (activeProj == PROJ_HALF) {\n        px = 1.0 / sceneBox.w;\n        sceneOrigin.y = -0.01 / px;\n    } else if (activeProj == PROJ_INV_DISK) {\n        px = 3.0 / smin;\n        lineSize *= 0.125;\n    } else if (activeProj == PROJ_ORTHO) {\n        px = 3.0 / smin;\n    } else if (activeProj == PROJ_BAND) {\n        px = 0.98 / sceneBox.w;\n    } else { // klein/disk\n        px = 1.04 / smin;\n    }   \n        \n    lineSize *= px;\n    \n    isConformal = (activeProj < PROJ_ORTHO);\n    \n    shouldDrawDisk = (activeProj == PROJ_DISK || \n                      activeProj == PROJ_INV_DISK || \n                      activeProj == PROJ_KLEIN);\n    \n    if (isConformal) {\n        \n        vec2 uv = projValid(sceneFromFrag(0.5*res.xy), false);\n        float m = metric(uv);\n        lineSize /= m;\n        \n    }\n   \n}\n\n//////////////////////////////////////////////////////////////////////\n// setup the inset triangle - a little expensive to call\n\nvoid setupInset(mat3 edges) {\n    \n    for (int i=0; i<3; ++i) {\n        insetEdges[i] = vec3(-perp(edges[i].xy), edges[i].z);\n    }\n    \n    insetBisectors = hyperTriAngleBisectors(insetEdges);\n    vec3 center = intersectGG(insetBisectors[0], insetBisectors[1]);\n    \n    vec3 centerInv = -hyperConj(center);\n    \n    for (int i=0; i<3; ++i) {\n        insetEdges[i] = hyperTranslate(insetEdges[i], centerInv);\n        insetBisectors[i] = hyperTranslate(insetBisectors[i], centerInv);\n        insetEdgePoints[i] = intersectGG(insetEdges[i], insetBisectors[i]);\n    }\n    \n    insetVerts = hyperTriVerts(insetEdges);\n\n    vec2 insetVertsDisk[3];\n\n    for (int i=0; i<3; ++i) {\n        insetVertsDisk[i] = diskFromHyperboloid(insetVerts[i]);\n    }\n\n    vec2 n = normalize(insetVertsDisk[1] - insetVertsDisk[0]);\n    \n    insetR = mat2(n, perp(n));\n\n    vec2 dmin = vec2(1e5);\n    vec2 dmax = vec2(-1e5);\n    \n    for (int i=0; i<3; ++i) {\n        dmin = min(dmin, insetVertsDisk[i]*insetR);\n        dmax = max(dmax, insetVertsDisk[i]*insetR);\n    }\n    \n    insetPointSize = 0.1*min(insetBox.z, insetBox.w);\n\n    vec2 drad = 0.5*(dmax-dmin);\n    vec2 dscl = drad / (insetBox.zw - 3.0*insetPointSize);\n    \n    insetPx = max(dscl.x, dscl.y);\n    \n    insetOrigin = insetBox.xy - 0.5*(dmax+dmin)/insetPx;\n    \n}\n\n// Poincaré disk from inset box\nvec2 diskFromInset(vec2 fragCoord) {\n    return insetR*((fragCoord - insetOrigin)*insetPx);\n}\n\n//////////////////////////////////////////////////////////////////////\n// box locations for UI interactions\n\nvec4 iconUIBox(ivec2 idx) {\n    \n    vec2 iconCtr = iconsBox.xy;\n    \n    iconCtr = floor(iconCtr+0.5);\n    \n    vec2 scl = vec2(2.5*iconSize, 3.*iconSize);\n    iconCtr += vec2(float(idx.x), float(-idx.y))*scl + vec2(-2., 0.5)*scl; \n    \n    return vec4(iconCtr, vec2(iconSize));\n    \n}\n\nvec4 digitUIBox(int idx) {\n    \n    const vec2 digitRad = vec2(0.35, 0.5);\n    \n    return vec4(pqrBox.x + (float(idx - 1))*pqrSize,\n                pqrBox.y,\n                digitRad*pqrSize);\n\n}\n\nvec4 triUIBox(int idx, float delta) {\n    \n    return vec4(digitUIBox(idx).xy + vec2(0, 0.9*delta*pqrSize), \n                0.4*pqrSize, 0.3*pqrSize);\n    \n}\n\nvec4 projUIBox(float delta) {\n    \n    return vec4(projBox.xy + vec2(delta*6.5*projSize, 0),\n                0.75*projSize, 1.0*projSize);\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define STORE(reg, value) if(fc == (reg)) { data = (value); }\n\n#define STORE1(reg, value) STORE(reg, vec4(value, 0, 0, 0))\n#define STORE2(reg, value) STORE(reg, vec4(value, 0, 0))\n#define STORE3(reg, value) STORE(reg, vec4(value, 0))\n#define STORE4(reg, value) STORE(reg, value)\n\n#define KEY_TEX(key, row) (texelFetch(iChannel1, ivec2(key, row), 0).x != 0.)\n#define KEY_IS_DOWN(key)  KEY_TEX(key, 0)\n#define KEY_HIT(key)      KEY_TEX(key, 1)\n#define KEY_TOGGLE(key)   KEY_TEX(key, 0)\n\n#define MOUSE_INACTIVE       0.\n#define MOUSE_SCROLL         1.\n#define MOUSE_ROTATE         2.\n#define MOUSE_SET_GENERATOR  3.\n#define MOUSE_SNAP_GENERATOR 4.\n\n\n// global variables for register storage management\nvec4 data;\nivec2 fc;\n\n//////////////////////////////////////////////////////////////////////\n// return true if (1/p + 1/q + 1/r) < 1\n\nbool isValidPQR(vec3 pqr) {\n    return (pqr.x*pqr.y + pqr.x*pqr.z + pqr.y*pqr.z) < pqr.x*pqr.y*pqr.z;       \n}\n\n// ensure valid pqr by modifying other axis\nvec3 fixPQR(vec3 pqr, int pqrAxis) {\n    for (int iter=0; iter<10; ++iter) {\n        if (isValidPQR(pqr.xyz)) { break; }\n        int j = TRI_NEXT(pqrAxis);\n        int k = TRI_LAST(pqrAxis, j);\n        if (pqr[j] > pqr[k]) { j = k; }\n        pqr[j] += 1.;\n    }\n    return pqr;\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute properties of triangle whenever triangle changed\n\nint computeTriangleFlags(mat3 edges, mat3 verts, vec3 gbary) {\n    \n    vec3 generator = hyperNormalizeP(verts * gbary);\n\n    mat3 perps = hyperTriPerps(edges, generator);\n\n    const float TOL = 1e-3;\n\n    // initially: \n    //   - all verts are faces, \n    //   - all perps have length\n    //   - all perps split edges\n    int drawFlags = 0xfff;\n\n    for (int i=0; i<3; ++i) {\n\n        int j = TRI_NEXT(i);\n        int k = TRI_LAST(i, j);\n        \n        // if generator lives on edge i, perp i has no length\n        if (abs(hyperDot(generator, edges[i])) < TOL) {\n            CLEAR_BIT(drawFlags, BIT_PERP_HAS_LENGTH, i);\n        }\n        \n        // if vertex j or k is on perp i, it can't be a face center,\n        // and perp i does not split edge i\n        if (abs(hyperDot(verts[j], perps[i])) < TOL) {\n            CLEAR_BIT(drawFlags, BIT_VERT_IS_FACE, j);\n            CLEAR_BIT(drawFlags, BIT_PERP_SPLITS_EDGE, i);\n        }\n        \n        if (abs(hyperDot(verts[k], perps[i])) < TOL) {\n            CLEAR_BIT(drawFlags, BIT_VERT_IS_FACE, k);\n            CLEAR_BIT(drawFlags, BIT_PERP_SPLITS_EDGE, i);\n        }\n\n    }\n    \n    return drawFlags;\n    \n}\n\n// from https://www.shadertoy.com/view/4djSRW\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//////////////////////////////////////////////////////////////////////\n// update storage registers\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // get integer frag coords and texel data from last frame\n    fc = ivec2(fragCoord);\n    data = texelFetch(iChannel0, fc, 0);\n    \n    // load all the important variables\n    vec4 pqr = LOAD4(REG_PQR_PROJ);        // p, q, r, projection\n    vec4 generator = LOAD4(REG_GENERATOR); // generator barycentric coordinates\n    vec4 mstate = LOAD4(REG_MOUSE);        // mouse x, y, state, down\n    ivec4 flags = ivec4(LOAD4(REG_FLAGS)); // style flags, face coloring, triangle flags\n    vec4 center = LOAD4(REG_CENTER);       // scroll point, scroll mode\n    vec4 time = LOAD4(REG_TIME);           // last time, cur time, scroll time, period\n    vec3 uiState = LOAD3(REG_UI_STATE);    // current, target, start time\n    vec2 rvec = LOAD2(REG_ROTATE);\n    vec4 wrap = LOAD4(REG_WRAP);\n\n    bool randomDemo = false;\n    bool updateTriangle = false;\n        \n    // initialize on first frame\n    if (pqr == vec4(0)) {\n        randomDemo = true;\n#ifndef DEMO_MODE        \n        uiState = vec3(1, 1, 0);\n#endif\n#ifdef DEMO_SEED\n        uiState.z = float(DEMO_SEED);\n#else\n        uiState.z = floor(iDate.w * 100.);\n#endif        \n    }\n\n    if (KEY_HIT(187) || KEY_HIT(13)) { \n        uiState.z += 1.; randomDemo = true;\n    }\n\n    if (KEY_HIT(189)) {\n        uiState.z -= 1.; randomDemo = true;\n    }\n\n    if (randomDemo) {\n\n        float s = uiState.z;\n        \n        vec4 t0 = hash41(s);\n        vec4 t1 = hash41(s+1.);\n        vec4 t2 = hash41(s+2.);\n        vec4 t3 = hash41(s+3.);\n\n        pqr = floor(0.999*t0 * vec4(7,1,2,NUM_PROJ)) + vec4(3,2,3,0);\n        \n        for (int i=0; i<3; ++i) { pqr.xyz = fixPQR(pqr.xyz, i); }\n        \n        vec4 r = floor(0.999*t1 * vec4(31,3,3,6));\n        \n        if (r.w == 0.) {\n            pqr = pqr.zxyw;\n        } else if (r.w == 1.) {\n            pqr = pqr.zyxw;\n        } else if (r.w == 2.) {\n            pqr = pqr.yxzw;\n        } else if (r.w == 3.) {\n            pqr = pqr.yzxw;\n        } else if (r.w == 4.) {\n            pqr = pqr.xzyw;\n        }\n        \n        flags.x = int(r.x);\n        flags.y = int(r.y);\n        \n        if (bool(flags.x & STYLE_DRAW_CIRCLES) &&\n            bool(flags.x & (STYLE_DRAW_POLYGONS | STYLE_DRAW_GENERATOR))) {\n            if (t3.y > 0.5) {\n                flags.x &= ~(STYLE_DRAW_POLYGONS | STYLE_DRAW_GENERATOR);\n            } else {\n                flags.x &= ~(STYLE_DRAW_CIRCLES);\n            }\n        } else if (flags.x == STYLE_DRAW_GENERATOR) {\n            flags.x |= STYLE_SHADE_TRIANGLES;\n        } else if (flags.x == 0 && flags.y == FACE_COLOR_PRIMARY) {\n            flags.y = FACE_COLOR_RANDOM;\n        }\n\n        if (t3.z < 0.4) {\n            flags.x |= STYLE_FIX_COLOR;\n        }\n\n#ifdef DEMO_MODE\n        time.w = 1.0/6.0;\n#else        \n        time.w = 1.0 / (t3.w*4. + 6.);\n#endif        \n        \n        generator.w = floor(0.999*t3.x*7.);\n        \n        updateTriangle = true;\n\n        setupProjection(int(pqr.w), iResolution.xy, uiState.x);\n        \n        vec2 f = (t2.xy * 2. - 1.);\n        center.xy = sceneFromFrag(sceneBox.xy + f*sceneBox.zw);\n        float cc = dot(center.xy, center.xy);\n\n        if (activeProj == PROJ_DISK || activeProj == PROJ_KLEIN) {\n            if (cc > 1.) {\n                center.xy /= cc;\n            }\n        } else if (activeProj == PROJ_INV_DISK) {\n            if (cc < 1.) {\n                center.xy /= cc;\n            }\n        }\n        \n        center.z = 0.;\n        center.w = r.z + 1.;\n\n        rvec = normalize(t2.zw);\n\n    } else {\n        \n        // set up scene <-> frag projection\n        setupProjection(int(pqr.w), iResolution.xy, uiState.x);\n\n    }\n\n    // update time (for pause detection)\n    time.x = time.y;\n    time.y = iTime;\n\n    // see https://www.shadertoy.com/view/XdtyWB for explanation of this\n    bool paused = (time.x == iTime);\n\n#ifdef DEMO_MODE\n    time.z = iTime*time.w;\n#else\n    if (!paused) { time.z += iTimeDelta*time.w; }\n#endif    \n    \n    //////////////////////////////////////////////////\n    // UI/mouse interaction\n    \n    // fpr changing PQR\n    int pqrAxis = -1;\n    float pqrDelta = 0.;\n\n    // Q/A, W/S, E/D\n    if (KEY_HIT(81)) { pqrAxis = 0; pqrDelta =  1.; }\n    if (KEY_HIT(65)) { pqrAxis = 0; pqrDelta = -1.; }\n    if (KEY_HIT(87)) { pqrAxis = 1; pqrDelta =  1.; }\n    if (KEY_HIT(83)) { pqrAxis = 1; pqrDelta = -1.; }\n    if (KEY_HIT(69)) { pqrAxis = 2; pqrDelta =  1.; }\n    if (KEY_HIT(68)) { pqrAxis = 2; pqrDelta = -1.; }\n\n    // for changing projection\n    float projDelta = 0.;\n\n    // [/]\n    if (KEY_HIT(219)) { projDelta = -1.; }\n    if (KEY_HIT(221)) { projDelta =  1.; }\n\n    // space toggles UI\n    if (KEY_HIT(32)) { uiState.y = 1. - uiState.y; }\n\n    // YUIOP\n    if (KEY_HIT(89)) { flags.x ^= STYLE_DRAW_POLYGONS; }\n    if (KEY_HIT(85)) { flags.x ^= STYLE_DRAW_GENERATOR; }\n    if (KEY_HIT(73)) { flags.x ^= STYLE_DRAW_TRIANGLES; }\n    if (KEY_HIT(79)) { flags.x ^= STYLE_DRAW_CIRCLES; }\n    if (KEY_HIT(80)) { flags.x ^= STYLE_SHADE_TRIANGLES; }\n    \n    // JKL\n    if (KEY_HIT(74)) { flags.y = FACE_COLOR_PRIMARY; }\n    if (KEY_HIT(75)) { flags.y = FACE_COLOR_RAINBOW; }\n    if (KEY_HIT(76)) { flags.y = FACE_COLOR_RANDOM; }\n\n    // X\n    if (KEY_HIT(88) && center.w != CENTER_SWEEPING) {\n        flags.x ^= STYLE_FIX_COLOR;\n    }\n    \n    // keys 1-7 update generator position\n    for (int i=0; i<7; ++i) {\n        if (KEY_HIT(49 + i)) { generator.w = float(i); updateTriangle = true; }\n    }\n\n    // is mouse down, are we clicking?\n    bool mouseIsDown = min(iMouse.z, iMouse.w) > 0.;     \n    bool click = mouseIsDown && mstate.w == MOUSE_INACTIVE;;\n    \n    mstate = mouseIsDown ? vec4(mstate.xyz, 1) : vec4(0);\n    \n    bool shiftIsPressed = KEY_IS_DOWN(16);\n    \n    // handle initial mouse down\n    if (click) {\n        \n        if (insideBox(iMouse.xy, sceneBox)) {\n            if (!shiftIsPressed) {\n                // scroll scene\n                mstate.z = MOUSE_SCROLL;\n            } else if (pointValid(sceneFromFrag(iMouse.xy))) {\n                mstate.z = MOUSE_ROTATE;\n            }\n            \n        } else if (insideBox(iMouse.xy, insetBox)) {\n            // choose generator point\n            mstate.z = MOUSE_SET_GENERATOR;\n        } else if (insideBox(iMouse.xy, projUIBox(1.))) {\n            // proj left/right spin\n            projDelta = 1.;\n        } else if (insideBox(iMouse.xy, projUIBox(-1.))) {\n            // proj left/right spin\n            projDelta = -1.;\n        }\n        \n        // PQR spin boxes\n        for (int i=0; i<3; ++i) {\n            for (float delta=-1.; delta<2.; delta+=2.) {\n                if (insideBox(iMouse.xy, triUIBox(i, delta))) {\n                    pqrAxis = i;\n                    pqrDelta = delta;\n                }\n            }\n        }\n        \n        // draw style\n        for (int i=0; i<5; ++i) {\n            if (insideBox(iMouse.xy, iconUIBox(ivec2(i, 0)))) {\n                flags.x ^= (1 << i);\n            }\n        }\n        \n        // color\n        for (int i=0; i<3; ++i) {\n            if (insideBox(iMouse.xy, iconUIBox(ivec2(i+1, 1)))) {\n                if (i > 0 && center.w != CENTER_SWEEPING) {\n                    if (flags.y == i) {\n                        flags.x ^= STYLE_FIX_COLOR;\n                    } else {\n                        flags.x &= ~STYLE_FIX_COLOR;\n                    }\n                }\n                flags.y = i;\n            }\n        }\n        \n    }\n    \n    // handle scroll using mouse\n    if (mstate.z == MOUSE_SCROLL) {\n        center = vec4(sceneFromFrag(iMouse.xy), 0, \n                      center.w == CENTER_GYRATING ? CENTER_STATIONARY : center.w);\n    }        \n    \n    // handle mouse rotation\n    if (mstate.z == MOUSE_ROTATE) {\n        \n        vec3 u = center.z == 0. ? toHyperboloid(projValid(center.xy, false)) : center.xyz;\n        vec3 v = toHyperboloid(projValid(sceneFromFrag(iMouse.xy), true));\n        \n        vec3 l = geodesicFromPoints(u, v);\n        float cosTheta = -hyperDot(l, hyperTranslate(vec3(1, 0, 0), u));\n        float sinTheta = -hyperDot(l, hyperTranslate(vec3(0, 1, 0), u));\n        \n        rvec = normalize(vec2(cosTheta, sinTheta));\n        \n        if (center.w == CENTER_ROTATING) { center.w = CENTER_STATIONARY; }\n        \n    }\n        \n    // does this register need to pay attention to triangle updates?\n    bool isUpdatable = (fc == REG_MOUSE || fc == REG_GENERATOR ||\n                        fc == REG_FLAGS || fc == REG_WRAP);\n\n    // if dragging generator and updatable\n    if (mstate.z >= MOUSE_SET_GENERATOR && isUpdatable) {\n        \n        // setup inset triangle\n        mat3 edges = setupTriangle(pqr.xyz);\n        setupInset(edges);\n        \n        // get point in Poincaré disk\n        vec2 uv = diskProjValid(diskFromInset(iMouse.xy - mstate.xy), false);        \n\n        float SNAP_TOL = insetPointSize*2.0;\n        const float MOVE_TOL = 4.;\n        \n        if (click) {\n            \n            // origin is first point\n            vec4 mousePoint = vec4(uv, length(uv), 6.);\n\n            // check all 3 verts and all 3 edge points\n            for (int j=0; j<2; ++j) {\n                for (int i=0; i<3; ++i) {\n                    vec3 xi = j == 0 ? insetVerts[i] : insetEdgePoints[i];\n                    vec2 di = uv - diskFromHyperboloid(xi) ;\n                    float l = length(di);\n                    vec4 p = vec4(di, l, float(i+3*j));\n                    mousePoint = p.z < mousePoint.z ? p : mousePoint;\n                }\n            }\n            \n            // see if we shouls snap to point\n            if (mousePoint.z < SNAP_TOL*insetPx) {\n                generator.w = mousePoint.w;\n                mstate.xy = mousePoint.xy / insetPx;\n                mstate.z = MOUSE_SNAP_GENERATOR;\n            }\n            \n        } else if (mstate.z == MOUSE_SNAP_GENERATOR &&\n                   length(iMouse.xy - iMouse.zw) > MOVE_TOL) {\n            // see if we should stop snapping\n            mstate.z = MOUSE_SET_GENERATOR;\n        }\n        \n        // if not snapped, solve for barycentric coords\n        if (mstate.z == MOUSE_SET_GENERATOR) {\n            \n            vec3 x = hyperboloidFromDisk(uv);\n        \n            generator.xyz = inverse(insetVerts) * x;\n            generator.w = -1.;\n        \n            generator.xyz /= dot(generator.xyz, vec3(1));\n            generator.xyz = clamp(generator.xyz, 0., 1.);\n            \n        }\n        \n        updateTriangle = true;\n        \n    }\n    \n    // handle showing/hiding UI\n    if (paused) {\n        uiState.x = uiState.y;\n    } else {\n        uiState.x = mix(uiState.x, uiState.y, 0.08);\n        if (abs(uiState.x - uiState.y) < 0.01) { uiState.x = uiState.y; }\n    }\n    \n    //////////////////////////////////////////////////\n    // handle changes to P, Q, R\n\n    if (pqrDelta != 0.) {\n        pqr[pqrAxis] = clamp(pqr[pqrAxis] + pqrDelta, PQR_MIN, PQR_MAX);\n        pqr.xyz = fixPQR(pqr.xyz, pqrAxis);\n        updateTriangle = true;\n    }\n            \n    //////////////////////////////////////////////////\n    // handle changes to projection\n\n    if (projDelta != 0.) {\n\n        vec2 f = fragFromScene(center.xy);\n\n        pqr.w = mod(pqr.w + projDelta, NUM_PROJ);\n\n        setupProjection(int(pqr.w), iResolution.xy, uiState.x);\n\n        if (center.z == 0.) {\n            center.xy = sceneFromFrag(f);\n        }\n\n    }\n    \n    //////////////////////////////////////////////////\n    // do triangle updates if necessary\n    \n    if (updateTriangle && isUpdatable) {\n\n        mat3 edges = setupTriangle(pqr.xyz);\n        mat3 verts = hyperTriVerts(edges);\n        mat3 bisectors = hyperTriAngleBisectors(edges);        \n        mat3 vinv = inverse(verts);\n\n        int i = int(generator.w);\n\n        if (i >= 0 && i < 3) {\n            generator.xyz = vec3(0);\n            generator[i] = 1.;\n        } else if (i >= 3 && i < 6) {\n            i -= 3;\n            generator.xyz = vinv * intersectGG(bisectors[i], edges[i]);\n        } else if (i == 6) {\n            generator.xyz = vinv * intersectGG(bisectors[0], bisectors[1]);\n        }\n        \n        flags.z = computeTriangleFlags(edges, verts, generator.xyz);\n                \n        vec3 edgeLengths;\n        \n        for (int i=0; i<3; ++i) {\n            int j = TRI_NEXT(i);\n            int k = TRI_LAST(i, j);\n            edgeLengths[i] = hyperDistPP(verts[j], verts[k]);\n        }\n            \n        const vec3 tbl[8] = vec3[8](\n            vec3(0, 0, 2),\n            vec3(0, 2, 2),\n            vec3(2, 0, 2),\n            vec3(2, 2, 2),\n            vec3(0, 0, 2),\n            vec3(2, 2, 2),\n            vec3(2, 2, 2),\n            vec3(1, 1, 1)\n        );\n            \n        ivec3 bits = ((ivec3(pqr) & 0x1) << ivec3(0, 1, 2));\n        int idx = bits.x | bits.y | bits.z;\n\n        vec3 u = verts[0];\n        vec3 v = verts[1];\n\n        vec3 w = v + hyperDot(u, v)*u;\n            \n        w = hyperNormalizeG(w);\n            \n        float dist = dot(edgeLengths, tbl[idx]);\n            \n        wrap = vec4(w, dist);\n        \n    }\n\n    //////////////////////////////////////////////////\n    // deal with scrolling/rotation\n    \n    flags.w = int(shiftIsPressed || mstate.z == MOUSE_SCROLL);\n\n    // C centers\n    if (KEY_IS_DOWN(67)) { \n        vec2 f = sceneBox.xy;\n        center = vec4(sceneFromFrag(f), 0, CENTER_STATIONARY);\n        rvec = vec2(1, 0);\n        flags.w = 1;\n    }\n    \n    // G toggles gyration\n    if (KEY_HIT(71)) { \n        center.w = (center.w == CENTER_GYRATING) ? CENTER_STATIONARY : CENTER_GYRATING;\n    }\n\n    // T toggles translation along triangle\n    if (KEY_HIT(84)) { \n        center.w = (center.w == CENTER_SWEEPING) ? CENTER_STATIONARY : CENTER_SWEEPING;\n    }\n\n    // R toggles continuous rotation\n    if (KEY_HIT(82)) {\n        center.w = (center.w == CENTER_ROTATING) ? CENTER_STATIONARY : CENTER_ROTATING;\n    }\n    \n    // if we are moving, then update scroll pos or rotation\n    if (center.w == CENTER_GYRATING) {\n        float t = time.z * 2.*PI;\n        float r = 1.33;\n        center.xyz = hyperboloidFromOrtho(r*vec2(cos(t), sin(t)));\n    } else if (center.w == CENTER_ROTATING) {\n        float t = time.z * 2.*PI;\n        rvec = vec2(cos(t), sin(t));\n    }\n    \n    //////////////////////////////////////////////////\n    // store data\n\n    STORE4(REG_PQR_PROJ, pqr);\n    STORE4(REG_GENERATOR, generator);\n    STORE4(REG_MOUSE, mstate);\n    STORE4(REG_FLAGS, vec4(flags));\n    STORE4(REG_CENTER, center);\n    STORE4(REG_TIME, time);\n    STORE3(REG_UI_STATE, uiState);\n    STORE2(REG_ROTATE, rvec);\n    STORE4(REG_WRAP, wrap);\n    \n    // write to texture\n    fragColor = data;\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}