{
    "Shader": {
        "info": {
            "date": "1479264636",
            "description": "Back to glass today.",
            "flags": 0,
            "hasliked": 0,
            "id": "llcXD8",
            "likes": 29,
            "name": "Daily Shade day 13: Zen glass",
            "published": 3,
            "tags": [
                "raymarch",
                "refraction",
                "glass",
                "daily"
            ],
            "usePreview": 0,
            "username": "psonice",
            "viewed": 1244
        },
        "renderpass": [
            {
                "code": "/* \nDay 13: Converted the mirrored boxes to glass, made hole in glass, coloured shadows.. that's it.\n*/\n\n//#define DEBUG\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n#define kFLIPY vec3(1, -1, 1)\n\n#define kINFINITY 10000.0 // An unimaginably large number\n\n// maximum iteration count\n#define kMAXITERS 120\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n\n#define kFLOORCOLOUR vec4(0.7, 0.65, 0.6, 1.0)\n    \n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 texrand(vec2 n) {\n    return texture(iChannel2, n).xyz;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    \n    // Get distance to floor\n    float distToFloor = floorDist(ray);\n    \n    // We'll mess with the ray but need the origin later, so preserve it\n    vec3 o = ray.origin;\n    float rippleBase = sin(o.x * 8.0);\n    \n    float boxSize = 6.0;\n    \n    // Repeat the ray through space. Anything inside this space naturally gets repeated...\n\n        ray.origin.xz = mod(ray.origin.xz, vec2(20.0)); \n        \n    \n    // Get a hash value for the 'cell' we're in\n    float hash = hashForCell(o, 20.0);\n    vec3 offset = vec3(\n        10.0 + sin(hash * 8.0) * 4.0,\n        0.0,\n        10.0 + sin(hash * 8.0 + 1.5) * 4.0\n        );\n    float y = cos(hash * 4.0) * boxSize * 0.5;\n    \n    offset.y += boxSize * 0.5 + sin(hash * 4.0);\n                                    \n    Sphere sphere0 = Sphere(offset, 3.0);\n    float distToSphere = sphereDist(ray, sphere0);\n    \n    // Rotate the cube by rotating the ray...\n    ray.origin -= offset;\n    ray.origin.xy = R(ray.origin.xy, hash * 4.0);\n    offset.y += sin(hash * 4.0 + 4.0);\n    ray.origin.xz = R(ray.origin.xz, hash * 4.0 + 4.0);\n    ray.origin += offset;\n    \n    // A box\n    Box b0 = Box(offset, vec3(boxSize), 0.4);\n    \n    // get the distance \n    float distToB0 = boxDist(ray, b0);\n    \n    rippleBase = mix(sin(distToB0 * 8.0), rippleBase, smoothstep(2.5, 4.0, distToB0));\n    distToFloor += rippleBase* 0.1;\n    \n    //Find the neares of the floor and box0\n    distToFloor = max(distToFloor, -distToB0 + eps);\n    result.d = min(distToFloor, max(distToB0, -distToSphere));\n    result.material = result.d == distToFloor ? kFLOORMATERIAL : kGLASSMATERIAL;\n    \n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d - baseDist,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d - baseDist\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n \tray.origin += n * d;\n \td = sceneDist(ray).d;\n \tn = normal(ray);\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\nfloat occlusion(in Ray ray, in vec3 n) {\n    float o = 0.0;\n    ray.dir = n;\n    float x = 0.1;\n    for (int i=0; i<5; i++) {\n    \tray.origin += x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0);\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o * 0.5;;\n}\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec4 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec4 impact = vec4(1.0); // This decreases each time the ray passes through glass, darkening colours\n    bool hit = false;\n#ifdef DEBUG   \nvec4 debugColour = vec4(1, 0, 0, 1);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = result.material == kGLASSMATERIAL ? abs(result.d) : result.d;\n        ray.origin += ray.dir * stepDistance * 0.3;  \n        \n        if (stepDistance < eps) {\n            // colision\n            \n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            clampToSurface(ray, stepDistance, n);\n    \n            hit = true;\n            \n            if ( result.material == kFLOORMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(ray.origin.xz * 0.4);\n                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);\n                \n                // Colour is just grey with crappy fake lighting...\n                colour += mix(\n                    kFLOORCOLOUR, \n                    vec4(0,0,0,1), \n                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)\n                ) * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 2.0;\n                float hash = hashForCell(ray.origin, 1.0);\n                vec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n                impact *= vec4(c, 1.0);\n                    \n#ifdef DEBUG\n    debugColour.rgb = ray.dir;\n    break;\n#endif\n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(-n, -ray.dir, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  1.-clamp(distance(glassStartPos, ray.origin) / 16.0, 0., 1.);\n                    \n                    // Get a random colour\n                    float hash = hashForCell(ray.origin, 20.0); \n                    vec3 c = randomColourForCell(ray.origin, 20.0);\n                \timpact *= mix(vec4(1), vec4(c, 1.0), glassTravelDist);\n                    \n#ifdef DEBUG\n    debugColour.rgb = vec3(1);\n    break;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 2.0);\n    \t\t\t\tcolour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n) * kFLIPY), \n                    \tvec4(fresnel) * impact);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                }\n            \n            \t\t// Flip in/out status\n           \t\t \tinside = !inside;\n            \t\tray.origin += (inside ? -n : n) * eps * 2.0;\n            }\n            \n            // Intersection count inc, break if over limit\n            if (ray.dir.y > 0.0 && ray.origin.y > 5.0) { break; }\n            \n            // Step 2x epsilon into object along normal to ensure we're beyond the surface\n            // (prevents multiple intersections with same surface)\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n    //if (result.material != kFLOORMATERIAL) {\n    if (ray.dir.y > 0.0) {\n        colour += texture(iChannel0, ray.dir * kFLIPY) * impact;// / float(steps+1);\n        //colour = vec4(1,0,0,1);\n    } else {\n        colour += kFLOORCOLOUR * impact;\n        float occludeFactor = occlusion(ray, n);\n        colour.rgb *= mix(vec3(1), randomColourForCell(ray.origin, 20.0) * 0.25, 1.-occludeFactor);\n    }\n    //}\n#ifdef DEBUG\n //   debugColour.rgb = ray.dir;\ncolour = debugColour;\n//colour.rgb = vec3(float(steps)/8.);\n//colour.rgb = ray.dir;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    float r = 15.0;\n    return vec3(sin(time) * r, sin(time*2.) + r, cos(time) * r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime / 4.0;\n    vec3 camPos = camPath(camTime);\n    vec3 camTarget = vec3(0);\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec4 col = vec4(0.0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}