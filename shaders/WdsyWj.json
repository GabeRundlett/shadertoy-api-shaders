{
    "Shader": {
        "info": {
            "date": "1585597203",
            "description": "The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n\nCreated a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdsyWj",
            "likes": 5,
            "name": " The Live Coders Conference - 2",
            "published": 3,
            "tags": [
                "3d",
                "fbm",
                "raymarcher",
                "tlc"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 496
        },
        "renderpass": [
            {
                "code": "// Created by mrange/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Unported License.\n\n// The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n// Created a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.\n\n// 2D shape created by combining 2D primitives from IQ's blog:\n//  https://iquilezles.org/articles/distfunctions2d\n// pmin from IQ's blog on smooth minimum functions:\n//  https://iquilezles.org/articles/smin\n\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  5.0\n#define MAX_BOUNCES     5\n#define MAX_RAY_MARCHES 65\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define AA              0\n\n#define TTIME           (TAU*iTime)\n\n#define SCA(a) vec2(sin(a), cos(a))\n\nconst vec2 sca          = SCA(PI*4.5/6.0);\nconst vec3 lightPos1    = 100.0*vec3(-1.0, 0.0, 0.0);\nconst vec3 lightCol1    = vec3(0.63, 0.63, 1.0);\nconst vec3 spokeColor   = vec3(0.5, 0.5, 1.0);\nconst vec3 meepleColor  = vec3(0.8);\nconst vec3 bgColor      = vec3(0.1, 0.1, 0.25);\n\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.0)/k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat maxComp(vec3 p) {\n  return max(p.x,max(p.y,p.z));\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nfloat cylinder(vec3 p, float ra, float rb, float h) {\n  h -= rb;\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat box(vec3 p, vec3 b, float r) {\n  b -= r;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat torus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - (2.0 - 0.000001)*ra*k ) - rb;\n}\n\nfloat spokes(vec3 p, float s) {\n  vec2 pp = toPolar(p.xz);\n  pp.y += TTIME/14.0;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p.xz = toRect(pp.xy);\n  float ds = box(p, s*vec3(0.075, 0.125, 0.5), s*0.04);\n  return ds;\n}\n\nfloat arcs(vec3 p, float s) {\n  p.xyz = p.zxy*vec3(1.0, -1.0, 1.0);\n  p.z += -0.25;\n  float d1 = torus(p, sca, 0.275*s, 0.025*s);\n  float d2 = torus(p, sca, 0.18*s, 0.025*s);\n  return min(d1, d2);\n}\n\nfloat meeple(vec3 p, float s) {\n  p.xyz = p.zxy*vec3(1.0, -1.0, 1.0);\n  float dh = box(p - s*vec3(0.0, -0.035, 0.125), s*vec3(0.07, 0.1, 0.05), s*0.065);\n  float dc = box(p - s*vec3(0.0, -0.22, 0.125), s*vec3(0.15, 0.04, 0.075), s*0.05);\n\n  return pmin(dh, dc, s*0.115);\n}\n\nfloat intersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a,r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\nfloat differenceRound(float a, float b, float r) {\n  return intersectionRound(a, -b, r);\n}\n\nfloat theLiveCoder(vec3 p, float s, out float oda, out float odm, out vec3 col, out float ref, out float trans, out vec3 absorb) {\n  float dr = cylinder(p, 0.375*0.5*s, 0.075*s, 0.125*s);\n  float ds = spokes(p, s);\n  float da = arcs(p, s);\n  float dm = meeple(p, s);\n\n  float nda = (da - 0.0125*s);\n  float ndm = (dm - 0.0125*s);\n  float nd  = min(nda, ndm);\n\n  float d = dr;\n  d = min(d, ds);\n  float dw = d;\n  d = differenceRound(d, nd, 0.02);\n  d = min(d, da);\n  d = min(d, dm);\n\n  oda = da;\n  odm = dm;\n\n  vec2 pp = toPolar(p.xz);\n\n  vec3 acol = saturate(spokeColor + 0.5*vec3(1.0, 0.0, 0.0)*sin(-TTIME/7.0 + PI*pp.x + 0.5) +  0.5*vec3(0.0, 1.0, 0.0)*sin(-TTIME/6.0 + 1.0*pp.y + 0.0));\n\n  if (d == da) {\n    col = acol;\n    trans = 0.70;\n  } else if (d == dm) {\n    col = meepleColor;\n    trans = 0.70;\n  } else if (d != dw) {\n    col = acol;\n    trans = 0.5;\n  } else {\n    col = vec3(0.25, 0.25, 0.5);\n    trans = 0.5;\n  }\n\n  ref = 0.25;\n  absorb = mix(vec3(1.0), vec3(-5.0), col*col);\n\n  return d;\n}\n\nfloat distanceField(in vec3 p, out float oda, out float odm, out vec3 col, out float ref, out float trans, out vec3 absorb) {\n  p.xy = p.yx*vec2(-1.0, 1.0);\n\n  float d = theLiveCoder(p, 2.0, oda, odm, col, ref, trans, absorb);\n\n  return d;\n}\n\nvec3 getSkyColor(vec3 rayDir) {\n  vec3 lightDir1 = normalize(lightPos1);\n\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  vec3 final     = 0.1*lightCol1;\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n\n  vec3 light = 1.0*lightCol1;\n\n  final += light*pow(ld1, 20.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3 eps = vec3(.0001,0.0,0.0);\n  vec3 col;\n  float oda;\n  float odm;\n  float ref;\n  float trans;\n  vec3 nor;\n  vec3 absorb;\n  nor.x = distanceField(pos+eps.xyy, oda, odm, col, ref, trans, absorb) - distanceField(pos-eps.xyy, oda, odm, col, ref, trans, absorb);\n  nor.y = distanceField(pos+eps.yxy, oda, odm, col, ref, trans, absorb) - distanceField(pos-eps.yxy, oda, odm, col, ref, trans, absorb);\n  nor.z = distanceField(pos+eps.yyx, oda, odm, col, ref, trans, absorb) - distanceField(pos-eps.yyx, oda, odm, col, ref, trans, absorb);\n  return normalize(nor);\n}\n\nfloat rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out float oda, out float odm, out vec3 col, out float ref, out float trans, out vec3 absorb) {\n  float t = mint;\n  float distance;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance_ = distanceField(ro + rd*t, oda, odm, col, ref, trans, absorb);\n    distance = dmod*distance_;\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += max(distance, minstep);\n    rep = i;\n  }\n\n  if (distance > TOLERANCE) return MAX_RAY_LENGTH;\n\n  return t;\n}\n\nvec3 postProcess(in vec3 col, in vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 lightPos = 1.5*vec3(1.0, 3.0, 1.0);\n\n  vec3 final  = vec3(0.0);\n\n  vec3 ragg   = vec3(1.0);\n\n  float tdist = 0.0;\n\n  float refraction = 1.3;\n\n  bool inside = false;\n\n  const float mint    = 0.05;\n  const float minstep = 0.00025;\n\n  for (int i = 0; i < MAX_BOUNCES; ++i)\n  {\n    if (maxComp(ragg) <  0.01) break;\n    float dmod  = inside ? -1.0 : 1.0;\n    vec3 absorb ;\n    float oda   ;\n    float odm   ;\n    vec3 col    ;\n    float ref   ;\n    float trans ;\n    int rep     ;\n    float t     = rayMarch(dmod, ro, rd, mint, minstep, rep, oda, odm, col, ref, trans, absorb);\n    tdist       += t;\n\n    vec3 pos    = ro + t*rd;\n\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n\n    if (t < MAX_RAY_LENGTH) {\n      nor = normal(pos);\n    } else {\n      final += ragg*getSkyColor(rd);\n      break;\n    }\n\n    float fresnel = pow(1.0 - abs(dot(nor, rd)), 2.0);\n\n    ref = mix(ref, 1.0, fresnel);\n    trans = mix(trans, 0.0, fresnel);\n\n    float mref = refraction;\n\n    if (inside) {\n      nor = -nor;\n      mref = 1.0/refraction;\n    }\n\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, mref);\n\n    vec3  lv  = lightPos - pos;\n    vec3  ld  = normalize(lv);\n    float ll  = length(lv);\n\n    float dif = max(dot(nor,ld),0.0);\n    float occ = 1.0 - float(rep)/float(MAX_RAY_MARCHES);\n    float l   = dif*occ;\n\n    vec3 lr   = vec3(0.0);\n\n    float lin = mix(0.2, 1.0, l);\n\n    vec3 sky  = getSkyColor(refl);\n    vec3 mcol = mix(lin*col + lr, sky, ref);\n    mcol += 0.5*spokeColor*tanh(1.0/(20.0*(max(oda, 0.05))));\n    mcol += meepleColor*0.35*tanh(1.0/(100.0*(pow(max(odm, 0.025), 1.5))));\n\n    vec3 beer = vec3(1.0, 1.0, 1.0);\n\n    if (inside) {\n      beer = exp(-absorb*t);\n    }\n\n    final      += (1.0 - trans)*ragg*beer*mcol;\n    ragg       *= trans*beer;\n\n    ro        = pos;\n\n    if (refr == vec3(0.0)) {\n        rd = refl;\n    } else {\n      rd = refr;\n      inside = !inside;\n    }\n  }\n\n  return final;\n}\n\nvec3 getSample(in vec2 p) {\n  vec3 ro  = vec3(2.5, 0.0, 0.0) + 0.5*vec3(0.0, sin(TTIME/33.0), cos(TTIME/36.0));;\n\n  vec3 la  = vec3(0.0) + 0.125*vec3(0.0, sin(TTIME/30.0), cos(TTIME/27.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n  vec3 col = render(ro, rd);\n\n  return col;\n}\n\n\nfloat box2(vec2 p, vec2 b, float r) {\n  b -= r;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  float db = box2(p, vec2(0.88), 0.3);\n\n  if (db > 0.0) {\n    float m = smoothstep(0.1, 0.105, db);\n    fragColor = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(bgColor, 1.0), m);\n    return;\n  }\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  for(int y = 0; y < 2; ++y)\n  {\n    for(int x = 0; x < 2; ++x)\n    {\n      col += getSample(p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 4.0;\n#endif\n  col = postProcess(col, p);\n  float bb = smoothstep(0.005, 0.125, abs(db));\n  col = mix(vec3(0.125), col, pow(bb, 0.350));\n  float wb = smoothstep(0.0, 0.005, abs(db));\n  col = mix(vec3(1.0), col, wb);\n  col = mix(bgColor, col, smoothstep(0.0, 16.0, iTime*iTime));\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}