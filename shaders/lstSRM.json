{
    "Shader": {
        "info": {
            "date": "1458447396",
            "description": "Press WASD keys to move the ball and take a walk :).\n\nQuaternion reference:\nhttp://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\nhttp://mollyrocket.com/forums/molly_forum_833.html",
            "flags": 48,
            "hasliked": 0,
            "id": "lstSRM",
            "likes": 38,
            "name": "Ball Runner",
            "published": 3,
            "tags": [
                "3d",
                "terrain",
                "ball",
                "quaternion",
                "buffer"
            ],
            "usePreview": 0,
            "username": "ciberxtrem",
            "viewed": 1620
        },
        "renderpass": [
            {
                "code": "// Memory Props\nvec2 mPos     = vec2(1., 0.);\nvec2 mCamPos  = vec2(2., 0.);\nvec2 mQuat    = vec2(4., 0.);\n\nvec3 gBallPos;\nvec3 gCamPos;\nvec4 gBallQuat;\n\nfloat gBallRadius = 1.0;\n\nfloat gSoundWave;\n\nfloat hash(float x) { return fract(sin(x)*4.86); }\n\nvec4 Load(in sampler2D sampler, vec2 samplerRes, in vec2 valueCoord)\n{\n    return texture(sampler, (valueCoord + 0.5)/samplerRes);\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\nvec2 MapBall(in vec3 p, out vec3 coord)\n{\n    coord = p - gBallPos - vec3(0., 1., 0.);\n    coord = Rotate(gBallQuat, coord);\n    float d = length(coord)-gBallRadius;\n    return vec2(d, 1.0);\n}\n\nvec2 MapTerrain(in vec3 p)\n{\n    float h = -1.;\n    h += sin(p.x*0.15)*1.5;\n    h += sin(1.8*p.x*0.1)*0.2;\n    \n    h += cos(0.6+p.z*0.1)*1.0;\n    h += sin(0.+p.z*0.16)*0.25;\n    \n    float d = p.y-h;\n    return vec2(d, 2.0);\n}\n\nvec2 Map(in vec3 p, out vec3 coord)\n{\n    vec2 res = MapTerrain(p);\n    vec2 res2 = MapBall(p, coord);\n    if(res2.x < res.x) { res = res2; }\n    return res;\n}\n\nvec2 Intersect(vec3 ro, vec3 rd, float dmin, float dmax, out vec3 coord)\n{\n    float k = dmin;\n    vec2 res = vec2(dmax);\n    for(int i=0; i<160; ++i)\n    {\n        vec2 tmp = Map(ro + rd*k, coord);\n        k += tmp.x;\n        if(tmp.x<0.01)\n        {\n            res = vec2(k, tmp.y); break;\n        }\n    }\n    return res;\n}\n\nvec3 CalcNormal(vec3 p)\n{\n    vec3 coord;\n    vec2 ep = vec2(1e-3, 0.);\n    float c = Map(p, coord).x;\n    return normalize( vec3(\n        Map(p+ep.xyy, coord).x - c,\n        Map(p+ep.yxy, coord).x - c,\n        Map(p+ep.yyx, coord).x - c\n    ) );\n}\n\nvec3 Shade(vec3 color, vec3 n, vec3 v, vec3 l)\n{\n    float diff = 0.05+0.95*pow(max(dot(n, -v), 0.), 2.0);\n    vec3 refl = reflect(v, n);\n    float spec = pow(max(dot(refl, l), 0.), 25.);\n    return color * diff + spec*vec3(1.0);\n}\n\nvec3 GetColor(float id, vec3 p, vec3 coord, vec3 rd, inout vec3 n)\n{\n    if(id < 1.5) \n    {\n        return texture(iChannel1, normalize(coord)).xyz+coord*0.25; \n    }\n    else \n    { \n        return vec3(0.384, 0.666, 0.917);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.y;\n    \n    gSoundWave = texture(iChannel2, vec2(0.15, 0.2)).x;\n    \n    gBallPos  = Load(iChannel0, iChannelResolution[0].xy, mPos).xyz;\n    gBallPos.y = -MapTerrain(vec3(gBallPos.x, 0., gBallPos.z)).x;\n    gCamPos  = Load(iChannel0, iChannelResolution[0].xy, mCamPos).xyz;\n    gBallQuat = Load(iChannel0, iChannelResolution[0].xy, mQuat);\n    \n    vec3 target = gBallPos;\n    vec3 ro = gCamPos;\n    \n\tvec3 front = normalize(target+vec3(0., 4.0, 0.)-ro);\n    vec3 right = cross(vec3(0., 1, 0.), front);\n    vec3 up = cross(front, right);\n    vec3 rd = normalize(front + 35.*(3.14159/180.)*(right*uv.x + up*uv.y));\n    \n    vec3 l = normalize(vec3(-0.1, 0.5, -0.1));\n    vec3 coord;\n    vec3 color = vec3(0.03);\n    float w = 1.;\n    for(int i=0; i<2; ++i)\n    {\n        vec2 res = Intersect(ro, rd, 0.1, 100., coord);\n        \n        if(res.x < 100.)\n        {\n            vec3 p = ro + res.x * rd;\n            vec3 n = CalcNormal(p);\n            vec3 tmpColor = GetColor(res.y, p, coord, rd, n);\n            color += Shade(tmpColor, n, rd, l)*w;\n            \n            if(res.y < 1.5) {break;}\n            else\n            {\n                rd = reflect(rd, n); rd.y *= 0.8;\n                ro = p;\n                w *= 0.25;\n            }\n        }\n        else\n        {\n            vec3 tmpColor = vec3(0.541, 0.388, 0.298);\n            color += mix(vec3(0.835, 0.823, 0.647), color, smoothstep(0., 1., pow(abs(rd.y+0.02)*4., 0.5)))*0.2*w;\n            \n            vec3 farPos = rd * 4./rd.z;\n            vec2 uv = farPos.xy*vec2(0.5, 1.)*0.40-vec2(-0.50, -0.40);\n            vec3 texColor = texture(iChannel3, uv).rgb;\n            \n            for(int i=0; i<25; ++i)\n            {\n                if(float(i) > floor(+26.*fract(0.01+ gSoundWave+0.*iTime*0.25))) break;\n                    \n                float d = abs(uv.y-1.00+hash(float(2+i)*7.625)*0.5+sin(gBallPos.x*0.5+hash(float(i)) + (hash(float(i))*2.-1.)*iTime*1.0 +uv.x*10.+0.7)*0.05);\n                color += w*mix(vec3(hash(float(i)), hash(float(i+4)), hash(float(i+9)))*0.5, vec3(0.), smoothstep(0., 1., pow(d/0.15, 0.2+gSoundWave*0.5+0.020*hash(float(i)))));\n            }\n            break;\n        }\n    }\n\tfragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float gTime;\nfloat gDt;\n\n// Memory Props\nvec2 mState   = vec2(0., 0.);\nvec2 mPos     = vec2(1., 0.);\nvec2 mCamPos  = vec2(2., 0.);\nvec2 mVel     = vec2(3., 0.);\nvec2 mQuat    = vec2(4., 0.);\n\n// Keys\nconst float KEY_A = 65.5/255.;\nconst float KEY_D = 68.5/255.;\nconst float KEY_W = 87.5/255.;\nconst float KEY_S = 83.5/255.;\n\nvec3 camDir = vec3(0., 0., -15.0);\nfloat gBallRadius = 1.0;\n\nfloat IsInside(in vec2 valueCoord, in vec2 fragCoord)\n{\n    vec2 res = abs(fragCoord - 0.5 - valueCoord) - 0.5;\n    return -max(res.x, res.y);\n}\n\nvoid Save(in vec2 valueCoord, in vec4 value, in vec2 fragCoord, inout vec4 fragColor)\n{\n    fragColor = IsInside(valueCoord, fragCoord) > 0.0 ? value : fragColor;\n}\n\nvec4 Load(in sampler2D sampler, vec2 samplerRes, in vec2 valueCoord)\n{\n    return texture(sampler, (valueCoord + 0.5)/samplerRes);\n}\n\nvec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\nvec2 MapTerrain(in vec3 p)\n{\n    float h = -1.;\n    h += sin(p.x*0.08)*2.5;\n    h += sin(1.8*p.x*0.1)*0.2;\n    \n    h += cos(0.6+p.z*0.1)*1.8;\n    h += sin(0.+p.z*0.16)*0.25;\n    \n    float d = p.y-h;\n    return vec2(d, 2.0);\n}\n\nvec3 CalcNormal(vec3 p)\n{\n    vec3 coord;\n    vec2 ep = vec2(1e-3, 0.);\n    float c = MapTerrain(p).x;\n    return normalize( vec3(\n        MapTerrain(p+ep.xyy).x - c,\n        MapTerrain(p+ep.yxy).x - c,\n        MapTerrain(p+ep.yyx).x - c\n    ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = iTime;\n    gDt = iTimeDelta;\n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec4 state    = Load(iChannel0, iChannelResolution[0].xy, mState);\n    vec4 pos      = Load(iChannel0, iChannelResolution[0].xy, mPos);\n    vec4 camPos   = Load(iChannel0, iChannelResolution[0].xy, mCamPos);\n    vec4 vel      = Load(iChannel0, iChannelResolution[0].xy, mVel);\n    vec4 quat     = Load(iChannel0, iChannelResolution[0].xy, mQuat);\n    \n    if(iFrame == 0 || iTime < 1e-3)\n    {\n        state.x = 0.;\n    }\n    if(state.x < 0.5)\n    {\n        state.x = 1.;\n        pos    = vec4(0., 0., 0., 0.);\n        camPos = vec4(0., 0., 0., 0.) + vec4(camDir, 0.);\n        vel    = vec4(0., 0., 0., 0.);\n        quat   = vec4(0., 0., 0., 1.);\n    }\n    else\n    {\n        \n        vec3 front = vec3(0., 0., 1.);\n        vec3 right = vec3(-1., 0., 0.);\n        \n        vel.xyz *= 0.98;\n        \n        vel.xyz += texture(iChannel3, vec2(KEY_W, 0.2)).x * front;\n        vel.xyz -= texture(iChannel3, vec2(KEY_S, 0.2)).x * front;\n        vel.xyz += texture(iChannel3, vec2(KEY_A, 0.2)).x * right;\n        vel.xyz -= texture(iChannel3, vec2(KEY_D, 0.2)).x * right;\n        \n        // add normal vel\n        vec3 n = CalcNormal(pos.xyz);\n        vel.xz += n.xz;\n            \n        // pos\n        vec3 deltaPos = vel.xyz * gDt;\n        pos.xyz += deltaPos;\n        \n        // cam pos\n        vec3 newCamPos = pos.xyz + camDir + vec3(0., 2.0, 0.);\n        camPos.xyz = mix(camPos.xyz, newCamPos, 5.*gDt);\n        \n        // ball rotation\n        float velLen = length(vel);\n        if(velLen > 1e-1)\n        {\n            vec3 axis = cross(normalize(vel.xyz), vec3(0., 1., 0.));\n            float angle =  length(deltaPos)/gBallRadius;\n            vec4 currQuat = BuildQuat(axis, angle);\n            quat = MulQuat(quat, currQuat);\n        }\n    }\n    \n    Save(mState, state, fragCoord, fragColor);\n    Save(mPos, pos, fragCoord, fragColor);\n    Save(mCamPos, camPos, fragCoord, fragColor);\n    Save(mVel, vel, fragCoord, fragColor);\n    Save(mQuat, quat, fragCoord, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}