{
    "Shader": {
        "info": {
            "date": "1632983119",
            "description": "Vaporwave Style Outrun",
            "flags": 0,
            "hasliked": 0,
            "id": "sscSWn",
            "likes": 12,
            "name": "Vaporwave Outrun",
            "published": 3,
            "tags": [
                "outrun",
                "vaporwave",
                "synthwave"
            ],
            "usePreview": 0,
            "username": "noobdawn",
            "viewed": 966
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265358979\n#define SPEED 0.25\n#define GRID_COUNT 32.\n#define STEP 0.005\n#define COUNT 256.\n#define HEIGHT 0.25\n#define SUN_SPEED 0.3\n\nvec3 GetBackgroundColor(in vec3 ray)\n{\n    vec3 c0 = vec3(115. / 255., 25. / 255., 171. / 255.);\n    vec3 c1 = vec3(235. / 255., 51. / 255., 201. / 255.);\n    vec3 c2 = vec3(40. / 255., 7. / 255., 80. / 255.);\n    float a = fract(iTime * 0.5) * 2.0;\n    a = a > 1.0 ? 2.0 - a : a;\n    vec3 c = c0 * a + c2 * (1.0 - a);\n    a = pow(1.0 - abs(ray.y), 0.25);\n    float b = abs(atan(ray.x / ray.z)) / PI;\n    float m = texture(iChannel1, vec2(b * 0.05, fract(iTime * 0.00005))).x;\n    a = 0.85 * a - 0.05 * m;\n        \n    c = c1 * a + c * (1.0 - a);\n    return c;\n}\n\nbool GetHitWithPlane(in vec3 o, in vec3 ray, out vec3 hitPoint)\n{\n    bool hit = false;\n    hitPoint = vec3(0.0, 0.0, 0.0);\n    float realHeight = 0.;\n    float preRealHeight = 0.;\n    float _step = STEP;// min(STEP / abs(ray.y), 2. * STEP);\n    for (float i = 1.; i <= COUNT; i++)\n    {\n        vec3 current = o + ray * _step * i;\n        realHeight = texture(iChannel0, current.xz / 16.).x * HEIGHT;\n        float s = abs(current.x - o.x) / 0.5;\n        s = clamp(s * s, 0., 1.);\n        realHeight *= s;\n        if (current.y < realHeight)\n        {\n            vec3 last = current - ray * _step;\n            float preDiff = last.y - preRealHeight;\n            float curDiff = realHeight - current.y;\n            float t = preDiff / (preDiff + curDiff);\n            current = last + ray * _step * t;      \n            hitPoint = current;\n            return true;\n        }\n        preRealHeight = realHeight;\n    }\n    return hit;\n}\n\nvec3 GetHitPointColor(in vec3 cameraPos, in vec3 hitPoint, in vec3 background)\n{\n    float fx = abs(fract(hitPoint.x * GRID_COUNT + 0.5) - 0.5);\n    float fz = abs(fract(hitPoint.z * GRID_COUNT + 0.5) - 0.5);\n\n    vec3 b = vec3(0.2, 0.6, 0.9);\n    vec3 r = background;\n    r.x = pow(r.x, 3.3);\n    r.y = pow(r.y, 0.7);\n    r.z = pow(r.z, 0.5);\n    float d = length(hitPoint.xz - cameraPos.xz) * 0.15;\n    d = clamp(d, 0., 1.);\n    vec3 col = r * d + b * (1. - d);\n    float li = texture(iChannel0, hitPoint.xz / 64. + vec2(0, -iTime * 0.005)).x * 0.5 + 0.5;\n    float lo = abs(hitPoint.z - cameraPos.z) + 0.3;\n    col /= min(li, lo);\n    \n    \n    d = min(fx, fz);\n    d = smoothstep(d, 0., 0.02);\n    \n    return r * d + col * (1. - d);\n}\n\nvec4 GetSun(in vec3 cameraPos, in vec3 ray)\n{\n    if (dot(ray, normalize(vec3(0.0, 0.035, 1.0))) > 0.96)\n    {\n        vec4 r = vec4(1., 0., 0., 1.);\n        vec4 y = vec4(2., 2., 0., 1.);\n        float a = abs(ray.y);\n        vec4 col = y * a + r * (1. - a);\n        \n        float ft = fract(iTime * SUN_SPEED) * 0.25;\n        vec2 l0 = vec2(-ft + 0.05, ft * 0.2);\n        ft = fract(iTime * SUN_SPEED + 0.25) * 0.25;\n        vec2 l1 = vec2(-ft + 0.05, ft * 0.2);\n        ft = fract(iTime * SUN_SPEED + 0.5) * 0.25;\n        vec2 l2 = vec2(-ft + 0.05, ft * 0.2);\n        ft = fract(iTime * SUN_SPEED + 0.75) * 0.25;\n        vec2 l3 = vec2(-ft + 0.05, ft * 0.2);\n        return col * (1. - \n                      step(l0.x - l0.y, ray.y) * step(ray.y, l0.x + l0.y) -\n                      step(l1.x - l1.y, ray.y) * step(ray.y, l1.x + l1.y) -\n                      step(l2.x - l2.y, ray.y) * step(ray.y, l2.x + l2.y) -\n                      step(l3.x - l3.y, ray.y) * step(ray.y, l3.x + l3.y)\n                      );\n        \n        return col * \n                (step(ray.y, -0.03) + \n                 step(0., ray.y) * step(ray.y, 0.04) +\n                 step(0.06, ray.y) * step(ray.y, 0.11) +\n                 step(0.13, ray.y) * step(ray.y, 0.18) +\n                 step(0.195, ray.y)\n                 );\n    }\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec4 GetScreenColor(in vec3 ray, in vec3 cameraPos)\n{\n    vec3 background = GetBackgroundColor(ray);\n    bool hit;\n    vec3 hitPoint;\n    hit = GetHitWithPlane(cameraPos, ray, hitPoint);\n    vec3 plane = GetHitPointColor(cameraPos, hitPoint, background);\n    if (hit)\n        return vec4(plane, 1);\n    vec4 sun = GetSun(cameraPos, ray);\n    \n    return vec4(background * (1.0 - sun.w) + sun.xyz * sun.w, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv * 2.0 - 1.0;\n    cuv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(cuv.x, cuv.y, 1.2));\n    \n    float ix = PI * 0.5 + (iMouse.x / iResolution.x) * PI;\n    float iy = iMouse.y / iResolution.y * PI * 0.25;\n    \n    vec3 f = vec3(\n        cos(ix) * cos(iy),\n        sin(iy),\n        sin(ix) * cos(iy)\n    );\n    f = normalize(f);\n    vec3 u = vec3(0.0, 1.0, 0.0);\n    vec3 r = normalize(cross(f, u));\n    u = normalize(cross(r, f));\n    \n    \n    fragColor = GetScreenColor(normalize(f * ray.z + u * ray.y + r * ray.x), vec3(0.0, 0.1, iTime * SPEED));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}