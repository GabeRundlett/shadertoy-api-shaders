{
    "Shader": {
        "info": {
            "date": "1532551486",
            "description": "storing an octree grid in the buffer. arrow keys, ctrl and shift to move, click to add a voxel, hold e and click to remove voxels.\nO and L to change voxel size.",
            "flags": 48,
            "hasliked": 0,
            "id": "XtdyDH",
            "likes": 33,
            "name": "octree buffer",
            "published": 3,
            "tags": [
                "voxel",
                "octree"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 2062
        },
        "renderpass": [
            {
                "code": "vec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nvec3 voxel(vec3 ro, vec3 rd, float size)\n{\n    size *= 0.5;\n    \n    vec3 hit = -(sign(rd)*(ro-size)-size)/max(abs(rd),0.001);\n    \n    return hit;\n}\n\nfloat map(vec3 p) {\n    p = mod(p,0.1)-0.05;\n    return length(p)-0.02;\n}\n\nvec3 findnormal(vec3 p) {\n    vec2 e = vec2(0.0,0.001);\n    \n    return normalize(vec3(map(p+e.yxx),map(p+e.xyx),map(p+e.xxy))-map(p));\n}\n\nvec4 octreeray(vec3 ro, vec3 rd, float maxdist, float e) {\n    \n    float size = 0.5;\n    vec3 lro = mod(ro,size);\n    vec3 fro = ro-lro;\n    vec3 mask;\n    vec3 lastmask;\n    bool exitoct = false;\n    int recursions = 0;\n    int recursions0 = 0;\n    int recursions1 = 0;\n    int voxelstate1;\n    float dist = 0.0;\n    int i;\n    int index = 0;\n    vec4 data;\n    vec3 invrd = 1.0/abs(rd);\n    vec3 hit = voxel(lro, rd, size);\n    \n    if (any(greaterThan(abs(ro-0.5),vec3(0.5)))) return vec4(0);\n    \n    //the octree traverser loop\n    //each iteration i:\n    // - check if i need to go up a level\n    // - check if i need to go down a level\n    // - check if i hit a cube\n    // - go one step forward if cube is empty\n    for (i = 0; i < steps; i++)\n    {\n        if (dist > maxdist) break;\n        \n        if (recursions0 == recursions) {\n            vec3 q = mod(floor(fro/size+0.5)+0.5,2.0)-0.5;\n            data = getdata(index*8+datapixels+int(dot(q,vec3(1,2,4))+0.5));\n        }\n        int voxelstate = int(data.w);\n        \n        if (recursions1 == recursions) {\n            voxelstate1 = getvoxel(fro, size);\n            if (recursions1 == debrisdetail-1 && voxelstate1 == cube_octree) {\n                voxelstate1 = cube_empty;\n            }\n        }\n        \n        bool isnothing = recursions0 < recursions || voxelstate == cube_nothing;\n        \n        if (isnothing) {\n            \n            voxelstate = voxelstate1;\n        }\n        \n        //i go up a level\n        if (exitoct)\n        {\n            \n            if (recursions0 == recursions) {\n                index = int(data.x);\n                recursions0--;\n            }\n            \n            if (recursions1 == recursions) {\n                recursions1--;\n            }\n            \n            vec3 newfro = floor(fro/size*0.5+0.25)*size*2.0;\n            \n            lro += fro-newfro;\n            fro = newfro;\n            \n            recursions--; \n            size *= 2.0;\n        \thit = voxel(lro, rd, size);\n            if (recursions < 0) break;\n            exitoct = (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n        }\n        //subdivide\n        else if(voxelstate == cube_octree)\n        {\n            recursions++;\n            \n            if (!isnothing) {\n                index = int(data.y);\n                recursions0++;\n            }\n            \n            if (voxelstate1 == cube_octree) {\n                recursions1++;\n            }\n            \n            size *= 0.5;\n            \n            //find which of the 8 voxels i will enter\n            vec3 mask2 = step(vec3(size),lro);\n            fro += mask2*size;\n            lro -= mask2*size;\n        \thit = voxel(lro, rd, size);\n        }\n        //move forward\n        else if (voxelstate == cube_nothing || voxelstate == cube_empty)\n        { \n            //raycast and find distance to nearest voxel surface in ray direction\n            if (hit.x < min(hit.y,hit.z)) {\n                mask = vec3(1,0,0);\n            } else if (hit.y < hit.z) {\n                mask = vec3(0,1,0);\n            } else {\n                mask = vec3(0,0,1);\n            }\n            float len = dot(hit,mask);\n            \n            hit -= len;\n            \n            hit += mask*invrd*size;\n            \n                lro += rd*len-mask*sign(rd)*size;\n            vec3 newfro = fro+mask*sign(rd)*size;\n            \n#ifdef raymarching\n            if (voxelstate == cube_nothing) {\n                if (map(ro+dist*rd) < e) {\n                    mask = lastmask;\n                    break;\n                }\n                int j = 100;\n                while (len > 0.0 && j > 0) {\n                    j--;\n                    float l = map(ro+dist*rd);\n                    if (l < e) {\n                        return vec4(dist,vec3(0));\n                    }\n                    dist += l;\n                    len -= l;\n                }\n            }\n#endif\n            \n            dist += len;\n            exitoct = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25));\n            fro = newfro;\n            lastmask = mask;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return vec4(dist, -mask*sign(rd));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int detail = int(getdata(detaildata).x);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec4 rotcam = getdata(camrot);\n    \n    vec3 cam = getdata(campos).xyz;\n    vec3 rd = normalize(vec3(uv,1));\n    rd.zy *= rot(rotcam.y);\n    rd.zx *= rot(rotcam.x);\n    \n    vec4 len = octreeray(cam,rd,4.0,epsilon);\n    vec3 ro = cam+rd*len.x;\n    \n    vec3 p1 = ro*exp2(float(detail));\n    \n    bool voxel = len.yzw != vec3(0);\n    \n    if (!voxel) {\n        len.yzw = findnormal(ro);\n    }\n    \n    //vec2 p1 = (ro.yz*len.y+ro.xz*len.z+ro.xy*len.w)*exp2(float(detail));\n    \n    fragColor.xyz = texture(iChannel1,p1).xxx*0.5+0.5;\n    fragColor *= fragColor;\n    \n    float a = mod(dot(floor(p1),vec3(1)),2.0);\n\n    p1 = abs(fract(p1)-0.5);\n    if (voxel) {\n    \tp1 = min(p1,p1.yzx);\n    }\n    float b = (1.0-max(max(p1.x,p1.y),p1.z)*2.0/(len.x*exp2(float(detail))*0.04+1.0));\n    fragColor = fragColor*b;\n    \n    \n    \n    vec3 normal = len.yzw;\n    \n    vec3 lightpos = vec3(0.4);\n    vec3 lightdir = ro-lightpos;\n    float lightdist = length(lightdir);\n    lightdir /= lightdist;\n    \n    float shadow = float(octreeray(lightpos,lightdir,lightdist,epsilon).x>lightdist-epsilon);\n    \n    fragColor *= max(dot(-lightdir,normal)*shadow,ambient);\n    \n    \n    //fragColor /= (len.x*len.x*exp2(float(detail+1))+1.0);\n    fragColor = sqrt(fragColor);\n    \n    \n    if (fragCoord.x < 10.0) {\n        fragColor = vec4(0);\n        vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n        if (data.x == -1.0) return;//fragColor = vec4(0);\n        fragColor = vec4(1.0);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//keyboard keys\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_RIGHT 39\n#define KEY_LEFT  37\n#define KEY_SHIFT 16\n#define KEY_CTRL  17\n#define KEY_Q  81\n#define KEY_E  69\n#define KEY_O  79\n#define KEY_L  76\n\n//movement keys\n#define MOVE_FORW   KEY_UP\n#define MOVE_LEFT   KEY_LEFT\n#define MOVE_RIGHT  KEY_RIGHT\n#define MOVE_BACK   KEY_DOWN\n#define MOVE_UP     KEY_SHIFT\n#define MOVE_DOWN   KEY_CTRL\n#define ERASE       KEY_E\n#define UP_DETAIL   KEY_O\n#define DOWN_DETAIL KEY_L\n\nfloat getkey(int x, int y)\n{\n    return texelFetch(iChannel1,ivec2(x,y),0).x;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nfloat map(vec3 p) {\n    p = mod(p,0.1)-0.05;\n    return length(p)-0.02;\n}\n\nvec3 voxel(vec3 ro, vec3 rd, float size)\n{\n    size *= 0.5;\n    \n    vec3 hit = -(sign(rd)*(ro-size)-size)/max(abs(rd),0.0001);\n    \n    return hit;\n}\n\nvec4 octreeray(vec3 ro, vec3 rd, float maxdist, float e) {\n    \n    float size = 0.5;\n    vec3 lro = mod(ro,size);\n    vec3 fro = ro-lro;\n    vec3 mask;\n    vec3 lastmask;\n    bool exitoct = false;\n    int recursions = 0;\n    int recursions0 = 0;\n    int recursions1 = 0;\n    int voxelstate1;\n    float dist = 0.0;\n    int i;\n    int index = 0;\n    vec4 data;\n    vec3 invrd = 1.0/abs(rd);\n    vec3 hit = voxel(lro, rd, size);\n    \n    if (any(greaterThan(abs(ro-0.5),vec3(0.5)))) return vec4(0);\n    \n    //the octree traverser loop\n    //each iteration i:\n    // - check if i need to go up a level\n    // - check if i need to go down a level\n    // - check if i hit a cube\n    // - go one step forward if cube is empty\n    for (i = 0; i < steps; i++)\n    {\n        if (dist > maxdist) break;\n        \n        if (recursions0 == recursions) {\n            vec3 q = mod(floor(fro/size+0.5)+0.5,2.0)-0.5;\n            data = getdata(index*8+datapixels+int(dot(q,vec3(1,2,4))+0.5));\n        }\n        int voxelstate = int(data.w);\n        \n        if (recursions1 == recursions) {\n            voxelstate1 = getvoxel(fro, size);\n        }\n        \n        bool isnothing = recursions0 < recursions || voxelstate == cube_nothing;\n        \n        if (isnothing) {\n            voxelstate = voxelstate1;\n        }\n        \n        if (recursions == maxdetail-1 && voxelstate == cube_octree) {\n            voxelstate = cube_empty;\n        }\n        //i go up a level\n        if (exitoct)\n        {\n            \n            if (recursions0 == recursions) {\n                index = int(data.x);\n                recursions0--;\n            }\n            \n            if (recursions1 == recursions) {\n                recursions1--;\n            }\n            \n            vec3 newfro = floor(fro/size*0.5+0.25)*size*2.0;\n            \n            lro += fro-newfro;\n            fro = newfro;\n            \n            recursions--; \n            size *= 2.0;\n        \thit = voxel(lro, rd, size);\n            if (recursions < 0) break;\n            exitoct = (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n        }\n        //subdivide\n        else if(voxelstate == cube_octree)\n        {\n            recursions++;\n            \n            if (!isnothing) {\n                index = int(data.y);\n                recursions0++;\n            }\n            \n            if (voxelstate1 == cube_octree) {\n                recursions1++;\n            }\n            \n            size *= 0.5;\n            \n            //find which of the 8 voxels i will enter\n            vec3 mask2 = step(vec3(size),lro);\n            fro += mask2*size;\n            lro -= mask2*size;\n        \thit = voxel(lro, rd, size);\n        }\n        //move forward\n        else if (voxelstate == cube_nothing || voxelstate == cube_empty)\n        { \n            //raycast and find distance to nearest voxel surface in ray direction\n            if (hit.x < min(hit.y,hit.z)) {\n                mask = vec3(1,0,0);\n            } else if (hit.y < hit.z) {\n                mask = vec3(0,1,0);\n            } else {\n                mask = vec3(0,0,1);\n            }\n            float len = dot(hit,mask);\n            \n            hit -= len;\n            \n            hit += mask*invrd*size;\n            \n                lro += rd*len-mask*sign(rd)*size;\n            vec3 newfro = fro+mask*sign(rd)*size;\n            \n#ifdef raymarching\n            if (voxelstate == cube_nothing) {\n                if (map(ro+dist*rd) < e) {\n                    mask = lastmask;\n                    break;\n                }\n                int j = 100;\n                while (len > 0.0 && j > 0) {\n                    j--;\n                    float l = map(ro+dist*rd);\n                    if (l < e) {\n                        return vec4(dist,vec3(0));\n                    }\n                    dist += l;\n                    len -= l;\n                }\n            }\n#endif\n            \n            dist += len;\n            exitoct = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25));\n            fro = newfro;\n            lastmask = mask;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return vec4(dist, -mask*sign(rd));\n}\n\nvec4 updatedata(int index) {\n    vec4 data = getdata(index);\n    \n    int detail = int(getdata(detaildata).x);\n    \n    vec2 muv = vec2((iMouse.xy*2.0-iResolution.xy)/iResolution.y);\n    \n    vec4 cray = getdata(clickray);\n    \n    vec4 iMouse2 = getdata(lastmouse);\n    iMouse2.w = abs(iMouse2.w);\n    //bool click = cray.w > 0.5;\n    bool click = iMouse2.z > 0.0 && iMouse.z < 0.0 && length(iMouse2.xy-iMouse2.zw)<10.0;\n    bool erase = getkey(ERASE,0) > 0.5;\n    \n    vec3 mpos = cray.xyz;\n    \n    if (any(greaterThan(abs(mpos-0.5),vec3(0.5)))) click = false;\n    \n    vec4 counterdata = getdata(counter);\n    \n    bool refresh = (iFrame == 0)\n        ||(iResolution.xy!=counterdata.zw);\n    \n                \n    float size = 0.5;\n    vec4 data2;\n    int index3 = 0;\n    vec3 p;\n    int i = 0;\n    while (true) {\n        p = mod(floor(mpos/size)+0.5,2.0)-0.5;\n        data2 = getdata(index3*8+datapixels+int(dot(p,vec3(1,2,4))));\n        if (int(data2.w) != cube_octree||i == detail-1) {\n            break;\n        }\n        i++;\n        size /= 2.0;\n        index3 = int(data2.y);\n    }\n    int subdivides = detail-i-1;\n    \n    \n    if (index == counter) {\n        if (refresh) {\n            data = vec4(0,0,iResolution.xy);\n            return data;\n        }\n        if (click) {\n            data.x += float(max(subdivides,0));\n        }\n        return data;\n    } else if (index == lastmouse) {\n        return iMouse;\n    } else if (index == campos) {\n        \n        if (refresh) {\n            return vec4(0.51,0.001,0.4,0);\n        }\n        \n        vec4 rotcam = getdata(camrot);\n        \n        vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                         getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                         getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n        move.zy *= rot(rotcam.y);\n        move.zx *= rot(rotcam.x);\n        \n        \n        vec3 newpos = clamp(data.xyz+move*movespeed*iTimeDelta,epsilon,1.0-epsilon);\n        \n        float size = 1.0;\n        vec4 data2;\n        int index3 = 0;\n        vec3 p;\n        int i = 0;\n        \n        int voxelstate0 = cube_octree;\n        int voxelstate1 = cube_octree;\n        \n        vec3 p2 = newpos;\n        int voxelstate;\n        while (true) {\n            vec3 fro = floor(newpos/size);\n            p = mod(fro+0.5,2.0)-0.5;\n            p2 -= p*size;\n            data2 = getdata(index3*8+datapixels+int(dot(p,vec3(1,2,4))+0.5));\n            \n            if (voxelstate0 == cube_octree) {\n                voxelstate0 = int(data2.w);\n            }\n            \n            if (voxelstate1 == cube_octree) {\n                voxelstate1 = getvoxel(fro*size,size);\n            }\n            \n            voxelstate = voxelstate0;\n            if (voxelstate == cube_nothing) {\n                voxelstate = voxelstate1;\n            }\n            \n            \n            if (voxelstate != cube_octree) {\n                break;\n            }\n            \n            i++;\n            size /= 2.0;\n            index3 = int(data2.y);\n        }\n        \n        p2 = p2/size-0.5;\n        \n        vec3 mask = 2.0*vec3(greaterThan(abs(p2),max(abs(p2.yzx),abs(p2.zxy))))*sign(p2)*movespeed*iTimeDelta;\n        \n        if (voxelstate == cube_empty || voxelstate == cube_nothing) {\n        \tdata.xyz = newpos;\n        } else {\n            data.xyz = newpos+mask;\n        }\n        \n        return data;\n    } else if (index == camrot) {\n        \n        if (refresh) {\n            return vec4(0);\n        }\n        \n        if (min(iMouse2.z,iMouse.z) > 0.5) {\n            data.xy += (iMouse.xy-iMouse2.xy)/iResolution.y*sensitivity;\n        }\n        return data;\n    } else if (index == clickray) {\n        \n        if (refresh) {\n            return vec4(0);\n        }\n        if (iMouse.z > 0.0 && iMouse2.z < 0.0) {\n            vec4 rotcam = getdata(camrot);\n\n            vec3 ro = getdata(campos).xyz;\n            vec3 rd = normalize(vec3(muv,1));\n            rd.zy *= rot(rotcam.y);\n            rd.zx *= rot(rotcam.x);\n            vec4 len = octreeray(ro,rd, 1.0, epsilon);\n            vec3  normal = len.yzw;\n            float minsize = 0.5/exp2(float(detail));\n\n            if (erase) {\n                ro += len.x*rd-normal*epsilon;\n            } else {\n                ro += len.x*rd+normal*epsilon;\n            }\n            \n            ro = clamp(ro,epsilon,1.0-epsilon);\n\n            data.xyz = floor(ro/minsize)*minsize;\n        \t//data.w = float((getkey(KEY_E,1)>0.5)||(getkey(KEY_Q,1)>0.5));\n        }\n        \n        return data;\n    } else if (index == detaildata) {\n        \n        if (refresh) {\n            return vec4(startdetail);\n        }\n        \n        float keys = getkey(UP_DETAIL,1)-getkey(DOWN_DETAIL,1);\n        \n        data.x = clamp(data.x+keys,float(mindetail),float(maxdetail));\n        \n        data.y = keys;\n        \n        return data;\n    } else {\n        \n        if (refresh) {\n            data = vec4(-1,-1,0,0);\n            return data;\n        }\n        if (click) {\n            int index2 = index-datapixels;\n            int quad = index2/8;\n            int quadindex = index2-quad*8;\n            if (quad <= int(counterdata.x)) {\n                //if (data.y < -0.5)\n                {\n                    if (index3 == quad) {\n                        vec3 clickp = mod(floor(mpos/size)+0.5,2.0)-0.5;\n                        int clicki = quad*8+int(dot(clickp,vec3(1,2,4)));\n\n                        if (clicki == index2) {\n                            if (i == detail-1) {\n                                if (erase) {\n                                \tdata.w = float(cube_empty);\n                                } else {\n                                \tdata.w = float(cube_brick);\n                                }\n                                data.y = -1.0;\n                                return data;\n                            }\n                            data.w = float(cube_octree);\n                            data.y = counterdata.x+1.0;\n                        }\n                    }\n                }\n        \t} else if( quad <= int(counterdata.x)+subdivides) {\n                vec3 q = mod(floor(mpos*exp2(float(i+quad)-counterdata.x+1.0))+0.5,2.0)-0.5;\n                vec3 q2 = vec3(quadindex%2,(quadindex/2)%2,quadindex/4);\n                \n                if (quad == int(counterdata.x)+1) {\n                \tdata.x = float(index3);\n                } else {\n                    data.x = float(quad-1);\n                }\n                \n                if (dot(abs(q-q2),vec3(1))<0.1) {\n                    data.w = float(cube_octree);\n                    data.y = float(quad+1);\n                    if (quad == int(counterdata.x)+subdivides) {\n                        if (erase) {\n                            data.w = float(cube_empty);\n                        } else {\n                            data.w = float(cube_brick);\n                        }\n                        data.y = -1.0;\n                    }\n                } else {\n                    data.w = data2.w;\n                \tdata.y = -1.0;\n                }\n        \t}\n        }\n    }\n    \n    \n    return data;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = updatedata(coord.x+coord.y*int(iResolution.x));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//uncomment to add some spheres you can mess with\n#define raymarching\n\n//the editor starts with octree lvl 8 (or startdetail) when you refresh\n#define startdetail 8\n//limit octree level to 20 (or maxdetail) and 1 (or mindetail)\n#define maxdetail 20\n#define mindetail 1\n#define debrisdetail 20\n//octree iterations before the ray gives up, gets really goofy on low numbers\n#define steps 1000\n#define ambient 0.2\n\n#define emptycells 0.5\n#define subdivisions 0.90 //should be higher than emptycells\n\n\n#define counter 0\n#define lastmouse 1\n#define campos 2\n#define camrot 3\n#define clickray 4\n#define detaildata 5\n#define datapixels 6\n\n#define cube_nothing 0\n#define cube_octree 1\n#define cube_empty 2\n#define cube_brick 3\n\n#define epsilon max(0.001*exp(-float(detail)),0.0000001)\n\n#define sensitivity 3.0\n#define movespeed (3.0*exp2(float(-detail)))\n\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n\n\n//random function from https://www.shadertoy.com/view/MlsXDf\nfloat rnd(vec4 v) { return fract(4e4*sin(dot(v,vec4(13.46,41.74,-73.36,14.24))+17.34)); }\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//0 is empty, 1 is subdivide and 2 is full\nint getvoxel(vec3 p, float size) {\n#ifdef objects\n    if (p.x==0.0&&p.y==0.0) {\n        return 0;\n    }\n#endif\n    \n    float val = rnd(vec4((p/size),size));\n    \n    if (val < emptycells) {\n        return cube_nothing;\n    } else if (val < subdivisions) {\n        return cube_octree;\n    } else {\n        return cube_brick;\n    }\n    \n    return int(val*val*3.0);\n}\n\n\n/**\nfloat rnd(vec4 v) { return fract(4e4*sin(dot(v,vec4(13.46,41.74,-73.36,14.24))+17.34)); }\n\nint getvoxel(vec3 p, float size) {\n    float val = rnd(vec4(p,size));\n    \n    if (p.x==0.0&&p.y==0.0) {\n        return 0;\n    }\n    \n    \n    if (val < 0.7) {\n        return 0;\n    } else if (val < 0.99) {\n        return 1;\n    } else {\n        return 2;\n    }\n    \n    //return int(val*3.0);\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nbool map(vec3 p) {\n    if (min(min(p.x,p.y),p.z)<-0.5||max(max(p.x,p.y),p.z)> 15.5) return true;\n    \n    float size = 0.5;\n    vec4 data;\n    int index = 0;\n    int i;\n    for (i = 0; i < detail; i++) {\n        vec3 q = mod(floor(p/size/16.0)+0.5,2.0)-0.5;\n        data = getdata(index*8+1+int(dot(q,vec3(1,2,4))+0.5));\n        if (data.w != 2.0) {\n            break;\n        }\n        index = int(data.y+0.5);\n        size /= 2.0;\n    }\n    \n    return data.w == 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(7.5,7.5,0.5);\n    vec3 lro = fract(ro);\n    vec3 cell = ro-lro;\n    vec3 rd = normalize(vec3(uv,1));\n    vec3 signrd = sign(rd);\n    vec3 invrd = 1.0/abs(rd);\n    \n    vec3 dists = abs(step(0.0,rd)-lro)/abs(rd);\n    \n    for ( int i = 0; i < 50; i++) {\n        \n        if (map(cell)) break;\n        \n        vec3 mask = vec3(lessThan(dists,min(dists.yzx,dists.zxy)));\n        \n        if (dot(mask,vec3(1)) < 0.5) {\n            mask.x = 1.0;\n        }\n        \n        float len = dot(mask,dists);\n        ro += rd*len;\n        \n        cell += mask*signrd;\n        lro = cell-ro;\n        dists -= len-mask*invrd;\n        \n    }\n    fragColor = vec4(fract(ro+0.001),1.0);\n    \n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (dot(abs(data - vec4(-1,-1,0,0)),vec4(1))<0.01) return;//fragColor = vec4(0);\n    fragColor += vec4(1.0);\n    \n}\n\n/**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}