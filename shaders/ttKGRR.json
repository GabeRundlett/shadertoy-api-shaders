{
    "Shader": {
        "info": {
            "date": "1578159165",
            "description": "Raymarching with repetition trick",
            "flags": 0,
            "hasliked": 0,
            "id": "ttKGRR",
            "likes": 1,
            "name": "Raymarch Tutorial v04",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "repetition"
            ],
            "usePreview": 0,
            "username": "tombla",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "// Based on youtube tutorial\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n// and SDF functions article at\n// https://iquilezles.org/articles/distfunctions\n\n#define SPHERE_POS_1 vec3(0., 0., 0.)\n#define SPHERE_RAD_1 1.\n#define SPHERE_POS_2 vec3(-0.6, 0., -0.6)\n#define SPHERE_RAD_2 0.9\n#define PLANE_POS -4.\n#define LIGHT_POS vec3(-0., 2.1, 0.2)\n#define JUMP_SPEED 1.4\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define CLOSENESS 0.01\n\nvec2 rescale(in vec2 p) {\n    return vec2((p - 0.5 * iResolution.xy) / iResolution.y);\n}\n\nfloat twoUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat twoSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nfloat twoIntersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat getOnion(float d, float r) {\n    return abs(d) - r;\n}\n\nvec3 getInfiniteRep(in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    return q;\n}\n\n// Get distance to sphere 1.\nfloat getDistSphere1(vec3 p) {\n    vec3 spherePos = SPHERE_POS_1;\n    float dS = length(spherePos - p) - SPHERE_RAD_1;\n    return dS;\n}\n\n// Get distance to sphere 2.\nfloat getDistSphere2(vec3 p) {\n    vec3 spherePos = SPHERE_POS_2;\n    float dS = length(spherePos - p) - SPHERE_RAD_2;\n    return dS;\n}\n\n// Get distance to both spheres.\nfloat getDistSpheres(vec3 p) {\n    float density = 4. + sin(iTime);\n    vec3 rep = getInfiniteRep(p, vec3(density, density, 11.));\n    float dS1 = getDistSphere1(rep);\n    float dS2 = getDistSphere2(rep);\n    float diff = twoSubtract(dS1, dS2);\n    //float onion = getOnion(diff, 0.003);\n    return diff;\n}\n\n// Get distance to plane and spheres.\nfloat getDistAll(vec3 p) {\n    float dS = getDistSpheres(p);\n    float dP = p.y - PLANE_POS;\n    //float dP = dS;\n    return min(dS, dP);\n}\n\nfloat rayMarch(vec3 origin, vec3 direction) {\n    float dist = 0.;\n    for(int i=0; i < MAX_STEPS; ++i) {\n        vec3 ray = origin + direction * dist;\n        float step = getDistAll(ray);\n        dist += step;\n        if (step < CLOSENESS || dist > MAX_DIST) break;\n    }\n    return min(dist, MAX_DIST);\n}\n\nvec3 getNormal(vec3 p) {\n    float toSurface = getDistAll(p);\n    vec2 e = vec2(0.01, 0.);\n    vec3 plane = toSurface - vec3(\n        getDistAll(p - e.xyy),\n        getDistAll(p - e.yxy),\n        getDistAll(p - e.yyx));\n    return normalize(plane);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = LIGHT_POS;\n    lightPos.xz += 2. * vec2(sin(iTime), cos(iTime));\n    vec3 lightVector = normalize(lightPos - p);\n    vec3 surfaceVector = getNormal(p);\n//    float diffusion = dot(surfaceVector, lightVector);\n    float diffusion = dot(lightVector, surfaceVector);\n    diffusion = clamp(diffusion, 0., 1.);\n\n    float toLight = rayMarch(p + surfaceVector * 1.05 * CLOSENESS, lightVector);\n    if (toLight < length(p - lightPos)) {\n        diffusion *= 0.3;\n    }\n\n    return diffusion;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = rescale(fragCoord);\n    vec3 color = vec3(1., 0.9, 0.7);\n\n    // Camera position\n    vec3 ro = vec3(0., 0.5, -9.);\n    // Camera direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    // Distance to a shape.\n    float dist = rayMarch(ro, rd);\n    // Point at the shape\n    vec3 ray = ro + rd * dist;\n    // Light diffusion\n    float diffusion = getLight(ray);\n    color *= diffusion;\n    // Sky\n    vec3 sky = vec3(0.1, 0.5, 0.8);\n    float skyMix = smoothstep(MAX_DIST * 0.6, MAX_DIST * 0.9, dist);\n\n    // Final color\n    vec3 final = mix(color, sky, skyMix);\n\n\n    fragColor = vec4(final, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}