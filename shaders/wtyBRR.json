{
    "Shader": {
        "info": {
            "date": "1613737802",
            "description": "Extraterrestrial energy transmission station or whatever. Just discovered this glowy effect and played with it",
            "flags": 0,
            "hasliked": 0,
            "id": "wtyBRR",
            "likes": 12,
            "name": "Transmission Theta",
            "published": 3,
            "tags": [
                "raymarching",
                "glow"
            ],
            "usePreview": 0,
            "username": "kostik1337",
            "viewed": 562
        },
        "renderpass": [
            {
                "code": "#define t iTime\n#define PI 3.14159265\n\n#define mr(a) (mat2(cos(a),sin(a),-sin(a),cos(a)))\n#define INF 1e10\n#define rep(p, s) mod(p,s)-s/2.\n\nfloat hash(float x) {return fract(sin(x)*31345.23);}\nfloat hash2(vec2 x) {return hash(dot(x, vec2(43.123, 32.12345)));}\n\nfloat glow = 0.;\n\nfloat box(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p,0.0)) + min(0.0, max(p.x,max(p.y, p.z)));\n}\n\nvec2 repPolarInfinite(vec2 p, float lDiv, float polDiv) {\n  vec2 pPol = vec2(length(p), atan(p.y, p.x));\n  \n  float ringId = floor(pPol.x / lDiv);\n  float div = polDiv * (ringId+1.);\n  float lcc = floor(pPol.y / (2.*PI/div));\n  pPol.y += .3*(hash(ringId) - .5)*t / (ringId+1.);\n  pPol.y = rep(pPol.y, 2.*PI/div);\n  p = pPol.x * vec2(cos(pPol.y), sin(pPol.y));\n  p.x -= lDiv*(ringId + .5);\n  return p;\n}\n\nfloat gear(vec3 p, float zcc) {\n  p.xy *= mr(t*2.*(hash(zcc)-.5));\n  p.xy = abs(p.xy) - .15;\n  vec3 s = vec3(.5, .03, .2);\n  float b = min(box(p, s), box(p, s.yxz));\n  return max(b, -box(p, vec3(INF, INF, .03)));\n}\n\nfloat map(vec3 p, float d) {\n  p.xy *= mr(.2 * t);\n  p.yz *= mr(.1 * sin(.5*t));\n\n  p.xy = repPolarInfinite(p.xy, 3., 3.);\n  \n  p.z += t;\n  \n  float pz_orig = p.z;\n  float zdiv = .5;\n  float zcc = floor(p.z / zdiv);\n  p.z = rep(p.z, zdiv);\n\n  float m_this = gear(p, zcc);\n  float m_near = gear(p + vec3(0., 0., -zdiv * sign(p.z)), zcc + sign(p.z));\n  float m_ring = 2. - abs(p.x);\n  float m = min(min(m_this, m_near), m_ring);\n  \n  float glowAmp = smoothstep(.7, 1., sin(-6.*t + 2.*pz_orig)*.5+.5);\n  float g = .01 * glowAmp / abs(m - .2);\n  g = min(1., g) * exp(-(d+m)/20.);\n  glow += g;\n  return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy - 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec2 mouse = iMouse.z > 0. ? (iMouse.xy / iResolution.xy-.5) * PI : vec2(0.);\n\n  vec3 O = vec3(0.,0.,0.), D = normalize(vec3(uv, 1.));\n  D.xz *= mr(mouse.x);\n  D.yz *= mr(mouse.y);\n  float d = 0., md = 100.;\n  vec3 c = vec3(0.);\n  \n  float I = 128.;\n  for (float i=0.; i<I; ++i) {\n    vec3 p = O+D*d;\n    float m = map(p, d);\n    if (m < 0.001*d || d>md) {\n      if (d<md) {\n        c += (.3 * vec3(1.-d/md) - 1.5*i/I);\n      }\n      break;\n    }\n    d += m;\n  }\n  c += glow * vec3(.8, .8, 1.2);\n  c = clamp(vec3(0.),vec3(2.),c);\n  \n  fragColor = vec4(c,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}