{
    "Shader": {
        "info": {
            "date": "1671678233",
            "description": "you can tilt the camera a bit with the mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "dlXGWH",
            "likes": 14,
            "name": "A Mall and the Night Visitors",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "neon",
                "vaporwave",
                "mall"
            ],
            "usePreview": 0,
            "username": "Xibanya",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "// uncomment out in visual studio code\n//#define DEFINED_SATURATE\n\n#ifndef DEFINED_SATURATE\n#define DEFINED_SATURATE\n#define saturate(x) clamp(x, 0., 1.)\n#endif\n\nconst float _XRot = 5.;\nconst float _YRot = -55.;\nconst float _XPos = -4.5;\nconst float _YPos = 0.55;\nconst float _ZPos = 4.;\nconst float _FOV = 45.;\nconst float _LightX = -0.5;\nconst float _LightY = 0.9;\nconst float _LightZ = 0.9;\nconst float _LightR = 0.25;\nconst float _LightG = 0.2;\nconst float _LightB = 0.3;\nconst float _FogGamma = 2.2;\nconst float _FlickerRate = 5.;\nconst float _FlickerPhase = 25.;\n\nconst int MARCH_STEPS = 200;\nconst int SHADOW_MARCH_STEPS = 100;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00005;\n#define PI 3.14159265\n\nconst vec3 SHADOW_COLOR = vec3(0.25, 0.2, 0.4) * 0.5;\nconst vec3 PINK = vec3(0.8, 0.7, 0.9);\nconst vec3 BLUE = vec3(0.7, 0.7, 1.);\nconst vec3 TRUNK_COLOR = vec3(0.6, 0.5, 0.5);\nconst vec3 FROND_COLOR = pow(vec3(0., 1., 0.8) * 0.5, vec3(1.2));\nconst float MIN_FOG_GAMMA = 0.75;\nconst float MAX_FOG_GAMMA = 2.2;\nconst float FOG_GAMMA_TIME = 0.5;\nconst float BUILDING_ROUND = 0.02;\n\nfloat Distance(vec3 p);\n\nstruct Object \n{\n    float dist;\n    vec3 color;\n    float smoothness;\n    float emission;\n    float metallic;\n    vec3 p;\n    vec3 scale;\n};\nstruct Objects {\n    float total;\n    Object Ornament; \n    Object Neon;\n    Object Building; \n    Object Under; \n    Object Ground;\n    Object Door;\n    Object Wall;\n    Object CeilingTile;\n    Object CeilingPlaster;\n    Object CeilingNeon;\n    Object OverNeon;\n    vec4 tex;\n};\nstruct Light {\n    float nDotL;\n    vec3 dir;\n    float atten;\n    float shadow;\n    float diffuse;\n    float occlusion;\n};\n\n// AO stuff from https://www.shadertoy.com/view/4sdGWN\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat AO( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = n*l;\n        \n        ao += (l - max(Distance( p + rd ),0.)) / maxDist * falloff;\n    }\n    return clamp( 1.-ao/float(nbIte), 0., 1.);\n}\nfloat Flicker(float phase, float rate)\n{\n    float flick = floor((iTime + phase) * rate) / rate;\n    \n    flick = fract(sin(flick) * 43758.5453);\n    return flick;\n}\nfloat InvLerp(float from, float to, float value)\n{\n    return clamp(abs(value - from) / abs(to - from), 0., 1.);\n}\nmat3 YRotationMatrix(float degrees)\n{\n\tfloat angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat3 rotateYMatrix = mat3(\n        c, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c);\n\treturn rotateYMatrix;\n}\nmat3 ZRotationMatrix(float degrees)\n{\n\tfloat angleZ = radians(degrees);\n\tfloat c = cos(angleZ);\n\tfloat s = sin(angleZ);\n\tmat3 rotateZMatrix = mat3(\n        c, -s, 0,\n\t\ts, c, 0,\n\t\t0, 0, 1\n\t\t);\n\treturn rotateZMatrix;\n}\nmat3 XRotationMatrix(float degrees)\n{\n\tfloat angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat3 rotateXMatrix = mat3(\n        1, 0, 0,\n\t\t0, c, -s, \n\t\t0, s, c);\n\treturn rotateXMatrix;\n}\nvec3 Rotate(vec3 a, vec3 o)\n{\n    vec3 localScaledTranslatedRotX = o * XRotationMatrix(a.x);\n    vec3 localScaledTranslatedRotXY = localScaledTranslatedRotX * YRotationMatrix(a.y);\n    return localScaledTranslatedRotXY * ZRotationMatrix(a.z);\n}\nmat2 Rotate2DMatrix(float a)\n{\n    a = radians(a);\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\nvec2 Rotate2D(float angle, vec2 original)\n{\n    return Rotate2DMatrix(angle) * original;\n}\n//https://www.shadertoy.com/view/XtBfzz\nfloat GridPattern( in vec2 p, float smoothness)\n{\n    vec2 thresh = vec2(1.0/ 30.);\n    vec2 fP = fract(p);\n    vec2 i = smoothstep(fP - smoothness, fP + smoothness, thresh);\n    return saturate(min((1.0 - i.x), (1.0 - i.y)));\n}\n//https://www.shadertoy.com/view/XlcSz2\nfloat CheckerPattern( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y, 2.0 );\n}\n//https://www.shadertoy.com/view/ws3Bzf\nvec4 BiplanarSample( sampler2D sam, in vec3 p, in vec3 n)\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n/////////////////////////////////\n//https://iquilezles.org/articles/distfunctions/\nfloat SDFBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    vec3 v = min(d, 0.);\n    return length(max(d, 0.0)) + max(max(v.x, v.y), v.z);\n}\n// individual scene pieces in separate functions to make them easier to duplicate \nfloat Overhang(vec3 p)\n{\n\treturn SDFBox(p - vec3(-.727,-.031,.0) -  vec3(.168,1.386,.42), \n        vec3(.961,.329,.917));\n}\nfloat Building(vec3 p, inout Objects o)\n{\n    vec3 wsPos = vec3(.0,.0,.0);\n    vec4 a0 = vec4(p, 1.0);\n    vec4 a1 = a0 - vec4(-.727,-.031,.0,.0);\n    vec4 a2 = a1;\n\tvec4 a3 = a2;\n    wsPos = a3.xyz - vec3(.164,.595,-.19);\n    o.Door.scale = vec3(.827,.795,.717);\n    o.Door.p = wsPos;\n    o.Door.dist = min(1., SDFBox(o.Door.p, o.Door.scale)) - BUILDING_ROUND;\n    wsPos = a3.xyz - vec3(.168,.661,-.408);\n    vec4 a4 = a1 - vec4(.168,1.386,.42,.0);\n    wsPos = a4.xyz - vec3(.0,-.493,-.837);\n    o.Building.dist = min(1., SDFBox(wsPos,vec3(1.5, .851, .917)));\n    o.Building.p = wsPos;\n    o.Building.dist = min(o.Building.dist, Overhang(p));\n    wsPos = a4.xyz - vec3(.773,-.901,.773);\n    float column = SDFBox(wsPos, vec3(.042, 0.5, .042)); // left column\n    wsPos = a4.xyz - vec3(-.773,-.901,.773);\n    column = min(column, SDFBox(wsPos,vec3(.042, 0.5,.042))); // right column\n    o.Building.dist = min(o.Building.dist, column) - BUILDING_ROUND;\n\n    float total = min(o.Building.dist, o.Door.dist);\n\n    vec4 a5 = a0 - vec4(.0,-.031,.0,.0);\n\twsPos = a5.xyz - vec3(-.559,1.45,.815);\n    float lowOrnament = SDFBox(wsPos,vec3(.996,.012,.544));\n    o.Ornament.dist = min(o.Ornament.dist, lowOrnament);\n\ttotal = min(total, lowOrnament);\n\twsPos = a5.xyz - vec3(-.559,1.525,.815);\n    float middleOrnament = SDFBox(wsPos,vec3(.996,.012,.544));\n    o.Ornament.dist = min(o.Ornament.dist, middleOrnament);\n\ttotal = min(total, middleOrnament);\n\twsPos = a5.xyz - vec3(-.559,1.6,.815);\n    float topOrnament = SDFBox(wsPos,vec3(.996,.012,.544));\n    o.Ornament.dist = min(o.Ornament.dist, topOrnament);\n    o.Ornament.dist -= 0.001;\n\ttotal = min(total, topOrnament);\n\twsPos = a5.xyz - vec3(-.559,1.032,.815);\n    o.Neon.p = wsPos;\n    o.Neon.dist = min(1., SDFBox(wsPos, vec3(.916,.014,.485)) - 0.005);\n\ttotal = min(total, o.Neon.dist);\n\twsPos = a5.xyz - vec3(-.559, 1.0, 0.819);\n    o.Under.dist = min(1., SDFBox(wsPos, vec3(.885,.035,.446)));\n    o.Under.p = wsPos;\n    total = min(total, o.Under.dist);\n    return total;\n}\n// diagonal domain repetition\nvec2 MirrorDiag( vec2 p, vec2 offset )\n{\n    p -= offset;\n    if( p.x > -p.y )\n        p.xy = -p.yx;\n    p += offset;\n    return p;\n}\nfloat Scene(vec3 p, out Objects o)\n{\n    o.Ornament.dist = 1.; \n    o.Neon.dist = 1.;\n    o.Building.dist = 1.;\n    o.Under.dist = 1.;\n    o.Ground.dist = 1.;\n    o.Wall.dist = 1.;\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tvec4 a0 = vec4(p, 1.0);\n    o.total = 1.;\n\tvec4 a1 = a0 - vec4(-.727,-.031,.0,.0);\n\tvec4 a2 = a1;\n\tvec4 a3 = a2;\n\twsPos = a3.xyz - vec3(.164,.595,-.19);\n\twsPos = a3.xyz - vec3(.168,.661,-.408);\n\tvec4 a4 = a1 - vec4(.168,1.386,.42,.0);\n\twsPos = a4.xyz;\n\n    float groundGrid = GridPattern(p.xz * 4., 0.1) * 0.005 + 0.1;\n\tfloat ground = (dot(a0.xyz - vec3(.0, groundGrid,.0), vec3(.0, 1.0, .0)) * 1.0);\n    o.Ground.dist = min(o.Ground.dist, ground);\n    o.total = min(o.total, o.Ground.dist);\n    float wallGrid = GridPattern(p.xy * 8., 0.05);\n    o.Wall.color = vec3(wallGrid);\n    float wall = SDFBox(wsPos + vec3(0., -0.5, 1.75 - wallGrid * 0.01), vec3(10., 2., 0.01));\n   \n    vec3 buildP = p;\n    buildP.xz = MirrorDiag(buildP.xz, vec2(1., 1.));\n    o.Building.dist = Building(buildP, o);\n\n    o.Wall.dist = min(o.Wall.dist, wall);\n    wall = SDFBox(\n        Rotate(vec3(0., 45., 0.), wsPos + vec3(0., -1., 1.5 - wallGrid * 0.01)), \n        vec3(10., 2., 0.01));\n    o.Wall.dist = min(o.Wall.dist, wall);\n    o.total = min(o.total, o.Wall.dist);\n    o.total = min(o.total, o.Building.dist);\n    o.Building.dist = -max(o.Door.dist, o.Building.dist);\n    \n\treturn o.total;\n}\n// meant to be called when distance is needed but color zones are not.\nfloat Distance(vec3 p)\n{\n    Objects o;\n    return Scene(p, o);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * EPSILON;\n    return normalize( e.xyy * Distance( pos + e.xyy) + \n\t\t\t\t\t  e.yyx * Distance( pos + e.yyx) + \n\t\t\t\t\t  e.yxy * Distance( pos + e.yxy) + \n\t\t\t\t\t  e.xxx * Distance( pos + e.xxx) );\n}\nfloat March(vec3 pos, vec3 dir, float withGlass, out Objects o) \n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MARCH_STEPS; i++) \n    {\n        vec3 p = pos + depth * dir;\n        float dist = Scene(p, o);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= MAX_DIST) break;\n    }\n    return MAX_DIST;\n}\n// https://iquilezles.org/articles/rmshadows\nfloat Shadow(in vec3 ro, in vec3 rd)\n{\n    float mint = 0.02;\n    float tmax = 2.5;\n    float tp = (0.4 - ro.y) / rd.y; \n    tmax = mix(tmax, min( tmax, tp ), step(0., tp));\n\n    float shadow = 1.0;\n    float t = mint;\n    for (int i = 0; i < SHADOW_MARCH_STEPS; i++ )\n    {\n\t\tfloat h = Distance( ro + rd * t);\n        float s = clamp(10.0 * h/t, 0.0, 1.0);\n        shadow = min(shadow, s * s * (3.0 - 2. * s));\n        t += clamp(h, 0.02, 0.2 );\n        if(shadow < 0.004 || t > tmax) break;\n    }\n    shadow = saturate(shadow);\n    return smoothstep(0., 0.2, shadow);\n}\n// SafeNormalize cribbed from \n// https://xibanya.github.io/UnityShaderViewer/Library/BuiltinShaders/CGIncludes/UnityStandardBRDF.html\nvec3 SafeNormalize(vec3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * pow(dp3, -0.5);\n}   \nfloat GetSpecular(vec3 normal, vec3 lightDir, vec3 viewDir, float n)\n{\n    vec3 halfDir = SafeNormalize(lightDir + viewDir);\n    float NdotH = saturate(dot(normal, halfDir));\n    float normTerm = (n + 2.0) * (0.5/PI);\n    float specTerm = pow(NdotH, n);\n    return specTerm * normTerm;\n}\nLight GetLight(vec3 normal, vec3 p, vec3 lightPos, vec3 viewDir)\n{\n    // using a struct for this stuff because I'll be using\n    // some of these values later for other things\n    Light light;\n    light.dir = lightPos;\n    light.nDotL = max(0., dot(light.dir, normal));\n    light.shadow = Shadow(p, light.dir);\n    light.atten = smoothstep(0., 0.1, pow(light.shadow, 5.));\n    light.occlusion = AO(p, normal, 5., 1.5);\n    light.diffuse = light.nDotL * light.atten * light.occlusion;\n    return light;\n}\nvec3 RayDir(float fieldOfView, vec2 size, vec2 fragCoord) \n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n// I started writing this doing something more elaborate for the door\n// now I'm not but I might again so this function stays...\nvec3 DoorColor(inout Objects o, vec3 p, vec3 dir, vec3 normal)\n{\n    o.Door.smoothness = 1.;\n    o.Door.metallic = 1.;\n    return o.Door.color = vec3(1.);\n}\nvec3 InitColor(inout Objects o, vec3 pos, vec3 dir, vec3 normal, float dist)\n{\n    vec3 p = pos + dir * dist;\n    float up = step(0.9, dot(normal, vec3(0., 1., 0.)));\n    o.tex = 1. - BiplanarSample(iChannel2, p * 0.5, normal);\n    float groundGrid = GridPattern(p.xz * 4., 0.05);\n    o.Ground.color = vec3(saturate(groundGrid * 1.5));\n    o.Building.color = mix(vec3(1.), vec3(0.75), o.tex.r) * PINK;\n    o.Ornament.color = pow(BLUE, vec3(2.));\n    o.Neon.color = pow(PINK, vec3(2.));\n    o.Under.color = vec3(0.05);\n    float interiorTex = BiplanarSample(iChannel2, p * 2., normal).r;\n    vec3 doorP = p * 2. + vec3(0., -0.1, 0.);\n    o.Door.color = DoorColor(o, doorP, dir, normal);\n    o.Wall.smoothness = o.Wall.color.r;\n    o.Wall.color = max(vec3(0.9), o.Wall.color);\n\n    vec3 albedo = vec3(0.);\n    albedo = mix(albedo, o.Building.color, step(o.Building.dist, o.total));\n    albedo = mix(albedo, o.Wall.color, step(o.Wall.dist, o.total));\n    albedo = mix(albedo, o.Ground.color, step(o.Ground.dist, o.total));\n    albedo = mix(albedo, o.Under.color, step(o.Under.dist, o.total));\n    albedo = mix(albedo, o.Ornament.color, step(o.Ornament.dist, o.total));\n    albedo = mix(albedo, o.Neon.color, step(o.Neon.dist, o.total));\n    albedo = mix(albedo, o.Door.color, step(o.Door.dist, o.total));\n\n    // other initialization\n    o.Ornament.emission = 0.5;\n    o.Neon.emission = 1.;\n\n    o.Ground.smoothness = groundGrid * max(0.9, o.tex.r);\n    o.Ground.metallic = 0.1;\n    o.Building.smoothness = (1. - o.tex.r) * 0.1;\n    o.Ornament.smoothness = 0.8;\n    o.Neon.smoothness = 1.;\n    o.Under.smoothness = min(0.3, o.tex.r);\n   \n    return albedo;\n}\nfloat GetGlow(float dist, float steps)\n{\n    float glow = 0.;\n    for (float i = 0.; i < steps; i++)\n    {\n        glow += max(0., (0.1 * i) - dist);\n    }\n    return glow +  \n        (1. - max(0., smoothstep(0.001, 0.01, dist - 0.005)));\n}\nvec3 Color(Objects o, vec3 pos, vec3 dir, vec3 normal, float dist)\n{\n    vec3 p = pos + dir * dist;\n    vec3 albedo = InitColor(o, pos, dir, normal, dist);\n\n    vec3 lightDir = vec3(_LightX, _LightY, _LightZ);\n    Light light = GetLight(normal, p, lightDir, -dir);\n    // this is slightly inaccurate, mix would get better results\n    // but whatever, close enough\n    float smoothness = \n        o.Building.smoothness * step(o.Building.dist, o.total) +\n        o.Ground.smoothness * step(o.Ground.dist, o.total) +\n        o.Under.smoothness * step(o.Under.dist, o.total) +\n        o.Ornament.smoothness * step(o.Ornament.dist, o.total) +\n        o.Neon.smoothness * step(o.Neon.dist, o.total) + \n        o.Wall.smoothness * step(o.Wall.dist, o.total);\n    ;\n    smoothness = mix(smoothness, o.Door.smoothness, step(o.Door.dist, o.total));\n\n    float specTerm = GetSpecular(normal, light.dir, dir, max(0., smoothness));\n    float spec = smoothstep(0.3, 0.7, specTerm);\n\n    float fogGamma = _FogGamma;\n    float fogHeight = 1.5 * smoothstep(-0.5, 2.2, fogGamma);\n    float fogDist = 1. - pow(InvLerp(MAX_DIST * 0.2, MAX_DIST * 0.01, dist), fogGamma);\n    float fogFactor = fogDist * ( 1. - pow(InvLerp(0., fogHeight, p.y), fogGamma));\n   \n    vec3 lightColor = vec3(_LightR, _LightG, _LightB);\n    vec3 shadowColor = SHADOW_COLOR;\n    shadowColor = min(shadowColor, lightColor);\n    vec3 diffuse = mix(shadowColor, lightColor, max(0., light.diffuse));\n    \n    float isEmissive = saturate(\n        step(o.Neon.dist, o.total) * o.Neon.emission + \n        step(o.Ornament.dist, o.total) * o.Ornament.emission +\n        step(o.Door.dist, o.total) * o.Door.emission\n    );\n    // more emissive = less affected by light\n    diffuse = mix(diffuse, vec3(1.), isEmissive);\n    // I already know only the ground or door could be \n    // metallic which is why I'm only checking against those\n    float metallic = o.Door.metallic * step(o.Door.dist, o.total);\n    metallic = mix(metallic, o.Ground.metallic, step(o.Ground.dist, o.total));\n    vec3 specCube = texture(iChannel0, dir).rgb;\n    // get luminosity of specCube cuz I don't want orange speculars\n    float specLum = (specCube.r + specCube.g + specCube.b) / 3.;\n    // boost specColor because I want those shinies to be real shiny\n    specLum *= 7.;\n    vec3 specColor = specLum * lightColor;\n    albedo = mix(albedo, specColor, metallic);\n    vec3 col = albedo * diffuse + spec * specColor;\n\n    // using the neon colors as fog colors to help suggest some sort of scattering\n    vec3 fogColor = mix(o.Ornament.color, o.Neon.color, saturate(dot(p.y, 1.25)));\n\n    // FRESNEL\n    float up = step(0.9, dot(normal, vec3(0., 1., 0.)));\n    float fresnelTerm = 1. - max(0., dot(normal, -dir));\n    fresnelTerm = smoothstep(0.3, 0.5, fresnelTerm) * max(0.1, (1. - up)) * max(0.1, smoothness);\n    col += mix(albedo * shadowColor, albedo * fogColor, light.diffuse) * fresnelTerm * specLum;\n    \n    // fog after fresnel highlight\n    col = mix(col, fogColor, fogFactor);\n    \n    // glow after fog to make a sort of scattering effect\n    float neonGlow = mix(\n        GetGlow(o.Neon.dist, 4.),\n        pow(GetGlow(o.Neon.dist, 8.) * 0.5, fogGamma), \n        fogFactor\n    );\n    float lum = (diffuse.r + diffuse.g + diffuse.b) / 3.;\n    neonGlow *= max(0.5, (1. - lum));\n    vec3 neonGlowColor = mix(o.Neon.color, fogColor, fogFactor);\n    col += neonGlowColor * neonGlow * o.Neon.emission; \n    float ornGlow = mix(\n        GetGlow(o.Ornament.dist, 4.5), \n        pow(GetGlow(o.Ornament.dist, 9.) * 0.5, fogGamma), \n        fogFactor\n    );\n    ornGlow *= max(0.25, (1. - lum));\n    float ornFlick = Flicker(_FlickerPhase, _FlickerRate);\n    ornFlick = smoothstep(0.0, 0.25, ornFlick);\n    ornGlow *= mix(0.75, 1., ornFlick);   \n   \n    vec3 ornGlowColor = mix(pow(o.Ornament.color, vec3(2.)), fogColor, fogFactor);\n    col += ornGlowColor * ornGlow * o.Ornament.emission;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rot = vec2(_XRot, _YRot);\n    if( iMouse.z>0.0 ) rot += ((iMouse.yx/iResolution.yx) * 2. - 1.) * vec2(4., 16.);\n\tvec3 dir = RayDir(_FOV, iResolution.xy, fragCoord);\n    dir *= XRotationMatrix(rot.x);\n    dir = dir * YRotationMatrix(rot.y);\n    vec3 pos = vec3(_XPos, _YPos, _ZPos);\n    Objects o;\n    float dist = March(pos, dir, 0., o);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 diffuse = vec3(0.);\n    if (dist > MAX_DIST - EPSILON) \n    {\n        float bgGradient = InvLerp(0.5, 1., uv.y);\n        diffuse = mix(\n            pow(BLUE, vec3(2.)), \n            pow(PINK, vec3(3.)), \n            bgGradient\n        );\n    }\n    else\n    {\n        vec3 p = pos + dist * dir;\n        vec3 normal = GetNormal(p);\n        diffuse = Color(o, pos, dir, normal, dist);\n    }\n    // final color tweak\n    diffuse = pow(diffuse, vec3(1.25));\n    fragColor = vec4(diffuse, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}