{
    "Shader": {
        "info": {
            "date": "1586017998",
            "description": "lada on weird copper planet...\nASDW for driving +/- for zoom\n...also try other worlds (uncomment in Common-Tab)",
            "flags": 48,
            "hasliked": 0,
            "id": "tsjcRz",
            "likes": 50,
            "name": "vodka runner copperworld",
            "published": 3,
            "tags": [
                "simulation",
                "galaxy",
                "universe",
                "car"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 1434
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// vodka runner (modification of \"whiskey runner\" with lada niva on weird planet)\n\n// ASDW for driving +/- for zoom\n\n\n//uncomment this if you want proper materials and lighting...\n//...might not compile well in windows (...the actual reason for the weird copper style)\n\n//#define ENABLE_MATERIALS \n\n\n#ifdef ENABLE_MATERIALS \n#define SHADOW\n#endif\n#define SCRATCHES\n#define RENDER_GLASS\n//#define RENDERED_REFECTIONS\n//#define RENDER_BBOX\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel0\n#define PhysTex iChannel1\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\nvec4 myRandInterpol(vec2 uv)\n{\n    //#define COARSE_TERRAIN\n    #ifdef COARSE_TERRAIN\n    return textureLod(RandTex,uv,0.);\n    #endif\n    uv=fract(uv);\n    ivec2 c0 = ivec2(fract(uv        )*256.);\n    ivec2 c1 = ivec2(fract(uv+1./256.)*256.);\n    vec2  f = fract(uv*256.);\n    vec4 c00=texelFetch(RandTex,ivec2(c0.x,c0.y),0);\n    vec4 c10=texelFetch(RandTex,ivec2(c1.x,c0.y),0);\n    vec4 c01=texelFetch(RandTex,ivec2(c0.x,c1.y),0);\n    vec4 c11=texelFetch(RandTex,ivec2(c1.x,c1.y),0);\n    //f=mix(f,.5-.5*cos(f*PI2*.5),.5);\n    f=.5-.5*cos(f*PI2*.5);\n    return mix(mix(c00,c10,f.x),mix(c01,c11,f.x),f.y);\n}\n\nconst vec3 terrbbpos=vec3(0,.0,.0);\n#ifdef CHAIN_WORLD\nconst vec3 terrbbsize=vec3(260.,260.,60.)*2.+50.;\n#else\nconst vec3 terrbbsize=vec3(0);\n#endif\n\nfloat distTerr(vec3 p)\n{\n    vec3 p2=p*.0001;\n    vec4 noise = vec4(0);\n    float sc;\n    sc=1.; \n    for(int i=0;i<3;i++)\n    {\n        noise += (myRandInterpol(p2.xy*sc)-.5)/sc;\n        noise += (myRandInterpol(p2.yz*sc)-.5)/sc;\n        noise += (myRandInterpol(p2.zx*sc)-.5)/sc;\n        sc*=2.;\n    }\n    noise += abs(myRandInterpol(p2.xy*sc*5.)-.5)/sc/5.;\n    noise += abs(myRandInterpol(p2.yz*sc*5.)-.5)/sc/5.;\n    noise += abs(myRandInterpol(p2.zx*sc*5.)-.5)/sc/5.;\n    \n    #if   defined(CHAIN_WORLD)\n    return distChainCircle(p+noise.xyz*10.,200., 6, 60.,20.,20.);\n    #elif defined(TORUS2_WORLD)\n    return min(distTorus(p+noise.xyz*10.,100.,40.),distTorus((p-vec3(100,0,0)).zxy+noise.xyz*10.,100.,40.));\n    #elif defined(TORUS_WORLD)\n    return distTorus(p+noise.xyz*10.,100.,40.);\n    #elif defined(HOLLOW_SPHERE_WORLD)\n    return -length(p+noise.xyz*10.)+100.;\n    #elif defined(SPHERE_WORLD)\n    return length(p+noise.xyz*10.)-60.;\n    #elif defined(PLANE_WORLD)\n    return dot(p+noise.xyz*10.,normalize(vec3(1,.5,.7)));\n    #elif defined(HOLLOW_TORUS)\n    return -distTorus(p+noise.xyz*10.,100.,40.);\n    #else\n    return p.z+noise.x;\n    #endif\n}\n\n/// my own version of a looped getGrad()\nvec3 getGradTerr4loop(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*distTerr(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\n// straight fwd gradient - windows dont like this... wtf...\nvec3 getGradTerr0(vec3 p,float delta)\n{\n    vec3 d=vec3(delta*.5,0,0);\n    return vec3(\n        distTerr(p+d.xyz)-distTerr(p-d.xyz),\n        distTerr(p+d.zxy)-distTerr(p-d.zxy),\n        distTerr(p+d.yzx)-distTerr(p-d.yzx)\n        )/delta;\n}\n\n// cheap tetrahedral gradient\nvec3 getGradTerrTetr(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    for(int i=min(0,iFrame);i<4;i++) { vec3 v=vec3((i&1)*2-1,(i/2)*2-1,1); vec3 d=v.xxz*v.zyy;  g+=d*distTerr(p+d*delta*.289); }\n    return g/(delta*1.732);\n}\n\n// full straight fwd grad as loop\nvec3 getGradTerr6loop(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    vec3 d=vec3(delta*.5,0,0);\n    for(int i=min(0,iFrame);i<6;i++) { g+=d*distTerr(p+d); d=-d.zxy; }\n    return g/(.5*delta*delta);\n}\n\nvec3 getGradTerr(vec3 p,float delta)\n{\n    return getGradTerr6loop(p,delta);\n}\n\n// transform to car coords\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    ///offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p-translate*pos,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\n// transform to world coords\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvec3 camTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(6,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvoid calcWheelOffsets(float clmin, float clmax)\n{\n    vec3 wp;\n    wp=carTrafoInv(WheelPosFL*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsFL = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosFR*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsFR = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosRL*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsRL = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosRR*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsRR = clamp(-distTerr(wp),clmin,clmax);\n    //hTerr(wp)-wp.z\n}\n\n\n#define BG 0.\n#define CARBODY 1.\n#define GUMMI 2.\n#define RIM 3.\n#define FLOOR 4.\n#define CHROME 5.\n#define INTERIOR 6.\n#define CHASSIS 7.\n#define BLACKPLASTIC 8.\n#define GLASS 9.\n#define REDGLASS 10.\n#define ORANGEGLASS 11.\n#define DBG_GREEN 12.\n#define DBG_RED 13.\n\n#ifdef ENABLE_MATERIALS\n//#define SET_PREV_MAT(x) mat=(abs(d-d_mat)>.0001)?(x):mat; d_mat=d;\n//#define SET_PREV_MAT(x) mat=mix(mat,x,step(.0001,abs(d-d_mat))); d_mat=d;\n//#define SET_PREV_MAT(x) mat+=step(.0001,abs(d-d_mat))*(-mat+x); d_mat=d;\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n#else\n#define SET_PREV_MAT(x) \n#endif\n\nstruct Material{\n    vec3 col;\n    float refl;\n    float scratchy;\n    vec2  scratchScale;\n};\n\n//#define MAT_CARBODY    Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_BG         Material(vec3(-1,-1,-1),       -1.,   0.0, vec2(1,.01))\n#define MAT_CARBODY    Material(vec3(.32, .4, .25)+.05,    -1.,   .6, vec2(1,.01))\n//#define MAT_CARBODY    Material(vec3(.85),    -1.,   .6, vec2(1,.01))\n//#define MAT_CARBODY    Material(vec3(.5),    1.,   1., vec2(1,.03))\n#define MAT_GUMMI      Material(vec3(.25),    -0.35, 1.0, vec2(1,.1)*.3)\n#define MAT_BLACKPLASTIC Material(vec3(.13),    -.9, 1.0, vec2(1,.1)*.3)\n#define MAT_RIM        Material(vec3(.3),          -1.,   0.6, vec2(1,.01))\n#define MAT_FLOOR      Material(vec3(.36,.35,.34)*1.2,            -0.2, 0.0, vec2(1,.01))\n#define MAT_CHROME     Material(vec3(.8),              1.,   0.1, vec2(1,.1))\n#define MAT_INTERIOR   Material(vec3(.9,.7,.5)*.3,    -0.0,  0.0, vec2(1,.01))\n#define MAT_REDGLASS   Material(vec3(1,0,0),          -1.,   0.6, vec2(1,.01))\n#define MAT_ORANGEGLASS Material(vec3(1,.5,0),          -1.,   0.6, vec2(1,.01))\n#define MAT_GLASS      Material(vec3(1),              -1.,   0.6, vec2(1,.01))\n#define MAT_CHASSIS    Material(vec3(.45),              1.,  1.0, vec2(1,.01)*.5)\n#define MAT_DBG_GREEN  Material(vec3(0,1,0), -1.,  0.0, vec2(1,.01))\n#define MAT_DBG_RED    Material(vec3(1,0,0), -1.,  0.0, vec2(1,.01))\n\n#define USE_MTL_ARRAY \n#ifdef USE_MTL_ARRAY\nconst Material mat[14] = Material[] (\nMAT_BG        ,\nMAT_CARBODY   ,\nMAT_GUMMI     ,\nMAT_RIM       ,\nMAT_FLOOR     ,\nMAT_CHROME    ,\nMAT_INTERIOR  ,\nMAT_CHASSIS   ,\nMAT_BLACKPLASTIC ,\nMAT_GLASS     ,\nMAT_REDGLASS  ,\nMAT_ORANGEGLASS ,\nMAT_DBG_GREEN ,\nMAT_DBG_RED\n);\nMaterial getMaterial(float mtl) { return mat[int(mtl)]; }\n#else\nMaterial getMaterial(float mtl)\n{\n    if(mtl==BG)           return MAT_BG        ;\n    if(mtl==CARBODY)      return MAT_CARBODY   ;\n    if(mtl==BLACKPLASTIC) return MAT_BLACKPLASTIC ;\n    if(mtl==GUMMI)        return MAT_GUMMI     ;\n    if(mtl==RIM)          return MAT_RIM       ;\n    if(mtl==FLOOR)        return MAT_FLOOR     ;\n    if(mtl==CHROME)       return MAT_CHROME    ;\n    if(mtl==INTERIOR)     return MAT_INTERIOR  ;\n    if(mtl==GLASS)        return MAT_GLASS     ;\n    if(mtl==REDGLASS)     return MAT_REDGLASS  ;\n    if(mtl==ORANGEGLASS)  return MAT_ORANGEGLASS ;\n    if(mtl==CHASSIS)      return MAT_CHASSIS   ;\n    if(mtl==DBG_GREEN)    return MAT_DBG_GREEN ;\n    if(mtl==DBG_RED)      return MAT_DBG_RED   ;\n}\n#endif\n\n#define DESERT FLOOR\n#define TIRE GUMMI\n#define GRILL CHROME\n\nbool enable_glass=true;\n\n#ifndef RandTex \n#define RandTex iChannel1\n#endif\n\nvec4 rand3d(vec3 uv)\n{\n    float pz=uv.z*256.;\n    float z=floor(pz);\n    vec2 uv1=uv.xy+z*vec2(17,31)/256.;\n    vec2 uv2=uv1+vec2(17,31)/256.;\n    return mix(textureLod(RandTex,uv1,0.),textureLod(RandTex,uv2,0.),pz-z);\n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\nvoid getTriSubDiv(vec3 pos, inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    mat3 m = mat3((p2-p1)*.5,(p3-p1)*.5,p1);\n    vec3 q = inverse(m)*pos;\n    q/=q.z;\n    vec3 qf=floor(q);\n    float f=step(1.,q.x-qf.x+q.y-qf.y);\n    p1 = m*vec3( qf.xy+f,            1 );\n    p2 = m*vec3( qf.xy+vec2(1.-f,f), 1 );\n    p3 = m*vec3( qf.xy+vec2(f,1.-f), 1 );\n    p1=normalize(p1);\n    p2=normalize(p2);\n    p3=normalize(p3);\n}\n\nvoid getOctaTri(vec3 dir, inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    vec3 s=sign(dir); p1=vec3(s.x,0,0); p2=vec3(0,s.y,0); p3=vec3(0,0,s.z);\n    if(s.x*s.y*s.z>0.) { s=p2;p2=p3;p3=s; }\n}\n\nvec3 galaxy(vec3 dir, vec3 p1, vec3 p2, vec3 p3, vec2 offs, float rot, float quench, float size)\n{\n    vec3 pm=normalize(p1+p2+p3);\n    vec3 bx=normalize(p2-p1);\n    vec3 bz=normalize(cross(p2-p1,p3-p1));\n    vec3 by=normalize(cross(bz,bx));\n    //vec3 by=normalize(p3-(p1+p2)*.5);\n    dir=(dir-pm)*mat3(bx,by,bz);\n    float lavg=sqrt(length(cross(p2-p1,p3-p1)));\n    dir.xy-=offs*lavg;\n    float ang=atan(dir.y,dir.x);\n    dir=rotZ(rot,dir);\n    dir*=vec3(1./(1.-quench),1,1);\n    float l=length(dir.xy);\n    lavg*=size;\n    float m=(1.-smoothstep(.0,.2*lavg,l))*(exp2(-(l/lavg))+.5*abs(cos(l/lavg*60.+ang)));\n    // fade out smaller tha 1 pixel galaxies\n    m*=min(.35/fwidth(l/(.2*lavg)),1.);\n    return vec3(m);\n}\n\nvec3 mySpaceEnv(vec3 dir)\n{\n    vec3 p1,p2,p3;\n    vec3 col=vec3(0);\n    dir=(normalize(dir));\n    vec3 bx=normalize(vec3(1,2,3)), by=normalize(bx.yxz*vec3(-1,1,0)), bz=cross(bx,by);\n    mat3 m=mat3(bx,by,bz);\n    getOctaTri(dir,p1,p2,p3);\n    vec3 c = normalize((p1+p2+p3)), cp=vec3(0);\n    vec2 offs; float rot; float quench=0.;\n    vec3 br=vec3(1.);\n    float size=1.;\n    vec3 allbr=vec3(1.);\n    for(int i=0;i<10;i++)\n    {\n        c = normalize(p1+p2+p3);\n        vec3 rc=m*c;\n        if (abs(rc.z)<abs(rc.y) || abs(rc.z)<abs(rc.x)) rc=rc.zxy;\n        if (abs(rc.z)<abs(rc.y) || abs(rc.z)<abs(rc.x)) rc=rc.zxy;\n        vec2 ruv=(rc.xy/rc.z*.5+.5)*7.;\n        vec4 r=(textureLod(RandTex,ruv,0.));\n        vec4 r2=(textureLod(RandTex,ruv+.3,0.));\n        offs=(r.xy-.5)*.3;\n        rot=r.y*PI2;\n        quench=r.z;\n        size=1.3*r.w;\n        allbr=br*(r2.xyz*.5+1.);\n        if(length(cp-c)>.0001) \n            col+=allbr*galaxy(dir,p1,p2,p3,offs,rot,quench,size);\n        getTriSubDiv(dir, p1, p2, p3);\n        cp=c;\n        br*=.97*vec3(.9,.86,.82); // decay with distance and red shift for more distant galaxies\n    }\n    col+=allbr*galaxy(dir,p1,p2,p3,offs,rot,quench,size);\n    return col;\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n    #ifndef ENABLE_MATERIALS\n        vec3 light=normalize(getLightDir());\n        float d=max(0.,dot(light,dir));\n        vec3 bx=normalize(vec3(light.yx*vec2(1,-1),0));\n        vec3 by=normalize(cross(bx,light));\n        vec2 d2=vec2(dot(dir,by),dot(dir,bx));\n        float ang=atan(d2.y,d2.x);\n        vec4 r=textureLod(RandTex,vec2(ang,length(d2)*2.),0.);\n        float ampl=mix((.7+.3*sin(ang+24.*length(d2)))*(r.x*.4+.8),1.,exp2(-dot(d2,d2)*40.));\n        return vec4(\n            vec3(1,.8,.5)*ampl*1.2*(4.*pow(d,20.)+1.*pow(d,4.))+mySpaceEnv(dir)\n            ,1);\n    #endif\n    vec3 sun = normalize(getLightDir());\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\nfloat distTire(vec3 p, float r)\n{\n    p=abs(p);\n    float d=1000.;\n    d=min(d,length(p)-r);\n    float ang = atan(p.z,p.y);\n    float l=length(p.zy);\n    p.x+=cos(ang*100.)*.005*smoothstep(.87*r,1.*r,l);\n    d=max(d,distTorus(p.yzx+vec3(0,0,.03),r*.78,r*.28));\n    d=max(d,-l+r*.61);\n    float dx=.04;\n    float xfr=mod(p.x,dx);\n    float x=p.x-xfr+dx*.5;\n    d=max(d,-distTorus(p.yzx-vec3(0,0,x),sqrt(r*r-x*x),.01));\n    return d;\n}\n\n\nfloat distRim(vec3 p, float r)\n{\n    r*=.6;\n    vec3 p0=p;\n    p.x=abs(p.x);\n    //p.yz=(p.y>p.z)?p.zy:p.yz; // only first 1/8 segment\n    p=p.zxy;\n    float d=1000.;\n    d=min(d,sdRoundedCylinder(p,r,.01,.6*r));\n    p-=vec3(0,.6*r,0);\n    d=-smin(-d,sdRoundedCylinder(p,.97*r,.01,.6*r),.015);\n    d=-smin(-d,sdRoundedCylinder(p,.89*r,.01,.8*r),.015);\n    float d_i=sdRoundedCylinder(p,.77*r,.01,1.9*r);\n    d=-smin(-d,d_i,.015);\n    \n    float d2=length(p0-vec3(-r*.6,0,0))-r*1.05;\n    d2=max(d2,d_i);\n    d2=-smin(-d2,sdRoundedCylinder(p,.4*r,.01,.8*r),.1);\n    d2=abs(d2)-.005;\n    d2=max(d2,-p0.x);\n\n    float mang,ang;\n    float ang0 = atan(p.z,p.x);\n    float dang=PI2/5.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n\n    d2=-smin(-d2,(length(p.xz-.95*r*cos(ang-vec2(0,1.57)))-.25*r),.01);\n    d=min(d,d2);\n    dang=PI2/5.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    d=min(d,max(abs(p.y+.6*r)-.22*r,(length(p.xz-.3*r*cos(ang-vec2(0,1.57)))-.05*r)));\n    d=min(d,sdRoundedCylinder(p-vec3(0,-.23,0),.1*r,.01,.25));\n    float l=length(p0.zx);\n    d=min(d,sdRoundedCylinder(p0.zxy-vec3(0,-.06,0),.7*r,.02,.05-.015*fermi((length(p.xz)-.6*r)/.003)));\n    return d;\n}\n\nconst vec3 bbpos=vec3(0,.0,.0);\nconst vec3 bbsize=vec3(1.68,3.74,1.64)+.2;\nconst vec3 bbpos1=vec3(0,.04,-.231);\nconst vec3 bbsize1=vec3(ALLW*1.08,3.68,1.23);\nconst vec3 bbpos2=vec3(0,.23,.33);\nconst vec3 bbsize2=vec3(ALLW*.83,1.25,.7);\n\nfloat rille2(float d, float w)\n{ \n    return w*exp2(-d*d*2./w/w);\n}\nfloat rille(float d, float w)\n{\n    ///// gauss\n    //return w*exp2(-d*d*2./w/w);\n    ///// exp\n    return w*exp2(-abs(d)*1.44/w);\n    ///// linear\n    //return max(abs(d)-w,0.);\n}\n\n#ifdef USE_SIMDATA\n#define SteerAng (texelFetch(iChannel1,ivec2(4,0),0).x)\n#define WheelRot (texelFetch(iChannel1,ivec2(5,0),0))\n#define CamDistFact (texelFetch(iChannel1,ivec2(4,0),0).y)\n#else\nuniform float SteerAng;\nconst vec4 WheelRot=vec4(0);\n#define CamDistFact 1.0\n#endif\n\n\n#ifdef ENABLE_MATERIALS \nvec2 distCarM(vec3 p)   \n#else\nfloat distCar(vec3 p)   \n#endif\n{\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),.023));\n    float d=100000.,d2;\n    vec3 p00=p;\n    p.x=abs(p.x);\n    vec3 p0=p;\n    vec3 psq=p*p;\n\n    #ifdef ENABLE_MATERIALS \n    float d_mat=1001., mat=-1.;\n    #endif\n    SET_PREV_MAT(BG);\n    \n//##IMG##ENCLZ:44aF7oGGzaDom4DtmI3sgbfhgInpu7XikaDulqDgsIPjgIHsgKPgpIPriJDinJnnqJbgpbrlgYDimbjZoOKmnsKx7buf4biE74m24K+A4ayI6oq86oKM6Y+d6KK+xZnplKvssq3qnL7ui5fmqaflvbnkqYfrr6ripL/llL7lm4bnmJXhoafhkbjmgozmmI7orLbmhKTrmpbYpuyejMus4KSu4Z6G4KKs2KvuiJjqg4foi4nilI3sv6runaDup67sp6PHqu6LhuSYpdGQ5KqZ7ImM6qOF4LuC5Lip4oOB5Jyd5ZGC7piD5JGL4rCD7ImF5J2L4Z+Z7ouJ5ZSI7KeD5JSG6ruJ47mI7K+V3L7ulLbkqYbjiYLomYXkkZLojYXkqYDklr7iiY7lho7gtIfSiui8iOS6vOyTme6rhuSbgOSdmeuviOeKhuqPiuSKjeKPhuOFgeSDjuWhi+q4hu6ypO2ioO2ikOi2rOmli+2FguSnhOidmuOiieasp+GEpeKTpOeeneGyieKdouKjmuGxruGEmOCjgeeNmeGhquKojeCop+iKouWUmOq4stSV7KqL7K2V7bmQ5o6S45eH44+666SB5rCozJrhlJPigYrskJvjmLDhsZjqhaDtgZDoqY7hs5jkh4Xvp5XhpJvmma/snanvh5viqbbmvLLpkKzqn4vioZLlgpXIuOqxoOSQhu+TreyUk+m1iuqJge6ErO6riuSOjuuNg+S+qeK0jtKO4bWc6I6X4LmU74Kb45qj4Y6t5YOg6YKI54yS1Kjor7XouIrsmJblpbLnvZzpurbll7rrqr7pkLjrt47ivJrvq5boqZXgt6HkqoHkj4TigovouJrugaHqp6Hsk5HsvIPkqZ3tr4PhkLTtm6HjioHtnYblgZLgo73kpJvrrrvth6Hqp4TklJ7jvYDpp6vhh4bnoZvomI/hj43kp7rjjKrnsZfim47th4njpZLtu73iqKDjuLvthKLnp4nmkaHhsaPok4Xigonrr5ruuL/mjaLjppDvgrjqsqLrm5jhl4boibrklIngqrjtgKThtYTvg5rinK3qmLDvgovqi6rroZLsqLHsgqPtkYPrlY/lgZLroYbuvrvimYPpqJzprJzskLLmoKnhkYTjnKTjrpDhkofqsaHkq7Xjrq/onrrprLLoqprhsITknqDgrLzpurfiqIbmgJAK7qeA5IS3xIPmjIjulIjovKbno7bivILujLjjiIjoi6Lvqprko6PqnqLjqajmuqTpi5HphIzql5DlkJ7ouabqqbThk4zpiKjorJ3pq6Pgs5zinozpgrnsiIvgrKPskKnhkY/thJTlhJzqmKHooKHilIzGqOGSiOS/keiCnuOAgu6WqOKwi+ipk+KSlOK8rOmAnu6kouiVguWjguO9guKPtOKmiOiWuOuiiuGMhuyAiOSwpeC7geqjpOKinueJie2Jtc6k4qeq5rKT6pOa7riM5rKm5Yim4pSj5omS5qmL6ImB6aOC4amk6oq275W44oKR7oO054mH5ION4rCb7oen5KOk46mG7IqG7bin7pqX5LSu4p6d45WQ7o2U6biJ6bCA4Y6ny4DjlpDqro/thqjppK/Lp+yxseO9gOCihOyIke6wguKgvOG+hO+UuO+Jquq3gOW7rOOMhe+nsNC36qGC6pqy4LOh64iw4rqK4LOD5amP5r+L4ouh5Iqy6LKr5KOi4ois6Ka87ZWI6ZOA6IeT5IS35KGs4qW645ST5pih5JuM44m855iU6reD64KH4KOS4YKc5Yqz6qu76quk5pWC6qeh6par4beM5pin4YOn56Kz57SC4aay4rCn4oeFw5DQuOuyqeixkOKkg9KQ4YuO6qqX64Oi7bqO4rew4K2K67Cja+Oth+WGjOWEteSsouuhteO1qOWHtOqKnuyeku+RlM6L7YW06rix7JGA46Gz44aK7oqQ4LSA6oeq66Oc6rKO5r6w5rC27IeV6J6R4ZSC5Yue3pXis7nliaLjpIvnp77kh53guKLilaPrnIvmno7Hhui0o+acjuK1mueene6Cn+Sao+ShveGzmOeKmeiTsuaBuOOvpuW7i+SgsOWQge6Qr+O5o+G0reOdlO2YtO2egOm1p+eSlueAgO6ap+acgMeb5Kay6ZGI4KK546y34LCC57CL7oCo6qWC6Kq34qKo5Lm25pK46pKc4pij45ai4ru945qF5Yap67SU7q6/7qe247WG5oms7pCP7YWD4qeV76OM772v4q2y5Jiw5JuJ4r2K4auF4ZCjbe2iiOSXqO6IiOKmkOeEheGTquK6guiglOmjoeSQhuCyoMiq4ZOw4bST7YyI5ZCQ5IGc6LKy74iy7Yag46m04bCJ5ICo75Og4Y+K56u04YKK6JeC64iJ4KCn6amD67WP5LSh6oKC6JmK6a6Z4oOQ4r2M6YWI4aiW5Kij7LG65L2S7qi15YGg6LqC5IWT5oS+5KKm5IGi64ym6pqS46Sj4bGx4YuA4bib6YiC7a+P4KKw552I7IeU57Gm7bm04YeL64GG4aqp4ZSq6o+w5Ji774aw6Lqg65C66rGR7Yuy6JuG5aCA4Z+g4Z6j4KKI44WG4qOE4bah7oOY4KyD7oKB4Y6H7IOk6I+h6ZK75JmS6LSZ5KW55aSA7LGn6pqi6KSh7Jm65Yi46aC47IC67I6g5KSs6IO475aC6I+26YSL7oWT7YKA6JCv7ICx6pC726jhhKflr7Dnoq3jg7zqlZLvh5Pgr4bjgaLplLXtoITkipLtpKTon7Dou4TqoqLhi5LooLrthqLlgITqlJDhnozkn5bnioLigpTvspLhhYbms5bHieG9m+eSiOqiouSIl+iBnuiYgNiY54Ko5oOo5oaB6KO14r6C6JCO4LeQ74SI5J2456y97oOF44SQy4TnoZPhh73hhbrso4DhjIXpiJjorLDmsozsjLHjiqrpoKLqnKHqopLjmoLvso/kk7jrmL/svbTuiojnj5TmoaHuhqHqpKDto4LGmOyKkeCgqOmwlOqDsuyqg+ylgue1reajtuafge+Houm0huCoj0XtspbsiojmiL3qg7LhiZLsorrknITmobzSqeiAm9ek5rCP6KeW6KSH5aWF4ZuK7Y2I5qWy5ae6442E4bKB7LuB6aKR5LqC65CR44+S46CX6KW45a2N7KWi4Kqr6LCO4KO55qWj7oip47CM7oCA562j6pSB7J6w75C64bab5Kad4LSJ5oGh4rKA45ep7JGB64Cs5Lmq6aCe6Iiq6JWa5qeY44SF7bWE44ej65SO5Y6B7pCzyoLmsIrgrrDjhY/kirjphIzjg5TqsoXtqJPEleSgkeCqqeiVguKrrOaqgOeHhu+gpeKGp+qcgOOgpuquhuWhksKI74qV5JmS45CK76em7ZWJ77GM4Lmk44Kd24LpgIzskprooJbogq3olrnjiKjklI/lqJXmhabmtpXqjZvimbrpmYHsoJHks5jpmq7hl4DohIXlh7jjjqfqm47poqnkiYrqmKPmlZvin6DrkJbpn5Toop7jh6npnoTjhLTjiLXkkZXtmIDpsJbnhrDtsJ/mgojjiYbmhonhuoTlg6TgsqvuiZjli6DlnIfKve2Mi+Sgtuq0oeGKtOi9rOOVieiNgOmhs+qogOOVluqnleGdiOqZkOG4oeyEvMik6paI4piY5qCk6LCg7pyQ7oOQ7aqS5IWOHuqsteeare2XuOGojeSHt+iUh+yhle6rvOWeouKmoOK/nOidv+aTlOmAnMuX7ZOF4LSG7ZCy6JuU5aSkzJDquZHtp4jnpZXmgIrrhqjrh5jliI3mhbPWheK8ne6GqOWloOWFkeCspuGMgua2k+ShmeKqseCgkuuCk+S0guS+uuKIgOeQmuiEgOKJouGBjui0pOKGpumomOiPuOaQkeSEoiPho7njkoPomJvhvqPkiI3omqfstLXDmOG9iOeCquCki+aduOOWo+aAu+iqmu+BseSlgO2chuyQkO2ynuaGsuSUiO6mh8SF5JKyy4zqrKXjqZ3olo3srbjkgZfui4jooZbHou2Pp+uxj+mxku+QpOulpum8leGInOqUhOWktuGFrOKxhuu7g+ONveGEle+RjOyfkcSB4a6q6qG9ybLvmp/og5/lvILolK3mpaLjgJXmh4DmlI7kjaDntJHoiZDjurvjk7runqLploznvIDroLDsjJnmpafon6Toiqbjj7TiiY/jn6Lln4TmgpLUge+oteuSsO2bkuSEs+2qh+S9geOoi+uAh+CohOewrtSC6YuI64eZ776BxpTji4bli5rnjL3lgYLssaDjoofmmZvgoZPjo6jos4nsk73rlbnktYrntLDokL7vk6PgrIjlh6PjqInjuqjTk+2luOiuhuq5gOCmreeHhOSnhuqintSf5paR5qaX4pO94rmC6Z2y4KqE5ay645Sl6amZ46CM4YCg6bCK5LOE6oaB46iL44qX6oej76qyxovpk7LgrrrnmJvjqajinZDlq4fmoqLuuIvtj4bkt4/um5TgrKLqorDqn5LllJ/krKrqgbHlioHUpu+hteioju+Dr+mLhuqgkem+remEn+mKmeOtl+SVvOiWleaHq+yGou+hju+JpNKE4qae4L2J6ri445i14a+U4K6e6p224KKj6KO9472Y5a2r5bqZ5rmp6Ja47Kqe7rm36LKe6Yew5aSN6oqg46SN4ZCE5IC+6pm+6ISs4puU56CP7bKO6Lyz7Kak7KSl6IOx4rmI74mM7qmq4pOB5KeC66a74oup7o2N4Km46J2AybrknYLRnu+Pjei/j+CgoOujkOm6hOypuuKSjuyKluOsiO2sqe6yhuyKouKtkuGvmeGoneaRreu5jeSDs96D7pSr4ZGA56GQ55ar6qq376+H5omI66SS5YqS5KWB47uA4omg74OB6Kih7IK105DgsJrjo5Dtj7/GgOaKou6VqeS+huqmvuSyjOyCvu+hhue9neWlluiSgeiNi+KAsuqwm+WkvuKor+6RnOG/v+OHv+Wkl++uqOG/pemmo+i7leqgoeKfiOeOseWYp+SFluaVg+OZn+iKluO8seWZhOSXi+WRheGgguKBluKVosiT5oGW4pKD5IOL74+75Yuh6amU6Yig55KW5LG26J2M4o2m5LG95pWY47aV5qCI6IKt5YKn5LGb6Y6o4Z2g5KiW7YWI5pOH5KCc7Jqy44uB4YCe7oGl44qw77C+6IGb5I6D67G+5ZWu44OB6rG/44qO5JiF4oGW7pOR4oaD76Wt6JeX5IOw75CC64mQ6Iim46Gp5out44CL5pCV5omI5JuH5IKG55mM46WA6rSg6oeM4oKj6oiv4Zqu5JWG46G65JOy47qA74ii6IKy55yA6qylyqvjpIHrmKTtiaTik5HjmInogafntInhg4DhiJDugIPpoIDos5jhhI7ooL7ohZnkurbjpZHmhIjhu6PpkKDou6jjtoXrpLrsjqHkraPviJDoqIjkhI/koKnmi7DnhaDFo+aAmOesjuW5veCrsOqKh+OYkuGciOqTgOqjge2RsOapleu8m+2FluakhO6Bo+aRqOybhOajkeiIqeKlouKkheaQpOSbhe6NqOiopOOEi+qBoui4vueaj+OUleaGteGVo+WJoMmD5q+y6bml75KQ6p+C5aGS2orkg4HpkLrJvOajhuOgsN+y44m374mf65u94ZCy6bmgxLbmioXsjLTsjoHmjofgoIXosIjogJPksK/grYzmo4TqoZ7rmabimI7qvZfoqJzmrJHguLTsh4jkqbDpnLTskYzhqrDmjYbrhrjmgIHvgb3mlaXmppN+6YOw4YOR5KS55IaIxoLgqb3mlrnlgqDooKTkupnntpTrhaDqh7LjgIfkoKjqiIjivKTmhJThj7DhkJHtqJThk5HniYjvuKrlm7HhupLpqbjomLjqooPqhJzlg53hmY7oqJnpioTpgoHqlIrhlqTurJfqlZHrmITvuYjmqIfimZ/kioflvKrlg6TphYjpkrDohrLhoofsuKDqjIDkhYjhvZHhlJTsl6fpvZXkvqXhnqTmk6PpkZTurofogKAA\n    vec3 frontWheelPos=vec3(1.44*.5,1.25,-.45);\n    vec3 rearWheelPos=vec3(1.42*.5,-1.05,-.5);\n    \n    //d=min(d,distBox(p-vec3(0,0,-.05),vec3(1.65,3.45,.7)*.5));\n    //d=min(d,distBox(p-vec3(0,-.5,.55),vec3(1.65,2.4,.55)*.5));\n    bool front = p0.y>0.; \n    vec3 pwheel = front?frontWheelPos:rearWheelPos;\n    // -- 15 ----- wheel cases (precalc) ------------\n    float dWheelcases=distCylR((p-pwheel+vec3(0,0,-.1-(front?-.018:.0))).zyx,.4,.7,.1);\n    \n    float wcext=.01+(p.z+.5)*.1;\n\n    // -- 0 ---------- main box -------------\n    d=min(d,\n          distBoxR(p-vec3(0,0,.2),\n                   vec3(1.63-(psq.y*psq.y*.1+1.)*psq.y*.01-psq.z*.521-smoothstep(0.25,0.35,p.z)*(p.z-.25)*.0\n                        +wcext*(1.-smoothstep(wcext*.3,wcext,dWheelcases))\n//                        +wcext*exp(-dWheelcases*dWheelcases/wcext/wcext)\n                        ,\n                        3.6- min(psq.z*psq.z*20.*step(0.,p.y),.1) - (psq.z+psq.x)*.1  -step(0.,-p.y)*smoothstep(0.,.2,p.z)*max(p.z-.2,0.)*1.1,\n                        1.3-psq.y*psq.y*psq.y*.015*(.5+.5*step(0.,-p.z))-step(0.,p.z)*(psq.x*.2+psq.y*.035+p.y*.04))*.5,\n                        .03-min(p.y*.03,0.)));\n    float dmainBox=d;\n    \n    // -- 1 ---------- hood/windshield cut -------------\n    float dwin =dot(p-vec3(0,1.5-psq.x*(.3-(p.z-.8)*.4),0.7)*.5,normalize(vec3(0,1.,1)));\n    float dhood=dot(p-vec3(0,1.5-psq.x*(2.-(p.y-.75)*1.),0.74-.1*(p.y-.75)*(p.y-.75))*.5,normalize(vec3(0,.07,1)));\n    //dwin=10000.;\n    d=-smin_(-d,-smin_(dwin,dhood,.03),max(.001,.05-.0*(p.y*.01)));\n    //d=-min(-d,-min(dwin,dhood));\n\n    float dwin2 =dot(p-vec3(0,1.64-psq.x*.3,0.7)*.5,normalize(vec3(0,1.5,1)));\n    float dhood2=dot(p-vec3(0,1.5,0.36)*.5,normalize(vec3(0,.04,1)));\n    d2=-min(-d,-min(dwin2,dhood2));\n    d+=exp(-abs(d2)/.006)*.006;\n    \n    p=p-vec3(0,0,-.01*psq.y);\n\n    // -------- absatz hood ---------------    \n    d2=distBoxR(p-vec3(0.,1.37,.3),vec3(.9,1,.5)*.5,.07);\n    d+=.015*(1.-smoothstep(-.015,.015,d2))*clamp(1.7-p0.y,0.,1.);\n    \n    // -- 2 ---------- side versenkung windows --------------\n    d2=distBoxR(p-vec3(.9-p.z*.2,0,.57),vec3(.1,3.25-p.z*.75,.59)*.5+.02,.15)-.02;\n    d=-smin_(-d,d2,.01);\n\n    SET_PREV_MAT(CARBODY);\n    \n    float dwincut=1000.;\n    // -- 3 ---------- side win rear -----------\n    p=p-vec3(0,-.88,.55);\n    d2=distBoxR(p,vec3(3.,.82-.8*(p.z)*step(0.,-p.y),.37)*.5,.063-p.y*.05);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    ////d+=exp(-abs(d2)/.006)*.006;\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n    dwincut=min(dwincut,d2);\n    p=p0;\n\n    // -- 4 ---------- side stripe --------------\n    d2=distBox(p-vec3(0,0,.16-.01*(p.y+.4)*(p.y+.4)),vec3(3.,3.3,.07)*.5);\n    //d+=clamp(-d2,0.,.01);\n    d+=smoothstep(0.,1.,-d2/.01)*.01;\n\n    // -- 5 ---------- door -------------\n    d2=distBoxR(p-vec3(0,.1,.235),vec3(3.,1.03,1.09)*.5,.07-.1*(p.z+.3));\n    d2=-smin_(-(dwin+.03),-d2,.07);\n    d+=exp(-abs(d2)/.006)*.01;\n    SET_PREV_MAT(CARBODY);\n\n    // -- 6 ---------- side win front -----------\n    d2=-smin_(-d2-.05,p.z-.36,.03);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    ////d+=exp(-abs(d2)/.006)*.006;\n    dwincut=min(dwincut,d2);\n    \n    // -- 7 ---------- front window -----------\n    p=p0-vec3(0,0,.53);\n    //d2=distBoxR(p,vec3(1.4,5.,.37)*.5,.05);\n    d2=dmainBox+.065-psq.x*.1*p.z;\n    d2=-smin(-d2,dhood-.015,.05);\n    //d+=clamp(-d2,0.,.01);\n    //d+=smoothstep(0.,1.,-d2/.015)*.01;\n    dwincut=min(dwincut,d2);\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n\n    // -- 8 ---------- rear window -----------\n    p=p0-vec3(0,-1.7,.5);\n    d2=distBoxR(p,vec3(1.15-p.z*.3,1.,.35)*.48,.07);\n    d+=smoothstep(0.,1.,-(d2-.03+.03*p.z)/.01)*.01;\n    SET_PREV_MAT(CARBODY);\n    //d+=smoothstep(0.,1.,-d2/.01)*.01;\n    dwincut=min(dwincut,d2);\n    //d=max(d,-d2);\n#ifdef ENABLE_MATERIALS \n    //if(enable_glass) { SET_PREV_MAT(GLASS); }\n#endif\n\n    // ------- bottom absatz ------------\n    d2=p0.z+.345;\n    d+=.02*min(exp2(-d2/.02),1.);\n\n    // -- 15 ----- wheel cases (apply) ------------\n    d=-smin_(-d,dWheelcases,.005);\n    \n    SET_PREV_MAT(p0.z<-.345?GUMMI:CARBODY);\n\n    // ------------- cut out interior, cutout windows, add windows + window lips\n    float d_inner=d+.06;\n    d=max(d,-d_inner); SET_PREV_MAT(BLACKPLASTIC); \n    d=-smin_(-d,dwincut,.01);\n    SET_PREV_MAT(CARBODY); \n    d=min(d,length(vec2(dwincut,d_inner-.045))-.01);\n    SET_PREV_MAT(GUMMI); \n    d=min(d,length(vec2(dwincut,d_inner-.045)+vec2(1,-1)*.008)-.0025);\n    SET_PREV_MAT(CHROME); \n    if(enable_glass) { d=min(d,d_inner-.045); SET_PREV_MAT(GLASS); }\n    \n    // -- 9 ---------- rear door -----------\n    p=p0-vec3(0,-1.7,.25);\n    d2=distBoxR(p,vec3(1.35-psq.z*.35,.5+p0.z*.5,.97)*.5,.07);\n    d+=exp(-abs(d2)/.006)*.01;\n\n    // -- 11 ---------- rear license plate box -----------\n    p=p0-vec3(0,-1.885,.04);\n    d2=distBoxR(p,vec3(.65+p.z*.3,.2,.2)*.5,.03);\n    d=max(d,-d2);\n    SET_PREV_MAT(CARBODY);\n    p=p0-vec3(0,-1.775,.14);\n    d2=distBoxR(p,vec3(.68,.05,.04)*.5,.005);\n    d=min(d,d2);\n\n    // -- 10 ---------- rear blinker -----------\n    p=p0-vec3(.68,-1.8,.0);\n    d2=distBoxR(p,vec3(.2-p.z*.2*step(0.,-p.x),.3,.3)*.5,.03);\n    d=min(d,d2);\n    d=max(d,dmainBox-.01);\n    SET_PREV_MAT(BLACKPLASTIC);\n    d-=smoothstep(.007,.01,-d2)*.001;\n    SET_PREV_MAT(p.z<0.06?(p.x>0.0?(p.z>-.05?GLASS:ORANGEGLASS):REDGLASS):REDGLASS);\n    \n    // -- 12 ---------- front blinker -----------\n    p=p0-vec3(.6,1.75,.15);\n    d2=distBoxR(p,vec3(.25,.095,.12)*.5,.03);\n    d=max(d,-d2);\n    SET_PREV_MAT(BLACKPLASTIC);\n    d=min(d,-smin_(-d2-.025,-p.y+.01,.01));\n    SET_PREV_MAT(p.x<0.03?ORANGEGLASS:GLASS);\n\n    // -- 13 ---------- grill -----------\n    p=p0-vec3(.0,1.78-psq.x*.05,-.05);\n    d2=distBoxR(p,vec3(1.48+.02-p.y*.3,.2,.265-psq.x*.03+.02-p.y*.3)*.5,.06-p.z*.15);\n    d=max(d,-d2);\n    // ----- einbuchtung rund um scheinwerfer -----\n    float d2b=-smin_(-d2,p.x-.48,.02);\n    vec2 pl=(p-vec3(.61,0,0)).xz; float lpl=length(pl);\n    float yo=mix(.02,max(-d2b-.016,0.)*.5,1.-exp2((-lpl+.1)/.0075));\n    d2=-smin_(-d2,-.1+lpl,.005);\n    d2=-smin_(-d2,-abs(p.y-.01)+.035-yo,.005);\n    // ----- cooling slits -----\n    vec3 pi=vec3(0,0,(clamp(floor(p.z/.029),-4.,3.)+.5)*.029);\n    d2=-smin_(-d2,distBox(p-pi,vec3(.96,.2,.02)*.5),.01);\n    // ----- lada logo -------\n    p.y-=.03;\n    d2=min(d2,distBoxR(p,vec3(.04+p.z*.1,.02,.07),.005));\n    d=min(d,d2);\n    SET_PREV_MAT(BLACKPLASTIC);\n\n    // ----- scheinwerfer -----\n    float lsph=length(p-vec3(.61,-.273-.03,0));\n    d=min(d,max(max(lsph-.3,-p0.y+1.65),lpl-.09));\n    SET_PREV_MAT(CHROME);\n\n    // -- 14 ---------- bumpers -----------\n    p=p0; p.y=abs(p.y);\n    p=p-vec3(0,1.87-.03*psq.x,-.25);\n    d2=distBoxR(p,vec3(1.62,.1,.1)*.5,.02);\n    d=min(d,d2);\n    SET_PREV_MAT(CHROME);\n    p-=vec3(.76-p.y*.15,-.065,0);\n    d2=distBoxR(p,vec3(.113,.25,.113)*.5,.02);\n    d2=max(d2,dot(p,vec3(-1,-.4,0))-.03);\n    d=min(d,d2);\n    SET_PREV_MAT(GUMMI);\n    \n    // ------- wheels, axes ------------\n    //d=max(d,-distCylR((p-rearWheelPos+vec3(0,0,-.1)).zyx,.4,.7,.1));\n    // ------- axes ------\n    #if 0\n    p=(p0-pwheel*vec3(0,1,1));\n#ifdef USE_SIMDATA\n    float leftSgn=sign(p00.x);\n    float rear=front?0.:1.;\n    vec3 wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    vec4 axQuat=front?qf:qr;\n    float axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n\n    p=transformVecByQuat(p,axQuat);\n    p.z-=axOffs;\n#endif\n    d=min(d,distCylR(p.zyx,.12*(1.-.6*smoothstep(0.05,.2,p.x)),1.44,.05));\n    #endif\n    p=(p0-pwheel);\n\n#ifdef USE_SIMDATA\n    float leftSgn=sign(p00.x);\n    float rear=front?0.:1.;\n    vec3 wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    vec4 axQuat=front?qf:qr;\n    float axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n    // wheel axis rot + offset\n    p=transformVecByQuat(p+wo,axQuat)-wo;\n    p.z-=axOffs;\n    d=min(d,distCyl(p.zyx-vec3(0,0,-.72),.12*(1.-.6*smoothstep(0.05,.2,p.x+.72)),1.55));\n    SET_PREV_MAT(CHASSIS);\n    // steering rotation of front wheels\n    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*-SteerAng*(front?1.:0.));\n    p=transformVecByQuat(p+vec3(.1,0,0),q)-vec3(.1,0,0);\n    // wheel rotations\n    float rot=-WheelRot.x*.7;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));\n#endif\n#define PROPER_WHEELS\n#ifndef PROPER_WHEELS\n    d=min(d,distCylR(p.zyx,.35,.2,.05));\n#else\n    //d=min(d, distWheelDim((p0-pwheel).yzx,185.,75.,16.,12.,.2));\n    d=min(d, distWheelDim(p.yzx,175.,80.,16.,12.,.2));\n#endif\n    SET_PREV_MAT(length(p.yz)<.215?CHROME:GUMMI);\n    \n#ifdef ENABLE_MATERIALS \n    return vec2(d,mat);\n#else\n    return d;\n#endif\n}\n\n#ifndef ENABLE_MATERIALS\nvec2 distCarM(vec3 p) {return vec2(distCar(p),1.); }\n#endif\n\nbool enable_car=true;\nbool enable_terr=true;\n\nfloat lorentz(float x) { return 1./(1.+x*x); }\n\nvec2 distM(vec3 p)\n{\n    float d=1000., mat=-1., d_mat=d;\n    \n    if(enable_car)\n    {\n        vec2 dm=distCarM(carTrafo(p)*vec3(1,-1,1));\n        d=dm.x; mat=dm.y; d_mat=d;\n    }\n    \n    if(enable_terr)\n    {\n        d=min(d,distTerr(p));\n    }\n    \n    SET_PREV_MAT(FLOOR);\n    \n    //#define DEBUG\n    #ifdef DEBUG\n    vec3 accFrontAxe = texelFetch(PhysTex,ivec2(7,0),0).xyz;\n    vec3 accRearAxe  = texelFetch(PhysTex,ivec2(8,0),0).xyz;\n    d=min(d,sdLine(p,carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.),carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.)+accFrontAxe)-.1);\n    d=min(d,sdLine(p,carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.),carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.)+accRearAxe)-.1);\n    SET_PREV_MAT(DBG_GREEN);\n    #endif\n    \n    return vec2(d,mat);\n}\n\nfloat dist(vec3 p) { return distM(p).x; }\n\nvec3 getGradOld(vec3 p,float delta)\n{\n    float v=dist(p);\n    vec2 d=vec2(delta,0); return vec3( dist(p+d.xyy)-v,\n                                       dist(p+d.yxy)-v,\n                                       dist(p+d.yyx)-v )/delta;\n}\n\n/// my own version of a looped getGrad() (is asymmetric)\nvec3 getGrad2(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*dist(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\n// cheap tetrahedral gradient (is symmetric)\nvec3 getGrad(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    for(int i=min(0,iFrame);i<4;i++) { vec3 v=vec3((i&1)*2-1,(i/2)*2-1,1); vec3 d=v.xxz*v.zyy;  g+=d*dist(p+d*delta*.289); }\n    return g/(delta*1.732);\n}\n\nfloat march(inout vec3 p, vec3 dir)\n{\n    //if(!intersectBox(p-bbpos,dir,bbsize)) { enable_car=false; }\n    vec3 pc=carTrafo(p);\n    vec3 pdir=carTrafo(dir,0.);\n    //enable_car=true;\n    if(!intersectBox(pc-bbpos,pdir,bbsize)) { enable_car=false; }\n    if(terrbbsize!=vec3(0) && (!intersectBox(p-terrbbpos,dir,terrbbsize))) { enable_terr=false; }\n    //if(!(intersectBox(pc-bbpos1,pdir,bbsize1)||intersectBox(pc-bbpos2,pdir,bbsize2))) { enable_car=false; }\n    vec3 p0=p;\n    float eps=.001;\n    float dmin=100000.;\n    bool findmin=false;\n    float d=dist(p);\n    vec3 pmin=p;\n    for(int i=min(0,iFrame);i<150;i++)  // min(0,iFrame) avoids unrolling of loop - thx Dave_Hoskins\n    {\n        float dp=d;\n        d=dist(p);\n        p+=dir*d*.7;\n#ifdef SHADOW\n        if (d<dp) findmin=true;\n        if (findmin && d<dmin) { dmin=d; pmin=p; }\n#endif\n        if (d<eps) return 0.;\n#ifndef SHADOW\n        if (dmin<50. && d>50.) break;\n#else\n        if (dmin<150. && d>150.) break;\n#endif\n        //if (length(p)>100.) break;\n    }\n    float lmin=length(pmin-p0);\n    return clamp(dmin/lmin/.05,0.,1.);\n}\n\nfloat wstep(float w, float thr, float x)\n{\n    return smoothstep(thr-w*.5,thr+w*.5,x);\n}\n\nfloat getAO(vec3 pos, vec3 n)\n{    \n    float ao=1.;\n    float sc=.025;\n    float amb=.3;\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    for( int i=min(iFrame,0); i<5; i++ )\n    {\n    \tao*=mix(dist(pos+n*sc)/sc*1.4,1.,amb);\n    \tao=clamp(ao,0.,1.);\n        sc*=2.;\n        amb=min(amb+.1,.5);\n    }\n    return ao;\n   \t/*\n    ao*=dist(pos+n*.02)/.02*1.4*.7+.3;\n   \tao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.05)/.05*1.4*.6+.4;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.1)/.1*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.2)/.2*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.4)/.4*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);*/\n}\n\nvec3 lighting(vec3 pos, vec3 dir, vec3 pos0, float reflections, inout float outfres, inout float outao)\n{\n    vec3 pc=carTrafo(pos);\n    vec3 glasspos=vec3(1000.);\n    vec3 glassn=vec3(0.);\n    float mat=distM(pos).y;\n    if(mat==GLASS)\n    {\n        glasspos=pos;\n        glassn=normalize(getGrad(pos,.001));\n        enable_glass=false;\n        march(pos,dir);\n    }\n    mat=distM(pos).y;\n    \n    vec3 light=getLightDir();\n    float sh=1.;\n#ifdef SHADOW\n    vec3 posS=pos+.017*light;\n    enable_car=true;\n    sh=march(posS,light);\n#endif\n    enable_car=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    if(mat==BG) n=vec3(0,0,1);\n\n    float ao=1.;\n    ao=getAO(pos,n);\n    //ao=pow(ao,.5);\n    ao=ao*.7+.3;\n    //ao=clamp(ao*2.-1.,0.,1.);\n\n    //vec3 light = normalize(vec3(-.5,.5,2));\n    float diff=clamp(dot(n,light),0.,1.);\n\n    diff=min(diff,sh);\n    \n    // no ao in lighted areas\n    ao=mix(ao,1.,diff);\n    ao=clamp(ao,0.,1.);\n    //return vec3((diff*.6+.4)*(ao));\n    \n\n    Material mtrl=getMaterial(mat);\n\n    // evironmental reflection\n    n=normalize(n);\n    if(mat==CARBODY) // brushed metal surface\n    {\n        vec4 r1=rand3d(pc*.1);\n        vec4 r2=rand3d(pc*.05);\n        // scramble normals randomly\n        //n+=clamp((r1.xyz-.5)*5.,0.,1.)*.015 + clamp((r2.xyz-.5)*5.,0.,1.)*.015;\n        // darken randomly\n        //n*=clamp(r1.w*3.-1.,0.,1.)*.05 + clamp(r2.w*3.-1.,0.,1.)*.07 + .88;\n    }\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(pos,R.xyz,1.).xyz;\n    //refl=refl*1.2+.3;\n    float fres=abs(dot(R,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;\n    float fres0=fres;\n    #ifdef SCRATCHES\n    vec3 n0=n;\n    int numscr=7;\n    float dang=1.57*2./float(numscr);\n    float ang=.5;\n    refl*=1.;\n    vec3 drefl=vec3(0);\n    float sum=0.;\n    vec3 pi=pc;\n    vec3 heading=vec3(0,0,1);\n    vec3 tan1=vec3(1,0,0);\n    vec3 tan2=vec3(0,1,0);\n    // ...trying to implement some micro scratches\n    for(int i=0;i<numscr*3;i++)\n    {\n        n=n0;\n        vec2 cs=cos(ang+vec2(0,-1.57));\n        mat2 m=mat2(cs,cs.yx*vec2(-1,1));\n        //dFdx()\n        vec2 dn2d=(texture(iChannel0,(m*pi.xy)*vec2(6.,.1)*mtrl.scratchScale+vec2(0,.5/256.)).x-.5)*mtrl.scratchScale;\n        dn2d=pow(abs(dn2d),vec2(.7))*sign(dn2d);\n        dn2d=dn2d*m;\n        //dn2d=dn2d.yx*vec2(1,-1);\n        n+=abs(dot(n0,heading))*carTrafoInv(dn2d.x*tan1+dn2d.y*tan2,0.);\n        n=normalize(n);\n        R=reflect(dir,n);\n        float fres=abs(dot(R,n));\n        fres=1.-fres;\n        fres*=fres*fres;\n        fres=fres*.4+.6;\n        float fact=(abs(dot(n0,-dir))*.8+.2)*fres;\n        //fact=.2;\n        drefl+=fact*myenv(pos,R.xyz,1.).xyz;\n        sum+=fact;\n        ang+=dang;\n        pi=pi.zxy;\n        heading=heading.yzx;\n        tan1=tan1.yzx;\n        tan2=tan2.yzx;\n    }\n    drefl/=float(numscr);\n    refl=mix(refl,drefl,mtrl.scratchy);\n    #endif\n    \n    #ifdef RENDER_GLASS\n    vec3 Rg=reflect(dir,glassn);\n    vec3 glassrefl=myenv(pos,Rg.xyz,1.).xyz;\n    //glassrefl=glassrefl*1.2+.3;\n    float glassfres=abs(dot(Rg,glassn));\n    glassfres=1.-glassfres;\n    glassfres*=glassfres*glassfres;\n    glassfres=glassfres*.7+.3;\n    if(glassn==vec3(0)) glassfres=0.;\n    #endif\n\n    vec3 rcol=vec3(1);\n    fres=(mtrl.refl<0.)?fres*-mtrl.refl:mtrl.refl;\n    rcol=(mtrl.refl<0.)?vec3(1):mtrl.col;\n    vec3 col=mtrl.col;\n    if(mat==FLOOR) {\n        col+=(texture(iChannel0,pos.xy*2.,-1.2).x-.5)*.3;\n        //col*=.9+.2*texture(iChannel2,pos.xy*.2).xyz;\n        #ifdef WET_ASPHALT\n        col*=.35+.65*step(-.66,pos.z);\n        fres=fres0*mix(-mtrl.refl,1.,(1.-smoothstep(-.661,-.659,pos.z))*exp(-length(pos.xy)/50.));\n        #endif\n    }\n\n    float zr=length(pos-pos0)/300.;\n    //diff=sqrt(diff);\n\n    outfres=fres;\n    if(glassfres!=0.) outfres=glassfres;\n    fres*=reflections;\n    glassfres*=reflections;\n\n    outao=ao;\n    \n\tvec3 bg=myenv(pos0,dir,1.).xyz;\n\t// diff, ao, refl\n\tvec3 finalcol = mix(col,rcol*refl,fres)*mix(vec3(1.2,1.4,1.5)*.35,vec3(1.,1,.9),diff)*ao*1.5;\n\t//finalcol=col;\n\t// fog\n\t//finalcol = mix(finalcol,bg,1.-exp(-zr));\n\tfinalcol = mix(finalcol,vec3(.35),1.-clamp(exp(-(zr-.1)/2.5),0.,1.));\n\t#ifdef RENDER_GLASS\n\tfinalcol=mix(finalcol*sqrt(1.-glassfres),glassrefl,glassfres);\n\t#endif\n\treturn finalcol;\n}\n\n#ifdef CAM_ANIM\nvec4 camAnim[8] = vec4[] (\n    vec4( 1.5, -2.75,-0.25 ,1.), vec4(0,1.,.1, 0.),\n    vec4(-1.5, -2.75,-0.25 ,1.), vec4(.5,1.,.1, 0.),\n    //vec4(-2., -1.5,-0.25 ,1.), vec4(1.,0.,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.)\n    );\n    \nvec3 getCamAnimPos(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].xyz,camAnim[i_c*2].xyz,fact);\n}\n\nvec3 getCamAnimDir(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2+1].xyz,camAnim[i_c*2+1].xyz,fact);\n}\n\nfloat getCamAnimBr(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].w,camAnim[i_c*2].w,fact);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    \n    float zoom=1.5+(500.*exp2(-iTime));\n    #ifdef SHADEROO\n    zoom=exp(-iMouseData.z/5000.);\n    #endif\n    zoom*=CamDistFact;\n\n    vec3 CarPos = carTrafoInv(vec3(0),1.);\n    vec3 pos=vec3(0,0,4.5)*zoom;\n    vec3 dir=normalize(vec3(sc,-.8));\n    \n    calcWheelOffsets(-.1,.2);\n    \n    vec4 q=vec4(0,0,0,1);\n    float th=-(iMouse.y-Res.y*.5)/Res.y*6.;\n    float ph=-(iMouse.x-Res.x*.5)/Res.x*10.;\n    if(iMouse.x<1.) { th=1.45; ph=-iTime*.25; }\n    //th=clamp(th,-1.65,1.65);\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),ph));\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),th));\n    pos=transformVecByQuat(pos,q)-vec3(0,0,.2);\n    dir=transformVecByQuat(dir,q);\n    pos=camTrafoInv(pos,1.);\n    // get camera out of terrain\n    for(int i=0; i<50 ; i++) {  float d=distTerr(pos); if (d>.1) break; pos+=normalize(getGradTerr(pos,.01))*max(d,.1); }\n    // make sure cam is always above ground\n    //pos.z=max(hTerr(pos)-.6,pos.z);\n    dir=camTrafoInv(dir,0.);\n\n    #ifdef CAM_ANIM\n    if(iMouse.x<1.)\n    {\n        pos=getCamAnimPos(iTime);\n        dir=normalize(getCamAnimDir(iTime));\n        vec3 right=normalize(cross(dir,vec3(0,0,1)));\n        vec3 up=cross(right,dir);\n        dir=normalize(dir+right*sc.x+up*sc.y);\n    }\n    #endif\n\n    vec3 pos0=pos;\n    float m=march(pos,dir);\n    \n    float refl=1.;\n    #ifdef RENDERED_REFECTIONS\n    refl=0.;\n    #endif\n    \n    float fres=0., ao=0.;\n    #ifdef ENABLE_MATERIALS\n        fragColor.xyz=lighting(pos,dir,pos0,refl,fres,ao);\n    #else\n        vec3 g=getGrad(pos,.001);\n        vec3 n=g/(length(g)+.00001);\n        enable_car=true;\n        ao=.5*clamp(dist(pos+n*.5)/.5,0.,1.)+.5*clamp(dist(pos+n*.25)/.25,0.,1.);\n        //ao=clamp(dist(pos+n*.5)/.5,0.,1.)*clamp(dist(pos+n*.25)/.25,0.,1.);\n        vec3 rdir=reflect(dir,n);\n        //pos+=n*.001;\n        //float sh=march(pos,reflect(dir,n));\n        fres=1.-abs(dot(rdir,n));\n        fres*=fres*fres;\n        fres=fres*.7+.3;\n        vec3 r=myenv(vec3(0),rdir,1.).xyz*.5;\n        //fragColor.xyz=mix((.3*n+.6)*(ao*.7+.3),r,fres);\n        //fragColor.xyz=vec3(1,.85,.6)*(dot(n,normalize(vec3(1,-1,1)))*.4+.1*n+.5)*(ao*.7+.3)+r*fres;\n        fragColor.xyz=mix(\n                        vec3(1.,.6,.4)*(1.+r*.6),\n                        vec3(.2,.4,.3)*.6,\n                        1.-(ao)*.7\n                        )*(dot(n,normalize(vec3(1,-1,1)))*.3+.1*n+.7)*1.;\n        //fragColor.xyz=mix(fragColor.xyz,vec3(.8,.9,1),.25*exp(-m));\n        //*(ao*.7+vec3(.1,.4,.2))*(.5+r*2.);\n    #endif\n    \n    #ifdef RENDERED_REFECTIONS\n    enable_glass=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    fragColor.xyz=n*.5+.5;\n    dir=reflect(dir,n);\n    pos+=dir*.003;\n    float mat=distM(pos).y;\n    march(pos,dir);\n    float dummyfres,dummyao;\n    vec3 lcol=lighting(pos,dir,pos0,1.,dummyfres,dummyao);\n    fragColor.xyz=mix(fragColor.xyz,lcol,(m!=0.)?0.:fres);\n\n    #ifdef CAM_ANIM\n    fragColor*=1.-exp(-getCamAnimBr(iTime)*getCamAnimBr(iTime)/.01);\n    #endif\n    //fragColor=myRandInterpol(fragCoord/iResolution.xy*.1);\n    #endif\n\n    fragColor.xyz=mix(myenv(vec3(0),dir,1.).xyz,fragColor.xyz,exp2(-abs(dist(pos))/10.));\n    \n\tfragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// physics driving sim\n\n//#ShaderooNumPasses 1\n#define NumPasses 1\n\n#define RandTex iChannel2\n#define PhysTex iChannel0\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\nvec4 myRandInterpol(vec2 uv)\n{\n    //#define COARSE_TERRAIN\n    #ifdef COARSE_TERRAIN\n    return textureLod(RandTex,uv,0.);\n    #endif\n    uv=fract(uv);\n    ivec2 c0 = ivec2(fract(uv        )*256.);\n    ivec2 c1 = ivec2(fract(uv+1./256.)*256.);\n    vec2  f = fract(uv*256.);\n    vec4 c00=texelFetch(RandTex,ivec2(c0.x,c0.y),0);\n    vec4 c10=texelFetch(RandTex,ivec2(c1.x,c0.y),0);\n    vec4 c01=texelFetch(RandTex,ivec2(c0.x,c1.y),0);\n    vec4 c11=texelFetch(RandTex,ivec2(c1.x,c1.y),0);\n    //f=mix(f,.5-.5*cos(f*PI2*.5),.5);\n    f=.5-.5*cos(f*PI2*.5);\n    return mix(mix(c00,c10,f.x),mix(c01,c11,f.x),f.y);\n}\n\nconst vec3 terrbbpos=vec3(0,.0,.0);\n#ifdef CHAIN_WORLD\nconst vec3 terrbbsize=vec3(260.,260.,60.)*2.+50.;\n#else\nconst vec3 terrbbsize=vec3(0);\n#endif\n\nfloat distTerr(vec3 p)\n{\n    vec3 p2=p*.0001;\n    vec4 noise = vec4(0);\n    float sc;\n    sc=1.; \n    for(int i=0;i<3;i++)\n    {\n        noise += (myRandInterpol(p2.xy*sc)-.5)/sc;\n        noise += (myRandInterpol(p2.yz*sc)-.5)/sc;\n        noise += (myRandInterpol(p2.zx*sc)-.5)/sc;\n        sc*=2.;\n    }\n    noise += abs(myRandInterpol(p2.xy*sc*5.)-.5)/sc/5.;\n    noise += abs(myRandInterpol(p2.yz*sc*5.)-.5)/sc/5.;\n    noise += abs(myRandInterpol(p2.zx*sc*5.)-.5)/sc/5.;\n    \n    #if   defined(CHAIN_WORLD)\n    return distChainCircle(p+noise.xyz*10.,200., 6, 60.,20.,20.);\n    #elif defined(TORUS2_WORLD)\n    return min(distTorus(p+noise.xyz*10.,100.,40.),distTorus((p-vec3(100,0,0)).zxy+noise.xyz*10.,100.,40.));\n    #elif defined(TORUS_WORLD)\n    return distTorus(p+noise.xyz*10.,100.,40.);\n    #elif defined(HOLLOW_SPHERE_WORLD)\n    return -length(p+noise.xyz*10.)+100.;\n    #elif defined(SPHERE_WORLD)\n    return length(p+noise.xyz*10.)-60.;\n    #elif defined(PLANE_WORLD)\n    return dot(p+noise.xyz*10.,normalize(vec3(1,.5,.7)));\n    #elif defined(HOLLOW_TORUS)\n    return -distTorus(p+noise.xyz*10.,100.,40.);\n    #else\n    return p.z+noise.x;\n    #endif\n}\n\n/// my own version of a looped getGrad()\nvec3 getGradTerr4loop(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*distTerr(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\n// straight fwd gradient - windows dont like this... wtf...\nvec3 getGradTerr0(vec3 p,float delta)\n{\n    vec3 d=vec3(delta*.5,0,0);\n    return vec3(\n        distTerr(p+d.xyz)-distTerr(p-d.xyz),\n        distTerr(p+d.zxy)-distTerr(p-d.zxy),\n        distTerr(p+d.yzx)-distTerr(p-d.yzx)\n        )/delta;\n}\n\n// cheap tetrahedral gradient\nvec3 getGradTerrTetr(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    for(int i=min(0,iFrame);i<4;i++) { vec3 v=vec3((i&1)*2-1,(i/2)*2-1,1); vec3 d=v.xxz*v.zyy;  g+=d*distTerr(p+d*delta*.289); }\n    return g/(delta*1.732);\n}\n\n// full straight fwd grad as loop\nvec3 getGradTerr6loop(vec3 p,float delta)\n{\n    vec3 g=vec3(0);\n    vec3 d=vec3(delta*.5,0,0);\n    for(int i=min(0,iFrame);i<6;i++) { g+=d*distTerr(p+d); d=-d.zxy; }\n    return g/(.5*delta*delta);\n}\n\nvec3 getGradTerr(vec3 p,float delta)\n{\n    return getGradTerr6loop(p,delta);\n}\n\n// transform to car coords\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    ///offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p-translate*pos,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\n// transform to world coords\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvec3 camTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(6,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvoid calcWheelOffsets(float clmin, float clmax)\n{\n    vec3 wp;\n    wp=carTrafoInv(WheelPosFL*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsFL = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosFR*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsFR = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosRL*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsRL = clamp(-distTerr(wp),clmin,clmax);\n    wp=carTrafoInv(WheelPosRR*vec3(1,1,1)+vec3(0,0,-.3),1.); WheelOffsRR = clamp(-distTerr(wp),clmin,clmax);\n    //hTerr(wp)-wp.z\n}\n\n#define keyTex iChannel1\n#define KEY_I (texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_A (texture(keyTex,vec2((65.5+ 0.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_W (texture(keyTex,vec2((65.5+22.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_R (texture(keyTex,vec2((65.5+17.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_S (texture(keyTex,vec2((65.5+18.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_D (texture(keyTex,vec2((65.5+ 3.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_F (texture(keyTex,vec2((65.5+ 5.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_PLUS  (texture(keyTex,vec2((187.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_MINUS (texture(keyTex,vec2((189.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_LEFT  (texture(keyTex,vec2(( 37.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_RIGHT (texture(keyTex,vec2(( 39.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_DOWN  (texture(keyTex,vec2(( 40.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_UP    (texture(keyTex,vec2(( 38.5)/256.0,(0.5+0.0)/3.0)).x)\n\n#define CalcTorque(a,r) cross((r),transformVecByQuat((a),iquat)*Mass)/I\n\nfloat mypow(float a, float b) { return exp2(log2(a)*b); }\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    #ifdef ZZT_AS_TEX\n    vec2 uv = fragCoord.xy / Res0;\n    fragColor = zztop((uv*2.-.75)*11.,-1.);\n    #endif\n    \n    if (fragCoord.x>10.) discard;\n    if (fragCoord.y>1.) discard;\n\n    vec3  pos      = texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    vec3  vel      = texelFetch(PhysTex,ivec2(1,0),0).xyz;\n    vec3  omega    = texelFetch(PhysTex,ivec2(2,0),0).xyz;\n    vec4  quat     = texelFetch(PhysTex,ivec2(3,0),0);\n    float SteerAng = texelFetch(PhysTex,ivec2(4,0),0).x;\n    float camDist  = texelFetch(PhysTex,ivec2(4,0),0).y;\n    vec4  wheelRot = texelFetch(PhysTex,ivec2(5,0),0);\n    vec4  camQuat  = texelFetch(PhysTex,ivec2(6,0),0);\n    vec4  iquat = inverseQuat(quat);\n    \n    calcWheelOffsets(-1.2,1.2);\n    \n    float dt=min(max(iTimeDelta/float(NumPasses),.0001),.03);\n    \n    float axDist=3.5;\n    vec3 rearAxPos = vec3(0,1.7,0);\n    \n    //quat=vec4(0,0,0,1);\n    vec3 bx=transformVecByQuat(vec3(1,0,0),quat);\n    vec3 by=transformVecByQuat(vec3(0,1,0),quat);\n    vec3 bz=transformVecByQuat(vec3(0,0,1),quat);\n    \n    vec3 acc=vec3(0);\n    vec3 alpha=vec3(0);\n    \n    float Mass=1000.;\n    vec3 S=vec3(2.,3.2,1.5);\n    vec3 I=vec3(S.y*S.y+S.z*S.z, S.z*S.z+S.x*S.x, S.x*S.x+S.y*S.y)*Mass/12.;\n    float mu = .7;\n    #define GRAVITY 9.81\n    //acc+=GRAVITY*vec3(0,0,-1);\n    acc+=GRAVITY*-normalize(getGradTerr(pos,10.));\n    float SpringOmega=10.;\n    float SpringGamma=20.;\n    \n    vec3 n=normalize(getGradTerr(pos,2.));\n    \n    //float dTerr = (pos.z-hTerr(pos))*n.z;\n    float dTerr1=distTerr(pos+by*1.1-bz*.8);\n    float dTerr2=distTerr(pos-by*1.1-bz*.8);\n    float dTerr = (dTerr1+dTerr2)*.5;\n    \n    float grip=step(0.,.1-dTerr);\n    //float grip=max(step(0.,.1-dTerr1),step(0.,.1-dTerr2));\n    \n    // FIXME: just one central springforce for now\n    //float dTerr=(pos.z-hTerr(pos))*n.z;\n    acc += grip*(0.*GRAVITY+SpringOmega*SpringOmega*(.1-dTerr))*n;\n        \n    // FIXME: just angular spring for now... (use wheel forces instead)\n    alpha -= 150.*grip*cross(transformVecByQuat(n,iquat)*Mass,normalize(vec3(0,.0,1)))/I;\n\n    vec3 dacc=vec3(0);\n    vec3 dalpha=vec3(0);\n    \n    dacc-=30.*grip*(max(KEY_W,KEY_UP)-max(KEY_S,KEY_DOWN))*by;\n    acc+=dacc;\n    \n    // FIXME: get rid of tweak-constant 0.15\n    alpha-=.2*grip*cross(transformVecByQuat(dacc,iquat)*Mass,.5*(WheelPosRL+WheelPosRR))/I;\n        \n    SteerAng*=.91;\n    SteerAng-=(max(KEY_A,KEY_LEFT)-max(KEY_D,KEY_RIGHT))*.05;\n    camDist*=(1.-.02*KEY_PLUS);\n    camDist*=(1.+.02*KEY_MINUS);\n    \n    //quat=multQuat(quat,axAng2Quat(vec3(0,0,1),+.001*SteerAng*dot(vel,by)));\n    \n    vec3 accFrontAxe;\n    vec3 accRearAxe;\n    \n    // friction on front/back tire (one virtual middle tire)\n    for(int i=0;i<2;i++)\n    {\n        vec3 fricDir=vec3(cos(SteerAng),-sin(SteerAng),0);\n        vec3 fricPos=.5*(WheelPosFL+WheelPosFR);\n        if (i==1)\n        {\n            fricDir=vec3(1,0,0);\n            fricPos=.5*(WheelPosRL+WheelPosRR);\n        }\n        // FIXME: this should be +omega ?!\n        vec3 dv = cross(omega,fricPos) + transformVecByQuat(vel,iquat); // speed of wheelpos (by car rotation) + car speed\n        dv = clamp(dot(dv,fricDir)*1.,-4.,4.)*fricDir;  // just component normal to wheel\n        dacc   = -transformVecByQuat(dv,quat)*mu*GRAVITY*grip*.5;\n        dalpha = CalcTorque(dacc,fricPos);\n        if(i==0) accFrontAxe=dacc;\n        if(i==1) accRearAxe=dacc;\n        acc+=dacc;\n        alpha+=dalpha;\n    }\n    \n    // very unphysical mix - so careful with timedelta (or NumPasses)!\n    //camQuat=normalize(mix(quat,camQuat,.95));\n    camQuat=normalize(mix(quat,camQuat,mypow(.95,dt/.0166)));\n\n    if(dTerr<0.) vel-=dot(vel,n)*n*.5;\n    //pos.z=.5+hTerr(pos);\n    //quat=multQuat(getTiltQuat(pos),quat);\n    acc-=.03*vel*length(vel);\n    alpha-=grip*2.*omega*length(omega);\n\n    vel+=acc*dt*.5;\n    pos+=vel*dt;\n    vel+=acc*dt*.5;\n#if 1\n    omega+=alpha*dt*.5;\n    //if (length(omega)>.1) omega=normalize(omega)*.1;\n    if (length(omega)>.001)\n        quat=multQuat(quat,angVec2Quat(omega*dt));\n    omega+=alpha*dt*.5;\n#endif\n    \n    //if(pos.z<hTerr(pos)) \n    vec3 omegaN=dot(omega,n)*n;\n    omega=mix(omegaN,omega,mypow(mix(.98,.85,grip),dt/.0166));\n    omega*=mypow(.99,dt/.0166);\n    //omega=mix(omegaN,omega,mix(.98,.85,grip));\n    //omega*=.99;\n    //vel*=.99;\n    if(length(vel)>.001) vel-=normalize(vel)*.005*dt/.0166;\n    //if(length(vel)<.1) vel=vec3(0);\n    //if(length(omega)<.01) omega=vec3(0);\n    \n    float wheelRadius=(WheelRadiusF+WheelRadiusR)*.5*.5;\n    wheelRot-=-dot(vel,by)*dt/wheelRadius;\n    \n    if(iFrame==0)\n    {\n        pos=vec3(10,300,150);\n        pos-=normalize(getGradTerr(pos,.5))*distTerr(pos);\n        pos-=normalize(getGradTerr(pos,.5))*distTerr(pos);\n        pos-=normalize(getGradTerr(pos,.5))*distTerr(pos);\n        pos-=normalize(getGradTerr(pos,.5))*distTerr(pos);\n        pos+=normalize(getGradTerr(pos,.5))*3.;\n        //pos.z=hTerr(pos)+1.;\n        vel=vec3(0,0,0);\n        quat=normalize(vec4(0.03,0.02,0,1));\n        camQuat=quat;\n        omega=vec3(0);\n        SteerAng=0.;\n        wheelRot=vec4(0);\n        camDist=1.;\n    }\n    \n    if (ivec2(fragCoord)==ivec2(0,0)) fragColor = vec4(pos,1.0);\n    if (ivec2(fragCoord)==ivec2(1,0)) fragColor = vec4(vel,1.0);\n    if (ivec2(fragCoord)==ivec2(2,0)) fragColor = vec4(omega,1.0);\n    if (ivec2(fragCoord)==ivec2(3,0)) fragColor = vec4(quat);\n    if (ivec2(fragCoord)==ivec2(4,0)) fragColor = vec4(SteerAng,camDist,0,1);\n    if (ivec2(fragCoord)==ivec2(5,0)) fragColor = vec4(wheelRot);\n    if (ivec2(fragCoord)==ivec2(6,0)) fragColor = vec4(camQuat);\n    if (ivec2(fragCoord)==ivec2(7,0)) fragColor = vec4(accFrontAxe,0);\n    if (ivec2(fragCoord)==ivec2(8,0)) fragColor = vec4(accRearAxe,0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// vodka runner\n\n#define CHAIN_WORLD\n//#define TORUS2_WORLD\n//#define TORUS_WORLD\n//#define HOLLOW_SPHERE_WORLD\n//#define SPHERE_WORLD\n//#define PLANE_WORLD\n//#define HOLLOW_TORUS\n\n// helper functions\n\n#define USE_SIMDATA\n\n#define PI2 6.283185\n#define PIH 1.57079632679\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang, vec3 p) { return vec3(ROTM(ang)*p.xy,p.z); }\nvec3 rotX(float ang, vec3 p) { return rotZ(ang,p.yzx).zxy; }\n\nvec3 getLightDir() { return normalize(1.*vec3(cos(1.+/*iTime+*/vec2(0,1.6)),.81)); }\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n// iq's sdf primitives\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundRect( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nvec2 sdRoundRect2( vec4 p, vec4 b, vec2 r )\n{\n  vec4 q = abs(p) - (b-r.xxyy);\n  vec4 qp=max(q,0.0);\n  return sqrt(qp.xz*qp.xz+qp.yw*qp.yw) + min(max(q.xz,q.yw),vec2(0)) - r;\n}\n\nfloat sdHalfRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return max((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r),-p.z);\n}\n\nfloat sdRoundedCylinder( vec3 p, float R, float r, float h )\n{\n  vec2 d = vec2( length(p.xz)-R, abs(p.y) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// iq's capsule\nfloat sdLine( vec3 p, vec3 a, vec3 b)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\n// my own distance experiments...\nfloat distChainSeg(vec3 p, float R, float r, float lh)\n{\n    return length(vec2(length(vec2(max(abs(p.x)-lh,0.),p.y))-R,p.z))-r;\n}\n\nfloat distChainCircle(vec3 p, float RR, int numh, float R, float r, float lh)\n{\n    float ang0=atan(p.y,p.x);\n    float dang=PI2/float(numh)/2.;\n    float fidx=floor(ang0/dang);\n    float angi =(fidx+0.)*dang;\n    float angi2=(fidx+1.)*dang;\n    vec3 pi =vec3(cos(angi -vec2(0,PIH))*RR,0);\n    vec3 pi2=vec3(cos(angi2-vec2(0,PIH))*RR,0);\n    float d=10000.;\n    d=min(d,distChainSeg(rotX(PIH*(fidx+0.),rotZ(-(angi +PIH),p-pi )),R,r,lh));\n    d=min(d,distChainSeg(rotX(PIH*(fidx+1.),rotZ(-(angi2+PIH),p-pi2)),R,r,lh));\n    return d;\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// flatness: // 0->sphere, 100-> nearly cylindric\nfloat distTire(vec3 p, float r, float w, float h, float flatness)\n{\n    float l=length(p.xy);\n    //p=abs(p);\n    float d=1000.;\n    // outer sphere\n    float rfl=r*(1.+flatness);\n    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);\n    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);\n    //d=min(d,l-rz);\n    float ang = atan(p.x,p.y);\n    p.z+=cos(ang*64.)*w*.01*smoothstep(.87*r,1.*r,l);\n    // main torus\n    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);\n    //d=max(d,-l+r*.61);\n    float w_l=sqrt(w*w-h*h); // w_laufflaeche\n    float dz=.243*w_l;\n    float zfr=mod(p.z,dz);\n    float z=p.z-zfr+dz*.5;\n    // rillen\n    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);\n    // rim radius\n    d=max(d,-(l-(r-h)));\n    return d;\n}\n\nfloat distRim(vec3 p, float r, float w, float sh)  // outer rim radius, rim width;\n{\n    vec3 p0=p;\n    p.z=abs(p.z);\n    float ang0 = atan(p.y,p.x);\n\n    float d=1000.,d2,d3;\n    float dmain=length(p.xy)-r-sh;\n    float dplane=-p.z+w*.5;\n    d=-smin_(dplane,-dmain,.005);\n    \n    d2=-smin_(-(dmain+.005),-(dplane-.005),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=-smin_(-(dmain+.02),-(dplane-.02),.01);\n    d=-smin_(-d,d2,.01);\n    \n    d2=dmain+.04;\n    d=-smin_(-d,d2,.01);\n    \n    dplane=-p0.z+w*.5;\n    d2=-smin_(-(dmain+.04),dplane+.015,.1);\n    float c5=cos(ang0*5.);\n    c5=-c5*.5+.5;\n    c5*=c5;\n    c5*=c5;\n    c5=1.-c5;\n    c5=mix(c5,0.,1.-clamp(((dmain+r+sh)-.045)/.03,0.,1.));\n    d3=-smin_(-(dmain+.115),-(dplane-.01*(.8+.5*c5)),.04);\n    d2=abs(-smin_(-d2,d3,.01))-.0015;\n    d2=max(d2,-p0.z-.01);\n    //d2=min(d2,);\n    d=min(d,d2);\n    \n    //d2=-smin_(-(dmain+.125),-(dplane-.015),.02);\n    //d=-smin_(-d,d2,.01);\n    \n    //return d;\n\n    ////d=max(d,-(distCyl(p-vec3(0,0,w*.5),r-sh*.5-.005,w*.05-.005)-.005));\n    //d2=length(p-vec3(0,0,+w*.03+r*1.5))-r*1.5;\n    //d2=-smin_(-d2,-(distCyl(p-vec3(0,0,0),r-sh*1.2-.005,w*1.-.005)-.005),.005);\n    //d=-smin(-d,d2,.01);\n    //return d;\n\n    float mang,ang;\n    float dang;\n\n    // rim holes\n    dang=PI2/12.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    vec2 cs=cos(ang-vec2(0,PIH));\n    d=max(d,-distCyl(p-vec3(r*.65*cs*(1.+3.*p.z),0.),.085*r,w*1.5));\n    \n    p=p0-vec3(0,0,.07);\n    \n    // screw holes\n    dang=PI2/5.;\n    mang=mod(ang0+dang*.5,dang);\n    ang=ang0-mang+dang*.5;\n    d2=distCyl(p-vec3(r*.3*cos(ang-vec2(0,PIH)),w*.05),.016,w*.19);\n    //d=max(d,-d2);\n    // screws\n    d=min(d, d2+.005);\n\n    // axle\n    d=min(d, distCyl(p,.045-.01,w*.25-.01)-.01);\n    return d;\n}\n\nfloat distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)\n{\n    float w=w_mm*.001;\n    float h=w*h_perc/100.;\n    float d=10000.,d2;\n    float rrim=rimD_inch*.5*.0254;\n    d2=distTire(p, rrim+h, w, h, flatness );\n    d=min(d,d2);\n    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001*2.5;\n    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );\n    d=min(d,d2);\n    return d;\n}\n\n\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nvec2 ROT(float ang, vec2 v) \n{ \n    vec2 cs=sin(vec2(1.6,0)+ang); \n    return mat2(cs,cs.yx*vec2(-1,1))*v;\n}\n\nfloat bigZ(vec2 p)\n{\n    vec2 p0=p;\n    \n    p=ROT(-.05,p);\n    \n    p+=vec2(0,.7);\n    //float falloff=exp(-dot(p,p));\n    float falloff=1./(1.+dot(p,p)*2.);\n    p=ROT(-PI2*.2*falloff*p.y,p-vec2(0,.7));   // locally rotate around x by 180 degrees\n\n    p.x+=.7*p.y;\n    \n    //p.x-=p.y;\n    p=-sign(p.y+p.x)*p;\n    \n    float d=abs(max(-p.y-.5,p.x));\n    d-=.04+.1/(1.+dot(p0,p0)*3.)+.03*min(p0.x,0.);\n    return d;\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(-x));\n}\n\n\n#define RUMPFW 1.3\n#define ALLW (RUMPFW*1.3)\n\n#define WheelDistF (1.44)\n#define WheelDistR (1.42)\n#define WheelPosFR (vec3(-WheelDistF*.5,-1.25,-.50))\n#define WheelPosRL (vec3( WheelDistR*.5, 1.05,-.50))\n#define WheelPosFL (vec3( WheelDistF*.5,-1.25,-.50))\n#define WheelPosRR (vec3(-WheelDistR*.5, 1.05,-.50))\n\nvec4 wheelOffs=vec4(0);\n#define WheelOffsRL wheelOffs.x\n#define WheelOffsRR wheelOffs.y\n#define WheelOffsFL wheelOffs.z\n#define WheelOffsFR wheelOffs.w\n\n#define WheelRadiusF .62\n#define WheelRadiusR .7\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}