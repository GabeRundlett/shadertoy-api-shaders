{
    "Shader": {
        "info": {
            "date": "1475886783",
            "description": "Closest distance to edges of Power Diagram. This is ShaderToy port. Here is original [url=http://polycu.be/edit/?h=cdpAH4]PolyCube version[/url]. Based on my [url=https://www.shadertoy.com/view/llG3zy]Faster Voronoi Edges[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "4tV3z3",
            "likes": 24,
            "name": "Power Diagram",
            "published": 3,
            "tags": [
                "voronoi",
                "noise",
                "worley",
                "distance",
                "cellular",
                "powerdiagram",
                "voronoiedges"
            ],
            "usePreview": 0,
            "username": "tomkh",
            "viewed": 1241
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2016-10-08\n\n// +LMB to see distance to circles\n\n// Relatively fast method to find closest distance to edges of Power diagram,\n// a weighted Voronoi diagram with squared weight subtracted from squared distance.\n// The edge between Power diagram of cells A and B can be also interpreted \n// as a segment spanned by intersection points of circles centered at A and B \n// with radii equal to respective weights. If sum of weights is bigger than the distance \n// between A and B, i.e. circles do not intersect, formula still holds.\n\n// PolyCube version: \n//   http://polycu.be/edit/?h=cdpAH4 - Power Diagram\n//   http://polycu.be/edit/?h=Gbhigy - Fast Voronoi Edges\n\n// ShaderToy references:\n//   https://www.shadertoy.com/view/llG3zy - My Fast Voronoi Edges (improved/corrected)\n//   https://www.shadertoy.com/view/ldl3W8 - IQ's Distance to Voronoi Edges\n//   https://www.shadertoy.com/view/4djSRW - Dave Hoskins wonderful hash functions\n\n#define SHOW_MODE 2\n // 0 = Distance to edge + mouse cursor for inspection\n // 1 = Distance to circle + mouse cursor for inspection\n // 2 = Display both and switch while pressing LMB\n\n#define ACCURACY 2\n // 0 = 3x3 both passes\n // 1 = 3x3 + 4x4 (fast + decent accuracy)\n // 2 = 4x4 both passes (improved accuracy)\n\n#define ANIMATE\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .5\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .0001\n\n// Max. distance\n#define MAX_D 9999.\n\nvec3 hash32(vec2 p)\n{\n   // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yxz+19.19);\n   vec3 o = fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n   #ifdef ANIMATE\n   o.z = 0.5 + ANIMATE_D*sin( iTime + o.z*6.283185 );\n   #endif\n   o.z *= 0.7071; // limit weight to 0..sqrt(2)/2 range\n   return o;\n}\n\n// Returns distance to closest circle with radius = weight\nfloat closest_circle( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    #if ACCURACY == 2\n    // shift by half-cell\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    #endif\n\n    float md = MAX_D;\n    vec3 mr;\n    #if ACCURACY == 2\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    #else\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    #endif\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        md = min( md, length(r) - o.z );\n    }\n    \n    return md;\n}\n\n// Power diagram-based continuous noise function (not used here)\nfloat power_noise( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    #if ACCURACY == 2\n    // shift by half-cell\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    #endif\n\n    float md = MAX_D;\n    #if ACCURACY == 2\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    #else\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    #endif\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        md = min( md, dot(r,r) - o.z*o.z );\n    }\n    \n    return md;\n}\n\n// Power Diagram edges,\n// returns closest distance to edge and closest cell with squared weight\nvec4 power_diagram( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    #if ACCURACY == 2\n    // shift by half-cell\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    #endif\n    \n    vec3 mr;\n\n    //--------------------------------------------------\n    // 1st pass: find weighted Voronoi cell for \"x\"\n    float md = MAX_D;\n    #if ACCURACY == 2\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    #else\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    #endif\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        float w = o.z*o.z;\n        float d = dot(r,r) - w;\n\n        if( d<md )\n        {\n            md = d;\n            mr = vec3(r, w);\n        }\n    }\n    //--------------------------------------------------\n    \n    #if ACCURACY == 1\n    // shift by half-cell\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n    #endif\n\n    //--------------------------------------------------\n    // 2nd pass: find closest weighted Voronoi edge\n    md = MAX_D;\n    #if ACCURACY >= 1\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    #else\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    #endif\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        vec2 dr = r - mr.xy;\n        float d = dot(dr,dr);\n        if( d>EPSILON ) {\n           float mf = (mr.z - o.z*o.z + d) / (2.*d);\n           md = min( md, dot( mix(mr.xy,r,mf), dr*(1./sqrt(d)) ) );\n        }\n    }\n    //--------------------------------------------------\n\n    return vec4(md, mr);\n}\n\n// Fast voronoi to get closest distance to generator points,\n// implemented/re-implemented by others many, many times already\nfloat fast_voronoi( in vec2 x )\n{\n    x -= .5;\n    vec2 n = floor(x);\n    vec2 f = fract(x) + .5;\n    \n    float md = MAX_D;\n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec3 o = hash32( n + g );\n        vec2 r = g + o.xy - f;\n        md = min(md, dot(r,r));\n    }\n    \n    return md;\n}\n\nvec3 plot( vec2 p, vec2 template_cursor, float ss )\n{\n   // Colors:\n   const vec3 interior = vec3(.2,.8,1.);\n   const vec3 exterior = vec3(1.,.4,.1);\n   const vec3 border = vec3(.1,.7,.3);\n   const vec3 point = vec3(1.,.5,0.);\n\n#if SHOW_MODE == 2\n   if (iMouse.z > 0.)\n   {\n#endif\n#if SHOW_MODE != 0\n   float c = sqrt(fast_voronoi(p));\n   float d = closest_circle(p);\n   float d2 = abs(d);\n   vec3 col =\n       mix(\n           mix(\n               (d2*1.4+.05)*mix(exterior,interior,sign(d)*.5+.5)*min(1.,d2*18.),\n               border,\n               smoothstep(.03,.01,d2)\n           )*min(1.,c*9.),\n           point,\n           smoothstep(.07,.05,c)\n       );\n   #if SHOW_MODE != 2\n   float dc = length(p - template_cursor);\n   if (dc < 2.) {\n       dc = abs(dc - abs(closest_circle(template_cursor)) + .03);\n       col = mix(col,vec3(1),smoothstep(ss,.0,dc));\n   }\n   #endif\n   return pow(col,vec3(.85));\n#endif\n#if SHOW_MODE == 2\n   }\n#endif\n#if SHOW_MODE != 1\n   vec4 cp = power_diagram(p);\n   float c = cp.x;\n    \n   float d = length(cp.yz);\n   //float d1 = sqrt(fast_voronoi(p));\n   float d2 = d - sqrt(cp.w);\n   float d3 = (1.-smoothstep(.06,.02,c));\n   vec3 col =\n   mix(      \n      mix(\n         mix(\n            (c*1.4+.05)*(sin(c*120.)*.1+.9)*interior*d3*min(1.,d*9.),\n            point,\n            smoothstep(.07,.05,d)\n         )*clamp(abs(d2)*18.,.7,1.),\n         point*d3,\n         max(smoothstep(.03,.01,abs(d2))*.5,\n             smoothstep(.03,.01,d2)*.2)\n      ),\n      border*(smoothstep(0.,.015,c)*.5+.5),\n      smoothstep(.04,.02,c)\n   );\n   #if SHOW_MODE != 2\n   float dc = length(p - template_cursor);\n   if (dc < 2.) {\n      dc = abs(dc - abs(power_diagram(template_cursor).x) + .03);\n      col = mix(col,vec3(1),smoothstep(ss,.0,dc));\n   }\n   #endif\n   return pow(col,vec3(.85))*1.2;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*4. + 4.; // scale differently for fullscreen\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) * sc / iResolution.y;\n    vec2 cursor = (abs(iMouse.xy) - iResolution.xy*.5) * sc / iResolution.y;\n\tfragColor = vec4(plot(uv, cursor, sc/iResolution.y), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}