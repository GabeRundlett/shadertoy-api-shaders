{
    "Shader": {
        "info": {
            "date": "1558676830",
            "description": "2D Line Segments Test.\nIntensity (bold), UV position (start - end), Gradation of line.\n\n24-05-19 PM 03:32 :: Refactor code, Update code. + Time UTC+0 Implemented.",
            "flags": 0,
            "hasliked": 0,
            "id": "3t23RD",
            "likes": 2,
            "name": "[liliilli] 2D Line Segments Test",
            "published": 3,
            "tags": [
                "liliilli"
            ],
            "usePreview": 0,
            "username": "liliilli",
            "viewed": 563
        },
        "renderpass": [
            {
                "code": "float DistLineToPoint(vec3 ro, vec3 rd, vec3 pos)\n{\n    vec3 ap = pos - ro;\n    return length(cross(ap, rd)) / length(rd);\n}\n\nfloat DistLineToPoint(vec2 ro, vec2 rd, vec2 pos)\n{\n    return DistLineToPoint(vec3(ro, 0), vec3(rd, 0), vec3(pos, 0));\n}\n\nfloat WeightSmoothV(float o, float scale, float p)\n{\n    return \n        smoothstep(o - scale / 2.0, o - scale, p) \n      + smoothstep(o + scale / 2.0, o + scale, p);\n}\n\nvec3 DrawLine(float pos, float line, float intensity, vec3 col, vec3 compColor)\n{\n    float lineOffset = step(0.2, WeightSmoothV(line, intensity, pos));\n    return mix(col, compColor, lineOffset);\n}\n\nfloat IsDown(vec2 start, vec2 end, vec2 pos)\n{\n    // Compare point.Y is in [start.Y, end.Y]\n    float insideY = step( \n        abs((end.y - pos.y) + (start.y - pos.y)),\n        abs(end.y - start.y)\n    );\n\n    // Get intersection.\n    float dx   = end.x - start.x;\n    float grad = float(end.y - start.y) / dx;\n    float resX = abs(dx) > 0.0 ? (pos.y + grad * start.x - start.y) / grad : end.x;\n\n    return float(resX < pos.x) * insideY;\n}\n\nfloat IsDown(vec4 segment, vec2 pos)\n{\n    return IsDown(segment.xy, segment.zw, pos);\n}\n\nvec3 DrawLineExt2(\n   \tvec2 start, vec2 end, \n    vec3 colStart, vec3 colEnd, \n    float intensity, \n    vec2 pos, vec3 compColor)\n{\n    // Common variable setting.\n    vec2 dir  = normalize(end - start);\n    vec2 side = -cross(vec3(0, 0, 1), vec3(dir, 0)).xy;\n    \n    vec4 upLine = vec4(start, end) - vec4(side, side) * intensity;\n    vec4 dnLine = vec4(end, start) + vec4(side, side) * intensity;\n    vec4 reLine = vec4(upLine.zw, dnLine.xy);\n    vec4 leLine = vec4(dnLine.zw, upLine.xy);\n\n    // Check pos is inside of area. using intersection checking.\n    const vec2 ray = vec2(1, 0);\n    vec4 psLine = vec4(pos, vec2(0, pos.y));\n    \n    // Dirty Way... Is there anyone who can improve this?\n    float intersected = 0.0;\n    intersected += IsDown(upLine, pos);\n    intersected += IsDown(dnLine, pos);\n    intersected += IsDown(reLine, pos);\n    intersected += IsDown(leLine, pos);\n    float isInside = mod(intersected, 2.0);\n    \n    // Get lerp color with trigonometric function.\n    // pos * isInside is important to avoid artifact dot line.\n    float hypot  = length(end - pos);\n    float dist   = DistLineToPoint(start, normalize(end - start), pos * isInside);\n    float offset = sqrt((hypot * hypot) - (dist * dist)) / length(end - start);\n    \n    // Mix.\n    vec3 pointCol = mix(colEnd, colStart, offset) * isInside;\n    return mix(compColor, pointCol, isInside);\n}\n\nvec2 Rotate(vec2 origin, vec2 pos, float radian)\n{\n    vec2 before = pos - origin;\n    vec2 after = vec2(\n        dot(vec2(cos(radian), -sin(radian)), before),\n        dot(vec2(sin(radian), cos(radian)), before));\n        \n   \treturn after;\n}\nvec2 Rotate(vec2 pos, float radian)\n{\n    return Rotate(vec2(0), pos, radian);\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    uv.x -= (iResolution.x - iResolution.y) / \n        (2.0 * min(iResolution.x, iResolution.y)); \n    uv -= 0.5;\n    \n    vec3 result = vec3(0);\n    \n    // Artifact. vec2(0.0, ..) create upper-Y jagging artifact in ShaderToy.\n    // (KodeLife does not create artifact)\n    result = DrawLineExt2(vec2(0.0001, -0.25), vec2(0, 0.25), \n                         vec3(.2, .2, .2), vec3(1, 1, 1),\n                         .25f, uv, result);\n    \n    result = DrawLine(uv.y, 0.f, .004f, vec3(1), result);\n    result = DrawLine(uv.x, 0.f, .002f, vec3(1), result);\n    \n    // Add time. (UTC+0)\n    const float kPi = 3.1415926535f;\n    float timestamp = iDate.w;\n    float seconds   = mod(timestamp, 60.0);\n    float minutes   = timestamp / 60.0;\n   \tfloat hours     = timestamp / 3600.0;\n    \n    result = DrawLineExt2(vec2(0, 0), Rotate(vec2(0, 0.5), -kPi / 30. * seconds), \n                          vec3(0, 0, 1), vec3(1, 1, 0),\n                          .008f, uv, result);\n    result = DrawLineExt2(vec2(0, 0), Rotate(vec2(0, 0.4), -kPi / 30. * minutes),\n                         vec3(1, 0, 0), vec3(0, 1, 0),\n                         .016f, uv, result);\n    result = DrawLineExt2(vec2(0, 0), Rotate(vec2(0, 0.3), -kPi / 12. * hours),\n                         vec3(1, 0, .5), vec3(0, .5, 1),\n                         .032f, uv, result);\n\t\n    fragColor = vec4(result, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}