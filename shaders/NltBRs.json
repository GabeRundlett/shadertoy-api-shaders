{
    "Shader": {
        "info": {
            "date": "1663523201",
            "description": "I fancied modelling the Dune ornithopter. :)\nApologies if performance is a problem - This one is a bit GPU-hungry.\nYouTube: https://youtu.be/01X29MpidM8",
            "flags": 0,
            "hasliked": 0,
            "id": "NltBRs",
            "likes": 45,
            "name": "Dune Ornithopter",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sand",
                "dune",
                "movie",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 4072
        },
        "renderpass": [
            {
                "code": "// 'Dune Ornithopter' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/NltBRs (YouTube: https://youtu.be/01X29MpidM8)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// I fancied modelling the Dune ornithopter. :)\n// Apologies if performance is a problem - This one is a bit GPU-hungry.\n//\n// Tricks to aid performance:\n//   - Precalculate function results, rotation matrices, and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - The 'copter SDF is not calculated when the ray is too far away.\n//   - Shadows not calculated if surface normal points away from the sun.\n//   - Only the ground and sky are reflected.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n//\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\n/// Global time.\nfloat gt, WING_SPEED, fade = 1.;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, int id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nvoid UH(inout Hit h, Hit h2) { if (h2.d < h.d) h = h2; }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat mul3(vec3 v) { return v.x * v.y * v.z; }\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// Two n31 results from two scales.\nvec2 n331(vec3 p) {\n\treturn vec2(n31(p * 20.), n31(p * 38.));\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b) {\n\tfloat h = sat(.5 + .5 * (b - a) / -.05);\n\treturn mix(b, a, h) + .05 * h * (1. - h);\n}\n\nfloat remap(float f, float in1, float in2) { return sat((f - in1) / (in2 - in1)); }\n\n// Dip below 0, overshoot 1, back down to 1.\nfloat backInOut(float x) {\n\tfloat f = x < .5 ? 2. * x : 1. - (2. * x - 1.),\n\t      g = pow(f, 3.) - f * sin(f * 3.141);\n\treturn x < .5 ? .5 * g : .5 * (1. - g) + .5;\n}\n\n// Ray/plane intersection.\nbool intPlane(vec3 p0, vec3 n, vec3 ro, vec3 rd, out float t) {\n\tfloat denom = dot(n, rd);\n\tt = dot(p0 - ro, n) / denom;\n\treturn t >= 0. && abs(denom) > 1e-4;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat honk(inout vec3 p, mat2 rot, vec2 r) {\n\tp.xy *= rot;\n\tfloat d = cap(p, r.x, r.y);\n\tp.x -= r.x;\n\treturn d;\n}\n\nfloat oct3D(vec3 p, float r, float h) {\n\tconst vec3 k = vec3(-.9239, .3827, .4142);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tp.xy -= 2. * min(dot(vec2(-k.x, k.y), p.xy), 0.) * vec2(-k.x, k.y);\n\tp.xy -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n\tvec2 d = vec2(length(p.xy) * sign(p.y), p.z - h);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 sky(vec3 rd) { return mix(mix(vec3(.74, .61, .52), vec3(.85, .81, .74), S(-.2, 0., rd.y)), vec3(1.54, 1.28, 1.23), S(.4, 1., dot(rd, vec3(-.33, .67, .67)))); }\n\n// Shameless self-promotion. :)\nfloat dtc(vec2 p, float fl) {\n\tp += vec2(.8, .9);\n\tp.y += p.x;\n\tp.x *= fl;\n\tp *= vec2(2.5, 3);\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return 0.;\n\tif (step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.) return 1.4;\n\tfloat f,\n\t      dc = step(.5, p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\treturn dc > 0. ? .8 : 0.;\n}\n\nvec2 dockFeet;\nHit wing(vec3 p, float ti, float isTop, float isBack) {\n\tp.y += .1 * (isTop * 2. - 1.) * (1. - isBack);\n\tp.xz *= rot(isBack * .1);\n\tif (isTop > 0.) {\n\t\tp.xy *= mat2(.995, .09983, -.09983, .995);\n\t\tti += .2;\n\t}\n\n\t// Wing dock and spin.\n\tp.xz *= rot(mix(1.25, 1.4, isBack) * dockFeet.x);\n\tp.yz *= rot(dockFeet.x * 5.2);\n\tfloat a, f, d, thk,\n\t      l = length(p);\n\tHit h = Hit(max(l - .35, p.x - .1), 3, p); // Ball socket. // Wing time.\n\ta = sin(3.141 * isBack + ti * WING_SPEED * 70. - abs(p.x) / 34.78261); // Pivot wing, and bend ends.\n\tf = max(sin(p.x * 70.), 0.) * .01; // Ridges.\n\td = l - .3; // Ball joint.\n\ta *= S(12., 12.5, gt); // Fade in initial wing movement.\n\td = min(d, honk(p, rot(a * .05), vec2(2, .16 - f))); // Wing rod.\n\tp.x -= 7.9;\n\tp.z -= .18;\n\n\t// Wing.\n\tthk = 1.01 - WING_SPEED;\n\tvec3 v = vec3(8, .04 * thk, .4);\n\tv.z -= .35 * sat(-6. - p.x) * sat(sign(p.z));\n\td = min(d, box(p, v - (.03 - .05 * S(-.35, -.15, p.z)) * thk));\n\tU(h, d, 3, p);\n\treturn h;\n}\n\nHit wings(vec3 p, float ti) {\n\tHit h;\n\th.d = 1e7;\n\tp.x--;\n\tp.y -= .1;\n\tvec3 dyz = vec3(0, .8, .8);\n\tfloat b = 1.;\n\tfor (float i = Z0; i < 2.; i++) {\n\t\tUH(h, wing(p - dyz * vec3(1, 1, -1), ti, b, 1. - b));\n\t\tUH(h, wing(p - dyz, ti, b, b));\n\t\tdyz = -dyz;\n\t\tb = 1. - b;\n\t}\n\n\treturn h;\n}\n\nvec3 rot2(vec3 p, float r) {\n\tp.xz *= rot(1.57079);\n\tp.yz *= rot(r);\n\treturn p;\n}\n\n// Copter pitch, height, distance.\nvec3 cop;\n\nvec3 copterPos(vec3 p) {\n\tp.yz *= rot(cop.x);\n\treturn p;\n}\n\n// 'smooth' abs().\nfloat sabs(float f) { return sqrt(f * f + 3e-4); }\n\nHit gnd(vec3 p) {\n\tp.y += cop.y;\n\tp.z -= cop.z;\n\tfloat h1,\n\t      lz = S(0., 90., length(p.xz));\n\tp.y += 1.77;\n\tvec3 pp = p;\n\tp.x += sin(p.z * .02 + 1.4 * n21(p.zx * .05)) * 15.;\n\n\t// Dunes.\n\th1 = (1. - sabs(sin(p.x * .03))) * 12.;\n\n\t// Sand bumps.\n\treturn Hit((p.y - mix(max(-.7, sin(p.x * 10. + sin(p.z + p.y))) * .02 * (1. - lz), h1, lz * lz)) * .9, 4, pp);\n}\n\nHit map(vec3 p) {\n\tp = p.zyx;\n\tHit h = gnd(p);\n\n\t// Optimization - Not close enough to the 'copter to bother including it.\n\tif (abs(p.z) > 52.) return h;\n    \n\tp = copterPos(p);\n\tp.x = abs(p.x);\n\tvec3 q,\n\t     op = p;\n\n\t// Legs.\n\tp += vec3(-.3, .8, .8);\n    mat2 m = mat2(.87758, .47943, -.47943, .87758);\n\tp.xy *= m;\n\tfloat f,\n\t      d = honk(p.zyx, rot(-dockFeet.y * .5), vec2(1, .1));\n\td = min(d, honk(p.zyx, rot(3.4 + dockFeet.y * .8), vec2(1, .1)));\n\tp.yz *= rot(.25 + .31 * S01(dockFeet.y));\n\tp.xy *= m;\n\td = min(d, box(p + vec3(0, -.05 * S(.2, .4, abs(p.z)), 0), vec3(.14, .05, .4)));\n\tp.z -= .3;\n\tp.y += (S(1., 1.3, abs(p.z)) - 1.) * .05;\n\td = min(d, box(p, vec3(.2, .03, 1.2)) - .02);\n\tU(h, d, 3, p);\n\tp = op;\n\n\t// Tail.\n\td = oct3D(p.xzy - vec3(0, 14.8, .4), 1., .3 - .2 * p.x);\n\n\t// Fuselage.\n\tp.z += 4.2;\n\tf = S(5., 10., p.z);\n\tp.y = abs(p.y - .1 - .3 * f) + .4;\n\td = min(d, oct3D(p - vec3(0, 0, 10), 1.3 - f * .6, 10.));\n\n\t// Cockpit.\n\tp = op;\n\tp.y -= 4.4;\n\tp.yz *= mat2(.97367, -.22798, .22798, .97367);\n\tp.z += 4.;\n\td = max(d, p.x - p.z * .4 - .6);\n\td = max(d, -p.z - 1.18);\n\tq = p;\n\tq.y += .3 * abs(sat(p.x - .28 - .14 * p.z));\n\n\t// Windows.\n\tf = S(.06, 0., abs(q.z) - .9) * S(.52, .46, q.x - q.z * .32);\n\tf *= step(-3., q.y);\n\n\t// Nose top slope.\n\td = max(d, f * .015 - oct3D(q.zyx, 3., 2.));\n\n\t// Nose window side cut-outs.\n\tp += vec3(-3.02, 3.5, 1.28);\n\tp.y -= max(0., p.z - 1.5) * S(.2, 0., p.y);\n\tp.yz *= mat2(.99755, .06994, -.06994, .99755);\n\tp.xz *= mat2(.90045, .43497, -.43497, .90045);\n\td = smin(d, -oct3D(p.xzy, 3., .65) - .2);\n\n\t// Glass.\n\tf += step(-.4, p.y) * mul3(step(p, vec3(p.z * 1.02 - 3.9, .43, 2.8)));\n\tU(h, d - .05, 3 - 2 * int(step(1., f)), p);\n\n\t// Wings.\n\tUH(h, wings(op, gt));\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat d,\n\t      s = 1.,\n\t      t = .01;\n\tfor (float i = Z0; i < 47.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 25. * d / t);\n\t\tt += max(.05, d);\n\t\tif (70. - t < .5 || s < .01) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n, vec2 h, float wingDock) {\n\tfloat od = dockFeet.x;\n\tdockFeet.x = wingDock;\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = map(h[i] * n + p).d;\n\n\tdockFeet.x = od;\n\treturn sat(min2(ao / h));\n}\n\nfloat fog(float d) { return S(0., -80., d - 4e2); }\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tconst vec3 ld = vec3(-.33333, .66667, .66667);\n\tfloat fre,\n\t      spe = 10.,\n\t      shine = 1.;\n\tvec3 c, l, sc;\n\tif (h.id == 4) {\n\t\t// Sand.\n\t\tc = vec3(.45, .35, .23);\n\t\tspe = .1;\n\t\tvec2 uv = h.p.xz * 1e2;\n\t\tshine = .05 + .1 * S(h21(floor(uv)), 0., length(fract(uv) - .5));\n\t\tfloat dust = S(1., 0., abs(gt - 21.) / 7.);\n\t\tif (dust > 0.) {\n\t\t\tfloat l = length(p.xz);\n\t\t\tdust *= S(15., 0., abs(l - 9.));\n\t\t\tdust *= n21(vec2(atan(p.x, p.z), l - gt * 20.) * vec2(12, 2));\n\t\t\tc = mix(c, vec3(.63, .49, .322), dust);\n\t\t}\n\t}\n\telse if (h.id == 3) {\n\t\t// 'copter.\n\t\tvec2 ns = n331(h.p);\n\t\tshine = 1.2 - sum2(ns) * .3;\n\t\tshine += dtc(h.p.xy, sign(p.z));\n\t\tc = vec3(.0185, .0165, .0125) * shine;\n\t\tfloat sand = S(.9, 0., ao(p, n, vec2(.2, 1.3), 0.) - ns.x * .45);\n\t\tsand *= .5 + .5 * ns[1];\n\t\tc = mix(c, vec3(.45, .35, .23), sand * .16);\n\t}\n\telse {\n\t\t// Window.\n\t\tc = vec3(.01);\n\t\tshine = 10.;\n\t\tspe = 20.;\n\t}\n\n\tl = sat(vec3(dot(ld, n),  // Key light.\n                 sat(-n.y),  // Reverse light.\n                 sat(n.y) // Sky light.\n\t       ));\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl.yz *= .1 + .9 * ao(p, n, vec2(.2, 1), dockFeet.x); // Ambient occlusion.\n\tl *= vec3(1.1, .25, .3); // Light contributions (key, reverse, sky).\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine; // Specular (Blinn-Phong)\n\tl.x *= .01 + .99 * shadow(p, ld, n); // Shadow.\n\tfre = S(.7, 1., 1. + dot(rd, n)) * .05;\n\tsc = sky(rd);\n\treturn mix((sum2(l.xy) * vec3(2.4, 2, 1.92) + l.z * sc) * c, sc, fre);\n}\n\nfloat addFade(float a) { return min(1., abs(gt - a)); }\n\nvec3 scene(vec3 ro, vec3 rd) {\n\tfade = addFade(0.) * addFade(20.);\n\n\t// March the scene.\n\tvec3 n, col,\n\t     p = ro;\n\tfloat i,\n\t      d = 1.;\n\tHit h;\n\tfor (i = Z0; i < 150.; i++) {\n\t\th = map(p);\n\n\t\tif (abs(h.d) < .001 * d || d > 4e2) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tn = N(p, d);\n\tcol = mix(sky(rd), lights(p, rd, n, h), fog(d));\n\n\t// Wing blur.\n\tfloat blurVis = S(.4, .7, WING_SPEED);\n\tif (blurVis > 0.) {\n\t\tconst mat2 m1 = mat2(.63268e-5, 1, -1, .63268e-5);\n\t\tfloat t,\n\t\t      ws = gt * WING_SPEED;\n\t\tmat2 m2 = rot(-cop.x);\n\t\tvec3 pn = vec3(0, 0, 1);\n\t\tpn.yz *= m2;\n\t\tpn.xz *= m1;\n\t\tfor (float dz = -1.; dz <= 1.; dz += 2.) {\n\t\t\tvec3 copP = vec3(0, 0, .8 * dz);\n\t\t\tcopP.yz *= m2;\n\t\t\tcopP.xz *= m1;\n\t\t\tfor (float dy = -1.; dy <= 1.; dy += 2.) {\n\t\t\t\tif (intPlane(copP, pn, ro, rd, t) && t < d) {\n\t\t\t\t\tp = rot2(rd * t + ro, cop.x);\n\t\t\t\t\tp.x = abs(p.x);\n\t\t\t\t\tp.xy *= rot(.1 * sat(-dy));\n\t\t\t\t\tp.y += .8 * dy + sat(-dy) * .3;\n\t\t\t\t\tfloat tint = sin(p.y * 120. / p.x + ws * 10.);\n\t\t\t\t\ttint *= sin(p.y * 80. / p.x - ws * 20.);\n\t\t\t\t\ttint = sat(tint * .5 + .9);\n\t\t\t\t\ttint *= S(1.5, 2., p.x);\n\t\t\t\t\ttint *= S(6., -5., p.x - 16.);\n\t\t\t\t\ttint *= S(p.x * .15, 0., abs(p.y));\n\t\t\t\t\tcol = mix(col, vec3(.02, .03, .01), tint * .4 * blurVis);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (h.id < 2) {\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\td = .01;\n\t\tfor (i = Z0; i < 32.; i++) {\n\t\t\th = gnd(p.zyx);\n\t\t\tif (abs(h.d) < .0015 * d || d > 10.) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tvec3 sc = sky(rd);\n\t\tcol += .1 * (d > 10. ? sc : mix(sc, lights(p, rd, N(p, d), h), fog(d)));\n\t}\n\n    // Gamma.\n\treturn pow(max(vec3(0), col), vec3(.4545));\n}\n\n#define rgba(col)\tvec4(col * fade, 0)\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tgt = mod(iTime, 60.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\n\t// Camera.\n\tfloat fly, x,\n\t      camDrift = remap(gt, 30., 34.);\n\tvec3 ro, col,\n\t     cam = mix(vec3(0, .30, .125), vec3(.44, .58, .32), S01(remap(gt, 0., 10.)));\n\tcam = mix(mix(mix(mix(cam, vec3(.37, .78, .44), S01(remap(gt, 9., 20.))), vec3(.46, .5, .19), S01(remap(gt, 20., 20.01))), vec3(.35, .53, .3), S01(remap(gt, 20.01, 25.))), vec3(.8, .75, 1.25), S01(remap(gt, 31., 33.)));\n\tWING_SPEED = pow(ceil(pow(remap(gt, 12., 18.), 2.) * 4.) / 4., 2.);\n\n\t// Movement.\n\tfly = remap(gt, 28., 30.);\n\tx = max(0., gt - 29.) * fly;\n\tcop.z = x * (1. - exp(-.1 * x)) * 250.;\n\tcop.y = 8. * sin(x * 1.5) * camDrift;\n\tcop.y += 8. + fly * 22.;\n\tcop.y *= S01(remap(gt, 24., 27.));\n\tcop.x = (cop.x / -360. - backInOut(fly)) * .2;\n\tdockFeet = vec2(S(9., 5., gt), remap(gt, 29., 25.));\n\n\t// Camera drift.\n\tcam += vec3(sin(gt * .4) * .05 - .05 - sin(gt * .1), sin(gt * .6) * .05, sin(gt * .5) * .8) * camDrift;\n\n\t// Scene.\n\tro = vec3(0, 0, -35. * cam.z);\n\tro.yz *= rot(1. - cam.y * 2.);\n\tro.xz *= rot(cam.x * -6. - 3.);\n\tcol = scene(ro, rayDir(ro, uv));\n\n\t// Vignette.\n\tcol *= 1. - .3 * dot(uv, uv);\n\n\t// Grain.\n\tcol += (h21(fc) - .5) / 32.;\n    \n\tfragColor = rgba(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}