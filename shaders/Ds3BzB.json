{
    "Shader": {
        "info": {
            "date": "1697312890",
            "description": "Naive approach, but it does work.\n\nPress SPACE to toggle amount of trailing. ENTER to toggle time dilation.",
            "flags": 48,
            "hasliked": 0,
            "id": "Ds3BzB",
            "likes": 9,
            "name": "Geometric Dot Transform",
            "published": 3,
            "tags": [
                "2d",
                "dots",
                "morph",
                "dot",
                "transform",
                "multipass",
                "linearinterpolation"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 245
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float v = texelFetch( iChannel0, ivec2(int(fragCoord.x),int(fragCoord.y)), 0 ).x;\n\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    float blue = abs(uv.y) < 0.43 ? 0.13 : 0.;\n    float white = blue>0. && abs(uv.y) > 0.427 && abs(uv.x)<0.85 ? 1. : 0.;\n    \n    fragColor = vec4( white+v*0.9, white+v*0.95, white+blue+v, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// prepare shape\n\nvec2 iResHalf;\n\nvec2 circle(float i, float xradius, float yradius, float epm, float tm, vec2 pos) {\n    float cp = (PI*2. / float(NOF_DOTS)) * (i*epm);\n    float asp = iResolution.y / iResolution.x;\n    return vec2(iResHalf.x+pos.x+sin(cp)*(asp*iResolution.x*xradius), iResHalf.y+pos.y+cos(cp*tm)*(iResolution.y*yradius));\n}\n\nvec2 randbox(float i, float xradius, float yradius, float rp, vec2 pos) {\n    float asp = iResolution.y / iResolution.x;\n    return vec2(iResHalf.x+pos.x+(hash1(i*0.1+rp)-.5)*(asp*iResolution.x*xradius), iResHalf.y+pos.y+(hash1(i*0.1+0.11+rp)-.5)*(iResolution.y*yradius));\n}\n\nvec2 boxr(float i, float xradius, float yradius, float rp, vec2 pos) {\n    float asp = iResolution.y / iResolution.x;\n    if ((int(i) & 1) == 1)\n        return vec2(iResHalf.x+pos.x+(hash1(i*0.1+rp)-.5)*(asp*iResolution.x*xradius), iResHalf.y+pos.y+(hash1(i*0.1+0.11+rp)>0.5?0.5:-0.5)*(iResolution.y*yradius));\n    else\n        return vec2(iResHalf.x+pos.x+(hash1(i*0.1+rp)>0.5?0.5:-0.5)*(asp*iResolution.x*xradius), iResHalf.y+pos.y+(hash1(i*0.1+0.11+rp)-.5)*(iResolution.y*yradius));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pxi = floor(fragCoord.y * iResolution.x + fragCoord.x - 1.);\n    if (fragCoord.y > 2.5) discard;\n\n    int frame= iFrame;\n    if (readKeyToggle(KEY_ENTER)) frame += int(pxi*0.25);\n\n    iResHalf = iResolution.xy * 0.5;\n    vec2 v0 = vec2(0.);\n    vec2 v1 = vec2((iResHalf.x*0.5) * (((frame/(NOF_SEQ_STEPS*NOF_ANIMS))&1)==1?1.:-1.), 0.);\n\n    vec2 sp=v0, ep=v0;\n    int animIndex = (frame / NOF_SEQ_STEPS) % NOF_ANIMS;\n    switch(animIndex) {\n        case 0:\n            sp = circle(pxi, 0.4, 0.4,  1., 1., v0); \n            ep = circle(pxi, 0.1, 0.1,  40.5, 1., v0);\n            break;\n        case 1:\n            sp = circle(pxi, 0.1, 0.1,  4.5, 1., v0);\n            ep = circle(pxi, 0.4, 0.4,  1., 1., v0); \n            break;\n        case 2:\n            sp = circle(pxi, 0.4, 0.4,  1., 1., v0); \n            ep = circle(pxi, 0.0, 0.35,  125.5, 1., v1);\n            break;\n        case 3:\n            sp = circle(pxi, 0.0, 0.35,  125.5, 1., v1);\n            ep = circle(pxi, 0.65, 0.25,  1., 1., v0); \n            break;\n        case 4:\n            sp = circle(pxi, 0.65, 0.25,  1., 1., v0); \n            ep = randbox(pxi, 0.7, 0.7,  0., v0);\n            break;\n        case 5:\n            sp = randbox(pxi, 0.7, 0.7,  0., v0);\n            ep = circle(pxi, 0.2, 0.2,  3., 3., v0); \n            break;\n        case 6:\n            sp = circle(pxi, 0.2, 0.2,  3., 3., v0); \n            ep = boxr(pxi, 1.7, 0.8,  0.17, v0);\n            break;\n        case 7:\n            sp = boxr(pxi, 1.7, 0.8,  0.17, v0);\n            ep = circle(pxi, 0.2, 0.2,  3., 4., v0); \n            break;\n        case 8:\n            sp = circle(pxi, 0.2, 0.2,  3., 4., v0); \n            ep = circle(pxi, 0.4, 0.4,  1., 1., v0); \n            break;\n    }\n\n    float FNS = float(NOF_STEPS);\n\n#ifdef SMOOTH_TRANSITION\n    float lpsm =  min(1., float(frame % NOF_SEQ_STEPS) / FNS);\n    vec2 fp = sp + ((ep-sp)/FNS) * smoothstep(0.,1.,lpsm)*FNS;\n#else\n    vec2 fp = sp + ((ep-sp)/FNS) * min(FNS, float(frame % NOF_SEQ_STEPS));\n#endif\n\tfragColor = vec4(fp, 0.,0.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int NOF_DOTS = 950;\nconst int NOF_STEPS = 100;\nconst int NOF_WAIT_STEPS = 8;\nconst int NOF_SEQ_STEPS = NOF_STEPS + NOF_WAIT_STEPS;\nconst int NOF_ANIMS = 9;\n\nconst int NOF_REGIONS = 9;\nconst int BPC = NOF_REGIONS * NOF_REGIONS /4 + 1;\n\n#define SMOOTH_TRANSITION\n\n//#define LARGE_DOTS\n\nconst float PI = 3.14159265359;\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_D     = 68;\n\n#define readKeyToggle(key) (texelFetch( iChannel3, ivec2(key, 2), 0).x > .5)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//check which regions have dots\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 2.5) discard;\n    \n    if (ivec2(0,0)==ivec2(fragCoord)) {\n\n        int xd=int(iResolution.x) / NOF_REGIONS + 1;\n        int yd=int(iResolution.y) / NOF_REGIONS + 1;\n        ivec2 r = ivec2(textureSize(iChannel0, 0));\n\n        ivec4 regions = ivec4(0);\n        for (int i=0; i<NOF_DOTS; i++) {\n            ivec2 p=ivec2(i%r.x,i/r.x); \n            vec2 px = texelFetch(iChannel0, p, 0 ).xy;\n            \n            int xr=int(px.x) / xd;\n            int yr=int(px.y) / yd;\n            int reg = xr + yr * NOF_REGIONS;\n            int cp = reg / BPC;\n            int bp = reg % BPC;\n            regions[cp] |= (1<<bp);\n        }\n        fragColor = vec4(regions);\n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// draw dots in place and fade old ones\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool alt = !readKeyToggle(KEY_SPACE);\n    float val = max(0.,texelFetch(iChannel1, ivec2(fragCoord), 0 ).x - (alt? 0.02 : 0.25));\n\n    vec4 regions = texelFetch(iChannel0, ivec2(0,0), 0 ); \n    int xd=int(iResolution.x) / NOF_REGIONS + 1;\n    int xr=int(fragCoord.x) / xd;\n    int yd=int(iResolution.y) / NOF_REGIONS + 1;\n    int yr=int(fragCoord.y) / yd;\n    int reg = xr + yr * NOF_REGIONS;\n    int cp = reg / BPC;\n    int bp = reg % BPC;\n    if ((int(regions[cp]) & (1<<bp)) == 0) {\n        fragColor = vec4(min(1.,val));\n        if (readKeyToggle(KEY_D)) fragColor = vec4(0.5); // see skipped regions\n        return;\n    }\n\n    ivec2 r = ivec2(textureSize(iChannel1, 0));\n    float hitadd = alt? 0.33 : 1.0;\n\n    for (int i=1; i<=NOF_DOTS; i++) {\n        ivec2 p=ivec2(i%r.x,i/r.x); \n        vec2 px = texelFetch(iChannel0, p, 0 ).xy;\n#ifdef LARGE_DOTS\n        if (distance(px,fragCoord) < 3.0) {\n#else\n        if (ivec2(px) == ivec2(fragCoord)) {\n#endif\n            val += hitadd; hitadd=0.;\n            // break; // slows things down, a lot...\n        }\n    }\n\tfragColor = vec4(min(1.,val));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}