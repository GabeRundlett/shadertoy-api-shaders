{
    "Shader": {
        "info": {
            "date": "1635963815",
            "description": "Just an ordinary blue box!\n\nTime And Relative Dimension(s) In Space\nResembling the 13.Doctor's Tardis from the British TV-series \"Doctor Who\".\n\nWalk around (and inside!) with WASD or arrow keys.",
            "flags": 48,
            "hasliked": 0,
            "id": "7dKSRG",
            "likes": 22,
            "name": "TARDIS",
            "published": 3,
            "tags": [
                "portal",
                "drwho",
                "tardis",
                "doctorwho"
            ],
            "usePreview": 0,
            "username": "efelo",
            "viewed": 513
        },
        "renderpass": [
            {
                "code": "//Copyright © 2021 efelo\n////////////////////\n////////////////////\n////////////////////\n//Still not done, but fps and motivation droped while compile time increased, so i decided to stop here, maybe.\n//\n//I hope the shader runs for you!\n//\n//\n////////////////////\n//the TARDIS\n//    short for \"Time And Relative Dimension(s) In Space\"\n//    is the space and time ship of an alien called the doctor.\n//    the TARDIS can travel in time and space.\n//    its inside is larger than its outside.\n//    the outside should change its shape to fit the surounding it lands in. But is stuck and looks like a police box.\n//    the inside is decorated diffrently from time to time.\n//    this shader respresents the Tardis of the 13. doctor.\n////////////////////\n//thechnical:\n//    the outside is fast.\n//    the inside is slow but hard to optimize.\n//    Inside and outside are two sdfs joined and swiched between by the \"inside\" variable.\n//    a raytraced portal in the open door moves raymarcher and camera between them.\n//    if you walk through walls you don't get moved.\n//    console and inside walls are low on detail.\n//    lighting is phong based with some fake ambient oclusion and fressnel.\n//    the noise is a fake normal map exept the pylons those are 3d.\n//    inside lighting looks strange implemented with one point light.\n////////////////////\n//compile time/speed optimization atempts:\n//    reduced noise functions to one for normalmap and one for the pylons\n//    shadow only sdf with only the outside rendered\n//    remove length() from box() and cylinder() functions where possible\n//    unwrap cone() and cylinder() functions to share lenght() operations\n//    use rotation tricks to not render the door seperately (has some artefacts)\n//    use as many symetries as possible\n//    material and normalmap are testet in the same function to share bounding boxes.\n//    use an extra function for hexagonal symetries to reduce use of polar coordinates.\n//    use #define ZERO (min(iFrame,0)) (no effect for me)\n//failed:\n//    use noise on whole sdf to remove the normalmap function.\n//    use matrial ids to reduce vec4 asignments\n//    use sphere inside Tardis to accelerate raymarching (still there and creates artefacts on the ceiling)\n//    use volume texture for noise (creates strange patterns on the pylons, maybe 8bit limit?)\n////////////////////\n//further ideas(but very expensive):\n//    time-traveling to different procedural landscapes\n//    different tardis interiors\n//    tardis ambient sounds inside tardis (no idear how to pull of)\n////////////////////\n\n\n#define ZERO (min(iFrame,0))\n\n////////////////////\n//texture lookups\n////////////////////\n\nvec4  get_buf(int adress)              {return texelFetch(iChannel0, ivec2(adress,0), 0);}\nfloat get_glyph(vec2 uv, float glyph)  {return    texture(iChannel2, vec2(uv + vec2(floor(mod(glyph, 16.)), 15. - floor(glyph / 16.))) / 16.).a;} \n\n\n////////////////////\n//sdf functions\n////////////////////\n//from iq:\n\n\n//box\nfloat box(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return max(q.x,max(q.y,q.z));//cheaper?\n    //return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//cylinder\nfloat cyl(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//cylinder\nfloat cheap_cyl(vec3 p, float h, float r)\n{\n  return max(abs(p.z)-r, length(p.xy)-h);\n}\n\n\n//cone cheap\n//float con(vec3 p, vec2 c, float h)\n//{\n//  float q = length(p.xy);\n//  return max(dot(c.xy,vec2(q,p.z)),-h-p.z);\n//}\n\n\n//torus\nfloat tor(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//plane\nfloat pln(vec3 p, vec3 dir)\n{\n    return dot(p,dir);\n}\n\n\n//sphere\nfloat sph(vec3 p, float rad)\n{\n    return length(p) - rad;\n}\n\n\n//capsule\nfloat cap(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return length( pa - ba*h ) - r;\n}\n\n\n//caped cone\nfloat cop(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n\n\n////////////////////\n//noise\n////////////////////\n///*\n//derived from demofox\nvec2 hash2(ivec3 pos)\n{\n    uvec3 ipos = uvec3(pos);\n    //4dim to seed\n    uint seed = (ipos.x * 1973u + ipos.y * 9277u + ipos.z * 26699u) | 1u;\n\n    //hash\n    seed *= 0x27d4eb2du;\n    seed = seed   ^ (seed   >> 15);\n    seed *= 0x27d4eb2du;\n    uint seed2 = seed   ^ (seed   >> 15);\n    seed2 *= 0x27d4eb2du;\n    //hash to float\n    return vec2(seed,seed2) / 4294967296.0;\n}\n\n\n\nvec2 noise3d2(vec3 pos)\n{\n    vec3  f = floor(pos);\n    ivec3 i = ivec3(f);\n    \n    vec2 r000 = hash2(i + ivec3(0,0,0));\n    vec2 r100 = hash2(i + ivec3(1,0,0));\n    vec2 r010 = hash2(i + ivec3(0,1,0));\n    vec2 r110 = hash2(i + ivec3(1,1,0));\n    vec2 r001 = hash2(i + ivec3(0,0,1));\n    vec2 r101 = hash2(i + ivec3(1,0,1));\n    vec2 r011 = hash2(i + ivec3(0,1,1));\n    vec2 r111 = hash2(i + ivec3(1,1,1));\n    \n    f = pos - f;\n    \n    f = f * f * (3. - 2. * f);\n    \n    return mix(mix(mix(r000,r100,f.x), mix(r010,r110,f.x), f.y),  mix(mix(r001,r101,f.x), mix(r011,r111,f.x), f.y),  f.z);\n}\n\n//*/\n\n//strange patterns on pylons:\n//add Grey Noise3D noise volume to iChannel1 to use this noise version\n/*\nvec2 noise3d2(vec3 pos)\n{\n    vec3  i = floor(pos);\n    vec3 f = fract(pos);\n    f = f * f * (3. - 2. * f);\n    \n    \n    f = (f + i - 0.5) / iChannelResolution[1];\n    \n    return vec2(texture(iChannel1,f).x,texture(iChannel1,f).y);\n}\n//*/\n\n////////////////////\n//ray functions\n////////////////////\n\n\n//helper struct\nstruct ray\n{\n    //ray position\n    vec3 pos;\n    // normalized ray direction\n    vec3 dir;\n};\n\n\n//ray plane\nfloat ray_pln(in ray r, in vec3 p)\n{\n    return - dot(r.pos, p.xyz) / dot(r.dir, p.xyz);\n}\n\n\n//ray box\nvec2 ray_box(in ray r, in vec3 pos, in vec3 size) \n{\n    vec3 m = 1.0 / r.dir; // can precompute if traversing a set of aligned boxes\n    vec3 n = m * (r.pos - pos);   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m) * size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float t_near = max( max( t1.x, t1.y ), t1.z );\n    float t_far = min( min( t2.x, t2.y ), t2.z );\n    \n    if( t_near > t_far || t_far < 0.0) \n        return vec2(1000,-1000); // no intersection\n        \n    return vec2(t_near,t_far);\n}\n\n\n////////////////////\n//hexagonal mappimg\n////////////////////\n///////////\nconst vec2 HEX_BOX = vec2(1, sqrt(0.75) / 1.5);//hex bounding box\nconst vec2 INV_BOX = 1.0 / HEX_BOX;            //hex bounding box inverse\nconst vec2 HEX_ROT = normalize(HEX_BOX);       //uv rotation for hex tiles\n///////////////////////////////////////\n/*\n            HEX_BOX.x\n         |<----------->|\n         \n         C------#------C  ---\n         |  \"-_ # _-\"  |   A\n         |     ###     |   |\n         |  ### . ###  |   |\n         ###    .    ###   |\n         #  \"-_ . _-\"  #   |\n         #     -C-     #   | HEX_BOX.y\n         # _-\"  .  \"-_ #   |\n       #####    .    ###   |\n    ###  |  ### . ###  |   |\n  ##     |    _###_    |   |\n  #      | _-\"  #  \"-_ |   V\n  #      C------#------C  ---\n  #             #       \n  ##           ###      \n    ###     ###   ###   \n       #####         ###\n         #             #\n  C      #      C      #\n         \n         \n         \n         C = hexagon centre (one in centre of box four on its corners)\n         # = hexagon borders\n         | = box and box symetry borders\n       \n*/\n////////////////////////////////////////\n\n\n\nvec2 hex_centre(in vec2 uv)\n{\n    //domain repetition\n    vec2 centre = round(uv*HEX_BOX)*INV_BOX;\n    \n    vec2 side = uv - centre;\n    \n    vec2 hex = abs(side);\n    \n    //select origin (domain centre or domain corner)\n    if(hex.y > (0.333-hex.x*0.333)*INV_BOX.y)\n        centre += 0.5*INV_BOX * sign(side);//select corner\n    \n    return centre;\n}\n\n\n\nvec2 hex_tile(in vec2 hex_uv)\n{\n    vec2 tile = abs(hex_uv.yx);//abs AND flip!!!\n    \n    \n    if(tile.x > tile.y*0.333*INV_BOX.y)//test fliped\n        tile *= mat2(-HEX_ROT.y,HEX_ROT.x, HEX_ROT);//rotate fliped\n        \n    if(hex_uv.y < 0.0)//mirror x to shape a \"triangle\"\n        tile.x = -tile.x;\n     \n     return tile;\n}\n\n\n\n\n\n\n\n\n\n\nvec2 map_hex(vec2 uv)\n{\n    vec3 t;\n    \n    t.x =  dot(uv.xy,vec2(0.559, 1));\n    t.y = -dot(uv.xy,vec2(0.559,-1));\n    t.z = uv.x * 1.118;\n    \n    vec3 p = fract(t*0.5);\n    vec3 b = fract(t);\n    \n    float sum = floor(t.x) + floor(t.y);\n    \n    float fr = mod(sum, 6.);\n    \n    vec2 res;\n    \n    if(p.z < 0.5)\n    {\n        fr = mod(sum + 3., 6.);\n    }\n    \n    \n        if(fr < 6.)\n        res = vec2(1.-b.y,1.-b.z);\n        if(fr < 5.)\n        res = vec2(   b.y,1.-b.x);\n        if(fr < 4.)\n        res = vec2(1.-b.z,   b.x);\n        \n        if(fr < 3.)\n        res = vec2(1.-b.x,   b.z);\n        if(fr < 2.)\n        res = vec2(   b.x,1.-b.y);\n        if(fr < 1.)\n        res = vec2(   b.z,   b.y);\n        \n        \n        \n    return\n    vec2(\n    1. - (res.x + res.y * 0.5),\n    res.y * 0.894\n    );\n}\n\n\n\n////////////////////\n//text rendering\n////////////////////\n\n\nfloat show_text(vec2 pos,ivec2 text, float text_size)\n{\n    //inside text\n    if(abs(pos.y) < text_size && abs(pos.x) < text_size * 8.)\n    {\n        //get glyph\n        int i = 7 - int(floor((pos.x + text_size * 8.) / text_size / 2.));\n        \n        //lookup glyph codepoint\n        float glyph_codepoint = float(i > 3 ? (text.x >> ((i-4) * 8)) & 255 : (text.y >> (i * 8)) & 255);\n        \n        //get glyph uv\n        vec2 gly_uv = fract((pos + vec2(8.*text_size,text_size)) / text_size / 2.);\n        \n        //zoom in on glyph to make it larger (causes some clipping)\n        gly_uv = (gly_uv -0.5) * vec2(0.6,0.6) + 0.5;\n       \n        //lookup glyph sdf\n        return get_glyph(gly_uv, glyph_codepoint) - 0.5;\n    }\n    //not inside text\n    return 1.0;\n}\n\n\n////////////////////\n////////////////////\n////////////////////\n\n////////////////////\n//main sdf function\n////////////////////\nfloat sdf(vec3 pose, bool inside)\n{\n    float d = box(pose - vec3( 0.00, 0.00, 1.00),  vec3(0.50,0.50,1.00));\n    \n    vec3 pos = pose;\n    vec3 rot = pos;\n    \n    rot.xy -= vec2(0.36,-0.4);\n\n    rot.xy = n_rotate(rot.xy,0.245);\n\n    rot.xy += vec2(0.36,-0.4);\n    \n    float door_box = box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67));\n    \n    if(door_box < 0.001)\n        pos = rot;\n        \n        \n    \n    //use symetries:\n        \n        //mirror at axes\n        vec3 pos_x  = vec3(abs(pos.x),abs(pos.y),pos.z);\n        \n        //mirror at diagonals\n        vec3 pos_xx = pos_x.x < pos_x.y  ?  pos_x.xyz  :  pos_x.yxz;\n        \n    \n    \n    if(d < 0.2)\n    {\n        d = 1000.;\n        \n        \n        if(pos.z > 1.55)\n        {\n            float roof = box(pos    -vec3( 0.00, 0.00,1.74),  vec3(0.40,0.40,0.06));//roof2\n            roof = max(roof, pln(pos_xx -vec3( 0.00, 0.00,1.80),  vec3(0.00,0.148,0.989)));//roof2 slope\n            d = min(d,roof);\n            \n            d = min(d, box(pos    -vec3( 0.00, 0.00,1.79),  vec3(0.09,0.09,0.03)));//light base\n            float tar_rad = length(pos.xy);\n            d = min(d, max(tar_rad - 0.05, abs(pos.z - 1.84) - 0.05));//light pole\n            d = min(d, max(tar_rad - 0.06, abs(pos.z - 1.91) - 0.05));//light\n            d = min(d, max(dot(vec2(0.447,0.894),vec2(tar_rad,pos.z-2.)),1.96-pos.z));//light roof\n        }\n        else\n        {\n            if(door_box > 0.001)\n                d = min(d,door_box+0.001);\n        \n            if(pos.z > 0.73)\n            {\n                d = min(d, box(pos_xx -vec3(0.20,.425,1.30),  vec3(0.15,0.01,.005)));//window bar\n                d = min(d, box(vec3(abs(pos_xx.x-.19),pos_xx.yz)-vec3(0.045,0.425,1.30),  vec3(.005,0.01,0.15)));//window vertical bar\n                \n                \n                d = min(d, box(pos_xx -vec3(0.20,0.425,1.30),  vec3(0.15,.005,0.15)) + 0.001+ 0.001*sin(pos_xx.x*400.));//window\n                \n                if(pos.y < -0.4)\n                {\n                    d = min(d, tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)));//phone handle\n                    \n                    d = min(d, box(vec3(abs(pos.x+.19)-0.11,pos.yz)    -vec3(0.,-0.435,0.97),  vec3(0.01,0.005,0.13)));//phone sign border vertical\n                    d = min(d, box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01)));//phone sign border horizontal\n                    \n                    d = min(d, cheap_cyl((rot    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005));//lock\n                }\n                \n                \n            }\n            else\n            {\n                float base = box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06));//base\n                base = max(base, pln(pos_xx -vec3( 0.00,0.47,0.12),  vec3(0.00,0.514,0.857)));//base chamfer (slope)\n                d = min(d,base);\n            }\n            \n            d = min(d, box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03)));//horizontal bars\n            \n            \n            d = min(d, box(pos_xx -vec3(0.20,.425,0.65),  vec3(0.15,0.01,0.50)));//panels\n            \n            d = min(d, box(vec3(abs(pos_xx.x-0.19)+0.19,pos_xx.yz) -vec3(0.35,.425,0.82),  vec3(0.03,0.02,0.70)));//door vertical bar\n            \n            d = min(d, box(pos_xx -vec3(0.00,0.44,0.82),  vec3(0.02,0.01,0.70)));//center vertical bar\n            \n            d = min(d, box(pos_xx -vec3(.365,0.45,0.82 ),  vec3(.005,.005,0.70)));//border vertical bar\n            d = min(d, box(pos_xx -vec3(0.00,0.45,1.485),  vec3(0.36,.005,.005)));//border horizontal bar\n        }\n        \n        d = min(d, box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06)));//sign\n        d = max(d,-box(pos_xx -vec3( 0.00, 0.52, 1.55),  vec3(0.325,0.03,.04)));//sign inside\n        \n        d = min(d, box(pos_x  -vec3( .42, .42, 0.90),  vec3(0.05,0.05,0.78)));//corner pole\n        \n        d = min(d, box(pos    -vec3( 0.00, 0.00, 1.655),  vec3(0.425,0.425,0.055)));//roof1\n        \n        if(inside)\n            d = max(d,-box(pos    -vec3(0.,0.45,0.81),  vec3(0.36,.2,0.68)));//open back\n        \n        d = max(d,-box(pose    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)));//open door\n        \n        if(door_box < 0.001)\n                d = max(d,door_box+0.001);\n    }\n    \n    \n    //interior\n    if(inside)\n    {\n        vec3 ipos = pos;\n        ipos.y -= 10.;\n        \n        ipos.z -= 0.14;\n        \n        vec2 pl = n_polar(ipos.xy);\n        \n        float bound_rad = length(ipos-vec3( 0.00, 0,1.));\n        \n        \n        if(6. < bound_rad)\n        {\n            vec3 tile = vec3(pl,ipos.z);\n\n\n            ////wall patern\n            tile.x = (tile.x*72.0 - round(tile.x*72.0-0.5) - 0.5)/72.0;\n\n            tile.xy = n_un_polar(tile.xy);\n\n            tile.xz = map_hex(2.14*tile.xz) / 2.14;\n\n            tile.y -= 7.8;\n\n\n            float ball = abs(sph(tile - vec3(0,5.80,0),4.))-0.01;\n            float cutout = cheap_cyl((tile - vec3(cos(pi2/6.)*0.5,3.7,sin(pi2/6.)*0.5)).xzy    ,   .37, 10.);//cutout\n\n            float ball2 = abs(sph(tile - vec3(0,-2.18,0),4.))-0.01;\n            float cutout2 = cheap_cyl((tile - vec3(-cos(pi2/6.)*0.5,3.7,sin(pi2/6.)*0.5)).xzy    ,   .37, 10.);//cutout\n\n            ball  = max(ball ,-cutout );\n            ball2 = max(ball2,-cutout2);\n\n\n\n            float deco = cheap_cyl((tile).xzy -vec3(0,0,-2.8)   ,   .37, 4.65);//hole\n\n            deco = max(deco,-ball);\n            deco = max(deco,-ball2);\n\n            ////\n\n            float dome = abs(pln(tile-vec3(0,1.9,0),vec3(0,1,0))) - 0.1;//dome\n            dome = max(dome,-box(pos    - vec3( 0.00, 0.00,0.84),  vec3(0.43,.6,0.76)));\n\n\n            dome = max(dome,-deco);\n\n            d = min(d,dome+0.02);\n\n            dome = max(dome,tile.z-0.41 );\n\n            d = min(d,dome);\n\n            d = min(d,pln(pos - vec3(0,0,9),vec3(0,0,-1)));//inside roof\n\n\n            vec3 things = vec3((pl.x*24.0 - round(pl.x*24.0-0.5) - 0.5)/24.0, pl.y, ipos.z);\n\n            things.xy = n_un_polar(things.xy);\n\n            things-=vec3(0,8.,1.64 * round(pl.x*24.0+0.5));\n\n\n\n            things.z = (things.z*0.5 - round(things.z*0.5)) * 2.;\n\n            things.xz = hex_tile(things.zx);\n            \n\n            if(round(pl.x*24.0-0.5) > -12. && round(pl.x*24.0-0.5) < 11.)\n            {\n                d = min(d, box(things,vec3(0.4,0.02,0.4)));//blue hex\n                things -= vec3(0.,-0.12,0.6);\n                d = min(d, box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.02,0.2))+ 0.006+ 0.006*sin(things.z*100.));//hex surounding\n            }\n            else\n            {\n                things -= vec3(0.,-0.12,0.6);\n                d = min(d, box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.0,0.2))+0.1);//sdf placeholder\n            }\n\n            d = min(d, pln(ipos    ,  vec3(0,0,1)));//floor\n        }\n        if(8.6 > bound_rad)\n        {\n            d = min(d, max(dot(vec2(0.447,0.894),vec2(pl.y,ipos.z-1.8)),1.0-ipos.z));//console\n            \n            d = min(d, tor((ipos    - vec3( 0.00, 0, 1.0)).xzy,   vec2(1.6,0.05)));//console\n            \n            \n            d = min(d, max(pl.y - 5.8, abs(ipos.z - 0.32) - 0.02));//stairs\n            d = min(d, max(pl.y - 7.8, abs(ipos.z       ) - 0.16));//stairs\n            d = min(d, max(pl.y - 5.7, abs(ipos.z       ) - 0.30));//stairs light\n            \n            \n            vec3 hex = vec3(hex_tile(ipos.xy),ipos.z);\n            \n            hex.x = abs(hex.x);\n            \n            d = min(d, cap(hex , vec3( 0.00, 1.62, 1.05), vec3( 0.00, 0.9 , 1.4),   0.05));//console_\n            d = min(d, cop(hex , vec3( 0.00, 0.75, 0.6), vec3( 0.00, 1.2 , 0.1),   0.2,0.3));//console_\n            d = min(d, cop(hex , vec3( 0.00, 0.75, 0.6), vec3( 0.00, 0.7 , 0.9),   0.2,0.2));//console_\n            d = min(d, max(pl.y - 1.0, abs(ipos.z - 1.43) - 0.03)); //upper console\n            \n            d = max(d,-max(pl.y - 0.7, abs(ipos.z - 0.74) - 2.0) );//console hole\n            \n            float p1 = cop(ipos, vec3( 0.00, 0.0,0.14), vec3( 0.00, 0.0,3.14),0.65, 0.40);//pylon\n            float p2 = cop( hex, vec3( 0.00, 5.0,0.14), vec3( 0.00, 5.4,2.14), 0.6, 0.51);//suround pylon\n            float p3 = cop( hex, vec3( 0.00, 5.4,2.14), vec3( 0.00, 4.0,3.94), 0.5, 0.41);//suround pylon\n            float p4 = cop( hex, vec3( 0.00, 4.0,3.94), vec3( 0.00, 2.0,3.54), 0.4, 0.30);//suround pylon\n            \n            vec3 drr;\n            \n            if(min(min(d,p2),min(p3,p4)) > p1)\n                drr = ipos;\n                \n            else if(min(d,min(p3,p4)) > p2)\n                drr = vec3(hex.x+2., n_rotate(hex.yz, .04));\n                \n            else if(min(d,p4) > p3)\n                drr = vec3(hex.x+2., n_rotate(hex.yz,-.10));\n                \n            else if(d > p4)\n                drr = vec3(hex.x+2., n_rotate(hex.yz,-.28));\n            \n            float cr = 0.12 * noise3d2(vec3(10,10,1.)*drr).x;\n            \n            d = min(d, p1 + cr);//pylon\n            d = min(d, p2 + cr);//suround pylon\n            d = min(d, p3 + cr);//suround pylon\n            d = min(d, p4 + cr);//suround pylon\n            \n            d = min(d, cyl((hex - vec3( 0.00, 4.0,3.94)).yzx, 0.25, 0.25) - 0.1);// pylon joint\n            d = min(d, cyl((hex - vec3( 0.00, 5.4,2.14)).yzx, 0.25, 0.35) - 0.1);// pylon joint\n            \n        }\n        \n    }\n     \n    return (d);\n}\n\nfloat shadow_sdf(vec3 pose, bool inside)\n{\n    \n    vec3 pos = pose;\n    vec3 rot = pos;\n    \n    rot.xy -= vec2(0.36,-0.4);\n\n    rot.xy = n_rotate(rot.xy,0.245);\n\n    rot.xy += vec2(0.36,-0.4);\n    \n    float door_box = box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67));\n    \n    if(door_box < 0.001)\n        pos = rot;\n        \n        \n    \n    //use symetries:\n        \n        //mirror at axes\n        vec3 pos_x  = vec3(abs(pos.x),abs(pos.y),pos.z);\n        \n        //mirror at diagonals\n        vec3 pos_xx = pos_x.x < pos_x.y  ?  pos_x.xyz  :  pos_x.yxz;\n        \n    \n    \n    \n     float d = 1000.;\n    \n    \n    if(pos.z > 1.55)\n    {\n        float roof = box(pos    -vec3( 0.00, 0.00,1.74),  vec3(0.40,0.40,0.06));//roof2\n        roof = max(roof, pln(pos_xx -vec3( 0.00, 0.00,1.80),  vec3(0.00,0.148,0.989)));//roof2 slope\n        d = min(d,roof);\n        \n        d = min(d, box(pos    -vec3( 0.00, 0.00,1.79),  vec3(0.09,0.09,0.03)));//light base\n        float tar_rad = length(pos.xy);\n        d = min(d, max(tar_rad - 0.05, abs(pos.z - 1.84) - 0.05));//light pole\n        d = min(d, max(tar_rad - 0.06, abs(pos.z - 1.91) - 0.05));//light\n        d = min(d, max(dot(vec2(0.447,0.894),vec2(tar_rad,pos.z-2.)),1.96-pos.z));//light roof\n    }\n    else\n    {\n        if(door_box > 0.001)\n            d = min(d,door_box+0.001);\n    \n        if(pos.z > 0.73)\n        {\n            d = min(d, box(pos_xx -vec3(0.20,.425,1.30),  vec3(0.15,0.01,.005)));//window bar\n            d = min(d, box(vec3(abs(pos_xx.x-.19),pos_xx.yz)-vec3(0.045,0.425,1.30),  vec3(.005,0.01,0.15)));//window vertical bar\n            \n            \n            d = min(d, box(pos_xx -vec3(0.20,0.425,1.30),  vec3(0.15,.005,0.15)) + 0.001+ 0.001*sin(pos_xx.x*400.));//window\n            \n            if(pos.y < -0.4)\n            {\n                d = min(d, tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)));//phone handle\n                \n                d = min(d, box(vec3(abs(pos.x+.19)-0.11,pos.yz)    -vec3(0.,-0.435,0.97),  vec3(0.01,0.005,0.13)));//phone sign border vertical\n                d = min(d, box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01)));//phone sign border horizontal\n                \n                d = min(d, cheap_cyl((rot    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005));//lock\n            }\n            \n            \n        }\n        else\n        {\n            float base = box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06));//base\n            base = max(base, pln(pos_xx -vec3( 0.00,0.47,0.12),  vec3(0.00,0.514,0.857)));//base chamfer (slope)\n            d = min(d,base);\n        }\n        \n        d = min(d, box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03)));//horizontal bars\n        \n        \n        d = min(d, box(pos_xx -vec3(0.20,.425,0.65),  vec3(0.15,0.01,0.50)));//panels\n        \n        d = min(d, box(vec3(abs(pos_xx.x-0.19)+0.19,pos_xx.yz) -vec3(0.35,.425,0.82),  vec3(0.03,0.02,0.70)));//door vertical bar\n        \n        d = min(d, box(pos_xx -vec3(0.00,0.44,0.82),  vec3(0.02,0.01,0.70)));//center vertical bar\n        \n        d = min(d, box(pos_xx -vec3(.365,0.45,0.82 ),  vec3(.005,.005,0.70)));//border vertical bar\n        d = min(d, box(pos_xx -vec3(0.00,0.45,1.485),  vec3(0.36,.005,.005)));//border horizontal bar\n    }\n    \n    d = min(d, box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06)));//sign\n    d = max(d,-box(pos_xx -vec3( 0.00, 0.52, 1.55),  vec3(0.325,0.03,.04)));//sign inside\n    \n    d = min(d, box(pos_x  -vec3( .42, .42, 0.90),  vec3(0.05,0.05,0.78)));//corner pole\n    \n    d = min(d, box(pos    -vec3( 0.00, 0.00, 1.655),  vec3(0.425,0.425,0.055)));//roof1\n    \n    if(inside)\n        d = max(d,-box(pos    -vec3(0.,0.45,0.81),  vec3(0.36,.2,0.68)));//open back\n    \n    d = max(d,-box(pose    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)));//open door\n    \n    if(door_box < 0.001)\n         d = max(d,door_box+0.001);\n      \n    \n    \n     \n    return (d);\n}\n\n\n////////////////////\n//normal from sdf function\n////////////////////\nvec3 normal(vec3 pos, float dist, bool inside) \n{\nif(pos.z < 0.0001)\n    return vec3(0,0,1);\n    \n    float h = 0.0001 * dist; \n    //const vec2 k = vec2(1,-1);\n    //return normalize( k.xyy*sdf( pos + k.xyy*h ,inside) + \n    //                  k.yyx*sdf( pos + k.yyx*h ,inside) + \n    //                  k.yxy*sdf( pos + k.yxy*h ,inside) + \n    //                  k.xxx*sdf( pos + k.xxx*h ,inside) );\n                      \n                      \n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdf(pos + e * h,inside);\n    }\n    return normalize(n);\n}\n\n\n////////////////////\n//test if ray goes trough door\n////////////////////\nfloat portal_intersect(ray r)\n{\n   float dist = - (r.pos.y + 0.425) / r.dir.y;\n    \n    if(dist > 0.)\n    {\n        vec2 uv = r.pos.xz + r.dir.xz * max(0.0,dist);\n\n        uv = abs(uv - vec2(0.18, 0.82)) - vec2(0.18,0.67);\n\n        if(max(uv.x, uv.y) < 0.0)\n        {\n            return dist;\n        }\n    }\n    \n    return 1000000.;\n}\n\n\n\n\n\n\n////////////////////\n// C++ code used to convert text to hexadecimal integers:\n////////////////////\n\n\n/*\n#include <iostream>\n#include <string>\n\nvoid write_to_ints()\n{\n    std::string data =\n    \"POLICE  \"s + \"BOX     \"s + \"PUBLIC  \"s + \"CALL    \"s +\n    \"POLICE T\"s + \"ELEPHONE\"s +\n    \"FREE FOR\"s +\n    \"USE OF P\"s + \"UBLIC   \"s +\n    \"ADVICE &\"s + \"ASSISTAN\"s + \"CE      \"s +\n    \"OBTAINAB\"s + \"LE IMMED\"s + \"IATELY  \"s +\n    \"OFFICERS\"s + \"& CARS  \"s +\n    \"RESPOND \"s + \"TO ALL C\"s + \"ALLS    \"s +\n    \"PULL TO \"s + \"OPEN    \"s;\n    \n    std::string lookup = \"0123456789abcdef\";\n    \n    for(int i = 0; i < data.size(); i++)\n    {\n        if(i % 4 == 0)\n            std::cout << \", 0x\";\n        \n        std::cout << lookup[data[i] / 16] << lookup[data[i] % 16];\n    }\n}\n*/\n\n\n////////////////////\n//get color and normal map\n////////////////////\nvec4 sdf_color_normal(vec3 pose, float dist, bool inside,inout vec3 nor)\n{\n    float pad = dist * 0.002;\n    \n    vec3 pos = pose;\n    vec3 rot = pos;\n    \n    rot.xy -= vec2(0.36,-0.4);\n\n    rot.xy = n_rotate(rot.xy,0.245);\n\n    rot.xy += vec2(0.36,-0.4);\n    \n    if(dist * 0.001 > box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)))\n        pos = rot;\n            \n    //use symetries\n    \n    // rotate by 90° segments\n    vec3 pos_x  = abs(pos.x) < abs(pos.y)  ?  vec3(pos.y < 0.0 ? pos.x : -pos.x, abs(pos.y), pos.z)  :  vec3(pos.x < 0.0 ? -pos.y : pos.y, abs(pos.x), pos.z);\n    \n    \n    //mirror x axis\n    vec3 pos_xx = vec3(abs(pos_x.x), pos_x.y, pos_x.z);\n    \n    \n    \n    \n    vec4 color = vec4(0.25,0.15,0.1,0.2);\n    vec4 ns_scale = vec4(10,10,1,0.1) * vec4(pos,1.);\n    \n    \n    \n    if(inside)\n    {\n        \n        vec3 ipos = pos;\n        ipos.y -= 10.;\n        ipos.z -= 0.14;\n        \n        if(pad > (length(ipos   + vec3( 0.00,   0, 1))-8.7)-0.3) color = vec4(3.,1.2,0.4,0.4);//all pylons\n        \n        \n        if(pad > max(cheap_cyl(ipos          - vec3( 0.00,   0, 0.14),   2., 2.), - cheap_cyl(ipos    - vec3( 0.00, 0,0.74),   0.7, 2.))) color = vec4(0.25,0.15,0.1,1.);//console\n        \n        if(pad > pln(ipos          - vec3( 0.00,   0, 0.34),  vec3(0,0,1))) color = vec4(0.1);//inside floor\n        \n        \n        if(pad > cheap_cyl(ipos          - vec3( 0.00,   0, 0.12),   5.7, 0.2)) color = vec4(3.,1.5,0.0,0.4);//stairs light\n    }\n    \n    \n    \n    if(pad > box(pos    - vec3( 0.00, 0.00,1.00),  vec3(0.50,0.50,1.00)))   {color = vec4(0.05,0.20,0.30,0.10);ns_scale = vec4(400,400,10,0.15) * vec4(pos,1.);}//tardis blue\n    //horizontal wood\n    if(pad > box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03))) ns_scale = vec4(10,400,400,0.15) * vec4(pos_xx,1.);//horizontal bars\n    if(pad > box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06))) ns_scale = vec4(10,400,400,0.15) * vec4(pos_xx,1.);//sign\n    if(pad > box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06))) ns_scale = vec4(10,400,400,0.1) * vec4(pos_xx,1.5);//base\n    if(pad > box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01))) ns_scale = vec4(10,400,400,0.1) * vec4(pos_xx,1.);//phone horizontal\n    \n    if(pad > box(pos_xx - vec3( 0.00, 0.46,1.55),  vec3(0.325,0.03,.04)))  {color = vec4(0.00,0.00,0.00,1.00); ns_scale = vec4(0);//sign\n    \n    \n    \n    float gly = 20.;\n        \n        gly = min(gly,show_text(pos_x.xz - vec2(-.11,1.55),ivec2(0x504f4c49, 0x43452020), 0.024));//\"POLICE  \"\n        gly = min(gly,show_text(pos_x.xz - vec2(0.33,1.55),ivec2(0x424f5820, 0x20202020), 0.024));//\"BOX     \"\n        gly = min(gly,show_text(pos_x.xz - vec2(0.08,1.565),ivec2(0x5055424c, 0x49432020), 0.01));//\"PUBLIC  \"\n        gly = min(gly,show_text(pos_x.xz - vec2(.105,1.535),ivec2(0x43414c4c, 0x20202020), 0.01));//\"CALL    \"\n        if(gly < 0.0)\n            color = vec4(1);\n    }\n    if(pad > pln(pos    -vec3(0)                 ,vec3(0.00,0.00,1.00) ))   color = vec4(0.30,0.25,0.20,0.01);//floor\n    if(pad > cheap_cyl(pos    - vec3( 0.00, 0.00, 1.91),  0.06, 0.05 ))   color = vec4(1);//light\n    \n    if(!inside)\n    {\n        if(pad > box(pos    - vec3(-0.19,-0.425, 0.97),  vec3(0.10,0.01,0.11)))  {color = vec4(0.00,0.00,0.00,1.00); ns_scale = vec4(0);//phone sign inside\n\n            float gly = 20.;\n            \n            \n            \n            gly = min(gly,show_text(pos.xz - vec2(-.237,1.055),ivec2(0x504f4c49, 0x43452054), .006));//\"POLICE T\"\n            gly = min(gly,show_text(pos.xz - vec2(-.142,1.055),ivec2(0x454c4550, 0x484f4e45), .006));//\"ELEPHONE\"\n            // \\n\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.190,1.025),ivec2(0x46524545, 0x20464f52), .005));//\"FREE FOR\"\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.220,1.010),ivec2(0x55534520, 0x4f462050), .005));//\"USE OF P\"\n            gly = min(gly,show_text(pos.xz - vec2(-.140,1.010),ivec2(0x55424c49, 0x43202020), .005));//\"UBLIC   \" \n            // \\n\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.235,0.985),ivec2(0x41445649, 0x43452026), .004));//\"ADVICE &\"\n            gly = min(gly,show_text(pos.xz - vec2(-.160,0.985),ivec2(0x41535349, 0x5354414e), .004));//\"ASSISTAN\" \n            gly = min(gly,show_text(pos.xz - vec2(-.095,0.985),ivec2(0x43452020, 0x20202020), .004));//\"CE      \" \n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.247,0.970),ivec2(0x4f425441, 0x494e4142), .004));//\"OBTAINAB\" \n            gly = min(gly,show_text(pos.xz - vec2(-.182,0.970),ivec2(0x4c452049, 0x4d4d4544), .004));//\"LE IMMED\" \n            gly = min(gly,show_text(pos.xz - vec2(-.117,0.970),ivec2(0x49415445, 0x4c592020), .004));//\"IATELY  \" \n            // \\n\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.220,0.940),ivec2(0x4f464649, 0x43455253), .004));//\"OFFICERS\"\n            gly = min(gly,show_text(pos.xz - vec2(-.150,0.940),ivec2(0x26204341, 0x52532020), .004));//\"& CARS  \"\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.190,0.925),ivec2(0x52455350, 0x4f4e4420), .004));//\"RESPOND \" \n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.205,0.910),ivec2(0x544f2041, 0x4c4c2043), .004));//\"TO ALL C\"\n            gly = min(gly,show_text(pos.xz - vec2(-.140,0.910),ivec2(0x414c4c53, 0x20202020), .004));//\"ALLS    \"\n            // \\n\n            // \\n\n            gly = min(gly,show_text(pos.xz - vec2(-.215,0.885),ivec2(0x50554c4c, 0x20544f20), .006));//\"PULL TO \"\n            gly = min(gly,show_text(pos.xz - vec2(-.115,0.885),ivec2(0x4f50454e, 0x20202020), .006));//\"OPEN    \"\n            \n            if(gly < 0.0)\n                color = vec4(1);\n        }\n        \n        if(pad > tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)))   color = vec4(0.5,0.5,0.5,1.);//phone handle\n        \n    \n    }\n    \n        if(pad > cheap_cyl((pos    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005))   color = vec4(0.2,0.15,0.1,1.);//lock\n    \n    if(inside)\n    {\n        \n        vec3 ipos = pos;\n        ipos.y -= 10.;\n        ipos.z -= 0.14;\n        \n        vec2 pl = n_polar(ipos.xy);\n        \n            \n        vec3 tile = vec3(pl,ipos.z);\n        \n        \n        tile.x = (tile.x*72.0 - round(tile.x*72.0-0.5) - 0.5)/72.0;\n        \n        tile.xy = n_un_polar(tile.xy);\n        \n        tile.xz = map_hex(2.14*tile.xz) / 2.14;\n        \n        tile.y -= 7.8;\n        \n        \n        \n        \n        if(pad > abs(pln(tile-vec3(0,1.9,0),vec3(0,1,0))) - 0.1) color = vec4(0.25,0.15,0.1,0.2);//dome\n        \n        vec3 things = vec3((pl.x*24.0 - round(pl.x*24.0-0.5) - 0.5)/24.0, pl.y, ipos.z);\n            \n        things.xy = n_un_polar(things.xy);\n        \n        things-=vec3(0,8.,1.64 * round(pl.x*24.0+0.5));\n        \n        things.z = (things.z*0.5 - round(things.z*0.5)) * 2.;\n        \n        \n        things.xz = hex_tile(things.zx);\n        \n        \n        if(round(pl.x*24.0-0.5) > -12. && round(pl.x*24.0-0.5) < 11.)\n        {\n            if(pad > box(things,vec3(0.4,0.02,0.4))) color = vec4(0.4,0.4,2.0,0.6);//blue hex\n            things -= vec3(0.,-0.12,0.6);\n            if(pad > box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.02,0.2))) color = vec4(0.1,0.1,0.1,0.9);//hex surounding\n        }\n        \n        vec3 hex = vec3(hex_tile(ipos.xy),ipos.z);\n        \n        hex.x = abs(hex.x);\n\n        if(pad > cyl((hex - vec3( 0.00, 4.0,3.94)).yzx, 0.25, 0.25) - 0.1) color = vec4(0.25,0.15,0.1,0.2);// pylon joint\n        if(pad > cyl((hex - vec3( 0.00, 5.4,2.14)).yzx, 0.25, 0.35) - 0.1) color = vec4(0.25,0.15,0.1,0.2);// pylon joint\n        \n        if(pad > max(dot(vec2(0.447,0.894),vec2(pl.y,ipos.z-1.8)),1.0-ipos.z)) color = vec4(3.,1.2,0.4,0.4);//console\n        \n        if(pad > cap(hex, vec3( 1.4, 3.,0.35), vec3( .30, 4.3,0.35), 0.02)) color = vec4(3.,1.5,0.0,0.1);//floor light\n        if(pad > cap(hex, vec3( 1.5, 2.6,0.35), vec3( .37, 0.65,0.35), 0.02)) color = vec4(3.,1.5,0.0,0.1);//floor light\n            \n    }\n    if(pad > box(pos    -vec3( 0.00, 0.00,0.84),  vec3(0.42,0.42,0.76)))   color = vec4(0.6,0.6,0.6,0.1);//tardis not inside inside\n    if(pad > box(pos_xx -vec3(0.19,0.425,1.30),  vec3(0.13,0.005,0.15)))   {color = vec4(0.8,0.8,0.8,1.);ns_scale = vec4(0);}//window\n    \n    \n    \n    //\"normal map\"\n    nor = normalize(nor +  ns_scale.w * (2.0 * vec3(noise3d2(ns_scale.xyz),0.5) - 1.0));\n\n    \n    \n    return color;\n}\n\n\n   \n  \n//////////////////// \nray camera(vec2 uv)\n{\n    \n    //get pos and dir\n    vec2 dir = get_buf(0).xy;\n    vec3 pos = get_buf(1).xyz;\n    \n    //init ray\n    vec3 ray_pos = pos.xyz;\n    vec3 ray_dir = normalize(vec3(uv,2.0));\n    \n    \n    //rotate by pitch\n    ray_dir.zy = n_rotate(ray_dir.yz,dir.y);\n    \n    //rotate by yaw\n    ray_dir.xy = n_rotate(ray_dir.xy,dir.x);\n    \n    \n    return ray(ray_pos, ray_dir);\n}\n\n\n////////////////////\nvec3 sky_dome(vec3 dir, vec3 sun_dir, float routhness, bool inside)\n{\n    if(inside)\n        return vec3(0.1);\n        \n    //colors\n    vec3 sun_color   = vec3(1.0,0.8,0.6);\n    vec3 sky_color   = vec3(0.9,0.7,0.6);\n    vec3 fog_color   = vec3(0.5        );\n    vec3 floor_color = vec3(0.3        );\n    \n    \n    //\"sun\" effect\n    float sun_effect = pow(max(dot(dir, sun_dir), 0.0), 200.0 * routhness) * routhness;\n    //\n    \n    \n    //\"fog\" effect\n    float fog_effect = 1.0 - abs(dir.z);\n    \n    fog_effect = fog_effect * fog_effect;\n    //\n    \n    \n    \n    //sky or floor\n    vec3 dome_color = dir.z < 0.0 ? floor_color : sky_color;\n    \n    //mix in fog\n    dome_color = mix(dome_color, fog_color, fog_effect);\n    \n    //add sun \n    return dome_color + (sun_color * sun_effect);\n}\n\n\n\n    \n\n\n\n////////////////////\n\n//difuse\nfloat difuse(vec3 nor,vec3 sun)\n{\n    return max(dot(nor,sun),0.0);\n}\n\n//blinn reflection model\n//float specular(vec3 dir,vec3 sun, vec3 nor, float sharpnes)\n//{\n//    vec3 halfv = normalize(sun+(-dir));\n//    return pow(max(dot(nor,halfv),0.0), sharpnes);\n//}\n\n//phong reflection model\nfloat specular(vec3 dir,vec3 sun, vec3 nor, float sharpnes)\n{\n    vec3 ref = reflect(sun,nor);\n    return pow(max(dot(ref,dir),0.0), sharpnes/4.0);\n}\n\n//cheap fressnel aproxiation\nfloat fressnel(vec3 dir,vec3 nor)\n{\n    return pow(1.0 - max(dot(-dir,nor),0.0),5.);\n}\n\nfloat ambient_occlusion(vec3 pos, vec3 nor, bool inside)\n{\n    float scale = 0.05;\n    \n    return min(1.0, sdf(pos + scale * nor, inside) / scale);\n}\n\nfloat corner_effect(vec3 pos, vec3 nor, bool inside)\n{\n    float scale = 0.05;\n    \n    return min(1.,0.2 + 0.8 *abs(shadow_sdf(pos - scale * nor, inside)) / scale);\n}\n\nvec3 color_smooth_clamp(vec3 color, float scale)\n{\n    float rt_scale = sqrt(scale);//border between linear x and 1/x\n    \n    return min(color, 1.0 - min(vec3(rt_scale), scale / (color - 1.0 + 2.0 * rt_scale)));\n}\n\n\n////////////////////\n////////////////////\n////////////////////\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates (from -1 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    //raw camera\n    ray r = camera(uv);\n    bool inside = get_buf(1).w > 0.5;\n    \n    //sun pos\n    vec3 sun_dir = vec3(0.267,-0.802,0.535);\n    \n    //if nothing hit\n    vec3 color = sky_dome(r.dir, sun_dir,1.,inside == portal_intersect(r) > 10000.);\n    \n    \n    //march \n    ray tst = r;\n    float rad = 0.0;\n    float dist = 0.0;\n    vec2 box_int = ray_box(r,vec3(0,0,1.),vec3(0.501,0.501,1.001));\n    \n    if(!inside)\n    {\n        dist = max(0.0,box_int.x);\n    }\n    \n    tst.pos += dist * tst.dir;\n    \n    float change_dist = portal_intersect(r);\n    \n    bool inside2 = inside;\n    \n    if(box_int.x < box_int.y || inside)\n    {\n        for(int i = ZERO; i < 128;i++)\n        {\n            rad = sdf(tst.pos, inside2);\n\n            dist += rad;\n\n            if(dist > change_dist)\n                inside2 = !inside;\n\n            tst.pos += tst.dir * rad;\n\n\n            if(rad < 0.001 * dist || dist > box_int.y && !inside2)//using adaptive minimum seems to save time, but needs adaptive test in all functions\n                break;\n\n        }\n    }\n    if(dist > box_int.y && !inside2 || box_int.x > box_int.y && !inside2)\n    {\n        if((-r.pos.z / r.dir.z) > 0.0)\n        {\n        dist = -r.pos.z / r.dir.z;\n        tst.pos = r.pos += r.dir * dist;\n        rad = 0.0001 * dist;\n        }\n        else\n        rad = 100000000000.;\n    }\n    \n    \n    inside = inside2;\n\n    \n    //if hit\n    if(rad < dist * 0.001)\n    {\n        vec3 nor = normal(tst.pos,dist,inside);\n        \n        vec4 matr = sdf_color_normal(tst.pos,dist, inside, nor);\n        \n        \n        \n        \n        vec3 cl = matr.rgb;\n        \n        \n        \n        float df = difuse(nor,sun_dir);\n        \n        \n        \n        \n        if(df > 0.001)\n        {\n            //march shadow\n            ray s_tst = ray(tst.pos + nor * 0.0001, sun_dir);\n            \n            \n            float s_change_dist = portal_intersect(s_tst);\n            \n            float s_dist = 0.;\n            float s_rad  = 0.;\n            \n            vec2 s_box_int = ray_box(s_tst,vec3(0,0,1.),vec3(0.501,0.501,1.001));\n            \n            if(!inside)\n            {\n                s_dist = max(0.0, s_box_int.x);\n                \n                s_tst.pos += s_tst.dir * s_dist;\n            }\n            \n            bool s_inside = inside;\n            \n            if((!inside && s_box_int.x < s_box_int.y) || (inside && s_change_dist < 100000.0))\n            {\n                for(int i = ZERO; i < 64;i++)\n                {\n                    s_rad = shadow_sdf(s_tst.pos, s_inside);\n\n                    s_dist += s_rad;\n\n                    if(s_dist > s_change_dist)\n                        s_inside = !inside;\n\n                    s_tst.pos += s_tst.dir * s_rad;\n\n                    if(!s_inside && s_dist > s_box_int.y)\n                    {\n                        break;\n                    }\n\n                    if(s_rad < 0.001 * s_dist)\n                    {\n                        df = 0.0;\n                        break;\n                    }\n                }\n            }\n            else if(s_box_int.x < s_box_int.y || inside)\n            {\n                df = 0.0;\n            }\n        }\n        \n        \n        vec3 inside_light = vec3(0,10,9);\n        \n        if(inside)\n        {\n            vec3 inside_light_dir = normalize(inside_light - tst.pos);\n            df += difuse(nor,inside_light_dir) * 10. / dot2(inside_light - tst.pos);\n        }\n        \n        \n        \n        //ambient oclusion\n        float ao = ambient_occlusion(tst.pos, nor, inside);\n        \n        //darken cornrs\n        if(!inside)\n            ao = min(ao, corner_effect(tst.pos, nor, inside));\n        \n        //fressnel\n        float fr = fressnel(r.dir,nor);\n        \n        float spec = df > 0.001 ? specular(r.dir,sun_dir,nor,200. * matr.w) * matr.w : 0.; //beter on flat things?\n        \n        vec3 difuse_color = cl * (0.3 + 0.7*df) * (0.5 + 0.5 * ao);\n        vec3 fressnel_color = fr * ao * sky_dome(reflect(r.dir,nor),sun_dir,matr.w,inside);\n        \n        //final color mix\n        color = difuse_color + spec + fressnel_color;\n    }\n    \n    \n    \n    \n    //make eedges of over exposed(to bright) regions less obvious\n    color = color_smooth_clamp(color, 0.05);\n    \n    //gamma compression(correction)\n    color = pow(saturate(color), vec3(0.4545));\n\n    //output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Copyright © 2021 efelo\n////////////////////\n////////////////////\n//game logic\n////////////////////\n////////////////////\n\n\n////////////////////\n//buffer storage:\n\n//adress 0: xy  = camera direction, zw = mouse_old\n//adress 1: xyz = camera position , w  = inside tardis dimension\n\n////////////////////\n//game logic\n\n\n//texture acces\nfloat get_key(int key)   {return texelFetch(iChannel1, ivec2(key,0), 0).x;}\nvec4 get_buf(int adress) {return texelFetch(iChannel0, ivec2(adress,0), 0);}\n\n\n//test if curent pos is oposite to last pos relative to tardis door\nvoid portal_intersect(vec3 pos_new, vec3 pos_old, inout bool inside)\n{\n    //translate\n    vec3 pos1 = pos_new + vec3(0,0.425, 0);\n    vec3 pos2 = pos_old + vec3(0,0.425, 0);\n    \n    //if not on same side of door\n    if(pos1.y * pos2.y < 0.0)\n    {\n        //intersection pos\n        float part = abs(pos1.y / (pos1.y - pos2.y));\n        \n        \n        \n        vec2 uv = mix(pos1.xz,pos2.xz,part);\n        \n        uv = abs(uv - vec2(0.18, 0.82)) - vec2(0.18,0.67);\n        \n        //intersection pos inside door\n        if(max(uv.x, uv.y) < 0.0)\n        {\n            //inverse side as traversing door always changes between inside and outside tardis\n            inside = !inside;\n        }\n    \n    }\n}\n\n\n////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //get buffer adress to write in\n    int adress = int(fragCoord.x);\n    \n    ////////////////////\n    \n    //update camera view direction\n    if(adress == 0)\n    {\n        //normalize mouse imput\n        vec4 mouse = iMouse / iResolution.y;\n        \n        \n        //get last camera direction \n        vec2 dir  = get_buf(0).xy;\n        //get last mouse position\n        vec2 last = get_buf(0).zw;\n        \n        \n        //initialize camera direction\n        if(iFrame < 20)\n            dir = vec2(0, 0.01);\n        \n        \n        //mouse active\n        if(iMouse.z > 0.0)\n        {\n            //test if old mouse was not active\n            if(last.x < 0.0)\n            {\n                //set old to new as no old available\n                last = mouse.xy;\n            }\n            //get delta\n            vec2 delta = mouse.xy - last;\n            //change direction by delta\n            dir += delta * .25;\n            //set old mouse pos to new mouse pos \n            last = mouse.xy;\n        }\n        else\n        {\n            //write that mouse is not active\n            last.x = -1.;\n        }\n        \n        //clamp pitch from going up side down\n        dir.y = clamp(dir.y,-0.25,0.25);\n\t\t\n        //write new camera direction\n        fragColor = vec4(dir, last);\n        \n        \n    }\n    \n    \n    ////////////////////\n    \n    \n    \n    //update camera position\n    if(adress == 1)\n    {\n        \n        //get old camera position\n        vec3 pos = get_buf(1).xyz;\n        //get old camera side\n        bool inside = get_buf(1).w > 0.5;\n        \n        //initialize camera position\n        if(iFrame < 20)\n        {\n            pos = vec3(0.01,-2.5,1.);\n            inside = false;\n        }\n        \n        //initialize camera position\n        if(iMouse.xy == vec2(0))\n        {\n            pos.x = 0.3 + 0.3*-cos(0.2*iTime);\n        }\n        \n\n        vec3 delta = \n        \n        //move left/right\n            vec3(\n         iTimeDelta * get_key(KEY_PX)\n        -iTimeDelta * get_key(KEY_NX)\n        +\n         iTimeDelta * get_key(KEY_PX2)// arrow keys\n        -iTimeDelta * get_key(KEY_NX2)\n        ,\n        //move forward/backward\n         iTimeDelta * get_key(KEY_PY)\n        -iTimeDelta * get_key(KEY_NY)\n        +\n         iTimeDelta * get_key(KEY_PY2)// arrow keys\n        -iTimeDelta * get_key(KEY_NY2)\n        ,\n        //move up/down\n         iTimeDelta * get_key(KEY_PZ)\n        -iTimeDelta * get_key(KEY_NZ)\n\t\t);\n        \n        //get old camera dir\n        vec2 dir = get_buf(0).xy;\n        \n        //translate input to current camera looking direction\n        delta.xy = -n_rotate(delta.xy, dir.x);\n        \n        vec3 old_pos = pos;\n        //move camera pos\n        pos += delta;\n        \n        \n        //check if moved trought tardis door and update inside\n        portal_intersect(pos, old_pos, inside);\n        \n        \n        //write new camera pos\n        fragColor.xyz = pos;\n        //write new side\n        fragColor.w = inside ? 1. : 0.;\n        \n    }\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Copyright © 2021 efelo\n////////////////////\n////////////////////\n\n\n\n\n\n////////////////////\n//key maping\n////////////////////\n//WASD\nconst int KEY_PX = 65 +  0;//a    P = positive, N = negative\nconst int KEY_NX = 65 +  3;//d\nconst int KEY_PY = 65 + 18;//s\nconst int KEY_NY = 65 + 22;//w\n//ARROW KEYS\nconst int KEY_PX2 = 37;//left \nconst int KEY_NX2 = 39;//right\nconst int KEY_PY2 = 40;//up   \nconst int KEY_NY2 = 38;//down \n//UP/DOWN\nconst int KEY_PZ = 32;//space\nconst int KEY_NZ = 16;//shift\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n////////////////////\n//const vars\n////////////////////\nconst float pi = 3.14159265358979323846264338327950288;\nconst float pi2 = pi * 2.0;\nconst float iv_pi2 = 1.0 / pi2;\n\nconst float sq2 = normalize(vec3(1,1,0)).x;\nconst float sq3 = normalize(vec3(1)).x;\n\n\n\n\n\n\n\n\n\n////////////////////\n//math\n////////////////////\n\n\n\n\nvec3 saturate(vec3 val)\n{\n    return clamp(val,0.0,1.0);\n}\n\nfloat saturate(float val)\n{\n    return clamp(val,0.0,1.0);\n}\n\nfloat dot2(vec3 var)\n{\n    return dot(var,var);\n}\n\nfloat dot2(vec2 var)\n{\n    return dot(var,var);\n}\n\n\n\n\n\nvec3 n_polar(vec3 pos)\n{\n    float radius = length(pos);\n         \n    return vec3(atan(pos.y, pos.x) * iv_pi2, acos(pos.z / radius) * iv_pi2, radius);\n}\n\nvec3 n_un_polar(vec3 unit_pos)\n{\n    return \n    vec3(\n    sin(unit_pos.y * pi2) * cos(unit_pos.x * pi2),\n    sin(unit_pos.y * pi2) * sin(unit_pos.x * pi2),\n    cos(unit_pos.y * pi2)\n    ) * unit_pos.z;\n}\n\n\nvec2 n_polar(vec2 pos)\n{\n    return vec2(atan(pos.x, pos.y) * iv_pi2, length(pos));\n}\n\n\nvec2 n_un_polar(vec2 unit_pos)\n{\n    return vec2(sin(unit_pos.x * pi2), cos(unit_pos.x * pi2)) * unit_pos.y;\n}\n\nvec2 n_rotate(vec2 pos, float unit_angle)\n{\n    vec2 rot = vec2(sin(unit_angle * pi2), cos(unit_angle * pi2));\n    \n    return vec2(pos.x * rot.y - pos.y * rot.x, pos.x * rot.x + pos.y * rot.y);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}