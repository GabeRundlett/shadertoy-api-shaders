{
    "Shader": {
        "info": {
            "date": "1658415865",
            "description": "Modification of the following shader: https://www.shadertoy.com/view/3tKXWy\nDid make a short video on youtube to describe the functionality of kernel convolve:\nhttps://www.youtube.com/watch?v=ytPIjZSJDVA",
            "flags": 0,
            "hasliked": 0,
            "id": "NdKBzy",
            "likes": 15,
            "name": "Kuwahara Filter: Multi-Pass",
            "published": 3,
            "tags": [
                "filter",
                "kuwahara",
                "multipass"
            ],
            "usePreview": 1,
            "username": "tida",
            "viewed": 588
        },
        "renderpass": [
            {
                "code": "#define ACTIVATE_FILTER 1\n#define X_RANGE 20.0\n#define Y_RANGE\t5.0\n\n\n// 2; for Classical Kuwahara\n#define COUNT 4     \n\n// 0.5 for smoothing  1.0 no smoothing\n#define SMOOTH 1.0\n\nfloat GetPixelAngle(vec2 uv)\n{\n    float GradientX = 0.0;\n    float GradientY = 0.0;\n    \n    float SobelX[9] = float[9](-1.0, -2.0, -1.0, \n        \t\t\t\t0.0, 0.0, 0.0, \n        \t\t\t\t1.0, 2.0, 1.0);\n        \n    float SobelY[9] = float[9](-1.0, 0.0, 1.0,\n        \t\t\t   -2.0, 0.0, 2.0,\n        \t\t\t   -1.0, 0.0, 1.0);\n        \n    int i = 0;\n    \n    for (float x = -1.0; x <= 1.0; x++)\n    {\n        for (float y = -1.0; y <= 1.0; y++)\n        {\n            vec2 offset = vec2(x,y);\n            vec2 Coords = uv + offset;\n            vec3 PixelColor = texture(iChannel0, Coords).rgb;\n            float PixelValue = dot(PixelColor, vec3(0.3, 0.59, 0.11));\n            \n            GradientX += PixelValue * SobelX[i];\n            GradientY += PixelValue * SobelY[i];\n            i++;\n        }\n    }\n    \n    return atan(GradientY/GradientX);\n}\n\nvec4 GetKernelMeanAndVariance(vec2 uv, vec4 Range, mat2 RotationMatrix)\n{\n    vec3 Mean = vec3(0.0);\n    vec3 Variance = vec3(0.0);\n    float Samples = 0.0;\n    \n    for (float x = Range.x; x <= Range.y; x++)\n    {\n            // The outer row pixels can be weighted by the Smooth Slider which give a more smoother appearance at abput 0.5\n            float fsmooth = 1.0f;\n            if (abs(x) == abs(Range.x-Range.y)) {fsmooth = SMOOTH;} \n            \n         \n        for (float y = Range.z; y <= Range.w; y++)\n        {            \n            vec2 offset = vec2(0.0);\n            \n            offset = vec2(x,y) * RotationMatrix;\n\n            \n            vec2 Coords = (uv + offset) / iResolution.xy;\n            vec3 PixelColor = texture(iChannel0, Coords).rgb*fsmooth;\n            \n            Mean+= PixelColor;\n            Variance += PixelColor * PixelColor;\n            Samples = Samples +1.0f * fsmooth;\n        }\n    }\n    \n    Mean /= Samples;\n    Variance = Variance / Samples - Mean * Mean;\n    \n    float TotalVariance = Variance.r + Variance.g + Variance.b;\n    return vec4(Mean.r, Mean.g, Mean.b, TotalVariance);\n}\n\nvec3 KuwaharaFilter(vec2 uv)\n{    \n    vec4 Range;\n    vec4 FinalColorMin = vec4(0.0f);\n    float MinVariance = 999.9;\n    \n    float Angle = GetPixelAngle(uv);\n    \n    for (int i = 1; i < COUNT; i = i + 1) {\n        float Angle0 = Angle + 3.1515f*2.0f*float(i-1)/float(COUNT);           \n        mat2 RotationMatrix = mat2(cos(Angle0), -sin(Angle0),\n                               sin(Angle0), cos(Angle0));  \n        Range = vec4(0.0, X_RANGE, 0, Y_RANGE);\n        vec4 MeanAndVariance1 = GetKernelMeanAndVariance(uv, Range, RotationMatrix);\n    \n        Range = vec4(0.0, X_RANGE, -Y_RANGE, 0.0);\n        vec4 MeanAndVariance2 = GetKernelMeanAndVariance(uv, Range, RotationMatrix);            \n\n        if (MeanAndVariance1.w < MinVariance) { FinalColorMin = MeanAndVariance1; MinVariance = MeanAndVariance1.w;}\n        if (MeanAndVariance2.w < MinVariance) { FinalColorMin = MeanAndVariance2; MinVariance = MeanAndVariance2.w;}\n    }\n    return FinalColorMin.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 Color = vec3(0.0);\n    \n     #if ACTIVATE_FILTER > 0\n    Color = KuwaharaFilter(fragCoord);\n    #else \n    Color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    #endif\n    fragColor = vec4(Color.rgb, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}