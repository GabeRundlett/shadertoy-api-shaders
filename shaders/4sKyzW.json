{
    "Shader": {
        "info": {
            "date": "1521219666",
            "description": "Exact distance to cubic bezier curve. Use mouse to play with control point, click in bottom left corner to autoplay.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKyzW",
            "likes": 57,
            "name": "Cubic bezier - Signed Distance",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "beziercurve",
                "distance",
                "polynomial",
                "cubicbezier"
            ],
            "usePreview": 1,
            "username": "NinjaKoala",
            "viewed": 6786
        },
        "renderpass": [
            {
                "code": "/*\nExact distance to cubic bezier curve by computing roots of the derivative(s)\nto isolate roots of a fifth degree polynomial and Halley's Method to compute them.\nInspired by https://www.shadertoy.com/view/4sXyDr and https://www.shadertoy.com/view/ldXXWH\nSee also my approximate version:\nhttps://www.shadertoy.com/view/lsByRG\n*/\nconst float eps = .000005;\nconst float zoom = 1.;\nconst float dot_size=.005;\nconst vec3 point_col=vec3(1,1,0);\nconst int halley_iterations = 8;\n\n//lagrange positive real root upper bound\n//see for example: https://doi.org/10.1016/j.jsc.2014.09.038\nfloat upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(a0,a1,a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn max_max + max_max2;\n}\n\n//lagrange upper bound applied to f(-x) to get lower bound\nfloat lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(-a0,a1,-a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn -max_max - max_max2;\n}\n\nvec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0] = min(roots[0],min(roots[1],roots[2]));\n\ttmp[1] = max(roots[0],min(roots[1],roots[2]));\n\ttmp[2] = max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\nvoid sort_roots4(inout vec4 roots){\n\tvec4 tmp;\n\n\tvec2 min1_2 = min(roots.xz,roots.yw);\n\tvec2 max1_2 = max(roots.xz,roots.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\ttmp[0] = min(min1_2.x,min1_2.y);\n\ttmp[1] = min(maxmin,minmax);\n\ttmp[2] = max(minmax,maxmin);\n\ttmp[3] = max(max1_2.x,max1_2.y);\n\n\troots = tmp;\n}\n\nfloat eval_poly5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\n\treturn f;\n}\n\n//halley's method\n//basically a variant of newton raphson which converges quicker and has bigger basins of convergence\n//see http://mathworld.wolfram.com/HalleysMethod.html\n//or https://en.wikipedia.org/wiki/Halley%27s_method\nfloat halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n        if(old_num!=num){\n            if(old_num == 0){\n                s[0] = tmp[0];\n                s[1] = tmp[1];\n            }\n            else{//old_num == 2\n                s[2] = tmp[0];\n                s[3] = tmp[1];\n            }\n        }\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\n//Sign computation is pretty straightforward:\n//I'm solving a cubic equation to get the intersection count\n//of a ray from the current point to infinity and parallel to the x axis\n//Also i'm computing the intersection count with the tangent in the end points of the curve\nfloat cubic_bezier_sign(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i < n_roots){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos < uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvec2 tang1 = p0.xy - p1.xy;\n\tvec2 tang2 = p2.xy - p3.xy;\n\n\tvec2 nor1 = vec2(tang1.y,-tang1.x);\n\tvec2 nor2 = vec2(tang2.y,-tang2.x);\n\n\tif(p0.y < p1.y){\n\t\tif((uv.y<=p0.y) && (dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif(!(uv.y<=p0.y) && !(dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(p2.y<p3.y){\n\t\tif(!(uv.y<=p3.y) && dot(uv-p3.xy,nor2)<0.){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif((uv.y<=p3.y) && !(dot(uv-p3.xy,nor2)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(n_ints==0 || n_ints==2 || n_ints==4){\n\t\treturn 1.;\n\t}\n\telse{\n\t\treturn -1.;\n\t}\n}\n\nfloat cubic_bezier_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\t//switch points when near to end point to minimize numerical error\n\t//only needed when control point(s) very far away\n\t#if 0\n\tvec2 mid_curve = parametric_cub_bezier(.5,p0,p1,p2,p3);\n\tvec2 mid_points = (p0 + p3)/2.;\n\n\tvec2 tang = mid_curve-mid_points;\n\tvec2 nor = vec2(tang.y,-tang.x);\n\n\tif(sign(dot(nor,uv-mid_curve)) != sign(dot(nor,p0-mid_curve))){\n\t\tvec2 tmp = p0;\n\t\tp0 = p3;\n\t\tp3 = tmp;\n\n\t\ttmp = p2;\n\t\tp2 = p1;\n\t\tp1 = tmp;\n\t}\n\t#endif\n\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n    \n    //compute polynomial describing distance to current pixel dependent on a parameter t\n\tfloat bc6 = dot(a3,a3);\n\tfloat bc5 = 2.*dot(a3,a2);\n\tfloat bc4 = dot(a2,a2) + 2.*dot(a1,a3);\n\tfloat bc3 = 2.*(dot(a1,a2) + dot(a0,a3));\n\tfloat bc2 = dot(a1,a1) + 2.*dot(a0,a2);\n\tfloat bc1 = 2.*dot(a0,a1);\n\tfloat bc0 = dot(a0,a0);\n\n\tbc5 /= bc6;\n\tbc4 /= bc6;\n\tbc3 /= bc6;\n\tbc2 /= bc6;\n\tbc1 /= bc6;\n\tbc0 /= bc6;\n    \n    //compute derivatives of this polynomial\n\n\tfloat b0 = bc1 / 6.;\n\tfloat b1 = 2. * bc2 / 6.;\n\tfloat b2 = 3. * bc3 / 6.;\n\tfloat b3 = 4. * bc4 / 6.;\n\tfloat b4 = 5. * bc5 / 6.;\n\n\tvec4 c1 = vec4(b1,2.*b2,3.*b3,4.*b4)/5.;\n\tvec3 c2 = vec3(c1[1],2.*c1[2],3.*c1[3])/4.;\n\tvec2 c3 = vec2(c2[1],2.*c2[2])/3.;\n\tfloat c4 = c3[1]/2.;\n\n\tvec4 roots_drv = vec4(1e38);\n\n\tint num_roots_drv = solve_quartic(c1,roots_drv);\n\tsort_roots4(roots_drv);\n\n\tfloat ub = upper_bound_lagrange5(b0,b1,b2,b3,b4);\n\tfloat lb = lower_bound_lagrange5(b0,b1,b2,b3,b4);\n\n\tvec3 a = vec3(1e38);\n\tvec3 b = vec3(1e38);\n\n\tvec3 roots = vec3(1e38);\n\n\tint num_roots = 0;\n    \n\t//compute root isolating intervals by roots of derivative and outer root bounds\n    //only roots going form - to + considered, because only those result in a minimum\n\tif(num_roots_drv==4){\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) > 0.){\n\t\t\ta[0]=lb;\n\t\t\tb[0]=roots_drv[0];\n\t\t\tnum_roots=1;\n\t\t}\n\n\t\tif(sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1])) != sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[2]))){\n            if(num_roots == 0){\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=roots_drv[2];\n                num_roots=1;\n            }\n            else{\n            \ta[1]=roots_drv[1];\n\t\t\t\tb[1]=roots_drv[2];\n                num_roots=2;\n            }\n\t\t}\n\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[3]) < 0.){\n            if(num_roots == 0){\n                a[0]=roots_drv[3];\n                b[0]=ub;\n                num_roots=1;\n            }\n            else if(num_roots == 1){\n                a[1]=roots_drv[3];\n                b[1]=ub;\n                num_roots=2;\n            }\n            else{\n                a[2]=roots_drv[3];\n                b[2]=ub;\n                num_roots=3;\n            }\n\t\t}\n\t}\n\telse{\n\t\tif(num_roots_drv==2){\n\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) < 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=ub;\n\t\t\t}\n\t\t\telse if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1]) > 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum_roots=2;\n\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\n\t\t\t\ta[1]=roots_drv[1];\n\t\t\t\tb[1]=ub;\n\t\t\t}\n\n\t\t}\n\t\telse{//num_roots_drv==0\n\t\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\n\t\t\tvec2 roots_trd_drv=vec2(1e38);\n\t\t\tint num_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t\tnum_roots=1;\n\n\t\t\ta[0]=lb;\n\t\t\tb[0]=ub;\n\t\t}\n        \n        //further subdivide intervals to guarantee convergence of halley's method\n\t\t//by using roots of further derivatives\n\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\t\tsort_roots3(roots_snd_drv);\n\n\t\tint num_roots_trd_drv=0;\n\t\tvec2 roots_trd_drv=vec2(1e38);\n\n\t\tif(num_roots_snd_drv!=3){\n\t\t\tnum_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t}\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(i < num_roots){\n\t\t\t\tfor(int j=0;j<3;j+=2){\n\t\t\t\t\tif(j < num_roots_snd_drv){\n\t\t\t\t\t\tif(a[i] < roots_snd_drv[j] && b[i] > roots_snd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_snd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tif(j < num_roots_trd_drv){\n\t\t\t\t\t\tif(a[i] < roots_trd_drv[j] && b[i] > roots_trd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_trd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat d0 = 1e38;\n\n    //compute roots with halley's method\n    \n\tfor(int i=0;i<3;i++){\n\t\tif(i < num_roots){\n\t\t\troots[i] = .5 * (a[i] + b[i]);\n\n            for(int j=0;j<halley_iterations;j++){\n\t\t\t\troots[i] = halley_iteration5(b0,b1,b2,b3,b4,roots[i]);\n            }\n\t\t\t\n\n            //compute squared distance to nearest point on curve\n\t\t\troots[i] = clamp(roots[i],0.,1.);\n\t\t\tvec2 to_curve = uv - parametric_cub_bezier(roots[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,dot(to_curve,to_curve));\n\t\t}\n\t}\n\n\treturn sqrt(d0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.y *= iResolution.y / iResolution.x;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.y *= iResolution.y / iResolution.x;\n\n\tborder*=zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n\n\tfloat t0 = mod(iTime*2.+1.5,24.*3.1416);\n\n\tvec2 p0 = vec2(-cos(t0 * 1./2.) * .2,sin(t0 * 1./3.) * .25);\n\tvec2 p1 = vec2(-cos(t0 * 2./3.) * .2,sin(t0 * 1./4.) * .1);\n\tvec2 p2 = vec2(cos(t0 * 1./4.) * .1,-sin(t0 * 2./3.) * .2);\n\tvec2 p3 = vec2(cos(t0 * 1./3.) * .25,-sin(t0 * 1./2.) * .1);\n\n    //mouse condition copied from mattz (https://www.shadertoy.com/view/4dyyR1)\n    if(max(iMouse.x, iMouse.y) > 20.){\n        p0=vec2(-.3,-.1);\n        p1=mouse;\n        p2=vec2(.1,-.2);\n        p3=vec2(.2,.15);\n    }\n\n\tfloat d0 = 1e38;\n\n\td0 = min(d0,cubic_bezier_dis(uv,p0,p1,p2,p3));\n\n\tfloat sgn = cubic_bezier_sign(uv,p0,p1,p2,p3);\n\n\t//iq's sd color scheme\n\tvec3 col = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-8.0 * d0);\n\tcol *= 0.8 + 0.2*cos(480.0*d0);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d0)));\n\n\td0 = 1e38;\n\n\td0 = min(d0,distance(p0,uv) - dot_size);\n\td0 = min(d0,distance(p1,uv) - dot_size);\n\td0 = min(d0,distance(p2,uv) - dot_size);\n\td0 = min(d0,distance(p3,uv) - dot_size);\n\n\tcol = mix(point_col,col,smoothstep(0.,border,d0));\n\n\tfragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}