{
    "Shader": {
        "info": {
            "date": "1520336814",
            "description": "Inspired by patterns from @AkiyoshiKitaoka mapped on a 3D scene.\nhttps://twitter.com/AkiyoshiKitaoka/status/967758875649699841\nhttps://twitter.com/AkiyoshiKitaoka/status/970964297550520320\nhttps://twitter.com/AkiyoshiKitaoka/status/969510301925236736\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XsdcDr",
            "likes": 8,
            "name": "3D Motion Illusion",
            "published": 3,
            "tags": [
                "illusion",
                "movement"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 1304
        },
        "renderpass": [
            {
                "code": "// 3D Motion Illusion Test - @P_Malin\n// https://www.shadertoy.com/view/XsdcDr\n\n// Inspired by patterns from @AkiyoshiKitaoka mapped on a 3D scene.\n// https://twitter.com/AkiyoshiKitaoka/status/967758875649699841\n// https://twitter.com/AkiyoshiKitaoka/status/970964297550520320\n// https://twitter.com/AkiyoshiKitaoka/status/969510301925236736\n\n//#define REVERSE_DIRECTION\n\n#define HEX_PATTERN 0\n\n\nfloat MAX_DIST = 1000.0;\n\n#define PI 3.141592654\n#define TAU  (PI * 2.0)\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n    float fPersp = 3.0;\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fPersp);\n\n\treturn vDir;\n}\n\nvec2 Scene_GetDistance( vec3 vPos )\n{\n\tvec2 vResult = vec2( MAX_DIST, 0.0 );\n\n#if 0\n    float fTunnelDist = 20.0 - length(vPos.xy);        \n    if ( fTunnelDist < vResult.x )\n    {\n        vResult = vec2( fTunnelDist, atan(vPos.x, vPos.y) * 150.0 / (3.14 * 2.0) );\n    }\n\treturn vResult;\n#else   \n    float fFloorPlaneDist = 10.0 + vPos.y;\n    if ( fFloorPlaneDist < vResult.x )\n    {\n        vResult = vec2( fFloorPlaneDist, vPos.x * 1.5 );\n    }\n\n    float fCeilPlaneDist = 18.6 - vPos.y;\n    if ( fCeilPlaneDist < vResult.x )\n    {\n        vResult = vec2( fCeilPlaneDist, vPos.x * 1.5 );\n    }\n    \n    float fTunnelDist = 20.0 - length(vPos.xy);        \n    if ( fTunnelDist < vResult.x )\n    {\n        vResult = vec2( fTunnelDist, atan(vPos.x, vPos.y) * 150.0 / (3.14 * 2.0) );\n    }\n\n    vec3 vRailDomain = vPos;\n    vRailDomain.x = abs( vRailDomain.x );\n    \n    float fRailDist = length(vRailDomain.xy - vec2(10.0, -9.0)) - 1.0;\n    if ( fRailDist < vResult.x )\n    {\n        vResult = vec2( fRailDist, 0.0 );\n    }\n\n    float fSideRailDist = length(vRailDomain.xy - vec2(19.0, -1.5)) - 2.0;\n    if ( fSideRailDist < vResult.x )\n    {\n        vResult = vec2( fSideRailDist, 0.0 );\n    }\n#endif    \n        \n    return vResult;\n}\n\nvec3 Scene_GetNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).x * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).x * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).x * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).x * e.yyy;\n    \n    return normalize( vNormal );\n}   \n\nvec2 Scene_Trace( vec3 vRayOrigin, vec3 vRayDir, float minDist, float maxDist )\n{\t\n    vec2 vResult = vec2(0, 0);\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 64;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tvResult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(vResult.x) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist;\n            break;\n        }               \n        \n        t += vResult.x;\n\t}\n    \n    vResult.x = t;\n    \n    return vResult;\n}    \n\n\n#if HEX_PATTERN\n\n// Returns vec4( distance to edge, distance to centre, vec2( hexagon co-ordinate ) )\n// hexagon co-ordinate integer part is hexagon I.D.\n// hexagon co-ordinate fractional part is uv within the hexagon\nvec4 Hexagon( vec2 pos ) \n{\n    vec2 vScale = vec2( 1.0f, sqrt(3.0f) );\n    \n    vec2 p = pos * vScale;\n      \n    // :\n    // :\n    // o--+--+--+--+--+--o\n    // |  : /:  |  :\\ :  |\n    // |  :/ :  |  : \\:  |\n    // +--+--+--o--+--+--+\n    // |  :\\ :  |  : /:  |\n    // |  : \\:  |  :/ :  |\n    // o--+--+--+--+--+--o - - - - \n    \n    vec2 f = fract( p );\n    \n    vec2 index = floor( p );\n    index.x *= 2.0f;\n    \n    vec2 c;    \n    \n    vec2 t = abs( f - vec2(0.5, 0.5) );\n\n    // get hexagon center and index\n    \n    // (6.0, 2.0) = dimensions of repeating grid above\n    if ( t.x * 6.0 < -t.y * 2.0 + 2.0 )\n    {\n        c = vec2(0.5);        \n    }\n    else\n    {\n        if ( f.x > 0.5f )\n        {\n            c.x = 1.0f; \n\n            index.x += 1.0f;\n        }\n        else\n        {\n            index.x -= 1.0f;\n            c.x = 0.0f;\n        }\n        \n        if ( f.y > 0.5f )\n        {\n            c.y = 1.0f;            \n            index.y += 1.0f;\n        }\n        else\n        {\n            c.y = 0.0f;\n        }\n    }\n            \n    vec2 offset = (f - c) / vScale;\n    float d = length( offset );\n    \n    vec2 vDir[3] = vec2[3]( \n        vec2(  0.0f, \t\t\t\t1.0f ), \n        vec2( -sqrt(3.0f) / 2.0f,\t1.0f / 2.0f ),\n        vec2(  sqrt(3.0f) / 2.0f,\t1.0f / 2.0f ) );    \n    \n    float s = 10000.0;\n    \n    for ( int i=0; i<3; i++ )\n    {\n        float d = 1.0 - abs( dot( offset, vDir[i] ) ) * 2.0 * sqrt(3.0);\n        s = min( s, d );\n    }\n    \n    vec2 vUV = index + offset * 1.5 + 0.5;\n    \n    return vec4(s, d, vUV );\n}\n\n\nvec3 HexPattern( vec2 vUV, vec3 colInner, vec3 colEdge )\n{\n    vec4 hex = Hexagon( vUV );\n    \n    float edgeShade = step( fract(hex.w), 0.5 );\n\n    vec3 col = colInner; \n    col = mix( col, vec3(edgeShade), step(hex.x, 0.3) ); // black / white edge\n    col = mix( col, colEdge, step(hex.x, 0.15) ); ; // Yellow Surround\n        \n    return col;\n}\n\n\n#endif\n\n\n\nvec3 MotionTextureGradient( float f )\n{\n#if 0\n    vec3 cols[] = vec3[](\n        vec3(1,0,0),\n        vec3(1,0,1),\n        vec3(0.95,0,1) * 0.75\n        );\n\n    f *= float( cols.length() );    \n\n    int c1 = int( floor(f) ) % cols.length();\n    int c2 = (c1 + 1) % cols.length();\n    float b = clamp( f - float(c1), 0.0, 1.0 );\n    \n    //b = smoothstep(0.0,1.0,b);\n    return mix( cols[c1], cols[c2], b );    \n#else    \n    vec3 vColA = vec3( 253, 27, 32 ) / 255.0;\n\tvec3 vColB = vec3( 198, 48, 249 ) / 255.0;\n    \n    //vec3 vColA = vec3(1,1,0);\n    //vec3 vColB = vec3(1,.1,0);\n        \n    float fCol = sin(f * TAU) * 0.5 + 0.5;\n    float fLum = sin((f + 0.25) * TAU) * 0.5 + 0.5;\n        \n    float fLumA = 0.9;\n    float fLumB = 1.0;\n\n    return mix( vColA, vColB, fCol ) * mix( fLumA, fLumB, fLum );\n#endif    \n}\n\nvec3 MotionTexture( vec2 vUV )\n{\n#if HEX_PATTERN\n    return HexPattern( vUV * 1.0 + 0.1, vec3(113, 36, 132) / 255., vec3(198, 161, 57) / 255. );\n#else\n    float x = fract( vUV.x );\n\n    float fOffset = floor( x * 2.0 ) / 2.0;\n    float y = fract( vUV.y + fOffset );\n    \n\treturn MotionTextureGradient( y );\n#endif    \n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n    float theta = atan(vRayDir.x, vRayDir.y);\n    vec2 vScene = Scene_Trace( vRayOrigin, vRayDir, 0.0, MAX_DIST );\n    float fDist = vScene.x;\n\tvec3 vPos = vRayOrigin + vRayDir * fDist;\n\t\n    vec3 vNormal = Scene_GetNormal( vPos );\n    vec2 vUV = vScene.yx * vec2(0.1, 0.05); \n    \n    if ( fDist > 350.0 )\n    {\n        vUV = vec2(0);\n    }   \n\n#ifdef REVERSE_DIRECTION\n    vUV.y = 1.0 - vUV.y;\n#endif    \n    \n    vec3 vTex = MotionTexture(vUV + 0.25);\n    \n    vTex = vTex * vTex;\n    float t = fDist * fDist;\n    float fFog = 1.0 - exp2( -t * 0.00005 );\n    vec3 vFogColor = vec3(0.0);\n    vec3 vResult = mix( vTex, vFogColor, fFog );\n    \n    return sqrt(vResult);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n\tvec3 vCameraPos = vec3(0.0, 0.0, 0.0);\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 10.0);\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t    \n\tfragColor = vec4(vResult, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}