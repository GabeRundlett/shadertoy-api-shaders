{
    "Shader": {
        "info": {
            "date": "1537599432",
            "description": " This is based on an excellent tutorial at https://www.youtube.com/watch?v=0ifChJ0nJfM&index=2&list=PL0EpikNmjs2CYUMePMGh3IjjP4tQlYqji.\n@iquilezles Thank you so much for your great teaching about manipulating the colours with sweet functions. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "MlKyWy",
            "likes": 1,
            "name": "palm-tree",
            "published": 3,
            "tags": [
                "glslmaths"
            ],
            "usePreview": 0,
            "username": "teraspora",
            "viewed": 701
        },
        "renderpass": [
            {
                "code": "// palm-tree - My fourth OpenGL shader;\n// Author: John Lynch (teraspora);\n// Date: 22 SEP 2018.\n// Based on Inigo Quilez's tutorial on making a basic palm tree, bending the trunk,\n// controlling the number of fronds and the smoothness or waviness of the trunk etc.\n// which can be found at\n// https://www.youtube.com/watch?v=0ifChJ0nJfM\n\n// I highly recommend the teachings of this highly intelligent and innovative \n// graphics developer, who in the best spirit of the dev community conveys his passion\n// for making art from mathematics and for communicating and sharing\n// his understanding.\n/// ====================================================================================\n\n// Note: I include some functions which I am not currently using but use in other \n// shaders and may experiment with in this or another shader based on this.\n// Feel free to play with them! :)\n\nconst float HALF = 0.5;\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\n\nconst vec3 white = vec3(1., 1., 1.);\nconst vec3 black = vec3(0., 0., 0.);\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0.1,0.8, 0.7);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\n// COLOUR FUNCTIONS:\n \n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// VECTOR FUNCTIONS:\nfloat len(vec2 v) {\n    return length(v);\n}\n\nvec2 hat(float phi) {\n  return vec2(cos(phi), sin (phi));\n}\n\nvec2 hat(vec2 v) {\n  return v / len(v);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\n// COMPLEX FUNCTIONS:\nvec2 times(vec2 v, vec2 w) {\n\treturn vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\nvec2 boxFold(vec2 z, float fold) {\n    return vec2(z.x > fold ? 2. * fold - z.x : (z.x < -fold ? -2. * fold - z.x : z.x),\n                z.y > fold ? 2. * fold - z.y : (z.y < -fold ? -2. * fold - z.y : z.y));\n}\n\nvec2 ballFold(vec2 z, float r, float bigR) {\n    float zAbs = len(z);\n    r = abs(r);\n    return zAbs < r ? z / (r * r) : (zAbs < abs(bigR)) ?\n            z / (zAbs * zAbs)\n            : z;\n}\n\nvec2 rotate(vec2 v, float phi) {\n  return times(v, polar(1.0, phi)) ;\n}\n\n// MISC. FUNCTIONS:\n\nbool isOdd(float n) {\n  return mod(n, 2.) > 0.5;\n}\n\n// MAIN METHOD:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // MUTABLE VARIABLES\n    float scaleFactor = 0.5;\n    float order = 10.0;\n    float timeFactor = 1.0;\n    float factorG = 20.0;\n\tfloat t = 2. * mod(iTime * timeFactor, 1.0);\n    scaleFactor += 0.5 *sin(iTime /6.) / 2.;\n    \n    order = floor(mod(iTime / 10., 16.));\n    \n    // COORDINATES RAW (p) AND NORMALISED TO [-0.5, 0.5[ (q):\n    vec2 p = fragCoord.xy / iResolution.xy;\n    // p.x *= sin(p.y);\n    vec2 q = (p - vec2(0.5, 0.5)) / scaleFactor;\n    q = rotate(q, cos(iTime / 20.) * TWO_PI);\n    \n    // SMOOTHSTEP RADII and ASSOCIATED TRANSFORMATION FUNCTION:\n    // ===============================================\n    float rmin = 0.2;\n    float rinc = 0.01;\n    float rincp = 0.002;\n    float rincf = 0.1;     \n    // ===============================================\n    \n    // Colours:\n    vec3 orange = vec3(1.0, 0.2, 0.0);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n    \n    // Define root colour:\n    vec3 col = mix(orange, yellow, (p.y));\n    col.b = sin(mod(iTime  / 12., 1.0));\n    // Now mutate according to length:\n    float r = rmin + rincf * cos(atan(q.y, q.x) * order + factorG * q.x + 1.0);\n    \n    col *= smoothstep(r, r + rinc, len(q));\n    \n    r = 0.04;\n    // make trunk wavy:\n    float barkWaviness = mod(iTime * 32., 100.0);\n    float barkIndentation = 0.016;\n    r += barkIndentation * cos(barkWaviness * q.y);\n    // make base broad; using p as it runs from 0 to 1:\n    r += exp(-64.0 *p.y);\n    \n    \n    // Put a green thing in the middle and tweak it:\n    float numPleats = 256.0;\n    float amp = 2.0 * cos(iTime / 20.);        \n    float baseX = 1.2;\n    float bendiness = 3.0;\n    baseX +=(mod(iTime/ 6.0, 1.6) - 1.6);\n    bendiness += (mod(iTime/ 2.0, 1.6) - 1.6);\n    col *= 1.0 -  (1.0 - smoothstep(r, r + rincp, abs(q.x + baseX * sin(bendiness * q.y)))) \n        * (1.0 - smoothstep(0.0, rincf, q.y));\n    \n    numPleats += (mod(iTime * 4., 18.) - 9.);\n    if (length(q) > 0.6 - amp * sin(numPleats *arg(q)) * 0.4) col = black;\n    \n    if (length(q) < 0.021 - amp * cos(numPleats * 3. * arg(q + PI / numPleats)) * 0.4) col = cyan;\n    \n    // Make things go a bit bluier once every so often:\n    float f = fract(iTime / 50.);\n    if (f < 0.2) col.b += abs(sin(f));;\n    \n    fragColor = vec4(col, 1.0);\n}\n\n//===================================================++++=========\n\n// SPARE CODE:\n\n// sin(atan(q.x, q.y) * (order - 1.)))",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}