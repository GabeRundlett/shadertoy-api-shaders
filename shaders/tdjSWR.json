{
    "Shader": {
        "info": {
            "date": "1553482685",
            "description": "fork of\nhttps://www.shadertoy.com/view/XsBSRG\nmouse.y sets lame FoV\nmouse.x rotates around vertical axis.\n\npossibly faster than its parent.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdjSWR",
            "likes": 24,
            "name": "morning city isOutClosed",
            "published": 3,
            "tags": [
                "tower",
                "city",
                "trace",
                "interval",
                "cars",
                "traverse",
                "isoutclosed",
                "isoutopen",
                "skyscraper"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1165
        },
        "renderpass": [
            {
                "code": "\n#define CARS\n#define I_MAX 270\n\n//self  :  https://www.shadertoy.com/view/tdjSWR\n//parent:  https://www.shadertoy.com/view/XsBSRG\n\n//child may have broken some minor things (some offsets may bebad)\n//child adds some useful subroutine identities to its parent;\n//by using more || than && it may run faster on some hardware\n//i increased I_MAX from 70 to 270\n//, seems that precision is a bigger issue than number of iterations.\n\n\n//opengl has no component wise [not] ?\nvoid bnot(inout bvec3 a){a.x=!a.x;a.y=!a.y;a.z=!a.z;}\n\n#define vec1 float\n//return if [a] is Outside of closed interval; [s..e] ;s<=e\nbool isOutClosed(vec1 a,vec1 s,vec1 e){return              e-s<abs(a*2.-e-s);}//return (a>e)&&(a<s)\nbool isOutClosed(vec2 a,vec2 s,vec2 e){return any(lessThan(e-s,abs(a*2.-e-s)));}\nbool isOutClosed(vec3 a,vec3 s,vec3 e){return any(lessThan(e-s,abs(a*2.-e-s)));}\nbool isOutClosed(vec4 a,vec4 s,vec4 e){return any(lessThan(e-s,abs(a*2.-e-s)));}\n//return if [a] is in closed interval; [s..e]  ;s<=e\n#define isInClosed(a,b,c) (!isOutClosed(a,b,c))\n//return if [a] is in open   interval; ]s..e[  ;s<=e\nbool isInOpen(vec1 a,vec1 s,vec1 e){return              abs(a*2.-e-s)<e-s;}//return (a>s)&& (a<e) \nbool isInOpen(vec2 a,vec2 s,vec2 e){return any(lessThan(abs(a*2.-e-s),e-s));}\nbool isInOpen(vec3 a,vec3 s,vec3 e){return any(lessThan(abs(a*2.-e-s),e-s));}\nbool isInOpen(vec4 a,vec4 s,vec4 e){return any(lessThan(abs(a*2.-e-s),e-s));}\n//return if [a] is Outside of open interval; ]s..e[   ;s<=e\n#define isOutOpen(a,b,c) (!isInOpen(a,b,c))\n//any() can perform faster than all(), therefore we define [all() == !(any(!(ivecN)))]\n//where [(a<b) == !(a>=b)]\n//where  (a< b) is isOutClosed()\n//where !(b>=a) is isOutOpen()   //note the swapped parameters \n\nfloat rand(vec2 n\n){return fract(sin((n.x*1e2+n.y*1e4+1475.4526)*1e-4)*1e6);}\n\nfloat noise(vec2 p){p=floor(p*200.);return rand(p);}\n\n//AxisAlignedQuad-tracing crunched by ollj\n#define pmpm vec4(1,-1,1,-1)\nvec4 setg(vec2 a,vec2 b){return pmpm*min(a.xxyy*pmpm,b.xxyy*pmpm);}\nvec3 polygon(vec2 c,vec4 g,vec3 d,vec3 u\n){if(any(lessThan(vec4(c.xy,g.yw),vec4(g.xz,c.xy)))||dot(d,u)<0.)return vec3(101,0,0)\n ;return vec3(length(u),c.xy-g.xz);}\nvec3 polygonXY(float z,vec2 a,vec2 b,vec3 u,vec3 d\n){vec2 c=u.xy-d.xy*(u.z-z)/d.z;return polygon(c,setg(a,b),d,vec3(c,z)-u);}\nvec3 polygonYZ(float x,vec2 a, vec2 b, vec3 u,vec3 d\n){vec2 c=u.yz-d.yz*(u.x-x)/d.x;return polygon(c,setg(a,b),d,vec3(x,c)-u);}\nvec3 polygonXZ(float y,vec2 a, vec2 b, vec3 u,vec3 d\n){vec2 c=u.xz-d.xz*(u.y-y)/d.y;return polygon(c,setg(a,b),d,vec3(c.x,y,c.y)-u);}\n\nvec3 textureWall(vec2 pos, vec2 maxPos, vec2 squarer,float s,float height,float dist,vec3 d,vec3 norm\n){float randB=rand(squarer*2.0)\n ;vec3 windowColor=(-0.4+randB*0.8)*vec3(0.3,0.3,0.0)\n +(-0.4+fract(randB*10.0)*0.8)*vec3(0.0,0.0,0.3)+(-0.4+fract(randB*10000.)*0.8)*vec3(0.3,0.0,0.0)\n ;float floorFactor=1.\n ;vec2 windowSize=vec2(0.65,0.35)\n ;vec3 wallColor=s*(0.3+1.4*fract(randB*100.))*vec3(0.1,0.1,0.1)\n +(-0.7+1.4*fract(randB*1000.))*vec3(0.02,0.,0.)\n ;wallColor*=1.3\n ;vec3 color=vec3(0)\n ;vec3 conturColor=wallColor/1.5\n ;if (height<0.51\n ){windowColor += vec3(.3,.3,.0)\n  ;windowSize=vec2(.4)\n  ;floorFactor=0.;}\n ;if (height<.6){floorFactor=0.;}\n ;if (height>.75)windowColor += vec3(0,0,.3)\n ;windowColor*=1.5\n ;float wsize=0.02\n ;wsize+=-0.007+0.014*fract(randB*75389.9365)\n ;windowSize+= vec2(0.34*fract(randB*45696.9365),0.50*fract(randB*853993.5783))\n ;windowSize/=2.\n ;vec2 contur=vec2(0.0)+(fract(maxPos/2.0/wsize))*wsize\n  ;vec2 pc=pos-contur\n ;if (contur.x<wsize)contur.x+=wsize\n ;if (contur.y<wsize)contur.y+=wsize\n ;vec2 winPos=(pc)/wsize/2.0-floor((pc)/wsize/2.0)\n ;float numWin=floor((maxPos-contur)/wsize/2.0).x\n ;vec3 n=floor(numWin*vec3(1,2,3)/4.)\n ;vec2 m=numWin*vec2(1,2)/3.\n ;float w=wsize*2.\n ;bvec3 bo=bvec3(isOutOpen(pc.x  ,w*n.y,w+w*n.y)||isOutOpen(maxPos.x,.5,.6)\n                ,isOutOpen(pc.xx ,w*m  ,w+w*m  )||isOutOpen(maxPos.x,.6,.7)\n                ,isOutOpen(pc.xxx,w*n  ,w+w*n  )||maxPos.x>.7)\n ;bnot(bo)\n ;if(any(bo))return (.9+.2*noise(pos))*conturColor \n ;if((maxPos.x-pos.x<contur.x)||(maxPos.y-pos.y<contur.y+w)||(pos.x<contur.x)||(pos.y<contur.y))\n            return (0.9+0.2*noise(pos))*conturColor\n ;if (maxPos.x<0.14)return (0.9+0.2*noise(pos))*wallColor\n ;vec2 window=floor(pc/w)\n ;float random=rand(squarer*s*maxPos.y+window)\n ;float randomZ=rand(squarer*s*maxPos.y+floor(pc.yy/w))\n ;float windows=floorFactor*sin(randomZ*5342.475379+(fract(975.568*randomZ)*0.15+0.05)*window.x)\n ;float blH=0.06*dist*600./iResolution.x/abs(dot(normalize(d.xy),normalize(norm.xy)))\n ;float blV=0.06*dist*600./iResolution.x/sqrt(abs(1.0-pow(abs(d.z),2.0)))\n ;windowColor +=vec3(1.0,1.0,1.0)\n ;windowColor*=smoothstep(.5-windowSize.x-blH,.5-windowSize.x+blH,winPos.x)\n ;windowColor*=smoothstep(.5+windowSize.x+blH,.5+windowSize.x-blH,winPos.x)\n ;windowColor*=smoothstep(.5-windowSize.y-blV,.5-windowSize.y+blV,winPos.y)\n ;windowColor*=smoothstep(.5+windowSize.y+blV,.5+windowSize.y-blV,winPos.y)\n ;if ((random <0.05*(3.5-2.5*floorFactor))||(windows>0.65)\n ){if (winPos.y<0.5)windowColor*=(1.0-0.4*fract(random*100.))\n  ;if ((winPos.y>0.5)&&(winPos.x<0.5))windowColor*=(1.0-0.4*fract(random*10.0))\n  ;return (.9+.2*noise(pos))*wallColor+(0.9+0.2*noise(pos))*windowColor\n ;} else windowColor*=0.08*fract(10.0*random)\n ;return (.9+.2*noise(pos))*wallColor+windowColor;}\n\nbool con(vec2 u,vec2 b,vec2 c\n){return any(lessThan(vec3(min(u.x,u.y),b),vec3(0,u)))||!(any(lessThan(min(abs(b-u),abs(u)),c)));}\n\nvec3 textureRoof(vec2 pos, vec2 maxPos,vec2 squarer\n){float wsize=0.025\n ;float randB=rand(squarer*2.0)\n ;vec3 wallColor=(0.3+1.4*fract(randB*100.))*vec3(.1)+(-0.7+1.4*fract(randB*1000.))*vec3(0.02,0.,0.)\n ;vec3 conturColor=wallColor*1.5/2.5\n ;vec2 contur=vec2(0.02)\n ;if ((maxPos.x-pos.x<contur.x)||(maxPos.y-pos.y<contur.y)||(pos.x<contur.x)||(pos.y<contur.y)\n )return (0.9+0.2*noise(pos))*conturColor\n ;float s=.06+.12*fract(randB*562526.2865)\n ;pos-=s;maxPos-=s*2.;if(con(pos,maxPos,contur))return(.9+.2*noise(pos))*conturColor\n ;pos-=s;maxPos-=s*2.;if(con(pos,maxPos,contur))return(.9+.2*noise(pos))*conturColor\n ;pos-=s;maxPos-=s*2.;if(con(pos,maxPos,contur))return(.9+.2*noise(pos))*conturColor\n ;return (.9+.2*noise(pos))*wallColor;}\n\n\nvoid carloop(inout vec3 c,vec2 u,vec3 car1,vec3 car2,vec2 s,vec3 e,float n,float t,float o\n){float carNumber=0.5\n ;float r=0.01\n ;for (float j=0.;j<10.; j++\n ){float i=.03+o+j*.094\n  ;vec2 a=vec2(fract(i+iTime/4.),e.x)\n  ;if(e.z>0.)a=a.yx;\n  ;if(fract(n*5./i)>carNumber)c+=car1*smoothstep(r,0.,length(u-a))\n  ;a=vec2(fract(i-iTime/4.),e.y)\n  ;if(e.z>0.)a=a.yx;\n  ;if(fract(n*10./i)>carNumber)c+=car2*smoothstep(r,0.,length(u-a))\n  ;if(c.x>0.) break;}}\n\nvec3 cars(vec2 squarer, vec2 u, float dist,float level\n){vec3 c=vec3(0)\n ;float carInten=3.5/sqrt(dist)\n ;float r=0.01\n ;if (dist>2.0)r*=sqrt(dist/2.0)\n ;vec3 car1=vec3(.5,.5,1)*carInten\n ;vec3 car2=vec3(1.,.1,.1)*carInten\n ;float carNumber=0.5\n ;float n=noise((level+1.)*squarer*1.24435824)\n ;float t=iTime/4.\n ;carloop(c,u,car1,car2,vec2(   5,  10),vec3(.025,.975,0),n, t,0.)\n ;carloop(c,u,car1,car2,vec2(  10,   5),vec3(.975,.025,1),n,-t,0.)\n ;carloop(c,u,car1,car2,vec2( 100,1000),vec3(.045,.955,0),n, t,.047)  \n ;carloop(c,u,car1,car2,vec2(1000, 100),vec3(.955,.045,1),n,-t,.047)\n ;return c;}\n\nvec3 textureGround(vec2 squarer, vec2 pos,vec2 a,vec2 b,float dist\n){vec3 color=(0.9+0.2*noise(pos))*vec3(0.1,0.15,0.1)\n ;float randB=rand(squarer*2.)\n ;vec3 wallColor=(.3+1.4*fract(randB*100.))*.1+(-.7+1.4*fract(randB*1000.))*vec3(.02,0,0)\n ;float fund=0.03\n ;float bl=0.01\n ;float f=smoothstep(a.x-fund-bl,a.x-fund,pos.x)\n ;f*=smoothstep(a.y-fund-bl,a.y-fund,pos.y)\n ;f*=smoothstep(b.y+fund+bl,b.y+fund,pos.y)\n ;f*=smoothstep(b.x+fund+bl,b.x+fund,pos.x)\n ;pos -= 0.0\n ;vec2 maxPos=vec2(1)\n ;vec2 contur=vec2(0.06,0.06)\n ;if((pos.x>0.&&pos.y>0.&&pos.x<maxPos.x&&pos.y<maxPos.y)&&((abs(maxPos.x-pos.x)<contur.x)||(abs(maxPos.y-pos.y)<contur.y)||(abs(pos.x)<contur.x)||(abs(pos.y)<contur.y)))\n            color= vec3(0.1,0.1,0.1)*(0.9+0.2*noise(pos))\n ;pos -= 0.06\n ;maxPos=vec2(.88)\n ;contur=vec2(.01)\n ;if ((pos.x>0.0&&pos.y>0.0&&pos.x<maxPos.x&&pos.y<maxPos.y)&&((abs(maxPos.x-pos.x)<contur.x)||(abs(maxPos.y-pos.y)<contur.y)||(abs(pos.x)<contur.x)||(abs(pos.y)<contur.y))) color=vec3(0)\n ;color=mix(color,(0.9+0.2*noise(pos))*wallColor*1.5/2.5,f)\n ;pos+=0.06    \n#ifdef CARS\n ;if (min(pos.x,pos.y)<0.07||max(pos.x,pos.y)>0.93) color+=cars(squarer,pos,dist,0.);\n#endif\n ;return color;}\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 pos=(fragCoord.xy*2.0 - iResolution.xy) / iResolution.y\n ;float t=-iTime\n ;float tt=-iTime-0.5\n ;vec3 camPos=vec3(5.0+12.0*sin(t*0.05),5.0+ 7.0*cos(t*0.05), 1.9)\n ;vec3 camTarget=vec3(5.0+0.0,5.0+7.0*sin(t*0.05), 0.0)\n ;if (fract(t/12.0)<0.25){camPos=vec3(5.*t,3.1*t,2.1);camTarget=vec3(5.*tt,3.1*tt,1.7);}\n ;if (fract(t/12.0)>0.75){camPos=vec3(35.,3.1,1.);camTarget=vec3(35.+sin(t/10.0),3.1+cos(t/10.0),0.7);}\n ;if(iMouse.z>0.)camTarget.xy=camPos.xy-cs(6.2*iMouse.x/iResolution.x)\n ;vec3 cd=normalize(camTarget-camPos)\n ;vec3 cs=cross(cd,normalize(vec3(0,0,-1)))\n  //FoV like its the 80s, makes sense here to debug the traverser\n ;vec3 d=normalize(cs*pos.x+cross(cd,cs)*pos.y+cd*(4.-8.*iMouse.y/iResolution.x))\n ;float angle=.03*pow(abs(acos(d.x)),4.0)\n ;//angle=min(0.0,angle)\n ;vec3 color=vec3(0.0)\n ;vec2 square=floor(camPos.xy)\n ;square.xy +=.5-.5*sign(d.xy)\n ;float mind=100.\n ;int k=0\n ;vec3 pol\n ;vec2 maxPos,crossG\n ;float tSky=-(camPos.z-3.9)/d.z\n ;vec2 crossSky=floor(camPos.xy + d.xy*tSky)\n ;for (int i=1; i<I_MAX; i++ //2d rectangle traverse loop\n ){vec2 squarer=square-vec2(0.5,0.5)+0.5*sign(d.xy)\n  ;if(crossSky==squarer&&crossSky!=floor(camPos.xy)\n  ){color+=vec3(vec2(.5,.15)*abs(angle)*exp(-d.z*d.z*30.),.2);break;}\n  ;float random=rand(squarer),t,height=0.\n  ;float quartalR=rand(floor(squarer/10.))\n  ;if (floor(squarer/10.)==vec2(0)) quartalR=.399\n  ;if (quartalR<.4\n  ){height=-.15+.4*random+smoothstep(12.,7.,length(fract(squarer/10.)*10.-vec2(5)))\n   *.8*random+.9*smoothstep(10.,0.,length(fract(squarer/10.)*10.-vec2(5)))\n   ;height*=quartalR/.4;}\n  ;float maxJ=2.\n  ;float roof=1.\n  ;if (height<0.3\n  ){height=0.3*(0.7+1.8*fract(random*100.543264));maxJ=2.0\n   ;if (fract(height*1000.)<0.04) height*=1.3;}\n  ;if (height>0.5)maxJ=3.\n  ;if (height>0.85)maxJ=4.\n  ;if (fract(height*100.)<0.15){height=pow(maxJ-1.0,0.3)*height; maxJ=2.0; roof=0.0;}\n  ;float maxheight=1.5*pow((maxJ-1.0),0.3)*height+roof*0.07\n  ;if (camPos.z+d.z*(length(camPos.xy - square) +0.71 - sign(d.z)*0.71)/length(d.xy)<maxheight\n  ){vec2 ar\n   ;vec2 br\n   ;float zz=0.\n   ;float prevZZ=0.\n   ;for(int nf=1;nf<8;nf++\n   ){float j=float(nf)\n    ;if(j>maxJ)break\n    ;prevZZ=zz\n    ;zz=1.5*pow(j,0.3)*height\n    ;//prevZZ=zz-0.8\n    ;float dia=1.0/pow(j,0.3)\n    ;if(j==maxJ\n    ){if (roof == 0.0)break\n     ;zz=1.5*pow((j-1.0),0.3)*height+0.03+0.04*fract(random*1535.347)\n     ;dia=1.0/pow((j-1.0),0.3)-0.2-0.2*fract(random*10000.);}\n    ;vec2 v1=vec2(0)//vec2(random*10.0,random*1.0);\n    ;vec2 v2=vec2(0)//vec2(random*1000.,random*100.);\n    ;float randomF=fract(random*10.0)\n    ;if(randomF<.25){ v1=vec2(fract(random*1000.),fract(random*100.));}\n   ;if(randomF>.25&&randomF<.5 ){v1=vec2(fract(random*100.),0.);v2=vec2(0.0,fract(random*1000.));}\n   ;if(randomF>.5 &&randomF<.75){v2=vec2(fract(random*1000.),fract(random*100.));}\n   ;if(randomF>.75             ){v1=vec2(0.,fract(random*1000.)); v2=vec2(fract(random*100.),0.);}\n   ;if(d.y<0.0){float y=v1.y;v1.y=v2.y;v2.y=y;}\n   ;if(d.x<0.0){float x=v1.x;v1.x=v2.x;v2.x=x;}\n   ;vec2 a=square+sign(d.xy)*(0.5-0.37*(dia*1.0-1.0*v1))\n   ;vec2 b=square+sign(d.xy)*(0.5+0.37*(dia*1.0-1.0*v2))\n   ;if (j==1.0\n   ){ar=vec2(min(a.x, b.x),min(a.y,b.y))\n    ;br=vec2(max(a.x, b.x),max(a.y,b.y));}\n   ;vec3 pxy=polygonXY(zz,a,b,camPos,d)\n   ;if (pxy.x<mind){mind=pxy.x; pol=pxy; k=1;maxPos=vec2(abs(a.x-b.x),abs(a.y-b.y));}\n   ;vec3 pyz=polygonYZ(a.x,vec2(a.y,prevZZ),vec2(b.y,zz),camPos,d)\n   ;if (pyz.x<mind){mind=pyz.x; pol=pyz; k=2;maxPos=vec2(abs(a.y-b.y),zz-prevZZ);}\n   ;vec3 pxz=polygonXZ(a.y,vec2(a.x,prevZZ),vec2(b.x,zz),camPos,d)\n   ;if (pxz.x<mind){mind=pxz.x; pol=pxz; k=3;maxPos=vec2(abs(a.x-b.x),zz-prevZZ);}}\n   ;if ((mind<100.)&&(k==1)\n   ){color += textureRoof(vec2(pol.y,pol.z),maxPos,squarer);if (mind>3.){color*=sqrt(3./mind);};break;}\n   ;if ((mind<100.)&&(k==2)\n   ){color += textureWall(vec2(pol.y,pol.z),maxPos,squarer,1.2075624928,height,mind,d,vec3(1,0,0))\n    ;if (mind>3.0)color*=sqrt(3.0/mind);break;} \n   ;if ((mind<100.)&&(k==3)\n   ){color += textureWall(vec2(pol.y,pol.z),maxPos,squarer,.8093856205,height,mind,d,vec3(0,1,0))\n    ;if (mind>3.0)color*=sqrt(3.0/mind);break;}\n   ;t=-camPos.z/d.z\n   ;crossG=camPos.xy + d.xy*t\n   ;if (floor(crossG) == squarer\n   ){mind=length(vec3(crossG,0.0)-camPos)\n    ;color += textureGround(squarer,fract(crossG),fract(ar),fract(br),mind)\n    ;if (mind>3.0)color*=sqrt(3.0/mind);break;}} \n  ;if ((square.x+sign(d.x)-camPos.x)/d.x<(square.y+sign(d.y)-camPos.y)/d.y\n  ){square.x += sign(d.x)*1.0;}else square.y += sign(d.y)*1.\n  ;if(i==I_MAX-1&&d.z>-0.1)color += vec3(vec2(0.5,0.15)*abs(angle)*exp(-d.z*d.z*30.0),0.2);}\n ;fragColor=vec4(color,1);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}