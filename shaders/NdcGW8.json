{
    "Shader": {
        "info": {
            "date": "1629627496",
            "description": "ðŸ‘€",
            "flags": 0,
            "hasliked": 0,
            "id": "NdcGW8",
            "likes": 5,
            "name": "i spy",
            "published": 3,
            "tags": [
                "eyes"
            ],
            "usePreview": 0,
            "username": "j0",
            "viewed": 270
        },
        "renderpass": [
            {
                "code": "\nfloat eye(vec2 uv, float time) {\n    // magic numbers\n    const float pinch = 0.15;\n    const float radius = 0.25;\n    const float eyeballRadius = 0.44;\n    const float pupilRadius = 0.48;\n    const float blinkingSpeed = 2.5;\n    const float eyeballRange = 0.08;\n    float outsideThickness = 10./iResolution.x;\n    \n    // open and close based on noise (0.0 -> open; 1.0 -> closed)\n    float closed = clamp(cnoise(vec2(time * 0.25, 0.0)) * 10.0, 0.0, 1.0);\n    // blink\n    closed = 1.0 - (1.0 - closed) * clamp(1.0 - smoothstep(0.0, 1.5, 18.0 * (sin(time * blinkingSpeed) * 0.5 + 0.5) - 17.0), 0.0, 1.0);\n    // scale eye and outline based on open/closed status\n    float scale = mix(1.0, 50.0, closed);\n    \n    // select direction the eye is looking in (-1..1 on both axes)\n    vec2 direction = clamp(cnoise2(vec2(time * 0.4, 0.0)) * 100.0, -1.0, 1.0);\n    // look directly at viewers every now and then\n    direction *= clamp(1.0 - smoothstep(0.0, 0.1, 3.0 * (sin(time + 0.723) * 0.5 + 0.5) - 2.0), 0.0, 1.0);\n    \n    // create eyeball\n    float ballL = 0.5-length(uv - direction * eyeballRange);\n    float eyeball = smoothstep(eyeballRadius, eyeballRadius + outsideThickness * 0.3, ballL);\n    eyeball -= smoothstep(eyeballRadius + outsideThickness * 0.7, eyeballRadius + outsideThickness, ballL);\n    eyeball += smoothstep(pupilRadius, pupilRadius + outsideThickness * 0.3, ballL);\n    float full = eyeball;\n    \n    // pinch out the extremities of the eye\n    uv.y *= scale;\n    outsideThickness *= scale;\n    uv.y -= (step(uv.y, 0.0) * 2.0 - 1.0) * pinch;\n    // draw outline\n    float fullL = 0.5-length(uv);\n    full *= smoothstep(radius + outsideThickness * 0.3, radius + outsideThickness * 0.3, fullL);\n    full += smoothstep(radius, radius + outsideThickness * 0.3, fullL);\n    full -= smoothstep(radius + outsideThickness * 0.7, radius + outsideThickness, fullL);\n    return clamp(full, 0.0, 1.0) * smoothstep(0.9, 0.91, 1.0 - closed);\n}\n\n\n// Palette based on iq's implementation (see Common)\nvec3 palette(float x) {\n    return pal( x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = ((uv.y - 0.5) / iResolution.x * iResolution.y) + 0.5;\n    uv += iTime * 0.02 * vec2(-1.0, 0.5);\n    uv *= 12.0;\n    uv -= iMouse.xy * 0.01;\n    \n    // assign tile values to the invidual eyes (drives colour + animation)\n    float tile1 = cnoise(floor(uv) + 0.5) * 97.2;\n    float tile2 = 0.726 + cnoise(floor(uv + 0.5) + 0.5) * 76.01;\n    \n    // stack eyes together (2 passes to achieve the hexagonal alignment easily)\n    vec3 eyes = eye((fract(uv) - 0.5) * 0.45, iTime * 0.5 + tile1) * palette(tile1 + iTime * 0.1 + iMouse.x * 0.006);\n    eyes += eye((fract(uv + 0.5) - 0.5) * 0.45, iTime * 0.5 + tile2) * palette(tile2 + iTime * 0.1 + iMouse.y * 0.006);\n    \n    fragColor = vec4(eyes, 1.0);\n}\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// Colour palette by iq https://www.shadertoy.com/view/ll2GD3\n//\n// The MIT License\n// Copyright Â© 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Return a 2D position\nvec2 cnoise2(vec2 p){\n    return vec2(cnoise(p), cnoise(p.yx));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}