{
    "Shader": {
        "info": {
            "date": "1660752838",
            "description": "How about a small dynamic array that can be loaded / stored in a single pixel ?\n\nDS Array is an utility snippet that implements just that: per-pixel dynamic-size arrays in glsl.\nCheck out Common tab for more info.\n\nEnjoy! :)",
            "flags": 32,
            "hasliked": 0,
            "id": "Nt3yDs",
            "likes": 21,
            "name": "Per-Pixel Dynamic Arrays",
            "published": 3,
            "tags": [
                "vector",
                "container",
                "spatialhashing",
                "dynamicarray",
                "dynamicvector",
                "dynamicmemory",
                "spacepartitioning",
                "datatype"
            ],
            "usePreview": 0,
            "username": "Lorenzo_Vannuccini",
            "viewed": 696
        },
        "renderpass": [
            {
                "code": "//\n//  How about a small dynamic array that can be loaded / stored in a single pixel ?\n// \n//  DS Array is an utility snippet that implements just that: per-pixel dynamic-size arrays in glsl.\n//  Now hold your horses, there are obviously some major limitations compared to classic containers from other languages:\n// \n//  - The maximum capacity a ds_array can grow is 9, so no more than 9 elements stored per vector / pixel.\n//  - A ds_array can only contain unsigned integers, and their values can only range from [0u, 9998u].\n//  - Code atm only works on desktop and it's far from being optimized (be wary)... but it's a start.\n// \n//  With these compromises in mind, a ds_array can be encoded / decoded in a single pixel on RGBA32F render textures,\n//  and passed to other render passes. This can come in real handy for use-cases such as spatial hashing / partitioning, \n//  tiled based deferred shading, OIT, etc.\n// \n//  This array is intended to be used as a small dynamic index buffer, its indices can look up about ~10k objects and the vector\n//  can grow / shrink at runtime. API is flexible and can be used to implement queues, sorting, and more.\n// \n// \n//  Find:\n// \n//  - Snippet & Doxygen in \"Common\" tab                <-- Copy/paste on your project to use, 10 lines snippet\n// \n//  - Test Cases Run / Usage examples in \"Buffer A\"    <-- The meat is here, should be fairly straightforward\n// \n//  - Test Cases Validation / Printing in \"Buffer B\"   <-- Note: only few test-cases are printed to ease compilation time,\n//                                                         select the ones you want\n// \n//  Enjoy! :)\n//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0); // pass-through\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ******************************************************************************************** //\n//                                           DS Array  v.1.0.1                                  //\n// ******************************************************************************************** //\n/*\n    Copyright Â© 2022 Lorenzo Vannuccini, blackravenprod@gmail.com\n\n    This framework is provided 'as-is', without any express or implied\n    warranty. In no event will the authors be held liable for any damages\n    arising from the use of this framework.\n\n    Permission is granted to anyone to use this framework for any purpose,\n    including commercial applications, and to alter it and redistribute it\n    freely, subject to the following restrictions:\n\n        1. The origin of this framework must not be misrepresented; you must not\n        claim that you wrote the original framework. If you use this framework\n        in a product, an acknowledgment in the product documentation would be\n        appreciated but is not required.\n\n        2. Altered source versions must be plainly marked as such, and must not be\n        misrepresented as being the original software.\n\n        3. This notice may not be removed or altered from any source distribution.\n*/\n\n#define USE_UIBTF_WORKAROUND // Hardware Bug Workaround: on some GPUs uintBitsToFloat() behaves inconsistently\n                             // due to internal optimizations. This workaround tricks the glsl compiler into thinking\n                             // input parameters to this function are uniform-dependent, which bypasses the issue.\n#define ds_array uvec4\n#ifdef  USE_UIBTF_WORKAROUND\n#define uintBitsToFloat(v)uintBitsToFloat(v+uint(mod(iDate.x,1e-6)))\n#endif\nuvec4 _ds_array_pack(const uint u[9]){return(u[0]+1u)/uvec4(1000u,100u,10u,1u)%10u+(u[1]+1u)/uvec4(1000u,100u,10u,1u)%10u*10u+(u[2]+1u)/uvec4(1000u,100u,10u,1u)%10u*100u+(u[3]+1u)/uvec4(1000u,100u,10u,1u)%10u*1000u+(u[4]+1u)/uvec4(1000u,100u,10u,1u)%10u*10000u+(u[5]+1u)/uvec4(1000u,100u,10u,1u)%10u*100000u+(u[6]+1u)/uvec4(1000u,100u,10u,1u)%10u*1000000u+(u[7]+1u)/uvec4(1000u,100u,10u,1u)%10u*10000000u+(u[8]+1u)/uvec4(1000u,100u,10u,1u)%10u*100000000u;}uint[9] _ds_array_unpack(const uvec4 u){return uint[9](1000u*(u.r%10u)+100u*(u.g%10u)+10u*(u.b%10u)+u.a%10u-1u,1000u*(u.r/10u%10u)+100u*(u.g/10u%10u)+10u*(u.b/10u%10u)+u.a/10u%10u-1u,1000u*(u.r/100u%10u)+100u*(u.g/100u%10u)+10u*(u.b/100u%10u)+u.a/100u%10u-1u,1000u*(u.r/1000u%10u)+100u*(u.g/1000u%10u)+10u*(u.b/1000u%10u)+u.a/1000u%10u-1u,1000u*(u.r/10000u%10u)+100u*(u.g/10000u%10u)+10u*(u.b/10000u%10u)+u.a/10000u%10u-1u,1000u*(u.r/100000u%10u)+100u*(u.g/100000u%10u)+10u*(u.b/100000u%10u)+u.a/100000u%10u-1u,1000u*(u.r/1000000u%10u)+100u*(u.g/1000000u%10u)+10u*(u.b/1000000u%10u)+u.a/1000000u%10u-1u,1000u*(u.r/10000000u%10u)+100u*(u.g/10000000u%10u)+10u*(u.b/10000000u%10u)+u.a/10000000u%10u-1u,1000u*(u.r/100000000u%10u)+100u*(u.g/100000000u%10u)+10u*(u.b/100000000u%10u)+u.a/100000000u%10u-1u);}int ds_array_size(const uvec4 u){int i=0;uint f=max(max(max(u.r,u.g),u.b),u.a);if(f==0u)i=0;else if(f==1u)i=1;else if(f==10u)i=2;else if(f==100u)i=3;else if(f==1000u)i=4;else if(f==10000u)i=5;else if(f==100000u)i=6;else if(f==1000000u)i=7;else if(f==10000000u)i=8;else if(f==100000000u)i=9;else i=max(int(floor(log(float(f))/2.30259))+1,0);return i;}void ds_array_clear(inout uvec4 u){u=uvec4(0u);}bool ds_array_empty(const uvec4 v){return ds_array_size(v)==0;}bool ds_array_full(const uvec4 v){return ds_array_size(v)>=9;}uint ds_array_remove(inout uvec4 i,in int u){int v=ds_array_size(i);u=clamp(u,0,v-1);uint f=uint(0);if(v>0){uint c[9]=_ds_array_unpack(i);--v;f=c[u];for(int t=u;t<=v;++t)c[t]=t<v?c[t+1]:-1u;i=_ds_array_pack(c);}return f;}int ds_array_insert(inout uvec4 i,in int u,const uint v){int c=ds_array_size(i);u=clamp(u,0,c);if(c<9){uint f[9]=_ds_array_unpack(i);for(int t=c;t>u;--t)f[t]=f[t-1];f[u]=v;++c;i=_ds_array_pack(f);}return c;}int ds_array_push(inout uvec4 u,const uint v){return ds_array_insert(u,9,v);}int ds_array_unshift(inout uvec4 v,const uint u){return ds_array_insert(v,0,u);}uint ds_array_pop(inout uvec4 v){return ds_array_remove(v,9);}uint ds_array_shift(inout uvec4 v){return ds_array_remove(v,0);}void ds_array_fill(inout uvec4 u,const uint v){int t=ds_array_size(u);uint i[9]=uint[9](-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u);for(int f=0;f<t;++f)i[f]=v;u=_ds_array_pack(i);}void ds_array_set(inout uvec4 i,const int v,const uint u){uint r[9]=_ds_array_unpack(i);r[v]=u;i=_ds_array_pack(r);}uint ds_array_get(const uvec4 i,in int v){uint u[9]=_ds_array_unpack(i);return u[v];}uint ds_array_front(const uvec4 i){return ds_array_get(i,0);}uint ds_array_back(const uvec4 i){int u=ds_array_size(i);return ds_array_get(i,u-1);}bool ds_array_resize(inout uvec4 i,in int v,in uint u){int t=ds_array_size(i);v=clamp(v,0,9);if(t!=v){uint f[9]=_ds_array_unpack(i);for(int r=min(v,t);r<9;++r)f[r]=r<v?u:-1u;i=_ds_array_pack(f);return true;}return false;}bool ds_array_resize(inout uvec4 i,in int u){return ds_array_resize(i,u,0u);}void ds_array_sort(inout uvec4 i){int v=ds_array_size(i);uint u[9]=_ds_array_unpack(i);for(int f=0;f<v-1;++f)for(int t=0;t<v-f-1;++t){if(u[t]>u[t+1]){uint o=u[t];u[t]=u[t+1];u[t+1]=o;}}i=_ds_array_pack(u);}void ds_array_reverse(inout uvec4 u){int v=ds_array_size(u);uint t[9]=_ds_array_unpack(u),i[9]=uint[9](-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u);for(int f=0;f<v;++f)i[f]=t[v-f-1];u=_ds_array_pack(i);}uvec4 ds_array_load(const vec4 c){return floatBitsToUint(c);}vec4 ds_array_store(const uvec4 u){return uintBitsToFloat(u);}uvec4 ds_array_make(){return uvec4(0);}uvec4 ds_array_make(const int v){uvec4 c=uvec4(0);ds_array_resize(c,v);return c;}uvec4 ds_array_make(const int c,const uint v){uvec4 i=uvec4(0);ds_array_resize(i,c,v);return i;}\n#define ds_array_overload(size) uvec4 ds_array_make(const uint v[size]){uvec4 u=uvec4(0);uint t[9]=uint[9](-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u,-1u);for(int e=0;e<size;++e)t[e]=min(v[e],9998u);return _ds_array_pack(t);}\nds_array_overload(1) ds_array_overload(2) ds_array_overload(3) ds_array_overload(4) ds_array_overload(5) ds_array_overload(6) ds_array_overload(7) ds_array_overload(8) ds_array_overload(9)\n\n// ---------------------------------------- API Doxygen ---------------------------------------- //\n\n/** Constructs a dynamic array\n *\n *  @param[in]  size  [OPTIONAL] The size of the array, must be in range [0, 9], default is 0 when unspecified\n *  @param[in]  fill  [OPTIONAL] Fills the array with this value, must be in range [0u, 9998u], default is 0u when unspecified\n *  @return           The dynamic array object\n */\nds_array ds_array_make(const int size, const uint fill);\n\n\n/** Constructs a dynamic array from a static array of arbitrary size\n *\n *  @param[in]  c_array  The input static array to copy, size must be in range [1, 9]\n *  @return              The dynamic array object\n */\nds_array ds_array_make(const uint c_array[9]);\n\n\n/** Returns the number of elements in the dynamic array\n *\n *  @param[in]  array  The input dynamic array\n *  @return            The size of the array, can range between [0, 9]\n */\nint ds_array_size(const ds_array array);\n\n\n/** Empties the dynamic array\n *\n *  @param[in, out]  array  The dynamic array to clear\n */\nvoid ds_array_clear(inout ds_array array);\n\n\n/** Checks if the dynamic array is empty\n *\n *  @param[in]  array  The input dynamic array\n *  @return            True is size is 0, false otherwise\n */\nbool ds_array_empty(const ds_array array);\n\n\n/** Checks if the dynamic array has reached maximum capacity\n *\n *  @param[in]  array  The input dynamic array\n *  @return            True is size is 9, false otherwise\n */\nbool ds_array_full(const ds_array array);\n\n\n/** Adds a new element at the back of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array, must not be full or the element won't be added\n *  @param[in]       value  The value of the new element\n *  @return                 The new size of the array\n */\nint ds_array_push(inout ds_array array, const uint value);\n\n\n/** Erases the last element of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array\n *  @return                 The removed element's value\n */\nuint ds_array_pop(inout ds_array array);\n\n\n/** Adds a new element at the front of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array, must not be full or the element won't be added\n *  @param[in]       value  The value of the new element\n *  @return                 The new size of the array\n */\nint ds_array_unshift(inout ds_array array, const uint value);\n\n\n/** Erases the first element of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array\n *  @return                 The removed element's value\n */\nuint ds_array_shift(inout ds_array array);\n\n\n/** Inserts a new element in the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array, must not be full or the element won't be added\n *  @param[in]       index  The index at which the element will be inserted\n *  @param[in]       value  The value of the new element\n *  @return                 The new size of the array\n */\nint ds_array_insert(inout ds_array array, in int index, const uint value);\n\n\n/** Erases an element from the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array\n *  @param[in]       index  The index of the element to remove\n *  @return                 The removed element's value\n */\nuint ds_array_remove(inout ds_array array, in int index);\n\n\n/** Fills the dynamic array with a value\n *\n *  @param[in, out]  array  The input dynamic array, must not be empty or it won't be filled\n *  @param[in]       value  The value to fill the array with\n */\nvoid ds_array_fill(inout ds_array array, const uint value);\n\n\n/** Sets an element of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array, must already contain the element or it won't set\n *  @param[in]       index  The index of the element to set\n *  @param[in]       value  The new value of the element\n */\nvoid ds_array_set(inout ds_array array, const int index, const uint value);\n\n\n/** Reads an element from the dynamic array\n *\n *  @param[in]  array  The input dynamic array, must already contain the element\n *  @param[in]  index  The index of the element to read\n *  @return            The element's value\n */\nuint ds_array_get(const ds_array array, in int index);\n\n\n/** Reads the first element of the dynamic array\n *\n *  @param[in]  array  The input dynamic array, must not be empty\n *  @return            The array first element's value\n */\nuint ds_array_front(const ds_array array);\n\n\n/** Reads the last element of the dynamic array\n *\n *  @param[in]  array  The input dynamic array, must not be empty\n *  @return            The array last element's value\n */\nuint ds_array_back(const ds_array array);\n\n\n/** Resizes the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array\n *  @param[in]       size   The new size of the array, must be in range [0, 9]\n *  @param[in]       fill   [OPTIONAL] Fills the new elements with this value, must be in range [0u, 9998u], default is 0u when unspecified\n *  @return                 True if the array was resized, false if the size was unchanged\n */\nbool ds_array_resize(inout ds_array array, in int size, in uint fill);\n\n\n/** Sorts the dynamic array in ascending order\n *\n *  @param[in, out]  array  The input dynamic array to sort\n */\nvoid ds_array_sort(inout ds_array array);\n\n\n/** Inverts the elements's order of the dynamic array\n *\n *  @param[in, out]  array  The input dynamic array to reverse\n */\nvoid ds_array_reverse(inout ds_array array);\n\n\n/** Packs the dynamic array into a single 32 bit vec4\n *\n *  @param[in]  array  The dynamic array to store\n *  @return            A 32 bit vec4 containing the encoded array, can be subsequently decoded via ds_array_load()\n */\nvec4 ds_array_store(const ds_array array);\n\n\n/** Unpacks the dynamic array from a single 32 bit vec4\n *\n *  @param[in]  encoded  The 32 bit vec4, which was encoded via ds_array_store()\n *  @return              The decoded dynamic array\n */\nds_array ds_array_load(const vec4 encoded);\n\n// --------------------------------------------------------------------------------------------- //\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ***************************************************************************************** //\n//                         Writes / Generates Tests-Cases Outputs                            //\n// ***************************************************************************************** //\n\n// This pass runs all kind of tests, some are stateless others are stateful.\n// Each test-case runs on a separate dynamic array, each is stored on a single pixel.\n// Generated results are then evaluated in next pass (\"Buffer B\"), and compared against expected results.\n\n#define TEST_CASE_CONSTRUCTOR_FILL  0 // tests dynamic array constructor and filling\n#define TEST_CASE_CONSTRUCTOR_IMPL  1 // tests dynamic array implicit constructor\n#define TEST_CASE_DYNAMIC_SIZE      2 // tests dynamic array insertions / resizing\n#define TEST_CASE_SORTING           3 // tests dynamic array elements sorting (bubble-sort)\n#define TEST_CASE_LOAD_REVERSE      4 // tests dynamic array elements reversing\n#define TEST_CASE_RUNTIME_QUEUE     5 // test dynamic arrays insertions / resizing at runtime\n#define TEST_CASES                  6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ds_array array = ds_array_make(); // make an empty dynamic array\n    \n    int pixelID = int(floor(fragCoord.x) + floor(fragCoord.y) * iResolution.x); // pixel index\n    switch(pixelID) // 1 array per pixel, so 1 test case per pixel\n    {\n        case TEST_CASE_CONSTRUCTOR_FILL:\n        {\n            // make a dynamic array of 4 elements, and fill it with value \"123\"\n            array = ds_array_make(4, 123u); // { 123, 123, 123, 123 }\n    \n        } break;\n        \n        case TEST_CASE_CONSTRUCTOR_IMPL:\n        { \n            // make a dynamic array from a static array\n            array = ds_array_make(uint[](0u, 123u, 456u, 789u, 1011u, 1213u, 1415u, 1617u, 9998u));\n    \n        } break;\n        \n        case TEST_CASE_DYNAMIC_SIZE:\n        { \n            uint i = 0u;\n            // fill the array incrementally until it reaches max capacity (9), stop at 99 in case something went wrong\n            while(!ds_array_full(array) && (++i < 99u)) ds_array_push(array, i); // { 1, 2, 3, 4, 5, 6, 7, 8, 9 }\n            \n            // remove 8th element and store it in a temp variable\n            uint temp = ds_array_remove(array, 7); // { 1, 2, 3, 4, 5, 6, 7, 9 } | temp = 8\n            \n            // halve the array size \n            int size = ds_array_size(array);\n            ds_array_resize(array, size / 2); // { 1, 2, 3, 4 }\n\n            // insert the removed element between the 1st and 2nd elements\n            ds_array_insert(array, 1, temp); // { 1, 8, 2, 3, 4 }\n\n            // read 3rd element\n            temp = ds_array_get(array, 2); // { 1, 8, 2, 3, 4 } | temp = 2\n            \n            // multiply 3rd element by 3\n            ds_array_set(array, 2, temp * 3u); // { 1, 8, 6, 3, 4 }\n\n        } break;\n        \n        case TEST_CASE_SORTING:\n        { \n            // make a dynamic array from a static array\n            array = ds_array_make(uint[](345u, 0u, 3u, 9u, 1234u, 9876u, 1u, 10u, 9876u));\n            \n            // sort the array in ascending order\n            ds_array_sort(array); // { 0, 1, 3, 9, 10, 345, 1234, 9876, 9876 }\n            \n        } break;\n        \n        case TEST_CASE_LOAD_REVERSE:\n        { \n            // fetch TEST_CASE_SORTING's array\n            vec4 test_case_sorting_frag_color = texelFetch(iChannel0, ivec2(TEST_CASE_SORTING, 0), 0);\n            array = ds_array_load(test_case_sorting_frag_color); // { 0, 1, 3, 9, 10, 345, 1234, 9876, 9876 }\n            \n            // reverse the elements on the array\n            ds_array_reverse(array); // { 9876, 9876, 1234, 345, 10, 9, 3, 1, 0 }\n            \n        } break;\n        \n        case TEST_CASE_RUNTIME_QUEUE:\n        { \n            // fetch last state\n            array = ds_array_load(texelFetch(iChannel0, ivec2(TEST_CASE_RUNTIME_QUEUE, 0), 0));\n            \n            // the queue max length\n            const int queue_max_size = 8;\n            const uint queue_regrow_period = 16u; // regrow the queue every 16 insertions\n            \n            // value to insert in the queue\n            uint frameID = (uint(iFrame) / 20u) % 9999u; // make sure we don't go over 9998u (ds_array limit)\n            \n            // regrow queue every n insertions\n            if(frameID % queue_regrow_period == 0u) ds_array_clear(array);\n            \n            // check if new value is different form the queue's head (prevents spamming the same value every frame)\n            if(ds_array_empty(array) || ds_array_front(array) != frameID)\n            {\n                // if the value is new, push it to the front and grab the new queue size\n                int size = ds_array_unshift(array, frameID);\n                 \n                // if size exceeded the queue's limit, remove last element (first-in first-out)\n                if(size > queue_max_size) ds_array_pop(array);\n            }\n\n        } break;\n    }\n    \n    fragColor = ds_array_store(array); // store the whole array on this pixel\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ********************************************************************************** //\n//                      Reads Tests-Cases Outputs & Validate                          //\n// ********************************************************************************** //\n\n// This pass reads the generated test cases arrays, and compares them against expected results.\n// \n// This shader can be quite slow to compile due to the amazing procedural text, so I'd recommend printing\n// only a few test-cases at once, but feel free to uncomment them all if you're brave ;)\n \n// #define TEST_CASE_CONSTRUCTOR_FILL  0 // tests dynamic array constructor and filling\n// #define TEST_CASE_CONSTRUCTOR_IMPL  1 // tests dynamic array implicit constructor\n// #define TEST_CASE_DYNAMIC_SIZE      2 // tests dynamic array insertions / resizing\n// #define TEST_CASE_SORTING           3 // tests dynamic array elements sorting (bubble-sort)\n #define TEST_CASE_LOAD_REVERSE      4 // tests dynamic array elements reversing\n #define TEST_CASE_RUNTIME_QUEUE     5 // test dynamic arrays insertions / resizing at runtime\n \n #define TEST_CASES 6\n\n// -------------------------------------------------------------------------------------- //\n//              SDF Font Printing - https://www.shadertoy.com/view/ldfcDr#                //\n//                      Creative Commons CC0 1.0 Universal (CC-0)                         //\n// -------------------------------------------------------------------------------------- //\n\n#define AUTO_FONT_SPACING\n#define FONT_SAMPLER iChannel1\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au,\n\n\t_LCUB = 0x7Bu,\t\t// '{'\n    _VERBAR = 0x7Cu,\t// '|'\n    _RCUB = 0x7Du,\t\t// '}'\n    _TILDE = 0x7Eu,\t\t// '~'\n    \n        \n    _EOL = 0x1000u, \t// End of Line - Carriage Return & Line Feed    \n    _BOLDON = 0x1001u,\t// Special\n    _BOLDOFF = 0x1002u,\t// Special\n    _ITALON = 0x1003u,\t// Special\n    _ITALOFF = 0x1004u\t// Special\n;\n\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( FONT_SAMPLER, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n#if 0\n    // Simple but not efficient - samples texture for each character\n    // Extends distance field beyond character boundary\n    vSample = textureLod( FONT_SAMPLER, vUV, 0.0 );\n    vSample.gb = vSample.gb * 2.0f - 1.0f;\n    vSample.a -= 0.5f+1.0/256.0;    \n    vSample.w += l * 0.75;\n#else    \n    // Skip texture sample when not in character boundary\n    // Ok unless we have big shadows / outline / font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( FONT_SAMPLER, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n#endif    \n        \n    return vSample;\n}\n\n#ifndef AUTO_FONT_SPACING\nfloat CharExtentsLeft( uint iChar )\n{\n    if ( iChar < 32u )\n    {\n        return 0.1f;\n    }\n    \n    switch( iChar )\n    {\n        case _EXCL:  case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.4f;\n        case _l: return 0.325f;        \n        case _A: case _Y: case _Q: case _w:case _W: case _m: case _M: return 0.25f;\n    }\n\treturn 0.3f;\n}\n\nfloat CharWidth( uint iChar )\n{\n    if ( iChar < 32u )\n    {     \n        return 0.8f;\n    }\n   \n    switch( iChar )\n    {\n        case _EXCL: case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.2f;       \n        case _1: case _j: return 0.3f;        \n        case _l: return 0.35f;\n        case _A: case _Y: case _Q: case _w: case _W: case _m: case _M: return 0.5f;\n    }\n\n    return 0.4f;\n}\n#endif \n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n#ifdef AUTO_FONT_SPACING\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n#else\n    result.left = CharExtentsLeft( iChar );\n    result.width = CharWidth( iChar );\n#endif\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vCanvasOrigin;\n    \n    // print position\n    vec2 vStart;\n    vec2 vPos;\n    vec2 vPixelSize;\n    bool EOL;\n\n    // result\n    float fDistance;\n#ifdef FONT_EFFECTS    \n    float fShadowDistance;\n    vec2 vNormal;    \n#endif\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vStart = state.vCanvasOrigin - vPos;\n    state.vPos = state.vStart;    \n    state.EOL = false;\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;\n#ifdef FONT_EFFECTS        \n    state.fShadowDistance = 1000000.0;\n    state.vNormal = vec2(0.0);    \n#endif    \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vCanvasOrigin = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n    bool bItalic;\n    bool bBold;\n#ifdef FONT_EFFECTS        \n    bool bShadow;\n    vec2 vShadowOffset;\n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(16.0f, 16.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n    style.bItalic = false;\n    style.bBold = false;    \n#ifdef FONT_EFFECTS        \n    style.vShadowOffset = vec2(0);\n    style.bShadow = false;\n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;\n#ifdef FONT_EFFECTS            \n    vec3 vOutlineColor;\n    vec3 vHighlightColor;\n    float fOutlineWeight;\n    float fBevelWeight;\n    float fShadowSpread;\n    float fShadowStrength;\n    vec2 vLightDir;\n#endif    \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;\n#ifdef FONT_EFFECTS            \n    style.vOutlineColor = vec3(1);\n    style.vHighlightColor = vec3(0);\n    style.fOutlineWeight = 0.0f;\n    style.fBevelWeight = 0.0f;\n    style.fShadowSpread = 0.0f;\n    style.fShadowStrength = 0.0f;\n    style.vLightDir = vec2(-1.0f, -0.5f );\n#endif    \n    return style;\n}\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vPos.x = state.vStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n    float fFontDescent = 0.15f;\n\tstate.vPos.y -= style.vSize.y * fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n    float fFontAscent = 0.65f;\n\tstate.vPos.y -= style.vSize.y * (fFontAscent + style.fLineGap);\n}\n\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n    \n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n    \n    vec2 vUV = (state.vPos / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;\n#ifdef FONT_EFFECTS            \n        state.vNormal = v.yz;\n#endif        \n    }\n\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fShadowDistance = SampleCharacter( iChar, vUV - style.vShadowOffset ).a;\n        if ( style.bBold )\n        {\n            fShadowDistance -= 0.025f;\n        }\n        \n        if ( fShadowDistance < state.fShadowDistance )\n        {\n            state.fShadowDistance = fShadowDistance;\n        }        \n    }\n#endif\n    \n    state.vPos.x -= style.vSize.x * (extents.width + style.fAdvancement);\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( in PrintState state, in LayoutStyle style, in RenderStyle renderStyle, inout vec3 color )\n{\n#ifdef FONT_EFFECTS            \n    if ( style.bShadow )\n    {\n        float fSize = renderStyle.fFontWeight + renderStyle.fOutlineWeight;\n        float fBlendShadow = clamp( (state.fShadowDistance - fSize - renderStyle.fShadowSpread * 0.5) / -renderStyle.fShadowSpread, 0.0, 1.0);\n        color.rgb = mix( color.rgb, vec3(0.0), fBlendShadow * renderStyle.fShadowStrength);    \n    }\n\n    if ( renderStyle.fOutlineWeight > 0.0f )\n    {        \n        float fBlendOutline = GetFontBlend( state, style, renderStyle.fFontWeight + renderStyle.fOutlineWeight );\n        color.rgb = mix( color.rgb, renderStyle.vOutlineColor, fBlendOutline);\n    }\n#endif\n    \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n\t\n#ifdef FONT_EFFECTS            \n    if ( renderStyle.fBevelWeight > 0.0f )\n    {    \n        float fBlendBevel = GetFontBlend( state, style, renderStyle.fFontWeight - renderStyle.fBevelWeight );    \n        float NdotL = dot( state.vNormal, normalize(renderStyle.vLightDir ) );\n        float shadow = 1.0 - clamp(-NdotL, 0.0, 1.0f);\n        float highlight = clamp(NdotL, 0.0, 1.0f);\n        highlight = pow( highlight, 10.0f);\n        vCol = mix( vCol, vCol * shadow + renderStyle.vHighlightColor * highlight, 1.0 - fBlendBevel);\n    }\n#endif\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n#define ARRAY_PRINT(STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i< CHAR_ARRAY.length(); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > 0u )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= -decimalPlaces )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\nvoid PrintMessage( inout PrintState state, LayoutStyle style )\n{\n    uint strA[] = uint[] ( _H, _e, _l, _l, _o, _COMMA, _SP, _w, _o, _r, _l, _d, _PERIOD, _EOL );\n    ARRAY_PRINT( state, style, strA );\n\n    uint strB[] = uint[] ( _ITALON, _A, _B, _C, _1, _2, _3, _ITALOFF, _EOL );\n    ARRAY_PRINT( state, style, strB );\n    \n    uint strC[] = uint[] ( _BOLDON, _A, _B, _C, _1, _2, _3, _BOLDOFF, _SP );\n    ARRAY_PRINT( state, style, strC );\n}\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n\n#define PRINT_TEST_CASE(state, style, title, array, compare, size) { ARRAY_PRINT(state, style, title); bool passed = true; int l = ds_array_size(array); if(l != size) passed = false; PrintCh(state, style, _COLON); PrintEOL(state, style); PrintCh(state, style, _LSQB); Print(state, style, l); PrintCh(state, style, _RSQB); PrintCh(state, style, _LCUB); for(int i = 0; i < l; ++i){ uint val = ds_array_get(array, i); if(passed && val != compare[i]) passed = false; Print(state, style, int(val)); if(i < l - 1){ PrintCh(state, style, _COMMA); PrintCh(state, style, _SP); }} PrintCh(state, style, _RCUB); PrintCh(state, style, _SP); RenderFont(state, style, RenderStyle_Default(vec3(0.2)), fragColor.rgb); ClearPrintResult(state); if(passed){ ARRAY_PRINT(state, style, uint[](_BOLDON, _ITALON, _P, _a, _s, _s, _ITALOFF, _BOLDOFF)); } else { ARRAY_PRINT(state, style, uint[](_BOLDON, _ITALON, _F, _a, _i, _l, _ITALOFF, _BOLDOFF)); } PrintEOL(state, style); PrintEOL(state, style); RenderFont(state, style, RenderStyle_Default(vec3(0.2 + 0.55 * float(!passed), 0.2 + 0.45 * float(passed), 0.2)), fragColor.rgb); ClearPrintResult(state); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // load generated test cases (1 array per pixel)\n    ds_array array_tests[TEST_CASES];\n    for(int i = 0; i < TEST_CASES; ++i) array_tests[i] = ds_array_load(texelFetch(iChannel0, ivec2(i, 0), 0)); \n    \n    // expected results (to compare against)\n    uint TEST_CASE_CONSTRUCTOR_FILL_title[] = uint[](_C, _o, _n, _s, _t, _r, _u, _c, _t, _o, _r, _SP, _F, _i, _l, _l);\n    uint TEST_CASE_CONSTRUCTOR_FILL_expected[] = uint[](123u, 123u, 123u, 123u);\n    \n    uint TEST_CASE_CONSTRUCTOR_LAMBDA_title[] = uint[](_C, _o, _n, _s, _t, _r, _u, _c, _t, _o, _r, _SP, _L, _a, _m, _b, _d, _a);\n    uint TEST_CASE_CONSTRUCTOR_LAMBDA_expected[] = uint[](0u, 123u, 456u, 789u, 1011u, 1213u, 1415u, 1617u, 9998u);\n    \n    uint TEST_CASE_DYNAMIC_SIZE_title[] = uint[](_D, _y, _n, _a, _m, _i, _c, _SP, _S, _i, _z, _e);\n    uint TEST_CASE_DYNAMIC_SIZE_expected[] = uint[](1u, 8u, 6u, 3u, 4u);\n    \n    uint TEST_CASE_SORTING_title[] = uint[](_A, _s, _c, _e, _n, _d, _i, _n, _g, _SP, _S, _o, _r, _t);\n    uint TEST_CASE_SORTING_expected[] = uint[](0u, 1u, 3u, 9u, 10u, 345u, 1234u, 9876u, 9876u);\n    \n    uint TEST_CASE_LOAD_REVERSE_title[] = uint[](_L, _o, _a, _d, _SP, _AMP, _SP, _R, _e, _v, _e, _r, _s, _e);\n    uint TEST_CASE_LOAD_REVERSE_expected[] = uint[](9876u, 9876u, 1234u, 345u, 10u, 9u, 3u, 1u, 0u);\n    \n    const int queue_max_size = 8;\n    const uint queue_regrow_period = 16u;\n    uint frameID = (uint(iFrame) / 20u) % 9998u;\n    uint TEST_CASE_RUNTIME_QUEUE_title[] = uint[](_R, _u, _n, _t, _i, _m, _e, _SP, _Q, _u, _e, _u, _e);\n    uint TEST_CASE_RUNTIME_QUEUE_expected[queue_max_size];\n    for(int i = 0; i < queue_max_size; ++i) TEST_CASE_RUNTIME_QUEUE_expected[i] = frameID - uint(i);\n    int TEST_CASE_RUNTIME_QUEUE_expected_length = min(int(frameID % queue_regrow_period) + 1, queue_max_size);\n    \n    // print results\n    fragColor = vec4(0.9);\n   \n    vec2 vCanvasCoord = vec2( fragCoord.x - 8.0, iResolution.y - 9.0f - fragCoord.y ) * vec2(640.0, 360) * 1.35 / iResolution.xy;\n    vec2 vCanvasPixelSize = vec2(640.0, 360) / iResolution.xy;\n\n    PrintState state = PrintState_InitCanvas( vCanvasCoord, vCanvasPixelSize );\n\n    LayoutStyle style = LayoutStyle_Default();\n    PrintBeginNextLine(state, style);\n    \n    ARRAY_PRINT(state, style, uint[](_ITALON, _P, _e, _r, _MINUS, _P, _i, _x, _e, _l, _SP, _D, _y, _n, _a, _m, _i, _c, _SP, _A, _r, _r, _a, _y, _s, _ITALOFF, _EOL, _EOL));\n    ARRAY_PRINT(state, style, uint[](_BOLDON, _T, _e, _s, _t, _SP, _C, _a, _s, _e, _s, _COLON, _BOLDOFF, _EOL, _EOL));\n    RenderFont(state, style, RenderStyle_Default(vec3(0.2)), fragColor.rgb); \n    ClearPrintResult(state);\n    \n#ifdef TEST_CASE_CONSTRUCTOR_FILL\n    PRINT_TEST_CASE(state, style, TEST_CASE_CONSTRUCTOR_FILL_title, array_tests[TEST_CASE_CONSTRUCTOR_FILL], TEST_CASE_CONSTRUCTOR_FILL_expected, TEST_CASE_CONSTRUCTOR_FILL_expected.length());\n#endif\n\n#ifdef TEST_CASE_CONSTRUCTOR_LAMBDA\n    PRINT_TEST_CASE(state, style, TEST_CASE_CONSTRUCTOR_LAMBDA_title, array_tests[TEST_CASE_CONSTRUCTOR_LAMBDA], TEST_CASE_CONSTRUCTOR_LAMBDA_expected, TEST_CASE_CONSTRUCTOR_LAMBDA_expected.length()); \n#endif\n\n#ifdef TEST_CASE_DYNAMIC_SIZE\n    PRINT_TEST_CASE(state, style, TEST_CASE_DYNAMIC_SIZE_title, array_tests[TEST_CASE_DYNAMIC_SIZE], TEST_CASE_DYNAMIC_SIZE_expected, TEST_CASE_DYNAMIC_SIZE_expected.length()); \n#endif\n\n#ifdef TEST_CASE_SORTING\n    PRINT_TEST_CASE(state, style, TEST_CASE_SORTING_title, array_tests[TEST_CASE_SORTING], TEST_CASE_SORTING_expected, TEST_CASE_SORTING_expected.length()); \n#endif\n\n#ifdef TEST_CASE_LOAD_REVERSE\n    PRINT_TEST_CASE(state, style, TEST_CASE_LOAD_REVERSE_title, array_tests[TEST_CASE_LOAD_REVERSE], TEST_CASE_LOAD_REVERSE_expected, TEST_CASE_LOAD_REVERSE_expected.length()); \n#endif\n\n#ifdef TEST_CASE_RUNTIME_QUEUE\n    PRINT_TEST_CASE(state, style, TEST_CASE_RUNTIME_QUEUE_title, array_tests[TEST_CASE_RUNTIME_QUEUE], TEST_CASE_RUNTIME_QUEUE_expected, TEST_CASE_RUNTIME_QUEUE_expected_length); \n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}