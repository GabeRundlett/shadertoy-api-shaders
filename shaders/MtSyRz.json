{
    "Shader": {
        "info": {
            "date": "1507155885",
            "description": "Keys/mouse do things -- see comments above code.",
            "flags": 16,
            "hasliked": 0,
            "id": "MtSyRz",
            "likes": 31,
            "name": "random cubic Truchet flow",
            "published": 3,
            "tags": [
                "random",
                "truchet",
                "flow",
                "cubic"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 1129
        },
        "renderpass": [
            {
                "code": "/* \n    random cubic Truchet flow, by mattz\n    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tInspired by:\n\n      Truchet Marbles (Simple) by shau - https://www.shadertoy.com/view/MtlcDs\n      Square Truchet Flow by Shane - https://www.shadertoy.com/view/XtfyDX\n\n\n    Keys:\n\n      D - toggle direction arrows (rotations/reflections of canonical cell)\n      M - toggle camera motion\n      S - toggle spheres\n      T - toggle Truchet torii\n      X - toggle X-axis alternation\n\n\n    Mouse to bottom-left to get default viewing angle.\n\n\n    Analogous to Shane's 2D shader, this fixes the flow directions along cube faces\n    in a repeating fashion. I randomize the torus orientations while confirming to the\n    predetermined flow directions.\n\n    See the documentation of the truchet function below for the meat.\n\n    This calls atan to do the shading along each torus segment, but I make sure\n    to only call it once per pixel when actually shading. \n\n*/\n\n// Bunch of globals/constants:\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\nfloat move_camera = 1.0;\nfloat show_spheres = 1.0;\nfloat show_directions = 0.0;\nfloat show_truchet = 1.0;\nfloat alternate_x = 1.0;\n\nconst float HALFPI = 1.5707963267948966;\nconst float TUBE_SIZE = 0.015;\nconst float SPHERE_SIZE = 0.06;\n\nconst float ARROW_RAD = 0.025;\nvec2 ARROW_HEAD_SLOPE = normalize(vec2(1, 2));\n    \nconst float ARROW_BODY_LENGTH = 0.3;\nconst float ARROW_HEAD_LENGTH = 0.1;\n\n/* RGB from hue. */\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n/* From https://www.shadertoy.com/view/4djSRW */\n#define HASHSCALE1 .1031\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/* Distance to 3D arrow - steal this if you like! */\nfloat sdArrow(vec3 p, vec3 d) {\n    \n    // component along\n    float t = dot(p, d);\n    \n    // component perp\n    float n = length(p - t*d);\n    \n\t// distance to cylinder body\n    float dist = n - ARROW_RAD;\n    \n    // account for arrowhead size\n    t += 0.5*ARROW_HEAD_LENGTH;\n    \n    // body caps\n    dist = max(dist, abs(t)-0.5*ARROW_BODY_LENGTH);\n    \n    // move to end of arrow\n    t -= 0.5*ARROW_BODY_LENGTH;\n    \n    // cone head\n    dist = min(dist, max(-t, dot(ARROW_HEAD_SLOPE, vec2(t-ARROW_HEAD_LENGTH, n))));\n    \n    return dist;\n    \n}\n\n\n/* Check distance to torus at origin, perpendicular to z axis. */\nfloat sdTorus(vec3 u) {\n    \n    vec2 q = vec2(length(u.xy)-0.5,u.z);\n    float d = length(q) - TUBE_SIZE;\n    d = max(d, max(u.x, u.y));\n\n    return d;\n    \n}\n\n/* Distance to ball along torus segment orbiting origin (same frame as sdTorus). */\nfloat sdBall(vec3 u) {\n    \n    float theta = HALFPI * fract(0.2*iTime);\n\n\t// Is this cheaper than separate sin & cos? I dunno.    \n    vec2 sc = 0.5*sin(vec2(theta, theta+HALFPI));\n    \n    // Need multiple checks to handle ball crossing cube face boundaries!\n    float d = length(u + vec3(sc.x, sc.y, 0));\n    d = min(d, length(u + vec3(sc.y, -sc.x, 0)));\n    d = min(d, length(u + vec3(-sc.y, sc.x, 0)));\n    \n    return d - SPHERE_SIZE;\n\n}\n\n/* Compute edge-relative coords and torus distance given:\n\n    - p is point in cube with vertices at +/- 0.5:\n    - src is outward facing normal of flow source face \n    - dst is outward facing normal of flow sink face\n\n   Returns a vec4 (ux uy uz d) where:\n\n     - ux is distance from src face (negative inside cube)\n     - uy is distance from dst face (also negative inside cube)\n     - uz is projected distance along edge from center (positive or negative)\n     - d is distance to torus.\n\n*/\nvec4 checkTorus(vec3 p, vec3 src, vec3 dst) {\n    \n    vec3 n = cross(dst, src);\n    vec3 ctr = 0.5*(src+dst);\n    \n    p -= ctr;\n    \n    vec3 u = p * mat3(src, dst, n);\n    \n    return vec4(u, sdTorus(u));\n    \n}\n\n/* Chooses vec4 with least last element (useful for comparing checkTorus output) */\nvec4 tmin(vec4 a, vec4 b) {\n    \n    return a.w < b.w ? a : b;\n    \n}\n\n\n/* This is the workhorse of the Truchet arrangement. Input argument is\n   an arbitrary 3D point, which is modified to become relative to cell\n   center and orientation upon output. Also outputs a mat3 of the format\n   output by sdTorus above. \n\n   As you can see by enabling cell directions, every cubic cell in the\n   Truchet tiling has three flow inputs and three outputs. The \"canonical \n   cell\" has flow inputs on the +X, -Y, and +Y faces (and flow outputs on\n   the -X, -Z, +Z) faces.\n\n   In order to get these to tile space, we need to swap Y with Z in a\n   checkerboard pattern along the YZ plane.\n\n   Also, it looks obviously \"fake\" (in my opinion, at least) to have all \n   of the flow from +X to -X, so I also alternate the X direction on\n   successive Y levels. \n\n   So, we now have the \"canonical cell\" potentially with Y/Z swapped, and/or\n   X negated. There are four possible torus segment arrangements within \n   the canonical cell. The table below shows for each input face (+X, -Y, +Y),\n   what output face it connects to:\n\n     case | +X -Y +Y\n     -----+----------\n        0 | -Z -X +Z\n        1 | -Z +Z -X\n        2 | +Z -X -Z\n        3 | +Z -Z -X\n       \n   We choose one of these cases at random for each cell, and get the torus \n   distance for the given point.\n\n*/\nvec4 truchet(inout vec3 pos) {\n\n    // Shift by 0.5 to place world origin at vertex, not cell center\n    pos -= 0.5;\n    \n    // Find center of nearest cell\n    vec3 ctr = floor(pos+0.5);\n    \n    // Subtract off difference\n    pos -= ctr;\n    \n    // Alternating sign on each axis\n    vec3 s = sign(mod(ctr, 2.0) - 0.5);\n    \n    // Swap Y and Z in checkerboard pattern.\n    if (s.y * s.z > 0.0) { pos.yz = pos.zy; }\n\n    // Alternate sign on X within cell if desired\n    if (alternate_x > 0.0) { pos.x *= -s.y; }\n\n    // Get case and set up destination axes\n    float k = hash13(ctr) * 4.0;\n    \n    mat3 dst = mat3(0, 0, -1, \n                    -1, 0, 0, \n                    0, 0, 1);                \n    \n    if (k < 2.0) {\n        if (k < 1.0) {\n            // NOP - just use setup above\n            // dst = dst\n        } else {\n            dst = mat3(dst[0], dst[2], dst[1]); \n        }\n    } else {\n        if (k < 3.0) {\n            dst = mat3(dst[2], dst[0], dst[1]); \n        } else {\n            dst = mat3(dst[2], dst[1], dst[0]); \n        }\n    }\n    \n    // Handle +X face\n    vec4 t = checkTorus(pos, vec3(1, 0, 0), dst[0]);\n    \n    // Handle +Y face\n    t = tmin(t, checkTorus(pos, vec3(0, 1, 0), dst[1]));\n    \n    // Handle -Y face\n    t = tmin(t, checkTorus(pos, vec3(0, -1, 0), dst[2]));\n    \n    return t;\n\n    \n}\n\n/* Boolean union of solids for map function below */\nvec2 dmin(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n/* Distance function to scene */\nvec2 map(in vec3 pos) {\t\n    \n    vec4 t = truchet(pos);\n    \n    vec2 dm = vec2(1e5, -1);\n    \n    if (show_truchet != 0.0) {\n        dm = dmin(dm, vec2(t.w, 2.0));\n    }\n    \n    if (show_spheres != 0.0) {\n        dm = dmin(dm, vec2(sdBall(t.xyz), 1.1));\n    }\n\n    if (show_directions != 0.0) {\n        dm = dmin(dm, vec2(sdArrow(pos - vec3(0.5, 0, 0), vec3(-1, 0, 0)), 0));\n        dm = dmin(dm, vec2(sdArrow(pos + vec3(0.5, 0, 0), vec3(-1, 0, 0)), 0));\n        dm = dmin(dm, vec2(sdArrow(pos - vec3(0, 0.5, 0), vec3(0, -1, 0)), 0.3333));\n        dm = dmin(dm, vec2(sdArrow(pos + vec3(0, 0.5, 0), vec3(0, 1, 0)), 0.3333));\n        dm = dmin(dm, vec2(sdArrow(pos - vec3(0, 0, 0.5), vec3(0, 0, 1)), 0.6666));\n        dm = dmin(dm, vec2(sdArrow(pos + vec3(0, 0, 0.5), vec3(0, 0, -1)), 0.6666));\n    }\n\n    return dm;\n\n}\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n/* IQ's distance marcher. */\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\n    const float precis = 0.002;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n    }    \n\n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n/* Only clever thing about the shading is to postpone the expensive atan call\n   until the last possible second. It should buy us a bit of framerate on \n   slower cards, but I was getting 60FPS before I decided to do this. Meh.\n */\nvec3 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd, dmax);        \n\n    vec3 c;\n\n    if (tm.y < 0.0) { \n\n        // miss\n        return vec3(1.0);\n\n    } else {        \n\n        // hit\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n\n        \n        if (tm.y >= 2.0) { \n            \n            // material 2 means we hit a torus, so use atan-based rainbow map\n            vec4 t = truchet(pos);\n            tm.y = fract( atan(t.y, t.x)/HALFPI - 0.25*iTime );\n            \n        }\n\n        vec3 color = hue(tm.y);\n\n        vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        vec3 c = diffamb + spec;\n        \n        return mix(c, vec3(1), 1.0-exp(-0.25*tm.x));\n\n    }\n\n\n}\n\n/* Compare key state to default state. */\nfloat keyState(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\nconst float KEY_D = 68.5/256.0;\nconst float KEY_M = 77.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_T = 84.5/256.0;\nconst float KEY_X = 88.5/256.0;\n\n/* Finally, our main function: */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    show_directions = keyState(KEY_D, show_directions);\n    move_camera = keyState(KEY_M, move_camera);\n    show_truchet = keyState(KEY_T, show_truchet);\n    show_spheres = keyState(KEY_S, show_spheres);\n    alternate_x = keyState(KEY_X, alternate_x);\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n    \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    const vec3 cpos = vec3(0, 0, 5);\n    const vec3 up = vec3(0, 1, 0);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n\n    vec2 mpos;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        mpos.xy = iMouse.xy;\n    } else {\n        mpos = iResolution.xy * vec2(0.432, 0.415);\n    }\n    \n    float thetax = (mpos.y - .5*iResolution.y) * -4.0*HALFPI/iResolution.y; \n    float thetay = (mpos.x - .5*iResolution.x) * 8.0*HALFPI/iResolution.x; \n\n\n    Rview = mat3(rx,ry,rz)*rotY(thetay)*rotX(thetax); \n    L = Rview*L;\n\n   \t/* Render. */\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n    \n    if (move_camera != 0.0) {\n        ro -= 0.15*iTime;\n    }\n\n    fragColor.xyz = shade(ro, rd);\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}