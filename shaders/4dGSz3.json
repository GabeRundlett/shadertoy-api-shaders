{
    "Shader": {
        "info": {
            "date": "1465549573",
            "description": "This is a basic raytracers that probably nears shadertoys limits (atleast with this code), I'm unable to enable the multisample define as it crashes when you do (it works when disabling reflections)",
            "flags": 0,
            "hasliked": 0,
            "id": "4dGSz3",
            "likes": 1,
            "name": "Ray Tracer (Reflection + Shadow)",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "shadow",
                "sphere",
                "plane",
                "hard"
            ],
            "usePreview": 1,
            "username": "Themperror",
            "viewed": 866
        },
        "renderpass": [
            {
                "code": "\n//This demonstrates multisampling by casting 4 rays per pixel, thus softening up edges (results are like anti-aliasing)\n//This option only allows shadowing and second light\n//#define MULTISAMPLE\n\n//This option automatically disables shadowing when used without multisampling\n//#define ENABLE_SECOND_LIGHT\n\n//Reflections are only enabled without multisampling, It disables shadowing when ENABLE_SECOND_LIGHT is set\n#define ALLOW_REFLECTIONS \n\n//This will get disabled depending on settings, feel free to disable manually\n#define ALLOW_SHADOW\n\n//do not change anything here, it's to prevent crashes with certain settings, the code is too big for shadertoy to handle otherwise\n#ifndef MULTISAMPLE \n\t#ifdef ENABLE_SECOND_LIGHT\n\t\t#ifdef ALLOW_REFLECTIONS\n\t\t\t#undef ALLOW_SHADOW\n\t\t#endif\n\t#endif\n#else\n\t#undef ALLOW_REFLECTIONS\n#endif\n////end\n\n\n\n#define EPSILON   0.001\n#define PI 3.14159265359\n#define MAX_DEPTH 4\n#define MAX_DEPTH_F 4.0\n#define NUM_LIGHTS_F 2.0\n#define NUM_LIGHTS_I 2\n\n#define LIGHT_START_FALL_OFF_RANGE 0.0\n#define LIGHT_END_FALL_OFF_RANGE 70.0\n#define FARPLANE 1000.0\n#define NEARPLANE 1.0\n#define AMBIENT vec3(0.05,0.05,0.05)\nstruct ViewPlane\n{\n\tvec3 pos;\n    vec2 size;\n};\nstruct Sphere\n{\n    vec3 p;\n    float r;\n\tvec4 c;\n};\nstruct Plane\n{\n\tvec3 p;\n    vec3 n;\n    vec4 c;\n};\nstruct Light\n{\n\tvec3 p;\n    vec4 c;\n};\nstruct Scene\n{\n\tSphere s[3];\n\tPlane p[6];\n};\nstruct Ray\n{\n\tvec3 p,d;\n};\nstruct HitInfo\n{\n\tbool hit;\n    float dist;\n    vec3 pos;\n    vec3 normal;\n    vec4 objColor; //only used in reflection code\n};\n\nScene scene;\nViewPlane vPlane;\nLight light;\nLight light2;\nSphere lightSphere;\nSphere lightSphere2;\n\n//project function should I need it, in-efficient though\nvec3 project(vec3 a, vec3 b)\n{\n    float wL = length(a);\n    float vL = length(b);\n    vec3 wN = normalize(a);\n    vec3 vN = normalize(b);\n    float d = dot(wN,vN);\n    return wL*d*vN;\n}\n\n\n//Can't remember where I found this, I converted it from some mathlab-ish code, This piece was the most efficient that I found across 3 versions\nHitInfo RaySphere(Ray ray, Sphere s)\n{\n    HitInfo info;\n    info.hit = false;\n\n    vec3 m = ray.p - s.p; \n    float b = dot(m, ray.d); \n    float c = dot(m, m) - s.r * s.r; \n\n    // Exit if râ€™s origin outside s (c > 0) and r pointing away from s (b > 0) \n    if (c > 0.0 && b > 0.0) return info; \n    float discr = b*b - c; \n\n    // A negative discriminant corresponds to ray missing sphere \n    if (discr < 0.0) return info; \n\n    // Ray now found to intersect sphere, compute smallest t value of intersection\n    float t = -b - sqrt(discr); \n\n    // If t is negative, ray started inside sphere so clamp t to zero \n    t = clamp(t,0.0,t); \n    vec3 q = ray.p + t * ray.d; \n\n    info.hit = true;\n    info.pos = q;\n    info.dist = t;\n    info.normal = -normalize(s.p-q);\n    return info;\n}\n\n//converted code from: http://geomalgorithms.com/a05-_intersect-1.html    :  intersect3D_SegmentPlane()\nHitInfo RayPlane(Ray ray, Plane p)\n{\n\tHitInfo info;\n    info.hit = false;\n    \n    vec3    u = (ray.p+ray.d*FARPLANE) - ray.p;\n    vec3    w = ray.p - p.p;\n\n    float     D = dot(p.n, u);\n    float     N = -dot(p.n, w);\n\n    if (abs(D) < EPSILON) //either they're parallel or never intersecting, in both cases return hit = false;\n    {          \n\t\treturn info;\n    }\n    \n    // they are not parallel\n    // compute intersect param\n    float sI = N / D;\n    if (sI < 0.0 || sI > 1.0)\n        return info;                        // no intersection\n\n    info.hit = true;\n    info.pos = ray.p + sI * u;                  // compute ray intersection point\n    info.dist = distance(ray.p,info.pos);\n    info.normal = -p.n;\n    return info;\n}\n\n//get spherical UV coordinates based on given normal, adjusted from source: https://www.cse.msu.edu/~cse872/tutorial4.html\nvec2 SphereUV(vec3 n)\n{\n    return vec2(atan(n.x, n.z) / (2.0 * PI) + 0.5,asin(n.y) / PI + 0.5);\n}\n\n//This function clamps a value between 0 and 1 based on the min and max value given\nfloat OneZeroClamp(float val, float minv, float maxv)\n{\n    val = clamp(val,minv,maxv);\n\tval -= minv;\n    float maxV = maxv - minv;\n    return (val/maxV);\n}\n//vec3 version\nvec3 OneZeroVClamp(vec3 val, vec3 minv, vec3 maxv)\n{\n   return vec3(OneZeroClamp(val.x,minv.x,maxv.x),OneZeroClamp(val.y,minv.y,maxv.y),OneZeroClamp(val.z,minv.z,maxv.z));\n}\n//vec4 version, .w value set to 1.0\nvec4 OneZeroVClamp(vec4 val, vec4 minv, vec4 maxv)\n{\n   return vec4(OneZeroClamp(val.x,minv.x,maxv.x),OneZeroClamp(val.y,minv.y,maxv.y),OneZeroClamp(val.z,minv.z,maxv.z),1.0);\n}\n\n//Calculates lighting and color based on ray hit, object position, object normal and object color.\nvec3 DoLighting(HitInfo hit,vec3 pos, vec4 col)\n{\n    float distIntensity =0.0;\n    float lightIntensity = 0.0;\n    bool canSeeLight = true;\n    Ray nRay;\n    HitInfo nHit;\n    #ifdef ALLOW_SHADOW\n        nRay.d = -normalize(hit.pos-light.p);\n        nRay.p = hit.pos + nRay.d*EPSILON;\n        nHit = RaySphere(nRay,lightSphere);\n        float hitDist = nHit.dist;\n        for(int i =0; i < 3;i++)\n        {\n            nHit = RaySphere(nRay,scene.s[i]);\n            if(nHit.hit)\n            {\n                if(hitDist > nHit.dist)\n                {\n                    canSeeLight = false;\n                    break;\n                }\n            }\n        }\n    #endif\n    if(canSeeLight)\n    {\n\t\t//calculate the distance in a range between 0 to 1 relative to the maximum light range  and then inverse it (one minus)\n    \tdistIntensity += 1.0-OneZeroClamp(distance(hit.pos,light.p),LIGHT_START_FALL_OFF_RANGE,LIGHT_END_FALL_OFF_RANGE);\n    \t//calculate light intensity based on the surface normal, distance and light.w value\n\t\tlightIntensity += light.c.w* clamp(dot(normalize(light.p-hit.pos),hit.normal),0.0,1.0);\n    }\n    \n    #ifdef ENABLE_SECOND_LIGHT\n    \t#ifdef ALLOW_SHADOW\n            nRay.d = -normalize(hit.pos-light2.p);\n            nHit = RaySphere(nRay,lightSphere2);\n            hitDist = nHit.dist;\n            canSeeLight= true;\n            for(int i =0; i < 3;i++)\n            {\n                nHit = RaySphere(nRay,scene.s[i]);\n                if(nHit.hit)\n                {\n                    if(hitDist > nHit.dist)\n                    {\n                        canSeeLight = false;\n                        break;\n                    }\n                }\n            }\n   \t\t#endif\n        if(canSeeLight)\n        {\n            distIntensity += 1.0-OneZeroClamp(distance(hit.pos,light2.p),LIGHT_START_FALL_OFF_RANGE,LIGHT_END_FALL_OFF_RANGE);\n            lightIntensity += light2.c.w* clamp(dot(normalize(light2.p-hit.pos),hit.normal),0.0,1.0);\n        }\n    #endif\n    \n\tlightIntensity *= distIntensity;\n    //return the final color in a range between 0 and 1+(total lights) + ambient \n    #ifndef ENABLE_SECOND_LIGHT\n    return OneZeroVClamp((col.rgb *lightIntensity + (light.c.xyz*lightIntensity ) + AMBIENT),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0)*(1.0)+AMBIENT);       \n \t#else\n    //double light\n    return OneZeroVClamp((col.rgb *lightIntensity + (light.c.xyz+light2.c.xyz)/2.0*lightIntensity ) + AMBIENT,vec3(0.0,0.0,0.0),(vec3(1.0,1.0,1.0)*(2.0+1.0)+AMBIENT));       \n\t#endif\n}\n\n\nHitInfo TraceReflect(Ray ray)\n{\n    //if we don't hit anything in the end, we output black.\n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    HitInfo hit;\n    HitInfo outHit;\n    bool setOuthit = false;\n   \n    float minDist = FARPLANE;\n\n    //Cast rays against the 3 spheres\n    for(int i=0;i<3;i++)\n    {\n        hit = RaySphere(ray,scene.s[i]);\n        if(hit.hit && hit.dist < minDist)\n        {\n            minDist = hit.dist;\n            vec4 sphereColor = scene.s[i].c;\n            vec2 UV = SphereUV(hit.normal);\n            if(mod(floor(10.0*UV.x)+floor(10.0*UV.y), 2.0) == 0.0)\n            {\n                //set color to oneminus sphere color\n                sphereColor = vec4(1.0 - scene.s[i].c.xyz,scene.s[i].c.w);\n            }\n            color = vec4(DoLighting(hit,scene.s[i].p,sphereColor),scene.s[i].c.w);\n            outHit = hit;setOuthit=true;\n            //color = vec4(5,0,0,1);\n            outHit.objColor = color;\n        }\n    }\n    //Cast rays against the 6 planes\n    for(int i =0; i<6;i++)\n    {\n\n        hit = RayPlane(ray,scene.p[i]);\n        if(hit.hit && hit.dist < minDist)\n        {\n            minDist = hit.dist;\n            color = vec4(DoLighting(hit,scene.s[i].p,scene.p[i].c),scene.p[i].c.w);\n            outHit = hit;setOuthit=true;\n            //color = vec4(0,5,0,1);\n            outHit.objColor = color;\n        }\n    }\n\n    //Cast ray against the visualisation of the light\n    hit = RaySphere(ray,lightSphere);\n    if(hit.hit)\n    {\n\t\tif(hit.dist < minDist)\n        {\n            color = lightSphere.c;\n            //color = vec4(0,0,5,1);\n            outHit = hit;setOuthit=true;\n            outHit.objColor = color;\n        }\n    }\n    hit = RaySphere(ray,lightSphere2);\n    if(hit.hit)\n    {\n\t\tif(hit.dist < minDist)\n        {\n\t\t\tcolor = lightSphere2.c;\n            outHit = hit;setOuthit=true;\n            outHit.objColor = color;\n        }\n    }\n    if(setOuthit==false)\n    {\n        outHit.hit = false;\n        outHit.pos = vec3(0,0,0);\n        outHit.normal = vec3(0,0,0);\n        outHit.dist = 0.0;\n        outHit.objColor = vec4(5,0,5,0);\n    }\n\treturn outHit;\n}\n\n//Sends out a ray into the scene and retrieves object color if it hits, otherwise vec3(0.0,0.0,0.0)\nvec4 Trace(Ray ray)\n{\n    //if we don't hit anything in the end, we output black.\n    vec3 color = vec3(0.0,0.0,0.0);\n    HitInfo hit;\n    \n    //set minimum distance on FARPLANE, this allows us to draw nothing behind this point (even if we were to hit something)\n    float minDist = FARPLANE;\n    \n    //Cast rays against the 3 spheres\n    for(int i=0;i<3;i++)\n    {\n        hit = RaySphere(ray,scene.s[i]);\n        if(hit.hit && hit.dist < minDist)\n        {\n            minDist = hit.dist;\n            vec4 sphereColor = scene.s[i].c;\n            vec2 UV = SphereUV(hit.normal);\n            if(mod(floor(10.0*UV.x)+floor(10.0*UV.y), 2.0) == 0.0)\n            {\n                //set color to oneminus sphere color\n                sphereColor = vec4(1.0 - scene.s[i].c.xyz,sphereColor.w);\n            }\n            \n\t\t\t#ifdef ALLOW_REFLECTIONS \n      ////////////////// REFLECTION ON SPHERES////////////////////\n            vec3 reflectColor = vec3(0.0,0.0,0.0);\n            vec4 tempColor = vec4(0.0,0.0,0.0,0.0);\n            \n            if(scene.s[i].c.w > EPSILON)\n            {\n                \n                Ray nRay;\n                nRay.d = reflect(ray.d,hit.normal);\n                nRay.p = hit.pos + nRay.d*EPSILON;\n                float t =0.0;\n                for(float j = 0.0; j < MAX_DEPTH_F; j++)\n\t\t\t\t{\n                    t = j;\n                    HitInfo tempHit = TraceReflect(nRay);\n                    if(tempHit.hit)\n                    {\n                        tempColor = tempHit.objColor;\n                        nRay.d = reflect(nRay.d,tempHit.normal);\n                        nRay.p = tempHit.pos+nRay.d*EPSILON;\n                        reflectColor += tempColor.xyz *(1.0- tempColor.w);\n                        if(tempColor.w <= EPSILON)\n                        {\n\t\t\t\t\t\t\tbreak;\n                        }  \n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                \n           \t\tsphereColor = vec4(sphereColor.xyz*(1.0-clamp(sphereColor.w,0.0,1.0))+(reflectColor.xyz*(MAX_DEPTH_F-t)),1.0);\n          \t  \tcolor = DoLighting(hit,scene.s[i].p,sphereColor);\n            }\n      ////////////////// END REFLECTION ON SPHERES////////////////////\n            else\n            {\n                #endif\n            \tcolor = DoLighting(hit,scene.s[i].p,sphereColor);\n                \n            #ifdef ALLOW_REFLECTIONS \n            }\n            #endif\n        }\n    }\n    //Cast rays against the 6 planes\n    for(int i =0; i<6;i++)\n    {\n\n        hit = RayPlane(ray,scene.p[i]);\n        if(hit.hit && hit.dist < minDist)\n        {\n            minDist = hit.dist;\n            vec4 planeColor =scene.p[i].c;\n            #ifdef ALLOW_REFLECTIONS  \n    ////////////////// REFLECTION ON PLANES////////////////////\n            vec3 reflectColor = vec3(0.0,0.0,0.0);\n            vec4 tempColor = vec4(0.0,0.0,0.0,0.0);\n          \t\n            if(scene.p[i].c.w > EPSILON)\n            {\n                Ray nRay;\n                nRay.d = reflect(ray.d,hit.normal);\n                nRay.p = hit.pos + nRay.d*EPSILON;\n                float t = 0.0;\n                for(float j = 0.0; j < MAX_DEPTH_F; j++)\n                {\n                    t = j+1.0;\n                    HitInfo tempHit = TraceReflect(nRay);\n                    if(tempHit.hit)\n                    {\n                        tempColor = tempHit.objColor;\n                        nRay.d = reflect(nRay.d,tempHit.normal);\n                        nRay.p = tempHit.pos+nRay.d*EPSILON;\n                        reflectColor += tempColor.xyz*(1.0- tempColor.w);\n                        if(tempColor.w <= EPSILON)\n                        {\n                            break;\n                        }  \n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n\n                planeColor = vec4(planeColor.xyz*(1.0-clamp(planeColor.w,0.0,1.0))+(reflectColor.xyz*(MAX_DEPTH_F-t)),1.0);\n                color = DoLighting(hit,scene.s[i].p,planeColor);\n            }\n     ////////////////// END REFLECTION ON PLANES////////////////////\n            else\n            {\n            #endif\n                color = DoLighting(hit,scene.p[i].p,planeColor);\n            #ifdef ALLOW_REFLECTIONS\n            }\n\t\t\t#endif\n        }\n    }\n    \n    //Cast ray against the visualisation of the light\n    hit = RaySphere(ray,lightSphere);\n    if(hit.hit)\n    {\n\t\tif(hit.dist < minDist)\n        {\n\t\t\tcolor = lightSphere.c.xyz;\n        }\n    }\n    hit = RaySphere(ray,lightSphere2);\n    if(hit.hit)\n    {\n\t\tif(hit.dist < minDist)\n        {\n\t\t\tcolor = lightSphere2.c.xyz;\n        }\n    }\n\treturn vec4(color,1.0);\n}\n\n\n\n//program entrypoint\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //creats a ray object\n    Ray ray;\n    //set fragCoords to be from 0 to iResolution instead of 0.5 to iResolution+0.5\n    fragCoord.xy -= vec2(0.5,0.5);\n    \n    //calculate aspect ration\n    float aspect = iResolution.x / iResolution.y;\n   \t\n    //set the \"view plane\" variables\n    vPlane.pos = vec3(0.0,0.0, NEARPLANE);\n    vPlane.size = vec2(aspect,1.0);\n    \n    //get the current coordinates on the viewplane (similiar to UV coords)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //get the world size of 1 pixel on the viewplane\n    vec2 pixSize = vPlane.size / iResolution.xy;\n    \n    float lightDistance = 7.0;\n    float timeSpeed = 1.5;\n    float time = iTime*timeSpeed;\n    vec3 lightOffset = vec3(0,0,20.0);\n    //float time = 90.00;\n    \n    //construct scene\n    light.p = vec3((sin(time/1.5)-cos(time/1.5))*lightDistance,sin(time)*lightDistance,cos(time)*lightDistance)+lightOffset; // move light around in a 3D \"infinity symbol\"\n    light.c = vec4(1.0,1.0,1.0,0.4);\n    light2.p = vec3((sin(-time/1.5)-cos(-time/1.5))*lightDistance,sin(-time)*lightDistance,cos(-time)*lightDistance)+lightOffset; // move light around in a 3D \"infinity symbol\"\n    light2.c = vec4(1.0,1.0,1.0,0.4);\n    lightSphere.p = light.p;\n    lightSphere.r = 0.2;\n    lightSphere.c = vec4(1.0,1.0,1.0,0.0);\n    \n    #ifdef ENABLE_SECOND_LIGHT\n    lightSphere2.p = light2.p;\n\t#else \n    lightSphere2.p = light.p;\n\t#endif\n    lightSphere2.r = 0.2;\n    lightSphere2.c = vec4(1.0,1.0,1.0,0.0);\n    \n    //Big sphere\n    scene.s[0].p = vec3(sin(time)*7.0,0.0,20.0);\n    scene.s[0].r = 4.0;\n    scene.s[0].c = vec4(0.0,0.0,1.0,0.9);\n    //left sphere\n    scene.s[1].p = vec3(sin(time)*2.0+5.0,cos(time)+2.0,9.0);\n    scene.s[1].r = 1.0;\n    scene.s[1].c = vec4(0.0,1.0,0.0,0.0);\n    //right sphere\n    scene.s[2].p = vec3(-9.0,2.0,20.0);\n    scene.s[2].r = 1.0;\n    scene.s[2].c = vec4(1.0,0.0,0.0,0.0);\n    \n    \n    //ground\n    scene.p[0].p = vec3(0.0,10,0.0);\n    scene.p[0].n = normalize(vec3(0.0,1.0,0.0));\n    scene.p[0].c = vec4(1.0,0.0,0.0,0.0);\n    //back wall\n    scene.p[1].p = vec3(0.0,0,40.0);\n    scene.p[1].n = normalize(vec3(-0.3,0.0,1.0));\n    scene.p[1].c = vec4(0.0,0.5,0.5,1.0);\n    //left wall\n    scene.p[2].p = vec3(20.0,0,0.0);\n    scene.p[2].n = normalize(vec3(1.0,0.0,0.0));\n    scene.p[2].c = vec4(0.0,0.5,0.5,0.0);\n    //right wall\n    scene.p[3].p = vec3(-20.0,0,0.0);\n    scene.p[3].n = normalize(vec3(-1.0,0.0,0.0));\n    scene.p[3].c = vec4(0.0,0.5,0.5,0.0);\n    //ceiling wall\n    scene.p[4].p = vec3(0.0,-10,0.0);\n    scene.p[4].n = normalize(vec3(0.0,-1.0,0.0));\n    scene.p[4].c = vec4(0.0,0.5,0.5,0.0);\n    //front wall\n    scene.p[5].p = vec3(0.0,0,-2.0);\n    scene.p[5].n = normalize(vec3(0.0,0.0,-1.0));\n    scene.p[5].c = vec4(0.0,0.5,0.5,0.0);\n    \n    \n    //raytrace & output\n   \t\n    //set ray position and calculate normal adjustment based on pixel size\n    ray.p = vec3(0.0,0.0,0.0);\n\tvec3 normalAdjust = vec3(iResolution.xy/2.0 * pixSize,0.0);\n\n#ifdef MULTISAMPLE\n\t//if we use multisample we send out 4 rays instead of 1, add them up and average the final color (result will give a anti-aliased image)   \n    \n//    crude visual explanation: every * is a trace, image represents 1 pixel\n//\t  __________\n//\t  |         |\n//    | *    *  |\n//    |\t\t    |\n//    | *    *  |\n//    -----------\n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x+0.25) * pixSize.x,(fragCoord.y + 0.25) * pixSize.y, 0.0)-normalAdjust));\n    vec4 col1 = Trace(ray);\n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x+0.75) * pixSize.x,(fragCoord.y + 0.25) * pixSize.y,0.0)-normalAdjust));\n    vec4 col2 = Trace(ray);\n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x+0.25) * pixSize.x,(fragCoord.y + 0.75) * pixSize.y,0.0)-normalAdjust));\n    vec4 col3 = Trace(ray);\n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x+0.75) * pixSize.x,(fragCoord.y + 0.75) * pixSize.y,0.0)-normalAdjust));\n    vec4 col4 = Trace(ray);\n    fragColor = (col1+col2+col3+col4) /4.0;\n    \n   #else\n    \n    // we cast a single ray, retrieve the final color and output it \n    ray.d = normalize(vPlane.pos - (vec3((fragCoord.x) * pixSize.x,fragCoord.y * pixSize.y,0.0)-normalAdjust));\n    vec4 col = Trace(ray);\n    fragColor = col;\n    \n#endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}