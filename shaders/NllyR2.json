{
    "Shader": {
        "info": {
            "date": "1648329053",
            "description": "tis the dagsoc logo\n\nv. cursed code",
            "flags": 32,
            "hasliked": 0,
            "id": "NllyR2",
            "likes": 4,
            "name": "Dagsoc logo competition",
            "published": 3,
            "tags": [
                "caustics",
                "dagsoc"
            ],
            "usePreview": 0,
            "username": "Molive",
            "viewed": 364
        },
        "renderpass": [
            {
                "code": "//uniform sampler2D T;\n//layout(location = 2) uniform vec3 TexCoord;\n#define TexCoord vec3(iResolution.xy,0)\n#define T iChannel0\nconst float a = 3.;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{  \n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 tex=texture(T,uv);\n    vec3 c= a*tex.rgb/tex.a;\n\n    vec3 color = c;\n    \n    float n = length(color);\n    color*=pow(n,1.1)*6.;\n\n\tcolor=color*(1.+(color/10.))/(1.+color);\n\n\tuv-=.5;   \n    // gamma correction and a slight blue color grading\n\tcolor=pow(color, .45*vec3(1.0,1.1,1.2))*(1.-dot(uv,uv)*.75);\n    \n\tfragColor.rgb=color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi (acos(-1.))\n\nconst int matDiffuse=0;\nconst int matMirror=1;\nconst int matBlack=2;\nconst int matLiquid=3;\nconst int matLight=4;\nconst vec3 lightpos=vec3(24.,12.,-29.);\n//const vec3 lightpos=vec3(19.,12.,-23.);\n#define Epsilon 1.000001\n#define pixelRadius 0.0001\n\n//A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nvec2 random( uvec2  v ) {return vec2(floatConstruct(hash( v.x ^ hash(v.y))),floatConstruct(hash( v.y ^ hash(v.x))));}\n\nvec2 uv;\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n    /// Returns a point on a sphere, r is in 0..1 range\nvec3 pointOnSphere(vec2 r) {\n    r=vec2(6.283185*r.x,2.*r.y-1.);\n    return vec3(sqrt(Epsilon-r.y*r.y)*vec2(cos(r.x),sin(r.x)),r.y); // 1.001 required to avoid NaN\n}\n \n    /// Returns a cosine weighted sample\nvec3 lambertSample(vec3 n,vec2 r) {\n    return normalize(n*Epsilon+pointOnSphere(r)); // 1.001 required to avoid NaN\n}\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// sphere of size ra centered at point ce\nvec4 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(-1.0); // no intersection\n    h = sqrt( h );\n    float t = (-b-h);\n    return vec4( t, (oc+t*rd)/ra );\n}\n\nvec2 box( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN, in bool far ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    if (far)\n    {\n        oN = -sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n    }\n    else\n    {\n        oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    }\n\n    return vec2( tN, tF );\n}\n\n#define checkinset if ((inset.x != -1.) && abs(inset.x - dist.x) < 0.0001) {if (abs(inset.y - dist.y) > 0.0001) {return vec4(inset.y, extra_normal);} else {return vec4(-1.);}}\n\nvec4 dagsoc(in vec3 ro, in vec3 rd)\n{\n    vec3 normal;\n    vec2 dist = box(ro,rd,vec3(3,3,3),normal,false);\n    if (dist.x != -1.)\n    {\n        vec3 extra_normal;\n        vec2 inset = box(ro-vec3(0,2.5,0),rd,vec3(0.75,0.5,0.75),extra_normal,true);\n        checkinset\n        inset = box(ro-vec3(2.25,-2.25,0),rd,vec3(0.75,0.75,1.4),extra_normal,true);\n        checkinset\n        inset = box(ro-vec3(2.7,0.2,0),rd,vec3(0.3,1,0.3),extra_normal,true);\n        checkinset\n        inset = box(ro-vec3(2.7,0.6,1),rd,vec3(0.3,1,0.3),extra_normal,true);\n        checkinset\n        inset = box(ro-vec3(2.7,0.6,-1),rd,vec3(0.3,1,0.3),extra_normal,true);\n        checkinset\n        \n        vec3 normal1;\n        vec2 inset1 = box(ro-vec3(-1,0.7,2.5),rd,vec3(2,0.2,0.5),normal1,true);\n        vec3 normal2;\n        vec2 inset2 = box(ro-vec3(-1,-0.3,2.5),rd,vec3(2,0.2,0.5),normal2,true);\n        vec3 normal3;\n        vec2 inset3 = box(ro-vec3(1.2,-0.35,2.5),rd,vec3(0.2,1.25,0.5),normal3,true);\n        vec3 normal4;\n        vec2 inset4 = box(ro-vec3(0,-1.4,2.5),rd,vec3(1,0.2,0.5),normal4,true);\n        vec3 normal5;\n        vec2 inset5 = box(ro-vec3(-0.8,-0.85,2.5),rd,vec3(0.2,0.35,0.5),normal5,true);\n        if ((inset1.x != -1.) && abs(inset1.x - dist.x) < 0.0001)\n        {\n            if (abs(inset1.y - inset3.x) < 0.0001) \n            {\n                return vec4(inset3.y, normal3);\n            }\n            else\n            if (abs(inset1.y - dist.y) > 0.0001) \n            {\n                return vec4(inset1.y, normal1);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        if ((inset2.x != -1.) && abs(inset2.x - dist.x) < 0.0001)\n        {\n            if (abs(inset2.y - inset3.x) < 0.0001) \n            {\n                return vec4(inset3.y, normal3);\n            }\n            else\n            if (abs(inset2.y - inset5.x) < 0.0001) \n            {\n                if (abs(inset5.y - inset4.x) < 0.0001) \n                {\n                    return vec4(inset4.y, normal4);\n                }\n                else\n                {\n                    return vec4(inset5.y, normal5);\n                }\n            }\n            else\n            if (abs(inset2.y - dist.y) > 0.0001) \n            {\n                return vec4(inset2.y, normal2);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        if ((inset3.x != -1.) && abs(inset3.x - dist.x) < 0.0001)\n        {\n            if (abs(inset3.y - inset1.x) < 0.0001) \n            {\n                return vec4(inset1.y, normal1);\n            }\n            else\n            if (abs(inset3.y - inset2.x) < 0.0001) \n            {\n                return vec4(inset2.y, normal2);\n            }\n            else\n            if (abs(inset3.y - inset4.x) < 0.0001) \n            {\n                return vec4(inset4.y, normal4);\n            }\n            else\n            if (abs(inset3.y - dist.y) > 0.0001) \n            {\n                return vec4(inset3.y, normal3);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        if ((inset4.x != -1.) && abs(inset4.x - dist.x) < 0.0001)\n        {\n            if (abs(inset4.y - inset3.x) < 0.0001) \n            {\n                return vec4(inset3.y, normal3);\n            }\n            else\n            if (abs(inset4.y - inset5.x) < 0.0001) \n            {\n                if (abs(inset5.y - inset2.x) < 0.0001) \n                {\n                    return vec4(inset2.y, normal2);\n                }\n                else\n                {\n                    return vec4(inset5.y, normal5);\n                }\n            }\n            else\n            if (abs(inset4.y - dist.y) > 0.0001) \n            {\n                return vec4(inset4.y, normal4);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        if ((inset5.x != -1.) && abs(inset5.x - dist.x) < 0.0001)\n        {\n            if (abs(inset5.y - inset2.x) < 0.0001) \n            {\n                return vec4(inset2.y, normal2);\n            }\n            else\n            if (abs(inset5.y - inset4.x) < 0.0001) \n            {\n                return vec4(inset4.y, normal4);\n            }\n            else\n            if (abs(inset5.y - dist.y) > 0.0001) \n            {\n                return vec4(inset5.y, normal5);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        \n        return vec4(dist.x,normal);\n    }\n    return vec4(-1.);\n}\n\n#define checkinverse if (top.x > 0. && top.x < ret.x) {ret = vec4(top.x, extra_normal);}\n\nvec4 inversedagsoc(in vec3 ro, in vec3 rd)\n{\n    vec3 extra_normal;\n    vec4 ret = vec4(1000);\n    vec2 top = box(ro-vec3(0,2.5,0),rd,vec3(0.75,0.5,0.75),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(2.25,-2.25,0),rd,vec3(0.75,0.75,1.4),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(2.7,0.2,0),rd,vec3(0.3,1,0.3),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(2.7,0.6,1),rd,vec3(0.3,1,0.3),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(2.7,0.6,-1),rd,vec3(0.3,1,0.3),extra_normal,false);\n    checkinverse\n    \n    top = box(ro-vec3(-1,0.7,2.5),rd,vec3(2,0.2,0.5),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(-1,-0.3,2.5),rd,vec3(2,0.2,0.5),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(1.2,-0.35,2.5),rd,vec3(0.2,1.25,0.5),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(0,-1.4,2.5),rd,vec3(1,0.2,0.5),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(-0.8,-0.85,2.5),rd,vec3(0.2,0.35,0.5),extra_normal,false);\n    checkinverse\n\n    vec3 normal;\n    vec2 dist = box(ro,rd,vec3(3,3,3),normal,true);\n    if (dist.y > 0. && dist.y < ret.x)\n    {\n        ret = vec4(dist.y, normal);\n    }\n    return ret;\n}\n\nvec2 hash2( float p ) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nint mat;\nfloat inv;\nbool inside;\n\n// intersection function\nvec4 iScene(vec3 ro, vec3 rd)\n{\n    mat = matLiquid;\n    vec4 innerScene;\n    if (inside) {\n    innerScene = inversedagsoc(ro,rd);\n    } else {\n    innerScene = dagsoc(ro,rd);\n    }\n    if (innerScene.x > 0.) return innerScene;\n    mat = matLight;\n    vec4 light = sphIntersect(ro,rd,lightpos,10.);\n    if (light.x > 0.) return light;\n    mat = matDiffuse;\n    float plane = plaIntersect(ro, rd, vec4(0,1,0,5));\n    if (plane > 0.) return vec4(plane, 0.,1.,0.);\n    //vec4 curve = iCylinderInverse(ro,rd, vec3(-10.,11.,0.), vec3(0.,0.,1.),15.);\n    //if (curve.x > 0. && ro.x+rd.x*curve.x <= -10.) return curve;\n    return vec4(0);\n}\n\nvec2 rv2;\nint bounce = 0;\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    const vec3 lightdir = normalize(vec3(.7,.4,-1));\n    \n    const float THRESHOLD = .0001;\n\n    vec3 accum = vec3(1);\n    inside = false;\n    for(bounce = 0;bounce<3;bounce++)\n    {\n        float t = 0.;\n        float k = 0.;\n        vec3 n = vec3(1,0,0);\n        vec3 h = vec3(0);\n        rv2 = random(uvec2(abs(rv2*2000.)));\n\n        t = 0.;\n        k = 0.;\n        n = vec3(1,0,0);\n        h = vec3(0);\n        mat = matBlack;\n        vec4 scene = iScene(cam,dir);\n        if (scene.x > 0.) \n        {\n            t = scene.x;\n            n = scene.yzw;\n            h = cam+dir*t;\n            k = THRESHOLD;\n            \n            /*if (inside) {\n                n= n*-1.;\n            }*/\n\n            // if we hit something\n\n            float fresnel = pow(1.-dot(-dir,n),5.);\n            fresnel*=1.-step(.99,fresnel);\n            \n            // debug normals visualization\n            //if (inside)\n            //if (mat != matBound)\n            //if (mat != matLiquid)\n            //return vec3(n*.1+0.1);\n            //return (n*.5+.5) * (.7+.3*step(1.4,length(step(.1,fract(h.xz-.5)))));\n\n            if (mat == matDiffuse)\n            {\n                // bounce the ray in a random direction\n                if (rv2.x > 0.) {\n                    dir = lambertSample(n,rv2);\n                } else {\n                    dir = normalize(lightpos + lambertSample(n,rv2) * 6. - cam);\n                }\n                accum *= dot(dir,n);\n            }\n            else if (mat == matLight)\n            {\n                return accum * vec3(6.,5.5,5.) * step(.8,dot(dir,lightdir));\n            }\n            else if (mat == matMirror)\n            {\n                n += sin(h*4.).bgr*.001;\n                n += sin(h*3.77).bgr*.001;\n                n += sin(h*.737).bgr*.001;\n                \n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            }\n            else if (mat == matLiquid)\n            {\n                // Randomly reflect or refract, probability based on fresnel term\n                // If non-fresnel, refract\n                if (rv2.x > fresnel) {\n                    // refraction\n                    // Index of refraction\n                    float ior = inside ? 1.364 : 1./1.364;\n        \n                    // Find refraction angle, accounting for surface roughness\n                    vec3 rayDir = normalize( // Ray dir must be normalised\n                          mix( // Mix between...\n                              refract(dir, n, ior), // the refracted angle\n                              lambertSample(-n, rv2), // and a random angle projected into the surface\n                              0.8 // based on how smooth the glass surface is\n                              )\n                          );\n        \n                    // Test for total internal reflection\n                    if(dot(n, dir) < 0.0) {\n                        // Not TIR, we're OK to refract\n            \n                        // Set the ray direction\n                        dir=rayDir;\n            \n                        // Flip the inside value as we pass through the surface\n                        inside=!inside;\n                        bounce--;\n                        cam = h + dir * 2. * THRESHOLD;\n\n                        if (!inside) {\n                        accum *= vec3(1.) - t * vec3(0.1,0.03, 0.08);\n                        }\n                        continue;\n                    }\n                }\n    \n                // Ray failed to refract, therefore reflection\n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            } else {\n            return vec3(0,0,1);\n            }\n            \n            cam = h + dir * THRESHOLD * 1.1 / dot(dir,n);\n        }\n        else {\n        bounce++;\n        break;\n        }\n    }\n    return vec3(0);\n}\n\nvec2 ringDof(vec2 seed)\n{\n    seed=fract(seed);\n    if (seed.y>seed.x)\n        seed=1.-seed;\n    float r=seed.x;\n    float a=(seed.y/seed.x)*pi*2.;\n    return vec2(cos(a),sin(a))*r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // grab the previous color so we can iteratively render.\n    // in the actual executable I just rendered additively to a single framebuffer instead\n   \tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    uv = fragCoord.xy/iResolution.xy-.5;\n\n    // random function borrowed from I can't remember where\n    float seed = float(((int(iFrame*73856093))^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\trv2 = hash2( 24.4316544311+float(iFrame)+seed );\n    //rv2 = random(uvec2(normalize(abs(vec2(seed, 24.4316544311+iFrame+seed)))*20000.0));\n\n    \n    // jitter camera for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // make a camera\n    vec3 cam = vec3(1.,1.,-80.);\n    //vec3 cam = vec3(0.1,0.1,0.1);\n    vec3 dir = normalize(vec3(uv,2.5));\n\n    // slight jitter for dof\n    //const float dofScale = .05 ;\n    //const float dofDist = 10.;\n    //vec2 dofJitter = ringDof(rv2);\n    //cam.xy += dofJitter*dofScale;\n    //dir.xy -= dofJitter*dofScale/dofDist;\n\n    // spin it to an isometric angle\n    cam.yz = rotate(cam.yz, pi/6.);\n    dir.yz = rotate(dir.yz, pi/6.);\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = .8-3.*(iMouse.y/iResolution.y);\n    \tcam.yz = rotate(cam.yz, a);\n    \tdir.yz = rotate(dir.yz, a);\n    }\n\n    // spin it to an isometric angle\n    cam.xz = rotate(cam.xz, pi/1.4);\n    dir.xz = rotate(dir.xz, pi/1.4);\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = 1.-8.*(iMouse.x/iResolution.x);\n    \tcam.xz = rotate(cam.xz, a);\n    \tdir.xz = rotate(dir.xz, a);\n    }\n    \n    // compute the pixel color\n    vec3 pixel = vec3(0);\n    for (int i = 0; i < 8; i++) {\n        pixel += trace(cam,dir);\n    }\n    pixel /= 8.;\n   \n    // reset buffer if we're clicking\n     if (iMouse.z > 0.) fragColor *= .1;\n\n    // accumulate the pixel\n    //if(pixel.r >= 0.)\n    fragColor += vec4(pixel,1);\n    \n    //gl_FragColor = vec4(random(uvec2(abs(uv*1000.))),1.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}