{
    "Shader": {
        "info": {
            "date": "1699559181",
            "description": "Transparence en ray tracing + 3 sources lumineuses",
            "flags": 0,
            "hasliked": 0,
            "id": "dtdcRs",
            "likes": 0,
            "name": "Transparence Ray tracing",
            "published": 3,
            "tags": [
                "refraction"
            ],
            "usePreview": 0,
            "username": "smirboulack",
            "viewed": 128
        },
        "renderpass": [
            {
                "code": "/*\n\nRéalisé par Temirboulatov Koureich p1707160 et Rezaoui Yanis p1810590 UCBL LYON 1 - 2023\n\nPyramide réalisé en suivant les instructions : \n - https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/ray-triangle-intersection-geometric-solution.html\n - https://www.shadertoy.com/view/MlGcDz\n*/\n\n\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.x * axis.z + axis.y * s,\n        oc * axis.y * axis.x + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.z * axis.y + axis.x * s, oc * axis.z * axis.z + c\n    );\n}\n\n\nstruct Material\n{\n    vec3 d;// Diffuse\n    float reflectivity; // Reflectivity coefficient, 0.0 for matte, 1.0 for fully reflective\n    float transparency; // valeur de transparence entre 0 et 1\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\nvec3 UniformTexture(vec3 color) {\n    return color;\n}\n\nvec3 Damier(vec3 p, float sideSize) {\n    vec3 color1 = vec3(1.0, 1.0, 1.0); // Couleur blanche\n    vec3 color2 = vec3(0.0, 0.0, 0.0); // Couleur noire\n\n    // Déterminer l'indice de la case dans laquelle se trouve le point\n    ivec3 boxIndex = ivec3(floor(p / sideSize));\n\n    // Calculer si la somme des indices de la case est paire ou impaire\n    int checker = int(boxIndex.x + boxIndex.y + boxIndex.z) % 2;\n\n    // Retourner la couleur correspondante\n    return checker == 0 ? color1 : color2;\n}\n\nvec3 StripedTexture(vec3 p, vec3 color1, vec3 color2, float stripeWidth) {\n    // Calculer le motif à rayures en fonction de la coordonnée x\n    float pattern = sin(p.x * stripeWidth);\n\n    // Déterminer si nous sommes dans une rayure ou non\n    float stripe = step(0.5, pattern);\n\n    // Mélanger les deux couleurs en fonction de la valeur de la rayure\n    return mix(color1, color2, stripe);\n}\n\nMaterial TexturePlane(vec3 p, int i) {\n    if (i == 0) {\n        // Définir les couleurs pour les rayures\n        vec3 color1 = vec3(1.0, 1.0, 1.0); // Couleur blanche\n        vec3 color2 = vec3(0.0, 0.0, 0.0); // Couleur noire\n        float stripeWidth = 3.1415 * 2.0; // Largeur des rayures\n\n        // Obtenir la texture à rayures\n        vec3 col = StripedTexture(p, color1, color2, stripeWidth);\n        return Material(col, 0.0,0.0); // Matériau non réfléchissant\n    }\n    // Ajouter d'autres cas de textures si nécessaire\n    return Material(vec3(0), 0.0,0.0); // Matériau mat par défaut\n}\n\n//Texture arc-en-ciel\nvec3 RainbowTexture(vec3 p) {\n    float pi = 3.14159265359; // Définir la valeur de pi\n\n    // S'assurer que la coordonnée Y est entre 0 et 1\n    float y = mod(p.y, 1.0); \n\n    // Convertir y en une valeur entre 0 et 2*pi\n    float angle = 2.0 * pi * y;\n\n    // Calculer les valeurs RGB en utilisant des fonctions trigonométriques\n    float r = 0.5 * sin(angle) + 0.5; // Calculer la composante rouge\n    float g = 0.5 * sin(angle + 2.0 * pi / 3.0) + 0.5; // Calculer la composante verte\n    float b = 0.5 * sin(angle + 4.0 * pi / 3.0) + 0.5; // Calculer la composante bleue\n    vec3 color = vec3(r, g, b); // Combiner les composantes RGB en une couleur\n    // Retourner la couleur\n    return color;\n}\n\n// Fonction de bruit simple\nfloat noise(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Fonction de texture d'herbe\nvec3 GrassTexture(vec3 p) {\n    // Couleur de base de l'herbe\n    vec3 grassColor = vec3(0.1, 0.5, 0.1);\n\n    // Ajouter une variation de couleur\n    float variation = noise(p.xz * 5.0); // Ajuster l'échelle pour contrôler la fréquence de variation\n    grassColor *= 0.7 + 0.3 * variation; // Assombrir et éclaircir la couleur de base\n\n    // Ajouter des taches plus sombres pour simuler des ombres ou différents types d'herbe\n    float darkPatches = smoothstep(0.4, 0.6, noise(p.xz * 10.0)); // Ajuster l'échelle pour la taille des taches\n    grassColor *= mix(vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0), darkPatches);\n\n    return grassColor;\n}\n\nvec3 ConcentricTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif concentrique basé sur la distance au centre\n    float distToCenter = length(p - centerPoint);\n    float concentricValue = sin(distToCenter * frequency);\n\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Combiner les deux motifs\n    float pattern = (concentricValue + radialValue) * 0.5;\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(vec3(0.2, 0.4, 0.6), vec3(0.8, 0.6, 0.4), (pattern + 1.0) * 0.5);\n\n    return color;\n}\n\nvec3 RadialTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Mapper la valeur radiale à une couleur\n    // Couleur noire\n    vec3 color1 = vec3(0.0, 0.0, 0.0);\n    // Couleur jaune\n    vec3 color2 = vec3(1.0, 1.0, 0.0);\n\n    // Créer le motif radial\n    float pattern = 0.5 * (1.0 + sin(frequency * distToAxis));\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(color1, color2, pattern);\n\n    return color;\n}\n\nvec3 multicolorTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Mapper la valeur radiale à une couleur\n    // Couleur noire\n    vec3 color1 = vec3(0.0, 0.0, 0.0);\n    // Couleur jaune\n    vec3 color2 = vec3(1.0, 1.0, 0.0);\n    // Couleur rouge\n    vec3 color3 = vec3(1.0, 0.0, 0.0);\n    // Couleur bleue\n    vec3 color4 = vec3(0.0, 0.0, 1.0);\n\n    // Créer le motif radial\n    float pattern = 0.5 * (1.0 + sin(frequency * distToAxis));\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(color1, color2, pattern);\n    color = mix(color, color3, pattern);\n    color = mix(color, color4, pattern);\n\n    return color;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i)\n{\n    if (i == 1)\n    {\n        return Material(vec3(.8, .5, .4), 0.5,0.0); // Matte material\n    }else if(i==2){\n         //return Material(Damier(p, 0.5), 0.0,0.9);\nreturn Material(vec3(.0, .0, .0), 0.0,0.5); // Matte material\n    } else if(i==3){\n        return Material(ConcentricTexture(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 10.0), 0.2,0.0);\n    }\n    else if(i==4){\n        return Material(RainbowTexture(p),0.4,0.0);\n    }\n    else if(i==5){\n        return Material(StripedTexture(p, vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 3.1415 * 2.0), 0.5,0.0);\n    }\n    else if(i==6){\n        return Material(RadialTexture(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 10.0), 0.2,0.0);\n    }\n    else if(i==7){\n        //mirror\n        return Material(vec3(0.0, 0.0, 0.0), 1.0,0.0);\n    }else if(i==8){\n        //uniform yellow\n        return Material(vec3(1.0, 1.0, 0.0), 0.0,0.0);\n    }\n    else if (i == 0) {\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col, 0.3,0.0); // Non-reflective material*/\n        //return Material(GrassTexture(p), 0.3,0.0); // Non-reflective grass material\n    }\n    // Add more materials with different reflectivity as needed\n\n    return Material(vec3(0), 0.0,0.0); // Default matte material\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectRotatingSphere(Ray ray, Sphere sph, out Hit x, float angle, vec3 axis) {\n    // 1. Calculer le centre de la sphère\n    vec3 center = sph.c;\n\n    // 2. Calculez la matrice de rotation en fonction de l'axe et de l'angle spécifiés\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transform ray\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translate to center, rotate, then translate back\n    transformedRay.d = invRot * ray.d;\n\n    // 3. Effectuez l'intersection comme si la sphère n'était pas tournée\n    if (IntersectSphere(transformedRay, sph, x)) {\n        return true;\n    }\n    return false;\n}\n\nvoid translateSphere(out Sphere s, vec3 maxTranslation, float translation_speed, float time) {\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    s.c += maxTranslation * oscillation;\n}\n\n\nvoid rotateSphere(out Sphere s, float angle, vec3 axis) {\n    axis = normalize(axis); // Assurez-vous que l'axe est normalisé\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    s.c = s.c * cosTheta +\n        cross(axis, s.c) * sinTheta +\n        axis * dot(axis, s.c) * (1.0 - cosTheta);\n}\n\nvoid scaleSphere(out Sphere s, float scaleMin, float scaleMax, float scale_speed, float time) {\n    // Oscillation entre scaleMin et scaleMax\n    float scaleFactor = mix(scaleMin, scaleMax, 0.5 * (1.0 + sin(time * scale_speed)));\n\n    s.r *= scaleFactor;\n}\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    float t = -dot(ray.o - pl.p, pl.n) / dot(ray.d, pl.n);\n    if (t > 0.) {\n\n        x = Hit(t, vec3(0, 0, 1), 0);\n        return true;\n    }\n    return false;\n}\n\nvec3 Background(vec3 rd) {\n    // Définir les couleurs du ciel : haut et horizon\n    vec3 skyTopColor = vec3(0.0, 0.5, 0.8); // Bleu profond\n    vec3 skyHorizonColor = vec3(0.7, 0.9, 1.0); // Bleu clair presque blanc\n\n    // Mélanger en fonction de la direction vers le haut (z dans ce cas)\n    // En supposant que rd est normalisé et que rd.z est dans l'intervalle [-1, 1]\n    float t = 0.5 * (rd.z + 1.0); // Échelle à l'intervalle [0, 1]\n    return mix(skyHorizonColor, skyTopColor, t); // Interpoler entre les couleurs de l'horizon et du haut\n}\n\n\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    Sphere sph1=Sphere(vec3(0.,0.,1.),1.,2);\n    Sphere sph2=Sphere(vec3(2.,0.,2.),1.,3);\n    rotateSphere(sph2,iTime,vec3(0.,0.0,1.));\n    \n    //PLAN\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n\n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    \n    \n    return ret;\n}\n\n\n// Teste si le point est dans l'ombre\nbool InShadow(vec3 point, vec3 lightPos, out float shadowFactor)\n{\n    vec3 toLight = lightPos - point;\n    float distanceToLight = length(toLight);\n    toLight = normalize(toLight);\n\n    Ray shadowRay = Ray(point + toLight * 0.001, toLight); // Décalage pour éviter l'auto-intersection\n    Hit shadowHit;\n\n    // Vérifie les intersections avec n'importe quel objet de la scène\n    if (Intersect(shadowRay, shadowHit))\n    {\n        // Si l'intersection est plus proche que la lumière, le point est dans l'ombre\n        if (shadowHit.t < distanceToLight)\n        {\n            shadowFactor = 0.0; // Dans l'ombre\n            return true;\n        }\n    }\n\n    shadowFactor = 1.0; // Pas dans l'ombre\n    return false;\n}\n\n// Calcul de l'occlusion ambiante\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n    float ao = 0.0;\n    float occlusion = 0.0;\n    float radius = 1.0; // Définit le rayon dans lequel vérifier l'occlusion\n\n    for (int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n); // Direction dans l'hémisphère\n        Ray aoRay = Ray(p + n * 0.001, d); // Décalage de l'origine un peu le long de la normale pour éviter l'auto-intersection\n\n        Hit aoHit;\n        if (Intersect(aoRay, aoHit) && aoHit.t < radius) {\n            occlusion += 1.0; // Ce rayon a frappé quelque chose, donc augmenter l'occlusion\n        }\n    }\n\n    ao = 1.0 - occlusion / float(N); // La fraction de rayons qui n'ont rien frappé\n    return ao;\n}\n\nvec3 applyTransparency(vec3 objectColor, vec3 backgroundColor, float alpha) {\n    // Mix the object color with the background color based on the alpha value\n    return mix(backgroundColor, objectColor, alpha);\n}\n\n\nvec3 PhongIllumination(Material m, vec3 n, vec3 v, vec3 lightPos, float shininess, vec3 point)\n{\n    float shadowFactor;\n    if (InShadow(point, lightPos, shadowFactor))\n    {\n        return vec3(0.0); // Dans l'ombre, pas de composante diffuse ou spéculaire\n    }\n\n    vec3 ambient = 0.1 * m.d; // Couleur ambiante\n\n    // Composante diffuse\n    vec3 l = normalize(lightPos - point);\n    float diff = max(dot(n, l), 0.0);\n    vec3 diffuse = diff * m.d * shadowFactor;\n\n    // Composante spéculaire\n    vec3 r = reflect(-l, n); // Réfléchir le vecteur lumineux sur la normale\n    float spec = pow(max(dot(r, v), 0.0), shininess);\n    vec3 specular = vec3(1.0) * spec * shadowFactor; // En supposant des reflets spéculaires blancs\n\n    return ambient + diffuse + specular;\n}\n\n// Applique le modèle de couleur avec l'illumination de Phong et les ombres\nvec3 Color(Material m, vec3 n, vec3 v, vec3 point)\n{\n    // Définit les positions des lumières\n    vec3 lightPos1 = vec3(1, 20, 10); // Position de la première lumière\n    vec3 lightPos2 = vec3(-2, -20, 10); // secondes lumière\n    vec3 lightPos3 = vec3(-200, -200, 100); // troisième lumière\n    \n    \n    // Calcule la direction de vue\n    vec3 viewDir = normalize(v); // Calcule la direction de vue\n    \n    // Calcule l'occlusion ambiante avant l'éclairage direct\n    float ao = AmbientOcclusion(point, n, 16); // Utilisation de 16 échantillons pour l'AO\n\n    // Illumination de Phong avec ombres pour la première lumière\n    vec3 col = PhongIllumination(m, n, viewDir, lightPos1, 100.0, point);\n    col += PhongIllumination(m, n, viewDir, lightPos2, 100.0, point);\n    col += PhongIllumination(m, n, viewDir, lightPos3, 100.0, point);\n\n    // Applique l'occlusion ambiante à la couleur finale\n    col *= ao;\n\n    return col;\n}\n\n// Rendu avec prise en charge de la transparence\nvec3 Shade(Ray ray)\n{\n    vec3 color = vec3(0.0); // Initialise la couleur à noir\n    vec3 attenuation = vec3(1.0); // Commence sans atténuation\n\n    for (int bounce = 0; bounce < 1000; bounce++)\n    {\n        Hit hit;\n        if (!Intersect(ray, hit))\n        {\n            // Si aucun objet n'est touché, utilisez la couleur de fond\n            color += attenuation * Background(ray.d);\n            break;\n        }\n\n        vec3 point = Point(ray, hit.t); // Point d'intersection\n        Material mat = Texture(point, hit.i);\n\n        // Calcul de la direction de vue\n        vec3 viewDir = normalize(-ray.d);\n\n        // Si le matériau est transparent,tracer un autre rayon\n        if (mat.transparency > 0.0)\n        {\n            // Mélanger avec le fond ou avec la couleur de l'objet derrière\n            vec3 background = Background(ray.d); \n            vec3 objectColor = Color(mat, hit.n, viewDir, point);\n            color += attenuation * applyTransparency(objectColor, background, mat.transparency);\n            \n            // Attnénuation basée sur la transparence pour le prochain rebond\n            attenuation *= (1.0 - mat.transparency);\n\n            // Préparez le rayon pour le prochain passage à travers un nouvel objet\n            ray.o = point + ray.d * 0.001;\n        }\n        else\n        {\n            // Si l'objet n'est pas transparent, calculez la couleur et arrêter la boucle.\n            color += attenuation * Color(mat, hit.n, viewDir, point);\n            break;\n        }\n    }\n\n    return color;\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=20.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}