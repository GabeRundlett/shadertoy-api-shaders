{
    "Shader": {
        "info": {
            "date": "1516025345",
            "description": "A soulstone from Diablo 3. The reference is the Reaper of Souls expansion trailer.",
            "flags": 96,
            "hasliked": 0,
            "id": "XtSfDD",
            "likes": 103,
            "name": "Soulstone pt2",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "generated",
                "crystal",
                "diablo",
                "blizzard",
                "soulstone"
            ],
            "usePreview": 1,
            "username": "mmerchante",
            "viewed": 4154
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------\n// BUF A: SURFACE RAYMARCHING AND FIRE\n// BUF B: MEDIUM RAYMARCHING AND NORMAL ESTIMATION\n// IMAGE: RENDERING AND COMPOSITION\n// ---------------------------------------------------------\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define MAX_STEPS 30\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define FIXED_STEP_SIZE .05\n\n#define MAX_DISTANCE 30.0\n#define MIN_DISTANCE 15.0\n#define EPSILON .02\n#define EPSILON_NORMAL .05\n\n#define MATERIAL_NONE -1\n#define MATERIAL_CRYSTAL 1\n\n// ---------------------------------------------------------\n\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n} \n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox(vec3 p) {\n    vec3 d = abs(p) - .5;\n    return length(max(d, 0.0)) + vmax(min(d, 0.0));\n}\n\n// hg\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// iq\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return saturate(a + b * cos(6.28318 * (c * t + d)));\n}\n\n// iq\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash31(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nvec3 domainRepeat(vec3 p, vec3 size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\nfloat domainRepeat1D(float p, float size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\n// hg\nvec2 pModPolar(vec2 p, float repetitions) {\n\tfloat angle = 2.0 * 3.1415 / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*r;\n}\n\n// ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \n// ---------------------------------------------------------\n    \nfloat frPlane(vec3 p)\n{\n    return p.y + (clamp(p.x, 0.0, 2.0) * 0.05 + clamp(p.z + .5, 0.0, 1.0) * .1);\n}\n\nconst mat4 tr[45] = mat4[45](\n\tmat4(.999, .0, .055, .0, .0, 1.0, .0, .0, -.055, .0, .999, .0, -1.509, .14, .498, 1.0),\n\tmat4(.795, .934, 2.28, .0, -.491, 1.642, -1.25, .0, -1.401, -.045, 1.732, .0, -.397, -.911, -7.876, 1.0),\n\tmat4(.5, .0, .0, .0, .0, .137, -.104, .0, .0, .029, .489, .0, -.8, -.064, .867, 1.0),\n\tmat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0),\n\tmat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0),\n\tmat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0),\n\tmat4(.788, .097, .425, .0, -.135, .792, .022, .0, -.418, -.073, .795, .0, 1.929, -6.665, -.972, 1.0),\n\tmat4(.203, .084, .048, .0, -.057, .293, -.032, .0, -.028, .013, .407, .0, -.895, .281, 1.418, 1.0),\n\tmat4(.149, .025, -.291, .0, .07, .222, .18, .0, .135, -.143, .228, .0, -.128, .448, .615, 1.0),\n\tmat4(.163, -.007, .238, .0, -.015, .102, .035, .0, -.23, -.012, .166, .0, -.815, .176, -.268, 1.0),\n\tmat4(1.68, -.01, .848, .0, -.871, .133, 1.509, .0, -.276, -.482, .4, .0, -5.624, -1.2, .976, 1.0),\n\tmat4(-1.288, -.085, -1.277, .0, -1.377, .184, 1.044, .0, .314, .457, -.658, .0, 2.367, .783, 2.615, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 1.346, .968, -.74, 1.0),\n\tmat4(.649, .468, -.157, .0, -1.578, .171, .798, .0, .862, -.04, 1.579, .0, .804, -1.56, 3.123, 1.0),\n\tmat4(-.446, -.32, 1.219, .0, -1.751, .078, -.321, .0, .016, -.369, -1.124, .0, -1.128, -.361, -6.142, 1.0),\n\tmat4(1.533, .154, .696, .0, -.87, .377, .718, .0, -.329, -.281, 1.342, .0, -4.104, -1.442, -.118, 1.0),\n\tmat4(1.853, -.102, -.211, .0, .221, -.014, 1.757, .0, -.392, -.489, -.008, .0, -1.772, -1.406, 6.376, 1.0),\n\tmat4(-.556, -.453, -.525, .0, -.17, -.141, 1.687, .0, -1.815, .152, .003, .0, -1.992, -.067, 6.05, 1.0),\n\tmat4(-.943, -.128, .043, .0, -.107, 1.049, .137, .0, -.059, .146, -.94, .0, 1.858, .33, -1.42, 1.0),\n\tmat4(.7, .065, .111, .0, -.117, .263, -.261, .0, -.161, .092, .671, .0, -1.761, -.553, -.067, 1.0),\n\tmat4(1.676, .466, 1.232, .0, -1.862, .058, 1.912, .0, 1.213, -.556, 1.231, .0, -3.822, -1.844, -6.583, 1.0),\n\tmat4(-1.467, .491, -1.337, .0, -1.788, .06, 1.971, .0, 1.549, .534, 1.009, .0, 6.023, -1.973, -.383, 1.0),\n\tmat4(-2.494, -.141, 1.034, .0, .951, .2, 2.324, .0, -.79, .686, -.467, .0, 6.624, -.322, -6.471, 1.0),\n\tmat4(-1.116, -.568, -1.242, .0, -2.513, .31, .163, .0, .432, .334, -2.263, .0, 7.905, .708, 4.921, 1.0),\n\tmat4(-.025, -.278, 1.937, .0, -.454, 1.573, .319, .0, -1.912, -.37, -.101, .0, .038, -4.893, -1.369, 1.0),\n\tmat4(.326, .111, .293, .0, -.106, .197, -.236, .0, -.365, .042, .33, .0, -1.141, -.145, -1.004, 1.0),\n\tmat4(1.01, .023, 1.506, .0, -1.623, .004, .939, .0, .032, -.499, .078, .0, -4.952, -.781, -2.879, 1.0),\n\tmat4(-1.354, .304, -.64, .0, -.774, .034, 1.62, .0, 1.106, .396, .35, .0, 2.953, -1.14, 2.649, 1.0),\n\tmat4(-1.462, -.104, 1.084, .0, .892, .238, 1.325, .0, -.851, .427, -.474, .0, 6.541, .212, -.951, 1.0),\n\tmat4(-1.166, -.349, -.663, .0, -1.442, .328, .007, .0, .463, .142, -1.648, .0, 3.098, 1.04, 2.74, 1.0),\n\tmat4(.024, .494, .28, .0, -1.723, -.028, .764, .0, .829, -.074, 1.579, .0, .498, -2.115, -.172, 1.0),\n\tmat4(.795, .0, -.714, .0, .302, 3.241, .336, .0, .647, -1.512, .721, .0, -.378, -3.143, .939, 1.0),\n\tmat4(.28, .504, 2.966, .0, -.047, 1.821, -.83, .0, -1.66, .033, .523, .0, 1.505, 4.294, -7.819, 1.0),\n\tmat4(.5, .0, .0, .0, .0, .137, -.104, .0, .0, .029, .489, .0, -.805, -.247, .582, 1.0),\n\tmat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0),\n\tmat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0),\n\tmat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0),\n\tmat4(1.43, -.088, -1.481, .0, -.092, 1.769, -.567, .0, .828, .35, 2.494, .0, -1.382, -4.146, -2.058, 1.0),\n\tmat4(.461, .046, -.065, .0, -.193, .102, -.182, .0, -.02, .084, .259, .0, -.378, -.212, .663, 1.0),\n\tmat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0),\n\tmat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.057, -.994, -1.057, 1.0),\n\tmat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.374, .102, 1.328, 1.0)\n);\n\n// Generated with a toy tool I'm developing: https://github.com/mmerchante/sdf-gen-unity\n// It may take some time to compile, sorry about that!\nfloat sdf_simple(vec3 p)\n{\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tfloat stack[12];\n\tvec4 pStack[12];\n\tpStack[0] = vec4(p, 1.0);\n\tpStack[0] = (pStack[0] * vec4(1.0,.98,1.0,1.0));\n\tpStack[1] = pStack[0];\n\tpStack[2] = (tr[0] * pStack[1]);\n\tpStack[2].xz = pModPolar(pStack[2].xz , 8.0);\n\tpStack[3] = (tr[1] * pStack[2]);\n\twsPos = (tr[2] * pStack[3]).xyz;\n\tstack[3] = fBox(wsPos);\n\twsPos = (tr[3] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (tr[4] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (tr[5] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (tr[6] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\tstack[2] = stack[3];\n\tpStack[4] = (tr[7] * pStack[1]);\n\tpStack[5] = pStack[4];\n\tpStack[6] = pStack[5];\n\twsPos = (tr[8] * pStack[6]).xyz;\n\tstack[6] = fBox(wsPos);\n\twsPos = (tr[9] * pStack[6]).xyz;\n\tstack[6] = min(stack[6],fBox(wsPos));\n\twsPos = (tr[10] * pStack[5]).xyz;\n\tstack[5] = max(-stack[6],fBox(wsPos));\n\twsPos = (tr[11] * pStack[4]).xyz;\n\tstack[4] = max(stack[5],frPlane(wsPos));\n\twsPos = (tr[12] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[13] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[14] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[15] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[16] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[17] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[18] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\tstack[1] = min(stack[2],stack[4]);\n\tpStack[7] = (tr[19] * pStack[1]);\n\tpStack[7].xz = pModPolar(pStack[7].xz , 10.0);\n\twsPos = (tr[20] * pStack[7]).xyz;\n\tstack[7] = fBox(wsPos);\n\twsPos = (tr[21] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (tr[22] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (tr[23] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (tr[24] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[7]);\n\tpStack[8] = (tr[25] * pStack[1]);\n\tpStack[8].xz = pModPolar(pStack[8].xz , 5.0);\n\twsPos = (tr[26] * pStack[8]).xyz;\n\tstack[8] = fBox(wsPos);\n\twsPos = (tr[27] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[28] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[29] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[30] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[31] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[8]);\n\tpStack[9] = (tr[32] * pStack[1]);\n\tpStack[9].xz = pModPolar(pStack[9].xz , 6.0);\n\tpStack[10] = (tr[33] * pStack[9]);\n\twsPos = (tr[34] * pStack[10]).xyz;\n\tstack[10] = fBox(wsPos);\n\twsPos = (tr[35] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (tr[36] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (tr[37] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (tr[38] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\tstack[9] = stack[10];\n\tstack[1] = min(stack[1],stack[9]);\n\tpStack[11] = (tr[39] * pStack[1]);\n\twsPos = (tr[40] * pStack[11]).xyz;\n\tstack[11] = fBox(wsPos);\n\twsPos = (tr[41] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (tr[42] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (tr[43] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (tr[44] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[11]);\n\tstack[0] = max(stack[1],dot(pStack[0].xyz - vec3(1.24,.07,2.43), vec3(-.129,-.864,.486)));\n\tstack[0] = max(stack[0],dot(pStack[0].xyz - vec3(-.2,-1.41,1.48), vec3(.107,-.943,-.314)));\n    // ...as if millions of drivers suddenly cried out in terror, and were suddenly silenced\n\treturn stack[0];\n}\n\n// https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;\n    \n    float t1 = sdf_simple(p + e.yxx), t2 = sdf_simple(p + e.xxy);\n    float t3 = sdf_simple(p + e.xyx), t4 = sdf_simple(p + e.yyy);\n    \n    return .25/e.y*(t1 + t2 + t3 + t4 - 4.0 * sdf_simple(p));\n}\n\nCamera GetCamera(vec2 uv, float zoom)\n{\n    float dist = 7.0 / zoom;\n    float time = 2.9 + sin(iTime) * .1;\n    \n    vec3 target = vec3(0.0, 4.45 + sin(iTime * 2.0) * .25, 0.0);\n    vec3 p = vec3(0.0, 10.5, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\nvec3 triplanar(vec3 P, vec3 N)\n{   \n    vec3 Nb = abs(N);\n    \n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\n    \n    vec3 c0 = textureLod(iChannel1, P.xy, 3.0).rgb * Nb.z;\n    vec3 c1 = textureLod(iChannel1, P.yz, 3.0).rgb * Nb.x;\n    vec3 c2 = textureLod(iChannel1, P.xz, 3.0).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvec3 Render(Camera camera, Intersection isect, vec2 uv, vec3 normal)\n{\n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    if(isect.materialID > 0)\n    {        \n        vec3 lPos = camera.origin - camera.left * 6.0 - camera.up * 15.0;\n       // vec3 normal = sdfNormal(p, EPSILON_NORMAL);\n        vec3 toLight = normalize(lPos - p);\n        vec3 lightColor = vec3(.85, .9, 1.0);\n\n        float fakeAO = saturate(sdf_simple(p - camera.direction)  + sdf_simple(p + normal * .25) / .5);\n                \n        vec3 tx = triplanar(p * .6 - p.zzz * .3, normal);\n        tx.r = gain(tx.r, 5.0);\n        \n        float cWidth = mix(.2, .9, saturate(p.y * .125 - .3) * tx.r);\n        float c = saturate(curv(p, cWidth));\n        normal = normalize(normal - vec3(c * .5) + (tx * .25 - .1));\n        \n        float rim = pow(smoothstep(0.0, 1.0, 1.0 - dot(normal, -camera.direction)), 7.0);\n        vec3 H = normalize(toLight - camera.direction);        \n        float specular = pow(max(0.0, dot(H, normal)), 15.0 + tx.r * 7.0);        \n                \n        vec3 glow = mix(vec3(2.5, .15, .15), vec3(1.7, .65, .15), (isect.density) * .05) * (isect.density) * .04;        \n        glow *= smoothstep(.5, 1.0, c) * 1.5 + 1.0;\n        \n        // Fake transmission\n        glow *= 1.0 + pow(exp(-isect.mediumDistance), 2.0) * 4.0;        \n        \n        // Some more noise\n        glow *= gain(fakeAO, 5.0) * tx.r * saturate((.25 - c) / .25);\n        \n        \n        float diffuse = dot(normal, toLight) * (c * .65 + .01) * tx.r; // Very dark        \n        \n        vec3 outColor = lightColor * diffuse * fakeAO;\n        \n        outColor += lightColor * (specular * fakeAO * 2.0 + rim * rim * .1);\n        \n        return outColor + glow;\n    }\n    \n    float vignette = 1.0 - pow(length(uv + hash31(p) * .2) / 2., 2.0);\n    return vec3(.15, .175, .25) * vignette * vignette * .25;\n}\n\nIntersection LoadIntersection(vec2 uv)\n{\n    vec4 d = texture(iChannel2, uv);\n        \n    Intersection isect;\n    isect.totalDistance = d.x;\n    isect.materialID = int(d.y);\n    isect.density = d.z;\n    isect.mediumDistance = d.w;\n    return isect;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rawUV = fragCoord / iResolution.xy;\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    \n    Camera camera = GetCamera(uv, .45);\n    Intersection isect = LoadIntersection(rawUV);\n        \n    vec4 medium = texture(iChannel3, rawUV);\n    vec3 color = Render(camera, isect, uv, medium.yzw);\n    \n    color += vec3(.85, .9, 1.0) * medium.x;\n    \n    uv.y += .45;\n    uv.x -= .1;\n    uv.y += sin(iTime * 2.0) * .035; // synced to cam position, super fake\n \tvec3 glowColor = vec3(1.3, .7, .15);\n    uv *= .5;\n    vec3 fx = glowColor * pow(saturate(1.0 - length(uv * vec2(.75, .9))), 2.0);\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.5, 1.0))), 2.0);\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.25, 7.0))), 2.0) * .25;\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.1, 7.0))), 2.0) * .15;\n    \n    float intensity = pow(texture(iChannel1, vec2(iTime * .03)).r, 4.0);\n    color += fx * fx * fx * intensity * .05;\n    \n    color *= 1.0 + rand(uv) * .1;\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 13154,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/blucaerellius/diablo-3-reaper-of-souls-soundtrack-01-reaper-of-souls-youtube-cvfzhvd4gqq"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------\n// BUF A: SURFACE RAYMARCHING AND FIRE\n// BUF B: MEDIUM RAYMARCHING AND NORMAL ESTIMATION\n// IMAGE: RENDERING AND COMPOSITION\n// ---------------------------------------------------------\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define MAX_STEPS 30\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define FIXED_STEP_SIZE .05\n\n#define MAX_DISTANCE 30.0\n#define MIN_DISTANCE 15.0\n#define EPSILON .02\n#define EPSILON_NORMAL .05\n\n#define MATERIAL_NONE -1\n#define MATERIAL_CRYSTAL 1\n\n// ---------------------------------------------------------\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox(vec3 p) {\n    vec3 d = abs(p) - .5;\n    return length(max(d, 0.0)) + vmax(min(d, 0.0));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\nvec3 domainRepeat(vec3 p, vec3 size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\nfloat domainRepeat1D(float p, float size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\n// hg\nvec2 pModPolar(vec2 p, float repetitions) {\n\tfloat angle = 2.0 * 3.1415 / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*r;\n}\n\n// ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \n// ---------------------------------------------------------\n    \n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random(inout uint seed)\n{\n\tseed = hash(seed);\n\treturn floatConstruct(seed);\n}\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat density(vec3 p)\n{\n    p -= vec3(-2.35, 2.5, 0.0);    \n    pR(p.xz, iTime * .3);\n    \n    vec3 p0 = p;\n    vec3 pp = p;\n    p *= .3;\n    float res = 0.0;\n    \n    pR(p.yz, iTime * .5);\n    \n    // credit to guil for this hybrid fractal:\n    // https://www.shadertoy.com/view/MtX3Ws\n    // Anything can work here, the idea is to warp the fracture cuts\n\tfor (int i = 0; i < 4; ++i) \n    {\n        p = .7 * abs(p) / dot(p,p) - .95;\n        p.yz = csqr(p.yz);\n        p = p.zxy;\n\t}    \n   \n    p = pp + p * .5;\n    \n    float d = 0.0;\n\tuint seed = uint(14041956);\n    \n    // The fractal warping now distorts the planar cuts in meaningful ways ;)\n    // I should unroll the planes...\n\tfor(int i = 0; i < 3; ++i)\n\t{\n        // Folding\n\t\tp.yxz = clamp(p, -1.0, 1.0) * 2.0 - p;\n        \n        vec3 axis = normalize(vec3(random(seed), random(seed) * 2.0, random(seed)) * 2.0 - vec3(1.0));\n        vec3 offset = vec3(0.0, random(seed) * 2.0 - 1.0, 0.0);\n\t\t\n        float proj = dot(p - offset, axis);\n\t\td += smoothstep(.1, .0, abs(proj));\n\t}\n    \n    p0 *= mix(.8, 1.0, sin(iTime * .8) * .5 + .5);\n        \n    d = d * smoothstep(1.5, -1.5, length(p0) - 2.5 - sin(iTime) * .35 + cos(iTime * 234.0) * .1 - sin(iTime * 2376.0) * .05);    \n    d *= sin(p0.y *2.0 + p.y * 4.0 + iTime * 1.0) * .25 + 1.0;\n    \n    d += smoothstep(1.5, -1.5, length(p0) - 2.5) * .4;\n\treturn d * d;\n}\n    \nfloat frPlane(vec3 p)\n{\n    return p.y + (clamp(p.x, 0.0, 2.0) * 0.05 + clamp(p.z + .5, 0.0, 1.0) * .1);\n}\n\nconst mat4 tr[45] = mat4[45](\n\tmat4(.999, .0, .055, .0, .0, 1.0, .0, .0, -.055, .0, .999, .0, -1.509, .14, .498, 1.0),\n\tmat4(.795, .934, 2.28, .0, -.491, 1.642, -1.25, .0, -1.401, -.045, 1.732, .0, -.397, -.911, -7.876, 1.0),\n\tmat4(.5, .0, .0, .0, .0, .137, -.104, .0, .0, .029, .489, .0, -.8, -.064, .867, 1.0),\n\tmat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0),\n\tmat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0),\n\tmat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0),\n\tmat4(.788, .097, .425, .0, -.135, .792, .022, .0, -.418, -.073, .795, .0, 1.929, -6.665, -.972, 1.0),\n\tmat4(.203, .084, .048, .0, -.057, .293, -.032, .0, -.028, .013, .407, .0, -.895, .281, 1.418, 1.0),\n\tmat4(.149, .025, -.291, .0, .07, .222, .18, .0, .135, -.143, .228, .0, -.128, .448, .615, 1.0),\n\tmat4(.163, -.007, .238, .0, -.015, .102, .035, .0, -.23, -.012, .166, .0, -.815, .176, -.268, 1.0),\n\tmat4(1.68, -.01, .848, .0, -.871, .133, 1.509, .0, -.276, -.482, .4, .0, -5.624, -1.2, .976, 1.0),\n\tmat4(-1.288, -.085, -1.277, .0, -1.377, .184, 1.044, .0, .314, .457, -.658, .0, 2.367, .783, 2.615, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 1.346, .968, -.74, 1.0),\n\tmat4(.649, .468, -.157, .0, -1.578, .171, .798, .0, .862, -.04, 1.579, .0, .804, -1.56, 3.123, 1.0),\n\tmat4(-.446, -.32, 1.219, .0, -1.751, .078, -.321, .0, .016, -.369, -1.124, .0, -1.128, -.361, -6.142, 1.0),\n\tmat4(1.533, .154, .696, .0, -.87, .377, .718, .0, -.329, -.281, 1.342, .0, -4.104, -1.442, -.118, 1.0),\n\tmat4(1.853, -.102, -.211, .0, .221, -.014, 1.757, .0, -.392, -.489, -.008, .0, -1.772, -1.406, 6.376, 1.0),\n\tmat4(-.556, -.453, -.525, .0, -.17, -.141, 1.687, .0, -1.815, .152, .003, .0, -1.992, -.067, 6.05, 1.0),\n\tmat4(-.943, -.128, .043, .0, -.107, 1.049, .137, .0, -.059, .146, -.94, .0, 1.858, .33, -1.42, 1.0),\n\tmat4(.7, .065, .111, .0, -.117, .263, -.261, .0, -.161, .092, .671, .0, -1.761, -.553, -.067, 1.0),\n\tmat4(1.676, .466, 1.232, .0, -1.862, .058, 1.912, .0, 1.213, -.556, 1.231, .0, -3.822, -1.844, -6.583, 1.0),\n\tmat4(-1.467, .491, -1.337, .0, -1.788, .06, 1.971, .0, 1.549, .534, 1.009, .0, 6.023, -1.973, -.383, 1.0),\n\tmat4(-2.494, -.141, 1.034, .0, .951, .2, 2.324, .0, -.79, .686, -.467, .0, 6.624, -.322, -6.471, 1.0),\n\tmat4(-1.116, -.568, -1.242, .0, -2.513, .31, .163, .0, .432, .334, -2.263, .0, 7.905, .708, 4.921, 1.0),\n\tmat4(-.025, -.278, 1.937, .0, -.454, 1.573, .319, .0, -1.912, -.37, -.101, .0, .038, -4.893, -1.369, 1.0),\n\tmat4(.326, .111, .293, .0, -.106, .197, -.236, .0, -.365, .042, .33, .0, -1.141, -.145, -1.004, 1.0),\n\tmat4(1.01, .023, 1.506, .0, -1.623, .004, .939, .0, .032, -.499, .078, .0, -4.952, -.781, -2.879, 1.0),\n\tmat4(-1.354, .304, -.64, .0, -.774, .034, 1.62, .0, 1.106, .396, .35, .0, 2.953, -1.14, 2.649, 1.0),\n\tmat4(-1.462, -.104, 1.084, .0, .892, .238, 1.325, .0, -.851, .427, -.474, .0, 6.541, .212, -.951, 1.0),\n\tmat4(-1.166, -.349, -.663, .0, -1.442, .328, .007, .0, .463, .142, -1.648, .0, 3.098, 1.04, 2.74, 1.0),\n\tmat4(.024, .494, .28, .0, -1.723, -.028, .764, .0, .829, -.074, 1.579, .0, .498, -2.115, -.172, 1.0),\n\tmat4(.795, .0, -.714, .0, .302, 3.241, .336, .0, .647, -1.512, .721, .0, -.378, -3.143, .939, 1.0),\n\tmat4(.28, .504, 2.966, .0, -.047, 1.821, -.83, .0, -1.66, .033, .523, .0, 1.505, 4.294, -7.819, 1.0),\n\tmat4(.5, .0, .0, .0, .0, .137, -.104, .0, .0, .029, .489, .0, -.805, -.247, .582, 1.0),\n\tmat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0),\n\tmat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0),\n\tmat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0),\n\tmat4(1.43, -.088, -1.481, .0, -.092, 1.769, -.567, .0, .828, .35, 2.494, .0, -1.382, -4.146, -2.058, 1.0),\n\tmat4(.461, .046, -.065, .0, -.193, .102, -.182, .0, -.02, .084, .259, .0, -.378, -.212, .663, 1.0),\n\tmat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0),\n\tmat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.057, -.994, -1.057, 1.0),\n\tmat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.374, .102, 1.328, 1.0)\n);\n\n// Generated with a toy tool I'm developing: https://github.com/mmerchante/sdf-gen-unity\n// It may take some time to compile, sorry about that!\nfloat sdf_simple(vec3 p)\n{\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tfloat stack[12];\n\tvec4 pStack[12];\n\tpStack[0] = vec4(p, 1.0);\n\tpStack[0] = (pStack[0] * vec4(1.0,.98,1.0,1.0));\n\tpStack[1] = pStack[0];\n\tpStack[2] = (tr[0] * pStack[1]);\n\tpStack[2].xz = pModPolar(pStack[2].xz , 8.0);\n\tpStack[3] = (tr[1] * pStack[2]);\n\twsPos = (tr[2] * pStack[3]).xyz;\n\tstack[3] = fBox(wsPos);\n\twsPos = (tr[3] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (tr[4] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (tr[5] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (tr[6] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\tstack[2] = stack[3];\n\tpStack[4] = (tr[7] * pStack[1]);\n\tpStack[5] = pStack[4];\n\tpStack[6] = pStack[5];\n\twsPos = (tr[8] * pStack[6]).xyz;\n\tstack[6] = fBox(wsPos);\n\twsPos = (tr[9] * pStack[6]).xyz;\n\tstack[6] = min(stack[6],fBox(wsPos));\n\twsPos = (tr[10] * pStack[5]).xyz;\n\tstack[5] = max(-stack[6],fBox(wsPos));\n\twsPos = (tr[11] * pStack[4]).xyz;\n\tstack[4] = max(stack[5],frPlane(wsPos));\n\twsPos = (tr[12] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[13] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[14] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[15] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[16] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[17] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[18] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\tstack[1] = min(stack[2],stack[4]);\n\tpStack[7] = (tr[19] * pStack[1]);\n\tpStack[7].xz = pModPolar(pStack[7].xz , 10.0);\n\twsPos = (tr[20] * pStack[7]).xyz;\n\tstack[7] = fBox(wsPos);\n\twsPos = (tr[21] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (tr[22] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (tr[23] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (tr[24] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[7]);\n\tpStack[8] = (tr[25] * pStack[1]);\n\tpStack[8].xz = pModPolar(pStack[8].xz , 5.0);\n\twsPos = (tr[26] * pStack[8]).xyz;\n\tstack[8] = fBox(wsPos);\n\twsPos = (tr[27] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[28] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[29] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[30] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[31] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[8]);\n\tpStack[9] = (tr[32] * pStack[1]);\n\tpStack[9].xz = pModPolar(pStack[9].xz , 6.0);\n\tpStack[10] = (tr[33] * pStack[9]);\n\twsPos = (tr[34] * pStack[10]).xyz;\n\tstack[10] = fBox(wsPos);\n\twsPos = (tr[35] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (tr[36] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (tr[37] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (tr[38] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\tstack[9] = stack[10];\n\tstack[1] = min(stack[1],stack[9]);\n\tpStack[11] = (tr[39] * pStack[1]);\n\twsPos = (tr[40] * pStack[11]).xyz;\n\tstack[11] = fBox(wsPos);\n\twsPos = (tr[41] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (tr[42] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (tr[43] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (tr[44] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[11]);\n\tstack[0] = max(stack[1],dot(pStack[0].xyz - vec3(1.24,.07,2.43), vec3(-.129,-.864,.486)));\n\tstack[0] = max(stack[0],dot(pStack[0].xyz - vec3(-.2,-1.41,1.48), vec3(.107,-.943,-.314)));\n    // ...as if millions of drivers suddenly cried out in terror, and were suddenly silenced\n\treturn stack[0];\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf_simple(p + eps.xzz) - sdf_simple(p + eps.yzz);\n\tfloat dY = sdf_simple(p + eps.zxz) - sdf_simple(p + eps.zyz);\n\tfloat dZ = sdf_simple(p + eps.zzx) - sdf_simple(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nint SampleMaterial(vec3 p)\n{\n    // We only have one material\n    return MATERIAL_CRYSTAL;\n}\n\nCamera GetCamera(vec2 uv, float zoom)\n{\n    float dist = 7.0 / zoom;\n    float time = 2.9 + sin(iTime) * .1;\n    \n    vec3 target = vec3(0.0, 4.45 + sin(iTime * 2.0) * .25, 0.0);\n    vec3 p = vec3(0.0, 10.5, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.materialID = MATERIAL_NONE;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf_simple(p);\n        \n\t\toutData.totalDistance += outData.sdf;\n        \n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n        \n    // INNER MEDIUM\n    if(outData.sdf < EPSILON)\n    {\n        float t = FIXED_STEP_SIZE;\n        float d = 0.0;\n        \n        vec3 hitPosition = camera.origin + camera.direction * (outData.totalDistance + FIXED_STEP_SIZE);\n        \n        vec3 normal = sdfNormal(hitPosition, .1);\n        vec3 refr = refract(camera.direction, normal, .35);\n        \n        for(int i = 0; i < 25; ++i)\n        {            \n            vec3 p = hitPosition + refr * t;\n            \n            if(sdf_simple(p) > EPSILON)\n                break;\n            \n            d += density(p);\n            t += FIXED_STEP_SIZE;\n        }\n        \n        outData.density = d;\n\t\toutData.materialID = SampleMaterial(camera.origin + camera.direction * outData.totalDistance);\n    \toutData.totalDistance *= .99;\n        outData.mediumDistance = t;\n    }\n    return outData;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;    \n    Camera camera = GetCamera(uv, .45);\n    Intersection isect = Raymarch(camera);\n    \n\tfragColor = vec4(isect.totalDistance, isect.materialID, isect.density, isect.mediumDistance);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------\n// BUF A: SURFACE RAYMARCHING AND FIRE\n// BUF B: MEDIUM RAYMARCHING AND NORMAL ESTIMATION\n// IMAGE: RENDERING AND COMPOSITION\n// ---------------------------------------------------------\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define MAX_STEPS 30\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define FIXED_STEP_SIZE .05\n\n#define MAX_DISTANCE 30.0\n#define MIN_DISTANCE 15.0\n#define EPSILON .02\n#define EPSILON_NORMAL .05\n\n#define MATERIAL_NONE -1\n#define MATERIAL_CRYSTAL 1\n\n// ---------------------------------------------------------\n\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox(vec3 p) {\n    vec3 d = abs(p) - .5;\n    return length(max(d, 0.0)) + vmax(min(d, 0.0));\n}\n\n// hg\nvec2 pModPolar(vec2 p, float repetitions) {\n\tfloat angle = 2.0 * 3.1415 / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*r;\n}\n\n// ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \n// ---------------------------------------------------------    \n    \nfloat frPlane(vec3 p)\n{\n    return p.y + (clamp(p.x, 0.0, 2.0) * 0.05 + clamp(p.z + .5, 0.0, 1.0) * .1);\n}\n\nconst mat4 tr[45] = mat4[45](\n\tmat4(.999, .0, .055, .0, .0, 1.0, .0, .0, -.055, .0, .999, .0, -1.509, .14, .498, 1.0),\n\tmat4(.795, .934, 2.28, .0, -.491, 1.642, -1.25, .0, -1.401, -.045, 1.732, .0, -.397, -.911, -7.876, 1.0),\n\tmat4(.5, .0, .0, .0, .0, .137, -.104, .0, .0, .029, .489, .0, -.8, -.064, .867, 1.0),\n\tmat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0),\n\tmat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0),\n\tmat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0),\n\tmat4(.788, .097, .425, .0, -.135, .792, .022, .0, -.418, -.073, .795, .0, 1.929, -6.665, -.972, 1.0),\n\tmat4(.203, .084, .048, .0, -.057, .293, -.032, .0, -.028, .013, .407, .0, -.895, .281, 1.418, 1.0),\n\tmat4(.149, .025, -.291, .0, .07, .222, .18, .0, .135, -.143, .228, .0, -.128, .448, .615, 1.0),\n\tmat4(.163, -.007, .238, .0, -.015, .102, .035, .0, -.23, -.012, .166, .0, -.815, .176, -.268, 1.0),\n\tmat4(1.68, -.01, .848, .0, -.871, .133, 1.509, .0, -.276, -.482, .4, .0, -5.624, -1.2, .976, 1.0),\n\tmat4(-1.288, -.085, -1.277, .0, -1.377, .184, 1.044, .0, .314, .457, -.658, .0, 2.367, .783, 2.615, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 1.346, .968, -.74, 1.0),\n\tmat4(.649, .468, -.157, .0, -1.578, .171, .798, .0, .862, -.04, 1.579, .0, .804, -1.56, 3.123, 1.0),\n\tmat4(-.446, -.32, 1.219, .0, -1.751, .078, -.321, .0, .016, -.369, -1.124, .0, -1.128, -.361, -6.142, 1.0),\n\tmat4(1.533, .154, .696, .0, -.87, .377, .718, .0, -.329, -.281, 1.342, .0, -4.104, -1.442, -.118, 1.0),\n\tmat4(1.853, -.102, -.211, .0, .221, -.014, 1.757, .0, -.392, -.489, -.008, .0, -1.772, -1.406, 6.376, 1.0),\n\tmat4(-.556, -.453, -.525, .0, -.17, -.141, 1.687, .0, -1.815, .152, .003, .0, -1.992, -.067, 6.05, 1.0),\n\tmat4(-.943, -.128, .043, .0, -.107, 1.049, .137, .0, -.059, .146, -.94, .0, 1.858, .33, -1.42, 1.0),\n\tmat4(.7, .065, .111, .0, -.117, .263, -.261, .0, -.161, .092, .671, .0, -1.761, -.553, -.067, 1.0),\n\tmat4(1.676, .466, 1.232, .0, -1.862, .058, 1.912, .0, 1.213, -.556, 1.231, .0, -3.822, -1.844, -6.583, 1.0),\n\tmat4(-1.467, .491, -1.337, .0, -1.788, .06, 1.971, .0, 1.549, .534, 1.009, .0, 6.023, -1.973, -.383, 1.0),\n\tmat4(-2.494, -.141, 1.034, .0, .951, .2, 2.324, .0, -.79, .686, -.467, .0, 6.624, -.322, -6.471, 1.0),\n\tmat4(-1.116, -.568, -1.242, .0, -2.513, .31, .163, .0, .432, .334, -2.263, .0, 7.905, .708, 4.921, 1.0),\n\tmat4(-.025, -.278, 1.937, .0, -.454, 1.573, .319, .0, -1.912, -.37, -.101, .0, .038, -4.893, -1.369, 1.0),\n\tmat4(.326, .111, .293, .0, -.106, .197, -.236, .0, -.365, .042, .33, .0, -1.141, -.145, -1.004, 1.0),\n\tmat4(1.01, .023, 1.506, .0, -1.623, .004, .939, .0, .032, -.499, .078, .0, -4.952, -.781, -2.879, 1.0),\n\tmat4(-1.354, .304, -.64, .0, -.774, .034, 1.62, .0, 1.106, .396, .35, .0, 2.953, -1.14, 2.649, 1.0),\n\tmat4(-1.462, -.104, 1.084, .0, .892, .238, 1.325, .0, -.851, .427, -.474, .0, 6.541, .212, -.951, 1.0),\n\tmat4(-1.166, -.349, -.663, .0, -1.442, .328, .007, .0, .463, .142, -1.648, .0, 3.098, 1.04, 2.74, 1.0),\n\tmat4(.024, .494, .28, .0, -1.723, -.028, .764, .0, .829, -.074, 1.579, .0, .498, -2.115, -.172, 1.0),\n\tmat4(.795, .0, -.714, .0, .302, 3.241, .336, .0, .647, -1.512, .721, .0, -.378, -3.143, .939, 1.0),\n\tmat4(.28, .504, 2.966, .0, -.047, 1.821, -.83, .0, -1.66, .033, .523, .0, 1.505, 4.294, -7.819, 1.0),\n\tmat4(.5, .0, .0, .0, .0, .137, -.104, .0, .0, .029, .489, .0, -.805, -.247, .582, 1.0),\n\tmat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0),\n\tmat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0),\n\tmat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0),\n\tmat4(1.43, -.088, -1.481, .0, -.092, 1.769, -.567, .0, .828, .35, 2.494, .0, -1.382, -4.146, -2.058, 1.0),\n\tmat4(.461, .046, -.065, .0, -.193, .102, -.182, .0, -.02, .084, .259, .0, -.378, -.212, .663, 1.0),\n\tmat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0),\n\tmat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.057, -.994, -1.057, 1.0),\n\tmat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0),\n\tmat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.374, .102, 1.328, 1.0)\n);\n\n// Generated with a toy tool I'm developing: https://github.com/mmerchante/sdf-gen-unity\n// It may take some time to compile, sorry about that!\nfloat sdf_simple(vec3 p)\n{\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tfloat stack[12];\n\tvec4 pStack[12];\n\tpStack[0] = vec4(p, 1.0);\n\tpStack[0] = (pStack[0] * vec4(1.0,.98,1.0,1.0));\n\tpStack[1] = pStack[0];\n\tpStack[2] = (tr[0] * pStack[1]);\n\tpStack[2].xz = pModPolar(pStack[2].xz , 8.0);\n\tpStack[3] = (tr[1] * pStack[2]);\n\twsPos = (tr[2] * pStack[3]).xyz;\n\tstack[3] = fBox(wsPos);\n\twsPos = (tr[3] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (tr[4] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (tr[5] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (tr[6] * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\tstack[2] = stack[3];\n\tpStack[4] = (tr[7] * pStack[1]);\n\tpStack[5] = pStack[4];\n\tpStack[6] = pStack[5];\n\twsPos = (tr[8] * pStack[6]).xyz;\n\tstack[6] = fBox(wsPos);\n\twsPos = (tr[9] * pStack[6]).xyz;\n\tstack[6] = min(stack[6],fBox(wsPos));\n\twsPos = (tr[10] * pStack[5]).xyz;\n\tstack[5] = max(-stack[6],fBox(wsPos));\n\twsPos = (tr[11] * pStack[4]).xyz;\n\tstack[4] = max(stack[5],frPlane(wsPos));\n\twsPos = (tr[12] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[13] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[14] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[15] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[16] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[17] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (tr[18] * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\tstack[1] = min(stack[2],stack[4]);\n\tpStack[7] = (tr[19] * pStack[1]);\n\tpStack[7].xz = pModPolar(pStack[7].xz , 10.0);\n\twsPos = (tr[20] * pStack[7]).xyz;\n\tstack[7] = fBox(wsPos);\n\twsPos = (tr[21] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (tr[22] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (tr[23] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (tr[24] * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[7]);\n\tpStack[8] = (tr[25] * pStack[1]);\n\tpStack[8].xz = pModPolar(pStack[8].xz , 5.0);\n\twsPos = (tr[26] * pStack[8]).xyz;\n\tstack[8] = fBox(wsPos);\n\twsPos = (tr[27] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[28] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[29] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[30] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (tr[31] * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[8]);\n\tpStack[9] = (tr[32] * pStack[1]);\n\tpStack[9].xz = pModPolar(pStack[9].xz , 6.0);\n\tpStack[10] = (tr[33] * pStack[9]);\n\twsPos = (tr[34] * pStack[10]).xyz;\n\tstack[10] = fBox(wsPos);\n\twsPos = (tr[35] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (tr[36] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (tr[37] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (tr[38] * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\tstack[9] = stack[10];\n\tstack[1] = min(stack[1],stack[9]);\n\tpStack[11] = (tr[39] * pStack[1]);\n\twsPos = (tr[40] * pStack[11]).xyz;\n\tstack[11] = fBox(wsPos);\n\twsPos = (tr[41] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (tr[42] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (tr[43] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (tr[44] * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[11]);\n\tstack[0] = max(stack[1],dot(pStack[0].xyz - vec3(1.24,.07,2.43), vec3(-.129,-.864,.486)));\n\tstack[0] = max(stack[0],dot(pStack[0].xyz - vec3(-.2,-1.41,1.48), vec3(.107,-.943,-.314)));\n    // ...as if millions of drivers suddenly cried out in terror, and were suddenly silenced\n\treturn stack[0];\n}\n    \nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf_simple(p + eps.xzz) - sdf_simple(p + eps.yzz);\n\tfloat dY = sdf_simple(p + eps.zxz) - sdf_simple(p + eps.zyz);\n\tfloat dZ = sdf_simple(p + eps.zzx) - sdf_simple(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\n// Generated with a toy tool I'm developing: https://github.com/mmerchante/sdf-gen-unity\n// It's unfinished, and may take some time to compile, sorry about that!\nfloat sdf_generated(vec3 p)\n{\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tfloat stack[2];\n\tvec3 pStack[2];\n\tpStack[0] = p;\n\twsPos = (mat4(.16, .0, .0, .0, .0, .16, .0, .0, .0, .0, .16, .0, -.348, .149, .329, 1.0) * vec4(pStack[0], 1.0)).xyz;\n\tstack[0] = length(wsPos) - .5;\n\tpStack[1] = (pStack[0] * vec3(1.022,.646,1.022)) - vec3(2.043,-5.67,-1.398);\n\tpStack[1].xz = pModPolar(pStack[1].xz , 13.0);\n\twsPos = (mat4(.628, -.065, .15, .0, .366, .113, -.138, .0, -.039, .023, 1.116, .0, -2.524, .342, -.263, 1.0) * vec4(pStack[1], 1.0)).xyz;\n\tstack[1] = fBox(wsPos);\n\tstack[0] = min( stack[0],stack[1]);\n\twsPos = (mat4(.111, .0, .0, .0, .0, .111, .0, .0, .0, .0, .111, .0, -.242, 1.23, .228, 1.0) * vec4(pStack[0], 1.0)).xyz;\n\tstack[0] = min( stack[0],length(wsPos) - .05);\n\treturn stack[0];\n}\n\n\nfloat outerDensity(vec3 p)\n{   \n    float d = 0.0;\n    \n    for(int i = 0; i < 5; ++i)\n        d += smoothstep(-1.5, 1.5, sdf_generated(p + vec3(0.0, -5.0 + float(i) * 3.5, 0.0))) * .05;\n    \n    p.y -= 4.5;\n    d *= smoothstep(10.0, -10.0, length(p) - 17.0);\n    \n    return d;\n}\n\nfloat RaymarchMedium(Camera camera, float surfaceDistance)\n{    \n    float d = 0.0;\n        \n\tfor(int j = 0; j < 25; ++j)\n\t{\n        float dist = 14.0 + float(j) * .5;\n                \n        d += outerDensity(camera.origin + camera.direction * dist);        \n\t}\n    \n    return d;\n}\n\nCamera GetCamera(vec2 uv, float zoom)\n{\n    float dist = 7.0 / zoom;\n    float time = 2.9 + sin(iTime) * .1;\n    \n    vec3 target = vec3(0.0, 4.45 + sin(iTime * 2.0) * .25, 0.0);\n    vec3 p = vec3(0.0, 10.5, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\nIntersection LoadIntersection(vec2 uv)\n{\n    vec4 d = texture(iChannel0, uv);\n        \n    Intersection isect;\n    isect.totalDistance = d.x;\n    isect.materialID = int(d.y);\n    isect.density = d.z;\n    return isect;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rawUV = fragCoord / iResolution.xy;\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n        \n    Camera camera = GetCamera(uv, .45);    \n    Intersection isect = LoadIntersection(rawUV);\n    float density = RaymarchMedium(camera, isect.totalDistance);\n    \n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n\tfragColor = vec4(saturate(log(density * .25)), sdfNormal(p, EPSILON_NORMAL));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}