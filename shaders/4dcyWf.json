{
    "Shader": {
        "info": {
            "date": "1520340726",
            "description": "multiple importance sampled next event estimation path tracer. Using BRDF importance sampling.",
            "flags": 32,
            "hasliked": 0,
            "id": "4dcyWf",
            "likes": 0,
            "name": "MIS direct lighting",
            "published": 3,
            "tags": [
                "brdfpathtracing"
            ],
            "usePreview": 0,
            "username": "dtoadq",
            "viewed": 653
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 r = pow(clamp(texture(iChannel1, uv), vec4(0.0), vec4(1.0)), vec4(1.0/2.2));\n    \n    if ( r.w == 0.0 ) r = vec4(0.3, 0.1, 0.3, 1.0);\n    \n    fragColor =  r;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SAMPLES 256.0\n#define COLLECT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 xy = gl_FragCoord.xy/iResolution.xy;\n  float f_delta = float(iFrame) - texture(iChannel2, vec2(0.5)).z;\n\n  vec4 c0 = texture(iChannel0, xy),\n       c1 = texture(iChannel1, xy);\n\n  if ( f_delta <= 1.0 ) {\n    c1 = fragColor = vec4(0.0);\n  }\n    \n  #ifndef COLLECT\n    if ( c0.w != 0.0 )\n      fragColor = vec4(c0.xyz, 1.0);\n  #else\n  if ( c0.w == 0.0 || c1.w >= 1.0 ) { // miss/end\n    fragColor = c1;\n  } else {\n    float t = c1.w*SAMPLES; // 0.01 => 1.0, 1.0 => 100.0\n    fragColor.xyz = mix(c0.xyz, c1.xyz, (t/(t+1.0)));\n    fragColor.w = c1.w+(1.0/SAMPLES);\n  }\n  #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 old = texture(iChannel0, uv);\n    \n    if( iMouse.z > 0.0 )\n        old = vec4( (iMouse.z-iMouse.x)/100.0 ,\n                    (iMouse.w-iMouse.y)/250.0 , float(iFrame) , 0.0);\n    \n    fragColor = old;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//------------------------------------------------------------------------------\n//-------- SETTINGS (FOR UTILITY LIBRARY) --------------------------------------\n\n// more paths = higher accuracy, better visuals, more effects, etc.\n// Probably need at least 5 for translucent materials.\n#define ITERS 3\n// Uncomment below to have light move along with scene (you have to undefine\n// collect in Buf c)\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//-------- UTILITY LIBRARY -----------------------------------------------------\n//------------------------------------------------------------------------------\n#define float4 vec4\n#define float3 vec3\n#define float2 vec2\n#define f4 vec4\n#define f3 vec3\n#define f2 vec2\n\nfloat sqr ( in float t ) { return t*t; }\n\n// DINPUT(iMouse.w) .. set w/ iMouse.w using plugin .. DINPUT(constant)\n#define DINPUT(w) (w/288.0)\n\n#define PI   3.141592653589793\n#define IPI  0.318309886183791\n#define IPI2 0.159154943091895\n#define TAU  6.283185307179586\n#define ITAU 0.159154943091895\n\n#define SQR(X) ((X)*(X))\n\n#define MOUSEX (iMouse.x/iResolution.x)\n#define MOUSEY (iMouse.y/iResolution.y)\n\nuniform vec3 u_eye3d;\nuniform vec3 u_centre3d;\nuniform vec3 u_up3d;\n\nstruct Ray { float3 ori, dir; };\n\nfloat2 Map ( float3 o );\n\nfloat2 March ( in Ray ray ) {\n  float dist = 0.0;\n  float2 cur;\n  for ( int i = 0; i != 128; ++ i ) {\n    cur = Map(ray.ori + ray.dir*dist);\n    if ( cur.x <= 0.0005 || dist > 256.0 ) break;\n    dist += cur.x;\n  }\n  if ( dist > 256.0 || dist < 0.0 ) return float2(-1.0);\n  return float2(dist, cur.y);\n}\n\nfloat3 Normal ( float3 p ) {\n  float2 e = float2(1.0, -1.0)*0.001;\n  return normalize(\n                   e.xyy*Map(p + e.xyy).x +\n                   e.yyx*Map(p + e.yyx).x +\n                   e.yxy*Map(p + e.yxy).x +\n                   e.xxx*Map(p + e.xxx).x);\n}\n\nfloat lengthn ( in float3 p, in float n ) {\n  return pow(pow(p.x, n) + pow(p.y, n) + pow(p.z, n), (1.0/n));\n}\n\nfloat lengthn ( in float2 p, in float n ) {\n  return pow(pow(p.x, n) + pow(p.y, n), (1.0/n));\n}\n\nvoid Union ( inout float2 t, float d, in float ID ) {\n  if ( t.x > d ) t = float2(d, ID);\n}\n\n//------------------------------------------------------------------------------\n//-------- HG SDF --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nfloat vmax ( float2 v ) { return max(v.x, v.y); }\nfloat vmax ( float3 v ) { return max(max(v.x, v.y), v.z); }\nfloat vmax ( float4 v ) { return max(max(v.x, v.y), max(v.z, v.w)); }\nfloat vmin ( float2 v ) { return min(v.x, v.y); }\nfloat vmin ( float3 v ) { return min(min(v.x, v.y), v.z); }\nfloat vmin ( float4 v ) { return min(min(v.x, v.y), min(v.z, v.w)); }\n\nfloat  sgn ( float x  ) { return (x<0.0) ? -1.0 : 1.0; }\nfloat2 sgn ( float2 v ) { return float2(sgn(v.x), sgn(v.y)); }\nfloat3 sgn ( float3 v ) { return float3(sgn(v.x), sgn(v.y), sgn(v.z)); }\n\nfloat sdSphere ( in float3 O, in float R ) { return length(O) - R; }\nfloat sdShell  ( in float  D, in float R ) { return abs(D) - R*0.5; }\nfloat sdPlane  ( in float3 O, in float3 N, in float D ) {\n  return dot(O, N) + D;\n}\n\nfloat sdBox ( float3 O, float3 b ) {\n  float3 d = abs(O) - b;\n  return length(max(d, float3(0.0))) + vmax(min(d, float3(0.0)));\n}\nfloat sdCheap2DBox ( float2 O, float2 b ) { return vmax(abs(O) - b); }\n\nfloat sdHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.0)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Cone with correct distances to tip and base circle. Y is up,\n// 0 is in the middle of the base.\nfloat sdCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(lengthn(p.xz, 8.0), p.y);\n\tvec2 tip = q - vec2(0.0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.0)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0.0)));\n\t}\n\treturn d;\n}\n\nfloat sdCylinder ( in float3 O, in float r, in float height ) {\n  float d = length(O.xz) - r;\n  d = max(d, abs(O.y) - height);\n  return d;\n}\n\nvoid opRotate(inout float2 p, in float a ) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opUnionChamfer ( in float a, in float b, in float r ) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// repeat around the origin by a fixed angle.\nfloat opModPolar ( inout float2 p, float repetitions ) {\n  float angle = 2.0*PI/repetitions,\n        a = atan(p.y, p.x) + angle/2.0,\n        r = length(p),\n        c = floor(a/angle);\n  a = mod(a, angle) - angle/2.0;\n  p = float2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x dir,\n  // (cell index would be -5 and 5 in two halves of the cell)\n  if ( abs(c) >= (repetitions/2.0) ) c = abs(c);\n  return c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative\n// half-space is unchanged.\nfloat opModSingle1(inout float p, in float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif ( p >= 0.0 )\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// mirror every second cell so they match at boundaries\nfloat opModMirror1 ( inout float p, float size ) {\n  float halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2.0 - 1.0;\n\treturn c;\n}\n\n// mirror at an axis-align plane which is at a dist from origin\nfloat opMirror ( inout float p, float dist ) {\n  float s = sgn(p);\n  p = abs(p) - dist;\n  return s;\n}\n\n// reflect space at a plane\nfloat opReflect ( inout float3 p, float3 plane_normal, float offset ) {\n  float t = dot(p, plane_normal) + offset;\n  if ( t < 0.0 )\n    p = p - (2.0*t)*plane_normal;\n  return sgn(t);\n}\n\n//------------------------------------------------------------------------------\n//-------- RANDOM --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nfloat Sample_Uniform(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 Sample_Uniform2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*\n                vec2(43758.5453123,22578.1459123));\n}\n\nvec3 Sample_Uniform3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*\n                 vec3(43758.5453123,22578.1459123,842582.632592));\n}\n\n// -----------------------------------------------------------------------------\n// ------- SAMPLERS ------------------------------------------------------------\n// -----------------------------------------------------------------------------\n\nvoid Calculate_XY ( in float3 N, inout float3 binormal, inout float3 bitangent){\n  binormal = vec3(1.0, 0.0, 0.0) ;\n  binormal = normalize(cross(N, binormal));\n  bitangent = cross(binormal, N);\n}\n\nvec3 Reorient_Hemisphere ( vec3 wo, vec3 N ) {\n  float3 binormal, bitangent;\n  Calculate_XY(N, binormal, bitangent);\n  return bitangent*wo.x + binormal*wo.y + wo.z*N;\n}\n\nfloat PDF_Cosine_Hemisphere ( float3 wi, float3 N ) {\n  return abs(dot(wi, N)) * IPI;\n}\n\nfloat3 To_Cartesian_T ( float theta, float phi ) {\n  return float3(cos(phi)*sin(theta), sin(phi)*sin(theta), cos(theta));\n}\nfloat3 To_Cartesian ( float cos_theta, float phi ) {\n  float sin_theta = sqrt(max(0.0, 1.0 - cos_theta));\n  return float3(cos(phi)*sin_theta, sin(phi)*sin_theta, cos_theta);\n}\n\nvec3 Sample_Cos_Hemisphere ( float3 wi, float3 N, out float pdf,\n                             inout float seed ) {\n  vec2 u = Sample_Uniform2(seed);\n  float3 wo = Reorient_Hemisphere(\n                normalize(To_Cartesian(sqrt(u.y), TAU*u.x)), N);\n  pdf = PDF_Cosine_Hemisphere(wo, N);\n  return wo;\n}\n\nfloat PDF_Cone ( float lobe ) {\n  if ( lobe < 0.001 ) return 1.0;\n  return (TAU*SQR(sin(0.5*lobe)));\n}\n\nfloat3 Sample_Uniform_Cone ( float lobe, out float pdf, inout float seed ) {\n  float2 u = Sample_Uniform2(seed);\n  float phi = TAU*u.x,\n        cos_theta = 1.0 - u.y*(1.0 - cos(lobe));\n  pdf = PDF_Cone(lobe);\n  return To_Cartesian(cos_theta, phi);\n}\n\nfloat2 Normal_Sampler ( in sampler2D s, in float2 uv ) {\n  float2 eps = float2(0.003, 0.0);\n  return float2(length(texture(s, uv+eps.xy)) - length(texture(s, uv-eps.xy)),\n                length(texture(s, uv+eps.yx)) - length(texture(s, uv-eps.yx)));\n}\n\n// -- camera --\n\nmat3 Look_At ( in float3 N ) {\n  float3 ww = normalize(N),\n         uu = normalize(cross(float3(0.0, 1.0, 0.0), ww)),\n         vv = normalize(cross(ww, uu));\n  return mat3(ww, uu, vv);\n}\n\nfloat3 RCamera_Origin ( in float2 uv );\nRay Look_At ( float2 uv, in float seed ) {\n  //----camera origin\n  #if 0\n    float3 ori = RCamera_Origin(vec2(iTime, iTime*0.5)*0.25);\n  #else\n    float3 ori = RCamera_Origin(vec2(MOUSEX, MOUSEY)*2.0-1.0);\n  #endif\n  //----etc\n  float3 center = float3(0.0, 0.0, 0.0);\n  float3 up     = float3(0.0, 1.0, 0.0);\n  mat3 LA = Look_At(normalize(center-ori));\n  LA = mat3(LA[2], LA[1], LA[0]);\n  uv += (Sample_Uniform2(seed) - 0.5)*2.0*(1.0/iResolution.xy);\n  return Ray(ori, normalize((LA)*float3(uv.y, uv.x, 1.5)));\n}\n\nmat3 Rotate_X ( in float gamma ) {\n  return mat3(1.0, 0.0      , 0.0        ,\n              0.0, cos(gamma), -sin(gamma) ,\n              0.0, sin(gamma),  cos(gamma));\n}\n\nmat3 Rotate_Y ( in float beta ) {\n  return mat3(cos(beta) , 0.0 , sin(beta),\n              0.0      , 1.0 , 0.0     ,\n              -sin(beta), 0.0 , cos(beta));\n}\n\nmat3 Rotate_Z ( in float alpha ) {\n  return mat3(cos(alpha), -sin(alpha), 0.0 ,\n              sin(alpha), cos(alpha) , 0.0 ,\n              0.0      , 0.0       , 1.0);\n}\n#define GTIME (MOUSEX+MOUSEY*0.5)\n//------------------------------------------------------------------------------\n//-------- LIGHTS/MATERIALS ----------------------------------------------------\n//------------------------------------------------------------------------------\n\nfloat3 RCamera_Origin ( in float2 uv ) {\n  return float3(8.0*-cos(uv.x*4.0),\n                3.0+0.6*sin(uv.y),\n                8.0*-sin(uv.x*4.0));\n}\n\nstruct Light {\n  float3 ori, N, emi;\n  float2 radius;\n};\n\n#define LIGHTS_LEN 2\n#define LIGHT_IDX(fl) int(fl - 100.0)\nLight lights[LIGHTS_LEN];\n\nvoid Construct_Light ( int idx, float3 ori, float3 N, float3 emi,\n                       float2 radius ) {\n  lights[idx] = Light(ori, N, emi, radius);\n}\n\nvoid Initialize_Lights ( ) {\n  float3 O; float3 P;\n  float time = GTIME*2.5;\n  O = float3(cos(time)*5.0, 2.0, sin(time)*5.0);\n  P = normalize(float3(cos(time), 1.5+sin(time)*2.5,\n                sin(time)+sin(time)*2.5));\n  Construct_Light(0, O, P, float3(1.0), float2(0.5, 0.5));\n  O.xz *= -1.0;\n  // P.xz = P.zx;\n  P.xz *= -1.0;\n  P.x += cos(time)*0.2;\n  P.y = sin(time)*0.2;\n  float tint = 0.5 + sin(time*2.0)*0.5;\n  Construct_Light(1, O, normalize(P),\n                  tint*float3(10.0, 1.0, 10.0+sin(time*5.0)*5.0),\n                  float2(0.5, 1.5));\n}\n\nfloat3 Sample_Emitter ( int I, float3 O, inout float seed ) {\n  float3 lorig = normalize((Sample_Uniform3(seed)-0.5)*2.0);\n  lorig *= float3(0.01, lights[I].radius);\n  lorig = inverse(Look_At(lights[I].N))*lorig;\n  lorig += lights[I].ori;\n  return normalize(lorig - O);\n}\n\nfloat REmit_PDF ( int I, float3 On, float3 wo, float dist ) {\n  float SA = length(lights[I].radius);\n  return ((1.0/SA) * (abs(dot(lights[I].N, wo)*dot(On, wo))))/SQR(dist);\n}\n\nbool Valid_Emitter ( int I, in float3 wo ) {\n  if ( I < 0 ) return false;\n  return dot(lights[I].N, wo) > 0.0;\n}\n\nstruct Material {\n  float3 colour;\n  float alpha, diffuse, transmittive, fresnel;\n};\n\n// RMTAG\nMaterial RMaterial ( float3 O, float idx ) {\n  if ( idx == 7.0 ) {\n    float3 N = normalize(O);\n    float2 uv = float2(atan(N.x, N.z)/TAU+0.0, N.y*0.5+0.5);\n    return Material(texture(iChannel0, uv*1.0).xyz, 1.0, 1.0, 0.0, 4.0);\n  }\n  if ( idx == 7.5 ) {\n    float2 uv = float2(O.x, O.z);\n    return Material(texture(iChannel0, uv*0.1).xyz, 0.2, 0.1, 0.0, 1.2);\n  }\n   if ( idx == 7.7 ) {\n    float2 uv = float2(O.x, O.z);\n    return Material(vec3(0.6f, 0.9f, 0.95f), 0.001, 0.00, 0.0, 1.2);\n  }\n  //--\n  if ( idx == 1.0 )\n    return Material(float3(0.3, 0.6, 0.4), 0.3, 0.01, 0.0, 1.3);\n  if ( idx == 1.5 )\n    return Material(float3(1.0), 0.5, 0.01, 0.0, 2.2);\n  if ( idx == 2.0 )\n    return Material(float3(0.2, 0.1, 0.3), 0.2, 0.02, 0.0, 2.0);\n  if ( idx == 4.0 )\n      return Material(float3(1.0), 0.3, 0.0, 0.4, 1.0);\n  if ( idx == 100.0 )\n    return Material(float3(lights[0].emi), 1.0, 1.0, 0.0, 1.5);\n}\n\n//------------------------------------------------------------------------------\n//-------- SHADER --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nfloat2 Map ( in vec3 O ) {\n  float3 o=O, ori=O;\n  float2 res = float2(999.0);\n\n  // opRotate(O.xz, t*0.05);\n  O += vec3(0.0, 0.0, 1.5);\n  float blah = -log(exp(-4.0*sdHexagonCircumcircle(O, vec2(0.5, 1.0))) +\n                    exp(-1.0*sdSphere(O, 1.0)));;\n  blah += dot(texture(iChannel0, O.xz),\n              texture(iChannel0, O.zy))*0.05;\n  Union(res, blah*0.25, 1.0);\n  blah = sdSphere(O - vec3(1.8, 0.2, 2.5), 1.5);\n  Union(res, blah*0.5, 1.5);\n  opRotate(O.xy, PI/2.0 - PI/4.0);\n  blah = sdBox(O - vec3(0.0, -0.8, 2.5),\n                   float3(1.25, 0.5, 0.8));\n  blah += length(texture(iChannel1, O.xz))*0.1;\n  Union(res, blah*0.5, 2.0);\n\n  O=ori;\n  blah = sdSphere(O-vec3(0.0, 1.0, 0.0), 1.0);\n  //Union(res, sdShell(blah, 0.005)*0.5, 4.0);\n  float s = sdShell(sdSphere(O, 10.0), 0.01)*0.5;\n  Union(res, s, 7.0);\n  O=ori;\n  float2 uv = float2(O.x, O.z);\n  O.y += length(texture(iChannel0, uv*0.1).xyz)*0.05;\n  float d = sdPlane(O, float3(0.0, 1.0, 0.0), 1.0);\n  Union(res, d, 7.5);\n    \n // O=ori;\n  O.y += sin(O.x*2.0)*0.2f + cos((25.32f+O.x)*42.0f)*0.01f;\n  Union(res, sdPlane(O, vec3(0.0, 1.0, 0.0), 0.5), 7.7);\n    \n  //-----------light--------\n  for ( int i = 0; i != LIGHTS_LEN; ++ i ) {\n    O = inverse(Look_At(lights[i].N))*(ori-lights[i].ori);\n    Union(res, sdBox(O, float3(0.01, lights[i].radius)), 100.0+float(i));\n  }\n  //----\n  return res;\n}\n\nfloat BSDF_PDF ( float3 N, float3 wi, float3 wo, Material mat ) {\n  if ( mat.transmittive > 0.0 ) {\n    float3 NN = refract(wi, N, mat.transmittive);\n    if ( dot(wo, NN) < cos(mat.alpha) ) return -1.0;\n    return 1.0;\n  }\n    if (mat.diffuse == 0.0) {\n        return 0.0f;\n    }\n  float3 H = normalize(wi+wo);\n  float theta = dot(H, N);\n  float k = mat.alpha*mat.alpha;\n  float pdf;\n  pdf = (k*k*theta)/(PI*sqr((k-1.0)*sqr(theta) + 1.0));\n\n  pdf = (pdf/(4.0 * max(dot(H, N), dot(wi, N)) * dot(wo, N)));\n  return pdf*(1.0 - mat.diffuse) + PDF_Cosine_Hemisphere(wo, N)*mat.diffuse;\n}\n\nfloat3 BSDF_Sample ( float3 N, float3 wi, float3 P, Material mat, out float pdf,\n                     inout float seed) {\n  if ( mat.transmittive > 0.0 ) {\n    pdf = 1.0f;\n    return refract(wi, N, mat.transmittive);\n  }\n    if (mat.diffuse == 0.0) { pdf = 1.0f; return reflect(wi, N); }\n  float diff_chance = Sample_Uniform(seed);\n  if ( diff_chance < mat.diffuse ) {\n    return Sample_Cos_Hemisphere(wi, N, pdf, seed);\n  }\n  float2 xi = Sample_Uniform2(seed);\n  float k = mat.alpha*mat.alpha;\n  float phi   = TAU * xi.x,\n        theta = asin( sqrt( ( k*log(1.0-xi.y) )/( k*log(1.0-xi.y)-1.0 )));\n  float3 wo = Reorient_Hemisphere(normalize(To_Cartesian(theta, phi)), N); \n  pdf = PDF_Cosine_Hemisphere(wi, N);\n  return wo;\n}\n\nfloat GTerm ( in float3 N, in float3 V, in float k ) {\n  return (dot(N, V))/( (dot(N, V)*(1.0 - k) + k));\n}\n\nfloat3 BSDF_F ( float3 N, float3 wi, float3 wo, Material mat ) {\n  if ( mat.transmittive > 0.0 ) {\n    return IPI*mat.colour;\n  }\n    if (mat.diffuse == 0.0) { return mat.colour; }\n  wi = -wi;\n\n  float3 X, Y;\n  Calculate_XY(N, X, Y);\n  float3 H = normalize(wi+wo);\n\n  float D, G, F;\n  \n  float k = mat.alpha*mat.alpha;\n\n  D = k/(PI*pow((k-1.0)*sqr(dot(N, H))+1.0, 2.0));\n  k = mat.alpha*sqrt(2.0*IPI);\n  G = GTerm(N, wi, k)*GTerm(N, wo, k);\n  F = mat.fresnel + (1.0-mat.fresnel)*pow(1.0 - dot(wi, H), 5.0);\n\n\n  float3 refl = float3(G*D*F)/(4.0*dot(wi, N)*max(dot(wi, N), dot(H, N)));\n  float diffuse = mat.diffuse;\n  return diffuse*IPI*mat.colour + (1.0-diffuse)*refl*mat.colour;\n}\n\nint Illumination ( inout float3 O, float3 N, float3 wi, inout float3 bsdf_wo,\n                   Material mat, inout float3 radiance,\n                   inout float3 direct_radiance, inout float seed ) {\n  int return_enum = 0;\n  float bsdf_pdf, emit_pdf;\n  float3 prev_radiance = radiance;\n\n  // ---- indirect radiance ----\n  bsdf_wo = BSDF_Sample(N, wi, O, mat, bsdf_pdf, seed);\n  float2 bsdf_res = March(Ray(O+bsdf_wo*0.1, bsdf_wo));\n  radiance *= (BSDF_F(N, wi, bsdf_wo, mat)*abs(dot(N, wi)))/bsdf_pdf;\n  int lidx = -1;\n\n  if ( bsdf_res.x < 0.0 ) return -1;\n  if ( Valid_Emitter(LIGHT_IDX(bsdf_res.y), bsdf_wo) ) {\n    lidx = LIGHT_IDX(bsdf_res.y);\n    float3 Lo = O + bsdf_wo*bsdf_res.x;\n    emit_pdf = REmit_PDF(lidx, N, bsdf_wo, bsdf_res.x);\n    float3 dr = lights[lidx].emi * BSDF_F(N, wi, bsdf_wo, mat);\n    dr *= prev_radiance * float3(bsdf_pdf/(bsdf_pdf+emit_pdf));\n    direct_radiance += clamp(dr, float3(0.0), float3(1.0));\n    return 2;\n  }\n\n  // ---- direct radiance ----\n  if ( lidx == -1 ) lidx = int(Sample_Uniform(seed)*float(LIGHTS_LEN));\n  float3 emit_wo = Sample_Emitter(lidx, O, seed);\n  float2 emit_res = March(Ray(O+emit_wo*0.01, emit_wo));\n  bsdf_pdf = BSDF_PDF(N, wi, emit_wo, mat);\n  if ( lidx == LIGHT_IDX(emit_res.y) && bsdf_pdf > 0.0 &&\n       Valid_Emitter(lidx, emit_wo) ) {\n    float3 Lo = O + emit_wo*emit_res.x;\n    emit_pdf = REmit_PDF(lidx, N, emit_wo, emit_res.x);\n    float3 dr = lights[lidx].emi * BSDF_F(N, wi, emit_wo, mat);\n    dr *= prev_radiance * emit_pdf/(bsdf_pdf+emit_pdf);\n    direct_radiance += clamp(dr, float3(0.0), float3(1.0));\n    if ( return_enum != 2 )\n      return_enum = 1;\n  }\n\n  // prepare origin\n  O = O + bsdf_wo * bsdf_res.x;\n  return return_enum;\n}\n\nint Propagate ( inout float3 radiance, inout float3 accum_rad,\n                inout Ray eye, inout float seed, int step ) {\n  float2 res = March(eye);\n\n  //-- accumulate radiance --\n  if ( res.x < 0.0 ) return 0;\n  //-- gather material and reflection information --\n  float3 O  = eye.ori + eye.dir*res.x,\n         N  = Normal(O),\n         wi = eye.dir,\n         wo;// to be calculated by direct light contribution\n  if ( res.y >= 100.0 ) {\n    int I = LIGHT_IDX(res.y);\n    if ( step == 0 && Valid_Emitter(I, wi) )\n      accum_rad = lights[I].emi;\n    return 2;\n  }\n  Material mat = RMaterial(O, res.y);\n  int return_enum = Illumination(O, N, wi, wo, mat, radiance, accum_rad,\n                                 seed);\n  //-- prepare for next propagation --\n  eye.ori = O+wo*0.01;\n  eye.dir = wo;\n\n  return return_enum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float2 uv = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n\n  float seed = uv.x + uv.y*3.829614823 + fract(3.19520814*iTime);\n\n  Ray eye = Look_At(uv, seed);\n  fragColor = float4(0.0);\n  float3 radiance  = float3(1.0),\n         accum_rad = float3(0.0);\n\n  Initialize_Lights();\n\n  int hit = 0;\n  for ( int i = 0; i != ITERS; ++ i ) {\n    int res = Propagate(radiance, accum_rad, eye, seed, i);\n    if ( res == 1 ) {\n      hit = 1;\n    }\n    if ( res == 2 ) {\n      hit = 1;\n      break;\n    }\n    if ( res == -1 ) break;\n  }\n\n  fragColor.xyz = accum_rad;\n  #ifdef ROTATAL\n  fragColor.w = 0.0;\n  #else\n  fragColor.w = hit==1 ? 1.0 : 0.0;\n  #endif\n}\n\n//------------------------------------------------------------------------------",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}