{
    "Shader": {
        "info": {
            "date": "1722996172",
            "description": "Edited to remove large glitch effects, nicer as a background",
            "flags": 32,
            "hasliked": 0,
            "id": "XcjcWK",
            "likes": 2,
            "name": "Fork of Hex Glitch",
            "published": 3,
            "tags": [
                "glitch"
            ],
            "usePreview": 0,
            "username": "Entropy159",
            "viewed": 106
        },
        "renderpass": [
            {
                "code": "// Vignetting is an effect caused by composite lenses whereby the image appears darker around the edges.\n// Despite being an artefact of lens design, it is often applied deliberately as an artistic effect to \n// frame the image and draw the eye inward toward the center. \nfloat Vignette(in vec2 fragCoord)\n{\n    #define kVignetteStrength         0.5             // The strength of the vignette effect\n    #define kVignetteScale            0.6            // The scale of the vignette effect\n    #define kVignetteExponent         3.0             // The rate of attenuation of the vignette effect\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x = (uv.x - 0.5) * (iResolution.x / iResolution.y) + 0.5;     \n    \n    float x = 2.0 * (uv.x - 0.5);\n    float y = 2.0 * (uv.y - 0.5);\n    \n    float dist = sqrt(x*x + y*y) / kRoot2;\n    \n    return mix(1.0, max(0.0, 1.0 - pow(dist * kVignetteScale, kVignetteExponent)), kVignetteStrength);\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n    SetGlobals(xy, iResolution.xy, iTime); \n    PCGInitialise(HashOf(uint(iFrame)));\n    \n    vec3 rgb = kZero;\n    if(kApplyBloom)\n    {\n        vec3 bloom = Bloom(xy / float(kScreenDownsample), iResolution, ivec2(0, 1), iChannel0) * kBloomGain; \n        if(kDebugBloom)\n        {\n             rgba = vec4(bloom, 1.0);\n             return;\n        }\n        \n        rgb = pow(bloom, vec3(1.));      \n    }  \n\n    \n    // Composite\n    rgb += texelFetch(iChannel1, ivec2(xy) / kScreenDownsample, 0).xyz * 0.6;     \n    rgb = saturate(rgb);\n    rgb = pow(rgb, vec3(0.8));\n    rgb = mix(kOne * 0.1, kOne * 0.9, rgb);\n    rgb *= Vignette(xy);\n    \n    rgb = saturate(rgb);\n    \n    rgba.xyz = rgb;    \n    rgba.w = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define kScreenDownsample 1\n\n// *******************************************************************************************************\n// Global variables\n\nvec2 gResolution;\nvec2 gFragCoord;\nfloat gTime;\nuvec4 rngSeed;\nfloat gDxyDuv;\n\nvoid SetGlobals(vec2 fragCoord, vec2 resolution, float time)\n{\n    gFragCoord = fragCoord;\n    gResolution = resolution;\n    gTime = time;\n    \n     // First derivative of screen to world space (assuming square pixels)\n    gDxyDuv = 1.0 / gResolution.x;\n}\n\n// *******************************************************************************************************\n//    Math functions\n// *******************************************************************************************************\n\n#define kPi                    3.14159265359\n#define kTwoPi                 (2.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRoot2                 1.41421356237\n#define kFltMax                3.402823466e+38\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.0)\n#define kZero                  vec3(0.0)\n#define kPink                  vec3(1.0, 0.0, 0.2)\n\nfloat cubrt(float a)           { return sign(a) * pow(abs(a), 1.0 / 3.0); }\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\nvec3 sqr(vec3 a)               { return a * a; }\nint sqr(int a)                 { return a * a; }\nfloat cub(float a)             { return a * a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\nfloat mod2(float a, float b)   { return mod(mod(a, b) + b, b); }\nvec3 mod2(vec3 a, vec3 b)      { return mod(mod(a, b) + b, b); }\nfloat length2(vec2 v)          { return dot(v, v); }\nfloat length2(vec3 v)          { return dot(v, v); }\nint sum(ivec2 a)               { return a.x + a.y; }\nfloat luminance(vec3 v)        { return v.x * 0.17691 + v.y * 0.8124 + v.z * 0.01063; }\nfloat mean(vec3 v)             { return v.x / 3.0 + v.y / 3.0 + v.z / 3.0; }\nvec4 mul4(vec3 a, mat4 m)      { return vec4(a, 1.0) * m; }\nvec3 mul3(vec3 a, mat4 m)      { return (vec4(a, 1.0) * m).xyz; }\nfloat sin01(float a)           { return 0.5 * sin(a) + 0.5; }\nfloat cos01(float a)           { return 0.5 * cos(a) + 0.5; }\nfloat saturate(float a)        { return clamp(a, 0.0, 1.0); }\nvec3 saturate(vec3 a)          { return clamp(a, 0.0, 1.0); }\nvec4 saturate(vec4 a)          { return clamp(a, 0.0, 1.0); }\nfloat saw01(float a)           { return abs(fract(a) * 2.0 - 1.0); }\nfloat cwiseMax(vec3 v)         { return (v.x > v.y) ? ((v.x > v.z) ? v.x : v.z) : ((v.y > v.z) ? v.y : v.z); }\nfloat cwiseMax(vec2 v)         { return (v.x > v.y) ? v.x : v.y; }\nfloat cwiseMin(vec3 v)         { return (v.x < v.y) ? ((v.x < v.z) ? v.x : v.z) : ((v.y < v.z) ? v.y : v.z); }\nfloat cwiseMin(vec2 v)         { return (v.x < v.y) ? v.x : v.y; }\nvoid sort(inout float a, inout float b) { if(a > b) { float s = a; a = b; b = s; } }\nvoid swap(inout float a, inout float b) { float s = a; a = b; b = s; }\n\nvec3 safeAtan(vec3 a, vec3 b)\n{\n    vec3 r;\n    #define kAtanEpsilon 1e-10\n    r.x = (abs(a.x) < kAtanEpsilon && abs(b.x) < kAtanEpsilon) ? 0.0 : atan(a.x, b.x); \n    r.y = (abs(a.y) < kAtanEpsilon && abs(b.y) < kAtanEpsilon) ? 0.0 : atan(a.y, b.y); \n    r.z = (abs(a.z) < kAtanEpsilon && abs(b.z) < kAtanEpsilon) ? 0.0 : atan(a.z, b.z); \n    return r;\n}\n\n// *******************************************************************************************************\n//    2D SVG\n// *******************************************************************************************************\n\nfloat SDFLine(vec2 p, vec2 v0, vec2 v1, float thickness)\n{\n    v1 -= v0;\n    float t = saturate((dot(p, v1) - dot(v0, v1)) / dot(v1, v1));\n    vec2 perp = v0 + t * v1;\n    return saturate((thickness - length(p - perp)) / gDxyDuv);\n}\n\nfloat SDFQuad(vec2 p, vec2 v[4], float thickness)\n{\n    float c = 0.0;\n    for(int i = 0; i < 4; i++)\n    {\n        c = max(c, SDFLine(p, v[i], v[(i+1)%4], thickness)); \n    }\n \n    return c;\n}\n\n// *******************************************************************************************************\n//    2D primitive tests\n// *******************************************************************************************************\n\nbool IsPointInQuad(vec2 uv, vec2 v[4])\n{\n    for(int i = 0; i < 4; i++)\n    {\n        if(dot(uv - v[i], v[i] - v[(i+1)%4]) > 0.0) { return false; }\n    }\n    return true;\n}\n\n// *******************************************************************************************************\n//    Transforms \n// *******************************************************************************************************\n\nmat3 WorldToViewMatrix(float rot, vec2 trans, float sca)\n{   \n    return mat3(vec3(cos(rot) / sca, sin(rot) / sca, trans.x), \n                vec3(-sin(rot) / sca, cos(rot) / sca, trans.y),\n                vec3(1.0));\n}\n\nvec2 TransformScreenToWorld(vec2 p)\n{   \n    return (p - vec2(gResolution.xy) * 0.5) / float(gResolution.y); \n}\n\n\nvec3 Cartesian2DToBarycentric(vec2 p)\n{    \n    return vec3(p, 0.0) * mat3(vec3(0.0, 1.0 / 0.8660254037844387, 0.0),\n                          vec3(1.0, 0.5773502691896257, 0.0),\n                          vec3(-1.0, 0.5773502691896257, 0.0));    \n}\n\nvec2 BarycentricToCartesian2D(vec3 b)\n{    \n    return vec2(b.y * 0.5 - b.z * 0.5, b.x * 0.8660254037844387);    \n}\n\n// Maps an input uv position to periodic hexagonal tiling\n//     inout vec2 uv: The mapped uv coordinate\n//     out vec3 bary: The Barycentric coordinates at the point on the hexagon\n//     out ivec2 ij: The coordinate of the tile\nvec2 Cartesian2DToHexagonalTiling(in vec2 uv, out vec3 bary, out ivec2 ij)\n{    \n    #define kHexRatio vec2(1.5, 0.8660254037844387)\n    vec2 uvClip = mod(uv + kHexRatio, 2.0 * kHexRatio) - kHexRatio;\n    \n    ij = ivec2((uv + kHexRatio) / (2.0 * kHexRatio)) * 2;\n    if(uv.x + kHexRatio.x <= 0.0) ij.x -= 2;\n    if(uv.y + kHexRatio.y <= 0.0) ij.y -= 2;\n    \n    bary = Cartesian2DToBarycentric(uvClip);\n    if(bary.x > 0.0)\n    {\n        if(bary.z > 1.0) { bary += vec3(-1.0, 1.0, -2.0); ij += ivec2(-1, 1); }\n        else if(bary.y > 1.0) { bary += vec3(-1.0, -2.0, 1.0); ij += ivec2(1, 1); }\n    }\n    else\n    {\n        if(bary.y < -1.0) { bary += vec3(1.0, 2.0, -1.0); ij += ivec2(-1, -1); }\n        else if(bary.z < -1.0) { bary += vec3(1.0, -1.0, 2.0); ij += ivec2(1, -1); }\n    }\n\n    return vec2(bary.y * 0.5773502691896257 - bary.z * 0.5773502691896257, bary.x);\n}\n\nbool InverseSternograph(inout vec2 uv, float zoom)\n{\n    float theta = length(uv) * kPi * zoom;\n    if(theta >= kPi - 1e-1) { return false; }\n    \n    float phi = atan(-uv.y, -uv.x) + kPi;\n    \n    vec3 sph = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), -cos(theta));\n    \n    uv = vec2(sph.x / (1.0 - sph.z), sph.y / (1.0 - sph.z));\n    return true;\n}\n\nfloat SmoothStep(float a, float b, float x) { return mix(a, b, x * x * (3.0 - 2.0 * x)); }\nvec4 SmoothStep(vec4 a, vec4 b, float x)    { return mix(a, b, x * x * (3.0 - 2.0 * x)); }\nfloat SmoothStep(float x)                   { return mix(0.0, 1.0, x * x * (3.0 - 2.0 * x)); }\n\nfloat PaddedSmoothStep(float x, float a, float b)\n{ \n    return SmoothStep(saturate(x * (a + b + 1.0) - a));\n}\n\nfloat PaddedSmoothStep(float x, float a)\n{\n    return PaddedSmoothStep(x, a, a);\n}\n\nfloat Impulse(float x, float axis, float stdDev)\n{\n    return exp(-sqr((x - axis) / stdDev));\n}\n\nfloat KickDrop(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    if(t < p1.x)\n    {\n        return mix(p0.y, p1.y, max(0.0, exp(-sqr((t - p1.x)*2.145966026289347/(p1.x-p0.x))) - 0.01) / 0.99);\n    }\n    else if(t < p2.x)\n    {\n        return mix(p1.y, p2.y, (t - p1.x) / (p2.x - p1.x));\n    }\n    else\n    {  \n        return mix(p3.y, p2.y, max(0.0, exp(-sqr((t - p2.x)*2.145966026289347/(p3.x-p2.x))) - 0.01) / 0.99);\n    }\n}\n\nfloat KickDrop(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n    return KickDrop(t, p0, p1, p1, p2);\n}\n\n// *******************************************************************************************************\n//    Random number generation\n// *******************************************************************************************************\n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\nuvec4 PCGAdvance()\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Generates a tuple of canonical random number and uses them to sample an input texture\nvec4 Rand(sampler2D sampler)\n{\n    return texelFetch(sampler, (ivec2(gFragCoord) + ivec2(PCGAdvance() >> 16)) % 1024, 0);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 Rand()\n{\n    return vec4(PCGAdvance()) / float(0xffffffffu);\n}\n\n// Seed the PCG hash function with the current frame multipled by a prime\nvoid PCGInitialise(uint seed)\n{    \n    rngSeed = uvec4(20219u, 7243u, 12547u, 28573u) * seed;\n}\n\n// Reverse the bits of 32-bit inteter\nuint RadicalInverse(uint i)\n{\n    i = ((i & 0xffffu) << 16u) | (i >> 16u);\n    i = ((i & 0x00ff00ffu) << 8u) | ((i & 0xff00ff00u) >> 8u);\n    i = ((i & 0x0f0f0f0fu) << 4u) | ((i & 0xf0f0f0f0u) >> 4u);\n    i = ((i & 0x33333333u) << 2u) | ((i & 0xccccccccu) >> 2u);    \n    i = ((i & 0x55555555u) << 1u) | ((i & 0xaaaaaaaau) >> 1u);        \n    return i;\n}\n\n// Samples the radix-2 Halton sequence from seed value, i\nfloat HaltonBase2(uint i)\n{    \n    return float(RadicalInverse(i)) / float(0xffffffffu);\n}\n\nconst mat4 kOrderedDither = mat4(vec4(0.0, 8.0, 2.0, 10.), vec4(12., 4., 14., 6.), vec4(3., 11., 1., 9.), vec4(15., 7., 13., 5.));\nfloat OrderedDither()\n{    \n    return (kOrderedDither[int(gFragCoord.x) & 3][int(gFragCoord.y) & 3] + 1.0) / 17.0;\n}\n\nfloat OrderedDither(ivec2 p)\n{    \n    return (kOrderedDither[p.x & 3][p.y & 3] + 1.0) / 17.0;\n}\n\n// *******************************************************************************************************\n//    Hash functions\n// *******************************************************************************************************\n\n// Constants for the Fowler-Noll-Vo hash function\n// https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function\n#define kFNVPrime              0x01000193u\n#define kFNVOffset             0x811c9dc5u\n#define kDimsPerBounce         4\n\n// Mix and combine two hashes\nuint HashCombine(uint a, uint b)\n{\n    return (((a << (31u - (b & 31u))) | (a >> (b & 31u)))) ^\n            ((b << (a & 31u)) | (b >> (31u - (a & 31u))));\n}\n\n// Compute a 32-bit Fowler-Noll-Vo hash for the given input\nuint HashOf(uint i)\n{\n    uint h = (kFNVOffset ^ (i & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 8u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 16u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 24u) & 0xffu)) * kFNVPrime;\n    return h;\n}\n\nuint HashOf(uint a, uint b) { return HashCombine(HashOf(a), HashOf(b)); }\nuint HashOf(uint a, uint b, uint c) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashOf(c)); }\nuint HashOf(uint a, uint b, uint c, uint d) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashCombine(HashOf(c), HashOf(d))); }\nuint HashOf(ivec2 v) { return HashCombine(HashOf(uint(v.x)), HashOf(uint(v.y))); }\n\n// Samples the radix-2 Halton sequence from seed value, i\nfloat HashToFloat(uint i)\n{    \n    return float(i) / float(0xffffffffu);\n}\n\n// *******************************************************************************************************\n//    Colour functions\n// *******************************************************************************************************\n\nvec3 Hue(float phi)\n{\n    float phiColour = 6.0 * phi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    return mix(c0, c1, phiColour - float(i));\n}\n\nvec3 HSVToRGB(vec3 hsv)\n{\n    return mix(vec3(0.0), mix(vec3(1.0), Hue(hsv.x), hsv.y), hsv.z);\n}\n\nvec3 RGBToHSV( vec3 rgb)\n{\n    // Value\n    vec3 hsv;\n    hsv.z = cwiseMax(rgb);\n\n    // Saturation\n    float chroma = hsv.z - cwiseMin(rgb);\n    hsv.y = (hsv.z < 1e-10) ? 0.0 : (chroma / hsv.z);\n\n    // Hue\n    if (chroma < 1e-10)        { hsv.x = 0.0; }\n    else if (hsv.z == rgb.x)    { hsv.x = (1.0 / 6.0) * (rgb.y - rgb.z) / chroma; }\n    else if (hsv.z == rgb.y)    { hsv.x = (1.0 / 6.0) * (2.0 + (rgb.z - rgb.x) / chroma); }\n    else                        { hsv.x = (1.0 / 6.0) * (4.0 + (rgb.x - rgb.y) / chroma); }\n    hsv.x = fract(hsv.x + 1.0);\n\n    return hsv;\n}\n\nvec3 Overlay(vec3 a, vec3 b)\n{\n    //return (luminance(a) < 0.5) ? (2.0 * a * b) : (1.0 - 2.0 * (1.0 - a) * (1.0 - b));\n    return vec3((a.x < 0.5) ? (2.0 * a.x * b.x) : (1.0 - 2.0 * (1.0 - a.x) * (1.0 - b.x)),\n                (a.y < 0.5) ? (2.0 * a.y * b.y) : (1.0 - 2.0 * (1.0 - a.y) * (1.0 - b.y)),\n                (a.z < 0.5) ? (2.0 * a.z * b.z) : (1.0 - 2.0 * (1.0 - a.z) * (1.0 - b.z)));\n}\n\nvec3 SoftLight(vec3 a, vec3 b)\n{\n    return (kOne - 2.0 * b) * sqr(a) + 2.0 * b * a;\n}\n\n// A Gaussian function that we use to sample the XYZ standard observer \nfloat CIEXYZGauss(float lambda, float alpha, float mu, float sigma1, float sigma2)\n{\n   return alpha * exp(sqr(lambda - mu) / (-2.0 * sqr(lambda < mu ? sigma1 : sigma2)));\n}\n\nvec3 SampleSpectrum(float delta)\n{\n\t// Here we use a set of fitted Gaussian curves to approximate the CIE XYZ standard observer.\n\t// See https://en.wikipedia.org/wiki/CIE_1931_color_space for detals on the formula\n\t// This allows us to map the sampled wavelength to usable RGB values. This code needs cleaning \n\t// up because we do an unnecessary normalisation steps as we map from lambda to XYZ to RGB.\n\n    float lambda = mix(3800.0, 7000.0, delta);    \n\n\t#define kRNorm (7000.0 - 3800.0) / 1143.07\n\t#define kGNorm (7000.0 - 3800.0) / 1068.7\n\t#define kBNorm (7000.0 - 3800.0) / 1068.25\n\n\t// Sample the Gaussian approximations\n\tvec3 xyz;\n\txyz.x = (CIEXYZGauss(lambda, 1.056, 5998.0, 379.0, 310.0) +\n             CIEXYZGauss(lambda, 0.362, 4420.0, 160.0, 267.0) +\n             CIEXYZGauss(lambda, 0.065, 5011.0, 204.0, 262.0)) * kRNorm;\n\txyz.y = (CIEXYZGauss(lambda, 0.821, 5688.0, 469.0, 405.0) +\n             CIEXYZGauss(lambda, 0.286, 5309.0, 163.0, 311.0)) * kGNorm;\n\txyz.z = (CIEXYZGauss(lambda, 1.217, 4370.0, 118.0, 360.0) +\n             CIEXYZGauss(lambda, 0.681, 4590.0, 260.0, 138.0)) * kBNorm;\n\n\t// XYZ to RGB linear transform\n\tvec3 rgb;\n\trgb.r = (2.04159 * xyz.x - 0.5650 * xyz.y - 0.34473 * xyz.z) / (2.0 * 0.565);\n\trgb.g = (-0.96924 * xyz.x + 1.87596 * xyz.y + 0.04155 * xyz.z) / (2.0 * 0.472);\n\trgb.b = (0.01344 * xyz.x - 0.11863 * xyz.y + 1.01517 * xyz.z) / (2.0 * 0.452);\n\n\treturn rgb;\n}\n\n// *******************************************************************************************************\n//    Filters\n// *******************************************************************************************************\n#define kApplyBloom               true\n\n#define kBloomGain                1.         // The strength of the bloom effect \n#define kBloomTint                vec3(1.0)       // The tint applied to the bloom effect\n#define kBloomWidth               (0.02 / float(kScreenDownsample))             // The width of the bloom effect as a proportion of the buffer width\n#define kBloomHeight              (0.02 / float(kScreenDownsample))             // The height of the bloom effect as a proportion of the buffer height\n#define kBloomShape               vec3(1.5, 1.0, 0.7)            // The fall-off of the bloom shape. Higher value = steeper fall-off\n#define kBloomDownsample          2               // How much the bloom buffer is downsampled. Higher value = lower quality, but faster\n#define kDebugBloom               false           // Show only the bloom in the final comp\n#define kBloomBurnIn              vec3(0.2) \n\n// Seperable bloom function. This filter requires two passes in the horizontal and vertical directions which are combined as a post-process\n// effect after each frame. The accuracy/cost of the effect can be tuned by dialing the kBloomDownsample parameter. \nvec3 Bloom(vec2 fragCoord, vec3 iResolution, ivec2 delta, sampler2D renderSampler)\n{        \n    vec2 scaledResolution = vec2(iResolution.x, iResolution.y) / float((delta.x == 1) ? kBloomDownsample : 1);\n   \n    if(fragCoord.x > scaledResolution.x || fragCoord.y > scaledResolution.y) { return kZero; }\n    \n    float bloomSize = (delta.x == 1) ? kBloomWidth : kBloomHeight;\n    \n    int kKernelWidth = int(bloomSize * max(iResolution.x, iResolution.y) + 0.5) / ((delta.x == 1) ? kBloomDownsample : 1);\n    vec3 sumWeights = vec3(0.0);\n    vec3 sumRgb = vec3(0.0);\n    for(int i = -kKernelWidth; i <= kKernelWidth; i++)\n    {      \n        vec2 xy = vec2(fragCoord.x + float(i * delta.x), fragCoord.y + float(i * delta.y));\n        \n        if(delta.x == 1) { xy *= float(kBloomDownsample); }\n        else { xy /= float(kBloomDownsample); }\n        \n        if(xy.x < 0.0 || xy.x > iResolution.x || xy.y < 0.0 || xy.y > iResolution.y) { continue; }\n            \n        vec4 texel = texture(renderSampler, xy / iResolution.xy);\n        vec3 rgb = max(texel.xyz / max(1.0, texel.w), vec3(0.0));            \n        float d = float(abs(i)) / float(kKernelWidth);\n           \n        vec3 weight = kOne;\n        if(i != 0)\n        {\n            // Currently using a single weight although this effect can be done per-channel\n            weight = pow(max(kZero, kOne * (exp(-sqr(d * 4.0)) - 0.0183156) / 0.981684), kBloomShape);\n        }\n            \n        sumRgb += ((delta.y == 1) ? rgb : max(kZero, rgb - kBloomBurnIn)) * weight;         \n        sumWeights += weight;\n    }\n    \n    sumRgb = sumRgb / sumWeights;\n    \n    return (delta.x == 1) ? sumRgb : (sumRgb * kBloomTint);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define kCaptureTimeDelay 0.0\n#define kCaptureTimeSpeed 1.0\n\nvec3 Render(vec2 uvScreen, int idx, int maxSamples, bool isDisplaced, float jpegDamage, out float blend)\n{       \n    #define kMBlurGain      (isDisplaced ? 100. : 10.0)\n    #define kZoomOrder      2\n    #define kEndPause       0.0\n    #define kSpeed          0.15\n     \n    // x: Lambda\n    // y: Motion blur\n    // z, w: Warping and distortion\n    \n    // Sample the time domain for motion blur\n    vec4 xi = Rand(iChannel0);\n    uint hash = HashOf(uint(98796523), uint(gFragCoord.x), uint(gFragCoord.y));        \n    xi.y = (float(idx) + HaltonBase2(uint(idx) + hash)) / float(maxSamples);\n    //xi.x = OrderedDither();\n    xi.x = xi.y;\n    float time = 1. * max(0.0, iTime - kCaptureTimeDelay);\n    time = (time * kCaptureTimeSpeed + xi.y * kMBlurGain / 60.0) * kSpeed; \n    //time = time - 0.2 * sqrt(uvScreen.y / iResolution.y);\n    \n    float phase = fract(time);\n    int interval = int(time) & 1;    \n    interval <<= 1;\n    float morph;\n    float warpedTime;\n    float spectrumBlend;\n    #define kIntervalPartition 0.85\n    if(phase < kIntervalPartition)\n    {\n        float y = (interval == 0) ? uvScreen.y : (iResolution.y - uvScreen.y);\n        warpedTime = (phase / kIntervalPartition) - 0.2 * sqrt(y / iResolution.y) - 0.1;\n        phase = fract(warpedTime);\n        morph = 1.0 - PaddedSmoothStep(sin01(kTwoPi * phase), 0., 0.4);\n        blend = float(interval / 2) * 0.5;\n        if(interval == 2) { warpedTime *= 0.5; }\n    }\n    else\n    {\n        time -=  0.8 * kSpeed * xi.y * kMBlurGain / 60.0;\n        warpedTime = time;\n        phase = (fract(time) - kIntervalPartition) / (1.0 - kIntervalPartition);\n        morph = 1.0;\n        blend = (KickDrop(phase, vec2(0.0, 0.0), vec2(0.2, -0.1), vec2(0.3, -0.1), vec2(0.7, 1.0)) + float(interval / 2)) * 0.5;        \n        interval++;\n    }\n    \n    float beta = abs(2.0 * max(0.0, blend) - 1.0);\n    \n    #define kMaxIterations  2\n    //int kMaxIterations = 2 + 2 * int(round(jpegDamage));\n    #define kTurns 7\n    #define kNumRipples 5\n    //#define kRippleDelay 1.\n    #define kRippleDelay (float(kNumRipples) / float(kTurns))\n    #define kThickness mix(0.5, 0.4, morph)\n    #define kExponent mix(0.05, 0.55, morph)\n    \n    float expMorph = pow(morph, 0.3);\n    //#define kZoom mix(0.3, 0.3, expMorph)\n    //#define kZoom 0.35\n    float kZoom = 0.35;\n    if(iResolution.x < iResolution.y)\n    {\n    kZoom = 0.20;\n    }\n    #define kScale mix(2.6, 1.1, expMorph)\n    //float kScale = (exp(5. * (1. - expMorph)) - 1.) + 1.05;\n    \n    //#define kZoom 0.35\n    //#define kScale mix(1.7, 1.3, pow(phase, 0.3))    \n\n    // Apply the transformation matrix and clip to screen space\n    mat3 M = WorldToViewMatrix(blend * kTwoPi, vec2(0.0), kZoom);\n    vec2 uvView = TransformScreenToWorld(uvScreen);\n    int invert = 0;\n     \n   \n    // Defocus blur\n    //vec4 blueNoise = texture(iChannel0, vec2(fract(iTime * 0.002), 0.5));\n    //blueNoise = pow(saturate((blueNoise - 0.5) / (1.0 - 0.5)), vec4(2.0));\n    //uvView += vec2(cos(kTwoPi * xi.z), sin(kTwoPi * xi.z)) * xi.w * 0.05 * blueNoise.x;\n    \n    // Chromatic aberration\n    //uvView /= 1.0 + mix(0.1, 0.5, length(uvView) * xiLambda * blueNoise.y); // Dynamic\n    uvView /= 1.0 + 0.05 * length(uvView) * xi.z; // Static\n    \n    //uvView *= 1.0 + length(uvView) * xi * 0.05;\n\n    uvView = (vec3(uvView, 1.0) * M).xy; \n    \n     vec3 bary;\n    ivec2 ij;\n    Cartesian2DToHexagonalTiling(uvView / 1.4, bary, ij);    \n    //float len = cwiseMax(abs(bary * mix(1.2, 1., cos01(1. * kTwoPi * blend))));\n    float len = cwiseMax(abs(bary));\n    //if(ij == ivec2(0) && len > 0.995 && len <= 1.) invert = 1;\n    \n    vec2 uvViewWarp = uvView;\n    uvViewWarp.y *= mix(1.0, 0.1, sqr(1.0 - morph) * xi.y * saturate(sqr(0.5 * (1.0 + uvView.y))));   \n    //uvViewWarp.x += mix(-1.0, 1.0, xi.w) * 0.002;\n    \n    float theta = toRad(30.0) * beta;\n    mat2 r = mat2(vec2(cos(theta), -sin(theta)), vec2(sin(theta), cos(theta)));\n    uvViewWarp = r * uvViewWarp;    \n\n    vec3 sigma = vec3(0.0);\n    for(int iterIdx = 0; iterIdx < kMaxIterations; ++iterIdx)\n    {   \n        vec3 bary;\n        ivec2 ij;\n        Cartesian2DToHexagonalTiling(uvViewWarp, bary, ij);        \n                        \n        if(!isDisplaced && ij != ivec2(0)) { break; }   \n        \n        //if(iterIdx == 0 && cwiseMax(abs(bary)) > 0.99) { invert = invert ^ 1; }\n        \n        int subdiv = 1 + int(exp(-sqr(10. * mix(-1., 1., phase))) * 100.);\n        \n        float theta = kTwoPi * (floor(cos01(kTwoPi * phase) * 12.) / 6.);\n        Cartesian2DToHexagonalTiling(uvViewWarp * (0.1 + float(subdiv)) - kHexRatio.y * vec2(sin(theta), cos(theta)) * floor(0.5 + sin01(kTwoPi * phase) * 2.) / 2., bary, ij);        \n        uint hexHash = HashOf(uint(phase * 6.), uint(subdiv), uint(ij.x), uint(ij.y));\n        if(hexHash % 2u == 0u)\n        {\n            float alpha = PaddedSmoothStep(sin01(phase * 20.0), 0.2, 0.75);\n            float dist = mix(cwiseMax(abs(bary)), length(uvView) * 2.5, 1.0 - alpha);\n            float hashSum = bary[hexHash % 3u] + bary[(hexHash + 1u) % 3u];\n\n            if( dist > 1.0 - 0.02 * float(subdiv)) { invert = invert ^ 1; }\n            else if( fract(20. / float(subdiv) * hashSum) < 0.5)  { invert = invert ^ 1; }\n            if(iterIdx == 0) break;\n        }\n        \n        float sigma = 0.0, sigmaWeight = 0.0;\n        for(int j = 0; j < kTurns; ++j)\n        {   \n            float delta = float(j) / float(kTurns);\n            float theta = kTwoPi * delta;\n            for(int i = 0; i < kNumRipples; ++i)\n            {\n                float l = length(uvViewWarp - vec2(cos(theta), sin(theta))) * 0.5;\n                float weight = log2(1.0 / (l + 1e-10));\n                sigma += fract(l - pow(fract((float(j) + float(i) / kRippleDelay) / float(kTurns) + warpedTime), kExponent)) * weight;\n                sigmaWeight += weight;\n            }            \n        }\n        invert = invert ^ int((sigma / sigmaWeight) > kThickness);\n        \n        //return vec3(sigma / sigmaWeight); \n       \n        theta = kTwoPi * (floor(cos01(kTwoPi * -phase) * 5. * 6.) / 6.);\n        uvViewWarp = r * (uvViewWarp + vec2(cos(theta), sin(theta)) * 0.5);\n        uvViewWarp *= kScale; \n    }\n    \n    sigma = vec3(float(invert != 0));\n    \n    return mix(1.0 - sigma, sigma * mix(kOne, SampleSpectrum(xi.x), sqr(beta)), beta);\n}\n\nbool Interfere(inout vec2 xy, inout vec3 tint, in vec2 res)\n{\n    #define kStatic false\n    #define kStaticFrequency 0.1\n    #define kStaticLowMagnitude 0.01\n    #define kStaticHighMagnitude 0.02\n    \n    #define kVDisplace false\n    #define kVDisplaceFrequency 0.07\n    \n    #define kHDisplace false\n    #define kHDisplaceFrequency 0.25\n    #define kHDisplaceVMagnitude 0.1\n    #define kHDisplaceHMagnitude 0.5\n    \n    float frameHash = HashToFloat(HashOf(uint(iFrame / int(10.0 / kCaptureTimeSpeed))));\n    bool isDisplaced = false;\n    \n    if(kStatic)\n    {\n        // Every now and then, add a ton of static\n        float interP = 0.01, displacement = res.x * kStaticLowMagnitude;\n        if(frameHash < kStaticFrequency)\n        {\n            interP = 0.5;\n            displacement = kStaticHighMagnitude * res.x;\n            tint = vec3(0.5);\n        }\n\n        // CRT interference at PAL refresh rate \n        PCGInitialise(HashOf(uint(xy.y / 2.), uint(iFrame / int(60.0 / (24.0 * kCaptureTimeSpeed)))));\n        vec4 xi = Rand();\n        if(xi.x < interP) \n        {  \n            float mag = mix(-1.0, 1.0, xi.y);        \n            xy.x -= displacement * sign(mag) * sqr(abs(mag)); \n            //isDisplaced = true;\n        }\n    }\n    \n    // Vertical displacment\n    if(kVDisplace && frameHash > 1.0 - kVDisplaceFrequency)\n    {\n        float dispX = HashToFloat(HashOf(8783u, uint(iFrame / int(10.0 / kCaptureTimeSpeed))));\n        float dispY = HashToFloat(HashOf(364719u, uint(iFrame / int(12.0 / kCaptureTimeSpeed))));\n        \n        if(xy.y < dispX * res.y) \n        { \n            xy.y -= mix(-1.0, 1.0, dispY) * res.y * 0.2; \n            isDisplaced = true;\n            tint = vec3(3.);\n        }\n    }\n    // Horizontal displacment\n    else if(kHDisplace && frameHash > 1.0 - kHDisplaceFrequency - kVDisplaceFrequency)\n    {\n        float dispX = HashToFloat(HashOf(147251u, uint(iFrame / int(9.0 / kCaptureTimeSpeed))));\n        float dispY = HashToFloat(HashOf(287512u, uint(iFrame / int(11.0 / kCaptureTimeSpeed))));\n        float dispZ = HashToFloat(HashOf(8756123u, uint(iFrame / int(7.0 / kCaptureTimeSpeed))));\n        \n        if(xy.y > dispX * res.y && xy.y < (dispX + mix(0.0, kHDisplaceVMagnitude, dispZ)) * res.y) \n        { \n            xy.x -= mix(-1.0, 1.0, dispY) * res.x * kHDisplaceHMagnitude; \n            isDisplaced = true;\n            tint = vec3(3.);\n        }\n    }\n    \n    return isDisplaced;\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n    rgba = vec4(0.);\n    SetGlobals(xy, iResolution.xy, iTime);   \n    \n    if(xy.x > iResolution.x / float(kScreenDownsample) || xy.y > iResolution.y / float(kScreenDownsample)) { return; }      \n    \n    xy *= float(kScreenDownsample);\n       \n    vec3 tint;\n    vec2 xyInterfere = xy;\n    bool isDisplaced = Interfere(xyInterfere, tint, iResolution.xy);\n    \n    ivec2 xyDither = ivec2(xy) / int(HashOf(uint(iTime + sin(iTime) * 1.5), uint(xyInterfere.x / 128.), uint(xyInterfere.y / 128.)) & 127u);\n    float jpegDamage = OrderedDither(xyDither);\n   \n    #define kAntiAlias 5\n    vec3 rgb = vec3(0.0);\n    float blend = 0.0;\n    for(int i = 0, idx = 0; i < kAntiAlias; ++i)\n    {\n        for(int j = 0; j < kAntiAlias; ++j, ++idx)\n        {\n            vec2 xyAA = xyInterfere + vec2(float(i) / float(kAntiAlias), float(j) / float(kAntiAlias));            \n            \n            rgb += Render(xyAA, idx, sqr(kAntiAlias), isDisplaced, jpegDamage, blend);\n        }\n    }\n    \n    rgb /= float(sqr(kAntiAlias));\n    rgb = mix(rgb, Overlay(rgb, vec3(.15, 0.29, 0.39)), blend);\n    \n    if(isDisplaced)\n    {\n        #define kColourQuantisation 5\n        //int kColourQuantisation = (isDisplaced) ? 2 : (5 + int(HashOf(uint(iTime + cos(iTime) * 1.5), uint(xyInterfere.x / 128.), uint(xyInterfere.y / 128.)) % 5u));\n        rgb *= float(kColourQuantisation);\n        if(fract(rgb.x) > jpegDamage) rgb.x += 1.0;\n        if(fract(rgb.y) > jpegDamage) rgb.y += 1.0;\n        if(fract(rgb.z) > jpegDamage) rgb.z += 1.0;\n        rgb = floor(rgb) / float(kColourQuantisation);\n    }\n\n        \n    // Scanlines\n    //rgb *= mix(1.0, 0.9, float((int(xy.y) / kScreenDownsample) & 1));\n    \n    // Grade\n    vec3 hsv = RGBToHSV(rgb);    \n    hsv.x += -sin((hsv.x + 0.05) * kTwoPi) * 0.07;\n    hsv.y *= 1.0;    \n    rgb = HSVToRGB(hsv);\n    \n    rgba.xyz = rgb;    \n    rgba.w = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 xy )\n{\n    if(xy.x > iResolution.x / float(kScreenDownsample) || xy.y > iResolution.y / float(kScreenDownsample)) { return; }\n    \n    if(kApplyBloom)\n    {    \n        fragColor.xyz = Bloom(xy, iResolution, ivec2(1, 0), iChannel0); \n        fragColor.w = 1.;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}