{
    "Shader": {
        "info": {
            "date": "1722015256",
            "description": "from https://www.shadertoy.com/view/7djXRm https://glslsandbox.com/e#73364.0",
            "flags": 0,
            "hasliked": 0,
            "id": "XfByRw",
            "likes": 1,
            "name": "fractal key lock",
            "published": 3,
            "tags": [
                "fractal",
                "key",
                "lock"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 88
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(10.,23,21))*0.5+.5)\n\n#define STEPS 256.0\n#define MDIST 250.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p, x) (mod(p,x)-0.5*(x))\nfloat glow = 0.0;\n\n\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\n\n\n\nfloat timeRemap (float t,float s1, float s2, float c){\n    return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)+s1*t*cos(iTime);  \n}\n\nvoid mo(inout vec2 p){\n  if(p.y>p.x) p = p.yx;\n}\n\nvec2 map(vec3 p){\n    vec3 po2 = p;\n \n    vec3 po = p;\n    float t = iTime*0.0;\n    \n  t = timeRemap(t*1.3, 1.*cos(iTime*0.5), 2.3, 0.1);\n     p.xz*=rot(iTime*1.4);\n    \n    for(float i = 0.0; i< 9.0; i++){\n        p = abs(p)-2.0*i*(vec3(0.35*asin(sin(t*0.15)),0.2*asin(sin(t*0.22)),0.3*asin(sin(t*0.38))));\n        p.xz*=rot(pi/2.0);\n       \n        mo(p.xy);//credit to FMS_CAT for this technique, I still have no idea how he makes it look so good\n        mo(p.zy);\n    }\n     \n    //Inner Cubes\n    p = pmod(p,2.2);\n     p=R(p,normalize(vec3(1,2,3)),iTime*.3);\n    vec2 a = vec2(box(p,vec3(0.5)),1.0);\n    a.x = abs(a.x)-0.2;\n    a.x = abs(a.x)-0.1;\n    //Inner Inner glowy Cubes\n    vec2 b = vec2(box(p,vec3(0.25)),2.0);\n    glow+=10.01/(0.11+b.x*b.x);\n  \n    \n    p = po;\n  \n  \n    //Boundry Cut Cube\n    vec3 cube = vec3(5.,1,5)*vec3(1.2+0.5*sin(t),1.2+0.5*cos(t),1.2+0.5*sin(t));\n     \n\n    a.x = max(box(p,cube),a.x);\n    //Outer Frame\n    ;\n   \n    b= vec2((p,cube+1.15,1.45),3.0);\n    a = (a.x<b.x)?a:b;\n  \n    a = (a.x<b.x)?a:b;\n    \n    return a;\n}\n\n\n\n\n\n#define ZERO (min(iFrame,0))\nvec3 norm(vec3 p){\n    \n#if 0    \n    vec2 e= vec2(0.01,0);\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n#endif  \n}\n\n\n//Lighting & modified tracing by Drake (me)\n//----------------------------------------------------------------------------\nvec3 tr(vec3 ro, vec3 rd)\n{\n    vec3 p = ro;\n    float shad = 0.0;\n    vec2 d = vec2(0);\n    \n    for(float i = 0.0; i < STEPS; i++){\n        vec2 s = map(p);\n        d.x += s.x*0.8;d.y=s.y;\n        p = ro+rd*d.x;\n        if(abs(s.x)<0.001||i==STEPS-1.0 ){\n            shad = i/STEPS;\n            break;\n        }\n        if(d.x>MDIST){ break;d.x=MDIST;d.y=0.;};\n    }\n    return vec3(d.x,d.y,shad);\n}\n#define time iTime\n#define resolution iResolution.xy\nvec3 lit(vec3 p, vec3 h, vec3 rd, vec3 al, vec3 n)\n{\n    vec3 fo = vec3(1.*0.5+0.5,1.*0.5+0.5,1.*0.5+0.5) * 0.1;\n    vec3 col = fo;\n    vec3 sss = vec3(0.5)*smoothstep(0.,1.,map(p+-rd*0.2).x/0.2);\n    float fom = clamp(h.x/MDIST,0.0,1.0);\n    float ffom =fom;\n    \n    //sneaky way to simplify lighting - i use -rd as the light direction, which\n    //makes it as if there's a point light at the camera position, and also makes\n    //fresnel a very simple calculation (essentially just the inverse of the diffuse)\n    float diffs = dot(n, -rd);\n    float diff = max(diffs,0.);\n    float fres = pow(1. - abs(diffs),4.);\n    float spec = pow(max(dot(reflect(-rd,n),rd),0.2),20.)*2.;\n\n    //this is a little bit wacky but works\n    if(h.y==4.){spec = 0.;fres=0.;ffom=0.;diff=0.;}\n    \n    //Definitely not using SSS as intended, but hey, it looks good!\n    col = mix(al * (fres + spec + diff/14.), diff * sss - h.z, ffom);\n    col = mix(col,fo,pow(fom,3.));\n    return col*3.;\n}\n\nconst int num_balls = 200; // change this, but be careful \nconst float coordinate_scale = 10000.;\nconst float structure_size = 15.20; // Size from 0 to 1, max size = 1\nconst float glow_decay = 1.85; \nconst float trail_len = 151.0;\n\nconst float speed = 0.1589;\nconst float rot_speed = pi;\nconst float blur_amount = 0.; \nconst float starting_pt = 1005.0; // This is a good number\n\nvec4 draw_ball(float i, float j, float size) {\n\tfloat balls = float(num_balls);\n\tfloat dt = starting_pt + time * speed;\n\t// Map coordinates to 0-1\n\tvec2 coord = gl_FragCoord.xy/resolution.xy;\n\t//map coordinates to -coord_scale -> +coord_scale\n\tcoord = coord *coordinate_scale-coordinate_scale/2.;\n\tcoord -= vec2(coord.x/2.,coord.y/2.);\n\t\n\t//Controls motion of balls\n\tfloat spacing = (2.*pi)/balls;\n\t\n\tfloat x =  (sin(dt*i*spacing)*100. - cos(dt*j*spacing + atan(dt))) * structure_size;\n\tfloat y =  (cos(dt*j*spacing)*100. - sin(dt*i*spacing + atan(dt))) * structure_size;\n\tx *= ((j - dt)/-dt) + sin(i*spacing + dt*sin(atan(dt*pi + y) - dt/100.));\n\ty *= ((i - dt)/dt)  + cos(i*spacing - dt*cos(atan(dt*pi + x) - dt/100.));\n\t//Correct aspect ratio\n\tcoord.x *= resolution.x/resolution.y; \n\tvec2 pos = vec2(x,y);\n\tmat2 rot = mat2(cos(dt*rot_speed), -sin(dt*rot_speed), sin(dt*rot_speed), cos(dt*rot_speed));\n\tpos *= rot;\n\tfloat dist = length(coord - pos) + sin(dt/1000. + atan(dt*(i+1.)))*blur_amount;\n\t\n\t//Controls how quickly brightness falls off\n\tfloat intensity = pow(size/dist, glow_decay);\n\t\n\tvec4 color = vec4(vec3(1.0) * (abs(sin(vec3(time/4.,time*pi/180.,time/8.)))*0.8 + 0.2), 1.0);\n\treturn color * intensity;\n}\n\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    \n    vec2 uv = (C-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 al = vec3(0);\n    //maybe a bit overkill to have a full camera \n    vec3 ro = vec3(0,0.,-15.);\n    ro.yz*=rot(iTime);\n        ro.yz*=rot(90.);\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f+uv.x*r+uv.y*cross(f,r);\n    \n    vec3 d = tr(ro,rd);\n    vec3 p = ro+rd*d.x;\nvec4 col3 = vec4(0.0);\n\tfor (int i = 0; i <100; i++) {\n\t\tvec2 pt = vec2(float(i),float(i));\n\t\tfloat ball_rad = 8.0 + abs(sin(time*speed + float(i)*pi)) * abs(cos(time*speed + float(i)*pi) * 10.0);\n\t\tcol3 += draw_ball(float(i),float(i), ball_rad-distance(pt,vec2(0.))/coordinate_scale);\n\t}\n\t\n\t\n\t\n\t\n    if(d.y==1.0) al = vec3(0.945,0.027,0.027);\n    if(d.y==2.0) al = vec3(0.741,0.059,1.000);\n    if(d.y==3.0) al = vec3(0.000,0.000,0.000);\n    if(d.y==4.0) al = vec3(0.839,0.812,0.780);\n    \n    //More lighting bits\n    vec2 e = vec2(0.01,0);\n    vec3 n = norm(p);\n    vec3 od = d;\n    vec3 op = p;\n    col = lit(p,d,rd,al,n);    \n    vec3 refld = reflect(rd,n);\n    d = tr(p + n*0.01,refld);\n    p = p+refld*d.x;\n    n = norm(p);\n    vec3 refl = lit(p,d,rd,al,n);\n    if(d.y<4.&&d.y>0.&&od.y>0.&&od.y<4.) col = mix(col,refl,0.5);\n    if(d.y>0.&&od.y<3.&&d.y<3.)col+=glow*0.03*vec3(0.741,0.059,1.000);    \n    //----------------\n\n       \n    col = pow(col,vec3(0.75));//Gamma correction\n    vec3 p2,q,r2=iResolution,\n    d2=normalize(vec3((C*2.-r2.xy)/r2.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.05,0.2,3.),H(g*2.15),1.8)*1./e/8e3\n    )\n    {\n        p2=g*d2+col;\n       \n        \n        p2=R(p2,normalize(vec3(1,2,3)),iTime*.3);\n        s=1.;\n        for(int i=0;i++<12;\n        p2=abs(p2)*e-vec3(1,2,1))\n            p2=.2-abs(p2),\n            p2.x<p2.z?p2=p2.zyx:p2,\n            p2.z<p2.y?p2=p2.xzy:p2,\n            s*=e=1.22;\n         g+=e=abs(p2.x)/s+.001;\n    }\n   O+= vec4(col3);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}