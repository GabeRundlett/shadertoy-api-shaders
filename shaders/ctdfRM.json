{
    "Shader": {
        "info": {
            "date": "1701092482",
            "description": "An interlocked Mobius strip.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctdfRM",
            "likes": 89,
            "name": "Interlocked Mobius Strip",
            "published": 3,
            "tags": [
                "raymarch",
                "mobius",
                "strip",
                "twist",
                "interlock"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 707
        },
        "renderpass": [
            {
                "code": "/*\n\n    Interlocked Mobius Strip\n    ------------------------\n    \n    Interlocked Mobius strips are a pretty common object amongst the 3D geometric\n    art crowd, and on the internet in general, so I was surprised not to find one on \n    Shadertoy... Well, it's possible that someone like Dr2, Fabrice, etc., has one \n    hidden away on here somewhere, but I wasn't able to track one down.\n\n    Either way, they're pretty easy to make: Produce two toroidal strips running\n    perpendicular to one another, each with some repeat holes in them. Offset one \n    set of holes by an angle that allows them to interweave, which will give you two \n    interlaced toroidal objects. The final step is to twist each along the toroidal \n    axis (the long circular one) by half a turn. This will, in effect, cause the two \n    separate toroidal objects to fuse into one continuous band, which I've always \n    thought looked pretty cool... but I'm easily amused, so it's probably not that \n    great. :D\n\n    I've had various incarnations of these objects sitting around for ages, so I \n    thought I'd dust one off and make it presentable. It originally featured some\n    rolling bearings running around the object, but I felt they were too distacting.\n    There are so many variations possible. I went for the single twist version with \n    bands around the edges because I thought it suited the background more. I happen \n    to prefer the more elegant ceramic or metallic versions sitting on a matte plane, \n    so I'll post one of those at some stage.\n    \n    \n\n\tRelated examples:\n    \n    // Essentially the same thing, but without the interlocking component.\n    // Dr2 has a heap of Mobius related material that's worth the look.\n    Twisted Ladder 2 - Dr2\n    https://www.shadertoy.com/view/Xsdczl\n    \n    // Stylish and mind bending at the same time.\n    Eternal Commute - tdhooper\n    https://www.shadertoy.com/view/ldKBRt\n    \n    \n*/\n\n\n// Attempting not to unroll loops.\n#define ZERO min(0, iFrame)\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n*/\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .1, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like \n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n// Texture sample.\nvec3 getTex(sampler2D iCh, vec2 p){\n\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(sampler2D iCh, in vec2 p){ return dot(getTex(iCh, p), vec3(.299, .587, .114)); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    //vec2 w = vec2( sdf, abs(pz) - h );\n  \t//return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n    \n    // Slight rounding. A little nicer, but slower.\n    const float sf = .028;\n    vec2 w = vec2( sdf, abs(pz) - h ) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    \n}\n\n// IQ's box routine.\nfloat sBoxS(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n// Object rotation, with some optional mouse movement.\nvec3 objRot(vec3 p){\n\n    // Mouse movement.\n    if(iMouse.z>1.){\n        p.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        p.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n\n    p.xy = rot2(3.14159/5.)*p.xy;\n    p.yz = rot2(-3.14159/5.)*p.yz;\n    p.xz = rot2(iTime/2.)*p.xz;  //iTime/4. \n    return p;\n\n}\n \n// Global scale for the background grid. \nvec2 fSc = vec2(1)/2.;\n\n\n// Subdivided rectangle grid.\nvec4 getGrid(vec2 p, inout vec2 sc){\n    \n    // Block offsets.\n    vec2 ipOffs = vec2(0);\n    // Row or column offset. Values like \"1/3\" would offset more\n    // haphazardly, but I wanted to maintain a little symmetry.\n\n    const float offDst = .5; \n    \n    if(mod(floor(p.y/sc.y), 2.)<.5){\n        p.x -= sc.x*offDst; // Row offset.\n        ipOffs.x += offDst;\n    }    \n    /*\n    if(mod(floor(p.x/sc.x), 2.)<.5){\n        p.y -= sc.y*offDst; // Column offset.\n        ipOffs.y += offDst;\n    }\n    */\n    /*\n    float ii = floor(p.y/sc.y);\n    float offDst = mod(ii, 4.)/4.; \n    p.x -= sc.x*offDst; // Row offset.\n    ipOffs.x += offDst;\n    */\n    \n         \n    // Current block ID.\n    vec2 ip = floor(p/sc) + .5;\n    \n    #define SUBDIV\n    #ifdef SUBDIV\n    // Random subdivision.\n\n    // Rectangle partitioning.\n    if(hash21(ip + .14)<.5){\n       sc.x /= 2.;\n       ip.x = floor(p.x/sc.x) + .5;\n    \n    }\n    if(hash21(ip + .42)<.5){\n       sc.y /= 2.;\n       ip.y = floor(p.y/sc.y) + .5;\n    \n    }\n    \n    /*\n    // Use this for squares only.\n    if(hash21(ip + .253)<.5){\n       sc /= 2.;\n       ip = floor(p/sc) + .5; \n    }\n    */\n    #endif\n    \n    // Local coordinates and cell ID.\n    return vec4(p - ip*sc, (ip + ipOffs)*sc);\n\n}\n\n\n\n// Back wall unit direction ray.\n// We need the direction itself for the standard cube\n// traversal trickery.\nvec3 gDir;\nvec3 gRd;\nfloat gCD;\n\n// The block pattern on the back wall.\nfloat getSurf(vec3 q3){\n\n    \n    vec2 sc = fSc; // Surface scale.\n    vec4 p4 = getGrid(q3.xy, sc); // Grid.\n    vec2 p = p4.xy, ip = p4.zw; // Local coordinates and cell ID.\n   \n    \n    vec3 p3 = vec3(p.xy, q3.z - 2.); // 3D position. \n    \n    float h = hash21(ip + .31)*.05; // Cell height.\n\n    float sq = sBoxS(p3.xy, sc/2., min(sc.y, sc.x)*.1); // Rounded square.\n    \n    float d2 = sq; // 2D distance.\n     \n    // Bore out some random holes.\n    if(hash21(ip + .21)<.5){\n    //if(mod(ip.x + ip.y, 2.)<.5){\n        //d2 = sBoxS(p3.xy, sc/2. - fSc.y/5., min(sc.y, sc.x)*.07);\n        float d2B = length(p3.xy) - (min(sc.y, sc.x)/2. - fSc.y/5.);\n        //float d2B = opExtrusion(d2, p3.z + (h + .2)*2., .5);\n        d2 = smax(d2, -d2B, fSc.y*.06);\n       \n    } \n    \n    // Extrude the 2D field above.\n    float d = opExtrusion(d2, p3.z + (h + .2), h + .2);\n    \n\n    \n    // Face curvature.\n    float fSph = length(p3 - vec3(0, 0, -(h + .2 -  max(sc.y, sc.x)/6.)*2.)) - sc.y/2.;\n    d += fSph*.1;\n    // Edge smoothing.\n    //d = smax(d, -abs(sq), fSc.y*.06); \n    \n    // Directional ray collision with the square cell boundaries.\n    vec2 rC = (gDir.xy*sc - p4.xy)/gRd.xy; // For 2D, this will work too.\n\n    // Minimum of all distances, plus not allowing negative distances.\n    // Adding a touch to advance to the next cell.\n    gCD = max(min(rC.x, rC.y), 0.) + .001; \n   \n    // Return the surface distance.\n    return d;\n\n\n}\n\n \n\n\n\n// Texture coordinates. It's easier to save them in the distance field and\n// reuse them later, rather than recalculate them all over again. The downside\n// is expense, but it's not really noticeable here.\nvec3 txCoord;\n \n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    float fl = getSurf(p);\n    \n\n    \n    // Rotate the object.\n    vec3 rP = objRot(p);\n    \n    // Number of toroidal twists: Only whole numbers work.\n    // Odd numbers will produce a continous strip, and even numbers\n    // will produce more than one.\n    float twists = 1.;\n \n    \n    // Toroidal strip dimensions.\n    vec2 dim = vec2(.1, .02);\n    float r = .38; // Toroidal radius.\n    \n    // Disc coordinates.\n    vec3 q = rP; \n    vec2 tc = vec2(length(q.xz) - r, rP.y);\n    \n    \n    // Disc holes.\n    vec3 q2 = rP;\n    float aN = 14.;\n    float a = mod(atan(q2.z, q2.x), 6.2831);\n    float na = (floor(a*aN/6.2831) + .5)/aN;\n    \n    // Rotate the repeat cells into position and move them out by the radius.\n    q2.xz *= rot2(-na*6.2831);\n    q2.x -= r;\n\n    q2.xy *= rot2(a*twists/2. - iTime*.5); // Twisting the toroidal plane objects.\n    // Producing the holes.\n    //float hole = sBoxS(q2.xz, vec2(1., 1)*r*6.2831/aN/2.*.65, .05); // X-axis holes.\n    float hole = length(q2.xz) - r*6.2831/aN/2.*.7; // X-axis holes.\n     \n    \n    tc *= rot2(a*twists/2. - iTime*.5); // Twisting the toroidal plane itself.\n    float taper = smoothstep(0., 1., abs(tc.x)/dim.x)*.5 + .5; // Holowing out the center.\n    float tor = sBoxS(tc, dim*vec2(1, taper), .01); // Creating the central strip.\n\n    // Outer band coordinates.\n    vec2 btc = tc; btc.x = abs(btc.x) - dim.x - dim.y;\n    float bands = sBoxS(btc, vec2(1, 1.5)*dim.y, .01);\n    tor = smax(tor, -hole, .01); // Boring out the wholes.\n    \n    // Band ridges... Interesting, but not for this example.\n    //bands += smoothstep(0., 1., sin(a*aN*6.))*.001;\n    \n    // Saving some coordinates to use for texturing.\n    txCoord = vec3(tc.xy, a/6.2831);\n    \n    \n    // Doing the same as above, but for a second object running\n    // perpendicular to the first. By twisting each object by a \n    // half turn, they fuse into one another giving the impression\n    // of one continous band.\n    q2 = rP;\n    q2.xz *= rot2(3.14159/aN);\n    a = atan(q2.z, q2.x);\n    na = (floor(a*aN/6.2831) + .5)/aN;\n    q2.xz *= rot2(-na*6.2831);\n    q2.x -= r;\n\n\n    q2.xy *= rot2(a*twists/2. - iTime*.5); // Twisting the toroidal plane objects.\n    //hole = sBoxS(q2.yz, vec2(1., 1)*r*6.2831/aN/2.*.65, .05); // Square holes.\n    hole = length(q2.yz) - r*6.2831/aN/2.*.7; // Z-axis holes.\n    \n    // Rendering the same as the torus object above, but out of \n    // sync by 90 degrees.\n    taper = smoothstep(0., 1., abs(tc.y)/dim.x)*.5 + .5; // Holowing out in the center.\n    float tor2 = sBoxS(tc, dim.yx*vec2(taper, 1), .01);\n    btc = tc; btc.y = abs(btc.y) - dim.x - dim.y;\n    float bands2 = sBoxS(btc, vec2(1, 1.5).yx*dim.y, .01);\n    //bands2 += smoothstep(0., 1., sin(a*aN*6.))*.001; // Second band ridges.\n    \n    // Second strip and second strip coordinates.\n    tor2 = smax(tor2, -hole, .02);\n    if(min(tor2, bands2)<min(tor, bands)) txCoord = vec3(tc.yx, a/6.2831);\n   \n   \n    // Combine the central strips and the outer bands. With odd turn numbers, they'll\n    // fuse together as one, and even numbers will produce separate objects.\n    tor = min(tor, tor2);\n    bands = min(bands, bands2);\n\n\n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(fl, bands, 1e5, tor);\n    \n    // Shortest distance.\n    return  min(min(tor, fl), bands);\n \n}\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    // Back wall unit direction ray. \n    // We need the direction itself for the standard cube\n    // traversal trickery.\n    gDir = step(0., rd) - .5;\n    gRd = rd;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += min(d*.9, gCD); \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t){\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = ZERO; i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n \n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable.\n    const int maxIter = 32; \n    \n    // Bumping the ray off the surface to avoid self collisions.\n    // The constant coincides with the hit condition in the \"trace\" function. \n    ro += n*.0015; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.; // Initial shadow value.\n    float t = 0.; // Initial distance.\n    float end = max(length(rd), 0.0001); // Distance from the jump point to the light.\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down.\n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this.\n        // So many options here, and none are perfect: \n        // dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Return the shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break; // Faux exit.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, -.1, 0); // \"Look At\" position.\n    vec3 ro = lk + vec3(cos(iTime/2.)*.05, .2, -1.25); // Camera position.\n \tvec3 lp = ro + vec3(-1, 1, -.5); // Light position.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n   \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the texture coordinates.\n    vec3 svTxCoord = txCoord;\n    \n\n    // Obtain the object ID.\n    objID = 0;\n    float obD = vID[0];\n    \n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n\n        // Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // Object coloring. \n        \n        if(objID==0){ // Background.\n            \n            // The dark subdivide wall.\n            vec3 txP = sp;\n            vec3 txN = sn;\n            txP.yz *= rot2(3.14159/5.);\n            vec4 p4 = getGrid(sp.xy, fSc);\n           \n            \n            vec3 tx = tex3D(iChannel1, txP*2. + .5, txN);\n            //vec3 tx = texture(iChannel1, txP.xz/3. + .4).xyz; tx *= tx;\n            //tx = smoothstep(0., 1., tx);\n            \n           \n            texCol = vec3(.4)*(hash21(p4.zw + .1)*.5 + .5);\n            texCol *= tx*2. + .1;\n            \n \n        }\n        else if(objID==1){ //  Bands.\n        \n            // Using the saved coordinates from the distance function \n            // to texture the outer bands. The sides aren't technically\n            // correct, but no one will notice.\n            \n            vec3 tx = getTex(iChannel0, svTxCoord.yz*vec2(4, 4)); \n            //vec3 tx2 = getTex(iChannel1, svTxCoord.yz*vec2(4, 4));\n            //tx = mix(tx, tx2, .5);         \n            \n            // Gold.\n            texCol = vec3(.6, .35, .15)*(tx*2. + .05);\n            // Silver -- I almost went with this but decided on gold at \n            // the last minute.\n            //texCol = vec3(.35)*(tx*2. + .05);\n            \n            // Ramping up the diffuse for a more metallic look.\n            diff = pow(diff, 8.)*2.; \n       \n            \n        }\n        else { // Strip.\n         \n            // Using the saved coordinates from the distance function \n            // to texture the central strip with holes.\n            \n            vec3 tx = getTex(iChannel0, svTxCoord.xz*vec2(2, 4));      \n             \n            // Coloring the individual blocks with the saved ID.\n            texCol = tx*.25 + .875; \n            \n            \n            //diff = pow(diff, 4.)*2.; // Diffuse ramping.\n            \n             \n        }\n        \n        \n        // Specular reflection.\n        vec3 hv = normalize(ld - rd); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel2, ref).xyz; refTx *= refTx;\n        refTx = (texCol*.75 + .25)*refTx;//smoothstep(0., .5, refTx);\n        float spRef = pow(max(dot(hv, sn), 0.), 16.); // Specular reflection.\n        float rf = objID == 0? .25 : 1.;\n        //\n        // Adding the specular reflection and glow for the inner light.\n        texCol += spRef*refTx*rf*8.;//vec3(1.4, 1, .4)*\n        \n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .25 + vec3(1, .97, .92)*spec*1.*sh);\n        \n\n        // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Fog -- A bit redundant here, but it does have a minor effect.\n    vec3 fog = vec3(1, .925, .85)*.01;\n    col = mix(col, fog, smoothstep(0., .99, t/FAR));\n    \n           \n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}