{
    "Shader": {
        "info": {
            "date": "1531175668",
            "description": "Gets pretty weird about halfway through.",
            "flags": 8,
            "hasliked": 0,
            "id": "lsyfD1",
            "likes": 12,
            "name": "Time Oscillator",
            "published": 3,
            "tags": [
                "oscilloscope",
                "music",
                "waveform"
            ],
            "usePreview": 0,
            "username": "stellartux",
            "viewed": 1016
        },
        "renderpass": [
            {
                "code": "// Graph functions taken from https://thebookofshaders.com/05/\n\nfloat plot(vec2 st, float pct) {\n    float pixel = 2./iResolution.y;\n\treturn smoothstep( pct-pixel, pct, st.y) -\n\t\t   smoothstep( pct, pct+pixel, st.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 C ) {\n    vec2 R = iResolution.xy;\n    vec2 uv = ( 2.*C - R) / R.y;\n    uv.x *= .25;\n    float t = iTime;\n    float qt = 70.;\n    float q = ((t < qt) ? 0. : (floor((t - qt)/24.) * sine((t - qt)/8.)));\n    float x = uv.x + t + q;\n    float y = (mixdown(x).x + mixdown(x).y) * 3.;\n    vec3 c = vec3(0);\n    if (abs(uv.y) < abs(y)) c.r += abs(y);\n    float pct = plot(uv, y);\n    c = (1.0-pct)*c+pct*vec3(0., 1., 0.)+plot(uv,0.)*vec3(0.,0.,1.);\n    O = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 mainSound( in int samp, float t )\n{\n    return master(t);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define TEMPO 132.\n\n// tasty functions for you to nom.\n// https://www.shadertoy.com/view/4sGfRw\n// Unlicense\nconst float TAU = 2.*acos(-1.);\nfloat sine(float a) { return sin(TAU * a); }\nfloat pwm(float a, float w) { return 1. - 2. * step(w, fract(a)); }\nfloat squa(float a) { return pwm(a, .5); }\nfloat sawt(float a) { return mix(-1., 1., fract(a-.5)); }\nfloat tria(float a) { return sawt(a * 2.) * squa(a * 2.) * squa(a); }\nfloat pv(float a) { return clamp(a, 0., 1.); }\nfloat nv(float a) { return clamp(a, -1., 0.); }\nfloat mpls(float t, float k, float r) { return pv(exp(-t * (1000. / (r+k)) - exp(-t * (1000. / k)))); }\nfloat mpls(float t) { return mpls(t, 27., 370.); }\nfloat lim(float a, float b) {return clamp(a, -b, b);}\nfloat lim(float a) {return lim(a, 1.);}\nfloat noiz(float a, float b) {\n    uint n = uint(abs(a) * (exp2(32. - 24. * pv(b)) - 1.));\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1. - 2. * float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nfloat noiz(float a) { return noiz(a, TAU-6.); }\nfloat midi(float n) { return 13.75 * exp2((n - 9.) / 12.); }\n\nfloat rhythmA (float t) {\n    float s = 0.;\n    if (mod(t, 4.) > 1.) {\n        s = pv(sine(mod(t*3.,8.)));\n    } else {\n        s = pv(sine(t*2.)) + pv(sine(t*2.+.5));\n    }\n    return s;   \n}\n\nfloat bass (float t, float tt) {\n    float n = floor( squa(tt/4.) * 2. + pwm(tt/4., .25) + nv(pwm(tt/4., .75)) * tria(tt) * sine(tt) );\n \treturn (sawt(t * midi(36. + n)) + squa(t * midi(36. + n))) * rhythmA(tt) * .01;   \n}\n\nfloat kick (float t, float tt) {\n   \treturn lim(sine(t * midi(24.)) * mpls(fract(tt*2.), 12., 150.), .1);\n}\n\nfloat snare(float t, float tt) {\n    tt += .5;\n    float k = abs(t / tt);\n    float s = (noiz(t, .75) + noiz(t, .85)) * mpls(fract(tt), 2.5, 25.);\n    s += (noiz(t, .75) + noiz(t, .85)) * mpls(fract(tt-.166), 2.5, 25.) * .666;\n    s += (noiz(t, .75) + noiz(t, .85)) * mpls(fract(tt-.333), 2.5, 25.) * .333;\n    s += (noiz(t, .75) + noiz(t, .85)) * mpls(fract(tt+.166), 2.5, 25.) * .133;\n    return lim(s);\n}\n\nvec2 mixdown (float t) {\n    float r = TEMPO / 120.;\n    float qt = 70.;\n    // TMW you modulate time over time\n    float q = ((t < qt) ? 0. : (floor((t - qt)/24.) * sine((t - qt)/8.)));\n    float tt = t * r;\n    float s = 0.;\n    s += bass(t, tt + q);\n    s += kick(t, tt + q) * .5;\n    s += snare(t, tt + q) * .06;   \n \treturn vec2(lim(s)); \n}\n\nvec2 master (float t) {\n\tvec2 s = mixdown(t);\n    float prev, curr, swap = 1.;\n    int stopper = int(t/8.) + 1;\n    for (int i = 0; i < stopper; i++) {\n    \ts += mixdown(t + curr * .03);\n        swap = curr;\n        curr += prev;\n        prev = swap;        \n    }\n    s /= float(stopper) + 2.;\n    s = clamp(s, -.7, .7) * 1.4;\n \treturn vec2(s);   \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}