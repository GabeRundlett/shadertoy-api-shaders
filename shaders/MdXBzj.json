{
    "Shader": {
        "info": {
            "date": "1496960804",
            "description": "Used as visuals in cooperation of polish demoscene musicians. \nReleased in wild compo at Decrunch copy party, 3 June 2017\n \nhttp://www.pouet.net/prod.php?which=70247",
            "flags": 96,
            "hasliked": 0,
            "id": "MdXBzj",
            "likes": 12,
            "name": "â™« Power Packed Alliance 2",
            "published": 3,
            "tags": [
                "tunnel",
                "demoscene"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 1421
        },
        "renderpass": [
            {
                "code": "/*\n\n\tTunnel2 a.k.a \"LHC\"\n    for cooperation of polish demoscene musicians, called:\n    \n    \n    \"Power Packed Alliance\".\n    -----------------------------------\n\n\thttps://www.youtube.com/watch?v=_lSReW7eRI4\n    http://www.pouet.net/prod.php?which=70247\n\n\t\n    \n    also check my chrome extension for Shadertoy:\n    https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl?hl=pl\n\n*/\n\n#define getNormal getNormalHex\n\n#define FAR 30.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 60.0\n#define FOG .4\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\n    \nvec3 light = vec3(0.0);\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec4 getFreq(float f){\n\tfloat fft  = texture( iChannel0, vec2(f, 0.25) ).x; \n\tfloat wave = texture( iChannel0, vec2(f, 0.75) ).x;\n\tvec3 col = vec3( fft, 4.0 * fft * (1.0 - fft), 1.0 - fft ) * fft;\n    return vec4(col, 1.0);\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = opU2(fBox(p, size), fBox(p, size.zxy));\n    return opU2(obj, fBox(p, size.yzx));\n}\n\nvec4 boxmap(sampler2D t, in vec3 p, vec3 n, in float k ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = texture(t, p.yz);\n\tvec4 y = texture(t, p.zx);\n\tvec4 z = texture(t, p.xy);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\nvec3 map(vec3 p) {\n    \n    vec3 \n        obj = vec3(FAR, -1.0, 0.0),\n        obj2 = obj;\n    \n    vec3 orgP = p;\n    \n    float mat = 0.;\n    \n    obj = vec3(\n        fBox(p, vec3(1.25, 1.25, INFINITY)),\n        7.,\n        0.\n    );\n    \n    pModPolar(p.yx, 8.);\n    \n    obj2 = vec3(\n        fBox(p, vec3(1.8, .9, INFINITY)),\n        8.0,\n        0.\n    );\n    \n    obj = opS2(obj, obj2);\n    \n    p = orgP;\n    p.z += 3. + t * 4.;\n    \n    obj2 = vec3(\n        fSphere(p + sin(t) / 3., 0.1),\n        6.0,\n        0.0\n    );\n    \n    p = orgP;\n    obj = opU2(obj, obj2);\n    \n    float mp = pModPolar(p.yx, 24.);\n    float rz = pModInterval1(p.z, 1.0, -INFINITY, INFINITY);\n    \n    p.y += -.9;\n  \n    obj2 = vec3(\n        fSphere(p, 0.1 + sin(mp * 8. + rz + t * 5.) / 8.),\n        ceil(mod(sin(rz) * 10., 4.)),\n        0.\n    );    \n    \n    obj = opU2(obj, obj2);\n    \n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = 50.;\nconst int MAX_ITERATIONS = 68;\n\nvec3 trace(vec3 o, vec3 d) {\n    float omega = 1.2;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 0.01;\n    float functionSign = map(o).x < 0. ? -1. : +1.;\n    vec3 mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.x;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) return vec3(INFINITY, 0., 0.);\n    \n    return vec3(candidate_t, mp.yz);\n}\n\nvec3 traceRef(vec3 ro, vec3 rd) {\n    \n    vec3 t = vec3(0., -1., 0.);\n    for (int i = 0; i < 48; i++) {\n        vec3 d = map(ro + rd * t.x);\n        t.x += d.x;\n        t.yz = d.yz;\n        \n        if (abs(d.x) < 0.015 || t.x> FAR) break;\n        \n    }\n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 38;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 10.0;\n    float dist = .05;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        shade = min(shade, k*h/dist);\n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.4), 2.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal)\n{\n    float dist = .3;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).x;\n    return clamp(sdist / dist, 0.4, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, vec2 mat) {\n    vec3 col = vec3(1.0, 0.6, .0) * .75 - .5;\n    \n    col += boxmap(iChannel0, p, n, 1.).rrr;;\n            \n    if (mat.x == 1.0) col = vec3(2.);\n    if (mat.x == 1.0) col = vec3(3.);\n    if (mat.x == 2.0) col = vec3(4.);\n    if (mat.x == 3.0) col = vec3(5.);\n\n    return col * 1. ;\n\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec2 mat) {\n\tvec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*0.05);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = .1;//pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.0);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, mat);\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(1.)*spec*2.) * atten;\n\n    // Return the color. \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n   \n    uv *= tan(radians (FOV) / 2.0);\n    \n    vol = texture(iChannel0, vec2(.75, .25)).r  * 4.; \n    \n    float \n        sk = sin(t * 2.3) * 2.0,\n        ck = cos(t * .3) * 1.0,\n        mat = 0.,\n        vol = getFreq(0.2).r / 4.;\n    \n    light = vec3(0., 0., -7. + ck * vol);        \n\n    vec3 \n        vuv = vec3(sin(t), 1., 0.),\n    \tro = vec3(0., 0. + vol, -t * 4.),\n    \tvrp =  vec3(ck * vol, vol, -4. + sk * vol ) + ro,\n        \t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        sceneColor = vec3(0.);\n\n    vec3 lp = light + ro;\n    vec3 tr = trace(ro, rd);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x);\n    ro += rd * tr.x;\n    \n    vec3 sn = getNormal(ro);\t\n    \n    float sh = softShadow(ro, lp, 6.);\n    float ao = getAO(ro, sn);\n    \n    sceneColor += doColor(ro, rd, sn, lp, tr.yz) * 2.;\n    \n    rd = reflect(rd, sn);\n\n    tr = traceRef(ro + rd * 0.1, rd);\t\n    \n    ro += rd * tr.x;\n    sn = getNormal(ro);\n    \n    vec3 dc = doColor(ro, rd, sn, lp, tr.yz).rrr * .1;\n\t\n    sceneColor += dc;\n    sceneColor *= fog;\n    sceneColor *= ao;\n    sceneColor *= sh;\n    \n    fragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// smooth audio texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    // smooth\n    float old = pow(texture(iChannel1, uv).r, 1.2);\n    float current = pow(texture(iChannel0, uv).r, 1.2);    \n    \n    float new = max(old, current + .15);\n    \n    new -= 0.001;\n    fragColor = vec4(clamp(new, 0., 1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 9938,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/decrunch/power-packed-alliance"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}