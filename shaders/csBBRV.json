{
    "Shader": {
        "info": {
            "date": "1689913233",
            "description": "just to remind my old shader algorithm.\ni forgot it by my self!\nthis time, with a scalable grid size.",
            "flags": 0,
            "hasliked": 0,
            "id": "csBBRV",
            "likes": 23,
            "name": "many balls around me",
            "published": 3,
            "tags": [
                "cineshader",
                "neighbors"
            ],
            "usePreview": 1,
            "username": "iY0Yi",
            "viewed": 1809
        },
        "renderpass": [
            {
                "code": "#define PI acos(-1.)\n#define TAU (PI*2.)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// \"hash11()\" - \"hash44()\"\n// by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash13(vec3 p3) {\n    p3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nvec4 bUni(vec4 a, vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\n// from iq\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n#define MIN_DIST 0.001\n#define MAX_DIST 1500.0\n#define COL_AMB vec3(0.541,0.718,1.000)\n#define COL_L0 vec3(1.000,0.965,0.898)\n#define COL_FLR vec3(0.792,0.769,0.780)*(1./PI)\n#define COL_S1 vec3(0.537,0.561,0.580)*(1./PI)\n#define COL_S2 vec3(0.259,1.000,0.545)*(1./PI)\n#define COL_S3 vec3(0.224,0.596,0.996)*(1./PI)\n#define COL_S4 vec3(0.545,0.302,1.000)*(1./PI)\n\n// i forgot where i found these bx_cossin()...\n// maybe from eiffie's shader\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\nvec3 grd = vec3(0);\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, vec3(0));\n    \n    float sphereRad = .5*(cos(iTime*.25)+1.)+.2;\n    float gridSize = pow(sin(iTime)*5.+5.,1.5)*2.+sphereRad*1.5;\n\n    // grid\n    vec3 q = p;\n    q.xz = mod(q.xz, gridSize);\n    q.y-= sphereRad;\n    \n    vec2 iqq = floor(p.xz/gridSize);\n    \n    bool bw = sin(iTime*.5+PI*.25)>0.;\n    \n    // tap only 4 neighbors\n    // see the image posted as comment\n    for(int x=-1; x<=0; x++)\n    for(int z=-1; z<=0; z++){\n    \n        vec2 offset = vec2(x,z);\n        vec2 rnd = hash22(iqq-offset);\n\n        // neighbor cell position\n        vec3 qq = q;\n        qq.xz+=offset*gridSize; \n        \n        // animation\n        float v =  rnd.x * iTime*.5 * sign(rnd.y-rnd.x); \n        vec2 sq = bx_cossin(v)*(gridSize-sphereRad)*rnd.y;\n        qq.xz+= sq;\n        \n        // jumping. just for fun.\n        float j = abs(sin(rnd.x*3.+iTime*3.*4.))*rnd.x*5.;\n        qq.y-=j;\n        \n        // random color\n        vec2 iq = abs(iqq-offset);\n        iq = vec2(int(iq.x)%2, int(iq.y)%2);\n        float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .05 : .05;\n        vec3 m = (rnd.y<.5) ? (tile<.5)?COL_S1:COL_S2 : (tile<.5)?COL_S3:COL_S4;\n        \n        // me\n        if(length(vec3(p.x,j,p.z))<sphereRad+.01 )m=vec3(bw?.9:.005);\n        \n        res = bUni(vec4(length(qq)-sphereRad, m), res);\n        res = bUni(vec4(sdCapsule(qq, vec3(0), vec3(sq.x, -sphereRad-j, sq.y), .03), m), res);\n        res = bUni(vec4(length(q+vec3(offset.x*gridSize,sphereRad,offset.y*gridSize))-.15, m), res);\n    }\n    \n    // prevent overshooting\n    res.x = min(res.x, -sdBox(q.xz-vec2(gridSize)*.5, vec2(gridSize)*.75));\n    \n    // floor\n    vec2 iq = abs(floor(iqq));\n    iq = vec2(int(iq.x)%2, int(iq.y)%2);\n    float tile = max(smoothstep(gridSize*.995*.5, gridSize*1.0005*.5, abs(q.x-gridSize*.5)),smoothstep(gridSize*.995*.5, gridSize*1.0005*.5, abs(q.z-gridSize*.5)));\n    if(!bw)tile=1.-tile;\n    else tile=.025+.975*tile;\n    res = bUni(vec4(p.y, COL_FLR*tile),res);\n    \n\treturn res;\n}\n\nvec4 intersect(vec3 ro, vec3 rd){\n\tfloat d = 1.;\n\tvec3  m = vec3(0);\n    grd=rd;\n\tfor (int i = 0; i < 600; i++){\n\t\tvec4 res = sdScene(ro + d * rd);\n\t\tm = res.yzw;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p){\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ ){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 ldir){\n\tfloat mint=.001;\n\tfloat maxt=5.;\n\tfloat k = 40.;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfor( int i=0; i < 80; i++){\n\t\tfloat h = sdScene(o + ldir*t).x;\n\t\tres = min( res, k*h/t);\n\t\tt += h;\n\t\tif( res<0.01 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Multi Level AO\" by iY0Yi\n// https://www.shadertoy.com/view/fsBfDR\nfloat aoSeed = 0.;\nconst float MAX_SAMP = 4.;\nfloat ao(vec3 p, vec3 n, float sphereRadius) {\n    float ao = 0.;\n    for(float i = 0.; i <= MAX_SAMP; i++) {\n        vec2 rnd = hash21(i + 1. + aoSeed);\n\n        float scale = (i + 1.)/MAX_SAMP;\n        scale = mix(.0, 1., pow(scale, .5));\n\n        rnd.x = (rnd.x * 2. - 1.) * PI * .5;\n        rnd.y = (rnd.y * 2. - 1.) * PI;\n        vec3 rd = normalize(n + hash21(i + 2. + aoSeed).xyx);\n        rd.xy *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n        rd.xz *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n\n        rd *= sign(dot(rd, n));\n\n        float raylen = sphereRadius * scale;\n        vec3 rndp = p + normalize(n + rd) * raylen;\n        float res = sdScene(rndp).x;\n        ao += res;\n        aoSeed++;\n    }\n    return ao/float(MAX_SAMP);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 h  = normalize(-vd+ld);\n\treturn pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\n\nvec3 mmr=vec3(0);\n\nvec3 render(vec2 uv){\n\n    // camera\n    float cL = 20.;\n    const vec3 forcus = vec3(0,-.5,0);\n    const float fov = .75;\n\n    vec3 up = vec3(0,1,0);\n    vec3 ro = vec3(0,14.,0);\n    float t = iTime;\n    ro.xz = vec2(sin(t),cos(t))*cL;\n    if(iMouse.z>.5)\n        ro.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-ro);\n    vec3 target = ro-dir;\n    vec3 cw = normalize(target - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    vec3 rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    \n    // ray march\n\tvec4 res = intersect(ro, rd);\n    \n\tvec3 p = ro + res.x * rd;\n    vec3 m = res.yzw;\n    vec3 col = COL_AMB;\n\tif (res.x<MAX_DIST){\n        vec3 ldir = normalize(vec3(-0.0875, 0.7071, -0.3935));\n\t\tvec3 n = normal(p);\n\n\t\tfloat lamb1 = sat(dot(n, ldir))*(1./PI);\n\t\tfloat lamb2 = sat(dot(n, -ldir))*(1./PI);\n\n\t\tfloat sh = shadow(p+n*.01, ldir);\n        float rgh = (length(m)<.3) ? .9 : 1.*texture(iChannel0, p.xz*.02).g*.01;\n        float spec = normalizedBlinnPhong(1./rgh, n, rd, ldir);\n        float a = ao(p-n*.1, n, .25);\n        a += ao(p-n*.25, n, .5);\n        a /= 2.;\n        \n\t\tfloat dif = lamb1;\n        \n        float hl = dot(n, ldir)*.5+.5;\n        vec3 mr = mix(vec3(0), mix(sdScene(p+ldir*.5).yzw, sdScene(p+ldir*1.5).yzw, .5), a);mmr=mr;\n\t\tdif *= sh;\n\t\tcol = mix(vec3(0), COL_L0*9., dif);\n\t\t\n\t\tcol += mix(vec3(0), COL_AMB, a)*1.5;\n\t\tcol*= m;\n        col += mix(vec3(0), mr, a*hl)*(.2+.8-sh*hl*.8)*1.5;\n\n        float intensity = .1*texture(iChannel0, p.xz*.02).g;\n\t\tspec = spec*intensity;\n\t\tcol = mix(col, col+COL_L0, spec*sh);\n\t\tcol = mix(col, COL_AMB, sat(pow(distance(ro, p)/MAX_DIST*4., 3.)));\n\t}\n    return col;\n}\n\n// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\nvec3 Tonemap_ACES(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 col = render(uv);\n    col = Tonemap_ACES(col);\n    //col=mmr;\n    col = mix(col,smoothstep(.0,1.,col),.3);\n\tcol = pow(col, vec3(.45454));\n\tfragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}