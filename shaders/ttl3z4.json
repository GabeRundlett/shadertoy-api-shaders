{
    "Shader": {
        "info": {
            "date": "1555793246",
            "description": "Ripples",
            "flags": 68,
            "hasliked": 0,
            "id": "ttl3z4",
            "likes": 12,
            "name": "Waves of sound",
            "published": 3,
            "tags": [
                "ripples",
                "physics"
            ],
            "usePreview": 0,
            "username": "madonius",
            "viewed": 1312
        },
        "renderpass": [
            {
                "code": "# define WARP 1.\n# define FREQ_RANGE 20.\n# define PI 3.141592653589793\n# define SCALE iResolution.x/\n# define SOUNDSOURCE iChannel1\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat getfrequency(float x) {\n\treturn texture(SOUNDSOURCE, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, .25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nfloat getMaxFreq(){\n\treturn texture(SOUNDSOURCE, vec2(1.)).x;\n}\n\nvec3 gradients( in vec2 fragCoord ) {\n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    return hsv2rgb(vec3 (\n        0.5+0.5*sin(0.4*iTime*WARP)*(\n            sqrt(\n                (\n                    pow(0.5-0.6*cos(0.3*WARP*iTime)*(fragCoord.x-(iResolution.x-iResolution.y)/2.)/iResolution.y,2.)\n                )\n                +\n                (\n                    pow(0.7-0.4*sin(0.15*WARP*iTime)*uv.y,2.)\n                )\n            )\n        ),\n        0.8+0.2*cos(0.2*WARP*iTime)*(\n            sqrt(\n                (\n                    pow(0.7-0.2*sin(0.5*WARP*iTime)*(fragCoord.x-(iResolution.x-iResolution.y)/2.)/iResolution.y,2.)\n                )\n                +\n                (\n                    pow(-0.1*cos(0.3*WARP*iTime)*uv.y,2.)\n                )\n        \t)\n        ),\n        0.9+0.1*sin(WARP*iTime)*(\n            sqrt(\n                (\n                    pow(0.6-\n                        sin(2.*WARP*iTime)*\n                        (\n                            fragCoord.x-(\n                                iResolution.x-iResolution.y\n                            )/2.\n                        )/iResolution.y,2.\n                       )\n                )\n                +\n                (\n                    pow(0.2-cos(WARP*iTime)*uv.y,2.)\n                )\n        \t)\n        )\n    ));\n}\n\nvec3 ripples( in vec2 fragCoord, in vec2 cent ){\n\tvec2 uv = fragCoord/iResolution.xy;\n    float scale = iResolution.x/1920.;\n    float max_rad = sqrt(\n        pow(iResolution.x,2.0)\n        +pow(iResolution.y,2.0)\n    );\n    \n    float r = sqrt(\n    \tpow(fragCoord.x-cent.x,2.0)\n        +pow(fragCoord.y-cent.y,2.0)\n    );\n    \n    return vec3 (\n    \t1.-0.9*sin((26.*(r/scale-150.*WARP*iTime)/(0.2*max_rad/scale)+0.1))\n    );\n}\n\nfloat fade( in float f_in, in float f_out){\n\tfloat warp_time = iTime*WARP;\n    float fade_duration = f_out-f_in;\n    return max(0.,min(1./(f_out-f_in)*(f_out-warp_time),1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float weight = .90;\n    float pi = 3.141592653589793;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cent = 0.5*iResolution.xy;\n    float scale = iResolution.x/1920.;\n    vec2 offset = vec2 (-.1*iResolution.y, -.1*iResolution.y);\n    vec2 cent2 = vec2 (-0.2*iResolution.x, -0.2*iResolution.y);\n    vec2 cent3 = vec2 (1.2*iResolution.x,1.2*iResolution.y);\n    vec2 cent4 = vec2 (-0.2*iResolution.x,1.2*iResolution.y);\n    vec2 cent5 = vec2 (1.2*iResolution.x,-0.2*iResolution.y);\n    vec2 cent6 = vec2 (iResolution.x/2., iResolution.y*1.05);\n    vec2 cent7 = vec2 (iResolution.x/2., -iResolution.y*0.15);\n    \n    vec3 col = fade(60.,80.)*gradients(fragCoord)*weight\n        \t   +fade(80.,60.)*(\n                   \t\t\t   hsv2rgb(vec3 (\n                                   sin(0.01*iTime)-0.4*getfrequency_smooth(\n                                       0.3*sin(\n                                           max(0.01,\n                                               min(1.,\n                                                sqrt(\n                                                    pow((cent.x-fragCoord.x)/(500.*scale),2.)\n                                                    +pow((cent.y-fragCoord.y)/(500.*scale),2.)\n                                                )\n                                               )\n                                           )   \n                                       )\n                                   ),\n                                   1.,\n                                   0.3\n                               )))\n        \t   -(\n                   +fade(25.,40.)*(\n                   \t+cos(-iTime*WARP*0.02)*ripples(fragCoord,cent3)\n                   \t+cos(-iTime*WARP*0.02)*ripples(fragCoord,cent3+offset)\n                   \t+cos(-iTime*WARP*0.02)*ripples(fragCoord,cent2)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent2+offset)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent4)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent4+offset)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent5)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent5+offset)\n                   )\n                   +fade(37.,20.)*fade(50.,60.)*(\n                   \t+2.*cos(-iTime*WARP*0.1)*ripples(fragCoord,cent6)\n                   \t+2.*cos(-iTime*WARP*0.1)*ripples(fragCoord,cent6-offset)\n                   \t+2.*cos(-iTime*WARP*0.1)*ripples(fragCoord,cent7)\n                   \t+2.*cos(-iTime*WARP*0.1)*ripples(fragCoord,cent7+offset)\n                   )\n                   /*+fade(70.,30.)*(\n                    +cos(-iTime*WARP/10.)*ripples(fragCoord,cent)\n                    +cos(-iTime*WARP/10.)*ripples(fragCoord,cent+offset)\n                   )*/\n                   +fade(80.,40.)*1.*(\n                    +(0.3+0.7*getfrequency_smooth(0.1*mod(iTime,10.))\n                     *ripples(fragCoord,cent\n                      +(0.7+0.3*getfrequency_smooth(0.1*mod(iTime,10.)))\n                      +vec2(-offset.x/4.*sin(iTime*WARP),\n                            -offset.x/4.*cos(iTime*WARP))\n                      +(0.7+0.3*getfrequency_smooth(0.1*mod(iTime,10.)))\n                       *vec2(-offset.x*4.*sin(0.4*iTime*WARP),\n                            -offset.x*4.*cos(0.4*iTime*WARP))\n                      )\n                     )\n                    +(0.3+0.7*getfrequency_smooth(0.1*mod(iTime,10.))\n                     *ripples(fragCoord,cent\n                      +(0.7+0.3*getfrequency_smooth(0.1*mod(iTime,10.)))\n                       *vec2(offset.x/4.*sin(iTime*WARP),\n                             offset.x/4.*cos(iTime*WARP))\n                      +(0.7+0.3*getfrequency_smooth(0.1*mod(iTime,10.)))\n                       *vec2(-offset.x*4.*sin(0.4*iTime*WARP),\n                             -offset.x*4.*cos(0.4*iTime*WARP))\n                      )\n                     )\n                   )\n               )*(1.-weight);\n\n    fragColor = vec4(0.2+0.8*sqrt(col),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 18431,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/bonifansius/bedtime-baby-lullaby-classical-music-mozart-bach-beethoven-pachelbel-sleep-music-1-hour"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}