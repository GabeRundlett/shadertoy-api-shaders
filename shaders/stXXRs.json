{
    "Shader": {
        "info": {
            "date": "1626296430",
            "description": "License CC0: Sommarhack warped fbm\nMore warped FBM stuff + sommarhack phoenix",
            "flags": 0,
            "hasliked": 0,
            "id": "stXXRs",
            "likes": 5,
            "name": "Sommarhack warped fbm",
            "published": 3,
            "tags": [
                "fbm",
                "warp"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 426
        },
        "renderpass": [
            {
                "code": "// License CC0: Sommarhack warped fbm\n//  More warped FBM stuff + sommarhack phoenix\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define TTIME           (TIME*TAU)\n#define DOT2(x)         dot(x, x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n\nvec2 g_qx = vec2(0.0);\nvec2 g_qy = vec2(0.0);\n\nvec2 g_rx = vec2(0.0);\nvec2 g_ry = vec2(0.0);\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat noise(vec2 p) {\n  p /= pow(1.1 + 0.25*(0.5 + 0.5*sin(0.1*(p.x + p.y) + TTIME/10.0)), 1.15);\n  float a = sin(p.x);\n  float b = cos(p.y);\n  float c = sin(p.x + p.y);\n  float d = mix(a, b, c);\n  return tanh_approx(d);\n\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm(vec2 p) {    \n  const float A = 0.57;\n  const float F = 2.1;\n  const int numOctaves = 4;\n  const mat2 rots[numOctaves] = mat2[](F*ROT(0.0/float(numOctaves)), F*ROT(1.0/float(numOctaves)), F*ROT(2.0/float(numOctaves)), F*ROT(3.0/float(numOctaves)));\n\n  float t = 0.0;\n  float f = 1.0;\n  float a = 1.0;\n  for(int i = 0; i<numOctaves; ++i) {\n    t += a*noise(f*p);\n    p *= rots[i];\n    a *= A;\n  }\n\n  return tanh_approx(0.3+t);\n}\n\nconst float scale1 = 1.4;\nconst float scale2 = 0.2; \n\nvoid compute_globals(vec2 p) {\n  const vec2 qx = vec2(1.0,3.0)*scale2;\n  const vec2 qy = vec2(5.0,2.0)*scale2;\n\n  const vec2 rx = vec2(2.0,9.0)*scale2;\n  const vec2 ry = vec2(8.0,3.0)*scale2;\n  \n  g_qx = qx*ROT(TTIME/100.0);\n  g_qy = qy*ROT(TTIME/90.0);\n\n  g_rx = rx*ROT(TTIME/80.0);\n  g_ry = ry*ROT(TTIME/70.0);\n}\n\n// https://iquilezles.org/articles/warp\nvec3 warp(in vec2 p, float d) {\n  float lp = length(p);\n  p *= ROT(-TTIME/100.0 + 0.125*length(p));\n  \n  vec2 qx = g_qx;\n  vec2 qy = g_qy;\n\n  vec2 rx = g_rx;\n  vec2 ry = g_ry;\n\n  vec2 q = vec2(fbm(p + qx),\n                fbm(p + qy));\n\n  vec2 r = vec2(fbm(0.25*p + scale1*q + rx),\n                fbm(0.5*p + scale1*q + ry));\n\n  float f = fbm(0.75*p + scale1*r);\n \n  const vec3 col1 = vec3(0.1, 0.3, 0.8);\n  const vec3 col2 = vec3(0.7, 0.3, 0.5);\n\n  float scaleIt = 1.5*(pow(abs((p.x + p.y)), 0.7));\n\n  float pp= mix(0.7, 0.35, 1.5*tanh_approx(length(p)));\n\n  float fi = tanh_approx(pow(scaleIt, pp)*d / (f - d*scaleIt));\n  vec3 col =  abs(fi + 0.1)*(+0.3 + length(q)*col1 + length(r)*col2);\n  return pow(col, vec3(2.0, 1.5, 1.5)*tanh_approx(0.25*lp));\n}\n\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Distance fields from: https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))                         : length(p-vec2(-d,0.0))-r;\n}\n\nfloat moon(vec2 p, float d, float ra, float rb ) {\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n// Imprecise faster version\nfloat fastMoon(vec2 p, float d, float ra, float rb) {\n  float d0 = length(p) - ra;\n  float d1 = length(p-vec2(d, 0.0)) - rb;\n  return max(d0, -d1);\n}\n\nfloat roundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h); // k should be const at modeling time\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(DOT2(p-vec2(1,k)))  :\n           sqrt(min(DOT2(p-vec2(0,h)),\n                    DOT2(p-vec2(1,0))));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n \nfloat plane(vec2 p, vec3 pp) {\n  return dot(p, pp.xy) + pp.z;\n}\n \nfloat summerhack(vec2 p) {\n  // As the moon shapes are mostly used for cut-outs I think there is less need for exact\n  //  moon distance and therefore rely on fastMoon instead\n  vec2 op = p;\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.385);\n  float d0 = circle(p0, 0.605);\n  vec2 p1 = p;\n  p1 -= vec2(0.0, -0.375);  \n  float d1 = vesica(p1, vec2(0.04, 0.569))-(mix(0.005, 0.035, smoothstep(0.1, 0.2, p1.y)));\n  \n  vec2 p2 = p;\n  p2 -= vec2(0.0, 0.4);\n  p2 = -p2.yx;\n  float d2 = fastMoon(p2, 0.075, 0.33, 0.275);\n  \n  vec2 p3 = p;\n  p3 -= vec2(0.0, 0.65);\n  float d3 = circle(p3, 0.367);\n  \n  vec2 p4 = p;\n  p4 -= vec2(0.0, 0.43);\n  float d4 = circle(p4, 0.29);\n  \n  vec2 p5 = p;\n  p5 -= vec2(-0.185, 0.12);\n  float d5 = circle(p5, 0.30);\n  \n  vec2 p6 = p;\n  p6 -= vec2(0.12, -0.19);\n  p6 *= ROT(0.65);\n  float d6 = vesica(p6, vec2(0.15, 0.024))-0.0175;\n  \n  vec2 p7 = p;\n  p7 -= vec2(0.0, 0.735);\n  p7 = -p7.yx;\n  float d7 = fastMoon(p7, 0.13, 0.68, 0.595);\n  \n  vec2 p8 = p;\n  p8 -= vec2(0.0, 0.7);\n  p8 = -p8.yx;\n  float d8 = fastMoon(p8, 0.1, 0.477, 0.4676);\n\n  vec2 p9 = p;\n  p9 -= vec2(0.25, 0.72);\n  p9.x = -p9.x;\n  float d9 = fastMoon(p9, 0.188, 0.73, 0.775);\n\n  vec2 p10 = op;\n  p10 -= vec2(0.0, 0.28);\n  p10 = p10.yx;\n  p10.x *= sign(op.x);\n  p10.x += (-sign(op.x)+1.0)*-0.0775;\n  float d10 = moon(p10, 0.045, 0.105, 0.095);\n\n  vec2 p11 = p;\n  p11 -= vec2(0.0, -0.78);\n  p11 = p11.yx;\n  float d11 = roundedCross(p11, 0.55);\n  \n  vec2 p12 = p;\n  float d12 = plane(p12, vec3(normalize(vec2(-4.0, 1.0)), 0.315));\n  \n  vec2 p13 = p;\n  p13 -= vec2(-0.05, -0.805);\n  float d13 = circle(p13, 0.175);\n\n  vec2 p14 = p;\n  p14 -= vec2(0.0, -0.88);\n  float d14 = p14.y;\n  \n  vec2 p15 = p;\n  p15 -= vec2(0.45, -0.4);\n  p15 = p15.yx;\n  float d15 = fastMoon(p15, 0.14, 0.4, 0.4);\n\n  vec2 p16 = op;\n  p16 -= vec2(-0.095, 0.323);\n  // Cheat to remove discontinuity in distance field due to hacking on d10\n  float d16 = length(p16); \n    \n  d11 = max(d11, -d13);\n  d11 = max(d11, -d14);\n  d11 = max(d11, -d15);\n  d11 = pmax(d11, -d12, 0.0125);\n\n  float dn = d3;\n  dn = min(dn, d4);\n  dn = min(dn, d2);\n  dn = min(dn, d5);\n  dn = min(dn, d6);\n  dn = min(dn, d7);\n  dn = min(dn, d8);\n  dn = min(dn, d9);\n\n  float d = d0;\n  d = max(d, -dn);\n  d = min(d, d1);\n  d = min(d, d10);\n  d = min(d, d11);\n  d = min(d, d16);\n  \n  \n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  compute_globals(p);\n  float aa = 2.0 / RESOLUTION.y;\n \n  vec3 col = vec3(0.0);  \n  float d = summerhack(p);\n  vec2 c = vec2(0.0, 0.385);\n  \n  const vec3 lcol2 = vec3(1.2, 1.3, 2.0)*1.5;\n  col = warp(p*6.0, d-0.05);\n  col = mix(2.0, 0.5, smoothstep(0.605, 1.5, length(p-c)))*col;\n  col = col;\n\n  col += lcol2*exp(-40.0*max(abs(d-mix(-0.05, -0.01, q.y)), 0.0));\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  col = mix(col, vec3(0.25*(lcol2*lcol2)*smoothstep(0.56, 0.8, q.y)), smoothstep(-aa, aa, -(d+aa*2.5)));\n  return col.zyx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}