{
    "Shader": {
        "info": {
            "date": "1674536573",
            "description": "40000 fruit-flavored sweets falling down a cube-wall, rendered via voronoi tracking with screen space ambient occlusion.\n\n*mouse to control candy dropper*\n*shift to disable ambient occlusion*\n*alt to disable FXAA*\n*up/down to zoom*",
            "flags": 48,
            "hasliked": 0,
            "id": "dlfSz4",
            "likes": 62,
            "name": "Candy Avalanche",
            "published": 3,
            "tags": [
                "3d",
                "simulation",
                "particles",
                "dynamics",
                "physics",
                "ssao"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 746
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  40000 fruit-flavored sweets falling down a cube-wall, rendered via voronoi tracking\n//  with screen space ambient occlusion.\n//\n//  This shader uses the same ideas as its predecessor, but it improves on them in\n//  several ways:\n//\n//   * SSAO can now be cast by the background. This required the system to consider\n//     the normal of the surface when deciding whether a pixel is occluded.\n//\n//   * SSAO now uses a spiral pattern instead of noise, for a smoother look.\n//\n//   * New particle stability hacks. The hackiest one is to defeat some jitter: I'm only\n//     updating the rendered position of the candies when they move more than a threshold.\n//\n//   * FXAA to smooth out the cube edges.\n//\n//  If your update is slow at all you can try to enable EIGHT_NBS in the common tab.\n//  \n//  Inspired by this vid: https://www.youtube.com/watch?v=heD5492JLRI\n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer\n//  Buffer D performs main render, light and SSAO\n//  Image performs FXAA\n//\n// ---------------------------------------------------------------------------------------\n\n// From reinder's  Post process - FXAA\n//    https://www.shadertoy.com/view/ls3GWS\n// he got it from:\n//    http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 AArender( vec2 uv2 )\n{    \n    uv2 /= iResolution.xy;\n    vec2 rcpFrame = 1. / iResolution.xy;\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n\n    vec3 rgbNW = textureLod(iChannel0, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(iChannel0, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(iChannel0, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(iChannel0, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(iChannel0, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(iChannel0, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel0, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(iChannel0, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel0, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (keyDown(KEY_CTRL))\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor.xyz = AArender(fragCoord);\n        \n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.w = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_SIZE = .08;\nconst float FAR_CLIP = 1e6;\n\n// PARTICLES\n\n// returns the ids of the four closest particles from the input\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\n\n// enable for speed if your particle update is too slow\n// this helps it two ways: faster update per particle, plus,\n// less stable so more particles fall off the screen\n#define EIGHT_NBS 0\n\n#if EIGHT_NBS\n#define L_NEIGHBORS 0\n#define R_NEIGHBORS 1\n#define POS 2\n#define RPOS 3\n#define VEL 4\n#define NUM_PARTICLE_DATA_TYPES 5\n#else\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define RPOS 5\n#define VEL 6\n#define NUM_PARTICLE_DATA_TYPES 7\n#endif\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    vec3 rPos;\n#if EIGHT_NBS\n    ivec4 nbs[2];\n#else\n    ivec4 nbs[4];\n#endif\n};\n\n// get the particle corresponding to the id\nfxParticle fxGetParticleImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n#if EIGHT_NBS\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, L_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, R_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, RPOS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.pos = particleData2.xyz;\n    particle.rPos = particleData3.xyz;\n    particle.vel = particleData4.xyz;\n#else\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, RPOS), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.nbs[2] = ivec4(particleData2);\n    particle.nbs[3] = ivec4(particleData3);\n    particle.pos = particleData4.xyz;\n    particle.rPos = particleData5.xyz;\n    particle.vel = particleData6.xyz;\n#endif\n\n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, int(iResolution.x), X)\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n#if EIGHT_NBS\n    case L_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case R_NEIGHBORS:\n        return vec4(p.nbs[1]);\n#else\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n#endif\n    case POS:  \n        return vec4(p.pos, 0);\n    case RPOS:  \n        return vec4(p.rPos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\nvec4 fxGetParticleDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromID(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// global variables, initialized via computeMaxParticles\nconst int IDEAL_MAX_PARTICLES = 40000;\nint MAX_PARTICLES = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\nvoid computeMaxParticles(vec3 res)\n{\n    MAX_PARTICLES = IDEAL_MAX_PARTICLES;\n    MAX_PARTICLES = min(MAX_PARTICLES, int(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float resolution;\n    float chuteX;\n    float chuteVel;\n    float lastMouseX;\n    float camDist;\n};\n\nvoid fxInitStateImpl(inout fxState state, vec3 iResolution)\n{\n    state.resolution = -iResolution.x * iResolution.y;\n    state.chuteX = 0.;\n    state.chuteVel = 0.05;\n    state.lastMouseX = 0.;\n    state.camDist = 10.;\n}\n\n#define fxInitState(state) fxInitStateImpl(state, iResolution)\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame, vec3 iResolution)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, 0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    \n    fxState state;\n    state.resolution = data0.x;\n    state.chuteX = data0.y;\n    state.chuteVel = data0.z;\n    state.lastMouseX = data0.w;\n    state.camDist = data1.x;\n    \n    if (iFrame == 0 || abs(state.resolution) != iResolution.x * iResolution.y)\n        fxInitStateImpl(state, iResolution);\n        \n    return state;\n}\n\n\n#define fxGetState() fxGetStateImpl(iChannel1, iFrame, iResolution)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n        return vec4(state.resolution, state.chuteX, state.chuteVel, state.lastMouseX);\n    else\n        return vec4(state.camDist, 0, 0, 0);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(fxState state, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0, 0, 0);\n    cameraPos\t = vec3(3, 1, -3) * state.camDist;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0) *.3,\n        vec4(-0.5*cameraUp, 0.0) * .3,\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft * .3 - screenPos.y * cameraUp * .3);\n}\n\n// SDFS\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat2 rotMat(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nfloat mapCubes(vec3 p)\n{\n    p.y += floor(p.x) - floor(p.z);\n    p.xz = fract(p.xz) - .5;\n\n    float d = sdBox(p, vec3(.5));\n    d = min(d, sdBox(p + vec3(1, -1, 0), vec3(.5)));\n    d = min(d, sdBox(p + vec3(0, -1, -1), vec3(.5)));\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normCubes(vec3 p)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*mapCubes(p + e.xyy) + \n\t\t\t\t\t  e.yyx*mapCubes(p + e.yyx) + \n\t\t\t\t\t  e.yxy*mapCubes(p + e.yxy) + \n\t\t\t\t\t  e.xxx*mapCubes(p + e.xxx) );\n}\n\nvec3 getChutePos(fxState state)\n{\n    return vec3(-1.5 + state.chuteX, 7, 1.5 + state.chuteX);\n}\n\nfloat mapChute(vec3 p, fxState state)\n{\n    return sdCappedCylinder(p - getChutePos(state), 1., 1.);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normChute(vec3 p, fxState state)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.0005773;\n    return normalize( e.xyy*mapChute(p + e.xyy, state) + \n\t\t\t\t\t  e.yyx*mapChute(p + e.yyx, state) + \n\t\t\t\t\t  e.yxy*mapChute(p + e.yxy, state) + \n\t\t\t\t\t  e.xxx*mapChute(p + e.xxx, state) );\n}\n\n// G BUFFER\n\n// note there are five dwords here...c is stored where the normal z would usually be, and the normal z is reconstructed\nstruct fxGBufferPixel\n{\n    vec3 n;  // normal\n    float t; // scene depth (not actually z depth)\n    float m; // material\n};\n\nvec4 fxPackGBuffer(fxGBufferPixel pix)\n{\n    // material is tucked away in where the normal's z is, so record the sign there\n    return vec4(pix.n.xy, pix.m * sign(pix.n.z), pix.t);\n}\n\nfxGBufferPixel fxUnpackGBuffer(vec4 fragColor)\n{\n    fxGBufferPixel pix;\n    pix.n.xy = fragColor.xy;\n    \n    // reconstruct the z component of the normal\n    if (fragColor.z == 0.) fragColor.z = 1e-3;\n    pix.n.z = sqrt(max(0., 1. - (pix.n.x * pix.n.x + pix.n.y * pix.n.y))) * sign(fragColor.z);\n    \n    pix.m = abs(fragColor.z);\n    pix.t = fragColor.w;\n    return pix;\n}\n\n// MISC\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0,-.005,0);\n\nvoid particleStep(inout fxParticle p, int id, fxState state)\n{\n    // init\n    vec3 h = hash3( uvec3(id, id * iFrame, iFrame) );\n\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // init particles in the holding pen\n        p.pos = vec3(0, -10, 0);\n        p.rPos = p.pos;\n        p.vel = vec3(0);\n        \n        return;\n    }\n    \n    // deactivate particles off the screen until we want to drop them\n    if (p.pos.y < -7.)\n    {        \n        if (h.x < .002)\n        {\n            // selected for being dropped from the chute\n            p.pos = getChutePos(state) + vec3(h.y - .5, -.75, h.z - .5);\n            p.vel = vec3(.5*state.chuteVel, -.01, .5*state.chuteVel);\n        }\n        else\n        {\n            // off-screen holding pen\n            p.pos = vec3(0, -10, 0);\n            p.vel = vec3(0);\n        }\n        \n        return;\n    }\n\n    // particle update\n    p.vel *= .99; // damping\n    float velMag = length(p.vel);\n    const float MAX_SPEED = .1; // clamping\n    const float MIN_SPEED = .001;\n    if (velMag > MAX_SPEED)\n    {\n        p.vel = p.vel * MAX_SPEED / velMag;\n    }\n    else if (velMag < MIN_SPEED)\n    {\n        p.vel = vec3(0);\n    }\n    p.vel += GRAVITY;\n    p.pos += p.vel; // integrate (this is done before collision so that the rendered results are position-corrected)\n\n    // collide with neighbors\n    bool noColl = true;\n    for (int i = 0; i < ((EIGHT_NBS == 1) ? 2 : 4); ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            int nid = p.nbs[i][j];\n            if (nid < 0 ) break;\n            fxParticle nb = fxGetParticle(nid);\n            vec3 dir = p.pos - nb.pos;\n            float dist = distance(nb.pos, p.pos) + 0.001;\n            dir = normalize(dir);\n\n            if (dist < PARTICLE_SIZE * 2.)\n            {\n                noColl = false;\n                \n                if (dist < PARTICLE_SIZE * .1)\n                {\n                    // we're overlapping another particle, emergency teleport; use id difference to decide direction\n                    p.pos.x += 2. * PARTICLE_SIZE * (float(id < nid) - .5);\n                    return;\n                }\n\n                float f = 1.; // relVel factor\n                float r = 1.; // restitution\n                if (nb.pos.y < p.pos.y + PARTICLE_SIZE * .3)\n                {\n                    // position correction (only applied on particles below us; stability hack)\n                    p.pos = mix(p.pos, nb.pos + dir * PARTICLE_SIZE * 2., .5);\n                }\n                else\n                {\n                    // particles above us can barely move us (stability hack)\n                    f = .8;\n                    r = .1;\n                }\n\n                // velocity correction\n                vec3 relVel = p.vel - nb.vel * f;\n                p.vel -= dot(relVel, dir) * dir * r;\n            }\n        }\n    }\n\n    // collide with boundary\n    float boundary = mapCubes(p.pos);\n    if (boundary < PARTICLE_SIZE + .01) // add margin due to SDF_EPSILON, so render and physical boundaries match\n    {\n        vec3 normal = normCubes(p.pos);\n\n        // position correction\n        p.pos += normal * (PARTICLE_SIZE + .01 - boundary);\n\n        // clip velocity\n        p.vel -= min(0., dot(p.vel, normal)) * normal * 1.2;\n    }\n    \n    // sleep particles that didn't move much (stability hack)\n    if (noColl || distance(p.pos, p.rPos) > .05 || length(p.vel) > .01)\n        p.rPos = mix(p.pos, p.rPos, .5);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id == currentId || any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int dataType, int currentId, int searchId, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX - myParticle.pos;\n    \n#if EIGHT_NBS\n    int dir = int(float(dx.x > 0.) * .5 + .5);\n#else\n    int dir = int(2.*(atan(dx.z, dx.x)+PI)/PI); \n#endif\n    if(dir != dataType) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState state, int dataType, ivec2 ifc, int id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    ivec4 bestIds = ivec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (iFrame > 0 && state.resolution > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < ((EIGHT_NBS == 1) ? 2 : 4); ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                sort0(bestIds, bestDists, dataType, id, nid, p);\n\n                // consider neighbors' neighbors\n                int h = int(hash(uvec4(ifc.x * i, ifc.y * int(iResolution.x), iFrame, j)).x);\n                int dir = h % ((EIGHT_NBS == 1) ? 2 : 4);\n                ivec4 nbsNbs = ivec4(fxGetParticleData(nid, dir));\n\n                for (int y = 0; y < 2; ++y)\n                {\n                    int nbNid = nbsNbs[y];\n                    if (nbNid < 0) break;\n                    sort0(bestIds, bestDists, dataType, id, nbNid, p);\n                }\n            }\n        }\n\n        // random search\n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int h = int(hash(uvec4(ifc.x, ifc.y * int(iResolution.x), iFrame, k)).x);\n            int hi = h % MAX_PARTICLES;\n            sort0(bestIds, bestDists, dataType, id, hi, p);\n        }\n    }\n    \n    return vec4(bestIds);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    int index = ifc.x + ifc.y * int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles(iResolution);\n    if(id>=MAX_PARTICLES) return;\n\n    fxState state = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType < POS)\n    {\n        fragColor = neighborUpdate(p, state, dataType, ifc, id);\n        return;\n    }\n    \n    particleStep(p, id, state);\n    fragColor = fxSaveParticle(p, dataType);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord, vec3 ro, vec3 rd)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    // compute screen space position\n    vec3 worldPos = fxGetParticleData(id, RPOS).xyz;\n    float t = sphIntersect(ro, rd, vec4(worldPos, PARTICLE_SIZE));\n        \n    if (t > 0. && worldPos != vec3(0))\n    {\n        return t;\n    }\n    \n    return FAR_CLIP;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n   \tivec2 ifc = ivec2(fragCoord);\n    computeMaxParticles(iResolution);\n    fxState state = fxGetState();\n    if(ifc == ivec2(0) || ifc == ivec2(1, 0))\n    {\n        // update persistent state\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0.)\n        {\n            float m = .5 - iMouse.x / iResolution.x;\n            if (iMouse.w < 0.)\n            {\n                state.chuteX = m * 16.;\n                state.chuteVel = m - state.lastMouseX;\n            }\n            \n            state.lastMouseX = m;\n        }\n        else\n        {\n            state.chuteVel -= state.chuteX * .00005;\n            state.chuteX += state.chuteVel;\n        }\n        \n        state.chuteVel *= float(abs(state.chuteX) < 8.);\n        state.chuteX = clamp(state.chuteX, -8., 8.);\n        \n        if (keyDown(KEY_UP)) state.camDist -= .1;\n        if (keyDown(KEY_DOWN)) state.camDist += .1;\n        if (keyDown(KEY_SPACE)) fxInitState(state);\n        \n        state.camDist = clamp(state.camDist, 2., 10.);\n        \n        fragColor = fxPutState(state, ifc);\n        return;\n    }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosest(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Particle(id, p, cameraPos, rayDir);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j)));\n            ivec4 nbs = ivec4(fxGetParticleData(id, h.x % 4));\n            int nid = nbs[h.y % 4];\n\n            if (nid >= 0)\n            {\n                float dis2 = distance2Particle(nid, p, cameraPos, rayDir);\n                insertion_sort( new, dis, nid, dis2 );\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint searchRange = 31u;\n        uint searchCount = 24u;\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n            ivec4 old = fxGetClosest( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n\n            for (int j = 0; j < 1; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float dis2 = distance2Particle(id, p, cameraPos, rayDir);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % MAX_PARTICLES;\n            insertion_sort(new, dis, id, distance2Particle(id, p, cameraPos, rayDir));\n        }\n    }\n    \n    fragColor = vec4(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\n\n// draw one ball\nvoid renderParticle(int id, fxParticle p, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    float t = sphIntersect(ro, rd, vec4(p.rPos, PARTICLE_SIZE));\n    if (t > 0. && t <= pix.t && p.pos != vec3(0))\n    {\n        vec3 hitPos = ro + rd * t;\n        vec3 normal = normalize(hitPos - p.rPos);\n\n        pix.n = normal;\n        pix.m = float(id + 2); // materials 0...1 are for box\n        pix.t = t;\n    }\n}\n\nvec3 marchCubes(vec3 p, vec3 rd, out float t)\n{\n    const int MAX_STEPS = 25;\n    const float SDF_EPS = .01;\n    t = dot(p, vec3(1));\n    p += rd * t;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        float d = mapCubes(p);\n        if (abs(d) < SDF_EPS) break;\n        d *= .6;\n        p += d * rd;\n        t += d;\n    }\n    return p;\n}\n\nvec3 marchChute(vec3 p, vec3 rd, out float t, fxState state)\n{\n    const int MAX_STEPS = 15;\n    const float SDF_EPS = .01;\n    t = 0.;\n    p += rd * t;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        float d = mapChute(p, state);\n        if (abs(d) < SDF_EPS) break;\n        p += d * rd;\n        t += d;\n    }\n    return p;\n}\n\nvoid renderScene(vec3 cameraPos, vec3 rayDir, fxState state, inout fxGBufferPixel pix)\n{\n    // march cubes and chute separately, otherwise it takes a lot of steps to get around the chute\n    float cubeT;\n    vec3 cubeHitPos = marchCubes(cameraPos, rayDir, cubeT);\n    vec3 cubeNormal = normCubes(cubeHitPos);\n    \n    float chuteT;\n    vec3 chuteHitPos = marchChute(cameraPos, rayDir, chuteT, state);\n    vec3 chuteNormal = normChute(chuteHitPos, state);\n    \n    if (cubeT < chuteT)\n    {\n        pix.n = cubeNormal;\n        pix.t = cubeT;\n        pix.m = 0.;\n    }\n    else\n    {\n        pix.n = chuteNormal;\n        pix.t = chuteT;\n        pix.m = 1.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n   \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    fxGBufferPixel pix;\n    pix.t = FAR_CLIP;\n    \n    // render box\n    renderScene(cameraPos, rayDir, state, pix);\n\n    // render particles\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        fxParticle data = fxGetParticle(id);\n        renderParticle(id, data, cameraPos, rayDir, pix);\n    }\n    \n    fragColor = fxPackGBuffer(pix);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Main render\n// ---------------------------------------------------------------------------------------\n\n// decode color from G buffer material\n#define RGB(R, G, B) vec3(float(R), float(G), float(B)) / 255.0\nvec3 materialColor(float c)\n{\n    if (c <= .5) return vec3(1);\n    if (c <= 1.5) return vec3(.25);\n    \n    // sphere colors\n    switch(int(c - 2.) % 5)\n    {\n        case 0: return RGB(255,46,0);\n        case 1: return RGB(221,150,2);\n        case 2: return RGB(4,150,7);\n        case 3: return RGB(48,11,53);\n        case 4: return RGB(140,4,12); \n    }\n}\n\nfloat calcAO(fxGBufferPixel pix, vec2 fragCoord, vec3 sNorm)\n{\n    if (pix.m == 1.) return 1.;// chute doesn't get occluded\n    if (keyDown(KEY_SHIFT)) return 1.;\n    \n    // sample neighbor pixels\n    float ao = 0.;\n    const float SAMPLES = 20.; // increase for higher quality if your GPU can handle it\n    for( float i=0.; i<SAMPLES; i++ )\n    {\n        // compute an offset in a spiral pattern\n        vec2 off = vec2(.2 + i * 40. / SAMPLES, 0) * rotMat(i * 20. / SAMPLES) / pix.t;\n        off += .1 * sNorm.xy / sNorm.z; // search more in the diretion of surface normal\n\n        // sample the zbuffer at a neightbor pixel\t\t\n        fxGBufferPixel nbPix = fxUnpackGBuffer(texture(iChannel0, (fragCoord.xy) / iResolution.xy + off * .015));\n\n        if (nbPix.m != 1.) // chute doesn't cause occlusion (prevents black halo)\n        {\n            vec2 td = min(vec2(0), 2. * sNorm.xy * off / sNorm.z);\n            float xt = pix.t + td.x + td.y - PARTICLE_SIZE * .0; // expected t based on plane determined by initial point and slope\n\n            // accumulate occlusion\t\n            float dt = xt - nbPix.t;\n            ao += smoothstep(0., .1, dt) * smoothstep(1., .5, dt); // blend out below .1 (not taller) and above .5 (foreground object)\n        }\n    }\n    \n    // average down the occlusion\t\n    return clamp(1. - pow(ao,1.4)/SAMPLES, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    fxGBufferPixel pix = fxUnpackGBuffer(texture(iChannel0, fragCoord/iResolution.xy));\n    if (pix.t >= FAR_CLIP)\n    {\n        // background\n        fragColor = vec4(.2);\n    }\n    else\n    {    \n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n        vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n        // construct basis for screen-space normal\n        vec3 left = -normalize(cross(rayDir, vec3(0, 1, 0)));\n        vec3 up = normalize(cross(left, rayDir));\n        mat3 basis = mat3(left, up, rayDir);\n\n        // screen-space normal\n        vec3 sNorm = pix.n * basis;\n        \n        float ao = calcAO(pix, fragCoord, sNorm);\n        \n        // lighting\n        const vec3 LIGHT_DIR = normalize(vec3(.5, 1, -.7));\n        float nDotL = max(dot(pix.n, LIGHT_DIR), .0);\n        float dif = ao * (nDotL * .9 + .1) + .1;\n        vec3 reflection = reflect(-LIGHT_DIR, pix.n);\n        float spec = ao * pow(max(dot(pix.n, reflection), 0.), 50.0);\n        fragColor.xyz = materialColor(pix.m) * dif + spec;\n    }\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 5.; // multiply with sth for intensity\n    vig = sqrt(vig); // change pow for modifying the extend of the  vignette\n    fragColor *= vig;\n\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}