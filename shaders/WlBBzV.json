{
    "Shader": {
        "info": {
            "date": "1599325807",
            "description": "Just a squishy donut cat, based on a drawing by my daughter (Misha). :)\n\nBased on my 'Blender donut' (https://www.shadertoy.com/view/ttfyWB).",
            "flags": 0,
            "hasliked": 0,
            "id": "WlBBzV",
            "likes": 30,
            "name": "Squishy Donut Cat",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "cat",
                "realtime",
                "donut",
                "squishy",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 17732
        },
        "renderpass": [
            {
                "code": "// 'Squishy donut cat'\n//\n// My daughter made a sketch of a 'squishy' in a donut.\n// A few hours later, a new shader is born.\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Based on my 'Blender donut'\n// https://www.shadertoy.com/view/ttfyWB\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\treturn (noise(p) + noise((p + .2) * 1.98) * .5 + noise((p + .66) * 4.12) * .25) / 1.75;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t\t  s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.z -= clamp(p.z, 0., h);\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return sqrt(dot(p, p) + ra * ra - 2. * ra * k) - rb;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 forward = normalize(lookAt - ro),\n\t\t right = normalize(cross(vec3(0, 1, 0), forward)),\n\t\t up = cross(forward, right);\n\treturn normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nvec2 sdDonut(vec3 p) {\n\treturn vec2(sdTorus(p, vec2(4, 1.4)), 1.5);\n}\n\nfloat fbmc;\nvec2 sdCream(vec3 p) {\n\tfloat d = abs(p.y + fbmc + .7) - 2.3;\n\treturn vec2(max(sdDonut(p).x, -d) - .13, 2.5);\n}\n\nvec2 sdSprinkles(vec3 p) {\n\tfloat dd = sdCream(p - vec3(0, .05, 0)).x;\n\n\tvec3 id = floor(p / .3);\n\n\tmat2 r = rot(noise(id) * 3.141);\n\tp.xz *= r;\n\tp.xy *= r;\n\tp.xz *= r;\n\n\tp = mod(p, .3) - .15;\n\n\tp.xz *= r;\n\tp.xy *= r;\n\tp.xz *= r;\n\tfloat d = max(sdCapsule(p, .3, .02), dd);\n\n\treturn vec2(d, mod(id.x, 6.) + mod(id.y, 6.) + mod(id.z, 6.) + 10.5);\n}\n\nvec2 map(vec3 p) {\n\tfbmc = fbm(p * .6) * 2.;\n\tvec2 d = sdDonut(p) - fbm(p * 8.) * .02;\n\td = min2(d, sdCream(p));\n\td = min2(d, sdSprinkles(p));\n\td = min2(d, vec2(p.y + 1.7, 3.5));\n\n\tvec3 mp = p;\n\tmp.x = abs(mp.x);\n\n\t// Paws.\n\tvec2 cat = vec2(length(mp - vec3(1.3, 1.4, -3.96)) - .2, 7.5);\n\tcat = min2(cat, vec2(length(mp - vec3(1.5, 1.4, -4)) - .2, 7.5));\n\tcat = min2(cat, vec2(length(mp - vec3(1.7, 1.45, -3.86)) - .2, 7.5));\n\tcat = min2(cat, vec2(length(mp - vec3(1.5, 1.3, -3.5)) - .6, 6.5));\n\n\t// Body\n\tmp.y += (sin(iTime)+0.33*sin(iTime * 3.)) * .5;\n\tcat = min2(cat, vec2(sdCapsule(mp.xzy, 1.6, 3.), 6.5));\n\n\t// Eyes.\n\tcat = min2(cat, vec2(length(mp - vec3(.8, 2.4, -2.3)) - .7, 5.5));\n\n\t// Ears.\n\tvec3 ep = mp;\n\tep.xz *= rot(-.5 + sin(iTime * 2.) * .1);\n\tfloat ear = length(ep - vec3(2, 4, 0)) - .8;\n\tear = max(ear, -ep.z);\n\tcat.x = smin(cat.x, ear, .3);\n\n\t// Nose.\n\tvec3 np = mp - vec3(0, 1.9, -2.9);\n\tfloat nose = sdCapsule(np, vec3(0), vec3(.16, .16, 0), .15);\n\tnose = smin(nose, sdCapsule(np * vec3(-1, 1, 1), vec3(0), vec3(.16, .16, 0), .15), .05);\n\tcat = min2(cat, vec2(nose, 2.5));\n\n\t// Mouth.\n\tnp.x = abs(np.x);\n\tnp -= vec3(.2, -.1, -.1);\n\tfloat mouth = sdCappedTorus(np, vec2(-1, 0), .2, .05);\n\tcat = min2(cat, vec2(mouth, 8.5));\n\n\treturn min2(d, cat);\n}\n\nvec3 calcNormal(vec3 p) {\n\tvec2 e = vec2(.00005, -.00005);\n\treturn normalize(e.xyy * map(p + e.xyy).x +\n\t\t\t\t\t e.yyx * map(p + e.yyx).x +\n\t\t\t\t\t e.yxy * map(p + e.yxy).x +\n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n\tvec3 rd = normalize(lightPos - p);\n\n\tfloat h,\n\t\t  minH = 1.,\n\t\t  d = .7;\n\tfor (int i = 0; i < 16; i++) {\n\t\th = map(p + rd * d).x;\n\t\tminH = abs(h / d);\n\t\tif (minH < .01)\n\t\t\treturn 0.;\n\t\td += h;\n\t}\n\n\treturn minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n\tconst float dist = .3;\n\treturn 1. - (dist - map(p + n * dist).x) * strength;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col,\n\n\t// Raymarch.\n\t\t ro = vec3(sin(iTime * .3) * 2., 4. + cos(iTime * .6) * .5, -12.),\n\t\t rd = getRayDir(ro, vec3(0, 1, 0), uv);\n\n\tint hit = 0;\n\tfloat d = .01;\n\tvec3 p;\n\tfor (float steps = 0.; steps < 128.; steps++) {\n\t\tp = ro + rd * d;\n\t\tvec2 h = map(p);\n\n\t\tif (h.x < .001) {\n\t\t\thit = int(h.y);\n\t\t\tbreak;\n\t\t}\n\n\t\td += h.x;\n\t}\n\n\tif (hit > 0) {\n\t\tvec3 n = calcNormal(p),\n\t\t\t lightPos = vec3(10, 7, -10),\n\t\t\t lightCol = vec3(1, .9, .8),\n\t\t\t lightToPoint = normalize(lightPos - p),\n\t\t\t skyCol = vec3(.15, .2, .25);\n\t\tfloat sha = calcShadow(p, lightPos, 5.),\n\t\t\t  occ = calcOcc(p, n, 4.),\n\t\t\t  spe = pow(max(0., dot(rd, reflect(lightToPoint, n))), 15.),\n\t\t\t  mainLight = max(0., dot(n, lightToPoint)),\n\t\t\t  backLight = clamp(dot(n, -rd), .01, 1.) * .1;\n\t\tvec3 skyLight = clamp(dot(n, vec3(0, 1, 0)), .01, 1.) * .4 * skyCol;\n\t\tfloat fog = 1. - exp(-d * .03);\n\n\t\tvec3 mat;\n\t\tif (hit == 1) {\n\t\t\t// Donut.\n\t\t\tmat = vec3(.5, .3, .2);\n\t\t} else if (hit == 2) {\n\t\t\t// Cream.\n\t\t\tmat = vec3(1, .43, .85);\n\t\t} else if (hit == 3) {\n\t\t\t// Plane.\n\t\t\tmat = vec3(.53, .81, .94);\n\t\t} else if (hit == 4) {\n\t\t\t// Eyes - White\n\t\t\tmat = vec3(.8);\n\t\t} else if (hit == 5 || hit == 8) {\n\t\t\t// Eyes - Black\n\t\t\tmat = vec3(.0001);\n\t\t} else if (hit == 6) {\n\t\t\t// Cat\n\t\t\tmat = vec3(1, 1, .5);\n\t\t} else if (hit == 7) {\n\t\t\t// Paws.\n\t\t\tmat = vec3(.4, .4, .2);\n\t\t} else if (hit >= 10) {\n\t\t\t// Sprinkles!\n\t\t\tvec3 c = vec3(float(hit)) + vec3(1, 2, 3);\n\t\t\tmat = sin(floor(c * 3.) / 3.);\n\t\t}\n\n\t\tcol = (mainLight * sha + (spe + backLight) * occ) * lightCol;\n\t\tcol += skyLight * occ;\n\t\tcol *= mat;\n\n\t\tif (hit == 5)\n\t\t\tcol += (pow(max(0., dot(rd, reflect(normalize(vec3(0, 6, -10) - p), n))), 15.) +\n\t\t\t\t   pow(max(0., dot(rd, reflect(normalize(vec3(2, -5, -10) - p), n))), 45.)) * 2.;\n\n\t\tcol = mix(col, skyCol, fog);\n\t} else {\n\t\t// Sky.\n\t\tcol = vec3(.15, .2, .25);\n\t}\n\n\t// Output to screen\n\tcol = pow(col, vec3(.4545)); // Gamma correction\n\tcol = vignette(col, fragCoord); // Fade screen corners\n\tfragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}