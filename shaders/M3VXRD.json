{
    "Shader": {
        "info": {
            "date": "1719890156",
            "description": "Given a quadrilateral, get a rounded quadrilateral with a given radius. I'm so proud of myself :3",
            "flags": 0,
            "hasliked": 0,
            "id": "M3VXRD",
            "likes": 2,
            "name": "Rounded Quadrilateral",
            "published": 3,
            "tags": [
                "rounded",
                "radius",
                "quadrilateral"
            ],
            "usePreview": 0,
            "username": "annie_weaver",
            "viewed": 96
        },
        "renderpass": [
            {
                "code": "uniform vec2 uSize;\nuniform vec4 hs;\nuniform vec4 ks;\nuniform vec4 xs;\nuniform vec4 ys;\n\nuniform sampler2D image;\n\nfloat radius = 0.05;\nfloat eps = 0.005;\n\n// for animating\nvec2 rot(vec2 z, float theta) {\n    return vec2(z.x*cos(theta) + z.y*sin(theta), z.y*cos(theta) - z.x*sin(theta));\n}\nvec2 f(vec2 z) {\n    vec2 center = vec2(0.5, 0.5);\n    float theta = iTime*1.3 + cos(iTime*0.8)*cos(iTime*0.8);\n    return 0.6*rot(z - center, cos(theta*0.1)) + center;\n}\nvec2 g(vec2 z) {\n    vec2 center = vec2(0.5, 0.5);\n    return (z-center) * (0.8 + 0.4*cos(iTime*1.1)) + center;\n}\nvec2 h(vec2 z) {\n    vec2 center = vec2(0.5, 0.5);\n    return (z-center) * (0.6 + 0.5*cos(iTime/2.237)) + center;\n}\n\nvec2 normal(vec2 z) {\n    return vec2(z.y, -z.x);\n}\n\n// derived by me :)\nvec2 innerQuadPt(vec2 P0, vec2 P1, vec2 P2, float r) {\n    vec2 N = normal(P1-P0)/length(P1-P0), M = normal(P2-P1)/length(P2-P1);\n    vec2 A = P0-r*N;\n    vec2 B = P1-P0;\n    vec2 C = P1-r*M;\n    vec2 D = P2-P1;\n    float s = dot(C-A, normal(D)) / dot(B, normal(D));\n    return P0 + (P1-P0)*s - r*N;\n}\nfloat sdPolygon(vec2 p, vec2 v0, vec2 v1, vec2 v2, vec2 v3) {\n    // from Inigo Quilez. Love him <3\n    vec2[] v = vec2[](v0, v1, v2, v3);\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i = 0, j = 3; i < 4; j = i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e * clamp(dot(w, e) / dot(e, e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n        bvec3 cond = bvec3(p.y >= v[i].y, p.y < v[j].y, e.x*w.y > e.y*w.x);\n        if(all(cond) || all(not(cond))) s = -s;\n    }\n    return s*sqrt(d);\n}\nfloat roundedSDF(vec2 x, vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    vec2 np0 = innerQuadPt(p0, p1, p2, radius),\n         np1 = innerQuadPt(p1, p2, p3, radius),\n         np2 = innerQuadPt(p2, p3, p0, radius),\n         np3 = innerQuadPt(p3, p0, p1, radius);\n    return sdPolygon(x, np0, np1, np2, np3)-radius;\n}\n\n// for rendering (again)\nfloat dist(vec2 a, vec2 b) {\n    return dot(b-a, b-a);\n}\nbool circle(vec2 x, vec2 pt, float r) {\n    return dist(x, pt) > r*r && dist(x, pt) < (r+eps)*(r+eps);\n}\nbool point(vec2 x, vec2 pt) {\n    return circle(x, pt, 0.0);\n}\n\nfloat smoothsep(float x) {\n    if(x <= 0.0) return 0.0;\n    if(x >= 1.0) return 1.0;\n    return 3.0*x*x - 2.0*x*x*x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n    float size = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / vec2(size, size) + vec2(0.5, 0.5);\n    \n    // Artifact of how I did this earlier that I'm too lazy to remove.\n    vec4 hs = vec4(0.0, 1.0, 1.0, 0.0);\n    vec4 ks = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 xs = vec4(0.0, 1.0, 1.0, 0.0);\n    vec4 ys = vec4(0.0, 0.0, 1.0, 1.0);\n\n    // input points. These get mapped to the corresponding X points\n    vec2 H0 = f(g(vec2(hs.x, ks.x)));\n    vec2 H1 = f(h(vec2(hs.y, ks.y)));\n    vec2 H2 = f(g(vec2(hs.z, ks.z)));\n    vec2 H3 = f(vec2(hs.w, ks.w));\n              \n    vec3 col = vec3(0.5, 0.5, 0.5); // texture(iChannel0, uv).xyz;\n       \n    float away = roundedSDF(uv, H0, H1, H2, H3);\n       \n    if(away < 0.0) {\n        float lerpt = smoothsep(-away*64.0);\n        col = vec3(0.0, 1.0, 0.5) * lerpt;\n    }\n    \n    if(point(uv, H0) || point(uv, H1) || point(uv, H2) || point(uv, H3))\n    col = vec3(0.0, 0.0, 0.0);\n     \n    if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n        col = vec3(0.0, 0.0, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}