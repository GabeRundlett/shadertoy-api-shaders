{
    "Shader": {
        "info": {
            "date": "1670423388",
            "description": "Just a simple visualizer",
            "flags": 0,
            "hasliked": 0,
            "id": "dsjXDm",
            "likes": 8,
            "name": "SphericalFibonacci",
            "published": 3,
            "tags": [
                "sphericalfibonacci",
                "hemisphericalfibonacci"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 643
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.1415926535\n\n\n// set to 0 for spherical fibonacci\n#define HEMISPHERICAL 1\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nconst float gNum = 64.;\n\n// from http://gec.di.uminho.pt/psantos/Publications_ficheiros/SF_CGF2013.pdf\n\n// unoptimized version\n\n// j: index of the point to generate\nvec3 sphericalFibonacci(float j)\n{\n    //float phi = 2. * PI * j * (2. / (1. + sqrt(5.)));\n    float phi = 2. * PI * j * (2. / (3. - sqrt(5.)));\n    float theta = acos(1. - 2. * j / gNum);\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\nvec3 HemisphericalFibonacci(float j)\n{\n    float phi = 2. * PI * j * (2. / (3. - sqrt(5.)));\n    float theta = acos(1. - (2. * j + 1.) / (2. * gNum));\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\nfloat gRayId = 0.;\n\nfloat map(vec3 p)\n{\n    p.xyz = p.xzy;\n    float d = 100.;\n    for(float i = 1.; i < gNum; i += 1.)\n    {\n    \n    #if HEMISPHERICAL\n        vec3 q = HemisphericalFibonacci(i);\n    #else\n        vec3 q = sphericalFibonacci(i);\n    #endif\n        \n        float dd = length(p-q) - 0.05;\n        if(d > dd)\n        {\n            gRayId = i;\n            d = dd;\n        }\n    }\n    \n    float d0 = length(p) - .99;\n    if(d > d0)\n    {\n        gRayId = -1.;\n        d = d0;\n    }\n    return d;\n}\n\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t = 0.1;\n    float d = 1e10;\n    for(int i = 0; i < 128; ++i)\n    {\n        if(d < 0.001 || t > 100.)\n            break;\n            \n        d = map(ro + t * rd);\n        t += d;\n    }\n    \n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps=vec2(0.001,0.);\n    return normalize(vec3(map(p+eps.xyy)-map(p-eps.xyy),\n                    map(p+eps.yxy)-map(p-eps.yxy),\n                    map(p+eps.yyx)-map(p-eps.yyx)));\n}\n\nmat3 cam(vec3 ro, vec3 ta)\n{\n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    return mat3(r,u,f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * 2.;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec3 ta = vec3(0);\n    vec3 ro = vec3(cos(0.1*time + 7.0*mo.x), mo.y*2. - 1., sin(0.1*time + 7.0*mo.x) )*-3.;\n    vec3 rd = normalize(cam(ro, ta) * vec3(p.x, p.y, 2.3));\n    \n    float t = intersect(ro, rd);\n    \n    vec3 col = vec3(1., 0.98, 0.94);\n    \n    if(t < 100.)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = getNormal(pos);\n        \n        if(gRayId < 0.)\n            col = vec3(.3);\n        else\n            col = hsv2rgb(vec3(gRayId / gNum, 1., 1.));\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}