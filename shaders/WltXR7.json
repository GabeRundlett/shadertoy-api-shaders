{
    "Shader": {
        "info": {
            "date": "1580670666",
            "description": "Wrote an isometric engine.\nIf you would like to use it, you can fill up the sdMain() function with your code.\nThe sdIso() function is where the repetition magic happens, it's a heavy read.",
            "flags": 0,
            "hasliked": 0,
            "id": "WltXR7",
            "likes": 6,
            "name": "Day 45 - Isometric",
            "published": 3,
            "tags": [
                "isometric",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 388
        },
        "renderpass": [
            {
                "code": "vec3 glow = vec3(0);\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pmod(p, x) mod(p, x) - x*0.5\n#define pi acos(-1.)\n\n#define iTime 0.5*(iTime + 1.*pi/2.)\n#define modDist vec2(1.42,1.)\n\n#define xOffs 0.71\n#define yOffs 0.7\n\n#define ZOOM 5.\n#define mx (50.*iMouse.x/iResolution.x)\n#define my (-iTime + 50.*iMouse.y/iResolution.x)\nfloat sdBox(vec3 p, vec3 r){\n\tp = abs(p) - r;\n\treturn max(p.x, max(p.y, p.z));\n}\n\n\nfloat sdBoxIQ( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOcta(vec3 p, vec3 s, vec2 id){\n\tp = abs(p) - s;\n    float d = max(p.x, max(p.y, p.z));\n    \n    d =  dot(p.xz + s.zx*0.5, normalize(vec2(1)));\n    \n    d = max(d, dot(p.xy + s.xy*0.5, normalize(vec2(1))));\n    \n    d = max(d, dot(p.yz + s.xy*0.5, normalize(vec2(1))));\n    \n    return d;\n}\n\nfloat sdRuby(vec3 p, vec3 s){\n\tp = abs(p) - s*0.9;\n    float d = max(p.x, max(p.y, p.z));\n\t//p = abs(p);\n    //p.xy *= rot(0.125*pi);\n    d = max(d, dot(p.xz + s.xz*0.5, normalize(vec2(1))));\n    \n    d = max(d, dot(p.yz + s.zy*0.5, normalize(vec2(1))));\n    //d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1))));\n    \n    return d;\n\n\n}\nfloat sdMain(vec3 p, vec2 idD){\n\tfloat d = 10e6;\n    \n    \n    \n    //p.xz *= rot(0. + iTime);\n    \n    d = sdBox(p, vec3(0.51));\n    //p.zy *= rot(-0.2565*pi );\n    //p.xy *= rot(-0.25*pi);\n    \n    #define tau (2.*pi)\n    float T = 7.*iTime/tau;\n    \n    \n    \n    vec3 s = vec3(0.5 + sin(iTime)*0.7);\n    \n    if(mod(floor(iTime/tau), 2.) == 1.){\n        for(int i = 0; i < 4; i++){\n            p = abs(p);\n\n            p.xy  *= rot(1.5*pi + sin(iTime)*0. + idD.x*pi);\n            p.xz *= rot(0.99);\n            //p.x -= 0.02;\n        }\n    \ts = vec3(0.5 + sin(iTime)*0.35);\n    }\n    //p = abs(p);\n    \n    d = min(d, sdOcta(p, s, idD));\n    \n    //d = max(d, -sdOcta(p, vec3(0.4 + sin(iTime)*0.5), idD));\n    //d = min(d, sdOcta(p, vec3(0.4 + sin(iTime)*0.5), idD));\n    \n    \n    \n\treturn d;\n}\n\n\nvec2 id;\n\nfloat sdIso(vec3 p, vec2 id){\n\tfloat d = 10e6;\n    //p.z -= 0.;\n    vec3 q = p;\n    \n    // ME\n    p.x -= id.y*xOffs;\n    p.y += id.y*yOffs;\n    p.xz = pmod(p.xz, modDist);\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, id));\n    \n    vec2 idD = id;\n    \n    // BOTTOM\n    p = q;\n    idD.y += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0,0. - id.y), vec2(modDist.x,modDist.y*3.));\n    \n    if (p.x > 0.){\n        idD.x -= 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n\n    // RIGHT\n    p = q;\n    idD = id;\n    idD.x -= 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // LEFT\n    p = q;\n    idD = id;\n    idD.x += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // TOP\n    idD = id;\n    idD.y -= 1.;\n    p = q;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0.,-1. - id.y), vec2(modDist.x,modDist.y*3.));\n    if (p.x < 0.){\n      idD.x += 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n    \n\treturn d;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    p.x += 0.5;\n    id = floor(p.xz/modDist);\n    id.x = floor((p.x - modDist.x*0.5*id.y)/modDist.x);\n    \n    d.x = min(d.x, sdIso(p, id));\n    \n    d.x *= 0.55;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tp = ro;\n    vec2 d;\n    hit = false;\n    for(int i = 0; i < 280 ;i++){\n    \td = map(p);\n        glow += exp(-d.x*6.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro );\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    ro -= ZOOM*dir;\n\treturn dir + right*uv.x + up*uv.y;\n}\nvec3 getRdIsometric(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 rd = normalize(\n        lookAt -\n        ro\n    );\n    \n    vec3 right = normalize(cross(vec3(0,1,0), rd));\n    vec3 up = normalize(cross(rd, right));\n    \n    \n    ro += right*uv.x*ZOOM;\n    ro += up*uv.y*ZOOM;\n \treturn rd;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0.0);\n    vec3 lookAt = vec3(0,-1,-2);\n    \n    \n    vec3 ro = vec3(0,8,0);\n   \n    vec3 rd = getRdIsometric(ro, lookAt, uv); \n    //vec3 rd = getRd(ro, lookAt, uv); \n        \n    vec3 p;\n    \n    //ro.x += mx;\n    ro.z += my;\n    ro.y -= my*0.65;\n    //ro += rd*5.4;\n    \n    float t = 0.; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if (hit){\n        vec3 n =-getNormal(p);\n        n.g*=0.4;\n        \n    \tcol += 0.8 + n*0.5;\n    \t\n    } else {\n    \n    }\n    \n    \n    col += glow*0.02;\n    \n    col = max(col, 0.);\n    \n    col = clamp(col, 0., 1.);\n    \n    \n    col = pow(col, vec3(1.7));\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}