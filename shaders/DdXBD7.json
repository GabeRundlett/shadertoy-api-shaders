{
    "Shader": {
        "info": {
            "date": "1689012179",
            "description": "All year long I'm going to just focus on truchet tiles and the likes! \n\nI'm moving, my life is in a lot of boxes for the next week - will be aching to code by this weekend!\n",
            "flags": 0,
            "hasliked": 0,
            "id": "DdXBD7",
            "likes": 20,
            "name": "Year of Truchets #048",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "truchet",
                "pattern",
                "maze",
                "tiles"
            ],
            "usePreview": 1,
            "username": "byt3_m3chanic",
            "viewed": 364
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #048\n    07/10/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    75.\n\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a){return fract(sin(dot(a,vec2(27.609,57.583)))*4376.545);}\n//@iq ALL THE SDFS\nfloat box(vec3 p, vec3 b){vec3 d=abs(p)-b;return length(max(d,0.))+min(max(d.x,max(d.y,d.z)),.0);}\nfloat box(vec2 p, vec2 b){vec2 d=abs(p)-b;return length(max(d,0.))+min(max(d.x,d.y),.0);}\n\n//globals s = saved / g = global\nvec3 s_hit,g_hit;\nvec2 s_id,g_id;\nfloat travelspeed = 0.;\n\n//scales for all things\nconst float scale = 1./.245;\nconst float scale_h = scale*.5;\nconst vec2 s = vec2(scale)*2.;\nconst float bscale = scale*.46;\nconst vec2 pos = vec2(.5,-.5);\nconst vec2[4] ps4 = vec2[4](pos.yx,pos.xx,pos.xy,pos.yy);\n\n// 4 tap technique @Shane\nvec2 map(vec3 q3){\n    vec2 res = vec2(1e5,0.);\n\n    q3.xz += vec2(travelspeed,-travelspeed);\n    \n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n\n    float t=1e5;\n\n    for(int i =0; i<4; i++){\n        ct = ps4[i]/2. -  ps4[0]/2.;\n        p = q3.xz - ct*s;\n        ip = floor(p/s) + .5;\n        p -= (ip)*s;\n        vec2 idi = (ip + ct)*s;\n\n        float px = sin(idi.x*.873)*.275;\n        float py = cos(idi.y*.9325)*.265;\n        float ah = -floor((px+py)*scale)*scale;\n        float hs = hash21(idi)*2.;\n        ah+=.2*sin(T*hs);\n        vec3 q = vec3(p.x,q3.y+9.-ah,p.y);\n\n        // just a box\n        float b = box(q,vec3(bscale))-.125;\n        if(b<t) {\n            t = b;\n            s_id = idi+float(i)+hs;\n            s_hit = q;\n        }\n  \n    }\n    \n\tif(t<res.x) res = vec2(t,2.);\n\n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++) {\n        p = ro + rd * d;\n        vec2 t = map(p);\n        if( t.x<d*MIN_DIST) hit = true;\n        d += i<32? t.x*.25:t.x*.75;\n        m  = t.y;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 getFace(int face, vec3 p, inout vec3 mask) {\n\n    vec3 color = vec3(.5);\n    float px = 10./R.x;\n    vec2 uv = fract(p.xy/scale_h)-.5;\n    vec2 id = floor(p.xy/scale_h);\n    \n    float rnd = hash21(id+g_id.x+id.y);\n    float hsh = fract(rnd*47.31);\n    if(rnd>.5) uv.x*=-1.;\n    \n    vec2 gx = length(uv-.5)<length(uv+.5)? vec2(uv-.5):vec2(uv+.5);\n\n    float cc = length(gx)-.5;\n    if(hsh>.85) cc = min(length(uv.x),length(uv.y));\n    cc=abs(cc)-.125;\n\n    mask=vec3(cc,0,1);\n    color = mix(color, vec3(.15),smoothstep(px,-px,cc));\n\n    return vec3(1.-color);\n}\n\n// based on bmp mapping from @Passion\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( vec3 p, vec3 n, float bf, float per, int face, inout vec3 mask){\n    vec2 e = vec2(per*MIN_DIST, 0);  \n    mat3 m = mat3( \n        getFace(face, p - e.xyy,mask), \n        getFace(face, p - e.yxy,mask), \n        getFace(face, p - e.yyx,mask)\n    );\n    vec3 g = vec3(.299,.587,.114) * m; \n    g = (g-dot(getFace(face, p,mask),vec3(.299,.587,.114)))/e.x; \n    g -= n*dot(n,g);  \n    return normalize(n+g*bf);\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    bool hit = false;\n\n    vec2 ray = marcher(ro,rd,p,hit,95);\n    d = ray.x;\n    m = ray.y;\n    g_hit = s_hit;\n    g_id = s_id;\n    \n    if(hit)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-8.,11,8.);\n        vec3 l = normalize(lpos);\n \n        vec3 h = vec3(.45);\n        \n        vec3 hp = g_hit;\n        vec3 tn = n;\n        \n        vec3 cuv;\n        int face;\n        \n        if(m==2.){\n            tn = n;\n            //@Shane https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n\n            // set coords\n            if(face==0) cuv = hp.yzx;\n            if(face==1) cuv = hp.zxy;\n            if(face==2) cuv = hp.xyz;\n            if(face==3) cuv = hp.xyz;\n            if(face==4) cuv = hp.xzy;\n            if(face==5) cuv = hp.yzx;\n\n            // get bump map surface\n            vec3 mask = vec3(0);\n\n            n=doBumpMap(cuv,n,.5,d,face,mask);\n         \n            vec3 tx1 = vec3(.667,.286,.031);\n            vec3 tx2 = texture(iChannel0,cuv.xy*.5).rgb;\n        \n            mask.x=smoothstep(.011,.01,mask.x);\n            \n            h=mix(h,tx1*tx2,mask.z);\n            h=mix(h,tx2,mask.x);\n\n            ref =min(mask.x,mask.z)<.5? h:vec3(.0001);\n        }\n        \n        float diff = clamp(dot(n,l),.1,1.);\n        float shdw = 1.;\n\n        for( float t=.01; t < 16.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h*.4;\n            if( shdw<MIN_DIST ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.65);\n        \n        float spec = .65 * pow(max(dot(normalize(p-ro),reflect(l,n)),.2),24.);\n\n        RC = (h*diff) + min(spec,shdw);\n\n        ro = p+n*.05;\n        rd = reflect(rd,n);\n\n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nconst vec3 FC = vec3(0.059,0.090,0.102);\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    travelspeed=T*.5;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,16);\n    vec3 rd = normalize(vec3(uv, -1.));\n\n    // mouse //\n    float x = M.xy==vec2(0)||M.z<0. ? .07+.02*sin(T*.1) : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0)||M.z<0. ? 0. : -(M.x/R.x*2.-1.)*PI;\n    \n    mat2 rx =rot(-.68+x),ry =rot(.58+y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0),RC=vec3(0),ref=vec3(0),fill=vec3(1),p = ro;\n    float d = 0., fA = 0.;\n    \n    // reflection loop + stop unroll\n    for(int i = 0; i < 2 + min(iFrame, 0); i++){\n        RC = render(ro,rd,ref,2-i,d);\n        C = mix(C,clamp(C+RC,vec3(0),vec3(1)),fill);\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    // fog dusting\n    C = mix(C,FC, 1.-exp(-.000025*fA*fA*fA));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}