{
    "Shader": {
        "info": {
            "date": "1556494378",
            "description": "Happy Sunday! Reference: [url]https://www.youtube.com/watch?v=D003S0gYbLs[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wlX3W7",
            "likes": 6,
            "name": "A Black Cat: Luoxiaohei",
            "published": 3,
            "tags": [
                "2d",
                "cat",
                "luoxiaohei",
                "996icu",
                "ruofei"
            ],
            "usePreview": 0,
            "username": "starea",
            "viewed": 633
        },
        "renderpass": [
            {
                "code": "/*\n  Creative Commons Attribution-ShareAlike 3.0 License with 996 ICU clause:\n  \n  http://996.icu\n\n  The above license is only granted to entities that act in concordance with local labor laws.\n  In addition, the following requirements must be observed:\n\n  The licensee must not, explicitly or implicitly, request or schedule \n    their employees to work more than 45 hours in any single week.\n  The licensee must not, explicitly or implicitly, request or schedule \n    their employees to be at work consecutively for 10 hours.\n  For more information about this protest, see http://996.icu\n\n  - Ruofei Du\n  https://www.shadertoy.com/view/wlX3W7\n*/\nvec3 RenderCat(in vec2 uv) {\n  vec3 col = kWhiteColor;\n  vec2 p = uv * 1.5 + vec2(0.0, 0.1);\n  // Distorts the coordinates horizontally or vertically.\n  vec2 q = p * vec2(0.8, 1.0);\n  vec2 r = p * vec2(1.1, 1.0);\n  float alias = 3.5 / uResolution.y;\n  // Draws the face.\n  float face = SmoothCircle(q, kOrigin, kFaceRadiusUpper, alias) * step(p.y, 0.0);\n  face += SmoothCircle(r, kOrigin, kFaceRadiusLower, alias) * step(0.0, p.y);\n  face = saturate(face);\n  // Draws the left ear.\n  q = p * vec2(1.0, 0.8);\n  float ear = SmoothCircle(q + vec2(-0.4, -0.32), vec2(0.0), 0.898, alias) * step(p.x, -0.47);\n  ear += SmoothCircle(q + vec2(0.9, 0.25), vec2(0.0), 0.9, alias) * step(-0.47, p.x);\n  // Draws the right ear.\n  ear += SmoothCircle(q + vec2(0.4, -0.32), vec2(0.0), 0.898, alias) * step(0.47, p.x);\n  ear += SmoothCircle(q + vec2(-0.9, 0.25), vec2(0.0), 0.9, alias) * step(p.x, 0.47);\n  ear -= face;\n  ear*= step(0.0, p.y);\n  ear = saturate(ear);\n  col = mix(col, kGreenColor, ear);\n  // Draws the outer ear.\n  float ear_out = SmoothCircle(p + vec2(0.7, 0.5), vec2(0.0), 1.2, alias) * step(0.47, p.y) * step(-0.47, p.x);\n  ear_out += SmoothCircle(p + vec2(-0.7, 0.5), vec2(0.0), 1.2, alias) * step(0.47, p.y) * step(p.x, 0.47);\n  ear_out -= ear;\n  ear_out = saturate(ear_out);\n  col = mix(col, vec3(0.2), ear_out * 1.0);\n  // Draws the eyes.\n  col = mix(col, kBlackColor, face);\n  float eye = SmoothCircle(q + vec2(0.23, -0.1), vec2(0.0), 0.2, alias);\n  eye += SmoothCircle(q + vec2(-0.23, -0.1), vec2(0.0), 0.2, alias);\n  col = mix(col, kWhiteColor, eye);\n  eye = SmoothCircle((p * vec2(1.0, 0.8)) + vec2(0.22, -0.1), vec2(0.0), 0.15, alias);\n  eye += SmoothCircle((p * vec2(1.0, 0.8)) + vec2(-0.22, -0.1), vec2(0.0), 0.15, alias);\n  col = mix(col, kBlackColor, eye);\n  // Draws the mouth.\n  float mouth = smoothstep(-alias, 0.0, -p.y - 0.15);\n  alias *= 2.0;\n  mouth *= smoothstep(-alias, alias, p.y - 4.0 * p.x + 0.35);\n  mouth *= smoothstep(-alias, alias, p.y + 4.0 * p.x + 0.35);\n  col = mix(col, kBlueColor, saturate(mouth));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5* uResolution.xy) / uResolution.y;\n  fragColor = vec4(RenderCat(uv), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define uResolution iResolution\n#define uTime iTime\nconst float kAntiAliasing = 0.005;\nconst vec3 kBlackColor = vec3(0.0);\nconst vec3 kWhiteColor = vec3(1.0);\nconst vec3 kGreenColor = vec3(203.0, 197.0, 111.0) / 255.0;\nconst vec3 kBlueColor = vec3(104.0, 140.0, 136.0) / 255.0;\nconst vec2 kOrigin = vec2(0.0);\nconst float kFaceRadiusUpper = 0.4005;\nconst float kFaceRadiusLower = 0.551;\n\nfloat saturate(in float x) { return clamp(x, 0.0, 1.0); }\nvec2 mirror_x(in vec2 p) { return vec2(abs(p.x), p.y); }\n\nvec2 CalculateAspectRatio(in vec2 size) {\n  return pow(size.yy / size, vec2(step(size.x, size.y) * 2.0 - 1.0));\n}\n\n// Returns the distance field of a 2D circle with anti-aliasing.\nfloat SmoothCircle(in vec2 uv, in vec2 origin, float radius, float alias) {\n  return 1.0 - smoothstep(radius - alias, radius + alias,\n                          length(uv - origin));\n}\n\n// Returns the distance field of a 2D circle with default anti-aliasing.\nfloat Circle(in vec2 uv, in vec2 origin, float radius) {\n  return SmoothCircle(uv, origin, radius, kAntiAliasing);\n}\n\n/*\nvec3 color(in int x) {\n  return vec3(float(x >> 16) / 255.0, float((x >> 8) & 255) / 255.0, float(x & 255) / 255.0);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}