{
    "Shader": {
        "info": {
            "date": "1541496132",
            "description": "Multiview version (see source)",
            "flags": 32,
            "hasliked": 0,
            "id": "4ldBWl",
            "likes": 16,
            "name": "Quasi Billiards 2",
            "published": 3,
            "tags": [
                "game",
                "collision",
                "interactive",
                "ball",
                "dynamics",
                "pool"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 945
        },
        "renderpass": [
            {
                "code": "// \"Quasi Billiards 2\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Multiview version\n\n/*\n Game starts and stops automatically; alternatively, click mouse (near center\n of view) while cue is swinging to shoot, and later click to reset game; click to\n select alternative views (tracking view follows first ball still on table).\n*/\n\n#define AA  1\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 QtToRMat (vec4 q);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nvec3 qHit, vnBall;\nfloat dstFar, hbLen, bWid, dCue, aCue, nStep, runState;\nint idObj, idBall;\nbool showCue;\nconst int nBall = 16;\nconst float pi = 3.14159;\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec3 u;\n  float b, d, w, dMin, rad;\n  rad = 0.47;\n  dMin = dstFar;\n  for (int n = 0; n < nBall; n ++) {\n    u = ro - vec3 (Loadv4 (2 * n).xy, 0.05).xzy;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 hIn;\n  float dMin, d;\n  dMin = dstFar;\n  hIn = hbLen * vec2 (1., 1.75) - bWid;\n  q = p;\n  d = PrBoxDf (q, vec3 (hIn.x, 0.4, hIn.y));\n  q.y -= -0.6;\n  d = max (PrRoundBoxDf (q, vec3 (hIn.x + 0.6, 0.5, hIn.y + 0.6), 0.2), - d);\n  q = p;\n  hIn -= bWid - 0.03;\n  q.x = abs (q.x) - hIn.x;\n  q.z = mod (q.z + 0.5 * hIn.y, hIn.y) - 0.5 * hIn.y;\n  d = SmoothMax (d, 0.53 - length (q.xz), 0.01);\n  DMINQ (1);\n  if (showCue) {\n    q = p;\n    q.yz -= vec2 (0., -0.6 * (hIn + bWid));\n    q.xz = Rot2D (q.xz, 0.5 * pi - aCue);\n    q.z -= -3.05 - dCue;\n    d = PrRoundCylDf (q, 0.1 - (0.015 / 2.5) * q.z, 0.05, 2.5);\n    DMINQ (2);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, ltPos, vn, u;\n  vec2 h;\n  float dstBall, dstObj, spec, c;\n  dstBall = BallHit (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstBall, dstObj) < dstFar) {\n    ltPos = vec3 (0., 3. * hbLen, 0.);\n    if (dstBall < dstObj) {\n      ro += dstBall * rd;\n      vn = vnBall;\n      if (idBall == 0) col = vec3 (1.);\n      else {\n        c = float (idBall - 1);\n        col = HsvToRgb (vec3 (mod (c / float (nBall), 1.),\n          1. - 0.3 * mod (c, 3.), 1. - 0.2 * mod (c, 2.)));\n      }\n      u = QtToRMat (Loadv4 (2 * idBall + 1)) * vn;\n      col *= ((u.z * (mod (pi + atan (u.x, u.y), 2. * pi) - pi) < 0.) ? 0.4 : 1.);\n      col *= 0.2 + 0.8 * max (vn.y, 0.);\n      rd = reflect (rd, vn);\n      c = (rd.y > max (abs (rd.x), abs (rd.z * 0.25))) ? min (2. * rd.y, 1.) :\n         0.05 * (1. + rd.y);\n      if (rd.y > 0.) c += 0.5 * pow (clamp (1.05 - 0.5 *\n         length (max (abs (rd.xz / rd.y) - vec2 (1., 4.), 0.)), 0., 1.), 6.);\n      c += (clamp (0.0002 / (1. - abs (rd.x)), 0., 1.) +\n            clamp (0.0002 / (1. - abs (rd.z)), 0., 1.));\n      col += 0.07 * c * vec3 (1., 1., 0.8);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        h = abs (ro.xz) - hbLen * vec2 (1., 1.75) + bWid;\n        if (max (h.x, h.y) < 0.3) {\n          col = vec3 (0.1, 0.5, 0.3);\n          vn = VaryNf (64. * ro, vn, 0.5);\n          for (int n = 0; n < nBall; n ++) {\n            c = length (ro.xz - Loadv4 (2 * n).xy);\n            if (c < 0.5) {\n              col *= 0.6 + 0.4 * smoothstep (0.3, 0.5, c);\n              break;\n            }\n          }\n          if (ro.y < -0.7) col *= 0.2;\n        } else {\n          col = vec3 (0.3, 0.1, 0.);\n        }\n      } else if (idObj == 2) {\n        col = (qHit.z < 2.2) ? vec3 (0.5, 0.3, 0.) : vec3 (0.7, 0.7, 0.3);\n      }\n      col *= 0.3 + 0.7 * max (dot (vn, normalize (ltPos - ro)), 0.);\n    }\n  } else col = vec3 (0.02, 0.02, 0.1) * (0.7 + 0.3 * rd.y);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 rd, ro, vd, col;\n  vec2 mMid[4], ut[4], mSize, um, canvas, uv, w;\n  float tCur, az, el, zmFac, asp, s, vuCorn, vuMode, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = 0.15 * vec2 (asp, 1.);\n  mMid[2] = (1. / mSize.y - 1.) * mSize;\n  mMid[0] = mMid[2] * vec2 (-1., -1.);\n  mMid[1] = mMid[2] * vec2 (-1., 1.);\n  mMid[3] = mMid[2] * vec2 (1., -1.);\n  for (int k = 0; k < 4; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  vuCorn = -1.;\n  for (int k = 0; k < 4; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuCorn = float (k);\n      break;\n    }\n  }\n  vuMode = (vuCorn >= 0.) ? vuCorn + 1. : 0.;\n  if (mPtr.z > 0.) {\n    f = -1.;\n    for (int k = 0; k < 4; k ++) {\n      um = abs (2. * mPtr.xy * vec2 (asp, 1.) - mMid[k]) / mSize;\n      if (max (um.x, um.y) < 1.) {\n        f = float (k);\n        break;\n      }\n    }\n    if (vuCorn < 0.) {\n      if (f >= 0.) vuMode = f + 1.;\n    } else if (f == vuCorn) vuMode = 0.;\n  }\n  stDat = Loadv4 (2 * nBall);\n  nStep = stDat.x;\n  runState = stDat.y;\n  showCue = (runState != 2. || nStep < 150.);\n  aCue = stDat.z;\n  dCue = (runState == 1.) ? 2.5 * smoothstep (0., 30., nStep) *\n     (1. - smoothstep (30., 50., nStep)) : 0.;\n  hbLen = 8.;\n  bWid = 0.4;\n  ro = vec3 (0., 0., -10. * hbLen);\n  if (vuMode == 0.) {\n    az = mod (pi + 0.1 * tCur, 2. * pi);\n    el = 0.8 + 0.3 * sin (2. * pi * 0.07 * tCur);\n    zmFac = 8.5 - 4. * abs (cos (az));\n    if (runState == 0.) s = smoothstep (0., 100., nStep);\n    else if (runState == 1.) s = 1.;\n    else if (runState == 2.) s = (1. - smoothstep (120., 250., nStep));\n    az = 0.5 * pi - mix (az, 0., s);\n    el = - mix (el, 0.4, s);\n    vd = vec3 (sin (az + vec2 (0.5 * pi, 0.)) * cos (el), sin (el)).xzy;\n    zmFac = mix (zmFac, 15., s);\n  } else if (vuMode == 1.) {\n    vd = vec3 (0., -1., 0.);\n    uv.xy = vec2 (- uv.y, uv.x);\n    zmFac = 7.;\n  } else if (vuMode == 2.) {\n    vd = normalize (vec3 (0., -0.5, 1.));\n    vd.xz = Rot2D (vd.xz, 0.1 * tCur);\n    zmFac = 8.;\n  } else if (vuMode == 3.) {\n    vuMode = 5.;\n    for (int n = 0; n < nBall; n ++) {\n      stDat = Loadv4 (2 * n);\n      w = stDat.xy;\n      if (w.x < 2. * hbLen) {\n        ro = vec3 (w.x, 1., w.y);\n        w = normalize (stDat.zw);\n        if (length (w) > 0.) vd = normalize (vec3 (w.x, -0.1, w.y));\n        else vd = vec3 (0., -0.3, 1.);\n        ro -= 4. * vd;\n        zmFac = 3.;\n        vuMode = 3.;\n        break;\n      }\n    }\n  } else if (vuMode == 4.) {\n    vd = normalize (vec3 (1., -1., 0.));\n    zmFac = 8.;\n  }\n  if (vuMode != 5.) {\n    vuMat = (abs (vd.y) < 1.) ? mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n       vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd) :\n       mat3 (vec3 (1., 0., 0.), vec3 (0., 0., 1.), vec3 (0., sign (vd.y), 0.));\n    if (vuMode != 3.) ro = vuMat * ro;\n    dstFar = 120.;\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 4.;\n#endif  \n    col = vec3 (0.);\n    for (float a = 0.; a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n         0.5 * pi * (a + 0.5)), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = vec3 (0., 0.2, 0.);\n  for (int k = 0; k < 4; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n       col = vec3 (0.5, 0.5, 0.);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Quasi Billiards 2\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nvec4 EulToQt (vec3 e);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat hbLen, dt, tCur, aCue, nPlay, nStep, runState;\nconst int nBall = 16;\nconst float txRow = 32.;\nconst float pi = 3.14159;\n\nvoid Step (int mId, out vec4 p, out vec4 qt)\n{\n  vec2 r, rn, dr, f, v;\n  float fOvlap, fric, rSep, vm;\n  fOvlap = 1000.;\n  fric = 0.015;\n  p = Loadv4 (2 * mId);\n  r = p.xy;\n  v = p.zw;\n  qt = Loadv4 (2 * mId + 1);\n  if (r.x < 2. * hbLen) {\n    f = vec2 (0.);\n    for (int n = 0; n < nBall; n ++) {\n      rn = Loadv4 (2 * n).xy;\n      if (rn.x < 2. * hbLen) {\n        dr = r - rn;\n        rSep = length (dr);\n        if (n != mId && rSep < 1.) f += fOvlap * (1. / rSep - 1.) * dr;\n      }\n    }\n    dr = hbLen * vec2 (1., 1.75) - abs (r);\n    f -= step (dr, vec2 (1.)) * fOvlap * sign (r) * (1. / abs (dr) - 1.) * dr;\n    f -= fric * v;\n    if (runState == 2.) {\n      v += dt * f;\n      r += dt * v;\n    }\n    if (min (length (0.6 - dr), length (0.6 - (hbLen * vec2 (1., 0.) - abs (r)))) < 0.9)\n       r.x = 100. * hbLen;\n    if (runState == 2.) {\n      vm = length (v);\n      if (vm > 1e-6) qt = normalize (QtMul (qt,\n         RotToQt (normalize (vec3 (- v.y, 0., v.x)), vm * dt / 0.5)));\n    }\n  }\n  p = vec4 (r, v);\n}\n\nvoid Init (int mId, out vec4 p, out vec4 qt)\n{\n  vec3 e;\n  vec2 r, v;\n  float s, fm;\n  if (mId == 0) r = vec2 (0., -0.6 * hbLen);\n  else if (mId > 0) {\n    fm = float (mId);\n    if (mId == 1) r = vec2 (0., 0.);\n    else if (mId <= 3) r = vec2 (fm - 2.5, 1.);\n    else if (mId <= 6) r = vec2 (fm - 5., 2.);\n    else if (mId <= 10) r = vec2 (fm - 8.5, 3.);\n    else r = vec2 (fm - 13., 4.);\n    r.x *= 1.1;\n    r.y += 0.2 * hbLen;\n  }\n  if (runState == 0.) aCue = pi * (0.5 + 0.09 * sin (0.6 * 2. * pi * tCur));\n  if (mId >= 0) {\n    v = (mId == 0) ? 10. * vec2 (cos (aCue), sin (aCue)) : vec2 (0.);\n    p = vec4 (r, v);\n    s = 7.7 * (nPlay + float (mId)) / float (nBall);\n    e = normalize (vec3 (Hashff (mod (s, 1.)),\n       Hashff (mod (s + 0.2, 1.)), Hashff (mod (s + 0.4, 1.))));\n    qt = EulToQt (vec3 (atan (e.x, e.y), acos (e.z),\n       2. * pi * Hashff (mod (s + 0.6, 1.))));\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qt;\n  vec2 canvas, kv;\n  int mId, pxId;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  kv = floor (fragCoord);\n  pxId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || pxId >= 2 * nBall + 1) discard;\n  mId = (pxId < 2 * nBall) ? mId = pxId / 2 : -1;\n  hbLen = 8.;\n  aCue = 0.;\n  nPlay = 0.;\n  nStep = 0.;\n  runState = 0.;\n  dt = 0.03;\n  if (iFrame <= 5) {\n    stDat = vec4 (nStep, 0., aCue, nPlay);\n    runState = 0.;\n  } else {\n    stDat = Loadv4 (2 * nBall);\n    nStep = stDat.x;\n    runState = stDat.y;\n    aCue = stDat.z;\n    nPlay = stDat.w;\n    if (runState == 0.) {\n      if (nStep > 50. && mPtr.z > 0. && length (mPtr.xy) < 0.45 || nStep > 300.) {\n        runState = 1.;\n        nStep = 0.;\n      }\n    } else if (runState == 1.) {\n      if (nStep > 50.) runState = 2.;\n    }\n    ++ nStep;\n    if (mId >= 0) {\n      Step (mId, p, qt);\n      if (pxId != 2 * mId) p = qt;\n    }\n    if (runState == 2.) {\n      if (mPtr.z > 0. && length (mPtr.xy) < 0.45 || nStep > 1800.) {\n        runState = 0.;\n        nStep = 0.;\n        ++ nPlay;\n      }\n    }\n  }\n  if (runState == 0.) {\n    Init (mId, p, qt);\n    if (pxId != 2 * mId) p = qt;\n  }\n  Savev4 (pxId, ((mId >= 0) ? p : vec4 (nStep, runState, aCue, nPlay)), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}