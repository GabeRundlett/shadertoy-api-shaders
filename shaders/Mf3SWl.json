{
    "Shader": {
        "info": {
            "date": "1718830975",
            "description": "Simple representation of the LMS response curves.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mf3SWl",
            "likes": 3,
            "name": "LMS sensitivity curves",
            "published": 3,
            "tags": [
                "spectrum",
                "light",
                "curves",
                "vision",
                "lms"
            ],
            "usePreview": 0,
            "username": "jsulpis",
            "viewed": 101
        },
        "renderpass": [
            {
                "code": "#define L_MIN 380.\n#define L_MAX 780.\n#define PADDING .2\n#define GRAPH_THICKNESS 1.3\n\n\nfloat getGraphShape(in float value, in vec2 uv) {\n    // by @FabriceNeyret2 https://www.shadertoy.com/view/lXlGRB\n    float v = value - uv.y;\n    float graph = smoothstep(0., GRAPH_THICKNESS/2., GRAPH_THICKNESS - abs(v)/fwidth(v));\n    \n    graph += uv.y * .2 * step(0., uv.y) * (1. - step(value, uv.y));\n\n    return graph;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (1. + 2.*PADDING) * fragCoord / iResolution.xy - PADDING;\n    \n    if (abs(uv.x - .5) > .5) {\n        fragColor = vec4(0.);\n        return;\n    }\n        \n    vec3 col = vec3(0.);\n    \n    float w = mix(L_MIN, L_MAX, uv.x);   \n    \n    vec3 lms = waveToLms(w, vec3(0.));\n\n    col = mix(col, vec3(1., .05, 0.), getGraphShape(lms.x, uv)); // long - red\n    col = mix(col, vec3(0., 1., 0.), getGraphShape(lms.y, uv)); // medium - green\n    col = mix(col, vec3(0.1, 0.3, 1.), getGraphShape(lms.z, uv)); // short - blue \n    \n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 1);\n} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n\n\n// x = current wavelength\n// u = control point wavelength\n#define gauss(x, u, o, A) A/o*exp(-0.5*pow((x - u)/o, 2.0))\n    \n// by @Tynach (https://www.shadertoy.com/view/MtcfDj)\n// Converts from a wavelength to LMS.\n// Constructed using multi-peak Gaussian functions generated using Labplot\n// and closely fitted to the CIE 2006 2Â° cone fundamentals created by Stockman & Sharp 2000).\nvec3 waveToLms(float wave, vec3 amount) {\n\t// LMS Gaussian function parameters for each cone type\n\tconst vec3[5] lParams = vec3[](\n\t\tvec3(449.682, 21.6622, 2.36612),\n\t\tvec3(477.589, 11.0682, 1.39883),\n\t\tvec3(532.488, 25.7494, 34.0478),\n\t\tvec3(570.2, 5.91487, 0.243387),\n\t\tvec3(585.858, 34.98, 77.8669)\n\t);\n\n\tconst vec3[5] mParams = vec3[](\n\t\tvec3(450.237, 19.5222, 3.33537),\n\t\tvec3(479.559, 13.3211, 3.68813),\n\t\tvec3(519.924, 17.1502, 9.68484),\n\t\tvec3(542.8, 3.27696, 0.105766),\n\t\tvec3(552.158, 33.3895, 77.9298)\n\t);\n\n\tconst vec3[5] sParams = vec3[](\n\t\tvec3(467.661, 8.84562, 5.32073),\n\t\tvec3(422.211, 10.2028, 8.58498),\n\t\tvec3(443.084, 11.9848, 19.6347),\n\t\tvec3(444.863, 1.30608, -0.0330768),\n\t\tvec3(460.886, 25.7907, 24.9128)\n\t);\n\n\t// Return the LMS values for the given wavelength\n\treturn vec3(\n\t\t// L cone response curve\n\t\tgauss(wave, lParams[0].x, lParams[0].y, lParams[0].z) +\n\t\tgauss(wave, lParams[1].x, lParams[1].y, lParams[1].z) +\n\t\tgauss(wave, lParams[2].x, lParams[2].y, lParams[2].z) +\n\t\tgauss(wave, lParams[3].x, lParams[3].y, lParams[3].z) +\n\t\tgauss(wave, lParams[4].x, lParams[4].y, lParams[4].z),\n\n\t\t// M cone response curve\n\t\tgauss(wave, mParams[0].x, mParams[0].y, mParams[0].z) +\n\t\tgauss(wave, mParams[1].x, mParams[1].y, mParams[1].z) +\n\t\tgauss(wave, mParams[2].x, mParams[2].y, mParams[2].z) +\n\t\tgauss(wave, mParams[3].x, mParams[3].y, mParams[3].z) +\n\t\tgauss(wave, mParams[4].x, mParams[4].y, mParams[4].z),\n\n\t\t// S cone response curve\n\t\tgauss(wave, sParams[0].x, sParams[0].y, sParams[0].z) +\n\t\tgauss(wave, sParams[1].x, sParams[1].y, sParams[1].z) +\n\t\tgauss(wave, sParams[2].x, sParams[2].y, sParams[2].z) +\n\t\tgauss(wave, sParams[3].x, sParams[3].y, sParams[3].z) +\n\t\tgauss(wave, sParams[4].x, sParams[4].y, sParams[4].z)\n\t)/sqrt(2.0*PI);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}