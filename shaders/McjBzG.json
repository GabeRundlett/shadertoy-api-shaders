{
    "Shader": {
        "info": {
            "date": "1725135175",
            "description": "Futuristic hex tilling, three variants with adjustable colors",
            "flags": 0,
            "hasliked": 0,
            "id": "McjBzG",
            "likes": 11,
            "name": "Futuristic Hex Tilling",
            "published": 3,
            "tags": [
                "colorful",
                "hexagon",
                "tiling",
                "hex",
                "tile",
                "futuristic"
            ],
            "usePreview": 0,
            "username": "Peace",
            "viewed": 154
        },
        "renderpass": [
            {
                "code": "#define HEX 1\n#define VARIANT int(id.x * (HEX > 0 ? 1.0 : BRICK_SIZE.x) / TILING * 1.5 + 0.1)\n\nconst vec4 COLOR = vec4(0.6,0.3,1.000,1);\nconst vec4 SECONDARY_COLOR = vec4(0.000,0.800,1.000, 1);\n\nconst float SCALE = 1.0;\nconst float TILING = 8.0;\nconst vec2 BRICK_SIZE = vec2(2, 1);\nconst float OUTLINE = 0.;\n// rounding doesn't work on hex for now\nconst float ROUNDING = 0.0;\nconst float DISPLACEMENT = 0.5;\n\n\n\n// Only for debugging, actual background color \n// will be whatever is behind the transparent floor\nconst vec3 BACKGROUND_COLOR = vec3(0.000,0.000,0.000);\nconst float TAU = 6.28318531;\n\n\n\n#if HEX\n    vec4 hex_uv(vec2 uv) {    \n        const vec2 s = vec2(1, 1.7320508);\n        vec4 hex_id = floor(vec4(uv, uv - vec2(0.5, 1)) / s.xyxy) + 0.5;\n        vec4 hex_uv = vec4(uv - hex_id.xy * s, uv - (hex_id.zw + 0.5) * s);\n\n        return dot(hex_uv.xy, hex_uv.xy) < dot(hex_uv.zw, hex_uv.zw)\n            ? vec4(hex_uv.xy, hex_id.xy) \n            : vec4(hex_uv.zw, hex_id.zw + 0.5);    \n    }\n    float hex(vec2 p, float s, float r) {    \n        p = abs(p);\n        return max(dot(p, vec2(0.5, 0.8660254)), p.x) - s;\n    }\n    float sdf(vec2 p, float s) {\n        return hex(p, s, ROUNDING);\n    }\n#else\n    float round_rect(vec2 p, vec2 s, float r) {\n        p = abs(p) - s + r;\n        return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0) - r;\n    }\n    float sdf(vec2 p) {\n        return round_rect(p, vec2(1.0 - OUTLINE), ROUNDING);\n    }\n#endif\n\nvec3 elongate(vec2 p, vec2 h) {\n    vec2 q = abs(p) - h;\n    return vec3(sign(p) * max(q, vec2(0)), min(max(q.x, q.y), 0.0));\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tf *= f * (3.0 - 2.0 * f);\n\tfloat res = mix(\n\t\tmix(hash12(i), hash12(i + vec2(1, 0)), f.x),\n\t\tmix(hash12(i + vec2(0, 1)), hash12(i + vec2(1)), f.x), f.y);\n\treturn res * res;\t\n}\n\nvec3 hue(vec3 col, float hue) {\n    return mix(vec3(dot(vec3(0.333), col)), col, cos(hue)) + cross(vec3(0.577), col) * sin(hue);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / mr / SCALE;\n    float t = iTime * 0.5;\n    \n    float f = length(fwidth(uv)) * TILING;\n\n#if HEX\n    vec4 hex_uv_id = hex_uv(uv * TILING);\n    vec2 frv = hex_uv_id.xy * 2.0;\n    vec2 id = hex_uv_id.zw;\n    float d = sdf(frv, 1.0) + OUTLINE;\n#else\n    vec2 sv = uv * TILING / BRICK_SIZE;\n    vec2 id = floor(sv);\n    id = floor(sv + vec2(fract(id.y * DISPLACEMENT), 0));\n    vec2 frv = fract(sv + vec2(id.y * DISPLACEMENT, 0)) * 2.0 - 1.0;\n    vec3 e = elongate(frv, vec2(1.0 - BRICK_SIZE.y / BRICK_SIZE.x, 0));\n    float d = e.z + sdf(e.xy * vec2(BRICK_SIZE.x / BRICK_SIZE.y, 1));\n#endif\n    float s = smoothstep(f * 3.0, 0.0, d);\n    d = mix((d - OUTLINE) * 0.3, d, s);\n    const float I = 2.0;\n    d = -d;\n    float w = sin(sqrt(max(0.1, d)) * TAU * I);\n\n    \n    float g = noise(uv + id * 0.4);\n    \n    vec4 c = mix(COLOR, SECONDARY_COLOR, g);\n    if (VARIANT == 0) {\n        float n = noise(d * 1.5 - dot(frv, frv) * 1.5 + uv * 11.0 + id * 11.0 + t) * sqrt(max(0.0, d)) * 1.5;\n        c.a *= 0.6 + abs(0.7 - 0.3 * sin(d * TAU * I + t * 5.0 + (id.x + id.y) * 25.0)) * w * w * 0.4;\n        c.a *= sqrt(d);\n        c.a += (1.0 - s) * 0.2 * sqrt(g);\n        c.rgb = hue(c.rgb, n * 0.6);\n        c.a *= abs(0.5 - n) + 0.5;\n        c.rgb *= 0.8 + (0.5 - n) * (0.5 - n);\n        c = (c - 0.5) * (1.0 + d) + 0.5;\n    } else if (VARIANT == 1) {\n        w = cos(d * TAU * 1.5);\n        float md = mix(w * w, smoothstep(0.0, -0.3, -d), 1.0 - w * w);\n        c.rgb *= 0.8 + 0.5 / sqrt(md);\n        float n = noise(d * 2.0 - dot(frv, frv) * 1.5 + uv * 11.0 + id * 11.0 + t) * sqrt(max(0.0, d)) * 1.5;\n\n        c.rgb = hue(c.rgb, sqrt(n) * 0.4);\n        c.rgb *= 0.8 + (0.5 - n) * (0.5 - n);\n    } else if (VARIANT == 2) {\n        float n = noise(frv);\n        c.rgb += n * d;\n        c.rgb += (1.0 - dot(frv, frv)) * 0.1 - 0.05;\n    }\n    c = clamp(c, vec4(0), vec4(1));\n    \n    fragColor = c;\n    fragColor.rgb = mix(BACKGROUND_COLOR, fragColor.rgb, fragColor.a);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}