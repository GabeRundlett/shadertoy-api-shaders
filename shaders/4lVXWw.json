{
    "Shader": {
        "info": {
            "date": "1484606598",
            "description": "I've been trying to reduce one of my favorite shaders from fb39ca4 down to two-tweets (2TC):\n[url]https://www.shadertoy.com/view/MsX3Wj[/url]\nFellow code golfers ... Please HELP reduce this further.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lVXWw",
            "likes": 42,
            "name": "Torus Interior - 200 chars",
            "published": 3,
            "tags": [
                "raymarch",
                "torus",
                "short",
                "2tc",
                "codegolf"
            ],
            "usePreview": 0,
            "username": "GregRostami",
            "viewed": 1973
        },
        "renderpass": [
            {
                "code": "// 200 chars - iq and Fabrice not only fix a bug, they kill another 13 chars:\n\nvoid mainImage(out vec4 o, vec2 u) {\n    o*=0.;\n    vec3 R = iResolution;\n    for ( o.z++; R.z++ < 64. ; )\n        o += vec4((u+u-R.xy)/R.x,1,0)*(length(vec2(o.a=length(o.xz)-.7,o.y) )-.5);\n    o += sin( 21.* ( atan(o.y,o.w) - atan(o.z,o.x) - iTime ) ); }\n    \n/*\n// 193 chars - using the #define trick to reduce.\n\n#define mainImage(o,u)\t\\\nvec3 R = iResolution, p = R-R;\t\\\np.z = 4.;\t\\\nwhile (R.z++<64.)\t\\\n    p+=vec3((u+u-R.xy)/R.x,.5)*(length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\t\\\no = vec4( 1&int(7.*(atan(p.y,o.a)-atan(p.z,p.x)-iTime)) )\n\n\n// 207 chars - Thanks to TomCat's amazing optimization we saved 8 more chars:\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec3 R = iResolution, \n         p = R-R; p.z = 4.;\n    \n    while (R.z++<64.)\n        p +=  vec3((u+u-R.xy)/R.x,.5) \n            * (length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\n    \n    o = vec4 ( 1&int(7.*(atan(p.y,o.a)-atan(p.z,p.x)-iTime)) );                 \n}\n\n\n// 215 chars - Another 3 chars lie dead behind Fabrice's path ...\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec3 R = iResolution, \n         p = R-R; p.z = 4.;\n    \n    for (int i = 0; i++ < 64;)\n        p +=  vec3((u+u-R.xy)/R.x,.5) \n            * (length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\n    \n    o = vec4 ( 2.*sin(16.*(atan(p.y, o.a) - atan(p.z,p.x) - iTime)) );                 \n}\n\n\n// 222 chars - Greg added fade to black for depth.\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec3 R = iResolution, \n         p = R-R; p.z = 4.;\n    \n    for (int i = 0; i < 64; i++)\n        p +=  vec3((u+u-R.xy)/R.x,.5) \n            * (length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\n    \n    o += .2*(p.z+6.)*sin(16.*(atan(p.y, o.a) - atan(p.z,p.x) - iDate.w)) -o;                 \n}\n\n\n// 216 chars - Code Golf Master F (Fabrice) schooled me AGAIN!!\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec3 p = iResolution;\n    u = (u+u-p.xy)/p.x;\n    p -=p; p.z = 4.;\n    for (int i = 0; i < 64; i++)\n        p += vec3(u,.5) * (length(vec2(o.a=length(p.xz)-4.,p.y))-3.);\n    \n    o += 9.*sin(16.*(atan(p.y, o.a) + atan(p.z,p.x) + iDate.w)) -o;                \n}\n\n\n// 280 chars - reduced by Greg Rostami\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec3 R = iResolution, p = R-R;\n    u = u/R.xy*2.-1.;\n    p.z = 4.;\n    for (int i = 0; i < 64; i++)\n        p += vec3(u.x*.8, u.y*R.y/R.x, .5) * (length(vec2(length(p.xz)-4.,p.y))-3.);\n    \n    o = vec4( smoothstep(\n        o.a = fract(8.*(atan(p.y, length(p.xz) - 4.) + atan(p.z,p.x) + iDate.w)/3.142),\n                        o.a, o.a < .6 ? .1 : 1.));\n}\n\n\n// 1151 chars - Original shader by fb39ca4\n\n//Thank you iquilez for some of the primitive distance functions!\n\n\nconst float PI = 3.14159265358979323846264;\n\n\nconst int MAX_PRIMARY_RAY_STEPS = 64; //decrease this number if it runs slow on your computer\n\nvec2 rotate2d(vec2 v, float a) { \n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); \n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distanceField(vec3 p) {\n\treturn -sdTorus(p, vec2(4.0, 3.0));\n}\n\nvec3 castRay(vec3 pos, vec3 dir, float treshold) {\n\tfor (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n\t\t\tfloat dist = distanceField(pos);\n\t\t\t//if (abs(dist) < treshold) break;\n\t\t\tpos += dist * dir;\n\t}\n\treturn pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 mousePos = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraPos = vec3(0.0, 0.0, -3.8);\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.5);\n\tvec3 planeU = vec3(1.0, 0.0, 0.0) * 0.8;\n\tvec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 1.0, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\t\n\t//cameraPos.yz = rotate2d(cameraPos.yz, mousePos.y);\n\t//rayDir.yz = rotate2d(rayDir.yz, mousePos.y);\n\t\n\t//cameraPos.xz = rotate2d(cameraPos.xz, mousePos.x);\n\t//rayDir.xz = rotate2d(rayDir.xz, mousePos.x);\n\t\n\tvec3 rayPos = castRay(cameraPos, rayDir, 0.01);\n\t\n\tfloat majorAngle = atan(rayPos.z, rayPos.x);\n\tfloat minorAngle = atan(rayPos.y, length(rayPos.xz) - 4.0);\n\t\t\n\tfloat edge = mod(8.0 * (minorAngle + majorAngle + iTime) / PI, 1.0);\n\tfloat color = edge < 0.7 ? smoothstep(edge, edge+0.03, 0.5) : 1.0-smoothstep(edge, edge+0.03, 0.96);\n\t//float color = step(mod(8.0 * (minorAngle + majorAngle + iTime) / PI, 1.0), 0.5);\n\t//color -= 0.20 * step(mod(1.0 * (minorAngle + 1.0 * majorAngle + PI / 2.0) / PI, 1.0), 0.2);\n\t\n\tfragColor = vec4(color);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}