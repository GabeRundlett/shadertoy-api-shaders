{
    "Shader": {
        "info": {
            "date": "1583766198",
            "description": "A variation of Knighty's [url]https://www.shadertoy.com/view/4sf3zX[/url] with some extra features. \n\nInspiration also from fizzer's [url]https://www.shadertoy.com/view/3tyXWw[/url].\n\nMouse, arrow keys etc: see code header.",
            "flags": 48,
            "hasliked": 0,
            "id": "wlGSWc",
            "likes": 25,
            "name": "Wythoffian Tiling Generator",
            "published": 3,
            "tags": [
                "tiling",
                "hyperbolic",
                "snub",
                "wythoffian"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 1338
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Wythoffian Tiling Generator\n//\n// Spherical, Euclidean, and Hyperbolic tilings, including duals and snubs.\n//\n// Based on Knighty's excellent 'Tilings': https://www.shadertoy.com/view/4sf3zX\n//\n// Modified by Matthew Arcus, mla, 9/3/2020\n//\n// Fundamental triangle angles are PI/P, PI/Q, PI/R and an appropriate\n// geometry is selected for the specified angles.\n//\n// P and Q are fixed in the code (but of course may be changed), R varies,\n// either automatically or with <left>/<right> keys.\n//\n// By default, display cycles through the 7 uniform tilings based on\n// the underlying triangle, as well as the snub form. Triangle goes\n// through (2,3,5),(2,3,6),(2,3,7), etc.\n//\n// <mouse>: apply appropriate isometry to tiling\n// <up>/<down>: zoom in/out\n// <left>/<right>: select R angle of fundamental triangle\n// d: show dual\n// f: use plain fill for tiles\n// p: show region parity\n// s: just show snub forms\n// t: show main tiling\n// x: texture tiles\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n// Original header\n////////////////////////////////////////////////////////////////////////////////\n// triangular groups tessellations. Coxeter group p-q-r. Stereographic\n// projection. \n// adapted from fragmentarium script.see:\n// http://www.fractalforums.com/fragmentarium/triangle-groups-tessellation/\n// Licence: free.\n// the type of the space embedding the tessellation depend on the value:\n// 1/p+1/q+1/r\n// if >1 its the sphere\n// if =1 its the euclidean plane\n// if <1 its the hyperbolic plane\n//  \n// Distance estimation to lines and vertices is used for antialiasing.\n// You can still improve quality by using antialiasing.\n////////////////////////////////////////////////////////////////////////////////\n\nbool snubify = false;\nbool dofill = true;\nbool dodual = true;\nbool dotiling = true;\nbool dotexture = true;\nbool doparity = true;\n\n// These are the p, q and r parameters that define the Coxeter/triangle group\nint P = 2; // Pi/p: angle beween reflexion planes a and b.\nint Q = 3; // Pi/q: angle beween reflexion planes b and c.\nint R = 3; // Pi/r: angle beween reflexion planes c and a.\n\n// Iteration number.\nconst int Iterations = 30;\n\n// Colors\nconst vec3 segColor        = vec3(0,0,0);\nconst vec3 dualColor       = vec3(1,0,0);\nconst vec3 backgroundColor = vec3(0);\nconst vec3 fillColor = vec3(1,1,0.7);\nconst vec3 faceColor0 = vec3(1,1,0);\nconst vec3 faceColor1 = vec3(0,1,1);\nconst vec3 faceColor2 = vec3(0,0,1);\nconst vec3 snubColor = vec3(0,1,0);\n\nvec3 A,B,C; // The vertices of the triangle\nfloat K = 0.0; // spaceType\nvec3 na,nb,nc; // The normals of the reflexion planes, na = (1,0,0),\nvec3 bary; // Barycentre coordinates of \"Wythoff point\"\n\nfloat aaScale = 0.005; //anti-aliasing scale == half of pixel size.\n\nconst float PI = 3.14159265;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;;\n}\n\n//#define assert(e)\n\n////////////////////////////////////////////////////////////////////////////////\n// Geometry\n////////////////////////////////////////////////////////////////////////////////\n\n// For hyperbolic and spherical geometry, hdott(p,q) = -hdots(p,q)\nfloat hdott(vec3 a, vec3 b){\n  //dot product for \"time like\" vectors.\n  return K*dot(a.xy,b.xy)+a.z*b.z;\n}\nfloat hdots(vec3 a, vec3 b){\n  //dot product for \"space like\" vectors (these are duals of the \"time like\" \n  //vectors).  \n  return dot(a.xy,b.xy)+K*a.z*b.z;\n}\nfloat hlengtht(vec3 v){\n  return sqrt(abs(hdott(v,v)));\n}\nfloat hlengths(vec3 v){\n  return sqrt(abs(hdots(v,v)));\n}\nvec3 hnormalizet(vec3 v){\n  // normalization of \"time like\" vectors.\n  return v/hlengtht(v);\n}\nvec3 hnormalizes(vec3 v){\n  //normalization of \"space like\" vectors (not used).\n  return v/hlengths(v);\n}\n\n/////////////////////////////////////////////////\n\nvoid initialize() {\n  // Set the space type\n  K = float(sign(Q*R+P*R+P*Q-P*Q*R)); // 1/P+1/Q+1/R-1;\n\n  float cospip=cos(PI/float(P)), sinpip=sin(PI/float(P));\n  float cospiq=cos(PI/float(Q)), sinpiq=sin(PI/float(Q));\n  float cospir=cos(PI/float(R)), sinpir=sin(PI/float(R));\n  float ncsincos=(cospiq+cospip*cospir)/sinpip;\n\n  // dot(na,nb) = -cos(PI/P)\n  // dot(nb,nc) = -cos(PI/Q)\n  // dot(nc,na) = -cos(PI/R)\n  // |na| = |nb| = |nc| = 1\n  na = vec3(1,0,0);\n  nb = vec3(-cospip,sinpip,0);\n  nc = vec3(-cospir,-ncsincos,sqrt(abs(1.0-cospir*cospir-ncsincos*ncsincos)));\n  if (K == 0.0) {\n    // This case is a little bit special - nc.z doesn't enter into\n    // inner product, but acts as a scaling factor.\n    nc.z = 0.25;\n  }\n\n  // \"vertices\" of the \"triangle\" made by the reflexion planes\n  A = cross(nb,nc); //vec3(nb.y*nc.z,-nb.x*nc.z,nb.x*nc.y-nb.y*nc.x);\n  B = cross(nc,na); //vec3(0,nc.z,-nc.y);\n  C = cross(na,nb); //vec3(0,0,nb.y);\n}\n\nvec3 reflecta(vec3 z) {\n  return z*vec3(-1,1,1);\n}\n\nvec3 reflectb(vec3 z) {\n  return z-2.0*dot(nb,z)*nb;\n}\n\nvec3 reflectc(vec3 z) {\n  // Only need spaceType for this\n  return z-2.0*dot(nc,z)*nc*vec3(1,1,K);\n}\n\nvec3 fold(vec3 pos, inout int flips) {\n  for (int i=0; i<Iterations; i++) {\n    int flips0 = 0;\n    flips0 += int(pos.x < 0.0);\n    pos.x = abs(pos.x); // Reflect in y-axis - always a line of symmetry\n    float t = 2.0*min(0.0,dot(nb,pos));\n    flips0 += int(t < 0.0);\n    pos -= t*nb;\n    t = 2.0*min(0.0,dot(nc,pos));\n    flips0 += int(t < 0.0);\n    pos -= t*nc*vec3(1,1,K);\n    if (flips0 == 0) break;\n    //pos = hnormalizet(pos); // TBD: test this..\n    flips += flips0;\n  }\n  return pos;\n}\n\nfloat DD(float t, float r2){\n  // Stereographic projection\n  //return t*(1.0+K*r2); // TBD: test this..\n  return t*(1.0+K*r2)/(1.0+K*K*sqrt(r2)*t);\n}\n\nfloat hdistance(vec3 p, vec3 q) {\n  return hlengths(p-q)/hlengtht(p+q);\n}\n\nfloat hangle(vec3 p, vec3 q, vec3 r) {\n  // Return cosine of angle at p\n  return hdots(p-q,p-r);\n}\n\n// Distance to half-line from p in direction n.\nfloat dist2Segment(vec3 z, vec3 p, vec3 n, float r2, float radius){\n  // pmin is the orthogonal projection of z onto the plane defined by p and n\n  // then pmin is projected onto the unit sphere\n\t\n  // we are assuming that p and n are normalized. If not, we should do: \n  mat2 smat=mat2(vec2(hdots(n,n),hdots(p,n)),vec2(hdott(p,n),hdott(p,p)));\n  //mat2 smat=mat2(1,hdots(p,n),hdott(p,n),1);\n\n  // v is the components of the \"orthogonal\" projection (depends on the\n  // metric) of z on the plane defined by p and n wrt to the basis (p,n)\n  vec2 v = smat*vec2(hdott(z,p),-hdots(z,n));\n  v.y = min(0.0,v.y); //crops the part of the segment past the point p\n\t\n  vec3 pmin = hnormalizet(v.x*p-v.y*n);\n  \n  float t = hdistance(pmin,z);\n  return DD((t-radius)/(1.0+K*t*radius),r2); // Return distance to \"cylinder\"\n}\n\nvoid snubdual(vec3 z, vec3 p, float r2, float radius, inout float dmin) {\n  dmin = min(dmin,dist2Segment(z,p,A-p,r2,radius));\n  dmin = min(dmin,dist2Segment(z,p,B-p,r2,radius));\n  dmin = min(dmin,dist2Segment(z,p,C-p,r2,radius));\n}\n\nfloat dist2Tiling(vec3 z, vec3 p, float r2, bool parity) {\n  const float radius = 0.01;// Thickness of the lines\n  float dmin = 1e8;\n  if (!snubify) {\n    dmin = min(dmin,dist2Segment(z,p,-na,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,-nb,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,-nc*vec3(1,1,K),r2,radius));\n  } else if (!parity) {\n    // The six rays from the triangle point.\n    vec3 p0 = reflecta(reflectb(p));\n    vec3 p1 = reflectb(reflecta(p));\n    vec3 p2 = reflectb(reflectc(p));\n    vec3 p3 = reflectc(reflectb(p));\n    vec3 p4 = reflectc(reflecta(p));\n    vec3 p5 = reflecta(reflectc(p));\n    dmin = min(dmin,dist2Segment(z,p,p0-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p1-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p2-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p3-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p4-p,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p,p5-p,r2,radius));\n  } else {\n    // The three rays passing through the other triangle.\n    vec3 p0 = reflecta(p);\n    vec3 p1 = reflectb(p);\n    vec3 p2 = reflectc(p);\n    dmin = min(dmin,dist2Segment(z,p0,p1-p0,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p1,p2-p1,r2,radius));\n    dmin = min(dmin,dist2Segment(z,p2,p0-p2,r2,radius));\n  }\n  return dmin;\n}\n\nfloat dist2Dual(vec3 z, vec3 p, float r2, bool parity) {\n  const float radius = 0.008; // Thickness of the lines\n  float dmin = 1e8;\n  if (!snubify) {\n    if (bary.z != 0.0) dmin = min(dmin,dist2Segment(z,A,B-A,r2,radius));\n    if (bary.x != 0.0) dmin = min(dmin,dist2Segment(z,B,C-B,r2,radius));\n    if (bary.y != 0.0) dmin = min(dmin,dist2Segment(z,C,A-C,r2,radius));\n  } else {\n    // Centre of snub triangle. Should check this is valid!\n    vec3 f = (reflecta(p)+reflectb(p)+reflectc(p))/3.0;\n    // Snub dual method from fizzer.\n    if (parity) {\n      snubdual(z,f,r2,radius,dmin);\n    } else {\n      snubdual(reflecta(z),f,r2,radius,dmin);\n      snubdual(reflectb(z),f,r2,radius,dmin);\n      snubdual(reflectc(z),f,r2,radius,dmin);\n    }\n  }\n  return dmin;\n}\n\nvec3 color(vec2 z, vec3 p){\n  float r2 = dot(z,z);\n  vec3 z3 = vec3(2.0*z,1.0-K*r2)/(1.0+K*r2);\n  int flips = 0;\n  z3 = fold(z3,flips);\n  bool parity = (flips&1) == 0;\n  vec3 color = backgroundColor;\n  // Fill in the tile colors. This can probably be simplified.\n  if (dofill) {\n    color = fillColor;\n  } else if (!snubify) {\n    // Non-chiral case, just 3 sectors of triangle.\n    bool side0 = dot(z3,cross(p,na)) < 0.0;\n    bool side1 = dot(z3,cross(p,nb)) < 0.0;\n    bool side2 = dot(z3,cross(p,nc*vec3(1,1,K))) < 0.0;\n    if (side0 && !side1) color = faceColor0;\n    else if (side1 && !side2) color = faceColor1;\n    else if (side2 && !side0) color = faceColor2;\n  } else if (!parity) {\n    // Triangle contains snub Wythoff point, p, there are\n    // 6 sectors, boundaries are between p and it's 6\n    // double reflections.\n    vec3 p0 = reflecta(reflectb(p));\n    vec3 p1 = reflectb(reflecta(p));\n    vec3 p2 = reflectb(reflectc(p));\n    vec3 p3 = reflectc(reflectb(p));\n    vec3 p4 = reflectc(reflecta(p));\n    vec3 p5 = reflecta(reflectc(p));\n    bool side0 = dot(z3,cross(p,p0)) < 0.0;\n    bool side1 = dot(z3,cross(p,p1)) < 0.0;\n    bool side2 = dot(z3,cross(p,p2)) < 0.0;\n    bool side3 = dot(z3,cross(p,p3)) < 0.0;\n    bool side4 = dot(z3,cross(p,p4)) < 0.0;\n    bool side5 = dot(z3,cross(p,p5)) < 0.0;\n    if (side1 && !side0) color = faceColor1;\n    if (side2 && !side1) color = snubColor;\n    if (side3 && !side2) color = faceColor2;\n    if (side4 && !side3) color = snubColor;\n    if (side5 && !side4) color = faceColor0;\n    if (side0 && !side5) color = snubColor;\n  } else {\n    // The other triangle, containing the centre of\n    // a snub triangle. The three sides of the snub triangle\n    // pass through region.\n    vec3 p0 = reflecta(p);\n    vec3 p1 = reflectb(p);\n    vec3 p2 = reflectc(p);\n    bool side0 = dot(z3,cross(p0,p1-p0)) < 0.0;\n    bool side1 = dot(z3,cross(p1,p2-p1)) < 0.0;\n    bool side2 = dot(z3,cross(p2,p0-p2)) < 0.0;\n    if (side0) color = faceColor1;\n    else if (side1) color = faceColor2;\n    else if (side2) color = faceColor0;\n    else color = snubColor;\n  }\n  \n  if (doparity && parity) color *= 0.9; // Antialias this?\n\n  if (dotexture) color *= 0.8+0.2*texture(iChannel2, z3.xy + 0.0*iTime).r;\n\n  //antialiasing using distance de segments and vertices (ds and dv) \n  //(see:https://iquilezles.org/articles/distance)\n  if (dodual) {\n    float ds = dist2Dual(z3,p,r2,parity);\n    color = mix(dualColor,color,smoothstep(-1.0,1.0,ds/aaScale));\n  }\n  if (dotiling) {\n    float ds = dist2Tiling(z3, p, r2, parity);\n    color = mix(segColor,color,smoothstep(-1.0,1.0,ds/aaScale));\n  }\n\t\n  // Final touch in order to remove jaggies at the edge of the circle\n  // (for hyperbolic case)\n  if (K == -1.0) {\n    color = mix(backgroundColor,color,\n                smoothstep(-1.0,1.0,(1.0-sqrt(r2))/aaScale));\n  }\n  return color;\n}\n\n// Decode integer k bitwise as bary coords.\nvec3 getbary(int k) {\n  k = 1+(k%7);\n  return vec3((k>>0)&1,(k>>1)&1,(k>>2)&1);\n}\n\n// Find bary coords of point whose 3 reflections form an equilateral triangle.\n// Fairly standard application of 2-dimensional Newton-Raphson.\n// It's pretty silly doing this in a fragment shader, but it's fun.\n// There are ways of directly calculating the \"Fermat point\", but\n// I haven't tried that for non-euclidean triangles.\nvec2 eval(vec2 s) {\n  vec3 t = mat3(A,B,C)*vec3(s,1.0-s.x-s.y);\n  vec3 p0 = reflecta(t);\n  vec3 q0 = reflectb(t);\n  vec3 r0 = reflectc(t);\n  // Doesn't seem to matter whether we equalize angles or distances\n#if 0\n  // Reflect to an equilateral triangle\n  float d0 = hdistance(p0,q0);\n  float d1 = hdistance(q0,r0);\n  float d2 = hdistance(r0,p0);\n#else\n  // Reflect to an equiangular triangle\n  float d0 = hangle(p0,q0,r0);\n  float d1 = hangle(q0,r0,p0);\n  float d2 = hangle(r0,p0,q0);\n#endif\n  return vec2(d1-d0,d2-d1);\n}\n\nmat2 jacobian(vec2 s, float eps) {\n  // f(a+eps) = f(a-eps) + 2*eps*f'(a) => f'(a) =  (f(a+eps)-f(a-eps))/(2*eps)\n  vec2 e = vec2(eps,0);\n  vec2 s0 = eval(s+e.xy);\n  vec2 s1 = eval(s-e.xy);\n  vec2 s2 = eval(s+e.yx);\n  vec2 s3 = eval(s-e.yx);\n  // df[0]/da df[0]/db\n  // df[1]/da df[1]/db\n  // Column major!\n  return mat2(s0-s1,s2-s3)/(2.0*eps);\n}\n\nvec2 refine(vec2 s) {\n  // 0 = f(a+dx) = f(a)+M(dx)\n  // f(a) = -M(dx)\n  // dx = -inv(M)(f(a))\n  mat2 m = inverse(jacobian(s,1e-6));\n  vec2 t = eval(s);\n  vec2 dx = m*t;\n  return s-dx;\n}\n\nvec3 getsnub() {\n  // Solve f(a,b,c) = g(a,b,c) = h(a,b,c)\n  // Here f,g,h are distances to 3 sides of triangle, or the three\n  // angles in the triangle.\n  // a,b,c are bary coords\n  // In fact, we can set a+b+c = 1, so only 2 variables really.\n  // Have a vector quantity: [f-g,h-g], which we want to set to [0,0].\n  // f(x+dx) = f(x) + F(dx)\n  // ie. f(x) + F(dx) = 0 => dx = -inv(F)(f(x))\n  // We need a decent starting point, here the middle of the triangle\n  vec2 s = vec2(0.333,0.333);\n  // A few iterations are enough\n  for (int i = 0; i < 4; i++) s = refine(s);\n  assert(length(eval(s)) < 1e-4); // Check we have a solution\n  vec3 res = vec3(s,1.0-s.x-s.y);\n  return res;\n}\n\nvec3 getbary(int k, float t) {\n  k %= 16;\n  if (k >= 14) {\n    snubify = true;\n    return getsnub();\n  }\n  //k = max(0,k-1);\n  k = min(k,12);\n  return mix(getbary(k/2),getbary((k+1)/2),t);\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_L = 76;\nconst int CHAR_P = 80;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Set up our options\n  dofill = keypress(CHAR_F);\n  dodual = !keypress(CHAR_D);\n  dotiling = !keypress(CHAR_T);\n  dotexture = !keypress(CHAR_X);\n  doparity = !keypress(CHAR_P);\n  snubify = keypress(CHAR_S);\n\n  // P,Q are fixed, select value for R.\n  int rselect = keycount(KEY_RIGHT)-keycount(KEY_LEFT);\n  if (rselect > 0) {\n    R = 2+rselect;\n  } else {\n    int cycle = snubify ? 3 : 16;\n    R = 5+int(iTime)/(cycle);\n  }\n  // Set up triangle, bary coords and Wythoff point.\n  initialize();\n  bary = snubify ? getsnub() : getbary(int(iTime),fract(iTime));\n  // The barycentric coords for the vertex.\n  vec3 p = mat3(A,B,C)*bary;\n    // Weighted average of the vertices of the triangle\n  p = hnormalizet(p);\n\n  // Scaling\n  float scaleFactor = K == 1.0 ? 2.0 : 1.0;\n  // Zoom in and out with arrow keys\n  scaleFactor *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n\n  // Get screen point..\n  vec2 z = scaleFactor*(2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\n  // ..and apply appropriate isometry.\n  if (iMouse.x > 0.0) {\n    vec2 m = scaleFactor*vec2((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n    if (K == 0.0) {\n      // euclidean translation\n      z -= m;\n    } else if (K == 1.0) {\n      // spherical, invert at mouse position\n      z -= m;\n      float k = 1.0/dot(z,z);\n      z *= k;\n      scaleFactor *= k; // Adjust scale factor for inversion\n      z += m;\n    } else if (K == -1.0) {\n      // hyperbolic, invert centre of unit disc to mouse position\n      float X = dot(m,m);\n      m /= X;\n      z -= m;\n      float k = (1.0-X)/(X*dot(z,z));\n      z *= k;\n      scaleFactor *= abs(k); // Adjust scale factor for inversion\n      z += m;\n    }\n  }\n  aaScale = 2.0*scaleFactor/iResolution.y;\n  fragColor = vec4(color(z,p),1.0);\n  if (alert) fragColor.x = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}