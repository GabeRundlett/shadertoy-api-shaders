{
    "Shader": {
        "info": {
            "date": "1540295816",
            "description": "mouse.y (tilesize)  sets escapeTimeThreshold from [all escapes (large tiles)] till [nothing escapes (small tiles)]\nmouse.x (opacity) mixes boolean operands of final composition, offset by the golden ratio for \"transparency\"\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4ltfRj",
            "likes": 4,
            "name": "truchet quadtree dynamic",
            "published": 3,
            "tags": [
                "truchet",
                "phi",
                "quadtree",
                "golden",
                "zigzag",
                "curcuit"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 677
        },
        "renderpass": [
            {
                "code": "/*\n//self: https://www.shadertoy.com/view/4ltfRj\nmouse.y (tilesize)  sets escapeTimeThreshold from [all escapes (large tiles)] till [nothing escapes (small tiles)]\nmouse.x (opacity) mixes boolean operands of final composition, offset by the golden ratio for \"transparency\"\n\n\nollj underestimated the foldingg complexity of a quadtree floor()\nand did other silly things with this instead\n\ni wanted this to be less noisy\n, but inversion of long functions is not what i am good at.\n*/\n\n//parent: https://www.shadertoy.com/view/MtcBDM\n\n//i made this shader because shane's shader looked so fancy\n//https://www.shadertoy.com/view/4t3BW4\n//\n//i read the articles shane linked to\n//\n//Multi-Scale Truchet Patterns  - Christopher Carlson\n//https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n//Linking paper containing more detail:\n//http://archive.bridgesmathart.org/2018/bridges2018-39.pdf\n\n//some macros\n#define limit 12.0\n\n//some constant macros\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n//hash function in hash without sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\n//it seems to make a weird truchet pattern\nfloat backdrop(vec3 p\n){\n ;//p.z=p.x-p.y //p is a floor(octree)d value, and i have no inverse.\n ;//return mix(cos(length(p)*12.)*.5+.5,sin(length(p)*12.61)*.5+.75,.5)\n ;p  = fract(p * HASHSCALE1)\n ;p += dot(p, p.yzx + 19.19)\n ;return fract((p.x + p.y) * p.z*15.3023+0.434)\n ;}\n\n\nvoid rando(inout float i,inout float rand,inout float j,inout vec2 r,vec2 u,float subs\n){for (j = 1.0; j < i; j++\n ){//if(rand>=subs)break//optional discontinuity exposes quatdree \n  ;vec3 a=vec3(floor(r*exp2(j))*exp2(-j),int(j))\n  ;rand=backdrop(a)//needed to flip alignment\n ;if(rand>=subs)break\n;}}\n  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y\n ;vec2 p = uv*0.3+iTime*0.05+vec2(-43.423,1.313)//animate camera\n ;//these were originally representing the white and black part of th truchet,\n ;//but that isn't really the case anymore, truchetw represents the truchet arc\n ;//,and truchetb represents the rest.\n ;bool truchetw = false\n ;bool truchetb = false\n ;bool isincell = false\n ;float i\n ;vec2 lp\n ;float ran\n ;float subs= (0.5-iMouse.y/iResolution.y*2.+1.)\n ;if(iMouse.z<=0.)subs=sin(iTime)*.5+.5\n ;for (i = limit; i > 0.0; i--\n ){//fp is position in the bottom left corner of truchet cell\n  ;vec2 fp = floor(p*exp2(i))*exp2(-i)\n  ;lp = (p-fp)*exp2(i)//fract()position within a cell\n  ;//r is the truchet cell you want the random\n  ;vec2 r = p\n  ;float rand\n  ;float j\n  ;rando(i,rand,j,r,uv,subs)\n  ;if (i==j//if the current cell is a truchet, break from the loop\n  ){ran = rand\n   ;isincell = true\n   ;break;}\n  ;//check closest neighbor overlapping part of the arcs\n  ;vec2 q = lp-0.5\n      \n        ;vec2 dir;\n        if (abs(q.x) > abs(q.y)) {\n            dir = vec2(sign(q.x),0.0);\n        } else {\n            dir = vec2(0.0,sign(q.y));\n        }\n\t\t;r = p+dir*exp2(-i);\n      \n  ;if(abs(q.x)>abs(q.y))dir=vec2(sign(q.x),0.0)\n  ;else                dir=vec2(0.0,sign(q.y))\n  ;rando(i,rand,j,r,uv,subs)\n  ;if (i==j)truchetw = length(q-dir*0.5)<0.1667;\n  ;//check for the overlapping black dots\n  ;vec2 fp2 = floor(p*exp2(i)-0.5)\n  ;vec2 p2 = p*exp2(i)\n  ;for(int x = 0; x <= 1; x++\n  ){for(int y = 0; y <= 1; y++\n   ){r = (fp2+vec2(x,y))*exp2(-i)\n    ;//this branch doesn't do anything, but it skips the random() once\n    ;if (r != fp\n    ){rando(i,rand,j,r,uv,subs)\n     ;if (i==j)truchetb = length(abs(p2-fp2-vec2(x,y)-0.5)-0.5)<0.333\n    ;}\n   ;}\n  ;}\n  ;if (truchetw||truchetb)break\n ;}\n ;if(isincell\n ){ran /= subs\n  ;//flips the truchet cell upside down randomly\n  ;if (ran < 0.5)lp.y = 1.0-lp.y\n  ; //lp but mirrored diagonally\n  ;vec2 q=abs(\n      \n      //vec2(smoothstep(1.,0.,lp.x-lp+1.)//not THAT simple, wrong uv space!\n      vec2(step(1.0-lp.x,lp.y)\n                  \n                  \n                -lp  )\n            \n             )\n  ;truchetw = abs(length(q)-0.5)<0.1667\n  ;truchetb = !truchetw\n ;}\n ;//simple black and white coloring abs(x-y) acts as xor,\n ;//so mod(i,2.0) xor truchetw\n ;//i=smoothstep(-.1,.1,i)\n ;i=mod(i,2.)\n ;float h=iMouse.x/iResolution.x\n ;if(iMouse.z<=0.)h=cos(iTime*1.61)*.5+.5\n ;//h*=4.-2.//failure to guess a good bijection range\n ;vec2 r=vec2(i,float(truchetw))*mix(vec2(1,0),vec2(0,1),h)\n ;i=abs(\n     \n     r.x-r.y+(sqrt(5.))*.5-.5\n     //i-float(truchetw)\n       \n       )\n ;fragColor = vec4(0,i,0,i);\n ;//fragColor.y=backdrop(vec3(p.xyx))\n ;//fragColor = vec4(abs(mod(i,2.0)-float(truchetw))*i/limit+(0.5-i/limit*0.5));\n ;}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}