{
    "Shader": {
        "info": {
            "date": "1617609018",
            "description": "Ancient Roman puzzle in the Rubik style",
            "flags": 0,
            "hasliked": 0,
            "id": "sd2GRy",
            "likes": 11,
            "name": "Latin Supercube",
            "published": 3,
            "tags": [
                "rubik",
                "puzzle",
                "sator",
                "palindrome"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 302
        },
        "renderpass": [
            {
                "code": "// \"Latin Supercube\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Ancient Roman puzzle in the Rubik style\n\n// Faces are (multipalindromic) Sator Squares - https://en.wikipedia.org/wiki/Sator_Square\n// (Based on extended \"Big Rubik Pseudosolver\")\n\nmat3 VToRMat (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nint PxTextId (int txt);\nfloat PxTextAA (vec2 qBlkH, int cId);\nfloat Hashff (float p);\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 vuMat;\nvec2 qBlk;\nfloat tCur, dstFar, bSize, rSeed;\nconst float pi = 3.1415927;\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 p, mat3 m)\n{\n  vec3 rdm, v, tm, tp, u, fcBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  rdm = m * rd;\n  if (rdm.x == 0.) rdm.x = 0.001;\n  if (rdm.y == 0.) rdm.y = 0.001;\n  if (rdm.z == 0.) rdm.z = 0.001;\n  v = (m * ro - p) / rdm;\n  tp = bSize / abs (rdm) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < min (df, dMin)) {\n    dMin = dn;\n    fcBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rdm;\n  }\n  if (dMin < dstFar) qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk));\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nconst float nbE = 5.;\nconst float nTwist = 30.;\n\nmat3 RotSeq (vec3 bId, float nt, float aRot)\n{                     // Derived rotation matrix sequence from Kali's \"Rubik\"\n  mat3 rMat, m;\n  vec3 ax[3], vSlice;\n  vec2 e;\n  float s, sa;\n  e = vec2 (1., 0.);\n  ax[0] = e.xyy;\n  ax[1] = e.yxy;\n  ax[2] = e.yyx;\n  rMat = mat3 (e.xyy, e.yxy, e.yyx);\n  for (float n = float (VAR_ZERO); n < nTwist; n ++) {\n    if (n > nt) break;\n    s = mod (n + floor (6. * Hashff (99. + rSeed)), 6.);\n    sa = sign (s - 2.5);\n    s = mod (s, 3.);\n    vSlice = (s == 0.) ? e.xyy : ((s == 1.) ? e.yxy : e.yyx);\n    if (length ((bId + 0.5 * (nbE + 1.)) * vSlice) - 1. == floor (nbE * Hashff (n + rSeed))) {\n      m = VToRMat (sa * ((s == 0.) ? ax[0] : ((s == 1.) ? ax[1] : ax[2])),\n         0.5 * pi * ((n < nt) ? 1. : aRot));\n      for (int k = 0; k < 3; k ++) ax[k] = m * ax[k];\n      rMat = m * rMat;\n      if (n < nt) bId = VToRMat (sa * vSlice, -0.5 * pi) * bId;\n    }\n  }\n  return rMat;\n}\n\nvoid ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, fcBlk;\n  float dn, df, bs;\n  bs = 10. * dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bs / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bs;\n  }\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return vec3 (0.6, 0.6, 0.8) * (0.3 + 0.1 * rd.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatH;\n  vec4 col4, d4, bs4;\n  vec3 col, vn, ltDir, fcBlk, bId, bidH, de3, ld, vnSph;\n  vec2 qBlkH, de, fc;\n  float dstBlk, dstSph, dstExtSph, d, nt, tCyc, shSpd, tWait, aRot, dSum, sSum, bMin, fcId;\n  bSize = 0.48;\n  d4 = SphHit (ro, rd, 0.9 * (2. * nbE + 1.) * bSize);\n  dstExtSph = d4.x;\n  col = BgCol (rd);\n  if (dstExtSph < dstFar) {\n    shSpd = 10.;\n    tWait = 4.;\n    tCyc = (nTwist + tWait) * (1. + 1. / shSpd) + tWait;\n    tCur += tCyc - 1.5 * tWait;\n    nt = nTwist - max (0., mod (tCur, tCyc) - tWait);\n    if (nt + tWait < 0.) nt = - shSpd * (nt + tWait);\n    aRot = smoothstep (0.1, 0.9, max (0., fract (nt) * sign (nt)));\n    nt = max (0., floor (nt));\n    rSeed = 17.77 * floor ((tCur + (nTwist + tWait) / shSpd + tWait) / tCyc + 1.);\n    bMin = 0.5 * (nbE - 1.) - 0.5;\n    dstBlk = dstFar;\n    for (float j = float (VAR_ZERO); j < nbE * nbE * nbE; j ++) {\n      bId = vec3 (mod (j, nbE), mod (floor (j / nbE), nbE), floor (j / (nbE * nbE))) - 0.5 * (nbE - 1.);\n      if (Maxv3 (abs (bId)) > bMin) {\n        rMat = RotSeq (bId, nt, aRot);\n        bs4 = BlkHit (ro, rd, bId, rMat);\n        d = bs4.x;\n        if (d < dstBlk) {\n          dstBlk = d;\n          fcBlk = bs4.yzw;\n          rMatH = rMat;\n          qBlkH = qBlk;\n          bidH = bId;\n        }\n      }\n    }\n    bs4 = SphHit (ro, rd, (nbE - 0.2) * bSize);\n    dstSph = bs4.x;\n    if (min (dstBlk, dstSph) < dstFar) {\n      if (dstBlk < dstSph) {\n        ro += dstBlk * rd;\n        de = smoothstep (-0.08, 0., abs (qBlkH.xy) - bSize);\n        de3 = vec3 (0.25 * pi * de * sign (qBlkH.xy), 0.);\n        vn = normalize (fcBlk + ((fcBlk.x != 0.) ? de3.zxy : ((fcBlk.y != 0.) ? de3.xzy : de3))) * rMatH;\n        if (length (max (abs (qBlkH) - bSize + 0.12, 0.)) < 0.07) {\n          if (abs (bidH.x) > bMin && sign (bidH.x) == fcBlk.x ||\n              abs (bidH.y) > bMin && sign (bidH.y) == fcBlk.y ||\n              abs (bidH.z) > bMin && sign (bidH.z) == fcBlk.z) {\n            if      (abs (fcBlk.x) == 1.) fcId = (fcBlk.x > 0.) ? 0. : 1.;\n            else if (abs (fcBlk.y) == 1.) fcId = (fcBlk.y > 0.) ? 2. : 3.;\n            else if (abs (fcBlk.z) == 1.) fcId = (fcBlk.z > 0.) ? 4. : 5.;\n            if (fcId == 0.) {\n              col = vec3 (1., 0., 0.);\n              fc = bidH.yz * vec2 (-1., 1.);\n            } else if (fcId == 1.) {\n              col = vec3 (1., 0.4, 0.);\n              fc = - bidH.yz;\n              qBlkH.y = - qBlkH.y;\n            } else if (fcId == 2.) {\n              col = vec3 (0., 0., 1.);\n              fc = bidH.zx * vec2 (1.,  -1.);\n              qBlkH = - qBlkH;\n            } else if (fcId == 3.) {\n              col = vec3 (0., 1., 0.);\n              fc = bidH.zx;\n              qBlkH.x = - qBlkH.x;\n            } else if (fcId == 4.) {\n              col = vec3 (1., 1., 0.);\n              fc = - bidH.yx;\n              qBlkH = qBlkH.yx * vec2 (-1., 1.);\n            } else if (fcId == 5.) {\n              col = vec3 (1., 1., 1.);\n              fc = bidH.yx * vec2 (-1., 1.);\n              qBlkH = - qBlkH.yx;\n            }\n            col *= 0.3 + 0.7 * PxTextAA (qBlkH, PxTextId (int (5. * (fc.x + 2.) + fc.y + 2.)));\n            col4 = vec4 (mix (col, vec3 (0.2, 0.2, 0.2), max (de.x, de.y)), 0.2);\n          } else {\n            col4 = vec4 (0.1, 0.1, 0.1, 0.);\n          }\n        } else {\n          col4 = vec4 (0.2, 0.2, 0.2, 0.1);\n        }\n      } else if (dstSph < dstFar) {\n        ro += dstSph * rd;\n        vn = bs4.yzw;\n        col4 = vec4 (0.1, 0.1, 0.1, 0.);\n      }\n      dSum = 0.;\n      sSum = 0.;\n      ltDir = normalize (vec3 (1., 1., -0.6));\n      for (int j = 0; j < 4; j ++) {\n        ltDir.xy = Rot2D (ltDir.xy, 0.5 * pi);\n        ld = vuMat * ltDir;\n        dSum += pow (max (dot (vn, ld), 0.), 1.5);\n        sSum += pow (max (dot (normalize (ld - rd), vn), 0.), 32.);\n      }\n      col = col4.rgb * (0.2 + 0.6 * dSum) + col4.a * sSum;\n    }\n    vnSph = d4.yzw;\n    ltDir = vuMat * normalize (vec3 (0.8, 1., -0.2));\n    col += 0.02 + 0.02 * max (dot (vnSph, ltDir), 0.) +\n       0.15 * pow (max (dot (normalize (ltDir - rd), vnSph), 0.), 32.);\n    ro += dstExtSph * rd;\n    rd = reflect (rd, vnSph);\n    ExBlkHit (ro, rd);\n    qBlk = step (0.1, mod (8. * qBlk + 0.05, 1.));\n    col = mix (col, BgCol (rd) * (0.8 + 0.2 * qBlk.x * qBlk.y), pow (1. - abs (dot (rd, vnSph)), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA     0  // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 1.15 * pi;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10. * nbE / 3.);\n  zmFac = 3.7;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.zyx * v.xzy;\n  b2 = - cs.y * v;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[1][2] = b1.x + b2.x;  m[2][1] = b1.x - b2.x;\n  m[2][0] = b1.y + b2.y;  m[0][2] = b1.y - b2.y;\n  m[0][1] = b1.z + b2.z;  m[1][0] = b1.z - b2.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\n// Characters from \"Amiga Balls\" (partial)\n\n/*\n Text derived from 8x12 Font shader by Flyguy (Mt2GWD)\n Glyph bitmaps generated from 8x12 font sheet\n   http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n\n#define g_A   33\n#define g_E   37\n#define g_N   46\n#define g_O   47\n#define g_P   48\n#define g_R   50\n#define g_S   51\n#define g_T   52\n\n#define C(g) s = max (s, PxChar (p, glph[g - g_A]));\n\nvec4 glph[26];\n\nfloat PxChar (vec2 p, vec4 c)\n{\n  vec2 cb, ip, fp;\n  float pOn, b;\n  ip = floor (p);\n  if (min (ip.x, ip.y) >= 0. && max (ip.x - 8., ip.y - 12.) < 0.) {\n    b = 8. * (ip.y + 1.) - (ip.x + 1.);\n    if (b < 48.) cb = (b < 24.) ? vec2 (c.w, b) : vec2 (c.z, b - 24.);\n    else cb = (b < 72.) ? vec2 (c.y, b - 48.) : vec2 (c.x, b - 72.);\n    pOn = mod (floor (cb.x / exp2 (cb.y)), 2.);\n  } else pOn = 0.;\n  return pOn;\n}\n\nfloat PxText (vec2 p, int cId)\n{\n  float s;\n  s = 0.;\n  if      (cId == g_S) C(g_S)\n  else if (cId == g_A) C(g_A)\n  else if (cId == g_T) C(g_T) \n  else if (cId == g_O) C(g_O)\n  else if (cId == g_R) C(g_R) \n  else if (cId == g_E) C(g_E)\n  else if (cId == g_P) C(g_P)\n  else if (cId == g_N) C(g_N)\n  return s;\n}\n\nint PxTextId (int txt)\n{\n  int cId;\n  if      (txt == 0 || txt == 24) cId = g_S;\n  else if (txt == 1 || txt == 5  || txt == 19 || txt == 23) cId = g_A;\n  else if (txt == 2 || txt == 10 || txt == 14 || txt == 22) cId = g_T;\n  else if (txt == 3 || txt == 9  || txt == 15 || txt == 21) cId = g_O;\n  else if (txt == 4 || txt == 6  || txt == 18 || txt == 20) cId = g_R;\n  else if (txt == 7 || txt == 11 || txt == 13 || txt == 17) cId = g_E;\n  else if (txt == 8 || txt == 16) cId = g_P;\n  else if (txt == 12) cId = g_N;\n  return cId;\n}\n\nvoid PxInit ()\n{\n  glph[g_A - g_A] = vec4 (0x003078, 0xCCCCCC, 0xFCCCCC, 0xCC0000);\n  glph[g_E - g_A] = vec4 (0x00FE62, 0x60647C, 0x646062, 0xFE0000);\n  glph[g_N - g_A] = vec4 (0x00C6C6, 0xE6F6FE, 0xDECEC6, 0xC60000);\n  glph[g_O - g_A] = vec4 (0x00386C, 0xC6C6C6, 0xC6C66C, 0x380000);\n  glph[g_P - g_A] = vec4 (0x00FC66, 0x66667C, 0x606060, 0xF00000);\n  glph[g_R - g_A] = vec4 (0x00FC66, 0x66667C, 0x6C6666, 0xE60000);\n  glph[g_S - g_A] = vec4 (0x0078CC, 0xCCC070, 0x18CCCC, 0x780000);\n  glph[g_T - g_A] = vec4 (0x00FCB4, 0x303030, 0x303030, 0x780000);\n}\n\nfloat PxTextAA (vec2 qBlkH, int cId)\n{\n  vec3 ee;\n  vec2 qc;\n  float sc;\n  ee = 0.4 * vec3 (1., -1., 0.);\n  qc = 16. * qBlkH + 32. * vec2 (0.1, 0.2);\n  PxInit ();\n  sc = PxText (qc, cId);\n  sc = max (sc, 0.5 * PxText (qc + ee.xz, cId));\n  sc = max (sc, 0.5 * PxText (qc + ee.yz, cId));\n  sc = max (sc, 0.5 * PxText (qc + ee.zx, cId));\n  sc = max (sc, 0.5 * PxText (qc + ee.zy, cId));\n  sc = max (sc, 0.3 * PxText (qc + ee.xx, cId));\n  sc = max (sc, 0.3 * PxText (qc + ee.xy, cId));\n  sc = max (sc, 0.3 * PxText (qc + ee.yy, cId));\n  sc = max (sc, 0.3 * PxText (qc + ee.yx, cId));\n  return sc;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}