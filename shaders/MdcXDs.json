{
    "Shader": {
        "info": {
            "date": "1462146415",
            "description": "lets ride them fractals...\nuse A,S,D,W (or cursor keys) for driving, X for break, R,F for camera zoom and Q,E for cam rotation, I for re-init.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "MdcXDs",
            "likes": 71,
            "name": "2121 on iceworld",
            "published": 3,
            "tags": [
                "3d",
                "game",
                "simulation",
                "truchet",
                "physics",
                "car",
                "driving"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 4050
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// very much inspired by iq's \"Volcanic\", WAHa_06x36's \"Truchet Tentacles\" and Shanes \"Entangled Vines\"\n\n#define readSampler iChannel1\n#define randSampler iChannel2\n#define time iDate.w\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n//----- common ------\n\n#define MaxParticleNum 1\n#define InRes iChannel0Resolution\n\nstruct Particle {\n    vec4 pos;\n    vec4 vel;\n    vec4 angVel;\n    vec4 quat;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\n#define PixPerParticle 5\n#define ParticlesPerLine 16\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/16)+50; } // first line (y=0) reserved for other than particle-data\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-50)*16 + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.vel;\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=p.angVel;\n    if (isPixel(xc+3,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+4,yc,fragCoord)) fragColor.xyzw=vec4(p.quat.w,0,0,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.vel    = getPixel(xc+1,yc);\n    p.angVel = getPixel(xc+2,yc);\n    p.quat   = getPixel(xc+3,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+4,yc);\n    p.quat.w = p2.x;\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\nvec3 readCamPos()\n{\n    return getPixel(0,0).xyz;\n}\n\nvec4 readCamQuat()\n{\n    vec4 q;\n    q   = getPixel(1,0);\n    q.w = getPixel(2,0).x;\n    return q;\n}\n\nvec3 readCamNav()\n{\n    return getPixel(3,0).xyz;\n}\n\nvoid writeCamPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(0,0,fragCoord)) fragColor.xyz=pos;\n}\n\nvoid writeCamQuat(vec4 quat, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(1,0,fragCoord)) fragColor.xyzw=quat;\n    if (isPixel(2,0,fragCoord)) fragColor.x=quat.w;\n}\n\nvoid writeCamNav(vec3 nav, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(3,0,fragCoord)) fragColor.xyz=nav;\n}\n\nfloat readSteeringAngle()\n{\n    return getPixel(4,0).x;\n}\n\nvoid writeSteeringAngle(float st, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(4,0,fragCoord)) fragColor.x=st;\n}\n\nfloat readGas()\n{\n    return getPixel(4,0).y;\n}\n\nvoid writeGas(float gas, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(4,0,fragCoord)) fragColor.y=gas;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos)\n{\n    float speed=0.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(60.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    eye = readCamPos();\n    vec4 cq = readCamQuat();\n    right = transformVecByQuat(vec3(1,0,0),cq);\n    up    = transformVecByQuat(vec3(0,0,1),cq);\n    fwd   = transformVecByQuat(vec3(0,1,0),cq);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\n#define torusWorldRadius1 90.0\n#define torusWorldRadius2 30.0\n\n\n\n// ---- truchet cell funcs -----\n// derived from WAHa_06x36 - shadertoy (https://www.shadertoy.com/view/ldfGWn)\n\nfloat truchetRand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat truchetArc(vec3 pos, float radius)\n{\n    pos=fract(pos);\n    float r=length(pos.xy);\n    return length(vec2(r-0.5,pos.z-0.5))-radius;\n}\n\nfloat truchetCell(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz               ,r),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat sphere(vec3 pos, float r) { return length(pos)-r; }\n\nfloat truchetCell2(vec3 pos, float r)\n{\n    return min(min(\n        min(sphere(fract(pos)-vec3(0,0.5,0.5),r),sphere(fract(pos)-vec3(0.5,0,0.5),r)),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat truchetCell3(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz    ,r),\n        truchetArc(pos.xyz*vec3(-1,-1,1) ,r)),\n        length(fract(pos.xy)-vec2(0.5))-r\n              );\n}\n\n// i tried to put all if's from WAHa_06x36's version into\n// one modulo operation, and left away the swizzling.\n// i think all roatational/mirrored cases are covered this way.\n// yet im not completely sure...\nfloat truchetDist(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    return truchetCell(cellpos*fact,r);\n}\n\nfloat truchetDist2(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    float rnd2=truchetRand(gridpos+vec3(3.2,4.432,6.32))*3.0;\n    float rnd3=truchetRand(gridpos-vec3(3.2,4.432,6.32))*3.0;\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    if     (rnd3>2.0) cellpos = cellpos.yzx;\n    else if(rnd3>1.0) cellpos = cellpos.zxy;\n\n    if     (rnd2<1.0)\n        return truchetCell(cellpos*fact,r);\n    else if(rnd2<2.0)\n        return truchetCell2(cellpos*fact,r);\n    else if(rnd2<3.0)\n        return truchetCell3(cellpos.zxy,r);\n\n    return truchetCell(cellpos*fact,r);\n}\n\n#define randSampler iChannel2\n\nvec4 snoise(vec2 texc) { return  2.0*texture(randSampler,texc, -1000.0)-vec4(1.0); }\n\nvec4 snoise3Dv4S(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    // using iq's improved texture filtering (https://www.shadertoy.com/view/XsfGDn)\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = ((p.xy+vec2(17.0,7.0)*p.z) + 0.5 + f.xy)/256.0;\n    vec4 v1 = texture( randSampler, uv, -1000.0);\n    vec4 v2 = texture( randSampler, uv+vec2(17.0,7.0)/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\n// this is a somewhat modified version of iq's noise in \"volcanic\"\nvec4 snoise3Dv4(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    //f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = texture( randSampler, uv/256.0, -1000.0);\n    vec4 v2 = texture( randSampler, (uv+vec2(17,7))/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\nfloat snoise3D(vec3 texc)\n{\n    return snoise3Dv4(texc).x;\n}\n\nfloat snoise3DS(vec3 texc)\n{\n    return snoise3Dv4S(texc).x;\n}\n\nfloat mScaleNoise(vec3 texc)\n{\n    float d=0.0;\n    d+=snoise3DS(texc);\n    d+=snoise3DS(texc*2.553)*0.5;\n    d+=snoise3DS(texc*5.154)*0.25;\n    //d+=snoise3DS(texc*400.45)*0.009;\n    d+=snoise3DS(texc*400.45*vec3(0.1,0.1,1.0))*0.009;\n    //d+=snoise3DS(texc*900.45*vec3(0.1,1.0,0.1))*0.005;\n    //d+=snoise3DS(texc*900.45*vec3(1.0,0.1,0.1))*0.005;\n    d*=0.5;\n    return d;\n}\n\nfloat getDistanceWorldS(vec3 pos)\n{\n    vec3 pos0=pos;\n\n    float dist = 100000.0;\n    dist=truchetDist(pos*0.006,0.13+0.05*cos(0.02*(pos.x+pos.y+pos.z)))/0.006;\n    float f=sin(0.01*(pos.x+pos.y+pos.z));\n    dist+=clamp(15.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0)*(0.2+0.8*f*f);\n\n    return dist;\n}\n\nvec3 getDistanceWorldSGradientSlow(vec3 pos, float delta)\n{\n    return vec3 (\n                 getDistanceWorldS( pos+delta*vec3(1,0,0) )-getDistanceWorldS( pos-delta*vec3(1,0,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,1,0) )-getDistanceWorldS( pos-delta*vec3(0,1,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,0,1) )-getDistanceWorldS( pos-delta*vec3(0,0,1) )\n                )/2.0/delta;\n}\n\nvec3 getDistanceWorldSGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistanceWorldS(pos);\n    return vec3(getDistanceWorldS(pos+eps.xyy)-d,\n                getDistanceWorldS(pos+eps.yxy)-d,\n                getDistanceWorldS(pos+eps.yyx)-d)/delta;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n\n#define Mass 2.0\n#define Iinv (mat3( 1.6,0,0, 0,3.0,0, 0,0,1.4 )/Mass)\n#define WheelRadius 0.45\n\n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec4 getDistanceObjS(vec3 pos)\n{\n    float obj=0.0;\n    float dist = 100000.0;\n    float steeringAngle=readSteeringAngle();\n    vec4 q = vec4(0,sin(steeringAngle*0.5),0,cos(steeringAngle*0.5));\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    float dist2 = dist;\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFR).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFL).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    if(dist!=dist2) obj=1.0;\n    return vec4(dist,obj,0,0);\n}\n\n#define lightPos vec3(-0.06,0.30,0)\n\n#define godStrength 1.3\n#define godPower 1.5\n#define sampNum 128\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect=iResolution.y/iResolution.x;\n    vec2 spos = fragCoord.xy/iResolution.xy*2.0-vec2(1.0);\n    vec3 right, fwd, up, pos, dir;\n    getEyeCoords(right,fwd,up,pos,dir,aspect,spos);\n\n    vec2 ppos = fragCoord.xy/iResolution.xy*2.0-vec2(1.0);\n\n    vec3 lpos = lightPos;\n    lpos = 0.5*vec3(0.3*cos(time*0.3132*3.0),cos(time*0.534*3.0),0);\n    vec4 camQuat=readCamQuat();\n    lpos = transformVecByQuat(vec3(0,0,100)-pos,inverseQuat(camQuat));\n    lpos.xy/=lpos.z;\n    lpos.xy = calcScreenPos(pos, right, fwd, up, pos+vec3(0,0,10000), aspect);\n    lpos.z=dot(vec3(0,0,1),fwd);\n\n    float rnd=0.2*texture(randSampler,normalize(ppos.xy-lpos.xy)*0.07+vec2(time*0.02), -1000.0).x;\n\n    float occ=0.0;\n\n    int i;\n    float sum=0.0;\n    vec4 col = vec4(0);\n    vec2  ldistv = ppos.xy-lpos.xy;\n    float ldist=length(ldistv);\n    float amp = pow(ldist,godPower)*godStrength;\n    amp=clamp(amp,0.0,1.0);\n    vec2 delta = normalize(ppos.xy-lpos.xy);\n    for(int i=0;i<sampNum;i++)\n    {\n        vec2 ppos2;\n        vec2 texc;\n        float weight = 1.0-length((float(i))/float(sampNum));\n        float sampOffs=-sign(lpos.z)*(float(i))/float(sampNum);\n        ppos2 = ppos.xy+amp*sampOffs*delta;\n        texc = ppos2*0.5+vec2(0.5);\n        vec4 c1=clamp(vec4(-0.4+0.1*rnd)+texture(iChannel0,texc),vec4(0),vec4(1))+vec4(0.2);\n        col+=weight*pow(c1,vec4(2.0));\n        sum+=weight;\n    }\n    col/=sum;\n    //col=1.0*mix(texture(iChannel0,fragCoord.xy/iResolution.xy),1.0*col,0.5*clamp(1.0-0.8*(-lpos.z*0.5+0.5),0.0,1.0));\n    float gf=clamp(1.0-4.0*(-lpos.z*0.5+0.5),0.0,1.0);\n    col=texture(iChannel0,fragCoord.xy/iResolution.xy)+col*1.0*gf;\n    fragColor = col*(1.0-0.25*gf);\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// very much inspired by iq's \"Volcanic\", WAHa_06x36's \"Truchet Tentacles\" and Shanes \"Entangled Vines\"\n\n#define readSampler iChannel0\n#define randSampler iChannel2\n#define time iDate.w\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n//----- common ------\n\n#define MaxParticleNum 1\n#define InRes iChannel0Resolution\n\nstruct Particle {\n    vec4 pos;\n    vec4 vel;\n    vec4 angVel;\n    vec4 quat;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\n#define PixPerParticle 5\n#define ParticlesPerLine 16\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/16)+50; } // first line (y=0) reserved for other than particle-data\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-50)*16 + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.vel;\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=p.angVel;\n    if (isPixel(xc+3,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+4,yc,fragCoord)) fragColor.xyzw=vec4(p.quat.w,0,0,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.vel    = getPixel(xc+1,yc);\n    p.angVel = getPixel(xc+2,yc);\n    p.quat   = getPixel(xc+3,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+4,yc);\n    p.quat.w = p2.x;\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\nvec3 readCamPos()\n{\n    return getPixel(0,0).xyz;\n}\n\nvec4 readCamQuat()\n{\n    vec4 q;\n    q   = getPixel(1,0);\n    q.w = getPixel(2,0).x;\n    return q;\n}\n\nvec3 readCamNav()\n{\n    return getPixel(3,0).xyz;\n}\n\nvoid writeCamPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(0,0,fragCoord)) fragColor.xyz=pos;\n}\n\nvoid writeCamQuat(vec4 quat, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(1,0,fragCoord)) fragColor.xyzw=quat;\n    if (isPixel(2,0,fragCoord)) fragColor.x=quat.w;\n}\n\nvoid writeCamNav(vec3 nav, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(3,0,fragCoord)) fragColor.xyz=nav;\n}\n\nfloat readSteeringAngle()\n{\n    return getPixel(4,0).x;\n}\n\nvoid writeSteeringAngle(float st, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(4,0,fragCoord)) fragColor.x=st;\n}\n\nfloat readGas()\n{\n    return getPixel(4,0).y;\n}\n\nvoid writeGas(float gas, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(4,0,fragCoord)) fragColor.y=gas;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos)\n{\n    float speed=0.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(60.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    eye = readCamPos();\n    vec4 cq = readCamQuat();\n    right = transformVecByQuat(vec3(1,0,0),cq);\n    up    = transformVecByQuat(vec3(0,0,1),cq);\n    fwd   = transformVecByQuat(vec3(0,1,0),cq);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\n#define torusWorldRadius1 90.0\n#define torusWorldRadius2 30.0\n\n\n\n// ---- truchet cell funcs -----\n// derived from WAHa_06x36 - shadertoy (https://www.shadertoy.com/view/ldfGWn)\n\nfloat truchetRand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat truchetArc(vec3 pos, float radius)\n{\n    pos=fract(pos);\n    float r=length(pos.xy);\n    return length(vec2(r-0.5,pos.z-0.5))-radius;\n}\n\nfloat truchetCell(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz               ,r),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat sphere(vec3 pos, float r) { return length(pos)-r; }\n\nfloat truchetCell2(vec3 pos, float r)\n{\n    return min(min(\n        min(sphere(fract(pos)-vec3(0,0.5,0.5),r),sphere(fract(pos)-vec3(0.5,0,0.5),r)),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat truchetCell3(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz    ,r),\n        truchetArc(pos.xyz*vec3(-1,-1,1) ,r)),\n        length(fract(pos.xy)-vec2(0.5))-r\n              );\n}\n\n// i tried to put all if's from WAHa_06x36's version into\n// one modulo operation, and left away the swizzling.\n// i think all roatational/mirrored cases are covered this way.\n// yet im not completely sure...\nfloat truchetDist(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    return truchetCell(cellpos*fact,r);\n}\n\nfloat truchetDist2(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    float rnd2=truchetRand(gridpos+vec3(3.2,4.432,6.32))*3.0;\n    float rnd3=truchetRand(gridpos-vec3(3.2,4.432,6.32))*3.0;\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    if     (rnd3>2.0) cellpos = cellpos.yzx;\n    else if(rnd3>1.0) cellpos = cellpos.zxy;\n\n    if     (rnd2<1.0)\n        return truchetCell(cellpos*fact,r);\n    else if(rnd2<2.0)\n        return truchetCell2(cellpos*fact,r);\n    else if(rnd2<3.0)\n        return truchetCell3(cellpos.zxy,r);\n\n    return truchetCell(cellpos*fact,r);\n}\n\n#define randSampler iChannel2\n\nvec4 snoise(vec2 texc) { return  2.0*texture(randSampler,texc, -1000.0)-vec4(1.0); }\n\nvec4 snoise3Dv4S(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    // using iq's improved texture filtering (https://www.shadertoy.com/view/XsfGDn)\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = ((p.xy+vec2(17.0,7.0)*p.z) + 0.5 + f.xy)/256.0;\n    vec4 v1 = texture( randSampler, uv, -1000.0);\n    vec4 v2 = texture( randSampler, uv+vec2(17.0,7.0)/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\n// this is a somewhat modified version of iq's noise in \"volcanic\"\nvec4 snoise3Dv4(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    //f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = texture( randSampler, uv/256.0, -1000.0);\n    vec4 v2 = texture( randSampler, (uv+vec2(17,7))/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\nfloat snoise3D(vec3 texc)\n{\n    return snoise3Dv4(texc).x;\n}\n\nfloat snoise3DS(vec3 texc)\n{\n    return snoise3Dv4S(texc).x;\n}\n\nfloat mScaleNoise(vec3 texc)\n{\n    float d=0.0;\n    d+=snoise3DS(texc);\n    d+=snoise3DS(texc*2.553)*0.5;\n    d+=snoise3DS(texc*5.154)*0.25;\n    //d+=snoise3DS(texc*400.45)*0.009;\n    d+=snoise3DS(texc*400.45*vec3(0.1,0.1,1.0))*0.009;\n    //d+=snoise3DS(texc*900.45*vec3(0.1,1.0,0.1))*0.005;\n    //d+=snoise3DS(texc*900.45*vec3(1.0,0.1,0.1))*0.005;\n    d*=0.5;\n    return d;\n}\n\nfloat getDistanceWorldS(vec3 pos)\n{\n    vec3 pos0=pos;\n\n    float dist = 100000.0;\n    dist=truchetDist(pos*0.006,0.13+0.05*cos(0.02*(pos.x+pos.y+pos.z)))/0.006;\n    float f=sin(0.01*(pos.x+pos.y+pos.z));\n    dist+=clamp(15.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0)*(0.2+0.8*f*f);\n\n    return dist;\n}\n\nvec3 getDistanceWorldSGradientSlow(vec3 pos, float delta)\n{\n    return vec3 (\n                 getDistanceWorldS( pos+delta*vec3(1,0,0) )-getDistanceWorldS( pos-delta*vec3(1,0,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,1,0) )-getDistanceWorldS( pos-delta*vec3(0,1,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,0,1) )-getDistanceWorldS( pos-delta*vec3(0,0,1) )\n                )/2.0/delta;\n}\n\nvec3 getDistanceWorldSGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistanceWorldS(pos);\n    return vec3(getDistanceWorldS(pos+eps.xyy)-d,\n                getDistanceWorldS(pos+eps.yxy)-d,\n                getDistanceWorldS(pos+eps.yyx)-d)/delta;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n\n#define Mass 2.0\n#define Iinv (mat3( 1.6,0,0, 0,3.0,0, 0,0,1.4 )/Mass)\n#define WheelRadius 0.45\n\n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec4 getDistanceObjS(vec3 pos)\n{\n    float obj=0.0;\n    float dist = 100000.0;\n    float steeringAngle=readSteeringAngle();\n    vec4 q = vec4(0,sin(steeringAngle*0.5),0,cos(steeringAngle*0.5));\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    float dist2 = dist;\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFR).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFL).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    if(dist!=dist2) obj=1.0;\n    return vec4(dist,obj,0,0);\n}\n//----- update ------\n\nvoid initAll( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0.0);\n    int pidx=PIdx(int(fragCoord.x),int(fragCoord.y));\n    if(pidx>=0)\n    {\n        Particle p;\n        p.pos.xyz = vec3(float(pidx*5)+torusWorldRadius1,0.0,torusWorldRadius2*1.1);\n        p.vel.xyz = vec3(0,0,0);\n        p.quat = vec4(0,0,0,1);\n        p.quat = normalize(vec4(0.46,0.68,0.26,0.5));\n        p.pos.xyz = vec3(101.7,2.41,84.72)+vec3(5,5,0)*float(pidx);\n        writeParticle(pidx,p,fragColor,fragCoord);\n    }\n    writeCamPos(vec3(0),fragColor,fragCoord);\n    writeCamPos(vec3(99.5,4.5,54.8),fragColor,fragCoord);\n    writeCamQuat(vec4(0,0,0,1),fragColor,fragCoord);\n    writeCamQuat(normalize(vec4(0.592,0.428,0.471,0.494)),fragColor,fragCoord);\n    writeSteeringAngle(0.2,fragColor,fragCoord);\n    writeGas(0.0,fragColor,fragCoord);\n    writeCamNav(vec3(30.0,-0.54,0.3), fragColor, fragCoord);\n}\n\n#define SpringConst 10.1\n#define SpringConstStab 5.1\n#define DT min(0.5*iTimeDelta,0.05)\n\nvoid calcWheelForceAndTorque(inout Particle p, vec3 wheelPos, float wheelRadius, float steeringAngle, float frictionCoeff, float wheelAngSpeed, float springConst, float clutch, inout vec3 force, inout vec3 torque)\n{\n    vec3 wheelPosW = p.pos.xyz+transformVecByQuat(wheelPos.xyz,p.quat);\n    float dist = getDistanceWorldS(wheelPosW);\n    if(dist<wheelRadius)\n    {\n        // forces by wheels\n        vec3 dforce = vec3(0,0,0);\n        vec3 distGrad = getDistanceWorldSGradient(wheelPosW,0.1);\n        vec3 distDir = normalize(distGrad);\n        dforce=distDir*(wheelRadius-dist)*springConst;\n        //p.vel.xyz -= distDir*dot(p.vel.xyz,distDir)*0.1;\n        force  += dforce;\n        torque += cross(dforce,wheelPosW-p.pos.xyz);\n\n        float fl = length(dforce);\n\n        // wheel-drive-forces\n        vec3 chassisRotVel = transformVecByQuat(cross(-p.angVel.xyz,wheelPos.xyz+vec3(0,0,-WheelRadius)),p.quat);\n        vec3 wheelAxe = transformVecByQuat(vec3(cos(steeringAngle),sin(-steeringAngle),0),p.quat);\n        vec3 f=normalize(cross(distDir,wheelAxe));\n        //vec3 c=wheelAngSpeed*wheelRadius*f-p.vel.xyz-chassisRotVel+dot(p.vel.xyz+chassisRotVel,distDir)*0.9*distDir;\n        ///*if(length(c)>1.0)*/ c=normalize(c);\n        //dforce = fl*frictionCoeff*c;\n\n        vec3 c=wheelAngSpeed*wheelRadius*f-p.vel.xyz-chassisRotVel;\n        // in f dir\n        dforce += fl*frictionCoeff*clutch*sign(dot(c,f))*f;\n        // in wheelaxe dir\n        dforce += fl*frictionCoeff*sign(dot(c,wheelAxe))*wheelAxe;\n        // in up dir\n        dforce += fl*sign(dot(c,distDir))*distDir*0.7;\n\n        force  += dforce;\n        torque += cross(dforce,wheelPosW+transformVecByQuat(vec3(0,0,-WheelRadius),p.quat)-p.pos.xyz);\n    }\n\n}\n\nvoid calcObjForceAndMom(Particle p, Particle p2, inout vec3 force, inout vec3 torque)\n{\n    vec3 collpos1;\n    vec3 collpos2;\n    vec3 dforce=vec3(0);\n    vec3 d;\n    vec3 dn;\n\n    for(int k=0;k<4;k++)\n    {\n        //collpos1 = p.pos.xyz  + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k&1),p.quat);\n        //collpos2 = p2.pos.xyz + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k&2)*0.5,p2.quat);\n        collpos1 = p.pos.xyz  + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*mod(float(k),2.0),    p.quat);\n        collpos2 = p2.pos.xyz + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*mod(float(k),4.0)*0.5,p2.quat);\n\n        d = collpos1 - collpos2;\n        dn = p2.pos.xyz-p.pos.xyz;\n        if( length(d)<2.0 ) dforce=100.1*d/(length(d)+0.1);\n        force+=dforce;\n        torque+=1.0*cross(dforce,0.5*(collpos1+collpos2)-p.pos.xyz);\n    }\n    //TODO: friction force+torque\n    //torque+=0.3*cross(cross(dforce,normalize(dn)),0.5*(collpos1+collpos2)-pos);\n}\n\n#define GRAVITY -4.0\nvec3 getGravityWorld(vec3 pos)\n{\n    return GRAVITY*normalize(getDistanceWorldSGradientSlow(pos, 5.0)+getDistanceWorldSGradientSlow(pos, 10.0));\n}\n\n#define keyTex iChannel1\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_A texture(keyTex,vec2(( 97.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_D texture(keyTex,vec2((100.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_W texture(keyTex,vec2((119.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_X texture(keyTex,vec2((120.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_Q texture(keyTex,vec2((113.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_R texture(keyTex,vec2((114.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_S texture(keyTex,vec2((115.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_E texture(keyTex,vec2((101.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_F texture(keyTex,vec2((102.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_LEFT  texture(keyTex,vec2(37.5/256.0,(0.5+0.0)/3.0)).x\n#define KEY_UP    texture(keyTex,vec2(38.5/256.0,(0.5+0.0)/3.0)).x\n#define KEY_RIGHT texture(keyTex,vec2(39.5/256.0,(0.5+0.0)/3.0)).x\n#define KEY_DOWN  texture(keyTex,vec2(40.5/256.0,(0.5+0.0)/3.0)).x\n\nvoid calcCamera( inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos  = readCamPos();\n    vec4 camQuat = readCamQuat();\n    vec3 camDistRzRx = readCamNav();\n    float camDistScalar = camDistRzRx.x;\n    float camRotZ = camDistRzRx.y;\n    float camRotX = camDistRzRx.z;\n\n    float sDist=getDistanceWorldS(camPos);\n    if(sDist<0.2) camDistScalar-=0.2;\n    if(KEY_R>0.5) camDistScalar-=0.3;\n    if(KEY_F>0.5) camDistScalar+=0.3;\n    if(camDistScalar<3.5) camDistScalar=3.5;\n\n    if(KEY_E>0.5) camRotZ-=0.01;\n    if(KEY_Q>0.5) camRotZ+=0.01;\n\n    Particle p = readParticle(0);\n    vec3 camDist = vec3(-sin(camRotZ)*cos(camRotX),-cos(camRotZ)*cos(camRotX),sin(camRotX))*camDistScalar;\n\n    vec3 newCamPos  = p.pos.xyz+transformVecByQuat(camDist,p.quat);\n    float ang;\n    vec4 newCamQuat = p.quat;\n    newCamQuat = multQuat(newCamQuat,vec4(normalize(vec2(camDist.yx*vec2(1,-1)))*sin(camRotX*0.5),0,cos(camRotX*0.5)));\n    newCamQuat = multQuat(newCamQuat,vec4(0,0,sin(-camRotZ*0.5),cos(-camRotZ*0.5)));\n\n    camPos  = mix( camPos,  newCamPos,  0.02 );\n\n    camQuat = normalize(mix( camQuat, newCamQuat, 0.08 ));\n\n    camDistRzRx.x=camDistScalar;\n    camDistRzRx.y=camRotZ;\n    camDistRzRx.z=camRotX;\n    writeCamNav(camDistRzRx, fragColor, fragCoord);\n    writeCamQuat(camQuat, fragColor, fragCoord);\n    writeCamPos(camPos,   fragColor, fragCoord);\n}\n\n\nvoid calcSteering( inout vec4 fragColor, in vec2 fragCoord )\n{\n    float steeringAngle = readSteeringAngle();\n    float gas = readGas();\n\n    if     (KEY_A>0.5 || KEY_LEFT >0.5) steeringAngle-=0.02;\n    else if(KEY_D>0.5 || KEY_RIGHT>0.5) steeringAngle+=0.02;\n    else steeringAngle*=0.9;\n\n    if     (KEY_W>0.5 || KEY_UP  >0.5) gas+=0.01;\n    else if(KEY_S>0.5 || KEY_DOWN>0.5) gas-=0.01;\n    else gas*=0.9;\n\n    gas=clamp(gas,-1.0,1.0);\n    steeringAngle=clamp(steeringAngle,-0.5,0.5);\n\n    writeSteeringAngle(steeringAngle,   fragColor, fragCoord);\n    writeGas(gas, fragColor, fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // copy old content\n    fragColor = getPixel(int(fragCoord.x),int(fragCoord.y));\n\n    int pidx=PIdx(int(fragCoord.x),int(fragCoord.y));\n    if(pidx>=0 && pidx<MaxParticleNum)\n    {\n        vec3 force = vec3(0,0,0);\n        vec3 torque = vec3(0,0,0);\n\n        Particle p = readParticle(pidx);\n\n        // gravity\n        force+=getGravityWorld(p.pos.xyz)*Mass;\n\n        // velocity damping\n        force+=-0.2*p.vel.xyz;\n        torque+=-0.2*transformVecByQuat(p.angVel.xyz,p.quat);\n\n        float steeringAngle = readSteeringAngle();\n        float gas = readGas();\n        float clutch = clamp(abs(gas),0.0,1.0);\n        float rotSpeed = gas*50.0;\n        if(KEY_X>0.5) { clutch=1.0; gas=0.0; }\n        // wheel forces\n        calcWheelForceAndTorque(p,WheelFL,WheelRadius,steeringAngle,1.7,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelFR,WheelRadius,steeringAngle,1.7,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelBL,WheelRadius,     0.0,     1.7,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelBR,WheelRadius,     0.0,     1.7,rotSpeed,SpringConst,clutch,force,torque);\n        // stabilizers\n        calcWheelForceAndTorque(p,vec3(0,0,1.6),1.8,     0.0,     0.0,0.0,SpringConstStab,1.0,force,torque);\n\n        vec3 fwd=transformVecByQuat(vec3(0,1,0),p.quat);\n        vec3 up=transformVecByQuat(vec3(0,0,1),p.quat);\n\n        // obj-obj collision forces\n        for(int i=0;i<MaxParticleNum;i++)\n        {\n            if (i!=pidx)\n            {\n                Particle p2 = readParticle(i);\n                calcObjForceAndMom(p,p2,force,torque);\n            }\n        }\n\n        // clamp velocity\n        float velLen = length(p.vel.xyz);\n        if(velLen>120.1) p.vel.xyz*=120.1/velLen;\n        /*float angVelLen = length(p.angVel.xyz);\n        if(angVelLen>3.1) p.angVel.xyz*=3.1/velLen;*/\n\n        // time integration\n        // ...positional\n        vec3 acc = force/Mass;\n        p.vel.xyz += acc*0.5*DT;\n        p.pos.xyz += p.vel.xyz*DT;\n        p.vel.xyz += acc*0.5*DT;\n        // ...angular\n        vec3 angAcc = Iinv*transformVecByQuat(torque,inverseQuat(p.quat));\n        p.angVel.xyz += angAcc*0.5*DT;\n        p.quat = rotateQuatbyAngle(p.quat,-p.angVel.xyz*DT);\n        p.angVel.xyz += angAcc*0.5*DT;\n\n        writeParticle(pidx,p,fragColor,fragCoord);\n    }\n\n    calcCamera(fragColor,fragCoord);\n\n    calcSteering(fragColor,fragCoord);\n\n    if(iFrame<10 || KEY_I>0.5) initAll(fragColor,fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// very much inspired by iq's \"Volcanic\", WAHa_06x36's \"Truchet Tentacles\" and Shanes \"Entangled Vines\"\n\n#define readSampler iChannel0\n#define randSampler iChannel2\n#define time iDate.w\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n//----- common ------\n\n#define MaxParticleNum 1\n#define InRes iChannel0Resolution\n\nstruct Particle {\n    vec4 pos;\n    vec4 vel;\n    vec4 angVel;\n    vec4 quat;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\n#define PixPerParticle 5\n#define ParticlesPerLine 16\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/16)+50; } // first line (y=0) reserved for other than particle-data\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-50)*16 + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.vel;\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=p.angVel;\n    if (isPixel(xc+3,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+4,yc,fragCoord)) fragColor.xyzw=vec4(p.quat.w,0,0,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.vel    = getPixel(xc+1,yc);\n    p.angVel = getPixel(xc+2,yc);\n    p.quat   = getPixel(xc+3,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+4,yc);\n    p.quat.w = p2.x;\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\nvec3 readCamPos()\n{\n    return getPixel(0,0).xyz;\n}\n\nvec4 readCamQuat()\n{\n    vec4 q;\n    q   = getPixel(1,0);\n    q.w = getPixel(2,0).x;\n    return q;\n}\n\nvec3 readCamNav()\n{\n    return getPixel(3,0).xyz;\n}\n\nvoid writeCamPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(0,0,fragCoord)) fragColor.xyz=pos;\n}\n\nvoid writeCamQuat(vec4 quat, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(1,0,fragCoord)) fragColor.xyzw=quat;\n    if (isPixel(2,0,fragCoord)) fragColor.x=quat.w;\n}\n\nvoid writeCamNav(vec3 nav, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(3,0,fragCoord)) fragColor.xyz=nav;\n}\n\nfloat readSteeringAngle()\n{\n    return getPixel(4,0).x;\n}\n\nvoid writeSteeringAngle(float st, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(4,0,fragCoord)) fragColor.x=st;\n}\n\nfloat readGas()\n{\n    return getPixel(4,0).y;\n}\n\nvoid writeGas(float gas, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(4,0,fragCoord)) fragColor.y=gas;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos)\n{\n    float speed=0.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(60.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    eye = readCamPos();\n    vec4 cq = readCamQuat();\n    right = transformVecByQuat(vec3(1,0,0),cq);\n    up    = transformVecByQuat(vec3(0,0,1),cq);\n    fwd   = transformVecByQuat(vec3(0,1,0),cq);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\n#define torusWorldRadius1 90.0\n#define torusWorldRadius2 30.0\n\n\n\n// ---- truchet cell funcs -----\n// derived from WAHa_06x36 - shadertoy (https://www.shadertoy.com/view/ldfGWn)\n\nfloat truchetRand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat truchetArc(vec3 pos, float radius)\n{\n    pos=fract(pos);\n    float r=length(pos.xy);\n    return length(vec2(r-0.5,pos.z-0.5))-radius;\n}\n\nfloat truchetCell(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz               ,r),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat sphere(vec3 pos, float r) { return length(pos)-r; }\n\nfloat truchetCell2(vec3 pos, float r)\n{\n    return min(min(\n        min(sphere(fract(pos)-vec3(0,0.5,0.5),r),sphere(fract(pos)-vec3(0.5,0,0.5),r)),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat truchetCell3(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz    ,r),\n        truchetArc(pos.xyz*vec3(-1,-1,1) ,r)),\n        length(fract(pos.xy)-vec2(0.5))-r\n              );\n}\n\n// i tried to put all if's from WAHa_06x36's version into\n// one modulo operation, and left away the swizzling.\n// i think all roatational/mirrored cases are covered this way.\n// yet im not completely sure...\nfloat truchetDist(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    return truchetCell(cellpos*fact,r);\n}\n\nfloat truchetDist2(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    float rnd2=truchetRand(gridpos+vec3(3.2,4.432,6.32))*3.0;\n    float rnd3=truchetRand(gridpos-vec3(3.2,4.432,6.32))*3.0;\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    if     (rnd3>2.0) cellpos = cellpos.yzx;\n    else if(rnd3>1.0) cellpos = cellpos.zxy;\n\n    if     (rnd2<1.0)\n        return truchetCell(cellpos*fact,r);\n    else if(rnd2<2.0)\n        return truchetCell2(cellpos*fact,r);\n    else if(rnd2<3.0)\n        return truchetCell3(cellpos.zxy,r);\n\n    return truchetCell(cellpos*fact,r);\n}\n\n#define randSampler iChannel2\n\nvec4 snoise(vec2 texc) { return  2.0*texture(randSampler,texc, -1000.0)-vec4(1.0); }\n\nvec4 snoise3Dv4S(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    // using iq's improved texture filtering (https://www.shadertoy.com/view/XsfGDn)\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = ((p.xy+vec2(17.0,7.0)*p.z) + 0.5 + f.xy)/256.0;\n    vec4 v1 = texture( randSampler, uv, -1000.0);\n    vec4 v2 = texture( randSampler, uv+vec2(17.0,7.0)/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\n// this is a somewhat modified version of iq's noise in \"volcanic\"\nvec4 snoise3Dv4(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    //f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = texture( randSampler, uv/256.0, -1000.0);\n    vec4 v2 = texture( randSampler, (uv+vec2(17,7))/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\nfloat snoise3D(vec3 texc)\n{\n    return snoise3Dv4(texc).x;\n}\n\nfloat snoise3DS(vec3 texc)\n{\n    return snoise3Dv4S(texc).x;\n}\n\nfloat mScaleNoise(vec3 texc)\n{\n    float d=0.0;\n    d+=snoise3DS(texc);\n    d+=snoise3DS(texc*2.553)*0.5;\n    d+=snoise3DS(texc*5.154)*0.25;\n    //d+=snoise3DS(texc*400.45)*0.009;\n    d+=snoise3DS(texc*400.45*vec3(0.1,0.1,1.0))*0.009;\n    //d+=snoise3DS(texc*900.45*vec3(0.1,1.0,0.1))*0.005;\n    //d+=snoise3DS(texc*900.45*vec3(1.0,0.1,0.1))*0.005;\n    d*=0.5;\n    return d;\n}\n\nfloat getDistanceWorldS(vec3 pos)\n{\n    vec3 pos0=pos;\n\n    float dist = 100000.0;\n    dist=truchetDist(pos*0.006,0.13+0.05*cos(0.02*(pos.x+pos.y+pos.z)))/0.006;\n    float f=sin(0.01*(pos.x+pos.y+pos.z));\n    dist+=clamp(15.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0)*(0.2+0.8*f*f);\n\n    return dist;\n}\n\nvec3 getDistanceWorldSGradientSlow(vec3 pos, float delta)\n{\n    return vec3 (\n                 getDistanceWorldS( pos+delta*vec3(1,0,0) )-getDistanceWorldS( pos-delta*vec3(1,0,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,1,0) )-getDistanceWorldS( pos-delta*vec3(0,1,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,0,1) )-getDistanceWorldS( pos-delta*vec3(0,0,1) )\n                )/2.0/delta;\n}\n\nvec3 getDistanceWorldSGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistanceWorldS(pos);\n    return vec3(getDistanceWorldS(pos+eps.xyy)-d,\n                getDistanceWorldS(pos+eps.yxy)-d,\n                getDistanceWorldS(pos+eps.yyx)-d)/delta;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n\n#define Mass 2.0\n#define Iinv (mat3( 1.6,0,0, 0,3.0,0, 0,0,1.4 )/Mass)\n#define WheelRadius 0.45\n\n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec4 getDistanceObjS(vec3 pos)\n{\n    float obj=0.0;\n    float dist = 100000.0;\n    float steeringAngle=readSteeringAngle();\n    vec4 q = vec4(0,sin(steeringAngle*0.5),0,cos(steeringAngle*0.5));\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    float dist2 = dist;\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFR).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFL).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    if(dist!=dist2) obj=1.0;\n    return vec4(dist,obj,0,0);\n}\n//----- update ------\n\nvoid initAll( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0.0);\n    int pidx=PIdx(int(fragCoord.x),int(fragCoord.y));\n    if(pidx>=0)\n    {\n        Particle p;\n        p.pos.xyz = vec3(float(pidx*5)+torusWorldRadius1,0.0,torusWorldRadius2*1.1);\n        p.vel.xyz = vec3(0,0,0);\n        p.quat = vec4(0,0,0,1);\n        p.quat = normalize(vec4(0.46,0.68,0.26,0.5));\n        p.pos.xyz = vec3(101.7,2.41,84.72)+vec3(5,5,0)*float(pidx);\n        writeParticle(pidx,p,fragColor,fragCoord);\n    }\n    writeCamPos(vec3(0),fragColor,fragCoord);\n    writeCamPos(vec3(99.5,4.5,54.8),fragColor,fragCoord);\n    writeCamQuat(vec4(0,0,0,1),fragColor,fragCoord);\n    writeCamQuat(normalize(vec4(0.592,0.428,0.471,0.494)),fragColor,fragCoord);\n    writeSteeringAngle(0.2,fragColor,fragCoord);\n    writeGas(0.0,fragColor,fragCoord);\n    writeCamNav(vec3(30.0,-0.54,0.3), fragColor, fragCoord);\n}\n\n#define SpringConst 10.1\n#define SpringConstStab 5.1\n#define DT min(0.5*iTimeDelta,0.05)\n\nvoid calcWheelForceAndTorque(inout Particle p, vec3 wheelPos, float wheelRadius, float steeringAngle, float frictionCoeff, float wheelAngSpeed, float springConst, float clutch, inout vec3 force, inout vec3 torque)\n{\n    vec3 wheelPosW = p.pos.xyz+transformVecByQuat(wheelPos.xyz,p.quat);\n    float dist = getDistanceWorldS(wheelPosW);\n    if(dist<wheelRadius)\n    {\n        // forces by wheels\n        vec3 dforce = vec3(0,0,0);\n        vec3 distGrad = getDistanceWorldSGradient(wheelPosW,0.1);\n        vec3 distDir = normalize(distGrad);\n        dforce=distDir*(wheelRadius-dist)*springConst;\n        //p.vel.xyz -= distDir*dot(p.vel.xyz,distDir)*0.1;\n        force  += dforce;\n        torque += cross(dforce,wheelPosW-p.pos.xyz);\n\n        float fl = length(dforce);\n\n        // wheel-drive-forces\n        vec3 chassisRotVel = transformVecByQuat(cross(-p.angVel.xyz,wheelPos.xyz+vec3(0,0,-WheelRadius)),p.quat);\n        vec3 wheelAxe = transformVecByQuat(vec3(cos(steeringAngle),sin(-steeringAngle),0),p.quat);\n        vec3 f=normalize(cross(distDir,wheelAxe));\n        //vec3 c=wheelAngSpeed*wheelRadius*f-p.vel.xyz-chassisRotVel+dot(p.vel.xyz+chassisRotVel,distDir)*0.9*distDir;\n        ///*if(length(c)>1.0)*/ c=normalize(c);\n        //dforce = fl*frictionCoeff*c;\n\n        vec3 c=wheelAngSpeed*wheelRadius*f-p.vel.xyz-chassisRotVel;\n        // in f dir\n        dforce += fl*frictionCoeff*clutch*sign(dot(c,f))*f;\n        // in wheelaxe dir\n        dforce += fl*frictionCoeff*sign(dot(c,wheelAxe))*wheelAxe;\n        // in up dir\n        dforce += fl*sign(dot(c,distDir))*distDir*0.7;\n\n        force  += dforce;\n        torque += cross(dforce,wheelPosW+transformVecByQuat(vec3(0,0,-WheelRadius),p.quat)-p.pos.xyz);\n    }\n\n}\n\nvoid calcObjForceAndMom(Particle p, Particle p2, inout vec3 force, inout vec3 torque)\n{\n    vec3 collpos1;\n    vec3 collpos2;\n    vec3 dforce=vec3(0);\n    vec3 d;\n    vec3 dn;\n\n    for(int k=0;k<4;k++)\n    {\n        //collpos1 = p.pos.xyz  + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k&1),p.quat);\n        //collpos2 = p2.pos.xyz + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k&2)*0.5,p2.quat);\n        collpos1 = p.pos.xyz  + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*mod(float(k),2.0),    p.quat);\n        collpos2 = p2.pos.xyz + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*mod(float(k),4.0)*0.5,p2.quat);\n\n        d = collpos1 - collpos2;\n        dn = p2.pos.xyz-p.pos.xyz;\n        if( length(d)<2.0 ) dforce=100.1*d/(length(d)+0.1);\n        force+=dforce;\n        torque+=1.0*cross(dforce,0.5*(collpos1+collpos2)-p.pos.xyz);\n    }\n    //TODO: friction force+torque\n    //torque+=0.3*cross(cross(dforce,normalize(dn)),0.5*(collpos1+collpos2)-pos);\n}\n\n#define GRAVITY -4.0\nvec3 getGravityWorld(vec3 pos)\n{\n    return GRAVITY*normalize(getDistanceWorldSGradientSlow(pos, 5.0)+getDistanceWorldSGradientSlow(pos, 10.0));\n}\n\n#define keyTex iChannel1\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_A texture(keyTex,vec2(( 97.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_D texture(keyTex,vec2((100.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_W texture(keyTex,vec2((119.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_X texture(keyTex,vec2((120.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_Q texture(keyTex,vec2((113.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_R texture(keyTex,vec2((114.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_S texture(keyTex,vec2((115.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_E texture(keyTex,vec2((101.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_F texture(keyTex,vec2((102.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_LEFT  texture(keyTex,vec2(37.5/256.0,(0.5+0.0)/3.0)).x\n#define KEY_UP    texture(keyTex,vec2(38.5/256.0,(0.5+0.0)/3.0)).x\n#define KEY_RIGHT texture(keyTex,vec2(39.5/256.0,(0.5+0.0)/3.0)).x\n#define KEY_DOWN  texture(keyTex,vec2(40.5/256.0,(0.5+0.0)/3.0)).x\n\nvoid calcCamera( inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos  = readCamPos();\n    vec4 camQuat = readCamQuat();\n    vec3 camDistRzRx = readCamNav();\n    float camDistScalar = camDistRzRx.x;\n    float camRotZ = camDistRzRx.y;\n    float camRotX = camDistRzRx.z;\n\n    float sDist=getDistanceWorldS(camPos);\n    if(sDist<0.2) camDistScalar-=0.2;\n    if(KEY_R>0.5) camDistScalar-=0.3;\n    if(KEY_F>0.5) camDistScalar+=0.3;\n    if(camDistScalar<3.5) camDistScalar=3.5;\n\n    if(KEY_E>0.5) camRotZ-=0.01;\n    if(KEY_Q>0.5) camRotZ+=0.01;\n\n    Particle p = readParticle(0);\n    vec3 camDist = vec3(-sin(camRotZ)*cos(camRotX),-cos(camRotZ)*cos(camRotX),sin(camRotX))*camDistScalar;\n\n    vec3 newCamPos  = p.pos.xyz+transformVecByQuat(camDist,p.quat);\n    float ang;\n    vec4 newCamQuat = p.quat;\n    newCamQuat = multQuat(newCamQuat,vec4(normalize(vec2(camDist.yx*vec2(1,-1)))*sin(camRotX*0.5),0,cos(camRotX*0.5)));\n    newCamQuat = multQuat(newCamQuat,vec4(0,0,sin(-camRotZ*0.5),cos(-camRotZ*0.5)));\n\n    camPos  = mix( camPos,  newCamPos,  0.02 );\n\n    camQuat = normalize(mix( camQuat, newCamQuat, 0.08 ));\n\n    camDistRzRx.x=camDistScalar;\n    camDistRzRx.y=camRotZ;\n    camDistRzRx.z=camRotX;\n    writeCamNav(camDistRzRx, fragColor, fragCoord);\n    writeCamQuat(camQuat, fragColor, fragCoord);\n    writeCamPos(camPos,   fragColor, fragCoord);\n}\n\n\nvoid calcSteering( inout vec4 fragColor, in vec2 fragCoord )\n{\n    float steeringAngle = readSteeringAngle();\n    float gas = readGas();\n\n    if     (KEY_A>0.5 || KEY_LEFT >0.5) steeringAngle-=0.02;\n    else if(KEY_D>0.5 || KEY_RIGHT>0.5) steeringAngle+=0.02;\n    else steeringAngle*=0.9;\n\n    if     (KEY_W>0.5 || KEY_UP  >0.5) gas+=0.01;\n    else if(KEY_S>0.5 || KEY_DOWN>0.5) gas-=0.01;\n    else gas*=0.9;\n\n    gas=clamp(gas,-1.0,1.0);\n    steeringAngle=clamp(steeringAngle,-0.5,0.5);\n\n    writeSteeringAngle(steeringAngle,   fragColor, fragCoord);\n    writeGas(gas, fragColor, fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // copy old content\n    fragColor = getPixel(int(fragCoord.x),int(fragCoord.y));\n\n    int pidx=PIdx(int(fragCoord.x),int(fragCoord.y));\n    if(pidx>=0 && pidx<MaxParticleNum)\n    {\n        vec3 force = vec3(0,0,0);\n        vec3 torque = vec3(0,0,0);\n\n        Particle p = readParticle(pidx);\n\n        // gravity\n        force+=getGravityWorld(p.pos.xyz)*Mass;\n\n        // velocity damping\n        force+=-0.2*p.vel.xyz;\n        torque+=-0.2*transformVecByQuat(p.angVel.xyz,p.quat);\n\n        float steeringAngle = readSteeringAngle();\n        float gas = readGas();\n        float clutch = clamp(abs(gas),0.0,1.0);\n        float rotSpeed = gas*50.0;\n        if(KEY_X>0.5) { clutch=1.0; gas=0.0; }\n        // wheel forces\n        calcWheelForceAndTorque(p,WheelFL,WheelRadius,steeringAngle,1.7,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelFR,WheelRadius,steeringAngle,1.7,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelBL,WheelRadius,     0.0,     1.7,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelBR,WheelRadius,     0.0,     1.7,rotSpeed,SpringConst,clutch,force,torque);\n        // stabilizers\n        calcWheelForceAndTorque(p,vec3(0,0,1.6),1.8,     0.0,     0.0,0.0,SpringConstStab,1.0,force,torque);\n\n        vec3 fwd=transformVecByQuat(vec3(0,1,0),p.quat);\n        vec3 up=transformVecByQuat(vec3(0,0,1),p.quat);\n\n        // obj-obj collision forces\n        for(int i=0;i<MaxParticleNum;i++)\n        {\n            if (i!=pidx)\n            {\n                Particle p2 = readParticle(i);\n                calcObjForceAndMom(p,p2,force,torque);\n            }\n        }\n\n        // clamp velocity\n        float velLen = length(p.vel.xyz);\n        if(velLen>120.1) p.vel.xyz*=120.1/velLen;\n        /*float angVelLen = length(p.angVel.xyz);\n        if(angVelLen>3.1) p.angVel.xyz*=3.1/velLen;*/\n\n        // time integration\n        // ...positional\n        vec3 acc = force/Mass;\n        p.vel.xyz += acc*0.5*DT;\n        p.pos.xyz += p.vel.xyz*DT;\n        p.vel.xyz += acc*0.5*DT;\n        // ...angular\n        vec3 angAcc = Iinv*transformVecByQuat(torque,inverseQuat(p.quat));\n        p.angVel.xyz += angAcc*0.5*DT;\n        p.quat = rotateQuatbyAngle(p.quat,-p.angVel.xyz*DT);\n        p.angVel.xyz += angAcc*0.5*DT;\n\n        writeParticle(pidx,p,fragColor,fragCoord);\n    }\n\n    calcCamera(fragColor,fragCoord);\n\n    calcSteering(fragColor,fragCoord);\n\n    if(iFrame<10 || KEY_I>0.5) initAll(fragColor,fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// very much inspired by iq's \"Volcanic\", WAHa_06x36's \"Truchet Tentacles\" and Shanes \"Entangled Vines\"\n\n#define readSampler iChannel0\n#define randSampler iChannel2\n#define time iDate.w\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n//----- common ------\n\n#define MaxParticleNum 1\n#define InRes iChannel0Resolution\n\nstruct Particle {\n    vec4 pos;\n    vec4 vel;\n    vec4 angVel;\n    vec4 quat;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\n#define PixPerParticle 5\n#define ParticlesPerLine 16\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/16)+50; } // first line (y=0) reserved for other than particle-data\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-50)*16 + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.vel;\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=p.angVel;\n    if (isPixel(xc+3,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+4,yc,fragCoord)) fragColor.xyzw=vec4(p.quat.w,0,0,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.vel    = getPixel(xc+1,yc);\n    p.angVel = getPixel(xc+2,yc);\n    p.quat   = getPixel(xc+3,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+4,yc);\n    p.quat.w = p2.x;\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\nvec3 readCamPos()\n{\n    return getPixel(0,0).xyz;\n}\n\nvec4 readCamQuat()\n{\n    vec4 q;\n    q   = getPixel(1,0);\n    q.w = getPixel(2,0).x;\n    return q;\n}\n\nvec3 readCamNav()\n{\n    return getPixel(3,0).xyz;\n}\n\nvoid writeCamPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(0,0,fragCoord)) fragColor.xyz=pos;\n}\n\nvoid writeCamQuat(vec4 quat, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(1,0,fragCoord)) fragColor.xyzw=quat;\n    if (isPixel(2,0,fragCoord)) fragColor.x=quat.w;\n}\n\nvoid writeCamNav(vec3 nav, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(3,0,fragCoord)) fragColor.xyz=nav;\n}\n\nfloat readSteeringAngle()\n{\n    return getPixel(4,0).x;\n}\n\nvoid writeSteeringAngle(float st, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(4,0,fragCoord)) fragColor.x=st;\n}\n\nfloat readGas()\n{\n    return getPixel(4,0).y;\n}\n\nvoid writeGas(float gas, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(4,0,fragCoord)) fragColor.y=gas;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos)\n{\n    float speed=0.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(60.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    eye = readCamPos();\n    vec4 cq = readCamQuat();\n    right = transformVecByQuat(vec3(1,0,0),cq);\n    up    = transformVecByQuat(vec3(0,0,1),cq);\n    fwd   = transformVecByQuat(vec3(0,1,0),cq);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\n#define torusWorldRadius1 90.0\n#define torusWorldRadius2 30.0\n\n\n\n// ---- truchet cell funcs -----\n// derived from WAHa_06x36 - shadertoy (https://www.shadertoy.com/view/ldfGWn)\n\nfloat truchetRand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat truchetArc(vec3 pos, float radius)\n{\n    pos=fract(pos);\n    float r=length(pos.xy);\n    return length(vec2(r-0.5,pos.z-0.5))-radius;\n}\n\nfloat truchetCell(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz               ,r),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat sphere(vec3 pos, float r) { return length(pos)-r; }\n\nfloat truchetCell2(vec3 pos, float r)\n{\n    return min(min(\n        min(sphere(fract(pos)-vec3(0,0.5,0.5),r),sphere(fract(pos)-vec3(0.5,0,0.5),r)),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat truchetCell3(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz    ,r),\n        truchetArc(pos.xyz*vec3(-1,-1,1) ,r)),\n        length(fract(pos.xy)-vec2(0.5))-r\n              );\n}\n\n// i tried to put all if's from WAHa_06x36's version into\n// one modulo operation, and left away the swizzling.\n// i think all roatational/mirrored cases are covered this way.\n// yet im not completely sure...\nfloat truchetDist(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    return truchetCell(cellpos*fact,r);\n}\n\nfloat truchetDist2(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    float rnd2=truchetRand(gridpos+vec3(3.2,4.432,6.32))*3.0;\n    float rnd3=truchetRand(gridpos-vec3(3.2,4.432,6.32))*3.0;\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    if     (rnd3>2.0) cellpos = cellpos.yzx;\n    else if(rnd3>1.0) cellpos = cellpos.zxy;\n\n    if     (rnd2<1.0)\n        return truchetCell(cellpos*fact,r);\n    else if(rnd2<2.0)\n        return truchetCell2(cellpos*fact,r);\n    else if(rnd2<3.0)\n        return truchetCell3(cellpos.zxy,r);\n\n    return truchetCell(cellpos*fact,r);\n}\n\n#define randSampler iChannel2\n\nvec4 snoise(vec2 texc) { return  2.0*texture(randSampler,texc, -1000.0)-vec4(1.0); }\n\nvec4 snoise3Dv4S(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    // using iq's improved texture filtering (https://www.shadertoy.com/view/XsfGDn)\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = ((p.xy+vec2(17.0,7.0)*p.z) + 0.5 + f.xy)/256.0;\n    vec4 v1 = texture( randSampler, uv, -1000.0);\n    vec4 v2 = texture( randSampler, uv+vec2(17.0,7.0)/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\n// this is a somewhat modified version of iq's noise in \"volcanic\"\nvec4 snoise3Dv4(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    //f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = texture( randSampler, uv/256.0, -1000.0);\n    vec4 v2 = texture( randSampler, (uv+vec2(17,7))/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\nfloat snoise3D(vec3 texc)\n{\n    return snoise3Dv4(texc).x;\n}\n\nfloat snoise3DS(vec3 texc)\n{\n    return snoise3Dv4S(texc).x;\n}\n\nfloat mScaleNoise(vec3 texc)\n{\n    float d=0.0;\n    d+=snoise3DS(texc);\n    d+=snoise3DS(texc*2.553)*0.5;\n    d+=snoise3DS(texc*5.154)*0.25;\n    //d+=snoise3DS(texc*400.45)*0.009;\n    d+=snoise3DS(texc*400.45*vec3(0.1,0.1,1.0))*0.009;\n    //d+=snoise3DS(texc*900.45*vec3(0.1,1.0,0.1))*0.005;\n    //d+=snoise3DS(texc*900.45*vec3(1.0,0.1,0.1))*0.005;\n    d*=0.5;\n    return d;\n}\n\nfloat getDistanceWorldS(vec3 pos)\n{\n    vec3 pos0=pos;\n\n    float dist = 100000.0;\n    dist=truchetDist(pos*0.006,0.13+0.05*cos(0.02*(pos.x+pos.y+pos.z)))/0.006;\n    float f=sin(0.01*(pos.x+pos.y+pos.z));\n    dist+=clamp(15.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0)*(0.2+0.8*f*f);\n\n    return dist;\n}\n\nvec3 getDistanceWorldSGradientSlow(vec3 pos, float delta)\n{\n    return vec3 (\n                 getDistanceWorldS( pos+delta*vec3(1,0,0) )-getDistanceWorldS( pos-delta*vec3(1,0,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,1,0) )-getDistanceWorldS( pos-delta*vec3(0,1,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,0,1) )-getDistanceWorldS( pos-delta*vec3(0,0,1) )\n                )/2.0/delta;\n}\n\nvec3 getDistanceWorldSGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistanceWorldS(pos);\n    return vec3(getDistanceWorldS(pos+eps.xyy)-d,\n                getDistanceWorldS(pos+eps.yxy)-d,\n                getDistanceWorldS(pos+eps.yyx)-d)/delta;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n\n#define Mass 2.0\n#define Iinv (mat3( 1.6,0,0, 0,3.0,0, 0,0,1.4 )/Mass)\n#define WheelRadius 0.45\n\n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec4 getDistanceObjS(vec3 pos)\n{\n    float obj=0.0;\n    float dist = 100000.0;\n    float steeringAngle=readSteeringAngle();\n    vec4 q = vec4(0,sin(steeringAngle*0.5),0,cos(steeringAngle*0.5));\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    float dist2 = dist;\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFR).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFL).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    if(dist!=dist2) obj=1.0;\n    return vec4(dist,obj,0,0);\n}\n//----- render ------\n\n#define randSampler iChannel2\n\nvec4 getDistanceExt(vec3 pos)\n{\n    float dist=1000000.0;\n    float oldDist=1000000.0;\n    float obj=0.0;\n    dist=min(dist,getDistanceWorldS(pos));\n\n    for(int i=0;i<MaxParticleNum;i++)\n    {\n        Particle p = readParticle(i);\n        oldDist=dist;\n        vec4 ov = getDistanceObjS(transformVecByQuat(pos-p.pos.xyz,inverseQuat(p.quat)));\n        dist=min(dist,ov.x);\n        if(dist!=oldDist) obj=float(i)+1.0+ov.y*0.1;\n    }\n\n    return vec4(dist,obj,0,0);\n}\n\nfloat getDistance(vec3 pos)\n{\n    return getDistanceExt(pos).x;\n}\n\nvec3 getDistanceGradientSlow(vec3 pos, float delta)\n{\n    vec3 eps=vec3(delta,0,0);\n    return vec3 (\n                 getDistance( pos+eps.xyy )-getDistance( pos-eps.xyy ),\n                 getDistance( pos+eps.yxy )-getDistance( pos-eps.yxy ),\n                 getDistance( pos+eps.yyx )-getDistance( pos-eps.yyx )\n                );\n}\n\nvec3 getDistanceGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistance(pos);\n    return vec3(getDistance(pos+eps.xyy)-d, getDistance(pos+eps.yxy)-d, getDistance(pos+eps.yyx)-d)/delta;\n}\n\n\n// Ambient occlusion approximation.\n// Based upon boxplorer's implementation which is derived from:\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n#define AoIterationsMax 4\nfloat ambientOcclusion(vec3 p, vec3 n, float eps, float aoSpread, float aoIntensity, int aoIterations)\n{\n    float o = 1.0;                  // Start at full output colour intensity\n    eps *= aoSpread;                // Spread diffuses the effect\n    float k = aoIntensity / eps;    // Set intensity factor\n    float d = 2.0 * eps;            // Start ray a little off the surface\n    \n    for (int i = 0; i < AoIterationsMax; ++i) {\n        o -= (d - getDistance(p + n * d)) * k;\n        d += eps;\n        k *= 0.5;                   // AO contribution drops as we move further from the surface\n        if(i > aoIterations) break;\n    }\n    \n    return clamp(o, 0.0, 1.0);\n}\n\n#define RaytraceMaxStepNum 200\n#define glowColor vec3(0.1,0.3,0.4)\n#define ambientColor (vec3(0.35,0.55,0.65)*0.7)\n#define diffuseColor vec3(0.8,0.95,1.0)\n\nfloat gauss(float x) { return exp(-x*x); }\n\nvec4 shadeCar(vec3 pos, float glow, float dist, vec3 dir, float obj)\n{\n    vec4 col=vec4(1.0);\n    vec3 normal=normalize(getDistanceGradient(pos,0.001));\n    float ao = 1.0;\n    ao *= ambientOcclusion(pos, normal, 0.03,\n                           8.0,    //spread,\n                           0.1, //intensity,\n                           4     //iterations\n                          );\n    col *= ao;\n    //col *= vec4(normal.xyz*0.5+vec3(0.5),1);\n    vec3 lightDir = normalize(vec3(-16.0, 100.0, -60.0));\n    float diff = clamp(dot(vec3(0,0,1),normal),0.0,1.0);\n    diff*=1.2;\n    //diff*=diff;\n    vec3 diffuseColorL = vec3(1,1,1);\n    //if(obj>=1.0) diffuseColorL =vec3(0.5); // tire\n\n    vec3  eye=-dir;\n    float spec = dot(-eye+2.0*normal*dot(normal,eye),vec3(0,0,1));\n    float shin1 = 0.6;\n    float shin2 = 0.05;\n    float shTot = 1.0;\n    //if(obj>=1.0) { shin1 = 0.8; shin2 = 0.4; shTot=0.3; }\n    vec3 specv = shTot*(0.9*gauss((spec+0.4)/shin1)*vec3(ambientColor) + 0.7*gauss((spec-0.95)/shin2)*vec3(1));\n\n    col.xyz *= mix(ambientColor*diffuseColorL,diffuseColorL,diff);\n    col.xyz += vec3(specv);\n\n    return col;\n}\n\nvec4 shadeTerrain(vec3 pos, float glow, float dist, vec3 dir)\n{\n    vec4 col=vec4(1);\n    vec3 normal=normalize(getDistanceGradient(pos,0.2123));\n\n    float ao = 1.0;\n    ao *= ambientOcclusion(pos, normal, 0.03,\n                           8.0,    //spread,\n                           0.1, //intensity,\n                           4     //iterations\n                          );\n    ao *= ambientOcclusion(pos, normal, 2.5,\n                           8.0,    //spread,\n                           0.07, //intensity,\n                           4     //iterations\n                          );\n    //ao*=ao;\n\n    vec3 lightDir = normalize(vec3(-16.0, 100.0, -60.0));\n    float diff = clamp(dot(vec3(0,0,1),normal),0.0,1.0);\n    diff=1.2*pow(diff,1.0);\n    vec3 eye=-dir;\n    vec3 rnormal = normalize(snoise3Dv4(pos*0.1).xyz);\n    float spec1 = dot(-eye+2.0*rnormal*dot(rnormal,eye),vec3(0,0,1));\n    float spec2 = dot(-eye+2.0*normal*dot(normal,eye),vec3(0,0,1));\n    float spec=2.0*gauss((spec1-0.8)/0.01)*diff+0.7*gauss((spec2-0.99)/0.2)*(1.0-dot(eye,normal));\n\n    col.xyz *= mix(diffuseColor, ambientColor, 1.0-diff);\n    col.xyz *= mix(vec3(ao),vec3(1,1,1),vec3(0.1,0.4,0.6));\n    col.xyz += 0.7*spec*vec3(1,1,1);\n    col.xyz += glowColor*glow;\n    return col;\n}\n\nvec4 raytraceDistfield(vec3 pos0, vec3 dir, float maxDist)\n{\n    vec3 colbg = mix(vec3(0.35,0.6,0.65)*0.5,1.2*vec3(0.8,0.95,1.0),dir.z*0.5+0.5);\n    vec4 col = vec4(1,1,1,1);\n\n    vec3 rpos = pos0;\n    vec3 rpos0 = rpos;\n\n    float dist=0.0;\n    float ddist=100.0;\n    int cnt=0;\n    float eps=0.0001; // m\n    vec4 dv;\n    for( int i=0 ; i<RaytraceMaxStepNum ; i++ )\n    {\n        cnt=i;\n        if(ddist<eps) break;\n        dv=getDistanceExt(rpos.xyz+dir*dist);\n        ddist=dv.x;\n        dist+=ddist*0.8;\n        if(dist>maxDist) break;\n    }\n\n\n    float ddistsurf=ddist;\n    float distsurf=dist;\n\n    if(ddistsurf<=eps) {\n        if(dv.y>=1.0)\n            col=shadeCar(rpos.xyz+dir*distsurf,float(cnt)/100.0,dist,dir,fract(dv.y)*10.0);\n        else\n            col=shadeTerrain(rpos.xyz+dir*distsurf,float(cnt)/100.0,dist,dir);\n    }\n    else\n    {\n        col.w = 0.0;\n        col.xyz=colbg.xyz;\n    }\n\n    if(cnt>=RaytraceMaxStepNum-2) col=vec4(0.8,0.95,1.0,1.0);\n\n    float fog = 1.0-exp(-dist/maxDist*3.0);\n    col.xyz = mix(col.xyz,colbg,fog);\n\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect=iResolution.y/iResolution.x;\n    vec2 spos = fragCoord.xy/iResolution.xy*2.0-vec2(1.0);\n    vec3 right, fwd, up, pos, dir;\n    getEyeCoords(right,fwd,up,pos,dir,aspect,spos);\n    fragColor = raytraceDistfield(pos,dir,1000.0);\n    Particle p = readParticle(0);\n    //drawFloat(length(p.vel.xyz)*3.6,2,vec2(10,10),2.0,fragColor,fragCoord);\n    //drawFloat(readGas(),2,vec2(10,45),2.0,fragColor,fragCoord);\n    //drawFloat(readSteeringAngle(),2,vec2(10,30),2.0,fragColor,fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}