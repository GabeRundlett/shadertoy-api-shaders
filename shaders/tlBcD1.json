{
    "Shader": {
        "info": {
            "date": "1594232170",
            "description": "Native attempt to implement opArt algo. (Based on book Graphisme Scientifique sur Micro-Ordinateur, R.Dony )\nStarted with simple implementation, then went crazy with simple glsl trick :p\n\nStill using some coordinate, wondering if it's possible to avoid it",
            "flags": 0,
            "hasliked": 0,
            "id": "tlBcD1",
            "likes": 16,
            "name": " 大龙猫 - OpArt #1",
            "published": 3,
            "tags": [
                "opart"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 560
        },
        "renderpass": [
            {
                "code": "#define PI  3.1415\n#define TAU 2.0*PI\n#define zero vec2(0.,0.)\n\n#define K .05\n#define RECUR 45.\n#define BASE_SIZE 1.0\nfloat det(vec2 a,vec2 b) {\n    return (a.x * b.y) - (a.t * b.x);\n}\nvec2 intersect(vec2 a, vec2 b,vec2 p,vec2 q) {\n       vec2 xdiff = vec2(a.x-b.x,p.x-q.x);\n       vec2 ydiff = vec2(a.y-b.y,p.y-q.y);\n      \n       float div = det(xdiff,ydiff);\n       \n       vec2 d = vec2(det(a,b),det(p,q));\n       return vec2(det(d,xdiff),det(d,ydiff))/div ;\n       \n    }\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nvec2 coord(float a,float r) {\n    return vec2(cos(a),sin(a))*r;\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv =( fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    uv*=2.;\n    uv +=vec2(cos(iTime),sin(iTime))*.1;\n    uv*=r(3.*sin(atan(uv.x,uv.y)*.45));\n    vec2 id = floor(uv);\n    uv=fract(uv)-.5;\n    float d = 0.;\n    vec3 col = vec3(0.);\n    float q = 6.+cos(floor(iTime)+pow(fract(iTime),2.))*2.;\n    float stepT = TAU/q;\n   \n   float D =1./20.;\n   \n   float loop_start;\n   float loop_end;\n   float stp;\n   if(mod(id.x,2.)==0.){\n      uv.x = -uv.x;\n      \n   } \n   if(mod(id.y,2.) == 0.){\n   uv.y = -uv.y;\n   }\n  \n   for(float j=0.;j<1.;j+=1./RECUR){\n        for(float i=0.;i<=TAU;i+=stepT) {\n         d += smoothstep(0.018,0.003,\n         sdSegment(uv,coord(i,BASE_SIZE), coord(i+stepT,BASE_SIZE)  ));\n      }\n      vec2 ipoint = intersect(zero,coord(0.+K,BASE_SIZE),coord(stepT,BASE_SIZE),coord(0.,BASE_SIZE));\n      float dst = length(ipoint);\n      uv*=1./dst;\n     uv *=r(K) ;\n    col += d*(palette(j + mod(iTime*.2,2.),vec3(.5),vec3(.5),vec3(1.),vec3(0.50, 0.10, 0.33))/RECUR);\n     \n    }\n     //col = mix(vec3(.1),vec3(.2,.3,.5),col);\n    //vec3 col = vec3(d);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}