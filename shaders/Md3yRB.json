{
    "Shader": {
        "info": {
            "date": "1519956349",
            "description": "Everything on the left-hand side is clickable. Arrows above/below digits set triangle corner angles. You can drag the red dot on the sphere. Space toggles GUI. Have fun! ",
            "flags": 48,
            "hasliked": 0,
            "id": "Md3yRB",
            "likes": 337,
            "name": "Wythoff explorer",
            "published": 3,
            "tags": [
                "tiling",
                "spherical",
                "symmetry",
                "polyhedron",
                "wythoff",
                "buckyball"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 15211
        },
        "renderpass": [
            {
                "code": "/* Wythoff explorer, by mattz\n   License https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n   This is an update to my \"Wythoff construction\" shader:\n   https://www.shadertoy.com/view/ldXczX \n\n   I've learned a bit since I wrote that, and was able to add\n   a few new features I couldn't figure out last time:\n\n     - lots more distance functions besides sphere and\n       polyhedron! faceted or ball-and-stick nets, and\n       also polyhedron dilated by sphere \n\n     - user-modifiable polyhedron vertex within triangle\n\n     - lots of cool blending effects\n\n   As usual, I'm indebted to other users on shadertoy for \n   helpful/inspiring examples, especially:\n \n     - Polyhedron again (knighty)\n       https://www.shadertoy.com/view/XlX3zB\n\n     - 2D Folding (gaz)\n       https://www.shadertoy.com/view/4tX3DS\n\n   These links were helpful when creating this shader:\n\n     - https://en.wikipedia.org/wiki/Wythoff_construction\n     - http://www.gregegan.net/APPLETS/26/WythoffNotes.html\n     - https://en.wikipedia.org/wiki/List_of_uniform_polyhedra\n\n   If you want to browse the code: this main buffer only does AA \n   and GUI rendering. Buffer A handles mouse interaction and \n   global state updates, and Buffer B handles distance marching \n   and shading the actual polyhedron.\n\n   I'm pretty sure this is the largest shader I've posted on\n   Shadertoy -- apologies for the long compile times!\n\n*/\n\n//#define DEBUG_HITBOXES\n#define ENABLE_EDGE_AA\n\n//////////////////////////////////////////////////////////////////////\n// point-line distance\n\nfloat dline(vec2 p, vec2 a, vec2 b) {\n    \n    vec2 ba = b-a;\n    vec2 n = normalize(vec2(-ba.y, ba.x));\n    \n    return dot(p, n) - dot(a, n);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// point-line and point-segment distance\n\nvec2 dline_seg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 ba = b-a;\n    vec2 n = normalize(vec2(-ba.y, ba.x));\n\n    vec2 pa = p-a;\n    \n    float u = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    \n    return vec2(dot(a, n) - dot(p, n), length(p-mix(a,b,u)));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to character in SDF font texture\n\nfloat font2d_dist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n      \n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+offset+0.5)*(1.0/16.0);\n    \n    float k = texture(iChannel2, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv)-0.5;\n        \n    return max(k-127.0/255.0, max(box.x, box.y))/scl;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to triangle for spin box\n\nfloat spin_icon_dist(vec2 pos, float size, bool flip, bool dim) {\n    \n    if (flip) { pos.y = -pos.y; }  \n    pos.x = abs(pos.x);\n    \n    vec2 p0 = vec2(0, -0.7)*text_size;\n    vec2 p1 = vec2(0.35, -0.7)*text_size;\n    vec2 p2 = vec2(0.0, -1.1)*text_size;\n    \n    float d = max(dline(pos, p0, p1), dline(pos, p1, p2));\n    \n    if (dim) { \n        d = abs(d + 0.02*text_size) - 0.02*text_size;\n    }\n    \n    return d;\n       \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to icon for distance function\n\nfloat dfunc_icon_dist(vec2 p, float sz, int style) {\n    \n    if (style == 0) {\n        \n        return length(p) - sz;\n        \n    } else if (style == 5 || style == 6) {\n\n\t\tp.y = abs(p.y);\n        \n        vec2 vp = p*vec2(1, 0.9);\n        float d = abs(length((vp - vec2(0, 0.6*sz))) - 0.5*sz) - 0.06*sz;\n        \n        float q = length(p - vec2(0, min(p.y, 0.4*sz)))-0.06*sz;\n        float r = box_dist(p, vec4(0, 0, 0.35, 0.7)*sz);\n                    \n        if (style == 6) {\n        \n            q = min(q, box_dist(p, vec4(0, 2.0, 0.06, 0.46)*sz));\n            q = min(q, box_dist(p, vec4(-0.5, 2.4, 0.56, 0.06)*sz));\n            \n        }\n                \n        return min(q, max(d, -r));\n        \n    }\n    \n    p += vec2(0, 0.15*sz);\n    \n    sz *= 0.9;\n    \n    const float k = 0.8660254037844387;\n    \n    p.x = abs(p.x);\n    \n    vec2 m0 = vec2(0, sz);\n    vec2 m1 = vec2(k*sz, -0.5*sz);\n    vec2 m2 = vec2(0, -0.5*sz);\n    \n    vec2 d_ls = min(dline_seg(p, m0, m1),\n                    dline_seg(p, m1, m2));\n    \n    float d_point = min(length(p - m0), length(p - m1));\n    \n    if (style == 1) {\n        return -d_ls.x - 0.5;\n    } else if (style == 2) {\n        return min(d_point - 0.25*sz, abs(d_ls.y)-0.08*sz);\n    } else if (style == 3) {\n        return abs(d_ls.x)-0.15*sz;\n    } else {\n        return min(min(d_ls.y, d_point) - 0.35*sz, -d_ls.x);    \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to icon for decorations\n\nfloat decor_icon_dist(vec2 p, float sz, int style) {\n    \n    float s = sign(p.x*p.y);\n    \n    p = abs(p);\n    \n    vec2 a = vec2(0, sz);\n    vec2 b = vec2(sz, 0);\n    \n    float l = dline(p, a, b);\n    float c = length( p - (p.x > p.y ? b : a)*0.8 );\n    \n    if (style == 0) {\n        return c - 0.2*sz;\n    } else if (style == 1) {\n        return abs(l + 0.04*sz) - 0.08*sz;\n    } else if (style == 2) {\n        return min(abs(l), max(min(p.x, p.y), l)) - 0.03*sz;\n    } else {\n        return min(max(min(s*p.x, s*p.y), l), abs(l)-0.03*sz);\n        \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// draw color icon (RGB or facet-shaded selectors)\n\nvoid draw_color_icon(vec2 p, float sz, int i, bool enable, inout vec3 color) {\n    \n    const float k = 0.8660254037844387;\n    \n    mat2 R = mat2(-0.5, k, -k, -0.5);\n    \n    vec2 p1 = vec2(k*sz, 0);\n    vec2 p2 = vec2(0, 0.5*sz);\n    \n    mat3 colors;\n    \n    if (i == 0) {\n        colors = mat3(vec3(1, 0, 0),\n                      vec3(1, 1, 0),\n                      vec3(0, 0, 1));\n    } else {\n        colors = mat3(vec3(0.6, 0, 0.6),\n                      vec3(0.7, 0.4, 0.7),\n                      vec3(0.1, 0.5, 0.5));\n    }\n    \n    float ue = enable ? 1. : 0.3;\n    float ds = 1e5;\n    \n    for (int j=0; j<3; ++j) {\n        \n        vec2 ap = vec2(abs(p.x), abs(p.y-0.5*sz));\n        \n        vec2 dls = dline_seg(ap, p2, p1);\n        \n        p = R*p;\n        \n        color = mix(color, colors[j], smoothstep(1.0, 0.0, -dls.x+0.5) * ue);\n        ds = min(ds, dls.y);\n    \n    }\n\n    color = mix(color, vec3(0), smoothstep(1.0, 0.0, ds-0.05*sz) * ue);\n    \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// draw sphere inset for bottom left corner\n\nvoid draw_sphere_inset(in vec2 p, inout vec3 color) {    \n    \n    float px = inset_scl;\n    \n    float dot_size = max(3.0*px, 0.03);\n    float line_width = max(.25*px, 0.003);\n\n    float lp = length((p - inset_ctr)*px);\n        \n    vec3 sp = sphere_from_gui(p);\n    \n    if (lp < 1.) {\n        \n        color = vec3(1);        \n      \n        float d_tri = 1e5;\n        \n        \n        float d_circ = 1e5;\n        \n        for (int i=0; i<3; ++i) {\n\n            d_circ = min(d_circ, length(sp - tri_verts[i]));\n            d_circ = min(d_circ, length(sp - tri_spoints[i]));\n            \n            d_tri = min(d_tri, dot(sp, tri_edges[i]));\n        }\n        \n        d_circ = min(d_circ, length(sp - tri_spoints[3]));\n                   \n        float d_V = length(sp - poly_vertex);\n                \n        vec3 sp2 = sp;\n        tile_sphere(sp2); \n        \n\n        float d_gray = 1e5;\n        \n        for (int i=0; i<3; ++i) {\n            d_gray = min(d_gray, abs(dot(sp2, tri_edges[i])));\n        }\n        \n        \n        float d_pink = length(sp2 - poly_vertex);\n        \n        color = mix(color, vec3(0.85), smoothstep(px, 0.0, d_gray-2.*line_width));\n\n        color = mix(color, vec3(0.9, 0.5, 0.5), smoothstep(px, 0.0, d_pink-0.7*dot_size));\n\n        color = mix(color, vec3(0.6), smoothstep(px, 0.0, -d_tri));\n        color = mix(color, vec3(0), smoothstep(px, 0.0, abs(d_tri)-line_width));\n\n        color = mix(color, vec3(1), step(d_circ, dot_size));\n        color = mix(color, vec3(0.7, 0, 0), smoothstep(px, 0.0, d_V-dot_size));\n        color = mix(color, vec3(0), smoothstep(px, 0.0, abs(d_circ - dot_size)-line_width));\n\n    \n    }    \n    \n    color = mix(color, vec3(0), smoothstep(px, 0.0, abs(lp - 1.)-line_width));                                                 \n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// was for debugging, now just for fun \n\nvec3 stereographic_polar_diagram(in vec2 p, in vec2 theta) {\n    \n    mat3 R = rotX(-theta.x)*rotY(-theta.y);\n\n    float rad = length(planar_verts[0]);\n    float scl = 8.0*rad / iResolution.y;\n    \n    p *= scl;\n\n    float d = 1e5;\n    \n    vec3 Rctr = R * vec3(0, 0, 1);\n    vec3 Rp3d = R * vec3(p, 1);\n    vec2 Rp = Rp3d.xy / Rp3d.z;\n        \n    for (int i=0; i<3; ++i) {\n        vec3 tp = (tri_verts[i] * planar_proj * R);\n        d = min(d, length(p - tp.xy / tp.z) - 2.*scl);\n    }\n        \n    vec3 pos = sphere_from_planar(Rp) * sign(Rp3d.z);\n    mat3 M = tile_sphere(pos);\n    \n    for (int i=0; i<3; ++i) {\n        vec3 e =  M * tri_edges[i] * planar_proj * R;\n        e /= length(e.xy);\n        d = min(d, abs(dot(vec3(p, 1), e)));\n    }    \n\n    vec3 pv = M * poly_vertex * planar_proj * R;\n    \n    vec3 color = vec3(1);\n\n    if (length(Rp) < rad) {\n        color = vec3(1, .5, 1);\n    }\n\n    float Mdet = dot(M[0], cross(M[1], M[2]));\n    \n    color *= mix(0.8, 1.0, step(0.0, Mdet));\n    \n    color = mix(color, vec3(0, 0, 1), smoothstep(scl, 0.0, abs(length(Rp)-rad)-.5*scl));\n    color *= smoothstep(0., scl, d-0.25*scl);\n    color = mix(color, vec3(0.7, 0, 0), smoothstep(scl, 0., length(p - pv.xy / pv.z)-3.*scl));\n    \n    vec3 e = vec3(0, 0, 1) * R;\n    e /= length(e.xy);\n    d = abs(dot(vec3(p, 1), e));    \n    color = mix(color, vec3(0.0, 0, 0.5), smoothstep(scl, 0., d-.5*scl));\n    \n    return color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// helper function for drawing icons below\n\nvoid icon_dist_update(inout vec2 blk_gray, \n                      float d, bool enable) {\n    \n    if (enable) {\n        blk_gray.x = min(blk_gray.x, d);\n    } else {\n        blk_gray.y = min(blk_gray.y, d);\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// our main image - apply AA to rendered polyhedron and draw GUI\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    ////////////////////////////////////////////////////////////\n    // set up GUI placement and load in settings from texture A\n    \n    \n    bary_poly_vertex = load3(BARY_COL, TARGET_ROW);\n    spoint_selector = load4(SPSEL_COL, TARGET_ROW);   \n    vec4 theta = load4(THETA_COL, TARGET_ROW);\n    \n    setup_triangle(load3(PQR_COL, TARGET_ROW));\n    \n    vec4 decorations = load4(DECOR_COL, TARGET_ROW);\n    \n    vec4 misc = load4(MISC_COL, TARGET_ROW);\n    bool is_linked = (misc.x != 0.);\n    \n    float gui = load(MISC_COL, CURRENT_ROW).z;\n\n    setup_gui(iResolution.xy, gui);\n    \n#ifdef STEREOGRAPHIC_POLAR    \n    \n    // render a cool 2D diagram\n    vec3 color = stereographic_polar_diagram(fragCoord.xy - object_ctr, theta.xy);\n    color = mix(vec3(1), color, smoothstep(0.0, 100.0, fragCoord.x-2.*inset_ctr.x));\n    \n#else\n#ifdef ENABLE_EDGE_AA\n\n    // texture B holds the rendered scene with the ray distance \n    // stored in the 4th (w) coordinate. \n    //\n    // note color not yet gamma-corrected so still safe to blend\n\n    ivec2 fc = ivec2(fragCoord);\n\n    // fetch center texel and four surrounding texels\n    vec4 sa = texelFetch(iChannel1, fc+ivec2(0, 1), 0);\n    vec4 sb = texelFetch(iChannel1, fc+ivec2(-1, 0), 0);\n    vec4 sc = texelFetch(iChannel1, fc, 0);\n    vec4 sd = texelFetch(iChannel1, fc+ivec2(1, 0), 0);\n    vec4 se = texelFetch(iChannel1, fc+ivec2(0, -1), 0);\n    \n    // blur the center pixel horizontally and vertically\n    const vec3 bcoeff = vec3(0.25, 0.5, 0.25);\n    vec3 hblur = mat3(sb.xyz, sc.xyz, sd.xyz)*bcoeff;\n    vec3 vblur = mat3(sa.xyz, sc.xyz, se.xyz)*bcoeff;\n         \n    // get the (absolute) gradient of the depth map \n    // and its (approximate) norm\n    vec2 depth_grad = abs(vec2(sd.w - sb.w, se.w - sa.w));\n    float depth_grad_norm = depth_grad.x + depth_grad.y;\n    \n    // depth gradient now sums to 1\n    depth_grad /= max(1e-5, depth_grad_norm);\n    \n    // compute blur along depth gradient direction\n    vec3 directed_blur = hblur*depth_grad.y + vblur*depth_grad.x;\n\n    // blend in blur where gradient is large\n    vec3 color = mix(sc.xyz, directed_blur, \n                     smoothstep(0.0, 0.5, depth_grad_norm));\n    \n#else\n    \n    vec3 color = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    \n#endif            \n#endif\n    \n    // everything from here down is just UI and gamma correction\n    \n    vec3 pre_gui_color = color;\n            \n    draw_sphere_inset(fragCoord.xy, color);    \n    \n    float d_gray = 1e5;\n    vec2 d_bg = vec2(1e5);\n\n    for (int i=0; i<3; ++i) {\n\n        vec2 text_pos = fragCoord.xy - char_ui_box(i).xy;\n        \n        d_bg.x = min(d_bg.x, font2d_dist(text_pos, text_size, vec2(pqr[i], 12.0)));\n        d_gray = min(d_gray, spin_icon_dist(text_pos, text_size, true, pqr[i] >= 5.));\n        d_gray = min(d_gray, spin_icon_dist(text_pos, text_size, false, pqr[i] <= 2.));\n        \n        text_pos -= vec2(1, 0) * text_size;\n        \n    }\n       \n    float icon_size = 0.35*text_size;\n\n    for (int row=0; row<2; ++row) {\n        \n        vec4 df = load4(!is_linked && row == 0 ? DFUNC0_COL : DFUNC1_COL, TARGET_ROW);\n        \n        for (int i=0; i<5; ++i) {\n                                \n            vec2 p = fragCoord.xy - dfunc_ui_box(i, row).xy;\n            float idist = dfunc_icon_dist(p, icon_size, i);\n            \n            float dfi;\n            if (i == 0) { dfi = 1. - dot(df, vec4(1)); } else { dfi = df[i-1]; }\n            \n            icon_dist_update(d_bg, idist, dfi != 0.);\n            \n        }\n        \n    }\n    \n    for (int i=0; i<4; ++i) {\n        \n        vec2 p = fragCoord.xy - decor_ui_box(i).xy;\n        float idist = decor_icon_dist(p, icon_size, i);\n        \n        icon_dist_update(d_bg, idist, decorations[i] != 0.);\n        \n    }\n    \n    for (int i=0; i<2; ++i) {\n        \n        vec2 p = fragCoord.xy - color_ui_box(i).xy;\n        bool enable = (misc.y == float(i));\n        \n        draw_color_icon(p, icon_size, i, enable, color);\n                \n    }\n    \n    float ldist = dfunc_icon_dist(fragCoord.xy - link_ui_box().xy, \n                                  icon_size, is_linked ? 6 : 5);\n    \n    icon_dist_update(d_bg, ldist, is_linked);\n\n    vec4 rule_box = vec4(inset_ctr.x,\n                         iResolution.y - 2.75*text_size,\n                         0.19 * iResolution.y,\n                         0.25);\n\n    d_gray = min(d_gray, box_dist(fragCoord.xy, rule_box));\n    \n    rule_box.y -= 2.5*text_size;\n    \n    d_gray = min(d_gray, box_dist(fragCoord.xy, rule_box));\n    \n    color = mix(vec3(0), color, smoothstep(0.0, 1.0, d_bg.x));\n    color = mix(vec3(0.4), color, smoothstep(0.0, 1.0, d_bg.y));     \n    color = mix(vec3(0.2), color, smoothstep(0.0, 1.0, d_gray));     \n\n#ifdef DEBUG_HITBOXES\n    \n    float d_hitbox = 1e5;\n    \n    d_hitbox = min(d_hitbox, length(fragCoord.xy - inset_ctr) - 1./inset_scl);\n\n    for (int i=0; i<3; ++i) {\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, tri_ui_box(i, -1.)));\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, tri_ui_box(i,  1.)));\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, char_ui_box(i)));\n    }\n    \n    for (int i=0; i<5; ++i) {\n        for (int row=0; row<2; ++row) {\n            d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, dfunc_ui_box(i, row)));\n        }\n    }\n    \n    for (int i=0; i<4; ++i) {\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, decor_ui_box(i)));\n    }\n\n    for (int i=0; i<2; ++i) {\n        d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, color_ui_box(i)));\n    }\n    \n    d_hitbox = min(d_hitbox, box_dist(fragCoord.xy, link_ui_box()));\n    \n    color = mix(vec3(1, 0, 1), color, 0.5+0.5*smoothstep(0., 1., d_hitbox));\n    \n#endif    \n    \n    color = mix(pre_gui_color, color, gui);\n    \n    // gamma correction\n    color = pow(color, vec3(1.0/2.2));\n\n    fragColor = vec4(color, 1);\n        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// mostly code for triangle setup and coordinate projection\n// also gui placement\n\nconst float PI = 3.141592653589793;\nconst float TOL = 1e-5;\n\n// define this to see some interesting visualization\n// (and to speed up compile!)\n//#define STEREOGRAPHIC_POLAR\n\n//////////////////////////////////////////////////////////////////////\n// state storage\n\n#define PQR_COL     0 \n#define THETA_COL   1\n#define BARY_COL    2\n#define SPSEL_COL   3\n#define DFUNC0_COL  4\n#define DFUNC1_COL  5\n#define DECOR_COL   6\n#define MISC_COL    7\n// link, shade per face, GUI, debugbgcolor\n\n#define TARGET_ROW  0\n#define CURRENT_ROW 1\n\n#define load(x,y) texelFetch(iChannel0, ivec2(x,y), 0)\n#define load4(a,b) load(a,b)\n#define load3(a,b) load(a,b).xyz\n#define load2(a,b) load(a,b).xy\n#define load1(a,b) load(a,b).x\n\n//////////////////////////////////////////////////////////////////////\n// triangle layout (see setup_triangle below)\n\nvec3 pqr;\n\nmat3 tri_edges, tri_verts, poly_edges, ortho_proj, planar_proj;\nmat4x3 tri_spoints;\nbvec3 is_face_normal;\n\nmat3x2 planar_verts;\nmat2 bary_mat;\n\nvec3 bary_poly_vertex;\nvec4 spoint_selector = vec4(0);\nvec3 poly_vertex;\n\n//////////////////////////////////////////////////////////////////////\n// GUI layout (see setup_gui below)\n\nfloat inset_scl;\nvec2 inset_ctr;\nvec2 object_ctr;\nfloat text_size;\nfloat dfunc_y;\n\n//////////////////////////////////////////////////////////////////////\n// stereographic projection\n\nvec2 planar_from_sphere(vec3 q) {\n    \n    q = q * planar_proj;\n    return q.xy / q.z;\n    \n}\n\nvec3 sphere_from_planar(vec2 p) {\n    \n    return planar_proj * vec3(p, 1.);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// cartesian <-> barycentric\n\nvec3 bary_from_planar(vec2 p) { \n\n    vec2 bxy = bary_mat * (p - planar_verts[2]);\n    return vec3(bxy, 1.-bxy.x-bxy.y);\n    \n}\n\nvec2 planar_from_bary(vec3 b) {\n    return planar_verts * b;\n}\n\n//////////////////////////////////////////////////////////////////////\n// 3D <-> barycentric (via sterographic projection)\n\nvec3 bary_from_sphere(vec3 q) {    \n    return bary_from_planar(planar_from_sphere(q));\n}\n\n\nvec3 sphere_from_bary(vec3 b) {\n    return tri_verts * b;\n}\n\n//////////////////////////////////////////////////////////////////////\n// given polyhedron vertex coords as barycentric coords,\n// compute where it should be on sphere (but first check)\n// if it should be at a \"special\" point\n\nvoid poly_from_bary() {\n    \n    bool was_select = false;\n    \n    for (int i=0; i<4; ++i) {\n        if (abs(spoint_selector[i] - 1.) < TOL) {\n            poly_vertex = tri_spoints[i];\n            bary_poly_vertex = bary_from_sphere(poly_vertex);\n            was_select = true;\n        }\n    }\n    \n    if (!was_select) {\n        poly_vertex = normalize(sphere_from_bary(bary_poly_vertex.xyz));\n    }\n    \n}    \n\n//////////////////////////////////////////////////////////////////////\n// map 2D position in lower right inset of gui to 3D sphere pos\n\nvec3 sphere_from_gui(in vec2 p) {\n    \n    p -= inset_ctr;\n    p *= inset_scl;\n    \n    float dpp = dot(p, p);\n    \n    if (dpp >= 1.) {\n        return vec3(p/sqrt(dpp), 0);\n    } else {    \n        vec3 p3d = vec3(p, sqrt(1. - dot(p, p)));\n        return ortho_proj*p3d;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given PQR and specification of polygon vertex, set up all of the\n// static info we need to do Wythoff construction later\n\nvoid setup_triangle(in vec3 new_pqr) {\n    \n    pqr = new_pqr;\n    \n    float p = pqr.x;\n    float q = pqr.y;\n    float r = pqr.z;\n\n    float tp = PI / p;\n    float tq = PI / q;\n    float tr = PI / r;\n\n    float cp = cos(tp), sp = sin(tp);\n    float cq = cos(tq);\n    float cr = cos(tr);\n\n    vec3 lr = vec3(1, 0, 0);\n    vec3 lq = vec3(-cp, sp, 0);\n    vec3 lp = vec3(-cq, -(cr + cp*cq)/sp, 0);\n    \n    lp.z = sqrt(1.0 - dot(lp.xy, lp.xy));\n    \n    tri_edges = mat3(lp, lq, lr);\n    \n    vec3 P = normalize(cross(lr, lq));\n    vec3 R = normalize(cross(lq, lp));\n    vec3 Q = normalize(cross(lp, lr));\n    \n    tri_verts = mat3(P, Q, R);\n    \n    tri_spoints[0] = normalize(cross(lq - lr, lp));\n    tri_spoints[1] = normalize(cross(lr - lp, lq));\n    tri_spoints[2] = normalize(cross(lp - lq, lr));\n    \n    tri_spoints[3] = normalize(cross(lp-lq, lr-lp));\n        \n    ortho_proj[2] = tri_spoints[3];\n    ortho_proj[0] = -normalize(cross(ortho_proj[2], tri_edges[1]));\n    ortho_proj[1] = normalize(cross(ortho_proj[2], ortho_proj[0]));\n    \n    planar_proj[2] = normalize(cross(R-P, Q-P));\n    \n    planar_proj[0] = -normalize(cross(planar_proj[2], tri_edges[1]));\n    planar_proj[1] = normalize(cross(planar_proj[2], planar_proj[0]));\n        \n    for (int i=0; i<3; ++i) {\n        planar_verts[i] = planar_from_sphere(tri_verts[i]);\n    }\n    \n    bary_mat = inverse(mat2(planar_verts[0] - planar_verts[2],\n                            planar_verts[1] - planar_verts[2]));\n    \n\n\tpoly_from_bary();\n    \n    is_face_normal = bvec3(true);\n    \n    for (int i=0; i<3; ++i) {\n        poly_edges[i] = normalize(cross(poly_vertex, tri_edges[i]));\n        for (int j=0; j<2; ++j) {\n            int vidx = (i+j+1)%3;\n            if (abs(dot(tri_verts[vidx], poly_edges[i])) < TOL) {\n                is_face_normal[vidx] = false;\n            }\n        }\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// if point p lies opposite m, mirror it. return the transform that\n// accomplishes this.\n\nmat3 mirror(inout vec3 p, in vec3 m) {\n    \n    float d = dot(p, m);\n    mat3 rval = mat3(1.) - (2. * step(d, 0.)) * outerProduct(m, m);\n        \n    p = rval * p;\n    \n    return rval;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// modify the vector m to halve the angle with respect to the y\n// axis (assume that m.z == 0)\n\nvec3 half_angle(in vec3 m) {\n    return normalize(vec3(m.x - 1.0, m.y, 0.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// use space folding to make sure pos lies in the triangular cone\n// whose edge planes are given by tri_edges\n//\n// this function was largely determined by trial and error. possibly\n// if I understood more about symmetry I would be able to get it \n// a little simpler\n\nmat3 tile_sphere(inout vec3 pos) {\n    \n    mat3 M = mat3(1.);\n    \n    ////////////////////////////////////////////////////\n    // part 1: guarantee that the point lives inside\n    // the cluster of p triangles that share the vertex\n    // (0, 0, 1)\n    \n    M *= mirror(pos, vec3(1, 0, 0));\n   \n    vec3 m = tri_edges[0];\n\n    for (float i=0.; i<5.; ++i) {\n\n        // mirror\n        M *= mirror(pos, m);\n        m -= tri_edges[1] * 2.0 * dot(m, tri_edges[1]);\n\n        M *= mirror(pos, m);\n        m -= tri_edges[2] * 2.0 * dot(m, tri_edges[2]);\n\n    }\n\n    ////////////////////////////////////////////////////\n    // part 2: fold in the XY plane to make sure the \n    // point lives in the triangular cone just to the\n    // right of the y axis\n       \n    M *= mirror(pos, vec3(1, 0, 0));\n       \n    float p = pqr.x;\n    float k = p >= 5.0 ? 4. : p >= 3.0 ? 2. : 1.;\n    \n    float theta = k * PI / p;\n\n    m = vec3(-cos(theta), sin(theta), 0); // lq\n    \n    if (p >= 5.0) {        \n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    if (p >= 3.0) {\n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    M *= mirror(pos, m);    \n\n    return M;\n        \n}    \n\n\n//////////////////////////////////////////////////////////////////////\n// rotate about x-axis \n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rotate about y-axis \n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// GUI box placement functions\n\nfloat box_dist(vec2 p, vec4 b) {\n    \n    p = abs(p - b.xy) - b.zw;\n    return max(p.x, p.y);\n    \n}\n\nvec4 char_ui_box(int idx) {\n    \n    const vec2 digit_rad = vec2(0.35, 0.5);\n    \n    return vec4(inset_ctr.x + (float(idx - 1))*text_size,\n                2.*inset_ctr.y + 1.15*text_size,\n                digit_rad*text_size);\n    \n}\n\nvec4 tri_ui_box(int idx, float delta) {\n    \n    return vec4(char_ui_box(idx).xy + vec2(0, 0.9*delta*text_size), \n                0.4*text_size, 0.3*text_size);\n    \n}\n\nvec4 dfunc_ui_box(int idx, int row) {\n    \n    return vec4(inset_ctr.x + (float(idx - 2))*text_size,\n    \t        dfunc_y - float(1-row)*text_size,\n                vec2(0.45*text_size));\n    \n}\n\nvec4 link_ui_box() {\n    \n    return vec4(inset_ctr.x + 2.85*text_size,\n                dfunc_y - 0.5*text_size,\n                0.3*text_size, 0.5*text_size);\n    \n}\n\nvec4 decor_ui_box(int idx) {\n    \n    return vec4(inset_ctr.x + (float(idx)-1.5)*text_size*1.1,\n                dfunc_y - 2.5*text_size,\n                vec2(0.45*text_size));\n    \n}\n\nvec4 color_ui_box(int idx) {\n    \n    return vec4(inset_ctr.x + (float(idx)-0.5)*text_size,\n                dfunc_y - 3.5*text_size,\n                vec2(0.45*text_size));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// set up GUI positions\n\nvoid setup_gui(vec2 res, float gui) {\n    \n    //bool show_gui = gui > 0.99 && res.y > 250.;\n    if (res.y < 250.) { gui = 0.; }\n    \n\n    float inset_sz = 0.20*res.y;\n\n    float margin_px = 6.0;\n\n    text_size = 0.06 * res.y;\n\n    inset_scl = 1.0 / inset_sz;\n    inset_sz += margin_px;\n    \n    inset_ctr = vec2(mix(-inset_sz, inset_sz, gui), inset_sz);\n\n    object_ctr = vec2(0.5*res.x + gui*inset_sz, 0.5*res.y);\n\n    dfunc_y = res.y - text_size;\n        \n\n\n}\n    \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// responsible for handling mouse and setting global states\n\nvec4 data = vec4(0); // data (fragment color) to write\nivec2 fc; // current fragment coords \n\n// how quick to blend to target state\nconst float TARGET_LERP_RATE = 0.08;\n\n// store a value in the current row (fc.y)\nvoid store(int dst_col, vec4 dst_value) {\n    if (fc.x == dst_col) { data = dst_value; }\n}\n\n//////////////////////////////////////////////////////////////////////\n// do these settings represent a valid triangle?    \n\nbool valid_pqr(vec3 pqr) {\n    float s = 1./pqr.x + 1./pqr.y + 1./pqr.z;\n    return s > 1. && s < 1.3;\n}\n\n//////////////////////////////////////////////////////////////////////\n// helper function for below\n\nvoid update_snap(inout float dmin,\n                 inout int imin,\n                 in int i,\n                 in vec3 q,\n                 in vec3 p) {\n    \n    float d = length(p-q);\n    \n    if (d < dmin) {\n        dmin = d;\n        imin = i;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given a position q on the sphere, see if it \"snaps\" to one of\n// three triangle vertices or four \"special points\"\n\nint tri_snap(in vec3 q) {\n\n    float dmin = 1e5;\n    int imin = -1;\n    \n    float ds = 1e5;\n\n    for (int i=0; i<3; ++i) {\n        update_snap(dmin, imin, i, q, tri_verts[i]);\n        update_snap(dmin, imin, i+3, q, tri_spoints[i]);\n        ds = min(ds, length(tri_spoints[i] - tri_spoints[3]));\n    }\n    \n    update_snap(dmin, imin, 6, q, tri_spoints[3]);\n\n    if (dmin < max(0.5*ds, 0.125)) {        \n        return imin;        \n    } else {\n    \treturn -1;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// helper function for below\n\nvoid update_closest(inout vec4 pd, in vec3 pi, in vec3 q) {\n    \n    float di = length(pi-q);\n    \n    if (di < pd.w) { \n        pd.xyz = pi;\n        pd.w = di;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// if q is in the triangle, return q; otherwise return closest point\n// in triangle to q\n\nvec3 tri_closest(vec3 q) {\n\n    if (min(dot(q, tri_edges[0]), \n            min(dot(q, tri_edges[1]), dot(q, tri_edges[2]))) > 0.) {\n        \n        return q;\n\n    } else {\n\n        vec4 pd = vec4(1e5);\n        \n        for (int i=0; i<3; ++i) {\n            \n            update_closest(pd, tri_verts[i], q);\n\n            int j = (i+1)%3;\n            int k = 3-i-j;\n\n            vec3 Tji = tri_verts[j] - tri_verts[i];\n            \n            float u = clamp(dot(q - tri_verts[i], Tji) / dot(Tji, Tji), 0., 1.);\n            vec3 p = normalize(tri_verts[i] + u*Tji);\n            \n            update_closest(pd, p, q);\n\n        }\n        \n        return pd.xyz;\n        \n    }\n\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// handle clicking in bottom right inset depicting sphere\n\nvoid gui_vertex_update() {    \n\n    if (fc.x != BARY_COL && fc.x != SPSEL_COL) { return; }\n\n    if (length(iMouse.zw - inset_ctr)*inset_scl > 1.) {       \n\n        return; \n        \n    } else {\n\n        vec3 q = sphere_from_gui(iMouse.xy);\n        \n        vec4 spsel;\n        int s = tri_snap(q);\n\n        if (abs(iMouse.zw) == iMouse.xy && s >= 0) {\n            if (s < 3) {\n                if (fc.x == BARY_COL) {\n                    data.xyz = bary_from_sphere( tri_verts[s] );\n                } else {\n                    data = vec4(0);\n                }\n            } else { \n                if (fc.x == BARY_COL) {\n                    data.xyz = bary_from_sphere( tri_spoints[s-3] );\n                } else {\n                    data = vec4(0);\n                    data[s-3] = 1.;\n                }\n            }\n        } else {\n            if (fc.x == BARY_COL) {\n                data.xyz = bary_from_sphere( tri_closest(q) );\n            } else {\n                data = vec4(0);\n            }\n        }\n\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// handle clicking triangle spin boxes \n\nvoid gui_pqr_update() {\n    \n    if (fc.x != PQR_COL) { return; }\n    \n    for (int i=0; i<3; ++i) {\n\n        int j = (i+1)%3;\n        int k = 3-i-j;\n\n        for (float delta=-1.; delta <= 1.; delta += 2.) {\n            \n            bool enabled = (delta < 0.) ? data[i] > 2. : data[i] < 5.;\n            if (!enabled) { continue; }\n\n            float d = box_dist(iMouse.xy, tri_ui_box(i, delta));       \n            if (d > 0.) { continue; }\n\n            data[i] += delta;\n            \n            int iopp = delta*data[j] > delta*data[k] ? j : k;\n            \n            for (int cnt=0; cnt<5; ++cnt) {\n                if (valid_pqr(data.xyz)) { continue; }\n                data[iopp] -= delta; \n            }   \n            \n        }\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// handle polyhedron rotation (time based or mouse based)\n\nvoid gui_theta_update() {\n    \n    if (fc.x != THETA_COL) { return; }\n    \n    if (iMouse.z > 2.*inset_ctr.x && iMouse.w > 0.) {\n        \n        // mouse down somewhere in the pane but not in GUI panel    \n        \n    \tif ( length(iMouse.zw - object_ctr) < 0.45 * iResolution.y) {\n\n            // down somewhere near object\n            vec2 disp = (iMouse.xy - object_ctr) * 0.01;\n            data.xyz = vec3(-disp.y, disp.x, 1);\n            \n        } else {\n            \n            // down far from object\n            data.z = 0.;\n            \n        }\n        \n    }\n    \n        \n    if (data.z == 0.) {\n        float t = iTime;\n        data.x = t * 2.*PI/6.; \n        data.y = t * 2.*PI/18.;\n    }    \n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// handle clicking on distance function selectors\n\nvoid gui_dfunc_update() {\n    \n    if (!(fc.x == DFUNC0_COL || fc.x == DFUNC1_COL)) { return; }\n        \n    bool is_linked = (load(MISC_COL, TARGET_ROW).x != 0.);\n\n    for (int row=0; row<2; ++row) {  \n\n        int col_for_row = (row == 0 ? DFUNC0_COL : DFUNC1_COL);\n\n        for (int i=0; i<5; ++i) {\n\n            bool update = ( (is_linked && fc.x == DFUNC1_COL) || \n                           (!is_linked && fc.x == col_for_row) );\n\n            if (update) {\n\n                if (box_dist(iMouse.xy, dfunc_ui_box(i, row)) < 0.) {\n                    data = vec4(0);\n                    if (i > 0) { data[i-1] = 1.; }\n                }\n\n            }\n        }\n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// handle clicking on chain link icon or color selectors\n\nvoid gui_misc_update() {\n    \n    if (fc.x != MISC_COL) { return; }\n        \n    if (box_dist(iMouse.xy, link_ui_box()) < 0.) {\n        data.x = 1. - data.x;\n    }\n    \n    for (int i=0; i<2; ++i) {\n        if (box_dist(iMouse.xy, color_ui_box(i)) < 0.) {\n            data.y = float(i);\n        }\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// handle clicking on decoration icons\n\nvoid gui_decor_update() {\n    \n    if (fc.x != DECOR_COL) { return; }\n    \n    for (int i=0; i<4; ++i) {\n        if (box_dist(iMouse.xy, decor_ui_box(i)) < 0.) {\n            data[i] = 1. - data[i];\n        }\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// main \"rendering\" function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    fc = ivec2(fragCoord);\n    \n    data = texelFetch(iChannel0, fc, 0);        \n               \n    vec4 pqrx = load(PQR_COL, TARGET_ROW);\n\n    float gui = 1.0 - texelFetch(iChannel1, ivec2(32, 2), 0).x;\n\n    if (iFrame == 0) {\n\n        // on first frame, store in default values\n        store(PQR_COL, vec4(5, 3, 2, iTime));\n        store(THETA_COL, vec4(0, 0, 0, 1));\n        store(BARY_COL, vec4(0, 0, 0, 0));\n        store(SPSEL_COL, vec4(0, 0, 0, 1));\n        store(DFUNC1_COL, vec4(0, 1, 0, 0));\n        store(DFUNC0_COL, vec4(0, 0, 0, 1));        \n        store(DECOR_COL, vec4(1));\n        store(MISC_COL, vec4(0, 0, gui, 1));\n\n    } else if (fc.y == TARGET_ROW) {\n        \n    \t// target values are set by UI    \n        setup_gui(iResolution.xy, gui);\n        setup_triangle(pqrx.xyz);                   \n\n        float cur_mouse_state = min(iMouse.z, iMouse.w) > 0. ? 1. : -1.;\n        bool click = (cur_mouse_state == 1. && pqrx.w <= 0.);       \n\n        if (fc.x == PQR_COL) {\n            data.w = cur_mouse_state * iTime;\n        } \n        if (fc.x == MISC_COL) {\n            data.z = gui;\n        }\n        \n        float current_gui = load(MISC_COL, CURRENT_ROW).z;\n\n        if (current_gui > 0.95) {\n            \n            if (click) { \n                gui_pqr_update(); \n                gui_dfunc_update(); \n                gui_decor_update(); \n                gui_misc_update(); \n            }\n\n            gui_vertex_update();        \n            \n        }\n\n        gui_theta_update();\n            \n        \n    } else {\n        \n        vec4 cpqrx = load(PQR_COL, CURRENT_ROW);\n        float dt = iTime - cpqrx.w;\n        \n        // current values are set by lerping towards target\n        vec4 target = load(fc.x, TARGET_ROW);         \n        \n        if (dt == 0.) {\n            data = target;\n        } else {\n            data = mix(data, target, TARGET_LERP_RATE);       \n        }\n        \n        if (fc.x == PQR_COL) {\n            data.w = abs(pqrx.w);\n        }\n        \n    }\n        \n    fragColor = data;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// distance marches and shades the polyhedron\n\nconst int rayiter = 8;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\n\nconst float dmin = 2.0;\nconst float dmax = 5.0;\n\nvec4 distance_function;\nfloat shade_per_face;\nfloat bg_value;\nvec4 decorations;\n\n//////////////////////////////////////////////////////////////////////\n// data structure for polyhedron distance queries\n\nstruct query_t {\n    \n    int vidx; // index of triangle vertex\n    int eidx; // index of triangle edge\n    \n    float fdist_vertex; // 3D distance to closest vertex\n    float fdist_edge;   // 3D distance to closest edge/vertex\n    float fdist_face;   // 3D distance to closest face/edge/vertex\n    \n    float pdist_tri;       // distance to triangle cutting plane\n    float pdist_poly_edge; // SIGNED distance to polyhedron edge cutting plane (pass thru ctr)\n    float pdist_poly_perp; // perpendicular distance to polyhedron edge (parallel to face)\n    float pdist_bisector;  // distance to polyhedron edge bisector cutting plane\n    \n    mat3 M; // 3D flip to move point inside spherical triangle\n    \n};\n\n//////////////////////////////////////////////////////////////////////\n// wythoff construction - the workhorse of the distance estimator.\n\nvoid construct(in vec3 pos, out query_t Q) {     \n    \n    // flip point to land within spherical triangle\n    Q.M = tile_sphere(pos);\n       \n    // position relative to vertex\n    vec3 rel_pos = pos - poly_vertex;\n    \n    // initialize data structure members that get updated \n    // as the loop progresses\n    Q.fdist_vertex = length(rel_pos);\n    Q.fdist_edge = Q.fdist_vertex;\n    Q.pdist_tri = 1e5;\n             \n    // for each potential face edge (perpendicular to each tri. edge)\n    for (int eidx=0; eidx<3; ++eidx) {   \n        \n        vec3 tri_edge = tri_edges[eidx];\n        \n        // update distance to triangle\n        Q.pdist_tri = min(Q.pdist_tri, dot(pos, tri_edge));\n        \n        // signed distance of polyhedron vertex poly_vertex from edge plane\n        float V_tri_dist = dot(poly_vertex, tri_edge);\n        \n        // polyhedron edge cut plane (passes thru origin and V, perpendicular\n        // to triangle edge)\n        vec3 poly_edge = poly_edges[eidx];\n                                \n        // signed distance from point to face edge\n        float poly_edge_dist = dot(pos, poly_edge);\n\n        // triangle vertex on the same side of face edge as point\n        int vidx = (eidx + (poly_edge_dist > 0. ? 2 : 1)) % 3;\n        \n        // see which side of the vertex we are on\n        float rel_tri_dist = dot(rel_pos, tri_edge);\n        \n\t\t// update distance to edge        \n        Q.fdist_edge = min(Q.fdist_edge, length(rel_pos - min(rel_tri_dist, 0.) * tri_edge));     \n       \n        // construct at the other polyhedron edge associated with the given\n        // triangle vertex\n        vec3 other_poly_edge = poly_edges[3-eidx-vidx];\n        \n        // construct the plane that bisects the two polyhedron edges\n        vec3 bisector = cross(poly_vertex, poly_edge - other_poly_edge);\n        \n        float bisector_dist = dot(pos, bisector);\n             \n        if (bisector_dist > 0.) {\n            // if we are on the correct side of the associated\n            // bisector, than we have found the closest triangle\n            // edge & vertex.\n            \n            Q.pdist_bisector = bisector_dist;\n            Q.pdist_poly_edge = poly_edge_dist;\n            Q.eidx = eidx;\n            Q.vidx = vidx;\n            \n        }\n \n    }\n    \n    // computing the perpendicular distance away from\n    // the polyhedron edges was a bit hairy. there\n    // was probably a better way to do this.\n    \n    // initialize to zero\n    Q.pdist_poly_perp = 1e5;\n\n    // for each triangle vertex\n    for (int vidx=0; vidx<3; ++vidx) {\n        \n        if (!is_face_normal[vidx]) { continue; }\n\n        vec3 tri_vertex = tri_verts[vidx];\n\n        // midpoint of polyhedron face\n        vec3 P = tri_vertex * dot(poly_vertex, tri_vertex);\n\n        // initial big negative perpendicular distance\n        float pp = -1e5;\n\n        // for each triangle edge associated with the vertex\n        for (int j=0; j<2; ++j) {\n\n            int eidx = (vidx+j+1)%3;\n\n            // constructed same as big for loop above\n            vec3 tri_edge = tri_edges[eidx];           \n\n            // midpoint of polyhedron edge\n            vec3 F = poly_vertex - dot(poly_vertex, tri_edge)*tri_edge;\n\n            // mix in signed distance perpendicular to edge\n            pp = max(pp, dot(rel_pos, normalize(F - P)));\n\n        }\n\n        Q.pdist_poly_perp = min(Q.pdist_poly_perp, pp); \n        \n    }\n\n    if (Q.pdist_poly_perp < 0.) {\n        // only use true distance to face if we are \"above\" it\n        Q.fdist_face = dot(rel_pos, tri_verts[Q.vidx]);\n    } else {\n        // otherwise just use distance to edge\n        Q.fdist_face = Q.fdist_edge;\n    }\n        \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance estimator weighs a linear combination of different\n// distance functions\n\nvec2 map(in vec3 pos) {\n    \n    query_t Q;\n    \n    construct(pos, Q);\n    \n    mat4x2 tm;\n    \n    // distance to sphere\n    vec2 sphere = vec2(length(pos)-1., 2);\n    \n    // distance to polyhedron\n\ttm[0] = vec2(Q.fdist_face, 2);\n    \n    // distance to ball-and-stick web (cylinders/spheres)\n    vec2 dv = vec2(Q.fdist_vertex-0.07, 0);\n    vec2 de = vec2(Q.fdist_edge-0.04, 1);    \n    tm[1] = dv.x < de.x ? dv : de;                  \n\n    // distance to polyhedral net (faceted edges)\n    tm[2] = vec2(max(-(Q.pdist_poly_perp+0.08),\n                     max(Q.fdist_face, -0.08-Q.fdist_face)), 1);\n    \n    // distance to polyhedron dilated by sphere\n    tm[3] = vec2(Q.fdist_face-0.15, 2);\n          \n    // sphere coefficient\n    float k = 1.0 - dot(distance_function, vec4(1));\n    \n    // return final linear combination\n    return (k*sphere + tm * distance_function);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// IQ's normal calculation. \n\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.01, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// IQ's distance marcher. \n\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n\n    const float precis = 0.001;   \n    float h=dmin;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<40; i++ ) {\n\n        if( abs(h)<precis||t>dmax ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n        \n    }    \n\n    if (t > dmax) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// coloring function for surface shading - input is position and\n// material (0=vertex, 1=edge, 2=face)\n\nvec3 poly_color(vec3 pos, float material) {\n\n    // do our distance query with the given point\n    query_t Q;\n    construct(pos, Q);\n    \n    // this would be an odd failure but it happened\n    // sometimes during debugging\n    if (Q.vidx < 0) {return vec3(0.9); }\n\n    // \"standard\" blue/yellow/red vertex colors\n    const mat3 std_fcolors = mat3(vec3(0, 0, 1),\n                               vec3(1, 1, 0),\n                               vec3(1, 0, 0));\n\n    // for coloring with faces - gives a nice contrast to \n    // the bgcolors above\n    const mat3 std_ecolors = mat3(vec3(1, 0.5, 0),\n                              vec3(0.5, 0, 1),\n                              vec3(0, 0.5, 0));\n\n    const vec3 std_vert = vec3(0.1, 0.2, 0.5);\n    \n    ////////////////////////////////////////////////////////////\n    // start setting up some AA for face coloring\n    //\n    // Q.vidx is the index of the triangle vertex that forms\n    // the normal of this face\n    //\n    // Q.eidx is the index of the triangle edge perpendicular\n    // to the polyhedron edge\n    // \n    // now we want to find the index of the triangle vertex\n    // which lies *across* this polyhedron edge (this is for\n    // anti-aliasing using the \"standard\" color scheme\n    \n    // start with other vertex on this triangle edge, \n    // and see if it is also on this polyhedron edge\n    int vidx2 = 3 - Q.vidx - Q.eidx;                    \n\n    vec3 opposite_tri_vertex = tri_verts[vidx2];\n    float opp_on_edge = abs(dot(opposite_tri_vertex, poly_edges[Q.eidx]));\n\n    // if so, then the same triangle vertex is used as normal\n    // for both faces (just in an adjacent triangle)\n    if (opp_on_edge < TOL) { vidx2 = Q.vidx; }\n    \n    vec3 tri_vert2 = tri_verts[vidx2];\n\n    if (vidx2 == Q.vidx) {\n         tri_vert2 = reflect(tri_vert2, poly_edges[Q.eidx]);\n    }\n\n    // hacked scaling factor for antialiasing -- should probably\n    // be based on ray differentials, but in practice this works fine\n    float s = 2.5/iResolution.y;\n\n    // blend coefficient for blending between two different face colors\n    float u_face_aa = smoothstep(-0.5*s, 0.5*s, abs(Q.pdist_poly_edge));\n\n    // get antialiased standard face color and face normal\n    vec3 std_face_aa = mix(std_fcolors[vidx2], std_fcolors[Q.vidx], u_face_aa);\n    vec3 sph_face_aa = mix(tri_vert2, tri_verts[Q.vidx], u_face_aa);\n    \n    ////////////////////////////////////////////////////////////\n    // AA for edge coloring\n\n    // get blended edge color (probably a smarter way to antialias)\n    vec3 std_edge_aa = mix(std_ecolors*vec3(0.33333), std_ecolors[Q.eidx],\n                           smoothstep(0., s, Q.pdist_bisector));\n\n    // midpoint of closest polygon edge\n    vec3 edge_midpoint = poly_vertex - dot(tri_edges[Q.eidx], poly_vertex)*tri_edges[Q.eidx];\n\n    // plane splitting face thru polyhedron vertex and face center\n    vec3 face_split = normalize(cross(tri_verts[Q.vidx], poly_vertex));\n    \n    // same midpoint across splitline\n    vec3 opp_edge_midpoint = reflect(edge_midpoint, face_split);\n\n    // edges should blend together at polyhedron vertex\n    vec3 sph_edge_aa = mix(poly_vertex, edge_midpoint,\n                         smoothstep(0., s, Q.pdist_bisector));\n    \n    // edges should blend together near corners of face\n    sph_edge_aa = mix(opp_edge_midpoint, sph_edge_aa,\n                      smoothstep(-0.5*s, 0.5*s, abs(dot(pos, Q.M*face_split))));\n\n    ////////////////////////////////////////////////////////////\n    // now put it all together\n\n    // blend between standard and spherical shading\n    vec3 face = mix(std_face_aa, 0.5*(Q.M*sph_face_aa)+0.5, shade_per_face);\n    vec3 edge = mix(std_edge_aa, 0.5*(Q.M*sph_edge_aa)+0.5, shade_per_face);\n    vec3 vert = mix(std_vert, 0.25*(Q.M*poly_vertex)+0.75, shade_per_face);\n\n    // blend face, verts, edges with decorations\n    vec3 color = face;\n    \n    // vertex and polyhedron edge decorations affect just face\n    float scaled_vertex_distance = length(pos - Q.M*poly_vertex*length(pos));\n    color *= mix(1.0, 0.0, \n                max(decorations.x*smoothstep(s, 0.0, scaled_vertex_distance-0.02),\n                    decorations.y*smoothstep(s, 0.0, abs(Q.pdist_poly_edge)-.5*s)));\n\n    // edge colors\n    color = mix(color, edge, clamp(2. - material, 0.0, 1.0));\n\n    // parity & triangle edges affect face & edge\n    float parity = dot(Q.M[0], cross(Q.M[1], Q.M[2]));\n    \n    color *= mix(1.0, 0.8, decorations.w*smoothstep(0.5*s, -0.5*s, parity*Q.pdist_tri));\n    color *= mix(1.0, 0.5, decorations.z*smoothstep(s, 0.0, abs(Q.pdist_tri)));        \n\n    // vertex colors\n    color = mix(color, vert, clamp(1. - material, 0.0, 1.0));\n    \n    //done\n    return color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// trace ray & determine fragment color\n\nvec4 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd);        \n\n    vec3 c;\n\n    if (tm.y < 0.0) {\n\n        tm.x = dmax;\n        c = vec3(bg_value);\n\n    } else {        \n\n        vec3 pos = ro + tm.x*rd;\n               \n        vec3 n = calcNormal(pos);\n        \n        vec3 color = poly_color(pos, tm.y);\n        \n        vec3 diffamb = (0.9*clamp(dot(n,L), 0.0, 1.0)+0.1) * color;\n        \n        vec3 p = normalize(pos);\n        \n        vec3 refl = 2.0*n*dot(n,L)-L;\n        float spec = 0.4*pow(clamp(-dot(refl, rd), 0.0, 1.0), 20.0);\n        c = diffamb + spec;\n        \n        c *= 0.4*dot(p, n) + 0.6;\n        \n\n    }\n\n    return vec4(c, tm.x);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// generate polyhedron image finally\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n#ifdef STEREOGRAPHIC_POLAR    \n    \n    fragColor = vec4(1, 1, 1, dmax); \n        \n#else    \n    \n    ////////////////////////////////////////////////////////////\n    // load in settings from GUI manager\n    \n    // load triangle shape & rotation from target row (set directly)\n    vec4 pqrx = load4(PQR_COL, TARGET_ROW);        \n    vec4 theta = load4(THETA_COL, TARGET_ROW);  \n\n    vec4 cpqrx = load4(PQR_COL, CURRENT_ROW);\n    float dt = iTime - cpqrx.w;\n    \n    int active_row = CURRENT_ROW;\n    \n    if (dt == 0.) {\n        active_row = TARGET_ROW;\n    }\n\n    // all other params change continuously\n    bary_poly_vertex = load3(BARY_COL, active_row);\n    spoint_selector = load4(SPSEL_COL, active_row);    \n    vec4 misc = load4(MISC_COL, active_row);\n    vec4 df1 = load4(DFUNC1_COL, active_row);    \n    vec4 df0 = mix(load4(DFUNC0_COL, active_row), df1, misc.x);\n    decorations = load4(DECOR_COL, active_row);\n\n    shade_per_face = misc.y;\n    bg_value = misc.w;\n    \n    distance_function = mix(df0, df1, smoothstep(0.25, 0.75, fragCoord.y/iResolution.y));\n                        \n    setup_triangle(pqrx.xyz); \n    setup_gui(iResolution.xy, misc.z);\n    \n    ////////////////////////////////////////////////////////////\n    // pretty normal raymarcher/renderer from here on out\n    // only twist is that emit ray distance along with\n    // color to final buffer in order to do AA along \n    // depth discontinuities\n\n    vec2 uv = (fragCoord.xy - object_ctr) * 0.8 / (iResolution.y);\n    \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    const vec3 cpos = vec3(0.0, 0.0, 3.25);\n    const vec3 up = vec3(0, 1, 0);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n\n    mat3 Rview = mat3(rx,ry,rz)*rotY(theta.y)*rotX(theta.x); \n    L = Rview*L;\n\n    vec3 rd = Rview*normalize(vec3(uv, 1.));\n    vec3 ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor = shade(ro, rd);\n    \n#endif\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}