{
    "Shader": {
        "info": {
            "date": "1651474781",
            "description": "I just think it's neat.",
            "flags": 32,
            "hasliked": 0,
            "id": "stXfDj",
            "likes": 22,
            "name": "Dramatic Window",
            "published": 3,
            "tags": [
                "raymarch",
                "raymarched",
                "purple",
                "aesthetic",
                "vaporwave"
            ],
            "usePreview": 0,
            "username": "Xibanya",
            "viewed": 621
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 texel = 1. / iResolution.xy;\n    vec2 duv = texel * vec2(-0.5, 0.5);\n    vec3 col1 = texture(iChannel0, uv + duv).rgb;\n    vec3 col2 = texture(iChannel0, uv - duv).rgb;\n    vec3 col = vec3((col1.r + col2.r) * 0.5, col1.g, col2.b) * 1.3;\n    col = pow(col, vec3(1.1));\n    \n    float n = fract(cos(\n        (sin(uv.x / texel.x) * uv.y / texel.y + iTime * 0.01)\n        * 90.) * 343.);\n\tcol = mix(col, max(col, n), 0.075);\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float _XRot = 0.;\nfloat _YRot = 90.;\nfloat _XPos = 3.;\nfloat _YPos = 0.3;\nfloat _ZPos = 0.;\nfloat _FOV = 25.;\n\nconst int MARCH_STEPS = 250;\nconst int SHADOW_MARCH_STEPS = 50;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 SHADOW_COLOR = vec3(0.1, 0.1, 0.2);\nconst vec3 PINK = pow(vec3(0.8, 0.3, 0.6), vec3(1.5));\nconst vec3 PURPLE = vec3(0.25, 0.1, 0.35);\nconst vec3 SKY_COLOR = pow(vec3(0.9, 0.4, 0.46), vec3(1.5));\n\nstruct Objects {\n    float main; float bg; float sphere; float ground;\n};\n\nmat3 YRotationMatrix(float degrees)\n{\n\tfloat angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat3 rotateYMatrix = mat3(\n        c, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c);\n\treturn rotateYMatrix;\n}\nmat3 XRotationMatrix(float degrees)\n{\n\tfloat angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat3 rotateXMatrix = mat3(\n        1, 0, 0,\n\t\t0, c, -s, \n\t\t0, s, c);\n\treturn rotateXMatrix;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat SDFBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    vec3 v = min(d, 0.);\n    return length(max(d, 0.0)) + max(max(v.x, v.y), v.z);\n}\nfloat SDFCylinder(vec3 p, float r, float height) \n{\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y) - height);\n}\nfloat SDFCapped( vec3 p, float r, float h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat SDFSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\nfloat SDFUnion( float sphere, float ground, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(ground-sphere)/k, 0.0, 1.0 );\n    return mix( ground, sphere, h ) - k*h*(1.0-h); \n}\nfloat SDFSub( float sphere, float ground, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(ground+sphere)/k, 0.0, 1.0 );\n    return mix( ground, -sphere, h ) + k*h*(1.0-h); \n}\nvec3 domainRepeat(vec3 p, vec3 size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\nfloat domainRepeat1D(float p, float size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n#define PI 3.14159265\nvec2 pModPolar(vec2 p, float repetitions) \n{\n    float angle = 2.0 * PI / repetitions;\n    float a = atan(p.y, p.x) + angle * .5;\n    float r = length(p);\n\n    a = mod(a, angle) - angle * .5;\n    return vec2(cos(a), sin(a)) * r;\n}\nfloat Scene(vec3 p, out Objects o)\n{\n    vec3 wsPos = vec3(.0,.0,.0);\n\tvec4 a0 = vec4(p, 1.0);\n\tvec4 a1 = a0;\n\twsPos = ( a1.xyz * vec3(4.238,4.238,4.238)) - vec3(-.62,.081,.284);\n    vec3 spherePos = p + vec3(0.5, -0.1, 0.25);\n\tfloat sphere = SDFSphere(spherePos, 0.1);\n    o.sphere = sphere;\n\tvec4 a2 = a0;\n\twsPos = a2.xyz - vec3(.084,.0,.0);\n    vec3 groundPos = wsPos;\n\tfloat ground = SDFBox(groundPos, vec3(1.,.001,1.));\n    o.ground = ground; \n\tfloat sdf = min(sphere, ground);\n    float ceiling = SDFBox(\n        groundPos - vec3(0., 1., 0.), vec3(2., .01, 2.));\n    sdf = min(sdf, ceiling);\n    o.ground = min(o.ground, ceiling);\n\tvec4 a3 = a0;\n\tvec4 a4 = a3;\n\twsPos = a4.xyz - vec3(-.894,.232,.0);\n\tfloat d4 = SDFBox(wsPos,vec3(.08,.165,.25));\n\twsPos = (mat4(.0, -1.0, .0, .0, 1.0, .0, .0, .0, .0, .0, 1.0, .0, -.412, -.867, .0, 1.0) * a4).xyz;\n\td4 = min(d4,SDFCylinder(wsPos, .25,.078));\n\tvec4 a5 = (a3 * vec4(1.0,1.0,1.112,1.0));\n\twsPos = (mat4(.0, -1.0, .0, .0, 1.0, .0, .0, .0, .0, .0, 1.0, .0, -.62, -.889, .0, 1.0) * a5).xyz;\n\tfloat d5 = SDFBox(wsPos,vec3(.65,.037,1.0));\n\tfloat d3 = max(-d4,d5);\n\tsdf = min(sdf,d3);\n\tvec4 a6 = a0;\n\twsPos = a6.xyz - vec3(-.907,.4,.0);\n\tfloat d6 = SDFBox(wsPos,vec3(.005,.005,.25));\n\twsPos = (mat4(1.0, .0, .0, .0, .0, .0, 1.0, .0, .0, -1.0, .0, .0, .907, -.1, -.36, 1.0) * a6).xyz;\n\td6 = min(d6,SDFBox(wsPos,vec3(.005,.005,.292)));\n\twsPos = (mat4(1.0, .0, .0, .0, .0, .0, 1.0, .0, .0, -1.0, .0, .0, .907, .1, -.36, 1.0) * a6).xyz;\n\td6 = min(d6,SDFBox(wsPos,vec3(.005,.005,.292)));\n\tsdf = min(sdf,d6);\n    o.main = max(max(sdf, -sphere), -ground);\n    float cyl = SDFCylinder(p + vec3(0.5, -0.1, -0.25), 0.05, 0.15);\n    o.sphere = min(o.sphere, cyl);\n    sdf = min(sdf, cyl);\n\treturn sdf;\n}\nfloat Skyline(vec3 p)\n{\n    vec3 wsPos = vec3(.0,.0,.0);\n\tvec4 a0 = vec4(p, 1.0);\n\twsPos = (mat4(\n        .936, .0, .352, .0, \n        .0, 1.0, .0, .0, \n        -.352, .0, .936, .0, \n        3.653, .081, 1.754, 1.0) * a0).xyz;\n\twsPos = domainRepeat(wsPos, vec3(2., 0., 4.));\n    float d0 = SDFBox(wsPos,vec3(.15,.77,.15));\n\twsPos = a0.xyz - vec3(-3.322,-.2,.132);\n\td0 = min(d0,SDFBox(wsPos,vec3(.18,.52,.2)));\n\twsPos = a0.xyz - vec3(-5, -.55, -.8);\n\td0 = min(d0,SDFBox(wsPos,vec3(.18,.87,.2)));\n\treturn d0;\n}\nfloat Distance(vec3 p)\n{\n    Objects o;\n    return Scene(p, o);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * EPSILON;\n    return normalize( e.xyy * Distance( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx * Distance( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy * Distance( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx * Distance( pos + e.xxx ) );\n}\nfloat March(vec3 pos, vec3 dir, out Objects o) \n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MARCH_STEPS; i++) \n    {\n        vec3 p = pos + depth * dir;\n        float dist = Scene(p, o);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= MAX_DIST) break;\n    }\n    return MAX_DIST;\n}\nfloat BGMarch(vec3 pos, vec3 dir) \n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MARCH_STEPS; i++) \n    {\n        vec3 p = pos + depth * dir;\n        float dist = Skyline(p);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= MAX_DIST) break;\n    }\n    return MAX_DIST;\n}\n// https://iquilezles.org/articles/rmshadows\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n    float mint = 0.02;\n    float tmax = 2.5;\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i< SHADOW_MARCH_STEPS; i++ )\n    {\n\t\tfloat h = Distance( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0);\n}       \nfloat GetLight(vec3 normal, vec3 p, vec3 lightPos)\n{\n    vec3 lightDir = normalize(p - lightPos);\n    float nDotL;\n    nDotL = dot(lightDir, normal) * 0.5 + 0.5;\n    float shadow = pow(Shadow(p, lightDir), .5);\n    nDotL *= shadow;\n    float atten = smoothstep(0.5, 1.5, length(lightDir));\n    nDotL /= atten;\n    return nDotL;\n}\nvec3 RayDir(float fieldOfView, vec2 size, vec2 fragCoord) \n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 Color(Objects o, vec3 p, vec3 dir, vec3 normal)\n{\n    // DIFFUSE\n    vec3 lightPos = vec3(20., -10., 0.);\n    float diffuseTerm = GetLight(normal, p, lightPos);\n    lightPos = vec3(20., -10., 5.);\n    diffuseTerm += GetLight(normal, p, lightPos) * 0.5;\n    lightPos = vec3(20., -10., -5.);\n    diffuseTerm += GetLight(normal, p, lightPos) * 0.5;\n    vec3 diffuse = mix(SHADOW_COLOR, PURPLE, diffuseTerm);\n\n    // FRESNEL\n    float fresnelTerm = 1. - max(0., dot(normal, -dir));\n    fresnelTerm = smoothstep(0.7, 0.75, fresnelTerm) * diffuseTerm;\n    fresnelTerm *= (o.main < o.ground || o.sphere < o.ground) ? 1. : 0.;\n    return diffuse + fresnelTerm * SKY_COLOR;\n}\nfloat fbm (vec2 uv)\n{\n    float freq = 0.0;\n    float total = 0.0;\n    float amplitude = 0.5;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        freq += texture(iChannel0, uv).r * amplitude;\n        total += amplitude;\n        uv *= 2.0;\n        amplitude *= 0.5;\n    }\n    return freq / total;\n}\n\nvec3 ColorBG(vec2 fragCoord, vec3 p, vec3 dir)\n{\n    vec2 uv = (fragCoord * 2.-iResolution.xy)/iResolution.x;\n    uv += 0.5;\n    float mixFactor = smoothstep(0.2, 0.7, uv.y);\n    vec3 bgColor = mix(PINK, SKY_COLOR, mixFactor);\n    \n     if (iMouse.xy != vec2(0)) \n     {\n         vec2 m = (vec2(iMouse.xy / iResolution.xy).yx * 2. - 1.);\n         p.z -= m.y * 0.05;\n     }\n    \n    float skyline = BGMarch(p, dir);\n    p = p + skyline * dir;\n    if (skyline <= MAX_DIST - EPSILON)\n    {\n        mixFactor = clamp(smoothstep(0.0, 0.7, p.y), 0., 1.);\n        vec3 buildingColor = pow(SHADOW_COLOR, vec3(2.));\n        bgColor = mix(bgColor, buildingColor, min(mixFactor, 0.7));\n    }\n    else\n    {\n        mixFactor = smoothstep(0.5, 0.75, uv.y);\n        float color1 = fbm(uv * vec2(0.05, 0.1) + \n            vec2(iTime * 1.e-3, 0.));\n        color1 = smoothstep(0.6, 0.75, color1) * mixFactor;\n        bgColor = mix(bgColor, SKY_COLOR * vec3(1.5), color1);\n    }\n\n    return bgColor;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rot = vec2(_XRot, _YRot);\n    if (iMouse.xy != vec2(0)) \n     {\n         vec2 m = (vec2(iMouse.xy / iResolution.xy).yx * 2. - 1.);\n         rot.x += m.x * 0.5;\n         rot.y -= m.y;\n     }\n\tvec3 dir = RayDir(_FOV, iResolution.xy, fragCoord);\n    dir *= XRotationMatrix(rot.x);\n    dir = dir * YRotationMatrix(rot.y);\n    vec3 pos = vec3(_XPos, _YPos, _ZPos);\n    Objects o;\n    float dist = March(pos, dir, o);\n    if (dist > MAX_DIST - EPSILON) \n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        float mixFactor = smoothstep(0.2, 0.7, uv.y);\n        vec3 bgColor = ColorBG(fragCoord, pos, dir);\n        fragColor = vec4(bgColor, 0.);\n\t\treturn;\n    }\n    \n    vec3 p = pos + dist * dir;\n    vec3 normal = GetNormal(p);\n    vec3 diffuse = Color(o, p, dir, normal);\n    fragColor = vec4(diffuse, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}