{
    "Shader": {
        "info": {
            "date": "1723059761",
            "description": "originals source  https://www.shadertoy.com/view/fsGGWG https://www.shadertoy.com/view/4sKcRh https://www.shadertoy.com/view/wdlGWn",
            "flags": 0,
            "hasliked": 0,
            "id": "McBcW3",
            "likes": 0,
            "name": "moving in mengerbox",
            "published": 3,
            "tags": [
                "fractal",
                "cinshader",
                "mengerbox"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 73
        },
        "renderpass": [
            {
                "code": "\n\n#define time iTime\n#define resolution iResolution.xy\n\n\nmat2 rot(float a){\n        float s = sin(a), c = cos(a);\n        return mat2(c, s, -s, c);\n}\n\nvec2 pmod(vec2 p, float r){\n float pi = acos(-1.);\n float pi2 = 2. * pi;\n        float a = atan(p.x, p.y) + pi / r;\n        float n = pi2 / r;\n        a = floor(a/n) * n;\n        return p * rot(-a);\n}\n\nfloat cube(vec3 p, vec3 s){\n        return length(max(abs(p) - s, 0.));\n}\n\nfloat PI = 3.1415926535;\nfloat sections = 3.0;\n\nbool belongs(float time, vec2 uv, float near, float far) {\n    near += sin(uv.x - time * 8.0) / 50.0;\n    far += cos(uv.y - time * 8.0) / 50.0;\n    vec2 center = vec2(0.5, 0.5);\n    vec2 xy = uv - center;\n    float dist = distance(xy, vec2(0.0, 0.0));\n    float angle = mod(atan(xy.y, xy.x) + time * 2.5 + sin(time * 4.0) / 1.0, PI * 2.0);\n    float oddity = mod(angle / (2.0 * PI) * sections * 2.0, 2.0);\n    if (dist > near && dist < far && floor(mod(oddity, 2.0)) == 0.0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n#define SPEED 2.8\n#define PI 3.141593\n\nfloat SCALE = 0.5;\nfloat SPEED3 = 0.25;\nfloat INTENSITY = 203.0;\nfloat LENGTH = 0.5;\nfloat RADIUS = 0.0520;\nfloat FADING = 0.125;\nfloat GLOW = 5.0;\n\n#define M_2_PI 6.28318530\n\n\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec2 circle(float t){\n    float x = SCALE * sin(t);\n    float y = SCALE * cos(t);\n    return vec2(x, y);\n}\n\nvec2 leminiscate(float t){\n    float x = (SCALE * (cos(t) / (1.0 + sin(t) * sin(t))));\n    float y = (SCALE * (sin(t) * cos(t) / (1.0 + sin(t) * sin(t))));\n    return vec2(x, y);\n}\n\n// inspired by https://www.shadertoy.com/view/wdy3DD\nfloat mapinfinite(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = leminiscate(t * M_2_PI);\n    vec2 p2 = leminiscate((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 3.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = leminiscate((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nfloat mapcircle(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = circle(t * M_2_PI);\n    vec2 p2 = circle((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = circle((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n//signed distance to a 2D triangle by iq : https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat pit = PI*2.0/3.0; \n\nfloat a0 = 0.*PI*2.0/3.0;\nfloat a1 = 1.*PI*2.0/3.0; \nfloat a2 = 2.*PI*2.0/3.0;\n\n\nfloat b = 0.01;\nfloat r = 0.1;\nfloat map(vec3 p){\n        vec3 q = p;\n        float d = 1e5;\n        q.y+=iTime*1.021;\n       q.z-=iTime*1.021;\n       q = mod(q, 0.82) - 0.4;\n         \n        float b = cube(q, vec3(.15));\n        float h1 = cube(q, vec3(10., .01, .01));\n        float h2 = cube(q, vec3(.01, 10., .01));\n          q.y+=iTime*1.021;\n       q.z-=iTime*1.021;\n        float h3 = cube(q, vec3(.1, .1, 10.));\n        float h = min(min(h1, h2), h3);\n        d = min(min(d, b), h);\n        \n        return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n        vec2 p = (gl_FragCoord.xy * 2. - resolution) / min(resolution.x, resolution.y);\n\n        vec3 ro = vec3(0., 0., 3.);\n        \n        float ft = abs(sin(time/2.));\n      \n                ro = vec3(0., 0., 3.);\n                \n        vec3 ta = vec3(0.);\n        vec3 cDir = normalize(ta - ro);\n        vec3 cUp = vec3(0., 1., 0.);\n        vec3 cSide = cross(cDir, cUp);\n        float fov = 1.;\n        vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * fov);\n\n        vec3 destColor = vec3(1.);\n        vec3 rayPos = ro;\n        float d, t = 0.;\n        float mainEmissive = 0.;\n\n        for(int i=0; i<74; i++){\n                rayPos = ro + ray * d;\n                t = map(rayPos);\n                mainEmissive += exp(abs(t) * -.2);\n                if(t < .001){\n                        destColor = (1. + abs(cos(time))) * vec3(0.1, 0.3, 1.) * mainEmissive * .03 + abs(1. - exp(d*d*.005));\n                        break;\n                }\n                d += t;\n        }\n        \n        vec2 UV = fragCoord/iResolution.yy;\n    \n    UV.x -= (iResolution.x / iResolution.y - 1.0) / 2.0;\n    float TIME = iTime;\n float t4 = iTime*SPEED;\n    float rot = (t4);\n    vec2 uv = vec2(fragCoord/iResolution.y);\n    uv.y -= 0.5;\n    uv.x -= iResolution.x/iResolution.y/2.;\n    uv*=0.5;\n\n       vec2 uv3 = (2. * fragCoord - iResolution.xy) / iResolution.y;\n        \n    float dist = pow(length(uv3*5.0),.5);\n    float twist = (rot/pit) * 6.0;\n    float bend = dist  - twist*iTime*0.002;\n\n    float dist1 = mapcircle(uv3.yx*vec2(1.0,0.66),1.0);\n\tfloat dist2 = mapinfinite(uv3.xy*vec2(0.66,1.0),2.0);\n\tfloat dist3 = mapcircle(uv3.xy*vec2(1.0,0.88),4.0);\n    \n    vec3 col1 = vec3(1.0, 0.55, 0.25) * pow(RADIUS/dist1, GLOW);\n\tvec3 col2 = vec3(0.55, 1.00, 0.25) * pow(RADIUS/dist2, GLOW);\n\tvec3 col3 = vec3(0.25, 0.55, 1.00) * pow(RADIUS/dist3, GLOW);\n\t\n\tvec3 col=(col1+col2+col3)*(1.*GLOW);\n    float angle_offset = mod(sin(t),pit) - bend;\n    vec2 v0 = vec2(cos(a0-angle_offset)*r,sin(a0-angle_offset)*r);\n    vec2 v1 = vec2(cos(a1-angle_offset)*r,sin(a1-angle_offset)*r);\n    vec2 v2 = vec2(cos(a2-angle_offset)*r,sin(a2-angle_offset)*r);\n\n    float d4 = sdTriangle( v0, v1, v2, uv*mat2(cos(iTime), sin(iTime),-sin(iTime),cos(iTime)));   \n    float col5 = clamp(d4*500.0,.0,1.);\n    if (belongs(TIME, UV, 0.2, 0.25) || belongs(TIME + 0.5, UV, 0.3, 0.35) || belongs(TIME + 1.0, UV, 0.4, 0.45)) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n      fragColor+= vec4(1.0-vec3(col5)*1.5,1.0);\n     \n      fragColor+= vec4(col, 1.0);\n        \n        \n        \n        fragColor += vec4(destColor, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}