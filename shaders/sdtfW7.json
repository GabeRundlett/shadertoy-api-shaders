{
    "Shader": {
        "info": {
            "date": "1656622191",
            "description": "just an experiment to visualize a bagel sliced by two mobius strips",
            "flags": 0,
            "hasliked": 0,
            "id": "sdtfW7",
            "likes": 7,
            "name": "bagel slicing experiment",
            "published": 3,
            "tags": [
                "mobius",
                "slice",
                "bagel"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 278
        },
        "renderpass": [
            {
                "code": "const float max_dist = 10.0;\nconst float other_side_bright = 0.25;\n\n#define ENABLE_TORUS_OUTLINE 1 // set to 0 to disable outline\n\nfloat to_toroid_sdf(in vec3 pt) {\n  float to_toroid_spine = length(pt.xz) - 0.75;\n  float to_toroid = length(vec2(to_toroid_spine, pt.y)) - 0.25;\n  return to_toroid;\n}\n\nfloat sdf(in vec3 pt) {\n  float to_toroid_spine = length(pt.xz) - 0.75;\n  float to_toroid = length(vec2(to_toroid_spine, pt.y)) - 0.25;\n  float angle = atan(pt.x, pt.z);\n  vec2 p1 = vec2(sin(0.5 * angle), cos(0.5 *angle));\n  vec2 p2 = vec2(cos(0.5 * angle), -sin(0.5 *angle));\n  float d1 = dot(vec2(to_toroid_spine, pt.y), p1);\n  float d2 = dot(vec2(to_toroid_spine, pt.y), p2);\n  float max_angle_dist = min(max(d1, d2), max(-d1, -d2));\n  return max(to_toroid, max_angle_dist);\n}\n\nfloat sdf_other_side(in vec3 pt) {\n  float to_toroid_spine = length(pt.xz) - 0.75;\n  float to_toroid = length(vec2(to_toroid_spine, pt.y)) - 0.25;\n  float angle = atan(pt.x, pt.z);\n  vec2 p1 = vec2(sin(0.5 * angle), cos(0.5 *angle));\n  vec2 p2 = vec2(cos(0.5 * angle), -sin(0.5 *angle));\n  float d1 = dot(vec2(to_toroid_spine, pt.y), p1);\n  float d2 = dot(vec2(to_toroid_spine, pt.y), p2);\n  float max_angle_dist = min(max(-d1, d2), max(d1, -d2));\n  return max(to_toroid, max_angle_dist);\n}\n\nfloat rough_raycast(in vec3 orig, in vec3 dir) {\n  float accum = 0.0;\n  float d = to_toroid_sdf(orig);\n  for (int i = 0; i < 256; ++i) {\n    accum = accum + 0.9 * d;\n    vec3 pt = orig + accum * dir;\n    d = to_toroid_sdf(pt);\n    if (abs(d) < 1.0e-2) {\n      return accum;\n    }\n    if (d > max_dist) {\n      return max_dist + 1.0;\n    }\n  }\n  return accum;\n}\n\n\nfloat raycast(in vec3 orig, in vec3 dir, float start_guess) {\n  float accum = start_guess;\n  if (accum > max_dist) {\n    return accum;\n  }\n  float d = sdf(orig + accum * dir);\n  for (int i = 0; i < 256; ++i) {\n    accum = accum + 0.7 * d;\n    vec3 pt = orig + accum * dir;\n    d = sdf(pt);\n    if (abs(d) < 1.0e-6) {\n      return accum;\n    }\n    if (accum > max_dist) {\n      return max_dist + 1.0;\n    }\n  }\n  return accum;\n}\n\nfloat raycast_other_side(in vec3 orig, in vec3 dir, float start_guess) {\n  float accum = start_guess;\n  if (accum > max_dist) {\n    return accum;\n  }\n  float d = sdf_other_side(orig + dir * accum);\n  for (int i = 0; i < 256; ++i) {\n    accum = accum + 0.7 * d;\n    vec3 pt = orig + accum * dir;\n    d = sdf_other_side(pt);\n    if (d < 1.0e-6) {\n      return accum;\n    }\n    if (d > max_dist) {\n      return max_dist + 1.0;\n    }\n  }\n  return accum;\n}\n\n\nvec3 get_norm(in vec3 pt) {\n  float f = sdf(pt);\n  const float h = 1.0e-3;\n  return normalize(vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf(pt + vec3(0.0, 0.0, h)) - f));\n}\n\nvec3 get_norm_other_side(in vec3 pt) {\n  float f = sdf_other_side(pt);\n  const float h = 1.0e-3;\n  return normalize(vec3(sdf_other_side(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf_other_side(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf_other_side(pt + vec3(0.0, 0.0, h)) - f));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float uv_scale = min(iResolution.x, iResolution.y);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / uv_scale;\n    \n    vec3 orig = vec3(0.0, 0.0, -3.0);\n    vec3 ray = normalize(vec3(uv, 0) - orig);\n    \n    float theta_tilt = 2.0 * iMouse.y / iResolution.y - 1.0;\n    float ct = cos(theta_tilt);\n    float st = sin(theta_tilt);\n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                       0.0, ct, -st,\n                       0.0, st, ct);\n    \n    float phi_yaw = 8.0 * (2.0 * iMouse.x / iResolution.x - 1.0);\n    float cp = cos(phi_yaw);\n    float sp = sin(phi_yaw);\n    mat3 yaw = mat3(cp, 0.0, -sp,\n                    0.0, 1.0, 0.0,\n                    sp, 0.0, cp);\n    orig = yaw * tilt * orig;\n    ray = yaw * tilt * ray;\n    \n    float bright = 0.95;\n    \n    vec3 overlay = vec3(0.5);\n    \n    vec3 col = vec3(0.0);\n    vec3 light = -vec3(0.8 * ray.x + 0.6 * ray.z, ray.y, 0.8 * ray.z - 0.6 * ray.x);\n    \n    float start_guess = rough_raycast(orig, ray);\n\n    float dist = raycast(orig, ray, start_guess);\n    if (dist < max_dist) {\n      overlay = vec3(0.0);\n      vec3 n = get_norm(orig + dist * ray);\n      // pixel color\n      vec3 bounce = normalize(reflect(ray, n));\n      col = 0.5 * bounce + 0.5;\n      float bounce_dot = max(0.0, dot(bounce, light));\n      bounce_dot = bounce_dot * bounce_dot;\n      bounce_dot = bounce_dot * bounce_dot;\n      col += 0.5 * bounce_dot;\n      bright = 1.0;\n    }\n    \n#if ENABLE_TORUS_OUTLINE\n    float dist_other_side = raycast_other_side(orig, ray, start_guess);\n    \n    if (dist_other_side < max_dist && dist_other_side < dist) {\n      if (dist >= max_dist) {\n        overlay = vec3(0.0);\n      }\n      bright = 1.0 - other_side_bright;\n      vec3 hit_pt = orig + dist_other_side * ray;\n      vec3 n = get_norm_other_side(hit_pt);\n      vec3 bounce = normalize(reflect(ray, n));\n      float stripe = mod(atan(hit_pt.x, hit_pt.z)/3.141592654, 0.1);\n      overlay += max(0.75, dot(bounce, light)) * 0.3 * step(0.015, stripe);\n    }\n#endif\n\n    // Output to screen\n    fragColor = vec4(bright * col + overlay,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}