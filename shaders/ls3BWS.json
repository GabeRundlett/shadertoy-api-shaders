{
    "Shader": {
        "info": {
            "date": "1528584393",
            "description": "Thinking about circles. Experimenting with subpixel rendering.\n\nFrom left to right: aliased, normal aa, and (almost) ground truth coverage calculation\nTop row uses coverage of full pixels, bottom row uses subpixel rendering",
            "flags": 0,
            "hasliked": 0,
            "id": "ls3BWS",
            "likes": 3,
            "name": "A More Accurate Circle?",
            "published": 3,
            "tags": [
                "circles",
                "subpixels"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 394
        },
        "renderpass": [
            {
                "code": "/*\nAn experiment to compare rendering methods and to try and analytically\nrender the most accurate circle possible (without multisampling).\n\n\n\nLeft:   \tNaive/aliased method\nMiddle: \tNormal analytical approach\nRight:  \tTrue circle coverage (almost)\n\nBottom row uses subpixel rendering, top row does not.\n\n\t\t\t\t\t\t\t\t\tR G B\nAssumes this subpixel geometry:\t\tR G B\n\t\t\t\t\t\t\t\t\tR G B\n\n\n\nThe usual analytical method uses a purely distance-based approach, so it isn't taking\nthe rectangular shape of pixels and subpixels into account. The difference between this\ncalculation and true coverage is quite subtle, but not completely invisible.\n\nThe true coverage calculation is adapted from a solution by 'the swine' on Stack Overflow:\n\thttps://stackoverflow.com/questions/622287/area-of-intersection-between-circle-and-rectangle\nThere appear to be noticable artifacts on the maximum and minimum points on the x and y\naxes of the circle. I have some theories about what the problem might be, but I'm not\nsure what to do about it. Calculus is not one of my strengths.\n\nSome aliasing in the subpixel-rendered circles is due to the difference\nin perceptual brightness between the differently coloured subpixels.\nHaving EQUALIZE_SUBPIXEL_BRIGHTNESS enabled gives the image a tint which\nattempts to alleviate this aliasing.\n*/\n\n#define EQUALIZE_SUBPIXEL_BRIGHTNESS\n\n\nfloat g( float x, float h, float r ) {\n    // indefinite integral of circle segment\n    return 0.5 * ( sqrt(1.0-x*x/(r*r))*x*r + r*r*asin(x/r) - 2.0*h*x );\n}\n\nfloat area( float xa, float xb, float h, float r ) {\n    // area of intersection of an infinitely tall box with left edge at xa, right edge at xb,\n    // bottom edge at h and top edge at infinity, with circle centered at the origin with radius r\n    float s = sqrt( max(r*r-h*h, 0.0) );\n    xa = clamp( xa, -s, s );\n    xb = clamp( xb, -s, s );\n    \n    //return g(xb, h, r) - g(xa, h, r);\n    return 0.5*r*( sqrt(1.0-xb*xb/(r*r))*xb-sqrt(1.0-xa*xa/(r*r))*xa + r*(asin(xb/r)-asin(xa/r)) )  - h*(xb-xa);\n}\n\nfloat area( float xa, float xb, float ya, float yb, float r ) {\n    // area of the intersection of a finite box with a circle centered at the origin with radius r\n    if(ya < 0.0) {\n        if(yb < 0.0) {\n            //the box is completely under - flip vertically\n    \t\treturn area(xa, xb, -yb, r) - area(xa, xb, -ya, r);\t\t\t//area2(xa, xb, -ya, -yb, r);\n        } else {\n            //the box is both above and below - divide into two boxes\n            return area(xa, xb, 0.0, r) - area(xa, xb, -ya, r)\t\t\t//area2(xa, xb, 0.0, -ya, r);\n    \t\t\t + area(xa, xb, 0.0, r) - area(xa, xb,  yb, r);\t\t\t//area2(xa, xb, 0.0,  yb, r);\n        }\n    } else {\n        return area(xa, xb, ya, r) - area(xa, xb, yb, r);\t//area of the lower box minus area of the higher box\n    }\n}\n\nfloat coverage( vec2 uva, vec2 uvb, vec2 p, float r ) {\n    // area of the intersection of a general box with a general circle\n    uva -= p;\t\t\t\t\t\t\t\t\t\t//lower-left corner of box\n    uvb -= p;\t\t\t\t\t\t\t\t\t\t//upper-right corner of box\n    float a = area(uva.x, uvb.x, uva.y, uvb.y, r);\t//get area covered by intersection of circle and box\n    a /= abs(uva.x-uvb.x)*abs(uva.y-uvb.y);\t\t\t//divide by area of box to find coverage\n    return clamp(a, 0.0, 1.0);\n}\n\nfloat truecircle( vec2 uv, vec2 p, float r ) {\n    uv *= iResolution.y;\n    p *= iResolution.y;\n    r *= iResolution.y;\n    return coverage( uv-0.5, uv+0.5, p, r );\n}\n\nvec3 subpixeltruecircle( vec2 uv, vec2 p, float r ) {\n    uv *= iResolution.y;\n    p *= iResolution.y;\n    r *= iResolution.y;\n    vec3 c;\n    c.r = coverage( uv+vec2(-0.5,-0.5), uv+vec2(-0.16667,0.5), p, r );\n    c.g = coverage( uv+vec2(-0.16667,-0.5), uv+vec2(0.16667,0.5), p, r );\n    c.b = coverage( uv+vec2(0.16667,-0.5), uv+vec2(0.5,0.5), p, r );\n    return c;\n}\n\n\nfloat naivecircle( vec2 uv, vec2 p, float r ) {\n    return distance(uv,p)<r ? 1.0 : 0.0;\n}\n\n\nvec3 subpixelnaivecircle( vec2 uv, vec2 p, float r ) {\n    uv *= iResolution.y;\n    p *= iResolution.y;\n    r = r * iResolution.y + 0.5;\n    vec3 c;\n    c.r = distance(uv+vec2(0.16667,0.0),p)<r ? 1.0 : 0.0;\n    c.g = distance(uv+vec2(0.5    ,0.0),p)<r ? 1.0 : 0.0;\n    c.b = distance(uv+vec2(0.83333,0.0),p)<r ? 1.0 : 0.0;\n    return c;\n}\n\n\nfloat circle( vec2 uv, vec2 p, float r ) {\n    float d = r-distance(uv,p);\t\t\t\t\t//distance from edge (>0 = inside shape,  <0 = outside shape)\n    return clamp(d*iResolution.y+0.5, 0.0, 1.0);\n}\n\n\nvec3 subpixelcircle( vec2 uv, vec2 p, float r ) {\n    uv *= iResolution.y;\n    p *= iResolution.y;\n    r = r * iResolution.y + 0.5;\n    vec3 c;\n    //c.r = r - distance(uv+vec2(0.16667, 0.0), p);\n    //c.g = r - distance(uv+vec2(0.5,     0.0), p);\n    //c.b = r - distance(uv+vec2(0.83333, 0.0), p);\n    c.r = r - distance(uv+vec2(-0.3333, 0.0), p);\n    c.g = r - distance(uv+vec2(\t0.0,    0.0), p);\n    c.b = r - distance(uv+vec2(\t0.3333, 0.0), p);\n    return clamp(c, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    //uv += vec2(sin(iTime*0.1), cos(iTime*0.1) ) *0.1;\n    uv.x += sin(iTime*0.1) *0.1;\n    \n    vec3 col = vec3(1.0);\n    \n    float ra = 0.667;\n    float rb = 0.333;\n    float ca = 0.5;\n    float cb = 0.75;\n    float cc = 1.0;\n    \n    col -= naivecircle( uv, vec2(ca,ra), 0.09 );\n    col -= naivecircle( uv, vec2(ca,ra), 0.1 );\n    col += naivecircle( uv, vec2(ca,ra), 0.0995 );\n    \n    col -= circle( uv, vec2(cb,ra), 0.09 );\n    col -= circle( uv, vec2(cb,ra), 0.1 );\n    col += circle( uv, vec2(cb,ra), 0.0995 );\n    \n    col -= truecircle( uv, vec2(cc,ra), 0.09 );\n    col -= truecircle( uv, vec2(cc,ra), 0.1 );\n    col += truecircle( uv, vec2(cc,ra), 0.0995 );\n    \n    col -= subpixelnaivecircle( uv, vec2(ca,rb), 0.09 );\n    col -= subpixelnaivecircle( uv, vec2(ca,rb), 0.1 );\n    col += subpixelnaivecircle( uv, vec2(ca,rb), 0.0995 );\n    \n    col -= subpixelcircle( uv, vec2(cb,rb), 0.09 );\n    col -= subpixelcircle( uv, vec2(cb,rb), 0.1 );\n    col += subpixelcircle( uv, vec2(cb,rb), 0.0995 );\n    \n    col -= subpixeltruecircle( uv, vec2(cc,rb), 0.09 );\n    col -= subpixeltruecircle( uv, vec2(cc,rb), 0.1 );\n    col += subpixeltruecircle( uv, vec2(cc,rb), 0.0995 );\n    \n    if(uv.y>ra || uv.y<rb) col = 1.0-col;\n    \n    col = pow( col, vec3(0.45) );\t\t\t\t\t\t//gamma adjustment\n    \n    //if(uv.y<0.5) col = vec3(0.0,0.0,1.0);\n    //else if(uv.x<1.0) col = vec3(0.0,1.0,0.0);\n    //else col = vec3(1.0,0.0,0.0);\n    \n    #ifdef EQUALIZE_SUBPIXEL_BRIGHTNESS\n    //col /= 13.8504*vec3(0.2126, 0.7152, 0.0722);\n    col.r /= 2.6;//2.945;\n    col.g /= 3.3;//9.906;\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}