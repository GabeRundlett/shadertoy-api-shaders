{
    "Shader": {
        "info": {
            "date": "1582665258",
            "description": "L2 Spherical Harmonics evaluation for Grace Cathedral",
            "flags": 0,
            "hasliked": 0,
            "id": "3lGXWW",
            "likes": 5,
            "name": "Irradiance Mapping, SH L2",
            "published": 3,
            "tags": [
                "irradiance",
                "probe"
            ],
            "usePreview": 0,
            "username": "4rknova",
            "viewed": 891
        },
        "renderpass": [
            {
                "code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPSILON\t\t\t\t0.0001\n#define EPSILON_M\t\t\t0.1\n#define PI\t\t\t\t\t3.14159265359\n#define PI2\t\t\t\t\tPI * 0.5\n#define RADIAN\t\t\t\t180.0 / PI\n\n// These constants have been calculated with a light probe from this website:\n// http://www.pauldebevec.com/Probes/\n// The light probe image used is Grace Cathedral.\nconst vec3 _SH[9] = vec3[](\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.5646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\n// Implementation from https://patapom.com/blog/SHPortal/\n// Evaluates the irradiance perceived in the provided direction\n// Analytic method from http://www1.cs.columbia.edu/~ravir/papers/envmap/envmap.pdf eq. 13\nvec3 Evaluate(vec3 dir) {\n    const float c1 = 0.42904276540489171563379376569857;\n    const float c2 = 0.51166335397324424423977581244463;\n    const float c3 = 0.24770795610037568833406429782001;\n    const float c4 = 0.88622692545275801364908374167057;\n    \n    return  max(vec3(0.0), \n        +  c4 * _SH[0]                                                                           //   c4  L00 \n        +  c2 * 2.0 * (_SH[3] * dir.x + _SH[1]* dir.y + _SH[2]* dir.z)                           // 2 c2 (L11 x + L1-1 y + L10 z)\n        +  c1 * 2.0 * (_SH[4] * dir.x * dir.y + _SH[7] * dir.x * dir.z + _SH[5] * dir.y * dir.z) // 2 c1 (L2-2 xy + L21 xz + L2-1 yz)\n        + (c1 * (dir.x * dir.x - dir.y * dir.y)) * _SH[8]                                        //   c1 L22 (x²-y²)\n        + (c3 * (3.0 * dir.z * dir.z - 1.0)) * _SH[6]                                            //   c3 L20 (3.z² - 1)\n    );\n}\n\nvec3 sph2dir(vec2 p)\n{\n    vec2 s = (p*2.-1.) * vec2(PI,PI * 0.5); // Spherical coords\n    vec4 t = vec4(sin(s), cos(s));       // Precalculated sin/cos values\n    return t.zyx * vec3(t.w, 1, t.w);    // Conversion to direction\n}\n\nvec3 Unwrap(vec2 uv)\n{\n    vec3 d = sph2dir(uv);\n    return Evaluate(d);\n}\n\n// ****************************************************************\n// Ray marching\n// ****************************************************************\n\n#define RMARCH_MAX_STEPS \t64\n#define CLEAR_COLOR\t\t\tvec3(0.2)\n\nfloat des_sphere(vec3 p, float r) { return length(p) - r; }\nvec3  translate (vec3 v, vec3  t) { return v - t; }\n\nconst float cCamera_fov = 60.0;\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\n\t\nvoid generate_ray(vec2 uv, Camera c, out Ray r)\n{\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(cCamera_fov * 0.5 * RADIAN)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\t\n\tr.d = normalize(tmat * r.d);\n}\n\nfloat scene_distance(vec3 p)\n{\n\treturn des_sphere(translate(p, vec3(0)), 1.0);\n}\n\nvec3 scene_normal(vec3 pos, float d)\n{\n    vec3 n;\n\t\n\t// Gradient via Forward differencing\n    n.x = scene_distance(vec3(pos.x + EPSILON, pos.y, pos.z));\n    n.y = scene_distance(vec3(pos.x, pos.y + EPSILON, pos.z));\n    n.z = scene_distance(vec3(pos.x, pos.y, pos.z + EPSILON));\n\t\n    return normalize(n - d);\n}\n\nvec3 scene_shade(vec3 p, vec3 n)\n{\n\treturn Evaluate(n);\n}\n\nbool rmarch(Ray r, out vec3 p, out vec3 n, out int iter)\n{\n\tp = r.o;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < RMARCH_MAX_STEPS; i++) {\n\t\titer = i;\n\n\t\td = scene_distance(pos);\n\n\t\tif (d < EPSILON) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tpos += d * r.d;\n\t}\n\t\n\tn = scene_normal(p, d);\t\n\treturn d < EPSILON;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 nv = (fragCoord.xy / iResolution.xy);\t\n    \n    vec3 col = CLEAR_COLOR;\n    \n    float mode = mod(floor(iTime*.5), 2.0);\n    \n    if (mode == 1.0) {\n        col = Unwrap(nv);\n    }\n    else\n    {\n        vec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.)\n        \t    * vec2(iResolution.x / iResolution.y, 1);\t\n   \n\t\tCamera c;\n\t\tc.p = vec3(cos(iTime) * 4.0, 0, sin(iTime) * 4.0);\n\t\tc.t = vec3(0, 0, 0);\n\t\tc.u = vec3(0, 1, 0); \n   \n\t\n\t\tRay r;\n\t\tgenerate_ray(uv, c, r);\n\t\n\t\tvec3 sp, sn;\n\t\tint iter = RMARCH_MAX_STEPS;\t\n\t\tbool res = rmarch(r, sp, sn, iter);\n\t\n    \n        if (res) {\n            col = scene_shade(sp, sn);    \n        }\n    }\n\t\n\n\tfragColor = vec4(col + Text(iResolution.xy, fragCoord), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Font rendering based on FlyGuy's shader: https://www.shadertoy.com/view/llSGRm\n#define FONTSC_SZ vec2(2.5, 5)     // Font size\n#define SCREEN_SZ vec2(800, 600) // Screen size\n#define CHR       vec4(6,7,6.*FONTSC_SZ.x,9.*FONTSC_SZ.y)  // Character size (xy), spacing(zw)\n#define STR_SZ(c) vec2(c*CHR.zw) // String size\n#define DWN_SC    2.             // Downscale\n\n#define C vec2\nC c_spc = C(      0,      0), c_exc = C( 276705,  32776), c_quo = C(1797408,      0)\n, c_hsh = C(  10738,1134484), c_dol = C( 538883,  19976), c_pct = C(1664033,  68006)\n, c_amp = C( 545090, 174362), c_apo = C( 798848,      0), c_lbr = C( 270466,  66568)\n, c_rbr = C( 528449,  33296), c_ast = C(  10471,1688832), c_crs = C(   4167,1606144)\n, c_per = C(      0,   1560), c_dsh = C(      7,1572864), c_com = C(      0,   1544)\n, c_lsl = C(   1057,  67584), c_0   = C( 935221, 731292), c_1   = C( 274497,  33308)\n, c_2   = C( 934929,1116222), c_3   = C( 934931,1058972), c_4   = C( 137380,1302788)\n, c_5   = C(2048263,1058972), c_6   = C( 401671,1190044), c_7   = C(2032673,  66576)\n, c_8   = C( 935187,1190044), c_9   = C( 935187,1581336), c_col = C(    195,   1560)\n, c_scl = C(    195,   1544), c_les = C( 135300,  66052), c_equ = C(    496,   3968)\n, c_grt = C( 528416, 541200), c_que = C( 934929,1081352), c_ats = C( 935285, 714780)\n, c_A   = C( 935188, 780450), c_B   = C(1983767,1190076), c_C   = C( 935172, 133276)\n, c_D   = C(1983764, 665788), c_E   = C(2048263,1181758), c_F   = C(2048263,1181728)\n, c_G   = C( 935173,1714334), c_H   = C(1131799,1714338), c_I   = C( 921665,  33308)\n, c_J   = C(  66576, 665756), c_K   = C(1132870, 166178), c_L   = C(1065220, 133182)\n, c_M   = C(1142100, 665762), c_N   = C(1140052,1714338), c_O   = C( 935188, 665756)\n, c_P   = C(1983767,1181728), c_Q   = C( 935188, 698650), c_R   = C(1983767,1198242)\n, c_S   = C( 935171,1058972), c_T   = C(2035777,  33288), c_U   = C(1131796, 665756)\n, c_V   = C(1131796, 664840), c_W   = C(1131861, 699028), c_X   = C(1131681,  84130)\n, c_Y   = C(1131794,1081864), c_Z   = C(1968194, 133180), c_lsb = C( 925826,  66588)\n, c_rsl = C(  16513,  16512), c_rsb = C( 919584,1065244), c_pow = C( 272656,      0)\n, c_usc = C(      0,     62), c_a   = C(    224, 649374), c_b   = C(1065444, 665788)\n, c_c   = C(    228, 657564), c_d   = C(  66804, 665758), c_e   = C(    228, 772124)\n, c_f   = C( 401543,1115152), c_g   = C(    244, 665474), c_h   = C(1065444, 665762)\n, c_i   = C( 262209,  33292), c_j   = C( 131168,1066252), c_k   = C(1065253, 199204)\n, c_l   = C( 266305,  33292), c_m   = C(    421, 698530), c_n   = C(    452,1198372)\n, c_o   = C(    228, 665756), c_p   = C(    484, 667424), c_q   = C(    244, 665474)\n, c_r   = C(    354, 590904), c_s   = C(    228, 114844), c_t   = C(   8674,  66824)\n, c_u   = C(    292,1198868), c_v   = C(    276, 664840), c_w   = C(    276, 700308)\n, c_x   = C(    292,1149220), c_y   = C(    292,1163824), c_z   = C(    480,1148988)\n, c_lpa = C( 401542,  66572), c_bar = C( 266304,  33288), c_rpa = C( 788512,1589528)\n, c_tid = C( 675840,      0), c_lar = C(   8387,1147904);\n\nvec2 carret = vec2(0);\n\n// Returns the digit sprite for the given number.\nvec2 digit(float d) {    \n    vec3 r = vec3(0, 0, floor(d));\n         if (r.z == 0.) r.xy = c_0; else if (r.z == 1.) r.xy = c_1;\n    else if (r.z == 2.) r.xy = c_2; else if (r.z == 3.) r.xy = c_3;\n    else if (r.z == 4.) r.xy = c_4; else if (r.z == 5.) r.xy = c_5;\n    else if (r.z == 6.) r.xy = c_6; else if (r.z == 7.) r.xy = c_7;\n    else if (r.z == 8.) r.xy = c_8; else if (r.z == 9.) r.xy = c_9;\n    return r.xy;\n}\n// Extracts bit\nfloat bit(float n, float b) {\n    b = clamp(b,-1.,22.);\n    return floor(mod(floor(n / pow(2.,floor(b))),2.));\n}\n// Returns the pixel at uv in the given bit-packed sprite.\nfloat spr(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv/ FONTSC_SZ);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float b = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? bit(spr.x, b - 21.0) + bit(spr.y, b) : 0.0;\n}\n// Prints a character and moves the carret forward by 1 character width.\nfloat print_char(vec2 ch, vec2 uv) { \n    float px = spr(ch, CHR.xy, uv - carret);\n    carret.x += CHR.z;\n    return px;\n}\n// Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.;\n    \n\tfor(int i = 3; i >= -2; --i) {\n        //Clip off leading zeros.\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0);        \n        float d = mod(number / pow(10., float(i)),10.);\n        \n        if(i == -1) {\n            result += spr(c_per,CHR.xy, uv - dec_pos) * clip;\n            dec_pos.x += CHR.z * clip;\n        }\n        \n        result += spr(digit(d),CHR.xy, uv - dec_pos) * clip;\n        dec_pos.x += CHR.z * clip;\n    }\n    \n    return result;\n}\n\n#define T(x) print_char(x,uv)\nfloat Text(vec2 resolution, vec2 uv)\n{    \n    vec2 res = resolution / DWN_SC,\n         pos = vec2(10,20.5-2.*CHR.y);\n    \n    carret = pos;\n    \n\tfloat r = 0.;\n    r += T(c_L) + T(c_2) + T(c_spc) + T(c_S) + T(c_H);\n    \n    return r;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}