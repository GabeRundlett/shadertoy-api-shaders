{
    "Shader": {
        "info": {
            "date": "1613265093",
            "description": "This took lots of trial and error, hope it helps someone else!\nExplanations are in the code.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ltBzl",
            "likes": 4,
            "name": "Cubemap Reverse Sampling Test",
            "published": 3,
            "tags": [
                "test",
                "ray",
                "cubemap",
                "inverse",
                "identitytest",
                "reversesampling"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "/*\nThis took lots of trial and error, hope it helps someone else!\n\nIf IDENTITY_TEST is working properly, you should see these cycle in this order (starting from iTime = 0):\n1. red background, black letters\n2. black background, red letters\n3. green background, black letters\n4. black background, green letters\n5. blue background, black letters\n6. black background, blue letters\n\nCubemap coordinates are stored as: vec3(face, u, v)\nThis is just my convention by the way.\n\nFace numbering:\n0: right\n1: left\n2: up\n3: down\n4: front\n5: back\n*/\n\n// Interactive view\n#define VIEW_3D\n\n// Test for identity mapping\n//#define IDENTITY_TEST\n\n// cube2ray() returns a ray direction hitting the cubemap texel at cm\n// This is useful for looking up data stored in the cubemap\nvec3 cube2ray(in vec3 cm) {\n    float sgn = sign(0.5 - mod(cm.x, 2.0));\n    if (cm.x == 0.0 || cm.x == 1.0) return vec3((cm.yz * 2.0 - 1.0) * vec2(-sgn, -1.0), sgn).zyx;\n    if (cm.x == 2.0 || cm.x == 3.0) return vec3((cm.yz * 2.0 - 1.0) * vec2( 1.0,  sgn), sgn).xzy;\n    if (cm.x == 4.0 || cm.x == 5.0) return vec3((cm.yz * 2.0 - 1.0) * vec2( sgn, -1.0), sgn).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #ifdef VIEW_3D\n        vec2 screenCenter = 0.5 * iResolution.xy;\n\n        vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n        vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n        vec3 ro = vec3(0.0, 0.0, 5.0);\n        vec3 rd = normalize(vec3(uv, -1.0));\n\n        float cy = cos(mouse.x), sy = sin(mouse.x);\n        float cp = cos(mouse.y), sp = sin(mouse.y);\n\n        // Rotate camera around the origin based on mouse position\n        ro.yz *= mat2(cp, -sp, sp, cp);\n        ro.xz *= mat2(cy, -sy, sy, cy);\n        rd.yz *= mat2(cp, -sp, sp, cp);\n        rd.xz *= mat2(cy, -sy, sy, cy);\n\n        // Coefficients for the quadratic intersection function\n        float a = dot(rd, rd);\n        float b = dot(2.0 * ro, rd);\n        float c = dot(ro, ro) - 2.25;\n\n        // Solve the intersection function\n        float discr = b * b - 4.0 * a * c;\n        if (discr > 0.0) {\n            float t = -(sqrt(discr) + b) / (2.0 * a);\n            vec3 l = vec3(-0.58, 0.58, 0.58); // Light\n            vec3 n = (ro + rd * t) / 1.5; // Normal\n            fragColor.rgb += max(0.0, dot(n, l));\n        }\n\n        else {\n            fragColor = texture(iChannel0, rd);\n        }\n    #endif\n\n    #ifdef IDENTITY_TEST\n    // Test for identity, should render the font texture in reading position cycling through proper colors\n    fragColor = texture(iChannel0, cube2ray(vec3(int(iTime) % 6, fragCoord / iResolution.xy)));\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// For storing data in the cubemap, don't flip the UVs\n// If you are using the cubemap as a skybox (like they were meant to ;)),\n// you probably do want to flip the UVs\n#define FLIP\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec2 uv = fragCoord / iResolution.xy;\n    #ifdef FLIP\n    uv *= -1.0;\n    #endif\n\n    // Sample the texture from the texel's local position on the cubemap face\n    float tex = texture(iChannel0, uv).r;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Change the color based on which face the ray is pointing at\n    vec3 ar = abs(rayDir);\n    if (ar.x >= ar.y && ar.x >= ar.z) fragColor.r = abs(step(0.0, rayDir.x) - tex); // X axis aligned face\n    if (ar.y >= ar.x && ar.y >= ar.z) fragColor.g = abs(step(0.0, rayDir.y) - tex); // Y axis aligned face\n    if (ar.z >= ar.x && ar.z >= ar.y) fragColor.b = abs(step(0.0, rayDir.z) - tex); // Z axis aligned face\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}