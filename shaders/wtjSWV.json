{
    "Shader": {
        "info": {
            "date": "1567185841",
            "description": "I wanted to make some clouds but I've never did transparent or volumetric stuff.\nBy intuition (and some souvenir of a shader I once saw) I came to this weird thing.\nI kinda like it.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtjSWV",
            "likes": 2,
            "name": "ShaderDojo 035",
            "published": 3,
            "tags": [
                "noise",
                "volume",
                "transparent",
                "training"
            ],
            "usePreview": 0,
            "username": "antonOTI",
            "viewed": 467
        },
        "renderpass": [
            {
                "code": "// hash and noise from shane's : https://www.shadertoy.com/view/ldscWH\nvec3 hash33(vec3 p) { \n\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;\n}\n\nfloat tetraNoise(in vec3 p)\n{\n    vec3 i = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    \n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n  \n    vec4 v = max(0.5 - vec4(dot(p,p), dot(p1,p1), dot(p2,p2), dot(p3,p3)), 0.0);\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    \n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); \n}\n\nmat2 rot(float a)\n{\n    float ca = cos(a); float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n#define PI 3.14159\n\nfloat map(vec3 p)\n{\n    \n    p.xz *= rot(iTime * .25);\n    \n    float len = length(p);\n    float boost = fract(len * .05 - iTime * .25);\n    boost = max(0., boost *9. - 8.);\n    boost = boost * boost;\n    boost = sin(boost * PI);\n\n   \tp *= 1. + boost * .1;\n    \n    float volNoise = tetraNoise(p * .6 + vec3(0.,sin(iTime * .5 + p.x * .5) * .2,0.));\n    volNoise -= boost * .4;\n    volNoise = volNoise * volNoise * 1.5;    \n    \n    float dist = .5 - volNoise;\n    \n    p = abs(p);\n\tfloat cu = (p.x + p.y + p.z) * (.5 + sin(boost * 2.) *.025) - boost * volNoise;\n    \n    dist = min(dist, 3. - cu);\n    return dist;\n}\n\nfloat volRay(in vec3 ro, in vec3 rd, float maxDist)\n{\n\tfloat nbSample = 20.;\n    float acc = 0.;\n    \n    for(float i = 1.; i > 0.; i -= 1. / nbSample)\n    {\n        vec3 p = ro + rd * maxDist * i;\n        acc += max(0., map(p)) / nbSample;\n        if(acc >= 1.)\n        {\n          //  break;\n        }\n    }\n    \n    return clamp(acc, 0. ,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n\n    vec3 ro = vec3(0.,0.,-10.);\n    vec3 cp = ro;\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float vol = volRay(ro, rd, 15.);\n    vol = vol;\n\tvol *= 10.;\n    vec3 noColor = vec3(0.,0.,0.);\n    vec3 fullColor = vec3(.6,.4,.37) * 2.;\n    \n    vec3 col = mix(noColor, fullColor, vol);\n\n    // Output to screen\n    fragColor = vec4(col, 0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}