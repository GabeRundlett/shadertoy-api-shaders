{
    "Shader": {
        "info": {
            "date": "1698426661",
            "description": "Coset colouring of the modular group using a variety of colouring methods based on reflection counting. Mouse control alters the colouring functions and loop exit point on the IIS reflection method to help in understanding the computation process.",
            "flags": 0,
            "hasliked": 0,
            "id": "msGfzy",
            "likes": 6,
            "name": "Modular group cosets colouring",
            "published": 3,
            "tags": [
                "group",
                "hyperbolic"
            ],
            "usePreview": 0,
            "username": "willwombell",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "// Core code derived from zenzicubic's https://www.shadertoy.com/view/Ds3SDf\n\n// Functionality to adjust colouring method added along with controls\n// to alter the representation and movement. Some combinations result in\n// strange effects but I find the given setup to be the most fun.\n\n// Deep into the walk, adjusting the loop break point can result in a sharp\n// change due to the nature of the control parameterisation. Just time reset\n// if necessary.\n\n// Scale: Wide 5.0 Mid 2.4 Close 1.8\n\n// Parameters\n#define NUMITERS 5000\n#define PHI 1.61803398874989\n#define PI 3.14159265\n#define SCALE 5.4\n\n// Control\n#define SPLIT true\n#define FLIP true\n\n#define ROTATE true\n#define DISK true\n#define ZOOM true\n#define WALK true\n\n// Colouring function, choose 0 to 4\n#define COLOUR 0\n\n\n// Colouring coset parameters\nconst vec4 count_mixer = vec4(1,2,3,5);\nconst vec3 coset_div = vec3(2.,3.,5.);\n\n\n\nvec2 cinv(vec2 z) {\n    return vec2(z.x, -z.y) / dot(z, z);\n}\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) {\n    return cmul(a, cinv(b));\n}\n\nvec3 eflip(vec2 p, vec2 ms) {\n    // Reflection counters\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    bool esc;\n    \n    for (int i = 0; i < NUMITERS; i++) \n    {\n        // Loop break controller\n        if (i > int((ms.x))) break;\n        \n        esc = true;\n        \n        // Reflection generation\n        if (length(p) < 1.) {\n            p = cinv(p);\n            c ++;\n            esc = false;\n        }\n        if ((p.x > 0.) && SPLIT) {\n            p.x *= -1.;\n            d ++;\n            esc = false;\n        }\n        if (p.x < -.5)\n        {\n            p.x = -1. - p.x;\n            e ++;\n            esc = false;\n        }\n        if ((p.x > .5) && FLIP)\n        {\n            p.x = 1. - p.x;\n            f ++;\n            esc = false;\n        }\n        \n        \n        if (esc) break;\n    }\n    \n    \n    float t = dot(vec4(c,d,e,f),count_mixer);\n    \n    float coset = ms.y*500.;\n    vec3 coset_vec = ms.y*coset_div;\n    \n    switch (COLOUR) {\n        // Coset rgb mixing\n        case 0:\n            return (0.5+0.5*cos(PI*vec3(float(t))/coset_vec));\n        // Scalar coset representation\n        case 1:\n            return vec3(0.5+0.5*cos(PI*float(t)/coset));\n        // Modular arithmetic representation\n        case 2:\n            return vec3(mod(float(t),coset)/float(coset));\n        // Random mixing\n        case 3:\n            return vec3(0.5/float((c+d)%2),\n                        0.4/float((d+e*f)%2),\n                        0.6/float((c*f+f-e)%3));\n        // Controlled random mixing\n        case 4:\n            return vec3(0.5*cos(ms.y)/float((c+d)%2),\n                        0.4*cos(3.*ms.y-0.2)/float((d+e*f)%2),\n                        0.6*cos(2.*ms.y+0.3)/float((c*f+f-e)%3));\n    }\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) \n{\n    vec2 z = SCALE*(coord - 0.5*iResolution.xy) / iResolution.y;\n    vec2 ms = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n    \n    float t = 0.1*iTime;\n    mat2 rot = mat2(1,0,0,1);\n    \n    if (ROTATE) {\n        rot = mat2(cos(t), sin(t), -sin(t), cos(t));\n    }\n    if (DISK) {\n        z = z*rot;\n        z = cdiv(vec2(0., 1.) - vec2(z.y, -z.x), z - vec2(1., 0.));\n    }\n    if (ROTATE) {\n        z.x += cos(iTime);\n        z.y += pow(0.4*sin(iTime*PHI), 2.);\n    }\n    if (WALK) {\n        z.x += pow(iTime, 1.);\n    }\n    if (ZOOM) {\n        z.y /= pow(iTime, 2.);\n        z.x /= pow(iTime, 2.);\n    }\n    col = vec4(eflip(z, vec2(exp(7.*(-ms.x+0.5)),exp(7.*(ms.y)))), 0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}