{
    "Shader": {
        "info": {
            "date": "1719619700",
            "description": "keyboard:\n1. heat map\n2. x-eyed stereo\n3. cutting plane\n4. zoom\n5. AA\n6. transmission",
            "flags": 48,
            "hasliked": 0,
            "id": "l3dXDj",
            "likes": 28,
            "name": "glass doodle",
            "published": 3,
            "tags": [
                "refraction",
                "glass",
                "optics"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 222
        },
        "renderpass": [
            {
                "code": "/*\n    This attempts to handle transparent materials\n    with various indices of refraction\n    which directly abut each other.\n    \n    Orion Elenzil 2024\n*/\n\n\n\n/*\n\nKeyboard (iChannel3)\n--------------------\n1. heat map\n2. x-eyed stereo\n3. cutting plane\n4. zoom\n5. AA\n6. transmission\n\n*/\n\n#define SUBSURFACE 0   // not-quite-right subsurface scattering\n#define HQ         0   // slowww but pretty\n\n//---------------------------------------------------------------\n// Viewport and Time\nconst float gZoom       = 0.8;\n      float gFOVZoom    = 2.0;\n      float gCamDist    = 24.0;\nconst float gToggleZoom = 2.0;\nconst float gStereoSep  = 0.4;\n\n      float gT;         // set in main\n\n//--------------------------------------------------------------------------\n// ray handling parameters\n\n// maximum number of rays per pixel.\n// reflections, shadows, and transmission all spawn a ray,\n// and a single ray travels until it hits a boundary.\n#if HQ\nconst uint  gHQMult         = 3u;\n#else\nconst uint  gHQMult         = 1u;\n#endif\nconst uint  gMaxRays        = 120u * gHQMult;\nconst uint  gQueueSize      =  18u * gHQMult;\n\n// standard marching parameters\nconst float gSceneScale     = 2.0f;\nconst uint  gMaxMarchSteps  = 200u * gHQMult;\nconst float gMarchEps       = 0.03;\nconst float gNormEps        = gMarchEps * 0.4;\nconst float gMarchMaxT      = 5e1 * gSceneScale;\nconst float gMarchUnderstep = 1.0 / float(gHQMult);\nconst float gHitBackoff     = gMarchEps * 0.0;\n\n// smallest contribution before extinguishing a ray\nconst float gMinAmt         = 0.01 / float(gHQMult);\n\n// direction to the light\nvec3  gLightDir;\nfloat gAmbient              = 0.02;\n\n// heat map stuff\n      float gMapCount       = 0.0;\nconst float cHeatMapSteps   = 200.0;\nconst float cHeatMapRays    = 20.0;\n\n// debugging color\n      vec3  gDebugRGB       = v0;\n\n//--------------------------------------------------------------------------\n// Materials\n\nconst uint gMtlAir   = 1u;\nconst uint gMtlFloor = 2u;\nconst uint gMtlGlass = 3u;\nconst uint gMtlWater = 4u;\nconst uint gMtlIce   = 5u;\nconst uint gMtlBands = 6u;\nmtl_t mtls[] = mtl_t[] (\n    //    albedo             opac   ior    absorption\n    mtl_t(vX * 1e9         , 1.0  , 1.0  , v41                   ), // 0 invalid\n    mtl_t(v1               , 0.0  , 1.0  , v41 * 0.5             ), // 1 air\n    mtl_t(v1 * 0.3         , 1.0  , 1.3  , v41 * 1.0             ), // 2 floor\n    mtl_t(v1 * 1.0         , 0.0  , 1.52 , V4(0.3, 0.3, 0.3, 0.2)), // 3 glass\n    mtl_t(v1 * 1.0         , 0.0  , 1.33 , V4(0.2, 0.2, 0.6, 0.5)), // 4 water\n    mtl_t(vX + vY          , 0.0  , 1.31 , V4(0.2, 0.2, 0.2, 0.1)), // 5 ice\n    mtl_t(V3(0.9, 0.0, 0.4), 0.015, 1.2  , V4(0.5, 0.8, 0.0, 2.0)), // 6 bands\n    mtl_t(v1 * 0.6         , 1.0  , 1.5  , v41                   )  // 7\n);\n\n//---------------------------------------------------------------------\n// keyboard & mouse stuff part one\nbool kPipOn;        // 1. heat map\nbool kXEyedStereo;  // 2. x-eyed stereo\nbool kCuttingPlane; // 3. cutting plane\nbool kZoom;         // 4. zoom\nbool kAA;           // 5. AA\nbool kTransmission; // 6. transmission\n// pbpaste | sed -e 's/.*\\/\\/ //' | pbcopy\n\n//--------------------------------------------------------------------------\n// Scene Setup\nvec3  gSceneCenter;\nfloat gFloorGap;\nmat2  gObjRot1;\nmat2  gObjRot2;\nvec3  gCamPos;\n\n\nvoid setupScene() {\n    gSceneCenter  = gSceneScale * vY * 8.0;\n    gLightDir     = normalize(vec3(-0.8, 1.5, 1.9));\n    gFOVZoom     *= kZoom ? gToggleZoom : 1.0;\n    \n    gObjRot1 = rot2(gT * 0.123);\n    gObjRot2 = rot2(gT * 0.321);\n    \n    // change the material verrrry slowly according to the wall time.\n    vec4 w = mtls[gMtlBands].absorption;\n    float t = (iDate.z * 100.0 + iDate.w) * 1e-3;\n    w.r  = sin(t * 1.01) * 0.3 + 0.4;\n    w.g  = sin(t * 1.21) * 0.3 + 0.4;\n    w.b  = sin(t * 1.31) * 0.3 + 0.4;\n    w.a += sin(t * 1.41) * 0.3 + 0.5;\n    mtls[gMtlBands].absorption = w;\n    \n    float no = sin(t * 1.51) * 0.1;\n    mtls[gMtlBands].ior += no;\n}\n\n\n//---------------------------------------------------------------------\n// The SDF !\n\nMST sdScene(in vec3 p) {\n    gMapCount += 1.0;\n    \n    p.y -= gSceneCenter.y;\n    \n    p /= gSceneScale;\n    vec3 q = p;\n    \n    \n    vec3 tmp;\n    tmp  = opRing(q.xz, 9.0, 5.0);\n    q.xz = tmp.xy;\n    q.yz *= gObjRot1;\n    tmp  = opRing(q.yz, 4.0, 3.0);\n    q.yz = tmp.xy;\n\n    q.yz *= gObjRot1;\n    q.yx *= gObjRot2;\n\n    float d = 1e9;\n    \n    d = min(d,  sdCappedCylinder(q, 1., 2.7));\n    d = max(d, -sdCylinder(q.xz, 0.8));\n    d -= 0.1;\n    \n    \n    MST ms = MST(d, 4u);\n\n    \n    if (kCuttingPlane) {\n        ms.dist = max(ms.dist, p.z);\n    }\n    \n    if (ms.dist > 0.0) {\n        ms.mtl = gMtlAir;\n    }\n    \n    return ms;\n}\n\n\n//------------------------------------------------------\n// ray-handling stuff.\n\n// FIFO queue of rays. see Common tab.\n#define Q_TYPE ray_t\n#define Q_MAX_ENTRIES (gQueueSize)\nQ_IMPLEMENTATION\nhit_t rayVsScene(ray_t);\nvec3  sky(ray_t);\nvec3  albedo(hit_t);\nMST sdScene(vec3 p);\nMST sdSceneWithFloor(vec3 p);\n\n// run a single ray.\nvec3 runRay(ray_t ray) {\n    hit_t hit = rayVsScene(ray);\n    \n    if (!hit.hit) {\n        // ray hit nothing.\n        \n        if (ray.isLightingRay) {\n            // a \"lighting ray\" is to the light.\n            return ray.amt;\n        }\n        else {\n            // it's a direct ray and sees the sky.\n            return ray.amt * sky(ray);\n        }\n    }\n    \n    // the ray hit something\n\n    // get map samples on either side of the interface\n    MST ms1 = sdSceneWithFloor(hit.pnt + hit.hf_nrm * gMarchEps * 3.0);\n    MST ms2 = sdSceneWithFloor(hit.pnt - hit.hf_nrm * gMarchEps * 3.0);\n    mtl_t mtl1 = mtls[ms1.mtl];\n    mtl_t mtl2 = mtls[ms2.mtl];\n\n    // just traveled through media, attenuate !  (but not through air)\n    if (ms1.mtl != gMtlAir) {\n        vec4 absorption = mtl1.absorption;\n        absorption.w   = mix(absorption.w * 0.7, absorption.w  , smoothstep(0.0, 4.0, hit.pnt.y / gSceneScale));\n        absorption.rgb = mix(absorption.brg * 1.7, absorption.rgb, smoothstep(0.0, 6.0, hit.pnt.y / gSceneScale));\n        float density = absorption.w;\n        float absorptionDist = hit.t / gSceneScale;\n        ray.amt *= sat(exp(-density * absorptionDist * (1.0 - absorption.rgb)));\n    }\n    \n    if (ray.isLightingRay && !QIsFull()) {\n        // lighting ray just keeps traveling\n        if (kTransmission) {\n            float R = reflectAmount(mtls[ms1.mtl].ior, mtl2.ior, dot(ray.rd, -hit.hf_nrm));\n            ray.amt *= 1.0 - mtl2.opacity;\n            ray.amt *= 1.0 - R;\n            ray.ro = hit.pnt - hit.hf_nrm * gMarchEps * 4.0;\n            QEnqueue(ray);\n        }\n        return v0;\n    }\n    \n    float dif;\n    vec4  rfl;\n    vec4  trn;\n    vec3  tmpAmt;\n    \n    thisRayWalksIntoAnInterface(\n        ray.rd,\n        hit.hf_nrm,\n        mtl1.ior,\n        mtl2.ior,\n        mtl2.opacity,\n        dif,\n        rfl,\n        trn);\n         \n    // diffuse\n    float normal_dot_light = dot(hit.of_nrm, gLightDir);\n    vec3 alb = albedo(hit);\n    float shade = sat(normal_dot_light);\n    tmpAmt = ray.amt * dif * alb * shade;\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little off the surface\n        // towards the light\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = gLightDir;\n        newRay.isLightingRay = true;\n        QEnqueue(newRay);\n    }\n    \n    // subsurface\n    // this has issues.\n    #if SUBSURFACE\n    tmpAmt = ray.amt * dif * alb * (sat(-normal_dot_light + 0.5));\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little inside the surface\n        // towards the light\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt - hit.hf_nrm * gMarchEps * 5.0;\n        newRay.rd  = gLightDir;\n        newRay.isLightingRay = true;\n        QEnqueue(newRay);\n    }\n    #endif\n    \n    // reflect\n    tmpAmt = ray.amt * rfl.w;\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little off the surface\n        // in the reflect direction\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = rfl.xyz;\n        newRay.isLightingRay = false;\n        QEnqueue(newRay);\n    }\n    \n    // transmit\n    tmpAmt = ray.amt * trn.w;\n    if (kTransmission && vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little inside the surface\n        // in the refraction direction\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt - hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = trn.xyz;\n        newRay.isLightingRay = false;\n        QEnqueue(newRay);\n    }\n    \n\n    // return ambient lighting, no new ray.\n    return ray.amt * gAmbient * alb * dif;\n}\n\n//---------------------------------------------------------------------\n// keyboard & mouse stuff part two\n\nconst float cPipScale = 0.45;\nvec2  gMouse;\n\nvoid readKeyboard() {\n    const int ZRO = 48;\n    kPipOn        =  KEY_TOGGLED(ZRO + 1, iChannel3);\n    kXEyedStereo  =  KEY_TOGGLED(ZRO + 2, iChannel3);\n    kCuttingPlane =  KEY_TOGGLED(ZRO + 3, iChannel3);\n    kZoom         =  KEY_TOGGLED(ZRO + 4, iChannel3);\n    kAA           =  KEY_TOGGLED(ZRO + 5, iChannel3);\n    kTransmission = !KEY_TOGGLED(ZRO + 6, iChannel3);\n    \n    #if HQ\n    kAA = true;\n    #endif\n}\n\nvoid readMouse() {\n    if (texelFetch(iChannel2, ivec2(3, 0), 0).r == 0.0) {\n        // This texel should be != 0,\n        // so we conclude buffers are broken on this platform.\n        // see https://www.shadertoy.com/view/McsXRM\n        \n        if (dot(iMouse.xy, iMouse.xy) < 75.0 * 75.0) {\n            gMouse = vec2(gT, 0.75 * RES.y);\n\n        }\n        else {\n            gMouse = iMouse.xy;\n        }\n    }\n    else {\n        gMouse = texelFetch(iChannel2, ivec2(0), 0).xy;\n        gMouse.x += 140.0;\n    }\n}\n\n\n\n// sdScene() does not include a floor,\n// because ray-marching infinite planes is a drag.\n// but sometimes we want such a thing.\nMST sdSceneWithFloor(in vec3 p) {\n    MST ms = sdScene(p);\n    opUnion(ms, MST(p.y, gMtlFloor));\n    if (ms.dist > 0.0) {\n        ms.mtl = gMtlAir;\n    }\n    return ms;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normalScene(vec3 p) {\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdSceneWithFloor(p+e*gNormEps).dist;\n    }\n    return normalize(n);\n}\n\n\n//-----------------------------------------------------------\n// material stuff\n\n\nvec3 albedo(hit_t hit) {\n    uint mtl = hit.ms.mtl;\n    vec3 rgb = mtls[mtl].albedo;\n    if (mtl == gMtlFloor) {\n        float f  = 0.0;\n        vec2  xz = mod(hit.pnt.xz * rot2(pi/6.0) + 10.0, 20.0) - 10.0;\n        f  = max(f, smoothstep(1.5, 1.0, abs(xz.x)));\n        f  = max(f, smoothstep(1.5, 1.0, abs(xz.y)));\n        f *= smoothstep(200.0, 100.0, length(hit.pnt.xz));\n        rgb = mix(rgb, rgb * 1.3, f);\n    }\n    return rgb;\n}\n\nfloat ior(MST ms) {\n    const float atmosphere = 1.0;\n\n    if (ms.dist > 0.0) {\n        return atmosphere;\n    }\n    \n    return mtls[ms.mtl].ior;\n}\n\nvec3 sky(ray_t ray) {\n\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(ray.rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(ray.rd, gLightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float dddd = d * d;\n    dddd *= dddd;\n    c *= mix(sin(dddd * dddd * 30.0 + gT) * 0.5 + 0.5, 1.0, 1.0 - dddd * 0.1);\n    \n    float a = atan(ray.rd.z, ray.rd.x);\n    \n    c = mix(c, v1 * (1.0 - sqrt(d)), 0.3 * smoothstep(0.06 + (1.0 - d) * 0.02 * cos(a * 23.0), 0.0, abs(ray.rd.y)));\n    return c;\n}\n\n//--------------------------------------------------------------------------\n// ray-vs scene stuff\n\nvoid rayVsFloor(ray_t ray, inout hit_t hit) {\n    float t = rayVsPlane(ray.ro, ray.rd, vY, 0.0);\n    if (t > 0.0 && (!hit.hit || t < hit.t)) {\n        hit.t   = t;\n        hit.hit = true;\n        hit.pnt = ray.ro + ray.rd * t;\n        hit.of_nrm = vY;\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = MST(0.0, gMtlFloor);\n    }\n}\n\nvoid rayMarch(ray_t ray, inout hit_t hit) {\n\n    float t = 0.0;\n    \n    MST ms;\n    uint n;\n    vec3 p;\n    for (n = 0u; n < gMaxMarchSteps; ++n) {\n    \n        // if our hit already has a hit\n        // and our t is not closer than it, return.\n        if (hit.hit && t >= hit.t) {\n            return;\n        }\n    \n        // sample the map (without floor)\n        p        = ray.ro + ray.rd * t;        \n        ms       = sdScene(p);\n        float d  = abs(ms.dist);\n\n        if (d < gMarchEps) {\n            // close to a surface!\n            // mark it the hit & return\n            hit.hit    = true;\n            hit.t      = t;\n            hit.pnt    = p;\n            hit.of_nrm = normalScene(p + ray.rd * gHitBackoff);\n            hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n            \n            // the hit should be from the new material. need to re-sample.\n            hit.ms     = sdScene(p - hit.hf_nrm * gMarchEps * 2.0);\n            return;\n        }\n        \n        // advance\n        t += d * gMarchUnderstep;\n        \n        // if we're just too far away, return.\n        if (t > gMarchMaxT) {\n            return;\n        }\n    }\n    \n    if (t < 1e4 * gSceneScale) {\n        // ran out of steps.\n        hit.hit = true;\n        hit.t   = t;\n        hit.pnt = p;\n        hit.of_nrm = normalScene(p + ray.rd * gHitBackoff);\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = ms;        \n    }\n}\n\nhit_t rayVsScene(ray_t ray) {\n    hit_t hit;\n    hit.hit = false;\n    hit.t   = 1e9;\n    \n    rayVsFloor(ray, hit);\n    rayMarch  (ray, hit);\n    \n    return hit;\n}\n\nvec3 runRays() {\n\n    vec3 rgb = v0;\n    \n    uint rayCount = 0u;\n    \n    while (!QIsEmpty() && rayCount < gMaxRays) {\n        rgb += runRay(QDequeue());\n        rayCount += 1u;\n    }\n    \n    if (rayCount >= gMaxRays) {\n    //    gDebugRGB.g = 1.0;\n    }\n    \n    return rgb;\n}\n\n//--------------------------------------------------------------------------\n// viewport, camera, initial ray stuff.\n\nray_t getCameraRay(vec2 xy, float stereoOffset) {\n    ray_t ret;\n    \n    vec3 lookFrom = vZ * gCamDist * gSceneScale;\n    float rX      = gT * 0.1;\n    float rY      = 0.0;\n    rX = (gMouse.x / RES.x * 2.0 - 1.0) * pi * -1.2;\n    rY =  smoothstep(1.0, 0.0, gMouse.y / RES.y) * pi * 0.49;\n    \n    lookFrom.yz  *= rot2(rY);\n    lookFrom.xz  *= rot2(rX);\n    lookFrom.y    = max(0.1, lookFrom.y);\n    gCamPos       = lookFrom;\n         \n    vec3 lookTo   = gSceneCenter;\n    \n    vec3 camFw    = normalize(lookTo - lookFrom);\n    vec3 camRt    = normalize(cross(camFw, vY));\n    vec3 camUp    = cross(camRt, camFw);\n    \n    ret.ro            = lookFrom;\n    ret.ro           += camRt * stereoOffset;\n    ret.rd            = normalize(camFw + (xy.x * camRt + xy.y * camUp) / gFOVZoom);\n    ret.amt           = v1;\n    ret.isLightingRay = false;\n        \n    return ret;\n}\n      \n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    // over-large time introduce precision problems\n    gT = mod(iTime, float( 60 * 60 * 4));\n    \n    readKeyboard();\n    readMouse();\n    \n    // modify XY for picture-in-picture\n    bool isPip = kPipOn && (XY.x < RES.x * cPipScale && XY.y < RES.y * cPipScale);\n    if (isPip) {\n        XY /= cPipScale;\n    }\n    \n    vec2  xy           = VIEWFROMSCREEN(XY);\n    float stereoOffset = 0.0;\n    \n    if (kXEyedStereo) {\n        float f = sign(xy.x);\n        xy.x -= f * VIEWFROMSCREEN_DIST(RES.x / 2.0);\n        xy   *= 2.0;\n        stereoOffset = -f * gStereoSep * gSceneScale;\n    }\n    \n    setupScene();\n        \n    QClear();\n    \n    if (kAA) {\n        vec2 aa = vec2(1, -1) * 0.3 / MINRES;\n        QEnqueue(getCameraRay(xy + aa.xx, stereoOffset));\n        QEnqueue(getCameraRay(xy + aa.xy, stereoOffset));\n        QEnqueue(getCameraRay(xy + aa.yx, stereoOffset));\n        QEnqueue(getCameraRay(xy + aa.yy, stereoOffset));\n    }\n    else {\n        QEnqueue(getCameraRay(xy, stereoOffset));\n    }\n    \n    float rootRayCount = float(QCount());\n\n    vec3 c  = runRays();\n    \n    c      /= rootRayCount;\n    c      *= 1.0 - pow(lengthSqr(XY/RES - 0.5) * 1.8, 3.0);\n    c       = pow(c, vec3(1.0 / 2.2));\n    c      += gDebugRGB;\n    \n    if (isPip) {\n        const vec3 cCool = vec3(0.0, 0.0, 0.2);\n        const vec3 cHot  = vec3(1.0, 0.9, 0.2);\n        float temp = gMapCount / float(cHeatMapSteps * cHeatMapRays);\n        c = mix(cCool, cHot, pow(temp, 0.6));\n    }\n    \n    RGBA    = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst vec4  v40 = v01.xxxx;\nconst vec4  v41 = v01.yyyy;\nconst float pi  = 3.14159265359;\n\n//---------------------------------------------------\n// Screen-to-View stuff\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (min(iFrame,0))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n\n\n//---------------------------------------------------\n// math conveniences\n#define saturate(v) ( clamp((v), 0.0, 1.0) )\nfloat lengthSqr(vec3 a) { return dot(a, a); }\nfloat lengthSqr(vec2 a) { return dot(a, a); }\nfloat sqr(float a) { return a * a; }\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nint   vmax(ivec2 A) { return max(    A.x, A.y); }\nfloat vmax( vec2 A) { return max(    A.x, A.y); }\nfloat vmax( vec3 A) { return max(max(A.x, A.y), A.z); }\nint   vmin(ivec2 A) { return min(    A.x, A.y); }\nfloat vmin( vec2 A) { return min(    A.x, A.y); }\nfloat vmin( vec3 A) { return min(min(A.x, A.y), A.z); }\nfloat sat (float A) { return clamp(A,      0.0 ,      1.0 ); }\nvec2  sat ( vec2 A) { return clamp(A, vec2(0.0), vec2(1.0)); }\nvec3  sat ( vec3 A) { return clamp(A, vec3(0.0), vec3(1.0)); }\n#define V2(A, B   )    ( vec2(A, B      ) )\n#define V3(A, B, C)    ( vec3(A, B, C   ) )\n#define V4(A, B, C, D) ( vec4(A, B, C, D) )\n\n//--------------------------------------------------------------------------\n// keyboard conveniences\n//\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n\n\n//--------------------------------------------------------------------------\n// ray stuff\n//\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    \n    // if true, this is a ray looking for the light.\n    bool  isLightingRay;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint  mtl;\n};\n#define MST mapSample_t\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  hf_nrm;\n    vec3  of_nrm;\n    MST   ms;\n};\n\nstruct mtl_t {\n    vec3  albedo;\n    float opacity;         // opacity at the surface\n    float ior;\n    vec4  absorption;      // <vec3, permeability>\n};\n\n//--------------------------------------------------------------------------\n// optics\n\n// A modified Schlick's approximation\n// where reflectamount -> 0 as n2 -> n1.\nfloat reflectAmount(float n1, float n2, float incidentDotNormal) {\n    // from https://en.wikipedia.org/wiki/Schlick%27s_approximation \n    float R0 = sqr((n1 - n2) / (n1 + n2));\n    float R  = R0 + (1.0 - R0) * pow(1.0 - incidentDotNormal, 5.0);\n\n    // Schlick's approximation seems invalid when n1 ~= n2.\n    // Compensate with an additional fudge.\n    // https://physics.stackexchange.com/q/794963\n    float ndiffSqr      = sqr(n1 - n2);\n    float elenzilFudge  = ndiffSqr / (ndiffSqr + 0.01);\n    R                  *= elenzilFudge;\n\n    return R;\n}\n\n// n1 == n2          -> no reflection\nvoid thisRayWalksIntoAnInterface(\n    //  direction of the incoming ray.\n    in  vec3  incident,\n    \n    //  surface normal.\n    in  vec3  hit_facing_normal,\n    \n    //  indices of refraction.\n    in  float n1,\n    in  float n2,\n    \n    in  float opacity,\n    \n    //  amount allocated to diffuse lighting\n    out float out_sDiffuse,\n    \n    //  direction and amount for specular reflection\n    out vec4  out_vReflect,\n    \n    //  direction and amount for transmission\n    out vec4  out_vTransmit\n    ) {\n    \n    // 0 = transmit 1 = reflect 1\n    float transmitVsReflect = reflectAmount(n1, n2, dot(incident, -hit_facing_normal));\n    \n    // check for total internal reflection.\n    float eta     = n1 / n2;\n    out_vTransmit.xyz = refract(incident, hit_facing_normal, eta);\n    if (dot(out_vTransmit.xyz, out_vTransmit.xyz) == 0.0) {\n        // total internal\n        transmitVsReflect = 1.0;\n    }\n    \n    float amtDiffuse  = (1.0 - transmitVsReflect) * opacity;\n    float amtReflect  = transmitVsReflect;\n    float amtTransmit =  1.0 - amtDiffuse - amtReflect;\n    \n    out_sDiffuse      = amtDiffuse;\n    out_vTransmit.w   = amtTransmit;\n    out_vReflect.w    = amtReflect;\n    out_vReflect.xyz  = reflect(incident, hit_facing_normal);\n}\n\n//--------------------------------------------------------------------------\n\n// Queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nvoid QClear() {                                    \\\n    gQHead = gQTail = 0u;                          \\\n}                                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n\n//--------------------------------------------------------------------------------\n// CSG Operations.\n// These all mutate the first argument and return void.\n// MST types are used only where sensible.\n\nvoid opUnion(inout MST A, MST B) {\n    if (A.dist > B.dist) {\n        A = B;\n    }\n}\n\nvoid opSub(inout float d1, in float d2) {\n    d1 = max(d1, -d2);\n}\n\nvoid opSub(inout MST ms1, in float d2) {\n    opSub(ms1.dist, d2);\n}\n\nvoid opReplace(inout float d1, in float d2) {\n    opSub(d1, d2);\n    d1 = min(d1, d2);\n}\n\nvoid opReplace(inout MST ms1, in MST ms2) {\n    opSub(ms1.dist, ms2.dist);\n    opUnion(ms1, ms2);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/smin/\n// polynomial smooth min\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\n// https://www.shadertoy.com/view/Ml3fWj\n// return.w must be added to the distance.\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n// Orion Elenzil\n// From https://www.shadertoy.com/view/43l3zr\n//\n// repeats the origin 'reps' times\n// around a ring of radius 'rad'.\n//\n// reps must be a positive integer.\n//\n// returns:\n//   v.xy = new coordinates\n//   v.z  = cell index, [0, reps - 1].   \nvec3 opRing(in vec2 p, float rad, float reps) {\n    float scale = pi * 2.0 / reps;\n    float theta;\n    float cell;\n    float isEven;\n    \n    // theta in [-𝜋, 𝜋]\n    theta  = atan(p.y, p.x);\n    \n    // scale theta to [-reps/2, reps/2]\n    theta /= scale;\n\n    // determine cell index\n    isEven = float((int(reps) + 1) % 2);\n    cell   = theta + (reps + isEven) / 2.0;\n    cell   = floor(mod(cell, reps));\n\n    // repeat space. theta in [-1/2, 1/2]\n    theta  = fract(theta + 0.5) - 0.5;\n    \n    // scale up again\n    theta *= scale;\n    \n    // polar to cartesian\n    p      = vec2(cos(theta), sin(theta)) * length(p);\n\n    // move the origin onto the ring\n    p.x   -= rad;\n\n    // align +x to be counter-clockwise along the ring.\n    // this might not be what you want,\n    // but it seems natural to me.\n    p      = vec2(p.y, -p.x);\n\n    return vec3(p, cell);\n}\n\n\n//--------------------------------------------------------------------------------\n// Signed Distance Field Primitives\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n//--------------------------------------------------------------------------------\n// Analytic ray-vs-primitives\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    return t;\n}\n\n\n//--------------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// mouse handling.\n// outputs non-normalized mouse as (0,0).xy.\n// defaults to iResolution.xy / 2.\n// resets when mouse is in lower-left.\n// https://www.shadertoy.com/view/Mf2GDy\n// orion elenzil January 2024.\n\n// Wrapping mode for X and Y:\n// 0u = unconstrained\n// 1u = clamp\n// 2u = wrap\nconst uvec2 wrap = uvec2(0u, 1u);\n\n// initial position (normalized)\nconst vec2  p0   = vec2(0.5, 0.75);\n\n// when actual mouse is within this radius\n// in the lower-right, reset to p0.\nconst float resetCircle = 75.0;\n\n// 1 to visualize the mouse position and reset circle.\n#define VISUALIZE 0\n\n// special texels\nconst ivec2 pos = ivec2(0, 0);\nconst ivec2 btn = ivec2(1, 0);\nconst ivec2 hrt = ivec2(3, 0);\n\n\n// data[0] <- bool mouseIsDown\n// data[1] <- bool mouseJustBecameDown\n// data.zw <- current mouse pos\nvoid trackButton(inout vec4 data) {\n    bool mouseIsDown         = iMouse.z > 0.0;\n    bool mouseWasDown        = bool(data[0]);\n    bool mouseJustBecameDown = !mouseWasDown && mouseIsDown;\n    \n    data[0] = float(mouseIsDown);\n    data[1] = float(mouseJustBecameDown);\n    data.zw = iMouse.xy;\n}\n\n// data.xy <- cumulative mousePos\n// data.zw <- raw last mousePos\nvoid trackMouse(inout vec4 data, in vec4 button) {\n    bool mouseIsDown = bool(button[0]);\n    bool mouseJustBecameDown = bool(button[1]);\n    vec2 mouse = button.zw;\n\n    vec2 home = p0 * iResolution.xy + 8.2 * iTime * v01.yx;\n    \n    if (iFrame == 0) {\n        data.xy = home;\n        data.zw = mouse;\n        return;\n    }\n\n    if (dot(iMouse.xy, iMouse.xy) < resetCircle * resetCircle) {\n        data.xy = mix(data.xy, home, 0.1);\n        data.zw = mouse;\n        return;\n    }\n    \n    if (!mouseIsDown) {\n        return;\n    }\n    \n    if (mouseJustBecameDown) {\n        data.zw = mouse;\n    }\n    \n    vec2 prevMouse = data.zw;\n    vec2 deltMouse = mouse - prevMouse;\n    \n    data.xy += deltMouse;\n    \n    for (int n = 0; n < 2; ++n) {\n        switch (wrap[n]) {\n            case 0u:\n                break;\n            case 1u:\n                // clamp\n                data[n] = clamp(data[n], 0.0, iResolution[n] - 1.0);\n                break;\n            case 2u:\n                // wrap\n                data[n] = mod(data[n], iResolution[n]);\n                break;\n        }\n    }\n    \n    data.zw = mouse;\n}\n\n// buffers are currently 100% broken on all browsers on iOS.\n// this provides a work-around so shaders can detect that.\nvoid trackHeartbeat(inout vec4 RGBA) {\n    RGBA.r = 1.0;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n    \n    RGBA = texelFetch(iChannel2, IJ, 0);\n    \n    if (iFrame == 0) {\n        RGBA = vec4(0);\n    }\n    \n    if (IJ == btn) {\n        trackButton(RGBA);\n        return;\n    }\n    \n    vec4 button = texelFetch(iChannel2, btn, 0);\n    \n    if (IJ == pos) {\n        trackMouse(RGBA, button);\n        return;\n    }\n    \n    if (IJ == hrt) {\n        trackHeartbeat(RGBA);\n        return;\n    }\n    \n    \n#if VISUALIZE    \n    vec4 mouse = texelFetch(iChannel2, pos, 0);\n    \n    vec2  p = XY;\n    float d = 1e9;\n    d = min(d, abs(length(p) - resetCircle));\n    float a = atan(p.y, p.x) * 20.0 - iTime;\n    d += smoothstep(-0.2, 0.2, sin(a));\n    d = min(d, abs(length(p - mouse.xy) - 20.0) - 2.0);\n    d = min(d, abs(length(p - mouse.zw) - 10.0) - 2.0);\n    float c = smoothstep(2.0, 0.0, d);\n    \n    RGBA.rgb = vec3(c);\n#else\n    discard;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}