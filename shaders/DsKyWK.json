{
    "Shader": {
        "info": {
            "date": "1696636970",
            "description": "Red is standard (second-order) finite differences, green is fourth order finite differences. Notice the decreased dispersion.",
            "flags": 32,
            "hasliked": 0,
            "id": "DsKyWK",
            "likes": 20,
            "name": "High-order FDTD",
            "published": 3,
            "tags": [
                "ripples",
                "grid",
                "wavelength",
                "finitedifferences",
                "waveequation",
                "fdtd",
                "yee"
            ],
            "usePreview": 0,
            "username": "athibaul",
            "viewed": 261
        },
        "renderpass": [
            {
                "code": "// Standard FDTD vs. fourth order FDTD\n\n// as described in\n// A Modified Equation Approach to Constructing Fourth Order Methods for Acoustic Wave Propagation\n// Shubin and Bell\n// SIAM 1987\n// https://doi.org/10.1137/0908026\n\n// Finite Difference Time-Domain (FDTD) methods are a family of numerical schemes\n// which allow to compute wave propagation on a regular grid.\n// They compute an approximate solution of the wave equation \n// by using approximate formulas for the partial derivatives.\n// The results therefore contain some errors, mostly in the form of \"dispersion\",\n// which manifests itself as a \"ripple\" effect.\n//\n// The most common version of FDTD uses second-order approximation in space and time using\n// five neighboring samples (the current pixel and its four neighbors).\n// This results in strong dispersion when fewer than about 20 points per wavelength are used.\n// The use of a finer grid allows to reduce this dispersion error, at an increased computational cost.\n//\n// Another way to reduce the dispersion error is to use higher-order methods.\n// Higher-order methods compute a more accurate approximation of the partial derivatives by looking\n// at more samples.\n// They allow to use fewer points per wavelength, at the cost of an increased number of operations\n// per point.\n//\n// The scheme implemented here is a fourth order FDTD, as described by Shubin and Bell in 1987.\n// The computation uses a 14-point stencil.\n//\n// The displayed graphics compare the two techniques: standard FDTD is shown in red,\n// whereas fourth-order FDTD is shown in green.\n// In the beginning they overlap; however, they very soon start to diverge, as numerical\n// dispersion spoils the results of the second-order method faster: this is indicated\n// by the presence of red ripples.\n//\n// Note that the simulation results depend on the screen resolution: higher resolution will\n// make both methods more accurate, so that it will take more time before they start to look\n// different. Conversely, at small resolutions, they will start differing almost instantly.\n\nMain {\n    float v4 = A(U).x;\n    float v2 = A(U).z;\n    \n    // Red is standard (second order), green is fourth order\n    vec4 col = vec4(100,0,0,0) * abs(v2) + vec4(0,100,0,0) * abs(v4);\n    Q = mix(vec4(0.5), col, isInDomain(uu(U)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 init(vec2 u) {\n    #if SETUP == 0\n    //u -= vec2(-1.0,0.62);\n    //return vec4(1) * exp(-1000.*dot(u,u)) * (u.x * u.y) * 3000.;\n    return vec4(1,1,1,1) * exp(-10000.*dot(u,u));\n    //return 0.1 * vec4(1) * exp(-5000.*u.x*u.x);\n    #elif SETUP == 1\n    vec2 v = u - vec2(-0.7-0.3,0.2);\n    vec4 Q = vec4(0,0,1,1) * exp(-8000.*dot(v,v));\n    v = u - vec2(0.7-0.3,0.2);\n    Q += vec4(1,1,0,0) * exp(-8000.*dot(v,v));\n    return Q;\n    #endif\n}\n\nMain {\n    Q = A(U);\n    \n    // This is the value of (c * Δt^2/Δx^2)\n    float dt2 = 0.5;\n    // Any number between zero and 0.5 may be used.\n    // Smaller values mean slower simulation, but do not make the simulation more accurate.\n    // On the contrary, the most accurate value to use is 0.5, for which\n    // the dispersion of the 2nd order scheme is minimal in the four diagonal directions\n    // (notice the directional pattern of the ripples).\n    \n    // Basic FDTD\n    {\n        float n = A(U+vec2(0,1)).z;\n        float s = A(U-vec2(0,1)).z;\n        float w = A(U-vec2(1,0)).z;\n        float e = A(U+vec2(1,0)).z;\n        float pn = Q.z;\n        float pnm1 = Q.w;\n\n\n        float p_next = 2.*pn - pnm1 + dt2 * (n+s+w+e - 4.*Q.z);\n        Q.z = p_next;\n        Q.w = pn;\n    }\n    \n    // Fourth-order FDTD\n    // as described in\n    // A Modified Equation Approach to Constructing Fourth Order Methods for Acoustic Wave Propagation\n    // Shubin and Bell\n    // SIAM 1987\n    // https://doi.org/10.1137/0908026\n    // It is based on a modified equation technique to compensate terms of the Taylor expansion\n    // up to the fourth order. \n    {\n        float n = A(U+vec2(0,1)).x;\n        float s = A(U-vec2(0,1)).x;\n        float w = A(U-vec2(1,0)).x;\n        float e = A(U+vec2(1,0)).x;\n        float pn = Q.x;\n        float pnm1 = Q.y;\n\n        float nn = A(U+vec2(0,2)).x;\n        float nw = A(U+vec2(-1,1)).x;\n        float ne = A(U+vec2(1,1)).x;\n        float ww = A(U+vec2(-2,0)).x;\n        float ee = A(U+vec2(2,0)).x;\n        float sw = A(U+vec2(-1,-1)).x;\n        float se = A(U+vec2(1,-1)).x;\n        float ss = A(U+vec2(0,-2)).x;\n\n        float D2xp = w - 2.*pn + e;\n        float D2yp = s - 2.*pn + n;\n        float D4xp = ww - 4.*w + 6.*pn - 4.*e + ee;\n        float D4yp = ss - 4.*s + 6.*pn - 4.*n + nn;\n        float D2xD2yp = sw + se + nw + ne - 2.*(s + w + n + e) + 4.*pn;\n        float p_next = 2.*pn - pnm1 + dt2 * (D2xp + D2yp) \n                      - dt2/12. * ( (1.-dt2) * (D4xp+D4yp) - 2.*dt2*D2xD2yp);\n\n\n        Q.y = pn;\n        Q.x = p_next;\n    }\n    \n    // Initial conditions or resolution change\n    if(iFrame == 0 || A(vec2(0)).xy != R) {\n        Q = init(uu(U));\n    }\n    \n    Q *= isInDomain(uu(U));\n    \n    if(floor(U) == vec2(0)) {\n        Q.xy = R;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texelFetch(iChannel0, ivec2(U), 0)\n#define R (iResolution.xy)\n#define uu(U) ((2.*U-R)/R.y)\n\n//#define FOURTH_ORDER\n\n#define SETUP 1\n\nfloat isInDomain(vec2 u) {\n    #if SETUP == 0\n    float rectangle = step(abs(u.x), 1.0) * step(abs(u.y), 0.618);\n    float obstacle = step(0.1, length(u - vec2(0.3,0.5)));\n    return rectangle;// * obstacle;\n    //return step(u.x, 1.618) * step(u.y, 1.0);\n    #elif SETUP == 1\n    u.x = abs(u.x) - 0.7;\n    return step(abs(u.x), 0.6) * step(abs(u.y), 0.6);\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}