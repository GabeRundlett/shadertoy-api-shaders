{
    "Shader": {
        "info": {
            "date": "1438214088",
            "description": "Windows10 wallpapar wip.\n\nOMG\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\n\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\nomg.",
            "flags": 0,
            "hasliked": 0,
            "id": "lllSR2",
            "likes": 75,
            "name": "w10",
            "published": 3,
            "tags": [
                "raymarching",
                "windows10",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "gyabo",
            "viewed": 265913
        },
        "renderpass": [
            {
                "code": "\n#define PI     3.1415926535897921284\n#define REP    25\n#define d2r(x) (x * PI / 180.0)\n#define WBCOL  (vec3(0.5, 0.7,  1.7))\n#define WBCOL2 (vec3(0.15, 0.8, 1.7))\n\n\nfloat hash( vec2 p ) {\n\tfloat h = dot( p, vec2( 127.1, 311.7 ) );\n\treturn fract( sin( h ) * 458.325421) * 2.0 - 1.0;\n}\n\nfloat noise( vec2 p ) {\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\tf = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix(\n\t\tmix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x ),\n\t\tmix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x ),\n\t\tf.y\n\t);\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n}\n\nfloat nac(vec3 p, vec2 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p.xy)-vec2(F),0.0)) - R;\t\n}\n\n\nfloat by(vec3 p, float F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(mod(p.xy, 3.0))-F,0.0)) - R;\t\n}\n\n\nfloat recta(vec3 p, vec3 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p)-F,0.0)) - R;\t\n}\n\n\nfloat map1(vec3 p, float scale) {\n\tfloat G = 0.50;\n\tfloat F = 0.50 * scale;\n\tfloat t =  nac(p, vec2(F,F), vec3( G,  G, 0.0));\n\tt = min(t, nac(p, vec2(F,F), vec3( G, -G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G,  G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G, -G, 0.0)));\n\treturn t;\n}\n\nfloat map2(vec3 p) {\n\tfloat t = map1(p, 0.9);\n\t//t = max(t, recta(p, vec3(1.0, 1.0, 0.02), vec3(0.0, 0.0, 0.0)));\n    t = max(t, recta(p, vec3(1.0, 1.0, 0.02), vec3(0.0, 0.0, 0.0)));\n\treturn t;\n}\n\n\n// http://glslsandbox.com/e#26840.0\nfloat gennoise(vec2 p) {\n\tfloat d = 0.5;\n\tmat2 h = mat2( 1.6, 1.2, -1.2, 1.6 );\n\t\n\tfloat color = 0.0;\n\tfor( int i = 0; i < 2; i++ ) {\n\t\tcolor += d * noise( p * 5.0 + iTime);\n\t\tp *= h;\n\t\td /= 2.0;\n\t}\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0.0);\n    for(int count = 0 ; count < 2; count++) {\n        vec2 uv = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n        uv *= 1.4;\n        uv.x += hash(uv.xy + iTime + float(count)) / 512.0;\n        uv.y += hash(uv.yx + iTime + float(count)) / 512.0;\n        vec3 dir = normalize(vec3(uv * vec2(iResolution.x / iResolution.y, 1.0), 1.0 + sin(iTime) * 0.01));\n        dir.xz = rot(dir.xz, d2r(70.0));\n        dir.xy = rot(dir.xy, d2r(90.0));\n        vec3 pos    = vec3(-0.1 + sin(iTime * 0.3) * 0.1, 2.0 + cos(iTime * 0.4) * 0.1, -3.5);\n        vec3  col   = vec3(0.0);\n        float t     = 0.0;\n        float M     = 1.002;\n        float bsh   = 0.01;\n        float dens  = 0.0;\n\n        for(int i = 0 ; i < REP * 24; i++) {\n            float temp = map1(pos + dir * t, 0.6);\n            if(temp < 0.2) {\n                col += WBCOL * 0.005 * dens;\n            }\n            t += bsh * M;\n            bsh *= M;\n            dens += 0.025;\n        }\n\n        //windows\n        t = 0.0;\n        float y = 0.0;\n        //for(int i = 0 ; i < REP * 50; i++)\n        for(int i = 0 ; i < REP; i++)\n        {\n            float temp = map2(pos + dir * t);\n            if(temp < 0.1) {\n                //col += WBCOL2 * 0.005;\n                col += WBCOL2 * 0.5;\n            }\n            t += temp;\n            y++;\n        }\n        col += ((2.0 + uv.x) * WBCOL2) + (y / (25.0 * 50.0));\n        col += gennoise(dir.xz) * 0.5;\n        col *= 1.0 - uv.y * 0.5;\n        col *= vec3(0.05);\n        col  = pow(col, vec3(0.717));\n        fragColor += vec4(col, 1.0 / (t));\n    }\n    fragColor /= vec4(2.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}