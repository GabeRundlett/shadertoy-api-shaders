{
    "Shader": {
        "info": {
            "date": "1498318249",
            "description": "Simple fractal object, constructed with mild alterations to the standard repeat Menger Sponge formula.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldScRt",
            "likes": 49,
            "name": "Menger Variation 2",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "reflection",
                "menger",
                "sponge",
                "gloss"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1778
        },
        "renderpass": [
            {
                "code": "/*\n\n    Menger Sponge Variation\n    -----------------------\n\n\tThis is just a variation on my Menger Sponge example. I put in some rounded corners,\n\tbracing, better lighting and some post processing effects. It was just an excuse to\n\tmake something artsy, so not that exciting.\n\n\tIt seems to take a while to compile. The reflection pass would add to things, but it\n\tfeels more like a WebGL 2 thing... Yeah, I know, only bad programmers blame their tools. :D\t\n\n\tFor anyone who's never put a Menger Sponge together, here's a very, very short, overly \n\tgeneralized explanation:\n\t\n\tConstruct a Void Cube (or repeat Void Cubes, as the case may be), which is analogous \n\tto a Rubix Cube with the center mechanism removed. Create Void Cubes from the 20 cubies \n\t(the remaining smaller cubes), and continue to iterate ad infinitum.\n\t\n\tIn code:\n\n\t// Repeat Void Cubes - A Void Cube is a Level-1 Menger Sponge.\n\tfloat map(vec3 p){\n    \tp = abs(mod(p, 3.) - 1.5); // Repeat space.\n    \treturn min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.; // Void Cube.\n\t}\n\n\t// More than one level Menger Sponge - Infinitely repeated, in this case.\n\tfloat map(vec3 q){\n        \n\t\tvec3 p; float d = 0.;\n        \n        // One Void Cube.\n    \tp = abs(mod(q, 3.) - 1.5);\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.);\n\n        // Subdividing into more Void Cubes.    \n    \tp = abs(mod(q, 1.) - 0.5); // Dividing above by 3.\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3.);\n        \n        // And so on.\n    \tp = abs(mod(q, 1./3.) - 0.5/3.); // Dividing above by 3.\n    \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3./3.);\n        \n\t\t// Continue on in this manner. For more levels, you'll want to loop it. There's\n\t\t// a commented out example in the code somewhere. Also, you can experiment with \n\t\t// the code to create more interesting variants.\n\n\t\treturn d;\n\t}\n\t\n\tFor a more formal explanation, look up \"Menger Sponge,\" \"Cantor Sets,\" \"Void Cube,\" \n\tetc., on the web, or better yet, refer to the countless Menger Sponge examples\n\ton this site.\t\n\n\tExamples:\n\n\tMenger Journey - Syntopia (A favorite of mine, and everyone else.)\n\thttps://www.shadertoy.com/view/Mdf3z7\n\n*/\n\n\n#define FAR 50. // Maximum ray distance. Analogous to the far plane.\n\n#define BRACING // Chrome bracing or no bracing. Obviously, faster without it.\n\n\n// Scene object ID. Either the Menger object (1) or the chrome bracing (0).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\nfloat hash(float n){ return fract(sin(n)*43758.5453); }\n\n// Fabrice's consice, 2D rotation formula.\n//mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float t){ \n\n    return vec2(0);\n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec2(s*4., 0.);\n    \n    float a = sin(t*.11);\n    float b = cos(t*.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5);\n    \n    //return vec2(sin(t*.15)*2.4, cos(t*.25)*1.7*.5); \n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n     \n    //p.xy *= r2(p.z*zRot);\n    //n.xy *= r2(p.z*zRot);    \n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7., 157., 113.);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    //p = p*p*(3. - 2.*p);\n    p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n\n// Variation on a Menger Sponge (See the formula above). This one has four layers. The \n// easiest way to understand this is to comment out layers, then add them back in to \n// see what each does.\nfloat map(vec3 q){\n    \n\n    q.xy -= path(q.z); // Wrap the object around the path.\n\n    \n    // Layer one. The \".05\" on the end varies the hole size.\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .03;\n    \n    ///////////\n    // Chrome bracing section.\n    #ifdef BRACING\n    float tb;\n    \n    float rp = 3.;\n    p = abs(fract(q/rp + .5)*rp - rp/2.);\n    float x1 = sqrt(min(dot(p.xy, p.xy),min(dot(p.yz, p.yz),dot(p.xz, p.xz))))-rp/2.*.475; // EQN 2\n\n    \n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    rp = 3./15.;\n    p = abs(fract(q/rp)*rp - rp/2.);\n    p = abs(p - rp/2.);\n    float x2 = min(p.x, min(p.y,p.z)) - .0125; // EQN 1\n    \n\n    // Combining the two entities above.\n    tb = smax(abs(x1), abs(x2), .1) - .035; \n    #endif\n    /////////////\n    \n \n    \n    // Layer two.\n    p =  abs(fract(q) - .5);    \n \td = smax(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05, .05);\n    \n   \n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    p =  abs(fract(q*2.)*.5 - .25);\n \td = max(d, min(smax(p.x, p.y, .125), min(smax(p.y, p.z, .125), smax(p.x, p.z, .125))) - .5/3. - .025); \n\n    // Layer four. The little holes, for fine detailing.\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\n    //d = max(d, max(max(p.x, p.y), p.z) - 1./18. - .024);\n    //d = max(d, length(p) - 1./18. - .048);\n    \n    #ifdef BRACING\n    objID = step(d, tb);\n    return min(d, tb);\n    #else\n    objID = 0.;\n    return d;\n    #endif\n    \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;//.001*(t*.125 + 1.)\n        \n        t += d; // Using slightly more accuracy in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<48; i++){\n\n        d = map(ro + rd*t);//*rDir;\n        \n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n// Another pass, which is the first, and only, refracted bounce. \n// Virtually the same as above, but uses a slimmed down distance function - due\n// to the fact that the water plane doesn't need to be included.\nfloat traceRefr(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<48; i++){\n\n        d = map(ro + rd*t);\n        \n        if((d<0. && abs(d)<0.001*(t*.25 + 1.)) || t>FAR) break;\n        \n        t += -d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0025*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .2); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit.\n    return min(max(shade, 0.) + .2, 1.); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. \n// Due to the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n \n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(3./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n     \n    // Wider sample spread for the curvature.\n    //e = vec2(12./450., 0);\n\t//d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\t//d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\t//d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n \n    \n    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n*/\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nfloat getEdge(in vec3 p, in vec2 e) { \n\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(0, iFrame); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n        \n    float d = map(p)*2.;\n\n    float edge = abs(mp[0] + mp[1] - d) + abs(mp[2] + mp[3] - d) + abs(mp[4] + mp[5] - d);\n    //edge = abs(mp[0] + mp[1] + mp[2] + mp[3] + mp[4] + mp[5] - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    return edge;\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNrm(in vec3 p, in vec2 e) {\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(0, iFrame); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Normal calculation, with some edging and curvature bundled in.\n//\n// Addendum: I've rewritten this in a very contrived and ugly form to \n// appease the compiler. It seems to work, but I still don't like it. :)\nvec3 getNormal(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    \n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(3./iResolution.y*(1. + t*.5), 0);\n    \n    edge = getEdge(p, e);\n/*   \n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n    \n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    */\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.\n    /*\n    d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n    */\n    \n    return getNrm(p, e);\n}\n\n/*\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormalRefr(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(3./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n   \n    // Wider sample spread for the curvature.\n    //e = vec2(12./450., 0);\n\t//d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\t//d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\t//d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n\n    \n    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n*/\n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    // Object texture color.\n\n    // Contorting the texture coordinates to math the contorted scene.\n    vec3 txP = p - vec3(path(p.z), 0.);\n    \n    // Grab the texel for the hit point.\n    vec3 tx = tex3D(iChannel0, txP/1., n);\n    tx = mix(tx, vec3(1)*dot(tx, vec3(.299, .587, .114)), .25);\n    tx = smoothstep(0., 1., tx); // Ramp up the color.\n\n    vec3 lCol = vec3(1.25, 1, .75);\n    \n    \n    // Darken part of the sponge object, and color up the rest.\n    vec3 q = abs(mod(txP, 3.) - 1.5);\n    if (max(max(q.x, q.y), q.z) > 1.063) tx *= lCol;\n    else tx *= vec3(1., .75, .5);\n    \n    // Shine up the bracing.\n    #ifdef BRACING\n    if(svObjID<.5) tx *= 5./vec3(1.25, 1, .75);\n    #endif\n    \n    //tx *= vec3(1.2, 1, .8); // Golden hue. \n\n    \n    return tx; // Return the object color.\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float edge, float crv, float ao, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 2./(1. + lDist*0.125 + lDist*lDist*0.025);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.        \n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + .6*ao + fres*fres) + vec3(1, .7, .5).zyx*spec*2.;\n        \n        // Edges and curvature.\n        //sceneCol *= clamp(crv, 0., 1.);\n        //sceneCol += (sceneCol*.75 + .25)*edge;\n        sceneCol *= 1. - edge*.9;\n        \n\n        // Attenuation only. To save cycles, the shadows and ambient occlusion\n        // from the first pass only are used.\n        sceneCol *= atten;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    return getObjectColor(rd, sn);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n\n   \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0, 1, 0);\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path, which is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    //rd.xy *= r2(ro.z*zRot);\n    rd.xy *= r2(iTime/4.);\n    rd.xz *= r2(iTime/4.);\n    \n    // Edge and curvature variables. Passed to the normal functions... The refraction\n    // pass has seperate normal function.\n    float edge = 0., crv = 1.;\n\n    \n    \n    // FIRST PASS.\n    //\n    float t = trace(ro, rd); // Trace.\n\n    // Save the object IDs after the first pass.\n    svObjID = objID;\n    float oSvObjID = svObjID;\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Retrieving the normal at the hit point, plus the edge and curvature values.\n    vec3 sn = getNormal(sp, edge, crv, t);\n\n    \n    // Fresnel. Handy for all kinds of aesthetic purposes. Not used here.\n    //float fr = clamp(1. + dot(rd, sn), 0., 1.);\n    \n    // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n    // right without them.\n    float sh = softShadow(sp + sn*.002, lp, 16., t); // Set to \"1.,\" if you can do without them.\n    float ao = calculateAO(sp, sn);\n    sh = (sh + ao*.3)*ao;\n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(sp, rd, sn, lp, edge, crv, ao, t);\n    \n\n    // Fog - based off of distance from the camera. This will be applied at the end.\n    float fog = smoothstep(0., .95, t/FAR);\n    \n    \n    // Cheap and nasty alternative, if not using the reflection pass.\n    //sceneColor += eMap(reflect(rd, sn)/2., sn);\n   \n   \n    // SECOND PASS\n    \n    // Reflected and refracted rays.\n    vec3 refl = reflect(rd, sn); // Standard reflection.\n    //vec3 refr = refract(rd, sn, 1./1.33); // Water refraction. Note the inverted index.\n    \n    // We're branching off from the same spot in two directions, so we'll use this so as\n    // not to interfere with the original surface point vector, \"sp.\" It was a style\n    // choice on my part, but there are other ways.\n    vec3 refSp; \n    \n    // REFLECTED PASS\n    //\n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n\n\n    // The ray is edged off the surface, as required, but note that it has to be enough\n    // to avoid conflict with the break condition in the \"reflected\" trace algorithm.\n    t = traceRef(sp + refl*0.005*(t*.125 + 1.), refl);\n\n    // Save the object IDs after the second pass.\n    svObjID = objID;\n    oSvObjID = svObjID; \n    \n    \n    // Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n    refSp = sp + refl*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(refSp, edge, crv, t);\n    //sn = getNormal(refSp);//*rDir;\n    //edge = 0.;\n \n    // Color at the reflected hit point.\n    vec3 reflColor = doColor(refSp, refl, sn, lp, edge, crv, 1., t);\n    sceneColor = sceneColor + reflColor*.5 ;\n    //sceneColor = sceneColor*.5 + mix(reflColor, sceneColor, fr*fr*.66 + .34);\n    \n\n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway.\n    sceneColor *= sh;\n    \n    \n    // APPLYING FOG\n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fogCol = vec3(.7, .8, 1.)*(rd.y*.5 + .5)*2.5;\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy //pow(fogCol, vec3(1.33))*1.66\n    \n    \n    // POSTPROCESSING\n    // Interesting red to blueish mix.\n    sceneColor = mix(sceneColor, pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)), uv.y);\n    //sceneColor = pow(max(sceneColor, 0.), vec3(1.33))*1.66; // Adding a bit of contrast.\n    //sceneColor *= vec3(1.2, 1, .8);\n    \n    //vec2 u2 = uv*r2(3.14159/6.);\n    //float overlay = 1. + .4*sin(u2.x*3.14159*iResolution.y/1.5);\n    //overlay *= 1. + .4*sin(u2.y*3.14159*iResolution.y/1.5); \n    //sceneColor *= overlay;\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.5 + .5;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)).zyx, sceneColor, \n                    // pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n\n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}