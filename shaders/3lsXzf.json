{
    "Shader": {
        "info": {
            "date": "1563834280",
            "description": "This has behavioral characteristics similar to triangle noise created by Nimitz. Though more expensive it's covered under MIT so it's commercial friendly! The base noise looks like intertwined lightning strikes! :) It's a chain-link fence of sine fBms ;)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsXzf",
            "likes": 51,
            "name": "Lightning noise!",
            "published": 3,
            "tags": [
                "noise",
                "triangle",
                "lightning",
                "pattern",
                "auroras"
            ],
            "usePreview": 0,
            "username": "toomuchvoltage",
            "viewed": 2073
        },
        "renderpass": [
            {
                "code": "#define DISPLAY_SCALE 1.0\n\n/*****************************************************************************\n   We're using 2D Triangle noise as our reference.\n\n\n   Copied from here: https://www.shadertoy.com/view/XtGGRt\n\n   Auroras by nimitz 2017 (twitter: @stormoid)\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   Contact the author for other licensing options\n\n******************************************************************************/\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(iTime*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.0),0.,.55);\n}\n\n/*****************************************************************************\n   And this is my noise... I dub this: 'lightning noise'.\n   The main two things to get right were the motion and the noisy fins!\n\n   Covered under the MIT license:\n\n   Copyright (c) 2019 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n   Hit me up!\n\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n******************************************************************************/\n\nmat2 rotate(in float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat lightningNoise (vec2 forPos)\n{\n    forPos *= 4.0;\n    forPos.y *= 0.85;\n    float wobbleAmount1 = sin(forPos.y) * 0.5 + sin(forPos.y * 2.0) * 0.25 + sin(forPos.y * 4.0) * 0.125 + sin(forPos.y * 8.0) * 0.0625;\n    float wobbleAmount2 = sin(forPos.x) * 0.5 + sin(forPos.x * 2.0) * 0.25 + sin(forPos.x * 4.0) * 0.125 + sin(forPos.x * 8.0) * 0.0625;\n    float horizontalStrike = 1.0 - abs(sin(forPos.x + wobbleAmount1 * 1.1));\n    float verticalStrike = 1.0 - abs(cos(forPos.y + wobbleAmount2 * 1.1));\n    return (horizontalStrike + verticalStrike) * 0.35;\n}\n\nfloat fBm (in vec2 uv)\n{\n    float amp = 0.5;\n    float res = 0.0;\n    for (int i = 0; i < 5; ++i) {\n        res += amp * lightningNoise(uv);\n        uv *= 2.0;\n        amp *= 0.5;\n    }\n    return res;\n}\n\nfloat domainWarp (in vec2 uv)\n{\n    mat2 rotMat = rotate(0.1);\n    float v1 = fBm(rotMat * uv + 0.02 * iTime);\n    uv = rotMat * uv + 1.0;\n    float v2 = fBm(uv - 0.02 * iTime);\n    uv = rotMat * uv + 1.0;\n    float v3 = fBm(uv + 0.02 * iTime);\n    uv = rotMat * uv + 1.0;\n    float v4 = fBm(uv - 0.02 * iTime);\n    float finalRes = fBm (vec2 (fBm(vec2 (v1,v2)), fBm(vec2 (v3,v4))));\n    return clamp (pow (1.0 - finalRes, 10.0) * lightningNoise (rotate (0.02 * iTime) * uv) * 10.0, 0.0, 0.55);\n}\n\n/*****************************************************************************\n   And finally a modified version of Nimitz's Auroras: https://www.shadertoy.com/view/XtGGRt\n   That uses our noise instead! :) ... just to see it in action really...\n\n   Auroras by nimitz 2017 (twitter: @stormoid)\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   Contact the author for other licensing options\n******************************************************************************/\n\n#define time iTime\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<50.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = domainWarp(p);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*15.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n//-----------------------------------------------------------\n\n\nvoid aurorasWithLightningNoise( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\n        col += stars(rd);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n    else //Reflections\n    {\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.6;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = domainWarp(pos.xz*vec2(.5,.7));\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n    }\n    \n\tfragColor = vec4(col, 1.);\n}\n\n/**************************************************\n    This part is just captain planet\n***************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord/iResolution.xy) * 4.0 - 2.0) * DISPLAY_SCALE;\n    float xOnScreen = fragCoord.x / iResolution.x;\n    float yOnScreen = fragCoord.y / iResolution.y;\n    \n    if (xOnScreen < 0.33333 )\n    {\n        if ( yOnScreen < 0.5 )\n\t\t    fragColor = vec4(vec3 (triNoise2d (uv, 0.4)),1.0);\n        else\n\t\t    fragColor = vec4(vec3 (domainWarp (uv)),1.0);\n    }\n    else\n        aurorasWithLightningNoise (fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}