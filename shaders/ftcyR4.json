{
    "Shader": {
        "info": {
            "date": "1659297205",
            "description": "Corrected test frame for animated 2d primitives and different 2d & 3d backgrounds. \nChange background animation by pressing mouse button at different x positions. \nY position of mouse changes the background speed and direction.\nIs this shader useful 4 u ?",
            "flags": 0,
            "hasliked": 0,
            "id": "ftcyR4",
            "likes": 1,
            "name": "Fork 2d-Primiti clonedpupp 194",
            "published": 3,
            "tags": [
                "2d",
                "line",
                "circle",
                "primitives",
                "rectangle",
                "disc",
                "frame",
                "backgrounds"
            ],
            "usePreview": 0,
            "username": "ClonedPuppy",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "\n//---------------------------------------------------------\n// Shader: 2dPrimitives.glsl by gPlatl\n//         v1.0  2015-09-13  initial release\n//         v1.1  2016-02-14  added primitives\n//         v1.2  2016-03-30  circleBox added\n//         v1.3  2016-08-15  line & line segment added\n//         v1.4  2016-09-09  circle2 & ring2 added\n//         v1.5  2017-03-05  code corrections\n//         v1.6  2017-03-15  donjon tunnel added\n//         v1.7  2017-10-29  rotateCCW added\n//               2018-12-17  working on...  \n// Tags:   2d, primitives, line, disc, circle, rectangle, frame, backgrounds \n// Test frame for animated 2d primitives and different 2d & 3d backgrounds.\n// Change background by pressing mouse button on different x positions.\n// Y position of mouse changes the background speed and direction.\n// Note:     Will be enhanced from time to time...\n// see also: http://glslsandbox.com/e#26010\n//           https://www.shadertoy.com/view/XtjGzt\n//           https://www.shadertoy.com/view/lsy3zz\n//           https://iquilezles.org/articles/distfunctions2d\n//---------------------------------------------------------\n\nconst float HALF_PI = 1.57079632679;\nconst float      PI = 3.14159265359;\nconst float  TWO_PI = 6.28318530718;\n\nvec2 uv = vec2(0);  // centered pixel position -1 .. 1\n\n#define BACKGROUNDS 7\n\n//---------------------------------------------------------\n// get moving background texture\n//---------------------------------------------------------\n#define TILES_COUNT_X 4.0\n#define TILES_COUNT_Y 3.0\nvec3 BackgroundColor (vec2 position, sampler2D tilesTexture, vec2 resolution)\n{\n  //vec2 p = TILES_COUNT_X * position.xy / resolution.x;\n  vec2 p = TILES_COUNT_Y * position.xy / resolution.y;\n  return texture (tilesTexture, p).xyz;\n}\n//---------------------------------------------------------\n// get pseudo 3d bump background\n//---------------------------------------------------------\nvec3 BumpyBackground (vec2 pos, sampler2D aTexture, float time)\n{\n  #define ANIMATE_TEXTURE true\n  #define LINEAR_STEPS 20.0\n  #define DISTANCE 0.16\n  #define FEATURES 0.5\n\n  vec3 color;\n  vec2 dir = 0.6*vec2(pos - vec2(0.5, 0.5)) * (DISTANCE / LINEAR_STEPS);\n  if (ANIMATE_TEXTURE)\n    pos += time * vec2(0.3, 1e-5* sin(time));\n    \n  for (float i = 1.0; i < LINEAR_STEPS; i++) \n  {\n    vec3 pixel1 = texture(aTexture, pos - i * dir).xyz;\n      \n      \n    if (pow(length(pixel1) / 1.4, 0.20) * (1.0 - FEATURES)\n       +pow(length(texture(aTexture, (pos - i * dir) * 2.0).rgb) / 1.4, 0.90) * FEATURES\n       > i / LINEAR_STEPS) \n    color = pixel1 * i / LINEAR_STEPS;\n    //color += 0.16 * pixel1 * i / LINEAR_STEPS;\n  }\n  return color;\n}\n//---------------------------------------------------------\n// perspective ground texture\n//---------------------------------------------------------\nvec3 BaseGround (vec2 pos, sampler2D tilesTexture, float atime)\n{\n  vec3 camera = vec3(atime, 1.0, atime);\n  vec3 raydelta = vec3(sin(pos.x)\n                      ,abs(sin(pos.y)-0.88)\n                      ,cos(pos.x));\n  vec3 mapped = raydelta * (camera.y / raydelta.y) + camera;\n  vec3 col = vec3(texture( tilesTexture, mapped.xz ));\n//  col *= abs(pos.y - 1.0);  // darkness based on the horizon\n  return col;\n}\n//---------------------------------------------------------\n// pipe tunnel with 1 texture\n//---------------------------------------------------------\nvec3 PipeTunnel (vec2 pos, sampler2D tilesTexture, float atime)\n{\n  float a = atan(pos.y, pos.x) / HALF_PI;\n  float r = sqrt(dot(pos, pos));\n  vec2 k = mod(vec2(atime + 1.0 / r, a), 1.0);\n  return r * texture(tilesTexture, k).xyz;\n}\n//---------------------------------------------------------\n// donjon tunnel with 2 textures\n//---------------------------------------------------------\nvec4 DonjonTunnel(vec2 p, float aTime)\n{\n    // p.y += sin(aTime) * 0.15;   // up/down\n    float a = atan(p.x,p.y) / HALF_PI;\n    p.x = abs(p.x);\n    float d = max(max(p.x,abs(p.y)), min(p.x+p.y, length(p)));\n    vec2 k = vec2(a, 1.2/d + aTime);  \n    if (d > p.x && (d > p.x+p.y))\n      return texture(iChannel3, k) * d;    // ground\n    return texture(iChannel0, k) * d;      // wall\n}\n//---------------------------------------------------------\n// square tunnel with 3 textures\n//---------------------------------------------------------\nvec3 SquareTunnel(vec2 p, float atime)\n{\n  float r = pow(pow(p.x*p.x,6.0) + pow(p.y*p.y,6.0), 1.0/16.0);\n  vec2 pp = 2.0 * vec2 (atime + 1.0/r, atan(p.y,p.x)/3.1416);\n\t\n  vec3 col = vec3(0);\n  if (p.y > 0.0)\n    col = texture(iChannel1, pp).rgb; \n  else col = texture(iChannel0, pp).rgb;\n  col = mix( col, texture(iChannel2, pp).rgb, smoothstep(0.9,1.1,abs(p.x/p.y) ) );\n  return vec3( col*r);\n}\n\n\n//=== 2d geometric primitives ===\n\n// y position ranges from -1.0 .. +1.0\n\n// functions return intensity (0.0 .. 1.0) with antialiased edges\n\n//---------------------------------------------------------\n// draw endless line through point A and B with radius r\n//---------------------------------------------------------\nfloat line(vec2 P, vec2 A, vec2 B, float r)\n{\n  vec2 g = B - A;\n  float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));\n  return smoothstep(r, 0.5*r, d);\n}\n\n//---------------------------------------------------------\n// draw segment line from point A to point B and radius r\n// see also sdCapsule(p,a,b,r) from inigo quilez\n// https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------\nfloat segment(vec2 P, vec2 A, vec2 B, float r)\n{\n  vec2 g = B - A;\n  vec2 h = P - A;\n  float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n  return smoothstep(r, 0.5*r, d);\n}\n//---------------------------------------------------------\nfloat segment2(vec2 P, vec2 A, vec2 B, float r)\n{\n  float d = length((P-=A)-(B-=A)*clamp(dot(P,B)/dot(B,B), 0.0, 1.0 ));\n  return smoothstep(r, 0.5*r, d);;   \n}\n\n//---------------------------------------------------------\n// draw rectangle at pos(-1..+1) with given size\n//---------------------------------------------------------\nfloat rectangle(vec2 pos, vec2 size)\n{\n  size *= 0.5;\n  vec2 r = abs(uv - pos - size) - size;\n  return step( max(r.x,r.y),0.0);\n}\n//---------------------------------------------------------\n// draw rectangle at pos with given size\n//---------------------------------------------------------\nfloat rectangle2(vec2 pos, vec2 size)\n{\n  return (step(pos.x, uv.x)         - step(pos.x + size.x,uv.x))\n       * (step(pos.y - size.y,uv.y) - step(pos.y, uv.y));\n}\n//---------------------------------------------------------\n// draw rounded rectangle\n//---------------------------------------------------------\nfloat roundedRectangle (vec2 pos, vec2 size, float radius, float thickness)\n{\n  float d = length(max(abs(uv - pos),size) - size) - radius;\n  return smoothstep(0.66, 0.33, d / thickness * 5.0);\n}\n//---------------------------------------------------------\n// draw rectangle frame with rounded edges\n//---------------------------------------------------------\nfloat roundedFrame (vec2 pos, vec2 size, float radius, float thickness)\n{\n  float d = length(max(abs(uv - pos),size) - size) - radius;\n  return smoothstep(0.55, 0.45, abs(d / thickness) * 5.0);\n}\n//---------------------------------------------------------\n// draw circle at pos with given radius\n//---------------------------------------------------------\nfloat circle(vec2 pos, float radius)\n{\n    float d = length(uv-pos);\n    return smoothstep(d,d+0.01,radius);\n}\n//---------------------------------------------------------\n// draw circle at pos with given radius and halo\n//---------------------------------------------------------\nfloat circle(vec2 pos, float radius, float halo)\n{\n  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);\n}\n//---------------------------------------------------------\nfloat circle2(vec2 pos, float radius, float halo)\n{\n  return clamp(((1.0-(length(uv-pos)-radius))-0.99)*100.0, 0.0, 1.0);   \n}\n\n//---------------------------------------------------------\n// interpolation between a circle and a box with rounded corner\n//---------------------------------------------------------\nfloat circleBox(vec2 pos            // position\n               ,vec2 size           // shape size\n               ,float cornerRadius  // radius of rounded box corner\n               ,float between)      // interpolation value: 0.0 .. 1.0\n{\n  float sd = (length(uv-pos) - size.x); // circle\n  size -= vec2(cornerRadius);           // rounded box\n  vec2 d = (abs(uv-pos) - size);\n  float box = min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - cornerRadius;\n  float v = (1.0 - between)*sd + box*between;  //mix\n  return clamp (-88.0*v , 0.0, 1.0);\n}\n\n//---------------------------------------------------------\n// return 2d rotation matrix\n//---------------------------------------------------------\nmat2 rotate2D(float angle)\n{\n  float c = cos(angle), s = sin(angle);\n  return mat2(c, s, -s, c);\n}\n//---------------------------------------------------------\n// return point p rotated with given angle\n//---------------------------------------------------------\nvec2 rotateCCW (vec2 pos, float angle)\n{ \n  float ca = cos(angle),  sa = sin(angle);\n  return pos * mat2(ca, sa, -sa, ca);  \n}\n\n//---------------------------------------------------------\n// squircle: a variable shape (star..rectangle..circle)\n// http://en.wikipedia.org/wiki/Squircle\n//---------------------------------------------------------\nfloat squircle(vec2 pos, float radius, float power)\n{\n  vec2 p = abs(pos - uv) / radius;\n  float d = (pow(p.x,power) + pow(p.y, power) - pow(radius, power)) -1.0;\n  return 1.0 - clamp (16.0*d, 0.0, 1.0);\n}\n//---------------------------------------------------------\n// draw ring at given position\n//---------------------------------------------------------\nfloat ring(vec2 pos, float radius, float thick)\n{\n  return mix(1.0, 0.0, smoothstep(thick, thick + 0.01, abs(length(uv-pos) - radius)));\n}\n//---------------------------------------------------------\nfloat ring2(vec2 pos, float radius, float thick)\n{\n  return clamp((thick-abs(length(uv-pos) - radius))*100.0, 0.0, 1.0); \n}\n//---------------------------------------------------------\n// draw ring at pos \n//---------------------------------------------------------\nfloat haloRing(vec2 pos, float radius, float thick)\n{\n  return clamp(-(abs(length(uv-pos) - radius) * 100.0 / thick) + 0.9, 0.0, 1.0);\n}\n//---------------------------------------------------------\n// draw polygon with n edges at pos \n//---------------------------------------------------------\nfloat polygon(vec2 pos, float n, float radius)\n{\n  vec2 p = pos;\n  float angle = atan(p.x, p.y) + PI;\n  float r = TWO_PI / n;\n  float d = cos(floor(0.5 + angle / r) * r - angle) * length(p) / radius;\n  return smoothstep(0.41,0.4,d);\n}\n\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = iTime;\n  vec2 pos, size;\n  vec2 npos = fragCoord.xy / iResolution.xy;   // 0.0 .. 1.0\n  \n  // get uv position with origin at window center\n  float aspect = iResolution.x / iResolution.y;   // aspect ratio x/y\n  vec2 ratio = vec2(aspect, 1.0);                 // aspect ratio (x/y,1)     \n  uv = (2.0 * npos - 1.0) * ratio;             // -1.0 .. 1.0\n    \n  vec2 mpos = iMouse.xy / iResolution.xy;      //  0.0 .. 1.0\n  vec2 mp = (2.0 * mpos - 1.0) * ratio;        // -1.0 .. 1.0  \n  float speed = (mpos.y - 0.4) * time;    \n    \n  vec3 col;\n  int selection = int((iMouse.x / iResolution.x) * float(BACKGROUNDS));\n    \n  if      (selection == 6)   \n    col = BackgroundColor(fragCoord, iChannel0, iResolution.xy);\n    \n  else if (selection == 5)\n    col = BackgroundColor(fragCoord+vec2(-180.0*speed,0.0), iChannel0, iResolution.xy);\n      \n  else if (selection == 4)\n    col = BumpyBackground (uv, iChannel2, 4.0 * speed);\n\n  else if (selection == 3)\n    col = BaseGround(npos, iChannel1, speed);\n\n  else if (selection == 2)\n    col = PipeTunnel(uv, iChannel1, speed);\n     \n  else if (selection == 1)\n    col = DonjonTunnel (uv, speed).rgb;\n\n  else\n    col = SquareTunnel(uv, speed);\n\n  float intensity = 0.0;\n      \n  //--- line --- \n  pos = vec2(-0.5*sin(time), 0.0);\n  const vec3 lineColor1 = vec3(0.1, 0.4, 0.7);\n  intensity = line (uv, pos, mp, 0.016);\n  if ((intensity > 0.0) && (intensity <= 1.0))\n    col = mix(col, lineColor1, intensity);\n    \n  //--- line segment --- \n  const vec3 lineColor2 = vec3(0.9, 0.9, 0.2);\n  intensity = segment (uv, pos, mp, 0.02);     \n  if ((intensity > 0.0) && (intensity <= 1.0))\n    col = mix(col, lineColor2, intensity);\n    \n  //--- green rectangle ---\n  const vec3 rectangleColor = vec3(0.2, 0.8, 0.5);\n  intensity = 0.6 * rectangle (vec2(sin(time),-0.9),vec2(0.5, 0.1));\n  col = mix(col, rectangleColor.rgb, intensity);\n\n  //--- rounded rectangle ---\n  const vec3 rectColor = vec3(0.1, 0.8, 0.5);\n  pos = vec2(-sin(time), 0.6);\n  size = vec2(0.16, 0.02);\n  intensity = 0.6 * roundedRectangle (pos, size, 0.1, 0.2);\n  col = mix(col, rectColor, intensity);\n    \n  //--- rounded frame ---\n  const vec3 frameColor = vec3(0.5, 0.3, 0.6);\n  size = vec2(0.28, 0.10);\n  intensity = roundedFrame (pos, size, 0.08, 0.2);\n  col = mix(col, frameColor, intensity);\n    \n  //--- red dot ---\n  const vec3 circleColor2 = vec3(0.6, 0.2, 0.2);\n  vec2 redPos = vec2(-0.5*sin(time), 0.0);\n  intensity = circle(redPos, 0.05, 100.0);\n  col = mix(col, circleColor2, intensity);\n\n  //--- mouse dot ---\n  if (iMouse.z > 0.0)\n  {\n    const vec3 circleColorM = vec3(1.6, 1.2, 0.6);\n    intensity = circle(mp, 0.05, 100.0);\n    col = mix(col, circleColorM, intensity);\n  }\n\n  //--- yellow circle ---\n  const vec3 circleColor = vec3(1, 0.8, 0.3);\n  intensity = circle(vec2(sin(time), 0.6), 0.2);\n  //intensity = circle(vec2(sin(time), 0.6), 0.2, 6.);\n  col = mix(col, circleColor, intensity);\n\n  //--- violet circleBox ---\n  const vec3 cbColor = vec3(0.5, 0.3, 0.8);\n  pos = vec2(-sin(time), -0.6);\n  float between = 0.5+0.5*sin(time);  // mix value\n  size = vec2(0.15, 0.10);\n  intensity = 0.8 * circleBox(pos, size, 0.02, between);\n  col = mix(col, cbColor, intensity);\n  \n  //--- brown squircle ---\n  const vec3 sqColor = vec3(0.8, 0.5, 0.3);\n  pos = vec2(1.3, 0.6*sin(time+HALF_PI));\n  float power = 0.8 + 2.0*(1.0+sin(time));\n  intensity = 0.9 * squircle (pos, 0.1, power);\n  if (intensity > 0.0) \n    col = mix(col, sqColor, intensity);\n  \n  //--- pink ring ---\n  vec3 ringColor = vec3(0.9, 0.4, 0.6);\n  pos = vec2(0.5*sin(time), 0.0);\n  intensity = ring2(pos, 0.2 +0.05*sin(time), 0.04);\n  if (intensity > 0.0) \n    col = mix(col, ringColor, intensity);\n  \n  //--- haloRing ---\n  ringColor = vec3(1.0, 1.0, 1.5);\n  intensity = haloRing (vec2(-sin(time), 0.0), 0.3, 6.0);\n  col = mix(col, ringColor, intensity);\n  \n  //--- polygon ---\n  const vec3 polygonColor = vec3(0.5, 0.9, 0.3);\n  pos = vec2(sin(time), -0.5);\n  pos = rotateCCW(uv - pos,time);\n  float n = floor (6.0 + 3.0 * sin(time));\n  intensity = 0.8 * polygon(pos,n, 0.4);\n  col = mix(col, polygonColor.rgb, intensity);\n    \n  fragColor = vec4 (col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}