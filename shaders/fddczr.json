{
    "Shader": {
        "info": {
            "date": "1652990602",
            "description": "jhb",
            "flags": 0,
            "hasliked": 0,
            "id": "fddczr",
            "likes": 2,
            "name": "Raytracing 1 owo",
            "published": 3,
            "tags": [
                "rtx"
            ],
            "usePreview": 0,
            "username": "vainstains",
            "viewed": 255
        },
        "renderpass": [
            {
                "code": "vec3 sundir = vec3(0.);\n// vertical\nfloat sdCylinder(vec3 p,vec2 h)\n{\n    vec2 d=abs(vec2(length(p.xz),p.y))-h;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nvec3 getBumpMap(vec3 pos)\n{\n    return texture(iChannel1,pos.xz).xyz/10.;\n}\nfloat Dist(vec3 pos)\n{\n    float sphere = length(pos-vec3(0.,0.,3.))-1.;\n    return min(min(sphere, pos.y+1.),sdCylinder(pos-vec3(2,0,3),vec2(0.5,1)));\n}\nfloat Dist1(vec3 pos)\n{\n    float sphere = length(pos-vec3(0.,0.,3.))-1.;\n    float a = min(min(sphere, pos.y+1.),sdCylinder(pos-vec3(2,0,3),vec2(0.5,1)));\n    return a*a*a/2000000000.+0.1;\n}\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 EstimateNormal(vec3 pos)\n{\n    vec3 norm = vec3(0.);\n    vec3 posx = pos;\n    vec3 posy = pos;\n    vec3 posz = pos;\n    posx.x+=0.01f;\n    posy.y+=0.01f;\n    posz.z+=0.01f;\n    float distx = (Dist(posx)-Dist(pos))*100.;\n    float disty = (Dist(posy)-Dist(pos))*100.;\n    float distz = (Dist(posz)-Dist(pos))*100.;\n    return normalize(vec3(distx,disty,distz));\n}\nfloat EstimateAO(vec3 pos)\n{\n    vec3 norm = vec3(0.);\n    vec3 posx = pos;\n    vec3 posy = pos;\n    vec3 posz = pos;\n    posx.x+=0.002f;\n    posy.y+=0.002f;\n    posz.z+=0.002f;\n    float distx = (Dist1(posx)-Dist1(pos))*1.;\n    float disty = (Dist1(posy)-Dist1(pos))*1.;\n    float distz = (Dist1(posz)-Dist1(pos))*1.;\n    return length(vec3(distx+disty+distz)-pos)*0.3/length(pos-vec3(0,1.,0.));\n}\nfloat shadow(vec3 pos,float seed)\n{\n    vec3 ray = pos+(EstimateNormal(pos)/200.);\n    vec3 dir = sundir+(EstimateNormal(pos)*rand(pos.xy+vec2(seed))/5.);\n    float dist = Dist(ray);\n    for(int i = 0; i<100; i++)\n    {\n        float dist = Dist(ray);\n        ray += dir*dist;\n        \n    }\n    bool hit = Dist(ray)<0.0005;\n    return hit?2.:0.5;\n}\n\n\nvec3 HitRay(vec2 scrcoord)\n{\n    vec3 col = vec3(0.3,0.8,0.9);\n    \n    sundir = vec3((iMouse.xy-(iResolution.xy/2.))/80.,2.);\n    sundir/=length(sundir);\n    vec3 ray = vec3(1.,0.5,0.);\n    vec3 dir = vec3(scrcoord.xy, 1.)/length(vec3(scrcoord.xy, 1.));\n    float dist = Dist(ray);\n    float steps=0.;\n    for(int i = 0; i<1000; i++)\n    {\n        float dist = Dist(ray);\n        ray += dir*dist;\n        if(dist>0.001)\n           steps += 0.3;\n    }\n    bool hit = Dist(ray)<0.001;\n    float AO = EstimateAO(ray-EstimateNormal(ray)/20.);\n    if(!hit)\n    {\n        col = vec3(0.3,0.8,0.9)*(1.+(dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir))/3.);\n        col = col + (vec3(1,1,0.3)-col)*clamp(dot(dir,sundir)-0.8,0.,1.);\n        col = col + (vec3(1,1,1)-col)*clamp((dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)-0.95)*300.,0.,1.);\n        \n    }\n    else\n    {\n        float sunlight = (dot(EstimateNormal(ray),sundir)-0.5);\n        float shadow = 1.-(0.5*((shadow(ray,1.+iTime)+shadow(ray,2.+iTime)+shadow(ray,3.+iTime)+shadow(ray,4.+iTime)+shadow(ray,5.+iTime)+shadow(ray,6.+iTime)+shadow(ray,7.+iTime))/7.));\n        if(ray.y>-1.01){shadow/=2.;shadow+=0.5;\n            col = (ray.y<-1.+0.001?(texture(iChannel0,ray.xz).xyz):vec3(1.,1.,1.))*((shadow*2.)+(sunlight+4.)/3.)/4.;\n        }\n        steps /= 2.;\n        steps += EstimateAO(ray);\n        steps /=length(ray-vec3(0,1.,0.));\n        col *= 1.-((AO)+(steps*steps)/16.)/2.;\n        col *= 1.5;\n    }\n    vec3 col1 = vec3(1);\n    vec3 col2 = col;\n    int reflections = 2;\n    if(ray.y<-0.999){reflections=1;}\n    for(int i1 = 0; i1<2; i1++)\n    {\n    if(hit)\n    {\n        dir = reflect(dir,EstimateNormal(ray)+(getBumpMap(ray)/8.));\n        ray += EstimateNormal(ray)/200.;\n        for(int i = 0; i<100; i++)\n        {\n            float dist = Dist(ray);\n            ray += dir*dist;\n        \n        }\n    }\n    hit = Dist(ray)<0.001;\n    if(!hit)\n    {\n        col1 = vec3(0.2,0.4,0.8)*(1.+(dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir))/30.);\n        col1 = col1 + (vec3(1,1,0.3)-col1)*clamp(dot(dir,sundir)-0.8,0.,1.);\n        col1 = col1 + (vec3(1,1,1)-col1)*clamp((dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)-0.95)*300.,0.,1.);\n    }\n    else\n    {\n        float sunlight = (dot(EstimateNormal(ray),sundir)-0.5);\n        float shadow = 1.-(0.5*((shadow(ray,1.+iTime)+shadow(ray,2.+iTime)+shadow(ray,3.+iTime)+shadow(ray,4.+iTime)+shadow(ray,5.+iTime)+shadow(ray,6.+iTime)+shadow(ray,7.+iTime))/7.));\n        if(ray.y>-1.01){shadow/=5.;shadow+=0.5;\n            col1 = (ray.y<-1.+0.001?(texture(iChannel0,ray.xz).xyz):vec3(1.,1.,1.))*((shadow*2.)+(sunlight+4.)/3.)/4.;\n    }\n    \n    \n    }\n    col2 += col1;\n    }\n    col2 /= 2.;\n    \n    \n    //return vec3((1.-AO)-steps);\n    return col * col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord/iResolution.yy)*2.);\n    uv.y-=1.;\n    uv.x-=(iResolution.x/iResolution.y);\n    // Time varying pixel color\n    vec2 col = (uv);\n    vec3 hit = HitRay(uv);\n    \n    // Output to screen\n    fragColor = vec4(hit,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}