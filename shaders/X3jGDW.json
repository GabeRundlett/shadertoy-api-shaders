{
    "Shader": {
        "info": {
            "date": "1708459523",
            "description": "distance function to a circular arc",
            "flags": 0,
            "hasliked": 0,
            "id": "X3jGDW",
            "likes": 3,
            "name": "Circular Arc SDF",
            "published": 3,
            "tags": [
                "math",
                "sdf",
                "arc"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 100
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T (iTime)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define FUI floatBitsToUint\n#define ZERO min(0, iFrame)\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n#define AMBIENT 0.0076\n\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sabs(in float v, in float k) {return smax(-v, v, k);}\nfloat sclamp(in float v, in float mi, in float ma, in float k) {return smin(smax(v, mi, k), ma, k);}\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\n\nfloat hash21(vec2 ip, float seed) {\n  uvec2 p = FUI(ip); uint s = FUI(seed); uvec2 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y) / float(0xFFFFFFFFU);\n}\n\nfloat noise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(hash21(id+vec2(0,0),s),hash21(id+vec2(1,0),s),lv.x),\n             mix(hash21(id+vec2(0,1),s),hash21(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nfloat noise(vec2 p, float s, float freq, float dec, float warp, const in int oct) {\n  float n = 0.0;\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*noise((p+tx)*freq,s);\n    div += amp;\n    amp *= dec;\n    freq *= exp(dec*1.386294401);\n    tx += warp * vec2(sin(n*6.28), cos(n*6.28));\n    \n  }\n  return n / div;\n}\n\nstruct Light {\n  vec3 p;\n  vec3 dir;\n  vec3 color;\n  float strength;\n  int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIRECTIONAL 2\n\nvec3 getLightDir(Light light, vec3 p) {\n  switch (light.type) {\n    case LIGHT_AMBIENT: return normalize(light.p); break;\n    case LIGHT_POINT: return normalize(light.p - p); break;\n    case LIGHT_DIRECTIONAL: return normalize(light.dir); break;\n    default: return normalize(vec3(1, 2, 3)); break;\n  }\n}\n\nvec3 getLightAtt(Light light, vec3 p, vec3 N) {\n  vec3 L = getLightDir(light, p);\n  float NdotL = max(AMBIENT, dot(N, L));\n\n  switch (light.type) {\n    case LIGHT_AMBIENT: return NdotL * light.strength * light.color; break;\n    case LIGHT_POINT: return (NdotL * light.strength * light.color) / max(0.0000353, pow(distance(light.p, p), 2.0));\n    case LIGHT_DIRECTIONAL:\n      return smoothstep(0.0, 0.8, dot(L, normalize(light.p -  p))) * light.strength * light.color; break;\n  }\n\n  return vec3(0.5);\n}\n\nstruct Material {\n  float rough;\n  float spec;\n  float z;\n};\n\n#define NEW_MATERIAL Material(0.0, 0.0, 0.0)\n\nstruct Object {\n  int id;\n  vec3 p;\n  vec3 q;\n};\n\nvec3 pointRot(vec3 p, vec3 r) {\n    p.yz *= rot(r.z);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.x);\n    return p;\n}\nvec3 transform(vec3 p, vec3 t, vec3 q) {\n    p = pointRot(p - t, q);\n    return p;\n}\n\n#define NEW_OBJECT Object(-1, vec3(0.0), vec3(0.0))\n\nstruct Data {\n  vec3 p;\n  vec3 n;\n  float d;\n  Object o;\n  Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, NEW_OBJECT, NEW_MATERIAL)\n\n\n#define SAMPLE(OBJ, DIST) { if (DIST < dist && DIST < FAR) { dist = DIST; data.o = OBJ; } }\n\n#define ID_GROUND 1\n\nfloat groundSDF(vec3 p) {\n  return p.y;\n}\n\nfloat arc(vec2 p, vec2 angles, float t, float radi, float s) {\n  angles = radians(angles);\n  float angle = mod(atan(p.y, p.x), TAU);\n  float dist = length(p);\n  float c1 = dist - (radi - t);\n  float c2 = (radi + t) - dist;\n  float c3 = angle - angles.x;\n  float c4 = angles.y - angle;\n  return sgt(dist, (radi - t), s) *\n         sgt((radi + t), dist, s) *\n         sgt(angle, angles.x,  s) *\n         sgt(angles.y, angle,  s);\n}\n\nfloat sdf(vec3 p, inout Data data) {\n  float dist = FAR;\n  \n  Object oGround = Object(ID_GROUND, vec3(0.0), vec3(0.0));\n  float ground = groundSDF(p - oGround.p);\n  \n  Object oAr = Object(0, vec3(0, 1.5, 0.0), vec3(0.0));\n  float sa = mix(0.0, 180.0, 0.5+0.5*sin(T));\n  float ea = mix(sa, 360.0-sa, 0.5+0.5*cos(T));\n  sa = mix(sa, 0.0, 0.5+0.5*sin(T+1.1));\n  ea = mix(ea, 360.0, 0.5+0.5*sin(T+1.1));\n  float ar = arc(transform(p, oAr.p, oAr.q).xz, vec2(sa, ea), \n  0.1, 5., 0.6);\n  SAMPLE(oGround, ground);\n  ar = (p.y-ar);\n  Object oSp = Object(0, vec3(0, sin(T)*0.5, 0), vec3(cos(T), 0.0, sin(T)));\n  float sp = length(transform(p, oSp.p, oSp.q))-1.5;\n  SAMPLE(oAr, ar);\n  SAMPLE(oSp, sp);\n  return dist;\n}\n\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n  float d = 0.0;\n\n  for (int i = ZERO; i < STEPS; i++) {\n    vec3 p = ro+rd*d;\n    float next = sdf(p, data);\n    if (next >= FAR) return false;\n    if (next <= NEAR) break;\n    d += next;\n  }\n\n  vec3 p = ro+rd*d;\n  vec2 e = vec2(NEAR, 0.0);\n  vec3 n = normalize(sdf(p, data) - vec3(\n    sdf(p - e.xyy, data),\n    sdf(p - e.yxy, data),\n    sdf(p - e.yyx, data)\n  ));\n\n  data.p = p;\n  data.n = n;\n  data.d = d;\n\n  return true;\n}\n\nfloat getShadow(vec3 ro, vec3 rd, vec3 n) {\n  Data data = NEW_DATA;\n  float NdotL = dot(n, rd);\n  if (NdotL <= 0.0) return AMBIENT;\n  const int steps = 22;\n  float d = 0.0;\n  float t = NEAR*2.0 * (1.0 + 2.0*max(0.0, NdotL));\n  float s = 0.0;\n  float k = 0.0;\n\n  for (int i = ZERO; i < steps; i++) {\n    vec3 p = ro+rd*t;\n    float next = sdf(p*1.1, data);\n    if (next >= FAR) return AMBIENT;\n    if (next < -0.25) break;\n    d += next;\n    t += clamp(next, 0.005, 0.5);\n    k += 1.0;\n  }\n  \n  d /= max(1.0, k);\n\n  s = smoothstep(0.5, 1.0, clamp(1.0-(d / (1.0+d)), 0.0, 1.0));\n  s = 1.0-s;\n  s = exp(s-1.0);\n  return clamp(s*s, AMBIENT, 1.0);\n}\n\nvec3 getAlbedoBox(inout Data data) {\n  vec3 p = transform(data.p, data.o.p, data.o.q);\n  vec3 n = transform(data.n, vec3(0.0), data.o.q);\n  vec2 uv = mix(mix(p.xy, p.yz, round(abs(dot(n, vec3(1, 0, 0))))),\n                p.xz,round(abs(dot(n, vec3(0, 1, 0)))));\n\n  vec2 id = floor(uv*2.0);\n  return vec3(1.0)*mod(id.x-id.y, 2.0);\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec2 uv = p.xz;\n    vec3 col = vec3(1.0)*noise(uv, 11.58813,  2.5, 0.5, 0.0, 4);\n    col = col*mix(col, vec3(0.3, 0.69, 0.06), smoothstep(0.05, 0.6, \n    noise(uv*0.85, 5.51, 0.9, 0.5, 0.15, 2)));\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n  switch (data.o.id) {\n    case ID_GROUND: return getAlbedoGround(data); break;\n  }\n\n  return getAlbedoBox(data);\n}\n\nvec3 forEachLight(Light light, vec3 ro, vec3 rd, Data data, vec3 diffuse) {\n  vec3 p = data.p;\n  vec3 N = data.n;\n  vec3 L = getLightDir(light, p);\n  vec3 att = getLightAtt(light, p, N);\n  vec3 ref = reflect(N, L);\n  float VdotR = max(0.0, dot(rd, ref));\n  float spec = pow(VdotR, 24.0);\n  float shadow = getShadow(data.p, getLightDir(light, data.p), data.n);\n  return ((diffuse + spec) * att) * shadow;\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n  #define NUM_LIGHTS 1\n\n  Light lights[NUM_LIGHTS] = Light[](\n    Light(vec3(1, 2, -3), vec3(0.0, 1, 1), vec3(0.97, 0.79, 0.69), 4.0, LIGHT_AMBIENT)\n  );\n  \n  vec3 col = vec3(0.0);\n  Data data = NEW_DATA;\n  bool hit = false;\n  if (march(ro, rd, data)) {\n    hit = true;\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n      Light light = lights[i];\n      col += forEachLight(light, ro, rd, data, diffuse);\n    }\n  }\n  float dup = max(0.0, dot(rd, vec3(0, 1, 0)));\n  vec3 blue = vec3(0.055, 0.55, 0.86);\n  blue = pow(blue, vec3(1.0 + 10.0*dup));\n  col = mix(col, blue, max(float(!hit), smoothstep(FAR-0.03, FAR+0.005, data.d)));\n  \n  \n  return col;\n}\n\nvoid getRay(vec2 uv, vec4 m, inout vec3 ro, inout vec3 rd) {\n  float Y = 1.25;\n  float Z = -10.0;\n  ro = vec3(0.0, Y, Z);\n  rd = normalize(vec3(uv, 1.0));\n\n  if (m.z > 0.01) {\n    ro.z -= 4.;\n    ro.y -= 1.0;\n    ro.yz *= rot(m.y*TAU);\n    ro.xz *= rot(m.x*TAU);\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n  } else {\n    ro.xz = mix(ro.xz, vec2(0.0, -10.0)+-2.0*vec2(sin(T), cos(T)), smoothstep(0.0, 4.0, T));\n    ro.y += 2.2;\n    vec3 dir = normalize(ro - (R.y*vec3(0.0, -0.05, 0.0)));\n    vec3 right = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, dir));\n    rd *= mat3(right, dir, up);\n  }\n  \n  ro.y = max(ro.y, 0.1);\n}\n\n////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 o, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc-0.5*R.xy)/R.y;\n  vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y,iMouse.zw);\n\n  vec3 ro = vec3(0.0);\n  vec3 rd = vec3(0.0);\n  getRay(uv, m, ro, rd);\n\n\n  col += scene(ro, rd);\n  col += 0.5*luma(col)*exp(col-1.);\n  col = aces(col);\n  col = pow(col, vec3(1.0 / 2.2));\n  \n  o = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}