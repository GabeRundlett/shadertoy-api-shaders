{
    "Shader": {
        "info": {
            "date": "1520234302",
            "description": "thing",
            "flags": 0,
            "hasliked": 0,
            "id": "MssfRj",
            "likes": 1,
            "name": "Cool Volumetric Thing",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "Simplex",
            "viewed": 107
        },
        "renderpass": [
            {
                "code": "#define iterations 4\n#define marching 10\n#define stepsize .2\n#define HASHSCALE .1\n\n#define pi 3.141592654\n#define numSteps 5\n\nfloat hash(vec3 p){\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 pos){\n    float acc = 0.0;\n    float scale = 1.0;\n    for(int n = 0; n < iterations; n++){\n        acc += noise(scale * pos) / scale;\n        scale *= 2.0;\n    }\n    return 0.5 * acc;\n}\n\nvec3 r(vec3 v, vec2 r){\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nvec3 velocity(vec3 p){\n    float a2 = dot(p.xy, p.xy);\n    float a = sqrt(a2);\n    float r = dot(p, p);\n    float ar = a2 + r;\n    return vec3(2.0*(-a*p.y + p.x*p.z, 2.0*(a*p.x - p.y*p.z), a - r))/(ar*ar);\n}\n\nvec3 density(vec3 pos){\n    float fn = fbm(pos * 10.0);\n    fn = 3.0 * smoothstep(.5, 1.0, fn);\n    vec3 col = pow(vec3(fn), .5 + .5 * sin(fn + vec3(0.0, pi * .666, pi * 1.333)));\n    return col;\n}\n\nvec3 rungeKutta(vec3 p, float t){\n    t /= float(numSteps);\n    for(int i = 0; i < numSteps; ++i) {\n        \tvec3 k1 = -velocity(p);\n        \tvec3 k2 = -velocity(p + 0.5*k1*t);\n        \tvec3 k3 = -velocity(p + 0.5*k2*t);\n\t        vec3 k4 = -velocity(p + k3*t);\n    \t    p += 0.161616*t*(k1 + 2.0*k2 + 2.0*k2 + k3);\n    }\n\t\n    return p;\n}\n\nvec3 interpolateDensity(vec3 p){\n    float t1 = fract(0.5*iTime);\n    float t2 = fract(t1 + 0.5);\n    vec3 p1 = rungeKutta(p, t1);\n    vec3 p2 = rungeKutta(p, t2);\n    vec3 d1 = density(p1);\n    vec3 d2 = density(p2);\n    t1 = 2.0*abs(t1 - 0.5);\n    return mix(d1, d2, t1);\n}\n    \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\tfragColor = vec4(0.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 cam = vec3(0.0, 0.0, -1.0);\n    vec3 dir = normalize(vec3(xy, 2.5));\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m *= 2.0;\n    dir = r(dir, m);\n    cam = r(cam, m);\n    float d = .5;\n    float div = 2.0;\n    for(int n = 0; n < marching; n++){\n        vec3 pos = d * dir + cam;\n        fragColor.xyz += interpolateDensity(pos) / (d * d);\n        d += stepsize;\n        div *= 2.0;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}