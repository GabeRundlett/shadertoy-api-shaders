{
    "Shader": {
        "info": {
            "date": "1589206350",
            "description": "effect experiment",
            "flags": 0,
            "hasliked": 0,
            "id": "wslBWX",
            "likes": 2,
            "name": "gradation map effect",
            "published": 3,
            "tags": [
                "gradationmap"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 587
        },
        "renderpass": [
            {
                "code": "const float Epsilon = 1e-10;\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec3 RGBtoHCV(vec3 RGB)\n{\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + Epsilon) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\nvec3 RGBtoHSL(vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + Epsilon);\n    return vec3(HCV.x, S, L);\n}\n\nvec3 HUEtoRGB(float H)\n{\n    float R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B),0.,1.);\n}\n\nvec3 HSLtoRGB(vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1. - abs(2. * HSL.z - 1.)) * HSL.y;\n    return (RGB - 0.5) * C + HSL.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n\tp*=1.6;\n    vec2 prevP = p;\n\n    float t = iTime*0.1;\n    float dist = 1.0;\n    p.x+=cos(t)*dist;\n    p.y+=sin(t)*dist;\n    p*= cnoise(p*0.5);\n    float d = length(p)-0.6;\n    \n    dist = 1.3;\n    p.x-=cos(-t*1.2)*dist;\n    p.y-=sin(-t*1.2)*dist;\n    p*= cnoise(p*0.9);\n    float d2 = length(p)-0.7;\n    \n    p = prevP;\n    p.y+=iTime*0.1;\n    float n = cnoise(p*2.5)+min(d,d2);\n\t//n = min(d,d2);\n    \n    // tone curve\n    float toneval = 0.5;\n    vec3 originalCol = vec3(pow(n,toneval));\n    \n    // gradient map\n    vec3 gradientCol1 = vec3(0.7,0.3,0.6);\n    vec3 gradientCol2 = vec3(0.7,0.7, .3);\n    \n    vec3 hsl = RGBtoHSL(originalCol);\n    \n    float r = gradientCol1.r+(gradientCol2.r-gradientCol1.r)*hsl.z;\n    float g = gradientCol1.g+(gradientCol2.g-gradientCol1.g)*hsl.z;\n    float b = gradientCol1.b+(gradientCol2.b-gradientCol1.b)*hsl.z;\n    \n    vec3 gradientMapResult = RGBtoHSL(vec3(r,g,b));\n    \n    // hue\n    float hueVal = 0.02;\n    gradientMapResult.x+=hueVal;\n    \n    // brightness\n    float brightness = 0.5;\n    \n    vec3 resRGB = HSLtoRGB(gradientMapResult)*brightness;\n    \n    float threthold =  0.21;\n    fragColor = vec4(vec3(step(resRGB.r,threthold),step(resRGB.g,threthold),step(resRGB.b,threthold)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}