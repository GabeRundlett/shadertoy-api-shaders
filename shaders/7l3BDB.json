{
    "Shader": {
        "info": {
            "date": "1663596935",
            "description": "New implementation of an algorithm for limited repetition of Hexagonal SDFs in a Hexagonal Grid.\nBased on the works of Inigo Quilez (https://iquilezles.org) and Red Blob Games (https://redblobgames.com/grids/hexagons).",
            "flags": 0,
            "hasliked": 0,
            "id": "7l3BDB",
            "likes": 4,
            "name": "Hexagonal LMR SDF V2",
            "published": 3,
            "tags": [
                "sdf",
                "repetition",
                "hexagon",
                "distance",
                "field",
                "hex",
                "tile",
                "hexagonal",
                "tilling",
                "signed",
                "limited"
            ],
            "usePreview": 0,
            "username": "josaid",
            "viewed": 264
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2022 João Pedro Braz (brazjoaopedro@ymail.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define CAMERA_ZOOM 16.0\n#define GRID_RADIUS 8.0\n#define HEX_RADIUS 0.5\n#define HEX_MARGIN 0.0\n#define ANIMATED 1\n\nconst float PI = 3.141592653589793;\nconst float TAU = 2.0 * PI;\nconst float SQRT_3 = 1.732050807568877;\nconst float HALF_SQRT_3 = 0.8660254037844386;\nconst float THIRD_SQRT_3 = 0.5773502691896258;\nconst float THIRD = 0.33333333333333334;\nconst float TWO_THIRDS = 0.6666666666666667;\nconst float THREE_HALFS = 1.5;\nconst float EPSILON = 0.00000001;\n\nconst vec3 KERNEL = vec3(-HALF_SQRT_3, 0.5, THIRD_SQRT_3);\n\n// Transformation Utilities\nvec2 translate(vec2 point, vec2 by);\nvec2 scale(vec2 point, vec2 scale);\n\n\n// Hex Utilities\nbool is_inside_grid(vec3 hex, float half_width);\nvec3 cube_round(vec3 cube);\nvec3 uv_to_hex(vec2 uv, float size);\nvec2 hex_to_uv(vec3 hex, float size);\n\n\n// SDF Utilities\nfloat sd_hexagon(vec2 point, float half_size);\nfloat sd_segment(vec2 point, vec2 a, vec2 b);\nfloat sd_lmr_hexagon(vec2 point, float radius, float grid_radius);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Resolution dependent antialiasing, used with smoothstep\n\tfloat aa = 1.0 / min(iResolution.y, iResolution.x) * 10.0 * CAMERA_ZOOM;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Compute zoom taking into account the current aspect ratio\n\tvec2 zoom = iResolution.xy * CAMERA_ZOOM / min(iResolution.y, iResolution.x);\n    \n    // Our camera offset\n    vec2 camera_offset = vec2(0.0, 0.0);\n    if (iMouse.z > EPSILON) {\n        camera_offset = iMouse.xy / iResolution.xy;\n        camera_offset = scale(translate(camera_offset, vec2(0.5, 0.5)), zoom);\n    }\n    \n    // Center and scale the UV\n\tvec2 point = translate(scale(translate(uv, vec2(0.5, 0.5)), zoom), camera_offset);\n    \n    // Compute the current Hexagon in Cube Coordinates\n\tvec3 hex = uv_to_hex(point, HEX_RADIUS);\n    \n    // Get the center of the Hexagon\n\tvec2 center = hex_to_uv(hex, HEX_RADIUS);\n    \n    // Transform our UV into the Local Coordinate System of the Hexagon\n\tvec2 relative_point = (point - center) / HEX_RADIUS;\n\t\n    // Compute the SDF\n    float roundness = 0.0;\n#if ANIMATED == 1\n    roundness = cos(iTime * 0.75) * 1.1 + 1.0;\n#endif\n\n    vec3 color;\n    if (is_inside_grid(hex, GRID_RADIUS)) {\n        // Hexagon SDF\n        float signed_distance =\n            sd_hexagon(relative_point * (HEX_MARGIN + HEX_RADIUS + roundness), HEX_RADIUS) - roundness;\n\n        // Inigo Quilez's Color Scheme\n        color = vec3(1.0) - sign(signed_distance) * vec3(0.1,0.4,0.7);\n        color *= 1.0 - exp(-2.0 * abs(signed_distance));\n        color *= 0.8 + 0.2 * cos(signed_distance);\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01 + aa, abs(signed_distance)));\n    } else {\n        // LMR Hexagonal Grid SDF\n        float signed_distance = sd_lmr_hexagon(point, HEX_RADIUS, GRID_RADIUS);\n        \n        color = mix(\n            color,\n            vec3(1.0),\n            smoothstep(\n                0.08 + aa * 0.25,\n                0.06,\n                abs(signed_distance - 0.25) + 0.05\n            )\n        );\n\n        color = mix(\n            color,\n            vec3(1.0),\n            smoothstep(\n                0.08 + aa * 0.25,\n                0.06,\n                abs(signed_distance - 0.02) + 0.06\n            )\n        );\n        \n\t\tcolor *= 1.0 - exp(-60.0 * abs(signed_distance));\n\t\tcolor *= 0.9 + 0.6 * cos(30.0 * signed_distance);\n\t\tcolor += (vec3(1.0, 0.58, 0.3) * cos(25.0 * signed_distance)) * smoothstep(0.01, 0.1, signed_distance);\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n\n// -- Transformation Utilities Implementations --\nvec2 translate(vec2 point, vec2 by) {\n    return point - by;\n}\n\nvec2 scale(vec2 point, vec2 scale) {\n    return point * scale;\n}\n\n// -- Hex Utilities Implementations --\n// Please check out https://www.redblobgames.com/grids/hexagons/\n// The source of most these functions.\nbool is_inside_grid(vec3 hex, float grid_radius) {\n\treturn (\n\t\tabs(hex.x) <= grid_radius && \n\t\tabs(hex.y) <= grid_radius && \n\t\tabs(hex.z) <= grid_radius\n\t);\n}\n\n// Justin Pombrio's\n// https://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html\nvec3 cube_round(vec3 cube) {\n\tfloat a = ceil(cube.x - cube.y);\n    float b = ceil(cube.y - cube.z);\n    float c = ceil(cube.z - cube.x);\n\t\n\treturn vec3(\n\t\tround((a - c) / 3.0),\n\t\tround((b - a) / 3.0),\n\t\tround((c - b) / 3.0)\n\t);\n}\n\nvec3 uv_to_hex(vec2 uv, float size) {\n\tfloat q = uv.x * TWO_THIRDS / size;\n\tfloat r = (-THIRD * uv.x + THIRD_SQRT_3 * uv.y) / size;\n\tfloat s = -q - r;\n\n\treturn cube_round(vec3(q, r, s));\n}\n\nvec2 hex_to_uv(vec3 hex, float size) {\n\tfloat x = THREE_HALFS * hex.x * size;\n\tfloat y = ((HALF_SQRT_3 * hex.x) + (SQRT_3 * hex.y)) * size;\n\t\n\treturn vec2(x, y);\n}\n\n// -- SDF Utilities Implementations --\n// Please check out https://iquilezles.org/articles/distfunctions2d/\n// For other SDF functions\nfloat sd_hexagon(vec2 point, float radius) {\n    point = abs(point);\n    point -= 2.0 * min(dot(KERNEL.xy, point), 0.0) * KERNEL.xy;\n    point -= vec2(clamp(point.x, -KERNEL.z * radius, KERNEL.z * radius), radius);\n    return length(point) * sign(point.y);\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sd_lmr_hexagon(vec2 point, float radius, float grid_radius) {\n    float H = 2.0 * radius;     // height\n    float W = SQRT_3 * radius;  // width\n    float XS = W;               // horizontal spacing\n    float YS = H * 0.75;        // vertical spacing\n    \n    // Here you can swap point.y and point.x for pointy-hex grids\n    float a = PI + atan(point.y, point.x);\n    a = mod(round(a / TAU * 6.0) / 6.0 * TAU, TAU); // pick one of six wedges\n    // And also here, you can swap \"-sin(a), -cos(a)\" and \"cos(a), -sin(a)\" for pointy-hex grids\n    point = mat2(-sin(a), -cos(a), cos(a), -sin(a)) * point;\n\n    // q is the hexagonal column, should be an integer or half integer\n    float left_q = -grid_radius / 2.0;\n    float right_q = -left_q;\n    float q = round(point.x / W - left_q) + left_q;\n    q = clamp(q, left_q, right_q);\n   \n    // Distance field is to the nearest hexagonal column\n    vec2 column = vec2(q * W, grid_radius * YS);\n    vec2 left = column + 0.5 * vec2(-W, radius);\n    vec2 right = column + 0.5 * vec2(W, radius);\n    vec2 center = column + vec2(0, radius);\n    return min(sd_segment(point, left, center),\n                  sd_segment(point, right, center));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}