{
    "Shader": {
        "info": {
            "date": "1610497299",
            "description": "Utilizing all channels it is possible to store 127 bits per pixel without using special float values (which become altered in buffers on some implementations).\n4x IEEE754 binary32 allows ((1<<24)*254)^4 distinct values or 127.9547 bits of information.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtKyR1",
            "likes": 11,
            "name": "127 bits per pixel",
            "published": 3,
            "tags": [
                "encoding",
                "uintbitstofloat",
                "floatbitstouint"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 564
        },
        "renderpass": [
            {
                "code": "\nfloat printbits (uint v, int b) {\n  return float( (v>>b)&0x1u );\n}\n\nfloat printbits (uvec4 v, int b) {\n  return printbits(v[b/32], b%32);\n}\n\nvoid mainImage( out vec4 d, in vec2 c ) {\n  uvec4 ref = testvalue(iFrame);\n  uvec4 dec = b127_ieee754_decode(texture(iChannel0, vec2(.5)));\n  //uvec4 dec = b127_ieee754_decode(texelFetch(iChannel0, ivec2(0), 0));\n  vec2 uv = 1.-c/iResolution.xy;\n  int i = int(floor(uv.x*(127.+4.)-2.));\n  int j = int(floor(uv.y*(3.+1.)-.5));\n  vec3 v = vec3(0.5);\n  if (i>=0 && i<127) {\n    if (j==0) v = vec3(printbits( ref     ,i )); // Top: correct value\n    if (j==1) v = vec3(printbits( ref^dec ,i )); //  -> Middle: difference: there should be none\n    if (j==2) v = vec3(printbits( dec     ,i )); // Bottom: decoded value\n  }\n  d.rgb = pow(v.rgb, vec3(1./2.2));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n\"127 bits per pixel\" by Theron Tarigo, www.shadertoy.com/user/ttg\n\nUtilizing all channels of an OpenGL 32-bit float buffer it is possible to store\n127 bits per pixel without using special float values\n(which become altered in buffers on some implementations).\n\n4x IEEE754 binary32 allows ((1<<24)*254)^4 distinct values or\n127.9547 bits of information.\n\nThe following implementations:\n  b127_ieee754_encode\n  b127_ieee754_decode\nare free for use, copying, and modification by anyone for any purpose,\nwithout restriction.\n\nAttribution should be included for providing clarity of the origin of these\nimplementations; including the original URL is sufficient attribution:\nhttps://www.shadertoy.com/view/wtKyR1\n\n*/\n\nvec4 b127_ieee754_encode (uvec4 v) {\n  v.w&=0x7FFFFFFFu;\n  uvec4 l = uvec4( v.xyz&0xFFFFFFu , v.x>>24 | v.y>>24<<8 | v.z>>24<<16 );\n  return uintBitsToFloat( (l&0x800000u)<<8 | l&0x7FFFFFu\n   | 1u+uvec4(v.w/uvec4(1,254,254*254,254*254*254))%254u <<23 );\n}\n\nuvec4 b127_ieee754_decode (vec4 f) {\n  uvec4 e = floatBitsToUint(f);\n  uvec4 l = (e&0x80000000u)>>8 | e&0x7FFFFFu;\n  uvec4 h = (e>>23&0xFFu)-1u;\n  return uvec4(\n    l.xyz | uvec3(l.w)>>uvec3(0,8,16)<<24,\n    h.x+254u*h.y+(254u*254u)*h.z+(254u*254u*254u)*h.w );\n}\n\n/*===========================================================================*/\n\n// test cases\n\nuint hash (uint x) {\n  // https://www.shadertoy.com/view/WttXWX\n  x ^= x >> 17;\n  x *= 0xed5ad4bbU;\n  x ^= x >> 11;\n  x *= 0xac4c1b51U;\n  x ^= x >> 15;\n  x *= 0x31848babU;\n  x ^= x >> 14;\n  return x;\n}\n\nuvec4 testvalue (int s) {\n  uvec4 v;\n  v.x = hash(uint(s*4+0));\n  v.y = hash(uint(s*4+1));\n  v.z = hash(uint(s*4+2));\n  v.w = hash(uint(s*4+3))&0x7FFFFFFFu;\n  return v;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid mainImage( out vec4 v, in vec2 c ) {\n  v = b127_ieee754_encode( testvalue(iFrame) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}