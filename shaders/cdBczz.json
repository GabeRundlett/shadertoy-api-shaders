{
    "Shader": {
        "info": {
            "date": "1690006498",
            "description": "Makes a spiral by setting distance from centre equal to angle from centre.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdBczz",
            "likes": 2,
            "name": "Zooming Rainbow Spiral",
            "published": 3,
            "tags": [
                "spiral"
            ],
            "usePreview": 0,
            "username": "evpevdev",
            "viewed": 153
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n\n\n// From https://www.shadertoy.com/view/XlfGDN\nvec3 hsv2rgb(vec3 c)\n{\n    //vec3 K = vec3(3,2,1)/3.;\n    //return c.z * mix(K.xxx, clamp(abs(fract(c.xxx + K)*6. - vec3(3.)) - K.xxx, 0., 1.), c.y);\n    // Which can be further optimized to:\n    // Thanks to las @ http://www.pouet.net/user.php?who=4548\n    return mix(vec3(1.),clamp((abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),c.y)*c.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    const float size = 0.2;\n    // Speed is currently not used.\n    //float speed = 0.02\n    const float minSpeed = 0.1;\n    const float maxSpeed = 0.2;\n    // This is the integral of speed with respect to time\n    // Integral of minSpeed + (maxSpeed-minSpeed) * (sin(iTime) + 1.0)/2.0\n    float distanceOffset = minSpeed*iTime + (maxSpeed-minSpeed) * (cos(iTime) + iTime)/2.0;\n    float len = length(uv);\n    float len2 = pow(len, 0.1);\n    float angle = mod(atan(uv.y, uv.x) / 1.0, PI) / PI;\n    // Map to 0 at right, 0.5 at top, 1 at left, 1.5 at bottom\n    angle = angle + -(sign(uv.y)-1.0)/2.0;\n    \n    const int spokes = 1;\n    // Number of spokes are changed by changing the range of angle from 0-2 to 0-#spokes.\n    float dFg = abs(mod(len2 + distanceOffset - angle*size*(float(spokes)/2.0), size));\n    float dBg = abs(mod(len2 - iTime*0.01 - angle*size*(float(spokes)/2.0), size));\n    \n    // Normalize so d is between 0 and 1.\n    dFg *= 1./size;\n    dBg *= 1./size;\n    // Make transition smooth so the mod does not make a harsh edge.\n    float dFgSmooth = abs(dFg - 0.5) * 2.;\n    float dBgSmooth = abs(dBg - 0.5) * 2.;\n    \n    // Used for transitioning between foreground and background rainbows smoothly\n    float transition = smoothstep(0.5, 0.9, dFgSmooth);\n    \n    const float fgInterlaceAmount = 20.0;\n    const float fgInterlaceOffset = 0.02;\n    const float bgInterlaceAmount = 150.0;\n    const float bgInterlaceOffset = 0.01;\n    // 0 in centre of screen and 1 on the left/right edges\n    float bgValue = pow(len/aspect, 0.8);\n    const float blackSize = 0.05;\n    float fgValue = (-pow(1e-3, len/aspect) + 1.0) * 1.2;\n    \n    // Glow effect done by making the value greater than 1 on the edges, and decreasing saturation at the edges\n    vec3 rainbowFg = hsv2rgb(vec3(angle-len2 + fgInterlaceOffset*floor(mod(dFg*fgInterlaceAmount, 2.)), (1.0-bgValue)*0.7, fgValue));\n    vec3 rainbowBg = hsv2rgb(vec3(dBgSmooth/10.+0.77 + bgInterlaceOffset*floor(mod(dBg*bgInterlaceAmount, 2.)), bgValue*0.8, bgValue*0.5));\n    vec3 col = mix(rainbowFg, rainbowBg, vec3(1.0-transition));\n    \n    const float posterisation = 16.0;\n    col = ceil(col * posterisation) / posterisation;\n    \n    //col = vec3(fgValue);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}