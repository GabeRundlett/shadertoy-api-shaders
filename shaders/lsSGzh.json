{
    "Shader": {
        "info": {
            "date": "1383509608",
            "description": "A set-up with some brick blocks from Mario's world. The lighting makes it look like a small plastic souvenir toy. Cross your eyes so that the white circles get superimposed, and you'll see stereographic 3D!",
            "flags": 0,
            "hasliked": 0,
            "id": "lsSGzh",
            "likes": 14,
            "name": "Mario Cross-eye 3D",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "eye",
                "stereo",
                "cross",
                "stereographic",
                "mario",
                "block"
            ],
            "usePreview": 0,
            "username": "HLorenzi",
            "viewed": 1956
        },
        "renderpass": [
            {
                "code": "// Comment to turn off for faster rendering!\n//#define SHADOWS 1\n#define SPECULAR 1\n\n// Reduce for accuracy-performance trade-off!\n#define RAYMARCH_ITERATIONS 40\n#define SHADOW_ITERATIONS 10\n\n// Increase for accuracy-performance trade-off!\n#define RAYMARCH_DOWNSTEP 1.0\n#define SHADOW_STEP 1.5\n\n\n\n\nvoid fUnionMat(inout float curDist, inout float curMat, float dist, in float mat)\n{\n\tif (dist < curDist) {\n\t\tcurMat = mat;\n\t\tcurDist = dist;\n\t}\n}\n\nfloat fSubtraction(float a, float b)\n{\n\treturn max(-a,b);\n}\n\nfloat fIntersection(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\nfloat fUnion(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat fSmoothUnion(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat pRoundBox(vec3 p, vec3 b, float r)\n{\n \treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat pBox(vec3 p, vec3 b)\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nvec2 pBlockBricks(vec3 p)\n{\n\tconst vec3 or = -vec3(0.8,0.86+0.2,0.8+0.2);\n\t// Top\n\tfloat d =     pBox(p+or+vec3(0,0,0), vec3(0.7,0.43,0.43));\n\td = fUnion(d, pBox(p+or+vec3(0.7+0.2+0.7,0,0), vec3(0.7,0.43,0.43)));\n\t\n\td = fUnion(d, pBox(p+or+vec3(-0.4,0.86+0.2,0), vec3(0.3,0.43,0.43)));\n\td = fUnion(d, pBox(p+or+vec3(-0.4+0.5+0.7,0.86+0.2,0), vec3(0.7,0.43,0.43)));\n\td = fUnion(d, pBox(p+or+vec3(0.2+0.4+1.4,0.86+0.2,0), vec3(0.3,0.43,0.43)));\n\t\n\td = fUnion(d, pBox(p+or+vec3(0,0.86+0.86+0.4,0), vec3(0.7,0.43,0.43)));\n\td = fUnion(d, pBox(p+or+vec3(0.7+0.2+0.7,0.86+0.86+0.4,0), vec3(0.7,0.43,0.43)));\n\t\n\t// Middle\n\td = fUnion(d, pBox(p+or+vec3(-0.27,0.27,0.86+0.2), vec3(0.43,0.7,0.43)));\n\td = fUnion(d, pBox(p+or+vec3(-0.27,0.27+0.2+1.4,0.86+0.2), vec3(0.43,0.7,0.43)));\n\t\n\td = fUnion(d, pBox(p+or+vec3(-0.27+0.86+0.2,0.27+0.7+0.1,0.86+0.2), vec3(0.43,1.5,0.43)));\n\t\n\td = fUnion(d, pBox(p+or+vec3(-0.27+0.86+0.86+0.4,0.27,0.86+0.2), vec3(0.43,0.7,0.43)));\n\td = fUnion(d, pBox(p+or+vec3(-0.27+0.86+0.86+0.4,0.27+0.2+1.4,0.86+0.2), vec3(0.43,0.7,0.43)));\n\t\n\t\n\t// Bottom\n\td = fUnion(d, pBox(p+or+vec3(0,0,0.86+0.86+0.4), vec3(0.7,0.43,0.43)));\n\td = fUnion(d, pBox(p+or+vec3(0.7+0.2+0.7,0,0.86+0.86+0.4), vec3(0.7,0.43,0.43)));\n\t\n\td = fUnion(d, pBox(p+or+vec3(-0.4,0.86+0.2,0.86+0.86+0.4), vec3(0.3,0.43,0.43)));\n\td = fUnion(d, pBox(p+or+vec3(-0.4+0.5+0.7,0.86+0.2,0.86+0.86+0.4), vec3(0.7,0.43,0.43)));\n\td = fUnion(d, pBox(p+or+vec3(0.2+0.4+1.4,0.86+0.2,0.86+0.86+0.4), vec3(0.3,0.43,0.43)));\n\t\n\td = fUnion(d, pBox(p+or+vec3(0,0.86+0.86+0.4,0.86+0.86+0.4), vec3(0.7,0.43,0.43)));\n\td = fUnion(d, pBox(p+or+vec3(0.7+0.2+0.7,0.86+0.86+0.4,0.86+0.86+0.4), vec3(0.7,0.43,0.43)));\n\t\n\td = fIntersection(d, pRoundBox(p, vec3(1.3,1.3,1.3), 0.2));\n\t\n\tfloat m = 3.0;\n\tfUnionMat(d,m,pBox(p,vec3(1.4,1.4,1.4)),0.0);\n\t\n\treturn vec2(d,m);\n}\n\nfloat distf(vec3 p, inout float m)\n{\n\tfloat d = 10000.0;\n\tm = 0.0;\n\t\n\tfloat grass1 = pBox(p+vec3(0,0,abs(cos(p.x)*cos(p.y))),vec3(12.2,12.2,1.2));\n\tgrass1 = fIntersection(grass1,pRoundBox(p+vec3(0,0,1.5),vec3(11,11,0.5), 1.0));\n\tfUnionMat(d,m,grass1,2.0);\n\t\n\tfloat ground1 = pRoundBox(p+vec3(0,0,4.0),vec3(10.7,10.7,2.5),1.0);\n\tfUnionMat(d,m,ground1,3.0);\n\t\n\tvec2 blocks = pBlockBricks((mod(p/2.0,3.0)-0.5*3.0));\n\tfloat blockd = blocks.x;\n\tfloat blockm = blocks.y;\n\t\n\tconst float blocksize = 2.95;\n\tfloat blocki = pBox(p-vec3(3,3,3),vec3(blocksize,blocksize,blocksize));\n\tblocki = fUnion(blocki, pBox(p-vec3(3,9,3),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(9,3,3),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(-9,3,9),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(9,-9,15),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(9,-9,9),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(-9,-9,3),vec3(blocksize,blocksize,blocksize)));\n\t\n\tblockd = fIntersection(blockd, blocki);\n\t\n\tfUnionMat(d,m,blockd,blockm);\n\t\n\t\n\treturn d;\n}\n\nfloat distf2(vec3 p, inout float m)\n{\n\tfloat d = 10000.0;\n\t\n\tfloat grass1 = pBox(p+vec3(0,0,abs(cos(p.x)*cos(p.y))),vec3(12.2,12.2,1.2));\n\tgrass1 = fIntersection(grass1,pRoundBox(p+vec3(0,0,1.5),vec3(11,11,0.5), 1.0));\n\td = fUnion(d,grass1);\n\t\n\tfloat ground1 = pRoundBox(p+vec3(0,0,4.0),vec3(10.7,10.7,2.5),1.0);\n\td = fUnion(d,ground1);\n\t\n\tvec2 blocks = pBlockBricks((mod(p/2.0,3.0)-0.5*3.0));\n\tfloat blockd = blocks.x;\n\t\n\tconst float blocksize = 2.95;\n\tfloat blocki = pBox(p-vec3(3,3,3),vec3(blocksize,blocksize,blocksize));\n\tblocki = fUnion(blocki, pBox(p-vec3(3,9,3),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(9,3,3),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(-9,3,9),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(9,-9,15),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(9,-9,9),vec3(blocksize,blocksize,blocksize)));\n\tblocki = fUnion(blocki, pBox(p-vec3(-9,-9,3),vec3(blocksize,blocksize,blocksize)));\n\t\n\tblockd = fIntersection(blockd, blocki);\n\t\n\td = fUnion(d,blockd);\n\t\n\t\n\treturn d;\n}\n\n\nvec3 normalFunction(vec3 p)\n{\n\tconst float eps = 0.01;\n\tfloat m;\n    vec3 n = vec3( (distf(vec3(p.x-eps,p.y,p.z),m) - distf(vec3(p.x+eps,p.y,p.z),m)),\n                   (distf(vec3(p.x,p.y-eps,p.z),m) - distf(vec3(p.x,p.y+eps,p.z),m)),\n                   (distf(vec3(p.x,p.y,p.z-eps),m) - distf(vec3(p.x,p.y,p.z+eps),m))\n\t\t\t\t );\n    return normalize( n );\n}\n\nvec4 raymarch(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.1;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 0.0;\n\t\n\tfloat material = 0.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(pos, material);\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += distEval * RAYMARCH_DOWNSTEP;\n\t}\n\t\n\t\n\tif (dist >= maxDist) {\n\t\tmaterial = 0.0;\n\t}\n\t\n\treturn vec4(dist, material, 0.0, 0.0);\n}\n\nfloat shadow(vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < SHADOW_ITERATIONS; i++) {\n\t\tfloat m;\n        float h = distf2(from + increment * t,m);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, 8.0 * h / t);\n        t += SHADOW_STEP;\n    }\n    return res;\n}\n\nvec4 getPixel(vec3 fromcenter, vec3 from, vec3 to, vec3 increment)\n{\n\tvec4 c = raymarch(from, increment);\n\t\n\tvec3 hitPos = from + increment * c.x;\n\tvec3 normal = normalFunction(hitPos);\n\tif (c.y == 2.0) {\n\t\tnormal -= texture(iChannel1, (hitPos.yz + hitPos.zx) / 10.0).xyz * 0.8;\n\t\tnormal = normalize(normal);\n\t} else if (c.y == 3.0) {\n\t\tnormal += texture(iChannel1, (hitPos.yz + hitPos.zx) / 10.0).xyz * 0.8;\n\t\tnormal = normalize(normal);\n\t}\n\t\n\tvec3 lightPos = -normalize(hitPos - (fromcenter + vec3(0,0,-10)));\n\t\n\tfloat diffuse = max(0.0, dot(normal, -lightPos)) * 0.3 + 0.7;\n\tfloat shade = \n\t\t#ifdef SHADOWS\n\t\t\tshadow(hitPos, -normalize(hitPos - (fromcenter + vec3(0,0,10)))) * 0.5 + 0.5;\n\t\t#else\n\t\t\t1.0;\n\t\t#endif\n\tfloat specular = 0.0;\t\n\t\t#ifdef SPECULAR\n\t\tif (dot(normal, -lightPos) < 0.0) {\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow(max(0.0,\n\t\t\t\t\tdot(reflect(-lightPos, normal), normalize(from - hitPos))), 50.0);\n\t\t}\n\t\t#endif\n\t\n\t\n\tvec4 m = vec4(0,0,0,1);\n\t\n\tif (c.y == 1.0) {\n\t\tm = vec4(1,1,1,1) *\n\t\t\tclamp((40.0 - length(hitPos.xy)) / 40.0, 0.0, 1.0);\n\t} else if (c.y == 2.0) {\n\t\tm = vec4(0.3,0.9,0.1,1) * (texture(iChannel0, hitPos.xy / 20.0) * 0.3 + 0.7);\n\t} else if (c.y == 3.0) {\n\t\tm = vec4(1,0.55,0.3,1) * (texture(iChannel1, (hitPos.yz + hitPos.zx) / 10.0) * 0.3 + 0.7);;\n\t}\n\t\n\t\n\treturn (m * diffuse + vec4(1,1,1,1) * specular) * shade;\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\t// Camera\n\t\n\tvec2 resolution = vec2(iResolution.x / 2.0, iResolution.y);\n\tvec2 coord;\n\tint eye;\n\tif (fragCoord.x < resolution.x) {\n\t\teye = 0;\n\t\tcoord = fragCoord.xy;\n\t} else {\n\t\tcoord = vec2(fragCoord.x - resolution.x,fragCoord.y);\n\t\teye = 1;\n\t}\n\t\n\tvec2 q = (coord/resolution.xy);\n    vec2 p = -1.0+2.0*q;\n\tp.x *= -(iResolution.x/2.0)/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n\t// camera\t\n\tfloat dist = 32.0;\n\t\n\tfloat eyedisp = (eye == 0 ? -0.15 : 0.15);\n\t\n\tvec3 ta = vec3(0,0,6);\n\tvec3 ro = vec3(cos((iTime + eyedisp) / 2.0) * dist,\n\t\t\t\t   sin((iTime + eyedisp) / 2.0) * dist,\n\t\t\t\t   cos((iTime) / 4.0) * 10.0 + 10.0);\n\tvec3 roe = vec3(cos((iTime) / 2.0) * dist,\n\t\t\t\t   sin((iTime) / 2.0) * dist,\n\t\t\t\t   cos((iTime) / 4.0) * 10.0 + 10.0);\n\t\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 0.0, 1.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\t\n\tif (length(coord - vec2(resolution.x / 2.0, resolution.y - 30.0)) < 10.0) {\n\t\tfragColor = vec4(1,1,1,1);\n\t} else {\n\t\tvec4 col = getPixel(roe, ro, ta, rd);\n        col = pow(col, vec4(1.0 / 2.2));\n        col = col*1.6-0.7;\n        fragColor = col;\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}