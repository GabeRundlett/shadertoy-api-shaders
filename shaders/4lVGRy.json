{
    "Shader": {
        "info": {
            "date": "1475237130",
            "description": "Mouse to look around. The camera switches every 30 seconds, there are currently 8 different paths.\n\nIt is meant to be slow pace / viewed at normal speed, but right arrow lets you fast forward.\n\n",
            "flags": 16,
            "hasliked": 0,
            "id": "4lVGRy",
            "likes": 133,
            "name": "Orbital Flights",
            "published": 3,
            "tags": [
                "clouds",
                "earth",
                "space",
                "planet",
                "atmosphere",
                "keplerorbit"
            ],
            "usePreview": 1,
            "username": "blackjero",
            "viewed": 8591
        },
        "renderpass": [
            {
                "code": "// Orbital Flight by Jerome Liard, August 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4lVGRy\n\n// Mouse to look around. The camera switches every 30 seconds, there are currently 8 different paths.\n// It is meant to be slow pace, but right arrow lets you fast forward.\n\n// Some camera paths are kepler orbits, others are just lookats.\n// Atmosphere sections of the shader could be way faster using buffers, but I just brute forced instead.\n// Disclaimer: important physical constants use garbage values, also there is no gamma correction.\n\n// The shader tries to make the most of shadertoy's mushroom texture using layering,\n// tiling, bombing of vortex distortions and silly exaggerations to make clouds shine more in the penumbra zone.\n\n//#define FORCE_CAMERA 2.0 // force camera, int values in [0,CAMERA_NUM[\n#define CAMERA_TIME_RESET // make camera predictable by resetting\n#define CAMERA_PERIOD 30.0 // time we stay on each camera, in seconds\n#define GLOBALTIME (iTime+0.0) // offset sets initial view\n//#define GLOBALTIME (CAMERA_PERIOD*0.0+25.0)\n\n#define CAMERA_NUM 8.0\n\n// set camera order\n#define CAMERA_SPECULAR_CLOSE   0.0\n#define CAMERA_CLOUDS           1.0\n#define CAMERA_TAKE_OFF_BLUE    2.0\n#define CAMERA_ORBITING_FAR     3.0\n#define CAMERA_SPECULAR_FAR     4.0\n#define CAMERA_TAKE_OFF_SUNRISE 5.0\n#define CAMERA_ORBITING_CLOSE   6.0\n#define CAMERA_MOON_WIP         7.0 // moon has no surface shader yet...\n\n#define CLOUD_FLOW\n#define EARTH_ROTATION\n//#define HD_BLACK_BANDS\n//#define SUPER_SAMPLE_HORIZON\n//#define NO_EXPOSE\n\n#define PI\t\t\t3.141592654\n#define FLT_MAX\t\t1000000.0\n\n#define RED\t\t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE\t\tvec3(0,0,1)\n#define WHITE\t\tvec3(1,1,1)\n#define BLACK\t\tvec3(0,0,0)\n#define MAGENTA\t\tvec3(1,0,1)\n#define YELLOW\t\tvec3(1,1,0)\n#define CYAN\t\tvec3(0,1,1)\n#define GREY50\t\tvec3(0.5,0.5,0.5)\n\n#define R01         vec2( 0.999847695, 0.017452406 )\n\n#define const\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\nfloat hash11( float p )\n{\n\tvec2 p2 = fract( vec2( p * 5.3983, p * 5.4427 ) );\n\tp2 += dot( p2.yx, p2.xy + vec2( 21.5351, 14.3137 ) );\n\treturn fract( p2.x * p2.y * 95.4337 );\n}\n\nvec3 hash32( vec2 p )\n{\n\tp  = fract( p * vec2( 5.3983, 5.4427 ) );\n\tp += dot( p.yx, p.xy +  vec2( 21.5351, 14.3137 ) );\n\treturn fract( vec3( p.x * p.y * 95.4337, p.x * p.y * 97.597, p.x * p.y * 93.8365 ) );\n}\n\nvec4 xyz1( vec3 v ) { return vec4( v, 1. ); }\nvec4 xyz0( vec3 v ) { return vec4( v, 0. ); }\nvec3 xy0( vec2 v ) { return vec3( v, 0. ); }\nvec4 xy01( vec2 v ) { return vec4( v, 0., 1. ); }\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec2 smoothstep_unchecked( vec2 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nfloat smoothstep_unchecked_6( float x ) { return x * x * x * x * x * ( 6.0 - 5.0 * x ); }\nfloat smoothbump( float c, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - c ), r ) / r ); }\nfloat remap( float x, float a, float b ) { return clamp( ( x - a ) / ( b - a ), 0., 1. ); }\nfloat tri( float x, float spacing ) { return spacing - ( abs( ( spacing * fract( x / spacing ) - spacing * 0.5 ) ) + spacing * 0.5 ); }\nfloat tri( float x ) { return 1.0 - abs( fract( x * 0.5 ) - 0.5 ) * 2.0; }\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat contrast( float x, float s ) { return ( x - 0.5 ) * s + 0.5; }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nfloat pow3( float x ) { return x * x * x; }\nfloat pow4( float x ) { x *= x; x *= x; return x; }\nvec4 pow2( vec4 x ) { return x * x; }\nvec4 pow3( vec4 x ) { return x * x * x; }\nvec4 pow4( vec4 x ) { x *= x; x *= x; return x; }\nfloat soft_max( float x, float y, float k ) { return log( exp( k * x ) + exp( k * y ) ) / k; }\nfloat soft_max( float x, float y, float z, float k ) { return log( exp( k * x ) + exp( k * y ) + exp( k * z ) ) / k; }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy )\n{\n\tRay view_ray;\n\tview_ray.o = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z;\n\tview_ray.d = normalize( view_ray.o );\n\treturn view_ray;\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n\tvec3 x = normalize( cross( up, z ) );\n\tvec3 y = cross( z, x );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) ));\n}\n\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\nvec3 zup_spherical_coords_to_vector( float theta, float phi )\n{\n\tvec2 theta_vec = unit_vector2( theta );\n\tvec2 phi_vec = unit_vector2( phi );\n\treturn vec3( theta_vec.y * phi_vec, theta_vec.x );\n}\n\nmat4 zup_spherical_lookat2( float theta, float phi )\n{\n\tvec3 z = zup_spherical_coords_to_vector( theta, phi );\n\tvec3 x = zup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 y = cross( z, x );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) ));\n}\n\nvec3 yup_spherical_coords_to_vector( float theta, float phi )\n{\n\treturn zup_spherical_coords_to_vector( theta, phi ).yzx;\n}\n\nmat4 yup_spherical_offset( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn (mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) ));\n}\n\nmat4 z_rotation( float angle )\n{\n\tvec2 v = unit_vector2( angle );\n\treturn mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) );\n}\n\n// use with constants...\n#define POW0(x) 1.0\n#define POW1(x) (x)\n#define POW2(x) (POW1(x)*(x))\n#define POW3(x) (POW2(x)*(x))\n#define POW4(x) (POW3(x)*(x))\n#define POW5(x) (POW4(x)*(x))\n#define POW6(x) (POW5(x)*(x))\n\n// project this on line (O,d), d is assumed to be unit length\nvec3 project_on_line1( vec3 P, vec3 O, vec3 d ) { return O + d * dot( P - O, d ); }\n\n#define layered5_pass_scale(func,p,a)((func(p,POW0(2.0),a)*POW1(0.5)+func(p,POW1(2.0),a)*POW2(0.5)+func(p,POW2(2.0),a)*POW3(0.5)+func(p,POW3(2.0),a)*POW4(0.5)+func(p,POW4(2.0),a)*POW5(0.5))*(1.0/(1.0-POW5(0.5))))\n\nstruct NoiseTiledParams\n{\n\tvec3 eye, n, p;\n\tfloat bias;\n};\n\nvec2 grid3( vec2 x, vec2 r ) { return smoothstep( r, vec2( 1.0 ), abs( ( fract( x ) - vec2( 0.5 ) ) * 2.0 ) ); }\n\nfloat tile_tex( in vec2 uv, float s, NoiseTiledParams ntp )\n{\n\tuv *= s;\n\n\tfloat bias = 0.0;\n\n\tfloat edge = 1.0 - dot( normalize( ntp.eye - ntp.p ), ntp.n );\n\tbias = -1.2 * edge; // bias the mipmap blur horror on edges\n\n\tbias += ntp.bias;\n\n\t// make the texture tilable\n\tfloat a0 = texture( iChannel1, vec2( uv.x - 0.0, uv.y - 0.0 ), bias ).x; // main image\n\tfloat b0 = texture( iChannel1, vec2( uv.x - 0.0, uv.y - 0.5 ), bias ).x; // fill seams\n\t// it's ok to fract on the seam filling lookups\n\t// without fract we are smooth tiled everywhere but at mipmap horror line\n\tfloat a1 = texture( iChannel1, vec2( fract( uv.x - 0.5 ), uv.y - 0.0 ), bias ).x; // fill seams\n\tfloat b1 = texture( iChannel1, vec2( fract( uv.x - 0.5 ), uv.y - 0.5 ), bias ).x; // fill seams\n\n\tfloat r = 1.0 - 0.2; // note: don't divide by s... 0,1 here\n\tuv = grid3( uv, vec2( r ) );\n\treturn mix( mix( a0, b0, uv.y ), mix( a1, b1, uv.y ), uv.x );\n}\n\nfloat fbm5_tiled_clouds( vec2 p, NoiseTiledParams ntp ) { return layered5_pass_scale( tile_tex, p, ntp ); }\n\n// just return the delta\nvec3 vortex( vec2 q, float max_twist, float aa_scale )\n{\n\tvec2 c = vec2( 0.5, 0.5 );\n\tfloat r0 = 0.5;\n\tvec2 v = ( q - c );\n\tfloat r = length( v );\n\tfloat x = min( r / r0, 1.0 );\n\tfloat aa = pow2( 1.0 - x );\n\treturn vec3( c + rotate_with_angle( q - c, aa * max_twist ) - q, aa * aa_scale );\n}\n\nvec3 vortex_bombing( vec2 p, float scale, float max_twist, float aa_scale, float probability )\n{\n\tp *= scale;\n\tvec2 pi = floor( p );\n\tvec2 pf = fract( p );\n\tvec3 x = vec3( 0.0, 0.0, 0.0 );\n\tfor ( int i = -1; i <= 1; ++i )\n\t{\n\t\tfor ( int j = -1; j <= 1; ++j )\n\t\t{\n\t\t\tvec2 o = vec2( float( i ), float( j ) );\n\t\t\tvec2 pj = pi + o;\n\t\t\tpj.x = mod( pj.x, scale ); // we are mapping a sphere so want same distortion at the u=0, u=1 limit\n\t\t\tvec3 rj = hash32( pj );\n\t\t\tif ( rj.z <= probability ) x += vortex( pf - o - rj.xy, max_twist * rj.z, aa_scale * rj.z ); //p - ( pj + rj.xy ) == ( pi + pf ) - ( pj + rj.xy ) == pf - o - rj.xy\n\t\t}\n\t}\n\treturn x;\n}\n\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\n\nvec2 sphere_trace( Ray ray, float radius, vec3 C )\n{\n\tvec3 O = ray.o;\n\tvec3 d = ray.d;\n\tfloat tp = dot( C - O, d ); // P = project C on line (O,d)\n\tvec3 P = O + d * tp;\n\tfloat h_sqr = lensqr( P - C );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n//\tbool start_inside = lensqr( O - C ) <= radius_sqr; // start inside the sphere?\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n//\tif ( start_inside )\treturn vec2(FLT_MAX,tp+dt);\t// order In->O->If // record only far hit If\n//\tif ( tp < 0.0 )\treturn vec2(FLT_MAX,FLT_MAX); // order In->If->O // O is outside the sphere and beyhond If, no hit\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\n#define earth_center vec3(0.0,0.0,0.0)\n//const float atm_scale=1e+3f; // 1=1m\n#define atm_scale 1.0 // 1=1km\n#define sun_direction vec3(0.0,1.0,0.0) // normalized please\nconst float earth_angular_velocity = ( 2.0 * PI / ( 24.0 * 60.0 * 60.0 ) );\nconst float earth_radius = 6378.15 * atm_scale;\nconst float sun_radius = 6.955e+5 * atm_scale; // for render only\n#define sun_dist (1.49e+8*atm_scale) // for render only\nconst float sun_cos = 0.999989; // for render only\nconst float sun_solid_angle = 0.0093355;  // sun view angle\nconst vec3 sun_center = earth_center + sun_direction * sun_dist;\n//const vec3 moon_direction=sun_direction; // full sun eclipse\n#define moon_direction /*normalize(*/vec3(1.0,0.0,0.0)/*)*/\t// moon close to sun\n//const vec3 moon_direction=normalize(vec3(0.01f,1.0,0.0)); // moon close to sun\n//const vec3 moon_direction=normalize(vec3(0.015f,1.0,-0.02f));\t// moon close to sun, a bit far appart\n//const vec3 moon_direction=normalize(vec3(0.0,-1.0,0.0)); // moon fully occluded\n//const vec3 moon_direction=normalize(vec3(0.016f,-1.0,0.0)); // half moon\nconst float moon_radius = 1738.14 * atm_scale;\n#define moon_dist (384400.0*atm_scale)\nconst float moon_cos = 0.99999;\nconst vec3 moon_center = earth_center + moon_direction * moon_dist;\nconst float H0_r = 0.7994 * atm_scale; // normally this is 8km\nconst float H0_m = 1.2 * atm_scale;\nconst float atm_max = 20.0 * atm_scale; // as small as possible, large enough to accomodate H0_ values\nconst vec3 beta_r = 2.504 * ( 1e+3f / atm_scale ) * vec3( 5.19673e-006, 1.21427e-005, 2.96453e-005 ); // fudge factor & account for km\nconst vec3 beta_m = 2.504 * ( 1e+3f / atm_scale ) * vec3( 5.19673e-006, 1.21427e-005, 2.96453e-005 ); // beta_m is normally a scalar (2.10e-005/m in \"Precomputed Atmospheric Scattering\" Fig7), but I tweaked this shader before fixing the constants\nconst vec3 Is = vec3( 1.0, 1.0, 1.0 ) * 35.0;\nconst vec3 earth_diffuse_reflection = vec3( 0.2 );\nconst float cloud_start = 1.0 * atm_scale;\nconst float cloud_end = 10.0 * atm_scale;\nconst float ie_cost_min = -0.3420; //110deg\n\nfloat sunh( float viewdist )\n{\n\treturn viewdist * ( sun_radius / sun_dist );\n//\treturn viewdist * tan( sun_solid_angle * 0.5 );\n}\n\n// params for Ie term manual fit\nstruct IeApproxS\n{\n\tfloat a;\n\tfloat k;\n\tfloat sx;\n\tfloat sy;\n\tfloat last_bit;\n};\n\nIeApproxS ie_params_r;\nIeApproxS ie_params_g;\nIeApproxS ie_params_b;\n\nvec2 calc_rho( float h ) { return exp( -vec2( h ) / vec2( H0_r, H0_m ) ); }\n\nstruct vec6 { vec3 r; vec3 m; };\n\nvec6 mkvec6( vec2 s ) { vec6 val; val.r = vec3( s.x ); val.m = vec3( s.y ); return val; }\nvec6 mkvec6( float s ) { return mkvec6( vec2( s, s ) ); }\n\nvoid add_vec6( inout vec6 od, vec6 value, float ds )\n{\n\tod.r += value.r * beta_r * ds;\n\tod.m += value.m * beta_m * ds;\n}\n\nvec6 opticalDepth( Ray ray, float t, float t2 )\n{\n\tvec6 ret = mkvec6( 0.0 );\n\t#define num_segments 20\n\tfloat dt = ( t2 - t ) / float( num_segments );\n\tfor ( int i = 0; i < num_segments + 1; ++i )\n\t{\n\t\tvec3 p = ray.o + ray.d * t;\n\t\tvec2 rho = calc_rho( length( p - earth_center ) - earth_radius );\n\t\tadd_vec6( ret, mkvec6( rho ), dt * ( ( i == 0 || i == num_segments ) ? 0.5 : 1.0 ) );\n\t\tt += dt;\n\t}\n\treturn ret;\n}\n\n// http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\nfloat CornetteSingleScatteringPhaseFunction( float cos_theta, float g ) { float g2 = g * g; return 3.0 * ( 1.0 - g2 ) * ( 1.0 + pow2( cos_theta ) ) / ( 2.0 * ( 2.0 + g2 ) * pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 ) ); }\n\n// == CornetteSingleScatteringPhaseFunction( cos_theta, 0.0 )\nfloat RayleighScattering( float cos_theta ) { return 0.75 * ( 1.0 + cos_theta * cos_theta ); }\n\n// https://www.astro.umd.edu/~jph/HG_note.pdf HG, g in [-1,1]\nfloat HenyeyGreensteinPhaseFunction( float cos_theta, float g ) { float g2 = g * g; return ( 1.0 / ( 4.0 * PI ) ) * ( 1.0 - g2 ) / pow( 1.0 + g2 - 2.0 * g * cos_theta, 1.5 ); }\n\nfloat calc_Fr_r( float cos_theta ) { return RayleighScattering( cos_theta  ); }\nfloat calc_Fr_m( float cos_theta, float g ) { return CornetteSingleScatteringPhaseFunction( cos_theta, g ); }\n\nbool in_earth_shadow( vec3 p )\n{\n\treturn ( dot( p, sun_direction ) < 0.0 )\n\t\t   && ( lensqr( p - project_on_line1( p, earth_center, sun_direction ) ) < earth_radius * earth_radius );\n}\n\nbool in_moon_shadow( vec3 p )\n{\n\treturn ( dot( p - moon_center, sun_direction ) < 0.0 )\n\t\t   && ( lensqr( p - project_on_line1( p, moon_center, sun_direction ) ) < moon_radius * moon_radius );\n}\n\n// this is a manual fit of the offline precalculated Ie 1d table (with various wrong physical constant) for each r,g,b, plus slight tweaks\nfloat ie_approx_S( float cos_alpha, IeApproxS params )\n{\n\tfloat y =\n\t\tsoft_max( cos_alpha * params.sx, params.a, params.k ) * params.sy\n\t\t- soft_max( 0.0, params.a, params.k ) * params.sy;\n\n\tfloat c = 0.98;\n\tif ( cos_alpha > c ) y *= ( 1.0 + params.last_bit * ( cos_alpha - c ) / ( 1.0 - c ) );\n\treturn max( 0.0, y );\n}\n\nvoid Ie_ie_params_init()\n{\n\tie_params_r.a = 1.07143104;\n\tie_params_r.k = 0.578571617;\n\tie_params_r.sx = 12.857152938;\n\tie_params_r.sy = 2.785715818;\n\tie_params_r.last_bit = 0.042857192;\n\n\tie_params_g.a = 5.250002384;\n\tie_params_g.k = 0.385714441;\n\tie_params_g.sx = 24.000009536;\n\tie_params_g.sy = 1.357144474;\n\tie_params_g.last_bit = 0.126428619;\n\n\tie_params_b.a = 7.285716533;\n\tie_params_b.k = 0.435714453;\n\tie_params_b.sx = 13.285723686;\n\tie_params_b.sy = 2.928573131;\n\tie_params_b.last_bit = 0.300000011;\n}\n\nvec3 calc_Ie_shaderfunc( float cos_alpha )\n{\n\tIe_ie_params_init();\n\tfloat bleed = 0.02; //0.0 means no bleed, sunset cameras need enough bleeding to look interesting\n\tcos_alpha = 1.0 + ( cos_alpha - 1.0 ) * ( 1.0 - bleed ); // exaggerate Ie bleed a little bit\n\tcos_alpha = clamp( cos_alpha, ie_cost_min, 1.0 - 0.019 ); // cos alpha=1 has a weird blob, clamp a bit...\n\treturn vec3( ie_approx_S( cos_alpha, ie_params_r ),\n\t\t\t\t ie_approx_S( cos_alpha, ie_params_g ),\n\t\t\t\t ie_approx_S( cos_alpha, ie_params_b ) );\n}\n\nstruct LameTweaks\n{\n\tfloat earth_rot_time;\n\tfloat cloud_flow_time;\n\t// no PBR no life\n\tfloat specular_hack;\n\tvec3 cloud_hack;\n};\n\nfloat cloudSphereMap( vec2 p, mat4 camera, vec3 n, float bias, LameTweaks lame_tweaks )\n{\n\tvec2 p0 = p;\n\n\tfloat pole = 0.1;\n\tp.y = ( p.y - pole ) / ( 1.0 - 2.0 * pole );\n\n\t// p0 is in x 0,1\n\t// q0 is in x 0,2\n\n\tvec3 q = vec3( p * vec2( 2, 1 ), 0.0 );\n\n\tvec3 q0 = q;\n\n//\tq += vortex_bombing( q.xy,  1.0, 1.0, 1.0, 0.0 ) * POW0( 0.5 ); // 1\n//\tq += vortex_bombing( q.xy,  2.0, 1.0, 1.0, 0.0 ) * POW1( 0.5 ); // 2\n//\tq += vortex_bombing( q.xy,  4.0, 1.0, 1.0, 0.0 ) * POW2( 0.5 ); // 3\n\tq += vortex_bombing( q.xy,  8.0, 3.0, 1.0, 0.9 ) * POW3( 0.5 ); // 4\n//\tq += vortex_bombing( q.xy, 16.0, 3.0, 1.0, 1.0 ) * POW4( 0.5 ); // 5\n\tq += vortex_bombing( q.xy, 32.0, 2.7, 5.5, 0.85 ) * POW5( 0.5 ); // 6\n//\tq += vortex_bombing( q.xy, 64.0, 1.0, 1.0, 0.0 ) * POW6( 0.5 ); // 7\n\n\tvec2 qoff = vec2( 0.0, 0 );\n#ifdef CLOUD_FLOW\n\tqoff.x = lame_tweaks.cloud_flow_time * earth_angular_velocity; //cloud flow (doesn't fix black line)\n#endif\n\n\tNoiseTiledParams ntp;\n\tntp.eye = camera[3].xyz;\n\tntp.n = n;\n\tntp.p = n * earth_radius;\n\tntp.bias = bias;\n\n\tfloat a = fbm5_tiled_clouds( q.xy * 4.0 + qoff, ntp );\n\n\ta *= 1.0 - smoothstep( 0.5 - pole * 3.4, 0.5, abs( p0.y - 0.5 ) ); // would like to do better than that...\n\n\tfloat a0 = a;\n\n\t{\n\t\t//increase density on areas that have vortices\n\t\ta += length( q - q0 ) * 0.5;\n\t\ta += q.z * q.z * 5.0;\n\t}\n\n\t// add a little bit more oompf detail, helps overall + on cloud close ups\n\ta += a0 * fbm5_tiled_clouds( q.xy * 8.0 + qoff, ntp ) * 0.5;\n\n\ta = contrast( a + 0.05, 2.75 ); // higher contrast = deeper blue if we keep negative cloud\n\ta = soft_max( a, 0.0, 15.0 );\n\treturn a;\n}\n\nfloat cloudMap( vec3 n, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tvec3 n0 = n;\n#ifdef EARTH_ROTATION\n\tn.xy = rotate_with_angle( n.xy, lame_tweaks.earth_rot_time * earth_angular_velocity );\n#endif\n\tfloat theta = acos( n.z );\n\tfloat phi = calc_angle( n.xy ) + PI; // assume range 0,1\n\n\treturn cloudSphereMap( vec2( phi * 0.5, theta ) * ( 1.0 / PI ), camera, n0, bias, lame_tweaks );\n}\n\nstruct CloudOut\n{\n\tvec3 sphere_point, sphere_normal;\n\tfloat cloud;\n\tbool hit;\n};\n\n// just one sphere lookup\nCloudOut cloudTraceFlat( Ray ray, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tCloudOut ret;\n\tret.cloud = 0.0;\n\tret.hit = false;\n\tfloat cloud_height = mix( cloud_start, cloud_end, 0.5 ); // cloud alt should be a number in 0-1\n//\tfloat cloud_height = mix( cloud_start, cloud_end, 10.0 ); // over the top shadow... fun\n\tvec2 tb = sphere_trace( ray, earth_radius, earth_center );\n\tvec2 tc = sphere_trace( ray, earth_radius + cloud_height, earth_center );\n\tif ( tc.x == FLT_MAX ) return ret; // no intersection with cloud sphere\n\tif ( tc.x < 0.0 && tb.x != FLT_MAX && tb.x >= 0.0 ) return ret;\n\tvec3 p = ray.o + ( tc.x < 0.0 ? tc.y : tc.x ) * ray.d;\n\tret.sphere_point = p;\n\tret.sphere_normal = normalize( p - earth_center );\n\tret.cloud = cloudMap( ret.sphere_normal, camera, bias, lame_tweaks );\n\tret.hit = true;\n\treturn ret;\n}\n\n// get a bit of volume\nCloudOut cloudTrace( Ray ray, mat4 camera, float bias, LameTweaks lame_tweaks )\n{\n\tCloudOut ret;\n\tret.cloud = 0.0;\n\tret.hit = false;\n\n\tfloat hcs = mix( cloud_start, cloud_end, 0.55 );\n\tfloat hce = mix( cloud_start, cloud_end, 0.8 );\n\tvec2 ts = sphere_trace( ray, earth_radius + hcs, earth_center ); // start\n\tvec2 te = sphere_trace( ray, earth_radius + hce, earth_center ); // end\n\tif ( te.x == FLT_MAX ) return ret; // ray line doesn't intersect a (and therefore, b since b is inside a)\n\tif ( te.y <= 0.0 ) return ret; // ray line intersects a(atm) but behind us\n\tvec2 range;\n\tif ( ts.x == FLT_MAX )\n\t{\n\t\t// inside cloud altitude range, looking at upper cloud shell\n\t\t// ray line intersects a\n\t\t// ray line doesn't intersect b\n\t\trange.x = max( 0.0, te.x );\n\t\trange.y = te.y;\n\t}\n\telse\n\t{\n\t\t// ray line intersects a\n\t\t// ray line intersects b\n\t\tif ( te.x > 0.0 )\n\t\t{\n\t\t\t// hitting clouds from above\n\t\t\t// ray hitting a from outside\n\t\t\trange.x = te.x;\n\t\t\trange.y = ts.x;\n\t\t}\n\t\telse if ( ts.x > 0.0 )\n\t\t{\n\t\t\t// below lower cloud layer, looking at lower cloud layer\n\t\t\trange.x = 0.0;\n\t\t\trange.y = ts.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// between cloud layers, looking at upper cloud layer\n\t\t\trange.x = 0.0;\n\t\t\trange.y = te.y;\n\t\t}\n\t}\n\n\tfloat t = range.x;\n\tfloat dt = ( range.y - range.x ) * ( 1.0 / 8.0 );\n\tfloat min_dist = FLT_MAX;\n\tfloat hcdv = 1.0 / ( hce - hcs );\n\n\tfor ( int i = 0; i < 8; ++i )\n\t{\n\t\tvec3 p = ray.o + t * ray.d;\n\t\tfloat hr = length( p - earth_center );\n\t\tfloat hp = hr - earth_radius;\n\t\tvec3 n = ( p - earth_center ) / hr;\n\n\t\tfloat c = cloudMap( n, camera, bias, lame_tweaks );\n\t\tfloat hc = hcs + ( hce - hcs ) * saturate( c );\n\n\t\tfloat dh = hp - hc;\n\n\t\tif ( abs( dh ) < 0.4 && t <= range.y )\n\t\t{\n\t\t\tret.cloud = c;\n\t\t\tret.sphere_normal = n;\n\t\t\tret.hit = true;\n\n\t\t\tt += dt * 0.5; // note: don't break, keep homing\n\t\t}\n\t\telse t += dt;\n\t}\n\n\treturn ret;\n}\n\n// fade shadow term based on distance\nfloat shadow_falloff( vec3 pa, vec3 pb )\n{\n\tvec3 d = ( pa - pb );\n\treturn 1.0 / ( 1.0 + lensqr( d ) * 0.00005 );\n}\n\n// losely based on http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\n\nstruct AtmOut\n{\n\tvec3 vod_attn; //view ray atm scattering\n\tvec3 earth_p;\n\tvec3 earth_n;\n\tbool earth_surface;\n\tvec3 Iv;\n};\n\nvec3 calc_Iv( Ray view_ray, inout AtmOut atm_out, mat4 camera, LameTweaks lame_tweaks )\n{\n\tvec2 te = sphere_trace( view_ray, earth_radius, earth_center );\n\tvec2 ta = sphere_trace( view_ray, earth_radius + atm_max, earth_center );\n\n\tatm_out.earth_surface = ( te.x > 0.0 && te.x != FLT_MAX );\n\tatm_out.vod_attn = vec3( 1.0 );\n\tatm_out.Iv = vec3( 0.0 );\n\n//\tvec3 spacecolor = MAGENTA; // debug\n\tvec3 spacecolor = BLACK;\n\n\tif ( ta.x == FLT_MAX ) return spacecolor; // view_ray line doesn't intersect a (and therefore, e since e is inside a)\n\tif ( ta.y <= 0.0 ) return spacecolor; // return mix(SPACECOLOR,WHITE,0.7);\t// view_ray line intersects a(atm) but behind us\n\tif ( te.x <= 0.0 && te.y >= 0.0 ) return GREEN; // inside (e)earth\n\n\tvec2 range; // range segment we integrate things on along view_ray\n\t\n\tif ( te.x == FLT_MAX ) range = vec2( max( 0.0, ta.x ), ta.y ); // view_ray line intersects a, doesn't intersect e\n\t// view_ray line intersects a and e\n\telse if ( ta.x > 0.0 ) range = vec2( ta.x, te.x ); // ray hitting a from outside atm\n\telse if ( te.x > 0.0 ) range = vec2( 0.0, te.x ); // ray hitting e from inside atm\n\telse range = vec2( 0.0, ta.y ); // ray hitting a from inside atm\n\t\n\tRay sun_ray;\n\tsun_ray.d = sun_direction;\n\n\tfloat tp = range.x;\n\n\t#define num_view_ray_segments 50 // we have to bump this number quite a bit to get decent integration\n\tfloat dl = ( range.y - range.x ) / float( num_view_ray_segments );\n\tif ( dl < 0.0 )\treturn YELLOW;\n\t\n\tvec3 p;\n\tvec6 tppc = mkvec6( 0.0 ); // the last of those is a earth hit -> sun ray when earth_surface is true\n\tvec6 tppa = mkvec6( 0.0 ); // the last of those is a earth hit -> eye ray when earth_surface is true\n\tvec6 Iv_sum = mkvec6( 0.0 );\n\tfor ( int i = 0; i < num_view_ray_segments + 1; ++i )\n\t{\n\t\tp = view_ray.o + view_ray.d * tp;\n\t\tp = earth_center + normalize( p ) * max( earth_radius * 1.00001, length( p ) ); // make sure we don't start inside the earth when P is a hit point\n\t\tvec2 rho = calc_rho( length( p - earth_center ) - earth_radius );\n\t\ttppc = mkvec6( 0.0 );\n\t\tif ( !in_earth_shadow( p ) )\n//\t\tif ( !in_moon_sun_shadow( p ) )\n\t\t{\n\t\t\tsun_ray.o = p;\n\t\t\tvec2 ta_sun = sphere_trace( sun_ray, earth_radius + atm_max, earth_center );\n\t\t\ttppc = opticalDepth( sun_ray, 0.0/*p*/, ta_sun.y/*pc*/ ); // note: ta_sun.y > 0.0\n\t\t\tvec6 tmp;\n\t\t\t#if 1\n\t\t\t// note: this is not the correct way to combine the r,m transmittance at all, but too late to fix\n\t\t\ttmp.r = rho.x * exp( -tppc.r - tppa.r );\n\t\t\ttmp.m = rho.y * exp( -tppc.m - tppa.m );\n\t\t\t#else\n\t\t\t// normally attenuation should affect both\n\t\t\tvec3 tr = exp( -tppc.r - tppa.r - tppc.m - tppa.m );\n\t\t\ttmp.r = rho.x * tr;\n\t\t\ttmp.m = rho.y * tr;\n\t\t\t#endif\n\t\t\tadd_vec6( Iv_sum, tmp, dl * ( ( i == 0 || i == num_view_ray_segments ) ? 0.5 : 1.0 ) );\n\t\t}\n\t\tadd_vec6( tppa, mkvec6( rho ), dl );\n\t\ttp += dl;\n\t}\n\n\tfloat cos_theta = dot( sun_direction, view_ray.d );\n\tvec3 Iv = Is *\n\t\t( ( Iv_sum.r / ( 4.0 * PI ) ) * calc_Fr_r( cos_theta ) + \n\t\t  ( Iv_sum.m / ( 4.0 * PI ) ) * calc_Fr_m( cos_theta, 0.8 ) );\n\n\tatm_out.Iv = Iv;\n\n\tvec3 Ie = vec3( 0, 0, 0 );\n\tvec6 tPaPb = mkvec6( 0.0 );\n\n\tfloat cloud_shadow = 0.0;\n\tfloat specular = 0.0;\n\n\tif ( atm_out.earth_surface )\n\t{\n\t\t//return RED; // check earth pixel\n\t\tp = view_ray.o + view_ray.d * te.x; // note: we shouldn't need to update p here\n\t\tvec3 n = normalize( p - earth_center );\n\t\tfloat cos_alpha = dot( sun_direction, n );\n\t\tIe = calc_Ie_shaderfunc( cos_alpha );\n//\t\ttPaPb = opticalDepth( view_ray, range.x/*Pa*/, te.x/*Pb*/ );\n\t\ttPaPb = tppa; // tppa already has the value\n\n\t\tatm_out.earth_p = p;\n\t\tatm_out.earth_n = n;\n\n\t\tRay cloud_shadow_ray;\n\t\tcloud_shadow_ray.d = sun_direction;\n\t\tcloud_shadow_ray.o = p + n * max( 1.00001, cloud_start * 0.5 ); //anything smaller than cloud_start and greater than a separation epsilon\n\n\t\tvec3 tangent = cross( sun_direction, n );\n\t\tvec3 np = normalize( cross( tangent, sun_direction ) );\n\n//\t\tvec2 acs = unit_vector2( radians( 5.0 ) );\n\t\tvec2 acs = R01;\n\t\tfloat w1 = 1.0;\n\t\tfloat w2 = 0.5;\n\n\t\tCloudOut cs;\n\n\t\tcloud_shadow_ray.d = sun_direction;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w1 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow_ray.d = sun_direction * acs.x + np * acs.y;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w2 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow_ray.d = sun_direction * acs.x - np * acs.y;\n\t\tcs = cloudTraceFlat( cloud_shadow_ray, camera, 0.0, lame_tweaks );\n\t\tcloud_shadow += cs.cloud * w2 * shadow_falloff( cloud_shadow_ray.o, cs.sphere_point );\n\n\t\tcloud_shadow *= ( 1.0 / ( w1 + w2 * 2.0 ) );\n\n\t\tvec3 l = sun_direction;\n\t\tvec3 e = -view_ray.d;\n\t\tvec3 h = normalize( e + l );\n\t\tfloat dp = dot( n, l );\n\n\t\tfloat specular_power = 75.0;\n\n\t\tspecular = pow( max( dot( n, h ), 0.0 ), specular_power )\n\t\t\t* ( ( specular_power + 8.0 ) / ( 8.0 * PI ) )\n\t\t\t* max( 0.0, dp );\n\t}\n\n\tCloudOut co = cloudTrace( view_ray, camera, 0.0, lame_tweaks );\n\tfloat cloud = co.cloud;\n\n\tatm_out.vod_attn = exp( -tppa.r ); // for sun attn\n\n\tfloat dp = dot( co.sphere_normal, sun_direction );\n\n\tfloat s = ( 1.0 - saturate( cloud_shadow * ( 1.0 - cloud ) ) );\n\n//\treturn vec3( ( 1.0 - s ) * 3.0, cloud, 0.0 );\n\n\tfloat earth_diffuse = 0.008;  // controls blue depth\n\n\treturn ( 0.0\n\t\t\t + earth_diffuse * s\n\t\t\t + specular * ( 1.0 - saturate( cloud ) ) * lame_tweaks.specular_hack * s * s\n\t\t\t + cloud\n\t\t\t * // this add specks of gold to the clouds in the penumbra zone\n\t\t\t ( 1.0\n\t\t\t   + smoothstep( -0.02, 0.012, dp )\n\t\t\t   * exp( ( cloud - cloud_shadow ) * lame_tweaks.cloud_hack.x )\n\t\t\t   * lame_tweaks.cloud_hack.y ) * lame_tweaks.cloud_hack.z\n\n\t\t\t) * Ie * exp( -tPaPb.r - tPaPb.m )\n\n\t\t   + Iv * ( 2.4 - ( 1.0 - s ) * 0.7 );\n}\n\n// linearly remap nl, cut is the value of nl that maps to 0\nfloat warp_nl( float nl, float cut ) { return max( 0.0, ( nl - cut ) ) / ( 1.0 - cut ); }\n\nfloat noise1s( in float x )\n{\n\tx -= 0.5;\n\n\tfloat x0 = floor( x );\n\tfloat y0 = hash11( x0 );\n\tfloat y1 = hash11( x0 + 1.0 );\n\n\treturn mix( y0, y1, smoothstep_unchecked( x - x0 ) );\n}\n\nfloat calcFallOff( float sd, float r, float p1, float p2 )\n{\n\tfloat sd_last = sun_cos - r; //length of rays\n\tfloat g = 1.0 - saturate( max( sun_cos - sd, 0.0 ) / ( sun_cos - sd_last ) );\n\treturn powerful_scurve( g, p1, p2 );\n}\n\nvec3 earthShader( Ray view_ray, mat4 camera, LameTweaks lame_tweaks, float exposure )\n{\n\tAtmOut atm_out;\n\n\tvec3 ret = calc_Iv( view_ray, atm_out, camera, lame_tweaks );\n\n\tvec3 sun_color = atm_out.vod_attn * vec3( 1.0, 0.85, 0.71 );\n\tfloat sun_intensity = 0.0;\n\n\tfloat sd = dot( normalize( view_ray.d ), sun_direction ); // assumes sun very far... view_ray.d needs renormalize for some obscure reason\n\n\tbool long_sun_flare = true;\n\tbool thin_flares = true;\n\tbool sun_glare = true;\n\tbool earth_clamped_sun_glare = true;\n\n\tif ( !atm_out.earth_surface )\n\t{\n\t\tvec2 tm = sphere_trace( view_ray, moon_radius, moon_center );\n\t\tif ( tm.x != FLT_MAX && tm.x > 0.0 )\n\t\t{\n\t\t\tvec3 moon_P = view_ray.o + view_ray.d * tm.x;\n\t\t\tfloat moon_sun_shadow = warp_nl( dot( normalize( moon_P - moon_center ), sun_direction ), -0.01 );\n\t\t\tfloat earth_sun_shadow = in_earth_shadow( moon_P ) ? 0.0 : 1.0; // fixme: don't want sharp... precalc or fit something\n\n\t\t\tret += vec3( 0.04 );\n\t\t\tret += min( pow( moon_sun_shadow, 0.57 ), earth_sun_shadow ) * atm_out.vod_attn * 2.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( earth_clamped_sun_glare )\n\t\t\t{\n\t\t\t\tfloat gs = calcFallOff( sd, 0.01, 1.4, 0.05 );\n\t\t\t\tsun_intensity += 16.0 * gs;\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat theta = acos( clamp( sd, -1., 1. ) );\n\tfloat phi = calc_angle( view_ray.d.zx );\n\tvec2 phi_vec = unit_vector2( phi );\n\n\tfloat sun_visibility = 0.0;\n\tvec3 ep_sv = view_ray.o + sun_direction * dot( earth_center - view_ray.o, sun_direction );\n\t{\n\t\tfloat sh = sunh( length( ep_sv - view_ray.o ) );\n\t\tfloat h = length( ep_sv - earth_center );\n\t\tsun_visibility = saturate( smoothstep( -sh, sh, h - earth_radius ) );\n//\t\tfloat darkness = saturate( smoothstep( 0, earth_radius - sh, h ) );\n//\t\tif ( sun_visibility != 0.0 ) ret += RED;\n\t}\n\n\tfloat xsum = 0.0;\n\n\tif ( long_sun_flare )\n\t{\n\t\tfloat gs = calcFallOff( sd, 1e-3 * 12., 1.2, 0.07 );\n\n\t\tfloat spacing = 2.0 * PI / 6.0;\n\t\tfor ( int i = 0; i < 6; ++i )\n\t\t{\n\t\t\tvec2 v = unit_vector2( float( i ) * spacing + 0.4 );\n\t\t\tfloat vv = abs( dot( phi_vec * theta, v ) );\n\t\t\tvv /= PI;\n\t\t\tvv *= 0.4;\n\t\t\txsum += exp( -vv * 1500.0 ) * gs * 0.8;\n\t\t}\n\t}\n\n\tif ( thin_flares )\n\t{\n\t\tfloat gs = calcFallOff( sd, 1e-5 * 4.0, 1.4, 0.3 );\n\n\t\t// thin flares\n\t\tfor ( int i = 0; i < 5; ++i )\n\t\t{\n\t\t\tfloat fi = float( i );\n\t\t\tfloat x = noise1s( phi * 3.5 + fi * 3.0 + 0.5 * sin( GLOBALTIME + fi ) );\n\t\t\tx = pow4( x );\n\t\t\tx = max( 0.0, contrast( x, 1.1 ) );\n\t\t\tx = gs * mix( 0.0, 1.0, x );\n\t\t\txsum += x * 2.0 * gs;\n\t\t}\n\t}\n\n\tret += xsum * ( atm_out.earth_surface ? 0.0 : 1.0 ) * pow( sun_visibility, 0.15 );\n\n\tif ( sun_glare )\n\t{\n\t\t// diffuse fall off\n\t\tsun_intensity += exp( -theta / PI * ( atm_out.earth_surface ? 70.0 : 27.0 ) ) * pow( sun_visibility, 0.20 );\n\t}\n\n\tret += sun_intensity * sun_color;\n\n//\tfloat scene_luminance = 0.0;\n//\tscene_luminance = max( 0.0, dot( view_ray.d, sun_direction ) );\n\n#ifndef NO_EXPOSE\n//\tret = 1.0 - exp( -mix( 0.85, 0.05, scene_luminance/**sun_visibility*/ ) * ret );\n\tret = 1.0 - exp( -exposure * ret );\n#endif\n\treturn ret;\n}\n\n// https://en.wikipedia.org/wiki/Kepler%27s_equation\nfloat kepler_eq_solve( float M, float e/*,float& err*/ )\n{\n\tfloat En = M;\n\tif ( e > 0.8 ) En = PI;\n\tfor ( int i = 0; i < 3; ++i ) En = En - ( En - e * sin( En ) - M ) / ( 1.0 - e * cos( En ) );\n//\terr = max( fabsf( ( En - e * sin( En ) - M ) ), err );\n\treturn En;\n}\n\n// n = mean motion n https://en.wikipedia.org/wiki/Mean_motion (consider this as the \"angular speed\")\n// n = 2pi/period\n// p,e see https://en.wikipedia.org/wiki/Kepler%27s_laws_of_planetary_motion\n// p is the scale of the trajectory\n// e the eccentricity, 0 for circle\n// becomes ellipsoid (and smaller, so compensate by increasing p) as we get closer to 1\n// above 0.8 kepler_eq_solve needs more iterations\n// rmin=p/(1+e) closest distance to focus...perihelion\n// rmax=p/(1-e) farthest distance to focus..aphelion\nvec2 kepler_orbit( float t, float p, float e, float n/*, float& err*/ )\n{\n\tfloat M = n * t;\n\tfloat E = kepler_eq_solve( M, e/*,err*/ );\n\tfloat a = p / ( 1.0 - e * e );\n\tfloat b = p / sqrt( 1.0 - e * e );\n\tfloat x = a * ( cos( E ) - e );\n\tfloat y = b * sin( E );\n\treturn vec2( x, y );\n}\n\n// calculate p given rmin\nfloat kepler_orbit_calc_p( float rmin, float e )\n{\n\treturn rmin * ( 1.0 + e );\n}\n\nstruct KeplerOrbit\n{\n\tfloat rmin; // min radius\n\tfloat period;\n\tfloat e; // ellipse eccentricity\n};\n\nstruct KeplerOrbitRetval\n{\n\tvec3 orbit_position;\n\tvec3 orbit_plane_normal;\n};\n\nKeplerOrbitRetval get_earth_camera_path_kepler( float t, in KeplerOrbit ko )\n{\n\tKeplerOrbitRetval ret;\n\t// you can can play with highly elliptical orbits here, see\n\t// http://www.polaris.iastate.edu/EveningStar/Unit4/unit4_sub3.htm\n\tfloat n = 2.0 * PI / ko.period;\n\tvec2 p = kepler_orbit( t, kepler_orbit_calc_p( ko.rmin, ko.e ), ko.e, n );\n\tp = perp( p ); // start on y, where the sun is, symmetry more convenient to tweak orbit period\n#if 1\n\t// define trajectory plane here (theta must be non zero if you want an inclination)\n//\tmat4 rep = zup_spherical_lookat2( radians( 90.0 ), radians( 90.0 ) ); // circle around penumbra zone\n\tmat4 rep = zup_spherical_lookat2( radians( 0.0 ), radians( 0.0 ) ); // trajectory inclination\n\tret.orbit_plane_normal = rep[2].xyz;\n\tret.orbit_position = ( rep * xy01( p ) ).xyz;\n#else\n\tret.orbit_plane_normal = vec3( 0, 0, 1 );\n\tret.orbit_position = xy0( xx );\n#endif\n\treturn ret;\n}\n\nvec3 get_earth_camera_path_iss( float t, inout vec3 up )\n{\n\t// needs high fov values\n\tfloat h = 340.0; //ISS\n\tfloat er = earth_radius / atm_scale;\n\tfloat dtheta = t * ( 27.6e+3 / 3600.0 ) / ( er + h ); //27.6km/h\n\tvec2 xx = unit_vector2( dtheta ) * ( er + h );\n\tmat4 rep = zup_spherical_lookat2( radians( 0.0 ), radians( 0.0 ) ); // trajectory inclination\n\tup = rep[2].xyz;\n\treturn ( rep * xy01( xx ) ).xyz;\n}\n\nstruct TangentView\n{\n\tvec3 target_vector; // sphere center -> target unit vector\n\tvec3 tangent_disk_center;\n\tfloat tangent_disk_radius;\n};\n\nTangentView get_tangent_view( vec3 p, vec3 c, float r )\n{\n\tTangentView ret;\n\tret.target_vector = p - c;\n\tfloat dt = length( ret.target_vector );\n\tret.target_vector /= dt;\n\tfloat e = ( r * r ) / dt;\n\tret.tangent_disk_radius = sqrt( r * r - e * e );\n\tret.tangent_disk_center = c + ret.target_vector * e;\n\treturn ret;\n}\n\n// set view center on tangent of a sphere c,r\nvec3 get_tangent_point( vec3 p, vec3 c, float r, vec3 up )\n{\n\tTangentView tv = get_tangent_view( p, c, r );\n\treturn tv.tangent_disk_center +\n\t\t   tv.tangent_disk_radius * normalize( cross( tv.target_vector, cross( up, tv.target_vector ) ) );\n}\n\n// reflect is builtin so use different name\nfloat myreflect( float x, float a ) { return a + ( a - x ); }\n\n// bounce time to make sure we are always travelling above the lit face of the earth\nfloat bounce_time( float t, float period, inout float fade )\n{\n\tt = mod( t, period );\n\tif ( t > period * 0.5 ) t -= period; // want mirrored time values\n\tfloat r = period * 0.005;\n\tfloat a = period * 0.25;\n\tfade *= 1.0 - smoothbump( a + r, r, clamp( abs( t ), a, a + r + r ) );\n\tif ( abs( t ) > ( a + r ) ) t = myreflect( t, ( ( t < 0.0 ) ? -1.0 : 1.0 ) * period * 0.25 );\n\treturn t;\n}\n\nvec3 rotate_around( vec3 c, vec3 z, vec3 p, float angle )\n{\n\tvec3 v = p - c;\n\tvec3 pp = project_on_line1( p, c, z );\n\tvec3 x = normalize( p - pp );\n\tvec3 y = cross( z, x );\n\tvec2 v2 = vec2( dot( v, x ), dot( v, y ) );\n\tv2 = rotate_with_angle( v2, angle );\n\treturn pp + v2.x * x + v2.y * y;\n}\n\n// can't find the source shadertoy for those functions...\n#define KEY_SPACE 32.\n#define KEY_RIGHT 39.\nbool key_toggle( float ascii ) { return (texture( iChannel0, vec2( ( ascii + .5 ) / 256., 0.75 ) ).x > 0.); }\nbool key_state( float ascii ) { return (texture( iChannel0, vec2( ( ascii + .5 ) / 256., 0.25 ) ).x > 0.); }\n\nmat4 get_earth_camera( inout float tan_half_fovy\n\t\t\t\t\t   , inout float fade\n\t\t\t\t\t   , float time\n\t\t\t\t\t   , out LameTweaks lame_tweaks\n\t\t\t\t\t   , inout float exposure )\n{\n\tvec3 eye = vec3( 0, 0, 2.0 );\n\tvec3 center = vec3( 0, 0, 0 );\n\n\tfloat roll = 0.0;\n\n#define IS_NEXT_INDEX(nn) ( abs( camera_index - nn ) < 0.01 )\n\n#ifdef FORCE_CAMERA\n\tfloat camera_index = FORCE_CAMERA;\n#else\n\tfloat camera_index = mod( floor( time / CAMERA_PERIOD ), CAMERA_NUM );\n#endif\n\tfade = pow2( saturate( tri( time, CAMERA_PERIOD ) ) );\n\n\tfloat camera_time = mod( time, CAMERA_PERIOD );\n\n\tfloat earth_rot_time_scale = 1.0;\n\tfloat earth_rot_time_offset = 0.0;\n\tfloat cloud_flow_time_scale = 1.0;\n\tfloat cloud_flow_time_offset = 0.0;\n\tlame_tweaks.specular_hack = 0.25;\n\tlame_tweaks.cloud_hack = vec3( 2.0, 0.12, 0.5 );\n\n#ifdef CAMERA_TIME_RESET\n\ttime = camera_time;\n#endif\n\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, 0.0 );\n\n\tfloat x = camera_time * ( 1.0 / CAMERA_PERIOD );\n\tfloat xs6 = smoothstep_unchecked_6( x );\n\n\tif ( IS_NEXT_INDEX( CAMERA_ORBITING_CLOSE ) )\n\t{\n\t\tKeplerOrbit ko;\n\t\tko.rmin = earth_radius + atm_max * 100.0;\n\t\tko.period = 60.0 * 180.0;\n\t\tko.e = 0.0024;\n\t\tfloat t = time * 20.0;\n#ifdef CAMERA_TIME_RESET\n\t\tt = bounce_time( t, ko.period, fade );\n#endif\n\t\t// time = 0; // eye should be on y=0,1,0 at time=0\n\t\tKeplerOrbitRetval kr = get_earth_camera_path_kepler( t, ko );\n\t\teye = kr.orbit_position;\n\t\tvec3 up = normalize( cross( kr.orbit_plane_normal, eye ) );\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * 0.98, up );\n\t\ttan_half_fovy = 0.09;\n\t\troll = time * 0.02;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = 2000.0;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tmouse_ctrl = 1.5;\n\t\tmm_offset = vec2( 0.0, 0.0 );\n//\t\texposure = 0.45;\n\t\tlame_tweaks.cloud_hack.z = 0.35;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_ORBITING_FAR ) )\n\t{\n\t\tvec3 up = vec3( 0, 0,  1 );\n\t\tKeplerOrbit ko;\n\t\tko.rmin = earth_radius + atm_max * 100.0;\n\t\tko.period = 60.0 * 25.0;\n\t\tko.e = 0.0024;\n\t\tfloat t = time * 10.0;\n#ifdef CAMERA_TIME_RESET\n\t\tt = bounce_time( t, ko.period, fade );\n#endif\n\t\tKeplerOrbitRetval kr = get_earth_camera_path_kepler( t, ko );\n\t\teye = kr.orbit_position;\n\t\tup = normalize( cross( kr.orbit_plane_normal, eye ) );\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * 0.965, up ); // don't look at real horizon, show more earth\n\t\ttan_half_fovy = 0.3; // 0.3 for sphere\n//\t\troll = time*0.02;\n\t\troll = PI * 3.0 / 4.0;\n\t\tearth_rot_time_scale = 12.0;\n\t\tearth_rot_time_offset = 0.0;\n\t\tcloud_flow_time_scale = 12.0;\n\t\tcloud_flow_time_offset = -10.0;\n\t\tmouse_ctrl = 0.6;\n\t\tmm_offset = vec2( 0.37, -0.08 );\n\t\texposure = 0.75;\n\t\tlame_tweaks.specular_hack = 0.07;\n\t\tlame_tweaks.cloud_hack = vec3( 4.2, 0.12, 0.27 ); // too much decal\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_TAKE_OFF_BLUE ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.382552146, 3.343272924, -0.757502257 ) * cam_scale;\n\t\tvec3 n = normalize( eye );\n\t\tvec3 up = sun_direction;\n\t\teye += n * 500.0 * xs6;\n\t\tcenter = get_tangent_point( eye, earth_center, earth_radius * mix( 1.0, 0.96, xs6 ), up ); // don't look at real horizon, show more earth\n\t\ttan_half_fovy = mix( 0.2, 0.09, xs6 );\n\t\troll = PI * mix( 0.25, -0.02, 1.0 - exp( -x * 2.0 ) );\n\t\tearth_rot_time_scale = 198.0;\n\t\tearth_rot_time_offset = 39.9;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tlame_tweaks.specular_hack = 0.25;\n\t\tlame_tweaks.cloud_hack = vec3( 2.0, 0.12, 0.3 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_CLOUDS ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( -5.704154491, -0.459553778, -3.58820796 ) * cam_scale;\n\t\tcenter = vec3( -5.828063488, -0.007100194, -2.705070018 ) * cam_scale;\n\t\tcenter = eye + ( center - eye ) * mix( 0.8, 0.8, x );\n\t\teye = rotate_around( center, normalize( center ), eye, x * PI * 0.12 );\n\t\ttan_half_fovy = 0.05;\n\t\troll = mix( -0.2, -0.3, x ) * PI;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = -1600.0;\n\t\tcloud_flow_time_scale = 1.0;\n\t\tcloud_flow_time_offset = -900.0;\n\t\tmouse_ctrl = 2.5;\n\t\texposure = 0.8;\n\t\tlame_tweaks.cloud_hack = vec3( 4.0, 0.12, 0.6 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_SPECULAR_FAR ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.421999931, -0.140298634, -3.804290771 ) * cam_scale;\n\t\tcenter = vec3( 5.581956386, 0.285743594, -2.913840293 ) * cam_scale;\n\t\tfloat rt = 0.25;\n\t\teye.xz = rotate_with_angle( eye.xz, PI * rt );\n\t\tcenter.xz = rotate_with_angle( center.xz, PI * rt );\n\t\ttan_half_fovy = 0.62;\n\t\tearth_rot_time_scale = 60.0;\n\t\tearth_rot_time_offset = 20.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 100.0;\n\t\tmouse_ctrl = 0.26;\n\t\tmm_offset = vec2( -0.5, -0.29 );\n\t\tlame_tweaks.specular_hack = 150.0;\n\t\tlame_tweaks.cloud_hack = vec3( 4.5, 0.15, 1.0 );\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_SPECULAR_CLOSE ) )\n\t{\n\t\tfloat cam_scale = 1e+3 * atm_scale;\n\t\teye = vec3( 5.421999931, -0.140298634, -3.804290771 ) * cam_scale;\n\t\tcenter = vec3( 5.581956386, 0.285743594, -2.913840293 ) * cam_scale;\n\t\tfloat r = 0.0603;\n\t\teye.xz = rotate_with_angle( eye.xz, PI * r );\n\t\tcenter.xz = rotate_with_angle( center.xz, PI * r );\n\t\ttan_half_fovy = 0.3;\n\t\tearth_rot_time_scale = 60.0;\n\t\tearth_rot_time_offset = 22.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\tmouse_ctrl = 0.9;\n\t\tmm_offset = vec2( -0.84, -0.28 );\n\t\tlame_tweaks.specular_hack = 100.0;\n\t\tlame_tweaks.cloud_hack = vec3( 3.4, 0.15, 0.9 );\n\t\texposure = 0.5;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_TAKE_OFF_SUNRISE ) )\n\t{\n\t\tfloat at1 = exp( -x * 10.0 ); // anim time 1: approach\n\t\tfloat at2 = smoothstep_unchecked_6( remap( x, 0.3, 1.0 ) ); // anim time 2: ascension\n\t\tfloat r = earth_radius + cloud_start * 5.0 + atm_max * at2 * 200.0;\n\t\tvec3 up = vec3( 0, 0, 0 ); up.zx = unit_vector2( -PI * 0.56 );\n\t\tvec3 sun_pos = sun_dist * sun_direction;\n\t\tvec3 tangent_point = get_tangent_point( sun_pos, earth_center, r, up );\n\t\tcenter = tangent_point;\n\t\tvec3 rail = normalize( sun_pos - tangent_point );\n\t\tfloat d0 = earth_radius * 0.08; // distance to tangent point is d\n\t\tfloat d1 = earth_radius * 0.03;\n\t\teye = tangent_point + rail * mix( -d0, d1, x ); //\n\t\tvec3 end_center = get_tangent_point( eye, earth_center, earth_radius * 0.984, sun_direction );\n\t\tcenter = eye + rail;\n\t\tcenter = mix( center, end_center, at2 );\n\t\ttan_half_fovy = 0.15;\n\t\tearth_rot_time_scale = 1.0;\n\t\tearth_rot_time_offset = 0.0;\n\t\tcloud_flow_time_scale = 10.0;\n\t\tcloud_flow_time_offset = 90.0;\n\t\texposure = mix( 0.4, 0.75, xs6 );\n\t\tlame_tweaks.cloud_hack = vec3( 3.0, 0.12, 0.65 );\n\t\tmm_offset = vec2( 0.0, -0.1 * xs6 );\n\t\tmouse_ctrl = 1.2;\n\t\troll = PI * 0.0;\n\t\tlame_tweaks.specular_hack = 0.1;\n\t}\n\telse if ( IS_NEXT_INDEX( CAMERA_MOON_WIP ) )\n\t{\n\t\tfloat d = earth_radius * 0.5; // distance to tangent point is d\n\t\tfloat r = earth_radius + 4.0 * atm_max;\n\t\tvec3 moon_pos = moon_dist * moon_direction * 1.0;\n\t\tvec3 tangent_point = get_tangent_point( moon_pos, earth_center, r, vec3( 0, 1, 0 ) );\n\t\tcenter = tangent_point;\n\t\teye = tangent_point + d * normalize( tangent_point - moon_pos ); //\n\t\ttan_half_fovy = 0.045;\n\t\tearth_rot_time_scale = 30.0;\n\t\tearth_rot_time_offset = 1700.0;\n\t\tcloud_flow_time_scale = 3.0;\n\t\tcloud_flow_time_offset = 0.0;\n\t\troll = -PI * 0.5;\n\t\tlame_tweaks.cloud_hack = vec3( 2.6, 0.12, 0.22 );\n\t\tmouse_ctrl = 0.5;\n\t\tmm_offset = vec2( -0.07, 0.018 );\n\t}\n\n\tvec3 up = normalize( eye ); // horizontal views\n\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 ) mm = ( iMouse.xy - iResolution.xy * 0.5 ) / ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\n//\tcamera_time = GLOBALTIME; // comment to always show the same time slice\n\tlame_tweaks.cloud_flow_time = ( cloud_flow_time_offset + camera_time ) * cloud_flow_time_scale;\n\tlame_tweaks.earth_rot_time = ( earth_rot_time_offset + camera_time ) * earth_rot_time_scale;\n\n\treturn lookat( eye, center, up ) * z_rotation( roll ) * yup_spherical_offset( mm.y, mm.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 resolution = iResolution.xy;\n\tvec2 pixel = fragCoord.xy;\n\tfragColor = vec4( 0., 0., 0., 1 );\n\n#ifdef HD_BLACK_BANDS\n\tfloat aspect = ( 16.0 / 9.0 ); // the ratio we want\n\tif ( iResolution.x < aspect * iResolution.y )\n\t{\n\t\tresolution.y = resolution.x * ( 1.0 / aspect );\n\t\tpixel.y -= ( iResolution.y - resolution.y ) * 0.5;\n\t\tif ( abs( pixel.y * 2.0 - resolution.y ) > resolution.y ) return;\n\t}\n\telse\n\t{\n\t\tresolution.x = resolution.y * aspect;\n\t\tpixel.x -= ( iResolution.x - resolution.x ) * 0.5;\n\t\tif ( abs( pixel.x * 2.0 - resolution.x ) > resolution.x  ) return;\n\t}\n#else\n\tfloat aspect = ( resolution.x / resolution.y );\n#endif\n\tvec2 uv = pixel / resolution.xy;\n\n\tfloat fade = 1.0;\n\tfloat tan_half_fovy = 0.06; // so we can see then sun\n\tfloat znear = 0.1;\n\tLameTweaks lame_tweaks;\n\tfloat exposure = 0.6;\n\n#ifdef EXTRA_3D_CAMERA\n\tmat4 camera;\n\tcamera[0] = iCamera[0];\n\tcamera[1] = iCamera[1];\n\tcamera[2] = iCamera[2];\n\tcamera[3] = iCamera[3];\n\tcamera[3].xyz *= 1e+3 * atm_scale;\n#else\n\tfloat fast_forward = ( key_state( KEY_RIGHT ) ? 5.0 : 1.0 );\n\tmat4 camera = get_earth_camera( tan_half_fovy, fade, GLOBALTIME * fast_forward, lame_tweaks, exposure );\n#endif\n\n\tRay view_ray = get_view_ray( ( uv - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\n\tview_ray.o = camera[3].xyz;\n\tview_ray.d = ( camera * vec4( view_ray.d, 0 ) ).xyz;\n\n#ifdef SUPER_SAMPLE_HORIZON\n\t// do SS on edge pixels... still expensive\n\tfloat ss = vec3( 1 - exp( -abs( length( project_on_line1( earth_center, view_ray.o, view_ray.d ) - earth_center ) - earth_radius ) * 0.1 ) );\n\tfragColor = vec4( ss, ss, ss, 1.0 );\n\tif ( ss < 0.7 )\n\t{\n\t\tvec2 pmin = ( pixel + vec2( 0.0, 0.0 ) ) / resolution.xy;\n\t\tvec2 pmax = ( pixel + vec2( 1.0, 1.0 ) ) / resolution.xy;\n\n\t\tfragColor.rgb = vec3( 0 );\n\t\tfor ( int i = 0; i < 2; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < 2; j++ )\n\t\t\t{\n\t\t\t\tvec2 uv2 = pmin + ( pmax - pmin )\n\t\t\t\t\t* vec2(\n\t\t\t\t\t0.5 + float( i ) / 2.0,\n\t\t\t\t\t0.5 + float( j ) / 2.0 );\n\t\t\t\tRay subray = get_view_ray( ( uv2 - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\t\t\t\tsubray.o = camera[3].xyz; // make sure all rays have same origin! we don't really care about havnig a znear here\n\t\t\t\tsubray.d = ( camera * vec4( subray.d, 0 ) ).xyz;\n\t\t\t\tfragColor.rgb += earthShader( subray, camera, lame_tweaks, exposure );\n\t\t\t}\n\t\t}\n\t\tfragColor.rgb /= 4.0;\n\t\treturn;\n\t}\n#endif\n\n\tfragColor.rgb = earthShader( view_ray, camera, lame_tweaks, exposure ) * fade;\n\treturn;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}