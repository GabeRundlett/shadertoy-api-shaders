{
    "Shader": {
        "info": {
            "date": "1633968031",
            "description": "从如何创建一个圆 到创建一个圆环，到为圆环增添颜色，到色彩动效；",
            "flags": 0,
            "hasliked": 0,
            "id": "7scXD2",
            "likes": 3,
            "name": "Thewaytoentry-1",
            "published": 3,
            "tags": [],
            "usePreview": 0,
            "username": "jialouluo",
            "viewed": 561
        },
        "renderpass": [
            {
                "code": "vec3 getcolor(float ang) {\n    //传入进来的是一个角度值 我们需要将他进行一定的运算来使得他成为我们需要的结果，这里可以根据自己喜好\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2));\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2)  + iTime );//有 iTime\n        //return .5 + .5 * cos(6.28 * (ang + vec3(0., .33, .67)));\n        return .5 + .5 * cos(6.28 * (ang/6.28 + vec3(0., .33, .67)));//6.28 约等于2Π\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //从如何创建一个圆 到创建一个圆环，到为圆环增添颜色，到色彩动效；\n    //本人也才刚开始学 ，有不对的一些地方或者理解错误的地方，也希望路过的大佬不吝赐教QAQ\n    vec2 uv = fragCoord/iResolution.xy;//将uv坐标转换到0-1\n    uv-=.5;//将uv移到中心(0,0)\n    uv.x *= (iResolution.x/iResolution.y);//别急着解开注释，uv.x更新\n    //下面创建一个圆\n    float dis = length(uv);//得到每个像素到原点(0，0)的长度\n    \n    //smoothstep(a,b,x); 当a>b时 ,x>a 那么y值(返回值)为0;x <b小返回值为1; b>a的情况这里用不到,具体可以看Api的解释\n    //若x大于b小于a为平滑过渡的值(0-1)\n    //基于这一点 我们可以实现一个圆\n    //我们屏幕的坐标范围为 -0.5=>0.5(注释掉uv.x更新的那行代码的范围)\n    //float r = 0.6;//这是半径,不受范围大小影响\n    //float c  = smoothstep(r,r-0.1,dis);//只要dis(像素的坐标距离原点的距离)大于r 那么 返回值就为0，\n    //小于r-0.1就为1，有0.1的平滑距离\n    //我们将目前的c值赋值给fragColor试试效果\n    //vec3 cir = vec3(c);\n    //fragColor = vec4(cir,1.0);\n    //会发现是一个椭圆\n    //可以发现 是由于长宽比例的问题 所以将 所有的uv的x值都乘以一个x/y的值\n    //需要在计算距离之前添加这句代码uv.x *= (iResolution.x/iResolution.y);\n    //这下我们解开上面的注释再试试\n    //运行之后我们发现 成功的绘制的一个圆\n    //利用smoothstep 我们想想 可不可以在圆的基础上制作一个空心的圆(圆环)\n    //我们知道 如果在a>b的基础上 若x大于a返回值为0 我们可以基于这一点来实现\n    //也就是 在距离原点位置越近 某个值越大 最后达到临界值会大于a 以此来实现返回0 \n    //这个值 我们可以用 value 同时我们也可以设置一个内圆的半径 ir\n    //接下来让我们重写第8 - 32行的代码;\n    float ir = 0.09;\n    float or = 0.4;\n    float value = abs(dis - or);//dis越近 value的值越大\n    float c = smoothstep(ir,ir-0.01,value);//这里可以不用0.01作为区间 ，可以用偏导宽来作为平滑区间,(偏导宽 + smoothstep 经常作为去锯齿的一种常用方法)\n    //vec3 cir = vec3(c);\n    //fragColor = vec4(cir,1.0);\n    //效果似乎还行，但是改变参数发现 似乎效果不如我们想得那样美好，\n    //原因是当我们改变内圆半径时 a，b的值也发生了改变,使得除开内圆范围判断的其他判断也发生了改变，\n    //但是已经不影响我们下面的使用了\n    //下面我们来对这个圆环进行着色\n    //我们需要知道每个uv坐标对应于中心点的角度，以此来进行不同uv位置的不同颜色赋值\n    //使用 atan(uv.y,uv.x)是常用的求uv角度的方法\n    float angle  =atan(uv.y,uv.x);\n    //我们这时来进行赋值操作,重写37 - 44行的代码\n    //vec3 cir = vec3(angle * c);\n    //fragColor = vec4(cir,1.0);\n    //会发现渐变的效果似乎出来了，当然因为rgb的参数是一样的所以呈黑白\n    //我们需要对他进行优化，我们需要一个方法来使得我们的角度值转变为一个具有不同rgb的一个vec3对象\n    //让我们为他创建一个函数\n    //让我们来重写47-50行代码\n    vec3 f_color = getcolor(angle) * c * fract(angle/6.28 - iTime);\n    //vec3 f_color = getcolor(angle) * c * fract(angle - iTime);//不除2Π\n    fragColor =vec4(f_color,1.0);\n    //到这已经创建一个具有自己特色颜色的圆环了，接下来我们需要为他添加一些动效\n    //我们需要用到 iTime 这个shadertoy内置变量 他代编运行时间 ，与他对应的还有一个 ItimeDelta 他表示每帧时长;\n    //将 iTime 写入到计算中，这里跳转到函数哪去\n    //我们可以为他添加一些彩虹头亮尾暗的效果\n    //至于除2Π的作用现目前无法用语言来形容 看看效果应该能大致清楚了\n    \n    //就先写到这里吧 我也是刚学的新人，借鉴了无数大佬的理解和代码 才勉强做到这里，以后一起加油吧\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}