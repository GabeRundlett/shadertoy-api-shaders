{
    "Shader": {
        "info": {
            "date": "1686375546",
            "description": "A not so very deep ocean.\nUse the mouse to look around :)",
            "flags": 0,
            "hasliked": 0,
            "id": "dlKSDK",
            "likes": 11,
            "name": "shallow ocean",
            "published": 3,
            "tags": [
                "sea",
                "water",
                "ocean",
                "foam"
            ],
            "usePreview": 1,
            "username": "ianertson",
            "viewed": 593
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T ((iTime+90.)*2.1)\n#define ZERO min(iFrame, 0)\n#define NEAR 0.003\n#define FAR 1600.0\n#define MAX_STEPS 40\n#define M_PI 3.1415\n#define TAU (M_PI*2.0)\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nfloat smod(float x, float y) {\n    float k = abs(0.5-fract(x/y));\n    return smoothstep(0.0, 1.0, k);\n}\n\n#define NOISE(p, seed) (textureLod(iChannel3, ((p+0.289128) + (seed * 156.0))/256.0, 0.1).rgb)\n\nvec3 noise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    return mix(\n        mix(NOISE(id, seed), NOISE(id+vec2(1, 0), seed), lv.x),\n        mix(NOISE(id+vec2(0, 1), seed), NOISE(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq, const in int octaves) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * noise(p*freq, seed);\n        div += amp;\n        amp /= 2.0;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n#define NEG(x) ((x)*2.0-1.0)\n\nfloat sdfWater(in vec3 p) {\n    if (p.y > 10.23) return p.y;\n    float t = T*0.15;\n    float freq = 0.59;\n    \n    vec2 offset = vec2(cos(t*2.0), sin(t*2.0))*1.3;\n    vec2 mp = vec2(smod(p.x, 200.0), smod(p.y, 200.0)) * 0.5;\n    \n    float h = 0.0;\n    vec2 shift = vec2(sin(t), cos(t)) * 1.5;\n    vec2 dir = vec2(1, 0);\n    float k1 = (0.5+(0.5*sin(mp.x*shift.y*0.1)));\n    float k2 = (0.5+(0.5*sin(mp.y*shift.x*0.1)));\n    float k = (k1 + k2) * 0.5;\n    dir = mix(dir, vec2(0, 1), k*0.25);\n    \n    dir *= rot(t);\n    vec3 n0 = noise(p.xz + (shift * 100.), 0.00001231, 0.009, 3);\n    shift *= (0.25+(0.75*dot(normalize(shift), dir)))*2.;\n    shift += 0.15*offset;\n    h += NEG(n0.x * n0.y + n0.z);\n    shift = mix(shift, (0.06*offset)+dir*vec2(sin(t+h-n0.x), cos(t+h-n0.y)), 0.5*smoothstep(0.4, 0.7, n0.x));\n    vec3 n1 = noise(p.zx + (shift * 50.0), 11.982715, 0.01, 4);\n    h += NEG(n1.x * n1.y + n1.z);\n    shift = mix(shift, dir*vec2(sin(t+h-n1.x), cos(t+h-n1.y)), 0.5*smoothstep(0.4, 0.7, n1.z));\n    shift -= offset*0.33;\n    vec3 n3 = noise(p.xz - (shift * 30.0), 55.555315, 0.06, 3);\n    h += NEG(n3.x) * smoothstep(0.4, 0.7, (n1.y+(n0.z*0.5))*0.6);\n    vec3 n4 = noise((offset*0.03)+p.zx + (shift * 30.0), 201.0928182, 0.08, 6);\n    float b = 0.15;\n    float ib = 1.0 - b;\n    h += NEG(n4.x * n4.y + n4.z) * (b + (ib * smoothstep(0.4, 0.9, (n0.z+n3.y+n0.z)*0.333333)));\n    \n    h *= 0.3333333;\n    \n    h *= 30.;\n    return ((p.y+h)/1.1)-4.;\n}\nfloat ground(in vec3 p) {\n    float h = 0.0;\n    \n    \n    vec3 n0 = noise(p.xz*1.9, 1.119281, 0.003, 6);\n    h += n0.x*(10.0+(n0.y + n0.z));\n    h += (h*h);\n    \n    vec3 n1 = noise(p.zx, 10.9281812, 0.02, 6);\n    h += (n1.x * n1.y + n1.z)*30. * smoothstep(0.4, 0.7, n0.y);\n    \n    vec3 n2 = noise(p.xz, 166.03989182, 0.003, 3);\n    \n    float fg = n2.x * n2.x;\n    float g = ((fg*fg) + (n0.z * n0.y + n0.z * n0.y)) * 40.0;\n    \n    h -= g*1.1111;\n    h += smoothstep(0.015, 0.5, n2.y)*100.*n2.y*n2.y*max(0.0, 1.0-fg);\n\n    \n    return h/1.05;\n}\nfloat sdf(in vec3 p, bool water) {\n    if (p.y < -200.) return p.y;\n    if (water) return sdfWater(p);\n    if (p.y > 16.2) return p.y;\n\n    float h = ground(p);\n    \n    return ((p.y+h)/1.1)+((p.y+4.0)*0.4);\n}\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n};\n\nbool march(in vec3 ro, in vec3 rd, inout Data data, bool water, in float far) {\n    data.d = FAR;\n    float d = 0.0;\n    for (int i = ZERO; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * d;\n        float next = sdf(p, water);\n        \n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (abs(d) * 2.5)))) break;\n        if (d >= far) return false;\n    }\n    \n    d = abs(d);\n    vec3 p = ro + rd * d;\n    vec2 e = vec2(water ? 0.09 : 0.05, 0.0);\n    data.n = normalize(sdf(p, water) - vec3(\n        sdf(p - e.xyy, water),\n        sdf(p - e.yxy, water),\n        sdf(p - e.yyx, water)\n    ));\n    data.d = d;\n    data.p = p;\n    return true;\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    vec3 col = vec3(0.22, 0.66, 0.72);\n    col = col * col;\n    col = pow(col, vec3(1.0 + dotup*2.0));\n    return col;\n}\n\nvec3 blit(in vec3 ro, in vec3 rd, in Data data, in vec3 L, in vec3 lcol, in vec3 alb, float spf) {\n    vec3 col = vec3(0.0);\n    vec3 N = data.n;\n    vec3 ref = reflect(L, N);\n    float VdotR = max(0.0, dot(rd, ref));\n    float spec = pow(VdotR, 128.0) * spf;\n    vec3 diffuse = alb / M_PI;\n    float NdotL = max(0.0, dot(N, L));\n    vec3 att = NdotL * NdotL * diffuse * lcol;\n    col += (att + spec);\n    \n    \n    vec3 ref2 = reflect(rd, N);\n    \n\n    vec3 env = getSky(ref2);\n    \n    col += env * col;\n    return col;\n}\n\n\nvec3 tt(in sampler2D samp, in vec2 uv, in vec3 N, in float d) {\n    vec3 n1 = noise(uv, 0.329812, 2.5, 6);\n    vec3 n2 = noise(uv.yx, 66.329812, 0.5, 6);\n    vec3 n3 = noise(uv.xy+0.38281, 231.281, 0.4, 6);\n    vec3 n4 = noise(uv.yx+13.3333, 125.38281, 0.1, 3);\n    vec3 c1 = vec3(0.5, 0.3, 0.15);\n    vec3 c2 = vec3(0.8, 0.33, 0.2);\n    vec3 c3 = vec3(0.75, 0.39, 0.25);\n    vec3 col = mix(c1, c2, n1.x);\n    col = mix(col, c3, smoothstep(0.4, 0.7, n3.x));\n    col = mix(col, clamp((col/M_PI)+0.19, 0.0, 1.0), 0.5*smoothstep(0.4, 0.7, n4.y));\n    float cc = 1.0-smoothstep(0.01, 0.1, abs(n3.z*2.0-1.0));\n    \n    col += 0.5*(c2+col*0.8)*cc*smoothstep(0.4, 0.7, n4.z);\n    return col;\n}\nvec3 render(in vec3 ro, in vec3 rd, inout float depth) {\n    depth = FAR;\n    vec3 col = vec3(0.0);\n    Data data1 = Data(vec3(0.0), vec3(0.0), FAR);\n    Data data2 = Data(vec3(0.0), vec3(0.0), FAR);\n    Data data3 = Data(vec3(0.0), vec3(0.0), FAR);\n    vec3 L = normalize(vec3(1, 2, 3));\n    vec3 lcol = vec3(0.8, 0.7, 0.65);\n\n    vec3 tmp = vec3(0.0);\n  \n    // ground over water\n    if (march(ro, rd, data3, false, FAR)) {\n      vec3 alb = tt(iChannel2, data3.p.xz, data3.n, data3.d);\n      tmp = blit(ro, rd, data3, L, lcol, alb, 0.01);\n      depth = (data3.d / FAR);\n    } else {\n       depth = FAR;\n       return getSky(rd);\n    }\n   \n    // water\n    if (march(ro, rd, data1, true, FAR)) {\n        vec3 alb = vec3(0.21, 0.66, 0.75);\n        if (data1.d-0.001 < data3.d) {\n            col += blit(ro, rd, data1, L, lcol, 0.22222*((alb*alb*alb)+0.5), 1.0);\n            depth  = data1.d / FAR;\n        }\n        \n        if (data3.d > data1.d-0.001) {\n            float ior = 1.33;\n            vec3 rd2 = refract(rd, data1.n, 1.0/ior);\n            vec3 ro2 = data1.p-data1.n*0.001;\n            \n            \n            // ground under water\n            if (march(ro2, rd2, data2, false, FAR)) {\n\n\n                float dd = distance(data1.p, data2.p) / FAR;\n\n                vec3 alb = tt(iChannel2, data2.p.xz, data2.n, data2.d);\n                col +=  blit(ro2, rd2, data2, L, lcol, alb, 0.1) / (1.0 + dd*6.0+(data2.d/FAR));\n\n                depth = max(depth,  data2.d / FAR);\n\n                float kj = distance(data2.p, data3.p);\n                // foam\n                col += smoothstep(0.04, 0.06, depth)*smoothstep(3.0, -4.0, kj) * noise(data3.p.xz+vec2(sin(T), cos(T)), 0.23918, 2.0, 1).x;\n\n            }\n        } else {\n            float dd = distance(data1.p, data3.p) / FAR;\n            col += tmp /  (1.0 + (dd*6.0));\n        }\n    }\n  \n \n    return col;\n}\nvec3 nextRo(in vec3 ro, in float t) {\n    ro.y += (35.) + 10.0*(0.5*(0.5+sin(t)));\n    ro.z += t*25.;\n    ro.x += cos((t-11.2989122)*0.15)*90.;\n    return ro;\n}\nvoid mainImage( out vec4 O, in vec2 fc )\n{   vec3 col = vec3(0.0);\n    vec2 uv = (fc - 0.5 * R.xy)/R.y;\n    \n    vec3 ro = vec3(0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv.xy, mix(1.0, 0.6, 0.33*(0.5+(0.5*cos(0.33*(T+33.329281)))))));\n    \n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy)/R.y, iMouse.zw);\n    \n    if (m.z > 0.001) {\n      rd.yz *= rot(m.y * TAU);\n      rd.xz *= rot(m.x * TAU);\n    } else {\n        rd.yz *= rot(radians(-(15. + (0.5*(0.5+cos(T+1.82818))))));\n        rd.xz *= rot(0.5*sin((T+11.023321)*0.25));\n    }\n    \n    ro = nextRo(ro, T);\n    float g1 = ground(ro);\n    float g2 = ground(nextRo(ro, T+0.015));\n    float g3 = ground(nextRo(ro, T+0.05));\n    float g4 = ground(nextRo(ro, T+0.08));\n    \n    float g = (g1 + g2 + g3 + g4) * 0.25;\n    \n    ro.y += 3.0*(1.0 - 0.85*smoothstep(0.0, 30.0, distance(vec3(0, ro.y, 0), vec3(0, g, 0))));\n    \n    float depth = FAR;\n    col = render(ro, rd, depth);\n    float b = 0.45;\n    float ib = 1.0 - b;\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    float d = smoothstep(0.1, 0.9, depth);\n    col += (d*d)* max(0.0, 1.0 - smoothstep(0.0, 0.44, dotup));\n    \n    float l = luma(col);\n  \n    col += (l*l + (col*col));\n    col += (col*col*col*col);\n    \n    col *= (1.0+col*4.);\n    \n    col /= (1.0+max(col-0.25, 0.0));\n    \n    col = aces(col);\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    O = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}