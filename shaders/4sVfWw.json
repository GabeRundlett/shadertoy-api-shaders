{
    "Shader": {
        "info": {
            "date": "1529078667",
            "description": "A 3d version of [url=https://www.shadertoy.com/view/MlsXDf]random quadtree[/url]\n[url=https://www.shadertoy.com/view/XdyfRy]With shadows[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4sVfWw",
            "likes": 92,
            "name": "random octree",
            "published": 3,
            "tags": [
                "voxel",
                "octree"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 4773
        },
        "renderpass": [
            {
                "code": "#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n#define detail 5\n#define steps 300\n#define time iTime*0.5\n#define maxdistance 30.0\n\n//#define drawgrid\n#define fog\n//#define borders\n#define blackborders\n//#define raymarchhybrid 100\n#define objects\n#define emptycells 0.5\n#define subdivisions 0.95 //should be higher than emptycells\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define sqr(a) (a*a)\n\n//random function from https://www.shadertoy.com/view/MlsXDf\nfloat rnd(vec4 v) { return fract(4e4*sin(dot(v,vec4(13.46,41.74,-73.36,14.24))+17.34)); }\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//0 is empty, 1 is subdivide and 2 is full\nint getvoxel(vec3 p, float size) {\n#ifdef objects\n    if (p.x==0.0&&p.y==0.0) {\n        return 0;\n    }\n#endif\n    \n    float val = rnd(vec4(p,size));\n    \n    if (val < emptycells) {\n        return 0;\n    } else if (val < subdivisions) {\n        return 1;\n    } else {\n        return 2;\n    }\n    \n    return int(val*val*3.0);\n}\n\n//ray-cube intersection, on the inside of the cube\nvec3 voxel(vec3 ro, vec3 rd, vec3 ird, float size)\n{\n    size *= 0.5;\n    \n    vec3 hit = -(sign(rd)*(ro-size)-size)*ird;\n    \n    return hit;\n}\n\nfloat map(vec3 p, vec3 fp) {\n    p -= 0.5;\n    \n    vec3 flipping = floor(hash33(fp)+0.5)*2.0-1.0;\n    \n    p *= flipping;\n    \n    vec2 q = vec2(abs(length(p.xy-0.5)-0.5),p.z);\n    float len = length(q);\n    q = vec2(abs(length(p.yz-vec2(-0.5,0.5))-0.5),p.x);\n    len = min(len,length(q));\n    q = vec2(abs(length(p.xz+0.5)-0.5),p.y);\n    len = min(len,length(q));\n    \n    \n    return len-0.1666;\n}\n\nvec3 findnormal(vec3 p, float epsilon, vec3 fp)\n{\n    vec2 eps = vec2(0,epsilon);\n    \n    vec3 normal = vec3(\n        map(p+eps.yxx,fp)-map(p-eps.yxx,fp),\n        map(p+eps.xyx,fp)-map(p-eps.xyx,fp),\n        map(p+eps.xxy,fp)-map(p-eps.xxy,fp));\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{\n    \n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) /iResolution.y;\n    float size = 1.0;\n    \n    vec3 ro = vec3(0.5+sin(time)*0.4,0.5+cos(time)*0.4,time);\n    vec3 rd = normalize(vec3(uv,1.0));\n    \n    //if the mouse is in the bottom left corner, don't rotate the camera\n    if (length(iMouse.xy) > 40.0) {\n    \trd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \trd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    vec3 lro = mod(ro,size);\n    vec3 fro = ro-lro;\n    vec3 ird = 1.0/max(abs(rd),0.001);\n    vec3 mask;\n    bool exitoct = false;\n    int recursions = 0;\n    float dist = 0.0;\n    float fdist = 0.0;\n    int i;\n    float edge = 1.0;\n    vec3 lastmask;\n    vec3 normal = vec3(0.0);\n    \n    //the octree traverser loop\n    //each iteration i either:\n    // - check if i need to go up a level\n    // - check if i need to go down a level\n    // - check if i hit a cube\n    // - go one step forward if octree cell is empty\n    // - repeat if i did not hit a cube\n    for (i = 0; i < steps; i++)\n    {\n        if (dist > maxdistance) break;\n        \n        //i go up a level\n        if (exitoct)\n        {\n            \n            vec3 newfro = floor(fro/(size*2.0))*(size*2.0);\n            \n            lro += fro-newfro;\n            fro = newfro;\n            \n            recursions--;\n            size *= 2.0;\n            \n            exitoct = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n        }\n        else\n        {\n            //checking what type of cell it is: empty, full or subdivide\n            int voxelstate = getvoxel(fro,size);\n            if (voxelstate == 1 && recursions > detail)\n            {\n                voxelstate = 0;\n            }\n            \n            if(voxelstate == 1&&recursions<=detail)\n            {\n                //if(recursions>detail) break;\n\n                recursions++;\n                size *= 0.5;\n\n                //find which of the 8 voxels i will enter\n                vec3 mask2 = step(vec3(size),lro);\n                fro += mask2*size;\n                lro -= mask2*size;\n            }\n            //move forward\n            else if (voxelstate == 0||voxelstate == 2)\n            {\n                //raycast and find distance to nearest voxel surface in ray direction\n                //i don't need to use voxel() every time, but i do anyway\n                vec3 hit = voxel(lro, rd, ird, size);\n\n                /*if (hit.x < min(hit.y,hit.z)) {\n                    mask = vec3(1,0,0);\n                } else if (hit.y < hit.z) {\n                    mask = vec3(0,1,0);\n                } else {\n                    mask = vec3(0,0,1);\n                }*/\n                mask = vec3(lessThan(hit,min(hit.yzx,hit.zxy)));\n                float len = dot(hit,mask);\n    #ifdef objects\n                if (voxelstate == 2) {\n    #ifdef raymarchhybrid\n                    //if (length(fro-ro) > 20.0*size) break;\n                    vec3 p = lro/size;\n                    if (map(p,fro) < 0.0) {\n                        normal = -lastmask*sign(rd);\n                        break;\n                    }\n                    float d = 0.0;\n                    bool hit = false;\n                    float e = 0.001/size;\n                    for (int j = 0; j < raymarchhybrid; j++) {\n                        float l = map(p,fro);\n                        p += l*rd;\n                        d += l;\n                        if (l < e || d > len/size) {\n                            if (l < e) hit = true;\n                            d = min(len,d);\n                            break;\n                        }\n                    }\n                    if (hit) {\n                        dist += d*size;\n                        ro += rd*d*size;\n                        normal = findnormal(p,e,fro);//(lro-0.5)*2.0;\n                        break;\n                    }\n    #else\n                    break;\n    #endif\n                }\n    #endif\n\n                //moving forward in ray direction, and checking if i need to go up a level\n                dist += len;\n                fdist += len;\n                lro += rd*len-mask*sign(rd)*size;\n                vec3 newfro = fro+mask*sign(rd)*size;\n                exitoct = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25))&&(recursions>0);\n                fro = newfro;\n                lastmask = mask;\n            }\n        }\n#ifdef drawgrid\n        vec3 q = abs(lro/size-0.5)*(1.0-lastmask);\n        edge = min(edge,-(max(max(q.x,q.y),q.z)-0.5)*80.0*size);\n#endif\n    }\n    ro += rd*dist;\n    if(i < steps && dist < maxdistance)\n    {\n    \tfloat val = fract(dot(fro,vec3(15.23,754.345,3.454)));\n#ifndef raymarchhybrid\n        vec3 normal = -lastmask*sign(rd);\n#endif\n        vec3 color = sin(val*vec3(39.896,57.3225,48.25))*0.5+0.5;\n    \tfragColor = vec4(color*(normal*0.25+0.75),1.0);\n        \n#ifdef borders\n        vec3 q = abs(lro/size-0.5)*(1.0-lastmask);\n        edge = clamp(-(max(max(q.x,q.y),q.z)-0.5)*20.0*size,0.0,edge);\n#ifdef blackborders\n        fragColor *= edge;\n#else\n        fragColor = 1.0-(1.0-fragColor)*edge;\n#endif\n#endif\n    } else {\n        #ifdef blackborders\n                fragColor = vec4(edge);\n        #else\n                fragColor = vec4(1.0-edge);\n        #endif\n    }\n#ifdef fog\n    fragColor *= 1.0-dist/maxdistance;\n#endif\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}