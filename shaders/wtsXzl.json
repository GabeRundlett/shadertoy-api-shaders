{
    "Shader": {
        "info": {
            "date": "1563978359",
            "description": "reproducing Vax Game [url]https://vax.herokuapp.com/game[/url]\nGraph = population network where virus propagates.\nUnconnect green nodes to vaccinate before infection, or quarantine after infection.\nRestart for new set-up.  click+SPACE to move nodes.",
            "flags": 48,
            "hasliked": 0,
            "id": "wtsXzl",
            "likes": 7,
            "name": "Vax Game: vaccinate them all !",
            "published": 3,
            "tags": [
                "game",
                "simulation",
                "mesh",
                "network",
                "graphs",
                "untangle",
                "vaccine",
                "vaccination",
                "epidemy"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 1139
        },
        "renderpass": [
            {
                "code": "// Fork of base graph untangling https://shadertoy.com/view/3lfSRB\n\n// draw line. from https://www.shadertoy.com/view/4dcfW8\nfloat line(vec2 p, vec2 a,vec2 b) {\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    p -= b * h;\n    return dot(p,p);                               // dist^2 to segment\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n#if TEST\n    O = texelFetch(iChannel0,ivec2(U/8.),0); if (int(U.x/8.)>0) O/=N,O.g=.6*float(O.x>0.); return;\n#endif\n    \n    vec2 R = iResolution.xy;\n    U = ( 2.*U - R ) / R.y;\n    \n    float p = 3./R.y, n = 1e9, l = 1e9, l2 = 1e9, r, ii; \n    bool hit = false; \n    \n    for (int i=0; i < int(N); i++) {       // for each node\n        vec4 P = node(i);\n        if (invalid(P)) continue;          // invalid node\n      //r = length(pos(P)-U)-.03;          // distance to node\n        r = length(pos(P)-U)-.01-.008*nLink(P); \n        if (r < n ) n=r, hit = infected(P), ii=float(i);\n        for (int j=0; j < int(nLinkD(P)); j++) { // for each link in its list\n            float k = link(i,j);           // distance to line\n            vec4 P2 = node(k);\n        if (invalid(P2)) continue;         // invalid node\n            l = min(l, line(U,pos(P), pos(P2)));\n        }              \n/*      for (int j=int(nLinkD(P)); j < int(nLink(P)); j++) { // debug: back-links\n            float k = link(i,j);           // distance to line\n            l2 = min(l2, line(U,pos(P), pos(node(k))));\n        }            \n*/  }\n    O = vec4(smoothstep(p,0.,sqrt(l)));    // draw (closest) line\n    O[hit?0:ii<N*antiVax?2:1] += smoothstep(p,0.,n); // draw (closest) node\n  //O.g = smoothstep(p,0.,sqrt(l2));       // debug: draw back-links\n\n    if (U.x+R.x/R.y<.05) {                 // --- display infection total balance\n        int n=0;\n        for (int i=0; i < int(N); i++) {\n            vec4 P = node(i);\n            if (valid(P)&&infected(P)) n++;\n        }\n        float(n)/N < .5+.5*U.y ? O.g++ : O.r++;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define rot(a)    mat2( cos(a), -sin(a), sin(a), cos(a) )\n//#define rnd4(p) texelFetch(iChannel1, ivec2(p)%256, 0) // not available at Frame0\n  #define rnd(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n  #define rnd4(p) vec4( rnd(p), rnd(.1+p), rnd(.3+p), rnd(.4+p) )\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.) // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if (U.y >= N) return;\n    \n    if (iFrame==0) { // --- init nodes: random pos + random targets\n        float t = mod(3.*iDate.w,256.);\n#if TEST\n        if (U.x > ceil(sqrt(N)/2.*rnd4(vec2(U.y,t)).z)) return;\n#endif\n        if (U.x==0.) { vec4 R = rnd4(vec2(U.y,t));\n                       pos(O) = 2.*R.xy-1.,    // coords\n                       nLinkD(O) = ceil(sqrt(N)/2.*R.z); }// connectivity: #n\n        else O.x = floor(N*rnd4(U+t).w);       // connectivity: link ids\n        return;\n    }\n    \n    O = texelFetch(iChannel0, ivec2(U), 0);    // restore prev state\n    \n    if (iFrame==1) { // --- appends the back-links to node list\n        float n = nLinkD(node(U.y)), t = 0.;\n        if ( ( U.x > n && U.x <= n+N ) || U.x == 0. ) {\n            for (int i=0; i < int(N); i++) {   // search for back-link\n                int n2 = int(nLinkD(node(i)));\n                for (int j=0; j < n2; j++) {\n                    if (link(i,j) == U.y) {    // got one !\n                        t++;                   // count back-links\n                        if ( U.x == n+t )      // it falls on the right slot\n                        { O.x = float(i); return; }\n                    }\n                }\n            }\n            if (U.x==0.) nLink(O) = n+t;       // total list count\n        }\n        return;\n    }\n    \n    //return;\n    if (U.x==0.) {                             // === node simulation\n        \n                                               // --- infection\n        bool start = iFrame > tInit;           // random new infection\n        for (int i=0; i<int(N); i++) \n            if ( valid(node(i)) && infected(node(i)) ) \n            { start = false; break; }          // if not already one\n        if (start // iFrame==60 // iFrame%600==0\n            && U.y==floor(N*rnd(vec2(iFrame%239,iFrame%233)))) \n            infect(O);                         // mark infected\n \n        if ( (iFrame-tInit) % virulence == 0 ) // propagation\n            for (int j=0; j < int(nLink(O)); j++) \n              if(rnd(vec2(iFrame%239,j)) < contagiousness) { // proba propag\n                vec4 P = node(link(U.y,j));\n                if (valid(P) && infected(P)) \n                    infect(O);                 // mark infected\n            }\n            \n        if ( iMouse.z > 0.) {\n            vec2  R = iResolution.xy,          // --- mouse move node\n                M = ( 2.*iMouse.xy - R ) / R.y;\n            float r = 1e5, l, ii=-1.;\n            for (int i=0; i < int(N); i++) {\n                vec4 P = node(i); \n                if (invalid(P)) continue;      // invalid node\n                l = length(pos(P)-M);\n                if ( l < r ) r=l, ii=float(i);\n            }\n            if (r<.1 && ii==U.y )          \n                if keyClick(32) pos(O) = M;    // nearest node follow mouse\n                else if(!( infected(O) || ii < N*antiVax) ) // only valid vaccinable peoples\n                     { invalidate(O); return; }// disconnect (lazy: should decrease backN).\n        }\n            \n        vec4 P = node(U.y);                    // --- do the spring physics\n        if (invalid(P)) return;                // invalid node\n        vec2 F = vec2(0); float n=0.;\n        for (int j=0; j < int(nLink(P)); j++) {\n            vec4 P2 = node(link(U.y,j));\n            if (invalid(P2)) continue;         // invalid node\n            F += pos(P2)-pos(P);\n          //F += pow(length(pos(P2)-pos(P)),4.)*normalize(1e-5+pos(P2)-pos(P));\n            n++;\n        }\n        if (n<=1.) return;\n        pos(O) += .02* F / n; // variant: with/without P.w normaliaztion\n        \n        vec2 M1=vec2(0), M2=vec2(0), S;        // --- reframe\n        float mxy = 0., sxy; n=0.;\n        for (int i=0; i < int(N); i++) {\n            vec2 P = pos(node(i));\n            if (invalid(P)) continue;          // invalid node\n            M1 += P; M2 += P*P; mxy += P.x*P.y;// 1st & 2nd moments        \n            n++;\n        }\n        M1 /= n; M2 /= n; mxy /= n;\n        pos(O) -= M1;                          // recenter coords\n        S = M2-M1*M1; sxy = mxy-M1.x*M1.y;     // covariance matrix\n      //pos(O) /= 2.*sqrt(S);                  // rescale coords\n        float a=S.x, b=S.y, ab=a+b, c=sxy, d = sqrt(max(0.,ab*ab-4.*(a*b-c*c))),\n             s = sign(a-b),                    // get eigenvalues/vectors\n            r1 = (ab+s*d)/2., r2 = (ab-s*d)/2.,// ellipsoid radius^2\n             A = d<1e-5 ? 0. : .5*asin(clamp(2.*c/(r1-r2),-1.,1.)); // ellipsoid tilt\n        pos(O) *= rot(-A); \n        pos(O) /= 2.*sqrt(max(vec2(r1,r2),1e-5)); \n        pos(O) *= rot(A);\n        pos(O) /= max(abs(pos(O)),1.);         // clamp to window border\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define N 30.               // number of nodes\n#define tInit 600           // #frame before epidemia\n#define virulence 240       // propagation rate (#frame)\n#define contagiousness .5   // probability to be contaminated by neighbor\n#define antiVax .1          // proportion of non-vaccinables\n\n#define TEST 0\n\n#define node(n)   texelFetch(iChannel0, ivec2(0,n), 0)      // (x,y,n,n+back)\n#define link(n,i) texelFetch(iChannel0, ivec2(i+1,n), 0).x  // #id\n#define pos(n)        n.xy                     // node position\n#define nLinkD(n)     n.z                      // # direct links from node\n#define nLink(n)      n.w                      // # direct + back links to node\n#define invalid(n)  ( n.xy == vec2(0) )        // node has been deleted\n#define valid(n)    ( n.xy != vec2(0) )        //\n#define invalidate(n) n.xy =  vec2(0)          // mark node deleted\n#define infected(n) ( fract(n.z) == .5 )       // node has been infected\n#define infect(n)   ( n.z = floor(n.z) + .5 )  // \n\n// Line = node id.  Columns: 0: (x,y,n,n+back) 1..n+back: (x:#id)\n// attention: node might link to self. ignore these.\n// invalid: (x,y)=0.   infected: fract(n)=.5\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}