{
    "Shader": {
        "info": {
            "date": "1709302091",
            "description": "Description!\n\nInspiration: https://www.youtube.com/watch?v=fKAyaP8IzlE",
            "flags": 0,
            "hasliked": 0,
            "id": "XXXSDn",
            "likes": 8,
            "name": "Steiner's Porism",
            "published": 3,
            "tags": [
                "math",
                "stuff"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 201
        },
        "renderpass": [
            {
                "code": "const float pi = 3.1415926;\n\nfloat outerRadius = 1.;\nvec2 rotation = vec2(0.);\nint circles = 9;\nfloat circleRadius = 0.26;\n\n// Values:\n// 2 : 0.5\n// 3 : 0.4638\n// 4 : 0.413\n// 5 : 0.37\n// 6 : 0.333\n// 7 : 0.3\n// 9 : 0.254\n// 10: 0.235\n// 11: 0.218\n// 12: 0.204\n// 13: 0.193\n// 14: 0.182\n// 15: 0.171\n\nvec2 circlePos(int i, float o){\n\n    float t = float(i) * 2. * pi / float(circles) + o;\n    vec2 p = vec2(sin(t), cos(t));\n    p *= (outerRadius - circleRadius);\n    \n    return p;\n    \n}\n\nvec3 sphereRay(vec3 o)\n{    \n    vec3 dirV = normalize(vec3(0, 0, 1) - o);\n    \n    float t = -dot(o, dirV);\n    vec3 p = o + dirV*t;\n    \n    float y = length(p);\n    \n    float t1;\n\n    if (y < 1. && t > 0.)\n    {\n        float x = sqrt(1. - y*y);\n        t1 = t-x;\n        \n        return o + dirV*t1;\n    }\n    else if (y < 1.)\n    {\n        return vec3(0, 0, 1);\n    }\n}\n\nmat2 rotMat(float t){\n    return mat2(\n        cos(t), sin(t), \n        -sin(t), cos(t)\n    );\n}\n\nvec2 reproject(vec2 p, vec2 rot){\n    vec3 sp = sphereRay(vec3(p.xy, 0.));\n    \n    sp.xz *= rotMat(rot.y);\n    sp.yz *= rotMat(rot.x);\n    \n    vec3 o = vec3(0, 0, 1);\n    vec3 dirV = normalize(o - sp);\n\n    float t = 1./dot(dirV, vec3(0, 0, -1));\n    return (o + dirV*t).xy;\n    \n    \n}\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = 1.*(2.*U-r)/r.y;\n\n    \n    float t = iTime/10.;\n    rotation.y = cos(t)*cos(t)*sign(cos(t));\n    //rotation.x = t;\n    \n    //uv += rotation.yx*0.5;\n    uv -= reproject(vec2(0.01, 0), rotation);\n    uv *= 1. + length(rotation); //Disable this if you enable rotation.x = t;\n\n    uv = reproject(uv, rotation);\n    \n    //O = vec4(mod(floor(uv.x) + floor(uv.y), 2.)); return;\n    \n    float blue = smoothstep(0.02, 0., abs(length(uv) - outerRadius) / fwidth(length(uv) * 1e2));\n    float red = smoothstep(0.02, 0., abs(length(uv) - outerRadius + 2.*circleRadius) / fwidth(length(uv) * 1e2));\n    float white = 0.;\n    \n    for (int i = circles; i-->0;){\n        vec2 p = circlePos(i, iTime/2.);\n        \n        white += smoothstep(0.02, 0., abs(length(uv-p) - circleRadius+0.01) / fwidth(length(uv) * 1e2));\n    }\n    // Thank you elenzil for teaching me about fwidth!\n    \n    \n    O = vec4(0.1);\n    O = max(vec4(white), O);\n    O = mix(O, vec4(0.2, 0.5, 0.8, 0), blue);\n    O = mix(O, vec4(0.9, 0.3, 0.2, 0), red);\n       \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}