{
    "Shader": {
        "info": {
            "date": "1514377729",
            "description": "A projective quadric, xw = yz, rotated in R4/P3, becoming either a hyperbolic paraboloid or a hyperboloid after projection.\n\nMouse changes orientation.",
            "flags": 0,
            "hasliked": 0,
            "id": "XllfDX",
            "likes": 4,
            "name": "Projective Quadric",
            "published": 3,
            "tags": [
                "quadric",
                "projective",
                "paraboloid",
                "hyperboloid"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 737
        },
        "renderpass": [
            {
                "code": "// (c) 2017 Matthew Arcus\n// MIT License: https://opensource.org/licenses/MIT\n\n// Raytrace a quadric surface in P3 with equation xw = yz.\n// Without rotation (in R4/P3) the surface is a hyperbolic\n// paraboloid (a saddle surface), with a rotation, the surface\n// projects to a hyperboloid.\n//\n// The surface can be generated parametrically as (uv,u,v,1)\n// and this gives a 2D coordinate system for the surface as\n// well as defining a set of lines (with u or v held constant)\n// that generate the surface.\n//\n// Here the surface is colored so integer values of u and v\n// have maximum color intensity. Also shown are 4 twisted cubic\n// curves, parametrically, (t^3,t^2,t^1,1) (and variations) that\n// are embedded in the surface.\n\nconst float PI =  3.141592654;\nconst float TWOPI = 2.0*PI;\nconst vec3 axis = vec3(1,1,1); //axis for P3/R4 rotation\nbool drawcubics = true;\n\n// Lighting params\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\n// Rotation in R4\nmat4 m4;\n\n// Rotation matrices, nb: column major.\n// Matrix from quaternion\nmat3 qrot(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  return 2.0*mat3(0.5-y*y-z*z, x*y+z*w,     x*z-y*w,\n                  x*y-z*w,     0.5-x*x-z*z, y*z+x*w,\n                  x*z+y*w,     y*z-x*w,     0.5-x*x-y*y);\n}\n\n// Quaternion multiplication as a matrix.\n// This is a \"Clifford translation\" in R4\nmat4 qmat(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  return mat4( w, z,-y,-x, \n              -z, w, x,-y,\n               y,-x, w,-z,\n               x, y, z, w);\n}\n\n// Rotations about x,y,z axes.\nmat3 xrotate(float theta) {\n  return mat3(1,0,0,0,cos(theta),sin(theta),0,-sin(theta),cos(theta));\n}\nmat3 yrotate(float theta) {\n  return mat3(cos(theta),0,sin(theta),0,1,0,-sin(theta),0,cos(theta));\n}\nmat3 zrotate(float theta) {\n  return mat3(cos(theta),sin(theta),0,-sin(theta),cos(theta),0,0,0,1);\n}\n\n// Solve quadratic equation, return number of real roots found\nint quadratic(float A, float B, float C, out vec3 x) {\n  float D = B*B - 4.0*A*C;\n  if (D < 0.0) return 0;\n  D = sqrt(D);\n  if (B < 0.0) D = -D;\n  x[0] = (-B-D)/(2.0*A);\n  x[1] = C/(A*x[0]);\n  return 2;\n}\n\n// p is in world coordinates\nfloat eval(vec4 p) {\n  p = m4*p;\n  //p = p.zyxw;\n  return p.x*p.w - p.y*p.z;\n}\n\nbool surface(vec4 p0, vec4 r0, inout float t0, out vec3 normal, out vec4 p2) {\n  vec4 p = m4*p0;\n  vec4 r = m4*r0;\n  //p = p.zyxw;\n  //r = r.zyxw;\n  //xw - yz == 0\n  // p = p + lr\n  // (p+lr).x * (p+lr).w - (p+lr).y * (p+lr).z = 0\n  // (p.x + lr.x)(p.w + lr.w) - (p.y + lr.y)(p.z + lr.z) = 0\n  // p.x * p.w - p.y * p.x\n  // l(r.x*p.w + p.x*r.w - p.y*r.z - r.y * p.z)\n  // l^2(r.x*r.w + r.y * r.z)\n  float A = r.x*r.w - r.y*r.z;\n  float B = p.x*r.w + r.x*p.w - p.y*r.z - r.y*p.z;\n  float C = p.x*p.w - p.y*p.z;\n  vec3 x;\n  int nroots = quadratic(A,B,C,x);\n  bool found = false;\n  for (int i = 0; i < 2; i++) {\n    if (i == nroots) break;\n    if (0.0 < x[i] && x[i] < t0) {\n      t0 = x[i];\n      found = true;\n    }\n  }\n  if (found) {\n    p2 = p+t0*r;\n  }\n#if 1\n  // Analytic gradient\n#if 0\n  // Polar surface at p2\n  mat4 m = mat4(0,0,0,1,\n                0,0,-1,0,\n                0,-1,0,0,\n                1,0,0,0);\n  vec4 grad = m*p2;\n#else\n  // or differentiate equation to get tangent surface\n  vec4 grad = vec4(p2.w,-p2.z,-p2.y,p2.x);\n#endif\n  grad = grad*m4; // Transpose mult\n  normal = grad.xyz;\n#else\n  // Compute normal by finding gradient (in R3)\n  vec4 p1 = p0+t0*r0;\n  float x0 = eval(p1);\n  vec2 eps = vec2(1e-2,0);\n  normal = vec3 (eval(p1+eps.xyyy)-x0,\n                 eval(p1+eps.yxyy)-x0,\n                 eval(p1+eps.yyxy)-x0);\n#endif\n  normal = normalize(normal);\n  return found;\n}\n    \nvec4 solve(vec3 p, vec3 r) {\n  vec3 normal = vec3(1,0,0);\n  float theta = iTime*0.1; \n  vec3 a = normalize(axis);\n  m4 = qmat(vec4(-sin(theta)*a,cos(theta)));\n  \n  float t = 1e10;\n  vec4 p1;\n  if (!surface(vec4(p,1),vec4(r,0),t,normal,p1)) {\n    return vec4(0,0,0,1);\n  }\n  if (dot(r,normal) > 0.0) {\n    normal = -normal; // Face forwards\n  }\n  p1 /= p1.w; // Normalize P3 coordinate\n  vec2 uv = p1.zy; // Hyperbolic coords\n  vec2 c = 0.4*(1.0+cos(TWOPI*uv));\n  c = mix(c,vec2(0.5),smoothstep(vec2(5),vec2(20),abs(uv)));\n  vec3 color = vec3(0,c);\n  float fade = sqrt(smoothstep(10.0,100.0,length(uv)));\n  if (drawcubics) {\n    // Draw twisted cubics\n    // (uv,v,u,1) = (t^3,t^2,t,1), (t^3,-t^2,-t,1), (t^3,t,t^2,1), (t^3,-t,-t^2,1),\n    // ie. abs(u) = v^2 or abs(v) = u^2\n    float u = abs(uv.x), v = abs(uv.y);\n    float k = min(abs(u*u-v)/u,abs(v*v-u)/v);\n    float kk = 0.2;\n    color *= mix(smoothstep(0.0,kk,k),1.0,0.2);\n  }\n  color *= ambient+(1.0-ambient)*dot(light,normal);\n  float specular = pow(max(0.0,dot(reflect(light,normal),r)),4.0);\n  color += 0.7*specular*vec3(1.0,1.0,1.0);\n  return vec4(pow(color,vec3(0.4545)),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.0,1.0,-1.0));\n  ambient = 0.6;\n  diffuse = 1.0-ambient;\n\n  vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.001;\n  uv *= 2.0;\n  vec3 p = vec3(0,0,-6.0);\n  vec3 r = normalize(vec3(iResolution.x/iResolution.y * uv.x, uv.y, 4.0));\n\n  float xrot = 0.0;\n  float yrot = 0.0;\n  if (iMouse.x > 0.0) {\n    xrot = PI*(2.0*iMouse.y-iResolution.y)/iResolution.y;\n    yrot = PI*(2.0*iMouse.x-iResolution.x)/iResolution.x;\n  }\n  mat3 m = xrotate(-xrot);\n  m = yrotate(-yrot)*m;\n  float psi = 0.123*iTime;\n  vec3 raxis = normalize(vec3(1,1,-1));\n  vec4 q = vec4(sin(psi)*raxis,cos(psi));\n  m = qrot(q)*m;\n  p = m*p;\n  r = m*r;\n  light  = m*light;\n  fragColor = solve(p,r);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}