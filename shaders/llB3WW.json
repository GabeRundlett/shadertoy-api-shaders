{
    "Shader": {
        "info": {
            "date": "1429200618",
            "description": "Simple 3D maze, to be explored in VR. The goal was to make a shader simple enough to run fast on mobile devices. The actual Unity project passes the camera position and orientation to the shader (the orientation comes from the gyroscope).",
            "flags": 0,
            "hasliked": 0,
            "id": "llB3WW",
            "likes": 14,
            "name": "VR Maze",
            "published": 3,
            "tags": [
                "maze",
                "vr"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 1317
        },
        "renderpass": [
            {
                "code": "// Note: set \"VR\" to 0.0 for classic (non-VR) rendering / 1.0 for VR.\n// For VR, better set \"FOV\" to 96.0.\n\n// Video of what it looks like on device (iPhone 5S), when controlled by the gyroscope:\n// https://www.facebook.com/video.php?v=10153361200936052\n\n///////////////////\n// Shadertoy (1) //\n///////////////////\n\n// Rendering parameters\n#define FOV\t\t\t\t80.0\n#define IPD\t\t\t\t0.01\n#define VR \t\t\t\t0.0\n#define headModel\t\tvec3 (0.0, 0.02, 0.01)\n#define QUALITY_HIGH\n\n// Uniform variables\nvec3 resolution;\nfloat time;\nvec3 headPosition;\nmat3 headRotate;\nvec3 lightPosition;\nfloat ambientIntensity;\n\n///////////\n// Unity //\n///////////\n\n// Rendering parameters\n#define RAY_STEP_MAX\t\t20.0\n#define RAY_LENGTH_MAX\t\t10.0\n#define EDGE_LENGTH\t\t\t0.1\n#ifdef QUALITY_HIGH\n\t#define EDGE_FULL\n//\t#define TEXTURE\n\t#define SHADOW\n#endif\n#define BUMP_RESOLUTION\t\t500.0\n#define BUMP_INTENSITY\t\t0.3\n#define AMBIENT_NORMAL\t\t0.2\n#define AMBIENT_HIGHLIGHT\t2.5\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define FADE_POWER\t\t\t1.5\n#define GAMMA\t\t\t\t0.8\n#define HSV2RGB_FAST\n\n// Math constants\n#define DELTA\t0.002\n#define PI\t\t3.14159265359\n\n// PRNG (unpredictable)\nfloat randUnpredictable (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.6789, 5.4321, 6.7890));\n\tseed += dot (seed.yzx, seed.zxy + vec3 (21.0987, 12.3456, 15.1273));\n\treturn fract (seed.x * seed.y * seed.z * 5.1337);\n}\n\n// PRNG (predictable)\nfloat randPredictable (in vec3 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y + 7.0 * seed.z));\n}\n\n// Check whether there is a block at a given voxel edge\nfloat block (in vec3 p, in vec3 n) {\n\tvec3 block = floor (p + 0.5 + n * 0.5);\n\tvec3 blockEven = mod (block, 2.0);\n\tfloat blockSum = blockEven.x + blockEven.y + blockEven.z;\n\treturn max (step (blockSum, 1.5), step (blockSum, 2.5) * step (0.5, randPredictable (block))) *\n\t\tstep (4.5, mod (block.x, 32.0)) *\n\t\tstep (2.5, mod (block.y, 16.0)) *\n\t\tstep (4.5, mod (block.z, 32.0));\n}\n\n// Cast a ray\nvec3 hit (in vec3 rayOrigin, in vec3 rayDirection, in float rayLengthMax, out float rayLength, out vec3 hitNormal) {\n\n\t// Launch the ray\n\tvec3 hitPosition = rayOrigin;\n\tvec3 raySign = sign (rayDirection);\n\tvec3 rayInv = 1.0 / rayDirection;\n\tvec3 rayLengthNext = (0.5 * raySign - fract (rayOrigin + 0.5) + 0.5) * rayInv;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Reach the edge of the voxel\n\t\trayLength = min (rayLengthNext.x, min (rayLengthNext.y, rayLengthNext.z));\n\t\thitNormal = step (rayLengthNext.xyz, rayLengthNext.yzx) * step (rayLengthNext.xyz, rayLengthNext.zxy) * raySign;\n\t\thitPosition = rayOrigin + rayLength * rayDirection;\n\n\t\t// Check whether we hit a block\n\t\tif (block (hitPosition, hitNormal) > 0.5 || rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Next voxel\n\t\trayLengthNext += hitNormal * rayInv;\n\t}\n\n\t// Return the hit point\n\treturn hitPosition;\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid _main (out vec4 _gl_FragColor, in vec2 _gl_FragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tfloat rayStereo = 0.5 * sign (_gl_FragCoord.x - resolution.x * 0.5) * step (0.5, VR);\n\tvec3 rayOrigin = headPosition + headRotate * (headModel + vec3 (rayStereo * IPD, 0.0, 0.0));\n\tvec3 rayDirection = headRotate * normalize (vec3 ((2.0 * _gl_FragCoord.x - (1.0 + rayStereo) * resolution.x), 2.0 * _gl_FragCoord.y - resolution.y, 0.5 * resolution.x / tan (FOV * PI / 360.0)));\n\n\t// Cast a ray\n\tfloat hitDistance;\n\tvec3 hitNormal;\n\tvec3 hitPosition = hit (rayOrigin, rayDirection, RAY_LENGTH_MAX, hitDistance, hitNormal);\n\tvec3 hitUV = hitPosition * abs (hitNormal.yzx + hitNormal.zxy);\n\n\t// Basic edge detection\n\tvec3 edgeDistance = fract (hitUV + 0.5) - 0.5;\n\tvec3 edgeDirection = sign (edgeDistance);\n\tedgeDistance = abs (edgeDistance);\n\n\t#ifdef EDGE_FULL\n\tvec3 hitNormalAbs = abs (hitNormal);\n\tvec2 edgeSmooth = vec2 (dot (edgeDistance, hitNormalAbs.yzx), dot (edgeDistance, hitNormalAbs.zxy));\n\tfloat highlightIntensity = (1.0 - block (hitPosition + edgeDirection * hitNormalAbs.yzx, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.x);\n\thighlightIntensity = max (highlightIntensity, (1.0 - block (hitPosition + edgeDirection * hitNormalAbs.zxy, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.y));\n\thighlightIntensity = max (highlightIntensity, (1.0 - block (hitPosition + edgeDirection, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, min (edgeSmooth.x, edgeSmooth.y)));\n\t#else\n\tfloat highlightIntensity = 1.0 - block (hitPosition + step (edgeDistance.yzx, edgeDistance.xyz) * step (edgeDistance.zxy, edgeDistance.xyz) * edgeDirection, hitNormal);\n\thighlightIntensity *= smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, max (edgeDistance.x, max (edgeDistance.y, edgeDistance.z)));\n\t#endif\n\n\t// Texture\n\t#ifdef TEXTURE\n\tvec2 textureUV = vec2 (dot (hitUV, hitNormal.yzx), dot (hitUV, hitNormal.zxy)) + 0.5;\n\tfloat textureIntensity = 1.0 - texture (texture, textureUV).a;\n\tfloat texturePhase = 2.0 * PI * randUnpredictable (floor (hitPosition + 0.5 + hitNormal * 1.5));\n\ttextureIntensity *= smoothstep (0.8, 1.0, cos (time * 0.2 + texturePhase));\n\thighlightIntensity = max (highlightIntensity, textureIntensity);\n\t#endif\n\n\t// Set the object color\n\tvec3 color = cos ((hitPosition + hitNormal * 0.5) * 0.05);\n\tcolor = hsv2rgb (vec3 (color.x + color.y + color.z + highlightIntensity * 0.05, 1.0, 1.0));\n\n\t// Lighting\n\tvec3 lightDirection = hitPosition - lightPosition;\n\tfloat lightDistance = length (lightDirection);\n\tlightDirection /= lightDistance;\n\n\tfloat lightIntensity = min (1.0, 1.0 / lightDistance);\n\t#ifdef SHADOW\n\tfloat lightHitDistance;\n\tvec3 lightHitNormal;\n\thit (hitPosition - hitNormal * DELTA, -lightDirection, lightDistance, lightHitDistance, lightHitNormal);\n\tlightIntensity *= step (lightDistance, lightHitDistance);\n\t#endif\n\n\t// Bump mapping\n\tvec3 bumpUV = floor (hitUV * BUMP_RESOLUTION) / BUMP_RESOLUTION;\n\thitNormal = normalize (hitNormal + (1.0 - highlightIntensity) * BUMP_INTENSITY * (hitNormal.yzx * (randUnpredictable (bumpUV) - 0.5) + hitNormal.zxy * (randUnpredictable (bumpUV + 1.0) - 0.5)));\n\n\t// Shading\n\tfloat ambient = mix (AMBIENT_NORMAL, AMBIENT_HIGHLIGHT, highlightIntensity) * ambientIntensity;\n\tfloat diffuse = max (0.0, dot (hitNormal, lightDirection));\n\tfloat specular = pow (max (0.0, dot (reflect (rayDirection, hitNormal), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\tcolor = (ambient + diffuse * lightIntensity) * color + specular * lightIntensity;\n\tcolor *= pow (max (0.0, 1.0 - hitDistance / RAY_LENGTH_MAX), FADE_POWER);\n\n\t// Light source\n\tlightDirection = lightPosition - rayOrigin;\n\tif (dot (rayDirection, lightDirection) > 0.0) {\n\t\tlightDistance = length (lightDirection);\n\t\tif (lightDistance < hitDistance) {\n\t\t\tvec3 lightNormal = cross (rayDirection, lightDirection);\n\t\t\tcolor += smoothstep (0.001, 0.0, dot (lightNormal, lightNormal));\n\t\t}\n\t}\n\n\t// Adjust the gamma\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Set the fragment color\n\t_gl_FragColor = vec4 (color, 1.0);\n}\n\n///////////////////\n// Shadertoy (2) //\n///////////////////\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Basic initialization\n\tresolution = iResolution;\n\ttime = iTime;\n\n\t// Set the position of the head\n\theadPosition = vec3 (64.0 * cos (iTime * 0.1), 9.0 + 9.25 * cos (iTime * 0.5), 2.0 + 2.25 * cos (iTime));\n\n\t// Set the orientation of the head\n\tfloat yawAngle;\n\tfloat pitchAngle;\n\tif (iMouse.z > 0.5) {\n\t\tyawAngle = 4.0 * PI * iMouse.x / iResolution.x;\n\t\tpitchAngle = -4.0 * PI * iMouse.y / iResolution.y;\n\t} else {\n\t\tyawAngle = iTime;\n\t\tpitchAngle = iTime * 0.2;\n\t}\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\theadRotate [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\theadRotate [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\theadRotate [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\t// Lighting\n\tlightPosition = headPosition + headRotate * vec3 (0.2 * sin (iTime * 2.0), 0.2 * sin (iTime * 3.0), 0.2 * sin (iTime) + 0.5);\n\tambientIntensity = max (step (1.0, mod (time, 10.0)), step (0.25, randUnpredictable (vec3 (time))));\n\n\t// Set the fragment color\n\t_main (fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}