{
    "Shader": {
        "info": {
            "date": "1542680526",
            "description": "I had a look at this and wanted to re-create it: https://www.youtube.com/watch?v=WHnFG66W2og",
            "flags": 0,
            "hasliked": 0,
            "id": "XtVfWD",
            "likes": 12,
            "name": "infinite circle stretch packing",
            "published": 3,
            "tags": [
                "circles"
            ],
            "usePreview": 0,
            "username": "qwert33",
            "viewed": 612
        },
        "renderpass": [
            {
                "code": "vec3 orange = vec3(1.,.5,0.);\n\nvec2 domsMouse;\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\n\nfloat circle(vec2 uv) {\n    //uv *= 2.;\n    if (length(uv)< 0.9) {\n        return 0.3;\n    }\n    if (length(uv)< 1.) {\n        return 1.;\n    }\n    return 0.;\n    return clamp(length(uv)-8., 0., 1.);\n    return bias(1.-(abs(length(uv) - 1. +.018) / .02), .8);\n}\nfloat row_of_circles(vec2 uv, float width) {\n    uv.x = mod(uv.x+width, 2.*width) - width;\n    return circle(uv);\n}\n// Returns a unit-length vector at a given rotation.\n// Analogous to e^(-i*theta)\n// i.e. rotate (1,0) anticlockwise for theta radians. (+y means facing up)\nvec2 e(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\nfloat monochrome(vec2 uv) {\n    float height = 4.;\n    float acc = 0.;\n    float animation_fraction = mod(.5*iTime, 1.);// (.5+ .5*cos(mod(2.*iTime, TAU*.5)));\n    animation_fraction = mix(animation_fraction, smoothstep(0., 1., animation_fraction), .5);\n    float theta = TAU/6. * animation_fraction;\n    vec2 c0 = vec2(0., 0.);\n    vec2 c1 = c0 - 2.*e(theta);\n    vec2 c2 = c1 - 2.*e(TAU/3.);\n    vec2 c3 = c2 - 2.*e(TAU/2.-theta);\n    vec2 c4 = c3 - 2.*e(TAU/3.);\n    float separation = 2.* cos(theta);\n    uv.y = mod(uv.y, -c4.y);\n    //if (uv.y > -c4.y*.99) { return 1. ; }\n    \n    acc += row_of_circles(uv + c0, separation);\n    acc += row_of_circles(uv + c1, separation);\n    acc += row_of_circles(uv + c2, separation);\n    acc += row_of_circles(uv + c3, separation);\n    \n    \n    \n    // Extra circles to not get artifacts when wrapping vertically.\n    vec2 offset_bot = vec2(0.0, c4.y);\n    acc += row_of_circles(uv + c0 + offset_bot, separation);\n    acc += row_of_circles(uv + c1 + offset_bot, separation);\n    //acc += row_of_circles(uv + c2 + offset_bot, separation);\n    //acc += row_of_circles(uv + c3 + offset_bot, separation);\n    \n    return clamp(acc, 0., 1.);\n}\n\nfloat f(vec2 fragCoord) {\n    vec2 uv = project(fragCoord);\n    uv /= length(project(domsMouse.xy));\n    return monochrome(uv);\n}\n// antialiasing\nfloat sampleSubpixel(vec2 pixels) {\n    const int size = 1; \n    float disp = 1.0 / (float(size) + 2.0);\n    float contrb = 0.0;\n    float maxContrb = 0.0;\n    for (int j = -size; j <= size; j++) {\n        for (int i = -size; i <= size; i++) {\n            contrb += f(pixels + vec2(float(i) * (disp / 3.0), float(j) * disp));\n            maxContrb += 1.0;\n        }\n    }\n    return contrb / maxContrb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    domsMouse = iMouse.xy;\n    if (iMouse.x == 0.) { \n        domsMouse.x = iResolution.x * .5 + 30.; \n        domsMouse.y = iResolution.y * .5; \n    }\n    fragColor = vec4(orange * sampleSubpixel(fragCoord), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define TAU 6.28318530718\n#define PI TAU/2\n    \n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    x = clamp(x, 0., 1.);\n    b = -log2(1.0 - b);\n    return 1.0 - pow(1.0 - pow(x, 1./b), b);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}