{
    "Shader": {
        "info": {
            "date": "1621584833",
            "description": "simple 2D physics engine with circles\n\ncould be upgrade with some kind of k-tree to check collisions faster",
            "flags": 32,
            "hasliked": 0,
            "id": "flX3zH",
            "likes": 12,
            "name": "2D physics engine",
            "published": 3,
            "tags": [
                "physicsengine"
            ],
            "usePreview": 0,
            "username": "mdb",
            "viewed": 599
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv += 0.5;\n\n    vec3 col = vec3(0.1);\n    \n    col = vec3(0.1);\n    float touch = 0.0;;\n    vec3 col2 = vec3(0.0, 0.0, 0.5);\n    for(int i = 0; i < entity; i++){\n        vec4 ball = getData(i, iChannel0);\n        if (ballRadius*ballRadius*1.8 > dot(uv - ball.xy, uv - ball.xy)) {\n            touch += 1.0;\n            col2.xy = mix(col2.xy, 1.0/(1.0 + exp(-ball.zw)), 1.0/touch);\n        }\n    }\n    if(touch != 0.0){\n        col = col2;\n    }\n    \n\n\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define highp float\n\n// from https://gamedevelopment.tutsplus.com/tutorials/how-to-create-a-custom-2d-physics-engine-the-basics-and-impulse-resolution--gamedev-6331\nstruct Circle\n{\n  vec2 position;\n  vec2 velocity;\n};\n\nbool intersect(Circle A, Circle B){\n    return dot(A.position - B.position, A.position - B.position) <= 4.0*ballRadius*ballRadius;\n}\n\nvoid ResolveCollision(inout Circle A, Circle B, vec2 normal, bool wall)\n{\n  // Calculate relative velocity\n  vec2 rv = B.velocity - A.velocity;\n \n  // Calculate relative velocity in terms of the normal direction\n  float velAlongNormal = dot(rv, normal);\n \n  // Do not resolve if velocities are separating\n  if(velAlongNormal > 0.0)\n    return;\n \n  // Calculate impulse scalar\n  float j = - 0.5 * (1.0 +  restitution) * velAlongNormal;\n  \n  if(wall) j *= 2.0;\n  \n  // Apply impulse\n  A.velocity -= j * normal;\n  return;\n}\n\nvoid PositionalCorrection(inout Circle A, Circle B, vec2 normal, float penetrationDepth, bool wall)\n{\n  const float percent = 0.1;\n  vec2 correction = 0.5 * penetrationDepth * percent * normal;\n  if(wall) correction *= 2.0;\n  \n  A.position -= correction;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int idx = int(fragCoord.x) + int(fragCoord.y)*int(texDimX);\n    if( idx >= entity || fragCoord.x >= float(texDimX)){\n        fragColor = vec4(0.0);\n        return;\n    }\n    if( iFrame < 6 ){\n        float y;\n        float x = 0.1 + modf(float(idx)*0.03, y)*0.8;\n        fragColor = vec4(x, 0.2 + y*0.025, 0.0, -0.9);\n        return;    \n    }\n    vec4 a = getData(idx, iChannel0);\n    Circle A = Circle(a.xy, a.zw);\n    \n    for(int i = 0; i < entity; i++){\n        if(i != idx){\n            vec4 raw = getData(i, iChannel0);\n            Circle B = Circle(raw.xy, raw.zw);\n            if(intersect(A, B)){\n                vec2 normal = normalize(B.position - A.position);\n                ResolveCollision(A, B, normal, false);\n                \n                float depth = distance(A.position, B.position) - 2.0 * ballRadius;\n                PositionalCorrection(A, B, -normal, depth, false);\n                \n            }\n        }\n    }\n    \n    //collition with walls\n    Circle Bfake =  Circle(vec2(0.0), vec2(0.0));\n    \n    if(A.position.x + ballRadius >= 1.0){\n        ResolveCollision(A, Bfake, vec2(1.0, 0.0), true);\n        float depth = A.position.x + ballRadius - 1.0;\n        PositionalCorrection(A, Bfake, vec2(1.0, 0.0), depth, true);\n    }\n    if(A.position.x - ballRadius <= 0.0){\n        ResolveCollision(A, Bfake, vec2(-1.0, 0.0), true);\n        float depth = -(A.position.x - ballRadius);\n        PositionalCorrection(A, Bfake, vec2(-1.0, 0.0), depth, true);\n    }\n        \n    if(A.position.y + ballRadius >= 1.0){\n        ResolveCollision(A, Bfake, vec2(0.0, 1.0), true);\n        float depth = A.position.y + ballRadius - 1.0;\n        PositionalCorrection(A, Bfake, vec2(0.0, 1.0), depth, true);\n    }\n    if(A.position.y - ballRadius <= 0.0){\n        ResolveCollision(A, Bfake, vec2(0.0, -1.0), true);\n        float depth = -(A.position.y - ballRadius);\n        PositionalCorrection(A, Bfake, vec2(0.0, -1.0), depth, true);\n    }\n    \n    \n    \n    float dt = min(iTimeDelta, maxdt);\n    A.velocity += vec2(0.0, -gravity) * dt;\n    A.position += A.velocity * dt;\n    \n    if(mod(float(iFrame), 700.0)<=0.01)A.velocity = vec2(-(A.position.x - 0.5)*2.0, 3.0);\n    \n    \n    fragColor = vec4(A.position, A.velocity);\n}\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define entity 1632\n#define maxdt 0.002\n#define gravity 9.81\n\n#define ballRadius 0.01\n#define ballMass 0.8\n#define restitution 0.7\nconst float invMass = 1.0/ballMass;\n\n#define texDimX 420\nvec4 getData(int i, sampler2D tex){\n    ivec2 coord = ivec2(i % texDimX, i / texDimX);\n    return texelFetch(tex, coord, 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}