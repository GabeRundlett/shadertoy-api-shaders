{
    "Shader": {
        "info": {
            "date": "1561964524",
            "description": "A small loading screen for a compo.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttXSRn",
            "likes": 6,
            "name": "Retro loading",
            "published": 3,
            "tags": [
                "loading"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float cMin = 0.05;\nconst float cMax = 0.07;\nfloat cthick = cMax - cMin;\n\nfloat sat(float a)\n{\n    return clamp(a, 0.,1.);\n}\n\nbool isIn(float a, float mi, float ma)\n{\n    return a > mi && a < ma;\n}\n\nfloat drawD(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(uv.y, -cMax, cMax) && isIn(uv.x,-cthick*2.0, -cthick));\n  float val2 = float(isIn(length(uv), cMin, cMax) && uv.x > 0.0);\n  return val + val2;\n}\n\nfloat drawY(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float valA = float(isIn(length(uv+vec2(0.0, -cMax)), cMin, cMax) && uv.y < cMax && !isIn(uv.x, -cthick, cthick));\n  float valB = float(isIn(uv.x, -cthick*0.5,cthick*0.5) && isIn(uv.y, -cMax, 0.0));\n  return valA +valB;\n}\n\nfloat drawL(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(length(uv), cMin, cMax) && uv.y < 0.0 && uv.x < (cMax-cMin)*0.5);\n  float valB = float(isIn(uv.y, 0.,cMax) && (isIn(uv.x, -cMax, -cMin)));\n  return val+valB;\n}\n\nfloat drawN(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(length(uv), cMin, cMax) && uv.y > 0.0);\n  float valB = float(isIn(uv.y, -cMax, 0.0) && (isIn(uv.x, -cMax, -cMin) || isIn(uv.x, cMin, cMax)));\n  return val+valB;\n}\n\nfloat drawI(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  return float(isIn(uv.y, -cMax, cMax) && isIn(uv.x, -cthick*0.5,cthick*0.5));\n}\n\nfloat drawS(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n//  float ref = float(isIn(length(uv), cMin, cMax));\n  float valA = float(isIn(length(uv), cMin, cMax) && !isIn(uv.y, -cthick, cthick));\n  float valB = float(isIn(-uv.y - uv.x*0.4, -cthick*0.5, cthick*0.5) &&\n    length(uv) < cMax);\n  return valA + valB;\n}\n\nfloat drawO(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n    return float(onCir);\n}\n\nfloat drawC(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n  float valA = float(onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||\n    uv.x <= 0.0 && onCir);\n\n  return valA;\n}\n\n\nfloat drawP(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(uv.y, -cMax, cMax) && isIn(uv.x,-cthick*2.0, -cthick));\n  float val2 = float(isIn(length(uv+vec2(0.0, -0.02)), cMin - cthick, cMin) && uv.x > 0.0);\n\n  return val + val2;\n}\n\nfloat drawR(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(isIn(uv.y, -cMax, cMax) && isIn(uv.x,-cthick*2.0, -cthick));\n  float val2 = float(isIn(length(uv+vec2(0.0, -0.02)), cMin - cthick, cMin) && uv.x > 0.0);\n  uv -= vec2(0.0, -0.02);\n  float  val3 = float(isIn(-uv.y-uv.x, -cthick*0.5,cthick*0.5) &&\n    isIn(uv.y, -0.05, -0.02));\n  return val + val2 + val3;\n}\n\nfloat drawG(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n  float valA = float(onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||\n    uv.x <= 0.0 && onCir);\n  float valB = float(isIn(uv.y, -cthick*0.5, cthick*0.5) &&\n    isIn(uv.x, -cMin + cthick*2., cMin));\n  float valC = float(isIn(uv.x, -cMin + cthick*2., cthick*.5) &&\n                    isIn(uv.y, -cMin, cthick*.5));\n  return valA+valB+valC;\n}\n\nfloat drawE(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n  float valA = float(onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||\n    uv.x <= 0.0 && onCir);\n  float valB = float(isIn(uv.y, -cthick*0.5, cthick*0.5) &&\n    isIn(uv.x, -cMin + cthick*0.5, cMin - cthick*0.5));\n  return valA+valB;\n}\n\nfloat drawA(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = isIn(length(uv), cMin, cMax);\n  float valA = float((onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||\n    uv.x <= 0.0 && onCir) && uv.y > 0.0);\n  float valB = float(isIn(uv.y, -cthick*0.5, cthick*0.5) &&\n    isIn(uv.x, -cMin + cthick*0.5, cMin - cthick*0.5));\n  float valC = float(isIn(uv.x, -cMax, -cMin) && isIn(uv.y, -cMax, 0.0));\n  float valD = float(isIn(uv.x, cMin, cMax) && isIn(uv.y, -cMax, -cthick));\n  return valA+valB+valC+valD;\n}\n\nvec3 drawTxt(vec2 uv, vec2 pos)\n{\n  float scale =0.2;\n  float res;\n  float offX = -0.05;\n  float sp =.9;\n\n  uv.y += 0.175;\n  uv.y *= (sin(10.0*uv.x+iTime)+1.5)*0.5;\n\n  res += drawL(uv, pos+vec2(sp*-0.1+offX,0.0), scale);\n  res += drawO(uv, pos+vec2(sp*-0.07+offX,0.0), scale);\n  res += drawA(uv, pos+vec2(sp*-0.03+offX,0.0), scale);\n  res += drawD(uv, pos+vec2(offX,0.0), scale);\n  res += drawI(uv, pos+vec2(sp*0.022+offX,0.0), scale);\n  res += drawN(uv, pos+vec2(sp*0.045+offX,0.0), scale);\n  res += drawG(uv, pos+vec2(sp*0.08+offX,0.0), scale);\n  /*res += drawA(uv, pos+vec2(sp*0.15+offX,0.0), scale);\n  res += drawN(uv, pos+vec2(sp*0.195+offX,0.0), scale);\n  res += drawC(uv, pos+vec2(sp*0.235+offX,0.0), scale);\n  res += drawY(uv, pos+vec2(sp*0.275+offX,0.0), scale);*/\n\n  return vec3(max(1.-clamp(res,0.0,1.0), 0.4));\n}\n\nvec3 drawFlare(vec2 uv, float radius, vec3 rgb)\n{\n    float coef = 1.-sat(length(uv) / radius);\n    vec3 col = vec3(coef);\n    return col * rgb;\n}\n\n\n\nfloat drawGrid(vec2 uv, float sz, float thick)\n{\n    return float(mod((uv.x), sz) < thick) * float(mod((uv.y), sz) < thick);;\n}\n\nfloat drawRect(vec2 uv, float sz, float thick)\n{\n   \tfloat hth = thick * .5;\n    return float((isIn(abs(uv.x) - sz, -hth, hth) && isIn(abs(uv.y), 0., sz + hth)) ||\n                 (isIn(abs(uv.y) - sz, -hth, hth) && isIn(abs(uv.x), 0., sz + hth))\n                );\n}\n\nvec3 drawBubbles(vec2 uv)\n{\n    int bCnt = 27;\n    float fCnt = float(bCnt);\n    float speed = .2;\n    vec3 col = vec3(153., 255., 153.)/255.;\n    vec3 acc;\n\n    \n    for (int i = 0; i < bCnt; ++i)\n    {\n        float fi = float(i);\n        float yPos =mod(speed*iTime+fi*.1015, 2.)-0.5;\n        vec2 pos = vec2(mod(fi/fCnt, 0.12)*4.-0.3+yPos*0.2*sin(iTime*3.14), yPos);\n        \n        float d = distance(uv, pos);\n        if (isIn(d, 0.008, 0.01))\n            acc -= vec3(2.)*sat(uv.y+0.2);\n    }\n    return acc;\n}\n\nvec3 drawJauge(vec2 uv, float level)\n{\n    float waveLvl = 0.05;\n    float sz = 0.21;\n    level += waveLvl*sin(iTime+uv.x*10.) - waveLvl;\n    level = sat(level);\n    \n    bool inWidth = abs(uv.x) < sz;\n    bool inHeight = uv.y > -sz && uv.y < mix(-sz, sz+waveLvl, level) && uv.y < sz;\n    \n\tfloat coef = float(inWidth && inHeight);\n    \n    vec3 col;\n    \n    float cGrad = pow(max(uv.x+uv.y+0.5,0.),.5);\n    \n    float power = 2.2;\n    vec3 light = vec3(204, 255, 204)/255.0;\n    light.x = pow(light.x, power);\n    light.y = pow(light.x, power);\n    light.z = pow(light.x, power);\n    \n    col = mix(vec3(204, 51, 153)/255.0*0.6, light, cGrad) * (2.*uv.y+0.9);\n\n\t//col += mix(vec3(0, 0, 102)/255.0*0.6, light, cGrad);\n    //col += mix(-sz, sz+waveLvl, level) * vec3(255, 102, 255)/255.0 * sat(uv.y);\n    vec3 greenish =vec3(153, 244, 26)/255.;\n    vec3 bluish = vec3(26, 182, 244)/255.;\n    return col+bluish*coef+drawBubbles(uv)*coef;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    \n    //uv -= vec2(0.5);\n    uv -= vec2(0.5)*(iResolution.xy / iResolution.xx);\n\n    vec3 col;\n    vec3 colFlare = 0.4*drawFlare(uv, 0.5, vec3(0.423,0.13, 0.78));\n    colFlare += 0.4*drawFlare(uv, 0.9, vec3(0.623,0.13, 0.78));\n    \n    colFlare *= 0.0;\n    col += drawJauge(uv, sat(sin(iTime*0.2) *0.5 + 0.5));\n    \n    col += 0.5*vec3(0.523,0.53, 0.88)*drawRect(uv, 0.25,0.0015)*float(!isIn(uv.y, -0.1,0.1));\n    col += 0.2*vec3(0.823,0.43, 0.48)*drawRect(uv, 0.23,0.0013);\n    \n    col += drawGrid(uv, 0.05,0.0015)*vec3(153, 204, 255)/255.0*0.6*sat(1.-(length(uv)/1.));\nfloat offsetPump = +sin(5.*iTime+uv.x*10.)*0.01;\n    col += vec3(204, 51, 153)/255.0*0.6*float(isIn(uv.x, 0.25,1.5) && isIn(uv.y, -0.2+offsetPump,-0.15-offsetPump));\n    col *= drawTxt(uv, vec2(0.42,-0.));\n    col += colFlare;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}