{
    "Shader": {
        "info": {
            "date": "1641448850",
            "description": "Using mipmaps, resolution scaling, and some other micro-optimisations to speed up slackermanz's MNCA. About 45x faster than the original on my machine",
            "flags": 32,
            "hasliked": 0,
            "id": "7tyXWc",
            "likes": 12,
            "name": "Scaled MNCA",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "mipmap",
                "diffusion",
                "automata",
                "life",
                "chaos",
                "cellular",
                "conway",
                "gameoflife",
                "cellularautomata",
                "cellularautomata",
                "cgol"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 341
        },
        "renderpass": [
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\n//\tShader developed by Slackermanz (optimised by davidar)\n//\n//\t\thttps://slackermanz.com\n//\n//\t\tDiscord:\tSlackermanz#3405\n//\t\tGithub:\t\thttps://github.com/Slackermanz\n//\t\tTwitter:\thttps://twitter.com/slackermanz\n//\t\tYouTube:\thttps://www.youtube.com/c/slackermanz\n//\t\tShadertoy: \thttps://www.shadertoy.com/user/SlackermanzCA\n//\t\tReddit:\t\thttps://old.reddit.com/user/slackermanz\n//\n//\t\tCommunities:\n//\t\t\tReddit:\t\thttps://old.reddit.com/r/cellular_automata\n//\t\t\tDiscord:\thttps://discord.com/invite/J3phjtD\n//\t\t\tDiscord:\thttps://discord.gg/BCuYCEn\n//\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texture( iChannel0, .5*fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\n//\tShader developed by Slackermanz (optimised by davidar)\n//\n//\t\thttps://slackermanz.com\n//\n//\t\tDiscord:\tSlackermanz#3405\n//\t\tGithub:\t\thttps://github.com/Slackermanz\n//\t\tTwitter:\thttps://twitter.com/slackermanz\n//\t\tYouTube:\thttps://www.youtube.com/c/slackermanz\n//\t\tShadertoy: \thttps://www.shadertoy.com/user/SlackermanzCA\n//\t\tReddit:\t\thttps://old.reddit.com/user/slackermanz\n//\n//\t\tCommunities:\n//\t\t\tReddit:\t\thttps://old.reddit.com/r/cellular_automata\n//\t\t\tDiscord:\thttps://discord.com/invite/J3phjtD\n//\t\t\tDiscord:\thttps://discord.gg/BCuYCEn\n//\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n\nconst uint MAX_RADIUS = 16u;\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), 105.507401); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n\n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(fragCoord.x > .5*iResolution.x || fragCoord.y > .5*iResolution.y) return;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Setup\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n    float\tres_c\t= texelFetch(txdata, ivec2(gl_FragCoord.xy), 0).x;\t//\tOrigin value references\n    ivec2 pos = ivec2(gl_FragCoord.xy);\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst uvec4 bitringdata = uvec4\n\t(\t32766u, \t\t62987u, \t32752u, \t\t2170u \t);\n\n\tconst uint[8] ubv \t\t= uint[8]\n\t(\t39879523u, \t\t526972426u, \t2727874005u, \t1461826227u, \n\t\t1300644632u, \t1298224u, \t\t95419984u, \t\t823214418u\t\t);\n\n\tconst uint[1] ubi \t\t= uint[1]\n\t(\t2390857921u \t\t\t\t\t\t\t\t\t\t\t\t\t);\n\n//\tParameters\n\tconst\tfloat \ts  = mnp *  64.0 *  96.0;\n\tconst\tfloat \tn  = mnp *  64.0 *  16.0;\n\n//\tNH Rings\n    vec4 sums;\n    vec4 tots;\n\tfor(int i = -(int(MAX_RADIUS)/2); i <= (int(MAX_RADIUS)/2); i++) {\n\t\tfor(int j = -(int(MAX_RADIUS)/2); j <= (int(MAX_RADIUS)/2); j++) {\n            int lod = 1;\n            float a = texelFetch(txdata, (pos + ivec2(i,j))>>lod, lod).x;\n            uint d = uint(.5 + 2.*sqrt(float(i*i+j*j)));\n            if(d < MAX_RADIUS) {\n                vec4 mask = vec4((bitringdata >> d) & 1u);\n                sums += mask * a;\n                tots += mask;\n            }\n        }\n    }\n\n\tvec4 nhv_r = sums/tots;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst uint bt = 8u;\n\n\tif( nhv_r[0] >= utp(ubv[0],bt,0u) && nhv_r[0] <= utp(ubv[0],bt,1u) ) { res_c += bsn(ubi[0], 0u)*s; }\n\tif( nhv_r[0] >= utp(ubv[0],bt,2u) && nhv_r[0] <= utp(ubv[0],bt,3u) ) { res_c += bsn(ubi[0], 1u)*s; }\n\tif( nhv_r[0] >= utp(ubv[1],bt,0u) && nhv_r[0] <= utp(ubv[1],bt,1u) ) { res_c += bsn(ubi[0], 2u)*s; }\n\tif( nhv_r[0] >= utp(ubv[1],bt,2u) && nhv_r[0] <= utp(ubv[1],bt,3u) ) { res_c += bsn(ubi[0], 3u)*s; }\n\n\tif( nhv_r[1] >= utp(ubv[2],bt,0u) && nhv_r[1] <= utp(ubv[2],bt,1u) ) { res_c += bsn(ubi[0], 4u)*s; }\n\tif( nhv_r[1] >= utp(ubv[2],bt,2u) && nhv_r[1] <= utp(ubv[2],bt,3u) ) { res_c += bsn(ubi[0], 5u)*s; }\n\tif( nhv_r[1] >= utp(ubv[3],bt,0u) && nhv_r[1] <= utp(ubv[3],bt,1u) ) { res_c += bsn(ubi[0], 6u)*s; }\n\tif( nhv_r[1] >= utp(ubv[3],bt,2u) && nhv_r[1] <= utp(ubv[3],bt,3u) ) { res_c += bsn(ubi[0], 7u)*s; }\n\n\tif( nhv_r[2] >= utp(ubv[4],bt,0u) && nhv_r[2] <= utp(ubv[4],bt,1u) ) { res_c += bsn(ubi[0], 8u)*s; }\n\tif( nhv_r[2] >= utp(ubv[4],bt,2u) && nhv_r[2] <= utp(ubv[4],bt,3u) ) { res_c += bsn(ubi[0], 9u)*s; }\n\tif( nhv_r[2] >= utp(ubv[5],bt,0u) && nhv_r[2] <= utp(ubv[5],bt,1u) ) { res_c += bsn(ubi[0],10u)*s; }\n\tif( nhv_r[2] >= utp(ubv[5],bt,2u) && nhv_r[2] <= utp(ubv[5],bt,3u) ) { res_c += bsn(ubi[0],11u)*s; }\n\n\tif( nhv_r[3] >= utp(ubv[6],bt,0u) && nhv_r[3] <= utp(ubv[6],bt,1u) ) { res_c += bsn(ubi[0],12u)*s; }\n\tif( nhv_r[3] >= utp(ubv[6],bt,2u) && nhv_r[3] <= utp(ubv[6],bt,3u) ) { res_c += bsn(ubi[0],13u)*s; }\n\tif( nhv_r[3] >= utp(ubv[7],bt,0u) && nhv_r[3] <= utp(ubv[7],bt,1u) ) { res_c += bsn(ubi[0],14u)*s; }\n\tif( nhv_r[3] >= utp(ubv[7],bt,2u) && nhv_r[3] <= utp(ubv[7],bt,3u) ) { res_c += bsn(ubi[0],15u)*s; }\n\n    res_c -= n;\n    \n    res_c = clamp(res_c,0.0,1.0);\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(.5*iMouse.xy - fragCoord) < 14.0) {\n        res_c = round(mod(float(iFrame),2.0));\n    }\n    if (iFrame == 0) { res_c = reseed(0); }\n    fragColor=vec4(res_c);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}