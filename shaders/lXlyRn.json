{
    "Shader": {
        "info": {
            "date": "1728052682",
            "description": "Using a triangle grid and a Mobius spiral transformation to create an impossible geometry style faux 3D lattice.",
            "flags": 0,
            "hasliked": 0,
            "id": "lXlyRn",
            "likes": 39,
            "name": "Faux Spiral Lattice",
            "published": 3,
            "tags": [
                "grid",
                "triangle",
                "spiral",
                "mobius",
                "geometry",
                "lattice",
                "impossible"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "/*\n\n\tFaux Spiral Lattice\n\t-------------------\n    \n    Lattice structures rendered in the impossible isometric style are pretty \n    common, and reasonably simple to make. This particular one has a Mobius \n    spiral applied to it, which makes it look a little more interesting.\n    \n    None of this is difficult: The lattice consists of cubes and joining beams.\n    The cubes are created by rendering quads at the triangle vertices and the\n    beams are created by rendering quads at the triangle mid-points. There's a\n    bit of fiddly triangle math involved, but nothing too difficult.\n    \n    The details are below, but the code was rushed, and written off the top of \n    my head without a lot of forethought. The code works fine, and if you\n    strip away the excess, you'll find that the code footprint is reasonably\n    small. However, for anyone who wants to make one of these, I'd suggest \n    ignoring the code here. Start by creating a triangle grid, then rendering \n    the quads by whatever means you're comfortable with.\n\n\n\t\n    Other Examples:\n    \n    // A similar, but slightly more complicated isometric lattice.\n    Isometric Lattice - Shane\n    https://www.shadertoy.com/view/tdKfW1\n\n\t\n    // This is a beautiful static rendering.\n    Confusing cubes - sinec\n    https://www.shadertoy.com/view/NsKXRd\n    \n\n*/\n\n// Mobius spiral transform.\n#define MOBIUS\n\n// Face color - Greyscale: 0, Green: 1, Yellow: 2.\n#define FACE_COLOR 2\n\n// Link color - Greyscale: 0, Pink: 1, Yellow: 2.\n#define LINK_COLOR 1\n\n// Show the triangle grid that the pattern is based on...\n// Probably a little redundant in this case, but it's there.\n//#define SHOW_GRID\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\n// Standard Mobius transform: f(z) = (az + b)/(cz + d). Slightly obfuscated.\n// You could use a 2x2 matrix tranformation as well, if you wanted.\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2){\n\n\tz1 = p - z1; p -= z2;\n\treturn vec2(dot(z1, p), z1.y*p.x - z1.x*p.y)/dot(p, p);\n}\n\n// Standard spiral zoom.\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase){\n\t\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.2831; // Bringing it back to integer range.\n\tfloat d = log(length(p));\n    // \"a*N/3.\" (for even N only) will work with Mobius (without scaling below) also.\n\tp = (vec2(a*n + d*spiral, -d*zoom + a) + phase);\n    \n    // Accounting for the triangle scaling.\n    #ifdef MOBIUS\n    p *= vec2(1./1.732, 1);\n    #endif\n    \n    return p;\n}\n\n// Not a proper quad polygon function, but it's good enough for this example.\nfloat quadP(vec2 p, mat4x2 q){\n\n    float d = -1e5;\n    \n    for(int i = 0; i<4; i++){\n    \n        d = max(d, distLineS(p, q[(i + 1)%4], q[i]));\n    }\n    \n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/res;\n    \n    \n    // Global scale factor.\n    #ifdef MOBIUS\n    // Extra fish-eye distortion. It makes the faux double tunnel effect\n    // appear a little more bulbous, or something to that effect.\n    uv *= .75 + dot(uv, uv)*.5;\n    const float sc = 1.25;\n    #else\n    const float sc = 1.35;    \n    #endif\n    // Smoothing factor.\n    float sf = sc/res;\n    \n    // Scene rotation, scaling and translation.\n    #ifdef MOBIUS\n    mat2 sRot = rot2(-3.14159/4.);\n    #else\n    mat2 sRot = rot2(-3.14159/6.); //mat2(1, 0, 0, 1);\n    #endif\n    \n    \n    vec2 camDir = sRot*normalize(vec2(1.732, 1)); // Camera movement direction.\n    vec2 ld = sRot*normalize(vec2(1, -1)); // Light direction.\n    vec2 p = sRot*uv*sc;\n    \n    #ifndef MOBIUS\n    // Camera animation when not using the Mobius transform.\n    p -= camDir*iTime*scale/3.;\n    #endif\n    \n    \n    // Radial coordinate factor. Used for shading.\n    float r = 1.;\n    // Mobius spiral transformation.\n    #ifdef MOBIUS\n    // Mobius.\n    // Hacky depth shading.\n    r = length(p - vec2(.5, 0));\n    p = Mobius(p, vec2(-1, -.5), vec2(.5, 0));\n\n    // Spiral zoon.\n    r = min(r, length(p - vec2(-.5))); \n    p = spiralZoom(p, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.25);\n    #endif\n\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    //\n    mat3x2 vID, v; // Vertex IDs and relative vertex position.\n    vec4 p4 = getTriVerts(p, vID, v);\n    // Local cell coordinates\n    p = p4.xy;\n    // Unique triangle ID (cell position based).\n    vec2 ctrID = p4.zw; \n    \n\n\n    // Equilateral triangle cell side length.\n    float sL = length(v[0] - v[1]);\n    \n    \n    float ln = 1e5;\n    \n    // Edge width.\n    #ifdef MOBIUS\n    float ew = .0045;\n    #else\n    float ew = .006;\n    #endif\n    \n    // Precalculating the edge points and edge IDs. You could do this inside\n    // the triangle grid function, but here will be fine.\n    mat3x2 e, eID;\n    for(int i = 0; i<3; i++){\n        int ip1 = (i + 1)%3;\n        eID[i] = mix(vID[i], vID[ip1], .5);\n        e[i] = mix(v[i], v[ip1], .5);\n    }\n\n\n    // Three quads.\n    vec3 quad = vec3(1e3);\n    \n    float poly = -1e5;\n    \n    // Triangles: A single call to a triangle distance function would\n    // be more efficient, but this will do for now.\n    for(int i = 0; i<3; i++){\n    \n        float ed = distLineS(p, v[i], v[(i + 1)%3]);\n        poly = max(poly, -ed);   \n    \n    }\n    \n    // Line thickness.\n    float th = sL/6.*.8660254;\n    float fL = sL/2.;\n\n    // Quads for the connecting lines.\n    for(int j = 0; j<3; j++){\n    \n        int i = j;\n\n        float dir = 1.;\n        if(gTri<0.){ \n        \n           i = 2 - j;        \n           dir *= -1.;\n        \n        }\n        \n        int ip1 = (i + 1)%3;\n        int ip2 = (i + 2)%3;\n\n        vec2 eN0 = -normalize(e[i])*th;\n        vec2 eN1 = -normalize(e[ip1])*th;\n        float innerLn0 = distLineS(p, v[i] + eN0, v[ip1] + eN0);\n        float innerLn1 = distLineS(p, v[ip1] + eN1, v[ip2] + eN1);\n        \n        quad[i] = max(poly, max(dir*innerLn0, -dir*innerLn1));\n   \n    }\n \n    \n      \n    // Random colors.\n    vec3 sCol = .5 + .45*cos(6.2831*hash21(p4.zw)/1. + vec3(0, 1, 2)*2. - .85);\n    \n    // Directional shading.\n    vec3 sh = vec3(.6, .3, .9);\n    \n    // Three colors for three directions.\n    vec3 fCol[3] = vec3[3](vec3(1, .4, .2), vec3(.4, .2, .1), vec3(1, 1, .3));\n    ////vec3 fCol[3] = vec3[3](vec3(.5), vec3(.2), vec3(1));\n    \n    // Background color.\n    vec3 col = vec3(.025); // fCol[1]/8.;\n \n    // Swizzling the shades and colors for alternate triangles.\n    if(gTri<0.){\n       sh = sh.zxy;\n       fCol = vec3[3](fCol[2],  fCol[0], fCol[1]);\n    \n    }\n    \n    // Face quads.\n    vec3 face; // Sides.\n    vec3 faceEnd; // Face end.\n   \n    // Main quad and quad shadow vertices.\n    mat4x2 pp, ppS;\n    \n    // Shadow.\n    float shadow = 1e5;\n    \n    // Constructing the face quads.\n    for(int i = 0; i<3; i++){\n       \n         int ip1 = (i + 1)%3;\n         int ip2 = (i + 2)%3;\n         \n         // \"gTri<0.\" is upside down.\n         vec2 t0 = normalize(v[ip1] - v[i])*fL;\n         vec2 t1 = normalize(v[ip2] - v[ip1])*fL;\n         vec2 t2 = normalize(v[i] - v[ip2])*fL;\n         // Clockwise from the left.\n         pp[0] = v[i];\n         pp[1] = v[i] + t0;/// - t2;////////\n         pp[2] = v[i] + t0 + t1;\n         pp[3] = v[i] + t1;\n         \n          \n         \n         // Rotating and reversing points on adjoining (upside down) triangles.\n         if(gTri>0.){\n          \n            pp[3] = v[i];\n            pp[2] = v[i] - t2;\n            pp[1] = v[i] - t2 - t1;\n            pp[0] = v[i] - t1;\n            \n            ppS = mat4x2(pp[0], mix(pp[0], pp[1], .5), pp[2], pp[3]);\n             \n            if(i==2) shadow = quadP(p, ppS);\n      \n         }\n         else {\n         \n            ppS = mat4x2(pp[0], pp[1], mix(pp[1], pp[2], .5), pp[3]);\n            if(i==0) shadow = quadP(p, ppS);\n         \n         }\n         \n          \n         face[i] = quadP(p, pp);\n         \n         float divLn = distLineS(p, v[i], v[ip2]);\n         float smCDist = (fL - th)/2.*.75;\n         float eD = (smCDist);\n         quad[i] = max(quad[i], (divLn + eD));\n         quad[i] = max(quad[i], -(divLn + (sL - fL)*.8660254));\n   \n         \n    \n    }\n    ///////////\n    \n    \n   \n    // Rendering the faces, dark edges, etc.\n    float tempR = r; \n    float sR = sqrt(tempR);\n    float rimW = scale/10.; // Inner quad width.\n\n    \n    for(int i = 0; i<3; i++){\n    \n    \n         int j = i;\n         if(gTri<0.) j = (i + 1)%3;\n\n         // Coloring.\n         vec3 oCol = fCol[(i + 2)%3];\n         \n         #if FACE_COLOR == 0\n         oCol = vec3(1)*dot(oCol, vec3(.299, .587, .114));\n         #elif FACE_COLOR == 1\n         oCol = fCol[i].yxz;\n         #endif\n         \n         // Faces, then the face ends, and finally, the quad lines.\n         col = mix(col, oCol*.05, 1. - smoothstep(0., sf, face[i]*r));\n         vec3 eCol = mix(oCol*1.3, vec3(1), .1);\n         col = mix(col, eCol, 1. - smoothstep(0., sf, (face[i] + ew/sR)*r));\n         \n     \n         col = mix(col, oCol*.05, 1. - smoothstep(0., sf, (face[i] + rimW)*r));\n         col = mix(col, oCol, \n               1. - smoothstep(0., sf, (face[i] + (rimW + ew*1./sR))*r));\n    \n    }\n    \n    \n    // Distance for inner dark quads.\n    rimW = scale/13.;\n    \n    // The shadow length is resolution dependent.\n    float shF = iResolution.y/450.;\n\n    // Rendering the lattice beams.\n    for(int i = 0; i<3; i++){\n\n         int j = i;\n         if(gTri<0.) j = (i + 2)%3;\n\n         // Colors.\n         vec3 oCol = fCol[i];\n         //\n         #if LINK_COLOR == 0\n         oCol = vec3(1)*dot(oCol, vec3(.299, .587, .114));\n         #elif LINK_COLOR == 1\n         oCol = fCol[i].xzy;\n         #endif\n\n         // Applying the lattice beam quads to the background.\n         // Faux ambient occlusion.\n         col = mix(col, vec3(0), (1. - smoothstep(0., sf*shF*12., \n                   max(quad[i], face[j] + .03)))*.5);\n         col = mix(col, oCol*.05, 1. - smoothstep(0., sf, quad[i]*r));\n         vec3 eCol = mix(oCol*1.3, vec3(1), .1);\n         col = mix(col, eCol, (1. - smoothstep(0., sf, (quad[i] + ew/sR)*r)));\n\n         col = mix(col, oCol*.05, 1. - smoothstep(0., sf, (quad[i] + rimW)*r));\n         col = mix(col, oCol, \n               1. - smoothstep(0., sf, (quad[i] + (rimW + ew*1./sR))*r));\n\n    }\n\n    // Applying the faux shadows.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*shF*4., shadow))*.5);\n\n\n    // Post processing colors. Not that important.\n    uv = fragCoord/iResolution.xy - .5;\n    vec3 oCol = vec3(1.2, .8, .6);\n    #if FACE_COLOR == 0\n    oCol = vec3(1)*dot(oCol, vec3(.299, .587, .114));\n    #elif FACE_COLOR == 1\n    oCol = oCol.yxz/(1. + oCol.yxz)*2.;\n    #endif\n\n    #ifdef MOBIUS\n    col *= oCol*smoothstep(.025, .5, tempR);\n    //col = mix(col.zyx, col.yzx, smoothstep(0., 1., r));\n    #if 0\n    col = mix(col, col.zyx, 1. - smoothstep(.3, .7, r));\n    col = mix(col, col.yxz, smoothstep(.3, 1., -uv.y + uv.x/2. + .4)); \n    #else\n    col = mix(col, col.zyx, smoothstep(.3, .8, -uv.y + uv.x/2. + .5)); \n    #endif\n    #else\n    col *= oCol;\n    col = mix(col, col.zyx, smoothstep(.1, .9, -uv.y + uv.x/2. + .5));  \n    #endif\n\n\n    #ifdef SHOW_GRID\n    // Rendering the grid.\n    vec3 svCol = col;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, (abs(poly*r) - ew*1.5)));\n    col = mix(col, svCol*4. + .8, 1. - smoothstep(0., sf, (abs(poly*r) - ew/3.*sqrt(r))));\n    #endif\n    \n    // Vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./3.;\n \nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n\n    // Rectangle scale.\n    const vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n    // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/3.;\n    vec2 tID = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n/*\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat sdEqTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n*/\n  \n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}