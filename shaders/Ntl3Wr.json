{
    "Shader": {
        "info": {
            "date": "1621912486",
            "description": "wot he said,\n\"Another fly through, this time through a Menger system (with some perturbations). \nThe 'roto-perspective' may be adjusted using the 'NonLinearPerspective' define.\"",
            "flags": 32,
            "hasliked": 0,
            "id": "Ntl3Wr",
            "likes": 6,
            "name": "Daisy chainsaw",
            "published": 3,
            "tags": [
                "raymarching",
                "fractals",
                "menger"
            ],
            "usePreview": 0,
            "username": "xenn",
            "viewed": 388
        },
        "renderpass": [
            {
                "code": "// Fork of \"MAY DAY , MAY DAY !\" by xenn. https://shadertoy.com/view/7sSXWd\n// 2021-05-25 03:06:14\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uuv = uv * 2.0 - 1.0;\n    vec3 c = texture(iChannel0, uv).rgb;\n    vec4 col = vec4(pow(c, vec3(0.5)), 1.0);\n\n    fragColor = mix(vec4(.0), col, 1.-smoothstep(0.,1.,length(uuv)*0.6));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// Fork of \"Menger Journey\" by Syntopia. https://shadertoy.com/view/Mdf3z7\n// 2021-05-17 16:50:31\n\n#define MaxSteps 22\n#define MinimumDistance 0.0009\n#define normalDistance     0.0002\n\n#define Iterations 8\n#define PI 3.141592\n#define Scale 3.0*abs(01.1-cos(iTime*0.25)/2.0)\n#define FieldOfView 1.0\n#define Jitter 0.05\n#define FudgeFactor 0.7\n#define NonLinearPerspective 3.0*abs(01.0+sin(iTime*0.35)/2.0)\n#define DebugNonlinearPerspective false\n\n#define Ambient 0.0184\n#define Diffuse 0.5\n#define LightDir vec3(1.0)\n#define LightColor vec3(1.0*abs(1.1-sin(iTime*0.5)/4.0),1.0,0.858824-cos(iTime*0.5)/2.0)\n#define LightDir2 vec3(1.0*abs(01.1-sin(iTime*01.5)/2.0),-1.0*abs(01.1-sin(iTime*0.5)/2.0),1.0/abs(01.1-sin(iTime*0.5)/0.50))\n#define LightColor2 vec3(0.0+abs(sin(iTime*1.0)),0.333333,1.0*abs(01.1-sin(iTime*0.25)/2.0))\n#define Offset vec3(0.92858+(01.1*(sin(iTime*0.35))/19.50),0.92858090,0.2858090*(02.1+cos(iTime*0.0235)/8.0))\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n// DE: Infinitely tiled Menger IFS.\n//\n// For more info on KIFS, see:\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\nfloat DE(in vec3 z)\n{\n\t// enable this to debug the non-linear perspective\n\tif (DebugNonlinearPerspective) {\n\t\tz = fract(z);\n\t\tfloat d=length(z.xy-vec2(0.5));\n\t\td = min(d, length(z.xz-vec2(0.5)));\n\t\td = min(d, length(z.yz-vec2(0.5)));\n\t\treturn d-0.01;\n\t}\n\t// Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));\n\n\tfloat d = 1000.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tz.xy = rotate(z.xy,4.0+2.0*cos( iTime/8.0));\t\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.5*Offset.z*(Scale-0.50))  z.z+=Offset.z*(Scale-1.0);\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\t\n\treturn d-0.001;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\t// Non-linear perspective applied here.\n\t\tdir.zy = rotate(dir2.zy,totalDistance*cos( iTime/4.0)*NonLinearPerspective);\n\t\t\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 1.1-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\t\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera position (eye), and camera target\n\tvec3 camPos = 0.05*iTime*vec3(1.0,0.0,0.0);\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.4*iTime));\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\n}\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base * overlay*0.8975, 1.0);\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*01.1;\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0, vUv);\n\tfloat random = rand(vUv+time*0.1);\n\n\tfragColor = mix(vec4(random), tex-random*0.5, clamp(time*0.50, 0.0,0.95));\n    \n    fragColor.rgb = clamp(fragColor.rgb,vec3(0.0), vec3(01.0)); \n\tfragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*0.78975, 1.0);\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}