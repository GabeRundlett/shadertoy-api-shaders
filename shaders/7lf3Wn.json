{
    "Shader": {
        "info": {
            "date": "1621876254",
            "description": "This shader illustrates Marden's theorem on the Steiner inellipse of a triangle.",
            "flags": 0,
            "hasliked": 0,
            "id": "7lf3Wn",
            "likes": 28,
            "name": "Marden's Theorem",
            "published": 3,
            "tags": [
                "2d",
                "ellipse",
                "marden",
                "saddlepoint"
            ],
            "usePreview": 0,
            "username": "neozhaoliang",
            "viewed": 962
        },
        "renderpass": [
            {
                "code": "/* Marden's theorem on Steiner inellipse, Zhao Liang.\n\nMotivated by this tweet:\n\n    https://twitter.com/theAlbertChern/status/1395468792788967428?s=20\n*/\n#define PI 3.141592653\n\nfloat sl;\n\nconst float palNum = 70.;\n\n\nfloat sFract(float x, float sm)\n{\n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = 1.;\n\n    // The hardware \"fwidth\" is cheap, but you could take the expensive route and\n    // calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x)*sf*sm);\n\n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2.*u)*step(u.y, u.x);\n    return clamp(1. - u.x/u.y, 0., 1.); // Cos term ommitted.\n}\n\n// Only correct for nonnegative values, but in this example, numbers aren't negative.\nfloat sFloor(float x)\n{\n    return x - sFract(x, 1.);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r )\n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    float d = length(max(w,0.0));\n    return ((k>0.0)?d:-d) + r;\n}\n\n\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\n    return clamp(p*hr, 0., 1.);\n}\n\nfloat msign(in float x)\n{\n    return x < 0.0 ? -1.0 : 1.0;\n}\n\nmat2 rot2d(float a)\n{\n    float c=cos(a), s=sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 cmul(vec2 p, vec2 q)\n{\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\nvec2 csqrt(vec2 p)\n{\n    float a = atan(p.y, p.x) / 2.;\n    return vec2(cos(a), sin(a)) * sqrt(length(p));\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    vec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\n// iq's triangle signed distance function\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// ellipse signed distance function\nfloat sdEllipse( vec2 p, vec2 cen, float theta, in vec2 ab )\n{\n    p -= cen;\n    float c = cos(theta), s = sin(theta);\n    p *= mat2(c, s, -s, c);\n    vec2 pab = p / (ab * ab);\n    return (0.5 * dot(pab, p) - 0.5) / length(pab);\n}\n\nfloat sdEllipseFromTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2, out vec2 f1, out vec2 f2)\n{\n    vec2 m = (p0 + p1 + p2) / 3.;\n    vec2 n = (cmul(p0, p1) + cmul(p1, p2) + cmul(p2, p0)) / 3.;\n    f1 = m + csqrt(cmul(m, m) - n);\n    f2 = m - csqrt(cmul(m, m) - n);\n    vec2 mid = (p0 + p1) / 2.;\n    float a = (length(mid - f1) + length(mid - f2)) / 2.;\n    vec2 cen = (f1 + f2) / 2.;\n    vec2 dir = (f1 - f2) / 2.;\n    float b = sqrt(a*a -dot(dir, dir));\n    float theta = atan(dir.y, dir.x);\n    return sdEllipse(p, cen, theta, vec2(a, b));\n}\n\nfloat getVoltage( vec2 p, vec2 p0, vec2 p1, vec2 p2 )\n{\n    float c = length(p - p0) * length(p - p1) * length(p - p2);\n    c = log(max(c, 0.001));\n    c = c / 10. + 0.5;\n    c = clamp(c, 0., 1.);\n    float level = sFloor(c*(palNum - .001));\n    sl = level;\n    return clamp(level/(palNum - 1.), 0., 1.) * .85 + .15 * c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float sf = 2. / iResolution.y;\n    vec2 p = uv * 2.;\n\n    // triangle vertices\n    vec2 A = vec2(1.5*sin(iTime), 1.5);\n    vec2 B = vec2(-2.+0.4*cos(iTime*0.7), -1.+0.6*cos(iTime*0.7));\n    vec2 C = vec2(1.8+cos(iTime), -1.6);\n\n    // distance to the triangle\n    float dtri = sdTriangle(p, A, B, C);\n\n    // foci of the Steiner inscribed ellipse.\n    vec2[2] foci;\n\n    // solve the ellipse and foci\n    vec2 m = (A + B + C) / 3.;\n    vec2 n = (cmul(A, B) + cmul(B, C) + cmul(C, A)) / 3.;\n    foci[0] = m + csqrt(cmul(m, m) - n);\n    foci[1] = m - csqrt(cmul(m, m) - n);\n    // the tangent point is the middle point of an edge.\n    vec2 mid = (A + B) / 2.;\n    // semi-axis\n    float a = (length(mid - foci[0]) + length(mid - foci[1])) / 2.;\n    vec2 cen = (foci[0] + foci[1]) / 2.;\n    vec2 dir = (foci[0] - foci[1]) / 2.;\n    float b = sqrt(a*a - dot(dir, dir));\n    float theta = atan(dir.y, dir.x);\n    // now we have the distance to the ellipse and the foci\n    float dellipse = sdEllipse(p, cen, theta, vec2(a, b));\n    float dfoci = min(length(p - foci[0]), length(p - foci[1])) - 0.04;\n\n    // distance to the medians\n    float dlines = 1e5;\n    dlines = min(dlines, dseg(p, A, (B+C)/2.));\n    dlines = min(dlines, dseg(p, B, (A+C)/2.));\n    dlines = min(dlines, dseg(p, C, (B+A)/2.));\n\n    // inside the ellipse/between ellipse and triangle/outside the triangle\n    float sgn = dellipse < 0. ? -2. : (dtri < 0. ?  0. : 1.);\n\n    // get voltage at this point\n    float volt = getVoltage(p, A, B, C);\n    float ssl = sl;\n\n    vec2 e = vec2(8./clamp(iResolution.y, 300., 800.), 0);\n    float fxl = getVoltage(p + e.xy, A, B, C);\n    float fxr = getVoltage(p - e.xy, A, B, C);\n    float fyt = getVoltage(p + e.yx, A, B, C);\n    float fyb = getVoltage(p - e.yx, A, B, C);\n\n    // color the region between voltage contours\n    vec3 col = vec3(0.4, 0.7, 0.4) - sgn*vec3(0.2, 0., 0.2)*ssl/palNum;\n    // dissipate the colors by doing some rotation\n    col = rotHue(col, -(min(ssl/palNum, 0.85))*12.+1.);\n    // darken the edges\n    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb))*10., 0.);\n    // make some highlight\n    fxl = getVoltage(p + e.xy*1.5, A, B, C);\n    fyt = getVoltage(p + e.yx*1.5, A, B, C);\n    col += vec3(.9, .7, 1.)*(max(volt - fyt, 0.) + max(volt - fxl, 0.)\n                             + max(volt - fxr, 0.) + max(volt - fyb, 0.))*ssl;\n    // draw the triangle\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dtri)-0.01);\n    // draw the ellipse\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dellipse)-0.005);\n    // draw the medians\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dlines)-0.002);\n    // draw the segment connecting the foci\n    col = mix(col, vec3(0.91, 0.1, 0.1), 1.-smoothstep(0., 0.005+2.*sf, dseg(p, foci[0], foci[1])-0.01));\n\n    // decorate the vertices and foci\n    vec2[3] verts; verts[0] = A; verts[1] = B; verts[2] = C;\n    float lw = 0.02;\n\n    for (int i=0; i<3; i++)\n    {\n        float dv = length(p - verts[i]) - .12;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(1, .7, .6), 1. - smoothstep(0., sf, dv + lw*1.6));\n        float cro = sdCross(p - verts[i], vec2(0.06, 0.012), 0.01);\n        cro = abs(cro);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, cro - lw));\n    }\n    for (int i=0; i<2; i++)\n    {\n        float dv = length(p - foci[i]) - .07;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(.4, .6, 1.), 1. - smoothstep(0., sf, dv + lw*1.2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .075 - lw));\n    }\n    \n    col *= 1.25 - 0.2*length(p);\n    \n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}