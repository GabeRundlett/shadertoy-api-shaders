{
    "Shader": {
        "info": {
            "date": "1586372449",
            "description": "This technique is described in this article I wrote: \nhttps://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/",
            "flags": 32,
            "hasliked": 0,
            "id": "wd2yRm",
            "likes": 34,
            "name": "Pixel sorting with vector field",
            "published": 3,
            "tags": [
                "pixel",
                "field",
                "vector",
                "sort",
                "sorting",
                "diagonal"
            ],
            "usePreview": 1,
            "username": "ciphered",
            "viewed": 7662
        },
        "renderpass": [
            {
                "code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n// To understand how this technique works, I wrote an illustrated article on\n// my blog, check it out if you are interested:\n//\n// https://ciphered.xyz/2020/04/08/pixel-sorting-on-shader-using-well-crafted-sorting-filters-glsl/\n// \n//\n// Buffer A, B, C generates the 2 different sorting filters,\n// Buffer C is where the filter selection happens,\n// Buffer D sorts\n//\n// This shader displays the result of the sort, and overlays the vector\n// field given the Y position of the mouse\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv);\n    vec4 vfield = texture(iChannel1, uv);\n    \n    float s = step(1. - iMouse.y / iResolution.y, 1.-uv.y);\n    \n    color.rgb+= vfield.rgb * s;\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec4 color = vec4(1.0);\n    float _Frame = float(iFrame);\n\n\t\n\tvec2 dir = vec2(1, 1);\n\t\n\t// size of a texel\n\tvec2 texelSize = vec2(1./iResolution.x, 1./iResolution.y);\n\t\n\t// we differentiate 1/2 pixels on the y axis\n\tvec2 iuv = floor(uv * iResolution.xy);\n\tfloat r = mod(iuv.y, 2.0) * 2. - 1.; // r = -1.0 or 1.0\n\t\n\t// here goes the rules to define the displacement map\n\tdir*= r * (mod(_Frame, 2.0) * 2. - 1.);\n\t\n\t// we create \"bands\", and swap correctly the direction \n\tfloat b = mod(floor(uv.y * 5.0), 2.0) * 2. - 1.;\n\tdir*= vec2(b, 1);\n\t\n\t// color defined by the direction, and b encodes the direction of the sort\n\tcolor = vec4(dir, b, 1.0);\n\t\n\t\n\tfragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec4 color = vec4(0, 0, 0, 1);\n    float _Frame = float(iFrame);\n    \n    // uvs\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv05 = uv - 0.5;\n    vec2 uva = abs(uv05);\n    vec2 uvf = mod(floor(uva * iResolution.xy) + _Frame, 2.0);\n    \n    \n    // directions\n\tvec2 topright = vec2(1, 1);\n\tvec2 bottomright = vec2(1, -1);\n    \n    // diagonal quadrant\n\tfloat dQuad = sign(uv05.x) * sign(uv05.y) * 0.5 + 0.5;\n\tfloat l = mix(uvf.x, uvf.y, dQuad);\n    \n    // direction depends on the quadrant\n\tvec2 dir = mix(topright, bottomright, dQuad);\n\tdir*= sign(uv05.y);\n    \n    // direction is nverted 1/2\n\tdir*= mod(floor(uv.y * iResolution.y) + _Frame, 2.0) * 2. - 1.;\n    color.rg = dir;\n    \n    // blue channel defines the direction of the swap\n\tcolor.b = uv05.y < 0.0 ? 1.0 : 0.0;\n    // we adjust the swap direction outside of the square to give a nice effect\n\tcolor.b+= round(uva.x + uva.y);\n\tif (color.b > 1.5) color.b = 0.0;\n\tcolor.b = 1. - color.b;\n\t\n\t// alpha channel defines if there is a sort or not on the line\n\tfloat isTopLeft = uv05.x > 0.0 && uv05.y > 0.0 ? 1.0 : 0.0;\n\tfloat nosort = isTopLeft;\n\tnosort*= uv05.y * iResolution.y > 1.0 ? 0.0 : 1.0;\n\tcolor.a-= nosort;\n    \n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n// This buffer both generates a sort filter and picks which one should be used \n// between A, B and C, given the time\n//\n// Output of this buffer will be the vector field used by the sort buffer (D)\n//\n\n\nvec4 getVfield (vec2 uv) {\n\tvec4 color = vec4(1.0);\n\n\tvec2 topright = vec2(1.0, 1.0);\n\t\n\t// size of a texel\n\tvec2 texelSize = vec2(1./iResolution.x, 1./iResolution.y);\n\t\n\t// we differentiate 1/2 pixels on the y axis\n\tvec2 iuv = floor(uv * iResolution.xy);\n\tfloat r = mod(iuv.y, 2.0) * 2. - 1.; // r = -1 or 1.0\n\t\n\t// here goes the rules to define the displacement map\n\tvec2 dir = topright * r * (mod(float(iFrame), 2.0) * 2. - 1.);\n    \n    // we invert on the left to preserve consistency\n    dir*= round(uv.x) * 2. - 1.;\n\t\n\t// color defined by the direction\n\tcolor = vec4(dir, round(uv.x), 1.0);\n\t\n\t// we stop on the middle\n\tfloat m = step(1./iResolution.x, abs(uv.x-0.5));\n\tcolor.a = m;\n\t\n\treturn color;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // sample buffer A & B\n    vec4 vfieldA = texture(iChannel0, uv);\n    vec4 vfieldB = texture(iChannel1, uv);\n    vec4 vfieldC = getVfield(uv);\n    \n    // the vector field changes periodically\n    float t = mod(iTime, 15.0);\n    \n    vec4 color = vfieldA;\n    \n    if (t > 10.0) {\n    \tcolor = vfieldC;   \n    } else if (t > 5.0) {\n     \tcolor = vfieldB;   \n    }\n    \n    // we swap the blue channel to change the direction of the sort\n    float t2 = mod(iTime, 30.0);\n    if (t2 > 15.0) {\n    \tcolor.b = 1. - color.b;   \n    }\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// @author ciphrd <https://instagram.com/ciphrd>\n// @license MIT\n//\n// This is where the sort happens\n// \n// A sorting filter (vector field), is grabbed from the buffer C.\n// Buffer C controls which buffer is picked\n//\n\n\n// returns a grayscale based on the average of the 3 components\nfloat gscale (in vec3 color) {\n\treturn (color.r + color.g + color.b) / 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uvs \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // threshold is defined by the mouse x\n    float threshold = 0.04; //+ 0.98 * iMouse.x/iResolution.x;\n    \n    // initialization\n    if (iFrame < 30) {\n     \tfragColor = texture(iChannel0, uv);\n        return;\n    }\n\n    \n    \n    vec4 vfield = texture(iChannel2, uv);\n    vec2 dr = vfield.xy / iResolution.xy; // pixel space to square space\n    vec2 p = uv + dr;\n    \n    // we make p loop on x\n    if (p.x < 0.0) p.x = 1. - p.x;\n    if (p.x > 1.0) p.x = fract(p.x);\n    \n    // sample the pixels to test\n    vec4 actv = texture(iChannel1, uv);\n    vec4 comp = texture(iChannel1, p);\n    \n    // if we are next to a border on the Y-axis, the prevent the sort from happening\n    if (uv.y+dr.y < 0.0 || uv.y+dr.y > 1.0) {\n    \tfragColor = actv;\n        return;\n    }\n    \n    // sample the vector field of the texel to compare, to get blue and alpha\n    vec4 vfieldComp = texture(iChannel2, uv + dr);\n    \n    // the alpha component encodes if whether or not a sort is possible\n    if (vfield.a < 0.5 || vfieldComp.a < 0.5) {\n\t\tfragColor = actv;\n        return;\n    }\n    \n    \n    // we can sort the texel with the other one\n    vec4 color = actv;\n    float gAct = gscale(actv.rgb);\n    float gCom = gscale(comp.rgb);\n    \n    // we separate the vector field dir into 2 \"categories\"\n    float classed = sign(dr.x*2. + dr.y);\n    \n    if (classed < 0.0) {\n        // given the blue component value, we sort one way or the other\n\t\tif (vfield.b > 0.5) {\n\t\t\tif (gCom > threshold && gAct > gCom) {\n\t\t\t\tcolor = comp;\n\t\t\t}\n\t\t} else {\n\t\t\tif (gAct > threshold && gAct < gCom) {\n\t\t\t\tcolor = comp;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (vfield.b > 0.5) {\n\t\t\tif (gAct > threshold && gAct < gCom) {\n\t\t\t\tcolor = comp;\n\t\t\t}\n\t\t} else {\n\t\t\tif (gCom > threshold && gAct > gCom) {\n\t\t\t\tcolor = comp;\n\t\t\t}\n\t\t}\n\t}\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}