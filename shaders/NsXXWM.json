{
    "Shader": {
        "info": {
            "date": "1618687525",
            "description": "my second task",
            "flags": 32,
            "hasliked": 0,
            "id": "NsXXWM",
            "likes": 0,
            "name": "315_Aiteyev_v0v1",
            "published": 3,
            "tags": [
                "mashgraph"
            ],
            "usePreview": 0,
            "username": "logiteg00",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) / float(iFrame + 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//MATH CONSTANTS\nconst float INF  = 1e10;\nconst int rayMachingTimes = 10;\n\n// CAMERA SETTINGS (5.0, 2.0, -2.7)\nconst float camera_x = 1.0;\nconst float camera_y =  2.4;\nconst float camera_z = -6.0;\n\nconst vec3  CAMERA_POS   = vec3 (camera_x, camera_y, camera_z);\n\n// SPHERE\nconst float SPHERE_R = 1.0;\n\n// TABLE\nconst float TABLE_RADIUS = 6.0;\nconst float tableTextureScale = 0.1;\n\n// FIRST LIGHT SOURCE\nconst vec3  LIGHT1_POS        = vec3 (-1.5, 0.7, 3.0);\nconst float LIGHT1_RADIUS     = 0.2;\nconst vec3  LIGHT1_COLOR      = vec3 (0.0, 1.0, 1.0);\nconst float LIGHT1_BRIGHTNESS = 10.0f;\n\n// SECOND LIGHT SOURCE\nconst vec3  LIGHT2_POS        = vec3 (1.5, 0.9, -1.0);\nconst float LIGHT2_RADIUS     = 0.2;\nconst vec3  LIGHT2_COLOR      = vec3 (1.0, 0.5, 0.5);\nconst float LIGHT2_BRIGHTNESS = 5.0f;\n\n// CUBEMAP\nconst float CUBEMAP_BRIGHTNESS = 0.35;\n\n// OCTAHEDRON\nconst float octahedronScale = 1.0;\nconst vec3 octahedronShift = vec3(2.0, -0.2, 0.0);\n\n// MATERALS\nconst int EMISSION = 0;// majorly it's material of the light source. it's spreading light from itself\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\n// REFRACTION\nconst float GLASS_N = 1.5;\nconst float OCTA_N = 1.50;\nconst float AIR_N = 1.0;\n\n// RANDOM\nvec3 randVals;\nvec3 randDir;\n\n\n\n\n\n// math functions\nfloat pow2(float x) \n{\n    return x * x;\n}\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\n// f(x,y,z) = 0  functions\n            //float r = 0.2;\n            //float k = 20.0;\nfloat f(vec3 v, float r, float k)\n{\n    return pow2(v.x) + pow2(v.y) + pow2(v.z)\n    - r*r - sin(k*v.x)*sin(k*v.y)*sin(k*v.z);\n}\nfloat dxf(vec3 v, float r, float k)\n{\n    return 2.0*v.x - k*cos(k*v.x)*sin(k*v.x)*sin(k*v.x);\n}\nfloat dyf(vec3 v, float r, float k)\n{\n    return 2.0*v.y - k*cos(k*v.y)*sin(k*v.y)*sin(k*v.y);\n}\nfloat dzf(vec3 v, float r, float k)\n{\n    return 2.0*v.z - k*cos(k*v.z)*sin(k*v.z)*sin(k*v.z);\n}\n\n// trace functions\nfloat traceSphere(vec3 pos, vec3 dir, float R, out vec3 normal) \n{\n    // abs(pos + t * dir) = r\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t = r * r\n    // D = 4 * dot(pos, dir) ^ 2 - 4 * (dot(pos, pos) - r * r)\n    float b = dot(pos, dir);\n    float D = b * b - (dot(pos, pos) - R * R);\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D));\n    if (t < 0.0)\n        t = (-b + sqrt(D));\n    if (t < 0.0)\n        return INF;\n    vec3 wPos = pos + t * dir;\n    normal = normalize(wPos);\n    return t;\n}\nfloat traceCylinder(vec3 pos, vec3 dir, inout vec3 normal) \n{\n    const float R = 1.0f;\n    const float H = 0.1f;\n    float floorT = (-1.0 - pos.y) / dir.y;\n    if (floorT < 0.0)\n        return INF;\n    vec3 finalPos = pos + dir * floorT;\n    if (dot(finalPos.xz, finalPos.xz) < R * R) {\n        normal = vec3(0, 1, 0);\n        return floorT;\n    }\n    \n    float b = dot(pos.xz, dir.xz);\n    float a = dot(dir.xz, dir.xz);\n    float D = b * b - (dot(pos.xz, pos.xz) - R * R) * a;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if (pos.y + t * dir.y < -1.0) {\n        vec3 wPos = pos + t * dir;\n        normal = normalize(vec3(wPos.x, 0, wPos.z));\n        return t;\n    }\n    \n    return INF;\n}\nfloat traceFunction(vec3 pos, vec3 dir, out vec3 normal, float r, float k)\n{\n    float dt = 0.1;\n    int times = 50;\n    \n    vec3 v = pos;\n    \n    for (int i = 0; i < times; i++)\n    {\n        \n        if( f(v,r,k) <= 0.0 ){\n            normal = vec3 (dxf(v,r,k), dyf(v,r,k), dzf(v,r,k));\n            return float(i)*dt;\n        }\n        else\n        {\n            v += (dt)*dir;\n            //t += dt;\n            \n        }\n    }\n    return INF;\n\n}\nfloat tracePolygon(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 normal)\n{\n    // Polygon interception with v = pos + t*dir\n    // \n    // Read more about method here: \n    // http://masters.donntu.org/2015/frt/yablokov/library/transl.htm\n    // result = (t, u, v) \n    \n    vec3 result;\n    \n    vec3 T  = pos - v0;\n    vec3 E1 = v1  - v0;\n    vec3 E2 = v2  - v0;\n    \n    vec3 P  = cross(dir, E2);\n    vec3 Q  = cross(T,   E1);\n    \n    \n    float det = dot(P, E1);\n    \n    float t = dot(Q, E2) / det;\n    float u = dot(P, T)  / det;\n    float v = dot(Q, dir) /det ;\n    \n    \n    float A = (v1.y-v0.y)*(v2.z-v0.z) - (v2.y-v0.y)*(v1.z-v0.z);\n    float B = (v1.z-v0.z)*(v2.x-v0.x) - (v2.z-v0.z)*(v1.x-v0.x);\n    float C = (v1.x-v0.x)*(v2.y-v0.y) - (v2.x-v0.x)*(v1.y-v0.y);\n    \n    normal.x = A;\n    normal.y = B;\n    normal.z = C;\n    \n    normal = normalize(normal);\n    \n    if( u >= 0.0 && v >= 0.0 && u + v <= 1.0 && t > 0.0)\n        return t;\n    \n    return INF;\n}\nfloat traceTriangle(vec3 pos, vec3 dir, vec3 scale, vec3 shift, out vec3 normal)\n{\n    // triagle equation \n    // v * scale == 1 + shift * scale\n    \n    // v = (x,y,z)\n    // scale = (1/a, 1/b, 1/c)\n    // shift = (dx,  dy,  dz)\n    \n    \n    // (x,y,z) * scale == 1 + shift * scale\n    // x/a + y/b + z/c == 1 + dx/a + dy/b + dz/c\n    \n    // because v = pos + t*dir\n    \n    // t*(dir, scale) + (pos, scale) = 1 + (shift, scale)\n    \n    \n    // t = ( 1 + (shift, scale) - (pos, scale)  ) / (dir,scale)\n    \n    \n    float a = 1.0 /scale.x; // length from dx to a + dx\n    float b = 1.0 /scale.y; // length from dy to b + dy\n    float c = 1.0 /scale.z; // length from dz to c + dz\n    \n    \n    //if(scale.x == 0.0 || scale.y == 0.0 || scale.z == 0.0)\n        //return INF;\n    \n    \n    \n\n    \n    \n    \n    \n    float dx = shift.x;\n    float dy = shift.y;\n    float dz = shift.z;\n    \n    \n    float x_min = min(dx, a + dx);\n    float x_max = max(dx, a + dx);\n    \n    float y_min = min(dy, b + dy);\n    float y_max = max(dy, b + dy);\n    \n    float z_min = min(dz, c + dz);\n    float z_max = max(dz, c + dz);\n    \n    \n    // Calculate distance and coord on triangle\n    float t = (1.0 + dot(shift,scale) - dot(pos, scale) ) / dot(dir, scale);\n    if (t <= 0.0)\n        return INF;\n    \n    vec3 coord = pos + t*dir;\n    \n    \n    // Calculate normal to   x/a + y/b + z/c = 1\n    normal = normalize(scale);\n    //normal = normalize(vec3 (0,0,0));\n    \n    // if trace intercept with triagle \n    // coord.x in [x_min, x_max] equal to x_min < coord.x && coord.x < x_max\n    // coord.y in [y_min, y_max] equal to y_min < coord.y && coord.y < y_max\n    // coord.z in [z_min, z_max] equal to z_min < coord.z && coord.z < z_max\n    if( x_min <= coord.x && coord.x <= x_max   &&   y_min <= coord.y && coord.y <= y_max   &&   z_min <= coord.z && coord.z <= z_max)\n        return t;\n    else \n        return INF;\n}\nfloat traceOctahedron(vec3 pos, vec3 dir, float size, vec3 shift, out vec3 normal)\n{\n    // see function traceTriagle to see more information about \"scale\" parametr\n    float scaleOcta = 1.0/ size;\n    \n    int minIndex = 0;// index of intercepted triagle (from 0 to 7)\n    \n    vec3 normal1;\n    vec3 normal2; \n    vec3 normal3; \n    vec3 normal4; \n    vec3 normal5; \n    vec3 normal6; \n    vec3 normal7; \n    vec3 normal8; \n    \n    \n    \n    ///*\n    vec3 v1 = vec3(shift.x - scaleOcta, shift.y             , shift.z);\n    vec3 v2 = vec3(shift.x            , shift.y - scaleOcta , shift.z);\n    vec3 v3 = vec3(shift.x+scaleOcta  , shift.y             , shift.z);\n    vec3 v4 = vec3(shift.x            , shift.y+scaleOcta   , shift.z);\n    vec3 v5 = vec3(shift.x            , shift.y             , shift.z+scaleOcta);\n    vec3 v6 = vec3(shift.x            , shift.y             , shift.z-scaleOcta);\n    \n    \n    float T1 = tracePolygon (pos, dir, v1, v2, v5, normal1);\n    float T2 = tracePolygon (pos, dir, v2, v3, v5, normal2);\n    float T3 = tracePolygon (pos, dir, v3, v4, v5, normal3);\n    float T4 = tracePolygon (pos, dir, v4, v1, v5, normal4);\n    float T5 = tracePolygon (pos, dir, v1, v2, v6, normal5);\n    float T6 = tracePolygon (pos, dir, v2, v3, v6, normal6);\n    float T7 = tracePolygon (pos, dir, v3, v4, v6, normal7);\n    float T8 = tracePolygon (pos, dir, v4, v1, v6, normal8);\n    //*/\n    /*\n    float T1 = traceTriangle (pos, dir, vec3(scaleOcta, scaleOcta, scaleOcta), shift , normal1);\n    float T2 = traceTriangle (pos, dir, vec3(-scaleOcta, scaleOcta, scaleOcta), shift , normal2);\n    float T3 = traceTriangle (pos, dir, vec3(scaleOcta, -scaleOcta, scaleOcta), shift , normal3);\n    float T4 = traceTriangle (pos, dir, vec3(-scaleOcta, -scaleOcta, scaleOcta), shift , normal4);\n    float T5 = traceTriangle (pos, dir, vec3(scaleOcta, scaleOcta, -scaleOcta), shift , normal5);\n    float T6 = traceTriangle (pos, dir, vec3(-scaleOcta, scaleOcta, -scaleOcta), shift , normal6);\n    float T7 = traceTriangle (pos, dir, vec3(scaleOcta, -scaleOcta, -scaleOcta), shift , normal7);\n    float T8 = traceTriangle (pos, dir, vec3(-scaleOcta, -scaleOcta, -scaleOcta), shift , normal8);\n    */\n    \n    \n    //find min of all this triagles and minIndex\n    vec3[]  arrayN = vec3[] ( normal1,normal2,normal3,normal4,normal5,normal6,normal7,normal8 );\n    float[] arrayD = float[](   T1,     T2,     T3,     T4,     T5,     T6,     T7,     T8    );\n \n \n    float minT = arrayD[0];\n    \n    for (int i = 1; i < 8; i++)\n \n        if (minT > arrayD[i])\n        {\n            minT = arrayD[i];\n            minIndex = i;\n        }\n    \n    \n    \n    \n    // Output values\n    normal = arrayN[minIndex];\n    return arrayD[minIndex];\n    \n    \n    \n    \n    // old version \n    //return min(min(min(min(min(min(min(T1,T2),T3),T4),T5),T6),T7),T8);\n}\nfloat tracePlane (vec3 pos, vec3 dir, out vec3 normal )\n{\n    // Create a table. \n    // Table is a plane y = -1 with restriction x^2 + z^2 < TABLE_RADIUS^2. \n    // Texture of table is iChannel0.\n    \n    \n    // (pos + t*dir).y == -1.0\n    float t = (-1.2 - pos.y)/dir.y;// distance between table (y = -1) and viewVec.\n    \n    \n    \n    // t(distance) must be positive only!\n    if (t <= 0.0)\n    {\n        return INF;\n    }\n    \n    \n    normal = vec3(0,1,0);\n    \n    // trace intercept with plane y = -1\n    if(t > 0.0){\n        vec3 worldPos = t*dir + pos;//restoring world position of table coordinates\n        \n        \n        // if x^2 + z^2 >= TABLE_RADIUS^2 (not intercept with table). \n        if(dot(worldPos.xz, worldPos.xz) >= TABLE_RADIUS*TABLE_RADIUS)\n            return INF;\n           \n           \n        // trace intercepted with table.\n        return t;\n            \n    }\n    \n    \n    \n}\n\n\n\n// shadow\nbool isOccluded(vec3 pos, vec3 target) \n{\n    vec3 rvec = target - pos;\n    float dist = length(rvec);\n    vec3 dir = rvec / dist;\n    \n    vec3 normal = vec3(0, 0, 0);\n    \n    \n    vec3 functionNormal;\n    vec3 functionShift = vec3( -1.25,1.5,-1.2 );\n    float functionT = traceFunction(pos-functionShift, dir, functionNormal, 0.7, 50.0);\n    \n    if(functionT < dist)\n        return true;\n    \n    \n    vec3 octahedronNormal;\n    float octahedronT = traceOctahedron(pos, dir, octahedronScale, octahedronShift, octahedronNormal);\n    \n    if(octahedronT < dist)\n        return true;\n    \n    \n    \n    \n    float t = traceSphere(pos, dir, SPHERE_R, normal);\n    if (dist >= t) {\n        return true;\n    }\n    \n    \n    \n    \n    vec3 cylNormal = normal;\n    t = traceCylinder(pos, dir, cylNormal);\n    return (t > 0.0 && dist >= t);\n}\n// refraction\nvec3 refraction(vec3 v_in, vec3 normal, float n1, float n2) \n{\n    if (dot(v_in, normal) < 0.0)\n        normal = -normal;\n    float cosA = dot(v_in, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v_in - cosA * normal);\n    float sinB = n1 * sinA / n2;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return tang * sinB + normal * cosB;\n}\n// light\nvec3 computeLighting(vec3 worldPos, vec3 color, vec3 normal, vec3 viewVec) {\n    vec3 lightPos = LIGHT1_POS + randDir * LIGHT1_RADIUS;\n    vec3 toLight = lightPos - worldPos;\n    bool occl = isOccluded(worldPos + normalize(toLight) * 1e-3, lightPos);\n    float lightAtten = 20.0f / dot(toLight, toLight) * (occl ? 0.0 : 1.0);\n\n    vec3 light2Pos = LIGHT2_POS + randDir * LIGHT2_RADIUS;\n    vec3 toLight2 = light2Pos - worldPos;\n    bool occl2 = isOccluded(worldPos + normalize(toLight2) * 1e-3, light2Pos);\n    float light2Atten = 10.0f / dot(toLight2, toLight2) * (occl2 ? 0.0 : 1.0);\n\n    return color * (\n        max(0.0f, dot(normal, normalize(toLight))) * lightAtten * LIGHT1_COLOR\n        + max(0.0f, dot(normal, normalize(toLight2))) * light2Atten * LIGHT2_COLOR\n        + texture(iChannel0, viewVec, 10.0).rgb * CUBEMAP_BRIGHTNESS\n    ).rgb;\n}\n\n\n\n// rainbow fog\nfloat difcolor(float h,float h0, float h1, float x0, float x1)\n{\n    return (x1-x0)/(h1-h0)*h + (x0*h1 - h0 * x1)/(h1-h0);\n    //return (h1-h0)/(x1-x0)*(h-x0)  +  h0;\n}\nfloat fogSdf(vec3 pos)\n{\n    return length(pos) - 0.75;\n}\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\nvec4 sampleFog(vec3 pos, vec3 dir)\n{\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float absorption = 10.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * (\n            texture(iChannel3, curPos * 0.2).x\n            + texture(iChannel3, curPos * 0.4).x\n            + texture(iChannel3, curPos * 0.8).x\n            + texture(iChannel3, curPos * 1.6).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    \n    vec3 color;\n    vec3 v = pos + t*dir;\n    float h = v.y;\n    \n    \n    float h0;\n    float h1;\n    float x0;\n    float x1;\n    \n    \n    float level1 =  0.9;\n    float level2 =  0.4;\n    float level3 =  0.2;\n    float level4 = -0.2;\n    float level5 = -0.4;\n    float level6 = -0.9;\n    \n    float outputColor;\n    \n    \n    \n    \n    if( level2 < h && h <= level1 )\n    {\n        h0 = level1;\n        h1 = level2;\n        \n        x0 = 0.0;\n        x1 = 1.0;\n        \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n        \n        color = vec3( 1.0, outputColor, 0.0) * totalAbs;\n    }\n    if( level3 < h && h <= level2 )\n    {\n        h0 = level2;\n        h1 = level3;\n        \n        x0 = 1.0;\n        x1 = 0.0;\n        \n        \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n        \n        \n        color = vec3( outputColor, 1.0, 0.0 ) * totalAbs;\n    }\n    if( level4 < h && h <= level3 )\n    {\n        h0 = level3;\n        h1 = level4;\n        \n        x0 = 0.0;\n        x1 = 1.0;\n    \n    \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n    \n    \n        color = vec3( 0.0, 1.0, outputColor ) * totalAbs;\n    }\n    if( level5 < h && h <= level4 )\n    {\n        h0 = level4;\n        h1 = level5;\n        \n        x0 = 1.0;\n        x1 = 0.0;\n    \n    \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n    \n    \n        color = vec3( 0.0, outputColor, 1.0 ) * totalAbs;\n    }\n    if( level6 <= h && h <= level5 )\n    {\n        h0 = level5;\n        h1 = level6;\n        \n        x0 = 0.0;\n        x1 = 1.0;\n    \n    \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n    \n    \n        color = vec3( outputColor, 0.0, 1.0 ) * totalAbs;\n    }\n    \n    \n    \n    \n    \n    return vec4(color * 5.0, 1.0 - opacity);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // random numbers\n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals);\n    \n    \n    // Anti-aliasing for better image. AA from -1 to 1\n    vec2 AA = (randVals.xy - 0.5 ) * 2.0;\n\n\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - iResolution.xy/2.0 + AA)/iResolution.x;\n\n\n    // Vectors forward up and right helps to create viewVec\n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n\n    // viewVec \n    vec3 viewVec = normalize(forward + uv.x * right + uv.y * up);\n\n\n    // refraction\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float curN = 1.0;\n    float nextN = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float GLASS_T = 1.0 - GLASS_R;\n\n\n    // Current camera position\n    vec3 currentPos = CAMERA_POS;\n    \n\n    // properties\n    int iterationType;\n    vec3 color;\n    vec3 normal;\n    float mult = 1.0;\n\n\n\n\n\n\n    // do Ray-Marching few times\n    for (int i = 0; i < rayMachingTimes; ++i) {\n        \n        \n        // if planeT will equal to distance to table then t = planeT, otherwise t = infinity.\n        float t = INF;\n    \n    \n        // Light 1\n        {\n            t = traceSphere(currentPos - LIGHT1_POS, viewVec, LIGHT1_RADIUS, normal);\n            if (t != INF) {\n                color = LIGHT1_COLOR.rgb * 5.0;\n                iterationType = EMISSION;\n            }\n        }\n        \n        \n        // Light 2\n        {\n            float l2_t = traceSphere(currentPos - LIGHT2_POS, viewVec, LIGHT2_RADIUS, normal);\n            if (t > l2_t) {\n                t = l2_t;\n                color = LIGHT2_COLOR.rgb;\n                iterationType = EMISSION;\n            }\n        }\n        \n        \n        // Sphere with fog\n        {\n            float sphere_t = traceSphere(currentPos, viewVec, SPHERE_R, normal);\n            if (sphere_t < t) {\n                if (GLASS_R > randVals.y) {\n                    iterationType = REFLECTION;\n                } else {\n                    iterationType = REFRACTION;\n                }\n                t = sphere_t;\n            }\n        }\n        \n        \n        // Cylinder\n        {\n            vec3 cylNormal = normal;\n            float cylT = traceCylinder(currentPos, viewVec, cylNormal);\n            if (cylT < t) {\n                t = cylT;\n                vec3 pos = currentPos + t * viewVec;\n                color = texture(iChannel1, pos.xz * pos.y).rgb;\n                normal = cylNormal;\n                iterationType = DIFFUSE;\n            }\n        }\n        \n        \n        // Table\n        {\n            vec3 tableNormal;\n\n            float planeT = tracePlane(currentPos, viewVec, tableNormal);\n            // If trace is intercept with plane then make t shorter and equal to distance between camera and table.\n            if (planeT < t)\n            {\n                t = planeT;\n                vec3 worldPos = t*viewVec + currentPos;//restoring world position of table coordinates\n                color = texture (iChannel2, worldPos.xz * tableTextureScale).rgb;\n                normal = tableNormal;\n                iterationType = DIFFUSE;\n\n                // for make floor reflaction\n                if(randVals.y < 0.3)\n                    iterationType = REFLECTION;\n\n            }\n        }\n        \n        \n        // Octahedron\n        {\n            vec3 octahedronNormal;\n\n            float octahedronT  = traceOctahedron(currentPos, viewVec, octahedronScale, octahedronShift, octahedronNormal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (octahedronT < t)\n            {\n                t = octahedronT;\n                color = vec3(0.0,0.0,1.0);\n                normal = octahedronNormal;\n\n                //combine reflection and refraction;\n                if(randVals.x*0.01 < GLASS_R)\n                    iterationType = REFLECTION;\n\n                else{\n                    iterationType = REFRACTION;\n                    // We need to know what is outside the object \n                    if( dot(viewVec, normal) > 0.0 )// they not oppodite directed\n                    {\n                        nextN = AIR_N;\n                    }\n                    else // they opposite directed \n                    {\n                        nextN = GLASS_N;\n\n                    }\n\n                }\n                //materialType = REFRACTION;\n\n            }\n        }\n\n\n        // Triangle (mirror)\n        {\n            vec3 triangleNormal;\n            vec3 triangleScale = vec3(0.3, 0.1, 0.5);;\n            vec3 triangleShift = vec3(-0.0, -0.5, 1.0);\n\n            float triangleT  = traceTriangle(currentPos, viewVec, triangleScale, triangleShift, triangleNormal);\n            // If trace is intercept with Triagle then make t shorter and equal to distance between camera and table.\n            if (triangleT < t)\n            {\n                t = triangleT;\n                iterationType = REFLECTION;\n\n                normal = triangleNormal;\n            }\n        }\n        \n        //Function 1\n        {\n            vec3 functionNormal;\n            \n            vec3 functionShift = vec3( -1.35,1.5,-1.2 );\n            float functionT = traceFunction(currentPos-functionShift, viewVec, functionNormal, 0.7, 50.0);\n            // If trace is intercept with function then make t shorter and equal to distance between camera and table.\n            if (functionT < t)\n            {\n                t = functionT;\n                //vec3 worldPos = t*viewVec + currentPos;//restoring world position of table coordinates\n\n                iterationType = DIFFUSE;\n                color = vec3(0.2,0.1,0.5);\n                normal = functionNormal;\n            }\n            \n        }\n        \n        \n        \n        // DRAW OBJECT\n        if (t != INF) \n        {\n        \n        \n            // EMISSION\n            if (iterationType == EMISSION) {\n                fragColor.rgb = color;\n                break;\n            } \n            \n            \n            // DIFFUSE\n            else if (iterationType == DIFFUSE) {\n                fragColor.rgb += mult * computeLighting(currentPos + t * viewVec, color, normal, viewVec);\n                break;\n            } \n            \n            \n            // REFLECTION\n            else if (iterationType == REFLECTION) {\n                currentPos += viewVec * t;\n                fragColor.rgb += mult * computeLighting(currentPos + t * viewVec, color, normal, viewVec);\n                viewVec = reflect(viewVec, normal);\n                currentPos += viewVec * 1e-5;\n            } \n            \n            \n            // REFRACTION\n            else if (iterationType == REFRACTION) {\n            \n                // do refraction\n                currentPos += viewVec * t;\n                viewVec = refraction(viewVec, normal, curN, nextN);\n                currentPos += viewVec * 1e-5;\n                \n                // fog\n                vec4 fog = sampleFog(currentPos, viewVec);\n                fragColor.rgb += fog.rgb * fog.a * mult;\n                mult *= 1.0 - fog.a;\n                \n                //change N\n                float tmp = curN;\n                curN = nextN;\n                nextN = tmp;\n                \n            }\n            \n            \n        } \n        // DRAW BACKGROUND\n        else \n        {\n            fragColor += mult * texture(iChannel0, viewVec) * 0.3;\n            break;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) + texture(iChannel1, screenUV);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}