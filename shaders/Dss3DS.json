{
    "Shader": {
        "info": {
            "date": "1666740244",
            "description": "I had to hit my head against the wall 500 times to make this, it's still quite messy.\nIt's based on the MazeBackTracker rule displayed here: https://github.com/mxgmn/MarkovJunior\n\npress r to reset",
            "flags": 48,
            "hasliked": 0,
            "id": "Dss3DS",
            "likes": 18,
            "name": "BackTracker",
            "published": 3,
            "tags": [
                "automata",
                "maze",
                "pathfinding",
                "pixelart",
                "ca"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 321
        },
        "renderpass": [
            {
                "code": "vec4 cell(ivec2 f) {\n    return texelFetch(iChannel0, f, 0);\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = 0.125;\n    col = cell(ivec2(sc * f + (1.-sc) * 0.5 * iResolution.xy));\n    col += col.a;\n    /*\n    col.rb *= 0.5 + 0.5 * thc(4., length(col) * 2. * pi + iTime);   \n    col += 0.05 + 0.1 * uv.y;\n    col.rgb = pal(0.25 * (col.r + 2. * col.g + 3. * col.b), \n                  0.25 * vec3(0,1,2)/3.);    \n    col = 1. - col;\n    col = pow(col, vec4(0.8)); \n    //*/\n    \n    //col += vec4(col.g);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n#define red vec4(1,0,0,0)\n#define green vec4(0,1,0,0)\n#define blue vec4(0,0,1,0)\n#define spec vec4(1,0,1,0)\n#define spec2 vec4(0,0,1,1)\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\n// rand value 0,1,2,3 (change me! looks really cool)\nivec2 rand(float t) {\n    float h = floor(4. * h21(vec2(0.01 * t, 50.)));\n    //float h = mod(floor(0.25 * t), 4.); //2.5*t, 3.9*t\n    //float h = floor(2. + 2. * cos(0.25 * t));\n    //float h = min(3., mod(t,8.));\n    if (h == 0.) return ivec2(0,1);\n    if (h == 1.) return ivec2(1,0);\n    if (h == 2.) return ivec2(0,-1);\n    if (h == 3.) return ivec2(-1,0);\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    ivec2 px = ivec2(f);\n    int frame = iFrame;// % 1800;\n\n    if (frame == 0 || key_down(KEY_RESET)) {     \n        vec2 r = floor(0.5 * vec2(textureSize(iChannel0, 0)));\n        \n        // starting point\n        vec2 q = abs(f-r+0.5);\n        col.r += step(max(q.x, q.y), 0.);\n          \n        // border\n        q = abs(f-r-0.5);\n        col.b += step(abs(max(q.x, q.y) - 21.), 0.);       \n        return;\n    }\n           \n    // Center cell\n    col = cell(px);\n     \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bb = cell(px - ivec2(0,2));\n    vec4 tt = cell(px + ivec2(0,2));\n    vec4 ll = cell(px - ivec2(2,0));\n    vec4 rr = cell(px + ivec2(2,0));  \n    \n    vec4 sum = l + b + t + r;\n    vec4 sum2 = ll + bb + tt + rr;\n    //float blueSum = (l + b + t + r).b;\n    //float blueSum2 = (ll + bb + tt + rr).b;\n \n    float time = float(iFrame);\n    ivec2 rnd = rand(time);\n\n    vec4 rc   = cell(px + 2 * rnd); // rand cell\n    vec4 orc  = cell(px - 2 * rnd); // rand cell opposite\n    vec4 hrc  = cell(px + rnd);     // half rand cell\n    vec4 ohrc = cell(px - rnd);     // half rand cell opposite\n\n    // red + gap found -> blue\n    if (col == red && orc == vec4(0)) \n        col = blue;\n    \n    if (col == vec4(0) && rc == spec2) \n        col = red; // black->new red\n    else if (col == spec2 && orc == vec4(0))  \n        col = blue; // \n    else if (col == vec4(0) && hrc == spec2 && ohrc == vec4(0))\n        col = green;\n    \n    if (col == vec4(0)) {\n        if (rc == red) {\n            if (sum2.b == 3.) // reach dead-end (3 blues + 1 red)\n                col = spec;\n            else // keep growing\n                col = red;\n        }\n        if (hrc == red && sum.b == 0.) // between red and blue\n            col = green;\n    } \n    else if (col == blue) {\n        if ((tt == spec && t == green) || // connected to a spec col \n            (bb == spec && b == green) ||\n            (rr == spec && r == green) ||\n            (ll == spec && l == green) ) {    \n            if (sum2.b == 4.)     // trapped\n                col = spec;\n            else if (sum.g >= 2.) // not trapped\n                col = spec2;    \n        }    \n    } \n    else if (col == spec) \n        col = spec2;\n    else if (col == red && sum.b == 0. && sum2.b == 4.)\n        col = spec;\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}