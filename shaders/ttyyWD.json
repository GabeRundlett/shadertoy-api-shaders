{
    "Shader": {
        "info": {
            "date": "1611013030",
            "description": "Changed my previous shader https://www.shadertoy.com/view/3djGDt, by adding different lighting, colouring, and patterns.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttyyWD",
            "likes": 6,
            "name": "IFS Revisited",
            "published": 3,
            "tags": [
                "ifs"
            ],
            "usePreview": 0,
            "username": "darkeclipz",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define MaxSteps 60.\n#define MinDistance 0.001\n#define eps 0.001\n#define Iterations 16.\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nvec2 DE(vec3 z)\n{\n    float trap = 10000.;\n    float angl = cos(iTime/20.)*2.*3.14159;\n    mat3 rz = rotateZ(angl);\n    mat3 rot = rz;\n \n    float Scale = 2. + cos(iTime/8.)*.5;\n    float Offset = .65;\n    float n = 0.;\n    while (n < Iterations) {\n       z *= rot;\n       if(z.x - z.y < 0.) z.yx = z.xy;\n       if(z.x + z.y < 0.) z.yx = -z.xy;\n       if(z.x - z.z < 0.) z.xz = z.zx;\n       z *= rot;\n       z = abs(z);\n       z = z*Scale - vec3(vec3(Offset*(Scale-1.0)).xy, 0);\n       trap = min(length(z), trap);\n       n++;\n    }\n    return vec2((length(z) ) * pow(Scale, -float(n)), trap);\n}\n\nvec2 scene(vec3 p) {\n    float t = iTime/4.;\n    p *= rotateY(t);\n    float size = 1.3;\n\treturn DE(size*p - vec3(0,.1,0))/size;\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p - vec3(0,.1,0)).x;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 h = vec2(0.0001,0);\n    return normalize(vec3(scene(p+h.xyy).x - scene(p-h.xyy).x, \n                          scene(p+h.yxy).x - scene(p-h.yxy).x, \n                          scene(p+h.yyx).x - scene(p-h.yyx).x));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        \n        if(hit.x < MinDistance) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n        t += hit.x;\n        if(t > 20.) {\n            break;\n        }\n        \n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\nfloat angle(vec3 a, vec3 b) {\n    return acos(dot(a,b) / (length(a)*length(b)));\n}\n\nvec3 brdf_gauss(vec3 N, vec3 L, vec3 V, vec3 diff, vec3 spec) {\n    vec3 H = normalize(L+V);\n    //specular\n    float m = 0.7;\n    float NHm = angle(N,H) / m;\n    float NHm2 = NHm*NHm;\n    float k_gauss = exp(-NHm2);\n    //diffuse\n    float wrap = 0.5;\n    float diffuse = max(0., dot(L, N));\n    float wrap_diffuse = max(0., (dot(L, N) + wrap) / (1. + wrap));\n    \n    return diff * diffuse + spec * k_gauss;\n}\n\nvec3 magma(float t) { // from Mattz\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n    t *= 2.; if(t >= 1.) { t = 2. - t; }\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 light(vec3 P, vec3 N, vec3 rd, float trap) {\n   \n    vec3 ambient = vec3(.1);\n    vec3 diff = magma(trap);\n    vec3 spec = vec3(.9,.9,.7) * .5;\n    return brdf_gauss(N, normalize(vec3(3,5,-3) - P), -rd, diff, spec)\n         + brdf_gauss(N, normalize(vec3(-5,-5,3) - P), -rd, diff, spec)*.6;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,0.18,-1); \n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro);\n    \n    vec3 hit = march(ro, rd);\n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = light(p, n, rd, hit.z);\n        col *= hit.y;\n    }\n    else { \n        vec3 bg = texture(iChannel0, rd).rgb;\n        col = mix(bg*.8, bg*.5, smoothstep(.2, .6, fragCoord.y/R.y));\n        \n    }\n    fragColor = vec4(pow(col, vec3(2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}