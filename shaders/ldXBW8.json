{
    "Shader": {
        "info": {
            "date": "1525773926",
            "description": "yea",
            "flags": 0,
            "hasliked": 0,
            "id": "ldXBW8",
            "likes": 2,
            "name": "duck test ",
            "published": 3,
            "tags": [
                "duck"
            ],
            "usePreview": 0,
            "username": "halcy",
            "viewed": 615
        },
        "renderpass": [
            {
                "code": "// Various knobs to twiddle\n#define MIN_DIST 0.01\n#define STEP_MULTIPLIER 0.9\n#define NORMAL_OFFSET 0.01\n#define MAX_STEPS 64\n#define MAX_STEPS_SHADOW 32\n#define SHADOW_OFFSET 0.02\n#define SHADOW_HARDNESS 32.0\n\nfloat rand(vec2 co){\n    return(fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453));\n}\n\n// Trefoil knot positions\nvec3 trefoil(float t) {\n\treturn vec3(\n        sin(t) + 2.0 * sin(2.0 * t),\n        cos(t) - 2.0 * cos(2.0 * t),\n        -sin(3.0 * t)\n    );\n}\n\n// Distance / color combiner\nvec4 distcompose(vec4 dista, vec4 distb, float softness) {\n    float mixfact = clamp(0.5 + 0.5 * (distb.a - dista.a) / softness, 0.0, 1.0);\n    return mix(distb, dista, mixfact) - vec4(0.0, 0.0, 0.0, softness * mixfact * (1.0 - mixfact));\n}\n\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec4 compose_ellipse(in vec4 dist, in vec3 pos, in vec3 offset, in vec3 scale, in vec3 color, in float size) {\n\tfloat object_dist = sdEllipsoid( pos - (size*offset), size*scale );\n\treturn distcompose(dist, vec4(color, object_dist), 0.02);\n}\n\nvec4 distfunc(vec3 pos) {\n    vec4 dist = vec4(0.0);\n    dist.xyz = vec3(0.3 * pos.y, 0.3, 0.9) * (fract(pos).x > 0.5 ? 1.0 : 0.5);\n    dist.a = min(min(pos.y, -abs(pos.z) + 2.0), -abs(pos.x) + 2.0);\n        \n    float t = iTime;\n    \n\n    pos.y -= 1.0;\n    \n    vec3 eye_col =   vec3(10000.0, 0.0, 0.0);\n    vec3 mouth_col = vec3(1.0, 0.07, 0.05);\n\tvec3 body_col =  vec3(3.0, 1.5, -0.2);\n\n\tfloat duck_size = 0.5;\n    \n    vec3 pos_orig = pos;\n    for(int i = 0; i < 6; i++) {\n        float t1 = t * 3.0 + float(i);\n        float t2 = t * 2.0 + float(i * 2);\n        vec2 sc = vec2(sin(t1), cos(t1));\n    \tvec2 sc2 = vec2(sin(t2), cos(t2));\n    \tmat3 boxRot = mat3(sc.t, 0.0, sc.s,   0.0,  1.0, 0.0, -sc.s, 0.0, sc.t);\n    \tmat3 boxRot2 = mat3(sc2.t, sc2.s, 0.0,  -sc2.s, sc2.t, 0.0, 0.0, 0.0, 1.0);\n        \n    \tvec4 duck_dist = vec4(0.0, 0.0, 0.0, 10000.0);\n        pos = pos_orig;\n       \tvec3 cut_pos = pos;\n        \n        pos -= trefoil(float(i) + t) * 0.25;\n        pos *= boxRot * boxRot2;\n    \tcut_pos *= boxRot2 * boxRot;\n        \n        duck_dist = compose_ellipse(duck_dist, pos, vec3( 0.0,-0.1, 0.0),  vec3(0.8, 0.4, 0.6),  body_col,  duck_size ); // body\n        duck_dist = compose_ellipse(duck_dist, pos, vec3(-0.5, 0.4, 0.0),  vec3(0.3),              body_col,  duck_size ); // head\n        duck_dist = compose_ellipse(duck_dist, pos, vec3(-0.8, 0.4, 0.0),  vec3(0.1, 0.02, 0.1),  mouth_col, duck_size ); // mouth\n        duck_dist = compose_ellipse(duck_dist, pos, vec3(-0.8, 0.5, 0.1),  vec3(0.005),             eye_col,   duck_size ); // eye\n        duck_dist = compose_ellipse(duck_dist, pos, vec3(-0.8, 0.5,-0.1),  vec3(0.005),             eye_col,   duck_size ); // eye\n        duck_dist = compose_ellipse(duck_dist, pos, vec3( 0.1, 0.0, 0.52), vec3(0.4, 0.25, 0.25), body_col,  duck_size ); // wing\n        duck_dist = compose_ellipse(duck_dist, pos, vec3( 0.1, 0.0,-0.52), vec3(0.4, 0.25, 0.25), body_col,  duck_size ); // wing\n        duck_dist = compose_ellipse(duck_dist, pos, vec3( 0.7, 0.1, 0.0),  vec3(0.15,0.15, 0.2),  body_col,  duck_size ); // tail\n        duck_dist.a = max(duck_dist.a, cut_pos.z);\n\n        dist = distcompose(dist, duck_dist, 0.0);\n    }\n    \n\treturn dist;\n}\n\nmat4 lookatmat(vec3 eye, vec3 center, vec3 up) {\n\tvec3 backward=normalize(eye - center);\n\tvec3 right=normalize(cross(up,backward));\n\tvec3 actualup=normalize(cross(backward,right));\n\n\treturn mat4(\n        vec4(right, -dot(right, eye)), \n        vec4(actualup, -dot(actualup, eye)), \n        vec4(backward, -dot(backward, eye)),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nvec3 lookat = vec3(0.0, 1.0, 0.0);\nvec3 campos(float t) {\n    float wobble = t * -0.1;\n    return(vec3(sin(wobble) * -1.3, 2.0, cos(wobble) * -1.3));\n}\n\n// Renderer\nvec4 pixel(vec2 fragCoord, out float depth) {\n    float t = iTime;\n\n    // Screen -1 -> 1 coordinates\n    vec2 coords = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n\n    // Camera as eye + imaginary screen at a distance\n    vec3 eye = campos(t);\n    vec3 lightpos = eye;\n    lightpos.y += 2.0;\n    \n    float sinpow = sin(t * 5.0);\n    sinpow = sinpow * sinpow;\n    \n    eye = (vec4(0.0, 0.0, 0.0, 1.0) * inverse(lookatmat(eye, lookat, vec3(0.0, 1.0, 0.0)))).xyz;\n    vec3 lookdir = normalize((vec4(0.0, 0.0, -1.0, 0.0) * inverse(lookatmat(eye, lookat, vec3(0.0, 1.0, 0.0)))).xyz);\n\n    vec3 left = normalize(cross(lookdir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    vec3 ray = normalize(pixelpos - eye);\n    ray = normalize(ray + hash33(ray * 0.01) * pow(length(coords), 3.0) * 0.15);\n    \n    // March\n    vec3 pos = eye;\n    float dist = 0.0;\n    float curdist = 1.0;\n    float iters = float(MAX_STEPS);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        curdist = distfunc(pos).a;\n        dist += curdist * STEP_MULTIPLIER;\n        pos = eye + ray * dist;\n        if(curdist < MIN_DIST) {\n        \titers = float(i);\n            break;\n        }\n    }\n    \n\t// Finite-difference normals\n   \tvec2 d = vec2(NORMAL_OFFSET, 0.0);\n    vec3 normal = normalize(vec3(\n        distfunc(pos + d.xyy).a - distfunc(pos - d.xyy).a,\n        distfunc(pos + d.yxy).a - distfunc(pos - d.yxy).a,\n        distfunc(pos + d.yyx).a - distfunc(pos - d.yyx).a\n    ));\n    \n    // Offset from surface\n    vec3 shadowstart = eye + ray * dist + normal * SHADOW_OFFSET;\n    vec3 shadowpos = shadowstart;\n    \n    // Shadow ray\n    vec3 shadowray = normalize(lightpos - pos);\n    float shadowdist = length(lightpos - pos);\n    float penumbra = 1.0;\n    dist = 0.0;\n    for(int i = 0; i < MAX_STEPS_SHADOW; i++) {\n        curdist = distfunc(shadowpos).a;\n\t\tdist += curdist * STEP_MULTIPLIER;        \n        shadowpos = shadowstart + shadowray * dist;\n        \n        if(curdist < MIN_DIST) {\n            penumbra = 0.0;\n            break;\n        }\n        \n        penumbra = min(penumbra, SHADOW_HARDNESS * curdist / dist);\n        if(dist >= shadowdist) {;\n        \tbreak;   \n        }\n        \n        if(i == MAX_STEPS_SHADOW - 1) {\n        \tpenumbra = 0.0;   \n        }\n        \n    }\n\n    // Shading\n    float light = max(0.0, dot(normal, shadowray)) * penumbra + 0.1;\n    vec3 colorval = light * distfunc(pos).rgb;\n   \n    // Calculate CoC (limited to a maximum size) and store\n    depth = length(pos - eye);\n    vec4 fragColor = vec4(colorval.xyz, 0.0);\n    float coc = 0.4 * abs(1.0 - length(eye - lookat) / depth);\n    coc = max(0.01 * 5.0, min(0.35 * 5.0, coc));\n    return(vec4(fragColor.rgb, coc));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float depth = 0.0;\n\tfragColor = pixel(fragCoord, depth);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}