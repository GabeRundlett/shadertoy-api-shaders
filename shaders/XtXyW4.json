{
    "Shader": {
        "info": {
            "date": "1505220668",
            "description": "Test of a first person camera and SDF-based physics. Rough and definitely unoptimized. \n\n * Mouse: Look Around\n * WASD/Arrows: Movement\n * Space: Jump\n * Shift: Speed Boost\n\nSee 'Image' for more information.",
            "flags": 48,
            "hasliked": 0,
            "id": "XtXyW4",
            "likes": 33,
            "name": "Courtyard (Camera / Physics)",
            "published": 3,
            "tags": [
                "sdf",
                "camera",
                "keyboard",
                "first",
                "physics",
                "firstperson",
                "ssao",
                "person"
            ],
            "usePreview": 1,
            "username": "ssell",
            "viewed": 1899
        },
        "renderpass": [
            {
                "code": "/**\n * -----------------------------------------------------------\n * - Courtyard (Camera / Physics)\n * - Created by Steven Sell (ssell) / 2017\n * - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * - https://www.shadertoy.com/view/XtXyW4\n * -----------------------------------------------------------\n *\n * Test of a basic first-person camera with SDF-based physics.\n * This is a test, and as such is rough and unoptimized.\n * My goal was never to create a camera or physics, it just kind of happened.\n *\n * -----------------------------------------------------------\n * -- Camera / Movement\n * -----------------------------------------------------------\n *\n *     * Mouse 'capture' (moves relative to last click, does not reset on click)\n *     * WASD/Arrows for movement\n *     * SPACE to jump\n *     * SHIFT for speed boost\n *     * Y-Axis Inversion available\n *     * Three modes (see Buf A #defines):\n *         * Physics-Enabled\n *         * No physics, y-limited to start position.\n *         * No physics, free-fly\n *\n * -----------------------------------------------------------\n * -- Physics\n * -----------------------------------------------------------\n *\n *     * SDF-based (probably not a good idea...)\n *     * Non-sticky walls (momentum continues, no climbing)\n *     * Constrained jumps (no mid-air jumps, checks for 'head' collision)\n *     * Slope climbing (doesn't get stuck on tiny ridges, can climb stairs)\n *\n * -----------------------------------------------------------\n * -- Buffers\n * -----------------------------------------------------------\n *\n *     * Buf A: Camera Controls. Stores the following:\n *         * Current Position\n *         * Current Forward Vector\n *         * Last Mouse Click Info (.xy = click position [0, 1], .z = is clicking [0 = false])\n *         * Last Mouse Position (deltas) (.xy = frame relative, .zw = total since last click)\n *         * Last Rotation (quaternion)\n *     * Buf B: Phyiscs.\n *         * Current Physics Position\n *         * Current Velocity\n *     * Buf C: Scene Marching / G-Buffer\n *         * .r = Depth (raw, not normalized) [Near Clip, Far Clip]\n *         * .g = Material ID \n *         * .b = Shadow Value [0, 1]\n *         * .a = Packed Normal\n *     * Buf D: Debug Overlay\n *         * Mouse click/drag information\n *         * Camera rotation axis\n *         * See '#define DRAW_DEBUG_OVERLAY' in 'Image' buffer\n *     * Image:\n *         * Scene Shading (lighting, texturing, SSAO).\n *\n * -----------------------------------------------------------\n * -- References\n * -----------------------------------------------------------\n * \n * Not very many external references this time. \n * Most is either made from scratch or has been carried over between my various other shaders.\n *\n * -- SSAO Implementation\n *\n *     'SSAO Demo' - ssell\n *     https://www.shadertoy.com/view/Xd2BDt\n *\n *     I might make another version of this scene/shader using true \n *     global ambient occlusion as it would really benefit from it...\n *\n * -- Checker Tile Texture\n * \n *     'Filtered Checkerboard' - iq\n *     https://www.shadertoy.com/view/XlcSz2\n *\n *     This checker tile is nicely filtered so it does not alias too much at a distance. \n *     Which is a must since there is no general AA in this shader.\n *\n * -----------------------------------------------------------\n * -- Known Issues\n * -----------------------------------------------------------\n *\n * See Buf B for physics-specific issues.\n *\n * In general:\n *\n *     - Full Screen Performance\n *     - So much code duplication between the buffers (can be alleviated with the new Common buffer)\n *     - Debug overlay circles not drawn with proper aspect ratio\n *     - SSAO banding if you stick your face in a wall\n *     - Shadow irregularities\n */\n\n#define DRAW_DEBUG_OVERLAY\n\n// General Values\n#define FarClip         300.0\n#define PI              3.14159265\n\n// SSAO Settings (a bit strong, but there is only one texture in the scene...)\n#define AOSampleRadius  1.0\n#define AOSampleCount   16\n#define AODistScale     25.0\n#define AOIntensity     3.0\n#define AOBias          0.1\n\n// Sky and Lighting Values\nconst vec3 HorizonColor = vec3(0.29804, 0.61569, 0.92157);\nconst vec3 SkyColor     = vec3(0.10980, 0.41764, 0.79215);\nconst vec3 SunLightDir  = normalize(vec3(1.0, 2.0, -2.0));\nconst vec3 SunLightCol  = vec3(1.0);\nconst vec3 AmbLightDir  = normalize(SunLightDir * vec3(-1.0, 0.0, -1.0));\nconst vec3 AmbLightCol  = vec3(1.0, 1.0, 0.975);\nconst vec3 SkyLightDir  = normalize(vec3(0.0, 1.0, 0.0));\nconst vec3 SkyLightCol  = vec3(0.975, 0.975, 1.0);\n\n//------------------------------------------------------------------------------------------\n// Utilities\n//------------------------------------------------------------------------------------------ \n    \n// Simple normal packing. Should be replaced with Octahedron compression.\n// See https://www.shadertoy.com/view/4llcRl\nvec3 UnpackR8G8B8(float f)\n{\n    uint ufloat = uint(f);\n    return vec3(float(ufloat & 0xFFu), float((ufloat >> 8) & 0xFFu), float((ufloat >> 16) & 0xFFu)) * 0.00392156862;\n}\n\nvec3 UnpackNorm(float f)\n{\n\treturn (UnpackR8G8B8(f) * 2.0) - 1.0;   \n}\n\n//------------------------------------------------------------------------------------------ \n// Camera\n//------------------------------------------------------------------------------------------ \n\nstruct Ray \n{ \n    vec3 o; \n    vec3 d; \n};\n\nstruct Camera \n{ \n    vec3 right; \n    vec3 up; \n    vec3 forward; \n    vec3 origin; \n};\n    \nRay Camera_GetRay(in Camera camera, vec2 uv) \n{ \n    uv    = (uv * 2.0) - 1.0; \n    uv.x *= (iResolution.x / iResolution.y); \n    \n    Ray ray; \n    ray.o = camera.origin; \n    ray.d = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5)); \n    \n    return ray; \n}\n\nvec3 Camera_GetPosition() \n{ \n    return texelFetch(iChannel0, ivec2(0, 0), 0).xyz; \n}\n\nvec3 Camera_GetForward() \n{ \n    return texelFetch(iChannel0, ivec2(0, 1), 0).xyz; \n}\n\nCamera Camera_Build() \n{ \n    Camera camera; \n    \n    camera.origin  = Camera_GetPosition(); \n    camera.forward = Camera_GetForward(); \n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0))); \n    camera.up      = normalize(cross(camera.right, camera.forward)); \n    \n    return camera; \n}\n\n//------------------------------------------------------------------------------------------\n// SSAO \n//------------------------------------------------------------------------------------------\n\nfloat SampleAO(in Camera camera, vec3 pos, vec3 norm, vec2 sampleUV)\n{\n    Ray ray = Camera_GetRay(camera, sampleUV);\n    \n\tfloat aoSampleDepth = textureLod(iChannel1, sampleUV, 0.0).r;\n    \n    vec3 aoSamplePos = ray.o + (ray.d * aoSampleDepth);\n    vec3 aoToVector  = (aoSamplePos - pos);\n     \n    float dist = length(aoToVector) * AODistScale;\n    float occl = max(0.0, dot(norm, normalize(aoToVector)) - AOBias) * (1.0 / (1.0 + dist)) * AOIntensity;\n    \n    return clamp(occl, 0.0, 1.0);\n}\n\nfloat AmbientOcclusion(in Camera camera, vec2 uv, vec3 pos, vec3 norm)\n{\n    float ao     = 0.0;\n    float rstep  = (AOSampleRadius / pos.z) / float(AOSampleCount);\n    float radius = rstep;                                             \n    float rangle = (textureLod(iChannel1, uv * 0.1, 0.0).r / FarClip) * (PI * 2.0);\n    \n    for(int i = 0; i < AOSampleCount; ++i, radius += rstep, rangle += 2.4)\n    {\n        vec2 sampleUV = vec2(sin(rangle), cos(rangle)) * radius;\n        ao += SampleAO(camera, pos, norm, uv + sampleUV);\n    }\n    \n    return clamp(ao / float(AOSampleCount), 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------------------------\n\nvec3 Sky(in Ray ray)\n{\n    float sun = pow(abs(dot(ray.d, SunLightDir)), 32.0);\n    vec3 sky = mix(vec3(0.29804, 0.61569, 0.92157), vec3(0.20980, 0.41764, 0.79215), clamp(abs(ray.d.y) * 2.0, 0.0, 1.0));\n    \n    return mix(sky, vec3(1.0), sun);\n}\n\nvec3 Lighting(in vec3 norm, in vec3 dir, float depth, float shadow, float ao, float roughness)\n{\n    vec3 sunLight    = max(0.0, dot(norm, SunLightDir)) * SunLightCol * shadow * 1.5;\n    vec3 ambLight    = max(0.0, dot(norm, AmbLightDir)) * AmbLightCol * ao;\n    vec3 skyLight    = clamp(0.5 + (0.5 * norm.y), 0.0, 1.0) * SkyLightCol * ao;\n    vec3 directLight = sunLight + (ambLight * 0.25) + (skyLight * 0.25);\n    \n    vec3 reflVec   = reflect(-SunLightDir, norm);\n    vec3 specLight = pow(max(0.0, dot(dir, -reflVec)), roughness) * vec3(1.0) * shadow;\n    \n    return (directLight + specLight);\n}\n\nvec3 CalcExpFog(vec3 color, vec3 pos, Ray ray)\n{\n    float dist      = distance(ray.o, pos);\n    float fogAmount = 1.0 - exp(-dist * 0.0025);\n    vec3  fogColor  = Sky(ray); \n    \n    return mix(color, fogColor, fogAmount);\n}\n\nvec2 CheckerIntegral(vec2 x)\n{\n    x /= 2.0;\n    return floor(x) + max(2.0*fract(x)-1.0, 0.0);\n}\n\nfloat Checkers(in vec2 p)\n{\n    vec2 fw = max(abs(dFdx(p)), abs(dFdy(p))); \n    float w = max(fw.x, fw.y);\n\n    vec2 i = (CheckerIntegral(p+0.5*w) -  \n              CheckerIntegral(p-0.5*w));\n    i /= w;                              \n    \n    return i.x + i.y - (2.0 * i.x * i.y); \n}\n\n\nvec3 Texture(in vec3 pos, in vec3 norm, in float material)\n{\n    vec3 checker = vec3(clamp(Checkers(pos.xz), 0.4, 0.7));\n    vec3 blank   = vec3(1.0);\n    \n    return mix(checker, blank, material);\n}\n\nvec3 Shade(in Camera camera, in vec2 uv, in Ray ray, in vec3 norm, float depth, float shadow, float id)\n{\n    vec3 color = Sky(ray);\n    \n    if(depth < (FarClip * 0.9))\n    {\n        vec3 pos = ray.o + (ray.d * depth);\n        float ao = 1.0 - AmbientOcclusion(camera, uv, pos, norm);\n        \n        color  = Texture(pos, norm, id);\n        color *= Lighting(norm, ray.d, depth, shadow, pow(ao, 3.0), color.r * 22.0);\n        \n        color = CalcExpFog(color, pos, ray);\n    }\n    \n    return pow(color, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 sceneSample = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec3 norm = UnpackNorm(sceneSample.a);\n    \n    Camera camera = Camera_Build();\n    Ray ray = Camera_GetRay(camera, uv);\n    \n    vec3 sceneRender = Shade(camera, uv, ray, norm, sceneSample.x, sceneSample.z, sceneSample.y);\n    \n#ifdef DRAW_DEBUG_OVERLAY\n\tvec4 debugOverlay = texture(iChannel2, uv);\n    fragColor.rgb = mix(sceneRender.rgb, debugOverlay.rgb, debugOverlay.a * 0.85);\n#else\n    fragColor.rgb = sceneRender.rgb;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n * -----------------------------------------------------------\n * -- First-Person Camera Controls\n * -----------------------------------------------------------\n *\n *     [0, 0] : Current Position\n *     [0, 1] : Current Forward Vector\n *     [0, 2] : Last Mouse Click    (.x = Click X [0, 1], .y = Click Y [0, 1], .z = Is Clicking [0 = false])\n *     [0, 3] : Last Mouse Position (.xy = Relative Delta Since Last Frame, .zw = Total Delta Since Last Click)\n *     [0, 4] : Last Rotation       (Quaternion)\n *\n * See the other buffers (except for Buf D) for an example of how to make use of this camera.\n */\n\n//------------------------------------------------------------------------------------------\n// Defines and Constants\n//------------------------------------------------------------------------------------------\n\n//#define INVERT_Y \n//#define FREE_FLY           // Only if physics is disabled\n#define PHYSICS_ENABLED\n\n#define LastPosition   ivec2(0, 0)\n#define LastForward    ivec2(0, 1)\n#define LastMouseClick ivec2(0, 2)\n#define LastMouseDelta ivec2(0, 3)\n#define LastRotation   ivec2(0, 4)\n\n#define Is(x) (ivec2(fragCoord) == x)\n\nconst float KEY_W            = 87.5 / 256.0;\nconst float KEY_A            = 65.5 / 256.0;\nconst float KEY_S            = 83.5 / 256.0;\nconst float KEY_D            = 68.5 / 256.0;\nconst float KEY_LEFT         = 37.5 / 256.0;\nconst float KEY_UP           = 38.5 / 256.0;\nconst float KEY_RIGHT        = 39.5 / 256.0;\nconst float KEY_DOWN         = 40.5 / 256.0;\nconst float KEY_SHIFT        = 16.5 / 256.0;\n\nconst vec3 Forward           = vec3(0.0, 0.0, -1.0);\nconst vec3 Right             = vec3(1.0, 0.0,  0.0);\nconst vec3 Up                = vec3(0.0, 1.0,  0.0);\n\nconst vec3 StartPos          = vec3(0.0, 4.0, 0.0);\nconst vec3 StartDir          = vec3(0.0, 0.0, -1.0);\nconst vec2 CameraSensitivity = vec2(3.14, 1.0);\n\nconst vec2 StartMouse        = vec2(0.5, 0.5);\n\nconst float MoveSpeed        = 2.0;\nconst float BoostModifier    = 8.0;\n\n//------------------------------------------------------------------------------------------\n// Quaternion Functions\n//------------------------------------------------------------------------------------------\n\nvec4 Quat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    return normalize(vec4(axis * sin(angle), cos(angle)));\n}\n\nvec4 QxQ(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = (q1.w * q2.w) - dot(q1.xyz, q2.xyz);\n    res.xyz = (q1.w * q2.xyz) + (q2.w * q1.xyz) + cross(q1.xyz, q2.xyz);\n    return normalize(res);\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + (q.w * t) + cross(q.xyz, t);\n}\n\n//------------------------------------------------------------------------------------------\n// Data Retrieval\n//------------------------------------------------------------------------------------------\n\nfloat IsKeyPressed(float key)\n{\n    return texture(iChannel1, vec2(key, 0.0)).r;\n}\n\nvec3 GetLastPosition()\n{\n\treturn texelFetch(iChannel0, LastPosition, 0).xyz;\n}\n\nvec3 GetLastForward()\n{\n    return texelFetch(iChannel0, LastForward, 0).xyz;\n}\n\nvec3 GetLastMouseClick()\n{\n    return texelFetch(iChannel0, LastMouseClick, 0).xyz;\n}\n\nvec4 GetLastMouseDelta()\n{\n    return texelFetch(iChannel0, LastMouseDelta, 0);\n}\n\nvec4 GetLastRotation()\n{\n\treturn texelFetch(iChannel0, LastRotation, 0);  // (x, y, z, w) quaternion\n}\n\n//------------------------------------------------------------------------------------------\n// Camera Updates\n//------------------------------------------------------------------------------------------\n\nvoid SetupFirstFrame(in vec2 fragCoord, inout vec4 fragColor)\n{\n    if(Is(LastPosition))\n    {\n        fragColor.xyz = StartPos;\n        return;\n    }\n    \n    if(Is(LastForward))\n    {\n        fragColor = vec4(Forward, 0.0);\n    }\n        \n    if(Is(LastMouseClick))\n    {\n        fragColor.xyz = vec3(StartMouse, 0.0);\n        return;\n    }\n        \n    if(Is(LastMouseDelta))\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if(Is(LastRotation))\n    {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n}\n\n#ifdef PHYSICS_ENABLED\nvoid UpdatePosition(inout vec4 pos)\n{\n    pos.xyz = texelFetch(iChannel2, ivec2(0), 0).xyz;\n}\n#else\nvoid UpdatePosition(inout vec4 pos)\n{\n    vec3 lastPos    = GetLastPosition();\n    vec3 dirForward = GetLastForward();\n    vec3 dirRight   = cross(dirForward, vec3(0.0, 1.0, 0.0));\n    \n    float keyForward = max(IsKeyPressed(KEY_W), IsKeyPressed(KEY_UP));\n    float keyDown    = max(IsKeyPressed(KEY_S), IsKeyPressed(KEY_DOWN));\n    float keyLeft    = max(IsKeyPressed(KEY_A), IsKeyPressed(KEY_LEFT));\n    float keyRight   = max(IsKeyPressed(KEY_D), IsKeyPressed(KEY_RIGHT));\n    \n    float pressForward = keyForward - keyDown;\n    float pressRight   = keyLeft - keyRight;\n    \n    vec3  direction = (dirForward * pressForward) + (-dirRight * pressRight);\n    float delta     = MoveSpeed * iTimeDelta * step(0.001, length(direction));\n    \n    if(delta > 0.0)\n    {\n        delta    *= max(1.0, IsKeyPressed(KEY_SHIFT) * BoostModifier);\n        direction = normalize(direction);\n    \n        pos.xyz = lastPos + (direction * delta);\n        \n#ifndef FREE_FLY\n        pos.y = StartPos.y;\n#endif\n    }\n}\n#endif\n\nvoid UpdateForward(inout vec4 fragColor)\n{\n    fragColor = vec4(Rotate(GetLastRotation(), Forward), 0.0);\n}\n\nvoid UpdateMouseClick(inout vec4 fragColor, in vec2 mouse)\n{\n    vec3 lastMouse = GetLastMouseClick();\n    float isClicked = step(0.5, iMouse.z);\n        \n    if((isClicked > 0.5) && lastMouse.z < 0.5)\n    {\n        fragColor.xy = vec2(mouse.xy / iResolution.xy);\n    }\n        \n    fragColor.z = isClicked;\n}\n\nvoid UpdateMouseDelta(inout vec4 fragColor, in vec2 mouse)\n{\n    vec3 lastMouse  = GetLastMouseClick();\n    vec2 totalDelta = (mouse.xy / iResolution.xy) - lastMouse.xy;\n    vec2 lastDelta  = GetLastMouseDelta().zw;\n       \n    if(lastMouse.z < 0.5)\n    {\n        fragColor.zw = vec2(0.0);\n        return;\n    }\n    \n    fragColor.xy = totalDelta - lastDelta;\n    fragColor.zw = totalDelta;\n}\n\nvoid UpdateRotation(inout vec4 fragColor)\n{\n    if(GetLastMouseClick().z < 0.5)\n    {\n        return;\n    }\n    \n    vec4 lastQuat    = GetLastRotation();\n    vec2 mouseDelta  = GetLastMouseDelta().xy * CameraSensitivity;\n    \n    vec3 forward = GetLastForward();\n    vec3 right   = normalize(cross(forward, Up));\n    vec3 up      = normalize(cross(right, forward));\n    \n#ifdef INVERT_Y\n    lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n    lastQuat = QxQ(Quat(right, -mouseDelta.y), lastQuat);\n#else\n    lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n    lastQuat = QxQ(Quat(right, mouseDelta.y), lastQuat);\n#endif\n    \n    fragColor = lastQuat;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec2 mouse = iMouse.xy;\n    \n    if(iFrame == 0)\n    {\n        SetupFirstFrame(fragCoord, fragColor);\n        return;\n    }\n    \n    if(Is(LastPosition))\n    {\n        UpdatePosition(fragColor);\n        return;\n    }\n    \n    if(Is(LastForward))\n    {\n\t\tUpdateForward(fragColor);\n        return;\n    }\n    \n    if(Is(LastMouseClick))\n    {\n        UpdateMouseClick(fragColor, mouse);\n        return;\n    }\n    \n    if(Is(LastMouseDelta))\n    {\n        UpdateMouseDelta(fragColor, mouse);\n        return;\n    }\n    \n    if(Is(LastRotation))\n    {\n        UpdateRotation(fragColor);\n        return;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * -- Physics Buffer\n * -----------------------------------------------------------\n *\n *     [0, 0] : Physics Position\n *     [0, 1] : Current Velocity\n *     [0, 2] : Last Space Button Press\n *\n * Physics collisions are all calculated based off of the scene's SDF. \n * This is probably not a good way of doing it, and it definitely is not\n * a concise way (as the scene definition/marching must be duplicated),\n * but it kind of works.\n *\n * This buffer makes use of the following inputs:\n *\n *     Buf A:    For camera rotation\n *     Buf B:    For latest position/velocity/space bar.\n *     Keyboard: For user input/movement.\n *\n * -----------------------------------------------------------\n * -- Goals\n * -----------------------------------------------------------\n *\n * This shader originally started out simply as a free-fly first-person\n * camera, but it felt lacking to not have a non-free-fly mode.\n *\n * So the physics initially was just to keep the camera along a ground \n * plane. Then came gravity. Then jumping. Etc. Now, there are the \n * following 'features':\n *\n *     * Gravity\n *     * Jumping\n *     * Non-sticky walls (keep sliding along them at reduced velocity)\n *     * Slope climbing (for ramps and steps)\n *\n * -----------------------------------------------------------\n * -- Known Issues\n * -----------------------------------------------------------\n *\n * As is true for any hastily written physics system, there are edge-cases\n * where the user can get stuck (temporarily or permanently). The primary\n * physics issues are:\n *\n *     - Corners (both outward and inward) are trouble spots. There is\n *       code that tries to prevent any issues from them, but it is not flawless.\n *     - Jumping (primarily head collision/prediction) needs further testing\n *       and probably a complete rewrite.\n *     - If falling directly along a wall, can fall into it and become stuck.\n *       This is because falling/gravity detection tests only the 'feet' location\n *       and does not account for the width of the player bounds. Then WASD movement\n *       considers width and is stuck. Either requires more SDF samples for falling\n *       or perhaps use an offset for WASD detection?\n */\n\n#define FarClip      300.0\n#define LocPosition  ivec2(0, 0)\n#define LocVelocity  ivec2(0, 1)\n#define LocSpace     ivec2(0, 2)\n#define Load(x)      texelFetch(iChannel2, x, 0)\n#define Is(x)        (ivec2(fragCoord) == x)\n\nconst float Gravity       = -9.86;\nconst float JumpImpulse   = -Gravity * 0.5;\nconst float Friction      = 0.7;\nconst float PI            = 3.14159265;\nconst float PlayerBounds  = 2.0;\nconst float MoveSpeed     = 1.0;\nconst float BoostModifier = 2.0;\n    \nconst vec3  FeetPosition  = vec3(0.0, -PlayerBounds, 0.0);\nconst vec3  HeadPosition  = vec3(0.0, PlayerBounds * 0.5, 0.0);\nconst vec3  StartPos      = vec3(0.0, 4.0, 0.0);\n\n//------------------------------------------------------------------------------------------\n// Keyboard\n//------------------------------------------------------------------------------------------\n\nconst float KEY_W            = 87.5 / 256.0;\nconst float KEY_A            = 65.5 / 256.0;\nconst float KEY_S            = 83.5 / 256.0;\nconst float KEY_D            = 68.5 / 256.0;\nconst float KEY_LEFT         = 37.5 / 256.0;\nconst float KEY_UP           = 38.5 / 256.0;\nconst float KEY_RIGHT        = 39.5 / 256.0;\nconst float KEY_DOWN         = 40.5 / 256.0;\nconst float KEY_SHIFT        = 16.5 / 256.0;\nconst float KEY_SPACE        = 32.5 / 256.0;\n\nfloat IsKeyPressed(float key)\n{\n    return texture(iChannel1, vec2(key, 0.0)).r;\n}\n\nfloat IsKeyToggled(float key)\n{\n    return texture(iChannel1, vec2(key, 2.0)).r;\n}\n\n//------------------------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------------------------\n\nvec3 Camera_GetPosition() \n{ \n    return texelFetch(iChannel0, ivec2(0, 0), 0).xyz; \n}\n\nvec3 Camera_GetForward() \n{ \n    return texelFetch(iChannel0, ivec2(0, 1), 0).xyz; \n}\n\n//------------------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------------------\n\nvec3 RotX(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3(p.x, (c * p.y) - (s * p.z), (s * p.y) + (c * p.z));\n}\n\nvec3 RotY(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3((c * p.x) + (s * p.z), p.y, (-s * p.x) + (c * p.z));\n}\n\nvec3 Repeat(vec3 p, vec3 c)\n{\n\treturn mod(p, c) - (0.5 * c);    \n}\n\nfloat Box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat HexPrism(vec3 p, vec2 h, float s)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x * s + q.y * 0.5), q.y) - h.x);\n}\n\nfloat RoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat Steps(vec3 p)\n{\n    float s = FarClip;\n    vec3  o = vec3(0.0);\n    float w = 14.0;\n    \n    for(int i = 0; i < 10; ++i)\n    {\n    \ts = min(s, Box(p + o + vec3(0.0, 0.0,- w), vec3(8.0, 0.25, w)));  \n        o += vec3(0.0, -0.35, -1.0);\n        w -= 1.0;\n    }\n    \n    float g = HexPrism(RotY(p + vec3(-8.5, 0.0, -14.0), PI * 0.5), vec2(3.4, 0.5), 0.2);\n    float b = Box(p - vec3(8.5, 0.0, -1.5), vec3(0.5, 1.0, 1.5));\n    \n    return min(s, min(g, b));\n}\n\nfloat Base(vec3 p)\n{\n    float h = mix(0.0, cos(p.x * 0.15), step(20.0, p.y));\n    \n\tfloat lowerBase = Box(p - vec3(10.0, 0.0, 24.0), vec3(33.0, 3.4, 13.0));\n    float upperBase = Box(p - vec3(10.0, 3.4, 41.0), vec3(21.0, 3.4, 13.0));\n    float roof      = Box(p - vec3(10.0, 19.0, 41.0), vec3(21.0, 6.5 + h, 13.0));\n\n    return min(lowerBase, min(upperBase, roof));\n}\n\nfloat Walls(vec3 p)\n{\n    float h = cos(clamp((p.z + 40.0) * 0.03, 0.0, PI * 0.5)) * 2.0;\n    \n    float wA = Box(p - vec3(24.0, 0.0, 10.0), vec3(3.0, 6.8 + h, 50.0));\n    float wB = Box(p - vec3(28.0, 0.0, 10.0), vec3(1.0, 13.5, 50.0));\n    float wC = Box(p - vec3(20.0, 0.0, 50.0), vec3(20.0, 13.5, 1.0));\n    float wD = Box(p - vec3(21.5, 0.0, -14.0), vec3(0.5, 7.8 + h, 26.0));\n    float wE = Box(p - vec3(10.0, 0.0, 28.5), vec3(20.0, 13.5, 0.5));\n    \n    float cA = RoundBox(Repeat(p - vec3(0.0, 1.5, 0.0), vec3(0.0, 0.0, 8.0)), vec3(22.0, 1.0, 1.0), 2.0);\n    float cC = RoundBox(Repeat(p - vec3(0.0, 8.0, 30.0), vec3(9.6, 0.0, 0.0)), vec3(1.0, 1.5, 4.0), 2.0);\n    \n    float rA = Box(p - vec3(21.0, 6.7, -15.0), vec3(0.2, 0.1, 27.0));\n    float rB = Box(p - vec3(14.0, 13.4, 28.0), vec3(14.0, 0.1, 0.2));\n    \n    wE = max(wE, -cC);\n    \n    float w = min(wA, min(wB, min(wC, min(wD, wE))));\n    float r = min(rA, rB);\n    \n    return min(r, max(w, -cA));\n}\n\nfloat Hallway(vec3 p)\n{\n    float hA = Box(p - vec3(24.0, 0.0, -30.0), vec3(2.0, 5.0, 70.0));\n    float hB = Box(p - vec3(0.0, 0.0, 40.0), vec3(26.0, 5.0, 2.0));\n    \n    return min(hA, hB);\n}\n\nfloat Scene(vec3 p)\n{\n    vec3 absp = vec3(abs(p.x), p.y, abs(p.z));\n    absp -= vec3(0.0, 0.0, 40.0);\n    \n    float result = FarClip;\n    \n    float steps     = min(Steps(absp), Steps(RotY(absp + vec3(-12.0, -3.4, -20.0), PI * 1.5)));\n    float base      = Base(absp);\n    float walls     = Walls(absp);\n    float hallway   = Hallway(absp);\n    \n    result = min(result, steps);\n    result = min(result, base);\n    result = min(result, walls);\n    result = max(result, -hallway);\n    \n    if(p.y < result)\n    {\n        return p.y;\n    }\n    \n    return result;\n}\n\nvec3 SceneNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(Scene(pos + eps.xyy) - Scene(pos - eps.xyy),\n                          Scene(pos + eps.yxy) - Scene(pos - eps.yxy),\n                          Scene(pos + eps.yyx) - Scene(pos - eps.yyx)));\n}\n\n//------------------------------------------------------------------------------------------\n// Physics Updates\n//------------------------------------------------------------------------------------------\n\nvoid UpdateGravity(inout vec3 position, inout vec3 velocity)\n{\n    vec3 g = vec3(0.0, Gravity, 0.0) * iTimeDelta;\n    vec3 p = (position + FeetPosition);\n    \n    float d = Scene(p);\n    \n    if(d <= 0.0)\n    {\n        position.y += (-d);\n        velocity.y = 0.0;\n    }\n    else\n    {\n        velocity += g;\n    }\n}\n\nvoid UpdateWASDMovement(in vec3 position, in vec3 forward, inout vec3 velocity)\n{\n    forward = normalize(vec3(forward.x, 0.0, forward.z));\n    vec3 right = cross(forward, vec3(0.0, 1.0, 0.0));\n    \n    float keyForward = max(IsKeyPressed(KEY_W), IsKeyPressed(KEY_UP));\n    float keyDown    = max(IsKeyPressed(KEY_S), IsKeyPressed(KEY_DOWN));\n    float keyLeft    = max(IsKeyPressed(KEY_A), IsKeyPressed(KEY_LEFT));\n    float keyRight   = max(IsKeyPressed(KEY_D), IsKeyPressed(KEY_RIGHT));\n    \n    float pressForward = keyForward - keyDown;\n    float pressRight   = keyLeft - keyRight;\n    \n    vec3  direction = normalize((forward * pressForward) + (-right * pressRight));\n    float delta     = MoveSpeed * step(0.001, length(direction));\n    \n    if(delta > 0.0)\n    {\n        delta *= max(1.0, IsKeyPressed(KEY_SHIFT) * BoostModifier);\n        \n        vec3 moveVelocity = velocity + (direction * delta);\n    \tvec3 bposition = position + (moveVelocity * iTimeDelta);\n        \n        if(Scene(bposition) < (PlayerBounds * 0.25))\n        {\n            // Continue moving against the normal to prevent sticky walls\n            vec3 normal = SceneNormal(bposition);\n            moveVelocity.xz *= vec2(1.0) - abs(normal.xz);\n            \n            bposition = position + (moveVelocity * iTimeDelta);\n            \n            // Make sure the slide doesnt push us into a wall (prevent slipping into corners)\n            if(Scene(bposition) < (PlayerBounds * 0.25))\n            {\n                moveVelocity = vec3(0.0);\n            }\n        }\n        \n        velocity = moveVelocity;\n    }\n}\n\nvoid UpdateJumpMovement(in vec3 position, inout vec3 velocity)\n{\n    float lastSpace = texelFetch(iChannel2, LocSpace, 0).r;\n    float currSpace = IsKeyPressed(KEY_SPACE);\n    \n    if(Scene(position + FeetPosition) > 0.1)\n    {\n        // Can't jump in mid air\n        return;\n    }\n    \n    if(Scene(position + HeadPosition) < 0.0)\n    {\n        // Can't jump if something is directly above head\n        return;\n    }\n    \n    // If space bar was pressed down since last update\n    if(currSpace > lastSpace)\n    {\n    \tvec3 jvelocity = vec3(0.0, 1.0, 0.0) * JumpImpulse;\n        vec3 jposition = position + jvelocity;\n        \n        velocity += jvelocity;\n    }\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 outval, in vec2 fragCoord)\n{\n    outval = vec4(0.0);\n    \n    if(iFrame == 0)\n    {\n        if(Is(LocPosition))\n        {\n        \toutval = vec4(StartPos, 0.0);\n        \treturn;\n        }\n        \n        return;\n    }\n    \n    if(Is(LocSpace))\n    {\n        outval.r = IsKeyPressed(KEY_SPACE);\n        return;\n    }\n    \n    if(!Is(LocPosition) && !Is(LocVelocity))\n    {\n        return;\n    }\n    \n    vec3 position  = Load(LocPosition).xyz;\n    vec3 velocity  = Load(LocVelocity).xyz;\n    vec3 direction = Camera_GetForward();\n    \n    vec3 dirVelocity = velocity * Friction * vec3(1.0, 0.0, 1.0);\n    vec3 grvVelocity = velocity * vec3(0.0, 1.0, 0.0);\n    \n    UpdateWASDMovement(position, direction, dirVelocity);\n    UpdateGravity(position, grvVelocity);\n    UpdateJumpMovement(position, grvVelocity);\n    \n    velocity.xyz = vec3(dirVelocity.x, grvVelocity.y, dirVelocity.z);\n    \n    if(Is(LocPosition))\n    {\n        outval.xyz = position + (velocity * iTimeDelta);\n        return;\n    }\n    \n    if(Is(LocVelocity))\n    {\n\t\toutval.xyz = velocity;\n        return;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * -- Test Scene\n * -----------------------------------------------------------\n * \n * Generates a G-Buffer for a simple courtyard scene. The buffer contents are:\n *\n *     .r = Scene Depth (not normalized)\n *     .g = Material ID (0.0 or 1.0)\n *     .b = Shadow Value [0.0, 1.0]\n *     .a = Packed Surface Normal\n */\n\n#define Epsilon  0.001\n#define NearClip 0.0\n#define FarClip  300.0\n#define PI       3.14159265\n\nconst vec3 SunLightDir  = normalize(vec3(1.0, 2.0, -2.0));\n\n//------------------------------------------------------------------------------------------\n// Utilities\n//------------------------------------------------------------------------------------------\n\nfloat PackR8G8B8(vec3 rgb)\n{\n    rgb = (rgb * 255.0) + 0.5;\n    return float((uint(rgb.r)) | (uint(rgb.g) << 8) | (uint(rgb.b) << 16));\n}\n\nfloat PackNorm(vec3 norm)\n{\n\treturn PackR8G8B8((norm + 1.0) * 0.5);   \n}\n\n//------------------------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------------------------\n\nstruct Ray \n{ \n    vec3 o; \n    vec3 d; \n};  \n    \nstruct Camera \n{ \n    vec3 right; \n    vec3 up; \n    vec3 forward; \n    vec3 origin; \n};\n    \nRay Camera_GetRay(in Camera camera, vec2 uv) \n{ \n    uv    = (uv * 2.0) - 1.0; \n    uv.x *= (iResolution.x / iResolution.y); \n    \n    Ray ray; \n    ray.o = camera.origin; \n    ray.d = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5)); \n    \n    return ray; \n}\n\nvec3 Camera_GetPosition() \n{ \n    return texelFetch(iChannel0, ivec2(0, 0), 0).xyz; \n}\n\nvec3 Camera_GetForward() \n{ \n    return texelFetch(iChannel0, ivec2(0, 1), 0).xyz; \n}\n\nCamera Camera_Build() \n{ \n    Camera camera; \n    \n    camera.origin  = Camera_GetPosition(); \n    camera.forward = Camera_GetForward(); \n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0))); \n    camera.up      = normalize(cross(camera.right, camera.forward)); \n    \n    return camera; \n}\n\n//------------------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------------------\n\nvec3 RotX(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3(p.x, (c * p.y) - (s * p.z), (s * p.y) + (c * p.z));\n}\n\nvec3 RotY(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3((c * p.x) + (s * p.z), p.y, (-s * p.x) + (c * p.z));\n}\n\nvec3 Repeat(vec3 p, vec3 c)\n{\n\treturn mod(p, c) - (0.5 * c);    \n}\n\nfloat Box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat HexPrism(vec3 p, vec2 h, float s)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x * s + q.y * 0.5), q.y) - h.x);\n}\n\nfloat RoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat Steps(vec3 p)\n{\n    float s = FarClip;\n    vec3  o = vec3(0.0);\n    float w = 14.0;\n    \n    for(int i = 0; i < 10; ++i)\n    {\n    \ts = min(s, Box(p + o + vec3(0.0, 0.0,- w), vec3(8.0, 0.25, w)));  \n        o += vec3(0.0, -0.35, -1.0);\n        w -= 1.0;\n    }\n    \n    float g = HexPrism(RotY(p + vec3(-8.5, 0.0, -14.0), PI * 0.5), vec2(3.4, 0.5), 0.2);\n    float b = Box(p - vec3(8.5, 0.0, -1.5), vec3(0.5, 1.0, 1.5));\n    \n    return min(s, min(g, b));\n}\n\nfloat Base(vec3 p)\n{\n    float h = mix(0.0, cos(p.x * 0.15), step(20.0, p.y));\n    \n\tfloat lowerBase = Box(p - vec3(10.0, 0.0, 44.0), vec3(33.0, 3.4, 33.0));\n    float upperBase = Box(p - vec3(10.0, 3.4, 61.0), vec3(21.0, 3.4, 33.0));\n    float roof      = Box(p - vec3(10.0, 19.0, 41.0), vec3(21.0, 6.5 + h, 13.0));\n\n    return min(lowerBase, min(upperBase, roof));\n}\n\nfloat Walls(vec3 p)\n{\n    // h = height modifier\n    // w = wall sdfs\n    // c = cutout sdfs\n    // r = ramp sdfs\n    \n    float h = cos(clamp((p.z + 40.0) * 0.03, 0.0, PI * 0.5)) * 2.0;\n    \n    float wA = Box(p - vec3(24.0, 0.0, 10.0), vec3(3.0, 6.8 + h, 50.0));\n    float wB = Box(p - vec3(28.0, 0.0, 10.0), vec3(1.0, 13.5, 50.0));\n    float wC = Box(p - vec3(20.0, 0.0, 50.0), vec3(20.0, 13.5, 1.0));\n    float wD = Box(p - vec3(21.5, 0.0, -14.0), vec3(0.5, 7.8 + h, 26.0));\n    float wE = Box(p - vec3(10.0, 0.0, 28.5), vec3(20.0, 13.5, 0.5));\n    \n    float cA = RoundBox(Repeat(p - vec3(0.0, 1.5, 0.0), vec3(0.0, 0.0, 8.0)), vec3(22.0, 1.0, 1.0), 2.0);\n    float cC = RoundBox(Repeat(p - vec3(0.0, 8.0, 30.0), vec3(9.6, 0.0, 0.0)), vec3(1.0, 1.5, 4.0), 2.0);\n    \n    float rA = Box(p - vec3(21.0, 6.7, -15.0), vec3(0.2, 0.1, 27.0));\n    float rB = Box(p - vec3(14.0, 13.4, 28.0), vec3(14.0, 0.1, 0.2));\n    \n    wE = max(wE, -cC);\n    \n    float w = min(wA, min(wB, min(wC, min(wD, wE))));\n    float r = min(rA, rB);\n    \n    return min(r, max(w, -cA));\n}\n\nfloat Hallway(vec3 p)\n{\n    float hA = Box(p - vec3(24.0, 0.0, -30.0), vec3(2.0, 5.0, 70.0));\n    float hB = Box(p - vec3(0.0, 0.0, 40.0), vec3(26.0, 5.0, 2.0));\n    \n    return min(hA, hB);\n}\n\nvec2 Scene(vec3 p, float shadow)\n{\n    vec3 absp = vec3(abs(p.x), p.y, abs(p.z));\n    absp -= vec3(0.0, 0.0, 40.0);\n    \n    float result = FarClip;\n    \n    float steps     = min(Steps(absp), Steps(RotY(absp + vec3(-12.0, -3.4, -20.0), PI * 1.5)));\n    float base      = Base(absp);\n    float walls     = Walls(absp);\n    float hallway   = Hallway(absp);\n    \n    result = min(result, steps);\n    result = min(result, base);\n    result = min(result, walls);\n    result = max(result, -hallway);\n    \n    if(shadow > 0.5)\n    {\n        // Add a circle shadow for the user\n        result = min(result, length(p - Camera_GetPosition()) - 1.0);\n    }\n    \n    if(p.y < result)\n    {\n        return vec2(p.y, 0.0);\n    }\n    \n    return vec2(result, 1.0);\n}\n\nvec2 March(in Ray ray)\n{\n    float depth    = NearClip;\n    float material = -1.0;\n    \n    for( ; depth < FarClip; )\n    {\n        vec3 pos = ray.o + (ray.d * depth);\n        vec2 sdf = Scene(pos, 0.0);\n        \n        if(sdf.x < Epsilon)\n        {\n            material = sdf.y;\n            break;\n        }\n        \n        depth += sdf.x;\n    }\n    \n    return vec2(depth, material);\n}\n\nvec3 SceneNormal(in vec3 pos, in float depth)\n{\n    vec2 eps = vec2(0.001 * depth, 0.0);\n    return normalize(vec3(Scene(pos + eps.xyy, 0.0).x - Scene(pos - eps.xyy, 0.0).x,\n                          Scene(pos + eps.yxy, 0.0).x - Scene(pos - eps.yxy, 0.0).x,\n                          Scene(pos + eps.yyx, 0.0).x - Scene(pos - eps.yyx, 0.0).x));\n}\n\nfloat Shadow(vec3 pos, float d)\n{\n    float shadow = 1.0;\n    float depth  = mix(1.0, 0.3, clamp(d / 3.0, 0.0, 1.0));\n    \n    for(int i = 0; i < 64; ++i)\n    {\n        vec3 p = pos + (SunLightDir * depth);\n        vec2 sdf = Scene(p, 1.0);\n        \n        shadow = min(shadow, (32.0 * sdf.x) / depth);\n        depth += sdf.x;\n        \n        if(sdf.x < 0.001)\n        {\n            break;\n        }\n    }\n    \n    return clamp(shadow, 0.1, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Trace\n//------------------------------------------------------------------------------------------\n\nvoid Trace(Ray ray, inout vec3 norm, inout float depth, inout float id, inout float shadow)\n{\n    vec2 march = March(ray);\n    \n    if(march.x < FarClip)\n    {\n        vec3 pos = ray.o + (ray.d * march.x);\n        \n        norm   = SceneNormal(pos, march.x);\n        depth  = march.x;\n        id     = march.y;\n        shadow = Shadow(pos, depth);\n    }\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    Camera camera = Camera_Build();\n    Ray ray = Camera_GetRay(camera, uv);\n    \n    vec3  norm   = vec3(0.0);\n   \tfloat depth  = FarClip;\n    float id     = 0.0;\n    float shadow = 1.0;\n    \n    Trace(ray, norm, depth, id, shadow);\n    \n    fragColor.rgb = vec3(depth, id, shadow);\n    fragColor.a = PackNorm(norm);  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * -- Debug Overlay\n * -----------------------------------------------------------\n *\n * Draws an overlay displaying mouse input.\n *\n *       Black Dot: Last mouse click\n *      Green Line: Total mouse delta since last click\n *        Red Line: Mouse delta since last frame\n *\n * The axis is right-handed, looking down -z axis.\n */\n\n//------------------------------------------------------------------------------------------\n// Line Drawing\n//------------------------------------------------------------------------------------------\n\nfloat DistToLine(vec2 p, vec2 a, vec2 b)\n{\n \tvec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float frac = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - (ba * frac));\n}\n\nfloat Sharpen(float dist, float thickness, float blur)\n{\n    float r = (1.0 / min(iResolution.x, iResolution.y)) * blur;\n    return smoothstep(r, -r, dist - thickness);\n}\n\nfloat Line(vec2 uv, vec2 a, vec2 b, float t)\n{\n    return Sharpen(DistToLine(uv, a, b), t, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvec4 drawMouse(in vec2 fragCoord)\n{\n    vec4 color = vec4(0.0);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 lastMouseClick = texelFetch(iChannel0, ivec2(0, 2), 0).xyz;\n    \n    float clickCircle = Sharpen(distance(uv, lastMouseClick.xy), 0.01, 1.0);\n    color = mix(color, vec4(0.0, 0.0, 0.0, 1.0), clickCircle);\n    \n    if(lastMouseClick.z > 0.5)\n    {\n        vec2 totalDelta   = (iMouse.xy / iResolution.xy) - lastMouseClick.xy;\n        vec4 lastDelta    = texelFetch(iChannel0, ivec2(0, 3), 0);\n        vec2 currentDelta = totalDelta - lastDelta.zw;\n        \n    \tfloat lastDeltaLine = Line(uv, lastMouseClick.xy, lastMouseClick.xy + lastDelta.zw, 0.005);\n        color = mix(color, vec4(0.0, 1.0, 0.0, 1.0), lastDeltaLine);\n        \n        float currentDeltaLine = Line(uv, lastMouseClick.xy + lastDelta.zw, lastMouseClick.xy + lastDelta.zw + currentDelta, 0.005);\n    \tcolor = mix(color, vec4(1.0, 0.0, 0.0, 1.0), currentDeltaLine);\n    }\n    \n    return color;\n}\n\nvec4 drawAxis(in vec2 xy)\n{\n    // Draw the right-handed coordinate axis\n    vec4 axis = vec4(0.0);\n    \n    if(xy.x < 200.0 && xy.y < 200.0)\n    {\n        vec3 forward = texelFetch(iChannel0, ivec2(0, 1), 0).xyz;\n        vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n        vec3 up      = normalize(cross(right, forward));\n        \n        float lf = Line(xy, -forward.xy * vec2(50.0) + 50.0, vec2(50.0), 1.0);\n        float lr = Line(xy, right.xy * vec2(50.0) + 50.0, vec2(50.0), 1.0);\n        float lu = Line(xy, up.xy * vec2(50.0) + 50.0, vec2(50.0), 1.0);\n\n        vec4 r = vec4(1.0, 0.0, 0.0, 1.0) * lr;\n        vec4 g = vec4(0.0, 1.0, 0.0, 1.0) * lu;        \n        vec4 b = vec4(0.0, 0.0, 1.0, 1.0) * lf;\n        \n        axis = mix(axis, g, g.a);\n        axis = mix(axis, r, r.a);\n        axis = mix(axis, b, b.a);\n    }\n    \n    return axis;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 1.0, 1.0, 0.0);\n    \n    vec4 mouse = drawMouse(fragCoord);\n    vec4 axis  = drawAxis(fragCoord);\n    \n    fragColor = mix(fragColor, mouse, mouse.a);\n    fragColor = mix(fragColor, axis, axis.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}