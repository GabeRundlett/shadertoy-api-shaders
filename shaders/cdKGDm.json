{
    "Shader": {
        "info": {
            "date": "1678662569",
            "description": "less exciting than it sounds, probably.\nexploded-view of a home improvement project.",
            "flags": 32,
            "hasliked": 0,
            "id": "cdKGDm",
            "likes": 12,
            "name": "exploding bookshelves",
            "published": 3,
            "tags": [
                "modeling",
                "shelves"
            ],
            "usePreview": 1,
            "username": "elenzil",
            "viewed": 282
        },
        "renderpass": [
            {
                "code": "// Fork of \"deconstructed telescope\" by elenzil. https://shadertoy.com/view/dlBXWm\n// 2023-03-04 05:02:47\n\nconst uint mtl_0       =  0u;\nconst uint mtl_floor   =  1u;\nconst uint mtl_white1  =  2u;\nconst uint mtl_board   =  3u;\nconst uint mtl_glass   =  4u;\nconst uint mtl_count   =  5u;\n\n\nfloat gT               = 1e9;\n\n// distance in inches\n\nfloat gBrdThick;\nfloat gBrdThickThin;\nfloat gBrdWidth;\nfloat gBrdRound;\n\nfloat gExplode;\n\nfloat gHeightExterior;\nfloat gWidthExterior;\nfloat gShelfSep;\n\nfloat fWallOffset;\nfloat fWallHeight;\nfloat fBaseLength;\nfloat fShelfLength;\nfloat fTopLength;\nfloat gTotalWidthExterior;\nfloat fBackBoardHeight;\n\nfloat gHeight;\n\nvoid setupScene2() {\n\n    // Measurements in inches.\n\n    // board thickness\n    gBrdThick =  7.0 / 8.0;\n    \n    // thickness of the thin backing board\n    gBrdThickThin = 3.0 / 16.0;\n    \n    // board width\n    gBrdWidth = 12.0;\n    \n    // smoothing radius on the edges of boards\n    gBrdRound =  2.0 / 32.0;\n\n    // overall exterior width of the pair of bookshelves\n    gTotalWidthExterior =  7.0 * 12.0;\n    \n    // exterior height of the shelves, including top board\n    gHeightExterior     = 66.0;\n    \n    // exterior width of each shelf\n    gWidthExterior      = 21.0;\n    \n    // amount of 'explode'\n    // explode should keep the dimensions of each piece unchanged.\n    const float explodeMax = 2.0;\n    float explodeAmt = smoothstep(0.3, -0.3, cos(gT));\n    gExplode  =  mix(0.0, explodeMax, explodeAmt);\n\n    gShelfSep           = gTotalWidthExterior - gWidthExterior;\n    fWallOffset         = (gWidthExterior - gBrdThick) / 2.0 + gExplode;\n    fWallHeight         = gHeightExterior - gBrdThick * 3.0;\n    fBaseLength         = gWidthExterior;\n    fShelfLength        = gWidthExterior - gBrdThick * 2.0;\n    fTopLength          = gTotalWidthExterior;\n    fBackBoardHeight    = fWallHeight + gBrdThick * 2.0;\n    \n    gHeight             = gHeightExterior + explodeMax * 2.0;\n}\n\n\nfloat sdBoard(in vec3 p, float h) {\n    return sdBox(p, vec3(gBrdWidth/2.0, h/2.0, gBrdThick/2.0) - gBrdRound) - gBrdRound;\n}\n\nfloat sdThinBoard(in vec3 p, float h, float w) {\n    return sdBox(p, vec3(w/2.0, h/2.0, gBrdThickThin/2.0) - gBrdRound) - gBrdRound;\n}\n\n\nfloat gMapCount = 0.0;\n\nmapSample_t map(in vec3 p) {\n    gMapCount += 1.0;\n    \n    p.y -= fWallHeight / 2.0 + gBrdThick;\n    p.y -= gExplode;\n\n    MST ret = MST(1e9, mtl_0);\n    \n    vec3 pp;\n\n    // walls on either side\n    pp = p;\n    pp.x = abs(pp.x) - gShelfSep / 2.0;\n    pp.x = abs(pp.x) - fWallOffset;\n    opUnion(ret, MST(sdBoard(pp.zyx, fWallHeight), mtl_board));\n\n    // base and top\n    pp   = p;\n    pp.x = abs(pp.x) - (gShelfSep / 2.0);\n    pp.y = abs(pp.y) - (fWallHeight / 2.0 + gExplode + gBrdThick / 2.0);    \n    opUnion(ret, MST(sdBoard(pp.zxy, fBaseLength), mtl_board));\n    \n    // shelves\n    const uint mtlShelves = mtl_board;\n    pp   = p;\n    pp.x = abs(pp.x) - (gShelfSep / 2.0);\n    pp.y = p.y - fWallHeight / 2.0 *  2.0 / 3.0;\n    opUnion(ret, MST(sdBoard(pp.zxy, fShelfLength), mtlShelves));\n    pp.y = p.y - fWallHeight / 2.0 *  1.0 / 3.0;\n    opUnion(ret, MST(sdBoard(pp.zxy, fShelfLength), mtlShelves));\n    pp.y = p.y - fWallHeight / 2.0 * -0.0 / 3.0;\n    opUnion(ret, MST(sdBoard(pp.zxy, fShelfLength), mtlShelves));\n    pp.y = p.y - fWallHeight / 2.0 * -1.5 / 3.0 - 2.0;\n    opUnion(ret, MST(sdBoard(pp.zxy, fShelfLength), mtlShelves));\n    \n    // top board\n    pp   = p;\n    pp.y -= fWallHeight / 2.0 + gBrdThick * 1.5 + gExplode * 2.0;\n    opUnion(ret, MST(sdBoard(pp.zxy, fTopLength), mtl_board));\n    \n    // back sheet\n    pp = p;\n    pp.x  = abs(pp.x) - gShelfSep / 2.0;\n    pp.z -= (gBrdWidth + gBrdThickThin) / 2.0 + gExplode;\n    opUnion(ret, MST(sdThinBoard(pp, fBackBoardHeight, fBaseLength), mtl_board));\n    \n\n\n    return ret;\n}\n\nconst mtl_t materials[mtl_count] = mtl_t[](\n    mtl_t(1.0        , 1.0 , v1),                   // sky\n    mtl_t(1.0        , 0.0 , v1),                   // floor\n    mtl_t(1.0        , 0.0 , v1 * 0.8),             // white1\n    mtl_t(1.0        , 0.0 , v1),                   // board\n    mtl_t(1.2        , 0.7 , v1 * 0.2)              // glass\n);\n\n\n\n\nconst float cPixelize           =   1.0;\n\nconst float cMinRayAmt          =   0.001 / 256.0;\n      uint  cMaxRays            =   8u;\nconst float cSurfEps            =   0.005;\nconst float cSelfSoftShadowDist =   0.5;\n\nconst int   cMaxMarchSteps      =  300;\nconst float cWSEps              =   0.002;\n      float gUnderStepFactor    =   1.0;\n\n\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 6u\nQ_IMPLEMENTATION\n\n\nvec2 viewportFromScreen(in vec2 p) {\n    return (p * 2.0 - RES) / MINRES;\n}\n\nfloat gSmoothEps   = 1e9;\nvec3  gSunDir      = 1e9 * v1;\nvec3  gRGB         = 1e9 * (vX + vZ);\n\nvoid setupScene() {\n    float sunT = gT * 0.1 + 10.0;\n    gSunDir = vec3(cos(sunT), abs(cos(sunT) * 0.5 + 0.51) * 2.0 + 3.0, -abs(sin(sunT)));\n    gSunDir = normalize(gSunDir);\n}\n\n// https://iquilezles.org/articles/normalsSDF\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\nvec3 mapNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*cWSEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvoid rayVsScene(in ray_t r, inout hit_t h) {\n    // tack on a plane via analytic intersection.\n    rayVsPlane (r, vY, 0.0, mtl_floor, h);\n\n    float t = 0.0;\n    \n    for (int n = 0; n < cMaxMarchSteps && t < 1e3; ++n) {\n        vec3 p = r.ro + r.rd * t;\n        mapSample_t ms = map(p);\n        if (ms.dist * r.side < cWSEps) {\n            h.hit      = true;\n            h.t        = t;\n            h.pnt      = p;\n            h.nrm      = mapNormal(p);\n            h.mtl      = ms.mtl;\n            h.miss     = 0.0;\n            return;\n        }\n        else {\n            if (t > cSelfSoftShadowDist && ms.dist < h.miss) {\n                h.miss  = ms.dist;\n                h.missT = t;\n            }\n        }\n\n        t += r.side * ms.dist * gUnderStepFactor;\n    }\n}\n\n\n//------------------------------------------------------------------\n\nvec3 toneSky(in ray_t r) {\n    vec3 rgb = simple_sky(r.ro, r.rd, gSunDir);\n    float theta = atan(r.rd.z, r.rd.x);\n    float q = 2.0 - smoothstep(1.0, 0.98, cos((theta + pi/2.0) * 50.0));\n    rgb *= q;\n    return rgb;\n}\n\nvec3 toneFloor(in vec2 p) {\n    vec3 tx = texture(iChannel0, fract(p * 0.01)).rgb * 1.2;\n    return tx*tx;\n}\n\nvec3 tone(in ray_t r, in hit_t h) {\n    switch (h.mtl) {\n        case mtl_0:\n            return toneSky(r);\n        case mtl_floor:\n            return toneFloor(h.pnt.xz);\n        default:\n            return materials[h.mtl].color;\n    }\n}\n\n//------------------------------------------------------------------\n\nbool gShadows = true;\nuint gRayCount;\nvoid runRays() {\n\n    // accumulates in gRGB.\n    \n    gRayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        gRayCount += 1u;\n        ray_t r = QDequeue();\n\n        hit_t h = newHit();\n        h.mtl = mtl_0;\n        rayVsScene(r, h);\n        \n        if (!h.hit) {\n            // no hit\n            gRGB += r.amt * tone(r, h);\n        }\n        else {\n            // a hit!\n            // \"nrm\" here is the hit-facing normal,\n            // while h.nrm is the \"outward\" facing normal.\n            \n            mtl_t m = materials[h.mtl];\n            \n            vec3  nrm     = h.nrm * r.side;\n            float R0      = schlickR0(m.ior, ior_air);\n            float reflAmt = schlick  (R0, dot(r.rd, -nrm));            \n            float trnsAmt = m.diffVsTrns * (1.0 - reflAmt);\n            float diffAmt = (1.0 - m.diffVsTrns) * (1.0 - reflAmt);\n                        \n            reflAmt *= r.amt;\n            trnsAmt *= r.amt;\n            diffAmt *= r.amt;\n\n            if (diffAmt > cMinRayAmt) {\n                // diffuse lighting at surfaces.\n                // cast a ray for shadows.\n                ray_t shdRay;\n                shdRay.ro         = h.pnt + h.nrm * cSurfEps;\n                shdRay.rd         = gSunDir;\n                shdRay.amt        = diffAmt;\n                shdRay.side       = 1.0;\n                hit_t shdHit      = newHit();\n                \n                float sunDot      = max(0.0, dot(gSunDir, h.nrm));\n                \n                if (gShadows) {\n                    rayVsScene(shdRay, shdHit);\n                }\n                \n                float lit = 1.0 - float(shdHit.hit);\n                float blur = shdHit.missT * 0.03;\n                lit *= smoothstep(0.0, blur, shdHit.miss);\n                                \n                vec3 diff = lit * diffAmt * sunDot * tone(r, h);\n                                \n                gRGB += diff + 0.5/255.0;\n            }\n\n            // moving on to transmission and then reflection.\n            \n            if (QSpaceLeft() < 2u) {\n                continue;\n            }\n            \n            if (gRayCount >= cMaxRays) {\n                continue;\n            }\n            \n            if (trnsAmt > cMinRayAmt) {\n                float eta = ior_air / m.ior;\n                if (r.side < 0.0) {\n                    eta = 1.0 / eta;\n                }\n                vec3 trnRayDir = refract(r.rd, nrm, eta);\n                if (dot(trnRayDir, trnRayDir) < 0.001) {\n                    // total internal reflection.\n                    // this is theoretically impossible for a ray that entered a sphere,\n                    // but keeping it in here anyhow for more exotic scenarios.\n                    reflAmt += trnsAmt;\n                }\n                else {\n                    ray_t trnRay;\n                    trnRay.ro   = h.pnt - nrm * cSurfEps;\n                    trnRay.rd   = trnRayDir;\n                    trnRay.side = -r.side;\n                    trnRay.amt  = trnsAmt;\n                    \n                    QEnqueue(trnRay);\n                }\n            }\n\n            if (reflAmt > cMinRayAmt) {\n                ray_t rflRay;\n                rflRay.ro   = h.pnt + nrm * cSurfEps;\n                rflRay.rd   = reflect(r.rd, nrm);\n                rflRay.side = r.side;\n                rflRay.amt  = reflAmt;\n\n                QEnqueue(rflRay);\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime * 0.2;\n    gSmoothEps = 4.0 / MINRES;\n    \n    const float pipScale = 0.4;\n    bool pip = XY.x < RES.x * pipScale && XY.y < RES.y * pipScale;\n    pip = pip && KEY_TOGGLED(32, iChannel2);\n    \n    gShadows  = !KEY_TOGGLED(83, iChannel2);\n    cMaxRays  =  KEY_TOGGLED(76, iChannel2) ? 1u : 8u;\n    \n    if (pip) {\n        XY /= pipScale;\n    }\n    \n    // pixelate\n    vec2 XY2 = XY - (fract(XY / cPixelize ) - 0.5) * cPixelize;\n    \n    vec2 xy = viewportFromScreen(XY2);\n    \n    vec4 inp = texelFetch(iChannel1, ivec2(0), 0);\n    vec2 m  = viewportFromScreen(inp.xy);\n    if (length(inp.xy) < 50.0) {\n        m = v0.xy;\n    }\n\n    setupScene();\n    setupScene2();\n                \n    // setup camera\n    float theta     = (m.x * 1.5 + 0.5) * -pi;\n    vec3  lookTo    = vY * gHeight * 0.55;\n    vec3  lookFrom  = vec3(cos(theta) * 9.0, 5.0 - 10.0 * m.y, sin(theta) * 9.0);\n    lookFrom = normalize(lookFrom) * gHeight * 1.3;\n    // don't let camera go below the floor\n    lookFrom.y = max(0.1, lookFrom.y);\n    \n    // configure our initial ray for this pixel\n    ray_t r0;\n    r0.ro   = lookFrom;\n    r0.rd   = matLookTo(lookFrom, lookTo) * normalize(vec3(xy, -1.8));\n    r0.amt  = 1.0;\n    r0.side = 1.0;\n    QEnqueue(r0);\n    \n    gRGB = v0;\n    runRays();\n    \n    gRGB = pow(gRGB, vec3(1.0/2.2));\n    \n    if (pip) {\n        float mapCost = gMapCount / 150.0;\n        float rayCost = float(gRayCount) / float(cMaxRays);\n        gRGB.r = mapCost;\n        if (cMaxRays > 1u) {\n            gRGB.g = rayCost;\n        }\n        else {\n            gRGB.g = 0.2;\n        }\n        gRGB.b = 0.3;\n    }\n    \n    RGBA = vec4(gRGB, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (0)\n\nconst float pi = 3.14159265359;\nconst vec3  v1 = vec3(1.0);\nconst vec3  v0 = vec3(0.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\n\n//--------------------------------------------------------------------------------\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    float amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float miss;  // smallest distance to a shadowing point.\n    float missT; // distance to miss.\n};\n\nstruct mapSample_t {\n    float dist;\n    uint mtl;\n};\n#define MST mapSample_t\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns;\n    vec3  color;\n};\n\nhit_t newHit() {\n    hit_t ret;\n    ret.hit      = false;\n    ret.t        = 1e9;\n    ret.miss     = 1e9;\n    ret.missT    = 1e9;\n    return ret;\n}\n\n\n//--------------------------------------------------------------------------------\n\nconst float ior_air     =  1.0003;\nconst float ior_aerogel =  1.03;\nconst float ior_ice     =  1.309;\nconst float ior_water   =  1.333;\nconst float ior_quartz  =  1.46;\nconst float ior_diamond =  2.42;\nconst float ior_shiny1  =  4.0;    // ad hoc\nconst float ior_mrr     =  1e2;    // ad hoc\n\n\n//--------------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n// assumes 'up' is world Y.\nmat3 matLookTo(in vec3 lookFrom, in vec3 lookTo) {\n    vec3 fw = -normalize(lookTo - lookFrom);\n    vec3 rt =  normalize(cross(fw, vY));\n    vec3 up =  cross(rt, fw);\n    \n    return mat3(rt, up, fw);\n}\n\nmat2 matRot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// how far to offset each of two spheres of radius sphRad\n// to obtain a lens of radius lensRad\nfloat offsetToMakeLens(float sphRad, float lensRad) {\n    return sqrt(max(0.0, (sphRad * sphRad) - (lensRad * lensRad)));\n}\n\n// lensmaker's equation\nfloat radiusForFocalLength(float focalLength, float ior) {\n    return (ior - 1.0) * 2.0 * focalLength;\n}\n\nvec2 radiusAndOffsetForLens(float focalLength, float ior, float lensRad) {\n    vec2 ret;\n    \n    ret.x = radiusForFocalLength(focalLength, ior);\n    ret.y = offsetToMakeLens(ret.x, lensRad);\n    \n    return ret;\n}\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(pos.y, 0.1)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(in vec3 dir, in vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(in vec3 p, in vec3 d, in vec3 lightDir)\n{\n    p.y *= -1.0;\n    p.y = max(0.1, p.y);\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////\n\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n\n///////////////////////////////////////////////////////\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCyl(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e ) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinderX( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// return a symmetric bi-concave lens shape given:\n// desc.x = sphere radius\n// desc.y = lens radius\n// desc.z = chamfer radius\nfloat sdLensCc(in vec3 p, vec3 desc) {\n\n    p.x = abs(p.x) + desc.y;\n    \n    float dCyl = length(p.yz) - desc.z;\n    \n    float d = length(p) - desc.x;\n    \n    d = max(d, dCyl);\n    \n    return d;\n}\n\nvoid opUnion(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist < cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opMinus(inout mapSample_t cur, mapSample_t new) {\n    if (-new.dist > cur.dist) {\n        cur.dist = -new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opInter(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist > cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opUnion(inout float cur, float new) {\n    cur = min(cur, new);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// mouse state\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    \n    if (iFrame < 2) {\n        RGBA = vec4(0.0, 0.0, iResolution.y / 2.0, 0.0);\n        return;\n    }\n    \n    if (IJ == ivec2(0)) {\n        RGBA = texelFetch(iChannel0, IJ, 0);\n        if (iMouse.x > iResolution.x - 100.0) {\n            RGBA.z = iMouse.y;\n        }\n        else {\n            RGBA.xy = iMouse.xy;\n        }\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}