{
    "Shader": {
        "info": {
            "date": "1506437387",
            "description": "Revisiting my PBR code on a shader ball model. Best viewed in full-screen.\n\n * Cook Torrance Specular with Lambertian Diffuse\n * Single bounce reflection with IBL environment mapping\n * Scene-based Ambient Occlusion\n * AA + DoF",
            "flags": 32,
            "hasliked": 0,
            "id": "MtXczf",
            "likes": 38,
            "name": "PBR Shader Ball",
            "published": 3,
            "tags": [
                "dof",
                "ao",
                "occlusion",
                "aa",
                "ambient",
                "pbr",
                "bumpmap"
            ],
            "usePreview": 0,
            "username": "ssell",
            "viewed": 2314
        },
        "renderpass": [
            {
                "code": "/**\n * -----------------------------------------------------------\n * - Shader Ball PBR\n * - Created by Steven Sell (ssell) / 2017\n * - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * - https://www.shadertoy.com/view/MtXczf\n * -----------------------------------------------------------\n *\n * -----------------------------------------------------------\n * - General \n * -----------------------------------------------------------\n *\n * Revisting my PBR code and applying it to a shader ball model.\n * The primary difference in the lighting is the addition of:\n *\n *     - Single bounce reflection/environment sampling\n *     - Ambient occlusion\n *\n * The scene itself is fairly simple as this is more a demo of \n * the lighting algorithm.\n *\n * See the individual buffers for more details.\n *\n *     - Buf A: Scene marching and rendering\n *     - Buf B: AA\n *     - Buf C: DoF\n *     - Image: Vignette and final output\n * \n * -----------------------------------------------------------\n * - References\n * -----------------------------------------------------------\n *\n * -- PBR Lighting\n *\n *     'PBR Lighting Demo' - ssell\n *     https://www.shadertoy.com/view/MsXBzl\n *\n *     Source for the general PBR lighting model.\n *\n * -- Anti-Aliasing\n *\n *     'Anti-Aliasing Compare' - JasonD\n *     'https://www.shadertoy.com/view/4dGXW1'\n *\n *     Adapted the 'Random 8x8 Dynamic' supersampling method.\n *\n * -- Edge Detection\n *\n *     'SDF Outline Comparison' - ssell\n *     https://www.shadertoy.com/view/4lfyR2\n *\n *     Concentrate anti-aliasing on the geometry edges.\n */\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nfloat Vignette(in vec2 uv)\n{\n    return 0.1 + 0.8 * pow(64.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tfragColor      = vec4(texture(iChannel0, uv).rgb, 1.0);\n    fragColor.rgb *= clamp(Vignette(uv), 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * - Scene Marching and Rendering\n * -----------------------------------------------------------\n *\n * A simple test scene consisting of a shader ball model and wooden platform/table.\n *\n * The shader ball has two different materials applied to it:\n *\n *     - Glossy white material. Low roughness and metallicness.\n *     - Black speckled material. Mid roughness and high metalicness.\n *\n * For the wood:\n *\n *     - Low metallic, roughness is based on .r component.\n *     - Simple bump mapping applied (only to direct lighting for performance consideration).\n *\n * For the lighting:\n *\n *     - Cook-Torrance Specular\n *     - Lambertian Diffuse\n *     - Single bounce reflection\n *     - Scene-based ambient occlusion\n */\n\n//--------------------------------------------\n// Defines for improved quality\n//--------------------------------------------\n\n/**\n * Toggles changes to:\n *\n *     - Enable bump mapping on ambient lighting (default: direct only)\n *     - Increase shadow marching steps to 32 (default: 16)\n *     - Increase reflection raymarching steps to 100 (default: 50)\n *     - Increase ambient environment sampling steps to 16 (default: 8)\n */\n\n//#define HIGH_QUALITY\n\n//--------------------------------------------\n// General defines and constants\n//--------------------------------------------\n\n#define Epsilon           0.001\n#define NearClip          Epsilon\n#define FarClip           14.0\n#define PI                3.14159\n#define ONE_OVER_PI       0.31831\n#define ONE_OVER_TWO_PI   0.15915\n\n#ifdef HIGH_QUALITY\n#define IBLSteps          16.0\n#else\n#define IBLSteps          8.0\n#endif\n\nconst vec3  CamOrigin   = vec3(0.0, 2.5, 0.0);\nconst vec3  CamLookAt   = vec3(0.0, 1.1, 0.0);\nconst float CamFOV      = radians(45.0);\nconst vec3  SunLightDir = normalize(vec3(1.65, 2.0, 0.5));\n\n//------------------------------------------------------------------------------------------\n// Ray / Camera\n//------------------------------------------------------------------------------------------\n\nstruct Ray\n{\n\tvec3 o;\n    vec3 d;\n};\n\nRay Ray_LookAt(in vec2 uv, in vec3 o, in vec3 d)\n{\n    vec3 forward = normalize(d - o);\n    vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up      = normalize(cross(right, forward));\n\n    uv = (uv * 2.0) - 1.0;\n\n    float u = tan(CamFOV) * distance(o, d);\n    float v = u * (iResolution.y / iResolution.x);\n\n    return Ray(o, normalize(d + (uv.x * u * right) + (uv.y * v * up) - o));\n}\n\nvec3 OrbitAround(vec3 origin, float radius, float rate)\n{\n    float time = iTime + 4.0f;\n  \treturn vec3((origin.x + (radius * cos(time * rate))), (origin.y), (origin.z + (radius * sin(time * rate))));\n}\n\n//------------------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------------------\n\n// Credit for simple shapes to https://iquilezles.org/articles/distfunctions\nvec3  RotX(in vec3 p, float a)        { float s = sin(a); float c = cos(a); return vec3(p.x, (c * p.y) - (s * p.z), (s * p.y) + (c * p.z)); }\nvec3  Repeat(vec3 p, vec3 c)          { return mod(p, c) - (0.5 * c); }\nfloat smin(float a, float b, float k) { float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0); return mix(b, a, h) - k*h*(1.0 - h); }\nfloat Box(vec3 p, vec3 b)             { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat Sphere(vec3 p, float r)         { return length(p) - r; }\nfloat Cylinder(vec3 p, vec2 h)        { vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nvec2  U(vec2 d1, vec2 d2)             { return (d1.x < d2.x) ? d1 : d2; }\nvec2  S(vec2 d2, vec2  d1 )           { return (-d1.x > d2.x) ? -d1 : d2; }\n\nvec2 ShaderBall(vec3 p)\n{\n    vec3 spos = p - vec3(0.0, 1.5, 0.0);\n    \n    vec2 ts   = vec2(max(Sphere(spos, 1.0), -Sphere(spos, 0.8)), 9.0);                // Hollow top sphere\n    vec2 tsi  = vec2(Sphere(spos, 0.725), 2.0);                                       // Inner sphere core\n    vec2 tsc  = vec2(Sphere(spos - vec3(0.0, 0.4, 0.8), 0.55), 3.0);                  // Cut into side of top sphere\n    vec2 rc   = vec2(Box(RotX(spos, PI * 0.15), vec3(2.0, 0.05, 2.0)), 4.0);          // Ring cut into top sphere\n    \n    vec2 st   = vec2(Cylinder(p - vec3(0.0, 0.1, 0.0), vec2(mix(0.8, 0.3, clamp(p.y - 0.125, 0.0, 1.0)), 0.2)), 5.0);    // Stand wide base      \n    vec2 stc  = vec2(Cylinder(Repeat(p, vec3(0.5, 0.0, 0.5)), vec2(0.125, 1.0)), 6.0);                                   // Stand ridge cuts\n    vec2 stm  = vec2(Cylinder(p - vec3(0.0, 0.35, 0.0), vec2(0.5, 0.35)), 5.0);       // Thinner stand middle\n    \n    st   = S(st, stc);\n    st.x = smin(st.x, stm.x, 0.2);                         \n    \n    vec2 b    = vec2(Cylinder(p - vec3(0.0, 0.025, 0.0), vec2(1.0, 0.05)), 8.0);      // Base\n       \n    vec2 result = S(ts, tsc);\n         result = S(result, rc);\n         result = U(result, tsi);\n         result = U(result, st);\n         result = U(result, b);\n    \n    return result;\n}\n\n// Returns vec2(sdf distance, surface/material id)\nvec2 Scene(in vec3 p)\n{\n    return U(ShaderBall(p), \n             vec2(Box(p + vec3(0.0, 0.5, 0.0), vec3(10.0, 0.5, 4.0)), 1.0));  // Wood platform/table\n}\n\nvec2 March(in Ray ray, int maxSteps)\n{\n    float depth = NearClip;\n    float id = 1.0;\n    \n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec2 sdf = Scene(ray.o + (ray.d * depth));\n        \n        if(sdf.x < Epsilon)\n        {\n            id = sdf.y;\n            break;\n        }\n        \n        if(sdf.x >= FarClip)\n        {\n            break;\n        }\n        \n        depth += sdf.x;\n    }\n    \n    return vec2(clamp(depth, NearClip, FarClip), id);\n}\n\nfloat Shadow(vec3 pos)\n{\n    float shadow = 1.0;\n    float depth  = 1.0;\n    \n#ifdef HIGH_QUALITY\n    for(int i = 0; i < 32; ++i)\n#else\n    for(int i = 0; i < 24; ++i)\n#endif\n    {\n        vec2 sdf = Scene(pos + (SunLightDir * depth));\n        \n        shadow = min(shadow, (8.0 * sdf.x) / depth);\n        depth += sdf.x;\n        \n        if(sdf.x < 0.001)\n        {\n            shadow = 0.0;\n            break;\n        }\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n\nvec3 SceneNormal(in vec3 p, in float d)\n{\n    vec2 eps = vec2(0.001 * d, 0.0);\n    return normalize(vec3(Scene(p + eps.xyy).x - Scene(p - eps.xyy).x,\n                          Scene(p + eps.yxy).x - Scene(p - eps.yxy).x,\n                          Scene(p + eps.yyx).x - Scene(p - eps.yyx).x));\n}\n\n//------------------------------------------------------------------------------------------\n// Sampling and Material\n//------------------------------------------------------------------------------------------\n\nvec3 SampleEnvironment(in vec3 reflVec)\n{\n    reflVec = normalize(reflVec);\n    return texture(iChannel3, reflVec).rgb;\n}\n\nstruct Material\n{\n    vec3  albedo;\n    vec3  bump;\n    float roughness;\n    float metallic;\n};\n\nvoid GetBumpNormal(in vec3 pos, inout Material mat, int id)\n{\n    if(id != 1)\n    {\n        return;    // We only bump map the wood material\n    }\n    \n    vec2 uv  = pos.xz * 0.25;\n    vec2 eps = vec2(0.001, 0.0);\n\n    float sampleU = texture(iChannel0, uv - eps.yx).r;\n    float sampleD = texture(iChannel0, uv + eps.yx).r;\n    float sampleL = texture(iChannel0, uv - eps.xy).r;\n    float sampleR = texture(iChannel0, uv + eps.xy).r;\n\n   \tvec3 delta = vec3(\n        (sampleL * sampleL - sampleR * sampleR), \n        0.0, \n        (sampleU * sampleU - sampleD * sampleD));\n\n    mat.bump = normalize(mat.bump + (delta * 2.0));\n}\n\nMaterial CreateMaterial(in vec3 pos, in vec3 norm, in int id)\n{\n    Material mat;\n    \n    mat.albedo    = vec3(1.0);    // Default glossy white\n    mat.roughness = 0.01;\n    mat.metallic  = 0.0;\n    mat.bump      = norm;\n    \n    if(id == 1)                   // Wood\n    {\n        mat.albedo    = textureLod(iChannel0, pos.xz * 0.25, 0.0).rgb;\n        mat.roughness = 0.01 + (mat.albedo.r * 0.2);\n        \n        return mat;\n    }\n    \n    if(id == 2)                   // Black sphere\n    {\n        mat.albedo    = vec3(0.1) * texture(iChannel1, pos * 10.0).r;\n        mat.roughness = 0.3;\n        mat.metallic  = 1.0;\n        \n        return mat;\n    }\n    \n    return mat;\n}\n\n//------------------------------------------------------------------------------------------\n// PBR (see https://www.shadertoy.com/view/MsXBzl for documentation)\n//------------------------------------------------------------------------------------------\n\nvec3 CalculateDiffuse(\n    in vec3 albedo)\n{                              \n    return (albedo * ONE_OVER_PI);\n}\n\nvec3 CalculateHalfVector(\n    in vec3 toLight,\n    in vec3 toView)\n{\n    return normalize(toLight + toView);\n}\n\nfloat CalculateNDF(\n    in vec3  surfNorm,\n    in vec3  halfVector,\n    in float roughness)\n{\n    float a = (roughness * roughness);\n    float halfAngle = dot(surfNorm, halfVector);\n    \n    return (a / (PI * pow((pow(halfAngle, 2.0) * (a - 1.0) + 1.0), 2.0)));\n}\n\nfloat CalculateAttenuation(\n    in vec3  surfNorm,\n    in vec3  vector,\n    in float k)\n{\n    float d = max(dot(surfNorm, vector), 0.0);\n \treturn (d / ((d * (1.0 - k)) + k));\n}\n\nfloat CalculateAttenuationAnalytical(\n    in vec3  surfNorm,\n    in vec3  toLight,\n    in vec3  toView,\n    in float roughness)\n{\n    float k = pow((roughness + 1.0), 2.0) * 0.125;\n    \n    float lightAtten = CalculateAttenuation(surfNorm, toLight, k);\n    float viewAtten  = CalculateAttenuation(surfNorm, toView, k);\n    \n    return (lightAtten * viewAtten);\n}\n\nfloat CalculateAttenuationIBL(\n    in float roughness,\n    in float normDotLight,\n    in float normDotView)       \n{\n    float k = pow(roughness, 2.0) * 0.5;\n    \n    float lightAtten = (normDotLight / ((normDotLight * (1.0 - k)) + k));\n    float viewAtten  = (normDotView / ((normDotView * (1.0 - k)) + k));\n    \n    return (lightAtten * viewAtten);\n}\n\nvec3 CalculateFresnel(\n    in vec3 surfNorm,\n    in vec3 toView,\n    in vec3 fresnel0)\n{\n\tfloat d = max(dot(surfNorm, toView), 0.0); \n    float p = ((-5.55473 * d) - 6.98316) * d;\n        \n    return fresnel0 + ((1.0 - fresnel0) * pow(1.0 - d, 5.0));\n}\n\nvec3 CalculateSpecularAnalytical(\n    in    vec3  surfNorm,\n    in    vec3  toLight,\n    in    vec3  toView,\n    in    vec3  fresnel0,  \n    inout vec3  sfresnel,   \n    in    float roughness)  \n{\n    vec3 halfVector = CalculateHalfVector(toLight, toView);\n    \n    float ndf      = CalculateNDF(surfNorm, halfVector, roughness);\n    float geoAtten = CalculateAttenuationAnalytical(surfNorm, toLight, toView, roughness);\n    \n    sfresnel = CalculateFresnel(surfNorm, toView, fresnel0);\n    \n    vec3  numerator   = (sfresnel * ndf * geoAtten);\n    float denominator = 4.0 * dot(surfNorm, toLight) * dot(surfNorm, toView);\n    \n    return (numerator / denominator);\n}\n\nvec2 Hammersley(float i, float numSamples)\n{   \n    uint b = uint(i);\n    \n    b = (b << 16u) | (b >> 16u);\n    b = ((b & 0x55555555u) << 1u) | ((b & 0xAAAAAAAAu) >> 1u);\n    b = ((b & 0x33333333u) << 2u) | ((b & 0xCCCCCCCCu) >> 2u);\n    b = ((b & 0x0F0F0F0Fu) << 4u) | ((b & 0xF0F0F0F0u) >> 4u);\n    b = ((b & 0x00FF00FFu) << 8u) | ((b & 0xFF00FF00u) >> 8u);\n    \n    float radicalInverseVDC = float(b) * 2.3283064365386963e-10;\n    \n    return vec2((i / numSamples), radicalInverseVDC);\n} \n\nvec3 ImportanceSample(\n    in vec2  xi,\n    in float roughness,\n    in vec3  surfNorm)\n{\n\tfloat a = (roughness * roughness);\n    \n    float phi = 2.0 * PI * xi.x;\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));\n    float sinTheta = sqrt(1.0 - (cosTheta * cosTheta));\n    \n    vec3 H = vec3((sinTheta * cos(phi)), (sinTheta * sin(phi)), cosTheta);\n    \n    vec3 upVector = (0.999 > surfNorm.z) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    vec3 tangentX = normalize(cross(upVector, surfNorm));\n    vec3 tangentY = cross(surfNorm, tangentX);\n    \n    return ((tangentX * H.x) + (tangentY * H.y) + (surfNorm * H.z));\n}\n\nvec3 CalculateSpecularIBL(\n    in    vec3  surfNorm,\n    in    vec3  surfPos,\n    in    vec3  toView,\n    in    vec3  fresnel0,\n    inout vec3  sfresnel,\n    inout float ao,\n    in    float roughness)\n{\n    // In the original version, this simply samples from the environment map (iChannel3).\n    // Single-bounce reflection and ambient occlusion were added for this shader.\n    \n    vec3 color = vec3(0.0);\n    vec3 totalSpec = vec3(0.0);\n    \n    ao = 0.0;\n    float aoScale = 0.8;\n    \n    for(float i = 0.0; i < IBLSteps; ++i)\n    {\n    \tvec2 xi = Hammersley(i, IBLSteps);\n        vec3 H  = ImportanceSample(xi, roughness, surfNorm);\n        vec3 L  = normalize((2.0 * dot(toView, H) * H) - toView);\n        \n        float NoV = max(0.0, dot(surfNorm, toView));\n        float NoL = max(0.0, dot(surfNorm, L));\n        float NoH = max(0.0, dot(surfNorm, H));\n        float VoH = max(0.0, dot(toView, H));\n        \n        if(NoL > 0.0)\n        {\n            // Perform single bounce and accumulate for AO\n            \n            Ray ray;\n            ray.d = L;\n            ray.o = surfPos + (ray.d * 0.05);\n            \n#ifdef HIGH_QUALITY\n            vec2 march = March(ray, 100);\n#else\n            vec2 march = March(ray, 50);\n#endif\n            \n            color = SampleEnvironment(L);\n            \n            if(march.x < FarClip)\n            {\n                vec3 pos = ray.o + (ray.d * march.x);\n                vec3 norm = SceneNormal(pos, march.x);\n                \n                Material mat = CreateMaterial(pos, norm, int(march.y));\n                float dirIntens = max(0.0, dot(norm, SunLightDir));\n                \n                if(dirIntens > 0.0) { dirIntens *= Shadow(pos); }\n                \n                // Calculate a very simple direct lighting for the bounce.\n                color = mat.albedo * max(0.2, dirIntens);\n                \n                ao      += (1.0 - 10.0 * clamp(march.x * 0.25, 0.0, 1.0)) * aoScale;\n                aoScale *= 0.4;\n            }\n            \n            // Calculate lighting\n            \n            float geoAtten = CalculateAttenuationIBL(roughness, NoL, NoV);\n            vec3  fresnel = CalculateFresnel(surfNorm, toView, fresnel0);\n            \n            sfresnel  += fresnel;\n            totalSpec += (color * fresnel * geoAtten * VoH) / (NoH * NoV);\n        }\n    }\n    \n    ao         = clamp(1.0 - (ao / IBLSteps), 0.0, 1.0);\n    sfresnel  /= IBLSteps;\n    totalSpec /= IBLSteps;\n    \n    return totalSpec;\n}\n\nvec3 CalculateLightingAnalytical(    // Direct lighting\n    in vec3 toLight,\n    in vec3 toView,\n    in Material mat)\n{\n    vec3 fresnel0 = mix(vec3(0.04), mat.albedo, mat.metallic);\n    vec3 ks       = vec3(0.0);\n    vec3 diffuse  = CalculateDiffuse(mat.albedo);\n    vec3 specular = CalculateSpecularAnalytical(mat.bump, toLight, toView, fresnel0, ks, mat.roughness);\n    vec3 kd       = (1.0 - ks);\n    \n    float angle = max(0.0, dot(mat.bump, toLight));\n    \n    return ((kd * diffuse) + specular) * angle;\n}\n\nvec3 CalculateLightingIBL(          // Ambient lighting\n    in vec3 surfNorm,\n    in vec3 surfPos,\n    in vec3 toView,\n    in Material mat)\n{\n    float ao = 0.0;\n    \n    vec3 fresnel0 = mix(vec3(0.04), mat.albedo, mat.metallic);\n    vec3 ks       = vec3(0.0);\n    vec3 diffuse  = CalculateDiffuse(mat.albedo);\n    vec3 specular = CalculateSpecularIBL(surfNorm, surfPos, toView, fresnel0, ks, ao, mat.roughness);\n    vec3 kd       = (1.0 - ks);\n    \n    return ((kd * diffuse) + specular) * ao;\n}\n\n//------------------------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------------------------\n\nvec3 Light(in Ray ray, in Material mat, in vec3 norm, in vec3 pos)\n{\n    vec3 direct = vec3(0.0);\n    float sunIntens = max(0.0, dot(norm, SunLightDir));\n    \n    if(sunIntens > 0.0)\n    {\n        direct = CalculateLightingAnalytical(SunLightDir, -ray.d, mat);\n    \tdirect *= Shadow(pos);\n    }\n    \n#ifdef HIGH_QUALITY\n    vec3 ambient = CalculateLightingIBL(mat.bump, pos, -ray.d, mat);\n#else\n    vec3 ambient = CalculateLightingIBL(norm, pos, -ray.d, mat);\n#endif\n    \n    return (direct * 2.0 + ambient);\n}\n\nvec4 Render(in Ray ray)\n{\n    vec3 color = SampleEnvironment(ray.d);\n    \n    vec2 march = March(ray, 150);\n    vec3 pos   = ray.o + (ray.d * march.x);\n    int  id    = int(march.y);\n    \n    if(march.x < FarClip)\n    {\n        vec3 norm = SceneNormal(pos, march.x);\n        Material mat = CreateMaterial(pos, norm, id);\n        \n        GetBumpNormal(pos, mat, id);\n        \n        color = clamp(Light(ray, mat, norm, pos), vec3(0.0), vec3(1.0));\n    }\n    \n    float d = clamp((march.x / FarClip), 0.0001, 1.0);\n    \n    // id is integer part of .w, depth is fractional part.\n    return vec4(color, march.y + d);\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv  = fragCoord.xy / iResolution.xy;\n    vec3 pos = OrbitAround(CamOrigin, 3.0, 0.2);\n    \n    fragColor = Render(Ray_LookAt(uv, pos, CamLookAt));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * - Anti-Aliasing\n * -----------------------------------------------------------\n * \n * Implements the 'Random 8x8 Dynamic' supersampling from:\n *\n *     'Anti-Aliasing Compare' - JasonD\n *     'https://www.shadertoy.com/view/4dGXW1'\n *\n * The results are acceptable, and I couldn't find anything \n * that worked better with this particular scene.\n *\n * Originally used temporal anti-aliasing (TAA), but it caused the  \n * outer edges to blur too much while doing little for the inner edges.\n *\n * The 8x8 supersampling tends to blur the scene too much overall\n * and so I only apply it to the geometry edges. Edges are calculated\n * by performing a surface ID difference which is demonstrated at:\n *\n *     'SDF Outline Comparison' - ssell\n *     https://www.shadertoy.com/view/4lfyR2\n *\n * The primary downside to this approach is that anti-aliasing in\n * reflections is not really ever addressed.\n */\n\nconst int SampleSteps = 4;      // Increase to 8 for better quality\n\n//------------------------------------------------------------------------------------------\n// AA \n//------------------------------------------------------------------------------------------\n\nvec2 noise2(vec2 location, vec2 delta) \n{\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location +      delta            , c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        );\n}\n\n\nvec4 SampleAA(sampler2D sampler, in vec2 uv)\n{\n    vec4 source = texture(sampler, uv);\n    \n    // IDs are the integer part of the .w (depth is stored in fractional)\n    float sourceID   = floor(source.w);     \n    float sourceDiff = 0.0;\n    \n    vec3 color = vec3(0.0);\n    vec2 s = vec2(1.0 / iResolution.x, 1.0 / iResolution.y) * 2.25;\n    \n    float t = iTime + 0.1;\n    \n    for (int i = 0; i < SampleSteps; i++)\n    {\n        for (int j = 0; j < SampleSteps; j++) \n        {\n            vec2 q = t * vec2(float(i), float(j));\n            vec2 n = noise2(uv , q);\n            vec2 offset = vec2(n.x, n.y) - vec2(0.5, 0.5);\n            \n            vec4 tx = texture(sampler, uv + offset * s);\n            color += tx.rgb;\n            \n            sourceDiff += abs(sourceID - tx.w);\n        }\n    }\n    \n    color      /= float(SampleSteps * SampleSteps); \n    sourceDiff /= float(SampleSteps * SampleSteps);\n    sourceDiff  = pow(sourceDiff, 8.0);\n    \n    return vec4(mix(source.rgb, color, clamp(sourceDiff, 0.2, 1.0)), source.w);\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = SampleAA(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * - Depth of Field\n * -----------------------------------------------------------\n * \n * Applies a very simple DoF effect to the image.\n *\n * Essentially just blurs distant geometry and is most visible\n * on the far corners of the wooden platform.\n */\n\n//------------------------------------------------------------------------------------------\n// DoF\n//------------------------------------------------------------------------------------------\n\nvec3 ApplyDoF(sampler2D sampler, in vec2 uv)\n{\n    // Retrieve depth from buffer.\n    // Depth is stored in the fractional part of the w component [0.0001, 1.0].\n    float depth = fract(texture(sampler, uv).w);\n    depth = (depth < 0.0001 ? 1.0 : depth);\n    depth = abs(0.175 - depth) * 4.0;             // Exaggerate distant geometry depths\n    \n    vec3 color = vec3(0.0);\n    \n    float angle  = 0.0;\n    float radius = 0.0;\n    \n    for(int i = 0; i < 10; ++i)\n    {\n        vec2 suv = uv + (vec2(sin(angle), cos(angle)) * radius);\n        color += texture(sampler, suv).rgb;\n        \n        angle  += 0.3;\n        radius += 0.0001 * depth;\n    }\n    \n    color *= 0.1;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor.rgb = ApplyDoF(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}